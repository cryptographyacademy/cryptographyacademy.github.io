---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/332';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Sequences of games: a tool for taming complexity in security proofs';
const AUTHORS_HTML = 'Victor Shoup';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">This paper is a brief tutorial on a technique for structuring security proofs as sequences of games.</p>
    </section>

    <p class="text-gray-300">Security proofs in cryptography may sometimes be organized as sequences of games. In certain circumstances, this can be a useful tool in taming the complexity of security proofs that might otherwise become so messy, complicated, and subtle as to be nearly impossible to verify. This technique appears in the literature in various styles, and with various degrees of rigor and formality. This paper is meant to serve as a brief tutorial on one particular &quot;style&quot; of employing this technique, which seems to achieve a reasonable level of mathematical rigor and clarity, while not getting bogged down with too much formalism or overly restrictive rules. We do not make any particular claims of originality &mdash; it is simply hoped that others might profit from some of the ideas discussed here in reasoning about security.</p>

    <p class="text-gray-300">At the outset, it should be noted that this technique is certainly not applicable to all security proofs. Moreover, even when this technique is applicable, it is only a tool for organizing a proof &mdash; the actual ideas for a cryptographic construction and security analysis must come from elsewhere.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 The Basic Idea</h3>

    <p class="text-gray-300">Security for cryptograptic primitives is typically defined as an attack game played between an adversary and some benign entity, which we call the challenger. Both adversary and challenger are probabilstic processes that communicate with each other, and so we can model the game as a probability space. Typically, the definition of security is tied to some particular event S. Security means that for every &quot;efficient&quot; adversary, the probability that event S occurs is &quot;very close to&quot; some specified &quot;target probabilty&quot;: typically, either 0, 1/2, or the probability of some event T in some other game in which the same adversary is interacting with a different challenger.</p>

    <p class="text-gray-300"><sup>&lowast;</sup>First public version: Nov. 30, 2004</p>

    <p class="text-gray-300"><sup>&dagger;</sup>Computer Science Dept. NYU. shoup@cs.nyu.edu</p>

    <p class="text-gray-300">In the formal definitions, there is a security parameter: an integer tending to infinity, and in the previous paragraph, &quot;efficient&quot; means time bounded by a polynomial in the security parameter, and &quot;very close to&quot; means the difference is smaller than the inverse of any polynomial in the security parameter, for sufficiently large values of the security parameter. The term of art is negligibly close to, and a quantity that is negliglibly close to zero is just called negligible. For simplicity, we shall for the most part avoid any further discussion of the security parameter, and it shall be assumed that all algorithms, adversaries, etc., take this value as an implicit input.</p>

    <p class="text-gray-300">Now, to prove security using the sequence-of-games approach, one prodceeds as follows. One constructs a sequence of games, Game 0, Game 1, . . . , Game n, where Game 0 is the original attack game with respect to a given adversary and cryptographic primitive. Let S<sup>0</sup> be the event S, and for i = 1, . . . , n, the construction defines an event S<sup>i</sup> in Game i, usually in a way naturally related to the definition of S. The proof shows that Pr[S<sup>i</sup> ] is negligibly close to Pr[Si+1] for i = 0, . . . , n &minus; 1, and that Pr[Sn] is equal (or negligibly close) to the &quot;target probability.&quot; From this, and the fact that n is a constant, it follows that Pr[S] is negligibly close to the &quot;target probability,&quot; and security is proved.</p>

    <p class="text-gray-300">That is the general framework of such a proof. However, in constructing such proofs, it is desirable that the changes between succesive games are very small, so that analyzing the change is as simple as possible. From experience, it seems that transitions between successive games can be restricted to one of three types:</p>

    <p class="text-gray-300">Transitions based on indistinguishability. In such a transition, a small change is made that, if detected by the adversary, would imply an efficient method of distinguishing between two distributions that are indistinguishable (either statistically or computationally). For example, suppose P<sup>1</sup> and P<sup>2</sup> are assumed to be computationally indistinguishable distributions. To prove that |Pr[S<sup>i</sup> ] &minus; Pr[Si+1]| is negligible, one argues that there exists a distinguishing algorithm D that &quot;interpolates&quot; between Game i and Game i+1, so that when given an element drawn from distribution P<sup>1</sup> as input, D outputs 1 with probability Pr[S<sup>i</sup> ], and when given an element drawn from distribution P<sup>2</sup> as input, D outputs 1 with probabilty Pr[Si+1]. The indistinguishability assumption then implies that |Pr[S<sup>i</sup> ] &minus; Pr[Si+1]| is negligible. Usually, the construction of D is obvious, provided the changes made in the transition are minimal. Typically, one designs the two games so that they could easily be rewritten as a single &quot;hybrid&quot; game that takes an auxilliary input &mdash; if the auxiallary input is drawn from P1, you get Game i, and if drawn from P2, you get Game i + 1. The distinguisher then simply runs this single hybrid game with its input, and outputs 1 if the appropriate event occurs.</p>

    <p class="text-gray-300">Transitions based on failure events. In such a transition, one argues that Games i and i + 1 proceed identically unless a certain &quot;failure event&quot; F occurs. To make this type of argument as cleanly as possible, it is best if the two games are defined on the same underlying probability space &mdash; the only differences between the two games are the rules for computing certain random variables. When done this way, saying that the two games proceed identically unless F occurs is equivalent to saying that</p>

    <p class="text-gray-300"><span class="math">$S_i \\wedge \\neg F \\iff S_{i+1} \\wedge \\neg F,</span>$</p>

    <p class="text-gray-300">that is, the events S<sup>i</sup> &and; &not;F and Si+1 &and; &not;F are the same. If this is true, then we can use the</p>

    <p class="text-gray-300">following fact, which is completely trivial, yet is so often used in these types of proofs that it deserves a name:</p>

    <p class="text-gray-300">Lemma 1 (Difference Lemma). Let A, B, F be events defined in some probability distribution, and suppose that A &and; &not;F &lArr;&rArr; B &and; &not;F. Then |Pr[A] &minus; Pr[B]| &le; Pr[F].</p>

    <p class="text-gray-300">Proof. This is a simple calculation. We have</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} |\\Pr[A] - \\Pr[B]| &amp;= |\\Pr[A \\wedge F] + \\Pr[A \\wedge \\neg F] - \\Pr[B \\wedge F] - \\Pr[B \\wedge \\neg F]| \\\\ &amp;= |\\Pr[A \\wedge F] - \\Pr[B \\wedge F]| \\\\ &amp;\\leq \\Pr[F]. \\end{aligned}</span>$</p>

    <p class="text-gray-300">The second equality follows from the assumption that A &and; &not;F &lArr;&rArr; B &and; &not;F, and so in particular, Pr[A &and; &not;F] = Pr[B &and; &not;F]. The final inequality follows from the fact that both Pr[A &and; F] and Pr[B &and; F] are numbers between 0 and Pr[F]. &#10039;</p>

    <p class="text-gray-300">So to prove that Pr[S<sup>i</sup> ] is negligibly close to Pr[Si+1], it suffices to prove that Pr[F] is negligible. Sometimes, this is done using a security assumption (i.e., when F occurs, the adversary has found a collision in a hash function, or forged a MAC), while at other times, it can be done using a purely information-theoretic argument.</p>

    <p class="text-gray-300">Usually, the event F is defined and analyzed in terms of the random variables of one of the two adjacent games. The choice is arbitrary, but typically, one of the games will be more suitable than the other in terms of allowing a clear proof.</p>

    <p class="text-gray-300">In some particularly challenging circumstances, it may be difficult to analyze the event F in either game. In fact, the analysis of F may require its own sequence of games sprouting off in a different direction, or the sequence of games for F may coincide with the sequence of games for S, so that Pr[F] finally gets pinned down in Game j for j &gt; i+ 1. This technique is sometimes crucial in side-stepping potential circularities.</p>

    <p class="text-gray-300">Bridging steps. The third type of transition introduces a bridging step, which is typically a way of restating how certain quantities can be computed in a completely equivalent way. The change is purely conceptual, and Pr[S<sup>i</sup> ] = Pr[Si+1]. The reason for doing this is to prepare the ground for a transition of one of the above two types. While in principle, such a bridging step may seem unnecessary, without it, the proof would be much harder to follow.</p>

    <p class="text-gray-300">As mentioned above, in a transition based on a failure event, it is best if the two successive games are understood to be defined on the same underlying probability space. This is an important point, which we repeat here for emphasis &mdash; it seems that proofs are easiest to understand if one does not need to compare &quot;corresponding&quot; events across distinct and (by design) quite different probability spaces. Actually, it is good practice to simply have all the games in the sequence defined on the same underlying probability space. However, the Difference Lemma generalizes in the obvious way as follows: if A, B, F<sup>1</sup> and F<sup>2</sup> are events such that Pr[A &and; &not;F1] = Pr[B &and; &not;F2] and Pr[F1] = Pr[F2], then |Pr[A] &minus; Pr[B]| &le; Pr[F1]. With this generalized version, one may (if one wishes) analyze transitions based on failure events when the underlying probability spaces are not the same.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Some Historical Remarks</h3>

    <p class="text-gray-300">&quot;Hybrid arguments&quot; have been used extensively in cryptography for many years. Such an argument is essentially a sequence of transitions based on indistinguishability. An early example that clearly illustrates this technique is Goldreich, Goldwasser, and Micali's paper [GGM86] on constructing pseudo-random functions (although this is by no means the earliest application of a hybrid argument). Note that in some applications, such as [GGM86], one in fact makes a non-constant number of transitions, which requires an additional, probabilistic argument.</p>

    <p class="text-gray-300">Although some might use the term &quot;hybrid argument&quot; to include proofs that use transitions based on both indistinguishability and failure events, that seems to be somewhat of a stretch of terminology. An early example of a proof that is clearly structured as a sequence of games that involves transitions based on both indistinguishability and failure events is Bellare and Goldwasser's paper [BG89].</p>

    <p class="text-gray-300">Kilian and Rogaway's paper [KR96] on DESX initiates a somewhat more formal approach to sequences of games. That paper essentially uses the Difference Lemma, specialized to their particular setting. Subsequently, Rogaway has refined and applied this technique in numerous works with several co-authors. We refer the reader to the paper [BR04] by Bellare and Rogaway that gives a detailed introduction to the methodology, as well as references to papers where it has been used. However, we comment briefly on some of the differences between the technique discussed in this paper, and that advocated in [BR04]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In Bellare and Rogaway's approach, games are programs and are treated as purely syntactic objects subject to formal manipulation. In contrast, we view games as probability spaces and random variables defined over them, and do not insist on any particular syntactic formalism beyond that convenient to make a rigorous mathematical argument.</li>
      <li>In Bellare and Rogaway's approach, transitions based on failure events are restricted to events in which an executing program explicitly sets a particular boolean variable to true. In contrast, we do not suggest that events need to be explicitly &quot;announced.&quot;</li>
      <li>In Bellare and Rogaway's approach, when the execution behaviors of two games are compared, two distinct probability spaces are involved, and probabilities of &quot;corresponding&quot; events across probability spaces must be compared. In contrast, we suggest that games should be defined on a common probability space, so that when discussing, say, a particular failure event F, there is literally just one event, not a pair of corresponding events in two different probability spaces.</li>
    </ul>

    <p class="text-gray-300">In the end, we think that the choice between the style advocated in [BR04] and that suggested here is mainly a matter of taste and convenience.</p>

    <p class="text-gray-300">The author has used proofs organized as sequences of games extensively in his own work [Sho00, SS00, Sho01, Sho02, CS02, CS03b, CS03a, GS04] and has found them to be an indispensable tool &mdash; while some of the proofs in these papers could be structured differently, it is hard to imagine how most of them could be done in a more clear and convincing way without sequences of games (note that all but the first two papers above adhere to the rule suggested here of defining games to operate on the same probability space). Other authors</p>

    <p class="text-gray-300">have also been using very similar proof styles recently [AFP04, BK04, BCP02a, BCP02b, BCP03, CPP04, DF03, DFKY03, DFJW04, Den03, FOPS04, GaPMV03, KD04, PP03, SWP04]. Also, Pointcheval [Poi04] has a very nice introductory manuscript on public-key cryptography that illustrates this proof style on a number of particular examples.</p>

    <p class="text-gray-300">The author has also been using the sequence-of-games technique extensively in teaching courses in cryptography. Many &quot;classical&quot; results in cryptography can be fruitfully analyzed using this technique. Generally speaking, it seems that the students enjoy this approach, and easily learn to use and apply it themselves. Also, by using a consistent framework for analysis, as an instructor, one can more easily focus on the ideas that are unique to any specific application.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Outline of the Rest of the Paper</h3>

    <p class="text-gray-300">After recalling some fairly standard notation in the next section, the following sections illustrate the use of the sequence-of-games technique in the analysis of a number of classical cryptographic constructions. Compared to many of the more technically involved examples in the literature of this technique (mentioned above), the applications below are really just &quot;toy&quot; examples. Nevertheless, they serve to illustrate the technique in a concrete way, and moreover, we believe that the proofs of these results are at least as easy to follow as any other proof, if not more so. All of the examples, except the last two (in &sect;&sect;7-8), are presented at an extreme level of detail; indeed, for these examples, we give complete, detailed descriptions of each and every game. More typically, to produce a more compact proof, one might simply describe the differences between games, rather than describing each game in its entirety (as is done in &sect;&sect;7-8). These examples are based mainly on lectures in courses on cryptography taught by the author.</p>

    <p class="text-gray-300">We make use of fairly standard notation in what follows. In describing probabilistic processes, we write</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\mbox{\\tiny </span>\\mathfrak{k}<span class="math">}}{\\leftarrow} X</span>$</p>

    <p class="text-gray-300">to denote the action of assigning to the variable x a value sampled according to the distribution X. If S is a finite set, we simply write s &larr;<sup>c</sup><sup>|</sup> S to denote assignment to s of an element sampled from the uniform distribution on S. If A is a probabilistic algorithm and x an input, then A(x) denotes the output distribution of A on input x. Thus, we write y &larr;<sup>c</sup><sup>|</sup> A(x) to denote the action of running algorithm A on input x and assigning the output to the variable y.</p>

    <p class="text-gray-300">We shall write</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x_1 \\stackrel{\\notin}{\\leftarrow} X_1, x_2 \\stackrel{\\notin}{\\leftarrow} X_2(x_1), \\dots, x_n \\stackrel{\\notin}{\\leftarrow} X_n(x_1, \\dots, x_{n-1}) : \\phi(x_1, \\dots, x_n)]</span>$</p>

    <p class="text-gray-300">to denote the probability that when x<sup>1</sup> is drawn from a certain distribution X1, and x<sup>2</sup> is drawn from a certain distribution X2(x1), possibly depending on the particular choice of x1, and so on, all the way to xn, the predicate &phi;(x1, . . . , xn) is true. We allow the predicate &phi; to involve the execution of probabilistic algorithms.</p>

    <p class="text-gray-300">If X is a probability distribution on a sample space X , then [X] denotes the subset of elements of X that occur with non-zero probability.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Basic Definitions</h3>

    <p class="text-gray-300">We first recall the basic definition of a public-key encryption scheme, and the notion of semantic security.</p>

    <p class="text-gray-300">A public-key encryption scheme is a triple of probabilistic algorithms (KeyGen, E, D). The key generation algorithm KeyGen takes no input (other than an implied security parameter, and perhaps other system parameters), and outputs a public-key/secret-key pair (pk, sk). The encryption algorithm E takes as input a public key pk and a message m, selected from a message space M, and outputs a ciphertext &psi;. The decryption algorithm takes as input a secret key sk and ciphertext &psi;, and outputs a message m.</p>

    <p class="text-gray-300">The basic correctness requirement is that decryption &quot;undoes&quot; encryption. That is, for all m &isin; M, all (pk, sk) &isin; [KeyGen()], all &psi; &isin; [E(pk, m)], and all m<sup>0</sup> &isin; [D(sk, &psi;)], we have m = m<sup>0</sup> . This definition can be relaxed in a number of ways; for example, we may only insist that it is computationally infeasible to find a message for which decryption does not &quot;undo&quot; its encryption.</p>

    <p class="text-gray-300">The notion of semantic security intuitively says that an adversary cannot effectively distinguish between the encryption of two messages of his choosing (this definition comes from [GM84], where is called polynomial indistinguishability, and semantic security is actually the name of a syntactically different, but equivalent, characterization). This is formally defined via a game between an adversary and a challenger.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The challenger computes (pk, sk) &larr;<sup>c</sup><sup>|</sup> KeyGen(), and gives pk to the adversary.</li>
      <li>The adversary chooses two messages m0, m<sup>1</sup> &isin; M, and gives these to the challenger.</li>
      <li>The challenger computes</li>
    </ul>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\protect}{\\leftarrow} \\{0,1\\}, \\ \\psi \\stackrel{\\protect}{\\leftarrow} E(pk,m_b)</span>$</p>

    <p class="text-gray-300">and gives the &quot;target ciphertext&quot; &psi; to the adversary.</p>

    <p class="text-gray-300">&bull; The adversary outputs &circ;b &isin; {0, 1}.</p>

    <p class="text-gray-300">We define the SS-advantage of the adversary to be |Pr[b = &circ;b] &minus; 1/2|. Semantic security means that any efficient adversary's SS-advantage is negligible.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 The ElGamal Encryption Scheme</h3>

    <p class="text-gray-300">We next recall ElGamal encryption. Let G be a group of prime order q, and let &gamma; &isin; G be a generator (we view the descriptions of G and &gamma;, including the value q, to be part of a set of implied system parameters).</p>

    <p class="text-gray-300">The key generation algorithm computes (pk, sk) as follows:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\protect}{\\leftarrow} \\mathbb{Z}_q, \\ \\alpha \\leftarrow \\gamma^x, \\ pk \\leftarrow \\alpha, \\ sk \\leftarrow x.</span>$</p>

    <p class="text-gray-300">The message space for the algorithm is G. To encrypt a message  <span class="math">m \\in G</span> , the encryption algorithm computes a ciphertext  <span class="math">\\psi</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$y \\stackrel{\\phi}{\\leftarrow} \\mathbb{Z}_q, \\ \\beta \\leftarrow \\gamma^y, \\ \\delta \\leftarrow \\alpha^y, \\ \\zeta \\leftarrow \\delta \\cdot m, \\ \\psi \\leftarrow (\\beta, \\zeta).</span>$</p>

    <p class="text-gray-300">The decryption algorithm takes as input a ciphertext  <span class="math">(\\beta, \\zeta)</span> , and computes m as follows:</p>

    <p class="text-gray-300"><span class="math">$m \\leftarrow \\zeta/\\beta^x</span>$
.</p>

    <p class="text-gray-300">It is clear that decryption &quot;undoes&quot; encryption. Indeed, if  <span class="math">\\beta = \\gamma^y</span>  and  <span class="math">\\zeta = \\alpha^y \\cdot m</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\zeta/\\beta^x = \\alpha^y m/\\beta^x = (\\gamma^x)^y m/(\\gamma^y)^x = \\gamma^{xy} m/\\gamma^{xy} = m.</span>$</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Security Analysis</h3>

    <p class="text-gray-300">ElGamal encryption is semantically secure under the Decisional Diffie-Hellman (DDH) assumption. This is the assumption that it is hard to distinguish triples of the form  <span class="math">(\\gamma^x, \\gamma^y, \\gamma^{xy})</span>  from triples of the form  <span class="math">(\\gamma^x, \\gamma^y, \\gamma^z)</span> , where x, y, and z are random elements of  <span class="math">\\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">The DDH assumption is more precisely formulated as follows. Let D be an algorithm that takes as input triples of group elements, and outputs a bit. We define the DDH-advantage of D to be</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[x, y \\xleftarrow{\\phi} \\mathbb{Z}_q : D(\\gamma^x, \\gamma^y, \\gamma^{xy}) = 1] - \\Pr[x, y, z \\xleftarrow{\\phi} \\mathbb{Z}_q : D(\\gamma^x, \\gamma^y, \\gamma^z) = 1]|.</span>$</p>

    <p class="text-gray-300">The DDH assumption (for G) is the assumption that any efficient algorithm's DDH-advantage is negligible.</p>

    <p class="text-gray-300">We now give a proof of the semantic security of ElGamal encryption under the DDH assumption, using a sequence of games.</p>

    <p class="text-gray-300"><strong>Game 0.</strong> Fix an efficient adversary A. Let us define Game 0 to be the attack game against A in the definition of semantic security. To make things more precise and more concrete, we may describe the attack game algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\ \\alpha \\leftarrow \\gamma^x</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R, \\ (m_0, m_1) \\leftarrow A(r, \\alpha)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}, \\ y \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\ \\beta \\leftarrow \\gamma^y, \\ \\delta \\leftarrow \\alpha^y, \\ \\zeta \\leftarrow \\delta \\cdot m_b</span>$</p>

    <p class="text-gray-300"><span class="math">$\\hat{b} \\leftarrow A(r, \\alpha, \\beta, \\zeta)</span>$</p>

    <p class="text-gray-300">In the above, we have modeled the adversary A is a deterministic algorithm that takes as input &quot;random coins&quot; r sampled uniformly from some set R. It should be evident that this algorithm faithfully represents the attack game. If we define  <span class="math">S_0</span>  to be the event that  <span class="math">b = \\hat{b}</span> , then the adversary's SS-advantage is  <span class="math">|\\Pr[S_0] - 1/2|</span> .</p>

    <p class="text-gray-300"><strong>Game 1.</strong> [This is a transition based on indistinguishability.] We now make one small change to the above game. Namely, instead of computing  <span class="math">\\delta</span>  as  <span class="math">\\alpha^y</span> , we compute it as  <span class="math">\\gamma^z</span>  for randomly chosen  <span class="math">z \\in \\mathbb{Z}_q</span> . We can describe the resulting game algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\ \\alpha \\leftarrow \\gamma^x</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R, \\ (m_0, m_1) \\leftarrow A(r, \\alpha)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}, \\ y \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\ \\beta \\leftarrow \\gamma^y, \\boxed{z \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\ \\delta \\leftarrow \\gamma^z,} \\zeta \\leftarrow \\delta \\cdot m_b</span>$</p>

    <p class="text-gray-300"><span class="math">$\\hat{b} \\leftarrow A(r, \\alpha, \\beta, \\zeta)</span>$</p>

    <p class="text-gray-300">Let  <span class="math">S_1</span>  be the event that  <span class="math">b = \\hat{b}</span>  in Game 1.</p>

    <p class="text-gray-300">Claim 1.  <span class="math">\\Pr[S_1] = 1/2</span> . This follows from the fact that in Game 2,  <span class="math">\\delta</span>  is effectively a one-time pad, and as such, the adversary's output  <span class="math">\\hat{b}</span>  is independent of the hidden bit b. To prove this more rigorously, it will suffice to show that  <span class="math">b, r, \\alpha, \\beta, \\zeta</span>  are mutually independent, since from this, it follows that b and  <span class="math">\\hat{b} = A(r, \\alpha, \\beta, \\zeta)</span>  are independent. First observe that by construction,  <span class="math">b, r, \\alpha, \\beta, \\delta</span>  are mutually independent. It will suffice to show that conditioned on any fixed values of  <span class="math">b, r, \\alpha, \\beta</span> , the conditional distribution of  <span class="math">\\zeta</span>  is the uniform distribution over G. Now, if  <span class="math">b, r, \\alpha, \\beta</span>  are fixed, then so are  <span class="math">m_0, m_1</span> , since they are determined by  <span class="math">r, \\alpha</span> ; moreover, by independence, the conditional distribution of  <span class="math">\\delta</span>  is the uniform distribution on G, and hence from this, one sees that the conditional distribution of  <span class="math">\\zeta = \\delta \\cdot m_b</span>  is the uniform distribution on G.</p>

    <p class="text-gray-300">Claim 2.  <span class="math">|\\Pr[S_0] - \\Pr[S_1]| = \\epsilon_{ddh}</span> , where  <span class="math">\\epsilon_{ddh}</span>  is the DDH-advantage of some efficient algorithm (and hence negligible under the DDH assumption).</p>

    <p class="text-gray-300">The proof of this is essentially the observation that in Game 0, the triple  <span class="math">(\\alpha, \\beta, \\delta)</span>  is of the form  <span class="math">(\\gamma^x, \\gamma^y, \\gamma^{xy})</span> , while in Game 1, it is of the form  <span class="math">(\\gamma^x, \\gamma^y, \\gamma^z)</span> , and so the adversary should not notice the difference, under the DDH assumption. To be more precise, our distinguishing algorithm D works as follows:</p>

    <pre><code class="language-text">Algorithm D(\\alpha, \\beta, \\delta)

r \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} R, \\ (m_0, m_1) \\leftarrow A(r, \\alpha)

b \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} \\{0, 1\\}, \\ \\zeta \\leftarrow \\delta \\cdot m_b

\\hat{b} \\leftarrow A(r, \\alpha, \\beta, \\zeta)
\\nif b = \\hat{b}

then output 1
\\nelse output 0
</code></pre>

    <p class="text-gray-300">Algorithm D effectively &quot;interpolates&quot; between Games 0 and 1. If the input to D is of the form  <span class="math">(\\gamma^x, \\gamma^y, \\gamma^{xy})</span> , then computation proceeds just as in Game 0, and therefore</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x, y \\stackrel{\\epsilon}{\\leftarrow} \\mathbb{Z}_q : D(\\gamma^x, \\gamma^y, \\gamma^{xy}) = 1] = \\Pr[S_0].</span>$</p>

    <p class="text-gray-300">If the input to D is of the form  <span class="math">(\\gamma^x, \\gamma^y, \\gamma^z)</span> , then computation proceeds just as in Game 1, and therefore</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x, y, z \\stackrel{\\epsilon}{\\leftarrow} \\mathbb{Z}_q : D(\\gamma^x, \\gamma^y, \\gamma^z) = 1] = \\Pr[S_1].</span>$</p>

    <p class="text-gray-300">From this, it follows that the DDH-advantage of D is equal to |Pr[S0] &minus; Pr[S1]|. That completes the proof of Claim 2.</p>

    <p class="text-gray-300">Combining Claim 1 and Claim 2, we see that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - 1/2| = \\epsilon_{\\mathrm{ddh}},</span>$</p>

    <p class="text-gray-300">and this is negligible. That completes the proof of security of ElGamal encryption.</p>

    <p class="text-gray-300">For a number of reasons, it is convenient to work with messages that are bit strings, say, of length \`, rather than group elements. Because of this, one may choose to use a &quot;hashed&quot; version of the ElGamal encryption scheme.</p>

    <p class="text-gray-300">This scheme makes use of a family of keyed &quot;hash&quot; functions H := {Hk}k&isin;K, where each H<sup>k</sup> is a function mapping G to {0, 1} \` .</p>

    <p class="text-gray-300">The key generation algorithm computes (pk, sk) as follows:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\phi}{\\leftarrow} \\mathbb{Z}_q, \\ k \\stackrel{\\phi}{\\leftarrow} K, \\ \\alpha \\leftarrow \\gamma^x, \\ pk \\leftarrow (\\alpha, k), \\ sk \\leftarrow (x, k).</span>$</p>

    <p class="text-gray-300">To encrypt a message m &isin; {0, 1} \` , the encryption algorithm computes a ciphertext &psi; as follows:</p>

    <p class="text-gray-300"><span class="math">$y \\stackrel{\\ \\leftarrow}{\\leftarrow} \\mathbb{Z}_q, \\ \\beta \\leftarrow \\gamma^y, \\ \\delta \\leftarrow \\alpha^y, \\ h \\leftarrow H_k(\\delta), \\ v \\leftarrow h \\oplus m, \\ \\psi \\leftarrow (\\beta, v).</span>$</p>

    <p class="text-gray-300">The decryption algorithm takes as input a ciphertext (&beta;, v), and computes m as follows:</p>

    <p class="text-gray-300"><span class="math">$m \\leftarrow H_k(\\beta^x) \\oplus v.</span>$</p>

    <p class="text-gray-300">The reader may easily verify that decryption &quot;undoes&quot; encryption.</p>

    <p class="text-gray-300">As for semantic security, this can be proven under the DDH assumption and the assumption that the family of hash functions H is &quot;entropy smoothing.&quot; Loosely speaking, this means that it is hard to distinguish (k, Hk(&delta;)) from (k, h), where k is a random element of K, &delta; is a random element of G, and h is a random element of {0, 1} <code>. More formally, let D be an algorithm that takes as input an element of K and an element of {0, 1}</code> , and outputs a bit. We define the ES-advantage of D to be</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[k \\xleftarrow{\\phi} K, \\ \\delta \\xleftarrow{\\phi} G : D(k, H_k(\\delta)) = 1] - \\Pr[k \\xleftarrow{\\phi} K, \\ h \\xleftarrow{\\phi} \\{0, 1\\}^{\\ell} : D(k, h) = 1]|.</span>$</p>

    <p class="text-gray-300">We say H is entropy smoothing if every efficient algorithm's ES-advantage is negligible.</p>

    <p class="text-gray-300">It is in fact possible to construct entropy smoothing hash function families without additional hypothesis (the Leftover Hash Lemma may be used for this [IZ89]). However, these may be somewhat less practical than ad hoc hash function families for which the entropy smoothing property is only a (perfectly reasonable) conjecture; moreover, our definition also allows entropy smoothers that use pseudo-random bit generation techniques as well.</p>

    <p class="text-gray-300">We now sketch the proof of semantic security of hashed ElGamal encryption, under the DDH assumption and the assumption that H is entropy smoothing.</p>

    <p class="text-gray-300">Game 0. This is the original attack game, which we can state algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, k \\stackrel{\\notin}{\\leftarrow} K, \\alpha \\leftarrow \\gamma^x</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}, y \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\beta \\leftarrow \\gamma^y, \\delta \\leftarrow \\alpha^y, h \\leftarrow H_k(\\delta), v \\leftarrow h \\oplus m_b</span>$</p>

    <p class="text-gray-300"><span class="math">$\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span>$</p>

    <p class="text-gray-300">We define  <span class="math">S_0</span>  to be the event that  <span class="math">b = \\hat{b}</span>  in Game 0.</p>

    <p class="text-gray-300"><strong>Game 1.</strong> [This is a transition based on indistinguishability.] Now we transform Game 0 into Game 1, computing  <span class="math">\\delta</span>  as  <span class="math">\\gamma^z</span>  for random  <span class="math">z \\in \\mathbb{Z}_q</span> . We can state Game 1 algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, k \\stackrel{\\notin}{\\leftarrow} K, \\alpha \\leftarrow \\gamma^x</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}, y \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\beta \\leftarrow \\gamma^y, z \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\delta \\leftarrow \\gamma^z, h \\leftarrow H_k(\\delta), v \\leftarrow h \\oplus m_b</span>$</p>

    <p class="text-gray-300"><span class="math">$\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span>$</p>

    <p class="text-gray-300">Let  <span class="math">S_1</span>  be the event that  <span class="math">b = \\hat{b}</span>  in Game 1. We claim that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - \\Pr[S_1]| = \\epsilon_{\\text{ddh}},\\tag{1}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon_{\\rm ddh}</span>  is the DDH-advantage of some efficient algorithm (which is negligible under the DDH assumption).</p>

    <p class="text-gray-300">The proof of this is almost identical to the proof of the corresponding claim for &quot;plain&quot; ElGamal. Indeed, the following algorithm D &quot;interpolates&quot; between Game 0 and Game 1, and so has DDH-advantage equal to  <span class="math">|\\Pr[S_0] - \\Pr[S_1]|</span> :</p>

    <p class="text-gray-300">Algorithm
<span class="math">$D(\\alpha, \\beta, \\delta)</span>$</p>

    <p class="text-gray-300"><span class="math">k \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} K</span>
<span class="math">r \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span>
<span class="math">b \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} \\{0, 1\\}, h \\leftarrow H_k(\\delta), v \\leftarrow h \\oplus m_b</span>
<span class="math">\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span>
\\nif  <span class="math">b = \\hat{b}</span>
then output 1
\\nelse output 0</p>

    <p class="text-gray-300"><strong>Game 2.</strong> [This is also a transition based on indistinguishability.] We now transform Game 1 into Game 2, computing h by simply choosing it at random, rather than as a hash. Algorithmically, Game 2 looks like this:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, k \\stackrel{\\notin}{\\leftarrow} K, \\alpha \\leftarrow \\gamma^x</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}, y \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\beta \\leftarrow \\gamma^y, z \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\delta \\leftarrow \\gamma^z, h \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}^\\ell, v \\leftarrow h \\oplus m_b</span>$</p>

    <p class="text-gray-300"><span class="math">$\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span>$</p>

    <p class="text-gray-300">Observe that  <span class="math">\\delta</span>  plays no role in Game 2.</p>

    <p class="text-gray-300">Let  <span class="math">S_2</span>  be the event that  <span class="math">b = \\hat{b}</span>  in Game 2. We claim that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_1] - \\Pr[S_2]| = \\epsilon_{\\text{es}},\\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon_{es}</span>  the ES-advantage of some efficient algorithm (which is negligible assuming  <span class="math">\\mathcal{H}</span>  is entropy smoothing).</p>

    <p class="text-gray-300">This is proved using the same idea as before: any difference between  <span class="math">\\Pr[S_1]</span>  and  <span class="math">\\Pr[S_2]</span>  can be parlayed into a corresponding ES-advantage. Indeed, it is easy to see that the following algorithm D' &quot;interpolates&quot; between Game 1 and Game 2, and so has ES-advantage equal to  <span class="math">|\\Pr[S_1] - \\Pr[S_2]|</span> :</p>

    <p class="text-gray-300">Algorithm D'(k,h)  <span class="math">x \\stackrel{\\rlap{</span>\\leftarrow}}{\\leftarrow} \\mathbb{Z}_q, \\ \\alpha \\leftarrow \\gamma^x$   <span class="math">r \\stackrel{\\rlap{</span>\\leftarrow}}{\\leftarrow} R, \\ (m_0,m_1) \\leftarrow A(r,\\alpha,k)$   <span class="math">b \\stackrel{\\rlap{</span>\\leftarrow}}{\\leftarrow} {0,1}, \\ y \\stackrel{\\rlap{<span class="math">\\leftarrow}}{\\leftarrow} \\mathbb{Z}_q, \\ \\beta \\leftarrow \\gamma^y, \\ v \\leftarrow h \\oplus m_b</span>   <span class="math">\\hat{b} \\leftarrow A(r,\\alpha,k,\\beta,v)</span> \\nif  <span class="math">b = \\hat{b}</span> then output 1\\nelse output 0</p>

    <p class="text-gray-300">Finally, as h acts like a one-time pad in Game 2, it is evident that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_2] = 1/2. \\tag{3}</span>$</p>

    <p class="text-gray-300">Combining (1), (2), and (3), we obtain</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - 1/2| \\le \\epsilon_{ddh} + \\epsilon_{es},</span>$</p>

    <p class="text-gray-300">which is negligible, since both  <span class="math">\\epsilon_{\\rm ddh}</span>  and  <span class="math">\\epsilon_{\\rm es}</span>  are negligible.</p>

    <p class="text-gray-300">This proof illustrates how one can utilize more than one intractability assumption in a proof of security in a clean and simple way.</p>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Pseudo-Random Functions</h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Basic Definitions</h3>

    <p class="text-gray-300">Let  <span class="math">\\ell_1</span>  and  <span class="math">\\ell_2</span>  be positive integers (which are actually polynomially bounded functions in a security parameter). Let  <span class="math">\\mathcal{F} := \\{F_s\\}_{s \\in S}</span>  be a family of keyed functions, where each function  <span class="math">F_s</span>  maps  <span class="math">\\{0,1\\}^{\\ell_1}</span>  to  <span class="math">\\{0,1\\}^{\\ell_2}</span> . Let  <span class="math">\\Gamma_{\\ell_1,\\ell_2}</span>  denote the set of all functions from  <span class="math">\\{0,1\\}^{\\ell_1}</span>  to  <span class="math">\\{0,1\\}^{\\ell_2}</span> . Informally, we say that  <span class="math">\\mathcal{F}</span>  is pseudo-random if it is hard to distinguish a random function drawn from  <span class="math">\\mathcal{F}</span>  from a random function drawn from  <span class="math">\\Gamma_{\\ell_1,\\ell_2}</span> , given black box access to such a function (this notion was introduced in [GGM86]).</p>

    <p class="text-gray-300">More formally, consider an adversary A that has oracle access to a function in  <span class="math">\\Gamma_{\\ell_1,\\ell_2}</span> , and suppose that A always outputs a bit. Define the PRF-advantage of A to be</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[s \\stackrel{\\ \\leftarrow}{\\leftarrow} S : A^{F_s}() = 1] - \\Pr[f \\stackrel{\\ \\leftarrow}{\\leftarrow} \\Gamma_{\\ell_1,\\ell_2} : A^f()] = 1|.</span>$</p>

    <p class="text-gray-300">We say that  <span class="math">\\mathcal{F}</span>  is pseudo-random if any efficient adversary's PRF-advantage is negligible.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Extending the Input Length with a Universal Hash Function</h3>

    <p class="text-gray-300">We now present one construction that allows one to stretch the input length of a pseudorandom family of functions. Let  <span class="math">\\ell</span>  be a positive integer with  <span class="math">\\ell &gt; \\ell_1</span> . Let  <span class="math">\\mathcal{H} := \\{H_k\\}_{k \\in K}</span>  be a family of keyed hash functions, where each  <span class="math">H_k</span>  maps  <span class="math">\\{0,1\\}^{\\ell}</span>  to  <span class="math">\\{0,1\\}^{\\ell_1}</span> . Let us assume that  <span class="math">\\mathcal{H}</span>  is an  <span class="math">\\epsilon_{\\text{uh}}</span> -universal family of hash functions, where  <span class="math">\\epsilon_{\\text{uh}}</span>  is negligible. This means that for all  <span class="math">w, w&#x27; \\in \\{0,1\\}^{\\ell}</span>  with  <span class="math">w \\neq w&#x27;</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[k \\stackrel{\\&amp;}{\\leftarrow} K : H_k(w) = H_k(w&#x27;)] \\le \\epsilon_{\\text{uh}}.</span>$</p>

    <p class="text-gray-300">There are many ways to construct such families of hash functions.</p>

    <p class="text-gray-300">Now define the family of functions</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F}&#x27; := \\{ F&#x27;_{k,s} \\}_{(k,s) \\in K \\times S},</span>$</p>

    <p class="text-gray-300">where each  <span class="math">F&#x27;_{k,s}</span>  is the function from  <span class="math">\\{0,1\\}^{\\ell}</span>  into  <span class="math">\\{0,1\\}^{\\ell_2}</span>  that sends  <span class="math">w \\in \\{0,1\\}^{\\ell}</span>  to  <span class="math">F_s(H_k(w))</span> . We shall now prove that if  <span class="math">\\mathcal{F}</span>  is pseudo-random, then  <span class="math">\\mathcal{F}&#x27;</span>  is pseudo-random.</p>

    <p class="text-gray-300"><strong>Game 0.</strong> This game represents the computation of an adversary given oracle access to a function drawn at random from  <span class="math">\\mathcal{F}&#x27;</span> . Without loss of generality, we may assume that the adversary makes exactly q queries to its oracle, and never repeats any queries (regardless of the oracle responses). We may present this computation algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, s \\stackrel{\\notin}{\\leftarrow} S</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$w_i \\leftarrow A(r, y_1, \\dots, y_{i-1}) \\in \\{0, 1\\}^{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i \\leftarrow H_k(w_i) \\in \\{0, 1\\}^{\\ell_1}</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow F_s(x_i) \\in \\{0, 1\\}^{\\ell_2}</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, y_1, \\dots, y_q) \\in \\{0, 1\\}</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">The idea behind our notation is that the adversary is modeled as a deterministic algorithm A, and we supply its random coins  <span class="math">r \\in R</span>  as input, and in loop iteration i, the adversary computes its next query  <span class="math">w_i</span>  as a function of its coins and the results  <span class="math">y_1, \\ldots, y_{i-1}</span>  of its previous queries  <span class="math">w_1, \\ldots, w_{i-1}</span> . We are assuming that A operates in such a way that the values  <span class="math">w_1, \\ldots, w_q</span>  are always distinct.</p>

    <p class="text-gray-300">Let  <span class="math">S_0</span>  be the event that the output b=1 in Game 0.</p>

    <p class="text-gray-300">Our goal is to transform this game into a game that is equivalent to the computation of the adversary given oracle access to a random element of  <span class="math">\\Gamma_{\\ell,\\ell_2}</span> , so that the probability that b=1 in the latter game is negligibly close to  <span class="math">\\Pr[S_0]</span> .</p>

    <p class="text-gray-300"><strong>Game 1.</strong> [This is a transition based on indistinguishability.] We now modify Game 0 so that we use a truly random function from  <span class="math">\\ell_1</span>  bits to  <span class="math">\\ell_2</span>  bits, in place of  <span class="math">F_s</span> . Intuitively, the pseudo-randomness property of  <span class="math">\\mathcal{F}</span>  should guarantee that this modification has only a negligible effect on the behavior of the adversary. Algorithmically, Game 1 looks like this:</p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\ensuremath{\\stackrel{\\leftarrow}{\\leftarrow}}}{K} K, \\boxed{f \\stackrel{\\ensuremath{\\stackrel{\\leftarrow}{\\leftarrow}}}{\\Gamma_{\\ell_1,\\ell_2}}}</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\ensuremath{\\leftarrow}}{R}</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$w_i \\leftarrow A(r,y_1,\\dots,y_{i-1}) \\in \\{0,1\\}^\\ell</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i \\leftarrow H_k(w_i) \\in \\{0,1\\}^{\\ell_1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\boxed{y_i \\leftarrow f(x_i) \\in \\{0,1\\}^{\\ell_2}}</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r,y_1,\\dots,y_q) \\in \\{0,1\\}</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - \\Pr[S_1]| = \\epsilon_{\\text{prf}},\\tag{4}</span>$</p>

    <p class="text-gray-300">where prf is the PDF-advantage, relative to F, of some efficient adversary (which is negligible assuming F is pseudo-random). Indeed, the following adversary essentially &quot;interpolates&quot; between Games 0 and 1, and so has PRF-advantage, with respect to F, exactly equal to |Pr[S0] &minus; Pr[S1]|:</p>

    <p class="text-gray-300">Oracle machine D<sup>O</sup></p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$w_i \\leftarrow A(r, y_1, \\dots, y_{i-1}) \\in \\{0, 1\\}^{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i \\leftarrow H_k(w_i) \\in \\{0, 1\\}^{\\ell_1}</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow \\mathcal{O}(x_i) \\in \\{0, 1\\}^{\\ell_2}</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, y_1, \\dots, y_q) \\in \\{0, 1\\}</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">Game 2. [This transition is a bridging step.] We now make a purely conceptual change to Game 1. Intuitively, one can think of a black box containing the random function f as a box with a little &quot;gnome&quot; inside: the gnome keeps a table of previous input/output pairs, and if a query is made that matches one of the previous inputs, the corresponding output is returned, and otherwise, an output value is chosen at random, and a new input/output pair is added to the table (see Figure 1). Based on this, we get the following equivalent formulation of Game 1:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} k &amp; \\stackrel{\\rlap{</span>\\leftarrow<span class="math">}}{\\leftarrow} K, \\boxed{Y_1, \\dots, Y_q \\stackrel{\\rlap{</span>\\leftarrow<span class="math">}}{\\leftarrow} \\{0,1\\}^{\\ell_2}} \\\\ r &amp; \\stackrel{\\rlap{</span>\\leftarrow<span class="math">}}{\\leftarrow} R \\\\ \\text{for } i \\leftarrow 1 \\dots q \\text{ do} \\\\ w_i \\leftarrow A(r, y_1, \\dots, y_{i-1}) \\in \\{0,1\\}^{\\ell} \\\\ x_i \\leftarrow H_k(w_i) \\in \\{0,1\\}^{\\ell_1} \\\\ &amp; \\text{ if } x_i = x_j \\text{ for some } j &lt; i \\text{ then } y_i \\leftarrow y_j \\text{ else } y_i \\leftarrow Y_i \\\\ b \\leftarrow A(r, y_1, \\dots, y_q) \\in \\{0,1\\} \\\\ \\text{output } b \\end{split}</span>$</p>

    <p class="text-gray-300">Let S<sup>2</sup> be the event that b = 1 in Game 2. Since the change in going from Game 1 to Game 2 was purely conceptual, we clearly have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_2] = \\Pr[S_1]. \\tag{5}</span>$</p>

    <p class="text-gray-300">    <img src="_page_13_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: A gnome implementation of a random function</p>

    <p class="text-gray-300">Game 3. [This is a transition based on a failure event.] We now modify Game 2 so that our gnome is &quot;forgetful,&quot; and does not perform any consistency checks in calculating the y<sup>i</sup> values:</p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, Y_1, \\dots, Y_q \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}^{\\ell_2}</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\&amp;}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$w_i \\leftarrow A(r, y_1, \\dots, y_{i-1}) \\in \\{0, 1\\}^{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i \\leftarrow H_k(w_i) \\in \\{0, 1\\}^{\\ell_1}</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow Y_i</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, y_1, \\dots, y_q) \\in \\{0, 1\\}</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">Define S<sup>3</sup> to be the event that b = 1 in Game 3. Define F to be the event that in Game 3, x<sup>i</sup> = x<sup>j</sup> for some i, j with i 6= j.</p>

    <p class="text-gray-300">Observe that k and x1, . . . , x<sup>q</sup> play no role in Game 3, other than to define the event F. In particular, the random variables k, r, y1, . . . , y<sup>q</sup> are mutually independent.</p>

    <p class="text-gray-300">We view Games 2 and 3 as operating on the same underlying probability space, so that the values of k, r, Y1, . . . , Y<sup>q</sup> are identical in both games. It is not hard to see that Games 2 and 3 proceed identically, unless event F occurs. In particular, if F does not occur, then the output in both games is identical. This is fairly obvious, but since this is our first example of this technique, let us make a more formal argument (in later examples, we will not do this). Select any fixed values k, r, Y1, . . . , Y<sup>q</sup> such that F does not occur. We prove by induction on i = 0, . . . , q, the values w1, x1, y1, . . . , w<sup>i</sup> , x<sup>i</sup> , y<sup>i</sup> are computed identically in both games. The case i = 0 is trivially true. Now we let i &gt; 0, assume the claim for i &minus; 1, and prove it for i. As the claim holds for i &minus; 1, the value w<sup>i</sup> is computed in the same way as A(r, y1, . . . , yi&minus;1) in both games, and hence x<sup>i</sup> is computed in the same way as Hk(wi) in both games. When it comes to computing y<sup>i</sup> , we see that since F does not hold, the values x1, . . . , x<sup>i</sup> are distinct (and are computed in the same way in both games); therefore, in both games  <span class="math">y_i</span>  is assigned the value  <span class="math">Y_i</span> . That completes the induction proof. It follows that when F does not occur, both games compute  <span class="math">y_1, \\ldots, y_q</span>  in the same way, and hence both compute  <span class="math">b = A(r, y_1, \\ldots, y_q)</span>  in the same way.</p>

    <p class="text-gray-300">In the previous paragraph, we argued that if F does not occur, then both games output the same value. This is the same as saying that  <span class="math">S_2 \\wedge \\neg F \\iff S_3 \\wedge \\neg F</span> . Therefore, by the Difference Lemma, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_2] - \\Pr[S_3]| \\le \\Pr[F]. \\tag{6}</span>$</p>

    <p class="text-gray-300">We now show that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F] \\le \\epsilon_{\\rm uh} \\cdot \\frac{q^2}{2}.\\tag{7}</span>$</p>

    <p class="text-gray-300">The analysis is all done with respect to Game 3. To prove this inequality, it suffices to prove it conditioned on any fixed values of  <span class="math">r, y_1, \\ldots, y_q</span> . In this conditional probability distribution, the values  <span class="math">w_1, \\ldots, w_q</span>  are fixed (as they are determined by  <span class="math">r, y_1, \\ldots, y_q</span> ), while k is uniformly distributed over K (by independence). For any fixed pair of indices i, j, with  <span class="math">i \\neq j</span> , by the universal hash property of  <span class="math">\\mathcal{H}</span> , and by our assumption that the adversary never repeats any queries, we have  <span class="math">w_i \\neq w_j</span> , and hence</p>

    <p class="text-gray-300"><span class="math">$\\Pr[H_k(w_i) = H_k(w_i)] \\le \\epsilon_{\\text{uh}}.</span>$</p>

    <p class="text-gray-300">Since there are q(q-1)/2 such pairs of indices, the inequality (7) follows from the union bound.</p>

    <p class="text-gray-300">Note that while one could have carried out the above analysis with respect to Game 2, it is conceptually much easier to carry it out in Game 3. In general, in applying the Difference Lemma, one can choose to analyze the probability of the &quot;failure event&quot; in either of the two adjacent games, but one will usually be easier to work with than the other.</p>

    <p class="text-gray-300">Since the values of k and  <span class="math">x_1, \\ldots, x_q</span>  play no role in Game 3, it is not hard to see that in fact, Game 3 is equivalent to the computation of the adversary given oracle access to a function drawn at random from  <span class="math">\\Gamma_{\\ell,\\ell_2}</span> : each successive (and by assumption, distinct) query yields a random result. Thus,  <span class="math">|\\Pr[S_0] - \\Pr[S_3]|</span>  is equal to the PRF-advantage of the adversary. It then follows from (4), (5), (6), and (7) that the PRF-advantage of the adversary is bounded by</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_{\\rm prf} + \\epsilon_{\\rm uh} \\cdot \\frac{q^2}{2},</span>$</p>

    <p class="text-gray-300">which is negligible.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Pseudo-Random Permutations</h2>

    <p class="text-gray-300">Let  <span class="math">\\ell</span>  be a positive integer. Let  <span class="math">\\mathcal{P} := \\{P_s\\}_{s \\in S}</span>  be a family of keyed functions, where each  <span class="math">P_s</span>  is a <em>permutation</em> on  <span class="math">\\{0,1\\}^{\\ell}</span> . Let  <span class="math">\\Pi_{\\ell}</span>  denote the set of all permutations on  <span class="math">\\{0,1\\}^{\\ell}</span> . Informally, we say that  <span class="math">\\mathcal{P}</span>  is pseudo-random if it is hard to distinguish a random permutation drawn from  <span class="math">\\mathcal{P}</span>  from a random permutation drawn from  <span class="math">\\Pi_{\\ell}</span> , given black box access to such a permutation.</p>

    <p class="text-gray-300">More formally, consider an adversary A that has oracle access to a function in  <span class="math">\\Gamma_{\\ell,\\ell}</span> , and suppose that A always outputs a single bit. Define the PRP-advantage of A to be</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[s \\stackrel{\\phi}{\\leftarrow} S : A^{P_s}() = 1] - \\Pr[\\pi \\stackrel{\\phi}{\\leftarrow} \\Pi_{\\ell} : A^{\\pi}() = 1]|.</span>$</p>

    <p class="text-gray-300">We say that P is pseudo-random if any efficient oracle machine's PRP-advantage is negligible.</p>

    <p class="text-gray-300">One of the things we want to do is to present a proof that every pseudo-random permutation family is also a pseudo-random function family. But first, we consider the slightly simpler problem of distinguishing random functions from random permutations. Suppose you are given a black box that contains either a random function on <code>bits or a random permutation on</code> bits, and your task is to determine which is the case. If you make roughly 2\`/<sup>2</sup> queries, then (by the birthday paradox) you would expect to see some outputs that are equal, if the box contains a function rather than a permutation. This would allow you to determine, with reasonably high probability, the contents of the box. We want to rigorously prove that there is really no better way to determine what is inside the box.</p>

    <p class="text-gray-300">Again, let A be an adversary given oracle access to a function in &Gamma;<code>,</code>. We define its RF/RP-advantage to be</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[f \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} \\Gamma_{\\ell,\\ell} : A^f() = 1] - \\Pr[\\pi \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} \\Pi_{\\ell} : A^{\\pi}() = 1]|.</span>$</p>

    <p class="text-gray-300">We shall now show that for any oracle machine that makes at most q queries to its oracle, its RF/RP-advantage is at most</p>

    <p class="text-gray-300"><span class="math">$\\frac{q^2}{2} \\cdot 2^{-\\ell}.</span>$</p>

    <p class="text-gray-300">As usual, we make this argument by considering a sequence of games.</p>

    <p class="text-gray-300">Game 0. This game represents the computation of an adversary A given oracle access to a random permutation. Let us assume that A makes precisely q queries, and that each of these queries is distinct. We may write this game algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">$\\pi \\stackrel{\\notin}{\\leftarrow} \\Pi_{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$x_i \\leftarrow A(r, y_1, \\dots, y_{i-1}) \\in \\{0, 1\\}^{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow \\pi(x_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, y_1, \\dots, y_q) \\in \\{0, 1\\}</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">As usual, we assume that the queries x1, . . . , x<sup>q</sup> are always distinct. Define S<sup>0</sup> to be the event that b = 1 in Game 0.</p>

    <p class="text-gray-300">Game 1. [This transition is a bridging step.] We now transform Game 1 into a new game involving &quot;gnomes,&quot; as in &sect;4.2. Our strategy is to first build a game that uses a &quot;faithful gnome&quot; that makes all the appropriate consistency checks. In the next game, we will use a &quot;forgetful gnome&quot; that does not bother with consistency checks, but that otherwise behaves identically. The idea is that we can model oracle access to a random permutation as a little &quot;gnome&quot; who keeps track input/output pairs, but now, the gnome has to make sure outputs as well as inputs are consistent:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp; \\overbrace{Y_1, \\dots, Y_q} \\overset{\\phi}{\\leftarrow} \\{0, 1\\}^{\\ell} \\\\ &amp; r \\overset{\\phi}{\\leftarrow} R \\\\ &amp; \\text{for } i \\leftarrow 1 \\dots q \\text{ do} \\\\ &amp; x_i \\leftarrow A(r, y_1, \\dots, y_{i-1}) \\in \\{0, 1\\}^{\\ell} \\\\ &amp; \\text{if } Y_i \\in \\{y_1, \\dots, y_{i-1}\\} \\text{ then } y_i \\overset{\\phi}{\\leftarrow} \\{0, 1\\}^{\\ell} \\setminus \\{y_1, \\dots, y_{i-1}\\} \\text{ else } y_i \\leftarrow Y_i \\\\ &amp; b \\leftarrow A(r, y_1, \\dots, y_q) \\in \\{0, 1\\} \\\\ &amp; \\text{output } b \\end{aligned}</span>$</p>

    <p class="text-gray-300">Recall that we are assuming that the inputs x1, . . . , x<sup>q</sup> are always distinct, so our &quot;gnome&quot; does not have to watch for duplicate inputs. Our &quot;gnome&quot; uses the random value Y<sup>i</sup> as the &quot;default value&quot; for &pi;(xi), unless that value has already been used as a previous output, in which case the &quot;gnome&quot; chooses the value of &pi;(xi) at random from all unused output values.</p>

    <p class="text-gray-300">Let S<sup>1</sup> be the event that b = 1 in Game 1. It is evident that Game 1 is equivalent to Game 0 from the point of view of the adversary, and therefore:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_1] = \\Pr[S_0]. \\tag{8}</span>$</p>

    <p class="text-gray-300">Game 2. [This is a transition based on a failure event.] As promised, we now make our gnome &quot;forgetful,&quot; by simply dropping the output consistency checks:</p>

    <p class="text-gray-300"><span class="math">$Y_1, \\dots, Y_q \\overset{\\&amp;}{\\leftarrow} \\{0, 1\\}^{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\overset{\\&amp;}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$x_i \\leftarrow A(r, y_1, \\dots, y_{i-1}) \\in \\{0, 1\\}^{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow Y_i</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, y_1, \\dots, y_q) \\in \\{0, 1\\}</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">Let S<sup>2</sup> be the event that b = 1 in Game 2. Let F be the event that Y<sup>i</sup> = Y<sup>j</sup> for some i 6= j. Let us view Games 1 and 2 as operating on the same underlying probability space, so the values of r, Y1, . . . , Y<sup>q</sup> are identical in both games. It is evident that these two games proceed identically unless the event F occurs; that is, S<sup>1</sup> &and; &not;F &lArr;&rArr; S<sup>2</sup> &and; &not;F. Therefore, by the Difference Lemma, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_1] - \\Pr[S_2]| \\le \\Pr[F]. \\tag{9}</span>$</p>

    <p class="text-gray-300">Furthermore, F is the union of q 2 events, each of which occurs with probability 2&minus;<code> (clearly, Pr[Y&lt;sup&gt;i&lt;/sup&gt; = Y&lt;sup&gt;j&lt;/sup&gt; ] = 2&minus;</code> , for i 6= j), and so by the union bound, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F] \\le \\frac{q^2}{2} \\cdot 2^{-\\ell}.\\tag{10}</span>$</p>

    <p class="text-gray-300">Finally, note that Game 2 is fully equivalent to the computation of the adversary given oracle access to a random function. Thus, its RF/RP-advantage is equal to</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - \\Pr[S_2]|,</span>$</p>

    <p class="text-gray-300">and by (8), (9), and (10), this is at most</p>

    <p class="text-gray-300"><span class="math">$\\frac{q^2}{2} \\cdot 2^{-\\ell}.</span>$</p>

    <p class="text-gray-300">We now show that if <code> is suitably large, so that 2&minus;</code> is negligible, then any pseudo-random permutation family P := {Ps}s&isin;<sup>S</sup> is also a pseudo-random function family. This follows quite easily from the definitions and the fact proved in &sect;5.1 bounding the RF/RP-advantage of any adversary.</p>

    <p class="text-gray-300">Let us fix an efficient adversary A, and show that its PRF-advantage, with respect to P, is negligible. Assume that the oracle machine always makes at most q queries (since the adversary is efficient, this means that q is bounded by a polynomial in a security parameter).</p>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_{\\mathrm{prf}} := |\\Pr[s \\stackrel{\\phi}{\\leftarrow} S : A^{P_s}() = 1] - \\Pr[f \\stackrel{\\phi}{\\leftarrow} \\Gamma_{\\ell,\\ell} : A^f() = 1]|</span>$</p>

    <p class="text-gray-300">be the PRF-advantage of A. We want to show that prf is negligible. Let</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_{\\text{prp}} := |\\Pr[s \\stackrel{\\phi}{\\leftarrow} S : A^{P_s}() = 1] - \\Pr[\\pi \\stackrel{\\phi}{\\leftarrow} \\Pi_{\\ell} : A^{\\pi}() = 1]|</span>$</p>

    <p class="text-gray-300">be the PRP-advantage of A. By assumption, prp is negligible. Let</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_{\\mathrm{rf/rp}} := |\\Pr[f \\stackrel{\\phi}{\\leftarrow} \\Gamma_{\\ell,\\ell} : A^f() = 1] - \\Pr[\\pi \\stackrel{\\phi}{\\leftarrow} \\Pi_{\\ell} : A^{\\pi}() = 1]|</span>$</p>

    <p class="text-gray-300">be the RF/RP-advantage of A. From the analysis in &sect;5.1, we know that</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_{\\rm rf/rp} \\le \\frac{q^2}{2} \\cdot 2^{-\\ell},</span>$</p>

    <p class="text-gray-300">which is negligible, assuming 2&minus;\` is negligible. Finally, it is easy to see that by the triangle inequality, we have</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_{\\text{prf}} = |\\Pr[s \\stackrel{\\xi}{\\leftarrow} S : A^{P_s}() = 1] - \\Pr[f \\stackrel{\\xi}{\\leftarrow} \\Gamma_{\\ell,ell} : A^f() = 1]|</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq |\\Pr[s \\stackrel{\\xi}{\\leftarrow} S : A^{P_s}() = 1] - \\Pr[\\pi \\stackrel{\\xi}{\\leftarrow} \\Pi_{\\ell} : A^{\\pi}() = 1]| +</span>$</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\pi \\stackrel{\\xi}{\\leftarrow} \\Pi_{\\ell} : A^{\\pi}() = 1] - \\Pr[f \\stackrel{\\xi}{\\leftarrow} \\Gamma_{\\ell,\\ell} : A^f() = 1]|</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\epsilon_{\\text{prp}} + \\epsilon_{\\text{rf/rp}},</span>$</p>

    <p class="text-gray-300">which is negligible.</p>

    <p class="text-gray-300">We now give an analysis of the Luby-Rackoff construction for building a pseudo-random permutation family out of a pseudo-random function family [LR88]. Since it is really no harder to do, we analyze the variation of Naor and Reingold [NR99], which uses a pairwise independent family of hash functions (or something slightly weaker) at one of the stages of the construction.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{F} := \\{F_s\\}_{s \\in S}</span>  be a pseudo-random family of functions, where each  <span class="math">F_s</span>  maps  <span class="math">\\ell</span> -bit strings to  <span class="math">\\ell</span> -bit strings.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{H} := \\{H_k\\}_{k \\in K}</span>  an  <span class="math">\\epsilon_{axu}</span> -almost-XOR-universal family of hash functions on  <span class="math">\\ell</span> -bits, meaning that each  <span class="math">H_k</span>  maps  <span class="math">\\ell</span> -bit strings to  <span class="math">\\ell</span> -bit strings, and for all  <span class="math">x, x&#x27;, y \\in \\{0, 1\\}^{\\ell}</span> , with  <span class="math">x \\neq x&#x27;</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[k \\stackrel{\\phi}{\\leftarrow} K : H_k(x) \\oplus H_k(x&#x27;) = y] \\le \\epsilon_{\\text{axu}}.</span>$</p>

    <p class="text-gray-300">We assume that  <span class="math">\\epsilon_{\\text{axu}}</span>  is negligible.</p>

    <p class="text-gray-300">The Luby-Rackoff construction builds a pseudo-random permutation family that acts on  <span class="math">2\\ell</span> -bit strings as follows. A Luby-Rackoff key consists of a triple  <span class="math">(k, s_1, s_2)</span> , with  <span class="math">k \\in K</span>  and  <span class="math">s_1, s_2 \\in S</span> . Let us interpret inputs and outputs as pairs of  <span class="math">\\ell</span> -bit strings. Given  <span class="math">u, v \\in \\{0, 1\\}^{\\ell}</span>  as input, the Luby-Rackoff algorithm runs as follows:</p>

    <p class="text-gray-300"><span class="math">$w \\leftarrow u \\oplus H_k(v)</span>$
<span class="math">$x \\leftarrow v \\oplus F_{s_1}(w)</span>$
<span class="math">$y \\leftarrow w \\oplus F_{s_2}(x)</span>$</p>

    <p class="text-gray-300">The output is x, y.</p>

    <p class="text-gray-300">It is easy to verify that the function computed by this algorithm is a permutation, and indeed, it is easy to invert the permutation given the key. We want to show that this construction is a pseudo-random permutation family, under the assumptions above, and the assumption that  <span class="math">2^{-\\ell}</span>  is negligible. To this end, by the result in &sect;5.1, it will suffice to show that this construction is a pseudo-random function family.</p>

    <p class="text-gray-300"><strong>Game 0.</strong> This game represents the computation of an adversary given oracle access to the Luby-Rackoff construction, for random keys  <span class="math">k, s_1, s_2</span> . We assume that the adversary makes exactly q oracle queries, and that all of these are distinct. We can present this game algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, s_1 \\stackrel{\\notin}{\\leftarrow} S, s_2 \\stackrel{\\notin}{\\leftarrow} S</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\dots, x_{i-1}, y_{i-1})</span>$</p>

    <p class="text-gray-300"><span class="math">$w_i \\leftarrow u_i \\oplus H_k(v_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i \\leftarrow v_i \\oplus F_{s_1}(w_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow w_i \\oplus F_{s_2}(x_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, x_1, y_1, \\dots, x_q, y_q)</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">We are assuming that for all  <span class="math">i \\neq j</span> , we may have  <span class="math">u_i = u_j</span>  or  <span class="math">v_i = v_j</span> , but not both. Let  <span class="math">S_0</span>  be the event that b = 1 in Game 0.</p>

    <p class="text-gray-300"><strong>Game 1.</strong> [This is a transition based on indistinguishability, plus a bridging step.] We now modify Game 0, replacing  <span class="math">F_{s_1}</span>  be a truly random function. To save steps, let us implement our random function directly as a &quot;faithful gnome&quot;:</p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, \\overline{X_1, \\dots, X_q \\leftarrow \\{0, 1\\}^\\ell}, s_2 \\stackrel{\\notin}{\\leftarrow} S</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\dots, x_{i-1}, y_{i-1})</span>$</p>

    <p class="text-gray-300"><span class="math">$w_i \\leftarrow u_i \\oplus H_k(v_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\{ \\text{if } w_i = w_j \\text{ for some } j &lt; i \\text{ then } x_i&#x27; \\leftarrow x_j&#x27; \\text{ else } x_i&#x27; \\leftarrow X_i \\}, x_i \\leftarrow v_i \\oplus x_i&#x27;</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow w_i \\oplus F_{s_2}(x_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, x_1, y_1, \\dots, x_q, y_q)</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">The intuition is that x 0 i represents the output of a random function on input w<sup>i</sup> . The default value for x 0 i is X<sup>i</sup> , but this default value is overridden if w<sup>i</sup> is equal to some previous input w<sup>j</sup> .</p>

    <p class="text-gray-300">Let S<sup>1</sup> be the event that b = 1 in Game 1. By a (by now) very familiar argument, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - \\Pr[S_1]| = \\epsilon_{\\text{prf}},\\tag{11}</span>$</p>

    <p class="text-gray-300">where prf is the PRF-advantage of some efficient adversary, and therefore negligible. Indeed, it is evident that the following adversary D does the job:</p>

    <p class="text-gray-300">Oracle machine D<sup>O</sup></p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, s_2 \\stackrel{\\notin}{\\leftarrow} S</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\dots, x_{i-1}, y_{i-1})</span>$</p>

    <p class="text-gray-300"><span class="math">$w_i \\leftarrow u_i \\oplus H_k(v_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i \\leftarrow v_i \\oplus \\mathcal{O}(w_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow w_i \\oplus F_{s_2}(x_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, x_1, y_1, \\dots, x_q, y_q)</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">Game 2. [This is also a transition based on indistinguishability, plus a bridging step.] Next, we naturally replace Fs<sup>2</sup> by a truly random function. Again, let us implement our random function directly as a &quot;faithful gnome&quot;:</p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, X_1, \\dots, X_q \\leftarrow \\{0,1\\}^\\ell, \\boxed{Y_1, \\dots, Y_q \\stackrel{\\notin}{\\leftarrow} \\{0,1\\}^\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\dots, x_{i-1}, y_{i-1})</span>$</p>

    <p class="text-gray-300"><span class="math">$w_i \\leftarrow u_i \\oplus H_k(v_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\{ \\text{ if } w_i = w_j \\text{ for some } j &lt; i \\text{ then } x_i&#x27; \\leftarrow x_j&#x27; \\text{ else } x_i&#x27; \\leftarrow X_i \\}, x_i \\leftarrow v_i \\oplus x_i&#x27;</span>$</p>

    <p class="text-gray-300"><span class="math">$\\{ \\text{ if } x_i = x_j \\text{ for some } j &lt; i \\text{ then } y_i&#x27; \\leftarrow y_j&#x27; \\text{ else } y_i&#x27; \\leftarrow Y_i \\}, y_i \\leftarrow w_i \\oplus y_i&#x27; \\}</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, x_1, y_1, \\dots, x_q, y_q)</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">Let  <span class="math">S_2</span>  be the event that b=1 in Game 2. Again, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_1] - \\Pr[S_2]| = \\epsilon&#x27;_{\\text{prf}},\\tag{12}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon&#x27;_{prf}</span>  is the PRF-advantage of some efficient adversary, and therefore negligible. Indeed, it is evident that the following adversary D' does the job:</p>

    <pre><code class="language-text">Oracle machine (D&#x27;)^{\\mathcal{O}}

k \\stackrel{\\ell}{\\leftarrow} K, X_1, \\dots, X_q \\leftarrow \\{0, 1\\}^{\\ell}

r \\stackrel{\\ell}{\\leftarrow} R

for i \\leftarrow 1 \\dots q do

(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\dots, x_{i-1}, y_{i-1})

w_i \\leftarrow u_i \\oplus H_k(v_i)

\\{ \\text{ if } w_i = w_j \\text{ for some } j &lt; i \\text{ then } x_i&#x27; \\leftarrow x_j&#x27; \\text{ else } x_i&#x27; \\leftarrow X_i \\}, x_i \\leftarrow v_i \\oplus x_i&#x27;

y_i \\leftarrow w_i \\oplus \\mathcal{O}(x_i)

b \\leftarrow A(r, x_1, y_1, \\dots, x_q, y_q)

output b
</code></pre>

    <p class="text-gray-300">Although it is not critical for this proof, we remark that one could jump directly from Game 0 to Game 2. The following adversary  <span class="math">\\tilde{D}</span>  has PRF-advantage equal to  <span class="math">|\\Pr[S_0] - \\Pr[S_2]|/2</span> :</p>

    <pre><code class="language-text">Oracle machine \\tilde{D}^{\\mathcal{O}}

c \\stackrel{\\text{$\\ensuremath{\\leftarrow}}}{\\leftarrow} \\{0,1\\}
\\nif c=0 then output D^{\\mathcal{O}} else output (D&#x27;)^{\\mathcal{O}}
</code></pre>

    <p class="text-gray-300">We leave this for the reader to verify. This is a special case of what is more generally called a &quot;hybrid argument,&quot; which allows one to replace any number (even a non-constant number) of pseudo-random objects by random objects in a single step. Exactly how and when such hybrid arguments are applicable depends on circumstances; however, one requirement is that all the objects are of the same basic type. (See &sect;3.2.3 of [Gol01] for more on hybrid arguments.)</p>

    <p class="text-gray-300"><strong>Game 3.</strong> [This is a transition based on a failure event.] Now we make both of our gnomes &quot;forgetful,&quot; and we eliminate all the input-consistency checks. When we do this, we get the following:</p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\notin}{\\leftarrow} K, X_1, \\dots, X_q \\leftarrow \\{0, 1\\}^{\\ell}, Y_1, \\dots, Y_q \\stackrel{\\notin}{\\leftarrow} \\{0, 1\\}^{\\ell}</span>$</p>

    <p class="text-gray-300"><span class="math">$r \\stackrel{\\notin}{\\leftarrow} R</span>$
for  <span class="math">i \\leftarrow 1 \\dots q</span>  do
<span class="math">$(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\dots, x_{i-1}, y_{i-1})</span>$</p>

    <p class="text-gray-300"><span class="math">$w_i \\leftarrow u_i \\oplus H_k(v_i)</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i \\leftarrow v_i \\oplus X_i</span>$</p>

    <p class="text-gray-300"><span class="math">$y_i \\leftarrow w_i \\oplus Y_i</span>$</p>

    <p class="text-gray-300"><span class="math">$b \\leftarrow A(r, x_1, y_1, \\dots, x_q, y_q)</span>$
output  <span class="math">b</span></p>

    <p class="text-gray-300">Let S<sup>3</sup> be the event that b = 1 in Game 3.</p>

    <p class="text-gray-300">Claim. In Game 3, the random variables k, r, x1, y1, . . . , xq, y<sup>q</sup> are mutually independent. Observe that k and r are independent by construction. Now condition on any fixed values of k and r. The first query (u1, v1) is now fixed, and hence so is w1; however, X<sup>1</sup> and Y<sup>1</sup> are both easily seen to still be uniformly and independently distributed in this conditional probability distribution, and so x<sup>1</sup> and y<sup>1</sup> are also uniformly and independently distributed. One continues the argument, conditioning on fixed values of x1, y1, observing that now u2, v2, and w<sup>2</sup> are also fixed, and that x<sup>2</sup> and y<sup>2</sup> are uniformly and independently distributed. The claim should now be clear.</p>

    <p class="text-gray-300">Let F<sup>1</sup> be the event that w<sup>i</sup> = w<sup>j</sup> for some i 6= j in Game 3. Let F<sup>2</sup> be the event that x<sup>i</sup> = x<sup>j</sup> for some i 6= j in Game 3. Let F := F<sup>1</sup> &or; F2. Games 2 and 3 proceed identically so long as F does not occur, and so by the Difference Lemma (and the union bound), we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_2] - \\Pr[S_3]| \\le \\Pr[F] \\le \\Pr[F_1] + \\Pr[F_2].</span>$
(13)</p>

    <p class="text-gray-300">By the fact that x1, . . . , x<sup>q</sup> are mutually independent (see claim), it is obvious that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_2] \\le \\frac{q^2}{2} \\cdot 2^{-\\ell}.\\tag{14}</span>$</p>

    <p class="text-gray-300">Let us now analyze the event F1. We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_1] \\le \\frac{q^2}{2} \\cdot \\epsilon_{\\text{axu}}.\\tag{15}</span>$</p>

    <p class="text-gray-300">To prove this, it suffices to prove it conditioned on any fixed values of r, x1, y1, . . . , xq, yq. If these values are fixed, then so are u1, v1, . . . , uq, vq. However, by independence (see claim), the variable k is still uniformly distributed over K. Now consider any fixed pair of indices i, j, with i 6= j. Suppose first that v<sup>i</sup> = v<sup>j</sup> . Then by assumption, we must have u<sup>i</sup> 6= u<sup>j</sup> , and it is easy to see that w<sup>i</sup> 6= w<sup>j</sup> for all k. Next suppose that v<sup>i</sup> 6= v<sup>j</sup> . Then by the almost-XOR-universal property for H, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[H_k(v_i) \\oplus H_k(v_j) = u_i \\oplus u_j] \\le \\epsilon_{\\text{axu}}.</span>$</p>

    <p class="text-gray-300">Thus, we have shown that for all pairs i, j with i 6= j,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[w_i = w_j] \\le \\epsilon_{\\text{axu}}.</span>$</p>

    <p class="text-gray-300">The inequality (15) follows from the union bound.</p>

    <p class="text-gray-300">As another consequence of the claim, we observe that Game 3 represents the computation of the adversary given oracle access to a random function. Thus, the adversary's PRFadvantage is equal to |Pr[S0] &minus; Pr[S3]|. From this, and (11), (12), (13), (14), and (15), we conclude that the PRF-advantage of our adversary is at most</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_{\\rm prf} + \\epsilon&#x27;_{\\rm prf} + \\frac{q^2}{2} (\\epsilon_{\\rm axu} + 2^{-\\ell}),</span>$</p>

    <p class="text-gray-300">which is negligible.</p>

    <p class="text-gray-300">That concludes the proof, but we make one remark about the proof &quot;strategy.&quot; One might have been tempted to take smaller steps: making the first gnome forgetful in one step, and making the second gnome forgetful in the second step. However, this would not be convenient. If we make only the first gnome forgetful, the resulting game is not &quot;nice enough&quot; to allow one to easily establish a bound on the &quot;failure probability.&quot; It is better to make both gnomes forgetful at once, thus getting a very nice game in which it is easy to analyze both &quot;failure probabilities.&quot; In general, finding a good strategy for how to modify games, and the order in which to modify them, etc., is a bit of a &quot;black art.&quot;</p>

    <p class="text-gray-300">In this section and the next, we now present some more elaborate examples. This section studies a chosen ciphertext secure symmetric-key encryption scheme.</p>

    <p class="text-gray-300">A symmetric-key encryption scheme is a triple of probabilistic algorithms (KeyGen, E, D). The key generation algorithm KeyGen takes no input (other than an implied security parameter, and perhaps other system parameters), and outputs a key k. The encryption algorithm E takes as input a key k and a message m, selected from a message space M, and outputs a ciphertext &psi;. The decryption algorithm takes as input a key k and a ciphertext &psi;, and outputs a message m.</p>

    <p class="text-gray-300">As for any encryption scheme, the basic correctness requirement is that decryption &quot;undoes&quot; encryption. That is, for all m &isin; M, all k &isin; [KeyGen()], all &psi; &isin; [E(k, m)], and all m<sup>0</sup> &isin; [D(k, &psi;)], we have m = m<sup>0</sup> .</p>

    <p class="text-gray-300">The notion of chosen ciphertext security is defined via a game between an adversary and a challenger:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The challenger computes k &larr;<sup>c</sup><sup>|</sup> KeyGen(), and b &larr; { <sup>c</sup><sup>|</sup> 0, 1}.</li>
      <li>The adversary makes a sequence of queries to the challenger. Each query is of one of two types:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>encryption query: The adversary submits two messages m0, m<sup>1</sup> &isin; M to the challenger. The challenger sends back &psi; &larr;<sup>c</sup><sup>|</sup> E(k, mb) to the adversary.</li>
      <li>decryption query: The adversary submits &psi; 0 to the challenger, subject to the restriction that &psi; 0 is not equal to the ciphertext output by any previous encryption query. The challenger sends back m<sup>0</sup> &larr;<sup>c</sup><sup>|</sup> D(k, &psi;<sup>0</sup> ) to the adversary.</li>
    </ul></li>
      <li>The adversary outputs &circ;b &isin; {0, 1}.</li>
    </ul>

    <p class="text-gray-300">We define the CCA-advantage of the adversary to be |Pr[b = &circ;b] &minus; 1/2|. Chosen ciphertext security means that any efficient adversary's CCA-advantage is negligible.</p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8">7.2 A Simple Construction</h3>

    <p class="text-gray-300">We can easily build a chosen-ciphertext secure symmetric encryption scheme out of two components.</p>

    <p class="text-gray-300">The first component is a pseudo-random family of functions F := {Fs}s&isin;S, where each F<sup>s</sup> maps n-bit strings to <code>-bit strings. It is assumed that 2&minus;&lt;sup&gt;n&lt;/sup&gt; is negligible. Also, the message space for the encryption scheme will be {0, 1} </code> .</p>

    <p class="text-gray-300">The second component is a &quot;message authentication code,&quot; which we shall define as an unpredictable function family H := {Hk}k&isin;K, where each H<sup>k</sup> is a function mapping (n + \`)-bit strings to w-bit strings. The property for H we are assuming is defined in terms of a game between an adversary and a challenger:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The challenger selects k &larr;<sup>c</sup><sup>|</sup> K.</li>
      <li>The adversary makes a sequence of queries to the challenger. Each query is a string y &isin; {0, 1} n+\` . The challenger gives the adversary t &larr; Hk(y).</li>
      <li>The adversary outputs a pair (y &lowast; , t<sup>&lowast;</sup> ).</li>
    </ul>

    <p class="text-gray-300">The adversary wins the above game if Hk(y &lowast; ) = t <sup>&lowast;</sup> and y &lowast; is not equal to any y-value submitted to the challenger during the game. The adversary's UF-advantage is defined to be the probability that the adversary wins the above game. The assumption that H is an unpredictable function family is the assumption that every efficient adversary's UFadvantage is negligible.</p>

    <p class="text-gray-300">The encryption scheme works as follows. A key for the scheme is a pair (s, k), with s &isin; S and k &isin; K, each chosen at random.</p>

    <p class="text-gray-300">To encrypt a message m &isin; {0, 1} \` , the encryption algorithm computes the ciphertext &psi; as follows:</p>

    <p class="text-gray-300"><span class="math">$x \\stackrel{\\phi}{\\leftarrow} \\{0,1\\}^n, \\ c \\leftarrow F_s(x) \\oplus m, \\ t \\leftarrow H_k(x \\mid\\mid c), \\ \\psi \\leftarrow (x,c,t).</span>$</p>

    <p class="text-gray-300">To decrypt a ciphertext &psi;, which we may assume to be of the form (x, c, t), with x &isin; {0, 1} n , c &isin; {0, 1} \` , t &isin; {0, 1} <sup>w</sup>, the decryption algorithm computes m as follows:</p>

    <p class="text-gray-300">if
<span class="math">$H_k(x \\mid\\mid c) = t</span>$
then  <span class="math">m \\leftarrow F_s(x) \\oplus c</span>  else  <span class="math">m \\leftarrow</span>  &quot;reject&quot;</p>

    <p class="text-gray-300">Here, we may assume that &quot;reject&quot; is a default message encoded as an \`-bit string, or we may assume that we allow the decryption algorithm to return a special value that is not in the message space (for our purposes, it does not matter).</p>

    <p class="text-gray-300">The reader may easily verify that decryption &quot;undoes&quot; encryption.</p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8">7.3 Security Analysis</h3>

    <p class="text-gray-300">We now give a security proof as a sequence of games. Because it would be rather unwieldy, we do not give an explicit, low-level, algorithmic description of these games, but it should by now be clear that this could be done in principle. Rather, we give only a high-level description of Game 0, and brief descriptions of the modifications between successive games. <strong>Game 0.</strong> This is the original attack game with respect to a given efficient adversary A. At the beginning of the game, the challenger computes</p>

    <p class="text-gray-300"><span class="math">$s \\stackrel{\\varepsilon}{\\leftarrow} S, \\ k \\stackrel{\\varepsilon}{\\leftarrow} K, \\ b \\stackrel{\\varepsilon}{\\leftarrow} \\{0,1\\}.</span>$</p>

    <p class="text-gray-300">We assume that A makes exactly q encryption queries, where for  <span class="math">i=1,\\ldots,q</span> , the ith query is  <span class="math">(m_{i0},m_{i1})</span> , and the corresponding ciphertext is  <span class="math">\\psi_i=(x_i,c_i,t_i)</span> , which is computed by the challenger by encrypting  <span class="math">m_{ib}</span>  under the key (s,k). Also, we assume that the adversary makes exactly q' decryption queries, where for  <span class="math">j=1,\\ldots,q&#x27;</span> , the jth such query is  <span class="math">\\psi&#x27;_j=(x&#x27;_j,c&#x27;_j,t&#x27;_j)</span> , which the challenger decrypts under the key (s,k). For  <span class="math">j=1,\\ldots,q&#x27;</span> , let us define  <span class="math">Q_j</span>  to be the number of encryption queries made prior to the jth decryption query. We assume all queries are syntactically well formed, and that A never submits  <span class="math">\\psi&#x27;_j</span>  for decryption with  <span class="math">\\psi&#x27;_j=\\psi_i</span>  for  <span class="math">i\\leq Q_j</span> . At the end of the game, the adversary outputs  <span class="math">\\hat{b}\\in\\{0,1\\}</span> . Let  <span class="math">S_0</span>  be the event that  <span class="math">b=\\hat{b}</span>  in this game.</p>

    <p class="text-gray-300"><strong>Game 1.</strong> This is the same as Game 0, except that we modify the way the challenger responds to decryption queries. Namely, we have the challenger respond with &quot;reject&quot; to all submitted ciphertexts, without performing any of the steps of the decryption algorithm.</p>

    <p class="text-gray-300">Let  <span class="math">S_1</span>  be the event that  <span class="math">b = \\hat{b}</span>  in Game 1. Let F be the event in Game 1 that for some  <span class="math">j = 1, \\ldots, q&#x27;</span> , we have  <span class="math">H_k(x&#x27;_j \\mid\\mid c&#x27;_j) = t&#x27;_j</span> . It is clear that Games 0 and 1 proceed identically unless F occurs (as usual, both games are understood to be defined on the same underlying probability space); therefore, by the Difference Lemma, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - \\Pr[S_1]| \\le \\Pr[F]. \\tag{16}</span>$</p>

    <p class="text-gray-300">It remains to bound Pr[F]. We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F] \\le q&#x27; \\cdot \\epsilon_{\\rm uf},\\tag{17}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon_{\\text{uf}}</span>  is the UF-advantage of some efficient adversary B, which by assumption is negligible.</p>

    <p class="text-gray-300">To prove this, we first make the following observations. Consider the jth decryption query  <span class="math">\\psi&#x27;_j = (x&#x27;_j, c&#x27;_j, t&#x27;_j)</span> . There are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(x&#x27;_j, c&#x27;_j) = (x_i, c_i)</span>  for some  <span class="math">i = 1, ..., Q_j</span> . In this case, as  <span class="math">\\psi&#x27;_j \\neq \\psi_i</span> , we must have  <span class="math">t&#x27;_j \\neq t_i</span> , and since  <span class="math">t_i = H_k(x_i \\mid\\mid c_i)</span> , we must have  <span class="math">t&#x27;_j \\neq H_k(x&#x27;_j \\mid\\mid c&#x27;_j)</span> .</li>
      <li><span class="math">(x&#x27;_j, c&#x27;_j) \\neq (x_i, c_i)</span>  for all  <span class="math">i = 1, ..., Q_j</span> . In this case, if  <span class="math">t&#x27;_j = H_k(x&#x27;_j \\mid\\mid c&#x27;_j)</span> , the adversary has effectively predicted the value of  <span class="math">H_k</span>  at a new point, and we can use him to build an adversary with a corresponding UF-advantage.</li>
    </ul>

    <p class="text-gray-300">Based on the above discussion, we can easily construct an efficient adversary B with UF-advantage at least  <span class="math">\\Pr[F]/q&#x27;</span> , which proves (17). We describe B as an oracle machine that makes use of A:</p>

    <pre><code class="language-text">Oracle machine B^{\\mathcal{O}}
s \\stackrel{\\ell}{\\leftarrow} S, b \\stackrel{\\ell}{\\leftarrow} \\{0,1\\}
j^* \\stackrel{\\ell}{\\leftarrow} \\{1,\\ldots,q&#x27;\\}
Run adversary A:

Upon the ith encryption query (m_{i0},m_{i1}) do:
x_i \\stackrel{\\ell}{\\leftarrow} \\{0,1\\}^n, c_i \\leftarrow F_s(x_i) \\oplus m_{ib}, t_i \\leftarrow \\mathcal{O}(x_i \\mid\\mid c_i)
give \\psi_i = (x_i,c_i,t_i) to A

Upon the jth decryption query \\psi&#x27;_j = (x&#x27;_j,c&#x27;_j,t&#x27;_j) do:\\nif j &lt; j^* then
give &quot;reject&quot; to A\\nelse - when j = j^*
output y^* = x&#x27;_j \\mid\\mid c&#x27;_j and t^* = t&#x27;_j
halt
</code></pre>

    <p class="text-gray-300">Let us analyze B when given oracle access to  <span class="math">H_k</span> , for randomly chosen  <span class="math">k \\in K</span> . Let  <span class="math">\\psi&#x27;_1, \\ldots, \\psi&#x27;_{q&#x27;}</span>  denote the decryption queries that would be processed by B if we let it run without halting it at the  <span class="math">j^*</span> th such query. The value of  <span class="math">(\\psi&#x27;_1, \\ldots, \\psi&#x27;_{q&#x27;})</span>  is completely determined by the coins of A, along with the values s, b, and k, and as such, is independent of  <span class="math">j^*</span> . Let  <span class="math">\\tilde{F}</span>  be the event that  <span class="math">H_k(x&#x27;_j \\mid\\mid c&#x27;_j) = t&#x27;_j</span>  for some  <span class="math">j = 1, \\ldots, q&#x27;</span> . Then by construction, we have  <span class="math">\\Pr[\\tilde{F}] = \\Pr[F]</span> . If  <span class="math">\\tilde{F}</span>  occurs, we can define  <span class="math">j_0</span>  to be the least j such that  <span class="math">H_k(x&#x27;_j \\mid\\mid c&#x27;_j) = t&#x27;_j</span> . We know that  <span class="math">x&#x27;_{j_0} \\mid\\mid c&#x27;_{j_0}</span>  is not among the queries made to the oracle for  <span class="math">H_k</span>  in processing the encryption queries made prior to processing decryption query  <span class="math">j_0</span> . Therefore, the UF-advantage of B is at least  <span class="math">\\Pr[\\tilde{F} \\land j^* = j_0]</span> , and by independence, the latter probability is equal to  <span class="math">\\Pr[F]/q&#x27;</span> .</p>

    <p class="text-gray-300"><strong>Game 2.</strong> In this game, we replace  <span class="math">F_s</span>  by a truly random function f. To save a step, let us implement f by using a &quot;faithful gnome.&quot; To do this, the challenger makes the following computations on the ith encryption query  <span class="math">(m_{i0}, m_{i1})</span>  to obtain the ciphertext  <span class="math">\\psi_i = (x_i, c_i, t_i)</span> :</p>

    <p class="text-gray-300"><span class="math">$x_i \\stackrel{\\notin}{\\leftarrow} \\{0,1\\}^n</span>$
,  <span class="math">P_i \\stackrel{\\notin}{\\leftarrow} \\{0,1\\}^\\ell</span>
if  <span class="math">x_i = x_j</span>  for some  <span class="math">j &lt; i</span>  then  <span class="math">p_i \\leftarrow p_j</span>  else  <span class="math">p_i \\leftarrow P_i</span>
<span class="math">c_i \\leftarrow p_i \\oplus m_{ib}, t_i \\leftarrow H_k(x_i \\mid\\mid c_i)</span></p>

    <p class="text-gray-300">Let  <span class="math">S_2</span>  be the event that  <span class="math">b = \\hat{b}</span>  in Game 2. By a familiar argument, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_1] - \\Pr[S_2]| = \\epsilon_{\\text{prf}},\\tag{18}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon_{\\text{prf}}</span>  is the PRF-advantage of some efficient adversary, and hence by assumption, negligible. Indeed, the following adversary D does the job:</p>

    <p class="text-gray-300">Oracle machine D<sup>O</sup></p>

    <p class="text-gray-300"><span class="math">$k \\stackrel{\\mbox{\\tiny </span>\\psi<span class="math">}}{\\leftarrow} S, \\ b \\stackrel{\\mbox{\\tiny </span>\\psi<span class="math">}}{\\leftarrow} \\{0,1\\}</span>$</p>

    <p class="text-gray-300">Run adversary A:</p>

    <p class="text-gray-300">Upon the ith encryption query (mi0, mi1) do:</p>

    <p class="text-gray-300"><span class="math">$x_i \\stackrel{\\ \\leftarrow}{\\leftarrow} \\{0,1\\}^n, c_i \\leftarrow \\mathcal{O}(x_i) \\oplus m_{ib}, t_i \\leftarrow H_k(x_i \\mid\\mid c_i)</span>$
give  <span class="math">\\psi_i = (x_i, c_i, t_i)</span>  to  <span class="math">A</span></p>

    <p class="text-gray-300">Upon the jth decryption query &psi; 0 <sup>j</sup> = (x 0 j , c0 j , t0 j ) do: give &quot;reject&quot; to A</p>

    <p class="text-gray-300">When A outputs &circ;b do:</p>

    <p class="text-gray-300">if b = &circ;b then output 1 else output 0 halt</p>

    <p class="text-gray-300">Game 3. Now, as usual, we make our gnome &quot;forgetful,&quot; and modify the way the challenger responds to encryption queries, so that it does not check for collisions among the xi-values:</p>

    <p class="text-gray-300"><span class="math">$x_i \\stackrel{\\notin}{\\leftarrow} \\{0,1\\}^n, P_i \\stackrel{\\notin}{\\leftarrow} \\{0,1\\}^\\ell</span>$</p>

    <p class="text-gray-300"><span class="math">$p_i \\leftarrow P_i</span>$</p>

    <p class="text-gray-300"><span class="math">$c_i \\leftarrow p_i \\oplus m_{ib}, t_i \\leftarrow H_k(x_i \\mid\\mid c_i)</span>$</p>

    <p class="text-gray-300">Let S<sup>3</sup> be the event that b = &circ;b in Game 3. Let F <sup>0</sup> be the event in Game 3 that x<sup>i</sup> = x<sup>j</sup> for some i 6= j. It is clear that Games 2 and 3 proceed identically unless F <sup>0</sup> occurs, and so by the Difference Lemma, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_2] - \\Pr[S_3]| \\le \\Pr[F&#x27;]. \\tag{19}</span>$</p>

    <p class="text-gray-300">Moreover, since the xi-values are independent, it is clear that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F&#x27;] \\le \\frac{q^2}{2} 2^{-n},</span>$
(20)</p>

    <p class="text-gray-300">which is negligible.</p>

    <p class="text-gray-300">Finally, since in Game 3, each p<sup>i</sup> is essentially a one-time pad, it is clear that b and &circ;b are independent, and so</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_3] = 1/2.</span>$
(21)</p>

    <p class="text-gray-300">Combining (16), (17), (18), (19), (20), and (21), we see that the CCA-advantage of A is</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - 1/2| \\le q&#x27; \\epsilon_{\\text{uf}} + \\epsilon_{\\text{prf}} + \\frac{q^2}{2} 2^{-n},</span>$</p>

    <p class="text-gray-300">which is negligible.</p>

    <p class="text-gray-300">In this section, we analyze the security of the &quot;hashed&quot; ElGamal encryption scheme, discussed in &sect;3.4, in the random oracle model [BR93]. Here, we model the hash function H<sup>k</sup> : G &rarr; {0, 1} \` as a random oracle; that is, for the purposes of analysis, the function H<sup>k</sup> is modeled as a truly random function, to which both the adversary and the challenger have oracle (i.e., &quot;black box&quot;) access. Thus, for any particular &lambda; &isin; G, the value of Hk(&lambda;) may be obtained only by giving the value &lambda; to a special &quot;hash oracle,&quot; who responds with the value Hk(&lambda;). In this model, there is no real reason to view the hash function as keyed, but we will continue to do so, just to maintain consistency with the notation in &sect;3.4.</p>

    <p class="text-gray-300">Hashed ElGamal encryption is semantically secure in the random oracle model under the Computational Diffie-Hellman (CDH) assumption. This is the assumption that given &gamma; <sup>x</sup> and &gamma; y , it is hard to compute &gamma; xy. Here, x and y are random elements of Zq.</p>

    <p class="text-gray-300">The CDH assumption is more precisely formulated as follows. Let B be an algorithm that takes as input a pair of group elements, and outputs a group element. We define the CDH-advantage of B to be</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x, y \\stackrel{\\phi}{\\leftarrow} \\mathbb{Z}_q : B(\\gamma^x, \\gamma^y) = \\gamma^{xy}].</span>$</p>

    <p class="text-gray-300">The CDH assumption (for G) is the assumption that any efficient algorithm's CDHadvantage is negligible.</p>

    <p class="text-gray-300">Clearly, the DDH assumption implies the CDH assumption, although the converse need not necessarily hold. One awkward aspect of the CDH assumption is that if the DDH assumption is indeed true, then we cannot efficiently verify the correctness of the output of an algorithm that attempts to compute &gamma; xy given &gamma; <sup>x</sup> and &gamma; y . Because of this, in our security proof, we shall actually consider a slightly different formulation of the CDH assumption. Let C be an algorithm that takes as input a pair of group elements, and outputs a list of group elements. We define the list CDH-advantage of C to be</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x, y \\xleftarrow{\\phi} \\mathbb{Z}_q : \\gamma^{xy} \\in C(\\gamma^x, \\gamma^y)].</span>$</p>

    <p class="text-gray-300">It is clear that the CDH assumption implies that any efficient algorithm's list CDHadvantage is negligible. Indeed, if C has non-negligible list CDH advantage, then we can build an algorithm B with non-negligible CDH advantage as follows: algorithm B simply runs algorithm C and then outputs one group element, chosen at random from among those in C's output list.</p>

    <p class="text-gray-300">We now give a security proof as a sequence of games. As in the previous section, we only give a high-level description of Game 0, and describe only the differences between successive games.</p>

    <p class="text-gray-300">Game 0. This is the original attack game with respect to a given efficient adversary A. At the beginning of the game, the challenger computes x &larr;<sup>c</sup><sup>|</sup> Z<sup>q</sup> and &alpha; &larr; &gamma; x , and gives &alpha; to A. Conceptually, the challenger has access to an oracle for the random function Hk.</p>

    <p class="text-gray-300">Next, A makes a sequence of queries to the challenger. There are two types of queries:</p>

    <p class="text-gray-300">hash oracle query: A presents the challenger with &lambda; &isin; G, who responds to A's query with the value Hk(&lambda;) &isin; {0, 1} \` .</p>

    <p class="text-gray-300">encryption query: A submits two messages m0, m<sup>1</sup> &isin; {0, 1} \` to the challenger, who responds to A's query with the value (&beta;, v), computed as follows:</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\ \\ }{\\leftarrow} \\{0,1\\}, \\ y \\stackrel{\\ \\ }{\\leftarrow} \\mathbb{Z}_q, \\ \\beta \\leftarrow \\gamma^y, \\ \\delta \\leftarrow \\alpha^y, \\ h \\leftarrow H_k(\\delta), \\ v \\leftarrow h \\oplus m_b.</span>$</p>

    <p class="text-gray-300">Moreover, while the adversary may make any number of hash oracle queries, he may make at most one encryption query. Without loss of generality, we assume the adversary makes exactly one encryption query.</p>

    <p class="text-gray-300">At the end of the game, A outputs &circ;b &isin; {0, 1}. Let S<sup>0</sup> be the event that b = &circ;b in Game 0.</p>

    <p class="text-gray-300">Game 1. Here, we make several conceptual changes. First, we make the challenger generate the random value y &isin; Z<sup>q</sup> at the beginning of the game. Second, at the beginning of the game, the challenger also computes h <sup>+</sup> &larr; { <sup>c</sup><sup>|</sup> 0, 1} \` . Moreover, we modify the way the challenger responds to queries as follows:</p>

    <p class="text-gray-300">hash oracle query: Given a query &lambda; &isin; G, if &lambda; = &alpha; y , respond with h <sup>+</sup>, otherwise, respond with Hk(&lambda;).</p>

    <p class="text-gray-300">encryption query: Given a query m0, m<sup>1</sup> &isin; {0, 1} \` , respond with (&beta;, v), computed as follows:</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\protect}{\\leftarrow} \\{0,1\\}, \\ \\beta \\leftarrow \\gamma^y, \\ v \\leftarrow h^+ \\oplus m_b.</span>$</p>

    <p class="text-gray-300">Let S<sup>1</sup> be the event that b = &circ;b in Game 1. It should be clear that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_1] = \\Pr[S_0]. \\tag{22}</span>$</p>

    <p class="text-gray-300">Indeed, all we have really done is to effectively replace the value of Hk(&alpha; y ) by h <sup>+</sup> consistently throughout the game, both in the hash oracle queries and in the encryption query.</p>

    <p class="text-gray-300">Game 2. This is the same as Game 1, except that the challenger now reverts to the rule used for responding to hash oracle queries in Game 0. That is, given a hash oracle query &lambda; &isin; G, the challenger now simply responds with Hk(&lambda;). However, the challenger responds to the encryption query just as in Game 1; in particular, the value h <sup>+</sup> is only used to &quot;'mask&quot; m<sup>b</sup> in the encryption query, and the value y is only used to compute &beta; in the encryption query.</p>

    <p class="text-gray-300">Let S<sup>2</sup> be the event that b = &circ;b in Game 2.</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_2] = 1/2.</span>$
(23)</p>

    <p class="text-gray-300">This follows directly from the fact that in Game 2, h <sup>+</sup> is effectively used as a one-time pad. Now let F be the event that the adversary makes an encryption oracle query &lambda; in Game 2 with &lambda; = &alpha; y . It is evident that Games 1 and 2 proceed identically unless F occurs. Therefore, by the Difference Lemma, we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_1] - \\Pr[S_2]| \\le \\Pr[F]. \\tag{24}</span>$</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F] = \\epsilon_{\\text{lcdh}},\\tag{25}</span>$</p>

    <p class="text-gray-300">where lcdh is the list CDH-advantage of some efficient algorithm C (which is negligible under the CDH assumption). Algorithm C runs as follows. It takes as input &alpha; = &gamma; <sup>x</sup> and &beta; = &gamma; y . It then interacts with A, playing the role of the challenger in Game 2, but using the given values of &alpha; and &beta;. At game's end, C outputs the list of all hash oracle queries made by A. Some implementation notes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The challenger in Game 2 never needs the values of x and y except to compute &alpha; and &beta;; therefore, algorithm C does not need either x or y.</li>
      <li>Algorithm C implements H<sup>k</sup> using the usual &quot;gnome&quot; implementation. Note that the only queries made to H<sup>k</sup> in Game 2 are by the challenger in response to the adversary's hash oracle queries.</li>
    </ul>

    <p class="text-gray-300">It should be clear that the probability that C's output list contains &alpha; y is precisely equal to Pr[F].</p>

    <p class="text-gray-300">Combining (22), (23), (24), and (25), we obtain</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - 1/2| \\le \\epsilon_{\\mathrm{lcdh}},</span>$</p>

    <p class="text-gray-300">which is negligible.</p>

    <p class="text-gray-300">Thanks to Alex Dent and Antonio Nicolosi for their comments on preliminary drafts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[AFP04] M. Abdalla, P.-A. Fouque, and D. Pointcheval. Password-based authenticated key exchange in the three party setting. Available at http://eprint.iacr. org/2004/233, 2004. To appear, PKC 2005.</p></li>
      <li><p class="text-gray-300">[BCP02a] E. Bresson, O. Chevassut, and D. Pointcheval. Dynamic group Diffie-Hellman key exchange under standard assumptions. In Advances in Cryptology&ndash; Eurocrypt 2002, pages 321&ndash;336, 2002. Full version avalable at http://www. di.ens.fr/~pointche.</p></li>
      <li><p class="text-gray-300">[BCP02b] E. Bresson, O. Chevassut, and D. Pointcheval. Group Diffie-Hellman key exchange secure against dictionary attack. In Advances in Cryptology&ndash;Asiacrypt 2002, pages 497&ndash;514, 2002. Full version avalable at http://www.di.ens.fr/ ~pointche.</p></li>
      <li><p class="text-gray-300">[BCP03] E. Bresson, O. Chevassut, and D. Pointcheval. Security proofs for an efficient password-based key exchange. In Proc. 10th ACM Conference on Computer and Communications Security, pages 241&ndash;250, 2003. Full version avalable at http://www.di.ens.fr/~pointche.</p></li>
      <li><p class="text-gray-300">[BG89] M. Bellare and S. Goldwasser. New paradigms for digital signatures andd message authentication based on non-interactive zero knowledge proofs. In Advances in Cryptology&ndash;Crypto '89, pages 194&ndash;211, 1989.</p></li>
      <li><p class="text-gray-300">[BK04] D. Boneh and J. Katz. Improved efficiency for CCA-secure cryptosystems built using identity-based encryption. Available at http://eprint.iacr.org/ 2004/261, 2004. To appear, CT-RSA 2005.</p></li>
      <li><p class="text-gray-300">[BR93] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. In First ACM Conference on Computer and Communications Security, pages 62&ndash;73, 1993.</p></li>
      <li><p class="text-gray-300">[BR04] M. Bellare and P. Rogaway. The game-playing technique. Available at http: //eprint.iacr.org/2004/331, 2004.</p></li>
      <li><p class="text-gray-300">[CPP04] D. Catalano, D. Pointcheval, and T. Pornin. IPAKE: Isomorphisms for password-based authenticated key exchange. In Advances in Cryptology&ndash; Crypto 2004, pages 477&ndash;493, 2004. Full version at www.di.ens.fr/~pointche.</p></li>
      <li><p class="text-gray-300">[CS02] R. Cramer and V. Shoup. Universal hash proofs and a paradigm for adaptive chosen ciphertext secure public key encryption. In Advances in Cryptology&ndash; Eurocrypt 2002, pages 45&ndash;64, 2002. Full version at http://eprint.iacr.org/ 2001/085.</p></li>
      <li><p class="text-gray-300">[CS03a] J. Camenisch and V. Shoup. Practical verifiable encryption and decryption of discrete logarithms. In Advances in Cryptology&ndash;Crypto 2003, pages 126&ndash;144, 2003. Full version at http://eprint.iacr.org/2002/161.</p></li>
      <li><p class="text-gray-300">[CS03b] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. SIAM Journal on Computing, 33:167&ndash;226, 2003. Preliminary version at http: //eprint.iacr.org/2001/108.</p></li>
      <li><p class="text-gray-300">[Den03] A. Dent. A designer's guide to KEMs. In Proc. 9th IMA Conf. on Coding and Cryptography (LNCS 2898), 2003. Full version at http://eprint.iacr.org/ 2002/174.</p></li>
      <li><p class="text-gray-300">[DF03] Y. Dodis and N. Fazio. Public key trace and revoke scheme secure against adaptive chosen ciphertext attack. In Proc. 2003 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2003), 2003. Full version at http://eprint.iacr.org/2003/095.</p></li>
      <li><p class="text-gray-300">[DFJW04] Y. Dodis, M. J. Freedman, S. Jarecki, and S. Walfish. Versatile padding schemes for joint signature and encryption. In Proc. 11th ACM Conference on Computer and Communications Security, 2004. Full verssion at http://eprint.iacr.org/2004/020.</p></li>
      <li><p class="text-gray-300">[DFKY03] Y. Dodis, N. Fazio, A. Kiayias, and M. Yung. Scalable public-key tracing and revoking. In Proc. 22nd ACM Symposium on Principles of Distributed Computing, 2003. Full version at http://eprint.iacr.org/2004/160.</p></li>
      <li><p class="text-gray-300">[FOPS04] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is secure under the RSA assumption. Journal of Cryptology, 17(2):81&ndash;104, 2004.</p></li>
      <li><p class="text-gray-300">[GaPMV03] D. Galindo, S. Mart&acute;&#305;n abd P. Morillo, and J. L. Villar. Fujisaki-Okamoto IND-CCA hybrid encryption revisted, 2003. Available at http://eprint. iacr.org/2003/107; to appear, Int. J. Inf. Secur.</p></li>
      <li><p class="text-gray-300">[GGM86] O. Goldreich, S. Goldwasser, and S. Micali. How to construct random functions. Journal of the ACM, 33:210&ndash;217, 1986.</p></li>
      <li><p class="text-gray-300">[GM84] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28:270&ndash;299, 1984.</p></li>
      <li><p class="text-gray-300">[Gol01] O. Goldreich. Foundations of Cryptography: Basic Tools. Cambridge University Press, 2001.</p></li>
      <li><p class="text-gray-300">[GS04] R. Gennaro and V. Shoup. A note on an encryption scheme of Kurosawa and Desmedt. Available at http://eprint.iacr.org/2004/194, 2004.</p></li>
      <li><p class="text-gray-300">[IZ89] R. Impagliazzo and D. Zuckermann. How to recycle random bits. In 30th Annual Symposium on Foundations of Computer Science, pages 248&ndash;253, 1989.</p></li>
      <li><p class="text-gray-300">[KD04] K. Kurosawa and Y. Desmedt. A new paradigm of hybrid encryption scheme. In Advances in Cryptology&ndash;Crypto 2004, pages 426&ndash;442, 2004. Full version at http://kuro.cis.ibaraki.ac.jp/~kurosawa.</p></li>
      <li><p class="text-gray-300">[KR96] J. Kilian and P. Rogaway. How to protect DES against exhaustive key search. In Advances in Cryptology&ndash;Crypto '96, pages 252&ndash;267, 1996.</p></li>
      <li><p class="text-gray-300">[LR88] M. Luby and C. Rackoff. How to construct pseudorandom permutaations from pseudorandom functions. SIAM Journal on Computing, 17(2):373&ndash;386, 1988.</p></li>
      <li><p class="text-gray-300">[NR99] M. Naor and O. Reingold. On the construction of pseudo-random permutations: Luby-Rackoff revisited. Journal of Cryptology, 12(1):29&ndash;66, 1999.</p></li>
      <li><p class="text-gray-300">[Poi04] D. Pointcheval. Provable security for public key schemes, 2004. Available at http://www.di.ens.fr/~pointche.</p></li>
      <li><p class="text-gray-300">[PP03] D. H. Phan and D. Pointcheval. Chosen ciphertext security without redundancy. In Advances in Cryptology&ndash;Asiacrypt 2003, pages 1&ndash;18, 2003. Full version avalable at http://www.di.ens.fr/~pointche.</p></li>
      <li><p class="text-gray-300">[Sho00] V. Shoup. Using hash functions as a hedge against chosen ciphertext attack. In Advances in Cryptology&ndash;Eurocrypt 2000, pages 275&ndash;288, 2000.</p></li>
      <li><p class="text-gray-300">[Sho01] V. Shoup. A proposal for an ISO standard for public key encryption. Available at http://eprint.iacr.org/2001/112, 2001.</p></li>
      <li><p class="text-gray-300">[Sho02] V. Shoup. OAEP reconsidered. Journal of Cryptology, 15(4):223&ndash;249, 2002. Extended abstract in Crypto 2001. Available online at http://eprint.iacr. org/2000/060.</p></li>
      <li><p class="text-gray-300">[SS00] T. Schweinberger and V. Shoup. ACE: The Advanced Cryptographic Engine. Available at http://eprint.iacr.org/2000/022, 2000.</p></li>
    </ul>

    <p class="text-gray-300">[SWP04] R. Steinfeld, H. Wang, and J. Pieprzyk. Efficient extension of standard Schnorr/RSA signatures into universal designated-verifier signatures. In Proc. 2004 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2004), pages 86&ndash;100, 2004. Full version at http://eprint.iacr. org/2003/193.</p>

    </section>
`;
---

<BaseLayout title="Sequences of games: a tool for taming complexity in security... (2004/332)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/332
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="sequences-of-games-a-tool-for-taming-complexity-in-security-2004" />
  </article>
</BaseLayout>
