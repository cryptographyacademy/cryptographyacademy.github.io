---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1565';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Baloo: Nearly Optimal Lookup Arguments';
const AUTHORS_HTML = 'Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, Carla Ràfols';

const CONTENT = `    <p class="text-gray-300">IACR Communications in Cryptology Vol. 0, No. 0, 38 pages.</p>

    <p class="text-gray-300">Arantxa Zapico<span class="math">^{a}</span>, Ariel Gabizon<span class="math">^{3}</span>, Dmitry Khovratovich<span class="math">^{1}</span>, Mary Maller<span class="math">^{1}</span> and Carla Ràfols<span class="math">^{4}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Ethereum Foundation <span class="math">^{2}</span> Zeta Function Technologies <span class="math">^{3}</span> Universitat Pompeu Fabra</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract.</h2>

    <p class="text-gray-300">We present Baloo, a protocol for lookup tables where the prover work is linear on the number of lookups and independent of the table size. Baloo is built over previous lookup arguments, and the framework for SNARKs from Ràfols and Zapico (CRYPTO 21).</p>

    <p class="text-gray-300">Our protocol supports <em>commit-and-prove expansions</em>: the prover selects the subtable containing the elements used in the lookup, that is unknown to the verifier, commits to it and later proves its relation with the committed elements. This feature makes Baloo especially suitable for proving input-output relations on hash functions, and in particular to instantiate the Ethereum Virtual Machine (EVM).</p>

    <p class="text-gray-300"><strong>Keywords</strong>: Public Key Cryptography · SNARKs · lookups</p>

    <p class="text-gray-300">The rise of succinct proving systems in the recent decade has brought us close to one of the Holy Grails of computer science. Namely, being able to prove a large computation while spending not much more time on the proof than on the computation itself. We know how to make a proof only a handful of bytes large, and how to make the verifier run in a millisecond – but the prover time remains a bottleneck.</p>

    <p class="text-gray-300">In recent years, there has been increasing focus on improving prover efficiency in cryptographic protocols. A key technique that has gained attention is the use of lookups table arguments, which allow heavy computations to be replaced by retrieving values from pre-defined tables, such as caches or databases.</p>

    <p class="text-gray-300">In lookup table arguments, prover and verifier each have as input some representation of a table <span class="math">\\vec{c}</span> and a vector <span class="math">\\vec{a}</span>, and the former aims to convince the latter that all elements of <span class="math">\\vec{a}</span> are also present in <span class="math">\\vec{c}</span>. When this is the case, we say that <span class="math">\\vec{a}</span> is a <em>lookup</em> on <span class="math">\\vec{c}</span>. In the settings we consider in this work, we have <span class="math">\\vec{c} \\in \\mathbb{F}^N</span> and <span class="math">\\vec{a} \\in \\mathbb{F}^m</span>, with <span class="math">m &amp;lt;&amp;lt; N</span>. We also assume that the table <span class="math">\\vec{c}</span> is public, and its representation can be precomputed and reused in several prover-verifier interactions. For instance, <span class="math">\\vec{c}</span> can contain all field elements within a range, or input-output pairs for some heavy public computation.</p>

    <p class="text-gray-300">This approach can significantly speed up certain operations, such as efficient regular <span class="math">(2^n)</span> integer arithmetic and bit-oriented algorithms, like modern hash functions. Until recently, the most efficient construction for proving lookups was Plookup [GW20], which constrained prover time to be linear in the size of the lookup table, <span class="math">N</span>, limiting its use with</p>

    <p class="text-gray-300">E-mail: arantxa.zapico@ethereum.org (Arantxa Zapico), ariel.gabizon@gmail.com (Ariel Gabizon), khovratovich@gmail.com (Dmitry Khovratovich), mary.maller@ethereum.org (Mary Maller), carla.rafols@upf.edu (Carla Ràfols)</p>

    <p class="text-gray-300"><span class="math">^{a}</span>This work was done while Arantxa Zapico was a PhD student at Universitat Pompeu Fabra, funded by Protocol Labs PhD Fellowship PL-RGP1-2021-062.</p>

    <p class="text-gray-300">large tables. However, in 2022, a second breakthrough lead by Caulk <em>[ZBK+22, x21]</em> appears as the first method to prove <span class="math">m</span> lookups in more reasonable <span class="math">O(m^{2})</span> time, i.e. independent of <span class="math">N</span>, after a pre-processing step of size <span class="math">O(N\\log N)</span>.</p>

    <p class="text-gray-300">At the same time, a number of computationally powerful blockchains, with Ethereum being the most prominent example, barely withstand the demand for a higher transaction rate and computational bandwidth. One bold attempt to get consensus on the computation without every node repeating work is to use a SNARK as a certificate of correctness. However, efforts to build a prover for Ethereum’s virtual machine <em>[x1, x10, x16, x22, x26]</em> have been hindered by the cost of proving the Keccak hash function, even if a prover is lookup-enhanced. As Keccak is used in the Merkle tree of the blockchain state, a proof for all state transitions in one block results in tens of millions of lookups — an amount insurmountable by Caulk.</p>

    <p class="text-gray-300">Baloo is the first lookup argument to prove <span class="math">m</span> lookups in quasi-linear time. It is tailored to prime fields suitable for KZG commitments and opening proofs <em>[x20]</em>, which are around 256-bit large, and thus to computations defined on such domains. The prover complexity is quasi-linear in the field and linear in the group. This is thanks to a number of new techniques designed around proving statements over sets that are not multiplicative subgroups (where we cannot use Fast Fourier Transforms).</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Related Work</h2>

    <p class="text-gray-300">In Fig. 1 we compare the concrete costs of the closest schemes to this work (that is, use univariate polynomials and are pairing-based), when compiled using the KZG polynomial commitment scheme <em>[x20]</em>. Plookup <em>[x13]</em> and Halo2 <em>[x6]</em> require no preprocessing but the prover work in the group is quasi-linear in the size of the table. They can be compiled using any polynomial commitment scheme including solutions that do not require pairings. Caulk <em>[ZBK+22]</em> introduced the first solution with prover work that is sublinear in the size of the table by using preprocessing, but they incur a quadratic cost in the number of lookups. Posen and Kattis introduced Caulk+<em>[x21]</em>, an improvement over Caulk that leads to a table-independent prover, still quadratic on number of lookups. Flookup <em>[x12]</em> reduced the prover complexity to quasi-linear on the lookups while retaining a table-independent prover. However, their techniques rely on committing to a table as roots of a polynomial instead of coefficients. This means their commitments are not homomorphic, which limits the applicability of their solution to stand-alone set membership proofs and makes it challenging to use their lookup to speed up SNARK provers (see Section C). We discuss concurrent and follow-up work at the end of this section.</p>

    <p class="text-gray-300">We provide an implementation of B<span class="math">aloo</span> and compare its performance with those protocols that have publicly available implementations in Appendix D.</p>

    <p class="text-gray-300">Other approaches, such as discrete-log based <em>[x5, x14, BCC+15, BCG+18]</em> require no trusted setup but incur a linear verifier. Bootle et al. <em>[BCG+18]</em> initially suggested the use of lookup arguments to improve the prover time in proving machine computations. Their solution targetted the TinyRAM virtual machine <em>[BCG+13]</em>. Campanelli et al. <em>[CFH+22]</em> present also a scheme for position-hiding linkability of RSA accumulators for large prime numbers and Pedersen commitments. Concretely they achieve good efficiency: their proof size is constant and their proving times do not depend on the size of the accumulator. Further, they can support larger lookup tables than B<span class="math">aloo</span> because they are not constrained by the size of their setup. However, their scheme crucially relies on groups of hidden order such as a trusted RSA modulus or class groups.</p>

    <p class="text-gray-300">Lookup arguments are often used in the context of key-value lookups in verifiable registries <em>[x10]</em>. Multiple works <em>[TBP+19, MKL+20, HHK+21, TFBT21]</em> explore how to ensure the correctness of the table that is used in verifiable registries. Campanelli et</p>

    <p class="text-gray-300">Table 1: Cost comparison of our scheme with other pairing-based lookups.  <span class="math">N</span>  is the size of the table and  <span class="math">m</span>  the size of the set to be opened. The preprocessing costs are given in the number of group operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Preproc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plookup [GW20]</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">5G1,9F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Halo2 [BGH19]</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">6G1,5F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk [ZBK+22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">14G1, 1G2, 4F</td>

            <td class="px-3 py-2 border-b border-gray-700">15m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m2 + m log(N))</td>

            <td class="px-3 py-2 border-b border-gray-700">4P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk+ [PK22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">7G1, 1G2, 2F</td>

            <td class="px-3 py-2 border-b border-gray-700">8m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m2)</td>

            <td class="px-3 py-2 border-b border-gray-700">3P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Flookup [GK22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">7G1, 1G2, 4F</td>

            <td class="px-3 py-2 border-b border-gray-700">6m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log2m)</td>

            <td class="px-3 py-2 border-b border-gray-700">3P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cq [EFG22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">8G1, 3F</td>

            <td class="px-3 py-2 border-b border-gray-700">8m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">5P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Baloo</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">12G1, 1G2, 4F</td>

            <td class="px-3 py-2 border-b border-gray-700">14m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log2m)</td>

            <td class="px-3 py-2 border-b border-gray-700">5P</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">al. [CEO22] demonstrate how homomorphic commitments can be used to build key-value lookups. Their solution is zero-knowledge, does not require a trusted setup or pairings, and uses techniques similar to Section C. However, their prover work is linear on the size of the table. Agrawal and Raghuraman [AR20] build key-value lookups using hidden order groups. Campanelli et al.  <span class="math">\\mathrm{[CFG^{+}20]}</span>  use lookup arguments to construct verifiable decentralized storage and achieve a sublinear prover assuming preprocessing. Benarroch et al.  <span class="math">\\mathrm{[BCF^{+}21]}</span>  discuss commit-and-prove set membership proofs, which is a useful primitive for constructing modular zero-knowledge proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Concurrent and follow-up work. Eagen et al. [EFG22] introduce  <span class="math">cq</span> , a lookup argument where prover work is  <span class="math">O(m)</span>  in the group and  <span class="math">O(m\\log m)</span>  in the field, for  <span class="math">m</span>  lookups on tables of any size  <span class="math">N</span> . To prove that for a table  <span class="math">\\vec{c} \\in \\mathbb{F}^N</span>  and vector  <span class="math">\\vec{a} \\in \\mathbb{F}^m</span> , it is true that all the elements in  <span class="math">\\vec{a}</span>  are also in  <span class="math">\\vec{c}</span> , Baloo creates an intermediate shorter table  <span class="math">\\vec{t} \\in \\mathbb{F}^k</span>  with  <span class="math">k \\leq N</span>  such that  <span class="math">\\vec{t}</span>  has all the elements in  <span class="math">\\vec{c}</span>  that are used in  <span class="math">\\vec{a}</span> . That is, our first step is to get rid of the unused elements in  <span class="math">\\vec{c}</span> . The main novelty in [EFG22], and follow-up work [PH23, CFF+24], is to use a property of logarithmic derivatives exploited in [Hab22] that allows to link directly the initial table  <span class="math">\\vec{c}</span>  with the lookup  <span class="math">\\vec{a}</span> , with prover work independent of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{c}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . On the downside, the commitments to vectors  </span>\\vec{c}<span class="math"> , and  </span>\\vec{a}$  are not homomorphic. Baloo is, to the best of our knowledge, the most efficient lookup argument with homomorphic commitments that uses a univariate setup.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Roughly speaking, the techniques of  <span class="math">cq</span>  are related to the ones used to prove the permutation argument in Plonk [GWC19]. In contrast, the ones of this work are based on a novel analysis of an argument for simple linear relations of [RZ21], which was designed as a plug-in for the Marlin proof system [CHM+20]. The core technical part of this work is to use techniques developed in the context of the Marlin proof system, namely, Checkable Subspace Sampling (CSS) arguments, to show that a vector  <span class="math">\\vec{d}</span>  is in the row space of some public matrix  <span class="math">\\mathbf{M}</span>  and use them in another context where  <span class="math">\\mathbf{M}</span>  is unknown. Therefore, our work presents a new technique, a stronger analysis of Marlin-like sparse polynomial commitments.</p>

    <p class="text-gray-300">The essence of Baloo is the observation that, to prove the lookup relation between  <span class="math">\\vec{t}</span>  and  <span class="math">\\vec{a}</span>  it is enough to prove the existence of a matrix  <span class="math">\\mathbf{M} \\in \\mathbb{F}^{m \\times k}</span>  such that (i)  <span class="math">\\mathbf{M}\\vec{t} = \\vec{a}</span> , and (ii) the rows of  <span class="math">\\mathbf{M}</span>  are unit vectors and so,  <span class="math">\\mathbf{M}</span>  is what we define as a lookup matrix. Proving matrix-vector products is a problem that arises in the design of SNARKs for R1CS arithmetization [BCR+19, CHM+20, CFF+21, Set20, RZ21]. Baloo's characterization of a lookup argument has opened a line of research where SNARK techniques can be exploited. Setty et al. proposed in Lasso [STW24] the first completely linear-time lookup building on multivariate polynomial commitments. The authors follow the same approach of committing to the (secret) matrix that relates  <span class="math">\\vec{a}</span>  and  <span class="math">\\vec{t}</span>  proposed in this work, but upholding</p>

    <p class="text-gray-300">the techniques in Spartan <em>[x20]</em>. A significant contribution of Lasso <em>[x21]</em> and the companion paper <em>[x1]</em> is the observation that many tables in practice are structured tables. Roughly speaking, this means that the lookup operation can be reconstructed by different lookups in smaller tables. This allows to handle much bigger tables than previous works. As pointed out in <em>[x21]</em>, to use proof systems that use KZG commitments <em>[x13]</em>, Lasso needs an additional argument to link them with multivariate commitments, whereas B<span class="math">aloo</span> natively supports them. Recently, Garreta and Manzur <em>[x10]</em> introduced FLL a folding scheme for lookup instances built over B<span class="math">aloo</span> and the folding scheme for R1CS presented in <em>[x12]</em>.</p>

    <p class="text-gray-300">It is natural to ask how B<span class="math">aloo</span> can be used for lookup arguments over witnesses defined on smaller domains. Natural examples include 64-bit proof systems such as Plonky2 <em>[x19]</em> and a family of hash functions <em>[GKL^{+}22, x18, x22]</em> recently introduced to speed up such proof systems. This question was addressed for the multivariate case, building on Lasso, in a recent work <em>[x6]</em>, and we leave the extension to the univariate case for future work.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3 Preliminaries</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 Notation</h3>

    <p class="text-gray-300">A bilinear group <span class="math">gk</span> is a tuple <span class="math">gk=(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,\\mathcal{P}_{1},\\mathcal{P}_{2})</span> where <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> are groups of prime order <span class="math">q</span>, the elements <span class="math">\\mathcal{P}_{1}</span>, <span class="math">\\mathcal{P}_{2}</span> are generators of <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> respectively, <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is an efficiently computable, non-degenerate bilinear map, and there is no efficiently computable isomorphism between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. Elements in <span class="math">\\mathbb{G}_{\\gamma}</span>, are denoted implicitly as <span class="math">[a]_{\\gamma}=a\\mathcal{P}_{\\gamma}</span>, where <span class="math">\\gamma\\in\\{1,2,T\\}</span> and <span class="math">[1]_{T}=e(\\mathcal{P}_{1},\\mathcal{P}_{2}).</span> With this notation, <span class="math">e([a]_{1},[b]_{2})=[ab]_{T}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\lambda\\in\\mathbb{N}</span> denote the security parameter and <span class="math">1^{\\lambda}</span> its unary representation. A function <span class="math">\\mathsf{negl}:\\mathbb{N}\\to\\mathsf{R}^{+}</span> is called <em>negligible</em> if for all <span class="math">c&gt;0</span>, there exists <span class="math">k_{0}</span> such that <span class="math">\\mathsf{negl}(k)&lt;\\frac{1}{k^{c}}</span> for all <span class="math">k&gt;k_{0}</span>. For a non-empty set <span class="math">S</span>, let <span class="math">x\\leftarrow S</span> denote sampling an element of <span class="math">S</span> uniformly at random and assigning it to <span class="math">x</span>.</p>

    <p class="text-gray-300">PPT denotes probabilistic polynomial-time, and algorithms are randomized unless explicitly noted otherwise. Let <span class="math">y\\leftarrow A(x;r)</span> denote running algorithm <span class="math">A</span> on input <span class="math">x</span> and randomness <span class="math">r</span> and assigning its output to <span class="math">y</span> and <span class="math">y\\leftarrow A(x)</span> denotes <span class="math">y\\leftarrow A(x;r)</span> for a uniformly random <span class="math">r</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a finite field <span class="math">\\mathbb{F}</span>, <span class="math">\\mathbb{F}[X]</span> the ring of univariate polynomials with coefficients in <span class="math">\\mathbb{F}</span>. For <span class="math">m\\in\\mathbb{F}</span>, we set <span class="math">[m]=\\{1,\\ldots,m\\}</span>. For a set <span class="math">S</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its cardinality, and </span>\\alpha\\leftarrow S<span class="math"> means </span>\\alpha<span class="math"> has been uniformly sampled from </span>S$. Matrices are denoted in boldface.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.2 Lagrange Polynomials</h3>

    <p class="text-gray-300">Given a vector <span class="math">\\vec{v}\\in\\mathbb{F}^{d}</span> and a basis <span class="math">\\mathcal{B}=\\{B_{i}(X)\\}_{i=1}^{d}</span> of the polynomials of degree <span class="math">d-1</span>, we can represent vector <span class="math">v</span> as a polynomial <span class="math">v(X)=\\sum_{i=1}^{d}v_{i}B_{i}(X)</span>. We call such a representation an <em>encoding</em> of <span class="math">\\vec{v}</span>, and omit reference to the basis when possible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Along this work, we will set <span class="math">\\mathcal{B}</span> to be the basis of Lagrange interpolation polynomials for some set <span class="math">S</span> of size <span class="math">d</span>. We recall the Lagrange basis with respect to a set <span class="math">S=(s_{1},\\ldots,s_{d})</span> consists of <span class="math">d</span> polynomials <span class="math">p_{i}(X)</span> of degree <span class="math">d-1</span> such that <span class="math">p_{i}(s_{i})=1</span> and <span class="math">p_{i}(s_{j})=0</span> when <span class="math">i\\neq j.</span> The vanishing polynomial <span class="math">z_{S}(X)</span> is the polynomial that takes value <span class="math">0</span> in all the elements of <span class="math">S</span>, i.e., <span class="math">z_{S}(X)=\\prod_{s_{i}\\in S}(X-s_{i})</span>. For any set of Lagrange interpolation polynomials <span class="math">\\{p_{i}(X)\\}_{i=1}^{d}</span> it is true that <span class="math">\\sum_{i=1}^{d}p_{i}(X)=1</span>, $z_{S}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_{i}(X)p_{j}(X)<span class="math"> for </span>i\\neq j<span class="math">, and since </span>p_{i}^{2}(X)=p_{i}(X)(1-\\sum_{j\\neq i}p_{j}(X))<span class="math">, it always hold that </span>p_{i}^{2}(X)\\equiv p_{i}(X)\\mod z_{S}(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will work with three different sets and their corresponding Lagrange interpolation basis in order to encode vectors of three different sizes: <span class="math">\\mathbb{H}</span> of size <span class="math">N</span>, <span class="math">\\mathbb{V}</span> of size <span class="math">m</span>, and <span class="math">\\mathbb{H}_{I}</span></p>

    <p class="text-gray-300">of size <span class="math">k</span>. If possible, we choose the set <span class="math">S</span> to be a set of roots of unity in the field <span class="math">\\mathbb{F}</span>, as this choice leads to sparse representations for both Lagrange and vanishing polynomials. For a vector of size <span class="math">N</span>, we assume without loss of generality that there exists a primitive <span class="math">N</span>th root of unity <span class="math">\\omega^{1}</span>. We define the subgroup <span class="math">\\mathbb{H}=\\{\\omega,\\omega^{2},\\ldots,\\omega^{N-1},1\\}\\subset\\mathbb{F}</span>. The Lagrange interpolation polynomials for this set are denoted as <span class="math">\\{\\lambda_{s}(X)\\}_{s=1}^{N}</span>, and the vanishing polynomial is <span class="math">z_{H}(X)</span>. Since <span class="math">\\mathbb{H}</span> is a subgroup, the Lagrange polynomial <span class="math">\\lambda_{s}(X)</span> can be expressed as <span class="math">\\lambda_{s}(X)=\\frac{\\omega^{s}}{N}\\frac{X^{N}-1}{X-\\omega^{s}}</span>, and the vanishing polynomial is <span class="math">z_{H}(X)=X^{N}-1</span>. For vectors of size <span class="math">m</span> (<span class="math">m\\neq N</span>) we assume <span class="math">\\nu</span> is a primitive <span class="math">m</span>th root of unity, and we define the set <span class="math">\\mathbb{V}=\\{\\nu,\\nu^{2},\\ldots,\\nu^{m}\\}</span>. The Lagrange interpolation polynomials for this set are denoted as <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span>, and the vanishing polynomial is <span class="math">z_{V}(X)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we consider vectors of size <span class="math">k</span>, which are constructed as subvectors of a vector of size <span class="math">N</span>. To do this, we define <span class="math">I\\subset[N]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k<span class="math">, and we set </span>\\mathbb{H}_{I}\\subset\\mathbb{H}<span class="math"> such that </span>\\mathbb{H}_{I}=\\{\\omega^{s}\\mid s\\in I\\}<span class="math">, maintaining the same order as in </span>\\mathbb{H}<span class="math">. For simplicity, we rename the elements in </span>\\mathbb{H}_{I}<span class="math"> and denote them as </span>\\mathbb{H}_{I}=\\{\\xi_{i}\\}_{i=1}^{k}<span class="math">, where </span>\\xi_{i}=\\omega^{s}<span class="math"> for the </span>i<span class="math">th index </span>s\\in I<span class="math">. The Lagrange polynomials for this set are denoted as </span>\\{\\tau_{i}(X)\\}_{i=1}^{k}<span class="math">, and the vanishing polynomial is </span>z_{I}(X)<span class="math">. Note that </span>\\mathbb{H}_{I}<span class="math"> is generally not a subgroup and thus </span>z_{I}(X)<span class="math"> and the </span>\\tau_{i}(X)$’s are not sparse.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.3 Cryptographic Assumptions</h3>

    <p class="text-gray-300">The security of our protocols holds in the Algebraic Group Model (AGM) of Fuchsbauer et al. <em>[x10]</em>, using the bilinear version of the q-dlog and q-sfrac assumptions <em>[x13, x4]</em> defined below. In the AGM, adversaries are restricted to be algebraic algorithms, namely, whenever <span class="math">\\mathcal{A}</span> outputs a group element <span class="math">[y]</span> in a cyclic group <span class="math">\\mathbb{G}</span> of order <span class="math">p</span>, it also outputs its representation as a linear combination of all previously received group elements. In other words, if <span class="math">[y]\\leftarrow\\mathcal{A}([x_{1}],\\ldots,[x_{m}])</span>, <span class="math">\\mathcal{A}</span> must also provide <span class="math">\\vec{z}</span> such that <span class="math">[y]=\\sum_{j=1}^{m}z_{j}[x_{j}]</span>. This definition generalizes naturally in asymmetric bilinear groups with a pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span>, where for <span class="math">i\\in{1,2}</span>, the adversary must construct <span class="math">\\mathbb{G}_{i}</span> elements as linear combinations of received <span class="math">\\mathbb{G}_{i}</span> elements.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1 (q-dlog).</h6>

    <p class="text-gray-300">The <span class="math">q(\\lambda)</span>-discrete logarithm assumption holds for a bilinear group generator <span class="math">gk\\leftarrow\\mathcal{G}(1^{\\lambda})</span> if for all PPT algorithm <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{q-dlog}_{gk,\\mathcal{A}}(\\lambda)=\\Pr\\left[x\\leftarrow\\mathcal{A}(gk,[x]_{1,2},\\ldots,[x^{q}]_{1,2})\\right]=\\mathsf{negl}(\\lambda).</span></p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2 (q-sfrac).</h6>

    <p class="text-gray-300">The <span class="math">q(\\lambda)</span>-Simple Fractional assumption holds for a bilinear group generator <span class="math">gk\\leftarrow\\mathcal{G}(1^{\\lambda})</span> if for all PPT algorithm <span class="math">\\mathcal{A}</span> the following probability is negligible in <span class="math">\\lambda</span></p>

    <p class="text-gray-300">\\[ \\mathsf{Adv}^{q-sfrac}_{gk,\\mathcal{A}}(\\lambda)=\\Pr\\left[\\begin{array}[]{c}\\frac{r(x)}{s(x)}e([1]_{1},[1]_{2})\\leftarrow\\mathcal{A}(gk,[1]_{1,2},[x]_{1,2},\\ldots,[x^{q}]_{1,2})\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\wedge\\deg(r)<\\deg(s)\\leq q.\\end{array}\\right.\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}gk\\leftarrow\\mathcal{G}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">x\\leftarrow\\mathbb{F}\\end{array}\\right.\\right]. \\]</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.4 Non-Interactive Argument of Knowledge</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}</span> be a family of universal relations. Given a relation <span class="math">\\mathsf{R}\\in\\mathcal{R}</span> and an instance <span class="math">\\mathsf{x}</span> we call <span class="math">w</span> a witness for <span class="math">\\mathsf{x}</span> if <span class="math">(\\mathsf{x},w)\\in\\mathsf{R}</span>, $\\mathcal{L}(\\mathsf{R})=\\{\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\exists w:(\\mathsf{x},w)\\in\\mathsf{R}\\}<span class="math"> is the language of all the </span>\\mathsf{x}<span class="math"> that have a witness </span>w<span class="math"> in the relation </span>\\mathsf{R}<span class="math">, while </span>\\mathcal{L}(\\mathsf{R})<span class="math"> is the language of all the pairs </span>(\\mathsf{x},\\mathsf{R})<span class="math"> such that </span>\\mathsf{x}\\in\\mathcal{L}(\\mathsf{R})<span class="math">. We will assume </span>\\mathsf{R}$ is implicit as prover and verifier input.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">A Non-Interactive Argument of Knowledge is a tuple of PPT algorithms <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{srs},\\tau)\\leftarrow\\mathsf{Setup}(\\mathcal{R})</span>: On input a family of relations <span class="math">\\mathcal{R}</span>, <span class="math">\\mathsf{Setup}</span> outputs a structured reference string <span class="math">\\mathsf{srs}</span> and a trapdoor <span class="math">\\tau</span> as a private output;</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">Baloo</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi \\gets \\operatorname{Prove}(\\operatorname{srs}, (\\mathsf{x}, w))</span>: On input a pair <span class="math">(\\mathsf{x}, w) \\in \\mathsf{R}</span>, it outputs a proof <span class="math">\\pi</span> of the fact that <span class="math">\\mathsf{x} \\in \\mathcal{L}(\\mathsf{R})</span>;</li>

      <li><span class="math">1/0 \\gets \\text{Verify}(\\text{srs}, \\mathsf{x}, \\pi)</span>: On input the srs, the instance <span class="math">\\mathsf{x}</span> and the proof, it produces a bit expressing acceptance (1), or rejection (0);</li>

    </ul>

    <p class="text-gray-300">and that satisfies completeness, knowledge soundness and zero-knowledge as defined below.</p>

    <p class="text-gray-300"><strong>Completeness:</strong> holds if an honest prover will always convince an honest verifier. Formally, <span class="math">\\forall \\mathsf{R} \\in \\mathcal{R}, (\\mathsf{x}, w) \\in \\mathsf{R}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\text{Verify}(\\text{srs}, \\mathsf{x}, \\pi) = 1 \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\text{srs}, \\tau) \\leftarrow \\text{Setup}(\\mathcal{R}) \\\\ \\pi \\leftarrow \\text{Prove}(\\text{srs}, (\\mathsf{x}, w)) \\end{array} \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Knowledge-Soundness:</strong> captures the fact that a cheating prover cannot, except with negligible probability, create a proof <span class="math">\\pi</span> accepted by the verification algorithm unless it has a witness <span class="math">w</span> such that <span class="math">(\\mathsf{x}, w) \\in \\mathsf{R}</span>. Formally, for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathsf{x}, w) \\notin \\mathsf{R} \\land \\text{Verify}(\\text{srs}, \\mathsf{x}, \\pi) = 1 \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\text{srs}, \\tau) \\leftarrow \\text{Setup}(\\mathcal{R}) \\\\ (\\mathsf{x}, \\pi) \\leftarrow \\mathcal{A}(\\text{srs}) \\\\ w \\leftarrow \\mathcal{E}(\\text{srs}, \\mathsf{x}, \\pi) \\end{array} \\right] \\leq \\text{negl}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-13" class="text-2xl font-bold">3.5 The KZG Polynomial Commitment Scheme</h2>

    <p class="text-gray-300">Our construction heavily relies on the polynomial commitment introduced by Kate, Zaverucha and Goldberg in [KZG10] that we described below. As noted in Caulk [ZBK+22], the protocol can be slightly modified to support degree checks, so it consists on a tuple <span class="math">\\left(\\text{KZG.Setup}, \\text{KZG.Commit}, \\text{KZG.Open}, \\text{KZG.Verify}\\right)</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{srs}_{\\mathsf{KZG}} \\gets \\mathsf{KZG.Setup}(gk, d)</span>: On input a bilinear group <span class="math">gk</span> and a degree bound <span class="math">d</span>, it samples <span class="math">x \\gets \\mathbb{F}</span> uniformly, and outputs a structured reference string <span class="math">\\mathsf{srs}_{\\mathsf{KZG}} = \\left(\\{[x^i]_{1,2}\\}_{i=1}^d\\right)</span>.</li>

      <li><span class="math">\\mathsf{cm}_{\\mathsf{c}} \\gets \\mathsf{KZG.Commit}(\\mathsf{srs}_{\\mathsf{KZG}}, p(X))</span>: On input polynomial <span class="math">p(X) \\in \\mathbb{F}[X]</span> of degree <span class="math">d</span>, it outputs <span class="math">\\mathsf{cm}_{\\mathsf{c}} = [p(x)]_1</span>.</li>

      <li><span class="math">(s, \\pi_{\\mathsf{KZG}}) \\gets \\mathsf{KZG.Open}(\\mathsf{srs}_{\\mathsf{KZG}}, p(X), \\alpha)</span>: Let <span class="math">\\deg &amp;lt; d</span> be the degree of <span class="math">p(X)</span>. Given <span class="math">\\alpha \\in \\mathbb{F}</span>, prover computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">q(X) = \\frac{p(X) - p(\\alpha)}{X - \\alpha},</span></div>

    <p class="text-gray-300">sets <span class="math">s = p(\\alpha), [Q]_1 = [q(x)x^{d - \\deg + 1}]_1</span>, and outputs <span class="math">(s, \\pi_{\\mathsf{KZG}} = [Q]_1)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">1/0 \\gets \\mathsf{KZG.Verify}(\\mathsf{srs}_{\\mathsf{KZG}}, \\mathsf{cm}_{\\mathsf{c}}, \\deg, \\alpha, s, \\pi_{\\mathsf{KZG}})</span>: Verifier accepts if and only if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e(\\mathsf{cm}_{\\mathsf{c}} - [s]_1, [x^{d - \\deg + 1}]_2) = e([Q]_1, [x - \\alpha]_2).</span></div>

    <p class="text-gray-300"><strong>Multiple Openings.</strong> We also implement the optimization noted in [KZG10] to open one polynomial to many distinct points. In a nutshell, given the polynomial <span class="math">p(X)</span>, a vector of opening points <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^t</span> and <span class="math">\\vec{s}</span> such that <span class="math">s_i = p(\\alpha_i)</span> for all <span class="math">i = 1, \\dots, t</span>, prover and verifier define <span class="math">C_{\\vec{\\alpha}}(X)</span> as the unique polynomial of degree <span class="math">t - 1</span> such that <span class="math">C_{\\vec{\\alpha}}(\\alpha_i) = s_i</span> for all <span class="math">i \\in [t]</span>. Then, <span class="math">p(\\alpha_i) = s_i</span> for all <span class="math">i = 1, \\dots, t</span> if and only if there exists <span class="math">q(X)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">p(X) - C_{\\vec{\\alpha}}(X) = \\prod_{i=1}^{t} (X - \\alpha_i) q(X).</span></div>

    <p class="text-gray-300">Subset openings. Crucial for our construction is the subvector opening scheme of Tomescu et al. <em>[TAB^{+}20]</em> that works for the vector commitment inspired by KZG.</p>

    <p class="text-gray-300">Consider <span class="math">\\vec{c}\\in\\mathbb{F}^{N}</span> and let <span class="math">\\vec{t}\\in\\mathbb{F}^{k}</span> be a subvector of <span class="math">\\vec{c}</span>, i.e., there exists <span class="math">I\\subset[N]</span> such that <span class="math">\\vec{t}=(c_{i})_{i\\in I}</span>. Given an encoding <span class="math">C(X)=\\sum_{s=1}^{N}c_{s}\\lambda_{s}(X)</span> of <span class="math">\\vec{c}\\in\\mathbb{F}^{N}</span> and <span class="math">C_{I}(X)=\\sum_{i=1}^{k}t_{i}\\tau_{i}(X)</span>, where <span class="math">\\{\\tau_{i}(X)\\}</span> are the Lagrange interpolation polynomials of the set <span class="math">\\mathbb{H}_{I}=\\{\\xi_{i}\\}_{i=1}^{k}=\\{\\omega^{s}\\}_{s\\in I}</span>, then note that for <span class="math">z_{I}(X)=\\prod_{i=1}^{k}(X-\\xi_{i})</span>,</p>

    <p class="text-gray-300"><span class="math">C(X)-C_{I}(X)=z_{I}(X)Q_{I}(X),</span></p>

    <p class="text-gray-300">for some polynomial <span class="math">Q_{I}(X)</span> if and only if <span class="math">t_{i}=c_{s}</span> for the pairs <span class="math">(i,s)</span> such that <span class="math">\\xi_{i}=\\omega^{s}</span>.</p>

    <p class="text-gray-300">What is more, it is demonstrated in <em>[TAB^{+}20]</em> that the prover can compute <span class="math">[Q_{I}]_{1}</span> by performing <span class="math">k</span> group and <span class="math">O(k\\log^{2}(k))</span> field operations, given they already have stored proofs <span class="math">\\{[Q_{s}]_{1}\\}_{s\\in I}</span> that <span class="math">C(\\omega^{s})=c_{s}</span>. Precomputing all the proofs <span class="math">\\{[Q_{s}]_{1}\\}_{s=1}^{N}</span> can be done in time <span class="math">O(N\\log N)</span> using techniques by Feist and Khovratovich <em>[x11]</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.6 Polynomial Holographic Proofs</h3>

    <p class="text-gray-300">For a family of relations <span class="math">\\mathcal{R}</span>, we denote <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span> if <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathsf{R}</span>, and <span class="math">\\mathsf{R}\\in\\mathcal{R}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[Polynomial Holographic IOPs (PHP) <em>[CFF^{+}21]</em>] A Polynomial Holographic IOP for a family of relations <span class="math">\\mathcal{R}</span> is a tuple <span class="math">\\mathsf{PHP}=(\\mathsf{rnd},\\mathsf{n},\\mathsf{m},\\mathsf{d},,\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\mathsf{rnd},\\mathsf{n},\\mathsf{m},\\mathsf{d}:\\{0,1\\}^{*}\\to\\mathbb{N}<span class="math"> are polynomial-time computable functions, and </span>\\mathcal{I},\\mathcal{P},\\mathcal{V}$ are algorithms that work as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Offline phase: The encoder or indexer <span class="math">\\mathcal{I}(\\mathsf{R})</span> is executed on a relation description <span class="math">\\mathsf{R}\\in\\mathcal{R}</span>, and returns <span class="math">\\mathsf{n}(0)</span> polynomials <span class="math">\\{p_{0,j}(X)\\}_{j=1}^{\\mathsf{n}(0)}\\in\\mathbb{F}[X]</span> encoding the relation <span class="math">\\mathsf{R}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Online phase: The prover <span class="math">\\mathcal{P}(\\mathsf{R},\\mathsf{x},\\mathsf{w})</span> and the verifier <span class="math">\\mathcal{V}^{\\mathcal{I}(\\mathsf{R})}(\\mathsf{x})</span> are executed for $\\mathsf{rnd}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2}<span class="math"> rounds, the prover has a tuple </span>(\\mathsf{x},\\mathsf{w})\\in\\mathsf{R}<span class="math"> , and the verifier has an instance </span>\\mathsf{x}<span class="math"> and oracle access to the polynomials encoding </span>\\mathsf{R}<span class="math">. In the </span>i<span class="math">th round, </span>\\mathcal{V}<span class="math"> sends a message </span>\\rho_{i}\\in\\mathbb{F}<span class="math"> to the prover, and </span>\\mathcal{P}<span class="math"> replies with </span>\\mathsf{m}(i)<span class="math"> messages </span>\\{\\pi_{i,j}\\in\\mathbb{F}\\}_{j=1}^{\\mathsf{m}(i)}<span class="math">, and </span>\\mathsf{n}(i)<span class="math"> oracle polynomials </span>\\{p_{i,j}\\in\\mathbb{F}[X]\\}_{j=1}^{\\mathsf{n}(i)}<span class="math">, such that </span>\\deg(p_{i,j})<\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Degree checks: to check a bound on the degree of the polynomials sent by the prover.</li>

      <li>Polynomial checks: to verify that certain polynomial identities hold between the oracle polynomials and the messages sent by the prover.</li>

    </ul>

    <p class="text-gray-300">The verifier accepts if and only if all the checks are satisfied.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is complete if for any triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, the checks returned by <span class="math">\\mathcal{V}^{\\mathcal{I}(\\mathsf{R})}</span> after interacting with the honest prover <span class="math">\\mathcal{P}(\\mathsf{R},\\mathsf{x},\\mathsf{w})</span>, are satisfied with probability 1.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is <span class="math">\\epsilon</span>-sound if for every relation-instance tuple <span class="math">(\\mathsf{R},\\mathsf{x})\\notin\\mathcal{L}(\\mathcal{R})</span> and polynomial-time prover <span class="math">\\mathcal{P}^{*}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\langle\\mathcal{P}^{*},\\mathcal{V}^{\\mathcal{I}(\\mathsf{R})}(\\mathsf{x})\\rangle=1\\right]\\leq\\epsilon.</span></p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">A PHP is <span class="math">\\epsilon</span>-knowledge sound if there exists a polynomial-time knowledge extractor <span class="math">\\mathcal{E}</span> such that for any prover <span class="math">\\mathcal{P}^{*}</span>, relation <span class="math">\\mathsf{R}</span>, instance <span class="math">\\mathsf{x}</span> and auxiliary input <span class="math">z</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}:\\mathsf{w}\\leftarrow\\mathcal{E}^{\\mathcal{P}^{<em>}}(\\mathsf{R},\\mathsf{x},z)\\right]\\geq\\Pr\\left[\\langle\\mathcal{P}^{</em>}(\\mathsf{R},\\mathsf{x},z),\\mathcal{V}^{\\mathcal{I}(\\mathsf{R})}(\\mathsf{x})\\rangle=1\\right]-\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathcal{E}</span> has oracle access to <span class="math">\\mathcal{P}^{<em>}</span>, it can query the next message function of <span class="math">\\mathcal{P}^{</em>}</span> (and also rewind it) and obtain all the messages and polynomials returned by it.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.7 Generalized Sumcheck</h3>

    <p class="text-gray-300">Following <em>[BCR^{+}19]</em>, in Section 5.2.4 we construct a scheme for inner product relations that rely on the univariate sumcheck argument. Since the sumcheck in <em>[BCR^{+}19]</em> requires to work with Lagrange polynomials that interpolate subgroups, and we will work with an arbitrary subset <span class="math">\\mathbb{H}_{I}</span> of <span class="math">\\mathbb{H}</span>, we use the generalized variant of the sumcheck:</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 1 (Generalized Sumcheck <em>[x20]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{H}_{I}=\\{\\xi_{i}\\}_{i=1}^{k}</span> be an arbitrary subset of size <span class="math">k</span> in some finite field <span class="math">\\mathbb{F}</span> and <span class="math">z_{I}(X)</span> its vanishing polynomial. For any <span class="math">P(X)\\in\\mathbb{F}[X]</span>, <span class="math">\\sum_{i=1}^{k}P(\\xi_{i})=\\sigma</span> if and only if there exist polynomials <span class="math">Q(X)\\in\\mathbb{F}[X]</span>, <span class="math">R(X)\\in\\mathbb{F}[X]</span> with <span class="math">\\deg(R)\\leq k-2</span> such that</p>

    <p class="text-gray-300"><span class="math">P(X)N_{\\mathbb{H}_{I}}(X)-\\sigma=XR(X)+z_{I}(X)Q(X),</span></p>

    <p class="text-gray-300">where <span class="math">N_{\\mathbb{H}_{I}}(X)=\\sum_{i=1}^{k}\\tau_{i}(0)^{-1}\\tau_{i}(X)</span> and <span class="math">\\tau_{i}(X)</span> is the <span class="math">i</span>th Lagrange polynomial associated to <span class="math">\\mathbb{H}_{I}</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4 Overview</h2>

    <p class="text-gray-300">In this section we provide a technical overview of the Ba<em>loo</em> protocol, which proves a committed lookup relation, informally:</p>

    <p class="text-gray-300">Given element <span class="math">\\mathsf{cm}_{\\mathsf{a}}\\in\\mathbb{G}_{1}</span> and a public set represented as vector <span class="math">\\vec{c}\\in\\mathbb{F}^{N}</span>, there exists <span class="math">\\vec{a}\\in\\mathbb{F}^{m}</span> such that all elements of <span class="math">\\vec{a}</span> are elements of <span class="math">\\vec{c}</span> and <span class="math">\\mathsf{cm}_{\\mathsf{a}}</span> is a KZG commitment to <span class="math">\\vec{a}</span>.</p>

    <p class="text-gray-300">To give an intuition of our protocol, we will first analyze the relation above in algebraic terms: given a public table represented in vector <span class="math">\\vec{c}\\in\\mathbb{F}^{N}</span> and a vector <span class="math">\\vec{a}\\in\\mathbb{F}^{m}</span>, prove that for all <span class="math">j\\in[m]</span>, there exists <span class="math">s\\in[N]</span> such that <span class="math">a_{j}=c_{s}</span>. The first observation made also in previous work (<em>[ZBK^{+}22]</em>, <em>[x21]</em>) is that as not all elements of <span class="math">\\vec{c}</span> are used in <span class="math">\\vec{a}</span>, we can create a new, shorter table <span class="math">\\vec{t}</span> by selecting from <span class="math">\\vec{c}</span> only those elements that are also in <span class="math">\\vec{a}</span>. This step is to prevent the prover from an unnecessary dependency on <span class="math">N</span>.</p>

    <p class="text-gray-300">Secondly, we prove that <span class="math">\\vec{a}</span> is a result of some expansion of <span class="math">\\vec{t}</span>, i.e., we design a lookup argument for <span class="math">\\vec{a}</span> in the new table <span class="math">\\vec{t}</span>. The hurdle of this step is that <span class="math">\\vec{t}</span> is unknown to the verifier and is encoded as a polynomial with an unknown Lagrange basis <span class="math">\\{\\tau_{i}(X)\\}_{i=1}^{k}</span>. Designing an efficient lookup argument for such a table is our main contribution. To do so, we note that the relation above has a simple algebraic representation: as <span class="math">\\vec{a}</span> is a vector generated using elements of <span class="math">\\vec{t}</span>, there exists a matrix <span class="math">\\mathbf{M}\\in\\mathbb{F}^{m\\times k}</span> whose rows are unit vectors such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}\\vec{t}=\\vec{a}.</span> (1)</p>

    <p class="text-gray-300">Concretely, all elements in <span class="math">\\mathbf{M}</span> are zero except for one element per row <span class="math">1=m_{j,i}</span> when <span class="math">j,i</span> are such that <span class="math">a_{j}=t_{i}</span>. Recall we call such a matrix a <em>lookup matrix</em>.</p>

    <p class="text-gray-300">In Figure 1, we depict the relations we aim to prove: <span class="math">\\vec{c}</span> is the original table. <span class="math">\\vec{t}</span> is a subvector of it: it keeps the ordering of the elements in <span class="math">\\vec{c}</span>, and takes some of them only</p>

    <p class="text-gray-300">once. On the other hand, <span class="math">\\vec{a}</span> is itself a lookup on <span class="math">\\vec{t}</span>: all elements of <span class="math">\\vec{a}</span> are taken from <span class="math">\\vec{t}</span>, in no strict order and with potential repetitions.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Relation between <span class="math">\\vec{t},\\vec{c},</span> and <span class="math">\\vec{a}</span></p>

    <p class="text-gray-300">To prove equation (1) and that <span class="math">\\mathbf{M}</span> is a lookup matrix, we leverage SNARK techniques where proving linear relations is done via a lincheck argument, e.g. <em>[BCR^{+}19]</em>. In particular, we use the framework of Ràfols and Zapico <em>[x21]</em>, that separates the lincheck into two parts: a Checkable Subspace Sampling (CSS) argument, and an inner product.</p>

    <p class="text-gray-300">The CSS is a PHP that deals with the problem of committing to a matrix of size <span class="math">m\\times k</span> in a succinct way. The solution, adopted in other works (<em>[CHM^{+}20]</em>, <em>[CFF^{+}21]</em>), is to sample a vector in the row-space of matrix <span class="math">\\mathbf{M}</span> and then commit to such vector. If the new vector is sampled using random coins chosen by the verifier, the linear relation can be reduced to proving the following inner product (with overwhelming probability):</p>

    <p class="text-gray-300"><span class="math">(\\vec{r}^{\\top}\\mathbf{M})\\cdot\\vec{t}=\\vec{r}^{\\top}\\vec{a}.</span> (2)</p>

    <p class="text-gray-300">Finally, to prove <span class="math">\\mathbf{M}</span> is of the correct form, we adapt the construction of <em>[x21]</em> to prove that a matrix has one non-zero element per column, so it works for lookup matrices.</p>

    <p class="text-gray-300">Overall, to build B<em>aloo</em> and prove the committed relation defined at the beginning of this section, we first use a succinct argument from <em>[x16]</em> to prove an element <span class="math">\\mathsf{cm}_{t}</span> is the commitment to a subvector of the vector committed in <span class="math">\\mathsf{cm}_{c}</span>, introduced in Section 5.1. Then, we design a PHP for proving <span class="math">\\vec{a}</span> is an expansion of vector <span class="math">\\vec{t}</span>, in Section 5.2 and compile it into a succinct argument in Section 6.1. Finally, we put all the building blocks together and present the full B<em>aloo</em> construction with optimizations in 6.2.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.1 Select a subvector</h3>

    <p class="text-gray-300">We denote by <span class="math">\\mathsf{cm}_{\\mathsf{c}}</span> the commitment to <span class="math">\\vec{c}</span>. Then we create a commitment <span class="math">\\mathsf{cm}_{\\mathsf{t}}</span> to a subvector <span class="math">\\vec{t}\\in\\mathbb{F}^{k}</span> defined by <span class="math">\\vec{a}</span> through the set of index <span class="math">I=\\{s\\in[N]\\text{ s.t. }\\exists a_{j}\\text{ with }c_{s}=a_{j}\\}</span>. That is, <span class="math">\\vec{t}</span> is the subvector of <span class="math">\\vec{c}</span> that contains only the elements of <span class="math">\\vec{c}</span> that are also in <span class="math">\\vec{a}</span>, i.e., <span class="math">\\vec{t}=(c_{s})_{s\\in I}</span>. Recall that Since <span class="math">I</span> is unknown to the verifier, we cannot use directly the subvector protocol in Section 3.5.</p>

    <p class="text-gray-300">Instead, to prove that <span class="math">\\mathsf{cm}_{t}</span> commits to a subvector of <span class="math">\\vec{c}</span>, the prover provides <span class="math">W_{1}\\in\\mathbb{G}_{1},[z_{I}]_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{cm}_{\\mathsf{c}}-\\mathsf{cm}_{\\mathsf{t}},[1]_{2})=e(W_{1},[z_{I}]_{2}),</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">along with a proof of well-formedness of <span class="math">[z_{I}]_{2}</span>. That is, a proof that <span class="math">[z_{I}]_{2}</span> is a commitment to the vanishing polynomial of <em>some</em> subset of <span class="math">\\mathbb{H}</span>. For proving the latter, we use the Caulk+ core protocol by <em>[x16]</em> described in Section 5.1. If the prover has access to precomputed KZG proofs <span class="math">\\{[Q_{s}]_{1}\\}_{s=1}^{N}</span> of opening for all the elements <span class="math">c_{s}\\in\\vec{c}</span> and individual proofs <span class="math">\\{[H_{s}]_{1}\\}_{s=1}^{N}</span> of statements “$(X-\\omega^{s})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{H}(X)<span class="math">”, it performs only </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> group operations to convince the verifier that </span>\\mathsf{cm}_{\\mathsf{t}}<span class="math"> is a commitment to some subvector of </span>\\vec{c}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.2 PHP for expansion</h3>

    <p class="text-gray-300">Our Checkable Subspace Sampling, that is a PHP for a special sampling relation, can be seen as a partial evaluation problem: given matrix <span class="math">\\mathbf{M}\\in\\mathbb{F}^{m\\times k}</span>, sets <span class="math">\\mathbb{H}_{I}</span> and <span class="math">\\mathbb{V}</span> of size <span class="math">k</span></p>

    <p class="text-gray-300">and <span class="math">m</span> with Lagrange interpolation polynomials <span class="math">\\{\\tau_{i}(X)\\}_{i=1}^{k}</span> and <span class="math">\\{\\mu_{j}(X)\\}_{j=1}^{m}</span> respectively, we can construct a bivariate polynomial encoding matrix <span class="math">\\mathbf{M}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">M(X,Y)=\\left(\\mu_{1}(Y),\\ldots,\\mu_{m}(Y)\\right)\\,\\mathbf{M}\\left(\\tau_{1}(X)\\,\\,\\ldots\\,\\,\\tau_{k}(X)\\right)^{\\top}</span> (3)</p>

    <p class="text-gray-300">Then, the goal of a CSS argument is to show that for some <span class="math">\\alpha\\in\\mathbb{F}</span> sent by the verifier,</p>

    <p class="text-gray-300"><span class="math">D(X)=M(X,\\alpha)=\\sum_{i=1}^{k}\\sum_{j=1}^{m}M_{ji}\\tau_{i}(X)\\mu_{j}(\\alpha).</span></p>

    <p class="text-gray-300">That is, <span class="math">D(X)</span> is an encoding for <span class="math">\\vec{d}=\\sum_{j=1}^{m}\\mu_{j}(\\alpha)\\vec{m}_{j}</span>, where <span class="math">\\vec{m}_{j}</span> are the row vectors of <span class="math">\\mathbf{M}</span>. Performing a CSS argument allows to reduce the statement in eq. 1 to a single inner product relation <span class="math">\\vec{d}\\cdot\\vec{t}=\\sum_{j=1}^{m}a_{j}\\mu_{j}(\\alpha)</span>, that can be proven with the univariate sumcheck <em>[BCR^{+}19]</em>.</p>

    <p class="text-gray-300">We solve many challenges when using the framework in <em>[x21]</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The indexer. The framework is built to work for a public matrix <span class="math">\\mathbf{M}</span> and secret <span class="math">\\vec{t},\\vec{a}</span>. Because in our case matrix <span class="math">\\mathbf{M}</span> is only known by the prover, we replace the offline phase performed by the indexer in the CSS with a commitment phase performed by the prover itself. To support our protocol, we give a new definition of Commit-and-Prove CSS which works for matrices that are chosen in a commit-and-prove fashion <em>[x5]</em>, that is, the prover selects matrix <span class="math">\\mathbf{M}</span>, communicates it to the verifier in a succinct manner and then convinces them that <span class="math">\\mathbf{M}\\vec{t}=\\vec{a}</span>.</li>

      <li>Matrix <span class="math">\\mathbf{M}</span>. To prove the lookup relation between <span class="math">\\vec{a}</span> and <span class="math">\\vec{t}</span>, the prover must convince the verifier that matrix <span class="math">\\mathbf{M}</span> is a lookup matrix, i.e., that its rows are unit vectors. For this, we adapt a construction of CSS given in <em>[x21]</em> for so-called <em>basic matrices</em> to work for lookup matrices. A basic matrix is a matrix with one non-zero element per column, while a lookup matrix has only one non-zero element per row.</li>

      <li>Inner Product. To complete the proof for the linear relation, in Section 5.2.4 we present a scheme for proving the inner product relation between <span class="math">\\vec{d}</span> as described above and table <span class="math">\\vec{t}</span>, from its encodings <span class="math">D(X)</span> and <span class="math">T(X)</span>. Both <span class="math">T(X)</span> and <span class="math">D(X)</span> can be naturally written in the Lagrange basis <span class="math">\\{\\tau_{i}(X)\\}_{i=1}^{k}</span> corresponding to set <span class="math">\\mathbb{H}_{I}</span>, and we build the argument from the encoding using the generalized univariate sumcheck in Section 3.7.</li>

    </ul>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">4.3 Summary</h3>

    <p class="text-gray-300">We summarize the statement to be proven and challenges of building an argument for it in Fig. 2.</p>

    <h2 id="sec-25" class="text-2xl font-bold">5 Building Blocks</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we present the building blocks of <span class="math">\\mathsf{B}\\mathit{a}\\mathit{l}\\mathit{o}\\mathit{o}</span>. In Section 5.1, we describe the <span class="math">\\mathsf{C}\\mathsf{a}\\mathsf{u}\\mathsf{l}\\mathsf{k}\\mathsf{+}</span> <span class="math">\\mathsf{c}\\mathsf{o}\\mathsf{r}\\mathsf{e}</span> protocol that lets the prover convince the verifier that a group element <span class="math">\\mathsf{c}\\mathsf{m}_{\\mathsf{t}}</span> is a commitment to a subvector of a public table <span class="math">\\vec{c}</span>, by performing $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. In Section 5.2 we introduce the expansion argument that proves the committed lookup relation between </span>\\mathsf{c}\\mathsf{m}_{\\mathsf{t}}<span class="math"> and </span>\\mathsf{c}\\mathsf{m}_{\\mathsf{z}}$. This expansion argument consists of a CSS scheme introduced in Section 5.2.3 and the inner product described in Section 5.2.4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Statement: Given  <span class="math">\\mathsf{cm}_{\\mathsf{c}}</span>  a commitment to  <span class="math">C(X) = \\sum_{j=1}^{N} c_{i} \\vec{\\lambda}_{j}(X)</span> , the claim is that  <span class="math">\\mathsf{cm}_{\\mathsf{a}}</span>  is a commitment to  <span class="math">A(X) = \\sum_{j=1}^{m} a_{j} \\vec{\\mu}_{j}(X)</span> , and  <span class="math">\\vec{a} \\in \\mathbb{F}^{m}</span>  is a lookup of  <span class="math">\\vec{c} \\in \\mathbb{F}^{N}</span> .</p>

    <p class="text-gray-300"><span class="math">\\{\\lambda_j(X)\\}_{j=1}^N</span>  (respectively,  <span class="math">\\{\\mu_j(X)\\}_{j=1}^m</span> ) are Lagrange basis polynomials associated to the set of roots of unity  <span class="math">\\mathbb{H} = \\{\\omega^i\\}_{i=1}^N</span>  (resp.  <span class="math">\\mathbb{V} = \\{\\nu^i\\}_{i=1}^m</span> ).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">I</span>  is a set of indexes  <span class="math">I \\subset [N]</span>  and  <span class="math">\\mathbb{H}_I = \\{\\xi_i\\}_{i=1}^k</span>  the set of  <span class="math">\\mathbb{H}</span>  indexed by  <span class="math">I</span> . The verifier does not know  <span class="math">I</span>  and only sees  <span class="math">[z_I]_1</span>  a commitment to  <span class="math">z_I(X)</span> .</li>

      <li><span class="math">\\{\\tau_i(X)\\}_{i=1}^k</span>  is the set of Lagrange basis polynomials associated to  <span class="math">\\mathbb{H}_I</span> , which is an arbitrary subset of  <span class="math">\\mathbb{H}</span> .</li>

      <li><span class="math">\\vec{t} \\in \\mathbb{F}^k</span>  is a subtable, i.e.  <span class="math">\\vec{t} = (\\vec{c})_I</span> .  <span class="math">\\mathsf{cm}_{\\mathfrak{t}}</span>  is a commitment to  <span class="math">T(X) = \\sum_{j=1}^{k} t_j \\tau_j(X)</span> , and such that  <span class="math">\\vec{a} = \\mathbf{M}\\vec{t}</span> , where  <span class="math">\\mathbf{M}</span>  is a matrix whose non-zero elements are ones, and where there is at most one non-zero element per row.</li>

      <li>The matrix  <span class="math">\\mathbf{M}</span>  is represented by a bivariate polynomial with mixed polynomial basis, i.e.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">M (X, Y) = \\left(\\mu_ {1} (Y), \\dots , \\mu_ {m} (Y)\\right) \\mathbf {M} \\left(\\tau_ {1} (X) \\dots \\tau_ {k} (X)\\right) ^ {\\top},</span></div>

    <p class="text-gray-300">to make it compatible with the encodings of  <span class="math">\\vec{a},\\vec{t}</span>  on left and right sides.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The bivariate encoding is never sent to the verifier, but only a partial evaluation on a challenge  <span class="math">\\alpha</span> , i.e. a commitment to  <span class="math">D(X) = M(X,\\alpha)</span> . The prover sends certain commitments that allow to prove that  <span class="math">D(X)</span>  is correct <span class="math">^3</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 2: Summary of Baloo.</p>

    <p class="text-gray-300">We use a subroutine of the lookup argument Caulk+, which we call Caulk+ core, as a building block of Baloo. Caulk+, by Posen and Kattis [PK22], is an improvement on Caulk  <span class="math">\\mathrm{[ZBK^{+}22]}</span>  that takes prover computation in the group from  <span class="math">O(m^2 +m\\log (N))</span>  to just  <span class="math">O(m^{2})</span>  for  <span class="math">m</span>  lookups on tables of size  <span class="math">N</span> . Following their blueprint, our first step is to create a subtable. That is, given a public vector  <span class="math">\\vec{c}</span> , encoded as polynomial  <span class="math">C(X)</span>  and committed as  <span class="math">\\mathsf{cm}_{\\mathsf{c}}</span> , and elements  <span class="math">\\mathsf{cm}_{\\mathsf{t}}\\in \\mathbb{G}_1</span>  and  <span class="math">k\\in \\mathbb{N}</span> , Caulk+ core proves that  <span class="math">\\mathsf{cm}_{\\mathsf{t}}</span>  is a commitment to a subvector  <span class="math">\\vec{t}\\in \\mathbb{F}^k</span>  of  <span class="math">\\vec{c}</span> . In other words, there exist  <span class="math">I\\subset [N]</span>  such that  <span class="math">\\vec{t} = (c_s)_{s\\in I}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Caulk}+</span>  core considers the subvector length  <span class="math">k</span>  as a public parameter, and proves the following relation</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\text {s u b t a b l e}} = \\left\\{ \\begin{array}{c c} &amp;amp; \\mathbb {H} _ {I} = \\{\\xi_ {1}, \\ldots , \\xi_ {k} \\} \\subset \\mathbb {H} \\\\ (C (X), \\mathsf {c m} _ {\\mathsf {t}}, [ z _ {I} ] _ {2}); &amp;amp; \\forall \\xi \\in \\mathbb {H} _ {I}, T (\\xi) = C (\\xi) \\\\ (\\mathbb {H} _ {I}, T (X)) &amp;amp; \\mathsf {c m} _ {\\mathsf {t}} = [ T (x) ] _ {1} \\\\ &amp;amp; [ z _ {I} ] _ {2} = [ z _ {I} (x) ] _ {2} \\text {f o r} z _ {I} (X) = \\prod_ {i = 1} ^ {k} (X - \\xi_ {i}) \\end{array} \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">C(X) = \\sum_{s=1}^{N} c_s \\lambda_s(X)</span>  for  <span class="math">\\{\\lambda_s(X)\\}_{s=1}^N</span>  the Lagrange interpolation polynomials of a subgroup of roots of unity  <span class="math">\\mathbb{H} = \\{\\omega^s\\}_{s=1}^N</span> .</p>

    <p class="text-gray-300">Baloo</p>

    <p class="text-gray-300">In Fig. 3 we describe a SNARK for  <span class="math">\\mathsf{R}_{\\mathrm{subtable}}</span>  [PK22]. The prover running time of Caulk+ core is quasi-linear in  <span class="math">k</span>  for field and linear in  <span class="math">k</span>  for group operations (assuming some precomputations). We refer the reader to Section B for more details.</p>

    <p class="text-gray-300">SetupC+: Runs KZG.Setup(par, N) to obtain  <span class="math">\\{[x^s]_{1,2}\\}_{s=1}^N</span> , computes  <span class="math">[z_H(x)]_1</span>  for  <span class="math">z_H(X) = \\prod_{s=0}^{N-1}(X - \\omega^s)</span>  and outputs  <span class="math">\\mathsf{srs} = \\left(\\{[x^s]_{1,2}\\}_{s=1}^N, [z_H(x)]_1\\right)</span></p>

    <p class="text-gray-300">ProverC+: Takes as input  <span class="math">\\mathbb{H}_I</span> ,  <span class="math">T(X)</span> ,  <span class="math">\\{[Q_i(x)]_1 = [(C(x) - C(\\xi_i)) / (x - \\xi_i)]_1, [H_i(x)]_1 = [z_H(x) / (x - \\xi_i)]_1\\}_{i=1}^k</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">z_{I}(X) = \\prod_{i=1}^{k}(X - \\xi_{i})</span>  and  <span class="math">z_{H\\backslash I} = \\prod_{s\\in [N]\\backslash I}(X - \\omega^{s})</span></li>

      <li>Compute  <span class="math">W_{1} = \\left[\\frac{C(x) - T(x)}{z_{I}(x)}\\right]_{1}</span>  and  <span class="math">W_{2} = [z_{H\\backslash I}(x)]_{1}</span></li>

      <li>Compute  <span class="math">W_{3} = [(z_{I}(x) - x^{k})x^{N - k + 1}]_{1}</span></li>

    </ul>

    <p class="text-gray-300">It outputs  <span class="math">\\pi_{\\mathbb{C}+} = (W_1, W_2, W_3)</span> .</p>

    <p class="text-gray-300">VerifierC+: On input  <span class="math">\\mathsf{srs},\\pi_{\\mathsf{C} + },\\mathsf{cm}_{\\mathsf{c}},\\mathsf{cm}_{t}</span>  and  <span class="math">[z_I]_2</span>  , accepts if and only if</p>

    <p class="text-gray-300">(i)  <span class="math">e\\left(\\mathsf{cm}_{\\mathsf{c}} - \\mathsf{cm}_{\\mathsf{t}},[1]_{2}\\right) = e\\left(W_{1},[z_{I}]_{2}\\right)\\quad \\# \\vec{t}</span>  and  <span class="math">\\vec{c}</span>  agree on  <span class="math">\\mathbb{H}_I</span></p>

    <p class="text-gray-300">(ii)  <span class="math">e([z_H(x)]_1,[1]_2) = e(W_2,[z_I]_2)\\quad \\# z_I</span>  is the vanishing of some  <span class="math">\\mathbb{H}_I\\subset \\mathbb{H}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(iii)  $e\\left([x^{N - k + 1}]_1,[z_I]_2 - [x^k ]_2\\right) = e\\left(W_3,[1]_2\\right)\\quad \\#</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= k$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3: The Caulk+ core [PK22] quasi-linear time protocol for proving  <span class="math">\\mathsf{R}_{\\mathrm{subtable}}</span>  that a commitment contains a subtable.</p>

    <p class="text-gray-300">Theorem 2. The protocol in Fig. 3 is a knowledge sound Non-Interactive Argument of Knowledge (Fig. 3) in the algebraic group model assuming the q-dlog and the q-sfrac (App. 3.3) assumptions hold.</p>

    <p class="text-gray-300">We refer the reader to Appendix A for the proof.</p>

    <p class="text-gray-300">In this section we introduce the building blocks of a PHP (Definition 4) that proves vector  <span class="math">\\vec{a}</span>  encoded in a polynomial  <span class="math">A(X)</span>  is an expansion of the vector  <span class="math">\\vec{t}</span>  encoded in a polynomial  <span class="math">T(X)</span> , which means that for all  <span class="math">j \\in [m]</span>  there exists  <span class="math">i \\in [k]</span>  such that  <span class="math">a_j = t_i</span> . Our PHP uses two main components: (i) a checkable subspace sampling argument and (ii) an inner product argument.</p>

    <p class="text-gray-300">Designing  <span class="math">(i)</span>  is the main technical contribution of this work, and there are several challenges sorted in order to achieve a CSS for a lookup matrix. We divide the presentation of such protocol in three parts: In Section 5.2.1 we introduce the definition of a Commit-and-Prove CSS, after discussing its need. In section 5.2.2, we introduce the relation prover and verifier will run the proving phase for, and introduce the final CSS for it in 5.2.3. In Section 5.2.4 we describe the PHP for inner product relations we will use. All these schemes are compiled into a succinct argument in Section 6.</p>

    <p class="text-gray-300">The first step for proving the relation between  <span class="math">\\vec{t}</span>  and  <span class="math">\\vec{a}</span>  through polynomial encodings is that the prover and the verifier agree on a polynomial  <span class="math">D(X)</span>  encoding a uniformly sampled element in the row space of matrix  <span class="math">\\mathbf{M}</span>  such that  <span class="math">\\mathbf{M}\\vec{t} = \\vec{a}</span> . That is, that  <span class="math">D(X)</span>  is a random linear combination of polynomials  <span class="math">\\vec{M}(X) = (M_1(X),\\dots,M_m(X))^{\\top}</span>  that are encodings of the rows  <span class="math">\\vec{m}_i</span>  of  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">Naturally, we do not want the verifier to have to read  <span class="math">\\mathbf{M}</span>  and thus they need to receive a succinct representation of it. In many SNARK constructions ([CHM+20], [CFF+21], [RZ21]) where matrix  <span class="math">\\mathbf{M}</span>  is public before the interaction, such a representation is given during an offline phase of the CSS by a trusted party, called the indexer. We take a similar approach but, since matrix  <span class="math">\\mathbf{M}</span>  is not part of the instance, we present a variant of CSS schemes where we ask the prover to provide the succinct representation.</p>

    <p class="text-gray-300">We call this variant a commit-and-prove CSS, where instead of having an indexer that in an offline phase computes polynomials describing the matrix, we have that the prover commits to a matrix and then proves attributes of it. More concretely,  <span class="math">\\vec{a}</span>  is an expansion of  <span class="math">\\vec{t}</span>  if and only if  <span class="math">\\mathbf{M}</span>  is a matrix that has unit vectors in its rows, that is, there exists only one non-zero element in each row of  <span class="math">\\mathbf{M}</span>  and it equals 1.</p>

    <p class="text-gray-300">In our commit-and-prove CSS, the prover and verifier first engage in a commit and sampling phase, during which they jointly agree on the statement being proven. This statement is described in Section 5.2.2. Afterwards the prover and verifier engage in a proving phase where the prover demonstrates that the statement is correct (Section 5.2.3).</p>

    <p class="text-gray-300">Definition 8 (Commit-and-Prove CSS). A commit-and-prove checkable subspace sampling argument over a field  <span class="math">\\mathbb{F}</span> , is a tuple of PPT algorithms  <span class="math">(\\mathcal{P}_{\\mathrm{CSS}},\\mathcal{V}_{\\mathrm{CSS}})</span>  that defines  <span class="math">k,m\\in \\mathbb{N}</span> , a set of allowed vectors of polynomials  <span class="math">\\mathcal{M}(X)</span> , a coinspace  <span class="math">\\mathcal{C}</span> , a sampling function  <span class="math">\\mathsf{Smp}:\\mathcal{C}\\to \\mathbb{F}^m</span>  and runs in four different stages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commit Phase: The prover  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  sends a vector of polynomials  <span class="math">\\vec{p}_{\\vec{M}}(X)</span>  that succinctly describe a vector  <span class="math">\\vec{M}(X) \\in \\mathcal{M}(X)</span> .</li>

      <li>Sampling Phase: Prover  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  and verifier  <span class="math">\\mathcal{V}_{\\mathrm{CSS}}</span>  engage in an interactive protocol Sample. In some round, the verifier sends  <span class="math">\\mathsf{cn}\\mathsf{s} \\gets \\mathcal{C}</span> , and the prover replies with a polynomial  <span class="math">D(X) = \\vec{s}^{\\top}\\vec{M}(X)</span> , for  <span class="math">\\vec{s} = \\mathsf{Smp}(\\mathsf{cn}\\mathsf{s})</span> .</li>

      <li>Proving Phase:  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  and  <span class="math">\\mathcal{V}_{\\mathrm{CSS}}</span>  engage in an interactive protocol to prove that  <span class="math">(\\vec{p}_{\\vec{M}}(X), \\mathsf{cn}, D(X)) \\in \\mathcal{L}_{\\mathrm{CSS}}</span>  where  <span class="math">\\mathcal{L}_{\\mathrm{CSS}}</span>  is the language for the following relation:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R} _ {\\mathsf {C S S}} = \\left\\{ \\begin{array}{c c} \\big ((\\vec {p} _ {\\vec {M}} (X), \\mathsf {c n s}, D (X)), \\vec {M} (X) \\big) &amp;amp; \\begin{array}{c} \\vec {M} (X) \\in \\mathcal {M} (X) \\\\ \\vec {p} _ {\\vec {M}} (X) = C o m m i t (\\vec {M} (X)) \\\\ \\vec {s} = \\mathsf {S m p} (\\mathsf {c n s}); \\\\ D (X) = \\vec {s} ^ {\\top} \\vec {M} (X) \\end{array} \\end{array} \\right\\}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decision Phase: When the proving phase is concluded, the verifier outputs a bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">Completeness. A Commit-and-Prove checkable subspace sampling argument is complete if for any  <span class="math">\\left((\\vec{p}_{\\vec{M}}(X),\\mathsf{cn},\\mathcal{D}(X)),(\\vec{M} (X))\\right)\\in \\mathsf{R}_{\\mathsf{CSS}}</span>  , the probability of this event is 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c} 1 \\leftarrow \\langle \\mathcal {P} _ {\\mathsf {C S S}} (\\mathsf {i n s t}, \\vec {M} (X)), \\mathcal {V} _ {\\mathsf {C S S}} (\\mathsf {i n s t}) \\rangle &amp;amp; \\begin{array}{c} \\vec {p} _ {\\vec {M}} (X) \\leftarrow \\mathcal {P} _ {\\mathsf {C S S}} (\\vec {M} (X)); \\\\ (D (X), \\mathsf {c n s}) \\leftarrow \\mathsf {S a m p l e} \\langle \\mathcal {P} _ {\\mathsf {C S S}} (\\vec {M} (X)), \\mathcal {V} _ {\\mathsf {C S S}} (\\mathcal {C}) \\rangle ; \\\\ \\mathsf {i n s t} \\leftarrow (\\vec {p} _ {\\vec {M}} (X), \\mathsf {c n s}, D (X)) \\end{array} \\end{array} \\right]</span></div>

    <p class="text-gray-300">Baloo</p>

    <p class="text-gray-300">Soundness. A Commit-and-Prove checkable subspace sampling argument is  <span class="math">\\epsilon</span> -sound if for any polynomial-time prover  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}^{<em>} = (\\mathcal{P}_{\\mathrm{CSS},1}^{</em>},\\mathcal{P}_{\\mathrm{CSS},2}^{*})</span> , the probability of the following event is less than  <span class="math">\\epsilon</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c} &amp;amp; \\vec {p} _ {\\vec {M}} (X) \\leftarrow \\mathcal {P} _ {\\mathsf {C S S}, 1} ^ {*}; \\\\ \\mathsf {i n s t} \\notin \\mathcal {L} (\\mathsf {R} _ {\\mathsf {C S S}}) &amp;amp; (\\mathsf {c n s}, D (X)) \\leftarrow \\mathsf {S a m p l e} \\langle \\mathcal {P} _ {\\mathsf {C S S}, 2} ^ {*} (\\vec {p} _ {\\vec {M}} (X)), \\mathcal {V} _ {\\mathsf {C S S}, 1} (\\mathcal {C}) \\rangle ; \\\\ b = 1 &amp;amp; \\mathsf {i n s t} \\leftarrow (\\vec {p} _ {\\vec {M}} (X), \\mathsf {c n s}, D (X)) \\\\ &amp;amp; b \\leftarrow \\langle \\mathcal {P} _ {\\mathsf {C S S}} ^ {*} (\\mathsf {i n s t}), \\mathcal {V} _ {\\mathsf {C S S}, 2} (\\mathsf {i n s t}) \\rangle \\end{array} \\right]</span></div>

    <p class="text-gray-300">Commit Phase: Similar to [RZ21], we encode matrix  <span class="math">\\mathbf{M}</span>  following Marlin  <span class="math">[\\mathrm{CHM}^{+}20]</span> , through the bivariate polynomial (Eq. 3, Section 4.2)</p>

    <div class="my-4 text-center"><span class="math-block">M (X, Y) = \\sum_ {j = 1} ^ {m} \\tau_ {\\mathsf {c o l} (j)} (0) ^ {- 1} \\tau_ {\\mathsf {c o l} (j)} (X) \\mu_ {j} (Y),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{col}:[m]\\mapsto [k]</span>  is such that  <span class="math">\\mathsf{col}(j) = i</span>  if and only if  <span class="math">M_{j,i}</span>  is the only non-zero element in row  <span class="math">j</span>  of  <span class="math">\\mathbf{M}</span> , and  <span class="math">\\{\\mu_j(X)\\}_{j = 1}^m</span> ,  <span class="math">\\{\\tau_i(X)\\}_{i = 1}^k</span>  are the Lagrange interpolation polynomials of some set  <span class="math">\\mathbb{V}</span>  of size  <span class="math">m</span>  and  <span class="math">\\mathbb{H}_I</span>  of size  <span class="math">k</span> , respectively. Note that  <span class="math">M(X,Y)</span>  is naturally an encoding of  <span class="math">\\vec{M} (X)</span>  as well.</p>

    <p class="text-gray-300">We will use the set of polynomials  <span class="math">\\{\\hat{\\tau}_i(X) = \\frac{\\tau_i(X)}{\\tau_i(0)}\\}_{i=1}^k</span>  instead of simply  <span class="math">\\tau_i(X)</span> , to later implement the Generalized Sumcheck of Section 3.7.</p>

    <p class="text-gray-300">Therefore, we define the allowed set of vectors of polynomials that define lookup matrices for which we can design a CSS as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {M} (X) = \\left\\{\\left(\\hat {\\tau} _ {\\mathsf {c o l} (1)} (X), \\dots , \\hat {\\tau} _ {\\mathsf {c o l} (m)} (X)\\right): \\text {f o r s o m e} \\mathsf {c o l}: [ m ] \\mapsto [ k ] \\text {a n d} \\mathbb {H} _ {I} \\subset \\mathbb {H} \\right\\}.</span></div>

    <p class="text-gray-300">The succinct representation of  <span class="math">\\vec{M}(X)</span>  is a polynomial  <span class="math">v(X)</span>  where  <span class="math">v(\\nu_j) = \\xi_{\\mathsf{col}(j)}^{-1}</span>  for all  <span class="math">\\nu_j \\in \\mathbb{V}</span> . Recall that all  <span class="math">\\xi_i</span>  equal some  <span class="math">\\omega^s \\in \\mathbb{H}_I</span> . This polynomial declares for each row in  <span class="math">\\mathbf{M}</span>  which is the column that takes value 1. As  <span class="math">\\mathbb{H}_I</span>  is unknown to the verifier, the representation of  <span class="math">\\vec{M}(X)</span>  must include information about it, and so includes the vanishing polynomial of  <span class="math">\\mathbb{H}_I z_I(X) = \\prod_{\\xi \\in \\mathbb{H}_I} (X - \\xi)</span></p>

    <p class="text-gray-300">Sampling Phase: As in  <span class="math">\\left[\\mathrm{CHM}^{+}20\\right]</span> , computing an encoding of a vector sampled in the row space of  <span class="math">\\mathbf{M}</span>  using verifier's coin  <span class="math">\\alpha</span> , is done through a partial evaluation  <span class="math">M(X,\\alpha)</span> . That is,</p>

    <div class="my-4 text-center"><span class="math-block">D (X) = M (X, \\alpha) = \\sum_ {j = 1} ^ {m} \\tau_ {\\mathsf {c o l} (j)} (0) ^ {- 1} \\tau_ {\\mathsf {c o l} (j)} (X) \\mu_ {j} (\\alpha)</span></div>

    <p class="text-gray-300">is an encoding of  <span class="math">\\vec{d} = \\sum_{j=1}^{m} \\mu_j(\\alpha) \\vec{M}_j</span> , where  <span class="math">\\vec{M}_j</span>  is the jth row of  <span class="math">\\mathbf{M}</span>  and is a unit vector in  <span class="math">\\mathbb{F}^k</span> . Proving well-formedness of  <span class="math">D(X)</span>  can be thought now as proving that  <span class="math">D(X) = \\vec{s}^\\top \\vec{M}(X)</span>  for some  <span class="math">\\vec{M}(X) \\in \\mathcal{M}(X)</span>  and  <span class="math">\\vec{s} = (\\mu_1(\\alpha), \\ldots, \\mu_m(\\alpha))</span> . That is,  <span class="math">\\mathsf{cn}\\mathbf{s} = \\alpha</span>  and  <span class="math">\\mathsf{Samp}(X) = \\vec{\\mu}(X)</span> .</p>

    <p class="text-gray-300">Proving Phase: Then the proving phase is run with respect to  <span class="math">\\mathsf{R}_{I,\\vec{M}}\\in \\mathsf{R}_{\\mathsf{CSS}}</span>  ..</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {I, \\vec {M}} = \\left\\{\\left((v (X), z _ {I} (X), \\alpha , D (X)), \\vec {M} (X)\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} v (\\nu_ {j}) = \\xi_ {\\mathsf {c o l} (j)} ^ {- 1} \\text {f o r a l l} \\nu_ {j} \\in \\mathbb {V} \\\\ z _ {I} (X) = \\prod_ {\\xi \\in \\mathbb {H} _ {I}} (X - \\xi) \\\\ \\vec {s} = (\\mu_ {j} (\\alpha)) _ {j = 1} ^ {m}, \\\\ D (X) = \\vec {s} ^ {\\top} \\vec {M} (X) = \\sum_ {j = 1} ^ {m} \\mu_ {j} (\\alpha) \\hat {\\tau} _ {\\mathsf {c o l} (j)} (X) \\end{array} \\right. \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In Fig. 4 we provide a commit-and-prove CSS for the relation defined above. During the committing and sampling phase the prover and verifier agree on an instance</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 4: Commit-and-Prove CSS for  <span class="math">\\vec{M}(X) \\in \\mathcal{M}(X)</span> .</p>

    <p class="text-gray-300"><span class="math">(z_{I}(X),v(X),\\alpha ,D(X))</span>  where  <span class="math">z_{I}(X) = \\prod_{i = 1}^{k}(X - \\xi_{i})</span>  . Note that  <span class="math">z_{I}(X)</span>  is proven to be correctly formed in the Caulk+ core protocol (see Section 5.1).</p>

    <p class="text-gray-300">To prove well-formedness of  <span class="math">D(X)</span> , we first recall that every lookup matrix is a transpose of a basic matrix, as defined in [RZ21]. Indeed, lookup matrices have only one non-zero element per row, while basic matrices have just one non-zero element per column. What is more, the rowspace of matrix  <span class="math">\\mathbf{M}</span>  is the column space of  <span class="math">\\mathbf{M}^{\\top}</span> . Then, it is the same to sample an element in the column space of  <span class="math">\\mathbf{M}^{\\top}</span>  or in the row space of  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">What is more,  <span class="math">M(X,Y) = \\sum_{i=1}^{k} \\sum_{j=1}^{m} M_{i,j} \\tau_i(X) \\mu_j(Y)</span>  is an encoding of both  <span class="math">\\mathbf{M}</span>  and  <span class="math">\\mathbf{M}^\\top</span> . Thus, we observe that  <span class="math">E(X) = M(\\beta, X)</span>  encodes a vector sampled in the column space of  <span class="math">\\mathbf{M}^\\top</span>  and a vector sampled in the row space of its transpose  <span class="math">\\mathbf{M}</span>  using the same coin  <span class="math">\\beta</span> . So we use the argument in [RZ21] to prove correct computation of the polynomial  <span class="math">E(X)</span>  that encodes a basic matrix, and then use the fact that if for a uniformly sampled  <span class="math">\\alpha \\in \\mathbb{F}</span> <span class="math">E(\\alpha) = D(\\beta)</span> , it must be the case that  <span class="math">D(X) = M(X, \\alpha)</span> , i.e.,  <span class="math">D(X)</span>  encodes a vector in the row space of  <span class="math">\\mathbf{M}</span>  sampled with coins  <span class="math">\\alpha</span> . So during the proving phase, the prover first sends a commitment to the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">E (X) = M (X, \\beta) = \\sum_ {j = 1} ^ {m} \\tau_ {\\operatorname {c o l} (j)} (0) ^ {- 1} \\tau_ {\\operatorname {c o l} (j)} (\\beta) \\mu_ {j} (X).</span></div>

    <p class="text-gray-300">They prove that  <span class="math">E(X)</span>  has exactly this form by showing that (i)  <span class="math">E(X)</span>  has degree less than  <span class="math">m</span>  and (ii)  <span class="math">E(\\nu_j) = \\tau_{\\mathrm{col}(j)}(0)^{-1}\\tau_{\\mathrm{col}(j)}(\\beta)</span>  for all  <span class="math">\\nu_j \\in V</span> . Below, we prove that point (ii) holds if and only if there exists  <span class="math">Q_1(X)</span>  such that</p>

    <p class="text-gray-300">4In our protocol, well-formedness of z_{I}(X)  is given by Caulk+ core.</p>

    <p class="text-gray-300">Baloo</p>

    <p class="text-gray-300">Theorem 3. The protocol in Fig 4 satisfies completeness.</p>

    <p class="text-gray-300">Proof. To prove that equation (ii) in the verifier check is satisfied, first recall that <span class="math">\\sum_{j=1}^{m} \\mu_j(X) = 1</span> (Section 3.2) and note:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} E(X)(\\beta v(X) - 1) &amp;amp;= \\left(\\sum_{j=1}^{m} \\tau_{\\operatorname{col}(j)}(\\beta)(\\tau_{\\operatorname{col}(j)}(0))^{-1} \\mu_j(X)\\right) \\left(\\beta \\sum_{j=1}^{m} \\xi_{\\operatorname{col}(j)}^{-1} \\mu_j(X) - \\sum_{j=1}^{m} \\mu_j(X)\\right) \\\\ &amp;amp;= \\left(\\sum_{j=1}^{m} \\tau_{\\operatorname{col}(j)}(\\beta)(\\tau_{\\operatorname{col}(j)}(0))^{-1} \\mu_j(X)\\right) \\left(\\sum_{j=1}^{m} \\left(\\beta \\xi_{\\operatorname{col}(j)}^{-1} - 1\\right) \\mu_j(X)\\right) \\\\ &amp;amp;= \\sum_{j=1}^{m} \\tau_{\\operatorname{col}(j)}(\\beta)(\\tau_{\\operatorname{col}(j)}(0))^{-1} \\left(\\beta \\xi_{\\operatorname{col}(j)}^{-1} - 1\\right) \\mu_j^2(X) \\\\ &amp;amp;\\quad + \\sum_{j=1}^{m} \\sum_{r \\neq j} \\tau_{\\operatorname{col}(j)}(\\beta)(\\tau_{\\operatorname{col}(j)}(0))^{-1} \\left(\\beta \\xi_{\\operatorname{col}(r)}^{-1} - 1\\right) \\mu_r(X) \\mu_j(X) \\end{aligned}</span></div>

    <p class="text-gray-300">Since <span class="math">\\mu_j^2(X) \\equiv \\mu_j(X) \\mod z_V(X)</span> and <span class="math">z_V(X) \\mid \\mu_j(X) \\mu_r(X)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">= \\sum_{j=1}^{m} \\tau_{\\operatorname{col}(j)}(\\beta)(\\tau_{\\operatorname{col}(j)}(0))^{-1} \\left(\\beta \\xi_{\\operatorname{col}(j)}^{-1} - 1\\right) \\mu_j(X) \\mod z_V(X)</span></div>

    <p class="text-gray-300">Expanding the definition of <span class="math">\\tau_{\\operatorname{col}(j)}(\\beta)</span> and <span class="math">\\tau_{\\operatorname{col}(j)}^{-1}(0)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp;= \\sum_{j=1}^{m} \\left(\\prod_{i \\in I, i \\neq \\operatorname{col}(j)} \\frac{\\beta - \\xi_i}{\\xi_j - \\xi_i} \\frac{\\xi_j - \\xi_i}{-\\xi_i}\\right) \\left(\\beta \\xi_{\\operatorname{col}(j)}^{-1} - 1\\right) \\mu_j(X) \\mod z_V(X) \\\\ &amp;amp;= \\sum_{j=1}^{m} \\left(\\prod_{i \\neq \\operatorname{col}(j)} \\frac{\\beta - \\xi_i}{-\\xi_i}\\right) \\left(\\beta \\xi_{\\operatorname{col}(j)}^{-1} - 1\\right) \\mu_j(X) \\mod z_V(X) \\\\ &amp;amp;= \\sum_{j=1}^{m} \\left(\\prod_{i \\neq \\operatorname{col}(j)} \\frac{\\beta - \\xi_i}{-\\xi_i}\\right) \\xi_{\\operatorname{col}(j)}^{-1} \\left(\\beta - \\xi_{\\operatorname{col}(j)}\\right) \\mu_j(X) \\mod z_V(X) \\\\ &amp;amp;= z_I(\\beta) \\sum_{j=1}^{m} \\left(\\prod_{i \\neq \\operatorname{col}(j)} \\frac{1}{-\\xi_i}\\right) \\xi_{\\operatorname{col}(j)}^{-1} \\mu_j(X) \\mod z_V(X) \\\\ &amp;amp;= -z_I(\\beta) z_I(0)^{-1} \\sum_{j=1}^{m} \\mu_j(X) = -z_I(\\beta) z_I(0)^{-1} \\mod z_V(X) \\end{aligned}</span></div>

    <p class="text-gray-300">Thus, there exists <span class="math">Q_1(X)</span> such that <span class="math">E(X)(\\beta v(X) - 1) + z_I(\\beta) z_I(0)^{-1} = Q_1(X) z_V(X)</span>.</p>

    <p class="text-gray-300">Equation (iii) follows as <span class="math">D(X) = M(X, \\alpha)</span> and <span class="math">E(X) = M(\\beta, X)</span>.</p>

    <p class="text-gray-300">Theorem 4. If <span class="math">z_I(X) = \\prod_{i=1}^{k}(X - \\xi_i)</span> for unique roots <span class="math">\\xi_i</span> then the CSS protocol in Fig. 4 is sound.</p>

    <p class="text-gray-300">Proof. Set <span class="math">v_j = v(\\nu_j)</span> for all <span class="math">j \\in [m]</span>, then there exists <span class="math">q(X) \\in \\mathbb{F}[X]</span> such that <span class="math">v(X) = \\sum_{j=1}^{m} v_j \\mu_j(X) + z_V(X) q(X)</span>. We first argue that the PHP enforces the form of <span class="math">E(X)</span> with respect to the evaluations <span class="math">\\{v_j\\}_{j \\in [m]}</span>. We then argue that given this <span class="math">E(X)</span>, the form of <span class="math">D(X)</span> is determined by <span class="math">v(X)</span> and <span class="math">z_I(X)</span> except with negligible probability. Third we will show that <span class="math">v_j^{-1}</span> is a root of <span class="math">z_I(X)</span> for all <span class="math">j \\in [m]</span>. Finally we will show that <span class="math">D(X)</span> is exactly in our allowed set of matrices.</p>

    <p class="text-gray-300">Form of <span class="math">E(X)</span>: We show <span class="math">E(X) = \\sum_{j=1}^{m} \\left( \\frac{-z_I(\\beta)}{z_I(0)(\\beta v_j - 1)} \\right) \\mu_j(X)</span> except with negligible probability over the choice of <span class="math">\\beta</span>. Since <span class="math">\\deg(E) &amp;lt; m</span>, there exist coefficients <span class="math">\\{e_j\\}_{j=1}^m</span> such</p>

    <p class="text-gray-300">17</p>

    <p class="text-gray-300">that <span class="math">E(X) = \\sum_{j=1}^{m} e_j \\mu_j(X)</span>. So we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} E (X) (\\beta v (X) - 1) = \\left(\\sum_ {j = 1} ^ {m} e _ {j} \\mu_ {j} (X)\\right) \\left(\\beta \\sum_ {j = 1} ^ {m} v _ {j} \\mu_ {j} (X) + \\beta z _ {V} (X) q (X) - \\sum_ {j = 1} ^ {m} \\mu_ {j} (X)\\right) \\\\ = \\sum_ {j = 1} ^ {m} e _ {j} (\\beta v _ {j} - 1) \\mu_ {j} (X) \\mod z _ {V} (X). \\end{array}</span></div>

    <p class="text-gray-300">Since <span class="math">\\beta \\notin \\mathbb{H}_I</span>, <span class="math">z_I(\\beta) \\neq 0</span> and equation (ii) says that for all <span class="math">\\nu_j \\in \\mathbb{V}</span>, <span class="math">\\sum_{j=1}^{m} e_j(\\beta v_j - 1) \\mu_j(\\nu_j) + z_I(\\beta) z_I(0)^{-1} = 0</span>, and then for all <span class="math">j \\in [m]</span>, <span class="math">e_j(\\beta v_j - 1) = -z_I(\\beta) z_I(0)^{-1}</span>. Thus for all <span class="math">j</span>, <span class="math">\\beta v_j - 1 \\neq 0</span> and it follows that <span class="math">e_j = \\frac{-z_I(\\beta)}{z_I(0)(\\beta v_j - 1)}</span>.</p>

    <p class="text-gray-300"><strong>Form of <span class="math">D(X)</span></strong>: We show that <span class="math">D(X) = -\\sum_{j=1}^{m} \\frac{z_I(X) \\mu_j(\\alpha)}{z_I(0) v_j(X - v_j^{-1})}</span> except with negligible probability. Let</p>

    <div class="my-4 text-center"><span class="math-block">f (X) = \\sum_ {j = 1} ^ {m} \\left(\\prod_ {s = 1, s \\neq j} ^ {m} \\left(X v _ {s} - 1\\right)\\right) z _ {I} (0) ^ {- 1} z _ {I} (X) \\mu_ {j} (\\alpha) + D (X) \\prod_ {j = 1} ^ {m} \\left(X v _ {j} - 1\\right)</span></div>

    <p class="text-gray-300">Then at random <span class="math">\\beta</span> we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f (\\beta) = \\sum_ {j = 1} ^ {m} \\left(\\prod_ {s = 1, s \\neq j} ^ {m} \\left(\\beta v _ {s} - 1\\right)\\right) z _ {I} (0) ^ {- 1} z _ {I} (\\beta) \\mu_ {j} (\\alpha) + D (\\beta) \\prod_ {j = 1} ^ {m} \\left(\\beta v _ {j} - 1\\right) \\\\ \\Rightarrow \\frac {f (\\beta)}{\\prod_ {j = 1} ^ {m} (\\beta v _ {j} - 1)} = \\sum_ {j = 1} ^ {m} \\frac {z _ {I} (\\beta)}{z _ {I} (0) (\\beta v _ {j} - 1)} \\mu_ {j} (\\alpha) + D (\\beta) \\\\ \\Rightarrow \\frac {f (\\beta)}{\\prod_ {j = 1} ^ {m} (\\beta v _ {j} - 1)} = - E (\\alpha) + D (\\beta) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">provided that <span class="math">\\prod_{j=1}^{m} (\\beta v_j - 1) \\neq 0</span>, which is the case as explained above. Now by the verifier's check (iii) we have <span class="math">-E(\\alpha) + D(\\beta) = 0</span> and hence that <span class="math">f(\\beta) = 0</span>. If <span class="math">f(X) \\neq 0</span> then <span class="math">f(\\beta) \\neq 0</span> except with negligible probability because <span class="math">v(X), z_I(X), D(X)</span> are chosen before <span class="math">\\beta</span>. Thus</p>

    <div class="my-4 text-center"><span class="math-block">D (X) = - \\sum_ {j = 1} ^ {m} \\frac {\\left(\\prod_ {s = 1 , s \\neq j} ^ {m} \\left(X v _ {s} - 1\\right)\\right) z _ {I} (0) ^ {- 1} z _ {I} (X) \\mu_ {j} (\\alpha)}{\\prod_ {j = 1} ^ {m} \\left(X v _ {j} - 1\\right)} = - \\sum_ {j = 1} ^ {m} \\frac {z _ {I} (X) \\mu_ {j} (\\alpha)}{z _ {I} (0) v _ {j} \\left(X - v _ {j} ^ {- 1}\\right)} \\tag {4}</span></div>

    <p class="text-gray-300"><strong>Form of <span class="math">v(X)</span></strong>: We show that for all <span class="math">j \\in [m]</span>, <span class="math">v_{j}^{-1}</span> is a root of <span class="math">z_{I}(X)</span>. In other words, there exists a map <span class="math">\\mathsf{col}:[m] \\mapsto [k]</span> such that for all <span class="math">j \\in [m]</span>, <span class="math">v_{j}^{-1} = \\xi_{\\mathsf{col}(j)}</span>. Indeed, define <span class="math">J = \\{j : v_{j}^{-1} \\notin \\mathbb{H}_{I}\\}</span>, and the set <span class="math">V = \\{v_{j} : j \\in J\\}</span>. We assume for contradiction that there is some <span class="math">v_{j}^{-1}</span> that is not a root of <span class="math">z_{I}(X)</span>, which means that <span class="math">V</span> is not empty. Then,</p>

    <div class="my-4 text-center"><span class="math-block">D _ {J ^ {c}} (X) = - \\sum_ {j \\in [ m ] \\backslash J} \\frac {z _ {I} (X) \\mu_ {j} (\\alpha)}{z _ {I} (0) v _ {j} (X - v _ {j} ^ {- 1})}</span></div>

    <p class="text-gray-300">is a polynomial, and following the definition of <span class="math">D(X)</span> in Eq. 4 we can write:</p>

    <div class="my-4 text-center"><span class="math-block">D (X) - D _ {J ^ {c}} (X) = - \\sum_ {j \\in J} \\frac {z _ {I} (X) \\mu_ {j} (\\alpha)}{z _ {I} (0) v _ {j} (X - v _ {j} ^ {- 1})} =</span></div>

    <p class="text-gray-300">18 Baloo</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\frac {z _ {I} (X)}{z _ {I} (0)} \\sum_ {v \\in V} \\frac {1}{v (X - v ^ {- 1})} \\left(\\sum_ {j: v _ {j} = v} \\mu_ {j} (\\alpha)\\right) - \\frac {z _ {I} (X)}{z _ {I} (0)} \\sum_ {v \\in V} \\frac {P _ {v} (\\alpha)}{v (X - v ^ {- 1})},</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where, for any <span class="math">v \\in V</span>, <span class="math">P_v(X) = \\sum_{j:v_j = v} \\mu_j(X)</span>. Regardless of <span class="math">\\alpha</span>, this identity can only hold if, for all <span class="math">v \\in V</span>, <span class="math">P_v(\\alpha) = 0</span>. Indeed, the left side is a polynomial because the prover sent <span class="math">D(X)</span> and <span class="math">D_{J^c}(X)</span> is a polynomial by definition of <span class="math">J</span>, but a polynomial cannot be equal to a sum of non-trivial rational functions with different poles. The probability that <span class="math">P_v(\\alpha) = 0</span> for all <span class="math">v \\in V</span> can be bounded by the probability that <span class="math">P_v(\\alpha) = 0</span> for any single <span class="math">v \\in V</span>. But this probability is at most $\\frac{m - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, because all these polynomials were defined independently of </span>\\alpha<span class="math">. We conclude that the probability that </span>V$ is not empty is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">D(X)</span> is in the space of allowed matrices: Let us substitute our mapping <span class="math">\\mathsf{col}</span> from <span class="math">v_{j}^{-1}</span> to the roots of <span class="math">z_{I}(X)</span> into our expression for <span class="math">D(X)</span> in Eq. 4:</p>

    <div class="my-4 text-center"><span class="math-block">D (X) = - \\sum_ {j = 1} ^ {m} \\frac {z _ {I} (X) \\mu_ {j} (\\alpha)}{z _ {I} (0) \\xi_ {\\mathsf {c o l} (j)} ^ {- 1} (X - \\xi_ {\\mathsf {c o l} (j)})} = \\sum_ {j = 1} ^ {m} \\frac {- \\xi_ {\\mathsf {c o l} (j)} z _ {I} (X) \\mu_ {j} (\\alpha)}{z _ {I} (0) (X - \\xi_ {\\mathsf {c o l} (j)})}</span></div>

    <p class="text-gray-300">Now the lagrange polynomials for the set <span class="math">\\{\\xi_i\\}_{i=1}^k</span> are given by</p>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {i} (X) = \\prod_ {s = 1, s \\neq i} ^ {k} \\frac {X - \\xi_ {s}}{\\xi_ {i} - \\xi_ {s}} = \\prod_ {s = 1, s \\neq i} ^ {k} (X - \\xi_ {s}) \\prod_ {s = 1, s \\neq i} ^ {k} \\frac {1}{\\xi_ {i} - \\xi_ {s}} = \\frac {z _ {I} (X)}{(X - \\xi_ {i})} \\prod_ {s = 1, s \\neq i} ^ {k} \\frac {1}{(\\xi_ {i} - \\xi_ {s})}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Evaluating in } X = 0, \\tau_{\\mathsf{col}(j)}(0) = \\frac{z_{I}(0)}{-\\xi_{\\mathsf{col}(j)}} \\prod_{s=1, s \\neq \\mathsf{col}(j)}^{k} \\frac{1}{(\\xi_{\\mathsf{col}(j)} - \\xi_{s})} \\text{ and}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tau_{\\mathsf{col}(j)}(0)^{-1} \\tau_{\\mathsf{col}(j)}(X) = \\\\ = \\left(\\frac{-\\xi_{\\mathsf{col}(j)}}{z_{I}(0)} \\prod_{s=1, s \\neq \\mathsf{col}(j)}^{k} (\\xi_{\\mathsf{col}(j)} - \\xi_{s})\\right) \\left(\\frac{z_{I}(X)}{(X - \\xi_{\\mathsf{col}(j)})} \\prod_{s=1, s \\neq \\mathsf{col}(j)}^{k} \\frac{1}{(\\xi_{\\mathsf{col}(j)} - \\xi_{s})}\\right) \\\\ = \\frac{-\\xi_{\\mathsf{col}(j)}}{z_{I}(0)} \\frac{z_{I}(X)}{(X - \\xi_{\\mathsf{col}(j)})} \\end{array}</span></div>

    <p class="text-gray-300">Substituting these into our expression for <span class="math">D(X)</span> yields our result:</p>

    <div class="my-4 text-center"><span class="math-block">D (X) = \\sum_ {j = 1} ^ {m} \\tau_ {\\mathsf {c o l} (j)} (0) ^ {- 1} \\tau_ {\\mathsf {c o l} (j)} (X) \\mu_ {j} (\\alpha) = \\sum_ {j = 1} ^ {m} \\mu_ {j} (\\alpha) \\hat {\\tau} _ {\\mathsf {c o l} (j)} (X)</span></div>

    <p class="text-gray-300">5.2.4 Inner products from Generalized Sumcheck</p>

    <p class="text-gray-300">In Fig. 5, we introduce a PHP for proving that for two vectors <span class="math">\\vec{a}, \\vec{b} \\in \\mathbb{F}^k</span> encoded as polynomials <span class="math">a(X), b(X)</span> and an element <span class="math">\\sigma \\in \\mathbb{F}</span> it is true that <span class="math">\\vec{a} \\cdot \\vec{b} = \\sigma</span>. Formally, we build a PHP for the following relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R} _ {\\mathsf {g l P}} = \\left\\{ \\begin{array}{c c} (a (X), b (X), \\sigma , z _ {I} (X))  ; &amp;amp; a _ {i} = a (\\xi_ {i}) \\tau_ {i} (0) ^ {- 1}, b _ {i} = b (\\xi_ {i}) \\\\ (\\vec {a}, \\vec {b}, \\mathbb {H} _ {I}) &amp;amp; \\text { and } \\sum_ {i = 1} ^ {k} a _ {i} b _ {i} = \\sigma \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">for  <span class="math">\\mathbb{H}_I = \\{\\xi_i\\}_{i=1}^k</span>  some fixed set of known size  <span class="math">k</span> ,  <span class="math">\\{\\tau_i(X)\\}_{i=1}^k</span>  its Lagrange interpolation polynomials, and  <span class="math">z_I(X)</span>  its vanishing polynomial.</p>

    <p class="text-gray-300">Importantly, our scheme uses polynomial encodings of both vectors, but in the case of vector  <span class="math">\\vec{a}</span>  the encoding is normalized, in particular,  <span class="math">a(X) = \\sum_{i=1}^{k} a_i \\hat{\\tau}_i(X) = \\sum_{i=1}^{k} a_i \\frac{\\tau_i(X)}{\\tau_i(0)}</span> . This is because we will instantiate our inner product argument setting  <span class="math">a(X)</span>  to be polynomial  <span class="math">D(X)</span>  from the previous section and  <span class="math">D(X) = \\sum_{i=1}^{k} \\frac{d_i}{\\tau_i(0)} \\tau_i(X)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">z_{I}(X)</span>  be the vanishing polynomial of  <span class="math">\\mathbb{H}_I</span> . Inspired by the linear check of Aurora [BCR+19], we compute an encoding  <span class="math">\\sum_{i = i}^{k}a_{i}b_{i}\\hat{\\tau}_{i}(X)</span>  of the Hadamard product between  <span class="math">\\vec{a},\\vec{b}</span>  and use a univariate sumcheck argument to obtain the inner product from it. Importantly, since  <span class="math">\\mathbb{H}_I</span>  may contain any set of distinct points that do not necessarily form a multiplicative group, we instantiate our inner product argument with the generalized sumcheck in Section 3.7.</p>

    <p class="text-gray-300">Offline Phase: On input  <span class="math">\\mathsf{R}_{\\mathsf{gIP}}</span> ,  <span class="math">\\mathcal{I}_{\\mathsf{IP}}</span>  outputs the polynomial  <span class="math">z_{I}(X) = \\prod_{\\xi \\in \\mathbb{H}_{I}}(X - \\xi)</span> . Online Phase:  <span class="math">\\mathcal{P}_{\\mathsf{IP}}(z_I(X),a(X),b(X))</span>  computes  <span class="math">R(X),Q(X)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">a (X) b (X) - \\sigma = X R (X) + z _ {I} (X) Q (X).</span></div>

    <p class="text-gray-300">It outputs  <span class="math">(R(X),Q(X))</span>  and a proof that  <span class="math">z_{I}(X)</span>  has distinct  <span class="math">k</span>  roots.</p>

    <p class="text-gray-300">Decision Phase:  <span class="math">\\mathcal{V}_{\\mathrm{IP}}(z_I(X),a(X),b(X),R(X),Q(X))</span>  accepts if and only if (i)  <span class="math">\\deg (R(X)) &amp;lt; k - 1</span> , (ii)</p>

    <div class="my-4 text-center"><span class="math-block">a (X) b (X) - \\sigma = X R (X) + z _ {I} (X) Q (X),</span></div>

    <p class="text-gray-300">and (iii)  <span class="math">z_{I}(X)</span>  has distinct  <span class="math">k</span>  roots.</p>

    <p class="text-gray-300">Figure 5: PHP for a generalised inner product argument. As before, well-formedness of  <span class="math">z_{I}(X)</span>  is given by Caulk+ core.</p>

    <p class="text-gray-300">Theorem 5 (Inner Product Polynomial Relation). The argument in Fig. 5 is a sound PHP for the relation  <span class="math">\\mathsf{R}_{\\mathsf{gIP}}</span> , as defined in Definition 4.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\xi_{i}</span> ,  <span class="math">i = 1, \\ldots, k</span>  be the roots of  <span class="math">z_{I}(X)</span> . If we define  <span class="math">a_{i} = a(\\xi_{i})\\tau_{i}(0)^{-1}</span>  and  <span class="math">b_{i} = b(\\xi_{i})</span> , we can represent  <span class="math">a(X) = \\sum_{i=1}^{k} a_{i}\\tau_{i}(0)^{-1}\\tau_{i}(X) + z_{I}(X)q_{1}(X)</span>  and  <span class="math">b(X) = \\sum_{j=1}^{k} b_{j}\\tau_{j}(X) + z_{I}(X)q_{2}(X)</span> . Then there exists  <span class="math">q_{3}(X)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">a (X) b (X) = \\left(\\sum_ {i = 1} ^ {k} a _ {i} \\tau_ {i} (0) ^ {- 1} \\tau_ {i} (X)\\right) \\left(\\sum_ {j = 1} ^ {k} b _ {j} \\tau_ {j} (X)\\right) + z _ {I} (X) q _ {3} (X).</span></div>

    <p class="text-gray-300">We recall that for  <span class="math">i \\neq j</span> ,  <span class="math">z_{I}(X) \\mid (\\tau_{i}(X) \\tau_{j}(X))</span>  and also  <span class="math">z_{I}(X) \\mid \\tau_{i}^{2}(X) - \\tau_{i}(X)</span>  for all  <span class="math">i \\in [k]</span>  (Section 3.2). Hence, there exists  <span class="math">q_{4}(X)</span>  such that  <span class="math">a(X)b(X) = \\sum_{i} a_{i} b_{i} \\tau_{i}(0)^{-1} \\tau_{i}(X) + z_{I}(X) q_{4}(X)</span> . Finally observe that  <span class="math">\\sum_{i} a_{i} b_{i} \\tau_{i}(0)^{-1} \\tau_{i}(X) = \\sum_{i} a_{i} b_{i} + X R(X)</span> . This is because the left hand side evaluated at 0 is  <span class="math">\\sum_{i} a_{i} b_{i} \\tau_{i}(0)^{-1} \\tau_{i}(0) = \\sum_{i} a_{i} b_{i}</span> . For some  <span class="math">X R(X)</span>  of degree strictly smaller than  <span class="math">z_{I}(X)</span> . Putting this together we have that</p>

    <div class="my-4 text-center"><span class="math-block">a (X) b (X) = \\sum_ {i} a _ {i} b _ {i} + X R (X) + z _ {I} (X) q _ {4} (X)</span></div>

    <p class="text-gray-300">and therefore  <span class="math">\\sum_{i}a_{i}b_{i} = \\sigma</span>  if and only if  <span class="math">a(X)b(X) - \\sigma = XR(X) + z_I(X)Q(X)</span>  for some  <span class="math">R(X), Q(X)</span>  for  <span class="math">R(X)</span>  of degree  <span class="math">k - 2</span> .</p>

    <p class="text-gray-300">Baloo</p>

    <p class="text-gray-300">In Section 6.1, we compile the CCS of Fig. 4 and PHP of Fig. 5 into a non-interactive argument of knowledge cp-expansion, following the compiler in  <span class="math">\\mathrm{[CFF^{+}21]}</span> , and obtain the protocol in Fig. 6. The result in  <span class="math">\\mathrm{[CFF^{+}21]}</span>  proves Theorem 6 and thus soundness of our scheme in the AGM, under the q-dfog assumption. In Section 6.2, in Fig. 7 and 8, we fully described Baloo, which is the result of combining the protocol for  <span class="math">\\mathsf{R}_{\\mathsf{cp - expansion}}</span>  below and the Caulk+ core protocol in Section 5.1 that proves  <span class="math">\\mathsf{R}_{\\mathsf{subtable}}</span> . Importantly, the numbers expressed in Table 1 are explained in the rolled-out protocol in Section 6.2, after we apply some efficiency improvements.</p>

    <p class="text-gray-300">In Fig. 6 we describe a protocol for proving the relation</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {\\mathsf {c p - e x p a n s i o n}} = \\left\\{\\left((\\mathsf {c m} _ {\\mathsf {a}}, \\mathsf {c m} _ {\\mathsf {t}}, \\mathbb {H} _ {I}, \\mathbb {V}), (A (X), T (X))\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {c m} _ {\\mathsf {t}} = \\mathsf {K Z G . C o m m i t} (\\mathsf {s r s}, T (X)) \\\\ \\mathsf {c m} _ {\\mathsf {a}} = \\mathsf {K Z G . C o m m i t} (\\mathsf {s r s}, A (X)) \\\\ \\forall \\nu \\in \\mathbb {V}, A (\\nu) \\in \\{T (\\xi_ {i}): \\xi_ {i} \\in \\mathbb {H} \\} \\end{array} \\right. \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The commit and prove lookup takes as input commitments  <span class="math">\\mathsf{cm}_{\\mathsf{t}}</span> ,  <span class="math">\\mathsf{cm}_{\\mathsf{a}}</span>  to vectors  <span class="math">\\vec{t} \\in \\mathbb{F}^k</span> ,  <span class="math">\\vec{a} \\in \\mathbb{F}^m</span>  encoded as polynomials  <span class="math">T(X)</span> ,  <span class="math">A(X)</span> . It also takes as input  <span class="math">[z_I]_2</span>  a commitment to the vanishing polynomial respect to a set  <span class="math">\\mathbb{H}_I = \\{\\xi_1, \\dots, \\xi_k\\}</span> . The polynomial  <span class="math">T(X)</span>  is computed using the Lagrange interpolation basis  <span class="math">\\{\\tau_i(X)\\}_{i=1}^k</span>  corresponding to set  <span class="math">\\mathbb{H}_I</span> . The polynomial  <span class="math">A(X)</span>  is computed using the Lagrange interpolation basis  <span class="math">\\{\\mu_j(X)\\}_{j=1}^m</span>  corresponding to subgroup  <span class="math">\\mathbb{V} = \\{\\nu, \\dots, \\nu^m = 1\\}</span> .</p>

    <p class="text-gray-300">The prover aims to convince the verifier that there exists some mapping  <span class="math">\\mathsf{col}:[m]\\mapsto [k]</span>  such that  <span class="math">a_{j} = t_{\\mathsf{col}(j)}</span>  for all  <span class="math">j\\in [m]</span> . The prover and verifier use as subroutine the CSS from Fig. 4 to agree on an encoding  <span class="math">D(X)</span>  such that for  <span class="math">\\hat{\\tau}_i(X) = (\\tau_i(X)) / (\\tau_i(0))</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">D (X) = \\sum_ {j = 1} ^ {m} \\mu_ {j} (\\alpha) \\hat {\\tau} _ {\\mathsf {c o l} (j)} (X)</span></div>

    <p class="text-gray-300">at a random point  <span class="math">\\alpha</span> . Then the prover and verifier engage in the generalised inner product argument from Fig. 5 so show that, if  <span class="math">d_{i} = D(\\xi_{i})\\tau_{i}(0)</span> , and  <span class="math">T(\\xi_{i}) = t_{i}</span> , then  <span class="math">\\sum_{i=1}^{k} d_{i}t_{i} = A(\\alpha)</span> . Since  <span class="math">d_{i} = \\sum_{j \\in \\mathsf{col}^{-1}(i)} \\mu_{j}(\\alpha)</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">A (\\alpha) = \\sum_ {i = 1} ^ {k} d _ {i} t _ {i} = \\sum_ {i = 1} ^ {k} t _ {i} \\sum_ {j \\in \\mathsf {c o l} ^ {- 1} (i)} \\mu_ {j} (\\alpha) = \\sum_ {j = 1} ^ {m} \\mu_ {j} (\\alpha) t _ {\\mathsf {c o l} (j)}</span></div>

    <p class="text-gray-300">we thus have that  <span class="math">a_{j} = A(\\nu_{j}) = t_{\\mathsf{col}(j)}</span>  with overwhelming probability, as required.</p>

    <p class="text-gray-300">Recall that this protocol is a subroutine of Baloo in Fig. 7 and thus the common inputs to the systems are the KZG commitments to  <span class="math">z_{I}(X), C(X)</span>  and  <span class="math">T(X)</span> . The srs of the full scheme is  <span class="math">\\left(\\{[x^{s}]_{1,2}\\}_{s=1}^{N}\\right)</span> , where  <span class="math">N</span>  is the maximum degree among all polynomials and  <span class="math">x \\gets \\mathbb{F}</span> . Prover and Verifier instantiate  <span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  and  <span class="math">\\mathcal{V}_{\\mathrm{IP}}</span>  for the PHP of Fig. 5. All oracle polynomials sent by  <span class="math">\\mathcal{P}_{\\mathrm{IP}}</span>  are translated into polynomials evaluated (in the source groups) at  <span class="math">x</span> . Polynomial equations are checked by the verifier from group elements using pairings. For quadratic checks, the prover must send the commitments to the polynomials in different source groups.</p>

    <p class="text-gray-300">All the openings at any point, as well as the degrees of the opened polynomials, are proven using the KZG polynomial commitment. For degree checks with  <span class="math">\\deg(p) = d &amp;lt; N</span>  and  <span class="math">p(X)</span>  a polynomial that is never opened, the prover sends a single extra polynomial  <span class="math">\\hat{p}(X) = X^{N - d}p(X)</span> , and the verifier checks one extra pairing equation as explained in Section 3.5.</p>

    <p class="text-gray-300">Theorem 6. The protocol in Fig. 6 is a non-interactive argument of knowledge for the relation  <span class="math">\\mathsf{R}_{\\mathsf{cp - expansion}}</span>  satisfying knowledge soundness and completeness as in Definition 3.</p>

    <p class="text-gray-300">Common input  <span class="math">x = (\\mathsf{cm}_{\\mathfrak{t}} = [T(x)]_1,\\mathsf{cm}_{\\mathfrak{a}} = [A(x)]_1,[z_I]_2 = [z_I(x)]_2,\\mathbb{H}_I,\\mathbb{V})</span>  and  <span class="math">\\mathsf{srs} = \\{\\{[x^s ]_{1,2}\\}_{s = 1}^N\\}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prover}_{\\mathsf{cp - e}}(\\mathsf{srs},\\mathsf{x},A(X),T(X))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">v(X) = \\sum_{j=1}^{m} \\xi_{\\mathrm{col}(j)}^{-1} \\mu_j(X)</span> ,</li>

      <li>Output  <span class="math">\\pi_1 = ([v]_2 = [v(x)]_2, \\cdot)</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Verifier}_{\\mathsf{cp - e}}(\\mathsf{srs},\\mathsf{x},\\pi_1)</span>  : Send  <span class="math">\\alpha \\in \\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prover}_{\\mathsf{cp - e}}(\\mathsf{srs},\\mathsf{x},A(X),T(X),\\alpha)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">D(X) = M(X, \\alpha) = \\sum_{j=1}^{m} \\mu_j(\\alpha) \\hat{\\tau}_{\\mathrm{col}(j)}(X)</span>  and find  <span class="math">R(X), Q_2(X)</span>  such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">D (X) T (X) - A (\\alpha) = X R (X) + z _ {I} (X) Q _ {2} (X)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\hat{R}(X) = X^{N - m + 2}</span></li>

      <li>Output  <span class="math">\\pi_2 = ([D]_2 = [D(x)]_2, [R]_1 = [R(x)]_1, [\\hat{R}]_1 = [\\hat{R}(x)]_1, [Q_2]_1 = [Q_2(x)]_1)</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Verifier}_{\\mathsf{cp - e}}(\\mathsf{srs},\\mathsf{x},\\pi_1,\\pi_2)</span>  : Send  <span class="math">\\beta \\in \\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prover}_{\\mathsf{cp - e}}(\\mathsf{srs},\\mathsf{x},A(X),T(X),\\alpha ,\\beta)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">E(X) = M(\\beta, X) = \\sum_{j=1}^{m} \\mu_j(X) \\hat{\\tau}_{\\mathrm{col}(j)}(\\beta)</span>  and  <span class="math">Q_1(X)</span>  such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">E (X) (\\beta v (X) - 1) + z _ {I} (\\beta) z _ {I} (0) ^ {- 1} = z _ {V} (X) Q _ {1} (X)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\left(u_{1},[w_{1}]_{1}\\right)\\gets</span>  Open.KZG(srsKZG,  <span class="math">[E]_1</span>  ,deg  <span class="math">= m - 1,\\alpha)</span></li>

      <li><span class="math">\\left(u_{2},[w_{2}]_{1}\\right)\\gets</span>  Open.KZG(srsKZG,cm,deg  <span class="math">= \\bot ,\\alpha)</span></li>

      <li><span class="math">\\left(u_{3}, u_{4}, [w_{3}]_{1}\\right) \\gets \\text{Open.KZG}(\\text{srs}_{\\text{KZG}}, [z_{I}]_{2}, \\deg = \\bot, (0, \\beta))</span></li>

      <li><span class="math">\\left(u_{5},[w_{4}]_{1}\\right)\\gets</span>  Open.KZG(srsKZG,[D]2,deg  <span class="math">= \\bot ,\\beta)</span></li>

      <li>Output  <span class="math">\\pi_3 = ([E]_1 = [E(x)]_1, [Q_1]_1 = [Q_1(x)]_1,</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">(u_{1},[w_{1}]_{1}),(u_{2},[w_{2}]_{1}),(u_{3},u_{4},[w_{3}]_{1}),(u_{5},[w_{4}]_{1}))</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Verifier}_{\\mathsf{cp - e}}(\\mathsf{srs},\\mathsf{x},\\pi_1,\\pi_2,\\pi_3)</span>  : Accept if and only if</p>

    <p class="text-gray-300">(i)  <span class="math">e(\\mathsf{cm}_{\\mathfrak{t}},[D]_2) - e(u_2[1]_1,[1]_2) = e([R]_1,[x]_2) + e([Q_2]_1,[z_I]_2)</span>  # Cond (ii) Fig. 5 (ii)e  <span class="math">([E]_1, (\\beta[v]_2 - 1)) + e(u_3^{-1}u_4[1]_1, [1]_2) = e([Q_1]_1, [z_V(x)]_2)</span>  # Cond (ii) Fig. 4</p>

    <p class="text-gray-300">(iii)  <span class="math">e([R]_1, [x^{N - m + 2}]_2) = e([\\hat{R}]_1, [1]_2)</span>  # Cond (i) Fig. 5 <span class="math">(iv)</span> <span class="math">u_{1} = u_{5}</span>  . # Cond (iii) in Fig. 4 (v)  <span class="math">1 \\gets \\mathsf{KZG}</span> . Verify  <span class="math">(\\mathsf{srs}_{\\mathsf{KZG}}, [E]_1, \\deg = m - 1, \\alpha, u_1, [w_1]_1)</span> (vi)  <span class="math">1 \\gets \\mathsf{KZG}</span> . Verify  <span class="math">(\\mathsf{srs}_{\\mathsf{KZG}}, \\mathsf{cm}_{\\mathsf{a}}, \\deg = \\bot, \\alpha, u_2, [w_2]_1)</span> (vii)  <span class="math">1 \\gets \\mathsf{KZG}</span> . Verify  <span class="math">(\\mathsf{srs}_{\\mathsf{KZG}}, [z_I]_2, \\deg = \\bot, (0, \\beta), (u_3, u_4), [w_3]_1)</span> (viii)  <span class="math">1 \\gets \\mathsf{KZG}</span> . Verify  <span class="math">(\\mathsf{srs}_{\\mathsf{KZG}}, [D]_2, \\deg = \\bot, \\beta, u_5, [w_4]_1)</span></p>

    <p class="text-gray-300">Figure 6: cp-expansion argument for proving  <span class="math">A(X)</span>  has entries in a (potentially unknown) subtable  <span class="math">T(X)</span> .</p>

    <p class="text-gray-300">Baloo</p>

    <p class="text-gray-300">In this section, we provide our full Baloo construction for proving the relation</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\text {l o o k u p}} = \\left\\{ \\begin{array}{l l} ((c m _ {c}, c m _ {a}, \\mathbb {H}, \\mathbb {V}), (A (X), C (X)) &amp;amp; \\begin{array}{l} c o m = K Z G. C o m m i t (\\mathsf {s r s}, C (X)) \\\\ c m _ {a} = K Z G. C o m m i t (\\mathsf {s r s}, A (X)) \\\\ \\forall \\nu \\in \\mathbb {V}, A (\\nu) \\in \\{C (\\omega^ {s}): \\omega^ {s} \\in \\mathbb {H} \\} \\end{array} \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbb{V}</span>  is a set of roots of unity that is independent from  <span class="math">N</span> , the size of the lookup table  <span class="math">\\vec{c}</span> . For simplicity we omit  <span class="math">\\vec{c}</span>  and  <span class="math">\\mathbb{V}</span>  from the relation description. The prover for the full construction is formally given in Fig. 7 and the verifier is given in Fig. 8. We also apply several efficiency optimizations which are specified in Appendix B.</p>

    <p class="text-gray-300">Common input:  <span class="math">\\mathsf{cm}_{\\mathsf{c}} = [C(x)]_{1},[z_{H}(x)]_{1} = [\\prod_{i = 0}^{N - 1}(x - \\omega^{s})]_{1}</span> ,  <span class="math">\\mathsf{srs} = \\{[x^i ]_{1,2}\\}_{i = 1}^d</span></p>

    <p class="text-gray-300">Take  <span class="math">\\mathsf{cm}_{\\mathbf{a}}</span>  as input.</p>

    <p class="text-gray-300">Receive  <span class="math">\\pi_1 = ([z_I]_2, [v]_1, [\\mathsf{cm}_t]_1)</span>  and send  <span class="math">\\alpha \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Receive  <span class="math">\\pi_2 = ([D]_1, [R]_1, [Q_2]_1)</span>  and send  <span class="math">\\beta \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Receive  <span class="math">\\pi_3 = ([E]_1, [Q_1]_1)</span>  and send  <span class="math">\\rho, \\gamma \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Receive  <span class="math">\\pi_4 = (u_1, u_2, u_3, u_4, u_5, [a]_1, [w_1]_1, [w_2]_1, [w_3]_1, [w_4]_1)</span></p>

    <p class="text-gray-300">Compute</p>

    <div class="my-4 text-center"><span class="math-block">[ P _ {1} ] _ {1} = u _ {1} [ \\mathrm {c m} _ {\\mathrm {t}} ] - u _ {2} [ 1 ] _ {1} - [ R ] _ {1} - u _ {4} [ Q _ {2} ] _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\# \\left[ P _ {1} \\right] _ {1} = \\left[ T (x) D (\\beta) - A (\\alpha) - R (x) - z _ {I} (\\beta) Q _ {2} (x) \\right] _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">[ P _ {2} ] _ {1} = u _ {5} (\\beta [ v ] _ {1} - 1) + u _ {3} ^ {- 1} u _ {4} - z _ {V} (\\rho) [ Q _ {1} ] _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\# \\left[ P _ {2} \\right] _ {1} = \\left[ E (\\rho) \\left(\\beta v (x) - 1\\right) + z _ {I} (\\beta) z _ {I} (0) ^ {- 1} - z _ {V} (\\rho) Q _ {1} (x) \\right] _ {1}</span></div>

    <p class="text-gray-300">Set  <span class="math">s = d - m + 1</span>  for  <span class="math">d</span>  the maximum power of  <span class="math">x</span>  in  <span class="math">\\mathbf{srs}</span>  and accept if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e((\\mathsf{cm}_{\\mathsf{c}} - \\mathsf{cm}_{\\mathsf{t}}) + \\gamma [z_{H}(x)]_{1},[1]_{2}) - e([a]_{1},[z_{I}]_{2}) = 0</span></li>

    </ol>

    <p class="text-gray-300">Check that  <span class="math">\\mathbb{C}+</span>  elements  <span class="math">[a_1]_1</span>  and  <span class="math">[a_2]_1</span>  verify.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e(\\alpha [w_1]_1,[1]_2) - e([w_1]_1,[x]_2) + e([E]_1 + \\gamma \\mathsf{cm}_s - [u_1 + \\gamma u_2]_1,[x^s ]_2) = 0</span></li>

    </ol>

    <p class="text-gray-300">Check that  <span class="math">E(\\alpha) = u_{1}</span> ,  <span class="math">A(\\alpha) = u_{2}</span> ,  <span class="math">\\deg (E(X)) &amp;lt; m</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e(-[u_3]_1 + \\gamma [R]_1,[1]_2) - e([w_2]_1,[x]_2) + e([1 + \\gamma^2 x^{s + 1}]_1,[z_I]_2) + e(-\\gamma^2 [x^m ]_1 + \\gamma^3 [R]_1,[x^{s + 1}]_2) = 0</span></li>

    </ol>

    <p class="text-gray-300">Check that  <span class="math">z_{I}(0) = u_{3}</span> ,  <span class="math">R(0) = 0</span> ,  <span class="math">\\deg (z_I(X)) = m</span>  and  <span class="math">\\deg (R(X)) &amp;lt; m</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e(\\beta [w_3]_1 + [D]_1 + \\gamma^2 [P_1]_1 - [u_1 + \\gamma u_4]_1,[1]_2) - e([w_3]_1,[x]_2) + e([\\gamma ]_1,[z_I]_2) = 0</span></li>

    </ol>

    <p class="text-gray-300">Check that  <span class="math">D(\\beta) = E(\\alpha)</span> ,  <span class="math">z_{I}(\\beta) = u_{4}</span> ,</p>

    <p class="text-gray-300"><span class="math">T(X)D(X) - A(\\alpha) = R(X) + z_I(X)Q_2(X)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e(\\rho [w_4]_1 + [E]_1 + \\gamma [P_2]_1 - [u_5]_1,[1]_2) - e([w_4]_1,[x]_2) = 0</span></li>

    </ol>

    <p class="text-gray-300">Check that  <span class="math">E(\\rho) = u_{5}</span>  and  <span class="math">E(X)(\\beta v(X) - 1) + z_{I}(\\beta)z_{I}(0)^{-1} = z_{V}(X)Q_{1}(X)</span></p>

    <p class="text-gray-300">These checks can be batched into 1 equation with 5 pairings.</p>

    <p class="text-gray-300">Figure 8: Optimized Baloo verifier.</p>

    <p class="text-gray-300">Common input:  <span class="math">\\mathsf{cm}_{\\mathsf{c}} = [C(x)]_{1},[z_{H}(x)]_{1} = [\\prod_{i = 0}^{N - 1}(x - \\omega^{i})]_{1}</span> ,  <span class="math">\\mathsf{srs} = \\{[x^i ]_{1,2}\\}_{i = 1}^d</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Take as input  <span class="math">\\{[Q_i(x)]_1, [H_i(x)]_1\\}_{i=1}^N</span>  and  <span class="math">A(X)</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Choose  <span class="math">I \\subset [N]</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= k<span class="math">  and  </span>\\forall \\nu \\in \\mathbb{V}, \\exists \\xi \\in \\mathbb{H}_I<span class="math">  s.t.  </span>A(\\nu) = C(\\xi)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">T(X) = \\sum_{i=1}^{k} t_i \\tau_i(X)</span>  for  <span class="math">\\tau_i(X) = \\prod_{s \\in I, s \\neq i} \\frac{X - \\xi_i}{\\xi_i - \\sum}</span> , and  <span class="math">v(X) = \\sum_{j=1}^{m} \\xi_{col(j)}^{-1} \\mu_j(X)</span></li>

      <li>Output  <span class="math">\\pi_1 = ([z_I]_2 = [z_I(x)]_2, [v]_1 = [v(x)]_1, \\mathsf{cm}_t = [T(x)]_1)</span> .</li>

      <li>Receive  <span class="math">\\alpha \\in \\mathbb{F}</span></li>

      <li>Compute  <span class="math">D(X) = M(X,\\alpha) = \\sum_{j = 1}^{m}\\mu_{j}(\\alpha)\\hat{\\tau}_{\\mathrm{col}(j)}(X)</span> , where  <span class="math">\\hat{\\tau}_{\\mathrm{col}(j)}(X) = \\tau_{\\mathrm{col}(j)}(X)\\tau_{\\mathrm{col}(j)}^{-1}(0)</span></li>

      <li>Find  <span class="math">R(X), Q_2(X)</span>  such that  <span class="math">\\deg(R(X)) &amp;lt; m - 1</span> ,  <span class="math">R(0) = 0</span> , and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">D (X) T (X) - A (\\alpha) = R (X) + z _ {I} (X) Q _ {2} (X)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\pi_2 = ([D]_1 = [D(x)]_1, [R]_1 = [R(x)]_1, [Q_2]_1 = [Q_2(x)]_1,</span></li>

      <li>Receive  <span class="math">\\beta \\in \\mathbb{F}</span></li>

      <li>Compute  <span class="math">E(X) = M(\\beta, X) = \\sum_{j=1}^{m} \\mu_j(X) \\hat{\\tau}_{\\mathrm{col}(j)}(\\beta)</span>  and  <span class="math">Q_1(X)</span>  such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">E (X) (\\beta v (X) - 1) + z _ {I} (\\beta) z _ {I} (0) ^ {- 1} = z _ {V} (X) Q _ {1} (X)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\pi_3 = ([E]_1 = [E(x)]_1, [Q_1]_1 = [Q_1(x)]_1)</span></li>

      <li>Receive  <span class="math">\\rho, \\gamma \\in \\mathbb{F}</span></li>

      <li>Compute  <span class="math">([a_1]_1, [a_2]_1, \\ldots) \\gets \\text{Prover}_{\\mathbb{C}^+}(T(X), \\mathbb{H}_I)</span>  and set  <span class="math">[a]_1 = [a_1]_1 + \\gamma[a_2]_2</span>  # Compress Caulk+ proof.</li>

      <li>Set  <span class="math">u_{1} = E(\\alpha)</span> ,  <span class="math">u_{2} = A(\\alpha)</span> ,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\hat {w} _ {1} (X) = \\frac {E (X) - u _ {1}}{X - \\alpha} + \\gamma \\frac {A (X) - u _ {2}}{X - \\alpha}</span></div>

    <p class="text-gray-300">Prove that  <span class="math">E(\\alpha) = u_{1}</span> ,  <span class="math">A(\\alpha) = u_{2}</span> ,  <span class="math">\\deg(E(X)) &amp;lt; m</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">u_{3} = z_{I}(0)</span>  and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">w _ {2} (X) = \\frac {z _ {I} (X) - u _ {3}}{X} + \\gamma \\frac {R (X)}{X} + \\gamma^ {2} X ^ {d - m + 1} \\left(z _ {I} (X) - X ^ {m}\\right) + \\gamma^ {3} X ^ {d - m + 1} R (X)</span></div>

    <p class="text-gray-300">Prove that  <span class="math">z_{I}(0) = u_{3}</span> ,  <span class="math">R(0) = 0</span> ,  <span class="math">\\deg (z_I(X)) = m</span>  and  <span class="math">\\deg (R(X)) &amp;lt; m</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">P_{1}(X) = T(X)D(\\beta) - A(\\alpha) - R(X) - z_{I}(\\beta)Q_{2}(X)</span> ,  <span class="math">u_{4} = z_{I}(\\beta)</span>  and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">w _ {3} (X) = \\frac {D (X) - u _ {1}}{X - \\beta} + \\gamma \\frac {z _ {I} (X) - u _ {4}}{X - \\beta} + \\gamma^ {2} \\frac {P _ {1} (X)}{X - \\beta}</span></div>

    <p class="text-gray-300">Prove that  <span class="math">D(\\beta) = E(\\alpha)</span> ,  <span class="math">z_{I}(\\beta) = u_{4}</span> ,</p>

    <p class="text-gray-300"><span class="math">T(X)D(X) - A(\\alpha) = R(X) + z_I(X)Q_2(X)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">u_{5} = E(\\rho)</span> ,  <span class="math">P_{2}(X) = E(\\rho)(\\beta v(X) - 1) + z_{I}(\\beta)z_{I}(0)^{-1} - z_{V}(\\rho)Q_{1}(X)</span> ,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">w _ {4} (X) = \\frac {E (X) - u _ {5}}{(X - \\rho)} + \\gamma \\frac {P _ {2} (X)}{X - \\rho}</span></div>

    <p class="text-gray-300">Prove that  <span class="math">E(X)(\\beta v(X) - 1) + z_I(\\beta)z_I(0)^{-1} = z_V(X)Q_1(X)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">s = d - m + 1</span>  for  <span class="math">d</span>  the maximum power of  <span class="math">x</span>  in  <span class="math">\\mathbf{srs}</span>  and output</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_3 = \\left(u_1,u_2,u_3,u_4,u_5,[a]_1,[w_1]_1 = [\\hat{w}_1(x)x^s ]_1,[w_2]_1 = [w_2(x)]_1,\\right.</span> <span class="math">[w_{3}]_{1} = [w_{3}(x)]_{1},[w_{4}]_{1} = [w_{4}(x)]_{1}\\big).</span></p>

    <p class="text-gray-300">Figure 7: Optimized Baloo prover. Underlined steps are messages from Verifier (Fig. 8).</p>

    <p class="text-gray-300">Acknowledgments We thank the anonymous reviewers of <em>Communications in Cryptology</em> for their valuable feedback, which greatly improved the quality of this work.</p>

    <h2 id="sec-35" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ac22] arkworks contributors. arkworks zksnark ecosystem, 2022. URL: https://arkworks.rs.</li>

      <li>[AR20] Shashank Agrawal and Srinivasan Raghuraman. KVaC: Key-Value Commitments for blockchains and beyond. In Shiho Moriai and Huaxiong Wang, editors, ASIACRYPT 2020, Part III, volume 12493 of LNCS, pages 839–869. Springer, Cham, December 2020. doi:10.1007/978-3-030-64840-4_28.</li>

      <li>[AST24] Arasu Arun, Srinath T. V. Setty, and Justin Thaler. Jolt: SNARKs for virtual machines via lookups. In Marc Joye and Gregor Leander, editors, EUROCRYPT 2024, Part VI, volume 14656 of LNCS, pages 3–33. Springer, Cham, May 2024. doi:10.1007/978-3-031-58751-1_1.</li>

      <li>[BB04] Dan Boneh and Xavier Boyen. Short signatures without random oracles. In Christian Cachin and Jan Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 56–73. Springer, Berlin, Heidelberg, May 2004. doi:10.1007/978-3-540-24676-3_4.</li>

      <li>[BBCCL21] Olivier Bégassat, Alexandre Belling, Théodore Chapuis-Chkaiban, and Nicolas Liochon1. A specification for a zk-evm, 2021. https://ethresear.ch/t/a-zk-evm-specification/11549.</li>

      <li>[BCC^{+}15] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Essam Ghadafi, Jens Groth, and Christophe Petit. Short accountable ring signatures based on DDH. In Günther Pernul, Peter Y. A. Ryan, and Edgar R. Weippl, editors, ESORICS 2015, Part I, volume 9326 of LNCS, pages 243–265. Springer, Cham, September 2015. doi:10.1007/978-3-319-24174-6_13.</li>

      <li>[BCF^{+}21] Daniel Benarroch, Matteo Campanelli, Dario Fiore, Kobi Gurkan, and Dimitris Kolonelos. Zero-knowledge proofs for set membership: Efficient, succinct, modular. In Nikita Borisov and Claudia Díaz, editors, FC 2021, Part I, volume 12674 of LNCS, pages 393–414. Springer, Berlin, Heidelberg, March 2021. doi:10.1007/978-3-662-64322-8_19.</li>

      <li>[BCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions</li>

    </ul>

    <p class="text-gray-300">succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90–108. Springer, Berlin, Heidelberg, August 2013. doi:10.1007/978-3-642-40084-1_6.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCG^{+}18] Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune K. Jakobsen, and Mary Maller. Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part I, volume 11272 of LNCS, pages 595–626. Springer, Cham, December 2018. doi:10.1007/978-3-030-03326-2_20.</li>

      <li>[BCR^{+}19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Cham, May 2019. doi:10.1007/978-3-030-17653-2_4.</li>

      <li>[BG13] Stephanie Bayer and Jens Groth. Zero-knowledge argument for polynomial evaluation with application to blacklists. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 646–663. Springer, Berlin, Heidelberg, May 2013. doi:10.1007/978-3-642-38348-9_38.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019. URL: https://eprint.iacr.org/2019/1021.</li>

      <li>[CDGM19] Melissa Chase, Apoorvaa Deshpande, Esha Ghosh, and Harjasleen Malvai. SEEMless: Secure end-to-end encrypted messaging with less trust. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 1639–1656. ACM Press, November 2019. doi:10.1145/3319535.3363202.</li>

      <li>[CEO22] Matteo Campanelli, Felix Engelmann, and Claudio Orlandi. Zero-knowledge for homomorphic key-value commitments with applications to privacy-preserving ledgers. In Clemente Galdi and Stanislaw Jarecki, editors, SCN 22, volume 13409 of LNCS, pages 761–784. Springer, Cham, September 2022. doi:10.1007/978-3-031-14791-3_33.</li>

      <li>[CFF^{+}21] Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaïs Querol, and Hadrián Rodríguez. Lunar: A toolbox for more efficient universal and updatable zkSNARKs and commit-and-prove extensions. In Mehdi Tibouchi and Huaxiong Wang, editors, ASIACRYPT 2021, Part III, volume 13092 of LNCS, pages 3–33.</li>

    </ul>

    <p class="text-gray-300">Baloo</p>

    <p class="text-gray-300">Springer, Cham, December 2021. doi:10.1007/978-3-030-92078-4_1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CFF^{+}24] Matteo Campanelli, Antonio Faonio, Dario Fiore, Tianyu Li, and Helger Lipmaa. Lookup arguments: Improvements, extensions and applications to zero-knowledge decision trees. In Qiang Tang and Vanessa Teague, editors, PKC 2024, Part II, volume 14602 of LNCS, pages 337–369. Springer, Cham, April 2024. doi:10.1007/978-3-031-57722-2_11.</li>

      <li>[CFG^{+}20] Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris Kolonelos, and Luca Nizzardo. Incrementally aggregatable vector commitments and applications to verifiable decentralized storage. In Shiho Moriai and Huaxiong Wang, editors, ASIACRYPT 2020, Part II, volume 12492 of LNCS, pages 3–35. Springer, Cham, December 2020. doi:10.1007/978-3-030-64834-3_1.</li>

      <li>[CFH^{+}22] Matteo Campanelli, Dario Fiore, Semin Han, Jihye Kim, Dimitris Kolonelos, and Hyunok Oh. Succinct zero-knowledge batch proofs for set accumulators. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022, pages 455–469. ACM Press, November 2022. doi:10.1145/3548606.3560677.</li>

      <li>[CFQ19] Matteo Campanelli, Dario Fiore, and Anaïs Querol. LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2075–2092. ACM Press, November 2019. doi:10.1145/3319535.3339820.</li>

      <li>[CHM^{+}20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Psi Vesely, and Nicholas P. Ward. Marlin: Preprocessing zk-SNARKs with universal and updatable SRS. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768. Springer, Cham, May 2020. doi:10.1007/978-3-030-45721-1_26.</li>

      <li>[DP25] Benjamin E. Diamond and Jim Posen. Succinct arguments over towers of binary fields. LNCS, pages 93–122. Springer, Cham, June 2025. doi:10.1007/978-3-031-91134-7_4.</li>

      <li>[EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon. cq: Cached quotients for fast lookups. Cryptology ePrint Archive, Report 2022/1763, 2022. URL: https://eprint.iacr.org/2022/1763.</li>

      <li>[Eth22] Zkevm introduction, 2022. https://github.com/privacy-scaling-explorations/zkevm-specs/blob/master/specs/introduction.md.</li>

      <li>[FK23] Dankrad Feist and Dmitry Khovratovich. Fast amortized kzg proofs, 2023. URL: https://eprint.iacr.org/2023/033.</li>

    </ul>

    <p class="text-gray-300">[FKL18] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 33–62. Springer, Cham, August 2018. doi:10.1007/978-3-319-96881-0_2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GG17] Essam Ghadafi and Jens Groth. Towards a classification of non-interactive computational assumptions in cyclic groups. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 66–96. Springer, Cham, December 2017. doi:10.1007/978-3-319-70697-9_3.</li>

      <li>[GK15] Jens Groth and Markulf Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 253–280. Springer, Berlin, Heidelberg, April 2015. doi:10.1007/978-3-662-46803-6_9.</li>

      <li>[GK22] Ariel Gabizon and Dmitry Khovratovich. flookup: Fractional decomposition-based lookups in quasi-linear time independent of table size. Cryptology ePrint Archive, Report 2022/1447, 2022. URL: https://eprint.iacr.org/2022/1447.</li>

      <li>[GKL^{+}22] Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, Markus Schofnegger, and Roman Walch. Reinforced concrete: A fast hash function for verifiable computation. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022, pages 1323–1335. ACM Press, November 2022. doi:10.1145/3548606.3560686.</li>

      <li>[GM24] Albert Garreta and Ignacio Manzur. FLI: Folding lookup instances. In Kai-Min Chung and Yu Sasaki, editors, ASIACRYPT 2024, Part V, volume 15488 of LNCS, pages 402–435. Springer, Singapore, December 2024. doi:10.1007/978-981-96-0935-2_13.</li>

      <li>[GW20] Ariel Gabizon and Zachary J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Report 2020/315, 2020. URL: https://eprint.iacr.org/2020/315.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical non-interactive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. URL: https://eprint.iacr.org/2019/953.</li>

      <li>[Hab22] Ulrich Haböck. Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive, Report 2022/1530, 2022. URL: https://eprint.iacr.org/2022/1530.</li>

    </ul>

    <p class="text-gray-300">Baloo</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[HHK^{+}21] Yuncong Hu, Kian Hooshmand, Harika Kalidhindi, Seung Jin Yang, and Raluca Ada Popa. Merkle^{2}: A low-latency transparency log system. In 2021 IEEE Symposium on Security and Privacy, pages 285–303. IEEE Computer Society Press, May 2021. doi:10.1109/SP40001.2021.00088.</li>

      <li>[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part IV, volume 13510 of LNCS, pages 359–388. Springer, Cham, August 2022. doi:10.1007/978-3-031-15985-5_13.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Berlin, Heidelberg, December 2010. doi:10.1007/978-3-642-17373-8_11.</li>

      <li>[MKL^{+}20] Sarah Meiklejohn, Pavel Kalinnikov, Cindy S. Lin, Martin Hutchinson, Gary Belvin, Mariana Raykova, and Al Cutter. Think global, act local: Gossip and client audits in verifiable data structures. CoRR, abs/2011.04551, 2020. URL: https://arxiv.org/abs/2011.04551.</li>

      <li>[PH23] Shahar Papini and Ulrich Haböck. Improving logarithmic derivative lookups using GKR. Cryptology ePrint Archive, Report 2023/1284, 2023. URL: https://eprint.iacr.org/2023/1284.</li>

      <li>[PK22] Jim Posen and Assimakis A. Kattis. Caulk+: Table-independent lookup arguments. Cryptology ePrint Archive, Report 2022/957, 2022. URL: https://eprint.iacr.org/2022/957.</li>

      <li>[Pol22] Polygon zkevm documentation, 2022. https://docs.hermez.io/zkEVM/Overview/Overview/.</li>

      <li>[PZ22] Team Polygon Zero. Plonky2: Fast recursive arguments with plonk and frio, 2022. URL: https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf.</li>

      <li>[RZ21] Carla Ràfols and Arantxa Zapico. An algebraic framework for universal and updatable SNARKs. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 774–804, Virtual Event, August 2021. Springer, Cham. doi:10.1007/978-3-030-84242-0_27.</li>

      <li>[Sal23] Robin Salen. Two additional instantiations from the tip5 hash function construction, 2023. URL: https://toposware.com/paper_tip5.pdf.</li>

    </ul>

    <p class="text-gray-300">[Set20] Srinath Setty. Spartan: Efficient and general-purpose zk-SNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Cham, August 2020. doi:10.1007/978-3-030-56877-1_25.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[SLST23] Alan Szepieniec, Alexander Lemmens, Jan Ferdinand Sauer, and Bobbin Threadbare. The Tip5 hash function for recursive STARKs. Cryptology ePrint Archive, Report 2023/107, 2023. URL: https://eprint.iacr.org/2023/107.</li>

      <li>[Sta22] Starknet, 2022. https://starkware.co/starknet/.</li>

      <li>[STW24] Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Unlocking the lookup singularity with Lasso. In Marc Joye and Gregor Leander, editors, EUROCRYPT 2024, Part VI, volume 14656 of LNCS, pages 180–209. Springer, Cham, May 2024. doi:10.1007/978-3-031-58751-1_7.</li>

      <li>[TAB^{+}20] Alin Tomescu, Ittai Abraham, Vitalik Buterin, Justin Drake, Dankrad Feist, and Dmitry Khovratovich. Aggregatable sub-vector commitments for stateless cryptocurrencies. In Clemente Galdi and Vladimir Kolesnikov, editors, SCN 20, volume 12238 of LNCS, pages 45–64. Springer, Cham, September 2020. doi:10.1007/978-3-030-57990-6_3.</li>

      <li>[TBP^{+}19] Alin Tomescu, Vivek Bhupatiraju, Dimitrios Papadopoulos, Charalampos Papamanthou, Nikos Triandopoulos, and Srinivas Devadas. Transparency logs via append-only authenticated dictionaries. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 1299–1316. ACM Press, November 2019. doi:10.1145/3319535.3345652.</li>

      <li>[TFBT21] Nirvan Tyagi, Ben Fisch, Joseph Bonneau, and Stefano Tessaro. Client-auditable verifiable registries. Cryptology ePrint Archive, Report 2021/627, 2021. URL: https://eprint.iacr.org/2021/627.</li>

      <li>[vzGG13] Joachim von zur Gathen and Jürgen Gerhard. Modern Computer Algebra (3. ed.). Cambridge University Press, 2013. doi:https://doi.org/10.1017/CBO9781139856065.</li>

      <li>[ZBK^{+}22] Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. Caulk: Lookup arguments in sublinear time. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022, pages 3121–3134. ACM Press, November 2022. doi:10.1145/3548606.3560646.</li>

    </ul>

    <p class="text-gray-300">[Zha22] Ye Zhang. Introducing zkevm, 2022. https://scroll.io/blog/zkEVM.</p>

    <p class="text-gray-300">[zks22] zkevm faq, 2022. https://docs.zksync.io/zkevm/.</p>

    <h2 id="sec-36" class="text-2xl font-bold">Appendix A Proof of Theorem 2</h2>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an algebraic adversary attempting to break knowledge soundness. We design an extractor <span class="math">\\mathcal{E}</span> that behaves as follows. When the adversary <span class="math">(C(X),\\mathsf{cm_{t}},[z_{I}]_{2},\\pi)\\leftarrow\\mathcal{A}(\\mathsf{srs})</span> outputs a proof <span class="math">\\pi=(W_{1},W_{2},W_{3})</span>, then it also outputs the representations <span class="math">w_{1}(X),w_{3}(X)</span> of maximum degree <span class="math">N</span> such that</p>

    <p class="text-gray-300"><span class="math">W_{1}=[w_{1}(x)]_{1},W_{3}=[w_{3}(x)]_{1}</span></p>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}</span> computes</p>

    <p class="text-gray-300"><span class="math">z_{I}(X)=w_{3}(X)X^{-(N-k+1)}+X^{k},T(X)=C(X)-w_{1}(X)z_{I}(X)</span></p>

    <p class="text-gray-300">and returns <span class="math">\\mathbb{H}_{I},T(X)</span> where <span class="math">\\mathbb{H}_{I}</span> consists of the roots of <span class="math">z_{I}(X)</span>.</p>

    <p class="text-gray-300">We show that either <span class="math">\\mathcal{E}</span> succeeds with overwhelming probability or we can construct a reductions <span class="math">\\mathcal{B}_{1}</span> and <span class="math">\\mathcal{B}_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{0}_{\\mathcal{A},\\mathcal{E}}(\\lambda)\\leq\\mathcal{A}^{{\\mathsf{q}}\\text{-sfrac}}_{\\mathcal{B}_{1}}(\\lambda)+\\mathcal{A}^{{\\mathsf{q}}\\text{-dlog}}_{\\mathcal{B}_{2}}(\\lambda)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}^{0}\\mapsto\\mathsf{Game}^{1}</span>: Let <span class="math">\\mathsf{Game}^{0}</span> be the original knowledge soundness game. We first transition to a game <span class="math">\\mathsf{Game}^{1}</span> that behaves identically to <span class="math">\\mathsf{Game}^{0}</span> except that, when <span class="math">\\mathcal{A}</span> outputs the representation <span class="math">w_{3}(X)</span>, if <span class="math">z_{I}(X)=w_{3}(X)X^{-(N-k+1)}+X^{k}</span> is not a degree <span class="math">k</span> polynomial (with positive degree monomials only) then <span class="math">\\mathsf{Game}^{1}</span> aborts.</p>

    <p class="text-gray-300">We show the existence of a reduction <span class="math">\\mathcal{B}_{1}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{0}_{\\mathcal{A},\\mathcal{E}}(\\lambda)\\leq\\mathcal{A}^{1}_{\\mathcal{A},\\mathcal{E}}(\\lambda)+\\mathcal{A}^{{\\mathsf{q}}\\text{-sfrac}}_{\\mathcal{B}_{1}}(\\lambda)</span></p>

    <p class="text-gray-300">The reduction <span class="math">\\mathcal{B}_{1}</span> gets as input <span class="math">\\mathsf{srs}</span> and forwards this reference string to run <span class="math">(C(X),\\mathsf{cm_{t}},[z_{I}]_{2}</span>, <span class="math">\\pi)\\leftarrow\\mathcal{A}(\\mathsf{srs})</span>. When <span class="math">\\mathcal{A}</span> outputs a proof <span class="math">\\pi=(W_{1},W_{2},W_{3})</span>, then it also outputs the representation <span class="math">w_{3}(X)</span> of maximum degree <span class="math">N</span> such that</p>

    <p class="text-gray-300"><span class="math">z_{I}=[w_{3}(x)x^{-N+k-1}+x^{k}]_{2}</span></p>

    <p class="text-gray-300">Write <span class="math">w_{3}(X)=\\sum_{s=0}^{N}a_{s}X^{s}</span> Then <span class="math">\\mathcal{B}_{1}</span> returns</p>

    <p class="text-gray-300"><span class="math">\\sum_{s=0}^{N-k}a_{s}X^{s},X^{N-k+1},[z_{I}]_{2}-[x^{k}]_{2}-[\\sum_{s=N-k+1}^{N}a_{s}x^{s}]_{2}</span></p>

    <p class="text-gray-300">If <span class="math">a_{s}\\neq 0</span> for <span class="math">0\\leq s\\leq N-k</span>, then the degree of <span class="math">\\sum_{s=0}^{N-k}a_{s}X^{s}</span> is less than <span class="math">N-k+1</span> and hence <span class="math">\\mathcal{B}_{1}</span> breaks the <span class="math">\\mathsf{q}</span>-<span class="math">\\mathsf{sfrac}</span> assumption.</p>

    <p class="text-gray-300">If <span class="math">a_{s}=0</span> for all <span class="math">0\\leq s\\leq N-k</span> then</p>

    <p class="text-gray-300"><span class="math">z_{I}(X)=w_{3}(X)X^{-(N-k+1)}+X^{k}=\\sum_{s=0}^{k-1}a_{N-k+1+s}X^{s}+X^{k}</span></p>

    <p class="text-gray-300">which is a degree <span class="math">k</span> polynomial.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}^{1}\\mapsto\\mathsf{Game}^{2}</span> We second transition to a game <span class="math">\\mathsf{Game}^{2}</span> that behaves identically to <span class="math">\\mathsf{Game}^{1}</span> except that, when <span class="math">\\mathcal{A}</span> outputs the representation <span class="math">w_{3}(X)</span>, if <span class="math">z_{I}(X)=w_{3}(X)X^{-(N-k+1)}+X^{k}</span> does not divide <span class="math">z_{H}(X)</span>, then <span class="math">\\mathsf{Game}^{2}</span> aborts. We show the existence of a reduction <span class="math">\\mathcal{B}_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{1}_{\\mathcal{A},\\mathcal{E}}(\\lambda)\\leq\\mathcal{A}^{2}_{\\mathcal{A},\\mathcal{E}}(\\lambda)+\\mathcal{A}^{{\\mathsf{q}-\\mathsf{dlog}}}_{\\mathcal{B}_{1}}(\\lambda)</span></p>

    <p class="text-gray-300">See that if <span class="math">\\mathsf{Game}^{2}</span> does not abort, then <span class="math">z_{I}=[f(X)]</span> for some <span class="math">f(X)</span> of degree <span class="math">k</span> that divides <span class="math">z_{H}(X)</span>. This means that <span class="math">z_{I}(X)=\\prod_{i=1}^{k}(X-\\xi_{i})</span> for <span class="math">\\mathbb{H}_{I}</span> some subset of <span class="math">\\mathbb{H}</span> of size <span class="math">k</span>.</p>

    <p class="text-gray-300">The reduction <span class="math">\\mathcal{B}_{2}</span> gets as input <span class="math">\\mathsf{srs}</span> and forwards this reference string to run <span class="math">(C(X),\\mathsf{cm_{t}},\\,[z_{I}]_{2},\\pi)\\leftarrow\\mathcal{A}(\\mathsf{srs})</span>. When <span class="math">\\mathcal{A}</span> outputs a proof <span class="math">\\pi=(W_{1},W_{2},W_{3})</span>, then it also outputs the representation <span class="math">w_{3}(X),w_{2}(X)</span> of maximum degree <span class="math">d</span> such that</p>

    <p class="text-gray-300"><span class="math">z_{I}=[f(x)]_{2}=[w_{3}(x)x^{-N+k-1}+x^{k}]_{2},W_{2}=[w_{2}(x)]_{1}</span></p>

    <p class="text-gray-300">Then <span class="math">\\mathcal{B}_{2}</span> computes the degree <span class="math">N</span> polynomial <span class="math">g(X)=Z_{H}(X)-z_{I}(X)w_{2}(X)</span> and solves to find the <span class="math">N</span> roots. It checks amongst these roots whether any solution <span class="math">x</span> corresponds to the <span class="math">\\mathsf{qdlog}</span> challenge and if yes it returns <span class="math">x</span>. Else it aborts.</p>

    <p class="text-gray-300">By the second verification equation we have that <span class="math">Z_{H}(x)-g(x)w_{2}(x)=0</span> whenever <span class="math">\\mathcal{A}</span> convinces the verifier. See that if <span class="math">g(X)</span> does not divide <span class="math">Z_{H}(X)</span>, then <span class="math">Z_{H}(X)-g(X)w_{2}(X)\\neq 0</span>. But then <span class="math">x</span> must lie in the roots and <span class="math">\\mathcal{B}_{2}</span> succeeds.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}^{2}\\mapsto 0</span> We finally show that for any adversary <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{2}_{\\mathcal{A},\\mathcal{E}}(\\lambda)=0</span></p>

    <p class="text-gray-300">Indeed, when <span class="math">\\mathcal{A}</span> also outputs the representation <span class="math">w_{3}(X)</span>, we have that either <span class="math">[z_{I}]_{2}=[z_{I}(x)]_{2}</span> for <span class="math">z_{I}(X)=w_{3}(X)X^{-(N-k+1)}+X^{k}</span> a degree <span class="math">N</span> polynomial dividing <span class="math">z_{H}(X)</span>, or <span class="math">\\mathsf{Game}^{2}</span> aborts. The adversary <span class="math">\\mathcal{A}</span> also outputs a representation <span class="math">w_{1}(X)</span> of maximum degree <span class="math">N</span> such that <span class="math">[W]_{1}=[w_{1}(x)]_{1}</span>. By the first verification equation we have that <span class="math">T(X)=C(X)-w_{1}(X)z_{I}(X)</span> is such that <span class="math">\\mathsf{cm_{t}}=[T(X)]_{1}</span>. Further <span class="math">T(\\xi_{i})=C(\\xi_{i})+0</span> for all <span class="math">i\\in[k]</span>, making <span class="math">z_{I}(X)</span> and <span class="math">T(X)</span> a correct witness. ∎</p>

    <h2 id="sec-38" class="text-2xl font-bold">Appendix B Baloo Prover Cost</h2>

    <p class="text-gray-300">In this section we elaborate on the Prover’s computational costs while showing that those are quasi-linear in <span class="math">m</span></p>

    <p class="text-gray-300">B.1 Optimizations for cp-expansion</p>

    <p class="text-gray-300">In this section we describe some optimizations that can be applied to the protocol in Fig. 6 in order to achieve a construction with smaller proof size and that requires less work from the verifier.</p>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Opening <span class="math">t</span> polynomials in one point.</h5>

    <p class="text-gray-300">As noted in <em>[x10]</em>,<em>[CHM^{+}20]</em>, whenever we have many openings of different polynomials at the same point, the prover can provide a joint proof after receiving a random element <span class="math">\\gamma\\in\\mathbb{F}</span> from the verifier, i.e., if</p>

    <p class="text-gray-300"><span class="math">(u_{1},[w_{1}]_{1})</span> <span class="math">\\leftarrow\\texttt{KZG.Open}(\\texttt{srs}_{\\texttt{KZG}},f_{1}(X),\\text{deg}=d,\\alpha)</span> <span class="math">(u_{2},[w_{2}]_{1})</span> <span class="math">\\leftarrow\\texttt{KZG.Open}(\\texttt{srs}_{\\texttt{KZG}},f_{2}(X),\\text{deg}=d,\\alpha)</span></p>

    <p class="text-gray-300">then <span class="math">[w]_{1}=[w_{1}]_{1}+\\gamma[w_{2}]_{2}</span> is a proof that <span class="math">f_{1}(X)+\\gamma f_{2}(X)</span> opens to <span class="math">u_{1}+\\gamma u_{2}</span> at <span class="math">\\alpha</span>.</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Openings for Pairings.</h5>

    <p class="text-gray-300">To save the verifier some work, we use a technique introduced in <em>[x10]</em> and attributed to M. Maller. In order to verify that <span class="math">a(X)b(X)=c(X)d(X)</span> for <span class="math">a(X),b(X),c(X),d(X)</span> the algebraic representations of <span class="math">[a]_{1},[b]_{2},[c]_{1},[d]_{2}</span>, instead of asking the verifier to check that</p>

    <p class="text-gray-300"><span class="math">e([a]_{1},[b]_{2})=e([c]_{1},[d]_{2}),</span></p>

    <p class="text-gray-300">we ask the prover to show that <span class="math">[b]_{2},[d]_{2}</span> open to <span class="math">u_{1},u_{2}</span> at <span class="math">\\beta</span> and that <span class="math">u_{1}[a]_{1}-u_{2}[c]_{1}</span> opens to zero at <span class="math">\\beta</span>. Note that now the prover can also commit to <span class="math">b(X)</span> and <span class="math">d(X)</span> in <span class="math">\\mathbb{G}_{1}</span> instead of <span class="math">\\mathbb{G}_{2}</span>. We apply this technique to the equations that verify the inner product relation and the well-formedness of <span class="math">[E]_{1}</span>; that is, equations <span class="math">(i)</span> and <span class="math">(ii)</span>. Note that we can open this equations together with other elements. Indeed, we will check equation <span class="math">(i)</span> by opening a polynomial <span class="math">[P_{1}]_{1}</span> at <span class="math">\\beta</span>, and batch that KZG opening together with the one for <span class="math">[D]_{1}</span>.</p>

    <h5 id="sec-41" class="text-base font-semibold mt-4">Degree checks.</h5>

    <p class="text-gray-300">Degree checks as <span class="math">\\text{deg}(f)\\leq k&lt;d</span> can be included in a KZG proof that <span class="math">f(\\alpha)=u</span> if the prover sets <span class="math">\\hat{w}(X)=\\frac{f(X)-f(\\alpha)}{X-\\alpha}</span>, outputs <span class="math">(u,[w]_{1}=[\\hat{w}(x)x^{d-k+1}])</span> and the verifier checks</p>

    <p class="text-gray-300"><span class="math">e\\big{(}[f]_{1}-[u]_{1},[x^{d-k+1}]_{2}\\big{)}=e\\big{(}[w]_{1},[x-\\alpha]_{2}\\big{)},</span></p>

    <p class="text-gray-300">as explained in Section 3.5. This is conditional on <span class="math">\\alpha</span> being randomly chosen after <span class="math">f(X)</span>.</p>

    <p class="text-gray-300">Throughout Ba<em>loo</em> we require 3 degree checks: <span class="math">(i)</span> that <span class="math">\\text{deg}(E(X))&lt;m-1</span>, <span class="math">(ii)</span> that <span class="math">\\text{deg}(z_{I}(X))=m</span>, and <span class="math">(iii)</span> that <span class="math">\\text{deg}(R(X))=m-2</span>. For <span class="math">(i)</span> we check via a KZG opening that <span class="math">E(X)</span> has bounded degree. For <span class="math">(ii)</span> we check that <span class="math">z_{I}(X)-X^{m}</span> has degree bounded by <span class="math">m-1</span> during our opening check that <span class="math">z_{I}(0)</span> is correct. Degree bounding <span class="math">f(X)&lt;k</span> via an opening at 0 checks that</p>

    <p class="text-gray-300"><span class="math">e\\big{(}[f]_{1}-[u]_{1},[1]_{2}\\big{)}=e\\big{(}[w]_{1},[x]_{2}\\big{)},</span></p>

    <p class="text-gray-300"><span class="math">\\text{and }e\\Big{(}[f]_{1},[x^{d-k+2}]_{2}\\Big{)}=e\\Big{(}[w]_{2},[x]_{2}\\Big{)},</span></p>

    <p class="text-gray-300">because <span class="math">0</span> is not a random point.</p>

    <p class="text-gray-300">For <span class="math">(iii)</span> we recall that the polynomial <span class="math">R(X)</span> is sent for the inner product relation to show that <span class="math">a(X)b(X)-\\sigma=XR(X)+z_{I}(X)Q(X)</span>. In our optimised protocol we instead send <span class="math">\\bar{R}(X)=XR(X)</span> and show that <span class="math">\\bar{R}(0)=0</span> and that <span class="math">\\bar{R}(X)</span> has degree bounded by <span class="math">m-1</span>. We then show that <span class="math">a(X)b(X)-\\sigma=\\bar{R}(X)+z_{I}(X)Q(X)</span>. This is equivalent because <span class="math">\\bar{R}(0)=0</span> if and only if <span class="math">\\bar{R}(X)=XR(X)</span>. Where we can batch this check with opening and degree bounding <span class="math">z_{I}(X)</span> at the same point (namely <span class="math">0</span>) and with the same degree <span class="math">(m-1)</span>, this check is essentially free.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Batching Pairings.</h4>

    <p class="text-gray-300">We also apply standard techniques to batch pairings that share the same elements in one of the two groups. Namely, upon sampling a uniform <span class="math">\\gamma_{2}\\in\\mathbb{F}</span>, the verifier can aggregate the equations</p>

    <p class="text-gray-300"><span class="math">e([a]_{1},[b_{1}]_{2})=e([c_{1}]_{1},[d]_{2})\\text{ and }e([a]_{1},[b_{2}]_{2})=e([c_{2}]_{1},[d]_{2}),</span> <span class="math">\\text{as }e([a]_{1},[b_{1}+\\gamma b_{2}]_{2})=e([c_{1}+\\gamma c_{2}]_{1},[d]_{2})</span></p>

    <p class="text-gray-300">Note that we can adapt KZG openings equations so they can be batched further, namely if we parse the verification pairing as <span class="math">e\\Big{(}[f]_{1}-u+[w]_{1}\\alpha,[1]_{2}\\Big{)}=e\\Big{(}[w]_{1},[x]_{2}\\Big{)}</span>, then two openings of different polynomials at different points can be verified by two pairings.</p>

    <p class="text-gray-300">Finally, note that in order to check <span class="math">E(\\alpha)=D(\\beta)</span>, the proves needs to provide proof of both openings but can only send <span class="math">u_{2}=E(\\alpha)</span> and the verifier checks <span class="math">D(\\beta)</span> opens to <span class="math">u_{2}</span> as well.</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">B.2 Generic algorithms</h3>

    <p class="text-gray-300">An excellent survey of various algorithms for polynomials with pseudocode is given in <em>[x11]</em>. Let <span class="math">\\mathbb{F}</span> be a domain with Fast Fourier Transform of size <span class="math">N</span>. Polynomials in <span class="math">\\mathbb{F}[X]</span> are considered as vectors of coefficients in the standard basis <span class="math">\\{1,X,X^{2},\\ldots,X^{N}\\}</span> unless stated otherwise. The set <span class="math">I</span> does not support FFTs. The computational costs are counted in operations in <span class="math">\\mathbb{F}</span>. We are using the following basic results (everywhere <span class="math">d&lt;N</span>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Multiplication: two polynomials of degree <span class="math">d</span> can be multiplied in <span class="math">O(d\\log d)</span> time.</li>

      <li>Inversion: given a polynomial <span class="math">f</span> of degree <span class="math">d</span> can be inverted modulo <span class="math">X^{\\ell}</span>, <span class="math">\\ell&gt;d</span>, in <span class="math">O(d\\log d)</span> time.</li>

      <li>Division: a polynomial <span class="math">f</span> of degree <span class="math">d</span> can be divided with a remainder by a polynomial <span class="math">g</span> of degree <span class="math">d^{\\prime}&lt;d</span> in <span class="math">O(d\\log d)</span> time, i.e. we can find <span class="math">q(X),r(X)</span> of degree <span class="math">d^{\\prime\\prime}&lt;d</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">f(X)=q(X)g(X)+r(X)</span></p>

    <p class="text-gray-300">Baloo</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Vanishing polynomial: a polynomial <span class="math">z_{I}(X)</span> that vanishes on set <span class="math">I</span> of size <span class="math">d</span> can be computed in <span class="math">O(d\\log^2 d)</span> time.</li>

      <li>Evaluation: a polynomial <span class="math">f</span> of degree <span class="math">d</span> can be evaluated in <span class="math">d</span> points in <span class="math">O(d\\log^2 d)</span> time.</li>

      <li>Interpolation: a polynomial <span class="math">f</span> of degree <span class="math">d</span> with values <span class="math">c_i</span> at points <span class="math">x_i</span>, <span class="math">0 \\leq i \\leq d</span>, can be computed (interpolated) in <span class="math">O(d\\log^2 d)</span> time.</li>

    </ul>

    <h2 id="sec-44" class="text-2xl font-bold">B.3 Costs analysis</h2>

    <p class="text-gray-300">For simplicity we assume that <span class="math">m = k</span>.</p>

    <p class="text-gray-300"><strong>Aggregation of individual proofs.</strong> The subset opening proofs for the set of points <span class="math">\\mathbb{H}_I \\subseteq \\mathbb{H}</span> are computed as <span class="math">[H]_1 = \\sum_{i \\in I} r_i [H_i]_1</span>. The coefficients <span class="math">r_i = \\prod_{s \\in I, s \\neq i} \\frac{1}{(\\omega^i - \\omega^s)}</span> are altogether computed in <span class="math">O(m \\log^2 m)</span> time as follows. Let <span class="math">Z_I&#x27;(X)</span> be the derivative of <span class="math">Z_I(X)</span> then we have <span class="math">r_i = \\frac{1}{Z_I&#x27;(\\omega^i)}</span> [vzGG13, p. 300]. We use a vanishing polynomial reconstruction algorithm (see above) and symbolically compute <span class="math">Z_I&#x27;(X)</span> in <span class="math">O(m \\log^2 m)</span> time. Then we evaluate <span class="math">Z_I&#x27;(X)</span> over <span class="math">I</span> also in <span class="math">O(m \\log^2 m)</span> time. Thus <span class="math">[H]_1</span> can be computed in <span class="math">m</span> group operations.</p>

    <p class="text-gray-300"><strong>Running time of Caulk+ core.</strong> The costs of Fig. 7 break down as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial <span class="math">\\frac{C(x) - T(x)}{z_I(x)}</span> similarly to <span class="math">[H]_1</span> using <span class="math">O(m\\log^2 m)</span> field operations. Then it takes <span class="math">m</span> group operations to compute <span class="math">W_1</span>.</li>

      <li>The group element <span class="math">W_{2}</span> is computed as a linear combination of <span class="math">[H_{i}(x)]_{1}</span> as in [ZBK+22] in time <span class="math">m</span> group and <span class="math">O(k\\log^2 k)</span> field operations (see above).</li>

      <li>The polynomial in <span class="math">W_{3}</span> has <span class="math">O(m)</span> nonzero coefficients and thus needs at most <span class="math">m</span> group operations to be computed.</li>

    </ul>

    <p class="text-gray-300">In Fig. 7 the element <span class="math">W_{3}</span> is unused and this computation can be omitted. Overall we need <span class="math">2m</span> group operations and <span class="math">O(m\\log^2 m)</span> field operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Running time of cp-expansion argument Fig. 6</strong> We first note that Lagrange polynomials <span class="math">\\mu_j(X)</span> and <span class="math">\\tau_i(X)</span> have succinct form. Concretely we have, assuming $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mu_j(X) = \\frac{X^m - 1}{m\\nu^{-j}(X - \\nu^j)}, \\quad \\tau_i(X) = \\frac{z_I(X)}{z_I&#x27;(\\xi_i)(X - \\xi_i)} = \\frac{r_i z_I(X)}{(X - \\xi_i)}</span></div>

    <p class="text-gray-300">where <span class="math">z_I&#x27;(X)</span> is the derivative of <span class="math">z_I(X)</span>. All <span class="math">\\mu_j(X)</span> can be batch-evaluated in <span class="math">m</span> points in <span class="math">m\\log m</span> time as one evaluation is <span class="math">\\log m</span> time. For <span class="math">\\tau_i(X)</span> we compute <span class="math">r_i = \\frac{1}{z_I&#x27;(\\xi_i)}</span> using the evaluation algorithm for <span class="math">z_I(X)</span> in <span class="math">O(m\\log^2 m)</span></p>

    <p class="text-gray-300">time, and then inverting in  <span class="math">m\\log(m)</span>  time. Then in order to batch-evaluate all  <span class="math">\\tau_i(X)</span>  at some point  <span class="math">\\beta</span> , we evaluate  <span class="math">z_I(X)</span>  at  <span class="math">\\beta</span>  in  <span class="math">m</span>  time and each  <span class="math">\\frac{r_i}{\\beta - \\xi_i}</span>  in  <span class="math">\\log m</span>  time. These costs are all in  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">The field operation costs of Fig. 3 break down as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial  <span class="math">v(X)</span>  has degree  <span class="math">m</span>  and can be computed via interpolation in  <span class="math">O(m\\log^2 m)</span> .</li>

      <li>Polynomial  <span class="math">D(X)</span>  is computed by interpolation as follows. We first batch-evaluate  <span class="math">\\mu_j(X)</span>  at  <span class="math">\\alpha</span>  in  <span class="math">O(m\\log m)</span>  time. Then we batch-evaluate  <span class="math">\\tau_i(X)</span>  at 0 in  <span class="math">O(m\\log^2 m)</span>  time, so that we know all coefficients of  <span class="math">\\tau_{\\mathrm{col}(j)}(X)</span>  in the sum. Those coefficients are exactly values of  <span class="math">D(X)</span>  at  <span class="math">\\xi_i</span> . From those we interpolate  <span class="math">D(X)</span>  in  <span class="math">O(m\\log^2 m)</span>  time.</li>

      <li>Polynomials  <span class="math">R(X), Q_1(X), Q_2(X)</span>  can be computed using the division algorithm (above) in  <span class="math">O(m\\log^2 m)</span>  time</li>

      <li>Polynomial  <span class="math">E(X)</span>  is computed by interpolation again. As for  <span class="math">D(X)</span>  we batch-evaluate all  <span class="math">\\tau_i(X)</span>  at  <span class="math">\\beta</span>  so that we know all coefficients of  <span class="math">\\mu_j(X)</span>  in  <span class="math">O(m\\log^2 m)</span>  time. As  <span class="math">\\mu_j(X)</span>  are defined over a subgroup of roots of unity, the interpolation of  <span class="math">E(X)</span>  is in  <span class="math">O(m\\log m)</span>  time.</li>

    </ul>

    <p class="text-gray-300">Computing  <span class="math">[z_I(x)]_2</span>  takes  <span class="math">m\\mathbb{G}_2</span>  operations. Computing the  <span class="math">12\\mathbb{G}_1</span>  elements that Prover sends takes  <span class="math">11m\\mathbb{G}_1</span>  operations as those commitments are either to polynomials of degree  <span class="math">m</span>  (those are  <span class="math">t,v,D,E,Q_1,R,Q_2,w_3,w_4</span> ) or have at most  <span class="math">m</span>  non-zero coefficients  <span class="math">([w_1]_1,[w_2]_1)</span> , or need constant time  <span class="math">([a]_1)</span> . Overall we need  <span class="math">11m\\mathbb{G}_1</span>  operations,  <span class="math">m\\mathbb{G}_2</span>  operations, and  <span class="math">O(m\\log^2 m)</span>  field operations.</p>

    <p class="text-gray-300">Full running cost By summing up the prover costs for Caulk+ core and cp-expansion we get that the total Prover cost in Baloo is  <span class="math">13m\\mathbb{G}_1</span>  operations,  <span class="math">m\\mathbb{G}_2</span>  operations and  <span class="math">O(m\\log^2 m)</span>  field operations.</p>

    <p class="text-gray-300">Table 2: Comparison table for lookups</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Time (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (KB)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m =</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MTPos</td>

            <td class="px-3 py-2 border-b border-gray-700">69.715</td>

            <td class="px-3 py-2 border-b border-gray-700">102.607</td>

            <td class="px-3 py-2 border-b border-gray-700">128.766</td>

            <td class="px-3 py-2 border-b border-gray-700">200.975</td>

            <td class="px-3 py-2 border-b border-gray-700">271.400</td>

            <td class="px-3 py-2 border-b border-gray-700">0.029</td>

            <td class="px-3 py-2 border-b border-gray-700">0.033</td>

            <td class="px-3 py-2 border-b border-gray-700">0.032</td>

            <td class="px-3 py-2 border-b border-gray-700">0.027</td>

            <td class="px-3 py-2 border-b border-gray-700">0.028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.290</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Harisa</td>

            <td class="px-3 py-2 border-b border-gray-700">1.228</td>

            <td class="px-3 py-2 border-b border-gray-700">2.014</td>

            <td class="px-3 py-2 border-b border-gray-700">2.374</td>

            <td class="px-3 py-2 border-b border-gray-700">3.939</td>

            <td class="px-3 py-2 border-b border-gray-700">6.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

            <td class="px-3 py-2 border-b border-gray-700">0.012</td>

            <td class="px-3 py-2 border-b border-gray-700">0.012</td>

            <td class="px-3 py-2 border-b border-gray-700">0.013</td>

            <td class="px-3 py-2 border-b border-gray-700">1.170</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk</td>

            <td class="px-3 py-2 border-b border-gray-700">0.565</td>

            <td class="px-3 py-2 border-b border-gray-700">0.803</td>

            <td class="px-3 py-2 border-b border-gray-700">0.991</td>

            <td class="px-3 py-2 border-b border-gray-700">1.468</td>

            <td class="px-3 py-2 border-b border-gray-700">2.767</td>

            <td class="px-3 py-2 border-b border-gray-700">0.045</td>

            <td class="px-3 py-2 border-b border-gray-700">0.046</td>

            <td class="px-3 py-2 border-b border-gray-700">0.041</td>

            <td class="px-3 py-2 border-b border-gray-700">0.043</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0483</td>

            <td class="px-3 py-2 border-b border-gray-700">0.890</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Baloo</td>

            <td class="px-3 py-2 border-b border-gray-700">0.097</td>

            <td class="px-3 py-2 border-b border-gray-700">0.105</td>

            <td class="px-3 py-2 border-b border-gray-700">0.096</td>

            <td class="px-3 py-2 border-b border-gray-700">0.101</td>

            <td class="px-3 py-2 border-b border-gray-700">0.101</td>

            <td class="px-3 py-2 border-b border-gray-700">0.020</td>

            <td class="px-3 py-2 border-b border-gray-700">0.021</td>

            <td class="px-3 py-2 border-b border-gray-700">0.019</td>

            <td class="px-3 py-2 border-b border-gray-700">0.021</td>

            <td class="px-3 py-2 border-b border-gray-700">0.020</td>

            <td class="px-3 py-2 border-b border-gray-700">0.794</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Commit-and-prove lookup tables are especially suitable for the Ethereum Foundation's zero-knowledge Ethereum Virtual Machine (zkEVM), which nowadays uses Halo2 with KZG commitments as a backend. In this section we describe an overview of how lookups are currently used in the Halo2 proving system [BGH19] and claim Baloo can be used as a drop-in replacement to</p>

    <p class="text-gray-300">the Halo2 lookup argument with better prover efficiency. In other words <span class="math">\\mathsf{Ba}loo</span> is backwards-compatible with instantiations of Halo2 that use KZG commitments.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ba}loo</span> is a proving system for the relation that</p>

    <p class="text-gray-300">\\[ \\mathsf{R_{lookup}}=\\left\\{\\begin{array}[]{ll}\\mathsf{cm_{a}};\\ A(X)&\\mbox{ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\end{array}\\right. \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathbb{V}</span> is a set of roots of unity that is <em>independent</em> from <span class="math">N</span> (the size of the lookup table <span class="math">\\mathsf{cm_{c}}</span>) and <span class="math">\\mathsf{Commit}</span> is the KZG commitment algorithm <em>[x10]</em>. This lookup argument only handles a single column. Suppose instead that we want to prove <span class="math">f(x)=y</span> by precomputing all possible values <span class="math">T=\\{(x_{s},f(x_{s}))\\}_{s=1}^{N}</span> and looking up whether <span class="math">(x,y)\\in T</span>. To achieve this we require more functionality from our lookup argument. In particular we need to be able to prove a lookup argument over <em>multicolumned</em> tables.</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Multi-column <span class="math">\\mathsf{Ba}loo</span></h4>

    <p class="text-gray-300">We build on the Halo2 approach . Given a lookup with input column polynomials <span class="math">[A_{0}(X),\\ldots,A_{k-1}(X)]</span> and a multi-columned table of the form <span class="math">C=\\{c_{i,s}\\}_{i,s=1}^{k,N}</span>, their prover shows that for all <span class="math">\\nu\\in\\mathbb{V}</span>, there exists some <span class="math">s</span> such that <span class="math">(A_{0}(\\nu),\\ldots,A_{k-1}(\\nu))=(c_{0,s},\\ldots,c_{k-1,s})</span>. It does this by taking a random linear combination of the input column polynomials and the table columns and then running a lookup argument over the compressed values. We present a similar compression for <span class="math">\\mathsf{Ba}loo</span> such that we can run lookups over multi-columned tables.</p>

    <p class="text-gray-300">Similarly than in Caulk+, described in Section 5.1, the pre-processing phase commits to the table <span class="math">\\{c_{i,s}\\}_{i,s=1}^{k,N}</span> by committing to the column polynomials</p>

    <p class="text-gray-300"><span class="math">C_{s}(X)=\\sum_{s=1}^{N}c_{s}\\lambda_{s}(X)</span></p>

    <p class="text-gray-300">for <span class="math">\\{\\lambda_{s}(X)\\}_{s=1}^{N}</span> the Lagrange interpolation polynomials of a set of roots of unity <span class="math">H=\\{\\omega^{s}\\}_{s=1}^{N}</span> of size <span class="math">N</span>. The pre-processing phase also computes auxiliary information for the prover, namely it computes commitments to the polynomials</p>

    <p class="text-gray-300"><span class="math">\\{Q_{i,s}(X)=(C_{s}(X)-C_{s}(\\omega_{j}))/(X-\\omega^{s})\\}_{i,s=1}^{k,N},</span> <span class="math">H_{s}(X)=\\{z_{H}(X)/(X-\\omega^{s})\\}_{s=1}^{N}</span></p>

    <p class="text-gray-300">in time <span class="math">kN\\log_{2}(N)</span>.</p>

    <p class="text-gray-300">Given the input column polynomials <span class="math">[A_{0}(X),\\ldots,A_{k-1}(X)]</span> we sample a random value <span class="math">\\theta</span>. Suppose that <span class="math">I</span> is the set of points such that <span class="math">j\\in I</span> if and only if <span class="math">(c_{0,s},\\ldots,c_{k-1,s})</span> appears in the input columns i.e. <span class="math">(c_{0,s},\\ldots,c_{k-1,s})\\in\\{(A_{0}(\\nu),\\ldots,A_{k-1}(\\nu))\\}_{\\nu\\in\\mathbb{V}}</span>. Then the prover commitments to the compressed polynomials</p>

    <p class="text-gray-300"><span class="math">A_{\\mathsf{comp}}(X)=A_{0}(X)+\\ldots+\\theta^{k-1}A_{k-1}(X)=\\sum_{j=1}^{m}\\left(\\sum_{i=0}^{k}\\theta^{i}A_{i}(\\nu_{j})\\right)\\mu_{j}(X)</span></p>

    <p class="text-gray-300">37</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} C_{\\text{comp}}(X) = C_0(X) + \\dots + \\theta^{k-1} C_{k-1}(X) = \\sum_{s=1}^{N} \\left( \\sum_{i=0}^{k} \\theta^i c_{i,s} \\right) \\lambda_s(X) \\\\ \\text{for } s \\in I, \\, Q_{\\text{comp},j} = Q_{0,s}(X) + \\dots + \\theta^{k-1} Q_{k-1,s}(X) \\\\ = \\left( \\sum_{i=0}^{k-1} \\theta^i C_i(X) - \\theta^i C_i(\\omega^s) \\right) / (X - \\omega^s) \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, <span class="math">C_{\\text{comp}}(X)</span> describes table <span class="math">C_{\\text{comp}} = \\left\\{ \\sum_{i=0}^{k-1} \\theta^i c_{i,s} \\right\\}_{s=1}^N</span>. The randomiser <span class="math">\\theta</span> is sampled from a large field. Thus the probability that <span class="math">\\sum_{i=0}^{k} \\theta^i A_i(\\nu) \\in C_{\\text{comp}}</span> is negligible unless there exists some <span class="math">s</span> such that <span class="math">(A_0(\\nu), \\ldots, A_{k-1}(\\nu)) = (c_{0,s}, \\ldots, c_{k-1,s})</span>. The auxiliary information that the prover requires for efficiency, namely commitments to <span class="math">\\{H_s(X), Q_{\\text{comp},s}(X)\\}_{s \\in I}</span>, can be computed in <span class="math">km</span> time where $m =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is the number of lookups.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus for <span class="math">\\mathsf{cm}_{\\mathsf{comp}}</span> a commitment to <span class="math">A_{\\mathsf{comp}}(X)</span>, the prover demonstrates that <span class="math">\\mathsf{cm}_{\\mathsf{comp}} \\in R_{\\mathsf{lookup}}</span> with respect to the table <span class="math">C_{\\mathsf{comp}}</span>.</p>

    <h2 id="sec-47" class="text-2xl font-bold">D Implementation</h2>

    <p class="text-gray-300">In this section, we compare Ba'loo's performance with its most direct competitors: Caulk, Harisa and Merkle Trees with Poseidon Hases. Ba'loo has been implemented<span class="math">^6</span> in Rust using the arkworks library [ac22]. We use Caulk's implementation<span class="math">^7</span> to measure its performance and run Harisa and Merkle Trees using the Legosnark code<span class="math">^8</span>. We instantiate Baloo, Caulk and Merkle Trees for tables of size <span class="math">2^{20}</span> (recall that in RSA based systems performance is independent of table size), and consider <span class="math">m = 10, 16, 20, 50^9</span>. Benchmarks were obtained by running the respective codes in a laptop with CPU i7-8565U and 8GB of RAM.</p>

    <p class="text-gray-300">We highlight prover work in Fig. 9, where <span class="math">y</span> axis represent prover time, and <span class="math">x</span> axis represent the value of <span class="math">m</span>. We specify running numbers of the provers, as well as verifiers and proof size in Table 2.</p>

    <p class="text-gray-300"><span class="math">^6</span>https://github.com/anonshidf7seifh/baloo <span class="math">^7</span>https://github.com/caulk-crypto/caulk <span class="math">^8</span>https://github.com/matteocam/libsnark-lego/ <span class="math">^9</span>Chosen over the available numbers for RSA accumulators in the Legosnark codebase.</p>

    <p class="text-gray-300">Baloo</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 9: Comparison for lookup tables</p>`;
---

<BaseLayout title="Baloo: Nearly Optimal Lookup Arguments (2022/1565)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1565
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
