---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/233';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Toward Practical Homomorphic Evaluation of Block Ciphers Using Prince';
const AUTHORS_HTML = 'Yarkın Doröz, Aria Shahverdi, Thomas Eisenbarth, Berk Sunar';

const CONTENT = `    <p class="text-gray-300">Yarkın Doröz Aria Shahverdi Thomas Eisenbarth Berk Sunar</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present the homomorphic evaluation of the Prince block cipher. Our leveled implementation is based on a generalization of NTRU. We are motivated by the drastic bandwidth savings that may be achieved by scheme conversion. To unlock this advantage we turn to <em>lightweight</em> ciphers such as Prince. These ciphers were designed from scratch to yield fast and compact implementations on resource-constrained embedded platforms. We show that some of these ciphers have the potential to enable near practical homomorphic evaluation of block ciphers. Indeed, our analysis shows that Prince can be implemented using only a 24 level deep circuit. Using an NTRU based implementation we achieve an evaluation time of 3.3 seconds per Prince block – one and two orders of magnitude improvement over homomorphic AES implementations achieved using NTRU, and BGV-style homomorphic encryption libraries, respectively.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">Homomorphic encryption, NTRU, Prince, lightweight block ciphers.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">An encryption scheme is <em>fully homomorphic</em> (FHE scheme) if it permits the efficient evaluation of any boolean circuit or arithmetic function on ciphertexts <em>[1]</em>. Gentry proposed the first FHE scheme <em>[2, 3]</em> based on lattices that supports addition and multiplication circuits for arbitrary depth. Since addition and multiplication on any non-trivial ring give us a universal set of logic gates, this scheme – if made efficient – allows one to employ <em>any</em> untrusted computing resources without risk of revealing sensitive data. In <em>[4]</em>, van Dijk, et al., proposed a FHE scheme based on integers. In 2010, Gentry and Halevi <em>[5]</em> presented a variant of Gentry’s FHE; this publication introduced a number of optimizations as well as the first actual FHE implementation. For other optimizations see also <em>[6, 7, 8]</em>. Although these earlier schemes have achieved full homomorphism, there is a serious bottleneck that prevents deployment.</p>

    <p class="text-gray-300">To address this problem, some newer FHE schemes were proposed in recent years. In <em>[9]</em>, Brakerski, Gentry and Vaikuntanathan proposed a new FHE scheme (BGV) based on LWE problems. Instead of re-encryption, this new scheme uses other lightweight methods to refresh ciphertexts. These methods cannot thoroughly refresh ciphertexts (as re-encryption does), but they limit noise growth so</p>

    <p class="text-gray-300">that the scheme can evaluate much deeper circuits. The re-encryption process is then reserved as an optimization only for extremely complicated circuits instead of a necessity for the majority of practical circuits. Gentry, Halevi and Smart <em>[8]</em> proposed a customized LWE-based FHE scheme tailored to achieve efficient evaluation of the AES cipher without bootstrapping. Their implementation is highly customized to evaluate AES efficiently and makes use of batching <em>[7]</em>, key and modulus switching techniques <em>[9]</em>. Their byte-sliced and SIMD implementations take about 5 minutes and 40 minutes, respectively, to evaluate an AES block.</p>

    <p class="text-gray-300">In <em>[10]</em>, Alt-López, Tromer and Vaikuntanathan adopted this idea to Stehlé and Steinfeld’s generalized NTRU scheme <em>[11]</em> and developed an FHE scheme (ATV) that supports inputs from multiple public keys. Bos et al. <em>[12]</em> presented a leveled FHE scheme and its implementation derived from ATV. The ATV scheme is modified by adopting a tensor product technique introduced by Brakerski <em>[14]</em> such that the security depends only on standard lattice assumptions (and no longer on the decisional small polynomial ratio assumption). Furthermore, modulus switching is no longer needed due to the reduced noise growth. Lastly, the authors advocate use of the Chinese Remainder Theorem on the message space to improve the flexibility of the scheme. In <em>[15]</em> Doröz, Hu and Sunar propose another implementation based on the ATV scheme <em>[10]</em>. Similar to earlier proposals the implementation is batched, bit-sliced and features modulus switching techniques. The authors also introduce a specialization of the modulus to reduce the public key size and thereby memory required during evaluation. The scheme is generic, i.e. not customized to efficiently evaluate any specific class of circuits such as AES. When used to evaluate an AES block the implementation performs one order of magnitude faster than the implementation of <em>[8]</em>.</p>

    <p class="text-gray-300">More recent FHE schemes displayed significant improvements over earlier constructions in both time complexity and in ciphertext size. Nevertheless, both latency and message expansion rates remain roughly two orders of magnitude higher than those of traditional public-key schemes. This rapid emergence of a diverse set of homomorphic encryption schemes has brought with it the need to transform one ciphertext into another. Bootstrapping <em>[2]</em>, relinearization <em>[16]</em>, and modulus reduction <em>[9, 16]</em> are tools of this form, allowing someone other than the holder of the original private key to transform one encryption into one or more encryptions using the same scheme and (typically) a different key and/or different parameters. One important type of ciphertext transformation was introduced by Brakerski and Vaikuntanathan. In <em>[16, Sec. 1.1]</em>, the technique of <em>relinearization</em> is introduced as a way to re-encrypt quadratic polynomials as linear polynomials under a new key, thereby making their security argument independent of lattice assumptions and dependent only on a standard LWE hardness assumption.</p>

    <p class="text-gray-300">Lauter, Naehrig and Vaikuntanathan <em>[17]</em> discuss tools for making somewhat homomorphic encryption schemes more practical including <em>scheme conversion</em>. First, they present two natural options for encryption of integers and demonstrate the versatility afforded by efficient transforms between bitwise representation and integer representation with a larger modulus. The authors of <em>[17]</em> also</p>

    <p class="text-gray-300">use this conversion idea to facilitate efficient communication with a cloud server. If cloud computations are to be performed with a FHE scheme, data can be uploaded to the server under a more compact scheme such as AES provided it has a relatively simple decryption circuit. If computations on ciphertexts are to be carried out, the decryption circuit of the target scheme is evaluated homomorphically to re-encrypt this data under the FHE. The result of these computations is a collection of very large ciphertexts and, at present, no method is known to transform these back to AES encryptions. But Lauter et al. observe that the dimension reduction technique of Brakerski and Vaikuntanathan <em>[16]</em> is useful here to reduce the ciphertext size (i.e., the overall FHE is the same, but the parameters are smaller, prohibiting further computation) before transmitting the results back to the client. In <em>[17]</em>, efficient implementation is left as an important open problem.</p>

    <p class="text-gray-300">Motivated by this need, we propose the use of lightweight block ciphers to facilitate efficient conversion. As a research area lightweight block ciphers <em>[18]</em> emerged from the proliferation of severely constrained embedded and mobile computing applications such as RFIDs, sensor network nodes etc. Such applications demand cryptographic primitives that can be computed with very little power in compact chips. Driven by this strong need, a new class of lightweight block ciphers were designed from scratch with security and implementation efficiency in mind. Here we exploit the synergy between block ciphers designed for constrained environments and the efficiency bottleneck of homomorphic encryption schemes to achieve efficient homomorphic evaluation of a block cipher.</p>

    <p class="text-gray-300">Our Contribution. In this work,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we present a survey of lightweight block ciphers. We show that some lightweight block ciphers are more suitable than others. In contrast some lightweight ciphers have worse homomorphic evaluation performance than traditional block ciphers, e.g. AES since our metric (circuit depth) is related to but different than the metrics used in the construction of lightweight ciphers.</li>

      <li>we present a leveled homomorphic implementation of the Prince cipher. Our implementation makes use of the NTRU based library developed by Doröz, Hu and Sunar <em>[15]</em>. Specifically, we optimize the Prince cipher for shallow circuit implementation, and based on the depth characteristics, chose optimal but secure parameters for the library to evaluate Prince efficiently. With the chosen parameters, the batched implementation evaluates 1024 blocks in 57 minutes, with 3.3 seconds per block amortization.</li>

      <li>more broadly, we motivate the study of lightweight block cipher design for homomorphic evaluation bringing a new metric, i.e. circuit depth, to the attention of block cipher designers.</li>

    </ul>

    <h2 id="sec-5" class="text-2xl font-bold">2 Background</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 The ATV-FHE Scheme</h3>

    <p class="text-gray-300">NTRU based FHE schemes present a viable alternative to the currently dominant BGV style constructions. We follow the methodology proposed in <em>[15]</em> by Doröz</p>

    <p class="text-gray-300">et al. which builds on the NTRU based homomorphic encryption scheme (ATV) by Alt-López, Tromer and Vaikuntanathan [10]. The ATV scheme uses a variant of NTRU proposed by Stehlé and Steinfeld [11] to develop a leveled multi-key FHE that features a new operation named relinearization. The authors note that although the transformation to a fully homomorphic system deteriorates the efficiency, their construction is a leading candidate for a practical FHE scheme.</p>

    <p class="text-gray-300">We next briefly outline the single key version of the ATV scheme. All operations are performed in <span class="math">\\mathrm{R}_q = \\mathbb{Z}_q[x] / \\langle x^n + 1 \\rangle</span> where <span class="math">n</span> represents the lattice dimension and <span class="math">q</span> is the prime modulus. A polynomial is <span class="math">B</span>-bounded if all of its coefficients lie in <span class="math">[-B, B]</span>. In the primitives we often sample "small" polynomials <span class="math">f \\in \\mathbb{R}</span> such that <span class="math">f</span> is <span class="math">B</span>-bounded. The error distribution <span class="math">\\chi</span> is the truncated discrete Gaussian distribution <span class="math">\\mathbb{D}_{\\mathbb{Z}^n, r}</span> for standard deviation <span class="math">r &amp;gt; 0</span>. A sample from this distribution is a <span class="math">r\\sqrt{n}</span>-bounded polynomial <span class="math">e \\in \\mathbb{R}</span>. For a detailed treatment of the discrete Gaussian distribution see [19]. With these definitions we are now ready to outline the primitives of the public key encryption scheme:</p>

    <p class="text-gray-300"><strong>KeyGen</strong> We choose a decreasing sequence of primes <span class="math">q_0 &amp;gt; q_1 &amp;gt; \\dots &amp;gt; q_d</span> and a polynomial <span class="math">\\phi(x) = x^n + 1</span>. For each <span class="math">i</span>, we sample <span class="math">u^{(i)}</span> and <span class="math">g^{(i)}</span> from distribution <span class="math">\\chi</span>, set <span class="math">f^{(i)} = 2u^{(i)} + 1</span> and <span class="math">h^{(i)} = 2g^{(i)}\\left(f^{(i)}\\right)^{-1}</span> in ring <span class="math">R_{q_i} = \\mathbb{Z}_{q_i}[x] / \\langle \\phi(x) \\rangle</span> (If <span class="math">f^{(i)}</span> is not invertible, re-sample). We then sample, for <span class="math">i = 0, \\ldots, d</span> and for <span class="math">\\tau = 0, \\ldots, \\lfloor \\log q_i \\rfloor</span>, <span class="math">s_\\tau^{(i)}</span> and <span class="math">e_\\tau^{(i)}</span> from <span class="math">\\chi</span> and publish evaluation key <span class="math">\\left\\{\\zeta_\\tau^{(i)}(x)\\right\\}_\\tau^i</span> where <span class="math">\\zeta_\\tau^{(i)}(x) = h^{(i)}s_\\tau^{(i)} + 2e_\\tau^{(i)} + 2^\\tau \\left(f^{(i-1)}\\right)^2</span> in <span class="math">R_{q_{i-1}}</span>.</p>

    <p class="text-gray-300"><strong>Encrypt</strong> To encrypt a bit <span class="math">b \\in \\{0,1\\}</span> with a public key <span class="math">(h^{(0)}, q_0)</span>, <strong>Encrypt</strong> first generates random samples <span class="math">s</span> and <span class="math">e</span> from <span class="math">\\chi</span> and sets <span class="math">c^{(0)} = h^{(0)}s + 2e + b</span>, a polynomial in <span class="math">R_{q_0}</span>.</p>

    <p class="text-gray-300"><strong>Decrypt</strong> To decrypt the ciphertext <span class="math">c</span> with the corresponding private key <span class="math">f^{(i)}</span>, <strong>Decrypt</strong> multiplies the ciphertext and the private key in <span class="math">R_{q_i}</span> then compute the message by modulo two: <span class="math">m = c^{(i)}f^{(i)}</span> (mod 2)</p>

    <p class="text-gray-300"><strong>Eval</strong> We assume we are computing a leveled circuit with gates alternating between XOR and AND. Arithmetic operations are performed directly on ciphertexts as follows: Suppose <span class="math">c_1^{(0)} = \\mathsf{Encrypt}(b_1)</span> and <span class="math">c_2^{(0)} = \\mathsf{Encrypt}(b_2)</span>. Then XOR is effected by simply adding ciphertexts: <span class="math">\\mathsf{Encrypt}(b_1 + b_2) = c_1^{(0)} + c_2^{(0)}</span>. Polynomial multiplication incurs a much greater growth in the noise, so each multiplication step is followed by a modulus switching. First, we compute <span class="math">\\tilde{c}^{(0)}(x) = c_1^{(0)}\\cdot c_2^{(0)}</span> (mod <span class="math">\\phi(x)</span>) and then perform <strong>Relinearization</strong>, as described below, to obtain <span class="math">\\tilde{c}^{(1)}(x)</span> followed by modulus switching <span class="math">\\mathsf{Encrypt}(b_1\\cdot b_2) = \\lfloor \\frac{q_1}{q_0}\\tilde{c}^{(1)}(x)\\rfloor_2</span> where the subscript 2 on the rounding operator indicates that we round up or down in order to make all coefficients equal modulo 2. The same process holds for evaluating with <span class="math">i</span>th level ciphertexts, e.g. computing <span class="math">\\tilde{c}^{(i)}(x)</span> from <span class="math">c_1^{(i-1)}</span> and <span class="math">c_2^{(i-1)}</span>.</p>

    <p class="text-gray-300">In addition to the primitives [10] defines another operation named <strong>Relinearization</strong> that computes <span class="math">\\tilde{c}^{(i)}(x)</span> from <span class="math">\\tilde{c}^{(i-1)}(x)</span> extending <span class="math">\\tilde{c}^{(i-1)}(x)</span> as a linear combination of 1-bounded polynomials <span class="math">\\tilde{c}^{(i-1)}(x) = \\sum_{\\tau} 2^{\\tau} \\tilde{c}_{\\tau}^{(i-1)}(x)</span> where <span class="math">\\tilde{c}_{\\tau}^{(i-1)}(x)</span> takes its coefficients from <span class="math">\\{0,1\\}</span>. Also define <span class="math">\\tilde{c}^{(i)}(x) = \\sum_{\\tau} \\zeta_{\\tau}^{(i)}(x) \\tilde{c}_{\\tau}^{(i-1)}(x)</span> in <span class="math">R_{q_i}</span>.</p>

    <p class="text-gray-300">Note that by augmenting the public key with the evaluation keys <span class="math">\\zeta_{\\tau}^{(i)}(x)</span>, i.e. encrypted shifted versions of <span class="math">f^{2}</span>, it becomes possible to homomorphically evaluate the product of <span class="math">c</span> with the encrypted <span class="math">f^{2}</span> using a shallow circuit of only additions. The authors propose the use of relinearization (with modulus switching) after both addition and multiplication operations and define evaluation key parameters accordingly. To relinearize after additions, we need shifted versions of the secret key <span class="math">f</span> encrypted with respect to the new modulus, whereas for after multiplications, we need the same but of <span class="math">f^{2}</span> instead.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 The DHS FHE Library</h3>

    <p class="text-gray-300">Doröz, Hu and Sunar (DHS) <em>[15]</em> proposed a customized leveled implementation of the ATV FHE scheme. The code is written in C++ and relies on the library functions provided by NTL software package linked with GMP. The implementation introduces a number of optimizations, including a modulus specialization technique to reduce the public key size. The main features of the DHS implementation are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The arithmetic is performed over <span class="math">\\mathrm{R}_{q}=\\mathbb{Z}_{q}[x]/\\langle\\Psi_{m}(x)\\rangle</span> where the modulus <span class="math">q</span> takes the special form <span class="math">q=p^{k}</span> and <span class="math">p&gt;2</span> is a prime, and <span class="math">\\Psi_{m}(x)</span> denotes the <span class="math">m^{th}</span> cyclotomic polynomial and <span class="math">n=\\varphi(m)=\\deg(\\Psi)</span>. Noise vectors are chosen from the discrete Gaussian noise distribution <span class="math">\\chi</span> <em>[19]</em>.</li>

      <li>Circuit evaluation is divided into levels by the multiplication (AND) operations. Modulus switching is implemented at the end of each level. Since the moduli are special: <span class="math">q=p^{k}</span>, after every multiplication first relinearization is performed which is then followed by modulus switching. Due to the special structure, the public key in one level can also be promoted to the next level via modular reduction. For instance, to evaluate a depth <span class="math">d</span> circuit, the scheme uses the public key in the first level defined over <span class="math">q_{0}=p^{d}</span> which is then promoted to the following levels that use <span class="math">q_{1}=p^{d-1},q_{2}=p^{d-2},\\ldots,q_{d-1}=p</span> by on-the-fly modular reduction with the new modulus, significantly reducing the memory requirement.</li>

      <li>The authors analyze the noise growth during circuit evaluation and determined that to keep the noise stable over the levels of the evaluation one needs to cut after each relinearization by</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\log(p)\\approx\\log\\left(\\epsilon[an(6B^{2}+2B)\\log(aq_{0})+n^{3/2}(2B+1)^{2}B^{2}]\\right)</span></p>

    <p class="text-gray-300">bits where <span class="math">\\epsilon</span> is small constant chosen to minimize the error probability, <span class="math">B=2</span> from the <span class="math">\\chi</span> distribution, and <span class="math">a</span> represents the maximum number of ciphertexts summed before multiplication in each level. Also note that in instantiation we fix <span class="math">\\chi</span> to choose from <span class="math">\\{-1,0,1\\}</span> with probabilities <span class="math">\\{0.25,0.5,0.25\\}</span>, respectively.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The implementation is bit-sliced and uses the batching technique proposed by Smart and Vercauteren <em>[6, 7]</em> (see also <em>[8]</em>). For this the modulus polynomial <span class="math">\\Psi_{m}(x)</span> is factorized over <span class="math">\\mathbb{F}_{2}</span> into equal degree polynomials <span class="math">F_{i}(x)</span> which</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">define the message slots in which message bits are embedded using the Chinese Remainder Theorem. Therefore, the number of message slots is found as  <span class="math">\\ell = \\varphi(m) / t</span>  where  <span class="math">\\deg(F_i(x)) = t</span>  may be determined by finding the smallest integer  <span class="math">d</span>  such that  $m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(2^t - 1)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The ATV library contains 5 main operations; KEYGEN, ENCRYPTION, DECRYPTION, MODULUS SWITCH and RELINEARIZATION. The most critical operation for circuit evaluation is RELINEARIZATION. The other operations have negligible effect on the run time.</p>

    <p class="text-gray-300">The authors also implement the 128-bit AES circuit to compare the performance of their scheme to the earlier AES implementation by Gentry, Halevi and Smart [8]. The implementation manages to evaluate the 10 round AES circuit in 31 hours with 2048 message slots with a 55 sec per AES block evaluation time making it 48 times faster than the generic SIMD implementation, 6 times faster than the AES customized byte-sliced implementation by Gentry, Halevi and Smart.</p>

    <p class="text-gray-300">Several lightweight block ciphers have been proposed with the goal of permitting a compact hardware implementation or good performance at small memory footprint in software. Examples include ciphers like Present, KATAN, TEA, HIGHT, etc. An overview of implementation properties can be found in [20]. Among these, Prince is a lightweight block cipher that has been optimized for low latency and a small hardware footprint [21]. It features a 64-bit block size, 128-bit key size. Prince implements a substitution-permutation network which iterates for 12 rounds. The round function is AES-like and operates on a 4 by 4 array of nibbles, with 4-bit S-boxes, shift rows and mix columns operations. The round key remains constant, but is augmented with a 64-bit round constant to ensure variation between rounds. An interesting feature of Prince is the inflective property: encryption and decryption only differ in the round key, i.e. decryption can use the same implementation as encryption, only the round key needs to be modified. Figure 1 shows the structure of the Prince cipher. To implement</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. The Prince cipher</p>

    <p class="text-gray-300">Prince, the following operations have to be realized:</p>

    <p class="text-gray-300">The 128-bit key is split into two parts  <span class="math">k_{0}</span>  and  <span class="math">k_{1}</span> .  <span class="math">k_{0}</span>  is used to generate another key  <span class="math">k_{0}&#x27; = (k_{0} &amp;gt;&amp;gt; 1) \\oplus (k_{0} &amp;gt;&amp;gt; 63)</span> . The keys  <span class="math">k_{0}</span>  and  <span class="math">k_{0}&#x27;</span>  are used as pre- and post-whitening keys, i.e. are XOR-added to the state before and after all round functions are performed. The round key  <span class="math">k_{1}</span>  is the same for all rounds and is also XOR-added during the key addition phase.</p>

    <p class="text-gray-300">Roun d Constant Addition Prince defines different round constants  <span class="math">RC_{i}</span>  for each round. A noteworthy property of the round constants is that  <span class="math">RC_{i} \\oplus RC_{11 - i} = \\alpha</span>  for  <span class="math">0 \\leq i \\leq 11</span> , with  <span class="math">\\alpha = c0ac29b7c97c50dd</span> . The round constant addition is a binary addition, just as the round key addition. Both operations can be merged.</p>

    <p class="text-gray-300">S-box The S-box layer uses a mapping of 4-bit to 4-bit, as defined in the following table. The S-box is the only operation of Prince that is not linear</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S[i]</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">E</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">in the bits, and hence needs costly AND operations (or binary multiplication) for its implementation. While other S-boxes are possible for Prince, we chose to use the original S-box, since the maximum depth of multiplication is already optimal for the standard S-box. More details on how we implemented the S-box is given in Section 3.2.</p>

    <p class="text-gray-300">Linear Layer The linear layer consists of two parts: a shift rows which is similar to the shift rows used in AES and simply changes the order of the nibbles. Hence, it is a free operation in a bit-oriented implementation. The mix columns equivalent XOR-adds three input bits to compute one output bit in such a way that the operation is invertible. Again, this operation is linear and easily implementable.</p>

    <p class="text-gray-300">All operations also need an implementation of their inverse, as the last six rounds use the inverse operations.</p>

    <p class="text-gray-300">In this section we describe our implementation in detail. Specifically, we first present a study of the depth characteristics of popular lightweight block ciphers among which we identify the Prince cipher as the most promising for homomorphic evaluation. Later we present in detail a shallow circuit implementation of Prince. In what follows, we select optimal parameters for the Doroz et al. [15] leveled ATV FHE implementation to support evaluation of the Prince circuit.</p>

    <p class="text-gray-300">We are looking for any cipher that provides efficient encryption while permitting a shallow circuit implementation, i.e. the number of consecutive multiplication</p>

    <p class="text-gray-300">levels should be minimized. Therefore we turn our attention to lightweight block ciphers [22]. There are two main factors that increase the number of consecutive multiplications: The size and complexity of the S-boxes, as higher non-linearity usually results in higher-degree terms, i.e. an increased number of consecutive binary multiplications. PRESENT [18], for example, has very simple S-boxes, resulting in a shallow circuit for each individual S-box. Another important factor is the number of rounds, where PRESENT is less optimal due to the rather high number of rounds. Prince, a recently proposed block cipher [21], has roughly the same complexity for the S-boxes, but has only 12 rounds which make it a much more efficient choice for our purposes. The more complex linear layer is not a problem, since it does not introduce new binary multiplications. We present an overview of the complexity of different lightweight ciphers in Table 1.</p>

    <p class="text-gray-300">Table 1. Comparison of the complexity of common lightweight block ciphers in number of rounds, algebraic degree of the S-box function, algebraic degree of a round excluding the S-box, per round and total number of multiplicative levels.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ALGEBRAIC DEGREE</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TOTAL DEPTH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">S-box</td>

            <td class="px-3 py-2 border-b border-gray-700">Rem. Round</td>

            <td class="px-3 py-2 border-b border-gray-700">Per Round</td>

            <td class="px-3 py-2 border-b border-gray-700">Full Cipher</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES-128 [23]</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Present [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prince [21]</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HIGHT [24]</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SEA96,8 [25]</td>

            <td class="px-3 py-2 border-b border-gray-700">93</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">372</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KATAN-64 [26]</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Simon-64/96 (64/128) [27]</td>

            <td class="px-3 py-2 border-b border-gray-700">42 (44)</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">42 (44)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the cipher depth is almost fully determined by the consecutive levels of binary AND-statements. The two software-oriented ciphers, namely SEA and HIGHT, feature Feistel-structure and a high number of rounds. The number of rounds, together with the Feistel structure, results in a high depth circuit, making them a bad choice for our purposes. Furthermore, additions mod  <span class="math">2^{n}</span>  add significant depth due to high nonlinearity for the most significant output bits. While there are [12, 13] FHE implementations capable of evaluating integer operations they do not support mixing of integer and bit-oriented operations as required by most block ciphers. Hence, the hardware-oriented ciphers such as Present and Prince seem more appropriate. Certain possible cipher-specific optimizations are likely missed in the table. Katan, for example, allows the evaluation of a few rounds in parallel, since independent bits are processed in consecutive rounds. We did not explore this further due to the big starting disadvantage in the number of rounds. It can be seen that AES already offers quite a low depth, due to the low number of rounds. In practice, the depth 30 implementation of AES is not attainable since the number of multiplications grows significantly.</p>

    <p class="text-gray-300">Instead at best a depth 40 implementation is used in practice <em>[15]</em>. Either way, the Prince cipher offers a significant improvement over AES.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.2 Prince as a Shallow Circuit</h3>

    <p class="text-gray-300">As described in Section 2.3, Prince can be implemented in a way that every operation is done on a single bit. Consecutive AND operations are costly in the ATV FHE scheme so it is a necessity to prevent them as much as possible. The only part of Prince that is nonlinear is the S–box layer. To determine an optimal representation of the S–box, we use Mathematica to obtain the Algebraic Normal Form (ANF), which represents all equations only in terms of XOR or AND statements. The following table gives the resulting ANF representation of the Prince S–box <span class="math">S(A,B,C,D)=(S_{0},S_{1},S_{2},S_{3})</span>. According to the table</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{l}\\hline\\cr S_{0}&A\\oplus C\\oplus AB\\oplus BC\\oplus ABD\\oplus ACD\\oplus BCD\\oplus 1\\\\ S_{1}&A\\oplus D\\oplus AC\\oplus AD\\oplus CD\\oplus ABC\\oplus ACD\\\\ S_{2}&AC\\oplus BC\\oplus BD\\oplus ABC\\oplus BCD\\oplus 1\\\\ S_{3}&A\\oplus B\\oplus AB\\oplus AD\\oplus BC\\oplus CD\\oplus BCD\\oplus 1\\end{array} \\]</p>

    <p class="text-gray-300">the S–box requires 28 AND-operations. Further optimization, making use of efficient reuse of intermediate terms, enables a significant reduction of two-input AND operations. The values for <span class="math">AB,AC,AD,BC,BD,CD</span> can simply be stored and used whenever it is necessary instead of recalculating them every time. There exist four more terms in the formula that can be saved and used again; these values are <span class="math">ABD,ABC,ACD,BCD</span>. To be more efficient, for calculating the first two terms and the next two terms we will use the saved value <span class="math">AB</span> and <span class="math">CD</span>, respectively. The resulting depth of the multiplication is 2 i.e. one for calculating terms such as <span class="math">AB</span> and one for calculating terms such as <span class="math">ABD</span>. Hence the total number of ANDs for S–box would be 10—much less than by straight implementation of the ANF. The same procedure is applied to optimize the implementation of the inverse S–box.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.3 Parameter Selection for the ATV FHE</h3>

    <p class="text-gray-300">We follow the parameter selection process of <em>[15]</em> for our ATV Prince implementation. In Table 2 we summarize the chosen parameters for Prince and AES. Clearly, the 24 levels of Prince give us an advantage over the 40 level AES in selecting smaller parameters: The polynomial degree of Prince is half the size of AES with <span class="math">n=16384</span>. The per level cutting rate is <span class="math">\\log{(p)}=20</span> bits, better than expected than the noise analysis in <em>[15]</em> predicts. The reason is simple; the Prince S–box has AND operations with three gates, e.g. <span class="math">A\\cdot B\\cdot C</span>, and therefore in the second level two polynomials with different noise levels are multiplied, whereas <em>[15]</em> assumes the product inputs bear the same level of noise. With <span class="math">\\log{(p)}=20</span>, the modulus may be chosen as <span class="math">\\log(q_{0})=500</span> which is less than half</p>

    <p class="text-gray-300">Table 2. Parameters for the AES [15] and our Prince implementations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log(q0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">δ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LEVELS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log(p)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MESSAGE SLOTS</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">1271</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0067</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prince</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0052</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as long as the AES modulus, i.e. 1271-bits used in [15]. With  <span class="math">n = 16384</span>  and  <span class="math">\\log (q_0)</span> , our Hermite factor is  <span class="math">\\delta = 1.0052</span> . This gives us a 130-bit security level, which actually exceeds the security claims of Prince. The only disadvantage of our Prince evaluation is that we have fewer message slots, exactly half of those of the AES evaluation.</p>

    <p class="text-gray-300">We ran our implementation on a single thread on Intel Core i7 3770K running 3.5 Ghz with 32 GBytes of memory. The most expensive Prince operation is the evaluation of the S-box circuit, since it is the only operation that contains multiplications and therefore requires Relinearization. The S-box is evaluated using 6 Relinearizations, resulting in 1,152 Relinearizations for the entire evaluation. The execution completes in 57 minutes compared to 31 hours [15] and 36 hours [8] for AES. This shows about  <span class="math">\\times 30</span>  speedup. A block of Prince encryption takes 3.3 seconds compared to 55 seconds for AES blocks. Another significant advantage of Prince is that at 1 Gbytes the public key is much smaller. Therefore we can run our implementations on standard machines.</p>

    <p class="text-gray-300">Table 3. Performance comparison of Prince against AES implementations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TOTAL TIME</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#BLOCKS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PER BLOCK seconds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PK Size GBytes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">31 hours</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">13.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES-Byte Sliced [8]</td>

            <td class="px-3 py-2 border-b border-gray-700">65 hours</td>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">n/a</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES-SIMD Sliced [8]</td>

            <td class="px-3 py-2 border-b border-gray-700">36 hours</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">2400</td>

            <td class="px-3 py-2 border-b border-gray-700">n/a</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prince (Ours)</td>

            <td class="px-3 py-2 border-b border-gray-700">57 minutes</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We presented a customized implementation of the lightweight block cipher Prince using a leveled fully homomorphic encryption scheme based on NTRU. For this we surveyed lightweight block ciphers and analyzed them with respect to a new metric: circuit depth. Our analysis determined that the Prince block cipher is the</p>

    <p class="text-gray-300">most suitable for homomorphic evaluation as it can be implemented using only a depth 24 circuit. Using the recently proposed ATV library <em>[15]</em> we developed an optimized shallow circuit implementation of Prince, which yielded an amortized 3.3 seconds per block evaluation running time, one to two orders of magnitude faster than previous homomorphic AES evaluation proposals <em>[8, 15]</em>.</p>

    <p class="text-gray-300">With this work, we presented a near practical block cipher implementation that could be used for scheme conversion <em>[17]</em>. We also aim to further motivate research in the field of lightweight cryptography under the new shallow circuit or circuit depth metric.</p>

    <h2 id="sec-15" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">Funding for this research was in part provided by the US National Science Foundation CNS Awards #1117590, #1319130, and #1261399.</p>

    <h2 id="sec-16" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Rivest, R.L., Adleman, L., Dertouzos, M.L.: “On data banks and privacy homomorphisms.” In: Foundations of Secure Computation, 1978.</li>

      <li>[2] Gentry, C.: “Fully homomorphic encryption using ideal lattices.” Symposium on the Theory of Computing (STOC), 2009, pp. 169-178.</li>

      <li>[3] Gentry, C.: A Fully Homomorphic Encryption Scheme. Ph.D. thesis, Department of Computer Science, Stanford University, 2009.</li>

      <li>[4] Van Dijk, M., Gentry, C., Halevi, S., Vaikuntanathan, V.: “Fully homomorphic encryption over the integers.” Advances in Cryptology–EUROCRYPT 2010 (2010): 24-4</li>

      <li>[5] Gentry, C., Halevi, S.: “Implementing Gentry’s fully-homomorphic encryption scheme,” Advances in Cryptology–EUROCRYPT 2011, pp. 129–148, 2011.</li>

      <li>[6] Gentry, C., Halevi, S., Smart, N.P.: “Fully homomorphic encryption with polylog overhead.” Manuscript, 2011.</li>

      <li>[7] Smart, N.P., Vercauteren, F.: “Fully homomorphic SIMD operations.” Manuscript at http://eprint.iacr.org/2011/133, 2011.</li>

      <li>[8] Gentry, C., Halevi, S., Smart, N.P.: “Homomorphic evaluation of the AES circuit.” Advances in Cryptology - CRYPTO 2012, 850-8, 2012.</li>

      <li>[9] Brakerski, Z., Gentry, C., Vaikuntanathan, V.: “Fully homomorphic encryption without bootstrapping.” Innovations in Theoretical Computer Science, ITCS 309–325, 2012.</li>

      <li>[10] Alt-López, A., Tromer E., Vaikuntanathan, V.: “On-the-fly multiparty computation on the cloud via multikey fully homomorphic encryption.” In: Proc. of the 44th STOC, pp. 1219-1234. ACM, 2012.</li>

      <li>[11] Stehlé, D., Steinfeld, R.: “Making NTRU as secure as worst-case problems over ideal lattices.” Advances in Cryptology – EUROCRYPT ’11 27–4, 2011.</li>

      <li>[12] Bos, J.W., Lauter, K., Loftus, J., Naehrig, M.: “Improved Security for a Ring-Based Fully Homomorphic Encryption Scheme”. In LNCS PQCrypto 2013. pp. 45–64. Springer, 2013.</li>

      <li>[13] Coron, J.S., Naccache, D., Tibouchi, M.: ”Public key compression and modulus switching for fully homomorphic encryption over the integers.” Advances in Cryptology-EUROCRYPT 2012. Springer Berlin Heidelberg, 2012. 446-464.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[14] Brakerski, Z.: “Fully Homomorphic Encryption without Modulus Switching from Classical GapSVP”. In Advances in Cryptology – CRYPTO 2012, Springer LNCS Volume 7417, 2012, pp 868-886.</li>

      <li>[15] Doröz, Y., Hu, Y., Sunar, B.: “Homomorphic AES Evaluation using NTRU”, IACR ePrint Archive. Technical Report 2014/039 January 2014. URL: http://eprint.iacr.org/2014/039.pdf</li>

      <li>[16] Brakerski, Z., Vaikuntanathan, V.: “Efficient fully homomorphic encryption from (standard) LWE.” Foundations of Computer Science (FOCS), 2011 IEEE 52nd Annual Symposium on. IEEE, 2011.</li>

      <li>[17] Lauter, K., Naehrig, M., Vaikuntanathan, V.: “Can homomorphic encryption be practical?” In: Proceedings of the 3rd ACM CCSW (Cloud Computing Security Workshop) ACM, 2011.</li>

      <li>[18] Bogdanov, A., Knudsen, L.R., Leander, G., Paar, C., Poschmann, A., Robshaw, M.J.B., Seurin, Y., Vikkelsoe, C.: “PRESENT: An Ultra-Lightweight Block Cipher”. Cryptographic Hardware and Embedded Systems - CHES 2007, LNCS vol 4727, 2007, pp 450–466.</li>

      <li>[19] Micciancio, D., Regev, O.: “Worst-case to average-case reductions based on gaussian measures”. SIAM J. Comput., 37(1):267?302, 2007.</li>

      <li>[20] Eisenbarth, T., Gong, Z., Güneysu, T., Heyse, S., Indesteege, S., Kerckhof, S., Koeune, F., Nad, T., Plos, T., Regazzoni, F., Standaert, F.X., Oldeneel tot Oldenzeel, L.: “Compact implementation and performance evaluation of block ciphers in tiny devices”. Progress in Cryptology - AFRICACRYPT 2012, vol 7374 of LNCS, pages 172–187, 2012.</li>

      <li>[21] Borghoff, J., Canteaut, A., Güneysu, T., Kavun, E.B., Knezevic, M., Knudsen, L.R., Leander, G., Nikov, V., Paar, C., Rechberger, C., Rombouts, P., Thomsen, S.S., Yalcin, T.: “Prince – a low-latency block cipher for pervasive computing applications”. In Progress in Cryptology - ASIACRYPT 2012, pages 208–225.</li>

      <li>[22] Eisenbarth, T., Paar, C., Poschmann, A., Kumar, S., Uhsadel, L.: “A Survey of Lightweight-Cryptography Implementations”. In Design & Test of Computers, IEEE , vol.24, no.6, pp.522,533, 2007.</li>

      <li>[23] Daemen, J., Rijmen, V.: The design of Rijndael: AES-the advanced encryption standard. Springer, 2002.</li>

      <li>[24] Hong, D., Sung, J., Hong, S., Lim, J., Lee, S., Koo, B., Lee, C., Chang, D., Lee, J., Jeong, K., Kim, H., Kim, J., Chee, S.: “HIGHT: A New Block Cipher Suitable for Low-Resource Device”. Cryptographic Hardware and Embedded Systems - CHES 2006, vol 4249 of LNCS, pages 46-59. Springer, 2006.</li>

      <li>[25] Standaert, F.X., Piret, G., Gershenfeld, N., Quisquater, J.J.: “SEA: A Scalable Encryption Algorithm for Small Embedded Applications”. CARDIS 2006, vol 3928 of LNCS, pages 222-236. Springer, 2006.</li>

      <li>[26] Canniere, C.D., Dunkelman, O., Knezevic, M.: “KATAN and KTANTAN - A Family of Small and Efficient Hardware-Oriented Block Ciphers”. Cryptographic Hardware and Embedded Systems - CHES 2009, vol 5747 of LNCS, pages 272-288. Springer, 2009.</li>

      <li>[27] Canniere, C.D., Dunkelman, O., Knezevic, M.: “The SIMON and SPECK Families of Lightweight Block Ciphers”. Cryptology ePrint Archive, Report 2013/404, 2013. http://eprint.iacr.org/.</li>

    </ul>`;
---

<BaseLayout title="Toward Practical Homomorphic Evaluation of Block Ciphers Usi... (2014/233)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/233
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
