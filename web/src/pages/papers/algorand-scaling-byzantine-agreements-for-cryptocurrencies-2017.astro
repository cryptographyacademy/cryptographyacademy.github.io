---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/454';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Algorand: Scaling Byzantine Agreements for Cryptocurrencies';
const AUTHORS_HTML = 'Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, Nickolai Zeldovich';

const CONTENT = `    <p class="text-gray-300">Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, Nickolai Zeldovich</p>

    <h2 id="sec-2" class="text-2xl font-bold">ABSTRACT</h2>

    <p class="text-gray-300">Algorand is a new cryptocurrency that confirms transactions with latency on the order of a minute while scaling to many users. Algorand ensures that users never have divergent views of confirmed transactions, even if some of the users are malicious and the network is temporarily partitioned. In contrast, existing cryptocurrencies allow for temporary forks and therefore require a long time, on the order of an hour, to confirm transactions with high confidence.</p>

    <p class="text-gray-300">Algorand uses a new Byzantine Agreement (BA) protocol to reach consensus among users on the next set of transactions. To scale the consensus to many users, Algorand uses a novel mechanism based on Verifiable Random Functions that allows users to privately check whether they are selected to participate in the BA to agree on the next set of transactions, and to include a proof of their selection in their network messages. In Algorand’s BA protocol, users do not keep any private state except for their private keys, which allows Algorand to replace participants immediately after they send a message. This mitigates targeted attacks on chosen participants after their identity is revealed.</p>

    <p class="text-gray-300">We implement Algorand and evaluate its performance on 1,000 EC2 virtual machines, simulating up to 500,000 users. Experimental results show that Algorand confirms transactions in under a minute, achieves 125<span class="math">\\times</span> Bitcoin’s throughput, and incurs almost no penalty for scaling to more users.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1. Introduction</h2>

    <p class="text-gray-300">Cryptographic currencies such as Bitcoin can enable new applications, such as smart contracts <em>(24; 49)</em> and fair protocols <em>(2)</em>, can simplify currency conversions <em>(12)</em>, and can avoid trusted centralized authorities that regulate transactions. However, current proposals suffer from a trade-off between latency and confidence in a transaction. For example, achieving a high confidence that a transaction has been confirmed in Bitcoin requires about an hour long wait <em>(7)</em>. On the other hand, applications that require low latency cannot be certain that their transaction will be confirmed, and must trust the payer to not double-spend <em>(45)</em>.</p>

    <p class="text-gray-300">Double-spending is the core problem faced by any cryptocurrency, where an adversary holding <span class="math">1 gives his </span>1 to two different users. Cryptocurrencies prevent double-spending by reaching consensus on an ordered log (“blockchain”) of transactions. Reaching consensus is difficult because of the open setting: since anyone can participate, an adversary can create an arbitrary number of pseudonyms (“Sybils”) <em>(21)</em>, making it infeasible to rely on traditional consensus protocols <em>(15)</em> that require a fraction of honest users.</p>

    <p class="text-gray-300">Bitcoin <em>(41)</em> and other cryptocurrencies <em>(23; 53)</em> address this problem using proof-of-work (PoW), where users must repeatedly compute hashes to grow the blockchain, and the longest chain is considered authoritative. PoW ensures that an adversary does not gain any advantage by creating pseudonyms. However, PoW allows the possibility of <em>forks</em>, where two different blockchains have the same length, and neither one supersedes the other. Mitigating forks requires two unfortunate sacrifices: the time to grow the chain by one block must be reasonably high (e.g., 10 minutes in Bitcoin), and applications must wait for several blocks in order to ensure their transaction remains on the authoritative chain (6 blocks are recommended in Bitcoin <em>(7)</em>). The result is that it takes about an hour to confirm a transaction in Bitcoin.</p>

    <p class="text-gray-300">This paper presents Algorand, a new cryptocurrency designed to confirm transactions on the order of one minute. The core of Algorand uses a Byzantine agreement protocol called <em>BA<span class="math">\\star</span></em> that scales to many users, which allows Algorand to reach consensus on a new block with low latency and without the possibility of forks. A key technique that makes <em>BA<span class="math">\\star</span></em> suitable for Algorand is the use of verifiable random functions (VRFs) <em>(38)</em> to randomly select users in a private and non-interactive way. <em>BA<span class="math">\\star</span></em> was previously presented at a workshop at a high level <em>(37)</em>, and a technical report by Chen and Micali <em>(16)</em> described an earlier version of Algorand.</p>

    <p class="text-gray-300">Algorand faces three challenges. First, Algorand must avoid Sybil attacks, where an adversary creates many pseudonyms to influence the Byzantine agreement protocol. Second, <em>BA<span class="math">\\star</span></em> must scale to millions of users, which is far higher than the scale at which state-of-the-art Byzantine agreement protocols operate. Finally, Algorand must be resilient to denial-of-service attacks, and continue to operate even if an adversary disconnects some of the users <em>(29; 51)</em>.</p>

    <p class="text-gray-300">Algorand addresses these challenges using several techniques, as follows.</p>

    <p class="text-gray-300">Weighted users. To prevent Sybil attacks, Algorand assigns a weight to each user. <em>BA<span class="math">\\star</span></em> is designed to guarantee consensus as long as a weighted fraction (a constant greater than 2/3) of the users are honest. In Algorand, we weigh users based on the money in their account. Thus, as long as</p>

    <p class="text-gray-300">more than some fraction (over 2/3) of the money is owned by honest users, Algorand can avoid forks and double-spending.</p>

    <p class="text-gray-300">Consensus by committee. BA<span class="math">\\star</span> achieves scalability by choosing a committee—a small set of representatives randomly selected from the total set of users—to run each step of its protocol. All other users observe the protocol messages, which allows them to learn the agreed-upon block. BA<span class="math">\\star</span> chooses committee members randomly among all users based on the users’ weights. This allows Algorand to ensure that a sufficient fraction of committee members are honest. However, relying on a committee creates the possibility of targeted attacks against the chosen committee members.</p>

    <p class="text-gray-300">Cryptographic sortition. To prevent an adversary from targeting committee members, BA<span class="math">\\star</span> selects committee members in a private and non-interactive way. This means that every user in the system can independently determine if they are chosen to be on the committee, by computing a function (a VRF <em>[38]</em>) of their private key and public information from the blockchain. If the function indicates that the user is chosen, it returns a short string that proves this user’s committee membership to other users, which the user can include in his network messages. Since membership selection is non-interactive, an adversary does not know which user to target until that user starts participating in BA<span class="math">\\star</span>.</p>

    <p class="text-gray-300">Participant replacement. Finally, an adversary may target a committee member once that member sends a message in BA<span class="math">\\star</span>. BA<span class="math">\\star</span> mitigates this attack by requiring committee members to speak just once. Thus, once a committee member sends his message (exposing his identity to an adversary), the committee member becomes irrelevant to BA<span class="math">\\star</span>. BA<span class="math">\\star</span> achieves this property by avoiding any private state (except for the user’s private key), which makes all users equally capable of participating, and by electing new committee members for each step of the Byzantine agreement protocol.</p>

    <p class="text-gray-300">We implement a prototype of Algorand and BA<span class="math">\\star</span>, and use it to empirically evaluate Algorand’s performance. Experimental results running on 1,000 Amazon EC2 VMs demonstrate that Algorand can confirm a 1 MByte block of transactions in <span class="math">\\sim</span>22 seconds with 50,000 users, that Algorand’s latency remains nearly constant when scaling to half a million users, that Algorand achieves 125<span class="math">\\times</span> the transaction throughput of Bitcoin, and that Algorand achieves acceptable latency even in the presence of actively malicious users.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2. Related Work</h2>

    <p class="text-gray-300">Proof-of-work. Bitcoin <em>[41]</em>, the predominant cryptocurrency, uses proof-of-work to ensure that everyone agrees on the set of approved transactions; this approach is often called “Nakamoto consensus.” Bitcoin must balance the length of time to compute a new block with the possibility of wasted work <em>[41]</em>, and sets parameters to generate a new block every 10 minutes on average. Nonetheless, due to the possibility of forks, it is widely suggested that users wait for the blockchain to grow by at least six blocks before considering their transaction to be confirmed <em>[7]</em>. This means transactions in Bitcoin take on the order of an hour to be confirmed. Many follow-on cryptocurrencies adopt Bitcoin’s proof-of-work approach and inherit its limitations. The possibility of forks also makes it difficult for new users to bootstrap securely: an adversary that isolates the user’s network can convince the user to use a particular fork of the blockchain <em>[28]</em>.</p>

    <p class="text-gray-300">By relying on Byzantine agreement, Algorand eliminates the possibility of forks, and avoids the need to reason about mining strategies <em>[8, 25, 46]</em>. As a result, transactions are confirmed on the order of a minute. To make the Byzantine agreement robust to Sybil attacks, Algorand associates weights with users according to the money they hold. Other techniques have been proposed in the past to resist Sybil attacks in Byzantine-agreement-based cryptocurrencies, including having participants submit security deposits and punishing those who deviate from the protocol <em>[13]</em>.</p>

    <p class="text-gray-300">Byzantine consensus. Byzantine agreement protocols have been used to replicate a service across a small group of servers, such as in PBFT <em>[15]</em>. Follow-on work has shown how to make Byzantine fault tolerance perform well and scale to dozens of servers <em>[1, 17, 33]</em>. One downside of Byzantine fault tolerance protocols used in this setting is that they require a fixed set of servers to be determined ahead of time; allowing anyone to join the set of servers would open up the protocols to Sybil attacks. These protocols also do not scale to the large number of users targeted by Algorand. BA<span class="math">\\star</span> is a Byzantine consensus protocol that does not rely on a fixed set of servers, which avoids the possibility of targeted attacks on well-known servers. By weighing users according to their currency balance, BA<span class="math">\\star</span> allows users to join the cryptocurrency without risking Sybil attacks, as long as the fraction of the money held by honest users is at least a constant greater than 2/3. BA<span class="math">\\star</span>’s design also allows it to scale to many users (e.g., 500,000 shown in our evaluation) using VRFs to fairly select a random committee.</p>

    <p class="text-gray-300">Most Byzantine consensus protocols require more than 2/3 of servers to be honest, and Algorand’s BA<span class="math">\\star</span> inherits this limitation (in the form of 2/3 of the money being held by honest users). BFT2F <em>[35]</em> shows that it is possible to achieve “fork^{∗}-consensus” with just over half of the servers being honest, but fork^{∗}-consensus would allow an adversary to double-spend on the two forked blockchains, which Algorand avoids.</p>

    <p class="text-gray-300">Honey Badger <em>[39]</em> demonstrated how Byzantine fault tolerance can be used to build a cryptocurrency. Specifically, Honey Badger designates a set of servers to be in charge of reaching consensus on the set of approved transactions. This allows Honey Badger to reach consensus within 5 minutes and achieve a throughput of 200 KBytes/sec of data appended to the ledger using 10 MByte blocks and 104 participating servers. One downside of this design is that the cryptocurrency is no longer decentralized; there are a fixed set of servers chosen when the system is first configured. Fixed servers are also problematic in terms of targeted at</p>

    <p class="text-gray-300">tacks that either compromise the servers or disconnect them from the network. Algorand achieves better performance (confirming transactions in about a minute, reaching similar throughput) without having to choose a fixed set of servers ahead of time.</p>

    <p class="text-gray-300">Bitcoin-NG <em>[26]</em> suggests using the Nakamoto consensus to elect a leader, and then have that leader publish blocks of transactions, resulting in an order of magnitude of improvement in latency of confirming transactions over Bitcoin. Hybrid consensus <em>[30, 32, 42]</em> refines the approach of using the Nakamoto consensus to periodically select a group of participants (e.g., every day), and runs a Byzantine agreement between selected participants to confirm transactions until new servers are selected. This allows improving performance over standard Nakamoto consensus (e.g., Bitcoin); for example, ByzCoin <em>[32]</em> provides a latency of about 35 seconds and a throughput of 230 KBytes/sec of data appended to the ledger with an 8 MByte block size and 1000 participants in the Byzantine agreement. Although Hybrid consensus makes the set of Byzantine servers dynamic, it opens up the possibility of forks, due to the use of proof-of-work consensus to agree on the set of servers; this problem cannot arise in Algorand.</p>

    <p class="text-gray-300">Pass and Shi’s paper <em>[42]</em> acknowledges that the Hybrid consensus design is secure only with respect to a “mildly adaptive” adversary that cannot compromise the selected servers within a day (the participant selection interval), and explicitly calls out the open problem of handling fully adaptive adversaries. Algorand’s BA<span class="math">\\star</span> explicitly addresses this open problem by immediately replacing any chosen committee members. As a result, Algorand is not susceptible to either targeted compromises or targeted DoS attacks.</p>

    <p class="text-gray-300">Stellar <em>[36]</em> takes an alternative approach to using Byzantine consensus in a cryptocurrency, where each user can trust quorums of other users, forming a trust hierarchy. Consistency is ensured as long as all transactions share at least one transitively trusted quorum of users, and sufficiently many of these users are honest. Algorand avoids this assumption, which means that users do not have to make complex trust decisions when configuring their client software.</p>

    <p class="text-gray-300">Proof of stake. Algorand assigns weights to users proportionally to the monetary value they have in the system, inspired by proof-of-stake approaches, suggested as an alternative or enhancement to proof-of-work <em>[3, 10]</em>. There is a key difference, however, between Algorand using monetary value as weights and many proof-of-stake cryptocurrencies. In many proof-of-stake cryptocurrencies, a malicious leader (who assembles a new block) can create a fork in the network, but if caught (e.g., since two versions of the new block are signed with his key), the leader loses his money. The weights in Algorand, however, are only to ensure that the attacker cannot amplify his power by using pseudonyms; as long as the attacker controls less than 1/3 of the monetary value, Algorand can guarantee that the probability for forks is negligible. Algorand may be extended to “detect and punish” malicious users, but this is not required to prevent forks or double spending.</p>

    <p class="text-gray-300">Proof-of-stake avoids the computational overhead of proof-of-work and therefore allows reducing transaction confirmation time. However, realizing proof-of-stake in practice is challenging <em>[4]</em>. Since no work is involved in generating blocks, a malicious leader can announce one block, and then present some other block to isolated users. Attackers may also split their credits among several “users”, who might get selected as leaders, to minimize the penalty when a bad leader is caught. Therefore some proof-of-stake cryptocurrencies require a master key to periodically sign the correct branch of the ledger in order to mitigate forks <em>[31]</em>. This raises significant trust concerns regarding the currency, and has also caused accidental forks in the past <em>[43]</em>. Algorand answers this challenge by avoiding forks, even if the leader turns out to be malicious.</p>

    <p class="text-gray-300">Ouroboros <em>[30]</em> is a recent proposal for realizing proof-of-stake. For security, Ouroboros assumes that honest users can communicate within some bounded delay (i.e., a strongly synchronous network). Furthermore, it selects some users to participate in a joint-coin-flipping protocol and assumes that most of them are incorruptible by the adversary for a significant epoch (such as a day). In contrast Algorand assumes that the adversary may temporarily fully control the network and immediately corrupt users in targeted attacks.</p>

    <p class="text-gray-300">Trees and DAGs instead of chains. GHOST <em>[47]</em>, SPEC-TRE <em>[48]</em>, and Meshcash <em>[5]</em> are recent proposals for increasing Bitcoin’s throughput by replacing the underlying chain-structured ledger with a tree or directed acyclic graph (DAG) structures, and resolving conflicts in the forks of these data structures. These protocols rely on the Nakamoto consensus using proof-of-work. By carefully designing the selection rule between branches of the trees/DAGs, they are able to substantially increase the throughput. In contrast, Algorand is focused on eliminating forks; in future work, it may be interesting to explore whether tree or DAG structures can similarly increase Algorand’s throughput.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3. Goals and Assumptions</h2>

    <p class="text-gray-300">Algorand allows users to agree on an ordered log of transactions, and achieves two goals with respect to the log:</p>

    <p class="text-gray-300">Safety goal. With overwhelming probability, all users agree on the same transactions. More precisely, if one honest user accepts transaction A (i.e., it appears in the log), then any future transactions accepted by other honest users will appear in a log that already contains A. This holds even for isolated users that are disconnected from the network—e.g., by Eclipse attacks <em>[28]</em>.</p>

    <p class="text-gray-300">Liveness goal. In addition to safety, Algorand also makes progress (i.e., allows new transactions to be added to the log) under additional assumptions about network reachability that we describe below. Algorand aims to reach consensus on a new set of transactions within roughly one minute.</p>

    <p class="text-gray-300">Assumptions. Algorand makes standard cryptographic assumptions such as public-key signatures and hash functions. Algorand assumes that honest users run bug-free software. As mentioned earlier, Algorand assumes that the fraction of money held by honest users is above some threshold  <span class="math">h</span>  (a constant greater than  <span class="math">2/3</span> ), but that an adversary can participate in Algorand and own some money. We believe that this assumption is reasonable, since it means that in order to successfully attack Algorand, the attacker must invest substantial financial resources in it. Algorand assumes that an adversary can corrupt targeted users, but that an adversary cannot corrupt a large number of users that hold a significant fraction of the money (i.e., the amount of money held by honest, non-compromised users must remain over the threshold).</p>

    <p class="text-gray-300">To achieve liveness, Algorand makes a "strong synchrony" assumption that most honest users (e.g.,  <span class="math">95\\%</span> ) can send messages that will be received by most other honest users (e.g.,  <span class="math">95\\%</span> ) within a known time bound. This assumption allows the adversary to control the network of a few honest users, but does not allow the adversary to manipulate the network at a large scale, and does not allow network partitions.</p>

    <p class="text-gray-300">Algorand achieves safety with a "weak synchrony" assumption: the network can be asynchronous (i.e., entirely controlled by the adversary) for a long but bounded period of time (e.g., at most 1 day or 1 week). After an asynchrony period, the network must be strongly synchronous for a reasonably long period again (e.g., a few hours or a day) for Algorand to ensure safety. More formally, the weak synchrony assumption is that in every period of length  <span class="math">b</span>  (think of  <span class="math">b</span>  as a day or a week), there must be a strongly synchronous period of length  <span class="math">s &amp;lt; b</span>  (an  <span class="math">s</span>  of a few hours suffices).</p>

    <p class="text-gray-300">Finally, Algorand assumes loosely synchronized clocks across all users (e.g., using NTP) in order to recover liveness after weak synchrony. Specifically, the clocks must be close enough in order for most honest users to kick off the recovery protocol at approximately the same time. If the clocks are out of sync, the recovery protocol does not succeed.</p>

    <p class="text-gray-300">Algorand requires each user to have a public key. Algorand maintains a log of transactions, called a blockchain. Each transaction is a payment signed by one user's public key transferring money to another user's public key. Algorand grows the blockchain in asynchronous rounds, similar to Bitcoin. In every round, a new block, containing a set of transactions and a pointer to the previous block, is appended to the blockchain. In the rest of this paper, we refer to Algorand software running on a user's computer as that user.</p>

    <p class="text-gray-300">Algorand users communicate through a gossip protocol. The gossip protocol is used by users to submit new transactions. Each user collects a block of pending transactions that they hear about, in case they are chosen to propose the next block, as shown in Figure 1. Algorand uses  <span class="math">BA \\star</span>  to reach consensus on one of these pending blocks.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: An overview of transaction flow in Algorand.</p>

    <p class="text-gray-300"><span class="math">BA\\star</span>  executes in steps, communicates over the same gossip protocol, and produces a new agreed-upon block.  <span class="math">BA\\star</span>  can produce two kinds of consensus: final consensus and tentative consensus. If one user reaches final consensus, this means that any other user that reaches final or tentative consensus in the same round must agree on the same block value (regardless of whether the strong synchrony assumption held). This ensures Algorand's safety, since this means that all future transactions will be chained to this final block (and, transitively, to its predecessors). Thus, Algorand confirms a transaction when the transaction's block (or any successor block) reaches final consensus. On the other hand, tentative consensus means that other users may have reached tentative consensus on a different block (as long as no user reached final consensus). A user will confirm a transaction from a tentative block only if and when a successor block reaches final consensus.</p>

    <p class="text-gray-300"><span class="math">BA\\star</span>  produces tentative consensus in two cases. First, if the network is strongly synchronous, an adversary may, with small probability, be able to cause  <span class="math">BA\\star</span>  to reach tentative consensus on a block. In this case,  <span class="math">BA\\star</span>  will not reach consensus on two different blocks, but is simply unable to confirm that the network was strongly synchronous. Algorand will eventually (in a few rounds) reach final consensus on a successor block, with overwhelming probability, and thus confirm these earlier transactions.</p>

    <p class="text-gray-300">The second case is that the network was only weakly synchronous (i.e., it was entirely controlled by the adversary, with an upper bound on how long the adversary can keep control). In this case,  <span class="math">BA \\star</span>  can reach tentative consensus on two different blocks, forming multiple forks. This can in turn prevent  <span class="math">BA \\star</span>  from reaching consensus again, because the users are split into different groups that disagree about previous blocks. To recover liveness, Algorand periodically invokes  <span class="math">BA \\star</span>  to reach consensus on which fork should be used going forward. Once the network regains strong synchrony, this will allow Algorand to choose one of the forks, and then reach final consensus on a subsequent block on that fork.</p>

    <p class="text-gray-300">We now describe how Algorand's components fit together.</p>

    <p class="text-gray-300">Gossip protocol. Algorand implements a gossip network (similar to Bitcoin) where each user selects a small random</p>

    <p class="text-gray-300">set of peers to gossip messages to. To ensure messages cannot be forged, every message is signed by the private key of its original sender; other users check that the signature is valid before relaying it. To avoid forwarding loops, users do not relay the same message twice. Algorand implements gossip over TCP and weighs peer selection based on how much money they have, so as to mitigate pollution attacks.</p>

    <p class="text-gray-300">Block proposal (§6). All Algorand users execute cryptographic sortition to determine if they are selected to propose a block in a given round. We describe sortition in §5, but at a high level, sortition ensures that a small fraction of users are selected at random, weighed by their account balance, and provides each selected user with a priority, which can be compared between users, and a proof of the chosen user's priority. Since sortition is random, there may be multiple users selected to propose a block, and the priority determines which block everyone should adopt. Selected users distribute their block of pending transactions through the gossip protocol, together with their priority and proof. To ensure that users converge on one block with high probability, block proposals are prioritized based on the proposing user's priority, and users wait for a certain amount of time to receive the block.</p>

    <p class="text-gray-300">Agreement using  <span class="math">BA \\star (\\S 7)</span> . Block proposal does not guarantee that all users received the same block, and Algorand does not rely on the block proposal protocol for safety. To reach consensus on a single block, Algorand uses  <span class="math">BA \\star</span> . Each user initializes  <span class="math">BA \\star</span>  with the highest-priority block that they received.  <span class="math">BA \\star</span>  executes in repeated steps, illustrated in Figure 2. Each step begins with sortition (§5), where all users check whether they have been selected as committee members in that step. Committee members then broadcast a message which includes their proof of selection. These steps repeat until, in some step of  <span class="math">BA \\star</span> , enough users in the committee reach consensus. (Steps are not synchronized across users; each user checks for selection as soon as he observes the previous step had ended.) As discussed earlier, an important feature of  <span class="math">BA \\star</span>  is that committee members do not keep private state except their private keys, and so can be replaced after every step, to mitigate targeted attacks on them.</p>

    <p class="text-gray-300">Efficiency. When the network is strongly synchronous,  <span class="math">BA \\star</span>  guarantees that if all honest users start with the same initial block (i.e., the highest priority block proposer was honest), then  <span class="math">BA \\star</span>  establishes final consensus over that block and terminates precisely in 4 interactive steps between users. Under the same network conditions, and in the worst case of a particularly lucky adversary, all honest users reach consensus on the next block within expected 13 steps, as analyzed in Appendix C.</p>

    <p class="text-gray-300">Cryptographic sortition is an algorithm for choosing a random subset of users according to per-user weights; that is, given a set of weights  <span class="math">w_{i}</span>  and the weight of all users</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: An overview of one step of  <span class="math">BA\\star</span> . To simplify the figure, each user is shown twice: once at the top of the diagram and once at the bottom. Each arrow color indicates a message from a particular user.</p>

    <p class="text-gray-300"><span class="math">W = \\sum_{i} w_{i}</span> , the probability that user  <span class="math">i</span>  is selected is proportional to  <span class="math">w_{i} / W</span> . The randomness in the sortition algorithm comes from a publicly known random seed; we describe later how this seed is chosen. To allow a user to prove that they were chosen, sortition requires each user  <span class="math">i</span>  to have a public/private key pair,  <span class="math">(pk_{i}, sk_{i})</span> .</p>

    <p class="text-gray-300">Sortition is implemented using verifiable random functions (VRFs) [38]. Informally, on any input string  <span class="math">x</span> ,  <span class="math">VRF_{sk}(x)</span>  returns two values: a hash and a proof. The hash is a hashlen-bit-long value that is uniquely determined by  <span class="math">sk</span>  and  <span class="math">x</span> , but is indistinguishable from random to anyone that does not know  <span class="math">sk</span> . The proof  <span class="math">\\pi</span>  enables anyone that knows  <span class="math">pk</span>  to check that the hash indeed corresponds to  <span class="math">x</span> , without having to know  <span class="math">sk</span> . For security, we require that the VRF provides these properties even if  <span class="math">pk</span>  and  <span class="math">sk</span>  are chosen by an attacker.</p>

    <p class="text-gray-300">Using VRFs, Algorand implements cryptographic sortition as shown in Algorithm 1. Sortition requires a role parameter that distinguishes the different roles that a user may be selected for; for example, the user may be selected to propose a block in some round, or they may be selected to be the member of the committee at a certain step of  <span class="math">BA\\star</span> . Algorand specifies a threshold  <span class="math">\\tau</span>  that determines the expected number of users selected for that role.</p>

    <pre><code class="language-latex">procedure Sortition  $(sk,seed,\\tau ,role,w,W)$  ..
$\\langle \\text{hash},\\pi \\rangle \\leftarrow \\mathrm{VRF}_{sk}(\\text{seed})|$  role)
$p\\gets \\frac{\\tau}{W}$ $j\\gets 0$
while  $\\frac{\\text{hash}}{2^{\\text{hashkn}}}\\notin \\left[\\sum_{k = 0}^{j}B(k;w,p),\\sum_{k = 0}^{j + 1}B(k;w,p)\\right)$  do
$\\lfloor j^{e + }$
return  $\\langle \\text{hash},\\pi ,j\\rangle$</code></pre>

    <p class="text-gray-300">Algorithm 1: The cryptographic sortition algorithm.</p>

    <p class="text-gray-300">It is important that sortition selects users in proportion to their weight; otherwise, sortition would not defend against Sybil attacks. One subtle implication is that users may be chosen more than once by sortition (e.g., because they have</p>

    <p class="text-gray-300">a high weight). Sortition addresses this by returning the <span class="math">j</span> parameter, which indicates how many times the user was chosen. Being chosen <span class="math">j</span> times means that the user gets to participate as <span class="math">j</span> different “sub-users.”</p>

    <p class="text-gray-300">To select users in proportion to their money, we consider each unit of Algorand as a different “sub-user.” If user <span class="math">i</span> owns <span class="math">w_{i}</span> (integral) units of Algorand, then simulated user <span class="math">(i,j)</span> with <span class="math">j\\in\\{1,\\ldots,w_{i}\\}</span> represents the <span class="math">j^{th}</span> unit of currency <span class="math">i</span> owns, and is selected with probability <span class="math">p=\\frac{\\tau}{W}</span>, where <span class="math">W</span> is the total amount of currency units in Algorand.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As shown in Algorithm 1, a user performs sortition by computing $\\langle hash,\\pi\\rangle\\leftarrow VRF_{sk}(seed</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">role)<span class="math">, where </span>sk<span class="math"> is the user’s secret key. The pseudo-random </span>hash<span class="math"> determines how many sub-users are selected, as follows. The probability that exactly </span>k<span class="math"> out of the </span>w<span class="math"> (the user’s weight) sub-users are selected follows the binomial distribution, </span>B(k;w,p)=\\binom{w}{k}p^{k}(1-p)^{w-k}<span class="math">, where </span>\\sum_{k=0}^{w}B(k;w,p)=1<span class="math">. Since </span>B(k_{1};n_{1},p)+B(k_{2};n_{2},p)=B(k_{1}+k_{2};n_{1}+n_{2},p)$, splitting a user’s weight (currency) among Sybils does not affect the number of selected sub-users under his/her control.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To determine how many of a user’s <span class="math">w</span> sub-users are selected, the sortition algorithm divides the interval <span class="math">[0,1)</span> into consecutive intervals of the form <span class="math">I^{j}=\\left\\{\\sum_{k=0}^{j}B(k;w,p),\\sum_{k=0}^{j+1}B(k;w,p)\\right)</span> for <span class="math">j\\in\\{0,1,\\ldots,w\\}</span>. If <span class="math">hash/2^{hashlen}</span> (where <span class="math">hashlen</span> is the bit-length of <span class="math">hash</span>) falls in the interval <span class="math">I^{j}</span>, then the user has exactly <span class="math">j</span> selected sub-users. The number of selected sub-users is publicly verifiable using the proof <span class="math">\\pi</span> (from the VRF output).</p>

    <p class="text-gray-300">Sortition provides two important properties. First, given a random seed, the VRF outputs a pseudo-random hash value, which is essentially uniformly distributed between <span class="math">0</span> and <span class="math">2^{hashlen}-1</span>. As a result, users are selected at random based on their weights. Second, an adversary that does not know <span class="math">sk_{i}</span> cannot guess how many times user <span class="math">i</span> is chosen, or if <span class="math">i</span> was chosen at all (more precisely, the adversary cannot guess any better than just by randomly guessing based on the weights).</p>

    <p class="text-gray-300">The pseudocode for verifying a sortition proof, shown in Algorithm 2, follows the same structure to check if that user was selected (the weight of the user’s public key is obtained from the ledger). The function returns the number of selected sub-users (or zero if the user was not selected at all).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">procedure VerifySort(<span class="math">pk,hash,\\pi,seed,\\tau,role,w,W</span>): if $\\neg VerifyVRF_{pk}(hash,\\pi,seed</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">role)<span class="math"> then return </span>0<span class="math">; </span>p\\leftarrow\\frac{\\tau}{W}<span class="math"> </span>j\\leftarrow 0<span class="math"> while </span>\\frac{hash}{2^{hashlen}}\\notin\\left\\{\\sum_{k=0}^{j}B(k;w,p),\\sum_{k=0}^{j+1}B(k;w,p)\\right)<span class="math"> do </span>\\lfloor\\ \\ j_{++}<span class="math"> return </span>j$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 2 Pseudocode for verifying sortition of a user with public key <span class="math">pk</span>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">5.2. Choosing the seed</h3>

    <p class="text-gray-300">Sortition requires a seed that is chosen at random and publicly known. For Algorand, each round requires a seed that is publicly known by everyone for that round, but cannot be controlled by the adversary; otherwise, an adversary may be able to choose a seed that favors selection of corrupted users.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In each round of Algorand a new seed is published. The seed published at Algorand’s round <span class="math">r</span> is determined using VRFs with the seed of the previous round <span class="math">r-1</span>. More specifically, during the block proposal stage of round <span class="math">r-1</span>, every user <span class="math">u</span> selected for block proposal also computes a proposed seed for round <span class="math">r</span> as $\\langle seed_{r},\\pi\\rangle\\leftarrow\\text{VRF}_{sk_{u}}(seed_{r-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)<span class="math">. Algorand requires that </span>sk_{u}<span class="math"> be chosen by </span>u<span class="math"> well in advance of the seed for that round being determined (§5.3). This ensures that even if </span>u<span class="math"> is malicious, the resulting </span>seed_{r}$ is pseudo-random.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This seed (and the corresponding VRF proof <span class="math">\\pi</span>) is included in every proposed block, so that once Algorand reaches agreement on the block for round <span class="math">r-1</span>, everyone knows <span class="math">seed_{r}</span> at the start of round <span class="math">r</span>. If the block does not contain a valid seed (e.g., because the block was proposed by a malicious user and included invalid transactions), users treat the entire proposed block as if it were empty, and use a cryptographic hash function <span class="math">H</span> (which we assume is a random oracle) to compute the associated seed for round <span class="math">r</span> as $seed_{r}=H(seed_{r-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)<span class="math">. The value of </span>seed_{0}$, which bootstraps seed selection, can be chosen at random at the start of Algorand by the initial participants (after their public keys are declared) using distributed random number generation <em>(14)</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To limit the adversary’s ability to manipulate sortition, and thus manipulate the selection of users for different committees, the selection seed (passed to Algorithm 1 and Algorithm 2) is refreshed once every <span class="math">R</span> rounds. Namely, at round <span class="math">r</span> Algorand calls the sortition functions with <span class="math">seed_{r-1-(r\\bmod R)}</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">5.3. Choosing <span class="math">sk_{u}</span> well in advance of the seed</h3>

    <p class="text-gray-300">Computing <span class="math">seed_{r}</span> requires that every user’s secret key <span class="math">sk_{u}</span> is chosen well in advance of the selection seed used in that round, i.e., <span class="math">seed_{r-1-(r\\bmod R)}</span>. When the network is not strongly synchronous, the attacker has complete control over the links, and can therefore drop block proposals and force users to agree on empty blocks, such that future selection seeds can be computed. To mitigate such attacks Algorand relies on the weak synchrony assumption (in every period of length <span class="math">b</span>, there must be a strongly synchronous period of length <span class="math">s&lt;b</span>). Whenever Algorand performs cryptographic sortition for round <span class="math">r</span>, it checks the timestamp included in the agreed-upon block for round <span class="math">r-1-(r\\bmod R)</span>, and uses the keys (and associated weights) from the last block that was created <span class="math">b</span>-time before block <span class="math">r-1-(r\\bmod R)</span>. The lower bound <span class="math">s</span> on the length of a strongly synchronous period should allow for sufficiently many blocks to be created in order to ensure with overwhelming probability that at least one block was honest. This ensures that, as long as <span class="math">s</span> is suitably large, an adversary <span class="math">u</span> choosing a key <span class="math">sk_{u}</span> cannot predict the seed for round <span class="math">r</span>.</p>

    <p class="text-gray-300">This look-back period <span class="math">b</span> has the following trade-off: a large <span class="math">b</span> mitigates the risk that attackers are able break the weak synchronicity assumption, yet it increases the chance that users have transferred their currency to someone else and therefore have nothing to lose if the system’s security breaks. This is colloquially known as the “nothing at stake” problem; one possible way to avoid this trade-off, which we do not explore in Algorand, is to take the minimum of a user’s current balance and the user’s balance from the look-back block as the user’s weight.</p>

    <p class="text-gray-300">Appendix A formally analyzes the number of blocks that Algorand needs to be created in the period <span class="math">s</span> when the network is strongly connected. We show that to ensure a small probability of failure <span class="math">F</span>, the number of blocks is logarithmic in <span class="math">\\frac{1}{F}</span>, which allows us to obtain high security with a reasonably low number of required blocks.</p>

    <h2 id="sec-11" class="text-2xl font-bold">6. Block proposal</h2>

    <p class="text-gray-300">To ensure that some block is proposed in each round, Algorand sets the sortition threshold for the block-proposal role, <span class="math">\\tau_{\\textsc{proposer}}</span>, to be greater than 1 (although Algorand will reach consensus on at most one of these proposed blocks). Appendix B proves that choosing <span class="math">\\tau_{\\textsc{proposer}}=26</span> ensures that a reasonable number of proposers (at least one, and no more than 70, as a plausible upper bound) are chosen with very high probability (e.g., <span class="math">1-10^{-11}</span>).</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">Minimizing unnecessary block transmissions</h3>

    <p class="text-gray-300">One risk of choosing several proposers is that each will gossip their own proposed block. For a large block (say, 1 MByte), this can incur a significant communication cost. To reduce this cost, the sortition hash is used to prioritize block proposals: For each selected sub-user <span class="math">1,\\ldots,j</span> of user <span class="math">i</span>, the priority for the block proposal is obtained by hashing the (verifiably random) hash output of VRF concatenated with the sub-user index. The highest priority of all the block proposer’s selected sub-users is the priority of the block.</p>

    <p class="text-gray-300">Algorand users discard messages about blocks that do not have the highest priority seen by that user so far. Algorand also gossips two kinds of messages: one contains just the priorities and proofs of the chosen block proposers (from sortition), and the other contains the entire block, which also includes the proposer’s sortition hash, and proof. The first kind of message is small (about 200 Bytes), and propagates quickly through the gossip network. These messages enable most users to learn who is the highest priority proposer, and thus quickly discard other proposed blocks.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">Waiting for block proposals</h3>

    <p class="text-gray-300">Each user must wait a certain amount of time to receive block proposals via the gossip protocol. Choosing this time interval does not impact Algorand’s safety guarantees but is important for performance. Waiting a short amount of time will mean no received proposals. If the user receives no block proposals, he or she initializes <span class="math">BA\\star</span> with the empty block, and if many users do so, Algorand will reach consensus on an empty block. On the other hand, waiting too long will receive all block proposals but also unnecessarily increase the confirmation latency.</p>

    <p class="text-gray-300">To determine the appropriate amount of time to wait for block proposals, we consider the plausible scenarios that a user might find themselves in. When a user starts waiting for block proposals for round <span class="math">r</span>, they may be one of the first users to reach consensus in round <span class="math">r-1</span>. Since that user completed round <span class="math">r-1</span>, sufficiently many users sent a message for the last step of <span class="math">BA\\star</span> in that round, and therefore, most of the network is at most one step behind this user. Thus, the user must somehow wait for others to finish the last step of <span class="math">BA\\star</span> from round <span class="math">r-1</span>. At this point, some proposer in round <span class="math">r</span> that happens to have the highest priority will gossip their priority and proof message, and the user must somehow wait to receive that message. Then, the user can simply wait until they receive the block corresponding to the highest priority proof (with a timeout <span class="math">\\lambda_{\\textsc{block}}</span>, on the order of a minute, after which the user will fall back to the empty block).</p>

    <p class="text-gray-300">It is impossible for a user to wait exactly the correct amount for the first two steps of the above scenario. Thus, Algorand estimates these quantities (<span class="math">\\lambda_{\\textsc{stepvar}}</span>, the variance in how long it takes different users to finish the last step of <span class="math">BA\\star</span>, and <span class="math">\\lambda_{\\textsc{priority}}</span>, the time taken to gossip the priority and proof message), and waits for <span class="math">\\lambda_{\\textsc{stepvar}}+\\lambda_{\\textsc{priority}}</span> time to identify the highest priority. §10 experimentally shows that these parameters are, conservatively, 5 seconds each. As mentioned above, Algorand would remain safe even if these estimates were inaccurate.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">Malicious proposers</h3>

    <p class="text-gray-300">Even if some block proposers are malicious, the worst-case scenario is that they trick different Algorand users into initializing <span class="math">BA\\star</span> with different blocks. This could in turn cause Algorand to reach consensus on an empty block, and possibly take additional steps in doing so. However, it turns out that even this scenario is relatively unlikely. In particular, if the adversary is not the highest priority proposer in a round, then the highest priority proposer will gossip a consistent version of their block to all users. If the adversary is the highest priority proposer in a round, they can propose the empty block, and thus prevent any real transactions from being confirmed. However, this happens with probability of at most <span class="math">1-h</span>, by Algorand’s assumption that at least <span class="math">h&gt;2/3</span> of the weighted user are honest.</p>

    <h2 id="sec-15" class="text-2xl font-bold">7. BA<span class="math">\\star</span></h2>

    <p class="text-gray-300">The execution of <span class="math">BA\\star</span> consists of two phases. In the first phase, <span class="math">BA\\star</span> reduces the problem of agreeing on a block to agreement on one of two options. In the second phase, <span class="math">BA\\star</span> reaches agreement on one of these options: either agreeing on a proposed block, or agreeing on an empty block.</p>

    <p class="text-gray-300">Each phase consists of several interactive steps; the first phase always takes two steps, and the second phase takes two steps if the highest-priority block proposer was honest (sent the same block to all users), and as we show in our analysis an expected 11 steps in the worst case of a malicious</p>

    <p class="text-gray-300">highest-priority proposer colluding with a large fraction of committee participants at every step.</p>

    <p class="text-gray-300">In each step, every committee member casts a vote for some value, and all users count the votes. Users that receive more than a threshold of votes for some value will vote for that value in the next step (if selected as a committee member). If the users do not receive enough votes for any value, they time out, and their choice of vote for the next step is determined by the step number.</p>

    <p class="text-gray-300">In the common case, when the network is strongly synchronous and the highest-priority block proposer was honest, <span class="math">BA\\star</span> reaches <em>final</em> consensus by using its final step to confirm that there cannot be any other agreed-upon block in the same round. Otherwise, <span class="math">BA\\star</span> may declare <em>tentative</em> consensus if it cannot confirm the absence of other blocks due to possible network asynchrony.</p>

    <p class="text-gray-300">A key aspect of <span class="math">BA\\star</span>’s design is that it keeps no secrets, except for user private keys. This allows any user observing the messages to “passively participate” in the protocol: verify signatures, count votes, and reach the agreement decision.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">7.1. Main procedure of <span class="math">BA\\star</span></h3>

    <p class="text-gray-300">The top-level procedure implementing <span class="math">BA\\star</span>, as invoked by Algorand, is shown in Algorithm 3. The procedure takes a context <em>ctx</em>, which captures the current state of the ledger, a <em>round</em> number, and a new proposed <em>block</em>, from the highest-priority block proposer (§6). Algorand is responsible for ensuring that the block is valid (by checking the proposed block’s contents and using an empty block if it is invalid, as described in §8). The context consists of the seed for sortition, the user weights, and the last agreed-upon block.</p>

    <p class="text-gray-300">For efficiency, <span class="math">BA\\star</span> votes for hashes of blocks, instead of entire block contents. At the end of the <span class="math">BA\\star</span> algorithm, we use the BlockOfHash() function to indicate that, if <span class="math">BA\\star</span> has not yet received the pre-image of the agreed-upon hash, it must obtain it from other users (and, since the block was agreed upon, many of the honest users must have received it during block proposal).</p>

    <p class="text-gray-300">The <span class="math">BA\\star</span> algorithm also determines whether it established final or tentative consensus. We will discuss this check in detail when we discuss Algorithm 8.</p>

    <p class="text-gray-300">⬇ procedure <span class="math">BA\\star(ctx,round,block)</span>:</p>

    <p class="text-gray-300">hblock <span class="math">\\leftarrow</span> Reduction(ctx,round,H(block)) hblock_{⋆} <span class="math">\\leftarrow</span> Binary<span class="math">BA\\star(ctx,round,hblock)</span> // Check if we reached “final” or “tentative” consensus <span class="math">r\\leftarrow</span> CountVotes(ctx,round,final,T_{final},<span class="math">\\tau_{final}</span>,<span class="math">\\lambda_{STEP}</span>) if <span class="math">hblock_{⋆}=r</span> then return <span class="math">\\langle</span>final,BlockOfHash(<span class="math">hblock_{⋆}</span>)<span class="math">\\rangle</span> else return <span class="math">\\langle</span>tentative,BlockOfHash(<span class="math">hblock_{⋆}</span>)<span class="math">\\rangle</span></p>

    <p class="text-gray-300">Algorithm 3 Running <span class="math">BA\\star</span> for the next round, with a proposed block. H is a cryptographic hash function.</p>

    <p class="text-gray-300">⬇ procedure CommitteeVote(ctx,round,step,<span class="math">\\tau</span>,value):</p>

    <p class="text-gray-300">// check if user is in committee using Sortition (Alg. 1) <span class="math">role\\leftarrow\\langle</span>“committee”,round,step\\rangle<span class="math"> </span>\\langle<span class="math">sorthash,</span>\\pi<span class="math">,</span>j\\rangle\\leftarrow<span class="math"> Sortition(user.sk,ctx.seed,</span>\\tau<span class="math">,role, ctx.weight[user.pk],ctx.W) // only committee members originate a message if </span>j>0<span class="math"> then Gossip(</span>\\langle<span class="math">user.pk,Signed_{user.sk}(round,step, sorthash,</span>\\pi<span class="math">,H(ctx.last_block),value)</span>\\rangle$)</p>

    <p class="text-gray-300">Algorithm 4 Voting for value by committee members. <span class="math">user.sk</span> and <span class="math">user.pk</span> are the user’s private and public keys.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">7.2. Voting</h3>

    <p class="text-gray-300">Sending votes (Algorithm 4). Algorithm 4 shows the pseudocode for CommitteeVote(), which checks if the user is selected for the committee in a given round and step of <span class="math">BA\\star</span>. The CommitteeVote() procedure invokes Sortition() from Algorithm 1 to check if the user is chosen to participate in the committee. If the user is chosen for this step, the user gossips a signed message containing the value passed to CommitteeVote(), which is typically the hash of some block. To bind the vote to the context, the signed message includes the hash of the previous block.</p>

    <p class="text-gray-300">Counting votes (Algorithm 5 and Algorithm 6). The CountVotes() procedure (Algorithm 5) reads messages that belong to the current round and step from the incomingMsgs buffer. (For simplicity, our pseudocode assumes that a background procedure takes incoming votes and stores them into that buffer, indexed by the messages’ round and step.) It processes the votes by calling the ProcessMsg() procedure for every message (Algorithm 6), which ensures that the vote is valid. Note that no private state is required to process these messages.</p>

    <p class="text-gray-300">ProcessMsg() returns not just the value contained in the message, but also the number of votes associated with that value. If the message was not from a chosen committee member, ProcessMsg() returns zero votes. If the committee member was chosen several times (see §5), the number of votes returned by ProcessMsg() reflects that as well. ProcessMsg() also returns the sortition hash, which we will use later in Algorithm 9.</p>

    <p class="text-gray-300">As soon as one value has more than <span class="math">T\\cdot\\tau</span> votes, CountVotes() returns that value. <span class="math">\\tau</span> is the expected number of users that Sortition() selects for the committee, and is the same for each step (<span class="math">\\tau_{\\textsc{step}}</span>) with the exception of the final step (<span class="math">\\tau_{\\textsc{final}}</span>). <span class="math">T</span> is a fraction of that expected committee size (<span class="math">T&gt;\\frac{2}{3}</span>) that defines <span class="math">BA\\star</span>’s voting threshold; this is also the same for every step except the final step, and we analyze it in §7.5. If not enough messages were received within the allocated <span class="math">\\lambda</span> time window, then CountVotes() produces timeout. The threshold ensures that if one honest user’s CountVotes() returns a particular value, then all other honest users will return either the same value or timeout, even under the weak synchrony assumption (see Lemma 1 in Appendix C.2).</p>

    <p class="text-gray-300">procedure CountVotes(ctx, round, step,  <span class="math">T,\\tau ,\\lambda</span>  . start  <span class="math">\\leftarrow</span>  Time() counts  <span class="math">\\leftarrow \\{\\}</span>  // hash table, new keys mapped to 0 voters  <span class="math">\\leftarrow \\{\\}</span>  msgs  <span class="math">\\leftarrow</span>  incomingMsgs[round, step].iterator() while TRUE do m  <span class="math">\\leftarrow</span>  msgs.next() if  <span class="math">m = \\bot</span>  then if Time()  <span class="math">&amp;gt;</span>  start  <span class="math">+\\lambda</span>  then return TIMEOUT; else  <span class="math">\\langle</span>  votes, value, sorthash  <span class="math">\\rangle \\leftarrow</span>  ProcessMsg(ctx,  <span class="math">\\tau ,m</span>  ) if pk  <span class="math">\\in</span>  voters or votes  <span class="math">= 0</span>  then continue; voters  <span class="math">\\cup = \\{pk\\}</span>  counts[value]  <span class="math">+ =</span>  votes // if we got enough votes, then output this value if counts[value]  <span class="math">&amp;gt;T\\cdot \\tau</span>  then return value</p>

    <p class="text-gray-300">Algorithm 5: Counting votes for round and step.</p>

    <p class="text-gray-300">procedure ProcessMsg(ctx,  <span class="math">\\tau ,m</span>  .  <span class="math">\\langle pk, signed\\_ m\\rangle \\leftarrow m</span>  if VerifySignature(pk, signed_m)  <span class="math">\\neq</span>  OK then return  <span class="math">\\langle 0,\\bot ,\\bot \\rangle</span> <span class="math">\\langle round, step, sorthash, \\pi, hprev, value\\rangle \\leftarrow signed\\_ m</span>  // discard messages that do not extend this chain if hprev  <span class="math">\\neq H(ctx.last_block)</span>  then return  <span class="math">\\langle 0,\\bot ,\\bot \\rangle</span>  votes  <span class="math">\\leftarrow</span>  VerifySort(pk, sorthash,  <span class="math">\\pi ,ctx.seed,\\tau</span> <span class="math">\\langle &quot;committee&quot;, round, step\\rangle ,ctx.weight[pk],ctx.W)</span>  return  <span class="math">\\langle</span>  votes, value, sorthash</p>

    <p class="text-gray-300">Algorithm 6: Validating incoming vote message  <span class="math">m</span> .</p>

    <p class="text-gray-300">The Reduction() procedure, shown in Algorithm 7, converts the problem of reaching consensus on an arbitrary value (the hash of a block) to reaching consensus on one of two values: either a specific proposed block hash, or the hash of an empty block. Our reduction is inspired by Turpin and Coan's two-step technique [50]. This reduction is important to ensure liveness.</p>

    <p class="text-gray-300">In the first step of the reduction, each committee member votes for the hash of the block passed to Reduction() by  <span class="math">BA \\star()</span> . In the second step, committee members vote for the hash that received at least  <span class="math">T \\cdot \\tau</span>  votes in the first step, or the hash of the default empty block if no hash received enough votes. Reduction() ensures that there is at most one non-empty block that can be returned by Reduction() for all honest users.</p>

    <p class="text-gray-300">In the common case when the network is strongly synchronous and the highest-priority block proposer was honest, most (e.g.,  <span class="math">95\\%</span> ) of the users will call Reduction() with the same hblock parameter, and Reduction() will return that same hblock result to most users as well.</p>

    <p class="text-gray-300">procedure Reduction(ctx, round, hblock):</p>

    <p class="text-gray-300">// step 1: gossip the block hash CommitteeVote(ctx, round, REDUCTION_ONE,  <span class="math">\\tau_{\\mathrm{STEP}}</span> , hblock) // other users might still be waiting for block proposals, // so set timeout for  <span class="math">\\lambda_{\\mathrm{BLOCK}} + \\lambda_{\\mathrm{STEP}}</span> hblock1  <span class="math">\\leftarrow</span>  CountVotes(ctx, round, REDUCTION_ONE,  <span class="math">T_{\\mathrm{STEP}}, \\tau_{\\mathrm{STEP}}, \\lambda_{\\mathrm{BLOCK}} + \\lambda_{\\mathrm{STEP}}</span> ) // step 2: re-gossip the popular block hash empty_hash  <span class="math">\\leftarrow</span>  H(Empty(round, H(ctx.last_block))) if hblock1 = TIMEOUT then CommitteeVote(ctx, round, REDUCTION_TWO,  <span class="math">\\tau_{\\mathrm{STEP}}</span> , empty_hash) else CommitteeVote(ctx, round, REDUCTION_TWO,  <span class="math">\\tau_{\\mathrm{STEP}}</span> , hblock1) hblock2  <span class="math">\\leftarrow</span>  CountVotes(ctx, round, REDUCTION_TWO,  <span class="math">T_{\\mathrm{STEP}}, \\tau_{\\mathrm{STEP}}, \\lambda_{\\mathrm{STEP}}</span> ) if hblock2 = TIMEOUT then return empty_hash; else return hblock2;</p>

    <p class="text-gray-300">On the other hand, if the highest-priority block proposer was dishonest, different users may start Reduction() with different hblock parameters. In this case, no single hblock value may be popular enough to cross the threshold of votes. As a result, Reduction() will return empty_hash.</p>

    <p class="text-gray-300">Algorithm 8 shows Binary  <span class="math">BA \\star()</span> , which reaches consensus on one of two values: either the hash passed to Binary  <span class="math">BA \\star()</span>  or the hash of the empty block. Binary  <span class="math">BA \\star()</span>  relies on Reduction() to ensure that at most one non-empty block hash is passed to Binary  <span class="math">BA \\star()</span>  by all honest users.</p>

    <p class="text-gray-300">Safety with strong synchrony. In each step of Binary  <span class="math">BA \\star()</span> , a user who has seen more than  <span class="math">T \\cdot \\tau</span>  votes for some value will vote for that same value in the next step (if selected). However, if no value receives enough votes, Binary  <span class="math">BA \\star()</span>  chooses the next vote in a way that ensures consensus in a strongly synchronous network.</p>

    <p class="text-gray-300">Specifically, user  <span class="math">A</span>  may receive votes from an adversary that push the votes observed by  <span class="math">A</span>  past the threshold, but the adversary might not send the same votes to other users (or might not send them in time). As a result,  <span class="math">A</span>  returns consensus on a block, but other users timed out in that step. It is crucial that Binary  <span class="math">BA \\star()</span>  chooses the votes for the next step in a way that will match the block already returned by  <span class="math">A</span> . Algorithm 8 follows this rule: every return statement is coupled with a check for TIMEOUT that sets the next-step vote to the same value that could have been returned.</p>

    <p class="text-gray-300">It is also crucial that Binary  <span class="math">BA \\star()</span>  is able to collect enough votes in the next step to carry forward the value that  <span class="math">A</span>  already reached consensus on. If there are many users like  <span class="math">A</span>  that have already returned consensus, Binary  <span class="math">BA \\star()</span>  may</p>

    <p class="text-gray-300">procedure BinaryBA<span class="math">\\star</span>(ctx, round, block_hash): step <span class="math">\\leftarrow</span> 1 <span class="math">r\\leftarrow</span> block_hash empty_hash <span class="math">\\leftarrow</span> H(Empty(round,H(ctx.last_block))) while step <span class="math">&lt;</span> MAXSTEPS do CommitteeVote(ctx, round, step, <span class="math">\\tau_{\\text{STEP}}</span>, r) <span class="math">r\\leftarrow</span> CountVotes(ctx, round, step, <span class="math">T_{\\text{STEP}}</span>, <span class="math">\\tau_{\\text{STEP}}</span>, <span class="math">\\lambda_{\\text{STEP}}</span>) if <span class="math">r</span> = TIMEOUT then <span class="math">\\lfloor</span> <span class="math">r\\leftarrow</span> block_hash else if <span class="math">r\\neq</span> empty_hash then for step <span class="math">&lt;</span> <span class="math">s^{\\prime}\\leq</span> step + 3 do <span class="math">\\lfloor</span> CommitteeVote(ctx, round, <span class="math">s^{\\prime}</span>, <span class="math">\\tau_{\\text{STEP}}</span>, r) if step = 1 then <span class="math">\\lfloor</span> CommitteeVote(ctx, round, FINAL, <span class="math">\\tau_{\\text{FINAL}}</span>, r) <span class="math">\\lfloor</span> return r step++ CommitteeVote(ctx, round, step, <span class="math">\\tau_{\\text{STEP}}</span>, r) <span class="math">r\\leftarrow</span> CountVotes(ctx, round, step, <span class="math">T_{\\text{STEP}}</span>, <span class="math">\\tau_{\\text{STEP}}</span>, <span class="math">\\lambda_{\\text{STEP}}</span>) if <span class="math">r</span> = TIMEOUT then <span class="math">\\lfloor</span> <span class="math">r\\leftarrow</span> empty_hash else if <span class="math">r</span> = empty_hash then for step <span class="math">&lt;</span> <span class="math">s^{\\prime}\\leq</span> step + 3 do <span class="math">\\lfloor</span> CommitteeVote(ctx, round, <span class="math">s^{\\prime}</span>, <span class="math">\\tau_{\\text{STEP}}</span>, r) <span class="math">\\lfloor</span> return r step++ CommitteeVote(ctx, round, step, <span class="math">\\tau_{\\text{STEP}}</span>, r) <span class="math">r\\leftarrow</span> CountVotes(ctx, round, step, <span class="math">T_{\\text{STEP}}</span>, <span class="math">\\tau_{\\text{STEP}}</span>, <span class="math">\\lambda_{\\text{STEP}}</span>) if <span class="math">r</span> = TIMEOUT then if CommonCoin(ctx, round, step, <span class="math">\\tau_{\\text{STEP}}</span>) = 0 then <span class="math">\\lfloor</span> <span class="math">r\\leftarrow</span> block_hash else <span class="math">\\lfloor</span> <span class="math">r\\leftarrow</span> empty_hash step++</p>

    <p class="text-gray-300">// No consensus after MAXSTEPS; assume network // problem, and rely on §8.2 to recover liveness. HangForever() Algorithm 8 BinaryBA<span class="math">\\star</span> executes until consensus is reached on either block_hash or empty_hash.</p>

    <p class="text-gray-300">not have enough users to push CountVotes() in the next step past the threshold. To avoid this problem, whenever a user returns consensus, that user votes in the next three steps with the value they reached consensus on.</p>

    <p class="text-gray-300">In the common case, when the network is strongly synchronous and the block proposer was honest, BinaryBA<span class="math">\\star</span>() will start with the same block_hash for most users, and will reach consensus in the first step, since most committee members vote for the same block_hash value.</p>

    <p class="text-gray-300">Safety with weak synchrony. If the network is not strongly synchronous (e.g., there is a partition), BinaryBA<span class="math">\\star</span>() may return consensus on two different blocks. For example, suppose that, in the first step of BinaryBA<span class="math">\\star</span>(), all users vote for block_hash, but only one honest user, <span class="math">A</span>, receives those votes. In this case, <span class="math">A</span> will return consensus on block_hash, but all other users will move on to the next step. Now, the other users vote for block_hash again, because CountVotes() returned TIMEOUT. However, let’s assume the network drops all of these votes. Finally, the users vote for empty_hash in the third step, the network becomes well behaved, and all votes are delivered. As a result, the users will keep voting for empty_hash until the next iteration of the loop, at which point they reach consensus on empty_hash. This is undesirable because BinaryBA<span class="math">\\star</span>() returned consensus on two different hashes to different honest users.</p>

    <p class="text-gray-300">BA<span class="math">\\star</span>() addresses this problem by introducing the notion of final and tentative consensus. Final consensus means that BA<span class="math">\\star</span>() will not reach consensus on any other block for that round. Tentative consensus means that BA<span class="math">\\star</span>() was unable to guarantee safety, either because of network asynchrony or due to a malicious block proposer.</p>

    <p class="text-gray-300">BA<span class="math">\\star</span>() designates consensus on value <span class="math">V</span> as “final” if BinaryBA<span class="math">\\star</span>() reached consensus on <span class="math">V</span> in the very first step, and if enough users observed this consensus being reached. Specifically, BinaryBA<span class="math">\\star</span>() sends out a vote for the special FINAL step to indicate that a user reached consensus on some value in the very first step, and BA<span class="math">\\star</span>() collects these votes to determine whether final consensus was achieved. In a strongly synchronous network with an honest block proposer, BinaryBA<span class="math">\\star</span>() will reach consensus in the first step, most committee members will vote for the consensus block in the special FINAL step in BinaryBA<span class="math">\\star</span>(), and will receive more than a threshold of such votes in BA<span class="math">\\star</span>(), thus declaring the block as final. The FINAL step is analogous to the final confirmation step implemented in many Byzantine-resilient protocols <em>(15; 34)</em>.</p>

    <p class="text-gray-300">Intuitively, this guarantees safety because a large threshold of users have already declared consensus for <span class="math">V</span>, and will not vote for any other value in the same round. In our example above, where user <span class="math">A</span> reached consensus on a different block than all other users, neither block would be designated as final, because only one user (namely, <span class="math">A</span>) observed consensus at the first step, and there would never be enough votes to mark that block as final. Appendix C.1 formalizes and proves this safety property.</p>

    <p class="text-gray-300">One subtle issue arises due to the fact that BA<span class="math">\\star</span> relies on a committee to declare final consensus, instead of relying on all participants. As a result, even if one user observes final consensus, an adversary that controls the network may be able to prevent a small fraction of other users from reaching any kind of consensus (final or tentative) for an arbitrary number of steps. Each of these steps give the adversary an additional small probability of reaching consensus on a different value (e.g., the empty block). To bound the total probability of an adversary doing so, BA<span class="math">\\star</span> limits the total number of allowed steps; Appendix C.1 relies on this. If the protocol runs for more than MAXSTEPS steps, BA<span class="math">\\star</span> halts without consensus and relies on the recovery protocol described in §8.2 to recover liveness.</p>

    <p class="text-gray-300">procedure CommonCoin(ctx, round, step,  <span class="math">\\tau</span> ): minhash  <span class="math">\\leftarrow 2^{\\text{hashlen}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for  <span class="math">m\\in</span>  incomingMsgs[round,step] do  <span class="math">\\langle</span>  votes, value, sorthash  <span class="math">\\rangle \\gets</span>  ProcessMsg(ctx,  <span class="math">\\tau ,m)</span>  for  <span class="math">1\\leq j &amp;lt;   \\mathrm{votes}</span>  do  $h\\gets H(sorthash(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j)<span class="math">  if  </span>h &lt;   \\mathrm{minhash}<span class="math">  then minhash  </span>\\leftarrow h$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">return minhash mod 2</p>

    <p class="text-gray-300">Algorithm 9: Computing a coin common to all users.</p>

    <p class="text-gray-300">Getting unstuck. One remaining issue is that consensus could get stuck if the honest users are split into two groups, A and B, and the users in the two groups vote for different values (say, we are in step 1,  <span class="math">A</span>  votes for empty_hash, and  <span class="math">B</span>  votes for block_hash). Neither group is large enough to gather enough votes on their own, but together with the adversary's votes, group A is large enough. In this situation, the adversary can determine what every user will vote for in the next step. To make some user vote for empty_hash in the next step, the adversary sends that user the adversary's own votes for empty_hash just before the timeout expires, which, together with  <span class="math">A</span> 's votes, crosses the threshold. To make the user vote for block_hash, the adversary does not send any votes to that user; as a result, that user's CountVotes() will return TIMEOUT, and the user will choose block_hash for the next step's vote, according to the BinaryBA\\* algorithm. This way, the adversary can split the users into two groups in the next step as well, and continue this attack indefinitely.</p>

    <p class="text-gray-300">The attack described above requires the adversary to know how a user will vote after receiving TIMEOUT from CountVotes(). The third step of Binary  <span class="math">BA \\star</span>  is designed to avoid this attack by pushing towards accepting either block_hash or empty_hash based on a random "common coin," meaning a binary value that is predominantly the same for all users. Although this may sound circular, the users need not reach formal consensus on this common coin. As long as enough users observe the same coin bit, and the bit was not known to the attacker in advance of the step, Binary  <span class="math">BA \\star</span>  will reach consensus in the next iteration of the loop with probability  <span class="math">1/2</span>  (i.e., the probability that the attacker guessed wrong). By repeating these steps, the probability of consensus quickly approaches 1.</p>

    <p class="text-gray-300">To implement this coin we take advantage of the VRF-based committee member hashes attached to all of the messages. Every user sets the common coin to be the least-significant bit of the lowest hash it observed in this step, as shown in Algorithm 9. If a user gets multiple votes (i.e., several of their sub-users were selected), then CommonCoin() considers multiple hashes from that user, by hashing that user's sortition hash with the sub-user index. Notice that hashes are random (since they are produced by hashing the pseudo-random VRF output), so their least-significant bits are also random. The common coin is used only when CountVotes() times out, giving sufficient time for all votes to propagate through the network. If the committee member</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: The committee size,  <span class="math">\\tau</span> , sufficient to limit the probability of violating safety to  <span class="math">5 \\times 10^{-9}</span> . The x-axis specifies  <span class="math">h</span> , the weighted fraction of honest users.  <span class="math">\\star</span>  marks the parameters selected in our implementation.</p>

    <p class="text-gray-300">with the lowest hash is honest, then all users that received his message observe the same coin.</p>

    <p class="text-gray-300">If a malicious committee-member happens to hold the lowest hash, then he might send it to only some users. This may result in users observing different coin values, and thus will not help in reaching consensus. However, since sortition hashes are pseudo-random, the probability that an honest user has the lowest hash is  <span class="math">h</span>  (the fraction of money held by honest users), and thus there is at least an  <span class="math">h &amp;gt; \\frac{2}{3}</span>  probability that the lowest sortition hash holder will be honest, which leads to consensus with probability  <span class="math">\\frac{1}{2} \\cdot h &amp;gt; \\frac{1}{3}</span>  at each loop iteration. This allows Appendix C.3 to show that, with strong synchrony,  <span class="math">BA\\star</span>  does not exceed MAXSTEPS with overwhelming probability.</p>

    <p class="text-gray-300">The fraction  <span class="math">h &amp;gt; \\frac{2}{3}</span>  of weighted honest users in Algorand must translate into a "sufficiently honest" committee for  <span class="math">BA\\star</span> .  <span class="math">BA\\star</span>  has two parameters at its disposal:  <span class="math">\\tau</span> , which controls the expected committee size, and  <span class="math">T</span> , which controls the number of votes needed to reach consensus  <span class="math">(T \\cdot \\tau)</span> . We would like  <span class="math">T</span>  to be as small as possible for liveness, but the smaller  <span class="math">T</span>  is, the larger  <span class="math">\\tau</span>  needs to be, to ensure that an adversary does not obtain enough votes by chance. Since a larger committee translates into a higher bandwidth cost, we choose two different parameter sets:  <span class="math">T_{\\text{FINAL}}</span>  and  <span class="math">\\tau_{\\text{FINAL}}</span>  for the FINAL step, which ensures an overwhelming probability of safety regardless of strong synchrony, and  <span class="math">T_{\\text{STEP}}</span>  and  <span class="math">\\tau_{\\text{STEP}}</span>  for all other steps, which achieve a reasonable trade-off between liveness, safety, and performance.</p>

    <p class="text-gray-300">To make the constraints on  <span class="math">\\tau_{\\mathrm{STEP}}</span>  and  <span class="math">T_{\\mathrm{STEP}}</span>  precise, let us denote the number of honest committee members by  <span class="math">g</span>  and the malicious ones by  <span class="math">b</span> ; in expectation,  <span class="math">b + g = \\tau_{\\mathrm{STEP}}</span> , but  <span class="math">b + g</span>  can vary since it is chosen by sortition. To ensure liveness, as we prove in Appendix C.2,  <span class="math">BA\\star</span>  requires  <span class="math">\\frac{1}{2} g + b \\leq T_{\\mathrm{STEP}} \\cdot \\tau_{\\mathrm{STEP}}</span>  and  <span class="math">g &amp;gt; T_{\\mathrm{STEP}} \\cdot \\tau_{\\mathrm{STEP}}</span> .</p>

    <p class="text-gray-300">Due to the probabilistic nature of how committee members are chosen, there is always some small chance that the  <span class="math">b</span>  and</p>

    <p class="text-gray-300"><span class="math">g</span> for some step fail to satisfy the above constraints, and <span class="math">BA\\star</span>’s goal is to make this probability negligible. Figure 3 plots the expected committee size <span class="math">\\tau_{\\textsc{step}}</span> that is needed to satisfy both constraints, as a function of <span class="math">h</span>, for a probability of violation of <span class="math">5\\times 10^{-9}</span>; Appendix B describes this computation in more detail. The figure shows a trade-off: the weaker the assumption on the fraction of money held by honest users (<span class="math">h</span>), the larger the committee size needs to be. The results show that, as <span class="math">h</span> approaches <span class="math">\\frac{2}{3}</span>, the committee size grows quickly. However, at <span class="math">h=80\\%</span>, <span class="math">\\tau_{\\textsc{step}}=2,000</span> can ensure that these constraints hold with probability <span class="math">1-5\\times 10^{-9}</span> (using <span class="math">T_{\\textsc{step}}=0.685</span>).</p>

    <p class="text-gray-300">The constraints on <span class="math">\\tau_{\\textsc{final}}</span> and <span class="math">T_{\\textsc{final}}</span> are dictated by the proof of safety under weak synchrony; Appendix C.1 shows that <span class="math">\\tau_{\\textsc{final}}=10,000</span> suffices with <span class="math">T_{\\textsc{final}}=0.74</span>.</p>

    <p class="text-gray-300">With these parameters, <span class="math">BA\\star</span> ensures safety even if the lowest-priority block proposer is malicious (proposes different blocks). Appendix C provides proofs of <span class="math">BA\\star</span>’s safety under weak synchrony (§C.1), liveness under strong synchrony (§C.2), and efficiency (§C.3).</p>

    <h2 id="sec-22" class="text-2xl font-bold">8. Algorand</h2>

    <p class="text-gray-300">Building Algorand on top of the primitives we have described so far requires Algorand to address a number of higher-level issues, which this section discusses.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">8.1. Block format</h3>

    <p class="text-gray-300">Algorand’s blocks consist of a list of transactions, along with metadata needed by <span class="math">BA\\star</span>. Specifically, the metadata consists of the round number, the proposer’s VRF-based seed (§6), a hash of the previous block in the ledger, and a timestamp indicating when the block was proposed. The list of transactions in a block logically translates to a set of weights for each user’s public key (based on the balance of currency for that key), along with the total weight of all outstanding currency.</p>

    <p class="text-gray-300">Once a user receives a block from the highest-priority proposer, the user validates the block contents before passing it on to <span class="math">BA\\star</span>. In particular, the user checks that all transactions are valid; that the seed is valid; that the previous block hash is correct; that the block round number is correct; and that the timestamp is greater than that of the previous block and also approximately current (say, within an hour). If any of them are incorrect, the user passes an empty block to <span class="math">BA\\star</span>.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">8.2. Safety and liveness</h3>

    <p class="text-gray-300">To a large extent, Algorand relies on <span class="math">BA\\star</span> to reach consensus on blocks in the ledger. Algorand confirms transactions only when they appear in a final block, or in the predecessor of a final block. Final blocks guarantee that no other block could have reached consensus in the same round. This means that all final blocks are totally ordered with respect to one another, since (1) blocks form a linear chain, and (2) there can be exactly one final block at any given position in the chain. In other words, given two final blocks, one of them (the one with the smaller round number <span class="math">r_{1}</span>) must be a predecessor of the other (the one with the higher round number <span class="math">r_{2}</span>), since there must be some predecessor of the <span class="math">r_{2}</span> block in round <span class="math">r_{1}</span>, and the safety condition guarantees that the <span class="math">r_{1}</span> block is the only possible such block.</p>

    <p class="text-gray-300">The remaining issue is that, if the network is not strongly synchronous, <span class="math">BA\\star</span> may create forks (i.e., different users reach consensus on different blocks). This does not violate safety, because <span class="math">BA\\star</span> will return tentative consensus in this situation. However, forks do impact liveness: users on different forks will have different <em>ctx.last_block</em> values, which means they will not count each others’ votes. As a result, at least one of the forks (and possibly all of the forks) will not have enough participants to cross the vote threshold, and <span class="math">BA\\star</span> will not be able to reach consensus on any more blocks on that fork.</p>

    <p class="text-gray-300">To resolve these forks, Algorand periodically proposes a fork that all users should agree on, and uses <span class="math">BA\\star</span> to reach consensus on whether all users should, indeed, switch to this fork. To determine the set of possible forks, Algorand users passively monitor all <span class="math">BA\\star</span> votes (i.e., even votes whose <em>prev_hash</em> value does not match the current user’s chain), and keep track of all forks. Users then use loosely synchronized clocks to stop regular block processing and kick off the recovery protocol at every time interval (e.g., every hour), which will propose one of these forks as the fork that everyone should agree on.</p>

    <p class="text-gray-300">The recovery protocol starts by having users propose a fork using the block proposal mechanism (§6). Specifically, if a user is chosen to be a “fork proposer,” that user proposes an empty block whose predecessor hash is the longest fork (by the number of blocks) observed by the user so far. Each user waits for the highest-priority fork proposal, much as in the block proposal mechanism. Each user validates the proposed block, by ensuring that the block’s parent pointer is a chain that is as long as the longest chain seen by that user. Choosing the longest fork ensures that this fork will include all final blocks. Finally, the user invokes <span class="math">BA\\star</span> to reach consensus on this block, passing the round number found in the proposed block.</p>

    <p class="text-gray-300">In order for <span class="math">BA\\star</span> to reach consensus on one of the forks, all Algorand users must use the same seed and user weights. This means that Algorand must use user weights and seeds from before any possible forks occurred. To do this, Algorand relies on the weak synchrony assumption—namely, that in every period of length <span class="math">b</span> (think of <span class="math">b</span> as 1 day), there must be a strongly synchronous period of length <span class="math">s&lt;b</span> (think of <span class="math">s</span> as a few hours). Under this assumption, using the block timestamps, Algorand quantizes time into <span class="math">b</span>-long periods (think days), and finds the most recent block from the next-to-last complete <span class="math">b</span>-long period. Algorand then uses the seed from this block, and uses user weights from the last block that was agreed upon at least <span class="math">b</span>-long time before it (§5.3).</p>

    <p class="text-gray-300">Algorand takes the seed from the block from the <em>next-to-last</em> <span class="math">b</span>-long period because the most recent <span class="math">b</span>-long period may still have an unresolved fork. Such a fork would prevent users from agreeing on the seed and weights used in the</p>

    <p class="text-gray-300">recovery. However, as long as Algorand can recover within the <span class="math">s</span>-long strongly synchronous period in the most recent <span class="math">b</span>-long period, all users will agree on the same block from the next-to-last period (as long as their clocks are roughly synchronized).</p>

    <p class="text-gray-300">To ensure that Algorand recovers from a fork (i.e., most honest users switch to the same fork) within the <span class="math">s</span>-long synchronous period, Algorand users repeatedly attempt to reach consensus on a fork (applying a hash function to the seed each time to produce a different set of proposers and committee members), until they achieve consensus. Since, by assumption, Algorand is operating in a strongly synchronous period, it is not important whether <span class="math">BA\\star</span> returns “final” or “tentative” consensus in this case. When Algorand is recovering outside of a strongly synchronous period, we cannot ensure recovery within <span class="math">s</span> time.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">8.3. Bootstrapping</h3>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Bootstrapping the system.</h4>

    <p class="text-gray-300">To deploy Algorand, a common genesis block must be provided to all users, along with the initial cryptographic sortition seed. The value of <span class="math">seed_{0}</span> specified in the genesis block is decided using distributed random number generation <em>(14)</em>, after the public keys and weights for the initial set of participants are publicly known.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Bootstrapping new users.</h4>

    <p class="text-gray-300">Users that join the system need to learn the current state of the system, which is defined to be the result of a chain of <span class="math">BA\\star</span> consensus outcomes. To help users catch up, Algorand generates a certificate for every block that was agreed upon by <span class="math">BA\\star</span> (including empty blocks). The certificate is an aggregate of the votes from the last step of Binary<span class="math">BA\\star()</span> (not including the final step) that would be sufficient to allow any user to reach the same conclusion by processing these votes (i.e., there must be at least <span class="math">\\lfloor T_{\\textsc{step}}\\cdot\\tau_{\\textsc{step}}\\rfloor+1</span> votes). Importantly, the users must check the sortition hashes and proofs just like in Algorithm 6, and that all messages in the certificate are for the same Algorand round and <span class="math">BA\\star</span> step.</p>

    <p class="text-gray-300">Certificates allow new users to validate prior blocks. Users validate blocks in order, starting from the genesis block. This ensures that the user knows the correct weights for verifying sortition proofs in any given round. Users can also request a certificate proving the safety of a block; this is simply the collection of votes for the final step. Since final blocks are totally ordered, users need to check the safety of only the most recent block.</p>

    <p class="text-gray-300">One potential risk created by the use of certificates is that an adversary can provide a certificate that appears to show that <span class="math">BA\\star</span> completed after some large number of steps. This gives the adversary a chance to find a <span class="math">BA\\star</span> step number (up to MaxSteps) in which the adversary controls more than a threshold of the selected committee members (and to then create a signed certificate using their private keys). We set the committee size to be sufficiently large to ensure the attacker has negligible probability of finding such a step number. For <span class="math">\\tau_{\\textsc{step}}&gt;1,000</span>, the probability of this attack is less than <span class="math">2^{-166}</span> at every step, making this attack infeasible.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Storage.</h4>

    <p class="text-gray-300">The block history and matching certificates allow new users to catch-up, and are not required for users who are already up-to-date with the current ledger. Therefore Algorand distributes certificate and block storage across users. For N shards, users store blocks/certificates whose round number equals their public key modulo N.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">8.4. Communication</h3>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Gossiping blocks and relaying messages.</h4>

    <p class="text-gray-300">Algorand’s block proposal protocol (§6) assumed that chosen users can gossip new blocks before an adversary can learn the user’s identity and mount a targeted DoS attack against them. In practice, Algorand’s blocks are larger than the maximum packet size, so it is inevitable that some packets from a chosen block proposer will be sent before others. A particularly fast adversary could take advantage of this to immediately DoS any user that starts sending multiple packets, on the presumption that the user is a block proposer.</p>

    <p class="text-gray-300">Formally, this means that Algorand’s liveness guarantees are slightly different in practice: instead of providing liveness in the face of immediate targeted DoS attacks, Algorand ensures liveness as long as an adversary cannot mount a targeted DoS attack within the time it takes for the victim to send a block over a TCP connection (a few seconds). We believe this does not matter significantly; an adversary with such a quick reaction time likely also has broad control over the network, and thus can prevent Algorand nodes from communicating at all. Another approach may be to rely on Tor <em>(19)</em> to make it difficult for an adversary to quickly disconnect a user.</p>

    <p class="text-gray-300">To avoid an adversary from sending garbage messages and overwhelming Algorand’s gossip network, Algorand nodes must validate messages before relaying them. Specifically, Algorand nodes should validate each message using Algorithm 6, and avoid relaying more than one message signed by a given public key per <span class="math">\\langle</span>round, step<span class="math">\\rangle</span>.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Scalability.</h4>

    <p class="text-gray-300">The communication costs for each user depend on the expected size of the committee and the number of block proposers, which Algorand sets through <span class="math">\\tau_{\\textsc{proposer}}</span>, <span class="math">\\tau_{\\textsc{step}}</span>, and <span class="math">\\tau_{\\textsc{final}}</span> (independent of the number of users). As more users join, it takes a message longer to disseminate in the gossip network. Algorand’s gossip network forms a random network graph (each user connects to random peers). Our theoretical analysis suggests that almost all users will be part of one connected component in the graph, and that dissemination time grows with the diameter of that component, which is logarithmic in the number of users <em>(44)</em>. Experiments confirm that Algorand’s performance is only slightly affected by more users (§10).</p>

    <p class="text-gray-300">Since our random graph uses a fixed number of peers, one potential concern is that it may contain disconnected components <em>(22)</em>. However, only a small fraction of users might end up in a disconnected component, which does</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameter</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Meaning</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Value</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">h</td>

            <td class="px-3 py-2 border-b border-gray-700">assumed fraction of honest weighted users</td>

            <td class="px-3 py-2 border-b border-gray-700">80%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">seed refresh interval (# of rounds)</td>

            <td class="px-3 py-2 border-b border-gray-700">1,000 (§5.2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">τPROPOSER</td>

            <td class="px-3 py-2 border-b border-gray-700">expected # of block proposers</td>

            <td class="px-3 py-2 border-b border-gray-700">26 (§B.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">τSTEP</td>

            <td class="px-3 py-2 border-b border-gray-700">expected # of committee members</td>

            <td class="px-3 py-2 border-b border-gray-700">2,000 (§B.2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TSTEP</td>

            <td class="px-3 py-2 border-b border-gray-700">threshold of τSTEP for BA★</td>

            <td class="px-3 py-2 border-b border-gray-700">68.5% (§B.2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">τFINAL</td>

            <td class="px-3 py-2 border-b border-gray-700">expected # of final committee members</td>

            <td class="px-3 py-2 border-b border-gray-700">10,000 (§C.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TFINAL</td>

            <td class="px-3 py-2 border-b border-gray-700">threshold of τFINAL for BA★</td>

            <td class="px-3 py-2 border-b border-gray-700">74% (§C.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MAXSTEPS</td>

            <td class="px-3 py-2 border-b border-gray-700">maximum number of steps in BinaryBA★</td>

            <td class="px-3 py-2 border-b border-gray-700">150 (§C.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λPRIORITY</td>

            <td class="px-3 py-2 border-b border-gray-700">time to gossip sortition proofs</td>

            <td class="px-3 py-2 border-b border-gray-700">5 seconds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λBLOCK</td>

            <td class="px-3 py-2 border-b border-gray-700">timeout for receiving a block</td>

            <td class="px-3 py-2 border-b border-gray-700">1 minute</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λSTEP</td>

            <td class="px-3 py-2 border-b border-gray-700">timeout for BA★ step</td>

            <td class="px-3 py-2 border-b border-gray-700">20 seconds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λSTEPVAR</td>

            <td class="px-3 py-2 border-b border-gray-700">estimate of BA★ completion time variance</td>

            <td class="px-3 py-2 border-b border-gray-700">5 seconds</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Implementation parameters.</p>

    <p class="text-gray-300">not pose a problem for  <span class="math">BA\\star</span> . Moreover, Algorand replaces gossip peers each round, which helps users recover from being possibly disconnected in a previous round.</p>

    <p class="text-gray-300">We implemented a prototype of Algorand in  <span class="math">\\mathrm{C}++</span> , consisting of approximately 5,000 lines of code. We use the Boost ASIO library for networking. Signatures and VRFs are implemented over Curve 25519 [6], and we use SHA-256 for a hash function. We use the VRF outlined in Goldberg et al [27: §4].</p>

    <p class="text-gray-300">In our implementation each user connects to 4 random peers, accepts incoming connections from other peers, and gossips messages to all of them. This gives us 8 peers on average. We currently provide each user with an "address book" file listing the IP address and port number for every user's public key. In a real-world deployment we imagine users could gossip this information, signed by their keys, or distribute it via a public bulletin board. This naive design of the gossip protocol in our prototype implementation is potentially susceptible to Sybil attacks, since it does not prevent an adversary from joining the gossip network with a large number of identities. We leave the problem of implementing a Sybil-resistant gossip network to future work.</p>

    <p class="text-gray-300">One difference between our implementation and the pseudocode shown in §7 lies in the Binary  <span class="math">BA \\star()</span>  function. The pseudocode in Algorithm 8 votes in the next 3 steps after reaching consensus. For efficiency, our implementation instead looks back to the previous 3 steps before possibly returning consensus in a future step. This logic produces equivalent results but is more difficult to express in pseudocode.</p>

    <p class="text-gray-300">Figure 4 shows the parameters in our prototype of Algorand; we experimentally validate the timeout parameters in §10.  <span class="math">h = 80\\%</span>  means that an adversary would need to control  <span class="math">20\\%</span>  of Algorand's currency in order to create a fork. By analogy, in the US, the top  <span class="math">0.1\\%</span>  of people own about  <span class="math">20\\%</span>  of the wealth [40], so the richest 300,000 people would have to collude to create a fork.</p>

    <p class="text-gray-300"><span class="math">\\lambda_{\\mathrm{PRIORITY}}</span>  should be large enough to allow block proposers to gossip their priorities and proofs. Measurements of message propagation in Bitcoin's network [18] suggest that gos</p>

    <p class="text-gray-300">sipping 1 KB to  <span class="math">90\\%</span>  of the Bitcoin peer-to-peer network takes about 1 second. We conservatively set  <span class="math">\\lambda_{\\mathrm{PRIORITY}}</span>  to 5 seconds.</p>

    <p class="text-gray-300"><span class="math">\\lambda_{\\mathrm{BLOCK}}</span>  ensures that Algorand can make progress even if the block proposer does not send the block. Our experiments (§10) show that about 10 seconds suffices to gossip a 1 MB block. We conservatively set  <span class="math">\\lambda_{\\mathrm{BLOCK}}</span>  to be a minute.</p>

    <p class="text-gray-300"><span class="math">\\lambda_{\\mathrm{STEP}}</span>  should be high enough to allow users to receive messages from committee members, but low enough to allow Algorand to make progress (move to the next step) if it does not hear from sufficiently many committee members. We conservatively set  <span class="math">\\lambda_{\\mathrm{STEP}}</span>  to 20 seconds. We set  <span class="math">\\lambda_{\\mathrm{STEPVAR}}</span> , the estimated variance in  <span class="math">BA\\star</span>  completion times, to 10 seconds.</p>

    <p class="text-gray-300">Our evaluation quantitatively answers the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>What is the latency that Algorand can achieve for confirming transactions, and how does it scale as the number of users grows? (§10.1)</li>

      <li>What throughput can Algorand achieve in terms of transactions per second? (§10.2)</li>

      <li>What are Algorand's CPU, bandwidth, and storage costs? (§10.3)</li>

      <li>How does Algorand perform when users misbehave? (§10.4)</li>

      <li>Does Algorand choose reasonable timeout parameters? (§10.5)</li>

    </ul>

    <p class="text-gray-300">To answer these questions, we deploy our prototype of Algorand on Amazon's EC2 using 1,000 m4.2xlarge virtual machines (VMs), each of which has 8 cores and up to 1 Gbps network throughput. To measure the performance of Algorand with a large number of users, we run multiple Algorand users (each user is a process) on the same VM. By default, we run 50 users per VM, and users propose a 1 MByte block. To simulate commodity network links, we cap the bandwidth for each Algorand process to 20 Mbps. To model network latency we use inter-city latency and jitter measurements [52] and assign each machine to one of 20 major cities around the world; latency within the same city is modeled as negligible. We assign an equal share of money to each user; the equal distribution of money maximizes the number of messages that users need to process. Graphs in the rest of this section plot the time it takes for Algorand to complete an entire round, and include the minimum, median, maximum, 25th, and 75th percentile times across all users.</p>

    <p class="text-gray-300">Figure 5 shows results with the number of users varying from 5,000 to 50,000 (by varying the number of active VMs from 100 to 1,000). The results show that Algorand can confirm transactions in well under a minute, and the latency is near-constant as the number of users grows. (Since  <span class="math">\\tau_{\\mathrm{FINAL}} = 10,000</span> , the time it takes to complete the FINAL step increases until there are 10,000 users in the system; before this point, users</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 5: Latency for one round of Algorand, with 5,000 to 50,000 users.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 6: Latency for one round of Algorand in a configuration with 500 users per VM, using 100 to 1,000 VMs.</p>

    <p class="text-gray-300">are selected more than once and send fewer votes with higher weights.)</p>

    <p class="text-gray-300">To determine if Algorand continues to scale to even more users, we run an experiment with 500 Algorand user processes per VM. This configuration runs into two bottlenecks: CPU time and bandwidth. Most of the CPU time is spent verifying signatures and VRFs. To alleviate this bottleneck in our experimental setup, for this experiment we replace verifications with sleeps of the same duration. We are unable to alleviate the bandwidth bottleneck, since each VM's network interface is maxed out; instead, we increase  <span class="math">\\lambda_{\\mathrm{STEP}}</span>  to 1 minute.</p>

    <p class="text-gray-300">Figure 6 shows the results of this experiment, scaling the number of users from 50,000 to 500,000 (by varying the number of VMs from 100 to 1,000). The latency in this experiment is about  <span class="math">4 \\times</span>  higher than in Figure 5, even for the same number of users, owing to the bandwidth bottleneck. However, the scaling performance remains roughly flat all the way to 500,000 users, suggesting that Algorand scales well.</p>

    <p class="text-gray-300">In the following set of experiments we deploy 50,000 users on our 1,000 VMs (50 users per machine). Figure 7 shows the results with a varying block size. The figure breaks the Algorand round into three parts. Block proposal ( <span class="math">\\S 6</span> ), at the bottom of the graph, is the time it takes a user to obtain the</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 7: Latency for one round of Algorand as a function of the block size.</p>

    <p class="text-gray-300">proposed block. The block proposal time for small block sizes is dominated by the  <span class="math">\\lambda_{\\mathrm{PRIORITY}} + \\lambda_{\\mathrm{STEPVAR}}</span>  wait time. For large block sizes, the time to gossip the large block contents dominates.  <span class="math">BA\\star</span>  except for the FINAL step, in the middle of the graph, is the time it takes for  <span class="math">BA\\star</span>  to reach the FINAL step. Finally,  <span class="math">BA\\star</span>  's FINAL step, at the top of the graph, is the time it takes  <span class="math">BA\\star</span>  to complete the FINAL step. We break out the FINAL step separately because, for the purposes of throughput, it could be pipelined with the next round (although our prototype does not do so).</p>

    <p class="text-gray-300">The results show that Algorand's agreement time (i.e.,  <span class="math">BA\\star</span> ) is independent of the block size, and stays about the same (12 seconds) even for large blocks. The throughput can be further increased by pipelining the FINAL step, which takes about 6 seconds, with the next round of Algorand. The fixed time for running  <span class="math">BA\\star</span>  and the linear growth in block propagation time (with the size of the block) suggest that increasing the block size allows one to amortize the time it takes to run  <span class="math">BA\\star</span>  to commit more data, and therefore reach a throughput that maximizes the network capability.</p>

    <p class="text-gray-300">At its lowest latency, Algorand commits a 2 MByte block in about 22 seconds, which means it can commit 327 MBytes of transactions per hour. For comparison, Bitcoin commits a 1 MByte block every 10 minutes, which means it can commit 6 MBytes of transactions per hour [9]. As Algorand's block size grows, Algorand achieves higher throughput at the cost of some increase to latency. For example, with a 10 MByte block size, Algorand commits about 750 MBytes of transactions per hour, which is  <span class="math">125 \\times</span>  Bitcoin's throughput.</p>

    <p class="text-gray-300">Users running Algorand incur CPU, network, and storage costs. The CPU cost of running Algorand is modest; when running 50 users per VM, CPU usage on the 8-core VM was about  <span class="math">40\\%</span>  (most of it for verifying signatures and VRFs), meaning each Algorand process uses about  <span class="math">6.5\\%</span>  of a core. In terms of bandwidth, each user in our experiment with 1 MByte blocks and 50,000 users uses about 10 Mbit/sec (empirically computed as the total amount of data sent, divided by the duration of the experiment). We note that the communication cost per user is independent of the number of</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 8: Latency for one round of Algorand with a varying fraction of malicious users, out of a total of 50,000 users.</p>

    <p class="text-gray-300">users running Algorand, since users have an expected fixed number of neighbors they gossip messages to, and the number of messages in the consensus protocol depends on the committee size (rather than the total number of users).</p>

    <p class="text-gray-300">In terms of storage cost, Algorand stores block certificates in order to prove to new users that a block was committed. This storage cost is in addition to the blocks themselves. Each block certificate is 300 KBytes, independent of the block size; for 1 MByte blocks, this would be a  <span class="math">\\sim 30\\%</span>  storage overhead. Sharding block storage across users (§8.3) reduces storage costs proportionally. For example, sharding modulo 10 would require each user to store, on average, 130 KB for every 1MB block that is appended to the ledger.</p>

    <p class="text-gray-300">Algorand's safety is guaranteed by  <span class="math">BA \\star (\\S 7)</span> , but proving this experimentally would require testing all possible attacker strategies, which is infeasible. However, to experimentally show that our Algorand prototype handles malicious users, we choose one particular attack strategy. We force the block proposer with the highest priority to equivocate about the proposed block: namely, the proposer sends one version of the block to half of its peers, and another version to others (note that as an optimization, if a user receives to conflicting versions of a block from the highest priority block proposer before the block proposal step is complete, he discards both proposals and starts  <span class="math">BA \\star</span>  with the empty block). Malicious users that are chosen to be part of the  <span class="math">BA \\star</span>  committee vote for both blocks. Figure 8 shows how Algorand's performance is affected by the weighted fraction of malicious users. The results show that, at least empirically for this particular attack, Algorand is not significantly affected.</p>

    <p class="text-gray-300">The above results confirm that  <span class="math">BA \\star</span>  steps finish in well under  <span class="math">\\lambda_{\\mathrm{STEP}}</span>  (20 seconds), that the difference between 25th and 75th percentiles of  <span class="math">BA \\star</span>  completion times is under  <span class="math">\\lambda_{\\mathrm{STEPVAR}}</span>  (5 seconds), and that blocks are gossiped within  <span class="math">\\lambda_{\\mathrm{BLOCK}}</span>  (1 minute). We separately measure the time taken to propagate a block proposer's priority and proof; it is consistently</p>

    <p class="text-gray-300">around 1 second, well under  <span class="math">\\lambda_{\\mathrm{FRIORITY}}</span>  (5 seconds), confirming the measurements by Decker and Wattenhofer [18].</p>

    <p class="text-gray-300">This paper focused on the consensus mechanism for committing transactions, and addressing the associated scalability and security challenges. There remain a number of open problems in designing permissionless cryptocurrencies:</p>

    <p class="text-gray-300">Incentives. In order to encourage Algorand users to participate, i.e., be online when selected and pay the network cost of operating Algorand, the system may need to include incentives, possibly in form of a reward mechanism. Designing and analyzing an incentive mechanism includes many challenges, such as ensuring that users do not have perverse incentives (e.g., to withhold votes), and that malicious users cannot "game the system" to obtain more rewards than users who follow the protocol (e.g., by influencing seed selection).</p>

    <p class="text-gray-300">Cost of joining. To join Algorand, new users fetch all existing blocks with their accompanying certificates, which can comprise a large amount of data. Other cryptocurrencies face a similar problem, but since the throughput of Algorand is relatively high, this may create a scalability challenge.</p>

    <p class="text-gray-300">Forward security. Attackers may attempt to corrupt users over time, since identities of committee members are revealed after they send a message. If an attacker manages to obtain enough user keys, he could construct a fake certificate to create a fork. One solution would be for users to forget the signing key before sending out a signed message (and commit to a series of signing keys ahead of time, perhaps using identity-based encryption [11, 20]).</p>

    <p class="text-gray-300">Algorand is a new cryptocurrency that confirms transactions on the order of a minute with a negligible probability of forking. Algorand's design is based on a cryptographic sortition mechanism combined with the  <span class="math">BA \\star</span>  Byzantine agreement protocol. Algorand avoids targeted attacks at chosen participants using participant replacement at every step. Experimental results with a prototype of Algorand demonstrate that it achieves sub-minute latency and  <span class="math">125 \\times</span>  the throughput of Bitcoin, and scales well to 500,000 users.</p>

    <p class="text-gray-300">Thanks to Iddo Bentov, Ethan Heilman, Jelle van den Hooff, and our shepherd, Robbert van Renesse, for their helpful comments and suggestions. Gilad, Hemo, and Zeldovich were supported by NSF awards CNS-1413920 and CNS-1414119.</p>

    <p class="text-gray-300">[1] M. Abd-El-Malek, G. R. Ganger, G. R. Goodson, M. K. Reiter, and J. J. Wylie. Fault-scalable Byzantine fault-tolerant services. In Proceedings of the 20th ACM Symposium on Operating Systems Principles (SOSP), pages 59-74, Brighton, UK, Oct. 2005.</p>

    <p class="text-gray-300">[2] I. Bentov and R. Kumaresan. How to use Bitcoin to design fair protocols. In Proceedings of the 34th Annual International Cryptology Conference (CRYPTO), Santa Barbara, CA, Aug. 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[3] I. Bentov, C. Lee, A. Mizrahi, and M. Rosenfeld. Proof of activity: Extending Bitcoin’s proof of work via proof of stake. In Proceedings of the 2014 Joint Workshop on Pricing and Incentives in Networks and Systems, Austin, TX, June 2014.</li>

      <li>[4] I. Bentov, A. Gabizon, and A. Mizrahi. Cryptocurrencies without proof of work. In Proceedings of the 2016 Financial Cryptography and Data Security Conference, 2016.</li>

      <li>[5] I. Bentov, P. Hubáček, T. Moran, and A. Nadler. Tortoise and hares consensus: the Meshcash framework for incentive-compatible, scalable cryptocurrencies. Cryptology ePrint Archive, Report 2017/300, Apr. 2017. http://eprint.iacr.org/.</li>

      <li>[6] D. J. Bernstein. Curve25519: New Diffie-Hellman speed records. In Proceedings of the 9th International Conference on Theory and Practice in Public-Key Cryptography (PKC), pages 207–228, New York, NY, Apr. 2006.</li>

      <li>[7] Bitcoin Wiki. Confirmation. https://en.bitcoin.it/wiki/Confirmation, 2017.</li>

      <li>[8] BitcoinWiki. Mining hardware comparison, 2016. https://en.bitcoin.it/wiki/Mining_hardware_comparison.</li>

      <li>[9] BitcoinWiki. Bitcoin scalability. https://en.bitcoin.it/wiki/Scalability, 2017.</li>

      <li>[10] BitcoinWiki. Proof of stake. https://en.bitcoin.it/wiki/Proof_of_Stake, 2017.</li>

      <li>[11] D. Boneh and M. K. Franklin. Identity-based encryption from the Weil pairing. In Proceedings of the 21st Annual International Cryptology Conference (CRYPTO), Santa Barbara, CA, Aug. 2001.</li>

      <li>[12] G. Brockman. Stellar, July 2014. https://stripe.com/blog/stellar.</li>

      <li>[13] V. Buterin. Minimal slashing conditions. https://medium.com/@VitalikButerin/minimal-slashing-conditions-20f0b500fc6c, Mar. 2017.</li>

      <li>[14] C. Cachin, K. Kursawe, F. Petzold, and V. Shoup. Secure and efficient asynchronous broadcast protocols. In Proceedings of the 21st Annual International Cryptology Conference (CRYPTO), pages 524–541, Santa Barbara, CA, Aug. 2001.</li>

      <li>[15] M. Castro and B. Liskov. Practical Byzantine fault tolerance and proactive recovery. ACM Transactions on Computer Systems, 20(4), Nov. 2002.</li>

      <li>[16] J. Chen and S. Micali. Algorand. Technical report, 2017. URL http://arxiv.org/abs/1607.01341.</li>

      <li>[17] A. Clement, E. L. Wong, L. Alvisi, M. Dahlin, and M. Marchetti. Making Byzantine fault tolerant systems tolerate Byzantine faults. In Proceedings of the 6th Symposium on Networked Systems Design and Implementation (NSDI), pages 153–168, Boston, MA, Apr. 2009.</li>

      <li>[18] C. Decker and R. Wattenhofer. Information propagation in the Bitcoin network. In Proceedings of the 13th IEEE International Conference on Peer-to-Peer Computing, Sept. 2013.</li>

      <li>[19] R. Dingledine, N. Mathewson, and P. Syverson. Tor: The second-generation onion router. In Proceedings of the 13th Usenix Security Symposium, pages 303–320, San Diego, CA, Aug. 2004.</li>

      <li>[20] N. Döttling and S. Garg. Identity-based encryption from the Diffie-Hellman assumption. In Proceedings of the 37th Annual International Cryptology Conference (CRYPTO), pages 537–569, Santa Barbara, CA, Aug. 2017.</li>

      <li>[21] J. R. Douceur. The Sybil attack. In Proceedings of the 1st International Workshop on Peer-to-Peer Systems (IPTPS ’02), Cambridge, MA, Mar. 2002.</li>

      <li>[22] P. Erdős and A. Rényi. On the evolution of random graphs. Publications of the Mathematical Institute of the Hungarian Academy of Sciences, 5:17–61, 1960.</li>

      <li>[23] Ethereum Foundation. Ethereum, 2016. https://www.ethereum.org/.</li>

      <li>[24] Ethereum Foundation. Create a democracy contract in Ethereum, 2016. https://www.ethereum.org/dao.</li>

      <li>[25] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Proceedings of the 2013 Financial Cryptography and Data Security Conference, Mar. 2014.</li>

      <li>[26] I. Eyal, A. E. Gencer, E. G. Sirer, and R. van Renesse. Bitcoin-NG: A scalable blockchain protocol. In Proceedings of the 13th Symposium on Networked Systems Design and Implementation (NSDI), pages 45–59, Santa Clara, CA, Mar. 2016.</li>

      <li>[27] S. Goldberg, M. Naor, D. Papadopoulos, and L. Reyzin. NSEC5 from elliptic curves: Provably preventing DNSSEC zone enumeration with shorter responses. Cryptology ePrint Archive, Report 2016/083, Mar. 2016. http://eprint.iacr.org/.</li>

      <li>[28] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg. Eclipse attacks on Bitcoin’s peer-to-peer network. In Proceedings of the 24th Usenix Security Symposium, pages 129–144, Washington, DC, Aug. 2015.</li>

    </ul>

    <p class="text-gray-300">[29] S. Higgins. Bitcoin mining pools targeted in wave of DDoS attacks. Mar. 2015. https://www.coindesk.com/bitcoin-mining-pools-ddos-attacks/.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[30] A. Kiayias, I. Konstantinou, A. Russell, B. David, and R. Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. Cryptology ePrint Archive, Report 2016/889, 2016. http://eprint.iacr.org/.</li>

      <li>[31] S. King and S. Nadal. PPCoin: Peer-to-peer cryptocurrency with proof-of-stake, Aug. 2012. https://peercoin.net/assets/paper/peercoin-paper.pdf.</li>

      <li>[32] E. Kokoris-Kogias, P. Jovanovic, N. Gailly, I. Khoffi, L. Gasser, and B. Ford. Enhancing Bitcoin security and performance with strong consistency via collective signing. In Proceedings of the 25th Usenix Security Symposium, pages 279–296, Austin, TX, Aug. 2016.</li>

      <li>[33] R. Kotla, L. Alvisi, M. Dahlin, A. Clement, and E. L. Wong. Zyzzyva: Speculative Byzantine fault tolerance. ACM Transactions on Computer Systems, 27(4):7:1–39, 2009.</li>

      <li>[34] L. Lamport. The part-time parliament. ACM Transactions on Computer Systems, 16(2):133–169, 1998.</li>

      <li>[35] J. Li and D. Mazières. Beyond one-third faulty replicas in Byzantine fault tolerant systems. In Proceedings of the 4th Symposium on Networked Systems Design and Implementation (NSDI), Cambridge, MA, Apr. 2007.</li>

      <li>[36] D. Mazières. The Stellar consensus protocol: A federated model for internet-level consensus. https://www.stellar.org/papers/stellar-consensus-protocol.pdf, 2014.</li>

      <li>[37] S. Micali. Fast and furious Byzantine agreement. In Proceedings of the Innovations in Theoretical Computer Science (ITCS) Conference, 2017.</li>

      <li>[38] S. Micali, M. O. Rabin, and S. P. Vadhan. Verifiable random functions. In Proceedings of the 40th Annual IEEE Symposium on Foundations of Computer Science (FOCS), New York, NY, Oct. 1999.</li>

      <li>[39] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song. The Honey Badger of BFT protocols. In Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS), pages 31–42, Vienna, Austria, Oct. 2016.</li>

      <li>[40] A. Monaghan. US wealth inequality: top 0.1% worth as much as the bottom 90%, Nov. 2014. https://www.theguardian.com/business/2014/nov/13/us-wealth-inequality-top-01-worth-as-much-as-the-bottom-90.</li>

      <li>[41] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. https://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>[42] R. Pass and E. Shi. Hybrid consensus: Efficient consensus in the permissionless model. Cryptology ePrint Archive, Report 2016/917, 2016. http://eprint.iacr.org/.</li>

      <li>[43] Peercointalk. Peercoin invalid checkpoint. https://www.peercointalk.org/t/invalid-checkpoint/3691, 2015.</li>

      <li>[44] O. Riordan and N. Wormald. The diameter of sparse random graphs. Combinatorics, Probability and Computing, 19(5-6):835–926, Nov. 2010.</li>

      <li>[45] P. Rizzo. BitGo launches “instant” Bitcoin transaction tool, Jan. 2016. http://www.coindesk.com/bitgo-instant-bitcoin-transaction-tool/.</li>

      <li>[46] J. Rubin. The problem of ASICBOOST, Apr. 2017. http://www.mit.edu/~jlrubin/public/pdfs/Asicboost.pdf.</li>

      <li>[47] Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in Bitcoin. In Proceedings of the 2015 Financial Cryptography and Data Security Conference, 2015.</li>

      <li>[48] Y. Sompolinsky, Y. Lewenberg, and A. Zohar. SPECTRE: A fast and scalable cryptocurrency protocol. Cryptology ePrint Archive, Report 2016/1159, 2016. http://eprint.iacr.org/.</li>

      <li>[49] N. Szabo. Smart contracts: Formalizing and securing relationships on public networks. First Monday, 2(9), Sept. 1997. http://firstmonday.org/ojs/index.php/fm/article/view/548/469.</li>

      <li>[50] R. Turpin and B. A. Coan. Extending binary Byzantine agreement to multivalued Byzantine agreement. Information Processing Letters, 18(2):73–76, Feb. 1984.</li>

      <li>[51] M. Vasek, M. Thornton, and T. Moore. Empirical analysis of denial-of-service attacks in the Bitcoin ecosystem. In Proceedings of the 18th International Financial Cryptography and Data Security Conference, Barbados, Mar. 2014.</li>

      <li>[52] WonderNetwork. Global ping statistics: Ping times between WonderNetwork servers, Apr. 2017. https://wondernetwork.com/pings.</li>

      <li>[53] Zerocoin Electric Coin Company. ZCash: All coins are created equal, 2017. https://z.cash.</li>

    </ul>

    <h2 id="sec-43" class="text-2xl font-bold">Appendix A Number of required blocks for unpredictable selection seed</h2>

    <h6 id="sec-44" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Under strong synchrony, the probability that the attacker can compute the next <span class="math">k</span> selection seeds decreases exponentially with <span class="math">k</span>.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">h</span> denote the fraction of honest users. When the block that was agreed upon for round <span class="math">r</span> is proposed by an honest user <span class="math">i</span>, then <span class="math">seed_{r+1}</span>, which sets the priorities among block proposers for round <span class="math">r+1</span>, takes a uniformly random value. Therefore, the highest priority for proposing a block at round <span class="math">r+1</span> has probability <span class="math">h</span> of belonging to an honest user, and so does every priority in the increasing sequence (i.e., the second highest priority also has probability <span class="math">h</span>, and so on). If the priority belongs to an honest user, then that user will propose a non-empty block which will become the unique certified block for round <span class="math">r+1</span>. If the <span class="math">c</span> highest priorities belong to malicious users instead, then the adversary can make any of those <span class="math">c</span> users propose the next block (and have that block agreed upon by all honest users), or he might force the round <span class="math">r+1</span> block to be the empty block (by sending the proof of selection with the highest priority, and then not sending the actual block). So the adversary has <span class="math">c+1</span> choices for the value of <span class="math">seed_{r+1}</span>. These options give the adversary the power to influence future seeds and ensure a malicious block proposer with probability greater than <span class="math">1-h</span>. We now prove that the adversary has limited power to influence future seeds.</p>

    <p class="text-gray-300">For the proof, we build a tree, where each node represents a user’s priority value, and contains the next selection seed, as set by that user (if the associated priority is the highest announced); each node in the tree can belong to an honest or a malicious user. The root of this tree belongs to the last honest user who proposed a block that was agreed upon. The selection seed in the root is <span class="math">seed_{r}</span>, which is the last seed that was in a block proposed by an honest user. The children of the root represent the users ordered from left to right, in decreasing priority order, determined by <span class="math">seed_{r}</span>, and each child node also contains a possible value for <span class="math">seed_{r+1}</span>. We define the children of each child node using the same procedure we used for the root. Each node’s children define an order of the users, which is sampled with a pseudo-random permutation of all user priorities (set by the selection seed in the father node).</p>

    <p class="text-gray-300">We refer to blocks set by honest/malicious users as honest/malicious blocks (respectively). We wish to bound the expected number of blocks between two consecutive honest-blocks. For the proof, we give the adversary the power to, given a selection seed, know the positions of the users in the decreasing order of priorities. If the leftmost child of the root represents an honest user, then block at round <span class="math">r+1</span> will be honest, so the number of malicious blocks between the two honest blocks is <span class="math">0</span>. If the leftmost child is malicious, then number of malicious blocks before the next honest block is at least <span class="math">1</span>. This happens with probability <span class="math">1-h</span>, so the probability that at least one non-honest block appears before the next honest block is <span class="math">1-h</span>. If we let <span class="math">f(k)</span> denote the probability that at least <span class="math">k</span> non-honest blocks appear before the next honest block, then <span class="math">f(1)=1-h</span>. We will now inductively compute an upper bound on <span class="math">f(k)</span>, using <span class="math">f(1)</span> as the base case.</p>

    <p class="text-gray-300">For <span class="math">f(k+1)</span>, if the root has exactly <span class="math">c</span> malicious children left of the first honest child, then the adversary has <span class="math">c+1</span> options for <span class="math">seed_{r+1}</span>. The adversary can generate <span class="math">k+1</span> malicious blocks iff he can generate at least <span class="math">k</span> malicious blocks starting from one of the <span class="math">c+1</span> options he has for the block following the root. The probability that at least one of <span class="math">c+1</span> options does generate <span class="math">k</span> non-honest blocks is less than <span class="math">(c+1)f(k)</span> by union bound. So we get the recursive formula:</p>

    <p class="text-gray-300">\\[ \\begin{split}f(k+1)\\leq\\\\ \\sum_{c=1}^{\\infty}\\Pr[\\text{adv. has exactly <span class="math">c</span> leftmost children}]\\cdot(c+1)f(k)=\\\\ \\sum_{c=1}^{\\infty}(1-h)^{c}h\\cdot(c+1)f(k)=\\frac{(1-h)(1+h)}{h}f(k)\\end{split} \\]</p>

    <p class="text-gray-300">So by induction,</p>

    <p class="text-gray-300"><span class="math">f(k)\\leq(\\frac{(1-h)(1+h)}{h})^{k-1}f(1)=\\left(\\frac{(1-h)(1+h)}{h}\\right)^{k-1}(1-h)</span> (1)</p>

    <p class="text-gray-300">Since <span class="math">h\\geq\\frac{2}{3}</span> it holds that,</p>

    <p class="text-gray-300"><span class="math">f(k)\\leq\\frac{1}{3}\\cdot(0.84)^{k-1}\\leq(0.84)^{k}</span></p>

    <p class="text-gray-300">Thus, for failure probability <span class="math">f</span> that the attacker can control <span class="math">k</span> blocks in a row, it is sufficient to chose <span class="math">k=\\log_{0.84}f</span>. For <span class="math">f=10^{-18}</span>, it is sufficient to use <span class="math">k=238</span>. If we assume a somewhat higher honesty rate, e.g., <span class="math">h=\\frac{3}{4}</span>, then it is sufficient to use <span class="math">k=77</span>. ∎</p>

    <h2 id="sec-46" class="text-2xl font-bold">Appendix B Number of selected users</h2>

    <p class="text-gray-300">We have at least <span class="math">h\\cdot U</span> honest sub-users, where <span class="math">U</span> is the total number of minimal Algorand units in the system. We assume a large number of currency units in Algorand (namely, <span class="math">U</span> can be made arbitrarily large). At each round, the number of sub-users selected for a given role varies, but the expected number of selected sub-users, <span class="math">\\tau</span>, is fixed. The probability <span class="math">p</span> of a sub-user to be selected is given by the formula <span class="math">p=\\frac{\\tau}{U}</span>. What is the probability that exactly <span class="math">K</span> sub-users are sampled?</p>

    <p class="text-gray-300">There are <span class="math">\\binom{U}{K}</span> subsets of <span class="math">U</span>, consisting of exactly <span class="math">K</span> sub-users. For each such set, the probability that exactly the sub-users of that set are sampled form <span class="math">U</span> is <span class="math">p^{K}(1-p)^{U-K}</span>. So the probability that exactly <span class="math">K\\in\\{0,1,\\ldots\\}</span> sub-users are sampled is:</p>

    <p class="text-gray-300"><span class="math">\\binom{U}{K}p^{K}(1-p)^{U-K}</span></p>

    <p class="text-gray-300">This is equal to:</p>

    <p class="text-gray-300"><span class="math">\\frac{U!}{K!(U-K)!}(\\frac{\\tau}{U})^{K}(1-\\frac{\\tau}{U})^{U-K}=\\frac{U\\cdots(U-K+1)}{U^{K}}\\frac{\\tau^{K}}{K!}(1-\\frac{\\tau}{U})^{U-K}</span></p>

    <p class="text-gray-300">For the purposes of Algorand, we can take <span class="math">U</span> to be arbitraril</p>

    <p class="text-gray-300">large and fix <span class="math">K</span>, so that effectively,</p>

    <p class="text-gray-300"><span class="math">\\frac{U\\cdots(U-K+1)}{U^{K}}=1</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">(1-\\frac{\\tau}{U})^{U-K}=\\frac{(1-\\frac{\\tau}{U})^{U}}{(1-\\frac{\\tau}{U})^{K}}=\\frac{e^{-\\tau}}{1}=e^{-\\tau}</span></p>

    <p class="text-gray-300">So the probability of sampling exactly <span class="math">K</span> sub-users is:</p>

    <p class="text-gray-300"><span class="math">\\frac{(\\tau)^{K}}{K!}e^{-\\tau}</span> (2)</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">B.1. Block proposers</h3>

    <p class="text-gray-300">We need that at least one proposer is selected every round, but not too many users are selected. Let the expected number of proposers be <span class="math">\\tau_{\\text{PROPOSER}}</span>. We can use the formula in Equation 2 to obtain the probability of <span class="math">0</span> good proposers as:</p>

    <p class="text-gray-300"><span class="math">\\frac{(\\tau_{\\text{PROPOSER}})^{0}}{0!}e^{-\\tau_{\\text{PROPOSER}}}=e^{-\\tau_{\\text{PROPOSER}}}</span></p>

    <p class="text-gray-300">For <span class="math">\\tau_{\\text{PROPOSER}}=26</span>, the probability that we get at least one proposer but no more than <span class="math">70</span> is:</p>

    <p class="text-gray-300"><span class="math">\\sum_{K=1}^{70}\\frac{26^{K}}{K!}e^{-26}&gt;1-10^{-11}</span></p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">B.2. Committee members</h3>

    <p class="text-gray-300">If #good is the number of honest committee members and #bad is the number of malicious committee members, then we want the following conditions to be satisfied for some pre-determined threshold <span class="math">T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}</span>. We give explicit formulas for the probability that each condition is violated.</p>

    <p class="text-gray-300">Condition (1), #good <span class="math">&gt;T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}</span>. This condition is violated when the number of honest committee members is <span class="math">\\leq T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}</span>. From Equation 2, the probability that we have exactly <span class="math">K</span> honest committee members is <span class="math">\\frac{(h\\tau_{\\text{STEP}})^{K}}{K!}e^{-h\\tau_{\\text{STEP}}}</span>. Thus, the probability that the condition is violated is given by the formula:</p>

    <p class="text-gray-300"><span class="math">\\sum_{k=0}^{T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}}\\frac{(h\\tau_{\\text{STEP}})^{K}}{K!}e^{-h\\tau_{\\text{STEP}}}</span></p>

    <p class="text-gray-300">Condition (2), #<span class="math">\\frac{1}{2}</span>good + #bad <span class="math">\\leq T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}</span>. As above, the probability that #bad <span class="math">=L</span> is</p>

    <p class="text-gray-300"><span class="math">\\frac{((1-h)\\tau_{\\text{STEP}})^{L}}{L!}e^{-(1-h)\\tau_{\\text{STEP}}}</span></p>

    <p class="text-gray-300">So the probability that both #good <span class="math">=K</span> and #bad <span class="math">=L</span> is:</p>

    <p class="text-gray-300"><span class="math">\\frac{(h\\tau_{\\text{STEP}})^{K}}{K!}e^{-h\\tau_{\\text{STEP}}}\\frac{((1-h)\\tau_{\\text{STEP}})^{L}}{L!}e^{-(1-h)\\tau_{\\text{STEP}}}=</span> <span class="math">\\frac{(h\\tau_{\\text{STEP}})^{K}}{K!}\\frac{((1-h)\\tau_{\\text{STEP}})^{L}}{L!}e^{-\\tau_{\\text{STEP}}}</span></p>

    <p class="text-gray-300">The condition is violated when <span class="math">K+2L&gt;2T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}</span>, so the probability that condition (2) is violated is given by the formula:</p>

    <p class="text-gray-300"><span class="math">\\sum_{K+2L&gt;2T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}}^{\\infty}\\frac{(h\\tau_{\\text{STEP}})^{K}}{K!}\\frac{((1-h)\\tau_{\\text{STEP}})^{L}}{L!}e^{-\\tau_{\\text{STEP}}}=</span> <span class="math">\\sum_{L=0}^{\\infty}\\sum_{K=\\max\\{T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}-2L,0\\}}^{\\infty}\\frac{(h\\tau_{\\text{STEP}})^{K}}{K!}\\frac{((1-h)\\tau_{\\text{STEP}})^{L}}{L!}e^{-\\tau_{\\text{STEP}}}</span></p>

    <p class="text-gray-300">This sum converges and we upper-bound its value for particular choice of <span class="math">h,T_{\\text{STEP}},\\tau_{\\text{STEP}}</span> parameters.</p>

    <p class="text-gray-300">In particular, the parameters <span class="math">T_{\\text{STEP}}</span> and <span class="math">\\tau_{\\text{STEP}}</span> are selected so as to ensure that both conditions hold with probability <span class="math">F</span> in a randomly generated committee. Here, <span class="math">F</span> is a parameter which marks a negligible probability for failure of either condition, which we usually set to <span class="math">F=10^{-12}</span> or <span class="math">F=10^{-18}</span>.</p>

    <p class="text-gray-300">Analysis behind Figure 3. For a given fraction of honest committee members <span class="math">h</span> (x-axis of Figure 3), the goal is to minimize the expected committee size, while maintaining the probability that conditions (1) or (2) fail to be at most <span class="math">F</span>. If some value of <span class="math">\\tau_{\\text{STEP}}</span> satisfies both conditions with probability <span class="math">1-F</span> for some appropriate value of <span class="math">T_{\\text{STEP}}</span>, then any larger value of <span class="math">\\tau_{\\text{STEP}}</span> also does for the same <span class="math">T_{\\text{STEP}}</span> with probability at least <span class="math">1-F</span>. So to find the optimal <span class="math">\\tau_{\\text{STEP}}</span>, we start with an arbitrary high value for <span class="math">\\tau_{\\text{STEP}}</span>, say <span class="math">10,000</span>, and then see if we can find a <span class="math">T_{\\text{STEP}}&gt;\\frac{2}{3}</span> that satisfies conditions (1) and (2). If such threshold exists, then we decrease <span class="math">\\tau_{\\text{STEP}}</span> and test whether a good threshold exists too. We continue this iterative process until finding the minimal committee size and corresponding threshold <span class="math">T_{\\text{STEP}}</span> that ensure both conditions.</p>

    <p class="text-gray-300">To check if a particular value for <span class="math">\\tau_{\\text{STEP}}</span> works, we do a binary search to find the highest <span class="math">T_{\\text{STEP}}\\in(\\frac{2}{3},1]</span> value such that condition (1), #good <span class="math">&gt;T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}</span>, fails with probability <span class="math">\\leq\\frac{1}{2}F</span>, then check if, for that particular value of <span class="math">T_{\\text{STEP}}</span>, condition (2) also fails with probability <span class="math">\\leq\\frac{1}{2}F</span>. By the union bound, the probability that either condition fails is <span class="math">F</span>, so the expected committee size <span class="math">\\tau_{\\text{STEP}}</span> works.</p>

    <p class="text-gray-300">With the above approach, we find an approximation of the optimal value for <span class="math">\\tau_{\\text{STEP}}</span> that is within <span class="math">1\\%</span> of the true optimal value for <span class="math">\\tau_{\\text{STEP}}</span>.</p>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix C. BA<span class="math">\\star</span> Analysis</h2>

    <p class="text-gray-300">In this section we analyze the safety, liveness, and efficiency of BA<span class="math">\\star</span>, presented in §7.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">C.1. Safety with weak synchrony</h3>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Assume the parameters <span class="math">T_{\\text{FINAL}}=0.74</span>, <span class="math">\\tau_{\\text{FINAL}}=10,000</span> and <span class="math">T_{\\text{STEP}}=0.685</span>, <span class="math">\\tau_{\\text{STEP}}=2000</span> (as in Figure 4). Fix a round <span class="math">r=0</span> mod <span class="math">R</span> (where <span class="math">R</span> is the selection seed refresh interval, see §5.2). The probability that there exists a round <span class="math">r\\leq r^{\\prime}&lt;r+R</span>, such that BA<span class="math">\\star</span> (Algorithm 3) returns for one honest user a final consensus for block <span class="math">A</span>, and for another honest user a consensus (final or tentative) for block <span class="math">B\\neq A</span>, is <span class="math">&lt;10^{-7}</span>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Corollary 3.</h6>

    <p class="text-gray-300">Given Theorem 2 and since <span class="math">R=10^{3}</span> (i.e., every <span class="math">10^{3}</span> consecutive rounds starting with an integral multiple of <span class="math">R</span> get their committees from the same selection seed), we expect <span class="math">BA\\star</span> to return for one honest user a final consensus for block <span class="math">A</span>, and for another honest user a consensus (final or tentative) for block <span class="math">B\\neq A</span> for the same round, only once every <span class="math">10^{3}\\cdot 10^{7}=10^{10}</span> rounds.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We next prove Theorem 2. In §5.3 and Appendix A we showed that the weak synchrony assumption allows Algorand to select the users’ public keys (and associated weights) before the adversary knows the selection seed, ensuring random sampling of users for <span class="math">BA\\star</span> committees. We next leverage this property to, informally, show that the committee members for the final step represent well all the users in the system. Therefore, if sufficiently many of them vote for a block to be final, then sufficiently many of the users have finished Binary<span class="math">BA\\star</span> at the first step and will not vote in future steps (so no other block can be approved).</p>

    <p class="text-gray-300">We set <span class="math">\\tau_{\\textsc{final}}=10,000</span> and assume that the weighted honest fraction of users is <span class="math">h=0.8</span>. Thus, the expected number of honest members in the final step committee is <span class="math">0.8\\cdot 10,000=8000</span>, while the expected number of malicious members for that step is <span class="math">0.2\\cdot 10,000=2000</span>. We next show that the probability that 7400 step-final votes for a round-<span class="math">r^{\\prime}</span> block <span class="math">A</span> are produced, but another block <span class="math">B</span> is also certified for the same round, is negligible.</p>

    <p class="text-gray-300">Let <span class="math">seed_{r-1-(r\\bmod R)}</span> be the seed used for selecting the committees for round <span class="math">r^{\\prime}\\in[r,r+R)</span>. If the round when that seed was published, i.e. round <span class="math">r-1-(r\\bmod R)</span>, happens when the network is not strongly synchronous, then the adversary may manipulate the selection of the seed (<span class="math">seed_{r-1-(r\\bmod R)}</span>) by discarding block proposals from honest users. We first show that despite the ability of the attacker to manipulate the seed, it is infeasible to compute a seed that: (1) gives <span class="math">i</span> malicious committee members in the <span class="math">r^{\\prime}</span> round final step, and (2) <span class="math">j</span> malicious committee members in some other step of round <span class="math">r^{\\prime}</span>, where <span class="math">i+3j&gt;4,100</span>.</p>

    <p class="text-gray-300">The expected numbers for <span class="math">i</span> and <span class="math">j</span> are <span class="math">0.2\\cdot 1000=2000</span> and <span class="math">0.2\\cdot 2000=400</span> respectively. So for a fixed round and step, we apply the formula in Equation 2, to find the probability that a random seed gives <span class="math">i+3j&gt;4,100</span>:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i+3j&gt;4,100}\\frac{2000^{i}}{i!e^{2000}}\\frac{400^{j}}{j!e^{400}}\\simeq 2^{-100}</span></p>

    <p class="text-gray-300">To check if a seed value satisfies <span class="math">i+3j&gt;4,100</span>, the adversary has to do at least one cryptographic hash or VRF operation. Each round has committees for at most MaxSteps = 150 steps. For each round, only <span class="math">2/3</span> of those 150 (i.e., 100) committees can create a certificate (only those that vote in the first or second step in the Binary<span class="math">BA\\star</span> loop). So by union bound, the probability that a seed value gives <span class="math">i+3j&gt;4,100</span> for a specific round (and any step of that round) is <span class="math">\\simeq 2^{-93}</span>. So it is infeasible for the adversary to find such a seed.</p>

    <p class="text-gray-300">Notice that our argument above does not exclude the possibility that more than a single pair of round final committee has <span class="math">i</span> malicious members and a targeted Binary<span class="math">BA\\star</span> committee has <span class="math">j</span> malicious members, where <span class="math">i+3j=4,100</span>. Intuitively, however, if the adversary concentrates all of his computational power on finding a round (with highly malicious final committee to finalize block A) and a targeted step within that round (with a highly malicious committee to certify block B) such that <span class="math">i+3j=4,100</span>, then for all other rounds and steps, the number of malicious committee members is random, which makes the probability that the attacker succeeds in one of those round/step pairs negligible (<span class="math">&lt;10^{-20}</span>).</p>

    <p class="text-gray-300">More precisely, if the adversary targets two round/step pairs where <span class="math">i+3j&gt;3850</span>, then both of those pairs will have <span class="math">i+3j&lt;3950</span>. This is true, because the probability that <span class="math">i+3j&gt;3850</span> is approximately <span class="math">0.41\\cdot 10^{-18}</span>, while the probability that <span class="math">i+3j&gt;3950</span> is approximately <span class="math">0.6\\cdot 10^{-23}</span>, so the probability that both events happen for two specific round-step pairs is less than <span class="math">2.5\\cdot 10^{-41}</span>. Since for a specific selection seed there are <span class="math">R=10^{3}</span> rounds with <span class="math">10^{2}</span> steps each, there are <span class="math">\\binom{10^{2}\\cdot 10^{3}}{2}=\\frac{1}{2}10^{10}</span> possible pairs of round/step. The probability that the attacker manages to target more than one round/step where <span class="math">i+3j&gt;3950</span> is therefore, by union bound, less than <span class="math">2.5\\cdot 10^{-41}\\cdot 0.5\\cdot 10^{10}=1.25\\cdot 10^{-31}&lt;2^{-93}</span>, so it should never happen.</p>

    <p class="text-gray-300">In sum, the attacker has two strategies: (1) target one round and step within that round such that <span class="math">i+3j\\leq 4,100</span>, or (2) target multiple step/round pairs where <span class="math">i+3j\\leq 3950</span>. We next analyze these two strategies.</p>

    <p class="text-gray-300">Strategy 1: one round/step pair where <span class="math">i+3j\\leq 4100</span>. If the final step committee at round r’ has <span class="math">i</span> malicious members, then any other committee at the same round has at most <span class="math">\\frac{4100-i}{3}</span> malicious members. Clearly, the worst case is when <span class="math">i+3j=4100</span>. Thus, in order to prove that the probability of failure is <span class="math">10^{-7}</span>, we need to show that for all integral tuples <span class="math">(i,j)</span> on the line <span class="math">i+3j=4100</span>, the probability that both committees have enough users is less than <span class="math">10^{-7}</span>. Equivalently, for each integral value <span class="math">j</span> in the interval <span class="math">[0,\\frac{4100}{3}]</span>, we need to prove that for <span class="math">i=4100-3j</span>, the probability that both committees have enough honest members (i.e., the final committee has <span class="math">0.74\\cdot 10,000-i=7400-i</span> and the other committee has <span class="math">0.685\\cdot 2000-j=1370-j</span> honest members) is less than <span class="math">10^{-7}</span> (since <span class="math">T_{\\textsc{final}}=0.74</span>, <span class="math">\\tau_{\\textsc{final}}=1000</span> and <span class="math">T_{\\textsc{step}}=0.685</span>, <span class="math">\\tau_{\\textsc{step}}=2000</span>). For each integral value <span class="math">j\\in[0,\\frac{4100}{3}]</span> we did a separate calculation to prove that the desired probability always is less than <span class="math">10^{-7}</span>.</p>

    <p class="text-gray-300">We next describe the method used to upper-bound the probability for each tuple <span class="math">(i,j)=(4100-3j,j)</span>.</p>

    <p class="text-gray-300">Fix <span class="math">(i,j)</span>. The <span class="math">i</span> malicious votes go towards the final block <span class="math">A</span>, while the <span class="math">j</span> votes go towards certifying another block <span class="math">B</span>. So <span class="math">7400-i</span> more signatures are required for the final committee and <span class="math">1370-j</span> more signatures for the other committee. Let <span class="math">\\dot{A}</span> denote the set of honest users who would vote to approve block A as final (if completed Binary<span class="math">BA\\star</span> at the first step and selected to the final committee), and <span class="math">\\dot{B}</span> the set of honest users who would vote to certify another block B (<span class="math">\\neq A</span>) if they were in a committee and did not finish Binary<span class="math">BA\\star</span> at the first step. Clearly, <span class="math">\\dot{A}\\cap\\dot{B}=\\emptyset</span>. So each honest user eventually</p>

    <p class="text-gray-300">becomes a member of at most one of the two sets. For the 7400 and 1370 thresholds to both be reached, set <span class="math">\\dot{A}</span> must include <span class="math">7400-i</span> committee members for final, while set <span class="math">\\dot{B}</span> must include <span class="math">1370-j</span> committee members for another step.</p>

    <p class="text-gray-300">We say that an honest user “joins” set <span class="math">\\dot{A}</span> when that user counts sufficiently many (more than <span class="math">T_{\\text{STEP}}\\cdot\\tau_{\\text{STEP}}</span>) votes for <em>block_hash</em> to complete Binary<span class="math">BA\\star</span> in its first step. Else (after the first step of Binary<span class="math">BA\\star</span>), we say that the honest user “joins” set <span class="math">\\dot{B}</span>. Without strong synchrony, the network is under the attacker’s control, so the attacker can choose whether a user joins set <span class="math">\\dot{A}</span> or <span class="math">\\dot{B}</span> (by delivering votes to that user). This allows the attacker to get some feedback: if the attacker lets a user join set <span class="math">\\dot{A}</span>, then he can observe whether that user is selected to the final committee (i.e., see if that user votes). In this fashion the attacker can let users join set <span class="math">\\dot{A}</span> one by one until sufficiently many votes are produced to approve block A as final, and then join the rest of the honest users to set <span class="math">\\dot{B}</span>.</p>

    <p class="text-gray-300">Therefore, users join set <span class="math">\\dot{A}</span> in some order. Let <span class="math">n</span> be the size of <span class="math">\\dot{A}</span> when the users in set <span class="math">\\dot{A}</span> can, for the first time, produce <span class="math">7400-i</span> final step votes in the targeted round. Let <span class="math">H</span> be the total number of units of Algorand currency held by honest users; to simplify our proof, we assume that each user has exactly one unit of currency so <span class="math">H</span> is also the number of users (if a user has more than one unit, we consider that user to be represented by multiple “subusers” each with one unit of currency). For a fixed value of <span class="math">n</span>, at most <span class="math">H-n</span> users join set <span class="math">\\dot{B}</span>. For the attacker to succeed, these <span class="math">H-n</span> users must produce <span class="math">1370-j</span> votes for block B in the targeted step of Binary<span class="math">BA\\star</span>. Let <span class="math">P_{k}</span> denote the probability that: (1) <span class="math">n=k</span>, and (2) the remaining <span class="math">H-k</span> users in set <span class="math">\\dot{B}</span> produce 1370-j votes for block <span class="math">B</span>. <span class="math">P_{k}</span> is given by:</p>

    <p class="text-gray-300"><span class="math">P_{k}=Pr[n=k]Pr[\\text{the H-k users in </span>\\dot{B}<span class="math"> produce at least 1370-j votes}]=</span> <span class="math">Pr[n=k]\\sum_{c=1370-j}^{\\infty}Pr[\\text{the H-k users in </span>\\dot{B}<span class="math"> produce exactly c votes}]</span></p>

    <p class="text-gray-300">Using the formula in Equation 2 we can compute <span class="math">Pr[\\text{the H-k users in </span>\\dot{B}<span class="math"> produce exactly c votes}]</span>. The expected number of honest users selected for the committee in the set <span class="math">\\dot{B}</span> (which includes H-k users) is <span class="math">h\\cdot 2000\\cdot\\frac{H-k}{H}</span>, so for <span class="math">h=0.8</span> the expected number of users is <span class="math">1600\\cdot\\frac{H-k}{H}</span>. Therefore, the expression in Equation 3 equals to:</p>

    <p class="text-gray-300"><span class="math">Pr[n=k]\\left(\\sum_{c=1370-j}^{\\infty}\\frac{(1600\\frac{H-k}{H})^{c}}{c!e^{1600\\frac{H-k}{H}}}\\right)</span></p>

    <p class="text-gray-300">The adversary succeeds with probability <span class="math">\\sum_{k=0}^{H}P_{k}</span>, which is equal to:</p>

    <p class="text-gray-300"><span class="math">\\sum_{k=0}^{H}P_{k}=\\sum_{k=0}^{H}Pr[n=k]\\left(\\sum_{c=1370-j}^{\\infty}\\frac{(1600\\frac{H-k}{H})^{c}}{c!e^{1600\\frac{H-k}{H}}}\\right)</span></p>

    <p class="text-gray-300">The inner sum converges and can be evaluated. However, the outer sum iterates over total number amount of honest currency units which might be arbitrarily large. We therefore evaluate an upper bound:</p>

    <p class="text-gray-300"><span class="math">\\leq\\sum_{f=1}^{100}Pr\\left[\\frac{f-1}{100}H\\leq n\\leq\\frac{f}{100}H\\right]\\left(\\sum_{c=1370-j}^{\\infty}\\frac{(1600\\frac{H-\\frac{f-1}{100}H}{H})^{c}}{c!e^{1600\\frac{H-\\frac{f-1}{100}H}{H}}}\\right)</span></p>

    <p class="text-gray-300">The above is the upper Riemann sum of the integral of <span class="math">\\sum_{c=1370-j}^{\\infty}\\frac{(1600\\frac{H-\\frac{f-1}{100}H}{H})^{c}}{c!e^{1600\\frac{H-\\frac{f-1}{100}H}{H}}}</span> from 0 to <span class="math">H</span>, where the interval <span class="math">[0,H]</span> is partitioned into 100 equal parts. Since the function <span class="math">\\sum_{c=1370-j}^{\\infty}\\frac{(1600\\frac{H-k}{H})^{c}}{c!e^{1600\\frac{H-k}{H}}}</span> is decreasing in k, this is an upper bound. It is evaluated as follows:</p>

    <p class="text-gray-300"><span class="math">Pr\\left[\\frac{f-1}{100}H\\leq n\\leq\\frac{f}{100}H\\right]=</span> <span class="math">Pr[\\text{the </span>\\frac{f}{100}<span class="math">H honest users in </span>\\dot{A}<span class="math"> produce 7400-i votes}]-</span> <span class="math">Pr[\\text{the </span>\\frac{f-1}{100}<span class="math">H honest users in </span>\\dot{A}<span class="math"> produce 7400-i votes}]=</span> <span class="math">\\frac{(8000\\frac{f}{100})^{7400-i}}{(7400-i)!e^{8000\\frac{f}{100}}}-\\frac{(8000\\frac{f-1}{100})^{7400-i}}{(7400-i)!e^{8000\\frac{f-1}{100}}}</span></p>

    <p class="text-gray-300">Thus, the probability of failure is upper-bounded by the following formula, which can be computed:</p>

    <p class="text-gray-300"><span class="math">\\leq\\sum_{f=1}^{100}\\left(\\frac{(8000\\frac{f}{100})^{7400-i}}{(7400-i)!e^{8000\\frac{f}{100}}}-\\frac{(8000\\frac{f-1}{100})^{7400-i}}{(7400-i)!e^{8000\\frac{f-1}{100}}}\\right)\\left(\\sum_{c=1370-j}^{\\infty}\\frac{(1600(1-\\frac{f-1}{100})^{c}}{c!e^{1600(1-\\frac{f-1}{100})}}\\right)</span></p>

    <p class="text-gray-300">Strategy 2: multiple round/step pairs where <span class="math">i+3j\\leq 3950</span>. We first show that the adversary cannot target 3 round/step pairs, where the final committee has at least <span class="math">i</span> malicious members and the step committee has <span class="math">j</span> malicious members where <span class="math">i+3j&gt;3850</span>. This is because the probability of targeting one round/step pair where <span class="math">i+3j&gt;3850</span> is at most <span class="math">0.41\\cdot 10^{-18}</span>, so the probability to target three such pairs is <span class="math">(0.41\\cdot 10^{-18})^{3}&lt;10^{-51}</span>. For each selection seed there are <span class="math">R=10^{3}</span> rounds and each round has at most <span class="math">10^{2}</span> steps that the attacker can target (i.e. steps where <em>BinaryBA</em><span class="math">\\star</span> can conclude and certify a block). So we have at most <span class="math">10^{3}\\cdot 10^{2}</span> step committees set for every selection seed, therefore the number of step/round pairs that the attacker can target is <span class="math">\\binom{10^{2}\\cdot 10^{3}}{3}&lt;10^{15}</span>. The probability of attacker success is thus bounded by <span class="math">10^{15}\\cdot 10^{-51}=10^{-36}</span>. Thus, the attacker can have at most two pairs with <span class="math">i+3j&gt;3850</span>, in which case for both we will have <span class="math">i+3j&lt;3950</span>. This allows us to analyze the following two cases (within the above attacker strategy):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Two targeted round/step pairs where <span class="math">3850&lt;i+3j\\leq 3950</span>. It can be shown (with similar calculations to the case <span class="math">i+3j\\leq 4100</span>) that the probability of success for the adversary success is less than <span class="math">10^{-9}</span> for one targeted round/step pair, and therefore less than <span class="math">2\\cdot 10^{-9}</span> in total.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All round/step pairs have <span class="math">i+3j\\leq 3850</span>. It can be similarly shown that probability of success for the adversary is less than <span class="math">10^{-20}</span>. Since each round has at most <span class="math">10^{2}</span> steps and there are <span class="math">R=10^{3}</span> rounds set by the same selection seed, the attacker’s probability for success is bounded by <span class="math">10^{2}\\cdot 10^{3}\\cdot 10^{-20}=10^{-15}</span>.</li>

    </ul>

    <p class="text-gray-300">In conclusion, strategy 2 provides a lower attacker success rate than strategy 1, where the attacker’s success rate is bounded by <span class="math">10^{-7}</span> for every sequence of <span class="math">R=10^{3}</span> rounds. ∎</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">C.2. Liveness with strong synchrony</h3>

    <p class="text-gray-300">In this section we show that under the strong synchrony assumption, Algorand maintains liveness.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Under strong synchrony, all users will eventually reach consensus on a block. If the highest priority block proposer is honest, then all honest users reach final consensus on that block.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof of the liveness theorem above follows from several properties of <span class="math">BA\\star</span> under strong synchrony which we next prove. First, in Lemma 1, we show that under weak synchrony the CountVotes procedure (Algorithm 5) does not return two different non timeout values for two users in the same round and step. Second, we prove Theorem 2, which shows that this property of CountVotes guarantees that if a final block exists for an Algorand round, then no other block was agreed upon in that round. Third, given this property, we show, in Lemma 2, that if <span class="math">BA\\star</span> executed by an honest user returns that consensus was achieved on some value for a particular round, then for all other honest users <span class="math">BA\\star</span> indicates consensus on the same value. Fourth, in Lemma 3, we prove that <span class="math">BA\\star</span> executed by an honest user always eventually returns a value. Finally, in Lemma 4, we show that if all honest users called <span class="math">BA\\star</span> with the same value and round, then they all agree on that value for the round and furthermore, the consensus is final. ∎</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">The probability that CountVotes, called for the same round and step by two honest users, returns some value <span class="math">v_{1}\\neq\\mathit{timeout}</span> for one honest user, and returns a value <span class="math">v_{2}\\notin\\{\\mathit{timeout},v_{1}\\}</span> for another honest user is negligible.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Under strong synchrony, the two conditions about the committee from §7.5 (analyzed in §B.2) hold with overwhelming probability. Since CountVotes returned <span class="math">v_{1}\\neq\\mathit{timeout}</span> for an honest user, that user counted more than <span class="math">T_{\\textsc{step}}\\cdot\\tau_{\\textsc{step}}</span> votes for <span class="math">v_{1}</span> by committee members in the particular round and step of <span class="math">BA\\star</span>. In order to cross the <span class="math">T_{\\textsc{step}}\\cdot\\tau_{\\textsc{step}}</span> threshold <span class="math">v_{1}</span> must receive more than half of the honest committee members’ votes. We select a committee large enough such that the safety condition, <span class="math">\\frac{1}{2}\\#\\mathit{good}+\\#\\mathit{bad}\\leq T_{\\textsc{step}}\\cdot\\tau_{\\textsc{step}}</span>, holds with overwhelming probability. Since honest committee members only vote for one value, then when the safety condition holds, no other value <span class="math">v_{2}</span> can receive enough votes. ∎</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Under strong synchrony, if an honest user completes <span class="math">BA\\star</span> for round <span class="math">r</span> with consensus on value <span class="math">v</span>, then all honest users complete <span class="math">BA\\star</span> for round <span class="math">r</span> with the same value.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Under strong synchrony, we assume that all users are in consensus on the block for round <span class="math">r-1</span> (if there was a fork due to an earlier non-strongly-synchronous period, the fork resolution protocol in §8 has resolved it). In this case, the Reduction procedure (Algorithm 7) returns for each honest user one of two values: either the empty block’s hash, which is completely determined by the previous block and therefore the same for all users, or the Reduction procedure returns the same block_hash (applying Lemma 1 we observe that only a single value can cross the threshold for CountVotes in the first step of the reduction, and hence only a single value different than the hash of the empty block is possible).</p>

    <p class="text-gray-300">Since <span class="math">BA\\star</span> returns consensus on what Binary<span class="math">BA\\star</span> returns, it is sufficient to show that if Binary<span class="math">BA\\star</span> returns for an honest user with a value <span class="math">v</span>, then it does so for all other honest users.</p>

    <p class="text-gray-300">Without loss of generality, let us assume that a user completed Binary<span class="math">BA\\star</span> with block_hash. Therefore the CountVotes procedure called by that user with round <span class="math">r</span> and step 1 (mod 3) returned block_hash. By Lemma 1 other users have either concluded that step with block_hash too, or with timeout. Therefore, all honest users who did not finish the protocol in that step will next vote for block_hash (since the step index was 1 mod 3). The users who completed the protocol will gossip all the votes they received for block_hash.</p>

    <p class="text-gray-300">In the following step (indexed 2 mod 3), since all honest users who timed out in the previous step (and therefore did not finish) will vote block_hash, the CountVotes procedure called by any honest user will return block_hash. Furthermore, honest committee members for this step, who finished in the previous step, have also sent their votes. Therefore, since we select a committee sufficiently large such that with high probability <span class="math">\\#\\mathit{good}&gt;T_{\\textsc{step}}\\cdot\\tau_{\\textsc{step}}</span>, CountVotes will return block_hash. This consensus will carry forward until the next step indexed 1 mod 3, where all users will agree on block_hash. ∎</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Under strong synchrony, Algorand eventually confirms a block in each round.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Algorand confirms a block when <span class="math">BA\\star</span> reaches consensus. It is sufficient to show that Binary<span class="math">BA\\star</span> eventually reaches consensus, which implies that <span class="math">BA\\star</span> also reaches consensus, since the rest of <span class="math">BA\\star</span> has a limited number of steps.</p>

    <p class="text-gray-300">By Lemma 2, it is sufficient to show that only one honest user confirms a block (since the rest will finish after that user within at most 3 steps). Let us consider the steps of <span class="math">BA\\star</span> in sequences of three, as in one loop iteration in Algorithm 8. So if an honest user finished Binary<span class="math">BA\\star</span> in the first two steps, we are done.</p>

    <p class="text-gray-300">Let us assume that this is not the case, and therefore, all honest users reach the third “common coin” step of Binary<span class="math">BA\\star</span>. If in that step all honest users receive more</p>

    <p class="text-gray-300">than <span class="math">T_{\\textsc{step}}\\cdot\\tau_{\\textsc{step}}</span> votes for value <span class="math">v</span> (one of two possible options), then they will all vote for that value in the next steps, and reach consensus on that value within the next two steps.</p>

    <p class="text-gray-300">Let us now assume the complementary case, that at least some honest users change their vote according to the common coin. Assume further that the user setting the coin (according to Algorithm 9) is honest; therefore, all honest users who did not observe sufficiently many votes for a value <span class="math">v</span> in the coin step see the same random coin and change their vote to that coin (since the network is strongly synchronous, all honest users receive messages within a bounded delay). Therefore, there are only three cases to consider:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Some honest users counted enough votes for block_hash and the rest observe the coin. In this case at the end of the coin step, all honest users will vote for block_hash if the common coin is 0 (that is, with probability 1/2).</li>

      <li>Some honest users counted enough votes for empty_block and the rest observe the coin. In this case at the end of the coin step, all honest users will vote for empty_hash if the common coin is 1 (that is, with probability 1/2).</li>

      <li>All honest users observe the coin. In this case all honest users will vote for the common coin. The agreement will carry forward until Binary<span class="math">BA\\star</span> completes in the next two steps.</li>

    </ul>

    <p class="text-gray-300">Importantly, the case where some honest users counted enough votes for empty_block while others counted enough votes for block_hash has negligible probability. See Lemma 1.</p>

    <p class="text-gray-300">Therefore, if the user setting the coin is honest, we reach consensus with probability of at least 1/2. Since the user setting the coin is selected at random out of the committee, and in the committee at least 2/3 of the members are honest, then the probability of reaching consensus is at least <span class="math">\\frac{1}{2}\\cdot\\frac{2}{3}=\\frac{1}{3}</span>. Since the probability of reaching consensus in every sequence of 3 steps is greater than 0, the protocol eventually reaches consensus. ∎</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Under strong synchrony, if all honest users start <span class="math">BA\\star</span> with the same value for the same round, then they reach a final consensus on that value.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let us follow the <span class="math">BA\\star</span> protocol and show that this is correct. All honest users will call the reduction with the same hash of the block, call it block_hash. Therefore in the first step of the reduction all honest users will count more than a threshold votes for block_hash, and will also vote for it in the second step of the reduction, where they will again count more than a threshold of votes for block_hash, and therefore all honest users will call Binary<span class="math">BA\\star</span> with block_hash and return after exactly one step, and therefore also vote on block_hash as a final consensus. ∎</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">C.3. Efficiency</h3>

    <h6 id="sec-66" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Under strong synchrony, <span class="math">BA\\star</span> reaches final consensus in 4 steps if the highest priority block proposer was honest, and otherwise is expected to reach consensus in 13 steps. The probability Binary<span class="math">BA\\star</span> does not complete within MaxSteps = 150 steps even in the worst case is negligible (<span class="math">&lt;3\\cdot 10^{-9}</span>).</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The first part of the theorem (reaching fast and final consensus when the highest priority block proposer is honest) was shown in Lemma 4. We focus on the second part, that <span class="math">BA\\star</span> is expected to reach consensus within 13 steps in the worst case.</p>

    <p class="text-gray-300">Let us analyze the probability that the common coin leads to consensus. The binary-agreement phase of <span class="math">BA\\star</span> consists of three repeated steps. A malicious highest-priority block proposer can make the first two steps of Binary<span class="math">BA\\star</span> go without consensus, but after every “common coin” step, the honest users will reach consensus with probability 1/3 in the following two steps (see Lemma 3). Therefore, following the first 2 steps, every sequence of three steps reaches consensus with probability 1/3. Thus, in total, binary-agreement requires an expected number of <span class="math">2+3*3=11</span> steps in the worst case, and <span class="math">BA\\star</span> has two extra initial steps for the reduction to binary-agreement, i.e., expected 13 steps in total.</p>

    <p class="text-gray-300">Since in each sequence of 3 steps of Binary<span class="math">BA\\star</span> (except the first iteration), it holds that <span class="math">BA\\star</span> reaches consensus with probability 1/3, then after MaxSteps = 150 steps is <span class="math">\\frac{2}{3}^{\\frac{150}{3}-1}&lt;3\\cdot 10^{-9}</span>. ∎</p>`;
---

<BaseLayout title="Algorand: Scaling Byzantine Agreements for Cryptocurrencies (2017/454)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/454
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
