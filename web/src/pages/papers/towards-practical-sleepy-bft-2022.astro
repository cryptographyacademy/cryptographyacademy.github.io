---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1448';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Towards Practical Sleepy BFT';
const AUTHORS_HTML = 'Dahlia Malkhi, Atsuki Momose, Ling Ren';

const CONTENT = `    <p class="text-gray-300">Dahlia Malkhi†, Atsuki Momose*, and Ling Ren‡</p>

    <p class="text-gray-300">†Chainlink Labs ‡University of Illinois at Urbana-Champaign</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Bitcoin’s longest-chain protocol pioneered consensus under dynamic participation, also known as sleepy consensus, where nodes do not need to be permanently active. However, existing solutions for sleepy consensus still face two major issues, which we address in this work. First, existing sleepy consensus protocols have high latency (either asymptotically or concretely). We tackle this problem and achieve <span class="math">4\\Delta</span> latency (<span class="math">\\Delta</span> is the bound on network delay) in the best case, which is comparable to classic BFT protocols without dynamic participation support. Second, existing protocols have to assume that the set of corrupt participants remains fixed throughout the lifetime of the protocol due to a problem we call <em>costless simulation</em>. We resolve this problem and support growing participation of corrupt nodes. Our new protocol also offers several other important advantages, including support for arbitrary fluctuation of honest participation as well as an efficient recovery mechanism for new active nodes.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Byzantine fault-tolerant (BFT) consensus, a decade-old problem in distributed computing and cryptography, allows a group of nodes to reach an agreement in the presence of corrupted nodes <em>[26, 34]</em>. Traditional consensus research has mainly focused on the static participation model where all honest nodes remain active throughout the execution <em>[9, 24]</em>. The celebrated Bitcoin protocol <em>[30]</em> pioneered consensus in a dynamic participation model, enabling nodes to switch between active and inactive states spontaneously without any prior notice. Furthermore, participants do not need to know how many other participants are currently active in the system. This dynamic and unknown participation model was later formalized as the <em>sleepy model</em> <em>[33]</em>. The sleepy model allows an arbitrary subset of <span class="math">n_{t}</span> nodes out of a total of <span class="math">N</span> eligible participants to be active at any given time <span class="math">t</span>. The status of active/inactive can be determined arbitrarily by an adversary, making the participation dynamic and unknown.</p>

    <p class="text-gray-300">Inspired by Bitcoin’s <em>longest-chain</em> protocol, there have been many recent proposals employing the longest-chain paradigm for the sleepy model <em>[33, 15, 12]</em>. However, all of these protocols face two major problems, which we highlight in this work.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Problem 1: Latency.</h6>

    <p class="text-gray-300">A notable drawback of the longest-chain paradigm has been its long latency. The latency of Nakamoto’s longest-chain protocol depends on several factors, including the security parameter and the actual level of participation <em>[32, 35]</em>. Substantial effort has been made to remove these dependencies <em>[6, 21, 27, 23]</em>, culminating in the work of Momose-Ren <em>[29]</em> that achieves constant latency. However, despite being asymptotically optimal, the concrete latency of Momose-Ren is still quite large. Specifically, its latency</p>

    <p class="text-gray-300">is at least <span class="math">16\\Delta</span> (where <span class="math">\\Delta</span> is the bound on network delay). This is much slower than classic BFT protocols operating under the static participation model, which can make decisions within <span class="math">\\Delta</span> time <em>[3]</em>.</p>

    <p class="text-gray-300">Our first result is to address this issue and achieve concretely small latency in the sleepy model. Specifically,</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">Assuming a verifiable random function (VRF) and public-key infrastructure (PKI), there exists an atomic broadcast protocol with (best-case) <span class="math">4\\Delta</span> latency in the sleepy model where up to <span class="math">f_{t}&lt;n_{t}/2</span> corrupt nodes are active at any given time <span class="math">t</span>.</p>

    <p class="text-gray-300">Following prior works, we focus on the atomic broadcast problem <em>[11]</em>, i.e., achieving consensus on a linearizable log.</p>

    <p class="text-gray-300">The core ingredient of our protocol is a new construction in the classic view-based approach to BFT atomic broadcast. We construct each view from the composition of a graded proposal election (GPE) and a sequence of graded agreements (GA). We observe that most classic construction puts the decision at the end of each view after sequential invocations of GA, and this introduces a large latency. We instead push back most of the tasks done by the sequential GAs and make a decision earlier after minimum steps (in GPE). This results in a significant improvement in the best-case latency.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Problem 2:</h6>

    <p class="text-gray-300">Costless simulation. Besides latency, another major limitation of previous sleepy consensus protocols (without proof-of-work) do not allow dynamic participation of corrupt nodes. The Bitcoin protocol allows both honest and corrupt nodes to fluctuate dynamically as long as there is an honest majority. However, once we remove the computationally expensive proof-of-work, we lose the crucial property that computational effort is not reusable. Because of this, the original sleepy model <em>[33]</em> by Pass-Shi assumes stable participation of corrupt nodes. To elaborate, at each point in time <span class="math">t</span>, they allow a maximum of <span class="math">f_{t}=O(n)</span> active corrupt nodes where <span class="math">n</span> represents the minimum count of active nodes throughout the entire execution. In other words, even if the overall (honest plus corrupt) participation level fluctuates tremendously throughout the execution, the count of corrupt participants must always be bounded by the minimum participation level rather than the current level. This assumption is hard to justify in practice. Suppose only dozens of nodes were active in the beginning, but a million nodes are active a few years later when a system attains widespread recognition. Even at that later time, the number of corrupt nodes must be limited to a few dozen out of the one million nodes!</p>

    <p class="text-gray-300">This problem arises due to an attack known as <em>costless simulation</em> <em>[16]</em>. To elaborate, when a corrupt node becomes active, it can pretend to have always been active in the past. It can fabricate messages that were supposed to be sent when it was not active in an attempt to alter the consensus results in the past. Our protocol tackles this problem and accommodates growing corrupt participation proportional to the active participation level (formalized in Section 2).</p>

    <p class="text-gray-300">Other advantages. Along the way, we also offer several other advantages elaborated below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>We introduce a novel technique to eliminate the assumption of eventual stable participation, a requirement for ensuring liveness in Momose-Ren. Intuitively, their protocol assumes that eventually, a large fraction of active nodes stays active for a certain period of time to make progress. In contrast, our protocol advances consistently even under arbitrary churn in active participants, offering guarantees akin to those of longest-chain protocols.</li>

      <li>The original sleepy model by Pass-Shi assumes that nodes upon waking up receive all past messages including those sent during their sleep, which is impractical. Momose-Ren addresses this issue by introducing a concrete recovery mechanism for newly active nodes to retrieve only essential messages from other active nodes. However, in Momose-Ren, nodes are required to recover messages from the past <span class="math">\\Omega(\\kappa)</span> rounds (besides the log contents) where <span class="math">\\kappa</span> is a security parameter. Moreover, the recovery protocol introduces additional overhead to the main protocol, resulting in an increased latency of at least <span class="math">19\\Delta</span>. In contrast, our recovery protocol mandates nodes to recover messages from only the constant number of past rounds (in fact less than a dozen). This protocol also avoids introducing any additional latency.</li>

    </ul>

    <p class="text-gray-300">Organization. The rest of this paper is organized as follows. After defining the model and some primitives in Section 2, we provide the overview of our protocol in Section 3. We present our graded agreement (GA) protocol in Section 4 graded proposal election protocol (GPE) in Section 5. Then, building on the GA and GPE protocols, we present our atomic broadcast protocol in Section 6. Finally, we review some related works in Section 8 and conclude this paper with some future works in Section 9.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Model and Definitions</h2>

    <p class="text-gray-300">We consider a system comprising a total of <span class="math">N</span> nodes communicating over a synchronous network. Note that network synchrony is necessary for consensus in the sleepy model <em>[33]</em>. <span class="math">\\Delta</span> represents the bound on communication delay. For simplicity, we assume the existence of a perfectly synchronous clock, meaning nodes share access to a common global clock. We can extend our results to accommodate a model with bounded clock skew by applying the round transformation technique in <em>[29]</em> (with a minor increase in latency). We assume the communication channel is <em>unauthenticated</em>, implying that the origin of any message is unknown to nodes. Let <span class="math">\\kappa</span> denote the security parameter. We assume an adaptive adversary that can corrupt nodes anytime during an execution. Corrupt nodes exhibit arbitrary behavior under the control of an adversary. Any non-corrupt node is said to be <em>honest</em> and behave as instructed by the protocol.</p>

    <p class="text-gray-300">The sleepy model. Our protocol operates in an extended sleepy model that accommodates the dynamic participation of corrupt nodes. Let us begin by briefly reviewing the original sleepy model introduced by Pass-Shi <em>[33]</em>. In this model, nodes exist in one of two states: <em>awake</em> or <em>asleep</em>. Awake nodes actively engage in the execution, while asleep nodes neither execute any code nor send/receive any message. The count of awake nodes at any given time <span class="math">t</span> is represented as <span class="math">0&lt;n_{t}\\leq N</span>. At each time point, the status of each node can change at the adversary’s control without any prior notice. Regarding the message delivery, the assumption is that if an honest node <span class="math">p</span> is awake at time <span class="math">t</span>, then <span class="math">p</span> must have received all messages sent to it by other honest nodes prior to time <span class="math">t-\\Delta</span>. However, as pointed out in <em>[29]</em>, this message delivery assumption is not realistic. It essentially assumes all past messages are magically buffered until the recipient comes back awake. We will eliminate this assumption in Section 6.3 where we introduce our recovery mechanism.</p>

    <p class="text-gray-300">Dynamic participation of corrupt nodes. Now let us delve into the dynamic participation of corrupt nodes and clarify the difference between the original sleepy model and our extended version. The original sleepy model, while allowing arbitrary churn among honest nodes, imposes a strong restriction on the dynamic participation of corrupt nodes. Precisely, the count of active corrupt nodes is capped at <span class="math">n/2</span> where <span class="math">n</span> is the minimum count of active nodes throughout the entire execution, essentially disallowing any fluctuation in the corrupt node’s participation. This stems from the costless simulation problem, wherein corrupt nodes can fabricate past messages during their inactive period.</p>

    <p class="text-gray-300">We address part of this issue and manage to allow corrupt nodes’ participation to grow proportionally to the current overall participation level. Formally, we measure corrupt nodes’ participation in the following way. Let <span class="math">\\mathcal{F}_{t}</span> be the set of corrupt nodes awake at time <span class="math">t</span>, and define</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f(t,T_{f},T_{b})=\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\bigcup_{t-T_{f}\\leq\\tau\\leq t+T_{b}}\\mathcal{F}_{\\tau}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say an execution is admissible in the <span class="math">(T_{f},T_{b},\\alpha)</span>-sleepy model if for all <span class="math">t\\geq 0</span></p>

    <p class="text-gray-300"><span class="math">f(t,T_{f},T_{b})&lt;\\alpha n_{t}.</span></p>

    <p class="text-gray-300">In other words, a corrupt node is counted as an active corrupt node for an extra <span class="math">T_{f}</span> time forward and an extra <span class="math">T_{b}</span> time backward beyond the time interval it is actually active. This essentially acknowledges that the protocol cannot effectively defeat costless simulation within that duration other than considering the corrupt node active in that duration. On the other hand, any simulation outside of this time frame must be tolerated by the protocol.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">For example, the original sleepy model can be described as the <span class="math">(\\infty,\\infty,1/2)</span>-sleepy model, and protocols in this model essentially are not tolerant to any backward or forward simulations. Bitcoin works in the <span class="math">(0,0,1/2)</span>-sleepy model because any simulation is costly due to the non-reusable property of proof-of-works.</p>

    <p class="text-gray-300">Our protocol is designed to operate in the <span class="math">(\\infty,T_{b},1/2)</span>-sleepy model with <span class="math">T_{b}=O(\\Delta)</span>. In other words, we are still unable to tolerate forward simulation because a corrupt node can simply give its secret key to the adversary before going to sleep. However, we prevent backward simulation for the most part. This allows the number of active corrupt nodes to grow proportionally to the overall participation, albeit with a slight delay of <span class="math">T_{b}=O(\\Delta)</span>. Further insight into these parameters will be provided in Section 3.3.</p>

    <p class="text-gray-300">Atomic broadcast. An atomic broadcast protocol <em>[11]</em> allows nodes to agree on a linearizable log. Specifically, nodes input a finite set of values and decide on a growing sequence of values <span class="math">[x_{0},x_{1},x_{2},...]</span> called a <em>log</em>. The protocol provides the following guarantees:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Safety</em>. If two honest nodes decide logs <span class="math">[x_{0},..,x_{j}]</span> and <span class="math">[x_{0}^{\\prime},..,x_{j^{\\prime}}^{\\prime}]</span>, then <span class="math">x_{i}=x_{i}^{\\prime}</span> for all <span class="math">i\\leq\\min\\{j,j^{\\prime}\\}</span>.</li>

      <li><em>Liveness</em>. If an awake honest node inputs a value <span class="math">x</span> at time <span class="math">t</span>, then there is a time <span class="math">t^{\\prime}\\geq t</span> s.t. all awake honest nodes at any time after <span class="math">t^{\\prime}</span> decide a log containing <span class="math">x</span>.</li>

    </ol>

    <p class="text-gray-300">Here, we do not specify what the values are. It might be from a finite class depending on the application built on top of the atomic broadcast.</p>

    <p class="text-gray-300">Latency of atomic broadcast. We define latency as the time needed for a value input by an honest node to get decided. Namely, suppose an honest node inputs a value <span class="math">x</span> at time <span class="math">t</span>, and an honest node decides a log that includes the value <span class="math">x</span> for the first time at time <span class="math">t^{\\prime}</span>. In this context, the latency for deciding the value <span class="math">x</span> is <span class="math">t-t^{\\prime}</span>. This paper primarily focuses on the <em>best-case</em> latency, representing the shortest possible latency, typically when all nodes behave honestly.</p>

    <p class="text-gray-300">Cryptographic assumptions. We make use of digital signatures with a public-key infrastructure (PKI). We use <span class="math">\\langle\\mu\\rangle_{p}</span> to denote a message <span class="math">\\mu</span> signed by node <span class="math">p</span>. We assume a cryptographic hash function denoted <span class="math">\\mathsf{H}(\\cdot)</span>. We also assume a verifiable random function (VRF). A node <span class="math">p</span> with its secret key can evaluate <span class="math">(\\rho,\\pi)\\leftarrow\\mathsf{VRF}_{p}(\\mu)</span> on any input <span class="math">\\mu</span>. The output is a deterministic pseudorandom value <span class="math">\\rho</span> along with a proof <span class="math">\\pi</span>. Using <span class="math">\\pi</span> and the public key of node <span class="math">p</span>, anyone can verify whether <span class="math">\\rho</span> is a correct evaluation of <span class="math">\\mathsf{VRF}_{p}</span> on input <span class="math">\\mu</span>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Definitions and Primitives</h3>

    <p class="text-gray-300">We define some primitives and notions we will use in our protocol.</p>

    <p class="text-gray-300">Blocks. As commonly done in recent BFT protocols, we employ the concept of <em>block</em>. In our protocol, a batch of values are grouped into a block. Each block contains a hash reference pointing to another block, forming a hash chain. The last block in the chain (i.e., without a hash reference) is called <em>genesis block</em> and is denoted as <span class="math">B_{0}=(\\bot,\\bot,0)</span>. The <em>height</em> of a block represents its position in the chain, measured as the distance from the genesis block. The block of height <span class="math">k</span> is formatted as</p>

    <p class="text-gray-300"><span class="math">B_{k}:=(b_{k},\\mathsf{H}(B_{k-1}),v)</span></p>

    <p class="text-gray-300">where <span class="math">b_{k}</span> is the batch of values in this block and <span class="math">\\mathsf{H}(B_{k-1})</span> is the hash reference to the preceding block <span class="math">B_{k-1}</span>. Any block <span class="math">B_{k}</span> uniquely defines a chain <span class="math">B_{0}\\ldots B_{k}</span>, and hence a unique log. We say a block <span class="math">B_{k}</span> <em>extends</em> <span class="math">B_{l}</span> (<span class="math">k\\geq l</span>) if <span class="math">B_{k}=B_{l}</span> or <span class="math">B_{l}</span> is the ancestor of <span class="math">B_{k}</span> in the chain (i.e., there is a path from <span class="math">B_{k}</span> to <span class="math">B_{l}</span>). We say two blocks <span class="math">B_{k}</span> and <span class="math">B_{l}</span> <em>conflict</em> with each other if neither of them extends the other. The last element <span class="math">v</span> is an integer called <em>view</em> number. Intuitively, the view number identifies when the block was created (we will elaborate more later). We say the block <span class="math">B_{k}</span> is of view <span class="math">v</span> and use the notation <span class="math">\\mathsf{view}(B)</span> to denote the view of block <span class="math">B</span>. We say the block <span class="math">B_{k}</span> is <em>valid</em> if the preceding block <span class="math">B_{k-1}</span> is valid and is of view <span class="math">v^{\\prime}&lt;v</span>. In other words, the view numbers in any valid chain must be strictly increasing.</p>

    <p class="text-gray-300">Graded agreement (GA). We use a primitive called graded agreement (GA), which is also used in Momose-Ren <em>[29]</em> and is similar to <em>gradecast</em> <em>[24]</em>. Each node takes as input a block <span class="math">B</span> and outputs a set of blocks along with <em>grades</em>. More specifically, at the end of the protocol, each node outputs a set of pairs <span class="math">(B,g)</span> of a block <span class="math">B</span> and a grade bit <span class="math">g\\in\\{0,1\\}</span>, subject to the following constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Graded delivery</em>. If an honest node outputs <span class="math">(B,1)</span>, then all honest nodes output <span class="math">(B,*)</span>.</li>

      <li><em>Integrity</em>. If an honest node outputs <span class="math">(B,*)</span>, then at least an honest node has input <span class="math">B^{\\prime}</span> extending <span class="math">B</span>.</li>

      <li><em>Validity</em>. Let <span class="math">B</span> be the highest block that every honest node’s input extends. Then, all honest nodes output <span class="math">(B,1)</span>.</li>

    </ul>

    <p class="text-gray-300">Note that the standard GA (also adopted in <em>[29]</em>) is defined for values, but we extend it to chained blocks. We also note that we do not have any <em>consistency</em> guarantee for outputs. In other words, nodes (even a single node) can output multiple conflicting blocks.</p>

    <p class="text-gray-300">Graded proposal election (GPE). We introduce a primitive called <em>graded proposal election</em>, which resembles the composition of a leader/proposal election and a graded agreement. In GPE, nodes propose their own blocks <span class="math">B</span> and elect a single block with grades. At the end of the protocol, each node outputs a <em>single</em> pair <span class="math">(B,g)</span> of a block <span class="math">B</span> (or <span class="math">B=\\bot</span>) and a grade bit <span class="math">g\\in\\{0,1\\}</span> with the following constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Consistency</em>. If two honest nodes output <span class="math">(B,<em>)</span> and <span class="math">(B^{\\prime},</em>)</span> for <span class="math">B,B^{\\prime}\\neq\\bot</span>, then <span class="math">B=B^{\\prime}</span>.</li>

      <li><em>Graded delivery</em>. If an honest node outputs <span class="math">(B,1)</span>, then all honest nodes output <span class="math">(B,*)</span>.</li>

      <li><em>Validity</em>. With a probability of more than <span class="math">1/2</span>, all honest nodes output <span class="math">(B,1)</span> where <span class="math">B</span> is inputted by an honest node.</li>

      <li><em>Integrity</em>. If an honest node outputs <span class="math">(B,<em>)</span>, then the block <span class="math">B</span> is </em>permissible* for at least an honest node.</li>

    </ul>

    <p class="text-gray-300">Here, the criterion for a block to be considered <em>permissible</em> for a node is defined externally. It is important to note that there is a case that a block is permissible for one node but not for others.</p>

    <p class="text-gray-300">Intuitively, with a probability of more than <span class="math">1/2</span>, all honest and awake nodes will output the same honest node’s input with grade 1. For the remaining less than <span class="math">1/2</span> probability, GPE still guarantees consistency in the sense at most one proposal is output, albeit not by all honest and awake nodes since some of them may output <span class="math">\\bot</span>. Furthermore, the block must pass an external safety check (be permissible) by at least one honest node, which helps eliminate unsafe proposals from corrupt nodes.</p>

    <p class="text-gray-300">As mentioned, GPE resembles and can be implemented with, a composition of a leader election and a GA. However, we will directly implement a GPE that is more efficient.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Overview</h2>

    <p class="text-gray-300">In this section, we present an overview of this work to elaborate on the technical details.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.1 View-based BFT with Early Decision</h3>

    <p class="text-gray-300">At a high level, we follow the classic view-by-view construction that is employed by most mainstream BFT protocols <em>[19, 9, 24, 8, 37, 1, 2]</em> as well as the latest sleepy consensus of Momose-Ren <em>[29]</em>. This paradigm is useful in achieving expected constant round latency. Specifically, the protocol progresses through a series of <em>views</em>, each possessing a fixed duration wherein one block is decided. View-based protocols in general (including non-sleepy protocols) involve (often implicitly) sequential invocations of a graded agreement (or a primitive with similar guarantees) and decide a block when all of the GAs from the initial to the final succeed. However, this approach brings a notable latency overhead, especially in the sleepy model, as each GA takes a few more rounds. For example, Momose-Ren involves five consecutive GAs, resulting in a latency of <span class="math">16\\Delta</span> at the minimum. To resolve this bottleneck, we introduce a new construction of each view. The high-level</p>

    <p class="text-gray-300">Each node in view <span class="math">v</span> runs the following steps if it is awake. Let <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> and <span class="math">\\mathsf{GA}_{v}</span> be the two graded agreements for view <span class="math">v</span>.</p>

    <p class="text-gray-300">GPE. Input to GPE a block <span class="math">B</span> extending <em>candidate</em>: the highest grade-0 output from <span class="math">\\mathsf{GA}_{v-1}</span>. A block is considered <em>permissible</em> within GPE if it extends <em>lock</em>: the highest grade-1 output from <span class="math">\\mathsf{GA}_{v-1}</span>.</p>

    <p class="text-gray-300">Decide. If GPE outputs <span class="math">(B,1)</span>, decide on <span class="math">B</span>.</p>

    <p class="text-gray-300">GA1. Each node inputs to <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> the output <span class="math">B</span> from GPE (with any grade) if <span class="math">B\\neq\\bot</span>, otherwise input <em>lock</em>.</p>

    <p class="text-gray-300">GA2. Each node inputs to <span class="math">\\mathsf{GA}_{v}</span> the highest block <span class="math">B</span> s.t. <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> has outputted <span class="math">B</span> with grade <span class="math">g=1</span> and has not output (with either grade) any block conflicting with <span class="math">B</span>.</p>

    <p class="text-gray-300"><em>lock, candidate</em> are initialized to the genesis block <span class="math">B_{0}</span>.</p>

    <p class="text-gray-300">Figure 1: Summary of each view of our atomic broadcast protocol (simplified).</p>

    <p class="text-gray-300">idea is that we can push back most of the tasks done by the sequential GAs to make a decision earlier. Concretely, we observe that we can instantiate a view from a composition of a GPE and two sequential GAs as outlined in Figure 1. The GPE performs the minimum task to make a safe decision within the view, and the latter two GAs resolve all other works to maintain safety and liveness across all views. This way, our protocol can decide on a block immediately after the GPE in the best case, taking <span class="math">4\\Delta</span>. We elaborate more on how our protocol maintains safety and liveness below.</p>

    <p class="text-gray-300">Each view starts with a graded proposal election (GPE), and a grade-1 output from GPE is decided. Again, the crucial role of the GPE is to converge on a unique proposal. The consistency of GPE ensures that two distinct blocks cannot be decided simultaneously in the same view, thereby guaranteeing safety within a view. To maintain safety across views, we want to make all nodes <em>lock</em> on the decided block and discard any block conflicting with the lock in the subsequent views. To this end, the subsequent GAs resolve which block has possibly been decided by other nodes. Specifically, grade-0 output from GPE is handed over to the GAs, and grade-1 output from the second GA is locked. The graded delivery of GPE says, that if one node decides on a grade-1 output from GPE, then all other nodes at least output the same block with grade-0 from GPE. Thus, they input the block to the GAs. The validity of GA makes sure all nodes output this block with grade 1 and thus lock on this decided block. Lastly, any blocks conflicting with the locked block are deemed impermissible during the GPE and are discarded.</p>

    <p class="text-gray-300">Now we also need to ensure liveness when some nodes lock on a block. It is important that other nodes extend this locked block in their proposals in later views; otherwise, honest nodes might discard an honest node’s proposal. To this end, a grade-0 output from the second GA is set to <em>candidate</em>, and each node in the next view proposes a block extending the candidate. The graded delivery of GA makes sure that when some nodes lock on a block (by outputting from GA with grade 1), all other nodes at least output the same block with grade 0 from GA, so they will always set the locked block (or its descendant) as their candidates.</p>

    <p class="text-gray-300">So far, we have only mentioned the role of the second GA. In fact, the second GA plays the primary role in maintaining safety and liveness across views. However, one missing aspect in the above is that a single GA can output conflicting blocks (recall that GA does not guarantee consistency). Therefore, a single GA does not guarantee that nodes lock on a unique block. The goal of the first GA is to prevent conflicting outputs from the second GA. We will provide further details in Section 6.</p>

    <p class="text-gray-300">Comparison with PBFT. We can get more intuition by drawing some analogy to classic view-based BFT designs. The <em>decide-lock</em> relation and the <em>lock-candidate</em> relation that we employ are in fact two pillars of classic view-based BFT protocols <em>[37, 9]</em>. In more detail, if a block is decided, then all (or supermajority) other nodes must lock on the block to safeguard it from conflicting decisions in later views. For liveness, if a block is locked, all (or supermajority) other nodes must recognize the block as the candidate of their future proposals. We observe that our construction is somewhat similar to the classic PBFT-style construction</p>

    <p class="text-gray-300">with a main path for decision followed by a view-change sub-protocol to resolve conflict across views. The GPE and GA can be viewed as the main path and the view-change, respectively.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.2 Graded Agreement without Stable Participation Requirement</h3>

    <p class="text-gray-300">Another key technical contribution is a new construction of graded agreement (GA) summarized in Figure 2. Our GA protocol builds on the GA protocol introduced by Momose-Ren but eliminates their reliance on the <em>eventual stable participation</em> assumption. For ease of exposition, let us consider a GA on binary values, i.e., <span class="math">B\\in\\{0,1\\}</span>, instead of blocks.</p>

    <p class="text-gray-300">Time-shifted quorum <em>[29]</em>. Our starting point is the <em>time-shifted quorum</em> idea introduced by Momose-Ren. Let us briefly review the original time-shifted quorum construction as a warm-up. First note that in the classic static participation model, achieving the graded delivery guarantee is trivial: forwarding a predefined quorum of votes is sufficient. When a node receives a quorum of votes (to obtain a grade-1 output), the node forwards these votes to all other nodes. All other nodes receive the quorum of votes one round later and output with grade <span class="math">g=0</span>. In the sleepy model, however, the quorum threshold (e.g., “majority”) is not predefined but rather depends on the “perceived” participation level of each node. The above quorum forwarding approach obviously breaks down because a quorum of votes is no longer <em>transferable</em>. In other words, a set of votes may be accepted as a quorum by one node but may not meet the quorum threshold for another node. To address this challenge, Momose-Ren introduced the following time-shifted quorum technique.</p>

    <p class="text-gray-300">Nodes send their inputs with “echo” messages at time <span class="math">t=0</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">E_{1}(B)</span> and <span class="math">E_{2}(B)</span> denote the counts of “echo” messages for each <span class="math">B\\in\\{0,1\\}</span> received by time <span class="math">t=\\Delta</span> and <span class="math">t=2\\Delta</span>, respectively.</li>

      <li>Let <span class="math">E_{2}^{<em>}</span> and <span class="math">E_{3}^{</em>}</span> denote the count of “echo” messages (i.e., perceived participation level) received by time <span class="math">t=2\\Delta</span> and <span class="math">t=3\\Delta</span>, respectively.</li>

    </ul>

    <p class="text-gray-300">These counts are maintained locally by each node (if awake at the specified times), and nodes forward all received “echo” messages to all other nodes.</p>

    <p class="text-gray-300">If a node <span class="math">p</span> observes <span class="math">E_{1}(B)&gt;E_{3}^{<em>}/2</span>, it outputs <span class="math">B</span> with grade 1. Since all “echo” messages are forwarded, any node <span class="math">q</span> at time <span class="math">t=2\\Delta</span> receives at least the same number of “echo” messages for <span class="math">B</span> as <span class="math">p</span>. Similarly, node <span class="math">q</span> at <span class="math">t=2\\Delta</span> cannot observe a higher participation level than what <span class="math">p</span> observes at time <span class="math">t=3\\Delta</span>. Thus, <span class="math">q</span> must satisfy <span class="math">E_{2}(B)&gt;E_{2}^{</em>}/2</span>, leading it to send a “vote” message for <span class="math">B</span> at time <span class="math">t=2\\Delta</span>. This process causes all honest nodes awake at time <span class="math">t\\geq 3\\Delta</span> to recognize a majority “vote” for <span class="math">B</span>, leading them to carry <span class="math">B</span> as grade-0 output.</p>

    <p class="text-gray-300">Removing the stability requirement. An observant reader may have noticed that the protocol described above imposes a constraint on nodes’ churn. A node relies on the values of <span class="math">E_{1}(B)</span> and <span class="math">E_{3}^{<em>}</span> counted at distinct points in time to output with grade-1. Therefore, the node must be active at both of these time points to make progress. This is why Momose-Ren assumes the participation level becomes </em>eventually stable* to ensure liveness.</p>

    <p class="text-gray-300">Our protocol sidesteps this assumption through the following novel technique. Instead of directly utilizing the value of <span class="math">E_{1}(B)</span> counted at time <span class="math">t=\\Delta</span>, a node awake at <span class="math">t=3\\Delta</span> obtains an estimation from the values reported by those who were awake at time <span class="math">t=\\Delta</span>. To ensure a robust estimation, we take the median of the reported values. Since we have an honest majority at any time, the estimated value is both upper and lower bounded by values reported by honest nodes. Thus, the time-shifted quorum argument still holds without the eventual stable participation assumption.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.3 Tolerating Backward Simulation with Stateless Algorithm</h3>

    <p class="text-gray-300">The challenge to tolerating <em>costless simulation</em> attacks lies in how to convince a newly awake node of the correct execution history. In the sleepy model, an honest node that just woke up has no idea what happened</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input. Each node awake at time <span class="math">t=0</span> multicasts the input value <span class="math">B</span> through a message <span class="math">\\langle\`\`\\mathrm{echo}&quot;\\,,B\\rangle</span>.</li>

      <li>Report tally. Each node awake at time <span class="math">t=\\Delta</span> multicasts the following value for each <span class="math">B\\in\\{0,1\\}</span>.</li>

      <li><span class="math">E_{1}(B)</span> is the # of <span class="math">\\langle\`\`\\mathrm{echo}&quot;\\,,B\\rangle</span></li>

      <li>Vote. Each node awake at time <span class="math">t=2\\Delta</span> computes the following values.</li>

      <li><span class="math">E_{2}^{<em>}</span> is the # of <span class="math">\\langle\`\`\\mathrm{echo}&quot;\\,,</em>\\rangle</span></li>

      <li><span class="math">E_{2}(B)</span> is the # of <span class="math">\\langle\`\`\\mathrm{echo}&quot;\\,,B\\rangle</span> for each <span class="math">B\\in\\{0,1\\}</span></li>

    </ul>

    <p class="text-gray-300">If <span class="math">E_{2}(B)&gt;E_{2}^{*}/2</span>, then the node multicasts <span class="math">\\langle\`\`\\mathrm{vote}&quot;\\,,B\\rangle</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output. Each node awake at time <span class="math">t\\geq 3\\Delta</span> compute the following values.</li>

      <li><span class="math">E_{3}^{<em>}</span> be the # of <span class="math">\\langle\`\`\\mathrm{echo}&quot;\\,,</em>\\rangle</span></li>

      <li><span class="math">\\overline{E}_{1}(B)</span> is the median of all <span class="math">E_{1}(B)</span> received for each <span class="math">B\\in\\{0,1\\}</span></li>

    </ul>

    <p class="text-gray-300">If <span class="math">\\overline{E}_{1}(B)&gt;E_{3}^{*}/2</span>, then output <span class="math">(B,1)</span>. Similarly, compute the following values.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V_{3}^{<em>}</span> is the # of <span class="math">\\langle\`\`\\mathrm{vote}&quot;\\,,</em>\\rangle</span></li>

      <li><span class="math">V_{3}(B)</span> is the # of <span class="math">\\langle\`\`\\mathrm{vote}&quot;\\,,b\\rangle</span> for each <span class="math">B\\in\\{0,1\\}</span></li>

    </ul>

    <p class="text-gray-300">If <span class="math">V_{3}(B)&gt;V_{3}^{*}/2</span>, then output <span class="math">(B,0)</span>.</p>

    <p class="text-gray-300">Figure 2: Summary of our GA. For simplicity, we present an agreement on a binary value <span class="math">B\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">during its sleep. In particular, it cannot distinguish messages that were truly sent/received earlier in the execution from messages that corrupt nodes fabricate and claim to have been sent/received at those moments. To give a more concrete example, consider a proof-of-stake longest-chain protocol. Suppose a newly awake node receives two chains. One was built over the last ten years using the voting powers of honest nodes active at each point in time. Another is recently put together by corrupt nodes who only became active a few hours ago but claimed to have been building this chain over the entire decade. The newly awake node cannot tell the honestly generated chain from the simulated corrupt chain. The Momose-Ren protocol faces a similar challenge in spirit (despite not being based on longest chains). At each time, their protocol determines the next move based on the history of graded agreements. Recall that graded agreement decides the output once the number of votes reaches the threshold. Because corrupt nodes can fabricate votes in the past, they can inflate the threshold and convince a newly awake node of a fake output. This is also why all previous protocols have to assume <span class="math">T_{b}=\\infty</span>, or equivalently, disallow the growing participation of corrupt nodes. Without this assumption, a newly active corrupt node at time <span class="math">t</span> can pretend to have been active all the way back when it was not counted in the corruption budget and help undermine the protocol’s safety.</p>

    <p class="text-gray-300">Making the protocol stateless. To tackle this issue, our approach is to make the protocol <em>stateless</em>. Note that each view <span class="math">v</span> of our protocol (summarized in Figure 1) updates crucial variables (namely, candidate and lock) based on the result of GA from the immediate last view, occurring at most <span class="math">T_{b}=O(\\Delta)</span> time earlier. Consequently, our protocol can ignore any message from the ancient past, including those fabricated by corrupt nodes. The key to a stateless protocol is to ensure that each node always inputs a non-empty value to GA even when the GPE results in failure. Specifically, each node provides its lock as input when GPE produces an output of <span class="math">\\bot</span>. This guarantees that GA in each view always yields an output (which could potentially match the result of the previous GA or even the genesis block). As a result, we can safely discard</p>

    <p class="text-gray-300">the outputs of all past GAs except the most recent one.</p>

    <p class="text-gray-300">The stateless nature of our protocol also brings benefits to the efficiency of our recovery mechanism. When a new active node joins, it only needs to retrieve messages from the most recent view (along with any missing blocks).</p>

    <p class="text-gray-300">Impossibility of fluctuating corruption. We note that our protocol does not tolerate fluctuating corruption. To elaborate, while our protocol allows active corrupt nodes to increase over time, it does not allow the set of corrupt participants to shrink, as implied by <span class="math">T_{f}=\\infty</span>. This limitation stems from the simple fact that corrupt nodes can hand off their secret keys to the adversary (or other corrupt nodes) before going inactive. Then, the adversary can use their keys to sign any future messages on their behalf as if those corrupt nodes never went inactive. In other words, a corrupt node can simulate indefinitely forward. Unfortunately, this issue is inherent in a model without constraints on adversary computational power such as those imposed by proof-of-work (Section 7).</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Graded Agreement</h2>

    <p class="text-gray-300">This section presents a graded agreement (GA) protocol with <span class="math">3\\Delta</span> latency. Our protocol builds on the time-shifted quorum technique of Momose-Ren <em>[29]</em> but eliminates the eventual stable participation assumption with the “median trick” explained in Section 3. Our protocol is described in Algorithm 1.</p>

    <p class="text-gray-300">The protocol runs up to time <span class="math">t=T_{b}</span> (c.f., Section 2) since the beginning of the execution. The specific value of <span class="math">T_{b}</span> will be given when we present our atomic broadcast protocol in Section 6. We also note that GA defined in this paper can output multiple pairs of <span class="math">(B,g)</span>. Therefore, we denote outputs as the set of outputs. Now we proceed to provide a detailed explanation of our protocol below, mainly focusing on how to extend the binary-valued GA in Section 3 to support chained blocks.</p>

    <p class="text-gray-300">Tally echo and report. At time <span class="math">t=0</span>, awake nodes multicast their input blocks through “echo” messages. At time <span class="math">t=\\Delta</span>, each awake node tallies “echo” messages received for each block and reports these tallies. Notably, even nodes that input non-conflicting blocks might input different blocks within the same chain. This implies we have to count “echo” for a block <span class="math">B</span> as an implicit “echo” for all ancestors of <span class="math">B</span>. Namely, for each block <span class="math">B</span>, a node counts the number of “echo” messages received from distinct nodes for some block <span class="math">B^{\\prime}</span> that extends <span class="math">B</span>. This count is denoted as <span class="math">E(B)</span> and is reported via a “tally” message. Moreover, each node also forwards all “echo” messages counted in <span class="math">E(B)</span>. To avoid sending an unbounded number of tallies (especially in cases where a corrupt node sends arbitrarily many “echo”), a node sends the “tally” message only if <span class="math">E(B)&gt;E^{<em>}/2</span> where <span class="math">E^{</em>}</span> is the total number of distinct nodes who send “echo” messages (for any block). This ensures at least one honest node must have sent “echo” for <span class="math">B</span> (or its descendant) when an honest node reports a tally for <span class="math">B</span>. If there is no tally to report, a node sends a “tally” for <span class="math">\\bot</span> just to announce itself to other nodes.</p>

    <p class="text-gray-300">Vote. At time <span class="math">t=2\\Delta</span>, each awake node tallies “echo” messages in the same manner as above and sends a “vote” message for a block <span class="math">B</span> that has a majority of “echo”, namely satisfying <span class="math">E(B)&gt;E^{<em>}/2</span>. If there is no such block, then send “vote” for <span class="math">\\bot</span>. Additionally, if it has received an “echo” message (for any block) from any node <span class="math">q</span>, it forwards the “echo” message if it has not done so already (line 22). This ensures that all awake nodes after time <span class="math">t=3\\Delta</span> will possess higher (or at least the same) quorum thresholds (i.e., <span class="math">E^{</em>}</span>), a critical aspect for the time-shifted quorum argument.</p>

    <p class="text-gray-300">Output. At time <span class="math">t=3\\Delta</span> or later up to <span class="math">t=T_{b}</span>, awake nodes decide outputs based on “tally” and “vote” messages. In order to compute potential grade-1 outputs, each node obtains a robust estimation of <span class="math">E(B)</span> tallied at time <span class="math">t=2\\Delta</span> from the “tally” messages. Specifically, for each block <span class="math">B</span>, a node calculates the set <span class="math">\\mathcal{E}</span> of reported tallies for <span class="math">B</span> as follows (line 25-30):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the node has received from a node <span class="math">q</span> a “tally” for a block <span class="math">B^{\\prime}</span> extending <span class="math">B</span>, then the reported tally <span class="math">E(B^{\\prime})</span> in the message is adopted for node <span class="math">q</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, for example, if the node has received from a node <span class="math">q</span> a “tally” for a block conflicting with <span class="math">B</span>, then node <span class="math">q</span> is considered reporting <span class="math">E(B)=0</span>.</li>

    </ol>

    <p class="text-gray-300">Next, the median <span class="math">\\overline{E}(B)</span> from the set <span class="math">\\mathcal{E}</span> is selected as the estimation. If the estimated tally meets the threshold, i.e., <span class="math">\\overline{E}(B)&gt;E^{<em>}/2</span>, then the node outputs <span class="math">B</span> with grade <span class="math">g=1</span>. Finally, the node computes a grade-0 output based on “vote” messages. If the count of “vote” messages for a block <span class="math">B</span> or its descendants (referred to as <span class="math">V(B)</span>) exceeds the majority of voters (denoted <span class="math">V^{</em>}</span>), then block <span class="math">B</span> is taken as an output with grade <span class="math">g=0</span>.</p>

    <p class="text-gray-300">Time-shifted quorum. Let us quickly go over the time-shifted quorum argument. Suppose an honest node <span class="math">p</span> has the estimated tally <span class="math">e_{p}=\\overline{E}(B)</span>. The estimated tally <span class="math">e_{p}</span> is upper bounded by an honest node’s tally <span class="math">e_{r}</span> at time <span class="math">t=\\Delta</span>. This is because <span class="math">e_{p}</span> is the median of all reported tally and there is always an honest majority. Now, suppose an honest node <span class="math">q</span> awake at time <span class="math">t=2\\Delta</span> has tally <span class="math">e_{q}=E(B)</span>. Since the node <span class="math">r</span> has forwarded all “echo” counted to <span class="math">e_{r}</span>, we have <span class="math">e_{r}\\leq e_{q}</span>. As we also have <span class="math">e_{p}\\leq e_{r}</span>, this leads to <span class="math">e_{p}\\leq e_{q}</span>. Similarly, given that node <span class="math">q</span> forwards all “echo” messages, the quorum threshold <span class="math">m_{p}/2=E^{*}/2</span> for node <span class="math">p</span> is higher than (or at least the same as) the threshold <span class="math">m_{q}/2</span> observed by node <span class="math">q</span> at time <span class="math">t=2\\Delta</span>. Consequently, if <span class="math">e_{p}&gt;m_{p}/2</span> (indicating <span class="math">p</span> would consider <span class="math">B</span> as a grade-1 output), we have <span class="math">e_{q}&gt;m_{q}/2</span>. Thus node <span class="math">q</span> sends “vote” for <span class="math">B</span>, resulting in a majority vote for <span class="math">B</span>, making all other nodes at least have <span class="math">B</span> as grade-0 output, thus achieving graded delivery.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 Correctness Proof</h3>

    <p class="text-gray-300">We prove the correctness of our GA protocol. Below, we use the notion of each node’s tally. We define the “tally <span class="math">e</span> of node <span class="math">q</span> for a block <span class="math">B</span>” as follows: 1) <span class="math">e=e^{\\prime}</span> if node <span class="math">q</span> sent <span class="math">\\langle</span>“tally”,<span class="math">B^{\\prime},e^{\\prime}\\rangle_{q}</span> for any block <span class="math">B^{\\prime}</span> extending <span class="math">B</span> (if multiple such <span class="math">e^{\\prime}</span> exists, then pick the largest one), and 2) <span class="math">e=0</span> otherwise. In other words, each node’s tally is the value counted to <span class="math">\\mathcal{E}</span> (line 25–30).</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">For any block <span class="math">B</span>, let <span class="math">e_{p}</span> be the value of <span class="math">\\overline{E}(B)</span> observed by an honest node <span class="math">p</span> at time <span class="math">t\\geq 3\\Delta</span>, and <span class="math">e_{q}</span> be the value of <span class="math">E(B)</span> observed by an honest node <span class="math">q</span> at time <span class="math">t=2\\Delta</span>. Then, <span class="math">e_{p}\\leq e_{q}</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since the total number of corrupt nodes ever awake by time <span class="math">t=T_{b}</span> is less than half of the nodes awake at time <span class="math">t=\\Delta</span>, the median <span class="math">e_{p}</span> in the set <span class="math">\\mathcal{E}</span> of all tallies for <span class="math">B</span> must be upper bounded by at least one honest node’s tally <span class="math">e</span> for <span class="math">B</span>. Consider the case where <span class="math">e&gt;0</span> (the lemma is obvious if <span class="math">e=0</span>). That node must have forwarded all <span class="math">\\langle</span>“echo”,<span class="math">B\\rangle_{*}</span> counted in <span class="math">e</span>, which were received by node <span class="math">q</span> by time <span class="math">t=2\\Delta</span>. Hence, we have <span class="math">e\\leq e_{q}</span>, leading to <span class="math">e_{p}\\leq e_{q}</span>. ∎</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 2 (Graded consistency).</h6>

    <p class="text-gray-300">If an honest node outputs <span class="math">(B,1)</span>, then for all <span class="math">t</span> where <span class="math">3\\Delta\\leq t\\leq T_{b}</span>, all honest nodes awake at time <span class="math">t</span> output <span class="math">(B,*)</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose an honest node <span class="math">p</span> outputs <span class="math">(B,1)</span>. Let <span class="math">e_{p}</span> and <span class="math">m_{p}</span> be the values of <span class="math">\\overline{E}(B)</span> and <span class="math">E^{<em>}</span>, respectively, observed by node <span class="math">p</span>. We have that <span class="math">e_{p}&gt;m_{p}/2</span>. Let <span class="math">e_{q}</span> and <span class="math">m_{q}</span> be the values of <span class="math">E(B)</span> and <span class="math">E^{</em>}</span>, respectively, observed by any honest node <span class="math">q</span> at time <span class="math">t=2\\Delta</span>. By Lemma 1, we have <span class="math">e_{p}\\leq e_{q}</span>. Since the node <span class="math">q</span> forwards all “echo” messages counted in <span class="math">m_{q}</span>, we also have <span class="math">m_{q}\\leq m_{p}</span>. Thus, we have <span class="math">e_{q}&gt;m_{q}/2</span>. So all honest nodes awake at time <span class="math">t=2\\Delta</span> must have sent <span class="math">\\langle</span>“vote”,<span class="math">B\\rangle_{<em>}</span>. Therefore, for all <span class="math">t</span> from <span class="math">3\\Delta</span> to <span class="math">T_{b}</span>, all honest nodes awake at time <span class="math">t</span> observe <span class="math">V(B)&gt;V^{</em>}/2</span> and output <span class="math">(B,0)</span>. ∎</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 3 (Integrity).</h6>

    <p class="text-gray-300">If an honest node outputs <span class="math">(B,*)</span>, then at least an honest node has input <span class="math">B^{\\prime}</span> extending <span class="math">B</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose all honest nodes awake at time <span class="math">t=0</span> input blocks that do not extend <span class="math">B</span>. Let <span class="math">e</span> and <span class="math">m</span> represent the values of <span class="math">E(B)</span> and <span class="math">E^{*}</span>, respectively, observed by an honest node awake at time <span class="math">t=2\\Delta</span>. The “echo” messages counted toward the value <span class="math">e</span> are only from corrupt nodes, while “echo” messages from honest nodes awake at time <span class="math">t=0</span> are counted to <span class="math">m</span>. Given that the number of all corrupt nodes ever awake by time <span class="math">t\\leq T_{b}</span> is less than half of all honest nodes awake at time <span class="math">t=0</span>, we have <span class="math">e&lt;m/2</span>. As a result, none of the honest nodes awake at time <span class="math">t=2\\Delta</span> would send <span class="math">\\langle</span>“vote”,<span class="math">B^{\\prime}\\rangle</span> for any block <span class="math">B^{\\prime}</span> extending <span class="math">B</span>. Therefore, any</p>

    <p class="text-gray-300">|  Algorithm 1 Graded Agreement - GAid  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Initialize outputs = ∅. Node p executes the following algorithm at every time 0 ≤ t ≤ Tb after starting the protocol. Below, we assume every message binds to the protocol's id denoted id.  |   |</p>

    <p class="text-gray-300">|  1: if t = 0 then  |   |</p>

    <p class="text-gray-300">|  2: multicast <“echo”, B>p for the input block B.  |   |</p>

    <p class="text-gray-300">|  3: if t = Δ then  |   |</p>

    <p class="text-gray-300">|  4: E<em> ← # of nodes q s.t. p has received <“echo”, </em>>q  |   |</p>

    <p class="text-gray-300">|  5: for all block B do // examine blocks from a higher height  |   |</p>

    <p class="text-gray-300">|  6: E(B) ← # of nodes q s.t. p has received <“echo”, B'>q for a block B' extending B  |   |</p>

    <p class="text-gray-300">|  7: if E(B) > E*/2 and p has not sent <“tally”, B', e>p for e ≥ E(B) and a block B' extending B then  |   |</p>

    <p class="text-gray-300">|  8: multicast <“tally”, B, E(B)>p  |   |</p>

    <p class="text-gray-300">|  9: forward all “echo” counted in E(B)  |   |</p>

    <p class="text-gray-300">|  10: if p has not sent “tally” then  |   |</p>

    <p class="text-gray-300">|  11: multicast <“tally”, ⊥, ⊥*  |   |</p>

    <p class="text-gray-300">|  12: if t = 2Δ then  |   |</p>

    <p class="text-gray-300">|  13: for all block B do // examine blocks from a higher height.  |   |</p>

    <p class="text-gray-300">|  14: E(B) ← # of nodes q s.t. p has received <“echo”, B'>q for a block B' extending B  |   |</p>

    <p class="text-gray-300">|  15: E<em> ← # of nodes q s.t. p has received <“echo”, </em>>q  |   |</p>

    <p class="text-gray-300">|  16: if E(B) > E*/2 then  |   |</p>

    <p class="text-gray-300">|  17: if p has not sent “vote” for a block B' extending B then  |   |</p>

    <p class="text-gray-300">|  18: multicast <“vote”, B>p  |   |</p>

    <p class="text-gray-300">|  19: if p has not sent “vote” then  |   |</p>

    <p class="text-gray-300">|  20: multicast <“vote”, ⊥>p  |   |</p>

    <p class="text-gray-300">|  21: forward all <“echo”, *>q // only once per q  |   |</p>

    <p class="text-gray-300">|  22: if 3Δ ≤ t ≤ Tb then  |   |</p>

    <p class="text-gray-300">|  23: for all block B do // examine blocks from a higher height.  |   |</p>

    <p class="text-gray-300">|  24: E ← ∅  |   |</p>

    <p class="text-gray-300">|  25: for all node q s.t. p has received <“tally”, B', e>q do  |   |</p>

    <p class="text-gray-300">|  26: if B' extends B then  |   |</p>

    <p class="text-gray-300">|  27: add e to E  |   |</p>

    <p class="text-gray-300">|  28: else  |   |</p>

    <p class="text-gray-300">|  29: add 0 to E  |   |</p>

    <p class="text-gray-300">|  30: E(B) ← median in E  |   |</p>

    <p class="text-gray-300">|  31: E<em> ← # of nodes q s.t. p has received <“echo”, </em>>q  |   |</p>

    <p class="text-gray-300">|  32: if E(B) > E*/2 then  |   |</p>

    <p class="text-gray-300">|  33: add (B, 1) to outputs  |   |</p>

    <p class="text-gray-300">|  34: for all block B do  |   |</p>

    <p class="text-gray-300">|  35: V<em> ← # of nodes q s.t. p has received <“vote”, </em>>q  |   |</p>

    <p class="text-gray-300">|  36: V(B) ← # of nodes q s.t. p has received <“vote”, B'>q for a block B' extending B  |   |</p>

    <p class="text-gray-300">|  37: if V(B) > V*/2 then  |   |</p>

    <p class="text-gray-300">|  38: add (B, 0) to outputs  |   |</p>

    <p class="text-gray-300">|  39: // line 25: If multiple “tally” exist, choose one with B' extending B with the largest e; if no such B' exists, pick one arbitrary.  |   |</p>

    <p class="text-gray-300">honest node awake at any time  <span class="math">3\\Delta \\leq t \\leq T_b</span>  observes  <span class="math">V(B) &amp;lt; V^{*} / 2</span> , and thus would not output  <span class="math">(B,0)</span> . By graded consistency (Lemma 2), nor would they output  <span class="math">(B,1)</span> .</p>

    <p class="text-gray-300">Lemma 4 (Validity). Let  <span class="math">B</span>  be the highest block that every honest node's input extends. Then, for any  <span class="math">3\\Delta \\leq t \\leq T_b</span> , all honest nodes awake at time  <span class="math">t</span>  output  <span class="math">(B,1)</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">p</span>  be any honest node awake at time  <span class="math">3\\Delta \\leq t \\leq T_b</span> , and let  <span class="math">e_p</span>  and  <span class="math">m_p</span>  be the values of  <span class="math">\\overline{E}(B)</span>  and</p>

    <p class="text-gray-300"><span class="math">E^{*}</span> observed by node <span class="math">p</span> at time <span class="math">t</span>. We observe that there exists an honest node <span class="math">q</span> awake at time <span class="math">t=\\Delta</span> and the tally <span class="math">e</span> of <span class="math">q</span> for <span class="math">B</span> satisfies <span class="math">e\\leq e_{p}</span>. This is because the number of all corrupt nodes ever awake by time <span class="math">t=T_{b}</span> is less than half of nodes awake at time <span class="math">t=\\Delta</span> (i.e., an honest majority), and the median <span class="math">e_{p}</span> in the set <span class="math">\\mathcal{E}</span> of all tallies for <span class="math">B</span> must be lower bounded by at least one honest node’s tallies <span class="math">e</span> for <span class="math">B</span>. Now, if every honest node’s (awake at time <span class="math">t=0</span>) input extends <span class="math">B</span>, then all “echo” messages sent by these honest nodes are counted to <span class="math">e</span>. Again since we have an honest majority, we have <span class="math">e&gt;m_{p}/2</span>, hence <span class="math">e_{p}&gt;m_{p}/2</span>. Therefore, node <span class="math">p</span> outputs <span class="math">(B,1)</span>. ∎</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Graded Proposal Election</h2>

    <p class="text-gray-300">This section presents a graded proposal election (GPE) protocol with <span class="math">4\\Delta</span> latency. Intuitively, the GPE protocol is a combination of a VRF-based leader election with the GA protocol presented in Section 4. Our protocol is presented in Algorithm 2.</p>

    <p class="text-gray-300">Input. The protocol starts with a VRF-based leader election. In this process, each node <span class="math">p</span> sends its own input block along with the VRF evaluation on the protocol’s ID in an “input” message. For ease of presentation, we define the <em>winning input</em> to be the input message with the highest VRF value. Given that each node may receive a distinct set of messages, the winning input is defined individually for each node. Specifically, a message <span class="math">\\langle\\text{\`\`input&#x27;&#x27;},B,\\rho,\\pi\\rangle_{q}</span> is considered a winning input by a node <span class="math">p</span> if both of the following conditions are satisfied:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">p</span> has not received any <span class="math">\\langle\\text{\`\`input&#x27;&#x27;},*,\\rho^{\\prime},\\pi^{\\prime}\\rangle_{r}</span> with <span class="math">\\rho^{\\prime}&gt;\\rho</span>.</li>

      <li><span class="math">p</span> has not received any <span class="math">\\langle\\text{\`\`input&#x27;&#x27;},B^{\\prime},\\rho,\\pi\\rangle_{q}</span> for <span class="math">B^{\\prime}\\neq B</span>.</li>

    </ol>

    <p class="text-gray-300">In simpler terms, if the VRF of node <span class="math">q</span>’s input is the highest among all received inputs and <span class="math">p</span> has not received any equivocating input from node <span class="math">q</span>, then node <span class="math">p</span> considers node <span class="math">q</span>’s input as the winning input. We also refer to the corresponding block <span class="math">B</span> as the <em>winning block</em>. Since we have an honest majority, there is a probability of at least <span class="math">1/2</span> that a VRF from an honest node will be the highest, resulting in its input being the winner.</p>

    <p class="text-gray-300">GA on the winning input. The rest of the algorithm (from time <span class="math">t=\\Delta</span> to <span class="math">t=4\\Delta</span>) can be viewed as achieving graded agreement on a winning input. At time <span class="math">t=\\Delta</span>, awake nodes send “echo” messages for the winning blocks they have received. At time <span class="math">t=2\\Delta</span>, nodes tally “echo” for the winning block and report their tallies. At time <span class="math">t=3\\Delta</span>, if the count of “echo” for a winning block meets the majority, then the block is voted. Finally, at time <span class="math">t=4\\Delta</span>, each node calculates the median of the reported tallies, and if it meets the majority, the node outputs the block with grade <span class="math">g=1</span>. If there are majority votes for a block, it becomes a grade-0 output.</p>

    <p class="text-gray-300">The key distinction from the GA in Section 4 is that each node performs every action exclusively on the winning input/block. This helps achieve <em>consistency</em> of the GPE, a property that is not mandated by GA. More concretely, each node votes only for the winning block, and all blocks voted by honest nodes are echoed at least <span class="math">\\Delta</span> time before. So it is impossible for two different blocks to get majority votes. Additionally, each node forwards the winning input to all other nodes. Similarly, if no winning input is present, indicating the highest VRF holder is equivocating, the equivocating inputs are propagated to all nodes. This ensures that if an honest node possesses a grade-1 output (at time <span class="math">t=4\\Delta</span>), all honest nodes awake at time <span class="math">t=3\\Delta</span> have unanimously identified the same input as the winner, i.e., there exists no input with a higher VRF and no equivocating input. This makes sure the time-shifted quorum argument holds.</p>

    <p class="text-gray-300">Another crucial distinction from GA is that each node sends “echo” only for a <em>permissible</em> block (line 8). Due to the honest majority, a block must be echoed by at least one honest node to become the GPE output. This guarantees the integrity of GPE. We reiterate that the condition for a block to be permissible is externally defined, which will be specified in Section 6.</p>

    <p class="text-gray-300">Remark on the validity. We note that, during the tallying of “echo” or “vote” for a block, a node only considers the messages regarding the specific block and excludes blocks extending that block. This distinction</p>

    <p class="text-gray-300">|  Algorithm 2 Graded Proposal Election - GPEid  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Node p executes the following algorithm at every time 0 ≤ t ≤ 4Δ after staring the protocol. Let id be the protocol's id.  |   |</p>

    <p class="text-gray-300">|  1: if t = 0 then  |   |</p>

    <p class="text-gray-300">|  2: multicast <“input”, B, ρ, π> p for the input B where ρ, π ← VRFp(id)  |   |</p>

    <p class="text-gray-300">|  3: if t = Δ then  |   |</p>

    <p class="text-gray-300">|  4: if A winning input <“input”, B, ρ, π> L exists then  |   |</p>

    <p class="text-gray-300">|  5: forward the winning input, and multicast <“echo”, B> p if B is permissible.  |   |</p>

    <p class="text-gray-300">|  6: else  |   |</p>

    <p class="text-gray-300">|  7: forward the equivocating inputs, and multicast <“echo”, ⊥ > p  |   |</p>

    <p class="text-gray-300">|  8: if t = 2Δ then  |   |</p>

    <p class="text-gray-300">|  9: if A winning input <“input”, B, ρ, π> L exists then  |   |</p>

    <p class="text-gray-300">|  10: forward the winning input (if not yet).  |   |</p>

    <p class="text-gray-300">|  11: E(B) ← # of nodes q s.t. p has received <“echo”, B> q  |   |</p>

    <p class="text-gray-300">|  12: forward all <“echo”, B> *  |   |</p>

    <p class="text-gray-300">|  13: multicast <“tally”, B, E(B)> *  |   |</p>

    <p class="text-gray-300">|  14: else  |   |</p>

    <p class="text-gray-300">|  15: forward the equivocating inputs (if not yet), and multicast <“tally”, ⊥, ⊥ > *  |   |</p>

    <p class="text-gray-300">|  16: if t = 3Δ then  |   |</p>

    <p class="text-gray-300">|  17: if A winning input <“input”, B, ρ, π> L exists then  |   |</p>

    <p class="text-gray-300">|  18: forward the winning input (if not yet)  |   |</p>

    <p class="text-gray-300">|  19: forward all <“echo”, * > q (once per node q)  |   |</p>

    <p class="text-gray-300">|  20: E(B) ← # of nodes q s.t. p has received <“echo”, B> q  |   |</p>

    <p class="text-gray-300">|  21: E<em> ← # of nodes q s.t. p has received <“echo”, </em> > q  |   |</p>

    <p class="text-gray-300">|  22: if E(B) > E*/2 then  |   |</p>

    <p class="text-gray-300">|  23: multicast <“vote”, B> p  |   |</p>

    <p class="text-gray-300">|  24: else  |   |</p>

    <p class="text-gray-300">|  25: multicast <“vote”, ⊥ > p  |   |</p>

    <p class="text-gray-300">|  26: else  |   |</p>

    <p class="text-gray-300">|  27: forward the equivocating inputs (if not yet), and multicast <“vote”, ⊥ > p  |   |</p>

    <p class="text-gray-300">|  28: if t = 4Δ then  |   |</p>

    <p class="text-gray-300">|  29: if A winning input <“input”, B, ρ, π> L exists then  |   |</p>

    <p class="text-gray-300">|  30: E ← ∅  |   |</p>

    <p class="text-gray-300">|  31: for all node q s.t. p has received <“tally”, B', e> q received do  |   |</p>

    <p class="text-gray-300">|  32: if B' = B then  |   |</p>

    <p class="text-gray-300">|  33: add e to E  |   |</p>

    <p class="text-gray-300">|  34: else  |   |</p>

    <p class="text-gray-300">|  35: add 0 to E  |   |</p>

    <p class="text-gray-300">|  36: E(B) ← the median in E  |   |</p>

    <p class="text-gray-300">|  37: E<em> ← # of nodes q s.t. p has received <“echo”, </em> > q  |   |</p>

    <p class="text-gray-300">|  38: if E(B) > E*/2 then  |   |</p>

    <p class="text-gray-300">|  39: output (B, 1)  |   |</p>

    <p class="text-gray-300">|  40: for all block B do  |   |</p>

    <p class="text-gray-300">|  41: V<em> ← # of nodes q s.t. p has received <“vote”, </em> > q  |   |</p>

    <p class="text-gray-300">|  42: V(B) ← # of nodes q s.t. p has received <“vote”, B> q  |   |</p>

    <p class="text-gray-300">|  43: if V(B) > V*/2 and p has not outputted yet then  |   |</p>

    <p class="text-gray-300">|  44: output (B, 0)  |   |</p>

    <p class="text-gray-300">arises from the validity requirement. Our GA must produce grade-1 output for the highest common input (i.e., the block that all honest nodes' inputs extend). In contrast, the validity of GPE requires the algorithm</p>

    <p class="text-gray-300">to have grade-1 output for an honest node’s input (with probability <span class="math">1/2</span>). Therefore, honest nodes will not echo different blocks when the winning input is from an honest node, which is why we do not need to count indirect echoes/votes.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.1 Correctness Proof</h3>

    <p class="text-gray-300">We prove the correctness of our GPE protocol. As in the proof for GA, we employ the notion of each node’s tally. We define the “tally <span class="math">e</span> of node <span class="math">q</span> for a block <span class="math">B</span>” as follows: 1) <span class="math">e=e^{\\prime}</span> if node <span class="math">q</span> sent <span class="math">\\langle</span>“tally”<span class="math">,B,e^{\\prime}\\rangle_{q}</span>, and 2) <span class="math">e=0</span> otherwise.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Lemma 5 (Graded delivery).</h6>

    <p class="text-gray-300">If an honest node outputs <span class="math">(B,1)</span>, then all honest nodes output <span class="math">(B,*)</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose an honest node <span class="math">p</span> outputs <span class="math">(B,1)</span>. Let <span class="math">e_{p}</span> and <span class="math">m_{p}</span> denote the values of <span class="math">\\overline{E}(B)</span> and <span class="math">E^{<em>}</span>, respectively, observed by node <span class="math">p</span> at time <span class="math">t=4\\Delta</span>. We have that <span class="math">e_{p}&gt;m_{p}/2</span>. We observe that there exists an honest node <span class="math">r</span> awake at time <span class="math">t=2\\Delta</span> and the tally <span class="math">e</span> for <span class="math">B</span> satisfies <span class="math">e_{p}\\leq e</span>. Let <span class="math">q</span> be any honest node awake at time <span class="math">t=3\\Delta</span>, and <span class="math">e_{q}</span> and <span class="math">m_{q}</span> be the values of <span class="math">\\overline{E}(B)</span> and <span class="math">E^{</em>}</span>, respectively, observed by node <span class="math">q</span>. Since node <span class="math">q</span> forwards <span class="math">\\langle</span>“echo”<span class="math">,<em>\\rangle_{s}</span> for every node <span class="math">s</span> counted to <span class="math">m_{q}</span>, we have <span class="math">m_{q}\\leq m_{p}</span>. We further observe that node <span class="math">r</span> has <span class="math">B</span> as the winning block; otherwise, it would have forwarded its winning input (or equivocating inputs), and node <span class="math">p</span> would not have considered <span class="math">B</span> as the winning block. So, <span class="math">r</span> must have forwarded all “echo” for the winning block <span class="math">B</span>, leading to <span class="math">e\\leq e_{q}</span> and hence <span class="math">e_{p}\\leq e_{q}</span>. Given that <span class="math">m_{q}\\leq m_{p}</span>, it follows that <span class="math">e_{q}&gt;m_{q}/2</span>. Consequently, node <span class="math">q</span> sends <span class="math">\\langle</span>“vote”<span class="math">,B\\rangle_{q}</span>. Therefore, any honest node awake at time <span class="math">t=4\\Delta</span> should observe <span class="math">V(B)&gt;V^{</em>}/2</span> and output <span class="math">(B,*)</span>. ∎</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 6 (Consistency).</h6>

    <p class="text-gray-300">If two honest nodes output <span class="math">(B,<em>)</span> and <span class="math">(B^{\\prime},</em>)</span>, respectively, then <span class="math">B=B^{\\prime}</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose for the sake of contradiction two honest nodes output <span class="math">(B,<em>)</span> and <span class="math">(B^{\\prime},</em>)</span>, respectively, with <span class="math">B\\neq B^{\\prime}</span>. These two nodes must have independently observed local conditions <span class="math">V(B)&gt;V^{<em>}/2</span> and <span class="math">V(B^{\\prime})&gt;V^{</em>}/2</span>, implying that both <span class="math">B</span> and <span class="math">B^{\\prime}</span> receive votes from honest nodes. Let <span class="math">p</span> and <span class="math">q</span> denote the nodes who voted for <span class="math">B</span> and <span class="math">B^{\\prime}</span>, respectively. By definition, node <span class="math">p</span> must have observed <span class="math">E(B)&gt;E^{<em>}/2</span> at time <span class="math">t=3\\Delta</span>, indicating that at least an honest node sent <span class="math">\\langle</span>“echo”<span class="math">,B\\rangle</span>. Similarly, node <span class="math">q</span>, voting for <span class="math">B^{\\prime}</span>, must have witnessed <span class="math">E(B^{\\prime})&gt;E^{</em>}/2</span>, indicating an honest node must have sent <span class="math">\\langle</span>“echo”<span class="math">,B^{\\prime}\\rangle</span>. However, this scenario implies that both <span class="math">p</span> and <span class="math">q</span> have received the corresponding “input” messages for <span class="math">B</span> and <span class="math">B^{\\prime}</span>, one of which is not the actual winning input. Given that nodes would not vote for non-winning blocks, this contradicts both <span class="math">B</span> and <span class="math">B^{\\prime}</span> are voted. ∎</p>

    <p class="text-gray-300">Here, we note that the validity we prove below assumes that every honest node inputs a permissible block; otherwise, the validity would be trivially false. It is worth noting that this assumption will be justified by our atomic broadcast (c.f., Section 6).</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 7 (Validity).</h6>

    <p class="text-gray-300">With probability more than <span class="math">1/2</span>, all honest nodes output <span class="math">(B,1)</span> for a block <span class="math">B</span> that honest node inputs.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be an honest node awake at time <span class="math">t=4\\Delta</span>, and let <span class="math">e_{p}</span> and <span class="math">m_{p}</span> be the values of <span class="math">\\overline{E}(B)</span> and <span class="math">E^{*}</span>, respectively, observed by node <span class="math">p</span>. We observe that there exists an honest node <span class="math">r</span> awake at time <span class="math">t=2\\Delta</span> whose tally <span class="math">e_{r}</span> for <span class="math">B</span> satisfies <span class="math">e_{r}\\leq e_{p}</span>. Given that the number of corrupt nodes ever awake by time <span class="math">t=T_{b}</span> is less than half of all honest nodes awake at time <span class="math">t=0</span>, with probability <span class="math">\\alpha&gt;1/2</span>, an honest node’s VRF will be the highest, making its input <span class="math">B</span> the winning block. Consequently, all honest nodes awake at time <span class="math">t=\\Delta</span> will send <span class="math">\\langle</span>“echo”<span class="math">,B\\rangle</span>. This leads to <span class="math">e_{r}&gt;m_{p}/2</span>. Given that <span class="math">e_{r}\\leq e_{p}</span>, it follows that <span class="math">e_{p}&gt;m_{p}/2</span>. As a result, node <span class="math">p</span> outputs <span class="math">(B,1)</span>. ∎</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Lemma 8 (Integrity).</h6>

    <p class="text-gray-300">If an honest node outputs <span class="math">(B,<em>)</span>, then the block <span class="math">B</span> is </em>permissible* for at least an honest node.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">As we have observed, when an honest node outputs a block <span class="math">B</span>, it indicates that at least one honest node has sent “echo” message for <span class="math">B</span>. This means the block is deemed permissible by the honest node that sent the “echo”. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">6 Atomic Broadcast</p>

    <p class="text-gray-300">This section presents an atomic broadcast protocol with <span class="math">4\\Delta</span> latency in the best case, building on the GA protocol (in Section 4) and the GPE protocol (in Section 5). Our protocol achieves safety and liveness in the <span class="math">O(\\infty,T_{b},1/2)</span>-sleepy model with <span class="math">T_{b}=11\\Delta</span>.</p>

    <p class="text-gray-300">The protocol is described in Algorithm 3. It progresses through repeated <em>views</em>. Each view is identified by an integer <span class="math">v&gt;0</span> and takes <span class="math">10\\Delta</span> time. As mentioned in Section 3, each view consists of a GPE and two GAs. Based on the output from GPE and GA, nodes lock on a potentially decided block to safeguard it from future conflicting decisions. Nodes also determine the next proposal does do not conflict with locked blocks to ensure liveness. These values are maintained by the variables lock and candidate, initially set to the genesis block <span class="math">B_{0}</span> (which is considered a block of view <span class="math">v=0</span>).</p>

    <p class="text-gray-300">Each view begins with a GPE. At time <span class="math">t=0</span>, each node inputs to <span class="math">\\mathsf{GPE}_{v}</span> a block <span class="math">B</span> that extends its current candidate. candidate is updated to the highest block that <span class="math">\\mathsf{GA}_{v-1}</span> has output with grade 0. Within the GPE, a block is considered <em>permissible</em> if it extends lock. Again, this makes sure any block conflicting with a potentially decided block is precluded from the GPE output.</p>

    <p class="text-gray-300">The output from <span class="math">\\mathsf{GPE}_{v}</span> is passed to two consecutive GAs (first <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> and then <span class="math">\\mathsf{GA}_{v}</span>). Let us call them the pre-GA and the main GA, respectively. The pre-GA <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> is to preclude conflicting outputs from the main GA. Specifically, a node inputs to <span class="math">\\mathsf{GA}_{v}</span> a grade-1 output from <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> only if there is no other conflicting output from <span class="math">\\mathsf{GA}_{v}^{\\prime}</span>. This makes sure honest nodes’ inputs to <span class="math">\\mathsf{GA}_{v}</span> are always non-conflicting, avoiding divergent locks and candidates among nodes.</p>

    <p class="text-gray-300">A grade-1 output from <span class="math">\\mathsf{GPE}_{v}</span> is decided immediately. When a node decides on a block, the node multicasts a “decide” message for the block to let other nodes (especially those who were not awake at <span class="math">t=4\\Delta</span>) decide on the block. If a node receives “decide” messages for a block <span class="math">B</span> (or its descendants) from a majority of all senders of “decide” messages, i.e., <span class="math">D(B)&gt;D^{*}/2</span>, the node also decides on the block <span class="math">B</span> (line 27–31, 4–8).</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Tolerating backward simulation.</h5>

    <p class="text-gray-300">Each view in our protocol examines only messages from the immediate preceding view. To be more specific, all steps that depend on previous messages are summarized below:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At time <span class="math">t=0</span>, each node computes its input to <span class="math">\\mathsf{GPE}_{v}</span> based on the result of <span class="math">\\mathsf{GA}_{v-1}</span> (i.e., candidate), which starts at time <span class="math">t=7\\Delta</span> of view <span class="math">v-1</span>. These messages are sent at most <span class="math">3\\Delta</span> earlier.</li>

      <li>At time <span class="math">t=4\\Delta</span>, each node decides a block or computes its input to <span class="math">\\mathsf{GA}_{v}</span> based on the result of <span class="math">\\mathsf{GA}_{v-1}</span> (i.e., lock), which are derived from messages sent at most <span class="math">7\\Delta</span> earlier.</li>

      <li>At any time up to time <span class="math">t=5\\Delta</span> of view <span class="math">v</span>, nodes decide blocks based on the “decide” messages sent at time <span class="math">t=4\\Delta</span> of view <span class="math">v-1</span>, which are at most <span class="math">11\\Delta</span> earlier.</li>

    </ol>

    <p class="text-gray-300">To sum up, attempts by corrupt nodes to fabricate messages of more than <span class="math">T_{b}=11\\Delta</span> time before have no impact on the execution of honest nodes.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">6.1 Safety and Liveness Proofs</h3>

    <p class="text-gray-300">We prove the safety and liveness of our atomic broadcast protocol. We say a node <em>directly</em> decides a block <span class="math">B</span> if the node has not decided any descendant of <span class="math">B</span> by that moment. We first show below that locks are always non-conflicting in the same view.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">Let <span class="math">p</span> and <span class="math">q</span> be honest nodes awake at time <span class="math">t=4\\Delta</span> of a view <span class="math">v</span>, and let <span class="math">\\mathsf{lock}_{p}</span> and <span class="math">\\mathsf{lock}_{q}</span> be the value of lock observed by honest nodes <span class="math">p</span> and <span class="math">q</span>, respectively. Then, <span class="math">\\mathsf{lock}_{p}</span> and <span class="math">\\mathsf{lock}_{q}</span> do not conflict with each other.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In each view, an honest node inputs to <span class="math">\\mathsf{GA}_{v}</span> (the main GA) a block received from <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> (the pre GA) with grade <span class="math">g=1</span>. Moreover, the block should not conflict with any other outputs from <span class="math">\\mathsf{GA}_{v}^{\\prime}</span>. The graded delivery ensures that other honest nodes deliver the block with grade <span class="math">g=0</span>, so they would not input any conflicting block to <span class="math">\\mathsf{GA}_{v}</span>. Due to the integrity of GA, <span class="math">\\mathsf{GA}_{v}</span> will output non-conflicting blocks. Thus, <span class="math">\\mathsf{lock}_{p}</span> and <span class="math">\\mathsf{lock}_{q}</span> do not conflict with each other. ∎</p>

    <p class="text-gray-300">Algorithm 3 Atomic Broadcast Variables are initialized as lock, candidate  <span class="math">= B_{0}</span> In each view  <span class="math">v</span>  , node  <span class="math">p</span>  executes the following algorithm at every time  <span class="math">0\\leq t\\leq 10\\Delta</span>  during view  <span class="math">v</span>  , and enter the next view  <span class="math">v + 1</span> // update variables 1: candidate  <span class="math">\\leftarrow</span>  the highest block  <span class="math">B</span>  s.t.  <span class="math">\\mathsf{GA}_{v - 1}</span>  outputs  <span class="math">(B,<em>)</span> 2: lock  <span class="math">\\leftarrow</span>  the highest block  <span class="math">B</span>  s.t.  <span class="math">\\mathsf{GA}_{v - 1}</span>  outputs  <span class="math">(B,1)</span> 3: if  <span class="math">t\\leq 5\\Delta</span>  then 4:  <span class="math">D^{</em>}\\gets \\#</span>  of nodes q s.t.  <span class="math">p</span>  has received  <span class="math">\\langle &quot;decide&quot;,<em>,v - 1\\rangle_q</span> 5: for all block  <span class="math">B</span>  do 6:  <span class="math">D(B)\\gets \\#</span>  of nodes q s.t.  <span class="math">p</span>  has received  <span class="math">\\langle &quot;decide&quot;,B&#x27;,v - 1\\rangle_q</span>  for any block  <span class="math">B^{\\prime}</span>  extending  <span class="math">B</span> 7: if  <span class="math">D(B) &amp;gt; D^{</em>} / 2</span>  then 8: decide  <span class="math">B</span>  and all its ancestors // GPE invocation 9: if  <span class="math">t = 0</span>  then 10:  <span class="math">B\\gets (b,\\mathsf{H}(B&#x27;),v)</span>  where  <span class="math">B^{\\prime} =</span>  candidate. 11: start  <span class="math">\\mathsf{GPE}_v</span>  with input  <span class="math">B</span>  ; within GPE, any block is considered permissible if it extends lock and view  <span class="math">(B) = v</span> // pre GA invocation 12: if  <span class="math">t = 4\\Delta</span>  then 13:  <span class="math">B,g\\gets</span>  the output from  <span class="math">\\mathsf{GPE}_v</span> 14: if  <span class="math">g = 1</span>  then 15: decide  <span class="math">B</span>  and all its ancestors 16: multicast  <span class="math">\\langle &quot;decide&quot;,B,v\\rangle_p</span> 17: else 18: multicast  <span class="math">\\langle &quot;decide&quot;,B&#x27;,v\\rangle_p</span>  for the highest decided block  <span class="math">B^{\\prime}</span> 19: if  <span class="math">B\\neq \\bot</span>  then 20: start  <span class="math">\\mathsf{GA}_v^{\\prime}</span>  with input  <span class="math">B</span> 21: else 22: start  <span class="math">\\mathsf{GA}_v^{\\prime}</span>  with input lock // main GA invocation 23: if  <span class="math">t = 7\\Delta</span>  then 24:  <span class="math">B\\gets</span>  the highest block s.t.  <span class="math">\\mathsf{GA}_v^{\\prime}</span>  has output  <span class="math">(B,1)</span>  but has not output  <span class="math">(B^{\\prime},<em>)</span>  for any  <span class="math">B^{\\prime}</span>  conflicting with  <span class="math">B</span> 25: start  <span class="math">\\mathsf{GA}_v</span>  with input  <span class="math">B</span> // decide 26: if  <span class="math">t\\geq 5\\Delta</span>  then 27:  <span class="math">D^{</em>}\\gets \\#</span>  of nodes q s.t.  <span class="math">p</span>  has received  <span class="math">\\langle &quot;decide&quot;,<em>,v\\rangle_q</span> 28: for all block  <span class="math">B</span>  do 29:  <span class="math">D(B)\\gets \\#</span>  of nodes q s.t.  <span class="math">p</span>  has received  <span class="math">\\langle &quot;decide&quot;,B&#x27;,v\\rangle_q</span>  for any block  <span class="math">B^{\\prime}</span>  extending  <span class="math">B</span> 30: if  <span class="math">D(B) &amp;gt; D^{</em>} / 2</span>  then 31: decide  <span class="math">B</span>  and all its ancestors</p>

    <p class="text-gray-300">Lemma 10. If a block  <span class="math">B</span>  of view  <span class="math">v</span>  is directly decided by an honest node, then at least an honest node has sent  <span class="math">\\langle &quot;decide&quot;, B, v \\rangle</span> .</p>

    <p class="text-gray-300">Proof. Assume for the sake of contradiction that none of the honest nodes awake at time  <span class="math">t = 4\\Delta</span>  in view  <span class="math">v</span>  sends  <span class="math">\\langle &quot;decide&quot;, B, v \\rangle</span> . Then, the block  <span class="math">B</span>  will not be decided (either directly or indirectly) until time  <span class="math">t = 5\\Delta</span>  of view  <span class="math">v + 1</span> . Thus, none of the honest nodes awake at time  <span class="math">t = 4\\Delta</span>  in view  <span class="math">v + 1</span>  will send  <span class="math">\\langle &quot;decide&quot;, B, v + 1 \\rangle</span> . By induction, in all subsequent views  <span class="math">v&#x27; \\geq v</span> , honest nodes will never send  <span class="math">\\langle &quot;decide&quot;, B, v&#x27; \\rangle</span> . This contradicts that the block  <span class="math">B</span>  was directly decided.</p>

    <p class="text-gray-300">Next, we show that a directly decided block will always be handed over to the immediately following GA, thereby ensuring its subsequent locking.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">If an honest node sends <span class="math">\\langle</span>“decide”,<span class="math">B,v\\rangle</span> for a block <span class="math">B</span> of view <span class="math">v</span>, then all honest nodes awake at time <span class="math">t=7\\Delta</span> of view <span class="math">v</span> input the block <span class="math">B</span> to <span class="math">\\mathsf{GA}_{v}</span>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose an honest node <span class="math">p</span> sends <span class="math">\\langle</span>“decide”,<span class="math">B,v\\rangle</span>. This implies that node <span class="math">p</span> must have received a block <span class="math">B</span> of view <span class="math">v</span> from <span class="math">\\mathsf{GPE}_{v}</span> with grade <span class="math">g=1</span>. Let <span class="math">q</span> be any honest node awake at time <span class="math">t=4\\Delta</span>. The graded delivery of GPE ensures that node <span class="math">q</span> has received <span class="math">B</span> from <span class="math">\\mathsf{GPE}_{v}</span> (with any grade). So node <span class="math">q</span> will input <span class="math">B</span> to <span class="math">\\mathsf{GA}_{v}^{\\prime}</span> (the pre-GA). Due to the validity of GA, the pre-GA will output <span class="math">B</span> (or a block extending <span class="math">B</span>) to all honest nodes awake at time <span class="math">t=7\\Delta</span>, leading them to input <span class="math">B</span> to <span class="math">\\mathsf{GA}_{v}</span> (the main GA). ∎</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Lemma 12 (Safety).</h6>

    <p class="text-gray-300">If two honest nodes decide <span class="math">B</span> and <span class="math">B^{\\prime}</span>, then <span class="math">B</span> does not conflict with <span class="math">B^{\\prime}</span>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose for the sake of contradiction two conflicting blocks are decided by honest nodes. This implies there are two conflicting blocks <span class="math">B</span> and <span class="math">B^{\\prime}</span> of view <span class="math">v</span> and <span class="math">v^{\\prime}</span>, respectively, decided directly by honest nodes. We have that <span class="math">v\\neq v^{\\prime}</span> due to the consistency of GPE. Without loss of generality, we assume <span class="math">v&lt;v^{\\prime}</span>. Based on Lemma 10 and 11, all honest nodes awake at time <span class="math">t=4\\Delta</span> of view <span class="math">v</span> input blocks extending <span class="math">B</span> into <span class="math">\\mathsf{GA}_{v}</span>, leading to all honest nodes awake during view <span class="math">v+1</span> locking on <span class="math">B</span> (i.e., set lock to <span class="math">B</span> or its descendants). Consequently, any conflicting block will be precluded from GPE/GA outputs during view <span class="math">v</span>. By induction, in all subsequent views, all honest nodes keep inputting blocks extending <span class="math">B</span> to GPE/GA. However, by the same argument, in view <span class="math">v^{\\prime}</span>, honest nodes must input blocks extending <span class="math">B^{\\prime}</span> into <span class="math">\\mathsf{GA}_{v^{\\prime}}</span>. This contradicts that <span class="math">B</span> and <span class="math">B^{\\prime}</span> are conflicting. ∎</p>

    <p class="text-gray-300">The above lemma directly implies <em>safety</em> as non-conflicting blocks <span class="math">B</span> and <span class="math">B^{\\prime}</span> represent consistent logs, i.e., one of them is a prefix of the other.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Lemma 13 (Liveness).</h6>

    <p class="text-gray-300">If an awake honest node inputs a value <span class="math">x</span> at time <span class="math">t</span>, then there is a time <span class="math">t^{\\prime}\\geq t</span> s.t. all honest nodes awake after <span class="math">t^{\\prime}</span> decide a log containing <span class="math">x</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first observe that if an honest node (say <span class="math">p</span>) inputs a block <span class="math">B</span> to <span class="math">\\mathsf{GPE}_{v}</span>, then <span class="math">B</span> extends lock observed by other honest nodes, indicating that <span class="math">B</span> is permissible for all honest nodes. This is due to the graded delivery of GA. An honest node <span class="math">q</span> sets to <span class="math">\\mathsf{lock}_{q}</span> a grade-1 output from <span class="math">\\mathsf{GA}_{v-1}</span>. This implies node <span class="math">p</span> has received <span class="math">\\mathsf{lock}_{q}</span> from <span class="math">\\mathsf{GA}_{v-1}</span>, at least as grade-0 output, leading to node <span class="math">p</span> setting it to <span class="math">p</span>’s candidate. Node <span class="math">p</span> inputs a block extending candidate, so <span class="math">B</span> must extend <span class="math">\\mathsf{lock}_{q}</span>.</p>

    <p class="text-gray-300">Now, if the honest node’s input becomes the winning block, then all honest nodes awake at time <span class="math">t=4\\Delta</span> of the view decide the block <span class="math">B</span> and send <span class="math">\\langle</span>“decide”,<span class="math">B,v\\rangle</span>. So all honest nodes awake at any time from time <span class="math">t=5\\Delta</span> of view <span class="math">v</span> to time <span class="math">t=5\\Delta</span> of view <span class="math">v+1</span> decide the block <span class="math">B</span>. By induction, all honest nodes awake at any time after <span class="math">t=5\\Delta</span> of view <span class="math">v</span> decide <span class="math">B</span>.</p>

    <p class="text-gray-300">The validity of GPE implies that such a view <span class="math">v</span> eventually and repeatedly appears. All values input by honest nodes before this view will get included in block <span class="math">B</span> (with input dissemination, i.e., honest nodes multicast their input values) and get decided. So all values input by honest nodes will eventually be decided. ∎</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">6.2 Analysis</h3>

    <p class="text-gray-300">We give the analysis of the latency and communication complexity of our protocol.</p>

    <p class="text-gray-300">Latency. The best-case latency of our protocol is <span class="math">4\\Delta</span> as nodes can decide on a block immediately after GPE. This is far better than prior and concurrent works such as <span class="math">16\\Delta</span> of Momose-Ren <em>[29]</em> and <span class="math">10\\Delta</span> of Gafni-Losa <em>[28]</em>. The expected latency of our protocol is <span class="math">14\\Delta</span>, which is also better than prior and concurrent works: <span class="math">32\\Delta</span> of Momose-Ren and <span class="math">20\\Delta</span> of Gafni-Losa. Finally, the latency in the worst case (except with negligible probability) is <span class="math">O(\\kappa\\Delta)</span>. This matches the lower bound <em>[4]</em>.</p>

    <p class="text-gray-300">Communication complexity. The expected communication complexity of our protocol described in Algorithm 3 is <span class="math">O(Ln^{3})</span> per view, where <span class="math">L</span> represents the block size. To elaborate, recall that honest nodes input to GA an output from GPE or blocks they are locking on. Since GPE guarantees consistency, there is no disagreement among honest nodes on the former. For the latter, honest nodes might have distinct locks.</p>

    <p class="text-gray-300">However, in the last few (constant in expectation) views, there is at least one “good” view where all honest nodes lock on the same block proposed by an honest node. Therefore, honest nodes collectively input at most constant number of blocks to GA. This implies each honest node sends <span class="math">O(1)</span> “vote/tally” messages and forwards <span class="math">O(n)</span> “echo” messages associated with these vote/tally, which means <span class="math">O(n^{3})</span> messages are sent in total.</p>

    <p class="text-gray-300">The communication complexity can be reduced to <span class="math">O(Ln^{2}+\\kappa n^{3})</span> with a simple modification: each message contains only the hash of the block (of length <span class="math">O(\\kappa)</span>) and nodes transmit blocks separately (and only once per block). When dealing with sufficiently large blocks, i.e., <span class="math">L=\\Omega(\\kappa n)</span>, it will be <span class="math">O(Ln^{2})</span>. This matches the cost of all existing sleepy consensus protocols including longest-chain protocols.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">6.3 Efficient Recovery</h3>

    <p class="text-gray-300">We have assumed for simplicity that any message sent by an honest node at time <span class="math">t</span> is received by the recipient awake at any time <span class="math">t^{\\prime}\\geq t+\\Delta</span> (Section 2). This is clearly an impractical assumption since it implies that messages must be magically buffered until the recipient comes back awake. In practice, we have to assume that the message will be lost if not received by the recipient within <span class="math">\\Delta</span> time, and we must provide an explicit message recovery mechanism for newly awake nodes.</p>

    <p class="text-gray-300">Let us begin by adjusting the model to accommodate message loss. We follow the <em>sleepy model with recovery</em> model introduced by Momose-Ren <em>[29]</em>. In addition to the <em>awake/asleep</em> statuses, we introduce a third status called <em>recovering</em>. When a node transitions from asleep to awake, it enters the recovering status. During this period, the node retrieves missing information from other awake nodes to catch up. The length of this grace period is denoted as <span class="math">\\Gamma\\geq 2\\Delta</span>. In theory, <span class="math">\\Gamma=2\\Delta</span> suffices as a single round trip fetches all missing data. In practice, <span class="math">\\Gamma</span> will depend on how much data a node needs to retrieve. The message delivery assumption is that if an honest node <span class="math">p</span> awake at time <span class="math">t</span> sends a message, then the message will be received by the recipient <span class="math">q</span> as long as <span class="math">q</span> is recovering or awake at all times during <span class="math">[t,t+\\Delta]</span>. A node is treated as awake after completing the recovery process.</p>

    <p class="text-gray-300">Now we present the concrete recovery sub-protocol of our atomic broadcast in Algorithm 4. When a node <span class="math">p</span> joins the execution (i.e., as a new recovering node), it begins the process by querying other nodes with a “recovery” message with the hash of the highest block <span class="math">B</span> it has ever decided (line 1–4). If <span class="math">p</span> has not decided or has not even been awake, then the hash corresponds to the genesis block. Other nodes respond to the recovering node with the required information <span class="math">p</span> might have missed. Specifically, each node sends <span class="math">p</span> all decided blocks after <span class="math">B</span> (i.e., missing log contents) as well as all messages of the current view <span class="math">v</span> and the preceding view <span class="math">v-1</span>. Recall that each view of our main protocol (Algorithm 3) relies only on messages from the current view and the immediate last view. More concretely, it relies on the result from <span class="math">\\mathsf{GA}_{v-1}</span> and “decide” messages from view <span class="math">v-1</span>. As a direct consequence, all messages from older views <span class="math">v^{\\prime}&lt;v-1</span> do not need to be recovered (except for the log contents).</p>

    <p class="text-gray-300">Note that our recovery protocol is completely decoupled from the main protocol, so the proofs in Section 6.1 still hold.</p>

    <h2 id="sec-43" class="text-2xl font-bold">7 Impossibility of Supporting Fluctuating Corruption</h2>

    <p class="text-gray-300">This section shows the impossibility of consensus in the sleepy model with corrupt nodes’ fluctuation. Namely, there is no atomic broadcast protocol against the standard (PPT) adversary in the <span class="math">(T_{f},T_{b},\\alpha)</span>-sleepy model with any bounded <span class="math">T_{f},T_{b}</span>, and constant <span class="math">\\alpha</span>.</p>

    <p class="text-gray-300">Assumptions. For clarity, let us review the assumptions that are critical to the result.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We assume a standard probabilistic polynomial-time (PPT) adversary that is allowed to perform any polynomial (in <span class="math">\\kappa</span>) amount of computation. This means we do not have any proof-of-work style assumption on relative computation power.</li>

      <li>The adversary can fully control any corrupt node once it becomes awake. This includes extracting the entire private state as well as deciding all the messages the node sends.</li>

    </ol>

    <p class="text-gray-300">Algorithm 4 Recovery mechanism for Algorithm 3 Node <span class="math">p</span> executes the following algorithm.</p>

    <p class="text-gray-300">// query other nodes 1: upon joining the execution 2: <span class="math">B \\leftarrow</span> the highest block that <span class="math">p</span> has ever decided 3: multicast <span class="math">\\langle</span> “recover”, <span class="math">\\mathsf{H}(B) \\rangle_p</span> 4: wait for <span class="math">\\Gamma</span> and resume the execution of Algorithm 3</p>

    <p class="text-gray-300">// respond to a recovering node 5: upon receiving <span class="math">\\langle</span> “recover”, <span class="math">h \\rangle_q</span> 6: if <span class="math">p</span> has decided a block <span class="math">B</span> s.t. <span class="math">\\mathsf{H}(B) = h</span> then 7: send to <span class="math">q</span> all decided blocks extending <span class="math">B</span> 8: Let <span class="math">v</span> be the current view. 9: sends to <span class="math">q</span> all messages of view <span class="math">v</span> and <span class="math">v - 1</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We assume the communication channels between nodes are unauthenticated. When an honest node receives a message, the node cannot tell the origin of the message. It is worth emphasizing and clarifying that what we are assuming here is that there are no innate authenticated channels in the model. A protocol can choose to implement authenticated channels using digital signatures and PKI; but looking ahead, these cryptographic authenticated channels will be broken by an adversary who extracts private keys.</li>

    </ol>

    <p class="text-gray-300">Under these assumptions, we can show the following result.</p>

    <p class="text-gray-300">Theorem 2. For any <span class="math">T_f, T_b = \\mathrm{poly}(\\kappa)</span> and <span class="math">0 &amp;lt; \\alpha &amp;lt; 1</span>, no atomic broadcast protocol exists in the <span class="math">(T_b, T_f, \\alpha)</span>-sleepy model.</p>

    <p class="text-gray-300">Intuitively, our proof is based on an adversary performing a forward simulation attack. More concretely, consider a network of two sets of <span class="math">1 / \\alpha</span> nodes <span class="math">P</span> and <span class="math">Q</span> (assume for simplicity that <span class="math">1 / \\alpha</span> is an integer), and a node <span class="math">r</span>. Nodes in <span class="math">P</span> are honest and always awake. Since less than <span class="math">\\alpha</span> fraction of awake nodes can be corrupt, we can have one corrupt node in each period of <span class="math">T = T_{f} + T_{b}</span> time. For <span class="math">k \\in [1, 1 / \\alpha]</span>, the adversary makes each node <span class="math">q_{k} \\in Q</span> awake and then asleep immediately at time <span class="math">t = (k - 1)T</span> after extracting all its private states. Now, after time <span class="math">t = T / \\alpha</span>, the adversary holds all private states of <span class="math">Q</span> and can simulate any execution using nodes in <span class="math">Q</span> as if they were awake from the beginning. This essentially breaks the honest majority requirement [33] of the <span class="math">(\\infty, \\infty, 1/2)</span>-sleepy model (the original sleepy model) and allows the adversary to convince an honest node <span class="math">r</span> who wakes up after time <span class="math">T / \\alpha</span> with the simulated execution, leading to an incorrect decision.</p>

    <p class="text-gray-300">Proof. Let <span class="math">\\beta = 1 / \\alpha</span>. We assume <span class="math">\\beta</span> is an integer (the proof is easily extended to the case <span class="math">\\beta</span> is not an integer). Suppose there exists such a protocol. Let <span class="math">T = T_{f} + T_{b}</span>. Let <span class="math">\\Gamma &amp;gt; \\beta T</span> be the smallest value s.t. the protocol satisfies <span class="math">\\Gamma</span>-Liveness. Let <span class="math">P</span> and <span class="math">Q</span> be two disjoint sets of <span class="math">\\beta</span> nodes, and <span class="math">r \\notin P \\cup Q</span> be a node. Consider the following two executions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>W1. For each <span class="math">k \\in [1, \\beta]</span>, there is a unique corrupt node <span class="math">p_k \\in P</span> that becomes awake and then asleep immediately at time <span class="math">t = (k - 1)T</span>. All nodes in <span class="math">Q</span> are honest and always awake. At time <span class="math">t = \\Gamma</span>, a new honest node <span class="math">r</span> becomes awake. The honest nodes <span class="math">Q</span> input a set <span class="math">X</span> of values. All corrupt nodes <span class="math">P</span> do not send any message. Until time <span class="math">t = \\Gamma</span>, the adversary simulates an honest execution among the corrupt nodes <span class="math">P</span> as if all nodes in <span class="math">P</span> were always awake from time 0 to <span class="math">\\Gamma</span> and they had a set <span class="math">X&#x27;</span> of input values s.t. <span class="math">X \\cap X&#x27; = \\emptyset</span>. At time <span class="math">t = \\Gamma</span>, the adversary delivers all messages in the simulated execution to the new awake node <span class="math">r</span>.</li>

      <li>W2. The second execution is symmetric. For each <span class="math">k \\in [1, \\beta]</span>, there is a unique corrupt node <span class="math">q_k \\in Q</span> that becomes awake and then asleep immediately at time <span class="math">t = (k - 1)T</span>. All nodes in <span class="math">P</span> are honest and always awake. At time <span class="math">t = \\Gamma</span>, a new honest node <span class="math">r</span> becomes awake. The honest nodes <span class="math">P</span> input a set <span class="math">X&#x27;</span></li>

    </ul>

    <p class="text-gray-300">of values. All corrupt nodes <span class="math">Q</span> do not send any message. Until time <span class="math">t=\\Gamma</span>, the adversary simulates an honest execution among the corrupt nodes <span class="math">Q</span> as if all nodes in <span class="math">Q</span> were always awake from time <span class="math">0</span> to <span class="math">\\Gamma</span> and they had a set <span class="math">X</span> of input values s.t. <span class="math">X\\cap X^{\\prime}=\\emptyset</span>. At time <span class="math">t=\\Gamma</span>, the adversary delivers all messages in the simulated execution to the new awake node <span class="math">r</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{view}_{1}</span> and <span class="math">\\mathsf{view}_{2}</span> be the random variables that describe the set of messages that <span class="math">r</span> receives in W1 and W2, respectively. Obviously, the distribution of these two variables must be identical since they both consist of two separate honest executions among <span class="math">P</span> with input <span class="math">X^{\\prime}</span>, and among <span class="math">Q</span> with input <span class="math">X</span>. So, the log decided by <span class="math">r</span> must be identically distributed in both W1 and W2. However, due to <span class="math">\\Gamma</span>-liveness, <span class="math">r</span> must decide a log containing <span class="math">X</span> in W1, and in W2, <span class="math">r</span> must decide a log containing <span class="math">X^{\\prime}</span>. So the two distributions should be different, leading to a contradiction. ∎</p>

    <h2 id="sec-44" class="text-2xl font-bold">8 Related Work</h2>

    <p class="text-gray-300">Byzantine consensus has been studied for several decades, with a primary focus on the static and known participation model <em>[26, 17, 7, 20, 18, 9]</em>. The emergence of the Bitcoin protocol <em>[30]</em> marked a turning point, which inspired a new area of research in Byzantine consensus that considers unknown and dynamic participation. This unknown and dynamic participation model was later formalized as the sleepy model <em>[33]</em>. Below, we review the related works in sleepy consensus research.</p>

    <p class="text-gray-300">Latency of sleepy consensus. Early research on sleepy consensus naturally adopted Bitcoin’s longest-chain paradigm. A number of works generalized the longest-chain paradigm by substituting the computationally intensive proof-of-work with proof-of-stake <em>[33, 25, 5, 12]</em>. However, one of the major drawbacks of the longest-chain protocol is its inherent long latency. In particular, the basic longest-chain protocol like Bitcoin has a latency of <span class="math">\\Omega(\\frac{\\kappa\\Delta}{\\gamma})</span> where <span class="math">\\kappa</span> is the desired security level, <span class="math">\\gamma</span> is the active participation level (i.e., the fraction of active nodes compared to the total nodes), and <span class="math">\\Delta</span> is the bound on network delay. Efforts have been made to eliminate some of the factors that contribute to this long latency. Prism <em>[6]</em>, Parallel Chain <em>[21]</em>, and Taiji <em>[27]</em> removed the dependency on <span class="math">\\kappa</span> using many parallel instances of longest chains, but maintained the dependency on <span class="math">\\gamma</span>. A recent work by D’Amato et al. <em>[14]</em> achieves <span class="math">O(\\Delta)</span> latency under optimistic conditions where the participation level is high, but it inherits the long latency of a longest-chain protocol under low participation level.</p>

    <p class="text-gray-300">Another line of work adapts the classic BFT paradigm from the traditional known and static participation model to the sleepy model. Goyal et al. <em>[23]</em> removes the dependency on <span class="math">\\gamma</span> by extending Algorand <em>[22]</em>, but the dependency on <span class="math">\\kappa</span> remains. Furthermore, due to the use of a static quorum threshold, it places a constraint on honest nodes’ fluctuation as it requires a steady presence of <span class="math">\\Omega(\\kappa)</span> awake honest nodes at all times.</p>

    <p class="text-gray-300">The closest to our work is the work by Momose-Ren <em>[29]</em>, which for the first time eliminates both of the above dependencies and achieves <span class="math">O(\\Delta)</span> latency. The protocol is built on the classic view-based construction and each view consists of a VRF-based leader election and five consecutive invocations of GA. That protocol incurs a latency of at least <span class="math">16\\Delta</span> time. Moreover, their GA protocol requires eventual stable participation for liveness.</p>

    <p class="text-gray-300">A concurrent and independent work by Gafni-Losa <em>[28]</em> also presents a sleepy consensus with <span class="math">O(\\Delta)</span> expected latency with optimal corruption threshold. They also remove the eventual stable participation assumption. The best-case latency is <span class="math">10\\Delta</span> and the expected latency is <span class="math">20\\Delta</span>. In contrast, our protocol achieves <span class="math">4\\Delta</span> best-case latency and <span class="math">14\\Delta</span> expected latency. The protocol consists of sequential invocations of Commit-Adopt sub-protocol (similar to GA). We also note that their protocol is a single-shot and agreement-style protocol rather than an atomic broadcast. Furthermore, their adversary model is rather strong, abstracting away the possibility of a costless simulation attack.</p>

    <p class="text-gray-300">Dynamic participation of corrupt nodes. Another drawback of the previous sleepy consensus protocols is that they do not support growing corrupt participation (proportional to the overall participation level) unless assuming proof-of-work (or other strong assumptions <em>[12, 15, 16]</em>) due to the costless simulation problem <em>[16]</em>. Our protocol removes this constraint and supports growing corruption. An interesting insight</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">latency</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">best-case</td>

            <td class="px-3 py-2 border-b border-gray-700">expected</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">longest-chain PoS [33, 25, 5, 12]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κΔ/γ)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">multi-chain [6, 21, 27]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Δ/γ)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Goyal et al. [23]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κΔ)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Momose-Ren [29]</td>

            <td class="px-3 py-2 border-b border-gray-700">16Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">32Δ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Gafni-Losa [28]</td>

            <td class="px-3 py-2 border-b border-gray-700">10Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">20Δ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">4Δ</td>

            <td class="px-3 py-2 border-b border-gray-700">14Δ</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Latency of sleepy consensus.  <span class="math">\\kappa</span>  is the security level,  <span class="math">\\gamma</span>  is the active participation level, and  <span class="math">\\Delta</span>  is the bound on network delay.</p>

    <p class="text-gray-300">we learned is "stateless" algorithm is the key to supporting growing corruption. Namely, each protocol's step must depend only on the recent messages. If the protocol makes decisions based on long-past messages, it would be vulnerable to an adversary trying to fabricate past messages (i.e., the backward simulation). This shows another advantage of the classic BFT-like quorum-based design for sleepy consensus; the longest-chain paradigm is by design vulnerable to backward simulation as they depend on the whole mining results in the past.</p>

    <p class="text-gray-300">A possible but orthogonal technique to defend against backward simulation is key evolution [10, 15]. Here, honest nodes constantly evolve their signing keys and erase their stale keys so that when they are corrupted, the adversary cannot access their old keys to simulate past messages on their behalf. This technique is effective in preventing backward simulation in the static and known participation model (e.g., in Algorand [10]). In the sleepy model with dynamic participation, however, an additional strong assumption is required for this technique to work: an adversary cannot corrupt a new active node before it completes evolving the key. Otherwise, an adversary could corrupt nodes immediately after they wake up, gain access to their original keys and sign their past messages.</p>

    <p class="text-gray-300">Fallback under asynchrony. As mentioned in Section 2, the synchrony assumption is necessary for consensus in the sleepy model. Therefore, it is inherent that our protocol loses safety under asynchrony. Nonetheless, there have been a few proposals to balance dynamic participation and partition tolerance [31, 36]. These protocols involve running a partially synchronous checkpointing protocol on top of the underlying sleepy consensus, which is also applicable to our protocol.</p>

    <p class="text-gray-300">Tolerating bounded asynchrony. D'Amato et al. [13] proposes extending our protocol with 1/3 fault tolerance (in Appendix A) to withstand a bounded period of asynchrony by restricting the degree of corrupt nodes' dynamic participation.</p>

    <p class="text-gray-300">This work presents an atomic broadcast protocol in the sleepy model with  <span class="math">4\\Delta</span>  latency in the best case, based on the new construction of a view-based protocol optimized for reducing best-case latency. Our protocol achieves liveness under wildly fluctuating honest participation with the new GA protocol that does not require stable honest nodes. The stateless nature of our atomic broadcast protocol allows us to achieve tolerance to growing corruption and also achieve efficient recovery for new active nodes.</p>

    <p class="text-gray-300">We have shown the impossibility of supporting fluctuating corruption (both growing/shrinking) with the standard adversary that can extract all corrupt nodes' private state. However, the assumption is too strong in practice. For example, in the proof-of-stake protocols, it is highly unlikely that corrupt nodes hand off their secret keys to the adversary (or other corrupt nodes) at the risk of losing their entire stake. Supporting corrupt nodes' fluctuation in a weaker but more realistic model is an interesting future work.</p>

    <p class="text-gray-300">Acknowledgement</p>

    <p class="text-gray-300">We would like to thank the anonymous reviewers at ACM CCS 2023 for their helpful feedback. We also thank Lorenzo Alvisi, Ittay Eyal, Jacob Leshno, Kartik Nayak, Youer Pu, Jun Wan, for valuable discussions. This work is supported in part by NSF award 2143058.</p>

    <h2 id="sec-46" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Ittai Abraham, Srinivas Devadas, Danny Dolev, Kartik Nayak, and Ling Ren. Synchronous byzantine agreement with expected <span class="math">o(1)</span> rounds, expected <span class="math">o(n^{2})</span> communication, and optimal resilience. In Financial Cryptography and Data Security (FC), pages 320–334. Springer, 2019.</li>

      <li>[2] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Maofan Yin. Sync hotstuff: Simple and practical synchronous state machine replication. In IEEE Symposium on Security and Privacy (S&P), pages 106–118. IEEE, 2020.</li>

      <li>[3] Ittai Abraham, Kartik Nayak, Ling Ren, and Zhuolun Xiang. Good-case latency of byzantine broadcast: A complete categorization. In ACM Symposium on Principles of Distributed Computing (PODC), pages 331–341, 2021.</li>

      <li>[4] Hagit Attiya and Keren Censor. Lower bounds for randomized consensus under a weak adversary. In ACM Symposium on Principles of Distributed Computing (PODC), pages 315–324, 2008.</li>

      <li>[5] Christian Badertscher, Peter Gaži, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas. Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. In ACM SIGSAC Conference on Computer and Communications Security (CCS), pages 913–930, 2018.</li>

      <li>[6] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath. Prism: Deconstructing the blockchain to approach physical limits. In ACM SIGSAC Conference on Computer and Communications Security (CCS), pages 585–602, 2019.</li>

      <li>[7] Gabriel Bracha and Sam Toueg. Asynchronous consensus and broadcast protocols. Journal of the ACM (JACM), 32(4):824–840, 1985.</li>

      <li>[8] Ethan Buchman. Tendermint: Byzantine fault tolerance in the age of blockchains. PhD thesis, 2016.</li>

      <li>[9] Miguel Castro, Barbara Liskov, et al. Practical byzantine fault tolerance. In 3rd Symposium on Operating Systems Design and Implementation (OSDI), pages 173–186. USENIX, 1999.</li>

      <li>[10] Jing Chen and Silvio Micali. Algorand. arXiv preprint arXiv:1607.01341, 2016.</li>

      <li>[11] Flaviu Cristian, Houtan Aghili, Ray Strong, and Danny Dolev. Atomic broadcast: From simple message diffusion to byzantine agreement. Information and Computation, 118(1):158–179, 1995.</li>

      <li>[12] Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Robustly reconfigurable consensus and applications to provably secure proof of stake. In Financial Cryptography and Data Security (FC), pages 23–41. Springer, 2019.</li>

      <li>[13] Francesco D’Amato, Giuliano Losa, and Luca Zanolini. Improving asynchrony resilience in dynamically available total-order broadcast protocols. arXiv preprint arXiv:2309.05347, 2023.</li>

      <li>[14] Francesco D’Amato, Joachim Neu, Ertem Nusret Tas, and David Tse. No more attacks on proof-of-stake ethereum? arXiv preprint arXiv:2209.03255, 2022.</li>

      <li>[15] Bernardo David, Peter Gaži, Aggelos Kiayias, and Alexander Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), pages 66–98. Springer, 2018.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[16] Soubhik Deb, Sreeram Kannan, and David Tse. Posat: Proof-of-work availability and unpredictability, without the work. arXiv preprint arXiv:2010.08154, 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[17] Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement. SIAM Journal on Computing, 12(4):656–666, 1983.</li>

      <li>[18] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. Journal of the ACM, 35(2):288–323, 1988.</li>

      <li>[19] Paul Feldman and Silvio Micali. Optimal algorithms for byzantine agreement. In 20th Annual ACM Symposium on Theory of Computing (STOC), pages 148–161, 1988.</li>

      <li>[20] Michael J Fischer, Nancy A Lynch, and Michael S Paterson. Impossibility of distributed consensus with one faulty process. Journal of the ACM (JACM), 32(2):374–382, 1985.</li>

      <li>[21] Matthias Fitzi, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Parallel chains: Improving throughput and latency of blockchain protocols via parallel composition. IACR Cryptology ePrint Archive, Report 2018/1119, 2018.</li>

      <li>[22] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich. Algorand: Scaling byzantine agreements for cryptocurrencies. In 26th Symposium on Operating Systems Principles (SOSP), pages 51–68, 2017.</li>

      <li>[23] Vipul Goyal, Hanjun Li, and Justin Raizes. Instant block confirmation in the sleepy model. In Financial Cryptography and Data Security (FC), 2021.</li>

      <li>[24] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. Journal of Computer and System Sciences, 75(2):91–112, 2009.</li>

      <li>[25] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Annual International Cryptology Conference (CRYPTO), pages 357–388. Springer, 2017.</li>

      <li>[26] Leslie Lamport, Robert Shostak, and Marshall Pease. The byzantine generals problem. ACM Transactions on Programming Languages and Systems, 4(3):382–401, 1982.</li>

      <li>[27] Songze Li and David Tse. Taiji: Longest chain availability with bft fast confirmation. arXiv preprint arXiv:2011.11097, 2020.</li>

      <li>[28] Giuliano Losa and Eli Gafni. Consensus in the unknown-participation message-adversary model. arXiv preprint arXiv:2301.04817, 2023.</li>

      <li>[29] Atsuki Momose and Ling Ren. Constant latency in sleepy consensus. In ACM SIGSAC Conference on Computer and Communications Security (CCS), pages 2295–2308, 2022.</li>

      <li>[30] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</li>

      <li>[31] Joachim Neu, Ertem Nusret Tas, and David Tse. Ebb-and-flow protocols: A resolution of the availability-finality dilemma. arXiv preprint arXiv:2009.04987, 2020.</li>

      <li>[32] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), pages 643–673. Springer, 2017.</li>

      <li>[33] Rafael Pass and Elaine Shi. The sleepy model of consensus. In Annual International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT), pages 380–409. Springer, 2017.</li>

    </ul>

    <p class="text-gray-300">[34] Marshall Pease, Robert Shostak, and Leslie Lamport. Reaching agreement in the presence of faults. Journal of the ACM (JACM), 27(2):228–234, 1980.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[35] Ling Ren. Analysis of nakamoto consensus. 2019.</li>

      <li>[36] Suryanarayana Sankagiri, Xuechao Wang, Sreeram Kannan, and Pramod Viswanath. The checkpointed longest chain: User-dependent adaptivity and finality. arXiv preprint arXiv:2010.13711, 2020.</li>

      <li>[37] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abraham. Hotstuff: Bft consensus with linearity and responsiveness. In ACM Symposium on Principles of Distributed Computing (PODC), pages 347–356. ACM, 2019.</li>

    </ul>

    <h2 id="sec-47" class="text-2xl font-bold">Appendix A Atomic Broadcast with <span class="math">1/3</span> Fault Tolerance and <span class="math">3\\Delta</span> latency</h2>

    <p class="text-gray-300">This section presents an atomic broadcast protocol with the best-case <span class="math">3\\Delta</span> latency by slightly degrading the fault tolerance from <span class="math">\\alpha=1/2</span> to <span class="math">1/3</span>. More specifically, our protocol operates in <span class="math">(\\infty,T_{b},1/3)</span>-sleepy model with <span class="math">T_{b}=\\Delta</span>. Our protocol consists of a VRF-based proposal election followed by two sequential graded agreements (GA). We will first describe a GA protocol and then the atomic broadcast protocol.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">A.1 Graded Agreement</h3>

    <p class="text-gray-300">Our GA protocol provides two properties besides the GA definition given in 2. Specifically,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Uniqueness. If an honest node outputs a block <span class="math">B</span> with grade 1, then no honest node outputs any conflicting block <span class="math">B^{\\prime}</span> with grade 1.</li>

      <li>Bounded divergence. Suppose an honest node outputs a block <span class="math">B</span>, then the node can output at most one block <span class="math">B^{\\prime}</span> conflicting with <span class="math">B</span> (expect blocks consistent with <span class="math">B^{\\prime}</span>).</li>

    </ol>

    <p class="text-gray-300">Our protocol. Our GA protocol is described in Figure 3. It takes one round of communication. At the beginning of the round (time <span class="math">t=0</span>), awake nodes vote for their own input blocks. At the end of the round (time <span class="math">t=\\Delta</span>), awake nodes tally votes and decide the outputs. If a block is voted by more than <span class="math">2/3</span> of voters (the node hears from), the node outputs the block with grade 1; and if the block is voted by more than <span class="math">1/3</span> but less than <span class="math">2/3</span> of voters, then the node outputs the block with grade 0. Here, a vote for a block is also considered a vote for all its prefixes. Also, votes for different blocks from the same node (an obvious corrupt behavior) are simply ignored.</p>

    <p class="text-gray-300">Proof sketch. This simple protocol achieves GA by the following arguments. First, although the number of voters is unknown, more than <span class="math">2/3</span> of voters are honest, and every honest node hears from them; validity holds. If <span class="math">&gt;2/3</span> of voters (that a node hears from) vote for the same block, all other nodes at least receive votes for the block from <span class="math">&gt;1/3</span> of voters (that they hear from); graded consistency holds. Moreover, these <span class="math">&gt;1/3</span> voters are honest, so no other block can collect <span class="math">&gt;2/3</span> votes; uniqueness holds. Integrity follows from the fact that <span class="math">&gt;1/3</span> of voters must include one honest node. Finally, as different vote messages from the same node are ignored, bounded divergence holds.</p>

    <p class="text-gray-300">Our GA protocol provides the following formal guarantees. Note that all of the proofs below hold assuming either authenticated channels or digital signatures plus PKI.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Lemma 14 (Graded delivery).</h6>

    <p class="text-gray-300">If an honest node outputs <span class="math">(B,1)</span>, then all honest nodes awake at time <span class="math">t=\\Delta</span> output <span class="math">(B,*)</span></p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose an honest node <span class="math">p</span> outputs <span class="math">(B,1)</span>, then it sees more than <span class="math">2m/3</span> votes for <span class="math">B</span> where <span class="math">m</span> is the number of vote messages <span class="math">p</span> receives by time <span class="math">t=\\Delta</span>. Let <span class="math">n</span> be the number of nodes awake at time <span class="math">t=0</span>. Then, more than <span class="math">2n/3</span> honest nodes are awake at time <span class="math">t=0</span>, and these nodes will vote. Given the way we define the fault threshold, there are less than <span class="math">n/3</span> corrupt nodes that are ever awake during the time interval <span class="math">[0,\\Delta]</span>.</p>

    <p class="text-gray-300">Node <span class="math">p</span> executes the following algorithm at every time <span class="math">0\\leq t\\leq T_{b}</span> after starting the protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>time <span class="math">t=0</span>. send <span class="math">\\langle\\mathsf{vote},B\\rangle_{p}</span> where <span class="math">B</span> is the input block.</li>

      <li>time <span class="math">t=\\Delta</span>. tally <span class="math">\\mathsf{vote}</span> messages and decides the outputs as follows. Let <span class="math">m</span> be the number of <span class="math">\\mathsf{vote}</span> messages received.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">B</span> voted by <span class="math">&gt;2m/3</span> nodes, output <span class="math">(B,1)</span></li>

      <li>For any <span class="math">B</span> voted by <span class="math">&gt;m/3</span> nodes (but <span class="math">\\leq 2m/3</span>), output <span class="math">(B,0)</span></li>

    </ol>

    <p class="text-gray-300">Here, <span class="math">B^{\\prime}</span> extends <span class="math">B</span>, then <span class="math">\\langle\\mathsf{vote},B^{\\prime}\\rangle</span> is also counted as a vote for <span class="math">B</span>. Two different <span class="math">\\mathsf{vote}</span> messages from the same node are ignored.</p>

    <p class="text-gray-300">Figure 3: GA: Our graded agreement protocol with 1/3 fault tolerance</p>

    <p class="text-gray-300">Thus, the <span class="math">m</span> messages <span class="math">p</span> receives consist of <span class="math">h&gt;2n/3</span> messages from honest nodes and <span class="math">\\beta&lt;n/3</span> messages from faulty nodes. By the same argument, another honest node <span class="math">q</span> awake at time <span class="math">t=\\Delta</span> receives <span class="math">m^{\\prime}=h+\\beta^{\\prime}</span> messages where <span class="math">\\beta^{\\prime}&lt;n/3</span> messages are from faulty nodes. Now, the number of <span class="math">\\mathsf{vote}</span> messages for <span class="math">B</span> that <span class="math">p</span> receives from honest nodes is more than</p>

    <p class="text-gray-300"><span class="math">2m/3-\\beta</span> <span class="math">=2(h+\\beta)/3-\\beta=2h/3-\\beta/3</span> <span class="math">&gt;h/3+\\beta^{\\prime}/3=m^{\\prime}/3.</span></p>

    <p class="text-gray-300">The inequality step uses the fact that <span class="math">h&gt;\\beta+\\beta^{\\prime}</span>. These honest nodes must also send the same <span class="math">\\mathsf{vote}</span> messages to <span class="math">q</span>. Therefore, out of the <span class="math">m^{\\prime}</span> votes <span class="math">q</span> receives, <span class="math">&gt;m^{\\prime}/3</span> votes are for <span class="math">B</span>, and output <span class="math">(B,*)</span>. ∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 15 (integrity).</h6>

    <p class="text-gray-300">If an honest node outputs <span class="math">(B,*)</span>, then at least an honest node inputs a block extending <span class="math">B</span>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose an honest node <span class="math">p</span> outputs <span class="math">(B,*)</span>, then it sees <span class="math">&gt;m/3</span> votes for <span class="math">B</span> where <span class="math">m</span> is the number of <span class="math">\\mathsf{vote}</span> messages <span class="math">p</span> receives by time <span class="math">t=\\Delta</span>. The <span class="math">m</span> messages include <span class="math">h&gt;2n/3</span> messages from honest nodes and <span class="math">\\beta&lt;n/3</span> messages from faulty nodes, where <span class="math">n</span> is the number of nodes awake at time <span class="math">t=0</span>. So the number of <span class="math">\\mathsf{vote}</span> messages voting for <span class="math">B</span> that <span class="math">p</span> receives from honest nodes is more than</p>

    <p class="text-gray-300"><span class="math">m/3-\\beta=(h+\\beta)/3-\\beta=(h-2\\beta)/3&gt;0.</span></p>

    <p class="text-gray-300">This implies at least one honest node must have input a block that extends <span class="math">B</span>. ∎</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 16 (validity).</h6>

    <p class="text-gray-300">Let <span class="math">B</span> be the highest block that every honest node’s input extends. Then, all honest nodes awake at <span class="math">t=\\Delta</span> output <span class="math">(B,1)</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">m</span> be the number of messages an honest node <span class="math">p</span> awake at time <span class="math">t=\\Delta</span> receives. The <span class="math">m</span> messages consist of <span class="math">h&gt;2n/3</span> messages from honest nodes and <span class="math">\\beta&lt;n/3</span> messages from faulty nodes, where <span class="math">n</span> is the number of nodes awake at time <span class="math">t=0</span>. As all <span class="math">h</span> honest nodes awake at time <span class="math">t=0</span> must vote for <span class="math">B</span>, <span class="math">p</span> must receive <span class="math">h&gt;2m/3</span> votes for <span class="math">B</span>, and output <span class="math">(B,1)</span>. ∎</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Lemma 17 (uniqueness).</h6>

    <p class="text-gray-300">If an honest node outputs <span class="math">(B,1)</span> and another honest node outputs <span class="math">(B^{\\prime},1)</span>, then <span class="math">B</span> and <span class="math">B^{\\prime}</span> do not conflict with each other.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose an honest node <span class="math">p</span> outputs <span class="math">(B,1)</span>, then it sees <span class="math">&gt;2m/3</span> votes for <span class="math">B</span> where <span class="math">m</span> is the number of <span class="math">\\mathsf{vote}</span> messages <span class="math">p</span> receives. By the same logic in the proof of graded consistency, we have that out of the <span class="math">m^{\\prime}</span> votes received by an honest node <span class="math">q</span> awake at <span class="math">t=\\Delta</span>, <span class="math">&gt;m^{\\prime}/3</span> votes are for <span class="math">B</span> and come from honest nodes. So <span class="math">q</span> cannot see more than <span class="math">2m^{\\prime}/3</span> votes for a block conflicting with <span class="math">B</span> and cannot output such a block with grade 1. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Lemma 18 (bounded divergence). Suppose an honest node outputs a block  <span class="math">B</span> , then the node can output at most one block  <span class="math">B&#x27;</span>  conflicting with  <span class="math">B</span>  (expect blocks consistent with  <span class="math">B&#x27;</span> ).</p>

    <p class="text-gray-300">Proof. In order to be an output, a block must be voted by  <span class="math">&amp;gt; m / 3</span>  nodes out of the  <span class="math">m</span>  votes received. Recall that conflicting vote messages from the same node are ignored. Thus, each node outputs at most two conflicting chains of blocks.</p>

    <p class="text-gray-300">Now we described our atomic broadcast protocol. The protocol is summarized in Figure 4.</p>

    <p class="text-gray-300">Overview. Our protocol progresses through iterated views with each view lasts  <span class="math">2\\Delta</span>  time, but the first view (view 0) lasts only  <span class="math">\\Delta</span> . Thus, view  <span class="math">v \\geq 1</span>  starts at time  <span class="math">(2v - 1)\\Delta</span> . For convenience, we also say "time  <span class="math">t = \\tau</span>  of view  <span class="math">v</span> " to refer to time  <span class="math">t = (2v - 1)\\Delta + \\tau</span> .</p>

    <p class="text-gray-300">Nodes propose blocks for view  <span class="math">v</span>  in the second round of view  <span class="math">v - 1</span>  (i.e., sent at time  <span class="math">\\Delta</span>  of view  <span class="math">v - 1</span> ). They also include VRF evaluation on the view number  <span class="math">\\mathsf{VRF}_p(v)</span>  in their proposals for electing a proposal. At the beginning of view  <span class="math">v</span>  (time 0 of view  <span class="math">v</span> ), a node chooses a proposal with the highest valid VRF evaluation and treats the node who sent it as the leader. The very first view  <span class="math">v = 0</span>  serves only as the "propose" step for view  <span class="math">v = 1</span> , which is why it takes  <span class="math">\\Delta</span> .</p>

    <p class="text-gray-300">A block is decided after two sequential invocations of GA. A node inputs the leader's proposed block to the first GA (denoted  <span class="math">\\mathsf{GA}_{v,1}</span> ) at time 0. A block output by the first GA with grade 1 is input to the second GA (denoted  <span class="math">\\mathsf{GA}_{v,2}</span> ) at time  <span class="math">\\Delta</span> . Recall that GA always outputs a block with grade 1 (by validity). Finally, a block output by the second GA with grade 1 is decided at time  <span class="math">2\\Delta</span> . The two GA invocations also update two key variables respectively: lock and candidate, denoted by candidate  <span class="math">v</span>  and lock  <span class="math">v</span> . The subscript refers to the view these variables are set.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{lock}_0</span>  and candidate  <span class="math">0</span>  are defined as the genesis block. Node  <span class="math">p</span>  runs the following algorithm if it is awake at time  <span class="math">t</span> . View 0 lasts  <span class="math">\\Delta</span>  time. At time  <span class="math">t = 0</span>  of view 0, send  <span class="math">\\langle \\mathsf{propose}, B, \\mathsf{VRF}_p(1) \\rangle_p</span>  to propose the first block  <span class="math">B</span>  extending the genesis block. All later views  <span class="math">v \\geq 1</span>  each take  <span class="math">2\\Delta</span>  and work as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>time  <span class="math">t = 0</span> . start  <span class="math">\\mathsf{GA}_{v,1}</span> ; The input is a block in the propose message with the largest valid VRF on  <span class="math">v</span>  that does not conflict with  <span class="math">\\mathsf{lock}_{v-1}</span> .</li>

      <li>time  <span class="math">t = \\Delta</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>start  <span class="math">\\mathsf{GA}_{v,2}</span> ; The input is the highest block  <span class="math">B</span>  such that  <span class="math">\\mathsf{GA}_{v,1}</span>  outputs  <span class="math">(B,1)</span> .</li>

      <li>Let candidate  <span class="math">v</span>  be the highest block such that  <span class="math">\\mathsf{GA}_{v,1}</span>  outputs with any grade. (If there are two such blocks, pick one at random.) Then, send  <span class="math">\\langle \\text{propose}, B&#x27;, \\mathsf{VRF}_p(v + 1) \\rangle_p</span>  where the new block  <span class="math">B&#x27;</span>  extends candidate  <span class="math">v</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>time  <span class="math">t = 2\\Delta</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\mathsf{GA}_{v,2}</span>  outputs  <span class="math">(B,1)</span> , decide the block  <span class="math">B</span> .</li>

      <li>set  <span class="math">\\mathsf{lock}_v</span>  to the highest block  <span class="math">B&#x27;</span>  such that  <span class="math">\\mathsf{GA}_{v,2}</span>  outputs  <span class="math">(B&#x27;, *)</span> .</li>

    </ul>

    <p class="text-gray-300">Note that  <span class="math">t = 2\\Delta</span>  of view  <span class="math">v</span>  matches  <span class="math">t = 0</span>  of view  <span class="math">v + 1</span> .</p>

    <p class="text-gray-300">Figure 4: Atomic broadcast with  <span class="math">1/3</span>  fault tolerance and  <span class="math">3\\Delta</span>  latency</p>

    <p class="text-gray-300">We prove the safety and liveness of our protocol.</p>

    <p class="text-gray-300">Lemma 19 (safety). If two honest nodes decide blocks  <span class="math">B</span>  and  <span class="math">B&#x27;</span> , then  <span class="math">B</span>  and  <span class="math">B&#x27;</span>  do not conflict with each other.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Without loss of generality, suppose <span class="math">B</span> is decided in view <span class="math">v</span> and <span class="math">B^{\\prime}</span> is decided in view <span class="math">v^{\\prime}\\geq v</span>. The honest node who decides <span class="math">B</span> must have output <span class="math">(B,1)</span> in <span class="math">\\mathsf{GA}_{v,2}</span>. If <span class="math">v=v^{\\prime}</span>, then the lemma follows from the uniqueness of <span class="math">\\mathsf{GA}_{v,2}</span>. So we consider <span class="math">v^{\\prime}&gt;v</span>. Due to graded delivery of <span class="math">\\mathsf{GA}_{v,2}</span>, any honest node <span class="math">p</span> awake at time <span class="math">t=2\\Delta</span> of view <span class="math">v</span> must have output <span class="math">(B,*)</span> in <span class="math">\\mathsf{GA}_{v,2}</span>. We also observe that <span class="math">p</span> could not have output any block conflicting with <span class="math">B</span> in <span class="math">\\mathsf{GA}_{v,2}</span>; otherwise, two conflicting blocks must have been output with grade 1 from <span class="math">\\mathsf{GA}_{v,1}</span> by honest nodes, which violates GA uniqueness. Therefore, <span class="math">p</span> must have set <span class="math">\\mathsf{lock}_{v}</span> to a block extending <span class="math">B</span>, and hence input to <span class="math">\\mathsf{GA}_{v+1,1}</span> a block extending <span class="math">B</span>. Due to integrity, <span class="math">\\mathsf{GA}_{v+1,1}</span>, and inductively all later GAs, must output blocks extending <span class="math">B</span>. Hence, <span class="math">B^{\\prime}</span> must extend <span class="math">B</span>. ∎</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Lemma 20 (liveness).</h6>

    <p class="text-gray-300">If an honest node inputs a value <span class="math">x</span> to the atomic broadcast protocol, then there exists a time <span class="math">t</span> such that all honest nodes awake at <span class="math">t</span> decide a block containing <span class="math">x</span>.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If an honest node has the highest VRF in view <span class="math">v</span>, we call that node the honest leader. If all honest nodes awake at time <span class="math">t=0</span> of view <span class="math">v</span> input to <span class="math">\\mathsf{GA}_{v,1}</span> a block proposed by an honest leader, then the block must be decided. The only reason an honest node does not input the leader’s proposal to <span class="math">\\mathsf{GA}_{v,1}</span> is that it conflicts with its lock <span class="math">\\mathsf{lock}_{v-1}</span>. We prove all awake honest node <em>accept</em> (i.e., input to <span class="math">\\mathsf{GA}_{v,1}</span>) the leader’s proposal with probability more than <span class="math">1/2</span>.</p>

    <p class="text-gray-300">Let <span class="math">B</span> be the highest block among the locks (i.e., variable <span class="math">\\mathsf{lock}_{v-1}</span>) of honest nodes awake at time <span class="math">t=0</span> of view <span class="math">v</span>. Then, there exists an honest node <span class="math">p</span> who outputs <span class="math">(B,*)</span> from <span class="math">\\mathsf{GA}_{v-1,2}</span>. Then, at least an honest node <span class="math">q</span> must have input to <span class="math">\\mathsf{GA}_{v,2}</span> a block extending <span class="math">B</span> after outputting <span class="math">(B,1)</span> in <span class="math">\\mathsf{GA}_{v-1,1}</span>. Due to graded delivery, the leader must have output <span class="math">(B,0)</span> in <span class="math">\\mathsf{GA}_{v-1,1}</span>. Due to bounded divergence, the leader outputs at most one other conflicting block from <span class="math">\\mathsf{GA}_{v-1,1}</span>. Therefore, with probability at least <span class="math">1/2</span>, the leader proposes a block extending <span class="math">B</span>. Due to uniqueness, all honest nodes awake at time <span class="math">t=0</span> of view <span class="math">v</span> set their lock values <span class="math">\\mathsf{lock}_{v-1}</span> to blocks extending <span class="math">B</span> (as we are assuming <span class="math">B</span> is the longest among them). Therefore, with probability at least <span class="math">1/2</span>, the leader’s proposal is accepted by all honest nodes awake at time <span class="math">t=0</span> of view <span class="math">v</span>.</p>

    <p class="text-gray-300">Now, as more than <span class="math">2/3</span> of awake nodes are honest at all times, an honest leader exists in each view with at least <span class="math">2/3</span> probability. Hence, a block is decided in each view with at least <span class="math">1/3</span> probability. All values input by honest nodes to the atomic broadcast are eventually included in a decided block. ∎</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Towards Practical Sleepy BFT (2022/1448)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1448
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
