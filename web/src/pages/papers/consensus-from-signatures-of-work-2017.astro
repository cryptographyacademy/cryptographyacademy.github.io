---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/775';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-22';
const TITLE_HTML = 'Consensus from Signatures of Work';
const AUTHORS_HTML = 'Juan A. Garay Texas A&amp;M University garay@cse.tamu.edu';

const CONTENT = `    <p class="text-gray-300">Juan A. Garay Texas A&amp;M University garay@cse.tamu.edu</p>

    <p class="text-gray-300">Aggelos Kiayias* University of Edinburgh &amp; IOHK akiayias@inf.ed.ac.uk</p>

    <p class="text-gray-300">Giorgos Panagiotakos University of Edinburgh giorgos.pan@ed.ac.uk</p>

    <p class="text-gray-300">April 13, 2020</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Assuming the existence of a public-key infrastructure (PKI), digital signatures are a fundamental building block in the design of secure consensus protocols with optimal resilience. More recently, with the advent of blockchain protocols like Bitcoin, consensus has been considered in the &quot;permissionless&quot; setting where no authentication or even point-to-point communication is available. Yet, despite some positive preliminary results, all attempts to formalize a building block that is sufficient for designing consensus protocols in this setting, rely on a very strong independence assumption about adversarial accesses to the underlying computational resource.</p>

    <p class="text-gray-300">In this work, we relax this assumption by putting forth a primitive, which we call signatures of work (SoW). Distinctive features of our new notion are a lower bound on the number of steps required to produce a signature; fast verification; moderate unforgeability—producing a sequence of SoWs, for chosen messages, does not provide an advantage to an adversary in terms of running time; and honest signing time independence—most relevant in concurrent multi-party applications, as we show.</p>

    <p class="text-gray-300">Armed with SoW, we then present a new permissionless consensus protocol which is secure assuming an honest majority of computational power, thus in a sense providing a blockchain counterpart to the classical Dolev-Strong consensus protocol. The protocol is built on top of a SoW-based blockchain and standard properties of the underlying hash function, thus improving on the known provably secure consensus protocols in this setting, which rely on the strong independence property mentioned above in a fundamental way.</p>

    <p class="text-gray-300">&lt;sup&gt;*&lt;/sup&gt;Research partly supported by Horizon 2020 project PANORAMIX, No. 653497.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">Contents</h3>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Introduction</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Preliminaries</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Signatures of Work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Applications</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1&lt;br&gt;The Permissionless Model, Revisited&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2&lt;br&gt;Public Transaction Ledger from Signatures of Work&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2.1&lt;br&gt;The Bitcoin backbone protocol.&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2.2&lt;br&gt;Security properties of the blockchain.&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2.3&lt;br&gt;Security proof.&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3&lt;br&gt;Consensus from Signatures of Work&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SoW Constructions from Idealized Assumptions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2 id="sec-3" class="text-2xl font-bold">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;1 Introduction</h2>

    <p class="text-gray-300">The consensus problem—reaching agreement distributedly in the presence of faults—has been extensively studied in the literature starting with the seminal work of Shostak, Pease and Lamport <a href="#page-38-0">[48,</a> <a href="#page-37-0">42]</a>. The problem formulation has a number of servers (parties) starting with an individual input which should agree at the end to a joint output that has to match the input in the case where all non-faulty servers happened to have the same input value. One of the critical measures of effectiveness for consensus protocols is maximizing their resilience to Byzantine faults, typically denoted by t. It is known that t &lt; n/2 is necessary to achieve consensus, where n is the total number of parties, while protocols have been designed that reach that level of resilience assuming synchrony and a way to authenticate messages using digital signatures <a href="#page-36-0">[22]</a> <a href="#page-2-1">1</a> (or &quot;pseudosignatures&quot; <a href="#page-38-1">[49]</a>). This result is known to be tight since lack of synchrony would imply t &lt; n/3 <a href="#page-36-1">[24]</a> (as well as randomization <a href="#page-36-2">[27]</a>), while lack of a message authentication mechanism has a similar effect <a href="#page-36-3">[18]</a>.</p>

    <p class="text-gray-300">Recently, with the advent of blockchain protocols like Bitcoin, the problem has experienced renewed interest from a much wider community of researchers and has seen its application expand to various novel settings, such as the so-called &quot;permissionless&quot; setting, where participation in the protocol is both unrestricted and unauthenticated. In fact, this setting was initially studied in <a href="#page-37-1">[45,</a> <a href="#page-37-2">46]</a>, where it was shown that deterministic consensus algorithms are impossible for even a single failure but that probabilistic consensus is still feasible by suitably adapting the protocols of <a href="#page-36-4">[13,</a> <a href="#page-36-5">26]</a>. Nevertheless, the resulting protocol required exponentially many rounds in n.</p>

    <p class="text-gray-300">The first efficient solutions for the consensus problem in the permissionless setting were formally shown to be possible utilizing an abstraction of the Bitcoin blockchain protocol in <a href="#page-37-3">[31]</a>, against adversaries controlling less than half of the computational power which, in a uniform configuration (meaning parties are endowed with the same computational power), corresponds to a number of Byzantine faults t &lt; n/2 in the original setting. At a high level, these protocols (as well as the Bitcoin blockchain protocol itself) rely on a concept known as proofs of work (PoW), which, intuitively, enables one party to convince others that he has invested some computational effort for solving a given task. While being formulated a while back <a href="#page-36-6">[25]</a> and used for a variety of purposes—e,g, spam mitigation <a href="#page-36-6">[25]</a>, sybil attacks <a href="#page-36-7">[23]</a>, and denial of service protection <a href="#page-37-4">[38,</a> <a href="#page-35-0">5]</a>—their role in the design of permissionless blockchain protocols <a href="#page-37-5">[44]</a>, is arguably their most impactful application.</p>

    <p class="text-gray-300">In the context of permissionless blockchain protocols, the way a PoW-like primitive helps is by slowing down message generation for all parties indiscriminately, thus generating opportunities for honest parties to converge to a unique view under the assumption that the aggregate computational power of honest parties sufficiently exceeds that of the adversary. Now, while this intuition matches the more rigorous analyses of the Bitcoin protocol that have been carried out so far <a href="#page-37-3">[31,</a> <a href="#page-37-6">47,</a> <a href="#page-37-7">32,</a> <a href="#page-35-1">7]</a>, these works have refrained from formally defining such enabling functionality as a stand-alone cryptographic primitive, and relied instead on the random oracle (RO) model <a href="#page-35-2">[11]</a> or similar idealized assumptions (cf. the Ftree functionality in <a href="#page-37-6">[47]</a>) to prove directly the properties of the blockchain protocol. The same is true for other provably secure PoW-based distributed protocols <a href="#page-35-3">[3,</a> <a href="#page-37-8">39,</a> <a href="#page-37-9">33]</a>.</p>

    <p class="text-gray-300">The core of the hardness (or even impossibility <a href="#page-36-8">[20]</a>) of implementing the assumed idealized resources is that they satisfy a strong independence property: Each bit output on a new query to the resource is independently sampled, even if the adversary is the one who is accessing the resource. This is indeed a very strong property, as it directly implies that the best way to compute a PoW for both an honest party and the adversary is brute force. Moreover, the same property is explicitly used to argue the security of the proposed consensus protocols in the PoW setting <a href="#page-37-3">[31,</a> <a href="#page-35-3">3]</a>, as we explain in</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt;Recall that the protocol in <a href="#page-36-0">[22]</a> tolerates an arbitrary number of Byzantine faults (n &gt; t), but in the version of the problem of a single sender (a.k.a. &quot;Byzantine Generals,&quot; or just broadcast); in the case of consensus, t &lt; n/2 is necessary regardless of the resources available to the parties in the protocol execution (see, e.g., <a href="#page-36-9">[28,</a> <a href="#page-36-10">29]</a>).</p>

    <p class="text-gray-300">detail later.</p>

    <p class="text-gray-300">In this work we make progress in relaxing this assumption, by putting forth a formalization of a PoW-like primitive, which we call signatures of work (SoW). An SoW can be implemented in the RO model or by using Ftree, but the adversarial SoW computation process does not necessarily satisfy such strong guarantees as the ones mentioned above. Indeed, in contrast to previous approaches, only an upper bound on the rate at which the adversary generates SoWs needs to be assumed. We then present a new permissionless consensus protocol based on SoWs that can be proven secure without relying on such strong independence guarantees. The protocol utilizes a SoW-based blockchain and standard properties of the underlying hash function, and is secure assuming an honest majority of computational power. As a result, this protocol can be seen as an exemplar of how a permissionless signature-like primitive enables honest majority consensus in the same way that classical digital signatures imply honest-majority consensus protocols in the traditional setting.</p>

    <p class="text-gray-300">Why signatures of work? We first provide some intuition behind the relevance of SoW as a useful primitive for the design of permissionless distributed protocols. Recall the main property of a digital signature in the design of classical consensus protocols: It enables parties to communicate to each other their protocol view and inputs at a certain stage of the protocol execution in a way that is transferable and non-repudiable. Indeed, Bob, upon receiving Alice's signed message, can show it to Charlie in a way that the latter is unequivocally convinced of the message's origin. It follows that Bob cannot modify Alice's messages, playing man-in-the-middle between Alice and Charlie, and thus Alice can be held accountable in case she provides conflicting views to the two parties. A SoW scheme provides a similar capability: Using a SoW, a party like Alice can invest effort into a specific protocol view and inputs, so that when Bob is presented with a SoW produced by Alice it will be infeasible for Alice to provide a conflicting view and inputs to Charlie, unless she invests twice the effort. Moreover, the above argument holds without establishing any set of identities among the parties, so for example Bob does not need to know he talks to Alice per se but rather to an arbitrary party that invested some effort with respect to a specific protocol view. Furthermore, exactly like digital signatures, SoWs can be chained recursively, enabling the parties to build on each other's protocol view.</p>

    <p class="text-gray-300">While the above functionalities hint to the usefulness of SoWs in the distributed permissionless setting, formalizing and applying them properly is no simple task. Firstly, in contrast with classical signatures, there is no secret key involved in this primitive. This make sense, since in a permisionless setting signing messages using some kind of secret information is meaningless, as parties do no have any secret setup to begin with. Hence, if they are to sign any message, they should use some other kind of resource that only they have access to, such as their computational power. Secondly, in classical signatures, the exact time when the verification key becomes available to different parties is irrelevant; The key is only useful for verification, up to polynomial-time differences. In the context of SoWs, however, this time is of great importance. For example, allowing a party to learn the verification key, say, two days earlier than other parties, means that this party will be able to compute two days worth of signatures more than them. Hence, in contexts where counting the number of generated signatures matters, as is the case in blockchain protocols, great care should be taken on guaranteeing that the verification key is &quot;fresh&quot; enough for the relevant application.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our results. Our contributions are are as follows:</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Formalization of an SoW scheme. The syntax of an SoW scheme entails four algorithms: Public parameter generation, key generation, signing and verification—PPub,KeyGen, Sign and Verify, respectively. PPub is invoked on input 1&lt;sup&gt;λ&lt;/sup&gt; , where λ is the security parameter, and outputs public security parameters pp. KeyGen is invoked on input pp, and outputs a random verification key vk. Sign is invoked on input (pp, vk, msg, h), where msg is the message to be signed, and h is the hardness level of the signature generation. Expectedly, Verify is invoked on input (pp, vk, msg, h, σ), where σ is (possibly) an output of Sign. We require a SoW scheme to be:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Correct: As in the case of classical signatures, we require that signatures produced by Sign should be accepted by the Verify algorithm.</li>
      <li>(t, α)-Successful: This property lower-bounds the probability that an honest signer will successfully produce a SoW in a certain number of steps t; α is a function of the hardness level h.</li>
      <li>t-Verifiable: The verifier should be able to verify a SoW in t steps. (Typically, t is a lot smaller than the time need to produce a signature.)</li>
      <li>Moderately Unforgeable against Tampering and Chosen-Message Attacks ((β, )-MU-TCMA): This property is akin to the property of existential unforgeability under chosen-message attacks of digital signatures (EU-CMA). It captures the fact that producing a sequence of SoWs, for chosen messages, does not provide an advantage to an adversary in terms of running time. Specifically, the chances to produce more than β · t SoWs in t steps (for any t) are less than . <a href="#page-4-0">2</a> Further, this should hold against an adversary able to tamper with the keys, and even in the presence of a Sign oracle.</li>
      <li>Run-time independent: This final property captures the setting where honest signers are potentially invoked on adversarial inputs and ensures that their running time enjoys some degree of independence. Specifically, the random variables defined as the running time of each Sign invocation is a set of almost independent random variables (cf. <a href="#page-35-4">[1]</a>). We stress that the adversarial signing algorithm may not satisfy this property.</li>
    </ul>

    <p class="text-gray-300">As a &quot;sanity check,&quot; we show in the full version of the paper that a SoW scheme can be easily designed and proven secure in the random oracle model (or by using Ftree), and hence in practice can be instantiated by a cryptographic hash function such as SHA-256.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consensus from SoW. Next, we design a consensus protocol for an honest majority of computational power that can be reduced to the SoW primitive above. The core idea behind our new protocol is as follows. First, the parties build a blockchain using SoWs in a way reminiscent of the Bitcoin blockchain. Using SoWs we show how to emulate the Bitcoin backbone protocol <a href="#page-37-3">[31]</a> by having parties compute a SoW in parallel, &quot;on top&quot; of the current view that incorporates the largest number of SoWs, i.e., the longest chain. However, in contrast with the consensus protocol of <a href="#page-37-3">[31]</a>, to generate a block, the parties include not only their input to the consensus protocol, but also the headers of &quot;orphan&quot; blocks that exist in forks stemming off their main chain and which have not been included so far, where the header of a block contains the hash of the previous block in the chain, the signature, the input to the consensus protocol, and a hash of the block's contents.</li>
    </ol>

    <p class="text-gray-300">Using this mechanism, as shown in Figure <a href="#page-5-0">1,</a> we prove that it is possible to reconstruct the whole tree of block headers from the blockchain contents, and thus in this way preserve all block headers produced by the honest parties. This ensures that the resulting ledger will reflect the number of parties and hence a consensus protocol may now be easily reduced to this blockchain protocol.</p>

    <p class="text-gray-300">Our new consensus protocol relying on the SoW primitive in the setting where no PKI is available, exemplifies the contrast with consensus in the classical setting, relying on standard signatures and a PKI setup <a href="#page-36-0">[22]</a> (cf. <a href="#page-36-10">[29]</a>). It is worth noting that the only known blockchain-based provably secure and optimally resilient consensus protocol is given in <a href="#page-37-3">[31]</a>, using a technique called &quot;2-for-1 PoW&quot; where two PoW-based protocols can be run concurrently and create a blockchain where the number of honest-party contributions is proportional to their actual number, but which relies on the strong independence property of the RO model, discussed earlier, in a fundamental way. Indeed, in the RO model, each witness for a PoW can be rearranged in a certain way so as to obtain a test for a witness for another PoW in a way that is independent from the first solution. Our new protocol gets rid of</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;2&lt;/sup&gt;Note that, unlike previous unforgeability definitions (e.g, <a href="#page-36-11">[12]</a>), this definition is parameterized by the rate β at which the adversary can produce signatures, instead of the number of steps it needs to compute one. We feel that this formulation is more appropriate for the moderate unforgeability game where the adversary tries to produce multiple signatures. For further details, see Definition <a href="#page-10-0">7.</a></p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;    <img src="_page_5_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: The data structure maintained by the consensus protocol. Block F has consensus input 1, and includes the headers of blocks D and G, with input 1 and 0, respectively. Block D includes the headers of invalid blocks. This is not a problem, since any chain that contains D will be invalid and not selected by any party, while D's consensus input is correctly counted as a valid block header.</p>

    <p class="text-gray-300">this need. The only other (non-blockchain) PoW-based consensus protocol <a href="#page-35-3">[3]</a> also relies on the RO model.</p>

    <p class="text-gray-300">As intermediate steps in our analysis, we first introduce an appropriate adaptation of the model of <a href="#page-37-3">[31]</a> that allows for a standard model analysis and which may be of independent interest. We then recall the three basic properties of the blockchain data structure presented in <a href="#page-37-3">[31]</a>: (strong) common prefix, chain quality and chain growth, and show how our SoW-based blockchain protocol satisfies them assuming, beyond the security of SoW, standard collision resistance from the underlying hash function that is used to &quot;glue&quot; the blocks together. This is achieved as follows: We first prove that using the MU-TCMA property and assuming the adversarial hashing power is suitably bounded, it is unlikely in any sufficiently long time window for the adversary to exceed the number of SoWs of the honest parties. Then, using the (t, α)-Successful and (β, )-MU-TCMA properties in conjunction with run-time independence, we establish that summations of running times of successive Sign invocations have the variance needed to ensure that &quot;uniquely successful rounds&quot; (i.e., rounds where exactly one of the honest parties produces a SoW) happen with high density in any sufficiently long time window. Using these last two core results, and under suitable constraints for the basic SoW parameters α, β, , h and number of parties n, we prove that the the security of the Bitcoin backbone protocol implements a robust transaction ledger <a href="#page-37-3">[31]</a>. Further, and as a sanity check, in the full version of the paper, we argue that the results we get from our black-box analysis (and the RO-based SoW construction mentioned earlier), are similar to those from the random-oracle analysis of <a href="#page-37-3">[31]</a>.</p>

    <p class="text-gray-300">Our analysis is carried out in the synchronous setting. It is relatively straightforward to extend our results to the ∆-synchronous setting of <a href="#page-37-6">[47]</a>, by using the same techniques as in <a href="#page-37-10">[30]</a> (Section 7)]. We leave as an open question extending our results to the variable difficulty setting of <a href="#page-37-7">[32]</a>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Other applications. In addition to the blockchain and consensus applications of SoW, we note that the security properties we put forth are suitable for the more traditional DDOS setting, with considerable advantages over existing approaches (cf. <a href="#page-38-2">[54]</a>). The problem is as follows: A server wants to protect itself from malicious actors in the network which send network packets to eat up its resources. The canonical defense for this attack is for the server to run a PoW challenge-response protocol with the sender, in order to make sending a message costly. The MU-TCMA property, we have defined, directly implies exactly this property in the strongest sense: For any, adaptively selected, set of messages sent, the adversary must consume computational resources proportional to the number of messages, even if it can also see SoWs sent by other parties. Moreover, this process can be made non-interactive by delegating the generation of the verification key to some public randomness service, e.g., the NIST beacon, and only accept messages that include a SoW with respect to this key. Finally, note that the same security guarantees can be easily extended to multiple servers who use the same beacon, by requiring that the sent messages contain some unique identification string.</li>
    </ol>

    <p class="text-gray-300">Prior and related work. We have already mentioned above relevant related work regarding classical and blockchain-based consensus protocols. For a more exhaustive recent survey, refer to [29]. We also note that the focus of the paper is the original consensus problem [48, 42], and not so-called &quot;ledger consensus&quot; (sometimes referred to as &quot;Nakamoto consensus&quot;), which is an instance of the state machine replication problem [51]; see also [29] for an overview of such protocols. The idea of referencing off-chain blocks has been considered early on in the ledger consensus literature (see, e.g., [43, 53, 52, 14]) as a way to obtain fairness, better throughput and faster confirmation times. Our novelty is that we leverage this technique along with the new SoW notion to build a provably secure consensus protocol, which, unlike prior results, is not based on the &quot;2-for-1 PoW&quot; technique described earlier.</p>

    <p class="text-gray-300">There have been a number of attempts to formalize a proof of work (PoW) primitive that it is also sufficient to imply the security of a blockchain protocol. Nevertheless, such works were either informal [6, 50, 37], or they did not produce a correctness proof for a blockchain or consensus protocol, focusing instead on other applications [16, 2, 17, 8, 35]. We proceed to give a partial list of such considerations.</p>

    <p class="text-gray-300">In [35], Garay et al. study the necessary hardness condition that the underlying computational problem should satisfy in order for Bitcoin to implement a public ledger. In contrast to our work, an enhanced version of that security notion is shown to be sufficient to implement a public ledger against an adversary controlling only 1/3 (as opposed to 1/2) of the computational power. Further, it is unclear whether such notion can be used to solve the original consensus problem.</p>

    <p class="text-gray-300">Another effort to formalize an intermediate PoW-like building block for the Bitcoin protocol was made in [47]. The proposed ideal functionality,  <span class="math">\\mathcal{F}_{\\text{TREE}}^p</span> , keeps track of a tree of messages, which both the honest parties and the adversary can extend with probability p. The outcome of each such trial is independent of the others, even if it is made by the adversary.  <span class="math">\\mathcal{F}_{\\text{TREE}}^p</span>  satisfies the strong independence property mentioned before, and hence it is not suitable for the goals of this paper. Moreover, we note that any protocol instantiating this functionality must necessarily be <em>interactive</em>, as two parties can use  <span class="math">\\mathcal{F}_{\\text{TREE}}^p</span>  to communicate at least one bit. Finally, in [47], it was shown how to implement a transaction ledger, but not how to achieve consensus; the techniques introduced in this paper can be adapted to implement a consensus protocol using  <span class="math">\\mathcal{F}_{\\text{TREE}}</span> .</p>

    <p class="text-gray-300">Another relevant work, is that of Back et al. [6] and of Poelstra [50], where the concept of &quot;dynamic membership multi-party signatures&quot; (DMMS) is proposed to describe the underlying primitive used in Bitcoin. The author of the latter work also argues the security of Bitcoin, based on a DMMS scheme. While the properties described there bear some similarities to our work, the treatment is not formal.</p>

    <p class="text-gray-300">Another related work, is that of Dwork and Naor [25], which considered PoWs under the term &quot;pricing functions,&quot; as a means of protection against spam e-mail. The main properties discussed in their work are amortization resistance, &quot;moderate hardness&quot; and the existence of trapdoors (&quot;shortcuts&quot; in their terms). Interestingly, among the three constructions described there, one of them is a partially &quot;broken&quot; signature scheme, i.e., while it is hard for an attacker to obtain the signing key, it is moderately hard to forge signatures.</p>

    <p class="text-gray-300">In a different direction, Juels and Jacobsson [37] and Back [4, 5] use PoWs to construct electronic payment systems. In [37], the authors consider the following properties: Amortization resistance, fast verification, and some special &quot;useful work&quot; property which states that generating a PoW for some scheme may help in generating a PoW for another scheme. As acknowledged by the authors themselves, the definitions they provide are only sketches. In [4, 5] another set of closely related properties is considered, including amortization and &quot;trapdoor-freeness.&quot; Amortization refers to the ability to combine PoWs of lesser difficulty in order to construct PoWs of greater difficulty. &quot;Trapdoor-freeness&quot; dictates that the party which generates the initial parameters of the scheme should not be able to also generate a trapdoor regarding these parameters. Again the approach is not rigorous.</p>

    <p class="text-gray-300">Bitansky et al. [16] construct time-lock puzzles as well as PoW schemes from randomized encod-</p>

    <p class="text-gray-300">ings. Since the focus of their work is time-lock puzzles, the properties of PoW schemes—amortization resistance, moderate hardness and fast verification—are only briefly investigated, although they do instantiate a PoW scheme based on randomized encodings and the existence of non-amortizing languages in the worst case.</p>

    <p class="text-gray-300">Another interesting approach is that of Ball <em>et al.</em> [8], who construct a PoW from worst case assumptions. They base the security of their PoW system on the worst case hardness of classical complexity theory problems, e.g., the Orthogonal Vectors problem. As many of the previously mentioned works, they also adopt a proof-system view in their security definitions.</p>

    <p class="text-gray-300">In [2], Alwen and Tackmann study moderately hard functions (MoHF), providing simulation based definitions for what they call &quot;non-interactive proofs of effort&quot; (niPoE), which—as explicitly acknowledged by the authors—cannot be used to analyze Bitcoin. The main impediment is that the adversary can only invoke the same MoHF only once per protocol session, while for the Bitcoin protocol multiple invocations of the same MoHF should be allowed.</p>

    <p class="text-gray-300">Another related moderately hard (albeit in a sequential manner) primitive is the recently introduced notion of Verifiable Delay Functions (VDF) [17]. However, while the authors explicitly mention the encoding of messages using the primitive, the provided security definitions do not capture CMA security, a property which is necessary in a concurrent multi-party setting.</p>

    <p class="text-gray-300">Summary of differences with a previous version [34]. The most important difference of this version of the paper from [34] is the introduction of the notion of SoW, replacing the Proof of Work (PoW) notion. Moreover, many proofs have been rewritten in a clearer fashion, and the properties required from the underlying computational primitive have been simplified. Finally, additional related work regarding consensus protocols has been added.</p>

    <p class="text-gray-300">Organization of the paper. The basic computational model, definitions and cryptographic building blocks used by our constructions are presented in Section 2. Formal definition of the SoW primitive and its security properties are presented in Section 3. Section 4 is dedicated to applications of SoW: First, we introduce an appropriate model for our applications (Section 4.1). We then analyze the Bitcoin backbone protocol based on (and reducing its security to) SoW (Section 4.2), followed by the new blockchain-based consensus protocol (Section 4.3). Further, and as a &quot;sanity check,&quot; in Section 5 we show how to implement SoW in the RO model, or using  <span class="math">\\mathcal{F}_{TREE}</span> .</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;2 Preliminaries</h3>

    <p class="text-gray-300">In this section we introduce basic notation and definitions that are used in the rest of the paper. For  <span class="math">k \\in \\mathbb{N}^+</span> , [k] denotes the set  <span class="math">\\{1,\\ldots,k\\}</span> . For strings x,z,x||z is the concatenation of x and z, and |x| denotes the length of x. We denote sequences by  <span class="math">(a_i)_{i\\in I}</span> , where I is the index set. For a set X,  <span class="math">x \\leftarrow X</span>  denotes sampling a uniform element from X. For a distribution  <span class="math">\\mathcal{U}</span>  over a set  <span class="math">X,x\\leftarrow\\mathcal{U}</span>  denotes sampling an element of X according to  <span class="math">\\mathcal{U}</span> . By  <span class="math">\\mathcal{U}_{\\lambda}</span>  we denote the uniform distribution over  <span class="math">\\{0,1\\}^{\\lambda}</span> . We denote the statistical distance between two random variables X,Z with range  <span class="math">\\mathcal{U}</span>  by  <span class="math">\\Delta[X,Y]</span> , i.e.,  <span class="math">\\Delta[X,Z]=\\frac{1}{2}\\sum_{v\\in\\mathcal{U}}|\\Pr[X=v]-\\Pr[Z=v]|</span> . For  <span class="math">\\epsilon&gt;0</span> , we say that X,Y are  <span class="math">\\epsilon</span> -close when  <span class="math">\\Delta(X,Y)\\leq\\epsilon</span> . We let  <span class="math">\\lambda</span>  denote the security parameter. In this paper we will follow a more concrete (&quot;exact&quot;) approach [12,9,36,15] to security evaluation rather than an asymptotic one. We will use functions  <span class="math">t,\\epsilon</span> , whose ranges are  <span class="math">\\mathbb{N},\\mathbb{R}</span> , respectively, and have possibly many different arguments, to denote concrete bounds on the running time (number of steps) and probability of adversarial success of an algorithm in some fixed computational model, respectively. When we speak about running time this will include the execution time plus the length of the code (cf. [15]; note also that we will be considering uniform machines). We will always assume that t is a polynomial in the security parameter  <span class="math">\\lambda</span> , although we will sometimes omit this dependency for brevity.</p>

    <p class="text-gray-300">Instead of using interactive Turing machines (ITMs) as the underlying model of distributed computation, we will use (interactive) RAMs. The reason is that we need a model where subroutine access and simulation do not incur a significant overhead. ITMs are not suitable for this purpose, since one needs to account for the additional steps to go back-and-forth all the way to the place where the subroutine is stored. A similar choice was made by Garay et al. <a href="#page-37-15">[36]</a>; refer to <a href="#page-37-15">[36]</a> for details on using interactive RAMs in a UC-like framework, as well as to Section <a href="#page-12-1">4.1.</a> Given a RAM M, we will denote by StepsM(1&lt;sup&gt;λ&lt;/sup&gt; , x) the random variable that corresponds to the number of steps of M given as input the security parameter 1&lt;sup&gt;λ&lt;/sup&gt; and x. We will say that M is t-bounded if it holds that Pr[StepsM(1&lt;sup&gt;λ&lt;/sup&gt; , x) ≤ t(λ)] = 1.</p>

    <p class="text-gray-300">Finally, we remark that in our analyses there will be asymptotic terms of the form negl(λ) and concrete terms; throughout the paper, we will assume that λ is large enough to render the asymptotic terms insignificant compared to the concrete terms.</p>

    <p class="text-gray-300">Cryptographic hash functions. We will make use of the following notion of security for cryptographic hash functions:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-1&quot;&gt;&lt;/span&gt;Definition 1. Let H = {{H&lt;sup&gt;k&lt;/sup&gt; : M(λ) → Y (λ)}k∈K(λ)}λ∈&lt;sup&gt;N&lt;/sup&gt; be a hash-function family, and A be a PPT adversary. Then H is collision resistant if and only if for any λ ∈ N and corresponding {Hk}k∈&lt;sup&gt;K&lt;/sup&gt; in H,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[k \\leftarrow K; (m, m&#x27;) \\leftarrow \\mathcal{A}(1^{\\lambda}, k); (m \\neq m&#x27;) \\land (H_k(m) = H_k(m&#x27;))] \\leq \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300">Robust public transaction ledgers. The notion of a public transaction ledger was introduced in <a href="#page-37-3">[31]</a> to describe the functionality implemented by the Bitcoin protocol. It is defined with respect to a set of valid ledgers L and a set of valid transactions T , each one possessing an efficient membership test. A ledger x ∈ L is a vector of sequences of transactions tx ∈ T . Ledgers correspond to chains in the Bitcoin protocol. It is possible for the adversary to create two transactions that are conflicting; valid ledgers must not contain conflicting transaction. Moreover, it is assumed that in the protocol execution there also exists an oracle Txgen that generates valid transactions, and is unambiguous, i.e., the adversary cannot create transactions that come in 'conflict' with the transactions generated by the oracle. A transaction is called neutral if there does not exist any transactions that comes in conflict with it.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;Definition 2. A protocol Π implements a robust public transaction ledger if it organizes the ledger as a chain of blocks of transactions and satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Persistence: Parameterized by k ∈ N (the &quot;depth&quot; parameter), if in a certain round an honest player reports a ledger that contains a transaction tx in a block more than k blocks away from the end of the ledger, then tx will always be reported in the same position in the ledger by any honest player from this round on.</li>
      <li>Liveness: Parameterized by u, k ∈ N (the &quot;wait time&quot; and &quot;depth&quot; parameters, resp.), provided that a transaction either (i) issued by Txgen, or (ii) is neutral, is given as input to all honest players continuously for u consecutive rounds, then all honest parties will report this transaction at a block more than k blocks from the end of the ledger.</li>
    </ul>

    <p class="text-gray-300">The consensus problem. Next, we give the definition of the well-known consensus problem (a.k.a. Byzantine agreement) <a href="#page-38-0">[48,</a> <a href="#page-37-0">42]</a>. There are n parties, t &lt; n of which might be corrupted, taking an initial input x ∈ V (without loss of generality, we can assume V = {0, 1}).</p>

    <p class="text-gray-300">Definition 3. A protocol Π solves the consensus problem provided it satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Agreement. All honest parties will output the same value eventually.</li>
      <li>Validity. If all the honest parties have the same input, then they all output this value.</li>
    </ul>

    <h2 id="sec-6" class="text-2xl font-bold">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;3 Signatures of Work</h2>

    <p class="text-gray-300">The main goal of this paper is to implement consensus in the permissionless setting without relying on the strong independence property of the underlying computational resource. Towards that goal, in this section we introduce the signature of work (SoW) primitive. At a high level, a SoW enables one party to convince others that she has invested some computational power during some specific time interval and with respect to a &quot;message.&quot; Next, we formalize this notion and present its desired security properties.</p>

    <p class="text-gray-300">SoW syntax. Given a security parameter λ, let P P be the public parameter space, HP ⊆ N the hardness parameter space, K the key space, M the message space, and S the signature space. With foresight, the role of the key is to provide &quot;freshness&quot; for the signature computation, thus certifying that the signature was computed in the given time interval.</p>

    <p class="text-gray-300">Definition 4. A SoW scheme consists of four algorithms SoW = (PPub,KeyGen, Sign, Verify), where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>PPub(1&lt;sup&gt;λ&lt;/sup&gt; ) is a randomized algorithm that takes as input the security parameter λ, and returns a set of public parameters pp ∈ P P.</li>
      <li>KeyGen(pp) is a randomized algorithm that takes as input the public parameters pp, and returns a key vk ∈ K. (See Remark <a href="#page-9-1">1</a> below on the role of keys in SoW schemes.)</li>
      <li>Sign(pp, vk, msg, h) is a randomized algorithm that takes as input public parameters pp ∈ P P, a key vk ∈ K, a message msg ∈ M and hardness parameter h ∈ HP, and returns a signature (of work) σ ∈ S.</li>
      <li>Verify(pp, vk, msg, h, σ) is a deterministic algorithm that takes as input public parameters pp ∈ P P, a key vk ∈ K, message msg ∈ M, hardness parameter h ∈ HP and a signature σ ∈ S, and returns true or false to indicate the validity of the signature.</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-9-1&quot;&gt;&lt;/span&gt;Remark 1. SoW schemes only have a public verification key. The role of this key is to guarantee that the computational work spent in order to create a signature of work is &quot;fresh,&quot; i.e., executed during a specific time interval (say, from the time the key became known to the signer). In contrast, classical digital signatures also have a secret key that serves as a trapdoor to compute signatures. In the applications we consider, the existence of trapdoor information is not meaningful, and in fact may hurt the security of the respective constructions.</p>

    <p class="text-gray-300">Security properties. Next, we present a number of security properties that we will require SoW schemes to satisfy. We start with the correctness property.</p>

    <p class="text-gray-300">Definition 5. We say that a SoW scheme is correct if for every λ ∈ N, pp ∈ P P, vk ∈ K, h ∈ HP, and msg ∈ M:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{Verify}(pp, vk, msg, h, \\mathsf{Sign}(pp, vk, msg, h)) = \\mathsf{true} \\quad \\right] \\geq 1 - \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300">Next, we require that the time to verify a signature be upper bounded.</p>

    <p class="text-gray-300">Definition 6. We say that a SoW scheme is t-verifiable, if Verify takes time at most t (on all inputs).</p>

    <p class="text-gray-300">Next, we capture the case of a malicious signer (resp., verifier) in the context of SoWs. In the first case, the adversary's objective is to compute a number of signatures a lot faster than an honest signer would, while in the second case it is to make the honest signer take too much time to generate a signature.</p>

    <p class="text-gray-300">We deal with malicious signers first. We put forth an attack that we will use to express a class of adversaries that attempt to forge signatures faster than expected. Intuitively, this constitutes an attack against an honest verifier that may be trying to gauge a certain measure using the number of signatures. The game defining the attack is shown in Figure 2; we call the corresponding security property  <span class="math">Moderate\\ Unforgeability\\ against\\ Tampering\\ and\\ Chosen\\ Message\\ Attack\\ (MU-TCMA).</span>  As in the security definitions of standard signatures (e.g., EU-CMA), we allow the adversary to have access to a signing oracle  <span class="math">\\mathcal{S}</span> . Every time the oracle is queried, we assume that it runs the Sign procedure with uniformly sampled randomness. A subtle point in the modeling of security in the presence of such oracle is that  <span class="math">\\mathcal{S}</span>  should also &quot;leak&quot; the number of steps it took for a query to be processed. In an actual execution while interacting with honest parties that are producing signatures, time is a side channel that may influence the adversarial strategy; in order to preserve the dependency on this side channel we will require from  <span class="math">\\mathcal{S}</span>  to leak this information. We note that in the classical signatures literature, timing attacks have also been a serious consideration [41].</p>

    <p class="text-gray-300">In addition, we require that the key used by the adversary to construct signatures be fresh, i.e., we want to avoid situations where the adversary outputs signatures that he has precomputed a long time ago. We model this by providing the fresh key after the adversary has finished running his precomputation phase. Further, we allow the adversary to tamper with the key by manipulating it via tampering functions belonging to a family of functions  <span class="math">\\mathcal{F}</span> .</p>

    <p class="text-gray-300">Looking ahead, the tampering function in our applications will be related to a keyed hash function, where the key of the hash is part of a common random string (CRS). Hence, we choose to model functions in  <span class="math">\\mathcal{F}</span>  to have two inputs:  <span class="math">\\Sigma</span>  (the CRS) and vk. Moreover, the output of the adversary is deemed invalid if he tampers vk with functions  <span class="math">f_1, f_2</span>  in such a way that  <span class="math">f_1(\\Sigma, vk) = f_2(\\Sigma, vk)</span> . Otherwise, the adversary could launch a generic attack that is unrelated to the SoW scheme, and produce signatures at twice the rate of an honest signer, as follows. The adversary first finds  <span class="math">f_1, f_2</span>  that have this property, and then computes signatures using the tampered key  <span class="math">f_1(\\Sigma, vk)</span> . The trick is that each of them will also correspond to a signature with key  <span class="math">f_2(\\Sigma, vk)</span> . Hence, he effectively can double the rate at which he produces signatures.</p>

    <p class="text-gray-300">Formally, the adversary will have access to  <span class="math">S(\\cdot, \\cdot)</span> , an SoW oracle that on input (vk', msg), where  <span class="math">vk&#x27; \\in K</span>  and  <span class="math">msg \\in M</span> , returns the pair  <span class="math">(\\sigma, t)</span>  where  <span class="math">\\sigma</span>  is the output of  <span class="math">\\mathsf{Sign}(pp, vk&#x27;, msg, h)</span>  and t is the number of steps taken by the  <span class="math">\\mathsf{Sign}</span>  algorithm on these parameters. Function  <span class="math">\\mathsf{Asked}(vk&#x27;, msg, \\sigma)</span>  is true if  <span class="math">\\sigma</span>  was the response of S to some query (vk', msg).</p>

    <p class="text-gray-300">We are now ready to formulate the security property of Moderate Unforgeability against Tampering and Chosen Message Attacks (MU-TCMA). It has two parameters,  <span class="math">\\beta</span>  and  <span class="math">\\epsilon</span> , and, informally, it states that no adversary  <span class="math">\\mathcal{A}</span>  exists in the experiment of Figure 2 that takes at most t steps after receiving key vk and produces  <span class="math">\\ell \\geq \\beta \\cdot t</span>  signatures with probability better than  <span class="math">\\epsilon</span> . Note that in total we allow  <span class="math">\\mathcal{A}</span>  to take any polynomial number of steps, i.e., the adversary is allowed to execute a precomputation stage that permits it to obtain an arbitrary number of signatures before learning vk. In the definition below, we allow  <span class="math">\\beta</span>  to depend on the hardness level h, and  <span class="math">\\epsilon</span>  on h, t and  <span class="math">q_{\\mathcal{S}}</span> , the number of queries the adversary makes to the signing oracle.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;<strong>Definition 7.</strong> Let  <span class="math">\\mathcal{F} = \\{F_{\\lambda}\\}_{{\\lambda} \\in \\mathbb{N}}</span> , where  <span class="math">F_{\\lambda}</span>  is a family of functions  <span class="math">f: \\{0,1\\}^{\\lambda} \\times K \\to K</span> . A SoW scheme is  <span class="math">(\\beta,\\epsilon)</span> -Moderately Unforgeable against Tampering and Chosen-Message Attacks (MUTCMA) with respect to tampering function class  <span class="math">\\mathcal{F}</span> , if for any polynomially large  <span class="math">t_1, t_2</span> , any adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , where  <span class="math">\\mathcal{A}_1</span>  is  <span class="math">t_1</span> -bounded and  <span class="math">\\mathcal{A}_2</span>  is  <span class="math">t_2</span> -bounded and makes at most  <span class="math">q_{\\mathcal{S}}</span>  queries to oracle  <span class="math">\\mathcal{S}</span> , for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , and any  <span class="math">h \\in HP</span> , the probability of  <span class="math">\\mathcal{A}</span>  winning in  <span class="math">\\mathsf{Exp}_{\\mathcal{A},\\mathcal{F}}^{\\mathsf{MU-TCMA}}(1^{\\lambda}, h, \\lfloor \\beta(h) \\cdot t_2 \\rfloor)</span>  (Figure 2) is less than  <span class="math">\\epsilon(h, t_2, q_{\\mathcal{S}})</span> .</p>

    <p class="text-gray-300">Remark 2. As mentioned in Section 1, unlike previous unforgeability definitions (e.g., [12]), Definition 7 is parameterized by the <em>rate</em> at which the adversary can produce signatures, instead of the number of steps it needs to compute one, which is more appropriate for the moderate unforgeability game where the adversary tries to produce multiple signatures.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^3&lt;/sup&gt;K</span>  is the key space of the SoW scheme.</p>

    <pre><code class="language-text">ExpMU-TCMA
                             A,F (1λ
                                     , h, \`)
Σ ← Uλ; pp ← PPub(1λ
               ); (Public parameters)
st ← A1(1λ
       , Σ, pp); (Precomputation)
vk ← KeyGen(pp); (Verification key)
(fi, msgi
     , σi)i∈[\`] ← AS(·,·)
             2
                (1λ
                  , vk, st); (SoW computation)
return V\`
     i=1
         Verify(pp, fi(Σ, vk), msgi
                        , σi) ∧ ¬Asked(fi(Σ, vk), msgi
                                           , σi)
         ∧ (fi ∈ Fλ) ∧ (∀j ∈ [\`] : fi(Σ, vk) = fj (Σ, vk) ⇒ i = j)
                                              !
</code></pre>

    <p class="text-gray-300">Figure 2: The Moderate Unforgeability against Tampering and Chosen-Message Attack (MU-TCMA) experiment for a SoW scheme.</p>

    <p class="text-gray-300">In the MU-TCMA definition we are going to consider tampering functions classes that at the very least preserve the unpredictability of vk. Otherwise, the adversary can generically attack any SoW scheme by predicting the tampered key and precomputing signatures. Formally, we will say that F is computationally unpredictable if the adversary, given the CRS Σ, cannot guess a value y that he will be able to &quot;hit&quot; when he gains access to vk through some f ∈ F.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;Definition 8. Let F = {Fλ}λ∈N, where F&lt;sup&gt;λ&lt;/sup&gt; is a family of functions f : {0, 1} &lt;sup&gt;λ&lt;/sup&gt; × K → K. We say that F is computationally unpredictable with respect to a SoW scheme SoW, if for any PPT RAM A = (A1, A2), and for any λ ∈ N, it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{pp \\leftarrow \\mathsf{PPub}(1^\\lambda);\\\\ vk \\leftarrow \\mathsf{KeyGen}(pp);\\\\ \\Sigma \\leftarrow \\mathcal{U}_\\lambda}} \\begin{bmatrix} (st,y) \\leftarrow \\mathcal{A}_1(1^\\lambda, \\Sigma, pp); f \\leftarrow \\mathcal{A}_2(1^\\lambda, st, vk) :\\\\ f \\in F_\\lambda \\land f(\\Sigma, vk) = y \\end{bmatrix} \\leq \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300">Next, we consider the case of attacking an honest signer. Attacking an honest signer amounts to finding a certain set of keys over which the honest signer algorithm fails to produce SoWs sufficiently fast and regularly. We say that a SoW scheme is (t, α)-successful when the probability that the signer computes a signature in t steps is at least α.</p>

    <p class="text-gray-300">Definition 9. We say that SoW scheme is (t, α)-successful if for any λ ∈ N and any h ∈ HP, it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{pp \\leftarrow \\mathsf{PPub}(1^\\lambda);\\\\ vk \\leftarrow \\mathsf{KeyGen}(pp);\\\\ msg \\leftarrow M}} \\left[ \\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk, msg, h) \\leq t \\right] \\geq \\alpha(h).</span>$</p>

    <p class="text-gray-300">Finally, in the same corrupt-verifier setting, we will require the signing time of honest signers to have some (limited) independence, which will be important for the applications we have in mind. This property, in combination with the efficiency and MU-TCMA properties, will prove crucial in ensuring that when multiple signers work together, the distribution of the number of them who succeed in producing a signature has some &quot;good&quot; variance and concentration properties.</p>

    <p class="text-gray-300">Definition 10. We say that a SoW scheme has almost-independent runtime iff for any polynomial p(·), any λ ∈ N, any h ∈ HP, there exists a set of mutually independent random variables {Yi}i∈[p(λ)] such that for any pp ∈ P P,((vk&lt;sup&gt;i&lt;/sup&gt; , mi))i∈[p(λ)] ∈ (K×M) p(λ) it holds that ∆[(StepsSign(pp, vk&lt;sup&gt;i&lt;/sup&gt; , m&lt;sup&gt;i&lt;/sup&gt; , h))&lt;sup&gt;i&lt;/sup&gt; ,(Yi)&lt;sup&gt;i&lt;/sup&gt; ] ≤ negl(λ).</p>

    <p class="text-gray-300">Independence assumptions. As mentioned earlier, MU-TCMA does not enforce any independence assumption, and only bounds the probability that the rate at which the adversary computes SoWs is high. In contrast, the independent-runtime property does so, but only for honest signers. We remark that achieving such property is considerably easier for the honest case, as we can be sure that signers will use independently sampled coins if instructed; a guarantee that we cannot have for the adversary.</p>

    <p class="text-gray-300"><strong>Parameters' range.</strong> Let SoW be a scheme that is  <span class="math">(t_{\\text{sign}}, \\alpha)</span> -Successful. SoW trivially satisfies the MU-TCMA property for  <span class="math">\\beta(h) &gt; 1</span> , since the adversary does not have enough time to output the signatures it has computed. On the other hand, assuming  <span class="math">\\epsilon(h, t, q_S)</span>  is a negligible function of t,  <span class="math">\\alpha(h)</span>  must be smaller than  <span class="math">\\beta(h) \\cdot t_{\\text{sign}}</span> , otherwise the expected number of SoWs computed by the Sign function would exceed that allowed by the MU-TCMA property. Hence, for optimal security, it should hold that  <span class="math">\\alpha(h)</span>  is close to  <span class="math">\\beta(h) \\cdot t_{\\text{sign}}</span> .</p>

    <p class="text-gray-300">Next, we turn to applications of our SoW primitive.</p>

    <h2 id="sec-7" class="text-2xl font-bold">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;4 Applications</h2>

    <p class="text-gray-300">In this section we showcase applications of SoWs, the first one being implementing robust transaction ledgers: Using our primitive and standard properties of the underlying hash function, we establish the security of the Bitcoin backbone protocol [31]. The second application is realizing consensus in the permisionless setting: We construct a new blockchain-based consensus protocol for an honest majority provably secure under the same assumptions as above, thus providing a blockchain counterpart to the classical result in the cryptographic setting with a trusted (PKI) setup [22].</p>

    <p class="text-gray-300">In both applications we assume the existence of a SoW scheme with the security properties defined bellow.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-3&quot;&gt;&lt;/span&gt;<strong>Assumption 1</strong> (SoW Assumption). For parameters  <span class="math">\\beta, \\epsilon, t&#x27;_{\\mathcal{H}}, \\alpha</span>  and  <span class="math">t_{\\text{ver}}</span>  we assume that SoW = (PPub, KeyGen, Sign, Verify) is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Correct;</li>
      <li><span class="math">(\\beta, \\epsilon)</span> -MU-TCMA with respect to any computationally unpredictable tampering function class (cf. Definition 8);</li>
      <li><span class="math">(t&#x27;_{\\mathcal{H}}, \\alpha)</span> -successful;&lt;sup&gt;4&lt;/sup&gt;</li>
      <li>almost run-time independent; and</li>
      <li><span class="math">t_{\\text{ver}}</span> -verifiable,</li>
    </ul>

    <p class="text-gray-300">where  <span class="math">\\epsilon(h,t,q_S) \\in \\mathsf{negl}(\\beta(h) \\cdot t)</span> . Moreover, we assume that the parameter spaces K,M,S of the scheme are equal to  <span class="math">\\{0,1\\}^{\\log |K|}, \\{0,1\\}^*, \\{0,1\\}^{\\log |S|}</span> , respectively.</p>

    <p class="text-gray-300">For a SoW scheme to be used in the context of the Bitcoin protocol, choosing K, M, S as above is important due to the underlying hash-chain structure of the blockchain: The hash of each block acts as a key of the SoW scheme, thus the output of the hash function should match the key space of the SoW.</p>

    <p class="text-gray-300">We start with some pertinent details about the model that the two applications mentioned above will be analyzed under.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;4.1 The Permissionless Model, Revisited</h4>

    <p class="text-gray-300">All the security models proposed for the analysis of PoW-based blockchain protocols [31, 47] rely on bounding the number of queries to an idealized functionality to model limited computational resources. In contrast, we do not wish to restrict the way the adversary accesses the computational resource, and thus we model limited computational resources in a more general manner, i.e., by limiting the exact number of steps parties take. Next, we present a revised version of the model of [31] that captures our considerations.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;4&lt;/sup&gt;Parameter  <span class="math">t&#x27;_{\\mathcal{H}}</span>  corresponds to a lower bound on the running time of honest parties that we introduce in detail later.</p>

    <p class="text-gray-300">For the reasons explained in Section 2, we substitute IRAMs for ITMs. The execution of a protocol  <span class="math">\\Pi</span>  is driven by an &quot;environment&quot; program  <span class="math">\\mathcal Z</span>  that may spawn multiple instances running the protocol  <span class="math">\\Pi</span> . The programs in question can be thought of as &quot;interactive RAMs&quot; communicating through registers in a well-defined manner, with instances and their spawning at the discretion of a control program which is also an IRAM and is denoted by C. In particular, the control program C forces the environment to perform a &quot;round-robin&quot; participant execution sequence for a fixed set of parties.</p>

    <p class="text-gray-300">Specifically, the execution driven by  <span class="math">\\mathcal{Z}</span>  is defined with respect to a protocol  <span class="math">\\Pi</span> , an adversary  <span class="math">\\mathcal{A}</span>  (also an IRAM) and a set of parties  <span class="math">P_1, ..., P_n</span> ; these are hardcoded in the control program C. The protocol  <span class="math">\\Pi</span>  is defined in a &quot;hybrid&quot; setting and has access to one &quot;ideal functionality,&quot; called the <em>diffusion channel</em> (see below). It is used as subroutine by the programs involved in the execution (the IRAMs of  <span class="math">\\Pi</span>  and  <span class="math">\\mathcal{A}</span> ) and is accessible by all parties once they are spawned.</p>

    <p class="text-gray-300">Initially, the environment  <span class="math">\\mathcal{Z}</span>  is restricted by C to spawn the adversary  <span class="math">\\mathcal{A}</span> . Each time the adversary is activated, it may communicate with C via messages of the form (Corrupt,  <span class="math">P_i</span> ). The control program C will register party  <span class="math">P_i</span>  as corrupted, only provided that the environment has previously given an input of the form (Corrupt,  <span class="math">P_i</span> ) to  <span class="math">\\mathcal{A}</span>  and that the number of corrupted parties is less or equal t, a bound that is also hardcoded in  <span class="math">\\mathcal{C}</span> . The first party to be spawned running protocol  <span class="math">\\Pi</span>  is restricted by C to be party  <span class="math">P_1</span> . After a party  <span class="math">P_i</span>  is activated, the environment is restricted to activate party  <span class="math">P_{i+1}</span> , except when  <span class="math">P_n</span>  is activated in which case the next party to be activated is always the adversary  <span class="math">\\mathcal{A}</span> . Note that when a corrupted party  <span class="math">P_i</span>  is activated the adversary  <span class="math">\\mathcal{A}</span>  is activated instead.</p>

    <p class="text-gray-300">Next, we describe how different parties communicate. Initially, the diffusion functionality sets the variable round to be 1. It also maintains a Receive() string defined for each party  <span class="math">P_i</span> . A party is allowed at any moment to fetch the messages sent to it at the previous round that are contained in its personal Receive() string. Moreover, when the functionality receives an instruction to diffuse a message m from party  <span class="math">P_i</span>  it marks the party as complete for the current round and forwards the message to the adversary; note that m is allowed to be empty. At any moment, the adversary A is allowed to specify the contents of the Receive() string for each party  <span class="math">P_i</span> . The adversary has to specify when it is complete for the current round. When all parties are complete for the current round, the functionality inspects the contents of all Receive() strings and includes any messages that were diffused by the parties in the current round but not contributed by the adversary to the Receive() tapes. The variable round is then incremented.</p>

    <p class="text-gray-300">Based on the above, we denote by  <span class="math">\\{\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,t,n}(z)\\}_{z\\in\\{0,1\\}^*}</span>  the random variable ensemble that corresponds to the view of party P at the end of an execution where  <span class="math">\\mathcal{Z}</span>  takes z as input. We will consider stand-alone executions, hence z will always be of the form  <span class="math">1^{\\lambda}</span> , for  <span class="math">\\lambda \\in \\mathbb{N}</span> . For simplicity, to denote this random variable ensemble we will use  <span class="math">\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,t,n}</span> . By  <span class="math">\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span>  we denote the concatenation of the views of all parties. The probability space where these variables are defined depends on the coins of all honest parties,  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span> .</p>

    <p class="text-gray-300">Next, we consider the complications in the modeling due to the analysis of Bitcoin in the concrete security setting. Both in [31] and [47] a modified version of the standard simulation-based paradigm of [19] is followed, where there exist both a malicious environment and a malicious adversary. In addition, the SoW scheme (called PoW in [31, 47]) is modeled in a non black-box way using a random oracle (RO), and the computational power of the adversary is then bounded by limiting the number of queries it can make to the RO per round. Since in this work the SoW scheme is modeled in a black-box way, an alternative approach to bound the adversary's power is needed.</p>

    <p class="text-gray-300">A naïve first approach is to only bound the computational power of  <span class="math">\\mathcal{A}</span> . Unfortunately this will not work for several reasons. Firstly, nothing stops the environment from aiding the adversary, i.e., computing signatures, and then communicating with it through their communication channel or some other subliminal channel. Secondly, even if we bound the <em>total</em> number of steps of  <span class="math">\\mathcal{A}</span> , it is not clear how to bound the steps it is taking per round in the model of [19], which we build on. Lastly, another issue arising is that if the adversary is able to send, say,  <span class="math">\\theta</span>  messages in each round, it can force each</p>

    <p class="text-gray-300">honest party to take  <span class="math">\\theta \\cdot t_{\\text{ver}}</span>  extra steps per round. If we don't bound  <span class="math">\\theta</span> , then the adversary will be able to launch a DOS attack and spend all the resources the honest parties have&lt;sup&gt;5&lt;/sup&gt;.</p>

    <p class="text-gray-300">In order to capture these considerations we are going to define a predicate on executions and prove our properties in disjunction with this predicate, i.e., either the property holds or the execution is not good.</p>

    <p class="text-gray-300"><strong>Definition 11.</strong> Let  <span class="math">(t_A, \\theta)</span> -good be a predicate defined on executions in the hybrid setting described above. Then E is  <span class="math">(t_A, \\theta)</span> -good, where E is one such execution, if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the total number of steps taken by  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  per round is no more than  <span class="math">t_{\\mathcal{A}}</span> ;</li>
      <li>the adversary sends at most  <span class="math">\\theta</span>  messages per round.</li>
    </ul>

    <p class="text-gray-300">Finally, we assume the existence of a <em>common reference string</em> (CRS), that becomes available to all parties at the start of the execution. This is also implicitly assumed in previous models, where either parties have access to a special &quot;genesis&quot; block at the beginning of the execution [47], or they do not have access to the RO before the beginning of the execution [31].</p>

    <p class="text-gray-300"><strong>Definition 12.</strong> Given a predicate Q and bounds  <span class="math">t_{\\mathcal{A}}, \\theta, t, n \\in \\mathbb{N}</span> , with t &lt; n, we say that protocol  <span class="math">\\Pi</span>  satisfies property Q for n parties assuming the number of corruptions is bounded by t, provided that for all PPT  <span class="math">\\mathcal{Z}, \\mathcal{A}</span> , the probability that  <span class="math">Q(\\text{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n})</span>  is false and the execution is  <span class="math">(t_{\\mathcal{A}}, \\theta)</span> -good is negligible in  <span class="math">\\lambda</span> .</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;4.2 Public Transaction Ledger from Signatures of Work</h3>

    <p class="text-gray-300">Next, we take a reduction approach to the underlying cryptographic primitive—SoW, as defined in Section 3—to prove the security of the Bitcoin backbone protocol [31]. We start with a description of the protocol based on SoW, and then continue with the security proof.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;4.2.1 The Bitcoin backbone protocol.</h4>

    <p class="text-gray-300">The Bitcoin backbone protocol [31], parameterized by functions  <span class="math">V(\\cdot), R(\\cdot), I(\\cdot)</span> , is an abstraction of the Bitcoin protocol. First, we introduce some notation needed to understand the description of the algorithms, and then cast the protocol making use of our SoW primitive.</p>

    <p class="text-gray-300">We will use the terms block and chain to refer to tuples of the form  <span class="math">\\langle s, x, \\sigma \\rangle</span>  and sequences of such tuples, respectively. The rightmost (resp. leftmost) block of chain  <span class="math">\\mathcal{C}</span>  is denoted by  <span class="math">head(\\mathcal{C})</span>  (resp.  <span class="math">tail(\\mathcal{C})</span> ). Each block contains a seed, data, and a signature denoted by  <span class="math">s, x, \\sigma</span> , respectively. As mentioned, all parties have access to a CRS at the beginning of the execution that contains: the public parameter pp of the SoW scheme, a verification key vk generated by KeyGen(pp), and the key k of the hash functions H, G used later. We will refer to  <span class="math">\\langle 0^{\\lambda}, pp||vk||k, 0^{\\lambda} \\rangle</span>  as the genesis block  <span class="math">genetic B_{Gen}</span> . A chain  <span class="math">\\mathcal{C} = B_1 \\dots B_m</span>  is valid with respect to the CRS if and only if (i)  <span class="math">genetic B_1</span>  is the genesis block, (ii) for any two consecutive blocks  <span class="math">genetic B_1</span>  is the late genesis block, besides  <span class="math">genetic B_2</span>  contains a valid SoW, i.e.,  <span class="math">genetic B_3</span>  is the genesis block  <span class="math">genetic B_4</span>  (iii) each block, besides  <span class="math">genetic B_4</span>  contains a valid SoW, i.e.,  <span class="math">genetic B_4</span>  is the genesis block  <span class="math">genetic B_4</span>  and denote it by  <span class="math">genetic B_4</span>  is the genesis block  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in</p>

    <p class="text-gray-300">At each round, each party chooses the longest valid chain amongst the ones it has received and tries to extend it by computing (mining) another valid block. If it succeeds, it diffuses the new block to the network. In more detail, each party will run the Sign procedure, with the message parameter being determined by the input contribution function  <span class="math">I(\\cdot)</span> , and the key parameter being the hash of the</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-3&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-14-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;5&lt;/sup&gt;This problem is extensively discussed in [3], Section 3.4.</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;6&lt;/sup&gt;The adversary cannot use the running time of honest parties that it has corrupted; it is activated instead of them during their turn. Also, note that it is possible to compute this number by counting the number of configurations that  <span class="math">\\mathcal{A}</span>  or  <span class="math">\\mathcal{Z}</span>  are activated per round.</p>

    <p class="text-gray-300">last block. We assume that the hardness parameter h is fixed for all executions. Finally, if the party is queried by the environment, it outputs R(C) where C is the chain selected by the party; the chain reading function R(·) interprets C differently depending on the higher-level application running on top of the backbone protocol. Each honest party runs for at most t&lt;sup&gt;H&lt;/sup&gt; steps per round. We summarize the modifications with respect to the original <a href="#page-37-3">[31]</a> protocol: In Algorithm <a href="#page-15-0">1</a> (signature of work function) the Sign function of the underlying SoW scheme is invoked for a limited number of steps so that the total number of steps of the invoking party does not exceed the t&lt;sup&gt;H&lt;/sup&gt; bound per round; in Algorithm <a href="#page-15-1">2</a> (chain validation predicate) the Verify predicate is replaced with a call to the Verify algorithm of the SoW scheme; and in Algorithm <a href="#page-16-1">3</a> (backbone protocol) we assume that the honest parties start the execution with a &quot;genesis&quot; block. We leave Algorithm <a href="#page-16-2">4</a> intact.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;Algorithm 1 The signature of work function, parameterized by pp, h and hash functions H(·), G(·). The input is (x, C).</p>

    <pre><code class="language-text">1: function sow(x, C)
2: s ← H(head(C))
3: σ ← Sign(pp, s, x, h) . Run the prover of the SoW scheme.
4: B ← ε
5: if σ 6= ⊥ then
6: B ← hs, x, σi
7: end if
8: C ← CB . Extend chain
9: return C
10: end function
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;Algorithm 2 The chain validation predicate, parameterized by pp, h, BGen, the hash functions G(·), H(·), and the input validation predicate V (·). The input is C.</p>

    <pre><code class="language-text">1: function validate(C)
2: b ← V(xC) ∧ (tail(C) = BGen) . xC describes the contents of chain C.
3: if b = True then . The chain is non-empty and meaningful w.r.t. V (·)
4: s
       0 ← H(head(C))
5: while (C 6= BGen) ∧ (b = True) do
6: hs, x, σi ← head(C)
7: if Verify(pp, s, x, h, σ) ∧ (H(head(C)) = s
                                  0
                                   ) then
8: s
           0 ← s . Retain hash value
9: C ← Cd1 . Remove the head from C
10: else
11: b ← False
12: end if
13: end while
14: end if
15: return (b)
16: end function
</code></pre>

    <p class="text-gray-300">In order to turn the backbone protocol into a protocol realizing a public transaction ledger suitable definitions were given for functions V(·), R(·),I(·) in <a href="#page-37-3">[31]</a>. We change these definitions slightly as shown in Table <a href="#page-17-1">1,</a> to ensure two things: Firstly, that the data contained in the hash chain is encoded with &lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;<strong>Algorithm 3</strong> The Bitcoin backbone protocol, parameterized by the <em>input contribution function</em>  <span class="math">I(\\cdot)</span>  and the <em>chain reading function</em>  <span class="math">R(\\cdot)</span> .</p>

    <pre><code class="language-text">1: \\mathcal{C} \\leftarrow B_{\\mathsf{Gen}}
                                                                                                                               \\triangleright Initialize \\mathcal{C} to the genesis block.
 2: st \\leftarrow \\varepsilon
 3: round \\leftarrow 0
 4: while True do
             \\tilde{\\mathcal{C}} \\leftarrow \\mathsf{maxvalid}(\\mathcal{C}, \\mathsf{any\\ chain\\ } \\mathcal{C}&#x27; \\mathsf{\\ found\\ in\\ Receive}())
             \\langle st, x \\rangle \\leftarrow I(st, \\tilde{\\mathcal{C}}, round, Input(), Receive())
                                                                                                                                                \\triangleright Determine the x-value.
 6:
             \\mathcal{C}_{\\mathsf{new}} \\leftarrow \\mathsf{sow}(x, \\tilde{\\mathcal{C}})
 7:
             if C \\neq C_{new} then
 8:
                    \\mathcal{C} \\leftarrow \\mathcal{C}_{\\mathsf{new}}
 9:
                    Broadcast(\\mathcal{C})
10:
             end if
11:
12:
             round \\leftarrow round + 1
             if Input() contains Read then
13:
                     write R(\\mathbf{x}_{\\mathcal{C}}) to OUTPUT()
14:
             end if
15:
16: end while
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-16-2&quot;&gt;&lt;/span&gt;<strong>Algorithm 4</strong> The function that finds the &quot;best&quot; chain, parameterized by function  <span class="math">\\max(\\cdot)</span> . The input is  <span class="math">\\{C_1, \\ldots, C_k\\}</span> .</p>

    <pre><code class="language-text">1: function \\max \\operatorname{valid}(\\mathcal{C}_1, \\dots, \\mathcal{C}_k)

2: temp \\leftarrow \\varepsilon

3: \\mathbf{for} \\ i = 1 \\ \\operatorname{to} \\ k \\ \\mathbf{do}

4: \\mathbf{if} \\ \\operatorname{validate}(\\mathcal{C}_i) \\ \\mathbf{then}

5: temp \\leftarrow \\max(\\mathcal{C}, temp)

6: \\mathbf{end} \\ \\mathbf{if}

7: \\mathbf{end} \\ \\mathbf{for}

8: \\mathbf{return} \\ temp

9: \\mathbf{end} \\ \\mathbf{function}
</code></pre>

    <p class="text-gray-300">a suffix-free code; this is important to ensure that no collisions occur [10] as we show later. And, secondly, to ensure that any block created by an honest party contains sufficient entropy, thus the adversary will not be able to use blocks that it has precomputed to extend this block. We call the resulting protocol  <span class="math">\\Pi_{Pl}^{SoW}</span> .</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;4.2.2 Security properties of the blockchain.</h4>

    <p class="text-gray-300">A number of desired basic properties for the blockchain were introduced in [31, 40, 47]. At a high level, the first property, called <em>common prefix</em>, has to do with the existence, as well as persistence in time, of a common prefix of blocks among the chains of honest players. Here we will consider a stronger variant of the property, presented in [47], which allows for the black-box proof of application-level properties (such as the <em>persistence</em> of transactions entered in a public transaction ledger built on top of the Bitcoin backbone).</p>

    <p class="text-gray-300">We will use  <span class="math">\\mathcal{C} \\leq \\mathcal{C}&#x27;</span>  to denote that some chain  <span class="math">\\mathcal{C}</span>  is a prefix of some other chain  <span class="math">\\mathcal{C}&#x27;</span> , and  <span class="math">\\mathcal{C}^{\\lceil k \\rceil}</span>  to denote the chain resulting from removing the last k blocks of  <span class="math">\\mathcal{C}</span> . We will call a block honest, if it was</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Content validation pre-</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">V(\\cdot)</span> is true if its input <span class="math">\\langle x_1, \\ldots, x_m \\rangle</span> is a valid ledger, i.e., it is in <span class="math">\\mathcal{L}</span> ,</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">dicate <span class="math">V(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">and each <span class="math">x_i</span> starts with a neutral transaction of the form <span class="math">r  i </span> , where</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r</span> is a string of length <span class="math">\\log  K </span> and <span class="math">i</span> is the &quot;height&quot; of the respective</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">block.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Chain reading function <span class="math">R(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R(\\cdot)</span> returns the contents of the chain if they constitute a valid ledger,</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">otherwise it is undefined.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Input contribution function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">I(\\cdot)</span> returns the largest subsequence of transactions in the input and</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">I(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">receive registers that constitute a valid ledger, with respect to the</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">contents of the chain $ C $ the party already has, preceded by a neutral</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">transaction of the form <span class="math">KeyGen(pp)   \\mathcal{C} </span> .</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: The instantiation of functions  <span class="math">I(\\cdot), V(\\cdot), R(\\cdot)</span>  for protocol  <span class="math">\\Pi^{\\texttt{SoW}}_{\\texttt{PL}}</span> .</p>

    <p class="text-gray-300">diffused for the first time in the execution by some honest party, and adversarial otherwise.</p>

    <p class="text-gray-300"><strong>Definition 13</strong> ((Strong) Common Prefix). The strong common prefix property  <span class="math">Q_{cp}</span>  with parameter  <span class="math">k \\in \\mathbb{N}</span>  states that the chains  <span class="math">C_1, C_2</span>  reported by two, not necessarily distinct honest parties  <span class="math">P_1, P_2</span> , at rounds  <span class="math">r_1, r_2</span>  in VIEW <span class="math">_{\\Pi, A, Z}^{t, n}</span> , with  <span class="math">r_1 \\leq r_2</span> , satisfy  <span class="math">C_1^{\\lceil k} \\leq C_2</span> .</p>

    <p class="text-gray-300">The next property relates to the proportion of honest blocks in any portion of some honest player's chain.</p>

    <p class="text-gray-300"><strong>Definition 14</strong> (Chain Quality). The <em>chain quality property</em>  <span class="math">Q_{cq}</span>  with parameters  <span class="math">\\mu \\in \\mathbb{R}</span>  and  <span class="math">k \\in \\mathbb{N}</span>  states that for any honest party P with chain C in  <span class="math">VIEW_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span>  it holds that for any k consecutive blocks of C the ratio of adversarial blocks is at most  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300">Further, in the derivations in [31] an important lemma was established relating to the rate at which the chains of honest players were increasing as the Bitcoin backbone protocol was run. This was explicitly considered in [40] as a property under the name <em>chain growth</em>.</p>

    <p class="text-gray-300"><strong>Definition 15</strong> (Chain Growth). The chain growth property  <span class="math">Q_{cg}</span>  with parameters  <span class="math">\\tau \\in \\mathcal{R}</span>  (the &quot;chain speed&quot; coefficient) and  <span class="math">s, r_0 \\in \\mathbb{N}</span>  states that for any round  <span class="math">r &gt; r_0</span> , where honest party P has chain  <span class="math">C_1</span>  at round r and chain  <span class="math">C_2</span>  at round r + s in  <span class="math">VIEW_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n}</span> , it holds that  <span class="math">|C_2| - |C_1| \\ge \\tau \\cdot s</span> .</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;4.2.3 Security proof.</h4>

    <p class="text-gray-300">We now prove that  <span class="math">\\Pi_{PL}^{SoW}</span>  implements a robust public transaction ledger (Definition 2), assuming the underlying SoW scheme satisfies Assumption 1 for appropriate parameters, related to the running time of honest parties and the adversary. First, we formalize this relation.</p>

    <p class="text-gray-300">Let  <span class="math">t_{\\rm bb}</span>  (bb for backbone) be an upper bound on the number of steps needed to run the code of an honest party in one round, besides the Sign and Verify calls. By carefully analyzing the backbone protocol one can extract an upper bound on this value.&lt;sup&gt;7&lt;/sup&gt; To aid our presentation, we will use  <span class="math">t&#x27;_{\\mathcal{A}}</span>  and  <span class="math">t&#x27;_{\\mathcal{H}}</span>  to denote: (i) the time needed by a RAM machine to simulate one round in the execution of the Bitcoin protocol, without taking into account calls made to the Sign routine by the honest parties, and (ii) the minimum number of steps that an honest party takes running the Sign routine per round, respectively.</p>

    <p class="text-gray-300"><span class="math">$t&#x27;_{\\mathcal{A}} = t_{\\mathcal{A}} + n \\cdot t_{\\mathsf{bb}} + \\theta t_{\\mathsf{ver}}</span>$
and  <span class="math">t&#x27;_{\\mathcal{H}} = t_{\\mathcal{H}} - t_{\\mathsf{bb}} - \\theta t_{\\mathsf{ver}}</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;7&lt;/sup&gt;Note that  <span class="math">t_{bb}</span>  depends on the running time of three external functions:  <span class="math">V(\\cdot), I(\\cdot)</span>  and  <span class="math">R(\\cdot)</span> . For example, in Bitcoin these functions include the verification of digital signatures, which would require doing modular exponentiations. In any case  <span class="math">t_{bb}</span>  is at least linear in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">It holds that at least n-t (non-corrupted) parties will run the Sign routine for at least  <span class="math">t&#x27;_{\\mathcal{H}}</span>  steps at every round.</p>

    <p class="text-gray-300">In previous works [31, 33, 47], the security assumptions regarding the computational power of the parties participating in the protocol were twofold: (1) The total running time of honest parties per round should exceed that of the adversary, and (2) the rate at which parties produce blocks at each round should be bounded. More realistically, in our approach the running time of the adversary and the running time of honest parties do not have the same quality, as the adversary may use a superior signing algorithm. To take this into account, we additionally need to assume that the efficiency of the adversarial signing algorithm, i.e.,  <span class="math">\\beta</span> , is close to that of the honest parties. Finally, note that if SoW is close to optimal, i.e.,  <span class="math">\\alpha(h) \\approx \\beta t_{\\mathcal{H}}&#x27;</span> , and the block generation rate is a lot less than 1, our assumption holds as long as the honest parties control the majority of the computational power.</p>

    <p class="text-gray-300">We now state the computational power assumption formally. The second and the third conditions are similar to the ones already found in previous works, while the first one is the new condition we introduce regarding the underlying computational primitive.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;<strong>Assumption 2</strong> (Computational Power Assumption). There exist  <span class="math">\\delta_{SoW}</span> ,  <span class="math">\\delta_{Steps}</span> ,  <span class="math">\\delta \\in (0,1)</span> , such that for sufficiently large  <span class="math">\\lambda \\in \\mathbb{N}</span> , there exists an  <span class="math">h \\in HP</span> , such that:</p>

    <pre><code class="language-text">- \\alpha(h) \\ge (1 - \\delta_{SoW})\\beta t_{\\mathcal{H}}&#x27; &gt; \\text{negl}(\\lambda)
                                                                (signatures generation rate gap)
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">$(n-t)t&#x27;_{\\mathcal{H}}(1-\\delta_{\\mathsf{Steps}}) \\ge t&#x27;_{\\mathcal{A}}</span>$
(steps gap)</li>
    </ul>

    <p class="text-gray-300"><span class="math">$- (n-t)t&#x27;_{\\mathcal{H}}(1-\\delta_{\\mathsf{Steps}}) \\geq t&#x27;_{\\mathcal{A}} \\qquad (steps \\ gap)</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\frac{\\delta_{\\mathsf{Steps}}-\\delta_{\\mathsf{SoW}}}{2} \\geq \\delta &gt; \\beta(h)(t&#x27;_{\\mathcal{A}}+nt_{\\mathcal{H}}) \\qquad (bounded \\ block \\ generation \\ rate)</span>$</p>

    <p class="text-gray-300">From now on, we will assume that the hardness parameter used in our protocols, is one satisfying the above conditions.</p>

    <p class="text-gray-300">Remark 3. The better the adversarial signing algorithm may be compared to the honest one, the closer  <span class="math">\\delta_{\\mathsf{SoW}}</span>  is to 0, while the closer the number of adversarial steps  <span class="math">t_{\\mathcal{A}}&#x27;</span>  are to that of the honest parties, the closer  <span class="math">\\delta_{\\mathsf{Steps}}</span>  is to 0. Assumption 2 implies, in a quantitative manner, that the better the adversarial signing algorithm, the smaller the computational power of the adversary we can tolerate.</p>

    <p class="text-gray-300">We introduce some additional notation. For each round j, we define the Boolean random variables  <span class="math">X_i</span>  and  <span class="math">Y_j</span>  as follows. Let  <span class="math">X_j = 1</span>  if and only if j was a successful round, i.e., at least one honest party computed a SoW at round j, and let  <span class="math">Y_j = 1</span>  if and only if j was a uniquely successful round, i.e., exactly one honest party computed a SoW at round j. With respect to a set of rounds S, let  <span class="math">X(S) = \\sum_{j \\in S} X_j</span>  and define Y(S) similarly. Moreover, with respect to some block B computed by an honest party P at some round r, let  <span class="math">Z_B(S)</span>  denote the number of distinct blocks broadcast by the adversary during S that have B as their ancestor. Define  <span class="math">X_B(S)</span>  similarly.</p>

    <p class="text-gray-300">Next, we focus on the hash functions used by Bitcoin, and the necessary security assumptions to avoid cycles in the blockchains. First, note that in the actual implementation of Bitcoin an unkeyed hash function is used, namely, a double invocation of SHA-256. In previous analyses of the protocol this was modeled as a random oracle. We choose to model it in a strictly weaker way, as a keyed hash function family:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{H} = \\{H_k : \\{0,1\\}^{\\log|K| + \\lambda + \\log|S|} \\to \\{0,1\\}^{\\log|K|}\\}_{k \\in K&#x27;}.</span>$</p>

    <p class="text-gray-300">that is collision resistant (Definition 1); the CRS we have already assumed will contain the key of our hash function. Moreover, as depicted in Figure 3, the protocol makes use of another hash function Gto compress the input x of each block, which may be of arbitrary size. In our analysis we will require Gto be collision resistant. It is well known (see, e.g., [21, 10]) that given a fixed-length collision-resistant hash function family, we can construct an arbitrary-length collision-resistant hash function family. To aid readability, we will sometimes omit the keys of both functions (as we already do in the description of the protocol). Furthermore, observe that the hash structure of any blockchain (depicted in Figure 3) is similar to the Merkle-Damgaard transform [21]:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{MD}_k(IV,(x_i)_{i\\in[m]}): z=IV; \\text{ for } i=1 \\text{ to } m \\text{ do } z=H_k(z,x_i); \\text{ return } z,</span>$</p>

    <p class="text-gray-300">where the fixed-length hash function family used is always assumed to be  <span class="math">\\mathcal{H}</span> . To show that the adversary cannot find distinct chains with the same hash, we are going to take advantage of the following property of the MD transform.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;Fact 1. For any non-empty valid chain  <span class="math">C = B_1, \\ldots, B_k</span> , where  <span class="math">B_i = \\langle s_i, x_i, \\sigma_i \\rangle</span> , it holds that for any  <span class="math">j \\in [k]</span> :  <span class="math">H_k(\\text{head}(C)) = \\text{MD}_k(H_k(B_j), ((G_k(x_i), \\sigma_i))_{i \\in \\{j+1, \\ldots, k\\}})</span> .</p>

    <p class="text-gray-300">    <img src="_page_19_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: The hash structure of the blocks in the Bitcoin protocol.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-3&quot;&gt;&lt;/span&gt;<strong>Lemma 16.</strong> The probability that any PPT RAM A can find two distinct valid chains  <span class="math">C_1, C_2</span>  such that  <span class="math">H(C_1) = H(C_2)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">C_1 = B_{\\text{Gen}}, B_1, \\ldots, B_{[|C_1|]}, C_2 = B_{\\text{Gen}}, B&#x27;_1, \\ldots, B&#x27;_{[|C_2|]}, m_1 = ((G(x_i), \\sigma_i))_{i \\in [|C_1|]}</span>  and  <span class="math">m_2 = ((G(x&#x27;_i), \\sigma&#x27;_i))_{i \\in [|C_2|]}</span> . For the sake of contradiction, assume that the lemma does not hold and there exists an adversary A that can find valid chains  <span class="math">C_1</span> ,  <span class="math">C_2</span>  such that  <span class="math">H(C_1) = H(C_2)</span> , with non-negligible probability. By Fact 1, this implies that  <span class="math">MD(H(B_{\\text{Gen}}), m_1) = MD(H(B_{\\text{Gen}}), m_2)</span> .</p>

    <p class="text-gray-300">We will construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that breaks the collision resistance of H also with non-negligible probability. We take two cases. In the first case,  <span class="math">|\\mathcal{C}_1| \\neq |\\mathcal{C}_2|</span> . Then, since the height of the chain is included in a fixed position in  <span class="math">x_{|\\mathcal{C}_1|}, x&#x27;_{|\\mathcal{C}_2|}</span>  (cf. Table 1), it follows that  <span class="math">x_{|\\mathcal{C}_1|} \\neq x&#x27;_{|\\mathcal{C}_2|}</span>  and with overwhelming probability  <span class="math">G(x_{|\\mathcal{C}_1|}) \\neq G(x&#x27;_{|\\mathcal{C}_2|})</span> , which in turn implies that  <span class="math">B_{|\\mathcal{C}_1|} \\neq B&#x27;_{|\\mathcal{C}_2|}</span> . Since  <span class="math">H(\\text{head}(\\mathcal{C}_1)) = H(\\text{head}(\\mathcal{C}_2))</span> , it follows that a collision in H has been found. In the second case, where  <span class="math">|\\mathcal{C}_1| = |\\mathcal{C}_2|</span> , following the classical inductive argument for the MD transform, it can be shown that there exists  <span class="math">\\ell</span>  less or equal to  <span class="math">|\\mathcal{C}_1|</span> , such that  <span class="math">MD(H(\\text{Gen}), ((G(x_i), \\sigma_i))_{i \\in [\\ell]}) = MD(H(\\text{Gen}), ((G(x_i&#x27;), \\sigma_i&#x27;))_{i \\in [\\ell]})</span>  and  <span class="math">(G(x_\\ell), \\sigma_\\ell) \\neq (G(x_\\ell&#x27;), \\sigma_\\ell&#x27;)</span> . The lemma follows.</p>

    <p class="text-gray-300">The following two properties&lt;sup&gt;8&lt;/sup&gt;, introduced in [31], regarding the way blocks are connected are implied by Lemma 16.</p>

    <p class="text-gray-300"><strong>Definition 17.</strong> An insertion occurs when, given a chain  <span class="math">\\mathcal{C}</span>  with two consecutive blocks B and  <span class="math">B_0</span> , a block  <span class="math">B^*</span>  created after  <span class="math">B_0</span>  is such that  <span class="math">B, B^*</span> ,  <span class="math">B_0</span>  form three consecutive blocks of a valid chain. A copy occurs if the same block exists in two different positions.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-4&quot;&gt;&lt;/span&gt;Corollary 18. Let  <span class="math">\\{H_k(\\cdot)\\}_{k\\in K}</span>  and  <span class="math">\\{G_k(\\cdot)\\}_{k\\in K}</span>  be collision-resistant hash functions. Then, no insertions and no copies occur with probability  <span class="math">1 - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Next, we prove that the adversary cannot mine blocks that extend an honest block created recently at a very high rate with probability better than that of breaking the MU-TCMA property. For a summary of our notation we refer to Table 2.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;8&lt;/sup&gt;A third property, called &quot;prediction,&quot; also introduced in [31], is not needed in our proof as it is captured by the fact that SoW is MU-TCMA secure even in the presence of adversarial precomputation.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;λ: security parametern: number of parties</p>

    <p class="text-gray-300"><span class="math">t_{\\mathcal{H}}</span> : number of steps per round per honest party  <span class="math">t_{\\mathcal{A}}</span> : total number of adversarial steps per round</p>

    <p class="text-gray-300"><span class="math">\\theta</span> : upper bound on the number of messages sent by the adversary per round</p>

    <p class="text-gray-300"><span class="math">\\beta:\\quad</span>  upper bound on SoW computation rate per step</p>

    <p class="text-gray-300"><span class="math">\\gamma</span> : lower bound on the rate of uniquely successful rounds</p>

    <p class="text-gray-300">f: lower bound on the rate of successful rounds</p>

    <p class="text-gray-300"><span class="math">\\delta</span> : advantage from the Computational Power Assumption (Assumption 2)</p>

    <p class="text-gray-300">k: number of blocks for the common-prefix property  <span class="math">\\ell</span> : number of blocks for the chain-quality property</p>

    <p class="text-gray-300">Table 2: The parameters in our analysis.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;<strong>Lemma 19.</strong> For any set of consecutive rounds S and for any party P, the probability that P mined some honest block B at some round  <span class="math">i \\in S</span>  and  <span class="math">Z_B(S) \\ge \\beta t&#x27;_A|S|</span> , is at most  <span class="math">\\epsilon(h, t&#x27;_A \\cdot |S|, n \\cdot |S|)</span> .</p>

    <p class="text-gray-300">Proof. W.l.o.g., assume that i is the first round of  <span class="math">S = \\{i&#x27; | i \\leq i&#x27; &lt; i + s\\}</span> , and let E be the event where in VIEW <span class="math">_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span>  the adversary has mined at least  <span class="math">\\beta t&#x27;_{\\mathcal{A}}s</span>  blocks until round i+s that descend some honest block B mined by party P at round i. For the sake of contradiction, assume that the lemma does not hold, and thus the probability that E holds is greater than  <span class="math">\\epsilon(h, t&#x27;_{\\mathcal{A}} \\cdot s, n \\cdot s)</span> . Using  <span class="math">\\mathcal{A}</span> , we will construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that wins the MU-TCMA game with probability greater than that.  <span class="math">\\mathcal{A}&#x27;</span>  is going to run internally  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span> , while at the same time perfectly simulating the view of honest parties using the signing oracle that he has in his disposal on the MU-TCMA game. This way, the view of  <span class="math">\\mathcal{A}, \\mathcal{Z}</span>  will be indistinguishable both in the real and the simulated runs, and thus the probability that E happens will be the same in both cases.</p>

    <p class="text-gray-300">We are going to describe the two stages of  <span class="math">\\mathcal{A}&#x27;</span>  separately, i.e. before and after obtaining vk. First,  <span class="math">\\mathcal{A}&#x27;_1</span>  creates the genesis block and sets the fixed length hash key and the SoW public parameters to be  <span class="math">\\Sigma</span>  and pp, respectively. Then, he perfectly simulates honest parties up to round i-1 and at the same time runs  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  in a black-box way. Finally, it outputs the contents of the registers of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  as variable st. He can do this since he has polynomial time on  <span class="math">\\lambda</span>  on his disposal. Note, that up until this point in the eyes of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  the simulated execution is indistinguishable compared to the real one.</p>

    <p class="text-gray-300">For the second stage,  <span class="math">\\mathcal{A}&#x27;_2</span> , is first going to use st to reset  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  to the same state that they were. We assume that this can be done efficiently, e.g., by having  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  read from the registers where st is stored whenever they perform some operation on their registers. Moreover, it is again going to simulate honest parties behavior, from round i until round i+s, but in a different way. Instead of running the Sign algorithm for each non-corrupted honest party at every round, it makes a query to the signing oracle  <span class="math">\\mathcal{S}</span>  with the respective parameters. Then, it checks if the honest party succeeded in making a signature in this round by comparing the number of steps needed to make this signature to the number of steps available to the party at this round. Hence,  <span class="math">\\mathcal{A}&#x27;_2</span>  has to do n queries to the signing oracle per round. The adversary can also send up to  <span class="math">\\theta</span>  messages per round to honest parties which they have to verify, thus inducing an additional  <span class="math">\\theta \\cdot t_{\\text{ver}}</span>  overhead in the simulation. Note that  <span class="math">\\mathcal{A}&#x27;_2</span>  has to run the verification procedure only once per message.</p>

    <p class="text-gray-300">Continuing with the description of  <span class="math">\\mathcal{A}&#x27;_2</span> , as shown in Figure 4, it takes as input a key vk generated from  <span class="math">\\mathsf{KeyGen}(pp)</span> . We should somehow relate vk to the blocks the internal adversary is going to produce. In our reduction, this is achieved by: (i) relating the block B that party P generates at round i with vk through the input contribution function  <span class="math">I(\\cdot)</span> , and (ii) by the fact that the seed of all blocks that have B as an ancestor is related to H(B). In more detail, at round i,  <span class="math">\\mathcal{A}&#x27;_2</span>  will use vk in the neutral transaction included in  <span class="math">I(\\cdot)</span>  for P; denote by  <span class="math">vk||x_0</span>  the output of I for P at this round. If</p>

    <p class="text-gray-300">P is successful at this round and mines a block  <span class="math">B = \\langle s_0, vk || x_0, \\sigma_0 \\rangle</span>  (this can be simulated using S), then any block  <span class="math">B&#x27; = \\langle s, x, \\sigma \\rangle</span>  descending B will be related to it as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} s &amp;= \\mathsf{MD}(H_\\Sigma(B), ((G_\\Sigma(x_i), \\sigma_i))_i) \\\\ &amp;= \\mathsf{MD}(H_\\Sigma(s, G_\\Sigma(vk||x_0), \\sigma_0), ((G_\\Sigma(x_i), \\sigma_i))_i) \\\\ &amp;\\stackrel{\\mathrm{def}}{=} f_{(s, \\{x_i, \\sigma_i\\}_i)}(\\Sigma, vk) \\end{split}</span>$</p>

    <p class="text-gray-300">for some  <span class="math">((x_i, \\sigma_i))_i</span>  due to Fact 1. Observe, that the seed of B' is a function of  <span class="math">\\Sigma</span>  and vk, as required by the MU-TCMA game. In fact the tampering function class we will consider is going to be exactly the set of all these functions f. More formally, let C be the set of sequences  <span class="math">((x_i, \\sigma_i))_i</span>  that correspond to a valid chain in the way described before. Then, the tampering function class we will be considering is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F} = \\{f_{s,a}\\}_{s \\in \\{0,1\\}^{\\lambda}, a \\in C}</span>$</p>

    <p class="text-gray-300">We show next, that  <span class="math">\\mathcal{F}</span>  is computationally unpredictable as required by our assumption regarding the signature scheme.</p>

    <p class="text-gray-300">Claim 1.  <span class="math">\\mathcal{F}</span>  is computationally unpredictable.</p>

    <p class="text-gray-300"><em>Proof.</em> For the sake of contradiction, assume that there exists a PPT adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  that breaks the computational unpredictability property of  <span class="math">\\mathcal{F}</span> . This implies that</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{pp \\leftarrow \\mathsf{PPub}(1^{\\lambda});\\\\ vk \\leftarrow \\mathsf{KeyGen}(pp);\\\\ \\Sigma \\leftarrow \\mathcal{U}_{\\lambda}:}} \\begin{bmatrix} (st,y) \\leftarrow \\mathcal{A}_{1}(\\Sigma, pp);\\\\ f \\leftarrow \\mathcal{A}_{2}(st, vk):\\\\ f \\in \\mathcal{F} \\land f(\\Sigma, vk) = y \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">is non-negligible. We are going to describe an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that uses  <span class="math">\\mathcal{A}</span>  to break the collision resistance property of H. Given  <span class="math">\\Sigma</span> ,  <span class="math">\\mathcal{A}&#x27;</span>  first runs  <span class="math">\\mathcal{A}_1(\\Sigma, pp)</span>  and obtains a prediction y and state st. Next,  <span class="math">\\mathcal{A}&#x27;</span>  randomly samples  <span class="math">vk_1, vk_2</span>  using KeyGen and runs  <span class="math">\\mathcal{A}_2</span>  twice on inputs  <span class="math">st, vk_1</span>  and  <span class="math">st, vk_2</span>  respectively. By an application of the splitting lemma we can show that with non-negligible probability  <span class="math">\\mathcal{A}_2</span>  will output (not necessarily different) functions  <span class="math">f_1, f_2</span>  such that  <span class="math">y = f_1(\\Sigma, vk_1) = f_2(\\Sigma, vk_2)</span> . As noted earlier, this corresponds to the hash of two chains, that due to the entropy of  <span class="math">vk_1, vk_2</span>  and the collision resistance of G start with different honestly mined blocks. Using similar techniques as in Lemma 16, we can show that  <span class="math">\\mathcal{A}&#x27;</span>  can find a collision in H using  <span class="math">f_1, f_2, vk_1, vk_2</span>  with non-negligible probability in  <span class="math">\\lambda</span> , which is a contradiction.</p>

    <p class="text-gray-300">Since  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  cannot distinguish between the bitcoin execution and the one we described above, E will occur with probability at least  <span class="math">\\epsilon(h, t&#x27;_{\\mathcal{A}}s, ns)</span> , i.e.  <span class="math">\\mathcal{A}</span>  will compute at least  <span class="math">\\beta t&#x27;_{\\mathcal{A}}s</span>  blocks starting from round i and up to round i + s that descend B. Note, that these blocks are also valid signatures, whose keys are of the form  <span class="math">f(\\Sigma, vk)</span> , for (possibly different) f's. Moreover, the event that the adversary outputs different  <span class="math">f_i</span> ,  <span class="math">f_j</span>  such that  <span class="math">f_i(\\Sigma, vk) = f_j(\\Sigma, vk)</span> , corresponds to finding chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  such that  <span class="math">H(\\mathcal{C}_1) = H(\\mathcal{C}_2)</span> . By Lemma 16, this happens with negligible probability. Hence,  <span class="math">\\mathcal{A}&#x27;</span>  will win the MUTCMA game with respect to tampering function class  <span class="math">\\mathcal{F}</span>  with probability greater than  <span class="math">\\epsilon(h, t&#x27;_{\\mathcal{A}}s, ns)</span> , while being  <span class="math">s \\cdot (t_{\\mathcal{A}} + \\theta \\cdot t_{\\text{ver}} + t_{\\text{bb}} \\cdot n) = s \\cdot t&#x27;_{\\mathcal{A}}</span> -bounded and having made at most ns queries to the signing oracle, which is a contradiction to our initial assumption. A sketch of the reduction is given at Figure 4.</p>

    <p class="text-gray-300">Note that we can do exactly the same reduction without using the oracle to simulate the signing procedure of the honest parties. Then, the total running time of the second stage of  <span class="math">\\mathcal{A}&#x27;</span>  is on the worst</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;    <img src="_page_22_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: The figure depicts a schematic of the reduction from the Bitcoin backbone to the MU-TCMA game of Lemma 19.</p>

    <p class="text-gray-300">case  <span class="math">s \\cdot (t_A + nt_H)</span> -bounded and hence the probability he can win is  <span class="math">\\epsilon(h, s \\cdot (t_A + nt_H), 0)</span> . Hence, we can derive the following bound on the total number of blocks produced by both honest and malicious parties during a certain number of rounds.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-2&quot;&gt;&lt;/span&gt;<strong>Corollary 20.</strong> For any set of consecutive rounds S and for any party P, the probability that P mined some honest block B at some round  <span class="math">i \\in S</span>  and  <span class="math">Z_B(S) + X_B(S) \\ge \\beta(t_A + nt_H) \\cdot |S|</span>  is less than  <span class="math">\\epsilon(h, |S| \\cdot (t_A + nt_H), 0)</span> .</p>

    <p class="text-gray-300">Next, we prove lower bounds on the rate of successful and uniquely successful rounds. Our proof crucially depends on the runtime independence property of the SoW scheme. More specifically, the property implies that for some set of rounds the sum of the Bernoulli random variables of the event that a round is uniquely successful, concentrate around the mean. Which in turn, implies that we can lower-bound the rate of uniquely successful rounds with good probability.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-1&quot;&gt;&lt;/span&gt;<strong>Lemma 21.</strong> Let  <span class="math">\\gamma = (n-t) \\cdot \\alpha(h) \\cdot (1-\\beta t_{\\mathcal{H}})^{n-1}</span> ,  <span class="math">f = (1-(1-\\alpha(h))^{n-t})</span> . For any set of consecutive rounds S, with  <span class="math">|S| \\geq \\frac{\\lambda}{\\gamma \\delta^2}</span> , the following two events occur with negligible probability in  <span class="math">\\lambda</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The number of uniquely successful rounds in S is less or equal to  <span class="math">(1 \\frac{\\delta}{4})\\gamma \\cdot |S|</span> ;</li>
      <li>the number of successful rounds in S is less or equal to  <span class="math">(1 \\frac{\\delta}{4})f \\cdot |S|</span> .</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> For some fixed execution we will denote by the array  <span class="math">\\mathbf{T}_{S\\times n}=(t_{i,j})\\in\\mathbb{N}^{|S|\\times n}</span>  the number of steps each honest party takes running the Sign routine, for each round in the set S. It holds that at most t elements of each column are zero, i.e. corrupted, and the rest are lower bounded by  <span class="math">t_{\\mathcal{H}}</span>  and upper bounded by  <span class="math">t_{\\mathcal{H}}</span> . W.l.o.g let  <span class="math">S=\\{1,\\ldots,s\\}</span> .</p>

    <p class="text-gray-300">Since this lemma talks about the steps taken by the Sign function, we are going to use the almost independent runtimes property of the SoW scheme, and do all the analysis on the independent random variable defined by this property. For the rest of this proof, unless explicitly stated, assume that the Steps&lt;sub&gt;Sign&lt;/sub&gt;(pp, vk, m, h) random variable refers to its idealized independent version. We first buildup some notation to help in our analysis. For  <span class="math">pp \\in PP</span> , arrays  <span class="math">(vk_{i,j}) \\in K^{s \\times n}, (msg_{i,j}) \\in M^{s \\times n}</span>  and for  <span class="math">h \\in \\mathbb{N}</span>  let:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>random variable  <span class="math">P_{i,j} = 1</span>  if  <span class="math">\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_{i,j}, msg_{i,j}, h) \\leq t_{i,j}</span> , and 0 otherwise;</li>
      <li>random variable  <span class="math">Y_i = 1</span>  if  <span class="math">\\sum_{j=1}^n P_{i,j} = 1</span>  and 0 otherwise.</li>
      <li>random variable  <span class="math">X_i = 1</span>  if  <span class="math">\\sum_{j=1}^n P_{i,j} \\ge 1</span> , and 0 otherwise.</li>
      <li>random variable  <span class="math">Y = \\sum_{i \\in [s]} Y_i, X = \\sum_{i \\in [s]} X_i</span> .</li>
    </ul>

    <p class="text-gray-300">It easily follows from the Successful property that Pr[Pi,j = 1] ≥ α(h). Moreover, it holds that Pr[Pi,j = 1] ≤ βtH. Otherwise, the honest solving algorithm would produce signatures with a rate bigger than β, which contradicts the MU-TCMA property. Next, we show that the random variables we have defined are mutually independent.</p>

    <p class="text-gray-300">Claim 2. The random variable families (Pi,j )i∈[s],j∈[n] , (Yi)i∈[s] , (Xi)i∈[s] are mutually independent.</p>

    <p class="text-gray-300">Proof. First, notice that the runtime independence of the scheme implies independence of (Pi,j ). We will show this for two random variables and the extension to m variables will be obvious. Let P1, P&lt;sup&gt;2&lt;/sup&gt; ∈ (Pi,j )i,j and x1, x&lt;sup&gt;2&lt;/sup&gt; ∈ {0, 1}, then</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Pr[P_1 = &amp;x_1 \\land P_2 = x_2] = \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) \\in S_1 \\land \\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) \\in S_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) = s_1 \\land \\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) = s_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) = s_1] \\cdot \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) = s_2] \\\\ &amp;= \\sum_{s_1 \\in S_1} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) = s_1] \\cdot \\sum_{s_2 \\in S_2} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) = s_2] \\\\ &amp;= \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) \\in S_1] \\cdot \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) \\in S_2] \\\\ &amp;= \\Pr[P_1 = x_1] \\cdot \\Pr[P_2 = x_2] \\end{split}</span>$</p>

    <p class="text-gray-300">where S1, S&lt;sup&gt;2&lt;/sup&gt; are either [0, t] or (t, ∞) depending on x1, x2, and pp, vk1, m1, vk2, m&lt;sup&gt;2&lt;/sup&gt; are the parameters of the random processes. We use the independence property on the third line.</p>

    <p class="text-gray-300">Next, we prove the second point of the claim. Again, w.l.o.g we only show it for 2 random variables, Y1, Y&lt;sup&gt;2&lt;/sup&gt; and the extension to m is obvious. Let y1, y&lt;sup&gt;2&lt;/sup&gt; ∈ {0, 1}, then</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[Y_1 = y_1 \\land Y_2 = y_2] &amp;= \\Pr[\\sum_{j \\in [n]} P_{1,j} \\in S_1 \\land \\sum_{j \\in [n]} P_{2,j} \\in S_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\sum_{j \\in [n]} P_{1,j} = s_1 \\land \\sum_{j \\in [n]} P_{2,j} = s_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\sum_{j \\in [n]} P_{1,j} = s_1] \\cdot \\Pr[\\sum_{j \\in [n]} P_{2,j} = s_2] \\\\ &amp;= \\sum_{s_1 \\in S_1} \\Pr[\\sum_{j \\in [n]} P_{1,j} = s_1] \\cdot \\sum_{s_2 \\in S_2} \\Pr[\\sum_{j \\in [n]} P_{2,j} = s_2] \\\\ &amp;= \\Pr[Y_1 = y_1] \\cdot \\Pr[Y_2 = y_2] \\end{split}</span>$</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">where S1, S&lt;sup&gt;2&lt;/sup&gt; are {1} or {0, 2, 3, . . .} depending on y1, y2. The same follows for (Xi)i∈[s] . a</p>

    <p class="text-gray-300">Next, we lower bound the expected value of random variables (Yi)&lt;sup&gt;i&lt;/sup&gt; and (Xi)&lt;sup&gt;i&lt;/sup&gt;</p>

    <p class="text-gray-300">Claim 3. It holds that for any i ∈ S : E[Y&lt;sup&gt;i&lt;/sup&gt; ] ≥ γ Proof of Claim.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbb{E}[Y_i] &amp;= \\Pr[Y_i = 1] = \\Pr[\\sum_{j \\in [n]} P_{i,j} = 1] \\\\ &amp;= \\sum_{j \\in [n]} \\Pr[P_{i,j} = 1] \\cdot \\prod_{m \\in [n] \\backslash \\{j\\}} \\Pr[P_{i,m} = 0] \\\\ &amp;\\geq \\sum_{j \\in [n]} \\alpha(h, t_{i,j}) \\prod_{m \\in [n] \\backslash \\{j\\}} (1 - \\Pr[P_{i,m} = 1]) \\\\ &amp;\\geq (n - t) \\cdot \\alpha(h) \\cdot (1 - \\beta t_{\\mathcal{H}})^{n - 1} = \\gamma \\end{split}</span>$</p>

    <p class="text-gray-300">The inequalities follow from the efficiency and MU-TCMA properties. Note, that in order for  <span class="math">\\mathbb{E}[Y_i]</span>  to be big,  <span class="math">\\alpha</span>  must be as big as possible, and  <span class="math">\\beta t_{\\mathcal{H}}</span>  must be as small as possible.</p>

    <p class="text-gray-300">Claim 4. It holds that for any  <span class="math">i \\in S : \\mathbb{E}[X_i] \\geq f</span></p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[X_i] = \\Pr[X_i = 1] = \\Pr[\\sum_{j \\in [n]} P_{i,j} \\ge 1]</span>$</p>

    <p class="text-gray-300"><span class="math">$= 1 - \\Pr[\\sum_{j \\in [n]} P_{i,j} = 0]</span>$</p>

    <p class="text-gray-300"><span class="math">$= 1 - \\prod_{m \\in [n]} \\Pr[P_{i,m} = 0]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\ge 1 - (1 - \\alpha(h))^{n-t} = f</span>$</p>

    <p class="text-gray-300">The inequality follows from the Successful property.</p>

    <p class="text-gray-300">By the linearity of expectation we have that  <span class="math">\\mathbb{E}[Y(S)] \\geq \\gamma |S|</span>  and  <span class="math">\\mathbb{E}[X(S)] \\geq f|S|</span> . Since all variables in  <span class="math">(Y_i)_i</span>  and  <span class="math">(X_i)_i</span>  are mutually independent and  <span class="math">\\delta \\in (0,1)</span> , by an application of the Chernoff Bound it holds that:</p>

    <p class="text-gray-300"><span class="math">\\dashv</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr[Y(S) \\le (1 - \\frac{\\delta}{4})\\gamma |S|] \\le \\Pr[Y(S) \\le (1 - \\frac{\\delta}{4})\\mathbb{E}[Y(S)]] \\le e^{-\\Omega(\\delta^2 \\gamma |S|)}</span>$</p>

    <p class="text-gray-300">Similarly, we can show that  <span class="math">\\Pr[X(S) \\leq (1 - \\frac{\\delta}{4})f|S|] \\leq e^{-\\Omega(\\delta^2 f|S|)}</span> .</p>

    <p class="text-gray-300">These results, with only negligible difference in probability, follow for the random variables in the real execution due to the almost runtime independence property, and the fact that Y and X are functions of the joint distribution referred by this property.</p>

    <p class="text-gray-300">Next, we show that  <span class="math">\\gamma</span> , the rate at which uniquely successful rounds occur, is lower bounded by  <span class="math">\\beta t&#x27;_{\\mathcal{A}}</span> , which corresponds to the rate at which the adversary is producing blocks.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;Lemma 22.  <span class="math">\\gamma \\geq (1+\\delta)\\beta t&#x27;_{\\mathcal{A}}</span></p>

    <p class="text-gray-300"><em>Proof.</em> It holds that:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\gamma = &amp; (n-t) \\cdot \\alpha(h) \\cdot (1-\\beta t_{\\mathcal{H}})^{n-1} \\geq (n-t) \\cdot \\alpha(h) \\cdot (1-\\beta t_{\\mathcal{H}} n) \\\\ \\geq &amp; (n-t) \\cdot (1-\\delta_{\\mathsf{SoW}}) \\cdot \\beta t_{\\mathcal{H}}&#x27; \\cdot (1-\\delta) \\geq \\frac{(1-\\delta_{\\mathsf{SoW}})(1-\\delta)}{(1-\\delta_{\\mathsf{Steps}})} \\cdot \\beta t_{\\mathcal{A}}&#x27; \\cdot \\geq (1+\\delta)\\beta t_{\\mathcal{A}}&#x27; \\end{split}</span>$</p>

    <p class="text-gray-300">where we have first used Bernouli's inequality, and then the three conditions from Assumption 2 (the Computational Power Assumption). The last inequality follows from the fact that  <span class="math">\\frac{\\delta_{\\mathsf{Steps}} - \\delta_{\\mathsf{SoW}}}{2} \\geq \\delta</span> .</p>

    <p class="text-gray-300">We are now ready to define the set of <em>typical executions</em> for this setting. This strategy was also followed in [31]. However, here we will need to adapt the definition due to the difficulties associated with performing a reduction to the security of the SoW scheme.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;<strong>Definition 23.</strong> [Typical execution] An execution is <em>typical</em> if and only if for any set S of consecutive rounds with  <span class="math">|S| \\ge \\frac{2\\lambda}{\\gamma\\delta^2}</span> , the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">Y(S) &gt; (1 \\frac{\\delta}{4})\\gamma |S|</span>  and  <span class="math">X(S) &gt; (1 \\frac{\\delta}{4})f|S|</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for any block B mined by an honest party at the some round in S,  <span class="math">Z_B(S) &lt; \\frac{\\gamma}{1+\\delta} \\cdot |S|</span>  and  <span class="math">Z_B(S) + X_B(S) &lt; \\beta(t_A + nt_H) \\cdot |S|</span> ; and</li>
    </ol></li>
      <li>&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;3. no insertions and no copies occurred.</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 24.</strong> An execution is typical with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Proof. In order for an execution to not be typical, one of the three points of Definition 23 must not hold with non-negligible probability for some big enough set of rounds. Point 3 is implied by Corollary 18. For a specific set of rounds S, where  <span class="math">|S| \\geq \\frac{2\\lambda}{\\gamma\\delta^2}</span> , point 1 is implied by Lemma 21 with overwhelming probability in  <span class="math">\\lambda</span> . Regarding point 2, by an application of Lemma 19 for  <span class="math">t&#x27;_{\\mathcal{A}} = \\frac{\\gamma}{(1+\\delta)\\beta}</span> , it follows that  <span class="math">Z_B(S) &lt; \\frac{\\gamma}{1+\\delta} \\cdot |S|</span>  with probability  <span class="math">\\operatorname{negl}(\\beta \\cdot t&#x27;_{\\mathcal{A}} \\cdot |S|)</span> . Note, that this is w.l.o.g., due to Lemma 22, and that  <span class="math">\\beta t&#x27;_{\\mathcal{A}} \\cdot |S| \\geq \\beta \\frac{\\gamma}{(1+\\delta)\\beta} \\cdot \\frac{2\\lambda}{\\gamma\\delta^2} = \\Omega(\\lambda)</span> . Moreover, using the fact that  <span class="math">\\beta t_{\\mathcal{H}} \\geq \\alpha</span>  argued in Lemma 21 and due to the definition of  <span class="math">\\gamma</span> , it holds that  <span class="math">\\beta(t_{\\mathcal{A}} + nt_{\\mathcal{H}}) \\cdot \\frac{2\\lambda}{\\gamma\\delta^2} \\geq \\frac{2\\lambda}{\\delta} = \\Omega(\\lambda)</span> , which in turn implies that Corollary 20 is sufficient to imply point 2 with overwhelming probability in  <span class="math">\\lambda</span> . Hence, we can bound the probability that an execution is not typical by applying the union bound on the negation of these events over all sets of consecutive rounds of sufficiently large size, where the probability of each event occurring is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Next, taking advantage of the Computational Power Assumption (Assumption 2, we show that the rate at which the adversary computes blocks in a typical execution, is bounded by the rate at which uniquely successful rounds occur. With foresight, we note that this relation is going to be at the core of our security proof.</p>

    <p class="text-gray-300"><strong>Lemma 25.</strong> For any set S of at least  <span class="math">\\frac{2\\lambda}{\\gamma\\delta^2}</span>  rounds in a typical execution and for any block B mined by an honest party during S, it holds that  <span class="math">Z_B(S) &lt; (1 - \\frac{\\delta}{4})Y(S)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> It holds that:</p>

    <p class="text-gray-300"><span class="math">$Z_B(S) &lt; \\frac{1}{1+\\delta}\\gamma|S| \\le (1-\\frac{\\delta}{4})Y(S)</span>$</p>

    <p class="text-gray-300">where, the first inequality follows from the assumption that the execution is typical.</p>

    <p class="text-gray-300">We can now use the machinery built in [31] to prove the common prefix, chain quality and chain growth properties, and eventually Persistence and Liveness, with only minor changes. Using these properties we prove that the modified Bitcoin backbone protocol implements a robust transaction ledger.</p>

    <p class="text-gray-300"><strong>Higher level properties.</strong> The notion of a typical execution is at the core of the proof of security of Bitcoin in [31]. Here, we describe the minor changes one has to do after proving the typical execution theorem with respect to the analysis of [31], in order to prove the security of the protocol in our model. We only give brief proof sketches of lemmas or theorems from [31] that are exactly the same for our own setting.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;<strong>Lemma 26.</strong> (Chain-Growth Lemma). Suppose that at round r an honest party has a chain of length  <span class="math">\\ell</span> . Then, by round  <span class="math">s \\geq r</span> , every honest party has adopted a chain of length at least  <span class="math">\\ell + \\sum_{i=r}^{s-1} X_i</span> . <em>Proof.</em> The main idea of the proof of this lemma is that, after each successful round at least one honest party will have received a chain that is at least one block longer than the chain it had, and all parties pick only chains that are longer than the ones they had. <strong>Theorem 27.</strong> (Chain-Growth). In a typical execution the chain-growth property holds with parameters  <span class="math">\\tau = (1 - \\frac{\\delta}{4})f</span>  and  <span class="math">s \\ge \\frac{2\\lambda}{\\gamma\\delta^2}</span> . <em>Proof.</em> Let S be any set of at least s consecutive rounds. Then, since the execution is typical:  <span class="math">X(S) \\geq</span>  <span class="math">(1-\\frac{\\delta}{4})f\\cdot |S|\\geq \\tau\\cdot |S|</span> . By Lemma 26, each honest player's chain will have grown by that amount of blocks at the end of this round interval. Hence, the chain growth property follows. <strong>Lemma 28.</strong> Let B be some honest block or the genesis block in a typical execution. Any sequence of  <span class="math">k \\geq \\frac{2\\lambda}{\\gamma\\delta}</span>  consecutive blocks in some chain C, where the first block in the sequence directly descends B, have been computed in at least  <span class="math">k/\\delta</span>  rounds, starting from the round that B was computed. <em>Proof.</em> First, note that due to the Computational Power Assumption it holds that  <span class="math">\\beta(t_A + nt_H) &lt; \\delta</span> . For some  <span class="math">k \\geq \\frac{2\\lambda}{\\gamma\\delta}</span> , assume there is a set of rounds S', such that  <span class="math">|S&#x27;| &lt; k/\\delta</span> , and more than k blocks that descend block B have been computed. This implies that there is a set of rounds S, where  <span class="math">|S| \\geq \\frac{2\\lambda}{\\gamma \\delta^2}</span> , such that  <span class="math">X(S) + Z_B(S) \\ge k \\ge |S| \\delta &gt; |S| \\beta(t_A + nt_H)</span> . This contradicts the typicality of the execution, hence the lemma follows. <strong>Lemma 29.</strong> (Common-prefix Lemma). Assume a typical execution and consider two chains  <span class="math">\\mathcal{C}_1</span>  and  <span class="math">C_2</span>  such that  <span class="math">len(C_2) \\ge len(C_1)</span> . If  <span class="math">C_1</span>  is adopted by an honest party at round r, and  <span class="math">C_2</span>  is either adopted by an honest party or diffused at round r, then  <span class="math">C_1^{\\lceil k} \\leq C_2</span>  and  <span class="math">C_2^{\\lceil k} \\leq C_1</span> , for  <span class="math">k \\geq \\frac{2\\lambda}{\\sqrt{\\delta}}</span> . <em>Proof.</em> In Lemma 19, instead of bounding the number of blocks mined by the adversary in a set of rounds, we bound the number of blocks mined by the adversary with the additional condition that these blocks extend some specific honest block. If we also use the previous lemma, the proof is exactly the same as in [31]. Note, that all adversarial blocks in the matching between uniquely successful rounds and adversarial blocks are descendants of the last honest block in the common prefix of  <span class="math">\\mathcal{C}_1</span>  and  <span class="math">\\mathcal{C}_2</span> . <strong>Theorem 30.</strong> (Common-prefix). In a typical execution the common-prefix property holds with parameter  <span class="math">k \\geq \\frac{2\\lambda}{\\gamma\\delta}</span> . <em>Proof.</em> The main idea of the proof is that if there exists a deep enough fork between two chains, then the previously proved lemma cannot hold. Hence, the theorem follows. <strong>Theorem 31.</strong> (Chain-Quality). In a typical execution the chain-quality property holds with parameter  <span class="math">\\mu &lt; 1 - \\delta/4</span>  and  <span class="math">\\ell \\ge \\frac{2\\lambda}{\\gamma\\delta}</span> . <em>Proof.</em> The main idea of the proof is the following: a large enough number of consecutive blocks will have been mined in a set rounds that satisfies the properties of Definition 23. Hence, the number of blocks that belong to the adversary will be upper bounded, and all other blocks will have been mined</p>

    <p class="text-gray-300">Finally, the Persistence and Liveness properties follow from the three basic properties, albeit with different parameters than in [31].</p>

    <p class="text-gray-300">by honest parties.</p>

    <p class="text-gray-300"><strong>Lemma 32.</strong> (Persistence). It holds that  <span class="math">\\Pi_{\\mathsf{PL}}</span>  with  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span>  satisfies Persistence with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The main idea is that if persistence is violated, then the common-prefix property will also be violated. Hence, if the execution is typical the lemma follows.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Lemma 33.</strong> (Liveness). It holds that  <span class="math">\\Pi_{\\mathsf{PL}}</span>  with  <span class="math">u = \\frac{2k}{(1-\\frac{\\delta}{4})f}</span>  rounds and  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span>  satisfies Liveness with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The main idea here is that after u rounds at least 2k successful rounds will have occurred. Thus, by the chain growth lemma the chain of each honest party will have grown by 2k blocks, and by the chain quality property at least one of these blocks that is deep enough in the chain, is honest.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-2&quot;&gt;&lt;/span&gt;<strong>Theorem 34.</strong> Assuming the existence of a collision-resistant hash function and a SoW scheme that complies with Assumption 1 and 2, protocol  <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{SoW}}</span>  implements a robust public transaction ledger with parameters  <span class="math">u = \\frac{2k}{(1-\\frac{\\delta}{A})f}</span>  and  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span>  except with negligible probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">As a &quot;sanity check,&quot; we show in in the full version of the paper that the Bitcoin SoW scheme we outline there, is secure both in the random oracle and the  <span class="math">\\mathcal{F}_{TREE}</span>  model [47] according to our definitions; moreover, according to the security parameters we obtain for the scheme, the security guarantees we get from our black-box analysis of the Bitcoin backbone are similar to those proved in [31, 47].</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;4.3 Consensus from Signatures of Work</h3>

    <p class="text-gray-300">In this section we show how to achieve consensus (a.k.a. Byzantine agreement [48, 42]) under exactly the same assumptions used for proving the security of the Bitcoin backbone protocol in Section 4.2.</p>

    <p class="text-gray-300">As mentioned earlier, in [31] consensus is achieved under the Honest Majority Assumption by using a proof-of-work construction in a <em>non-black-box</em> way, through a mining technique called &quot;2-for-1 PoWs.&quot; In more detail, the technique shows how miners can compute proofs of work for two different PoW schemes at the cost of one, while at the same time ensuring that their resources cannot be used in favor of one of the two schemes. However, the security proof for the resulting protocol crucially relies on the fact that each of the bits of the strings output by the random oracle are independently sampled, and thus goes again our stated goal of designing a SoW scheme that does not make such a strong independence assumption.</p>

    <p class="text-gray-300">Here we get rid of this requirement, by showing how blockchain-based consensus can be achieved by only using the security properties we have defined, directly, and without the extra non-black-box machinery used in [31]. This yields the first consensus protocol for honest majority reducible to a SoW primitive in the permissionless setting. The protocol is based on the Bitcoin backbone protocol, and formally specified by providing adequate definitions for the V, R, I functions presented in Section 4.2.</p>

    <p class="text-gray-300">First, we define some additional notation and terminology that will be used in the remainder of the section. We will use the terms &quot;input&quot; and &quot;vote&quot; interchangeably, referring to the parties' input to the consensus problem. We will use  <span class="math">header(\\langle s,x||vote,\\sigma\\rangle)</span>  to denote the &quot;compressed&quot; version of block  <span class="math">\\langle s,x||vote,\\sigma\\rangle^9</span> , equal to  <span class="math">\\langle s,G(x)||vote,\\sigma\\rangle</span> . Note that, as defined, the header of any block is of a fixed size. We also extend the definition of our hash function H as applied to headers of blocks. The hash of the header of some block B will be equal to the hash of B, i.e.,  <span class="math">H((header(B)) = H(B) = H(s,G(x)||vote,\\sigma)</span>  (note that the header of B provides all the information needed to calculate the hash of B).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-1&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^{9}&lt;/sup&gt;</span> We augment the block content x with a vote bit. This does not change the results of the analysis of the previous section.</p>

    <p class="text-gray-300">We now present a high-level description of the protocol. The basic idea is that during block mining, parties are going to include in their blocks not only their own votes, but also headers of other blocks that they have seen and that are not part of their chain. Then, after a predetermined number of rounds, the parties will count the votes &quot;referenced&quot; in a prefix of their chain, including the votes found in the headers of the blocks referenced. In this way, they can take advantage of the robust transaction ledger built in Section <a href="#page-14-0">4.2.</a> The Persistence property implies that the honest parties will all agree on which votes should be counted, while the Liveness property guarantees that the majority of the counted votes come from honest parties.</p>

    <p class="text-gray-300">The reader may wonder about the reason behind honest parties including in their blocks also headers of other blocks that they have seen but that are not part of their chain. It's because, as shown in <a href="#page-37-3">[31]</a>, the adversary is able to add more blocks in the main chain than his ratio of mining power (e.g., using a selfish-mining attack). This does not hold if the honest parties are able to also count off-chain blocks as our protocol does.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;Algorithm 5 The content validation predicate. The input is the contents of the blocks of some chain.</p>

    <pre><code class="language-text">1: function V(hx1, . . . , xmi)
2: D ← new AVL() . Create a new (empty) AVL tree.
3: D.add(H(BGen)) . Add the hash of the genesis block on the tree.
4: for i = 1, ..., m do
5: queue ← references(xi) . Add all block references in a queue.
6: hr||heighti ← queue.top()
7: if height 6= i then
8: return False . Check for the correct block &quot;height&quot;.
9: end if
10: while queue 6= ∅ do
11: hs, G(x)||vote, wi ← queue.top()
12: if ((D.exists(s)) ∧ Verify(s, G(x)||vote, h, w)) then
13: D.add(H(hs, G(x)||vote, wi)) . Add new entry on the tree.
14: queue.pop()
15: else
16: return False . If not, the chain is invalid.
17: end if
18: end while
19: end for
20: return True
21: end function
</code></pre>

    <p class="text-gray-300">A main technical challenge is to be able to add the block references without making the honest parties' chains grow too large, and at the same time to ensure that the number of honest votes exceeds the adversarial ones. To overcome this challenge, we modify the Sign algorithm so that it is run on the header of the block, i.e., Sign(pp, s, G(x)||vote, h) and Verify(pp, s, G(x)||vote, h, σ), respectively. This way we are able to verify the validity of a block as a SoW and determine the block's vote by only knowing its header. These are exactly the properties we need for the consensus application.</p>

    <p class="text-gray-300">Moreover, we should be able to tell whether the referenced blocks are &quot;fresh&quot;; that is, the adversary should not be able to reference blocks that it has precomputed and are not related to the genesis block. We achieve this by requiring blockchain contents to have a special structure in order to be considered valid by the content validation predicate V(·) (Algorithm <a href="#page-28-0">5)</a>. A chain will be valid when the referenced blocks on every prefix of the chain form a tree that has the genesis block at its root. In order to check</p>

    <p class="text-gray-300">this efficiently, we require that the block headers listed in each block are ordered, so that each entry extends some block header found in previous entries of the same or parent blocks.</p>

    <p class="text-gray-300">In more detail, to efficiently check for membership in the hash tree, in line 2 of Algorithm 5 we use an AVL tree. (Any other data structure supporting efficient updates and search would also work.) In line 5 the referenced blocks are extracted and pushed into a queue. We note that during this process it is checked that: (i) the contents of the block have a correct format, i.e., a vote field and list of block headers, (ii) each header in the list is a valid SoW and extends a chain starting from the genesis block, and (iii) that the first reference includes a string r and the height of the block as required in the security analysis of Section 4.2.3 and described in Table 1.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Content validation pre-</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">As defined in Algorithm 5.</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">dicate <span class="math">V(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Chain reading function <span class="math">R(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R(\\cdot)</span> outputs the majority of the votes found in the block headers of</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">the first <span class="math">M</span> blocks of the selected chain.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Input contribution function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The input function <span class="math">I(\\cdot)</span> maintains state of which blocks have been</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">I(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">received, and outputs an input value <span class="math">x</span> that contains (i) the headers</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of all valid blocks that extend the genesis and are not mentioned in the</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">chain <span class="math">C</span> that the party is currently extending, (ii) a neutral transaction</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of the form <span class="math">KeyGen(pp)   \\mathcal{C} </span> , and (iii) the party's input (i.e., 0 or 1).</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: The instantiation of functions  <span class="math">I(\\cdot), V(\\cdot), R(\\cdot)</span>  for protocol  <span class="math">\\Pi_{RA}^{SoW}</span> .</p>

    <p class="text-gray-300">The algorithm runs for L rounds, after which it outputs the majority of the votes found in a prefix of the selected chain, of a predetermined length M. We call the resulting protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{SoW}}</span>  (&quot;BA&quot; for Byzantine agreement). A description of the consensus protocol (specifically, the V, R, I functions) is presented in Table 3, and also recall the example in Figure 1. Note that all parties terminate the protocol simultaneously.</p>

    <p class="text-gray-300"><strong>Theorem 35.</strong> Assuming the existence of a collision-resistant hash function and a SoW scheme that complies with Assumptions 1 and 2. Protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{SoW}}</span>  solves consensus in  <span class="math">O(\\frac{\\lambda}{\\gamma^3\\delta})</span>  rounds with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We are going to show that protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{SoW}}</span> , parameterized with  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span> ,  <span class="math">M = k + \\frac{8k}{\\gamma}</span>  number of blocks, and  <span class="math">L = \\frac{M+k}{(1-\\frac{\\delta}{4})\\gamma}</span>  number of rounds solves consensus with overwhelming probability in  <span class="math">\\lambda</span> . Our analysis uses many of the intermediate lemmas established for the proof of Theorem 34.</p>

    <p class="text-gray-300">We start, by proving that the Agreement property holds. First, note that our definition of  <span class="math">V(\\cdot)</span>  guarantees that if an honest party accepts a chain as valid, all other parties are also going to accept it as valid, since the validation predicate only depends on the chain that is being validated. Assume that an execution is  <span class="math">\\delta</span> -typical. Since  <span class="math">L \\geq \\frac{2\\lambda}{\\gamma\\delta}</span> , after L rounds: (i) due to chain growth the chains of all honest parties will have length at least M+k blocks, and (ii) due to the common prefix property they will all agree on the first M blocks of their chains. Hence, all honest parties will decide on their output values based on the &quot;votes&quot; mentioned in the same blocks, and thus they will all agree on the same value.</p>

    <p class="text-gray-300">Regarding Validity, we are going to show that the majority of the counted &quot;votes,&quot; i.e., from blocks and block headers found in blocks  <span class="math">B_1, \\ldots, B_M</span>  of the common prefix, have been mined by honest parties. Due to the chain quality property at least one block from  <span class="math">B_{M-k}, \\ldots, B_M</span>  is honest. Assume that the last honest block in this chain has been diffused in the network at round r. Since  <span class="math">M-k \\geq \\frac{8k}{\\gamma} \\geq k</span> , by an application of Lemma 28 starting from the genesis block, it holds that  <span class="math">r \\geq \\frac{8k}{\\gamma\\delta}</span> . Hence, at round  <span class="math">r + \\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span> , by the chain growth property all parties will have chains of length at least M+k, and by the common-prefix property all blocks up to the M-th position will be fixed for the rest</p>

    <p class="text-gray-300">of the execution. Hence, the last adversarial block in  <span class="math">B_1, \\ldots, B_M</span>  must have been computed before round  <span class="math">r + \\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">r&#x27; = r + \\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span> . It remains to show that for  <span class="math">S_1 = \\{1,\\ldots,r\\}</span>  and  <span class="math">S_2 = \\{1,\\ldots,r&#x27;\\}</span>  it holds that  <span class="math">Z(S_2) &lt; X(S_1)</span> :</p>

    <p class="text-gray-300"><span class="math">$Z(S_2) &lt; \\frac{1}{1+\\delta} \\gamma r&#x27; \\le (1-\\frac{\\delta}{4})(1-\\frac{\\delta}{4})\\gamma r&#x27; \\le (1-\\frac{\\delta}{4})\\gamma r \\le X(S_1).</span>$</p>

    <p class="text-gray-300">The first and the last inequalities hold due to the fact that the execution is typical. The fourth inequality follows by the size of r. The theorem follows since the majority of the referenced blocks in the chain agreed upon, have been mined by honest parties.</p>

    <p class="text-gray-300">Concluding, notice that the total size of any chain is bounded by the total number of blocks mined, since each block's header is mentioned at most once in a single chain. Hence, in s rounds of a typical execution a chain has size at most  <span class="math">O(s \\cdot \\lambda)</span>  bits.</p>

    <h2 id="sec-14" class="text-2xl font-bold">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt;5 SoW Constructions from Idealized Assumptions</h2>

    <p class="text-gray-300">In this section, and as a sanity check, we outline a SoW scheme that is secure both in the random oracle and the  <span class="math">\\mathcal{F}_{TREE}</span>  model [47]. Moreover, according to the security parameters we obtain for the scheme, the security guarantees we get from our black-box analysis of the Bitcoin backbone are similar to those proved in [31, 47].</p>

    <p class="text-gray-300">SoW in the RO model. Our first step is to show that the SoW scheme used in the Bitcoin protocol (call it BSOW) is secure in the random oracle model according to our definitions. Bitcoin's Sign algorithm tries to find a block header with a small hash. The main components of the header are as follows: (i) the hash of the header of the previous block, (ii) the hash of the root of the Merkle tree of the transactions that are going to be added to Bitcoin's ledger, including the randomly created coinbase transaction, and (iii) a counter. The algorithm works by first fetching available transactions from the network, then computing a random public key that will be used for the coinbase transaction, and then iteratively incrementing the counter and calculating the hash of the header of the block until a small value is found. Casting this in our terms, the key is the hash of the previous block, which by itself depends on Bitcoin's genesis block, while the transactions received by the network as well as the coinbase transaction constitute the message. It is important to note that it is not possible to consider the key to be the coinbase transaction, as there is no guarantee it has any entropy when produced by an adversarial signer. To abstract the randomization of the signing procedure, which in the actual implementation is captured by the coinbase transaction, we hash msqtogether with a randomly generated string. This should be part of the signature in our SoW syntax since it is produced by the signing process and is necessary for verification. Similarly, the counter is also part of the signature produced by the signing process. BSOW, a simplified version of the scheme described above with the transaction semantics omitted for simplicity, is presented in Figure 6.</p>

    <p class="text-gray-300">Remark 4. In the Bitcoin implementation, the hash of the root of the Merkle tree of the transactions is not &quot;salted.&quot; This means that if we consider the adversary to be non-uniform, she could get collisions for free in her advice string and use them to compute two SoWs at the cost of one. This would be problematic for our MU-TCMA security game. Thus, in order to strengthen the security of the scheme, we choose to also include the key in the hash of the message.</p>

    <p class="text-gray-300">We will assume that H is an idealized hash function, i.e., our analysis is in the random oracle, and  <span class="math">G_k</span>  is sampled from a collision resistant hash function family.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-1&quot;&gt;&lt;/span&gt;<strong>Theorem 36.</strong> If G is a collision resistant hash function family, and H is modeled as a Random Oracle, then for any  <span class="math">\\sigma \\in (0,1)</span> , Algorithm 6 is</p>

    <p class="text-gray-300">&lt;span id=&quot;page-31-0&quot;&gt;&lt;/span&gt;<strong>Algorithm 6</strong> Bitcoin's SoW implementation based on the ROM. H is modeled as a RO, while  <span class="math">G_k</span>  is sampled from a collision resistant hash function family  <span class="math">\\mathcal{G}</span> .</p>

    <pre><code class="language-text">1: function PPub(1^{\\lambda})
          k \\leftarrow K(\\lambda)
                                                                                            \\triangleright Sample the key of hash function G.
          return (1^{\\lambda}, k)
 3:
 4: end function
 6: function KeyGen(pp)
          vk \\leftarrow \\mathcal{U}_{\\lambda}
 7:
          return vk
 8:
 9: end function
11: function Sign(pp = (1^{\\lambda}, k), vk, msg, h)
          while true do
12:
               \\sigma_1 \\leftarrow \\mathcal{U}_{\\lambda}
13:
               dig \\leftarrow G_k(vk, \\sigma_1, msg)
14:
               for \\sigma_2 = 0^{\\lambda}|_2 to 1^{\\lambda}|_2 do
15:
                    if (H(vk, dig, \\sigma_2) &lt; 2^{\\lambda} - h) then
16:
                         return (\\sigma_1, \\sigma_2)
17:
                    end if
18:
               end for
19:
          end while
20:
21: end function
22:
23: function Verify(pp = (1^{\\lambda}, k), vk, msg, h, \\sigma = (\\sigma_1, \\sigma_2))
          return (H(vk, G_k(vk, \\sigma_1, msq), \\sigma_2) &lt; 2^{\\lambda} - h)
24:
25: end function
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>correct;</li>
      <li><span class="math">O(\\lambda)</span> -verifiable;</li>
      <li><span class="math">(t_{sign}, 1 (\\frac{h}{2^{\\lambda}})^{t_{sign}})</span> -successful, for  <span class="math">h \\in [2^{\\lambda} 1]</span> ;</li>
      <li>run-time independent;</li>
      <li><span class="math">((1+\\sigma)(1-\\frac{h}{2^{\\lambda}}),e^{-\\frac{\\beta(h)t\\sigma^2}{6}}+\\text{negl}(\\lambda))</span> -MU-TCMA secure w.r.t. any computationally unpredictable function family  <span class="math">\\mathcal{F}</span> , for  <span class="math">h \\in [2^{\\lambda}-1]</span> .</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">p_h = 1 - \\frac{h}{2^{\\lambda}}</span>  be the probability that a query to the random oracle returns a value less than  <span class="math">2^{\\lambda} - h</span> , and let  <span class="math">q_{\\mathcal{H}}</span>  be the number of queries the adversary makes to the RO. We consider each property in turn.</p>

    <p class="text-gray-300">Correct. By the collision resistance of G, it follows that  <span class="math">|\\{G(vk, \\sigma_1, msg) | \\sigma_1 \\in \\{0, 1\\}^{\\lambda}\\}|</span>  is greater than  <span class="math">\\lambda</span>  with overwhelming probability in  <span class="math">\\lambda</span> . Hence, the probability that the Sign algorithm cannot find any signature for the given parameters is upper bounded by the probability that  <span class="math">\\lambda \\cdot 2^{\\lambda}</span>  different queries to the  <span class="math">\\mathcal{RO}</span>  return a value greater or equal than  <span class="math">2^{\\lambda} - h</span> . This is upper bounded by:</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{h}{2^{\\lambda}}\\right)^{\\lambda 2^{\\lambda}} \\le \\left(1 - \\frac{1}{2^{\\lambda}}\\right)^{\\lambda 2^{\\lambda}} \\le e^{-\\lambda}</span>$</p>

    <p class="text-gray-300">The correctness property follows.</p>

    <p class="text-gray-300">MU-TCMA. Let  <span class="math">\\ell = \\beta(h)t</span> . W.l.o.g., assume  <span class="math">\\ell \\geq 1</span> , since if  <span class="math">\\ell &lt; 1</span>  there exists a trivial adversary that wins with probability 1. First, we show that for any adversary  <span class="math">\\mathcal{A}</span>  there exists an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that succeeds in winning  <span class="math">\\mathsf{Exp}^{\\mathrm{MU-TCMA}}_{\\mathcal{A}&#x27;,\\mathcal{F}}</span>  (Figure 2) with almost the same time complexity and probability that  <span class="math">\\mathcal{A}</span>  wins, without using the signing oracle  <span class="math">\\mathcal{S}</span> .  <span class="math">\\mathcal{A}&#x27;</span>  is going to run  <span class="math">\\mathcal{A}</span>  internally, and all calls made by  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathcal{S}</span>  are going to be simulated, i.e., assuming  <span class="math">\\mathcal{A}</span>  queries  <span class="math">\\mathcal{S}</span>  with values (k, msq),  <span class="math">\\mathcal{A}&#x27;</span>  will respond with some number t' sampled from the time distribution of  <span class="math">\\mathcal{S}</span>  (t' can be efficiently sampled from a geometric distribution, since queries are i.i.d Bernoulli trials) and some random signature  <span class="math">\\sigma = (\\sigma_1, \\sigma_2)</span> , where  <span class="math">\\sigma_2 &lt; t&#x27;</span> .  <span class="math">\\mathcal{A}&#x27;</span>  is also going to store this query in some efficient data structure that allows for search in logarithmic time. Any calls made by the adversary afterwards to the RO that are related to (k, msg) will be answered accordingly; if  <span class="math">\\mathcal{A}_2</span>  queries the RO with some string  <span class="math">k||G(k, \\sigma_1, msg)||\\sigma&#x27;_2</span> , where  <span class="math">\\sigma_2&#x27; = \\sigma_2</span> , then  <span class="math">\\mathcal{A}&#x27;</span>  will respond with the same value he responded on the initial query to  <span class="math">\\mathcal{S}</span> , otherwise if  <span class="math">\\sigma&#x27;_2 &lt; \\sigma_2</span> , he responds by  <span class="math">2^{\\lambda} - h + (y \\mod h)</span> , where y is the output of the real RO in this query. Note, that since  <span class="math">\\sigma_1</span>  is chosen at random and RO is unpredictable, the probability that  <span class="math">\\mathcal{A}</span>  has queried the RO with a string of this format before querying  <span class="math">\\mathcal S</span>  is negligible. Hence, the view of  <span class="math">\\mathcal A</span>  in both experiments is computationally indistinguishable, and he will output  <span class="math">\\ell</span>  valid SoWs with respect to the simulated view with the same probability that he wins in the real experiment.</p>

    <p class="text-gray-300">We next have to show that  <span class="math">\\mathcal{A}&#x27;</span>  can use the output of  <span class="math">\\mathcal{A}</span>  to win in the real experiment. The only case this will not happen, is if the output of  <span class="math">\\mathcal{A}</span>  contains a SoW related to the queries asked to (the simulated) oracle  <span class="math">\\mathcal{S}</span> , and thus it does not correspond to a winning output for  <span class="math">\\mathcal{A}&#x27;</span> , i.e.,  <span class="math">\\mathcal{A}&#x27;</span>  has set the value of this SoW to be small enough, while this does not necessarily hold for the actual RO. This implies, that there exists a SoW on the output of  <span class="math">\\mathcal{A}</span>  of the form  <span class="math">\\langle f, msg, (\\sigma_1, \\sigma_2) \\rangle</span>  and a query  <span class="math">\\langle (k, msg&#x27;), (\\sigma&#x27;_1, \\sigma&#x27;_2) \\rangle</span>  on  <span class="math">\\mathcal{S}</span> , such that  <span class="math">f(\\Sigma, vk)||G(f(\\Sigma, vk), \\sigma_1, msg)||\\sigma_2 = k||G(k, \\sigma&#x27;_1, msg&#x27;)||\\sigma&#x27;_2</span> . In order for this to be a winning output for  <span class="math">\\mathcal{A}</span> , it must not correspond to the asked query, and thus it should hold that either  <span class="math">msg \\neq msg&#x27;</span>  or  <span class="math">\\sigma_1 \\neq \\sigma&#x27;_1</span> . This implies that the adversary has found a collision in G, which only happens with negligible probability in  <span class="math">\\lambda</span> . Hence,  <span class="math">\\mathcal{A}&#x27;</span>  will win  <span class="math">\\text{Exp}_{\\mathcal{A}&#x27;,\\mathcal{F}}^{\\text{MU-TCMA}}</span>  with the same probability (minus some negligible term in  <span class="math">\\lambda</span> ) as  <span class="math">\\mathcal{A}</span> . Moreover, the overhead incurred to  <span class="math">\\mathcal{A}&#x27;</span> 's running time will be only logarithmic on  <span class="math">q_{\\mathcal{S}}</span>  i.e.  <span class="math">\\mathcal{A}&#x27;</span>  can simulate the t steps taken by  <span class="math">\\mathcal{A}_2</span>  in time  <span class="math">t&#x27; = t \\cdot (1 + \\log(q_{\\mathcal{S}}))</span> ; he has to maintain a heap of the queries made to  <span class="math">\\mathcal{S}</span>  and search it each time the RO is queried. Note, that  <span class="math">\\mathcal{A}&#x27;</span>  queries the real RO at most t times.</p>

    <p class="text-gray-300">Let  <span class="math">A_{\\ell}</span>  be the event where  <span class="math">\\mathcal{A}&#x27;</span>  asks t queries the RO after receiving vk, and receives at least  <span class="math">\\ell</span>  responses that have value less than  <span class="math">2^{\\lambda} - h</span> . Let random variable X be equal to the number of these responses that are less than  <span class="math">2^{\\lambda} - h</span> . Since the queries are i.i.d. Bernoulli random variables with probability of success  <span class="math">p_h</span> , we can use the Chernoff bound to bound the probability of  <span class="math">A_{\\ell}</span> . For any  <span class="math">\\sigma \\in (0,1)</span> , since  <span class="math">\\ell = \\beta t \\geq (1+\\sigma)p_h t</span> , it follows that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[A_{\\ell}] = \\Pr[X \\ge \\ell] \\le \\Pr[X \\ge (1+\\sigma)p_h t]</span>$
<span class="math">$= \\Pr[X \\ge (1+\\sigma)\\mathbb{E}[X]] \\le e^{-\\frac{\\mathbb{E}[X]\\sigma^2}{3}} \\le e^{-\\frac{(1+\\sigma)p_h t\\sigma^2}{6}}.</span>$</p>

    <p class="text-gray-300">Let B be the event where  <span class="math">\\mathcal{A}&#x27;_2</span>  outputs  <span class="math">f, m, \\sigma</span>  such that  <span class="math">f \\in \\mathcal{F}</span>  and there exists a query made to the random oracle by  <span class="math">\\mathcal{A}&#x27;_1</span>  of the form  <span class="math">f(\\Sigma, vk)||x||\\sigma</span> , for some  <span class="math">x \\in \\{0, 1\\}^*</span> . We will show that B happens with only negligible probability in  <span class="math">\\lambda</span> . For the sake of contradiction, assume that B happens with non-negligible probability. Then, we can use  <span class="math">\\mathcal{A}&#x27;</span>  to break the computational unpredictability of  <span class="math">\\mathcal{F}</span> . Let  <span class="math">\\mathcal{A}&#x27;&#x27; = (\\mathcal{A}&#x27;&#x27;_1, \\mathcal{A}&#x27;&#x27;_2)</span>  be the attacker in the computational unpredictability game.  <span class="math">\\mathcal{A}&#x27;&#x27;_1</span>  on input  <span class="math">(1^{\\lambda}, \\Sigma, pp)</span>  will first run  <span class="math">\\mathcal{A}&#x27;_1(1^{\\lambda}, \\Sigma, pp)</span> . It will output st' = st||y, where st is the output of  <span class="math">\\mathcal{A}_1</span> , and y the prefix of a random query that  <span class="math">\\mathcal{A}&#x27;_1</span>  made to the RO with length equal to the size of a verification key. Then,  <span class="math">\\mathcal{A}&#x27;&#x27;_2</span>  on input (st', vk) will run  <span class="math">\\mathcal{A}&#x27;_2(1^{\\lambda}, vk, st)</span> , until it halts and possibly outputs a number of SoWs. Since  <span class="math">\\mathcal{A}&#x27;</span>  is a PPT algorithm, the number of queries made to the RO is at most polynomial in number. Hence, with non-negligible probability B will occur and y will be the prefix of the RO query that matches the</p>

    <p class="text-gray-300">key of the SoW output by  <span class="math">\\mathcal{A}&#x27;</span> . This violates the computational unpredictability property, and hence B only occurs with negligible probability.</p>

    <p class="text-gray-300">Let C be the event where the adversary wins and outputs two distinct SoWs that correspond to the same query to the RO. This implies that the adversary can find a collision on G. In time  <span class="math">L = t&#x27; + t_{pre}</span>  polynomial in  <span class="math">\\lambda</span> , the probability that  <span class="math">\\mathcal{A}&#x27;</span>  finds a collision is  <span class="math">\\binom{L}{2} 2^{-\\lambda+1} = e^{-\\Omega(\\lambda)} = \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Finally, note that if  <span class="math">A_{\\ell}, B, C</span>  do not occur, it is implied that  <span class="math">\\mathcal{A}&#x27;</span>  will lose in the MU-TCMA experiment. Thus:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[\\mathsf{Exp}^{\\mathsf{MU\\text{-}TCMA}}_{\\mathcal{A},\\mathcal{F}}(1^{\\lambda},h,\\ell) &amp;= 1] = \\Pr[\\mathsf{Exp}^{\\mathsf{MU\\text{-}TCMA}}_{\\mathcal{A}&#x27;,\\mathcal{F}}(1^{\\lambda},h,\\ell) = 1] \\\\ &amp;\\leq \\Pr[A_{\\ell} \\vee B \\vee C] \\\\ &amp;\\leq \\Pr[A_{\\ell}] + \\Pr[B] + \\Pr[C] \\\\ &amp;\\leq \\Pr[A_{\\ell}] + \\mathsf{negl}(\\lambda) \\\\ &amp;\\leq e^{-\\frac{(1+\\sigma)p_ht\\sigma^2}{6}} + \\mathsf{negl}(\\lambda) \\end{split}</span>$</p>

    <p class="text-gray-300">where we have used the union bound for the third inequality.</p>

    <p class="text-gray-300">Verifiability. Assuming H and G take constant time, verification takes time  <span class="math">c_{\\text{ver}}\\lambda</span> , for some small constant  <span class="math">c_{\\text{ver}}</span>  which can be easily computed by careful inspection of the verification protocol.</p>

    <p class="text-gray-300">Successful. Let E be the event that in an execution of the Sign function no collisions occur. By the collision resistance property of H and G, it holds that  <span class="math">\\Pr[\\neg E] \\leq \\mathsf{negl}(\\lambda)</span> . For any  <span class="math">t \\in \\mathbb{N}</span> ,  <span class="math">pp \\in PP</span> ,  <span class="math">vk \\in K</span> ,  <span class="math">msg \\in M</span>  and  <span class="math">h \\in \\mathbb{N}</span>  it follows that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk, msg, h) &lt; t\\right] \\geq 1 - (1 - p_h)^t - \\mathsf{negl}(\\lambda)</span>$</p>

    <p class="text-gray-300">Independence. Let  <span class="math">\\{Y_i\\}_{i\\in I}</span>  be the same as  <span class="math">\\{X_i\\}_{i\\in I}=\\{\\mathsf{Steps}_{\\mathsf{Sign}}(pp,vk_i,m_i,h_i)\\}_{i\\in I}</span>  with the only difference that the random oracle is replaced with a random function, i.e., every time  <span class="math">\\mathsf{Sign}</span>  is called and the oracle H is queried it generates a random output. Obviously the random variables in  <span class="math">\\{Y_i\\}_{i\\in I}</span>  are mutually independent, since their output only depends on their own local coins.</p>

    <p class="text-gray-300">Regarding the second property, let E be the event that all  <span class="math">\\sigma_1</span>  sampled are different among all the invocations of Sign, and that no collisions occurs in G. Note, for polynomially big I, this event happens with overwhelming probability in  <span class="math">\\lambda</span> . Moreover, conditioned E, it holds that  <span class="math">\\Pr[\\{X_i\\}_{i\\in I}=z|E]</span>  is equal to  <span class="math">\\Pr[\\{Y_i\\}_{i\\in I}=z|E]</span> , for any z, since the random oracle behaves exactly as the random function we have replaced it with. Therefore, if  <span class="math">p(\\cdot)</span>  is a polynomial that upper bounds the number of steps of Sign, it holds that for any  <span class="math">z \\in [p(\\lambda)]^{|I|}</span></p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp;\\Pr[\\{X_i\\}_{i \\in I} = z] - \\Pr[\\{Y_i\\}_{i \\in I} = z] = \\\\ &amp;= \\Pr[\\{X_i\\}_{i \\in I} = z | E] \\Pr[E] + \\Pr[\\{X_i\\}_{i \\in I} = z | \\neg E] \\Pr[\\neg E] \\\\ &amp;- \\Pr[\\{Y_i\\}_{i \\in I} = z | E] \\Pr[E] - \\Pr[\\{Y_i\\}_{i \\in I} = z | \\neg E] \\Pr[\\neg E] \\\\ &amp;= (\\Pr[\\{X_i\\}_{i \\in I} = z | \\neg E] - \\Pr[\\{Y_i\\}_{i \\in I} = z | \\neg E]) \\Pr[\\neg E] \\end{aligned}</span>$</p>

    <p class="text-gray-300">Hence, it follows that the two distributions are  <span class="math">negl(\\lambda)</span> -close:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} 2\\Delta[\\{X_i\\}_{i\\in I}, &amp;\\{Y_i\\}_{i\\in I}] = \\sum_z |\\Pr[\\{X_i\\}_{i\\in I} = z] - \\Pr[\\{Y_i\\}_{i\\in I} = z]| \\\\ &amp;\\leq \\sum_z |(\\Pr[\\{X_i\\}_{i\\in I} = z|\\neg E] - \\Pr[\\{Y_i\\}_{i\\in I} = z|\\neg E]) \\Pr[\\neg E]| \\\\ &amp;\\leq \\Pr[\\neg E] \\sum_z |(\\Pr[\\{X_i\\}_{i\\in I} = z|\\neg E] - \\Pr[\\{Y_i\\}_{i\\in I} = z|\\neg E])| \\\\ &amp;\\leq \\operatorname{negl}(\\lambda) (\\sum_z \\Pr[\\{X_i\\}_{i\\in I} = z|\\neg E] + \\sum_z \\Pr[\\{Y_i\\}_{i\\in I} = z|\\neg E]) \\leq \\operatorname{negl}(\\lambda) \\end{split}</span>$</p>

    <p class="text-gray-300">The last inequality follows from the fact that each of the sums should be less or equal to 1, as the events described are disjoint and their union covers the entire sample space.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">SoW in the  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  model. Next, we argue that we can use the  <span class="math">\\mathcal{F}_{\\text{TREE}}^p</span>  functionality from [47] to realize a secure SoW scheme.</p>

    <p class="text-gray-300">We start by reciting the  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  description.  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  is parametrized by some hardness parameter p and keeps track of records on a tree. Initially, the tree contains  <span class="math">\\bot</span> . On invocation of  <span class="math">extend((m_1, \\ldots, m_{\\ell-1}), m)</span> ,  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  checks if  <span class="math">(m_1, \\ldots, m_{\\ell-1})</span>  is a valid path on the tree, and if yes with probability p extends this path by m and returns 1. Otherwise, returns 0. On invocation of  <span class="math">ver(m_1, \\ldots, m_\\ell)</span> ,  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  returns 1 if  <span class="math">m_1, \\ldots, m_\\ell</span>  is a valid path, and 0 otherwise. For simplicity, here we assume that extend and ver take one computational step each.</p>

    <p class="text-gray-300">The SoW protocol is constructed in a similar way as in the ROM; we only have to replace the &quot; <span class="math">H(...) &lt; 2^{\\lambda} - h</span> &quot; checks in Sign and Verify, with invocations to extend and ver on  <span class="math">\\mathcal{F}_{\\text{TREE}}^{(2^{\\lambda} - h)/2^{\\lambda}}</span> , respectively (see Algorithm 7). We will consider a slightly stronger version of  <span class="math">\\mathcal{F}_{\\text{TREE}}</span> , where the hardness parameter p is a parameter of the function calls. That is because SoW schemes allow for different hardness levels, while the original  <span class="math">\\mathcal{F}_{\\text{TREE}}</span>  functionality has a fixed hardness level. We note, that the results of [47] can be easily proved for the strengthened functionality.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-0&quot;&gt;&lt;/span&gt;<strong>Algorithm 7</strong> Bitcoin's SoW implementation based on functionality  <span class="math">\\mathcal{F}_{TREE}</span> . H is modeled as a RO, while  <span class="math">G_k</span>  is sampled from a collision resistant hash function family  <span class="math">\\mathcal{G}</span> . We omit functions PPub, KeyGen which are exactly the same as in Algorithm 6, while differences in Sign, Verify are depicted in red.</p>

    <pre><code class="language-text">1: function Sign(pp = (1^{\\lambda}, k), vk, msg, h)
              while true do
 2:
                    \\sigma_1 \\leftarrow \\mathcal{U}_{\\lambda}
 3:
                    dig \\leftarrow G_k(vk, \\sigma_1, msg)
  4:
                    for \\sigma_2 = 0^{\\lambda}|_2 to 1^{\\lambda}|_2 do
  5:
                           if (\\mathcal{F}_{\\text{TREE}}^{(2^{\\lambda}-h)/2^{\\lambda}}.extend(\\perp,vk||dig||\\sigma_2)=1) then
  6:
                                  return (\\sigma_1, \\sigma_2)
  7:
                           end if
  8:
                    end for
 9:
              end while
10:
11: end function
13: function Verify(pp = (1^{\\lambda}, k), vk, msg, h, \\sigma = (\\sigma_1, \\sigma_2))
14: return \\mathcal{F}_{\\text{TREE}}^{(2^{\\lambda} - h)/2^{\\lambda}}.ver(\\bot, vk||G(vk, \\sigma_1, msg)||\\sigma_2)
15: end function
</code></pre>

    <p class="text-gray-300">The proof that Algorithm 7 implements a secure SoW scheme follows the same arguments as the proof of Theorem 36. We omit the details for the full version of the paper.</p>

    <p class="text-gray-300"><strong>Theorem 37.</strong> If  <span class="math">\\mathcal{G}</span>  is a collision resistant hash function family, and we are in the  <span class="math">\\mathcal{F}_{TREE}</span> -hybrid world, then for any  <span class="math">\\sigma \\in (0,1)</span> , Algorithm 7 is</p>

    <pre><code class="language-text">- correct;

- O(\\lambda)-verifiable;

- (t_{sign}, 1 - \\left(\\frac{h}{2^{\\lambda}}\\right)^{t_{sign}})-successful, for h \\in [2^{\\lambda} - 1];

- run-time independent;
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">((1+\\sigma)(1-\\frac{h}{2^{\\lambda}}),e^{-\\frac{\\beta(h)t\\sigma^2}{6}}+\\text{negl}(\\lambda))</span> -MU-TCMA secure w.r.t. any computationally unpredictable function family  <span class="math">\\mathcal{F}</span> , for  <span class="math">h\\in[2^{\\lambda}-1]</span> .</li>
    </ul>

    <p class="text-gray-300">Comparison with the results of [31]. Since parameter  <span class="math">\\epsilon</span>  of the MU-TCMA property of BSOW is negligible in  <span class="math">\\beta(h) \\cdot t</span>  and the scheme is runtime independent, we can use Theorem 36 and obtain meaningful bounds for the  <span class="math">\\gamma</span> , f quantities introduced in the previous subsection. These quantities are important since  <span class="math">\\gamma</span>  determines how powerful the adversary our system can handle can be, and f is related to how fast blocks are produced. Replacing with the parameters proved for BPOW, for  <span class="math">\\sigma \\ll 1</span> ,  <span class="math">\\gamma</span>  and f are equal to:</p>

    <p class="text-gray-300"><span class="math">$\\gamma = (n-t) \\cdot \\left(1 - \\left(\\frac{h}{2^{\\lambda}}\\right)^{t&#x27;_{\\mathcal{H}}}\\right) \\cdot \\left(\\frac{h}{2^{\\lambda}}\\right)^{(n-1)t_{\\mathcal{H}}}, f = 1 - \\left(\\frac{h}{2^{\\lambda}}\\right)^{t&#x27;_{\\mathcal{H}}(n-t)}</span>$</p>

    <p class="text-gray-300">Both of these quantities appear in [31] and are well approximated by our results. Hence,  <span class="math">\\Pi_{PL}^{BSoW}</span>  implements a robust transaction ledger with overwhelming probability in  <span class="math">\\lambda</span>  and with bounds comparable to those in [31], and achieves consensus when the honest parties have the honest majority of the computational power.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">References</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-4&quot;&gt;&lt;/span&gt;[1] N. Alon, O. Goldreich, J. Håstad, and R. Peralta. Simple construction of almost k-wise independent random variables. <em>Random Struct. Algorithms</em>, 3(3):289–304, 1992.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-6&quot;&gt;&lt;/span&gt;[2] J. Alwen and B. Tackmann. Moderately hard functions: Definition, instantiations, and applications. In Theory of Cryptography - 15th International Conference, TCC 2017, Baltimore, MD, USA, November 12-15, 2017, Proceedings, Part I, pages 493–526, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-3&quot;&gt;&lt;/span&gt;[3] M. Andrychowicz and S. Dziembowski. Pow-based distributed cryptography with no trusted setup. In R. Gennaro and M. Robshaw, editors, Advances in Cryptology - CRYPTO 2015 - 35th Annual Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2015, Proceedings, Part II, volume 9216 of Lecture Notes in Computer Science, pages 379–399. Springer, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-8&quot;&gt;&lt;/span&gt;[4] A. Back. Hashcash-amortizable publicly auditable cost functions. Early draft of paper, 2000.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-0&quot;&gt;&lt;/span&gt;[5] A. Back. Hashcash–a denial of service counter-measure, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-5&quot;&gt;&lt;/span&gt;[6] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra, J. Timón, and P. Wuille. Enabling blockchain innovations with pegged sidechains. <em>URL: http://www. opensciencereview.</em> com/papers/123/enablingblockchain-innovations-with-pegged-sidechains, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-1&quot;&gt;&lt;/span&gt;[7] C. Badertscher, U. Maurer, D. Tschudi, and V. Zikas. Bitcoin as a transaction ledger: A composable treatment. In Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I, pages 324-356, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-7&quot;&gt;&lt;/span&gt;[8] M. Ball, A. Rosen, M. Sabin, and P. N. Vasudevan. Proofs of work from worst-case assumptions. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I, pages 789–819, 2018.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-9&quot;&gt;&lt;/span&gt;[9] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete security treatment of symmetric encryption. In 38th Annual Symposium on Foundations of Computer Science, FOCS '97, Miami Beach, Florida, USA, October 19-22, 1997, pages 394-403, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-10&quot;&gt;&lt;/span&gt;[10] M. Bellare, J. Jaeger, and J. Len. Better than advertised: Improved collision-resistance guarantees for md-based hash functions. In <em>Proceedings of the 2017 ACM SIGSAC Conference on Computer and Com</em>munications Security, CCS '17, pages 891–906, New York, NY, USA, 2017. ACM.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-2&quot;&gt;&lt;/span&gt;[11] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In CCS '93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993, pages 62–73, 1993.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-11&quot;&gt;&lt;/span&gt;[12] M. Bellare and P. Rogaway. The exact security of digital signatures - how to sign with RSA and rabin. In Advances in Cryptology - EUROCRYPT '96, International Conference on the Theory and Application of Cryptographic Techniques, Saragossa, Spain, May 12-16, 1996, Proceeding, pages 399–416, 1996.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-4&quot;&gt;&lt;/span&gt;[13] M. Ben-Or. Another advantage of free choice: Completely asynchronous agreement protocols (extended abstract). In R. L. Probert, N. A. Lynch, and N. Santoro, editors, Proceedings of the Second Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, Montreal, Quebec, Canada, August 17-19, 1983, pages 27–30. ACM, 1983.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-12&quot;&gt;&lt;/span&gt;[14] I. Bentov, P. Hub'avcek, T. Moran, and A. Nadler. Tortoise and hares consensus: the meshcash framework for incentive-compatible, scalable cryptocurrencies. IACR Cryptology ePrint Archive, 2017:300, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-15&quot;&gt;&lt;/span&gt;[15] D. J. Bernstein and T. Lange. Non-uniform cracks in the concrete: The power of free precomputation. In Advances in Cryptology - ASIACRYPT 2013 - 19th International Conference on the Theory and Application of Cryptology and Information Security, Bengaluru, India, December 1-5, 2013, Proceedings, Part II, pages 321–340, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-13&quot;&gt;&lt;/span&gt;[16] N. Bitansky, S. Goldwasser, A. Jain, O. Paneth, V. Vaikuntanathan, and B. Waters. Time-lock puzzles from randomized encodings. In M. Sudan, editor, Proceedings of the 2016 ACM Conference on Innovations in Theoretical Computer Science, Cambridge, MA, USA, January 14-16, 2016, pages 345–356. ACM, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-14&quot;&gt;&lt;/span&gt;[17] D. Boneh, J. Bonneau, B. B¨unz, and B. Fisch. Verifiable delay functions. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I, pages 757–788, 2018.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-3&quot;&gt;&lt;/span&gt;[18] M. Borderding. Levels of authentication in distributed agreement. In O. Babaoglu and K. Marzullo, ¨ editors, Distributed Algorithms, 10th International Workshop, WDAG '96, Bologna, Italy, October 9-11, 1996, Proceedings, volume 1151 of Lecture Notes in Computer Science, pages 40–55. Springer, 1996.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-16&quot;&gt;&lt;/span&gt;[19] R. Canetti. Security and composition of multiparty cryptographic protocols. J. Cryptology, 13(1):143–202, 2000.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-8&quot;&gt;&lt;/span&gt;[20] R. Canetti, O. Goldreich, and S. Halevi. The random oracle methodology, revisited. J. ACM, 51(4):557–594, July 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-17&quot;&gt;&lt;/span&gt;[21] I. Damg˚ard. A design principle for hash functions. In Advances in Cryptology - CRYPTO '89, 9th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 1989, Proceedings, pages 416–427, 1989.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-0&quot;&gt;&lt;/span&gt;[22] D. Dolev and H. R. Strong. Authenticated algorithms for byzantine agreement. SIAM J. Comput., 12(4):656–666, 1983.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-7&quot;&gt;&lt;/span&gt;[23] J. R. Douceur. The sybil attack. In P. Druschel, M. F. Kaashoek, and A. I. T. Rowstron, editors, Peerto-Peer Systems, First International Workshop, IPTPS 2002, Cambridge, MA, USA, March 7-8, 2002, Revised Papers, volume 2429 of Lecture Notes in Computer Science, pages 251–260. Springer, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-1&quot;&gt;&lt;/span&gt;[24] C. Dwork, N. A. Lynch, and L. J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288–323, 1988.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-6&quot;&gt;&lt;/span&gt;[25] C. Dwork and M. Naor. Pricing via processing or combatting junk mail. In Proceedings of the 12th Annual International Cryptology Conference on Advances in Cryptology, CRYPTO '92, pages 139–147, London, UK, UK, 1993. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-5&quot;&gt;&lt;/span&gt;[26] P. Feldman and S. Micali. An optimal probabilistic protocol for synchronous byzantine agreement. SIAM J. Comput., 26(4):873–933, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-2&quot;&gt;&lt;/span&gt;[27] M. J. Fischer, N. A. Lynch, and M. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374–382, 1985.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-9&quot;&gt;&lt;/span&gt;[28] M. Fitzi. Generalized communication and security models in Byzantine agreement. PhD thesis, ETH Zurich, Z¨urich, Switzerland, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-10&quot;&gt;&lt;/span&gt;[29] J. A. Garay and A. Kiayias. SoK: A consensus taxonomy in the blockchain era. IACR Cryptology ePrint Archive, 2018:754, 2018.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-10&quot;&gt;&lt;/span&gt;[30] J. A. Garay, A. Kiayias, and N. Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. IACR Cryptology ePrint Archive, 2014:765, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-3&quot;&gt;&lt;/span&gt;[31] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology - EUROCRYPT 2015, pages 281–310, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-7&quot;&gt;&lt;/span&gt;[32] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol with chains of variable difficulty. In Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I, pages 291–323, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-9&quot;&gt;&lt;/span&gt;[33] J. A. Garay, A. Kiayias, N. Leonardos, and G. Panagiotakos. Bootstrapping the blockchain, with applications to consensus and fast PKI setup. In Public-Key Cryptography - PKC 2018 - 21st IACR International Conference on Practice and Theory of Public-Key Cryptography, Rio de Janeiro, Brazil, March 25-29, 2018, Proceedings, Part II, pages 465–495, 2018.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-14&quot;&gt;&lt;/span&gt;[34] J. A. Garay, A. Kiayias, and G. Panagiotakos. Consensus from signatures of work. Cryptology ePrint Archive, Report 2017/775, 2017. <a href="https://eprint.iacr.org/2017/775">https://eprint.iacr.org/2017/775</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-13&quot;&gt;&lt;/span&gt;[35] J. A. Garay, A. Kiayias, and G. Panagiotakos. Iterated search problems and blockchain security under falsifiable assumptions. Cryptology ePrint Archive, Report 2019/315, 2019. <a href="https://eprint.iacr.org/2019/315">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2019/315">2019/315</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-15&quot;&gt;&lt;/span&gt;[36] J. A. Garay, P. MacKenzie, M. Prabhakaran, and K. Yang. Resource fairness and composability of cryptographic protocols. Journal of cryptology, 24(4):615–658, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-12&quot;&gt;&lt;/span&gt;[37] M. Jakobsson and A. Juels. Proofs of work and bread pudding protocols. In Proceedings of the IFIP TC6/TC11 Joint Working Conference on Secure Information Networks: Communications and Multimedia Security, CMS '99, pages 258–272, Deventer, The Netherlands, The Netherlands, 1999. Kluwer, B.V.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-4&quot;&gt;&lt;/span&gt;[38] A. Juels and J. G. Brainard. Client puzzles: A cryptographic countermeasure against connection depletion attacks. In Proceedings of the Network and Distributed System Security Symposium, NDSS 1999, San Diego, California, USA. The Internet Society, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-8&quot;&gt;&lt;/span&gt;[39] J. Katz, A. Miller, and E. Shi. Pseudonymous secure computation from time-lock puzzles. IACR Cryptology ePrint Archive, 2014:857, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-17&quot;&gt;&lt;/span&gt;[40] A. Kiayias and G. Panagiotakos. Speed-security tradeoffs in blockchain protocols. Technical report, IACR: Cryptology ePrint Archive, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-16&quot;&gt;&lt;/span&gt;[41] P. C. Kocher. Timing attacks on implementations of diffie-hellman, rsa, dss, and other systems. In Advances in Cryptology - CRYPTO '96, 16th Annual International Cryptology Conference, Santa Barbara, California, USA, August 18-22, 1996, Proceedings, pages 104–113, 1996.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-0&quot;&gt;&lt;/span&gt;[42] L. Lamport, R. E. Shostak, and M. C. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, 1982.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-11&quot;&gt;&lt;/span&gt;[43] Y. Lewenberg, Y. Sompolinsky, and A. Zohar. Inclusive block chain protocols. In Financial Cryptography and Data Security, 2015, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-5&quot;&gt;&lt;/span&gt;[44] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-1&quot;&gt;&lt;/span&gt;[45] M. Okun. Agreement among unacquainted byzantine generals. In P. Fraigniaud, editor, DISC, volume 3724 of Lecture Notes in Computer Science, pages 499–500. Springer, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-2&quot;&gt;&lt;/span&gt;[46] M. Okun. Distributed computing among unacquainted processors in the presence of byzantine distributed computing among unacquainted processors in the presence of byzantine failures. Ph.D. Thesis Hebrew University of Jerusalem, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-37-6&quot;&gt;&lt;/span&gt;[47] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In J. Coron and J. B. Nielsen, editors, Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II, volume 10211 of Lecture Notes in Computer Science, pages 643–673, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-38-0&quot;&gt;&lt;/span&gt;[48] M. C. Pease, R. E. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27(2):228–234, 1980.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-38-1&quot;&gt;&lt;/span&gt;[49] B. Pfitzmann and M. Waidner. Unconditional byzantine agreement for any number of faulty processors. In STACS 92, 9th Annual Symposium on Theoretical Aspects of Computer Science, Cachan, France, February 13-15, 1992, Proceedings, pages 339–350, 1992.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-38-6&quot;&gt;&lt;/span&gt;[50] A. Poelstra. On stake and consensus (2015). URL https://download. wpsoftware. net/bitcoin/pos. pdf.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-38-3&quot;&gt;&lt;/span&gt;[51] F. B. Schneider. Implementing fault-tolerant services using the state machine approach: A tutorial. ACM Comput. Surv., 22(4):299–319, Dec. 1990.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-38-5&quot;&gt;&lt;/span&gt;[52] Y. Sompolinsky, Y. Lewenberg, and A. Zohar. SPECTRE: A fast and scalable cryptocurrency protocol. IACR Cryptology ePrint Archive, 2016:1159, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-38-4&quot;&gt;&lt;/span&gt;[53] Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers, pages 507–527, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-38-2&quot;&gt;&lt;/span&gt;[54] D. Stebila, L. Kuppusamy, J. Rangasamy, C. Boyd, and J. M. G. Nieto. Stronger difficulty notions for client puzzles and denial-of-service-resistant protocols. In Topics in Cryptology - CT-RSA 2011 - The Cryptographers' Track at the RSA Conference 2011, San Francisco, CA, USA, February 14-18, 2011. Proceedings, pages 284–301, 2011.</p></li>
    </ul>

`;
---

<BaseLayout title="Consensus from Signatures of Work (2017/775)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/775
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="consensus-from-signatures-of-work-2017" />
  </article>
</BaseLayout>
