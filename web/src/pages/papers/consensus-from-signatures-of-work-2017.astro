---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/775';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-22';
const TITLE_HTML = 'Consensus from Signatures of Work';
const AUTHORS_HTML = 'Juan A.  Garay, Aggelos Kiayias, Giorgos Panagiotakos';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Assuming the existence of a public-key infrastructure (PKI), digital signatures are a fundamental building block in the design of
secure consensus protocols
with optimal resilience.
More recently, with the advent of blockchain
protocols like Bitcoin, consensus has been considered in the \`\`permissionless&#x27;&#x27;
setting where no authentication or even point-to-point communication is available.
Yet, despite some positive preliminary
results, there has been no attempt to formalize a
building block that is sufficient for designing consensus protocols in this setting.

In this work we fill this void by putting forth a formalization of
such a primitive, which we call {\\em signatures of work} (SoW). Distinctive features of our new notion are a lower bound on the number of steps required to produce a signature;
fast verification; {\\em moderate unforgeability}---producing a sequence of SoWs, for chosen messages, does not provide an advantage to an adversary in terms of running time; and signing time independence---most relevant in concurrent multi-party applications, as we show.

Armed with SoW, we then present a new permissionless consensus protocol  which is secure
assuming an honest majority of computational power,
thus providing
a blockchain counterpart to the classical Dolev-Strong consensus protocol.
The protocol is built on top of a SoW-based blockchain and standard properties of the underlying hash function,
thus improving on the only
known provably secure consensus protocol in this setting, which
relies on the random-oracle model in a fundamental way.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Bitcoin &middot; proof of work &middot; consensus</p>
    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Signatures of Work</h2>

    <p class="text-gray-300">The main goal of this paper is to implement consensus in the permissionless setting without relying on the strong independence property of the underlying computational resource. Towards that goal, in this section we introduce the signature of work (SoW) primitive. At a high level, a SoW enables one party to convince others that she has invested some computational power during some specific time interval and with respect to a &quot;message.&quot; Next, we formalize this notion and present its desired security properties.</p>

    <p class="text-gray-300">SoW syntax. Given a security parameter &lambda;, let P P be the public parameter space, HP &sube; N the hardness parameter space, K the key space, M the message space, and S the signature space. With foresight, the role of the key is to provide &quot;freshness&quot; for the signature computation, thus certifying that the signature was computed in the given time interval.</p>

    <p class="text-gray-300">Definition 4. A SoW scheme consists of four algorithms SoW = (PPub,KeyGen, Sign, Verify), where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>PPub(1<sup>&lambda;</sup> ) is a randomized algorithm that takes as input the security parameter &lambda;, and returns a set of public parameters pp &isin; P P.</li>
      <li>KeyGen(pp) is a randomized algorithm that takes as input the public parameters pp, and returns a key vk &isin; K. (See Remark <a href="#page-9-1">1</a> below on the role of keys in SoW schemes.)</li>
      <li>Sign(pp, vk, msg, h) is a randomized algorithm that takes as input public parameters pp &isin; P P, a key vk &isin; K, a message msg &isin; M and hardness parameter h &isin; HP, and returns a signature (of work) &sigma; &isin; S.</li>
      <li>Verify(pp, vk, msg, h, &sigma;) is a deterministic algorithm that takes as input public parameters pp &isin; P P, a key vk &isin; K, message msg &isin; M, hardness parameter h &isin; HP and a signature &sigma; &isin; S, and returns true or false to indicate the validity of the signature.</li>
    </ul>

    <p class="text-gray-300">Remark 1. SoW schemes only have a public verification key. The role of this key is to guarantee that the computational work spent in order to create a signature of work is &quot;fresh,&quot; i.e., executed during a specific time interval (say, from the time the key became known to the signer). In contrast, classical digital signatures also have a secret key that serves as a trapdoor to compute signatures. In the applications we consider, the existence of trapdoor information is not meaningful, and in fact may hurt the security of the respective constructions.</p>

    <p class="text-gray-300">Security properties. Next, we present a number of security properties that we will require SoW schemes to satisfy. We start with the correctness property.</p>

    <p class="text-gray-300">Definition 5. We say that a SoW scheme is correct if for every &lambda; &isin; N, pp &isin; P P, vk &isin; K, h &isin; HP, and msg &isin; M:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{Verify}(pp, vk, msg, h, \\mathsf{Sign}(pp, vk, msg, h)) = \\mathsf{true} \\quad \\right] \\geq 1 - \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300">Next, we require that the time to verify a signature be upper bounded.</p>

    <p class="text-gray-300">Definition 6. We say that a SoW scheme is t-verifiable, if Verify takes time at most t (on all inputs).</p>

    <p class="text-gray-300">Next, we capture the case of a malicious signer (resp., verifier) in the context of SoWs. In the first case, the adversary's objective is to compute a number of signatures a lot faster than an honest signer would, while in the second case it is to make the honest signer take too much time to generate a signature.</p>

    <p class="text-gray-300">We deal with malicious signers first. We put forth an attack that we will use to express a class of adversaries that attempt to forge signatures faster than expected. Intuitively, this constitutes an attack against an honest verifier that may be trying to gauge a certain measure using the number of signatures. The game defining the attack is shown in Figure 2; we call the corresponding security property  <span class="math">Moderate\\ Unforgeability\\ against\\ Tampering\\ and\\ Chosen\\ Message\\ Attack\\ (MU-TCMA).</span>  As in the security definitions of standard signatures (e.g., EU-CMA), we allow the adversary to have access to a signing oracle  <span class="math">\\mathcal{S}</span> . Every time the oracle is queried, we assume that it runs the Sign procedure with uniformly sampled randomness. A subtle point in the modeling of security in the presence of such oracle is that  <span class="math">\\mathcal{S}</span>  should also &quot;leak&quot; the number of steps it took for a query to be processed. In an actual execution while interacting with honest parties that are producing signatures, time is a side channel that may influence the adversarial strategy; in order to preserve the dependency on this side channel we will require from  <span class="math">\\mathcal{S}</span>  to leak this information. We note that in the classical signatures literature, timing attacks have also been a serious consideration [41].</p>

    <p class="text-gray-300">In addition, we require that the key used by the adversary to construct signatures be fresh, i.e., we want to avoid situations where the adversary outputs signatures that he has precomputed a long time ago. We model this by providing the fresh key after the adversary has finished running his precomputation phase. Further, we allow the adversary to tamper with the key by manipulating it via tampering functions belonging to a family of functions  <span class="math">\\mathcal{F}</span> .</p>

    <p class="text-gray-300">Looking ahead, the tampering function in our applications will be related to a keyed hash function, where the key of the hash is part of a common random string (CRS). Hence, we choose to model functions in  <span class="math">\\mathcal{F}</span>  to have two inputs:  <span class="math">\\Sigma</span>  (the CRS) and vk. Moreover, the output of the adversary is deemed invalid if he tampers vk with functions  <span class="math">f_1, f_2</span>  in such a way that  <span class="math">f_1(\\Sigma, vk) = f_2(\\Sigma, vk)</span> . Otherwise, the adversary could launch a generic attack that is unrelated to the SoW scheme, and produce signatures at twice the rate of an honest signer, as follows. The adversary first finds  <span class="math">f_1, f_2</span>  that have this property, and then computes signatures using the tampered key  <span class="math">f_1(\\Sigma, vk)</span> . The trick is that each of them will also correspond to a signature with key  <span class="math">f_2(\\Sigma, vk)</span> . Hence, he effectively can double the rate at which he produces signatures.</p>

    <p class="text-gray-300">Formally, the adversary will have access to  <span class="math">S(\\cdot, \\cdot)</span> , an SoW oracle that on input (vk', msg), where  <span class="math">vk&#x27; \\in K</span>  and  <span class="math">msg \\in M</span> , returns the pair  <span class="math">(\\sigma, t)</span>  where  <span class="math">\\sigma</span>  is the output of  <span class="math">\\mathsf{Sign}(pp, vk&#x27;, msg, h)</span>  and t is the number of steps taken by the  <span class="math">\\mathsf{Sign}</span>  algorithm on these parameters. Function  <span class="math">\\mathsf{Asked}(vk&#x27;, msg, \\sigma)</span>  is true if  <span class="math">\\sigma</span>  was the response of S to some query (vk', msg).</p>

    <p class="text-gray-300">We are now ready to formulate the security property of Moderate Unforgeability against Tampering and Chosen Message Attacks (MU-TCMA). It has two parameters,  <span class="math">\\beta</span>  and  <span class="math">\\epsilon</span> , and, informally, it states that no adversary  <span class="math">\\mathcal{A}</span>  exists in the experiment of Figure 2 that takes at most t steps after receiving key vk and produces  <span class="math">\\ell \\geq \\beta \\cdot t</span>  signatures with probability better than  <span class="math">\\epsilon</span> . Note that in total we allow  <span class="math">\\mathcal{A}</span>  to take any polynomial number of steps, i.e., the adversary is allowed to execute a precomputation stage that permits it to obtain an arbitrary number of signatures before learning vk. In the definition below, we allow  <span class="math">\\beta</span>  to depend on the hardness level h, and  <span class="math">\\epsilon</span>  on h, t and  <span class="math">q_{\\mathcal{S}}</span> , the number of queries the adversary makes to the signing oracle.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> Let  <span class="math">\\mathcal{F} = \\{F_{\\lambda}\\}_{{\\lambda} \\in \\mathbb{N}}</span> , where  <span class="math">F_{\\lambda}</span>  is a family of functions  <span class="math">f: \\{0,1\\}^{\\lambda} \\times K \\to K</span> . A SoW scheme is  <span class="math">(\\beta,\\epsilon)</span> -Moderately Unforgeable against Tampering and Chosen-Message Attacks (MUTCMA) with respect to tampering function class  <span class="math">\\mathcal{F}</span> , if for any polynomially large  <span class="math">t_1, t_2</span> , any adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , where  <span class="math">\\mathcal{A}_1</span>  is  <span class="math">t_1</span> -bounded and  <span class="math">\\mathcal{A}_2</span>  is  <span class="math">t_2</span> -bounded and makes at most  <span class="math">q_{\\mathcal{S}}</span>  queries to oracle  <span class="math">\\mathcal{S}</span> , for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , and any  <span class="math">h \\in HP</span> , the probability of  <span class="math">\\mathcal{A}</span>  winning in  <span class="math">\\mathsf{Exp}_{\\mathcal{A},\\mathcal{F}}^{\\mathsf{MU-TCMA}}(1^{\\lambda}, h, \\lfloor \\beta(h) \\cdot t_2 \\rfloor)</span>  (Figure 2) is less than  <span class="math">\\epsilon(h, t_2, q_{\\mathcal{S}})</span> .</p>

    <p class="text-gray-300">Remark 2. As mentioned in Section 1, unlike previous unforgeability definitions (e.g., [12]), Definition 7 is parameterized by the <em>rate</em> at which the adversary can produce signatures, instead of the number of steps it needs to compute one, which is more appropriate for the moderate unforgeability game where the adversary tries to produce multiple signatures.</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^3&lt;/sup&gt;K</span>  is the key space of the SoW scheme.</p>

    <pre><code class="language-text">ExpMU-TCMA
                             A,F (1&lambda;
                                     , h, \`)
&Sigma; &larr; U&lambda;; pp &larr; PPub(1&lambda;
               ); (Public parameters)
st &larr; A1(1&lambda;
       , &Sigma;, pp); (Precomputation)
vk &larr; KeyGen(pp); (Verification key)
(fi, msgi
     , &sigma;i)i&isin;[\`] &larr; AS(&middot;,&middot;)
             2
                (1&lambda;
                  , vk, st); (SoW computation)
return V\`
     i=1
         Verify(pp, fi(&Sigma;, vk), msgi
                        , &sigma;i) &and; &not;Asked(fi(&Sigma;, vk), msgi
                                           , &sigma;i)
         &and; (fi &isin; F&lambda;) &and; (&forall;j &isin; [\`] : fi(&Sigma;, vk) = fj (&Sigma;, vk) &rArr; i = j)
                                              !
</code></pre>

    <p class="text-gray-300">Figure 2: The Moderate Unforgeability against Tampering and Chosen-Message Attack (MU-TCMA) experiment for a SoW scheme.</p>

    <p class="text-gray-300">In the MU-TCMA definition we are going to consider tampering functions classes that at the very least preserve the unpredictability of vk. Otherwise, the adversary can generically attack any SoW scheme by predicting the tampered key and precomputing signatures. Formally, we will say that F is computationally unpredictable if the adversary, given the CRS &Sigma;, cannot guess a value y that he will be able to &quot;hit&quot; when he gains access to vk through some f &isin; F.</p>

    <p class="text-gray-300">Definition 8. Let F = {F&lambda;}&lambda;&isin;N, where F<sup>&lambda;</sup> is a family of functions f : {0, 1} <sup>&lambda;</sup> &times; K &rarr; K. We say that F is computationally unpredictable with respect to a SoW scheme SoW, if for any PPT RAM A = (A1, A2), and for any &lambda; &isin; N, it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{pp \\leftarrow \\mathsf{PPub}(1^\\lambda);\\\\ vk \\leftarrow \\mathsf{KeyGen}(pp);\\\\ \\Sigma \\leftarrow \\mathcal{U}_\\lambda}} \\begin{bmatrix} (st,y) \\leftarrow \\mathcal{A}_1(1^\\lambda, \\Sigma, pp); f \\leftarrow \\mathcal{A}_2(1^\\lambda, st, vk) :\\\\ f \\in F_\\lambda \\land f(\\Sigma, vk) = y \\end{bmatrix} \\leq \\mathsf{negl}(\\lambda).</span>$</p>

    <p class="text-gray-300">Next, we consider the case of attacking an honest signer. Attacking an honest signer amounts to finding a certain set of keys over which the honest signer algorithm fails to produce SoWs sufficiently fast and regularly. We say that a SoW scheme is (t, &alpha;)-successful when the probability that the signer computes a signature in t steps is at least &alpha;.</p>

    <p class="text-gray-300">Definition 9. We say that SoW scheme is (t, &alpha;)-successful if for any &lambda; &isin; N and any h &isin; HP, it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{pp \\leftarrow \\mathsf{PPub}(1^\\lambda);\\\\ vk \\leftarrow \\mathsf{KeyGen}(pp);\\\\ msg \\leftarrow M}} \\left[ \\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk, msg, h) \\leq t \\right] \\geq \\alpha(h).</span>$</p>

    <p class="text-gray-300">Finally, in the same corrupt-verifier setting, we will require the signing time of honest signers to have some (limited) independence, which will be important for the applications we have in mind. This property, in combination with the efficiency and MU-TCMA properties, will prove crucial in ensuring that when multiple signers work together, the distribution of the number of them who succeed in producing a signature has some &quot;good&quot; variance and concentration properties.</p>

    <p class="text-gray-300">Definition 10. We say that a SoW scheme has almost-independent runtime iff for any polynomial p(&middot;), any &lambda; &isin; N, any h &isin; HP, there exists a set of mutually independent random variables {Yi}i&isin;[p(&lambda;)] such that for any pp &isin; P P,((vk<sup>i</sup> , mi))i&isin;[p(&lambda;)] &isin; (K&times;M) p(&lambda;) it holds that &#8710;[(StepsSign(pp, vk<sup>i</sup> , m<sup>i</sup> , h))<sup>i</sup> ,(Yi)<sup>i</sup> ] &le; negl(&lambda;).</p>

    <p class="text-gray-300">Independence assumptions. As mentioned earlier, MU-TCMA does not enforce any independence assumption, and only bounds the probability that the rate at which the adversary computes SoWs is high. In contrast, the independent-runtime property does so, but only for honest signers. We remark that achieving such property is considerably easier for the honest case, as we can be sure that signers will use independently sampled coins if instructed; a guarantee that we cannot have for the adversary.</p>

    <p class="text-gray-300"><strong>Parameters' range.</strong> Let SoW be a scheme that is  <span class="math">(t_{\\text{sign}}, \\alpha)</span> -Successful. SoW trivially satisfies the MU-TCMA property for  <span class="math">\\beta(h) &gt; 1</span> , since the adversary does not have enough time to output the signatures it has computed. On the other hand, assuming  <span class="math">\\epsilon(h, t, q_S)</span>  is a negligible function of t,  <span class="math">\\alpha(h)</span>  must be smaller than  <span class="math">\\beta(h) \\cdot t_{\\text{sign}}</span> , otherwise the expected number of SoWs computed by the Sign function would exceed that allowed by the MU-TCMA property. Hence, for optimal security, it should hold that  <span class="math">\\alpha(h)</span>  is close to  <span class="math">\\beta(h) \\cdot t_{\\text{sign}}</span> .</p>

    <p class="text-gray-300">Next, we turn to applications of our SoW primitive.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Applications</h2>

    <p class="text-gray-300">In this section we showcase applications of SoWs, the first one being implementing robust transaction ledgers: Using our primitive and standard properties of the underlying hash function, we establish the security of the Bitcoin backbone protocol [31]. The second application is realizing consensus in the permisionless setting: We construct a new blockchain-based consensus protocol for an honest majority provably secure under the same assumptions as above, thus providing a blockchain counterpart to the classical result in the cryptographic setting with a trusted (PKI) setup [22].</p>

    <p class="text-gray-300">In both applications we assume the existence of a SoW scheme with the security properties defined bellow.</p>

    <p class="text-gray-300"><strong>Assumption 1</strong> (SoW Assumption). For parameters  <span class="math">\\beta, \\epsilon, t&#x27;_{\\mathcal{H}}, \\alpha</span>  and  <span class="math">t_{\\text{ver}}</span>  we assume that SoW = (PPub, KeyGen, Sign, Verify) is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Correct;</li>
      <li><span class="math">(\\beta, \\epsilon)</span> -MU-TCMA with respect to any computationally unpredictable tampering function class (cf. Definition 8);</li>
      <li><span class="math">(t&#x27;_{\\mathcal{H}}, \\alpha)</span> -successful;<sup>4</sup></li>
      <li>almost run-time independent; and</li>
      <li><span class="math">t_{\\text{ver}}</span> -verifiable,</li>
    </ul>

    <p class="text-gray-300">where  <span class="math">\\epsilon(h,t,q_S) \\in \\mathsf{negl}(\\beta(h) \\cdot t)</span> . Moreover, we assume that the parameter spaces K,M,S of the scheme are equal to  <span class="math">\\{0,1\\}^{\\log |K|}, \\{0,1\\}^*, \\{0,1\\}^{\\log |S|}</span> , respectively.</p>

    <p class="text-gray-300">For a SoW scheme to be used in the context of the Bitcoin protocol, choosing K, M, S as above is important due to the underlying hash-chain structure of the blockchain: The hash of each block acts as a key of the SoW scheme, thus the output of the hash function should match the key space of the SoW.</p>

    <p class="text-gray-300">We start with some pertinent details about the model that the two applications mentioned above will be analyzed under.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 The Permissionless Model, Revisited</h3>

    <p class="text-gray-300">All the security models proposed for the analysis of PoW-based blockchain protocols [31, 47] rely on bounding the number of queries to an idealized functionality to model limited computational resources. In contrast, we do not wish to restrict the way the adversary accesses the computational resource, and thus we model limited computational resources in a more general manner, i.e., by limiting the exact number of steps parties take. Next, we present a revised version of the model of [31] that captures our considerations.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>Parameter  <span class="math">t&#x27;_{\\mathcal{H}}</span>  corresponds to a lower bound on the running time of honest parties that we introduce in detail later.</p>

    <p class="text-gray-300">For the reasons explained in Section 2, we substitute IRAMs for ITMs. The execution of a protocol  <span class="math">\\Pi</span>  is driven by an &quot;environment&quot; program  <span class="math">\\mathcal Z</span>  that may spawn multiple instances running the protocol  <span class="math">\\Pi</span> . The programs in question can be thought of as &quot;interactive RAMs&quot; communicating through registers in a well-defined manner, with instances and their spawning at the discretion of a control program which is also an IRAM and is denoted by C. In particular, the control program C forces the environment to perform a &quot;round-robin&quot; participant execution sequence for a fixed set of parties.</p>

    <p class="text-gray-300">Specifically, the execution driven by  <span class="math">\\mathcal{Z}</span>  is defined with respect to a protocol  <span class="math">\\Pi</span> , an adversary  <span class="math">\\mathcal{A}</span>  (also an IRAM) and a set of parties  <span class="math">P_1, ..., P_n</span> ; these are hardcoded in the control program C. The protocol  <span class="math">\\Pi</span>  is defined in a &quot;hybrid&quot; setting and has access to one &quot;ideal functionality,&quot; called the <em>diffusion channel</em> (see below). It is used as subroutine by the programs involved in the execution (the IRAMs of  <span class="math">\\Pi</span>  and  <span class="math">\\mathcal{A}</span> ) and is accessible by all parties once they are spawned.</p>

    <p class="text-gray-300">Initially, the environment  <span class="math">\\mathcal{Z}</span>  is restricted by C to spawn the adversary  <span class="math">\\mathcal{A}</span> . Each time the adversary is activated, it may communicate with C via messages of the form (Corrupt,  <span class="math">P_i</span> ). The control program C will register party  <span class="math">P_i</span>  as corrupted, only provided that the environment has previously given an input of the form (Corrupt,  <span class="math">P_i</span> ) to  <span class="math">\\mathcal{A}</span>  and that the number of corrupted parties is less or equal t, a bound that is also hardcoded in  <span class="math">\\mathcal{C}</span> . The first party to be spawned running protocol  <span class="math">\\Pi</span>  is restricted by C to be party  <span class="math">P_1</span> . After a party  <span class="math">P_i</span>  is activated, the environment is restricted to activate party  <span class="math">P_{i+1}</span> , except when  <span class="math">P_n</span>  is activated in which case the next party to be activated is always the adversary  <span class="math">\\mathcal{A}</span> . Note that when a corrupted party  <span class="math">P_i</span>  is activated the adversary  <span class="math">\\mathcal{A}</span>  is activated instead.</p>

    <p class="text-gray-300">Next, we describe how different parties communicate. Initially, the diffusion functionality sets the variable round to be 1. It also maintains a Receive() string defined for each party  <span class="math">P_i</span> . A party is allowed at any moment to fetch the messages sent to it at the previous round that are contained in its personal Receive() string. Moreover, when the functionality receives an instruction to diffuse a message m from party  <span class="math">P_i</span>  it marks the party as complete for the current round and forwards the message to the adversary; note that m is allowed to be empty. At any moment, the adversary A is allowed to specify the contents of the Receive() string for each party  <span class="math">P_i</span> . The adversary has to specify when it is complete for the current round. When all parties are complete for the current round, the functionality inspects the contents of all Receive() strings and includes any messages that were diffused by the parties in the current round but not contributed by the adversary to the Receive() tapes. The variable round is then incremented.</p>

    <p class="text-gray-300">Based on the above, we denote by  <span class="math">\\{\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,t,n}(z)\\}_{z\\in\\{0,1\\}^*}</span>  the random variable ensemble that corresponds to the view of party P at the end of an execution where  <span class="math">\\mathcal{Z}</span>  takes z as input. We will consider stand-alone executions, hence z will always be of the form  <span class="math">1^{\\lambda}</span> , for  <span class="math">\\lambda \\in \\mathbb{N}</span> . For simplicity, to denote this random variable ensemble we will use  <span class="math">\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,t,n}</span> . By  <span class="math">\\text{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span>  we denote the concatenation of the views of all parties. The probability space where these variables are defined depends on the coins of all honest parties,  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span> .</p>

    <p class="text-gray-300">Next, we consider the complications in the modeling due to the analysis of Bitcoin in the concrete security setting. Both in [31] and [47] a modified version of the standard simulation-based paradigm of [19] is followed, where there exist both a malicious environment and a malicious adversary. In addition, the SoW scheme (called PoW in [31, 47]) is modeled in a non black-box way using a random oracle (RO), and the computational power of the adversary is then bounded by limiting the number of queries it can make to the RO per round. Since in this work the SoW scheme is modeled in a black-box way, an alternative approach to bound the adversary's power is needed.</p>

    <p class="text-gray-300">A na&iuml;ve first approach is to only bound the computational power of  <span class="math">\\mathcal{A}</span> . Unfortunately this will not work for several reasons. Firstly, nothing stops the environment from aiding the adversary, i.e., computing signatures, and then communicating with it through their communication channel or some other subliminal channel. Secondly, even if we bound the <em>total</em> number of steps of  <span class="math">\\mathcal{A}</span> , it is not clear how to bound the steps it is taking per round in the model of [19], which we build on. Lastly, another issue arising is that if the adversary is able to send, say,  <span class="math">\\theta</span>  messages in each round, it can force each</p>

    <p class="text-gray-300">honest party to take  <span class="math">\\theta \\cdot t_{\\text{ver}}</span>  extra steps per round. If we don't bound  <span class="math">\\theta</span> , then the adversary will be able to launch a DOS attack and spend all the resources the honest parties have<sup>5</sup>.</p>

    <p class="text-gray-300">In order to capture these considerations we are going to define a predicate on executions and prove our properties in disjunction with this predicate, i.e., either the property holds or the execution is not good.</p>

    <p class="text-gray-300"><strong>Definition 11.</strong> Let  <span class="math">(t_A, \\theta)</span> -good be a predicate defined on executions in the hybrid setting described above. Then E is  <span class="math">(t_A, \\theta)</span> -good, where E is one such execution, if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the total number of steps taken by  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  per round is no more than  <span class="math">t_{\\mathcal{A}}</span> ;</li>
      <li>the adversary sends at most  <span class="math">\\theta</span>  messages per round.</li>
    </ul>

    <p class="text-gray-300">Finally, we assume the existence of a <em>common reference string</em> (CRS), that becomes available to all parties at the start of the execution. This is also implicitly assumed in previous models, where either parties have access to a special &quot;genesis&quot; block at the beginning of the execution [47], or they do not have access to the RO before the beginning of the execution [31].</p>

    <p class="text-gray-300"><strong>Definition 12.</strong> Given a predicate Q and bounds  <span class="math">t_{\\mathcal{A}}, \\theta, t, n \\in \\mathbb{N}</span> , with t &lt; n, we say that protocol  <span class="math">\\Pi</span>  satisfies property Q for n parties assuming the number of corruptions is bounded by t, provided that for all PPT  <span class="math">\\mathcal{Z}, \\mathcal{A}</span> , the probability that  <span class="math">Q(\\text{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n})</span>  is false and the execution is  <span class="math">(t_{\\mathcal{A}}, \\theta)</span> -good is negligible in  <span class="math">\\lambda</span> .</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Public Transaction Ledger from Signatures of Work</h3>

    <p class="text-gray-300">Next, we take a reduction approach to the underlying cryptographic primitive&mdash;SoW, as defined in Section 3&mdash;to prove the security of the Bitcoin backbone protocol [31]. We start with a description of the protocol based on SoW, and then continue with the security proof.</p>

      <h4 id="sec-4.2.1" class="text-lg font-semibold mt-6">4.2.1 The Bitcoin backbone protocol.</h4>

    <p class="text-gray-300">The Bitcoin backbone protocol [31], parameterized by functions  <span class="math">V(\\cdot), R(\\cdot), I(\\cdot)</span> , is an abstraction of the Bitcoin protocol. First, we introduce some notation needed to understand the description of the algorithms, and then cast the protocol making use of our SoW primitive.</p>

    <p class="text-gray-300">We will use the terms block and chain to refer to tuples of the form  <span class="math">\\langle s, x, \\sigma \\rangle</span>  and sequences of such tuples, respectively. The rightmost (resp. leftmost) block of chain  <span class="math">\\mathcal{C}</span>  is denoted by  <span class="math">head(\\mathcal{C})</span>  (resp.  <span class="math">tail(\\mathcal{C})</span> ). Each block contains a seed, data, and a signature denoted by  <span class="math">s, x, \\sigma</span> , respectively. As mentioned, all parties have access to a CRS at the beginning of the execution that contains: the public parameter pp of the SoW scheme, a verification key vk generated by KeyGen(pp), and the key k of the hash functions H, G used later. We will refer to  <span class="math">\\langle 0^{\\lambda}, pp||vk||k, 0^{\\lambda} \\rangle</span>  as the genesis block  <span class="math">genetic B_{Gen}</span> . A chain  <span class="math">\\mathcal{C} = B_1 \\dots B_m</span>  is valid with respect to the CRS if and only if (i)  <span class="math">genetic B_1</span>  is the genesis block, (ii) for any two consecutive blocks  <span class="math">genetic B_1</span>  is the late genesis block, besides  <span class="math">genetic B_2</span>  contains a valid SoW, i.e.,  <span class="math">genetic B_3</span>  is the genesis block  <span class="math">genetic B_4</span>  (iii) each block, besides  <span class="math">genetic B_4</span>  contains a valid SoW, i.e.,  <span class="math">genetic B_4</span>  is the genesis block  <span class="math">genetic B_4</span>  and denote it by  <span class="math">genetic B_4</span>  is the genesis block  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in  <span class="math">genetic B_4</span>  in</p>

    <p class="text-gray-300">At each round, each party chooses the longest valid chain amongst the ones it has received and tries to extend it by computing (mining) another valid block. If it succeeds, it diffuses the new block to the network. In more detail, each party will run the Sign procedure, with the message parameter being determined by the input contribution function  <span class="math">I(\\cdot)</span> , and the key parameter being the hash of the</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>This problem is extensively discussed in [3], Section 3.4.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>The adversary cannot use the running time of honest parties that it has corrupted; it is activated instead of them during their turn. Also, note that it is possible to compute this number by counting the number of configurations that  <span class="math">\\mathcal{A}</span>  or  <span class="math">\\mathcal{Z}</span>  are activated per round.</p>

    <p class="text-gray-300">last block. We assume that the hardness parameter h is fixed for all executions. Finally, if the party is queried by the environment, it outputs R(C) where C is the chain selected by the party; the chain reading function R(&middot;) interprets C differently depending on the higher-level application running on top of the backbone protocol. Each honest party runs for at most t<sup>H</sup> steps per round. We summarize the modifications with respect to the original <a href="#page-37-3">[31]</a> protocol: In Algorithm <a href="#page-15-0">1</a> (signature of work function) the Sign function of the underlying SoW scheme is invoked for a limited number of steps so that the total number of steps of the invoking party does not exceed the t<sup>H</sup> bound per round; in Algorithm <a href="#page-15-1">2</a> (chain validation predicate) the Verify predicate is replaced with a call to the Verify algorithm of the SoW scheme; and in Algorithm <a href="#page-16-1">3</a> (backbone protocol) we assume that the honest parties start the execution with a &quot;genesis&quot; block. We leave Algorithm <a href="#page-16-2">4</a> intact.</p>

    <p class="text-gray-300">Algorithm 1 The signature of work function, parameterized by pp, h and hash functions H(&middot;), G(&middot;). The input is (x, C).</p>

    <pre><code class="language-text">1: function sow(x, C)
2: s &larr; H(head(C))
3: &sigma; &larr; Sign(pp, s, x, h) . Run the prover of the SoW scheme.
4: B &larr; &epsilon;
5: if &sigma; 6= &perp; then
6: B &larr; hs, x, &sigma;i
7: end if
8: C &larr; CB . Extend chain
9: return C
10: end function
</code></pre>

    <p class="text-gray-300">Algorithm 2 The chain validation predicate, parameterized by pp, h, BGen, the hash functions G(&middot;), H(&middot;), and the input validation predicate V (&middot;). The input is C.</p>

    <pre><code class="language-text">1: function validate(C)
2: b &larr; V(xC) &and; (tail(C) = BGen) . xC describes the contents of chain C.
3: if b = True then . The chain is non-empty and meaningful w.r.t. V (&middot;)
4: s
       0 &larr; H(head(C))
5: while (C 6= BGen) &and; (b = True) do
6: hs, x, &sigma;i &larr; head(C)
7: if Verify(pp, s, x, h, &sigma;) &and; (H(head(C)) = s
                                  0
                                   ) then
8: s
           0 &larr; s . Retain hash value
9: C &larr; Cd1 . Remove the head from C
10: else
11: b &larr; False
12: end if
13: end while
14: end if
15: return (b)
16: end function
</code></pre>

    <p class="text-gray-300">In order to turn the backbone protocol into a protocol realizing a public transaction ledger suitable definitions were given for functions V(&middot;), R(&middot;),I(&middot;) in <a href="#page-37-3">[31]</a>. We change these definitions slightly as shown in Table <a href="#page-17-1">1,</a> to ensure two things: Firstly, that the data contained in the hash chain is encoded with <strong>Algorithm 3</strong> The Bitcoin backbone protocol, parameterized by the <em>input contribution function</em>  <span class="math">I(\\cdot)</span>  and the <em>chain reading function</em>  <span class="math">R(\\cdot)</span> .</p>

    <pre><code class="language-text">1: \\mathcal{C} \\leftarrow B_{\\mathsf{Gen}}
                                                                                                                               \\triangleright Initialize \\mathcal{C} to the genesis block.
 2: st \\leftarrow \\varepsilon
 3: round \\leftarrow 0
 4: while True do
             \\tilde{\\mathcal{C}} \\leftarrow \\mathsf{maxvalid}(\\mathcal{C}, \\mathsf{any\\ chain\\ } \\mathcal{C}&#x27; \\mathsf{\\ found\\ in\\ Receive}())
             \\langle st, x \\rangle \\leftarrow I(st, \\tilde{\\mathcal{C}}, round, Input(), Receive())
                                                                                                                                                \\triangleright Determine the x-value.
 6:
             \\mathcal{C}_{\\mathsf{new}} \\leftarrow \\mathsf{sow}(x, \\tilde{\\mathcal{C}})
 7:
             if C \\neq C_{new} then
 8:
                    \\mathcal{C} \\leftarrow \\mathcal{C}_{\\mathsf{new}}
 9:
                    Broadcast(\\mathcal{C})
10:
             end if
11:
12:
             round \\leftarrow round + 1
             if Input() contains Read then
13:
                     write R(\\mathbf{x}_{\\mathcal{C}}) to OUTPUT()
14:
             end if
15:
16: end while
</code></pre>

    <p class="text-gray-300"><strong>Algorithm 4</strong> The function that finds the &quot;best&quot; chain, parameterized by function  <span class="math">\\max(\\cdot)</span> . The input is  <span class="math">\\{C_1, \\ldots, C_k\\}</span> .</p>

    <pre><code class="language-text">1: function \\max \\operatorname{valid}(\\mathcal{C}_1, \\dots, \\mathcal{C}_k)

2: temp \\leftarrow \\varepsilon

3: \\mathbf{for} \\ i = 1 \\ \\operatorname{to} \\ k \\ \\mathbf{do}

4: \\mathbf{if} \\ \\operatorname{validate}(\\mathcal{C}_i) \\ \\mathbf{then}

5: temp \\leftarrow \\max(\\mathcal{C}, temp)

6: \\mathbf{end} \\ \\mathbf{if}

7: \\mathbf{end} \\ \\mathbf{for}

8: \\mathbf{return} \\ temp

9: \\mathbf{end} \\ \\mathbf{function}
</code></pre>

    <p class="text-gray-300">a suffix-free code; this is important to ensure that no collisions occur [10] as we show later. And, secondly, to ensure that any block created by an honest party contains sufficient entropy, thus the adversary will not be able to use blocks that it has precomputed to extend this block. We call the resulting protocol  <span class="math">\\Pi_{Pl}^{SoW}</span> .</p>

      <h4 id="sec-4.2.2" class="text-lg font-semibold mt-6">4.2.2 Security properties of the blockchain.</h4>

    <p class="text-gray-300">A number of desired basic properties for the blockchain were introduced in [31, 40, 47]. At a high level, the first property, called <em>common prefix</em>, has to do with the existence, as well as persistence in time, of a common prefix of blocks among the chains of honest players. Here we will consider a stronger variant of the property, presented in [47], which allows for the black-box proof of application-level properties (such as the <em>persistence</em> of transactions entered in a public transaction ledger built on top of the Bitcoin backbone).</p>

    <p class="text-gray-300">We will use  <span class="math">\\mathcal{C} \\leq \\mathcal{C}&#x27;</span>  to denote that some chain  <span class="math">\\mathcal{C}</span>  is a prefix of some other chain  <span class="math">\\mathcal{C}&#x27;</span> , and  <span class="math">\\mathcal{C}^{\\lceil k \\rceil}</span>  to denote the chain resulting from removing the last k blocks of  <span class="math">\\mathcal{C}</span> . We will call a block honest, if it was</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Content validation pre-</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">V(\\cdot)</span> is true if its input <span class="math">\\langle x_1, \\ldots, x_m \\rangle</span> is a valid ledger, i.e., it is in <span class="math">\\mathcal{L}</span> ,</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">dicate <span class="math">V(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">and each <span class="math">x_i</span> starts with a neutral transaction of the form <span class="math">r  i </span> , where</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r</span> is a string of length <span class="math">\\log  K </span> and <span class="math">i</span> is the &quot;height&quot; of the respective</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">block.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Chain reading function <span class="math">R(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R(\\cdot)</span> returns the contents of the chain if they constitute a valid ledger,</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">otherwise it is undefined.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Input contribution function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">I(\\cdot)</span> returns the largest subsequence of transactions in the input and</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">I(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">receive registers that constitute a valid ledger, with respect to the</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">contents of the chain $ C $ the party already has, preceded by a neutral</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">transaction of the form <span class="math">KeyGen(pp)   \\mathcal{C} </span> .</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: The instantiation of functions  <span class="math">I(\\cdot), V(\\cdot), R(\\cdot)</span>  for protocol  <span class="math">\\Pi^{\\texttt{SoW}}_{\\texttt{PL}}</span> .</p>

    <p class="text-gray-300">diffused for the first time in the execution by some honest party, and adversarial otherwise.</p>

    <p class="text-gray-300"><strong>Definition 13</strong> ((Strong) Common Prefix). The strong common prefix property  <span class="math">Q_{cp}</span>  with parameter  <span class="math">k \\in \\mathbb{N}</span>  states that the chains  <span class="math">C_1, C_2</span>  reported by two, not necessarily distinct honest parties  <span class="math">P_1, P_2</span> , at rounds  <span class="math">r_1, r_2</span>  in VIEW <span class="math">_{\\Pi, A, Z}^{t, n}</span> , with  <span class="math">r_1 \\leq r_2</span> , satisfy  <span class="math">C_1^{\\lceil k} \\leq C_2</span> .</p>

    <p class="text-gray-300">The next property relates to the proportion of honest blocks in any portion of some honest player's chain.</p>

    <p class="text-gray-300"><strong>Definition 14</strong> (Chain Quality). The <em>chain quality property</em>  <span class="math">Q_{cq}</span>  with parameters  <span class="math">\\mu \\in \\mathbb{R}</span>  and  <span class="math">k \\in \\mathbb{N}</span>  states that for any honest party P with chain C in  <span class="math">VIEW_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span>  it holds that for any k consecutive blocks of C the ratio of adversarial blocks is at most  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300">Further, in the derivations in [31] an important lemma was established relating to the rate at which the chains of honest players were increasing as the Bitcoin backbone protocol was run. This was explicitly considered in [40] as a property under the name <em>chain growth</em>.</p>

    <p class="text-gray-300"><strong>Definition 15</strong> (Chain Growth). The chain growth property  <span class="math">Q_{cg}</span>  with parameters  <span class="math">\\tau \\in \\mathcal{R}</span>  (the &quot;chain speed&quot; coefficient) and  <span class="math">s, r_0 \\in \\mathbb{N}</span>  states that for any round  <span class="math">r &gt; r_0</span> , where honest party P has chain  <span class="math">C_1</span>  at round r and chain  <span class="math">C_2</span>  at round r + s in  <span class="math">VIEW_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n}</span> , it holds that  <span class="math">|C_2| - |C_1| \\ge \\tau \\cdot s</span> .</p>

      <h4 id="sec-4.2.3" class="text-lg font-semibold mt-6">4.2.3 Security proof.</h4>

    <p class="text-gray-300">We now prove that  <span class="math">\\Pi_{PL}^{SoW}</span>  implements a robust public transaction ledger (Definition 2), assuming the underlying SoW scheme satisfies Assumption 1 for appropriate parameters, related to the running time of honest parties and the adversary. First, we formalize this relation.</p>

    <p class="text-gray-300">Let  <span class="math">t_{\\rm bb}</span>  (bb for backbone) be an upper bound on the number of steps needed to run the code of an honest party in one round, besides the Sign and Verify calls. By carefully analyzing the backbone protocol one can extract an upper bound on this value.<sup>7</sup> To aid our presentation, we will use  <span class="math">t&#x27;_{\\mathcal{A}}</span>  and  <span class="math">t&#x27;_{\\mathcal{H}}</span>  to denote: (i) the time needed by a RAM machine to simulate one round in the execution of the Bitcoin protocol, without taking into account calls made to the Sign routine by the honest parties, and (ii) the minimum number of steps that an honest party takes running the Sign routine per round, respectively.</p>

    <p class="text-gray-300"><span class="math">$t&#x27;_{\\mathcal{A}} = t_{\\mathcal{A}} + n \\cdot t_{\\mathsf{bb}} + \\theta t_{\\mathsf{ver}}</span>$
and  <span class="math">t&#x27;_{\\mathcal{H}} = t_{\\mathcal{H}} - t_{\\mathsf{bb}} - \\theta t_{\\mathsf{ver}}</span></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>Note that  <span class="math">t_{bb}</span>  depends on the running time of three external functions:  <span class="math">V(\\cdot), I(\\cdot)</span>  and  <span class="math">R(\\cdot)</span> . For example, in Bitcoin these functions include the verification of digital signatures, which would require doing modular exponentiations. In any case  <span class="math">t_{bb}</span>  is at least linear in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">It holds that at least n-t (non-corrupted) parties will run the Sign routine for at least  <span class="math">t&#x27;_{\\mathcal{H}}</span>  steps at every round.</p>

    <p class="text-gray-300">In previous works [31, 33, 47], the security assumptions regarding the computational power of the parties participating in the protocol were twofold: (1) The total running time of honest parties per round should exceed that of the adversary, and (2) the rate at which parties produce blocks at each round should be bounded. More realistically, in our approach the running time of the adversary and the running time of honest parties do not have the same quality, as the adversary may use a superior signing algorithm. To take this into account, we additionally need to assume that the efficiency of the adversarial signing algorithm, i.e.,  <span class="math">\\beta</span> , is close to that of the honest parties. Finally, note that if SoW is close to optimal, i.e.,  <span class="math">\\alpha(h) \\approx \\beta t_{\\mathcal{H}}&#x27;</span> , and the block generation rate is a lot less than 1, our assumption holds as long as the honest parties control the majority of the computational power.</p>

    <p class="text-gray-300">We now state the computational power assumption formally. The second and the third conditions are similar to the ones already found in previous works, while the first one is the new condition we introduce regarding the underlying computational primitive.</p>

    <p class="text-gray-300"><strong>Assumption 2</strong> (Computational Power Assumption). There exist  <span class="math">\\delta_{SoW}</span> ,  <span class="math">\\delta_{Steps}</span> ,  <span class="math">\\delta \\in (0,1)</span> , such that for sufficiently large  <span class="math">\\lambda \\in \\mathbb{N}</span> , there exists an  <span class="math">h \\in HP</span> , such that:</p>

    <pre><code class="language-text">- \\alpha(h) \\ge (1 - \\delta_{SoW})\\beta t_{\\mathcal{H}}&#x27; &gt; \\text{negl}(\\lambda)
                                                                (signatures generation rate gap)
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">$(n-t)t&#x27;_{\\mathcal{H}}(1-\\delta_{\\mathsf{Steps}}) \\ge t&#x27;_{\\mathcal{A}}</span>$
(steps gap)</li>
    </ul>

    <p class="text-gray-300"><span class="math">$- (n-t)t&#x27;_{\\mathcal{H}}(1-\\delta_{\\mathsf{Steps}}) \\geq t&#x27;_{\\mathcal{A}} \\qquad (steps \\ gap)</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\frac{\\delta_{\\mathsf{Steps}}-\\delta_{\\mathsf{SoW}}}{2} \\geq \\delta &gt; \\beta(h)(t&#x27;_{\\mathcal{A}}+nt_{\\mathcal{H}}) \\qquad (bounded \\ block \\ generation \\ rate)</span>$</p>

    <p class="text-gray-300">From now on, we will assume that the hardness parameter used in our protocols, is one satisfying the above conditions.</p>

    <p class="text-gray-300">Remark 3. The better the adversarial signing algorithm may be compared to the honest one, the closer  <span class="math">\\delta_{\\mathsf{SoW}}</span>  is to 0, while the closer the number of adversarial steps  <span class="math">t_{\\mathcal{A}}&#x27;</span>  are to that of the honest parties, the closer  <span class="math">\\delta_{\\mathsf{Steps}}</span>  is to 0. Assumption 2 implies, in a quantitative manner, that the better the adversarial signing algorithm, the smaller the computational power of the adversary we can tolerate.</p>

    <p class="text-gray-300">We introduce some additional notation. For each round j, we define the Boolean random variables  <span class="math">X_i</span>  and  <span class="math">Y_j</span>  as follows. Let  <span class="math">X_j = 1</span>  if and only if j was a successful round, i.e., at least one honest party computed a SoW at round j, and let  <span class="math">Y_j = 1</span>  if and only if j was a uniquely successful round, i.e., exactly one honest party computed a SoW at round j. With respect to a set of rounds S, let  <span class="math">X(S) = \\sum_{j \\in S} X_j</span>  and define Y(S) similarly. Moreover, with respect to some block B computed by an honest party P at some round r, let  <span class="math">Z_B(S)</span>  denote the number of distinct blocks broadcast by the adversary during S that have B as their ancestor. Define  <span class="math">X_B(S)</span>  similarly.</p>

    <p class="text-gray-300">Next, we focus on the hash functions used by Bitcoin, and the necessary security assumptions to avoid cycles in the blockchains. First, note that in the actual implementation of Bitcoin an unkeyed hash function is used, namely, a double invocation of SHA-256. In previous analyses of the protocol this was modeled as a random oracle. We choose to model it in a strictly weaker way, as a keyed hash function family:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{H} = \\{H_k : \\{0,1\\}^{\\log|K| + \\lambda + \\log|S|} \\to \\{0,1\\}^{\\log|K|}\\}_{k \\in K&#x27;}.</span>$</p>

    <p class="text-gray-300">that is collision resistant (Definition 1); the CRS we have already assumed will contain the key of our hash function. Moreover, as depicted in Figure 3, the protocol makes use of another hash function Gto compress the input x of each block, which may be of arbitrary size. In our analysis we will require Gto be collision resistant. It is well known (see, e.g., [21, 10]) that given a fixed-length collision-resistant hash function family, we can construct an arbitrary-length collision-resistant hash function family. To aid readability, we will sometimes omit the keys of both functions (as we already do in the description of the protocol). Furthermore, observe that the hash structure of any blockchain (depicted in Figure 3) is similar to the Merkle-Damgaard transform [21]:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{MD}_k(IV,(x_i)_{i\\in[m]}): z=IV; \\text{ for } i=1 \\text{ to } m \\text{ do } z=H_k(z,x_i); \\text{ return } z,</span>$</p>

    <p class="text-gray-300">where the fixed-length hash function family used is always assumed to be  <span class="math">\\mathcal{H}</span> . To show that the adversary cannot find distinct chains with the same hash, we are going to take advantage of the following property of the MD transform.</p>

    <p class="text-gray-300">Fact 1. For any non-empty valid chain  <span class="math">C = B_1, \\ldots, B_k</span> , where  <span class="math">B_i = \\langle s_i, x_i, \\sigma_i \\rangle</span> , it holds that for any  <span class="math">j \\in [k]</span> :  <span class="math">H_k(\\text{head}(C)) = \\text{MD}_k(H_k(B_j), ((G_k(x_i), \\sigma_i))_{i \\in \\{j+1, \\ldots, k\\}})</span> .</p>

    <p class="text-gray-300">    <img src="_page_19_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: The hash structure of the blocks in the Bitcoin protocol.</p>

    <p class="text-gray-300"><strong>Lemma 16.</strong> The probability that any PPT RAM A can find two distinct valid chains  <span class="math">C_1, C_2</span>  such that  <span class="math">H(C_1) = H(C_2)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">C_1 = B_{\\text{Gen}}, B_1, \\ldots, B_{[|C_1|]}, C_2 = B_{\\text{Gen}}, B&#x27;_1, \\ldots, B&#x27;_{[|C_2|]}, m_1 = ((G(x_i), \\sigma_i))_{i \\in [|C_1|]}</span>  and  <span class="math">m_2 = ((G(x&#x27;_i), \\sigma&#x27;_i))_{i \\in [|C_2|]}</span> . For the sake of contradiction, assume that the lemma does not hold and there exists an adversary A that can find valid chains  <span class="math">C_1</span> ,  <span class="math">C_2</span>  such that  <span class="math">H(C_1) = H(C_2)</span> , with non-negligible probability. By Fact 1, this implies that  <span class="math">MD(H(B_{\\text{Gen}}), m_1) = MD(H(B_{\\text{Gen}}), m_2)</span> .</p>

    <p class="text-gray-300">We will construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that breaks the collision resistance of H also with non-negligible probability. We take two cases. In the first case,  <span class="math">|\\mathcal{C}_1| \\neq |\\mathcal{C}_2|</span> . Then, since the height of the chain is included in a fixed position in  <span class="math">x_{|\\mathcal{C}_1|}, x&#x27;_{|\\mathcal{C}_2|}</span>  (cf. Table 1), it follows that  <span class="math">x_{|\\mathcal{C}_1|} \\neq x&#x27;_{|\\mathcal{C}_2|}</span>  and with overwhelming probability  <span class="math">G(x_{|\\mathcal{C}_1|}) \\neq G(x&#x27;_{|\\mathcal{C}_2|})</span> , which in turn implies that  <span class="math">B_{|\\mathcal{C}_1|} \\neq B&#x27;_{|\\mathcal{C}_2|}</span> . Since  <span class="math">H(\\text{head}(\\mathcal{C}_1)) = H(\\text{head}(\\mathcal{C}_2))</span> , it follows that a collision in H has been found. In the second case, where  <span class="math">|\\mathcal{C}_1| = |\\mathcal{C}_2|</span> , following the classical inductive argument for the MD transform, it can be shown that there exists  <span class="math">\\ell</span>  less or equal to  <span class="math">|\\mathcal{C}_1|</span> , such that  <span class="math">MD(H(\\text{Gen}), ((G(x_i), \\sigma_i))_{i \\in [\\ell]}) = MD(H(\\text{Gen}), ((G(x_i&#x27;), \\sigma_i&#x27;))_{i \\in [\\ell]})</span>  and  <span class="math">(G(x_\\ell), \\sigma_\\ell) \\neq (G(x_\\ell&#x27;), \\sigma_\\ell&#x27;)</span> . The lemma follows.</p>

    <p class="text-gray-300">The following two properties<sup>8</sup>, introduced in [31], regarding the way blocks are connected are implied by Lemma 16.</p>

    <p class="text-gray-300"><strong>Definition 17.</strong> An insertion occurs when, given a chain  <span class="math">\\mathcal{C}</span>  with two consecutive blocks B and  <span class="math">B_0</span> , a block  <span class="math">B^*</span>  created after  <span class="math">B_0</span>  is such that  <span class="math">B, B^*</span> ,  <span class="math">B_0</span>  form three consecutive blocks of a valid chain. A copy occurs if the same block exists in two different positions.</p>

    <p class="text-gray-300">Corollary 18. Let  <span class="math">\\{H_k(\\cdot)\\}_{k\\in K}</span>  and  <span class="math">\\{G_k(\\cdot)\\}_{k\\in K}</span>  be collision-resistant hash functions. Then, no insertions and no copies occur with probability  <span class="math">1 - \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Next, we prove that the adversary cannot mine blocks that extend an honest block created recently at a very high rate with probability better than that of breaking the MU-TCMA property. For a summary of our notation we refer to Table 2.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>A third property, called &quot;prediction,&quot; also introduced in [31], is not needed in our proof as it is captured by the fact that SoW is MU-TCMA secure even in the presence of adversarial precomputation.</p>

    <p class="text-gray-300">&lambda;: security parametern: number of parties</p>

    <p class="text-gray-300"><span class="math">t_{\\mathcal{H}}</span> : number of steps per round per honest party  <span class="math">t_{\\mathcal{A}}</span> : total number of adversarial steps per round</p>

    <p class="text-gray-300"><span class="math">\\theta</span> : upper bound on the number of messages sent by the adversary per round</p>

    <p class="text-gray-300"><span class="math">\\beta:\\quad</span>  upper bound on SoW computation rate per step</p>

    <p class="text-gray-300"><span class="math">\\gamma</span> : lower bound on the rate of uniquely successful rounds</p>

    <p class="text-gray-300">f: lower bound on the rate of successful rounds</p>

    <p class="text-gray-300"><span class="math">\\delta</span> : advantage from the Computational Power Assumption (Assumption 2)</p>

    <p class="text-gray-300">k: number of blocks for the common-prefix property  <span class="math">\\ell</span> : number of blocks for the chain-quality property</p>

    <p class="text-gray-300">Table 2: The parameters in our analysis.</p>

    <p class="text-gray-300"><strong>Lemma 19.</strong> For any set of consecutive rounds S and for any party P, the probability that P mined some honest block B at some round  <span class="math">i \\in S</span>  and  <span class="math">Z_B(S) \\ge \\beta t&#x27;_A|S|</span> , is at most  <span class="math">\\epsilon(h, t&#x27;_A \\cdot |S|, n \\cdot |S|)</span> .</p>

    <p class="text-gray-300">Proof. W.l.o.g., assume that i is the first round of  <span class="math">S = \\{i&#x27; | i \\leq i&#x27; &lt; i + s\\}</span> , and let E be the event where in VIEW <span class="math">_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span>  the adversary has mined at least  <span class="math">\\beta t&#x27;_{\\mathcal{A}}s</span>  blocks until round i+s that descend some honest block B mined by party P at round i. For the sake of contradiction, assume that the lemma does not hold, and thus the probability that E holds is greater than  <span class="math">\\epsilon(h, t&#x27;_{\\mathcal{A}} \\cdot s, n \\cdot s)</span> . Using  <span class="math">\\mathcal{A}</span> , we will construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that wins the MU-TCMA game with probability greater than that.  <span class="math">\\mathcal{A}&#x27;</span>  is going to run internally  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span> , while at the same time perfectly simulating the view of honest parties using the signing oracle that he has in his disposal on the MU-TCMA game. This way, the view of  <span class="math">\\mathcal{A}, \\mathcal{Z}</span>  will be indistinguishable both in the real and the simulated runs, and thus the probability that E happens will be the same in both cases.</p>

    <p class="text-gray-300">We are going to describe the two stages of  <span class="math">\\mathcal{A}&#x27;</span>  separately, i.e. before and after obtaining vk. First,  <span class="math">\\mathcal{A}&#x27;_1</span>  creates the genesis block and sets the fixed length hash key and the SoW public parameters to be  <span class="math">\\Sigma</span>  and pp, respectively. Then, he perfectly simulates honest parties up to round i-1 and at the same time runs  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  in a black-box way. Finally, it outputs the contents of the registers of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  as variable st. He can do this since he has polynomial time on  <span class="math">\\lambda</span>  on his disposal. Note, that up until this point in the eyes of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  the simulated execution is indistinguishable compared to the real one.</p>

    <p class="text-gray-300">For the second stage,  <span class="math">\\mathcal{A}&#x27;_2</span> , is first going to use st to reset  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  to the same state that they were. We assume that this can be done efficiently, e.g., by having  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  read from the registers where st is stored whenever they perform some operation on their registers. Moreover, it is again going to simulate honest parties behavior, from round i until round i+s, but in a different way. Instead of running the Sign algorithm for each non-corrupted honest party at every round, it makes a query to the signing oracle  <span class="math">\\mathcal{S}</span>  with the respective parameters. Then, it checks if the honest party succeeded in making a signature in this round by comparing the number of steps needed to make this signature to the number of steps available to the party at this round. Hence,  <span class="math">\\mathcal{A}&#x27;_2</span>  has to do n queries to the signing oracle per round. The adversary can also send up to  <span class="math">\\theta</span>  messages per round to honest parties which they have to verify, thus inducing an additional  <span class="math">\\theta \\cdot t_{\\text{ver}}</span>  overhead in the simulation. Note that  <span class="math">\\mathcal{A}&#x27;_2</span>  has to run the verification procedure only once per message.</p>

    <p class="text-gray-300">Continuing with the description of  <span class="math">\\mathcal{A}&#x27;_2</span> , as shown in Figure 4, it takes as input a key vk generated from  <span class="math">\\mathsf{KeyGen}(pp)</span> . We should somehow relate vk to the blocks the internal adversary is going to produce. In our reduction, this is achieved by: (i) relating the block B that party P generates at round i with vk through the input contribution function  <span class="math">I(\\cdot)</span> , and (ii) by the fact that the seed of all blocks that have B as an ancestor is related to H(B). In more detail, at round i,  <span class="math">\\mathcal{A}&#x27;_2</span>  will use vk in the neutral transaction included in  <span class="math">I(\\cdot)</span>  for P; denote by  <span class="math">vk||x_0</span>  the output of I for P at this round. If</p>

    <p class="text-gray-300">P is successful at this round and mines a block  <span class="math">B = \\langle s_0, vk || x_0, \\sigma_0 \\rangle</span>  (this can be simulated using S), then any block  <span class="math">B&#x27; = \\langle s, x, \\sigma \\rangle</span>  descending B will be related to it as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} s &amp;= \\mathsf{MD}(H_\\Sigma(B), ((G_\\Sigma(x_i), \\sigma_i))_i) \\\\ &amp;= \\mathsf{MD}(H_\\Sigma(s, G_\\Sigma(vk||x_0), \\sigma_0), ((G_\\Sigma(x_i), \\sigma_i))_i) \\\\ &amp;\\stackrel{\\mathrm{def}}{=} f_{(s, \\{x_i, \\sigma_i\\}_i)}(\\Sigma, vk) \\end{split}</span>$</p>

    <p class="text-gray-300">for some  <span class="math">((x_i, \\sigma_i))_i</span>  due to Fact 1. Observe, that the seed of B' is a function of  <span class="math">\\Sigma</span>  and vk, as required by the MU-TCMA game. In fact the tampering function class we will consider is going to be exactly the set of all these functions f. More formally, let C be the set of sequences  <span class="math">((x_i, \\sigma_i))_i</span>  that correspond to a valid chain in the way described before. Then, the tampering function class we will be considering is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F} = \\{f_{s,a}\\}_{s \\in \\{0,1\\}^{\\lambda}, a \\in C}</span>$</p>

    <p class="text-gray-300">We show next, that  <span class="math">\\mathcal{F}</span>  is computationally unpredictable as required by our assumption regarding the signature scheme.</p>

    <p class="text-gray-300">Claim 1.  <span class="math">\\mathcal{F}</span>  is computationally unpredictable.</p>

    <p class="text-gray-300"><em>Proof.</em> For the sake of contradiction, assume that there exists a PPT adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  that breaks the computational unpredictability property of  <span class="math">\\mathcal{F}</span> . This implies that</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{pp \\leftarrow \\mathsf{PPub}(1^{\\lambda});\\\\ vk \\leftarrow \\mathsf{KeyGen}(pp);\\\\ \\Sigma \\leftarrow \\mathcal{U}_{\\lambda}:}} \\begin{bmatrix} (st,y) \\leftarrow \\mathcal{A}_{1}(\\Sigma, pp);\\\\ f \\leftarrow \\mathcal{A}_{2}(st, vk):\\\\ f \\in \\mathcal{F} \\land f(\\Sigma, vk) = y \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">is non-negligible. We are going to describe an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that uses  <span class="math">\\mathcal{A}</span>  to break the collision resistance property of H. Given  <span class="math">\\Sigma</span> ,  <span class="math">\\mathcal{A}&#x27;</span>  first runs  <span class="math">\\mathcal{A}_1(\\Sigma, pp)</span>  and obtains a prediction y and state st. Next,  <span class="math">\\mathcal{A}&#x27;</span>  randomly samples  <span class="math">vk_1, vk_2</span>  using KeyGen and runs  <span class="math">\\mathcal{A}_2</span>  twice on inputs  <span class="math">st, vk_1</span>  and  <span class="math">st, vk_2</span>  respectively. By an application of the splitting lemma we can show that with non-negligible probability  <span class="math">\\mathcal{A}_2</span>  will output (not necessarily different) functions  <span class="math">f_1, f_2</span>  such that  <span class="math">y = f_1(\\Sigma, vk_1) = f_2(\\Sigma, vk_2)</span> . As noted earlier, this corresponds to the hash of two chains, that due to the entropy of  <span class="math">vk_1, vk_2</span>  and the collision resistance of G start with different honestly mined blocks. Using similar techniques as in Lemma 16, we can show that  <span class="math">\\mathcal{A}&#x27;</span>  can find a collision in H using  <span class="math">f_1, f_2, vk_1, vk_2</span>  with non-negligible probability in  <span class="math">\\lambda</span> , which is a contradiction.</p>

    <p class="text-gray-300">Since  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  cannot distinguish between the bitcoin execution and the one we described above, E will occur with probability at least  <span class="math">\\epsilon(h, t&#x27;_{\\mathcal{A}}s, ns)</span> , i.e.  <span class="math">\\mathcal{A}</span>  will compute at least  <span class="math">\\beta t&#x27;_{\\mathcal{A}}s</span>  blocks starting from round i and up to round i + s that descend B. Note, that these blocks are also valid signatures, whose keys are of the form  <span class="math">f(\\Sigma, vk)</span> , for (possibly different) f's. Moreover, the event that the adversary outputs different  <span class="math">f_i</span> ,  <span class="math">f_j</span>  such that  <span class="math">f_i(\\Sigma, vk) = f_j(\\Sigma, vk)</span> , corresponds to finding chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  such that  <span class="math">H(\\mathcal{C}_1) = H(\\mathcal{C}_2)</span> . By Lemma 16, this happens with negligible probability. Hence,  <span class="math">\\mathcal{A}&#x27;</span>  will win the MUTCMA game with respect to tampering function class  <span class="math">\\mathcal{F}</span>  with probability greater than  <span class="math">\\epsilon(h, t&#x27;_{\\mathcal{A}}s, ns)</span> , while being  <span class="math">s \\cdot (t_{\\mathcal{A}} + \\theta \\cdot t_{\\text{ver}} + t_{\\text{bb}} \\cdot n) = s \\cdot t&#x27;_{\\mathcal{A}}</span> -bounded and having made at most ns queries to the signing oracle, which is a contradiction to our initial assumption. A sketch of the reduction is given at Figure 4.</p>

    <p class="text-gray-300">Note that we can do exactly the same reduction without using the oracle to simulate the signing procedure of the honest parties. Then, the total running time of the second stage of  <span class="math">\\mathcal{A}&#x27;</span>  is on the worst</p>

    <p class="text-gray-300">    <img src="_page_22_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: The figure depicts a schematic of the reduction from the Bitcoin backbone to the MU-TCMA game of Lemma 19.</p>

    <p class="text-gray-300">case  <span class="math">s \\cdot (t_A + nt_H)</span> -bounded and hence the probability he can win is  <span class="math">\\epsilon(h, s \\cdot (t_A + nt_H), 0)</span> . Hence, we can derive the following bound on the total number of blocks produced by both honest and malicious parties during a certain number of rounds.</p>

    <p class="text-gray-300"><strong>Corollary 20.</strong> For any set of consecutive rounds S and for any party P, the probability that P mined some honest block B at some round  <span class="math">i \\in S</span>  and  <span class="math">Z_B(S) + X_B(S) \\ge \\beta(t_A + nt_H) \\cdot |S|</span>  is less than  <span class="math">\\epsilon(h, |S| \\cdot (t_A + nt_H), 0)</span> .</p>

    <p class="text-gray-300">Next, we prove lower bounds on the rate of successful and uniquely successful rounds. Our proof crucially depends on the runtime independence property of the SoW scheme. More specifically, the property implies that for some set of rounds the sum of the Bernoulli random variables of the event that a round is uniquely successful, concentrate around the mean. Which in turn, implies that we can lower-bound the rate of uniquely successful rounds with good probability.</p>

    <p class="text-gray-300"><strong>Lemma 21.</strong> Let  <span class="math">\\gamma = (n-t) \\cdot \\alpha(h) \\cdot (1-\\beta t_{\\mathcal{H}})^{n-1}</span> ,  <span class="math">f = (1-(1-\\alpha(h))^{n-t})</span> . For any set of consecutive rounds S, with  <span class="math">|S| \\geq \\frac{\\lambda}{\\gamma \\delta^2}</span> , the following two events occur with negligible probability in  <span class="math">\\lambda</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The number of uniquely successful rounds in S is less or equal to  <span class="math">(1 \\frac{\\delta}{4})\\gamma \\cdot |S|</span> ;</li>
      <li>the number of successful rounds in S is less or equal to  <span class="math">(1 \\frac{\\delta}{4})f \\cdot |S|</span> .</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> For some fixed execution we will denote by the array  <span class="math">\\mathbf{T}_{S\\times n}=(t_{i,j})\\in\\mathbb{N}^{|S|\\times n}</span>  the number of steps each honest party takes running the Sign routine, for each round in the set S. It holds that at most t elements of each column are zero, i.e. corrupted, and the rest are lower bounded by  <span class="math">t_{\\mathcal{H}}</span>  and upper bounded by  <span class="math">t_{\\mathcal{H}}</span> . W.l.o.g let  <span class="math">S=\\{1,\\ldots,s\\}</span> .</p>

    <p class="text-gray-300">Since this lemma talks about the steps taken by the Sign function, we are going to use the almost independent runtimes property of the SoW scheme, and do all the analysis on the independent random variable defined by this property. For the rest of this proof, unless explicitly stated, assume that the Steps<sub>Sign</sub>(pp, vk, m, h) random variable refers to its idealized independent version. We first buildup some notation to help in our analysis. For  <span class="math">pp \\in PP</span> , arrays  <span class="math">(vk_{i,j}) \\in K^{s \\times n}, (msg_{i,j}) \\in M^{s \\times n}</span>  and for  <span class="math">h \\in \\mathbb{N}</span>  let:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>random variable  <span class="math">P_{i,j} = 1</span>  if  <span class="math">\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_{i,j}, msg_{i,j}, h) \\leq t_{i,j}</span> , and 0 otherwise;</li>
      <li>random variable  <span class="math">Y_i = 1</span>  if  <span class="math">\\sum_{j=1}^n P_{i,j} = 1</span>  and 0 otherwise.</li>
      <li>random variable  <span class="math">X_i = 1</span>  if  <span class="math">\\sum_{j=1}^n P_{i,j} \\ge 1</span> , and 0 otherwise.</li>
      <li>random variable  <span class="math">Y = \\sum_{i \\in [s]} Y_i, X = \\sum_{i \\in [s]} X_i</span> .</li>
    </ul>

    <p class="text-gray-300">It easily follows from the Successful property that Pr[Pi,j = 1] &ge; &alpha;(h). Moreover, it holds that Pr[Pi,j = 1] &le; &beta;tH. Otherwise, the honest solving algorithm would produce signatures with a rate bigger than &beta;, which contradicts the MU-TCMA property. Next, we show that the random variables we have defined are mutually independent.</p>

    <p class="text-gray-300">Claim 2. The random variable families (Pi,j )i&isin;[s],j&isin;[n] , (Yi)i&isin;[s] , (Xi)i&isin;[s] are mutually independent.</p>

    <p class="text-gray-300">Proof. First, notice that the runtime independence of the scheme implies independence of (Pi,j ). We will show this for two random variables and the extension to m variables will be obvious. Let P1, P<sup>2</sup> &isin; (Pi,j )i,j and x1, x<sup>2</sup> &isin; {0, 1}, then</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Pr[P_1 = &amp;x_1 \\land P_2 = x_2] = \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) \\in S_1 \\land \\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) \\in S_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) = s_1 \\land \\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) = s_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) = s_1] \\cdot \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) = s_2] \\\\ &amp;= \\sum_{s_1 \\in S_1} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) = s_1] \\cdot \\sum_{s_2 \\in S_2} \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) = s_2] \\\\ &amp;= \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_1, m_1, h) \\in S_1] \\cdot \\Pr[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_2, m_2, h) \\in S_2] \\\\ &amp;= \\Pr[P_1 = x_1] \\cdot \\Pr[P_2 = x_2] \\end{split}</span>$</p>

    <p class="text-gray-300">where S1, S<sup>2</sup> are either [0, t] or (t, &infin;) depending on x1, x2, and pp, vk1, m1, vk2, m<sup>2</sup> are the parameters of the random processes. We use the independence property on the third line.</p>

    <p class="text-gray-300">Next, we prove the second point of the claim. Again, w.l.o.g we only show it for 2 random variables, Y1, Y<sup>2</sup> and the extension to m is obvious. Let y1, y<sup>2</sup> &isin; {0, 1}, then</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[Y_1 = y_1 \\land Y_2 = y_2] &amp;= \\Pr[\\sum_{j \\in [n]} P_{1,j} \\in S_1 \\land \\sum_{j \\in [n]} P_{2,j} \\in S_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\sum_{j \\in [n]} P_{1,j} = s_1 \\land \\sum_{j \\in [n]} P_{2,j} = s_2] \\\\ &amp;= \\sum_{(s_1, s_2) \\in S_1 \\times S_2} \\Pr[\\sum_{j \\in [n]} P_{1,j} = s_1] \\cdot \\Pr[\\sum_{j \\in [n]} P_{2,j} = s_2] \\\\ &amp;= \\sum_{s_1 \\in S_1} \\Pr[\\sum_{j \\in [n]} P_{1,j} = s_1] \\cdot \\sum_{s_2 \\in S_2} \\Pr[\\sum_{j \\in [n]} P_{2,j} = s_2] \\\\ &amp;= \\Pr[Y_1 = y_1] \\cdot \\Pr[Y_2 = y_2] \\end{split}</span>$</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">where S1, S<sup>2</sup> are {1} or {0, 2, 3, . . .} depending on y1, y2. The same follows for (Xi)i&isin;[s] . a</p>

    <p class="text-gray-300">Next, we lower bound the expected value of random variables (Yi)<sup>i</sup> and (Xi)<sup>i</sup></p>

    <p class="text-gray-300">Claim 3. It holds that for any i &isin; S : E[Y<sup>i</sup> ] &ge; &gamma; Proof of Claim.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbb{E}[Y_i] &amp;= \\Pr[Y_i = 1] = \\Pr[\\sum_{j \\in [n]} P_{i,j} = 1] \\\\ &amp;= \\sum_{j \\in [n]} \\Pr[P_{i,j} = 1] \\cdot \\prod_{m \\in [n] \\backslash \\{j\\}} \\Pr[P_{i,m} = 0] \\\\ &amp;\\geq \\sum_{j \\in [n]} \\alpha(h, t_{i,j}) \\prod_{m \\in [n] \\backslash \\{j\\}} (1 - \\Pr[P_{i,m} = 1]) \\\\ &amp;\\geq (n - t) \\cdot \\alpha(h) \\cdot (1 - \\beta t_{\\mathcal{H}})^{n - 1} = \\gamma \\end{split}</span>$</p>

    <p class="text-gray-300">The inequalities follow from the efficiency and MU-TCMA properties. Note, that in order for  <span class="math">\\mathbb{E}[Y_i]</span>  to be big,  <span class="math">\\alpha</span>  must be as big as possible, and  <span class="math">\\beta t_{\\mathcal{H}}</span>  must be as small as possible.</p>

    <p class="text-gray-300">Claim 4. It holds that for any  <span class="math">i \\in S : \\mathbb{E}[X_i] \\geq f</span></p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[X_i] = \\Pr[X_i = 1] = \\Pr[\\sum_{j \\in [n]} P_{i,j} \\ge 1]</span>$</p>

    <p class="text-gray-300"><span class="math">$= 1 - \\Pr[\\sum_{j \\in [n]} P_{i,j} = 0]</span>$</p>

    <p class="text-gray-300"><span class="math">$= 1 - \\prod_{m \\in [n]} \\Pr[P_{i,m} = 0]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\ge 1 - (1 - \\alpha(h))^{n-t} = f</span>$</p>

    <p class="text-gray-300">The inequality follows from the Successful property.</p>

    <p class="text-gray-300">By the linearity of expectation we have that  <span class="math">\\mathbb{E}[Y(S)] \\geq \\gamma |S|</span>  and  <span class="math">\\mathbb{E}[X(S)] \\geq f|S|</span> . Since all variables in  <span class="math">(Y_i)_i</span>  and  <span class="math">(X_i)_i</span>  are mutually independent and  <span class="math">\\delta \\in (0,1)</span> , by an application of the Chernoff Bound it holds that:</p>

    <p class="text-gray-300"><span class="math">\\dashv</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr[Y(S) \\le (1 - \\frac{\\delta}{4})\\gamma |S|] \\le \\Pr[Y(S) \\le (1 - \\frac{\\delta}{4})\\mathbb{E}[Y(S)]] \\le e^{-\\Omega(\\delta^2 \\gamma |S|)}</span>$</p>

    <p class="text-gray-300">Similarly, we can show that  <span class="math">\\Pr[X(S) \\leq (1 - \\frac{\\delta}{4})f|S|] \\leq e^{-\\Omega(\\delta^2 f|S|)}</span> .</p>

    <p class="text-gray-300">These results, with only negligible difference in probability, follow for the random variables in the real execution due to the almost runtime independence property, and the fact that Y and X are functions of the joint distribution referred by this property.</p>

    <p class="text-gray-300">Next, we show that  <span class="math">\\gamma</span> , the rate at which uniquely successful rounds occur, is lower bounded by  <span class="math">\\beta t&#x27;_{\\mathcal{A}}</span> , which corresponds to the rate at which the adversary is producing blocks.</p>

    <p class="text-gray-300">Lemma 22.  <span class="math">\\gamma \\geq (1+\\delta)\\beta t&#x27;_{\\mathcal{A}}</span></p>

    <p class="text-gray-300"><em>Proof.</em> It holds that:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\gamma = &amp; (n-t) \\cdot \\alpha(h) \\cdot (1-\\beta t_{\\mathcal{H}})^{n-1} \\geq (n-t) \\cdot \\alpha(h) \\cdot (1-\\beta t_{\\mathcal{H}} n) \\\\ \\geq &amp; (n-t) \\cdot (1-\\delta_{\\mathsf{SoW}}) \\cdot \\beta t_{\\mathcal{H}}&#x27; \\cdot (1-\\delta) \\geq \\frac{(1-\\delta_{\\mathsf{SoW}})(1-\\delta)}{(1-\\delta_{\\mathsf{Steps}})} \\cdot \\beta t_{\\mathcal{A}}&#x27; \\cdot \\geq (1+\\delta)\\beta t_{\\mathcal{A}}&#x27; \\end{split}</span>$</p>

    <p class="text-gray-300">where we have first used Bernouli's inequality, and then the three conditions from Assumption 2 (the Computational Power Assumption). The last inequality follows from the fact that  <span class="math">\\frac{\\delta_{\\mathsf{Steps}} - \\delta_{\\mathsf{SoW}}}{2} \\geq \\delta</span> .</p>

    <p class="text-gray-300">We are now ready to define the set of <em>typical executions</em> for this setting. This strategy was also followed in [31]. However, here we will need to adapt the definition due to the difficulties associated with performing a reduction to the security of the SoW scheme.</p>

    <p class="text-gray-300"><strong>Definition 23.</strong> [Typical execution] An execution is <em>typical</em> if and only if for any set S of consecutive rounds with  <span class="math">|S| \\ge \\frac{2\\lambda}{\\gamma\\delta^2}</span> , the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">Y(S) &gt; (1 \\frac{\\delta}{4})\\gamma |S|</span>  and  <span class="math">X(S) &gt; (1 \\frac{\\delta}{4})f|S|</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for any block B mined by an honest party at the some round in S,  <span class="math">Z_B(S) &lt; \\frac{\\gamma}{1+\\delta} \\cdot |S|</span>  and  <span class="math">Z_B(S) + X_B(S) &lt; \\beta(t_A + nt_H) \\cdot |S|</span> ; and</li>
    </ol></li>
      <li>3. no insertions and no copies occurred.</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 24.</strong> An execution is typical with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Proof. In order for an execution to not be typical, one of the three points of Definition 23 must not hold with non-negligible probability for some big enough set of rounds. Point 3 is implied by Corollary 18. For a specific set of rounds S, where  <span class="math">|S| \\geq \\frac{2\\lambda}{\\gamma\\delta^2}</span> , point 1 is implied by Lemma 21 with overwhelming probability in  <span class="math">\\lambda</span> . Regarding point 2, by an application of Lemma 19 for  <span class="math">t&#x27;_{\\mathcal{A}} = \\frac{\\gamma}{(1+\\delta)\\beta}</span> , it follows that  <span class="math">Z_B(S) &lt; \\frac{\\gamma}{1+\\delta} \\cdot |S|</span>  with probability  <span class="math">\\operatorname{negl}(\\beta \\cdot t&#x27;_{\\mathcal{A}} \\cdot |S|)</span> . Note, that this is w.l.o.g., due to Lemma 22, and that  <span class="math">\\beta t&#x27;_{\\mathcal{A}} \\cdot |S| \\geq \\beta \\frac{\\gamma}{(1+\\delta)\\beta} \\cdot \\frac{2\\lambda}{\\gamma\\delta^2} = \\Omega(\\lambda)</span> . Moreover, using the fact that  <span class="math">\\beta t_{\\mathcal{H}} \\geq \\alpha</span>  argued in Lemma 21 and due to the definition of  <span class="math">\\gamma</span> , it holds that  <span class="math">\\beta(t_{\\mathcal{A}} + nt_{\\mathcal{H}}) \\cdot \\frac{2\\lambda}{\\gamma\\delta^2} \\geq \\frac{2\\lambda}{\\delta} = \\Omega(\\lambda)</span> , which in turn implies that Corollary 20 is sufficient to imply point 2 with overwhelming probability in  <span class="math">\\lambda</span> . Hence, we can bound the probability that an execution is not typical by applying the union bound on the negation of these events over all sets of consecutive rounds of sufficiently large size, where the probability of each event occurring is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Next, taking advantage of the Computational Power Assumption (Assumption 2, we show that the rate at which the adversary computes blocks in a typical execution, is bounded by the rate at which uniquely successful rounds occur. With foresight, we note that this relation is going to be at the core of our security proof.</p>

    <p class="text-gray-300"><strong>Lemma 25.</strong> For any set S of at least  <span class="math">\\frac{2\\lambda}{\\gamma\\delta^2}</span>  rounds in a typical execution and for any block B mined by an honest party during S, it holds that  <span class="math">Z_B(S) &lt; (1 - \\frac{\\delta}{4})Y(S)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> It holds that:</p>

    <p class="text-gray-300"><span class="math">$Z_B(S) &lt; \\frac{1}{1+\\delta}\\gamma|S| \\le (1-\\frac{\\delta}{4})Y(S)</span>$</p>

    <p class="text-gray-300">where, the first inequality follows from the assumption that the execution is typical.</p>

    <p class="text-gray-300">We can now use the machinery built in [31] to prove the common prefix, chain quality and chain growth properties, and eventually Persistence and Liveness, with only minor changes. Using these properties we prove that the modified Bitcoin backbone protocol implements a robust transaction ledger.</p>

    <p class="text-gray-300"><strong>Higher level properties.</strong> The notion of a typical execution is at the core of the proof of security of Bitcoin in [31]. Here, we describe the minor changes one has to do after proving the typical execution theorem with respect to the analysis of [31], in order to prove the security of the protocol in our model. We only give brief proof sketches of lemmas or theorems from [31] that are exactly the same for our own setting.</p>

    <p class="text-gray-300"><strong>Lemma 26.</strong> (Chain-Growth Lemma). Suppose that at round r an honest party has a chain of length  <span class="math">\\ell</span> . Then, by round  <span class="math">s \\geq r</span> , every honest party has adopted a chain of length at least  <span class="math">\\ell + \\sum_{i=r}^{s-1} X_i</span> . <em>Proof.</em> The main idea of the proof of this lemma is that, after each successful round at least one honest party will have received a chain that is at least one block longer than the chain it had, and all parties pick only chains that are longer than the ones they had. <strong>Theorem 27.</strong> (Chain-Growth). In a typical execution the chain-growth property holds with parameters  <span class="math">\\tau = (1 - \\frac{\\delta}{4})f</span>  and  <span class="math">s \\ge \\frac{2\\lambda}{\\gamma\\delta^2}</span> . <em>Proof.</em> Let S be any set of at least s consecutive rounds. Then, since the execution is typical:  <span class="math">X(S) \\geq</span>  <span class="math">(1-\\frac{\\delta}{4})f\\cdot |S|\\geq \\tau\\cdot |S|</span> . By Lemma 26, each honest player's chain will have grown by that amount of blocks at the end of this round interval. Hence, the chain growth property follows. <strong>Lemma 28.</strong> Let B be some honest block or the genesis block in a typical execution. Any sequence of  <span class="math">k \\geq \\frac{2\\lambda}{\\gamma\\delta}</span>  consecutive blocks in some chain C, where the first block in the sequence directly descends B, have been computed in at least  <span class="math">k/\\delta</span>  rounds, starting from the round that B was computed. <em>Proof.</em> First, note that due to the Computational Power Assumption it holds that  <span class="math">\\beta(t_A + nt_H) &lt; \\delta</span> . For some  <span class="math">k \\geq \\frac{2\\lambda}{\\gamma\\delta}</span> , assume there is a set of rounds S', such that  <span class="math">|S&#x27;| &lt; k/\\delta</span> , and more than k blocks that descend block B have been computed. This implies that there is a set of rounds S, where  <span class="math">|S| \\geq \\frac{2\\lambda}{\\gamma \\delta^2}</span> , such that  <span class="math">X(S) + Z_B(S) \\ge k \\ge |S| \\delta &gt; |S| \\beta(t_A + nt_H)</span> . This contradicts the typicality of the execution, hence the lemma follows. <strong>Lemma 29.</strong> (Common-prefix Lemma). Assume a typical execution and consider two chains  <span class="math">\\mathcal{C}_1</span>  and  <span class="math">C_2</span>  such that  <span class="math">len(C_2) \\ge len(C_1)</span> . If  <span class="math">C_1</span>  is adopted by an honest party at round r, and  <span class="math">C_2</span>  is either adopted by an honest party or diffused at round r, then  <span class="math">C_1^{\\lceil k} \\leq C_2</span>  and  <span class="math">C_2^{\\lceil k} \\leq C_1</span> , for  <span class="math">k \\geq \\frac{2\\lambda}{\\sqrt{\\delta}}</span> . <em>Proof.</em> In Lemma 19, instead of bounding the number of blocks mined by the adversary in a set of rounds, we bound the number of blocks mined by the adversary with the additional condition that these blocks extend some specific honest block. If we also use the previous lemma, the proof is exactly the same as in [31]. Note, that all adversarial blocks in the matching between uniquely successful rounds and adversarial blocks are descendants of the last honest block in the common prefix of  <span class="math">\\mathcal{C}_1</span>  and  <span class="math">\\mathcal{C}_2</span> . <strong>Theorem 30.</strong> (Common-prefix). In a typical execution the common-prefix property holds with parameter  <span class="math">k \\geq \\frac{2\\lambda}{\\gamma\\delta}</span> . <em>Proof.</em> The main idea of the proof is that if there exists a deep enough fork between two chains, then the previously proved lemma cannot hold. Hence, the theorem follows. <strong>Theorem 31.</strong> (Chain-Quality). In a typical execution the chain-quality property holds with parameter  <span class="math">\\mu &lt; 1 - \\delta/4</span>  and  <span class="math">\\ell \\ge \\frac{2\\lambda}{\\gamma\\delta}</span> . <em>Proof.</em> The main idea of the proof is the following: a large enough number of consecutive blocks will have been mined in a set rounds that satisfies the properties of Definition 23. Hence, the number of blocks that belong to the adversary will be upper bounded, and all other blocks will have been mined</p>

    <p class="text-gray-300">Finally, the Persistence and Liveness properties follow from the three basic properties, albeit with different parameters than in [31].</p>

    <p class="text-gray-300">by honest parties.</p>

    <p class="text-gray-300"><strong>Lemma 32.</strong> (Persistence). It holds that  <span class="math">\\Pi_{\\mathsf{PL}}</span>  with  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span>  satisfies Persistence with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The main idea is that if persistence is violated, then the common-prefix property will also be violated. Hence, if the execution is typical the lemma follows.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Lemma 33.</strong> (Liveness). It holds that  <span class="math">\\Pi_{\\mathsf{PL}}</span>  with  <span class="math">u = \\frac{2k}{(1-\\frac{\\delta}{4})f}</span>  rounds and  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span>  satisfies Liveness with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The main idea here is that after u rounds at least 2k successful rounds will have occurred. Thus, by the chain growth lemma the chain of each honest party will have grown by 2k blocks, and by the chain quality property at least one of these blocks that is deep enough in the chain, is honest.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Theorem 34.</strong> Assuming the existence of a collision-resistant hash function and a SoW scheme that complies with Assumption 1 and 2, protocol  <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{SoW}}</span>  implements a robust public transaction ledger with parameters  <span class="math">u = \\frac{2k}{(1-\\frac{\\delta}{A})f}</span>  and  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span>  except with negligible probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">As a &quot;sanity check,&quot; we show in in the full version of the paper that the Bitcoin SoW scheme we outline there, is secure both in the random oracle and the  <span class="math">\\mathcal{F}_{TREE}</span>  model [47] according to our definitions; moreover, according to the security parameters we obtain for the scheme, the security guarantees we get from our black-box analysis of the Bitcoin backbone are similar to those proved in [31, 47].</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Consensus from Signatures of Work</h3>

    <p class="text-gray-300">In this section we show how to achieve consensus (a.k.a. Byzantine agreement [48, 42]) under exactly the same assumptions used for proving the security of the Bitcoin backbone protocol in Section 4.2.</p>

    <p class="text-gray-300">As mentioned earlier, in [31] consensus is achieved under the Honest Majority Assumption by using a proof-of-work construction in a <em>non-black-box</em> way, through a mining technique called &quot;2-for-1 PoWs.&quot; In more detail, the technique shows how miners can compute proofs of work for two different PoW schemes at the cost of one, while at the same time ensuring that their resources cannot be used in favor of one of the two schemes. However, the security proof for the resulting protocol crucially relies on the fact that each of the bits of the strings output by the random oracle are independently sampled, and thus goes again our stated goal of designing a SoW scheme that does not make such a strong independence assumption.</p>

    <p class="text-gray-300">Here we get rid of this requirement, by showing how blockchain-based consensus can be achieved by only using the security properties we have defined, directly, and without the extra non-black-box machinery used in [31]. This yields the first consensus protocol for honest majority reducible to a SoW primitive in the permissionless setting. The protocol is based on the Bitcoin backbone protocol, and formally specified by providing adequate definitions for the V, R, I functions presented in Section 4.2.</p>

    <p class="text-gray-300">First, we define some additional notation and terminology that will be used in the remainder of the section. We will use the terms &quot;input&quot; and &quot;vote&quot; interchangeably, referring to the parties' input to the consensus problem. We will use  <span class="math">header(\\langle s,x||vote,\\sigma\\rangle)</span>  to denote the &quot;compressed&quot; version of block  <span class="math">\\langle s,x||vote,\\sigma\\rangle^9</span> , equal to  <span class="math">\\langle s,G(x)||vote,\\sigma\\rangle</span> . Note that, as defined, the header of any block is of a fixed size. We also extend the definition of our hash function H as applied to headers of blocks. The hash of the header of some block B will be equal to the hash of B, i.e.,  <span class="math">H((header(B)) = H(B) = H(s,G(x)||vote,\\sigma)</span>  (note that the header of B provides all the information needed to calculate the hash of B).</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{9}&lt;/sup&gt;</span> We augment the block content x with a vote bit. This does not change the results of the analysis of the previous section.</p>

    <p class="text-gray-300">We now present a high-level description of the protocol. The basic idea is that during block mining, parties are going to include in their blocks not only their own votes, but also headers of other blocks that they have seen and that are not part of their chain. Then, after a predetermined number of rounds, the parties will count the votes &quot;referenced&quot; in a prefix of their chain, including the votes found in the headers of the blocks referenced. In this way, they can take advantage of the robust transaction ledger built in Section <a href="#page-14-0">4.2.</a> The Persistence property implies that the honest parties will all agree on which votes should be counted, while the Liveness property guarantees that the majority of the counted votes come from honest parties.</p>

    <p class="text-gray-300">The reader may wonder about the reason behind honest parties including in their blocks also headers of other blocks that they have seen but that are not part of their chain. It's because, as shown in <a href="#page-37-3">[31]</a>, the adversary is able to add more blocks in the main chain than his ratio of mining power (e.g., using a selfish-mining attack). This does not hold if the honest parties are able to also count off-chain blocks as our protocol does.</p>

    <p class="text-gray-300">Algorithm 5 The content validation predicate. The input is the contents of the blocks of some chain.</p>

    <pre><code class="language-text">1: function V(hx1, . . . , xmi)
2: D &larr; new AVL() . Create a new (empty) AVL tree.
3: D.add(H(BGen)) . Add the hash of the genesis block on the tree.
4: for i = 1, ..., m do
5: queue &larr; references(xi) . Add all block references in a queue.
6: hr||heighti &larr; queue.top()
7: if height 6= i then
8: return False . Check for the correct block &quot;height&quot;.
9: end if
10: while queue 6= &empty; do
11: hs, G(x)||vote, wi &larr; queue.top()
12: if ((D.exists(s)) &and; Verify(s, G(x)||vote, h, w)) then
13: D.add(H(hs, G(x)||vote, wi)) . Add new entry on the tree.
14: queue.pop()
15: else
16: return False . If not, the chain is invalid.
17: end if
18: end while
19: end for
20: return True
21: end function
</code></pre>

    <p class="text-gray-300">A main technical challenge is to be able to add the block references without making the honest parties' chains grow too large, and at the same time to ensure that the number of honest votes exceeds the adversarial ones. To overcome this challenge, we modify the Sign algorithm so that it is run on the header of the block, i.e., Sign(pp, s, G(x)||vote, h) and Verify(pp, s, G(x)||vote, h, &sigma;), respectively. This way we are able to verify the validity of a block as a SoW and determine the block's vote by only knowing its header. These are exactly the properties we need for the consensus application.</p>

    <p class="text-gray-300">Moreover, we should be able to tell whether the referenced blocks are &quot;fresh&quot;; that is, the adversary should not be able to reference blocks that it has precomputed and are not related to the genesis block. We achieve this by requiring blockchain contents to have a special structure in order to be considered valid by the content validation predicate V(&middot;) (Algorithm <a href="#page-28-0">5)</a>. A chain will be valid when the referenced blocks on every prefix of the chain form a tree that has the genesis block at its root. In order to check</p>

    <p class="text-gray-300">this efficiently, we require that the block headers listed in each block are ordered, so that each entry extends some block header found in previous entries of the same or parent blocks.</p>

    <p class="text-gray-300">In more detail, to efficiently check for membership in the hash tree, in line 2 of Algorithm 5 we use an AVL tree. (Any other data structure supporting efficient updates and search would also work.) In line 5 the referenced blocks are extracted and pushed into a queue. We note that during this process it is checked that: (i) the contents of the block have a correct format, i.e., a vote field and list of block headers, (ii) each header in the list is a valid SoW and extends a chain starting from the genesis block, and (iii) that the first reference includes a string r and the height of the block as required in the security analysis of Section 4.2.3 and described in Table 1.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Content validation pre-</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">As defined in Algorithm 5.</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">dicate <span class="math">V(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Chain reading function <span class="math">R(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R(\\cdot)</span> outputs the majority of the votes found in the block headers of</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">the first <span class="math">M</span> blocks of the selected chain.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Input contribution function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The input function <span class="math">I(\\cdot)</span> maintains state of which blocks have been</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">I(\\cdot)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">received, and outputs an input value <span class="math">x</span> that contains (i) the headers</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of all valid blocks that extend the genesis and are not mentioned in the</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">chain <span class="math">C</span> that the party is currently extending, (ii) a neutral transaction</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of the form <span class="math">KeyGen(pp)   \\mathcal{C} </span> , and (iii) the party's input (i.e., 0 or 1).</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: The instantiation of functions  <span class="math">I(\\cdot), V(\\cdot), R(\\cdot)</span>  for protocol  <span class="math">\\Pi_{RA}^{SoW}</span> .</p>

    <p class="text-gray-300">The algorithm runs for L rounds, after which it outputs the majority of the votes found in a prefix of the selected chain, of a predetermined length M. We call the resulting protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{SoW}}</span>  (&quot;BA&quot; for Byzantine agreement). A description of the consensus protocol (specifically, the V, R, I functions) is presented in Table 3, and also recall the example in Figure 1. Note that all parties terminate the protocol simultaneously.</p>

    <p class="text-gray-300"><strong>Theorem 35.</strong> Assuming the existence of a collision-resistant hash function and a SoW scheme that complies with Assumptions 1 and 2. Protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{SoW}}</span>  solves consensus in  <span class="math">O(\\frac{\\lambda}{\\gamma^3\\delta})</span>  rounds with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We are going to show that protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{SoW}}</span> , parameterized with  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span> ,  <span class="math">M = k + \\frac{8k}{\\gamma}</span>  number of blocks, and  <span class="math">L = \\frac{M+k}{(1-\\frac{\\delta}{4})\\gamma}</span>  number of rounds solves consensus with overwhelming probability in  <span class="math">\\lambda</span> . Our analysis uses many of the intermediate lemmas established for the proof of Theorem 34.</p>

    <p class="text-gray-300">We start, by proving that the Agreement property holds. First, note that our definition of  <span class="math">V(\\cdot)</span>  guarantees that if an honest party accepts a chain as valid, all other parties are also going to accept it as valid, since the validation predicate only depends on the chain that is being validated. Assume that an execution is  <span class="math">\\delta</span> -typical. Since  <span class="math">L \\geq \\frac{2\\lambda}{\\gamma\\delta}</span> , after L rounds: (i) due to chain growth the chains of all honest parties will have length at least M+k blocks, and (ii) due to the common prefix property they will all agree on the first M blocks of their chains. Hence, all honest parties will decide on their output values based on the &quot;votes&quot; mentioned in the same blocks, and thus they will all agree on the same value.</p>

    <p class="text-gray-300">Regarding Validity, we are going to show that the majority of the counted &quot;votes,&quot; i.e., from blocks and block headers found in blocks  <span class="math">B_1, \\ldots, B_M</span>  of the common prefix, have been mined by honest parties. Due to the chain quality property at least one block from  <span class="math">B_{M-k}, \\ldots, B_M</span>  is honest. Assume that the last honest block in this chain has been diffused in the network at round r. Since  <span class="math">M-k \\geq \\frac{8k}{\\gamma} \\geq k</span> , by an application of Lemma 28 starting from the genesis block, it holds that  <span class="math">r \\geq \\frac{8k}{\\gamma\\delta}</span> . Hence, at round  <span class="math">r + \\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span> , by the chain growth property all parties will have chains of length at least M+k, and by the common-prefix property all blocks up to the M-th position will be fixed for the rest</p>

    <p class="text-gray-300">of the execution. Hence, the last adversarial block in  <span class="math">B_1, \\ldots, B_M</span>  must have been computed before round  <span class="math">r + \\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">r&#x27; = r + \\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span> . It remains to show that for  <span class="math">S_1 = \\{1,\\ldots,r\\}</span>  and  <span class="math">S_2 = \\{1,\\ldots,r&#x27;\\}</span>  it holds that  <span class="math">Z(S_2) &lt; X(S_1)</span> :</p>

    <p class="text-gray-300"><span class="math">$Z(S_2) &lt; \\frac{1}{1+\\delta} \\gamma r&#x27; \\le (1-\\frac{\\delta}{4})(1-\\frac{\\delta}{4})\\gamma r&#x27; \\le (1-\\frac{\\delta}{4})\\gamma r \\le X(S_1).</span>$</p>

    <p class="text-gray-300">The first and the last inequalities hold due to the fact that the execution is typical. The fourth inequality follows by the size of r. The theorem follows since the majority of the referenced blocks in the chain agreed upon, have been mined by honest parties.</p>

    <p class="text-gray-300">Concluding, notice that the total size of any chain is bounded by the total number of blocks mined, since each block's header is mentioned at most once in a single chain. Hence, in s rounds of a typical execution a chain has size at most  <span class="math">O(s \\cdot \\lambda)</span>  bits.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 SoW Constructions from Idealized Assumptions</h2>

    <p class="text-gray-300">In this section, and as a sanity check, we outline a SoW scheme that is secure both in the random oracle and the  <span class="math">\\mathcal{F}_{TREE}</span>  model [47]. Moreover, according to the security parameters we obtain for the scheme, the security guarantees we get from our black-box analysis of the Bitcoin backbone are similar to those proved in [31, 47].</p>

    <p class="text-gray-300">SoW in the RO model. Our first step is to show that the SoW scheme used in the Bitcoin protocol (call it BSOW) is secure in the random oracle model according to our definitions. Bitcoin's Sign algorithm tries to find a block header with a small hash. The main components of the header are as follows: (i) the hash of the header of the previous block, (ii) the hash of the root of the Merkle tree of the transactions that are going to be added to Bitcoin's ledger, including the randomly created coinbase transaction, and (iii) a counter. The algorithm works by first fetching available transactions from the network, then computing a random public key that will be used for the coinbase transaction, and then iteratively incrementing the counter and calculating the hash of the header of the block until a small value is found. Casting this in our terms, the key is the hash of the previous block, which by itself depends on Bitcoin's genesis block, while the transactions received by the network as well as the coinbase transaction constitute the message. It is important to note that it is not possible to consider the key to be the coinbase transaction, as there is no guarantee it has any entropy when produced by an adversarial signer. To abstract the randomization of the signing procedure, which in the actual implementation is captured by the coinbase transaction, we hash msqtogether with a randomly generated string. This should be part of the signature in our SoW syntax since it is produced by the signing process and is necessary for verification. Similarly, the counter is also part of the signature produced by the signing process. BSOW, a simplified version of the scheme described above with the transaction semantics omitted for simplicity, is presented in Figure 6.</p>

    <p class="text-gray-300">Remark 4. In the Bitcoin implementation, the hash of the root of the Merkle tree of the transactions is not &quot;salted.&quot; This means that if we consider the adversary to be non-uniform, she could get collisions for free in her advice string and use them to compute two SoWs at the cost of one. This would be problematic for our MU-TCMA security game. Thus, in order to strengthen the security of the scheme, we choose to also include the key in the hash of the message.</p>

    <p class="text-gray-300">We will assume that H is an idealized hash function, i.e., our analysis is in the random oracle, and  <span class="math">G_k</span>  is sampled from a collision resistant hash function family.</p>

    <p class="text-gray-300"><strong>Theorem 36.</strong> If G is a collision resistant hash function family, and H is modeled as a Random Oracle, then for any  <span class="math">\\sigma \\in (0,1)</span> , Algorithm 6 is</p>

    <p class="text-gray-300"><strong>Algorithm 6</strong> Bitcoin's SoW implementation based on the ROM. H is modeled as a RO, while  <span class="math">G_k</span>  is sampled from a collision resistant hash function family  <span class="math">\\mathcal{G}</span> .</p>

    <pre><code class="language-text">1: function PPub(1^{\\lambda})
          k \\leftarrow K(\\lambda)
                                                                                            \\triangleright Sample the key of hash function G.
          return (1^{\\lambda}, k)
 3:
 4: end function
 6: function KeyGen(pp)
          vk \\leftarrow \\mathcal{U}_{\\lambda}
 7:
          return vk
 8:
 9: end function
11: function Sign(pp = (1^{\\lambda}, k), vk, msg, h)
          while true do
12:
               \\sigma_1 \\leftarrow \\mathcal{U}_{\\lambda}
13:
               dig \\leftarrow G_k(vk, \\sigma_1, msg)
14:
               for \\sigma_2 = 0^{\\lambda}|_2 to 1^{\\lambda}|_2 do
15:
                    if (H(vk, dig, \\sigma_2) &lt; 2^{\\lambda} - h) then
16:
                         return (\\sigma_1, \\sigma_2)
17:
                    end if
18:
               end for
19:
          end while
20:
21: end function
22:
23: function Verify(pp = (1^{\\lambda}, k), vk, msg, h, \\sigma = (\\sigma_1, \\sigma_2))
          return (H(vk, G_k(vk, \\sigma_1, msq), \\sigma_2) &lt; 2^{\\lambda} - h)
24:
25: end function
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>correct;</li>
      <li><span class="math">O(\\lambda)</span> -verifiable;</li>
      <li><span class="math">(t_{sign}, 1 (\\frac{h}{2^{\\lambda}})^{t_{sign}})</span> -successful, for  <span class="math">h \\in [2^{\\lambda} 1]</span> ;</li>
      <li>run-time independent;</li>
      <li><span class="math">((1+\\sigma)(1-\\frac{h}{2^{\\lambda}}),e^{-\\frac{\\beta(h)t\\sigma^2}{6}}+\\text{negl}(\\lambda))</span> -MU-TCMA secure w.r.t. any computationally unpredictable function family  <span class="math">\\mathcal{F}</span> , for  <span class="math">h \\in [2^{\\lambda}-1]</span> .</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">p_h = 1 - \\frac{h}{2^{\\lambda}}</span>  be the probability that a query to the random oracle returns a value less than  <span class="math">2^{\\lambda} - h</span> , and let  <span class="math">q_{\\mathcal{H}}</span>  be the number of queries the adversary makes to the RO. We consider each property in turn.</p>

    <p class="text-gray-300">Correct. By the collision resistance of G, it follows that  <span class="math">|\\{G(vk, \\sigma_1, msg) | \\sigma_1 \\in \\{0, 1\\}^{\\lambda}\\}|</span>  is greater than  <span class="math">\\lambda</span>  with overwhelming probability in  <span class="math">\\lambda</span> . Hence, the probability that the Sign algorithm cannot find any signature for the given parameters is upper bounded by the probability that  <span class="math">\\lambda \\cdot 2^{\\lambda}</span>  different queries to the  <span class="math">\\mathcal{RO}</span>  return a value greater or equal than  <span class="math">2^{\\lambda} - h</span> . This is upper bounded by:</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{h}{2^{\\lambda}}\\right)^{\\lambda 2^{\\lambda}} \\le \\left(1 - \\frac{1}{2^{\\lambda}}\\right)^{\\lambda 2^{\\lambda}} \\le e^{-\\lambda}</span>$</p>

    <p class="text-gray-300">The correctness property follows.</p>

    <p class="text-gray-300">MU-TCMA. Let  <span class="math">\\ell = \\beta(h)t</span> . W.l.o.g., assume  <span class="math">\\ell \\geq 1</span> , since if  <span class="math">\\ell &lt; 1</span>  there exists a trivial adversary that wins with probability 1. First, we show that for any adversary  <span class="math">\\mathcal{A}</span>  there exists an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that succeeds in winning  <span class="math">\\mathsf{Exp}^{\\mathrm{MU-TCMA}}_{\\mathcal{A}&#x27;,\\mathcal{F}}</span>  (Figure 2) with almost the same time complexity and probability that  <span class="math">\\mathcal{A}</span>  wins, without using the signing oracle  <span class="math">\\mathcal{S}</span> .  <span class="math">\\mathcal{A}&#x27;</span>  is going to run  <span class="math">\\mathcal{A}</span>  internally, and all calls made by  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathcal{S}</span>  are going to be simulated, i.e., assuming  <span class="math">\\mathcal{A}</span>  queries  <span class="math">\\mathcal{S}</span>  with values (k, msq),  <span class="math">\\mathcal{A}&#x27;</span>  will respond with some number t' sampled from the time distribution of  <span class="math">\\mathcal{S}</span>  (t' can be efficiently sampled from a geometric distribution, since queries are i.i.d Bernoulli trials) and some random signature  <span class="math">\\sigma = (\\sigma_1, \\sigma_2)</span> , where  <span class="math">\\sigma_2 &lt; t&#x27;</span> .  <span class="math">\\mathcal{A}&#x27;</span>  is also going to store this query in some efficient data structure that allows for search in logarithmic time. Any calls made by the adversary afterwards to the RO that are related to (k, msg) will be answered accordingly; if  <span class="math">\\mathcal{A}_2</span>  queries the RO with some string  <span class="math">k||G(k, \\sigma_1, msg)||\\sigma&#x27;_2</span> , where  <span class="math">\\sigma_2&#x27; = \\sigma_2</span> , then  <span class="math">\\mathcal{A}&#x27;</span>  will respond with the same value he responded on the initial query to  <span class="math">\\mathcal{S}</span> , otherwise if  <span class="math">\\sigma&#x27;_2 &lt; \\sigma_2</span> , he responds by  <span class="math">2^{\\lambda} - h + (y \\mod h)</span> , where y is the output of the real RO in this query. Note, that since  <span class="math">\\sigma_1</span>  is chosen at random and RO is unpredictable, the probability that  <span class="math">\\mathcal{A}</span>  has queried the RO with a string of this format before querying  <span class="math">\\mathcal S</span>  is negligible. Hence, the view of  <span class="math">\\mathcal A</span>  in both experiments is computationally indistinguishable, and he will output  <span class="math">\\ell</span>  valid SoWs with respect to the simulated view with the same probability that he wins in the real experiment.</p>

    <p class="text-gray-300">We next have to show that  <span class="math">\\mathcal{A}&#x27;</span>  can use the output of  <span class="math">\\mathcal{A}</span>  to win in the real experiment. The only case this will not happen, is if the output of  <span class="math">\\mathcal{A}</span>  contains a SoW related to the queries asked to (the simulated) oracle  <span class="math">\\mathcal{S}</span> , and thus it does not correspond to a winning output for  <span class="math">\\mathcal{A}&#x27;</span> , i.e.,  <span class="math">\\mathcal{A}&#x27;</span>  has set the value of this SoW to be small enough, while this does not necessarily hold for the actual RO. This implies, that there exists a SoW on the output of  <span class="math">\\mathcal{A}</span>  of the form  <span class="math">\\langle f, msg, (\\sigma_1, \\sigma_2) \\rangle</span>  and a query  <span class="math">\\langle (k, msg&#x27;), (\\sigma&#x27;_1, \\sigma&#x27;_2) \\rangle</span>  on  <span class="math">\\mathcal{S}</span> , such that  <span class="math">f(\\Sigma, vk)||G(f(\\Sigma, vk), \\sigma_1, msg)||\\sigma_2 = k||G(k, \\sigma&#x27;_1, msg&#x27;)||\\sigma&#x27;_2</span> . In order for this to be a winning output for  <span class="math">\\mathcal{A}</span> , it must not correspond to the asked query, and thus it should hold that either  <span class="math">msg \\neq msg&#x27;</span>  or  <span class="math">\\sigma_1 \\neq \\sigma&#x27;_1</span> . This implies that the adversary has found a collision in G, which only happens with negligible probability in  <span class="math">\\lambda</span> . Hence,  <span class="math">\\mathcal{A}&#x27;</span>  will win  <span class="math">\\text{Exp}_{\\mathcal{A}&#x27;,\\mathcal{F}}^{\\text{MU-TCMA}}</span>  with the same probability (minus some negligible term in  <span class="math">\\lambda</span> ) as  <span class="math">\\mathcal{A}</span> . Moreover, the overhead incurred to  <span class="math">\\mathcal{A}&#x27;</span> 's running time will be only logarithmic on  <span class="math">q_{\\mathcal{S}}</span>  i.e.  <span class="math">\\mathcal{A}&#x27;</span>  can simulate the t steps taken by  <span class="math">\\mathcal{A}_2</span>  in time  <span class="math">t&#x27; = t \\cdot (1 + \\log(q_{\\mathcal{S}}))</span> ; he has to maintain a heap of the queries made to  <span class="math">\\mathcal{S}</span>  and search it each time the RO is queried. Note, that  <span class="math">\\mathcal{A}&#x27;</span>  queries the real RO at most t times.</p>

    <p class="text-gray-300">Let  <span class="math">A_{\\ell}</span>  be the event where  <span class="math">\\mathcal{A}&#x27;</span>  asks t queries the RO after receiving vk, and receives at least  <span class="math">\\ell</span>  responses that have value less than  <span class="math">2^{\\lambda} - h</span> . Let random variable X be equal to the number of these responses that are less than  <span class="math">2^{\\lambda} - h</span> . Since the queries are i.i.d. Bernoulli random variables with probability of success  <span class="math">p_h</span> , we can use the Chernoff bound to bound the probability of  <span class="math">A_{\\ell}</span> . For any  <span class="math">\\sigma \\in (0,1)</span> , since  <span class="math">\\ell = \\beta t \\geq (1+\\sigma)p_h t</span> , it follows that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[A_{\\ell}] = \\Pr[X \\ge \\ell] \\le \\Pr[X \\ge (1+\\sigma)p_h t]</span>$
<span class="math">$= \\Pr[X \\ge (1+\\sigma)\\mathbb{E}[X]] \\le e^{-\\frac{\\mathbb{E}[X]\\sigma^2}{3}} \\le e^{-\\frac{(1+\\sigma)p_h t\\sigma^2}{6}}.</span>$</p>

    <p class="text-gray-300">Let B be the event where  <span class="math">\\mathcal{A}&#x27;_2</span>  outputs  <span class="math">f, m, \\sigma</span>  such that  <span class="math">f \\in \\mathcal{F}</span>  and there exists a query made to the random oracle by  <span class="math">\\mathcal{A}&#x27;_1</span>  of the form  <span class="math">f(\\Sigma, vk)||x||\\sigma</span> , for some  <span class="math">x \\in \\{0, 1\\}^*</span> . We will show that B happens with only negligible probability in  <span class="math">\\lambda</span> . For the sake of contradiction, assume that B happens with non-negligible probability. Then, we can use  <span class="math">\\mathcal{A}&#x27;</span>  to break the computational unpredictability of  <span class="math">\\mathcal{F}</span> . Let  <span class="math">\\mathcal{A}&#x27;&#x27; = (\\mathcal{A}&#x27;&#x27;_1, \\mathcal{A}&#x27;&#x27;_2)</span>  be the attacker in the computational unpredictability game.  <span class="math">\\mathcal{A}&#x27;&#x27;_1</span>  on input  <span class="math">(1^{\\lambda}, \\Sigma, pp)</span>  will first run  <span class="math">\\mathcal{A}&#x27;_1(1^{\\lambda}, \\Sigma, pp)</span> . It will output st' = st||y, where st is the output of  <span class="math">\\mathcal{A}_1</span> , and y the prefix of a random query that  <span class="math">\\mathcal{A}&#x27;_1</span>  made to the RO with length equal to the size of a verification key. Then,  <span class="math">\\mathcal{A}&#x27;&#x27;_2</span>  on input (st', vk) will run  <span class="math">\\mathcal{A}&#x27;_2(1^{\\lambda}, vk, st)</span> , until it halts and possibly outputs a number of SoWs. Since  <span class="math">\\mathcal{A}&#x27;</span>  is a PPT algorithm, the number of queries made to the RO is at most polynomial in number. Hence, with non-negligible probability B will occur and y will be the prefix of the RO query that matches the</p>

    <p class="text-gray-300">key of the SoW output by  <span class="math">\\mathcal{A}&#x27;</span> . This violates the computational unpredictability property, and hence B only occurs with negligible probability.</p>

    <p class="text-gray-300">Let C be the event where the adversary wins and outputs two distinct SoWs that correspond to the same query to the RO. This implies that the adversary can find a collision on G. In time  <span class="math">L = t&#x27; + t_{pre}</span>  polynomial in  <span class="math">\\lambda</span> , the probability that  <span class="math">\\mathcal{A}&#x27;</span>  finds a collision is  <span class="math">\\binom{L}{2} 2^{-\\lambda+1} = e^{-\\Omega(\\lambda)} = \\text{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Finally, note that if  <span class="math">A_{\\ell}, B, C</span>  do not occur, it is implied that  <span class="math">\\mathcal{A}&#x27;</span>  will lose in the MU-TCMA experiment. Thus:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[\\mathsf{Exp}^{\\mathsf{MU\\text{-}TCMA}}_{\\mathcal{A},\\mathcal{F}}(1^{\\lambda},h,\\ell) &amp;= 1] = \\Pr[\\mathsf{Exp}^{\\mathsf{MU\\text{-}TCMA}}_{\\mathcal{A}&#x27;,\\mathcal{F}}(1^{\\lambda},h,\\ell) = 1] \\\\ &amp;\\leq \\Pr[A_{\\ell} \\vee B \\vee C] \\\\ &amp;\\leq \\Pr[A_{\\ell}] + \\Pr[B] + \\Pr[C] \\\\ &amp;\\leq \\Pr[A_{\\ell}] + \\mathsf{negl}(\\lambda) \\\\ &amp;\\leq e^{-\\frac{(1+\\sigma)p_ht\\sigma^2}{6}} + \\mathsf{negl}(\\lambda) \\end{split}</span>$</p>

    <p class="text-gray-300">where we have used the union bound for the third inequality.</p>

    <p class="text-gray-300">Verifiability. Assuming H and G take constant time, verification takes time  <span class="math">c_{\\text{ver}}\\lambda</span> , for some small constant  <span class="math">c_{\\text{ver}}</span>  which can be easily computed by careful inspection of the verification protocol.</p>

    <p class="text-gray-300">Successful. Let E be the event that in an execution of the Sign function no collisions occur. By the collision resistance property of H and G, it holds that  <span class="math">\\Pr[\\neg E] \\leq \\mathsf{negl}(\\lambda)</span> . For any  <span class="math">t \\in \\mathbb{N}</span> ,  <span class="math">pp \\in PP</span> ,  <span class="math">vk \\in K</span> ,  <span class="math">msg \\in M</span>  and  <span class="math">h \\in \\mathbb{N}</span>  it follows that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk, msg, h) &lt; t\\right] \\geq 1 - (1 - p_h)^t - \\mathsf{negl}(\\lambda)</span>$</p>

    <p class="text-gray-300">Independence. Let  <span class="math">\\{Y_i\\}_{i\\in I}</span>  be the same as  <span class="math">\\{X_i\\}_{i\\in I}=\\{\\mathsf{Steps}_{\\mathsf{Sign}}(pp,vk_i,m_i,h_i)\\}_{i\\in I}</span>  with the only difference that the random oracle is replaced with a random function, i.e., every time  <span class="math">\\mathsf{Sign}</span>  is called and the oracle H is queried it generates a random output. Obviously the random variables in  <span class="math">\\{Y_i\\}_{i\\in I}</span>  are mutually independent, since their output only depends on their own local coins.</p>

    <p class="text-gray-300">Regarding the second property, let E be the event that all  <span class="math">\\sigma_1</span>  sampled are different among all the invocations of Sign, and that no collisions occurs in G. Note, for polynomially big I, this event happens with overwhelming probability in  <span class="math">\\lambda</span> . Moreover, conditioned E, it holds that  <span class="math">\\Pr[\\{X_i\\}_{i\\in I}=z|E]</span>  is equal to  <span class="math">\\Pr[\\{Y_i\\}_{i\\in I}=z|E]</span> , for any z, since the random oracle behaves exactly as the random function we have replaced it with. Therefore, if  <span class="math">p(\\cdot)</span>  is a polynomial that upper bounds the number of steps of Sign, it holds that for any  <span class="math">z \\in [p(\\lambda)]^{|I|}</span></p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp;\\Pr[\\{X_i\\}_{i \\in I} = z] - \\Pr[\\{Y_i\\}_{i \\in I} = z] = \\\\ &amp;= \\Pr[\\{X_i\\}_{i \\in I} = z | E] \\Pr[E] + \\Pr[\\{X_i\\}_{i \\in I} = z | \\neg E] \\Pr[\\neg E] \\\\ &amp;- \\Pr[\\{Y_i\\}_{i \\in I} = z | E] \\Pr[E] - \\Pr[\\{Y_i\\}_{i \\in I} = z | \\neg E] \\Pr[\\neg E] \\\\ &amp;= (\\Pr[\\{X_i\\}_{i \\in I} = z | \\neg E] - \\Pr[\\{Y_i\\}_{i \\in I} = z | \\neg E]) \\Pr[\\neg E] \\end{aligned}</span>$</p>

    <p class="text-gray-300">Hence, it follows that the two distributions are  <span class="math">negl(\\lambda)</span> -close:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} 2\\Delta[\\{X_i\\}_{i\\in I}, &amp;\\{Y_i\\}_{i\\in I}] = \\sum_z |\\Pr[\\{X_i\\}_{i\\in I} = z] - \\Pr[\\{Y_i\\}_{i\\in I} = z]| \\\\ &amp;\\leq \\sum_z |(\\Pr[\\{X_i\\}_{i\\in I} = z|\\neg E] - \\Pr[\\{Y_i\\}_{i\\in I} = z|\\neg E]) \\Pr[\\neg E]| \\\\ &amp;\\leq \\Pr[\\neg E] \\sum_z |(\\Pr[\\{X_i\\}_{i\\in I} = z|\\neg E] - \\Pr[\\{Y_i\\}_{i\\in I} = z|\\neg E])| \\\\ &amp;\\leq \\operatorname{negl}(\\lambda) (\\sum_z \\Pr[\\{X_i\\}_{i\\in I} = z|\\neg E] + \\sum_z \\Pr[\\{Y_i\\}_{i\\in I} = z|\\neg E]) \\leq \\operatorname{negl}(\\lambda) \\end{split}</span>$</p>

    <p class="text-gray-300">The last inequality follows from the fact that each of the sums should be less or equal to 1, as the events described are disjoint and their union covers the entire sample space.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">SoW in the  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  model. Next, we argue that we can use the  <span class="math">\\mathcal{F}_{\\text{TREE}}^p</span>  functionality from [47] to realize a secure SoW scheme.</p>

    <p class="text-gray-300">We start by reciting the  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  description.  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  is parametrized by some hardness parameter p and keeps track of records on a tree. Initially, the tree contains  <span class="math">\\bot</span> . On invocation of  <span class="math">extend((m_1, \\ldots, m_{\\ell-1}), m)</span> ,  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  checks if  <span class="math">(m_1, \\ldots, m_{\\ell-1})</span>  is a valid path on the tree, and if yes with probability p extends this path by m and returns 1. Otherwise, returns 0. On invocation of  <span class="math">ver(m_1, \\ldots, m_\\ell)</span> ,  <span class="math">\\mathcal{F}^p_{\\text{TREE}}</span>  returns 1 if  <span class="math">m_1, \\ldots, m_\\ell</span>  is a valid path, and 0 otherwise. For simplicity, here we assume that extend and ver take one computational step each.</p>

    <p class="text-gray-300">The SoW protocol is constructed in a similar way as in the ROM; we only have to replace the &quot; <span class="math">H(...) &lt; 2^{\\lambda} - h</span> &quot; checks in Sign and Verify, with invocations to extend and ver on  <span class="math">\\mathcal{F}_{\\text{TREE}}^{(2^{\\lambda} - h)/2^{\\lambda}}</span> , respectively (see Algorithm 7). We will consider a slightly stronger version of  <span class="math">\\mathcal{F}_{\\text{TREE}}</span> , where the hardness parameter p is a parameter of the function calls. That is because SoW schemes allow for different hardness levels, while the original  <span class="math">\\mathcal{F}_{\\text{TREE}}</span>  functionality has a fixed hardness level. We note, that the results of [47] can be easily proved for the strengthened functionality.</p>

    <p class="text-gray-300"><strong>Algorithm 7</strong> Bitcoin's SoW implementation based on functionality  <span class="math">\\mathcal{F}_{TREE}</span> . H is modeled as a RO, while  <span class="math">G_k</span>  is sampled from a collision resistant hash function family  <span class="math">\\mathcal{G}</span> . We omit functions PPub, KeyGen which are exactly the same as in Algorithm 6, while differences in Sign, Verify are depicted in red.</p>

    <pre><code class="language-text">1: function Sign(pp = (1^{\\lambda}, k), vk, msg, h)
              while true do
 2:
                    \\sigma_1 \\leftarrow \\mathcal{U}_{\\lambda}
 3:
                    dig \\leftarrow G_k(vk, \\sigma_1, msg)
  4:
                    for \\sigma_2 = 0^{\\lambda}|_2 to 1^{\\lambda}|_2 do
  5:
                           if (\\mathcal{F}_{\\text{TREE}}^{(2^{\\lambda}-h)/2^{\\lambda}}.extend(\\perp,vk||dig||\\sigma_2)=1) then
  6:
                                  return (\\sigma_1, \\sigma_2)
  7:
                           end if
  8:
                    end for
 9:
              end while
10:
11: end function
13: function Verify(pp = (1^{\\lambda}, k), vk, msg, h, \\sigma = (\\sigma_1, \\sigma_2))
14: return \\mathcal{F}_{\\text{TREE}}^{(2^{\\lambda} - h)/2^{\\lambda}}.ver(\\bot, vk||G(vk, \\sigma_1, msg)||\\sigma_2)
15: end function
</code></pre>

    <p class="text-gray-300">The proof that Algorithm 7 implements a secure SoW scheme follows the same arguments as the proof of Theorem 36. We omit the details for the full version of the paper.</p>

    <p class="text-gray-300"><strong>Theorem 37.</strong> If  <span class="math">\\mathcal{G}</span>  is a collision resistant hash function family, and we are in the  <span class="math">\\mathcal{F}_{TREE}</span> -hybrid world, then for any  <span class="math">\\sigma \\in (0,1)</span> , Algorithm 7 is</p>

    <pre><code class="language-text">- correct;

- O(\\lambda)-verifiable;

- (t_{sign}, 1 - \\left(\\frac{h}{2^{\\lambda}}\\right)^{t_{sign}})-successful, for h \\in [2^{\\lambda} - 1];

- run-time independent;
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">((1+\\sigma)(1-\\frac{h}{2^{\\lambda}}),e^{-\\frac{\\beta(h)t\\sigma^2}{6}}+\\text{negl}(\\lambda))</span> -MU-TCMA secure w.r.t. any computationally unpredictable function family  <span class="math">\\mathcal{F}</span> , for  <span class="math">h\\in[2^{\\lambda}-1]</span> .</li>
    </ul>

    <p class="text-gray-300">Comparison with the results of [31]. Since parameter  <span class="math">\\epsilon</span>  of the MU-TCMA property of BSOW is negligible in  <span class="math">\\beta(h) \\cdot t</span>  and the scheme is runtime independent, we can use Theorem 36 and obtain meaningful bounds for the  <span class="math">\\gamma</span> , f quantities introduced in the previous subsection. These quantities are important since  <span class="math">\\gamma</span>  determines how powerful the adversary our system can handle can be, and f is related to how fast blocks are produced. Replacing with the parameters proved for BPOW, for  <span class="math">\\sigma \\ll 1</span> ,  <span class="math">\\gamma</span>  and f are equal to:</p>

    <p class="text-gray-300"><span class="math">$\\gamma = (n-t) \\cdot \\left(1 - \\left(\\frac{h}{2^{\\lambda}}\\right)^{t&#x27;_{\\mathcal{H}}}\\right) \\cdot \\left(\\frac{h}{2^{\\lambda}}\\right)^{(n-1)t_{\\mathcal{H}}}, f = 1 - \\left(\\frac{h}{2^{\\lambda}}\\right)^{t&#x27;_{\\mathcal{H}}(n-t)}</span>$</p>

    <p class="text-gray-300">Both of these quantities appear in [31] and are well approximated by our results. Hence,  <span class="math">\\Pi_{PL}^{BSoW}</span>  implements a robust transaction ledger with overwhelming probability in  <span class="math">\\lambda</span>  and with bounds comparable to those in [31], and achieves consensus when the honest parties have the honest majority of the computational power.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[1] N. Alon, O. Goldreich, J. H&aring;stad, and R. Peralta. Simple construction of almost k-wise independent random variables. <em>Random Struct. Algorithms</em>, 3(3):289&ndash;304, 1992.</p></li>
      <li><p class="text-gray-300">[2] J. Alwen and B. Tackmann. Moderately hard functions: Definition, instantiations, and applications. In Theory of Cryptography - 15th International Conference, TCC 2017, Baltimore, MD, USA, November 12-15, 2017, Proceedings, Part I, pages 493&ndash;526, 2017.</p></li>
      <li><p class="text-gray-300">[3] M. Andrychowicz and S. Dziembowski. Pow-based distributed cryptography with no trusted setup. In R. Gennaro and M. Robshaw, editors, Advances in Cryptology - CRYPTO 2015 - 35th Annual Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2015, Proceedings, Part II, volume 9216 of Lecture Notes in Computer Science, pages 379&ndash;399. Springer, 2015.</p></li>
      <li><p class="text-gray-300">[4] A. Back. Hashcash-amortizable publicly auditable cost functions. Early draft of paper, 2000.</p></li>
      <li><p class="text-gray-300">[5] A. Back. Hashcash&ndash;a denial of service counter-measure, 2002.</p></li>
      <li><p class="text-gray-300">[6] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra, J. Tim&oacute;n, and P. Wuille. Enabling blockchain innovations with pegged sidechains. <em>URL: http://www. opensciencereview.</em> com/papers/123/enablingblockchain-innovations-with-pegged-sidechains, 2014.</p></li>
      <li><p class="text-gray-300">[7] C. Badertscher, U. Maurer, D. Tschudi, and V. Zikas. Bitcoin as a transaction ledger: A composable treatment. In Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I, pages 324-356, 2017.</p></li>
      <li><p class="text-gray-300">[8] M. Ball, A. Rosen, M. Sabin, and P. N. Vasudevan. Proofs of work from worst-case assumptions. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I, pages 789&ndash;819, 2018.</p></li>
      <li><p class="text-gray-300">[9] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete security treatment of symmetric encryption. In 38th Annual Symposium on Foundations of Computer Science, FOCS '97, Miami Beach, Florida, USA, October 19-22, 1997, pages 394-403, 1997.</p></li>
      <li><p class="text-gray-300">[10] M. Bellare, J. Jaeger, and J. Len. Better than advertised: Improved collision-resistance guarantees for md-based hash functions. In <em>Proceedings of the 2017 ACM SIGSAC Conference on Computer and Com</em>munications Security, CCS '17, pages 891&ndash;906, New York, NY, USA, 2017. ACM.</p></li>
      <li><p class="text-gray-300">[11] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In CCS '93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993, pages 62&ndash;73, 1993.</p></li>
      <li><p class="text-gray-300">[12] M. Bellare and P. Rogaway. The exact security of digital signatures - how to sign with RSA and rabin. In Advances in Cryptology - EUROCRYPT '96, International Conference on the Theory and Application of Cryptographic Techniques, Saragossa, Spain, May 12-16, 1996, Proceeding, pages 399&ndash;416, 1996.</p></li>
      <li><p class="text-gray-300">[13] M. Ben-Or. Another advantage of free choice: Completely asynchronous agreement protocols (extended abstract). In R. L. Probert, N. A. Lynch, and N. Santoro, editors, Proceedings of the Second Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, Montreal, Quebec, Canada, August 17-19, 1983, pages 27&ndash;30. ACM, 1983.</p></li>
      <li><p class="text-gray-300">[14] I. Bentov, P. Hub'avcek, T. Moran, and A. Nadler. Tortoise and hares consensus: the meshcash framework for incentive-compatible, scalable cryptocurrencies. IACR Cryptology ePrint Archive, 2017:300, 2017.</p></li>
      <li><p class="text-gray-300">[15] D. J. Bernstein and T. Lange. Non-uniform cracks in the concrete: The power of free precomputation. In Advances in Cryptology - ASIACRYPT 2013 - 19th International Conference on the Theory and Application of Cryptology and Information Security, Bengaluru, India, December 1-5, 2013, Proceedings, Part II, pages 321&ndash;340, 2013.</p></li>
      <li><p class="text-gray-300">[16] N. Bitansky, S. Goldwasser, A. Jain, O. Paneth, V. Vaikuntanathan, and B. Waters. Time-lock puzzles from randomized encodings. In M. Sudan, editor, Proceedings of the 2016 ACM Conference on Innovations in Theoretical Computer Science, Cambridge, MA, USA, January 14-16, 2016, pages 345&ndash;356. ACM, 2016.</p></li>
      <li><p class="text-gray-300">[17] D. Boneh, J. Bonneau, B. B&uml;unz, and B. Fisch. Verifiable delay functions. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I, pages 757&ndash;788, 2018.</p></li>
      <li><p class="text-gray-300">[18] M. Borderding. Levels of authentication in distributed agreement. In O. Babaoglu and K. Marzullo, &uml; editors, Distributed Algorithms, 10th International Workshop, WDAG '96, Bologna, Italy, October 9-11, 1996, Proceedings, volume 1151 of Lecture Notes in Computer Science, pages 40&ndash;55. Springer, 1996.</p></li>
      <li><p class="text-gray-300">[19] R. Canetti. Security and composition of multiparty cryptographic protocols. J. Cryptology, 13(1):143&ndash;202, 2000.</p></li>
      <li><p class="text-gray-300">[20] R. Canetti, O. Goldreich, and S. Halevi. The random oracle methodology, revisited. J. ACM, 51(4):557&ndash;594, July 2004.</p></li>
      <li><p class="text-gray-300">[21] I. Damg&#730;ard. A design principle for hash functions. In Advances in Cryptology - CRYPTO '89, 9th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 1989, Proceedings, pages 416&ndash;427, 1989.</p></li>
      <li><p class="text-gray-300">[22] D. Dolev and H. R. Strong. Authenticated algorithms for byzantine agreement. SIAM J. Comput., 12(4):656&ndash;666, 1983.</p></li>
      <li><p class="text-gray-300">[23] J. R. Douceur. The sybil attack. In P. Druschel, M. F. Kaashoek, and A. I. T. Rowstron, editors, Peerto-Peer Systems, First International Workshop, IPTPS 2002, Cambridge, MA, USA, March 7-8, 2002, Revised Papers, volume 2429 of Lecture Notes in Computer Science, pages 251&ndash;260. Springer, 2002.</p></li>
      <li><p class="text-gray-300">[24] C. Dwork, N. A. Lynch, and L. J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288&ndash;323, 1988.</p></li>
      <li><p class="text-gray-300">[25] C. Dwork and M. Naor. Pricing via processing or combatting junk mail. In Proceedings of the 12th Annual International Cryptology Conference on Advances in Cryptology, CRYPTO '92, pages 139&ndash;147, London, UK, UK, 1993. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[26] P. Feldman and S. Micali. An optimal probabilistic protocol for synchronous byzantine agreement. SIAM J. Comput., 26(4):873&ndash;933, 1997.</p></li>
      <li><p class="text-gray-300">[27] M. J. Fischer, N. A. Lynch, and M. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374&ndash;382, 1985.</p></li>
      <li><p class="text-gray-300">[28] M. Fitzi. Generalized communication and security models in Byzantine agreement. PhD thesis, ETH Zurich, Z&uml;urich, Switzerland, 2003.</p></li>
      <li><p class="text-gray-300">[29] J. A. Garay and A. Kiayias. SoK: A consensus taxonomy in the blockchain era. IACR Cryptology ePrint Archive, 2018:754, 2018.</p></li>
      <li><p class="text-gray-300">[30] J. A. Garay, A. Kiayias, and N. Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. IACR Cryptology ePrint Archive, 2014:765, 2014.</p></li>
      <li><p class="text-gray-300">[31] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology - EUROCRYPT 2015, pages 281&ndash;310, 2015.</p></li>
      <li><p class="text-gray-300">[32] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol with chains of variable difficulty. In Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I, pages 291&ndash;323, 2017.</p></li>
      <li><p class="text-gray-300">[33] J. A. Garay, A. Kiayias, N. Leonardos, and G. Panagiotakos. Bootstrapping the blockchain, with applications to consensus and fast PKI setup. In Public-Key Cryptography - PKC 2018 - 21st IACR International Conference on Practice and Theory of Public-Key Cryptography, Rio de Janeiro, Brazil, March 25-29, 2018, Proceedings, Part II, pages 465&ndash;495, 2018.</p></li>
      <li><p class="text-gray-300">[34] J. A. Garay, A. Kiayias, and G. Panagiotakos. Consensus from signatures of work. Cryptology ePrint Archive, Report 2017/775, 2017. <a href="https://eprint.iacr.org/2017/775" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2017/775</a>.</p></li>
      <li><p class="text-gray-300">[35] J. A. Garay, A. Kiayias, and G. Panagiotakos. Iterated search problems and blockchain security under falsifiable assumptions. Cryptology ePrint Archive, Report 2019/315, 2019. <a href="https://eprint.iacr.org/2019/315" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2019/315" target="_blank" rel="noopener noreferrer">2019/315</a>.</p></li>
      <li><p class="text-gray-300">[36] J. A. Garay, P. MacKenzie, M. Prabhakaran, and K. Yang. Resource fairness and composability of cryptographic protocols. Journal of cryptology, 24(4):615&ndash;658, 2011.</p></li>
      <li><p class="text-gray-300">[37] M. Jakobsson and A. Juels. Proofs of work and bread pudding protocols. In Proceedings of the IFIP TC6/TC11 Joint Working Conference on Secure Information Networks: Communications and Multimedia Security, CMS '99, pages 258&ndash;272, Deventer, The Netherlands, The Netherlands, 1999. Kluwer, B.V.</p></li>
      <li><p class="text-gray-300">[38] A. Juels and J. G. Brainard. Client puzzles: A cryptographic countermeasure against connection depletion attacks. In Proceedings of the Network and Distributed System Security Symposium, NDSS 1999, San Diego, California, USA. The Internet Society, 1999.</p></li>
      <li><p class="text-gray-300">[39] J. Katz, A. Miller, and E. Shi. Pseudonymous secure computation from time-lock puzzles. IACR Cryptology ePrint Archive, 2014:857, 2014.</p></li>
      <li><p class="text-gray-300">[40] A. Kiayias and G. Panagiotakos. Speed-security tradeoffs in blockchain protocols. Technical report, IACR: Cryptology ePrint Archive, 2015.</p></li>
      <li><p class="text-gray-300">[41] P. C. Kocher. Timing attacks on implementations of diffie-hellman, rsa, dss, and other systems. In Advances in Cryptology - CRYPTO '96, 16th Annual International Cryptology Conference, Santa Barbara, California, USA, August 18-22, 1996, Proceedings, pages 104&ndash;113, 1996.</p></li>
      <li><p class="text-gray-300">[42] L. Lamport, R. E. Shostak, and M. C. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382&ndash;401, 1982.</p></li>
      <li><p class="text-gray-300">[43] Y. Lewenberg, Y. Sompolinsky, and A. Zohar. Inclusive block chain protocols. In Financial Cryptography and Data Security, 2015, 2015.</p></li>
      <li><p class="text-gray-300">[44] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</p></li>
      <li><p class="text-gray-300">[45] M. Okun. Agreement among unacquainted byzantine generals. In P. Fraigniaud, editor, DISC, volume 3724 of Lecture Notes in Computer Science, pages 499&ndash;500. Springer, 2005.</p></li>
      <li><p class="text-gray-300">[46] M. Okun. Distributed computing among unacquainted processors in the presence of byzantine distributed computing among unacquainted processors in the presence of byzantine failures. Ph.D. Thesis Hebrew University of Jerusalem, 2005.</p></li>
      <li><p class="text-gray-300">[47] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In J. Coron and J. B. Nielsen, editors, Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II, volume 10211 of Lecture Notes in Computer Science, pages 643&ndash;673, 2017.</p></li>
      <li><p class="text-gray-300">[48] M. C. Pease, R. E. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27(2):228&ndash;234, 1980.</p></li>
      <li><p class="text-gray-300">[49] B. Pfitzmann and M. Waidner. Unconditional byzantine agreement for any number of faulty processors. In STACS 92, 9th Annual Symposium on Theoretical Aspects of Computer Science, Cachan, France, February 13-15, 1992, Proceedings, pages 339&ndash;350, 1992.</p></li>
      <li><p class="text-gray-300">[50] A. Poelstra. On stake and consensus (2015). URL https://download. wpsoftware. net/bitcoin/pos. pdf.</p></li>
      <li><p class="text-gray-300">[51] F. B. Schneider. Implementing fault-tolerant services using the state machine approach: A tutorial. ACM Comput. Surv., 22(4):299&ndash;319, Dec. 1990.</p></li>
      <li><p class="text-gray-300">[52] Y. Sompolinsky, Y. Lewenberg, and A. Zohar. SPECTRE: A fast and scalable cryptocurrency protocol. IACR Cryptology ePrint Archive, 2016:1159, 2016.</p></li>
      <li><p class="text-gray-300">[53] Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers, pages 507&ndash;527, 2015.</p></li>
      <li><p class="text-gray-300">[54] D. Stebila, L. Kuppusamy, J. Rangasamy, C. Boyd, and J. M. G. Nieto. Stronger difficulty notions for client puzzles and denial-of-service-resistant protocols. In Topics in Cryptology - CT-RSA 2011 - The Cryptographers' Track at the RSA Conference 2011, San Francisco, CA, USA, February 14-18, 2011. Proceedings, pages 284&ndash;301, 2011.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Consensus from Signatures of Work (2017/775)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/775
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li><a href="#sec-2" class="hover:text-white">Preliminaries</a></li>
        <li><a href="#sec-3" class="hover:text-white">Signatures of Work</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Applications</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">The Permissionless Model, Revisited</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Public Transaction Ledger from Signatures of Work</a></li>
            <li><a href="#sec-4.2.1" class="hover:text-white">The Bitcoin backbone protocol.</a></li>
            <li><a href="#sec-4.2.2" class="hover:text-white">Security properties of the blockchain.</a></li>
            <li><a href="#sec-4.2.3" class="hover:text-white">Security proof.</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Consensus from Signatures of Work</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">SoW Constructions from Idealized Assumptions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="consensus-from-signatures-of-work-2017" />
  </article>
</BaseLayout>
