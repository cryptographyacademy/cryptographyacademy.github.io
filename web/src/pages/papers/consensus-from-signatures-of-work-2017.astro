---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/775';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Consensus from Signatures of Work';
const AUTHORS_HTML = 'Juan A.  Garay, Aggelos Kiayias, Giorgos Panagiotakos';

const CONTENT = `    <p class="text-gray-300">Juan A. Garay Texas A&amp;M University garay@cse.tamu.edu Aggelos Kiayias University of Edinburgh &amp; IOHK akiayias@inf.ed.ac.uk Giorgos Panagiotakos University of Edinburgh giorgos.pan@ed.ac.uk</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Assuming the existence of a public-key infrastructure (PKI), digital signatures are a fundamental building block in the design of secure consensus protocols with optimal resilience. More recently, with the advent of blockchain protocols like Bitcoin, consensus has been considered in the “permissionless” setting where no authentication or even point-to-point communication is available. Yet, despite some positive preliminary results, all attempts to formalize a building block that is sufficient for designing consensus protocols in this setting, rely on a very strong independence assumption about adversarial accesses to the underlying computational resource.</p>

    <p class="text-gray-300">In this work, we relax this assumption by putting forth a primitive, which we call signatures of work (SoW). Distinctive features of our new notion are a lower bound on the number of steps required to produce a signature; fast verification; moderate unforgeability—producing a sequence of SoWs, for chosen messages, does not provide an advantage to an adversary in terms of running time; and honest signing time independence—most relevant in concurrent multi-party applications, as we show.</p>

    <p class="text-gray-300">Armed with SoW, we then present a new permissionless consensus protocol which is secure assuming an honest majority of computational power, thus in a sense providing a blockchain counterpart to the classical Dolev-Strong consensus protocol. The protocol is built on top of a SoW-based blockchain and standard properties of the underlying hash function, thus improving on the known provably secure consensus protocols in this setting, which rely on the strong independence property mentioned above in a fundamental way.</p>

    <p class="text-gray-300">*Research partly supported by Horizon 2020 project PANORAMIX, No. 653497.</p>

    <p class="text-gray-300">1 Introduction 3 2 Preliminaries 8 3 Signatures of Work 10 4 Applications 13 4.1 The Permissionless Model, Revisited 13 4.2 Public Transaction Ledger from Signatures of Work 15 4.2.1 The Bitcoin backbone protocol. 15 4.2.2 Security properties of the blockchain. 17 4.2.3 Security proof. 18 4.3 Consensus from Signatures of Work 28 5 SoW Constructions from Idealized Assumptions 31</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The consensus problem—reaching agreement distributedly in the presence of faults—has been extensively studied in the literature starting with the seminal work of Shostak, Pease and Lamport <em>[48, 42]</em>. The problem formulation has a number of servers (parties) starting with an individual input which should agree at the end to a joint output that has to match the input in the case where all non-faulty servers happened to have the same input value. One of the critical measures of effectiveness for consensus protocols is maximizing their resilience to Byzantine faults, typically denoted by <span class="math">t</span>. It is known that <span class="math">t&lt;n/2</span> is necessary to achieve consensus, where <span class="math">n</span> is the total number of parties, while protocols have been designed that reach that level of resilience assuming synchrony and a way to authenticate messages using digital signatures <em>[22]</em> (or “pseudosignatures” <em>[49]</em>). This result is known to be tight since lack of synchrony would imply <span class="math">t&lt;n/3</span> <em>[24]</em> (as well as randomization <em>[27]</em>), while lack of a message authentication mechanism has a similar effect <em>[18]</em>.</p>

    <p class="text-gray-300">Recently, with the advent of blockchain protocols like Bitcoin, the problem has experienced renewed interest from a much wider community of researchers and has seen its application expand to various novel settings, such as the so-called “permissionless” setting, where participation in the protocol is both unrestricted and unauthenticated. In fact, this setting was initially studied in <em>[45, 46]</em>, where it was shown that deterministic consensus algorithms are impossible for even a single failure but that probabilistic consensus is still feasible by suitably adapting the protocols of <em>[13, 26]</em>. Nevertheless, the resulting protocol required exponentially many rounds in <span class="math">n</span>.</p>

    <p class="text-gray-300">The first efficient solutions for the consensus problem in the permissionless setting were formally shown to be possible utilizing an abstraction of the Bitcoin blockchain protocol in <em>[31]</em>, against adversaries controlling less than half of the computational power which, in a uniform configuration (meaning parties are endowed with the same computational power), corresponds to a number of Byzantine faults <span class="math">t&lt;n/2</span> in the original setting. At a high level, these protocols (as well as the Bitcoin blockchain protocol itself) rely on a concept known as proofs of work (PoW), which, intuitively, enables one party to convince others that he has invested some computational effort for solving a given task. While being formulated a while back <em>[25]</em> and used for a variety of purposes—e,g, spam mitigation <em>[25]</em>, sybil attacks <em>[23]</em>, and denial of service protection <em>[38, 5]</em>—their role in the design of permissionless blockchain protocols <em>[44]</em>, is arguably their most impactful application.</p>

    <p class="text-gray-300">In the context of permissionless blockchain protocols, the way a PoW-like primitive helps is by slowing down message generation for all parties indiscriminately, thus generating opportunities for honest parties to converge to a unique view under the assumption that the aggregate computational power of honest parties sufficiently exceeds that of the adversary. Now, while this intuition matches the more rigorous analyses of the Bitcoin protocol that have been carried out so far <em>[31, 47, 32, 7]</em>, these works have refrained from formally defining such enabling functionality as a stand-alone cryptographic primitive, and relied instead on the random oracle (RO) model <em>[11]</em> or similar idealized assumptions (cf. the <span class="math">\\mathcal{F}_{\\textsc{tree}}</span> functionality in <em>[47]</em>) to prove directly the properties of the blockchain protocol. The same is true for other provably secure PoW-based distributed protocols <em>[3, 39, 33]</em>.</p>

    <p class="text-gray-300">The core of the hardness (or even impossibility <em>[20]</em>) of implementing the assumed idealized resources is that they satisfy a strong independence property: Each bit output on a new query to the resource is independently sampled, even if the adversary is the one who is accessing the resource. This is indeed a very strong property, as it directly implies that the best way to compute a PoW for both an honest party and the adversary is brute force. Moreover, the same property is explicitly used to argue the security of the proposed consensus protocols in the PoW setting <em>[31, 3]</em>, as we explain in</p>

    <p class="text-gray-300">detail later.</p>

    <p class="text-gray-300">In this work we make progress in relaxing this assumption, by putting forth a formalization of a PoW-like primitive, which we call signatures of work (SoW). An SoW can be implemented in the RO model or by using <span class="math">\\mathcal{F}_{\\textsc{tree}}</span>, but the adversarial SoW computation process does <em>not</em> necessarily satisfy such strong guarantees as the ones mentioned above. Indeed, in contrast to previous approaches, only an upper bound on the rate at which the adversary generates SoWs needs to be assumed. We then present a new permissionless consensus protocol based on SoWs that can be proven secure without relying on such strong independence guarantees. The protocol utilizes a SoW-based blockchain and standard properties of the underlying hash function, and is secure assuming an honest majority of computational power. As a result, this protocol can be seen as an exemplar of how a permissionless signature-like primitive enables honest majority consensus in the same way that classical digital signatures imply honest-majority consensus protocols in the traditional setting.</p>

    <p class="text-gray-300">Why signatures of work? We first provide some intuition behind the relevance of SoW as a useful primitive for the design of permissionless distributed protocols. Recall the main property of a digital signature in the design of classical consensus protocols: It enables parties to communicate to each other their protocol view and inputs at a certain stage of the protocol execution in a way that is transferable and non-repudiable. Indeed, Bob, upon receiving Alice’s signed message, can show it to Charlie in a way that the latter is unequivocally convinced of the message’s origin. It follows that Bob cannot modify Alice’s messages, playing man-in-the-middle between Alice and Charlie, and thus Alice can be held accountable in case she provides conflicting views to the two parties. A SoW scheme provides a similar capability: Using a SoW, a party like Alice can invest effort into a specific protocol view and inputs, so that when Bob is presented with a SoW produced by Alice it will be infeasible for Alice to provide a conflicting view and inputs to Charlie, unless she invests twice the effort. Moreover, the above argument holds without establishing any set of identities among the parties, so for example Bob does not need to know he talks to Alice per se but rather to an arbitrary party that invested some effort with respect to a specific protocol view. Furthermore, exactly like digital signatures, SoWs can be chained recursively, enabling the parties to build on each other’s protocol view.</p>

    <p class="text-gray-300">While the above functionalities hint to the usefulness of SoWs in the distributed permissionless setting, formalizing and applying them properly is no simple task. Firstly, in contrast with classical signatures, there is no secret key involved in this primitive. This make sense, since in a permisionless setting signing messages using some kind of secret information is meaningless, as parties do no have any secret setup to begin with. Hence, if they are to sign any message, they should use some other kind of resource that only they have access to, such as their computational power. Secondly, in classical signatures, the exact time when the verification key becomes available to different parties is irrelevant; The key is only useful for verification, up to polynomial-time differences. In the context of SoWs, however, this time is of great importance. For example, allowing a party to learn the verification key, say, two days earlier than other parties, means that this party will be able to compute two days worth of signatures more than them. Hence, in contexts where counting the number of generated signatures matters, as is the case in blockchain protocols, great care should be taken on guaranteeing that the verification key is “fresh” enough for the relevant application.</p>

    <p class="text-gray-300">Our results. Our contributions are are as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Formalization of an SoW scheme. The syntax of an SoW scheme entails four algorithms: Public parameter generation, key generation, signing and verification—PPub, KeyGen, Sign and Verify, respectively. PPub is invoked on input <span class="math">1^{\\lambda}</span>, where <span class="math">\\lambda</span> is the security parameter, and outputs public security parameters <span class="math">pp</span>. KeyGen is invoked on input <span class="math">pp</span>, and outputs a random verification key <span class="math">vk</span>. Sign is invoked on input <span class="math">(pp,vk,msg,h)</span>, where <span class="math">msg</span> is the message to be signed, and <span class="math">h</span> is the hardness level of the signature generation. Expectedly, Verify is invoked on input <span class="math">(pp,vk,msg,h,\\sigma)</span>, where <span class="math">\\sigma</span> is (possibly) an output of Sign. We require a SoW scheme to be:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correct: As in the case of classical signatures, we require that signatures produced by Sign should be accepted by the Verify algorithm.</li>

      <li><span class="math">(t,\\alpha)</span>-Successful: This property lower-bounds the probability that an honest signer will successfully produce a SoW in a certain number of steps <span class="math">t</span>; <span class="math">\\alpha</span> is a function of the hardness level <span class="math">h</span>.</li>

      <li><span class="math">t</span>-Verifiable: The verifier should be able to verify a SoW in <span class="math">t</span> steps. (Typically, <span class="math">t</span> is a lot smaller than the time need to produce a signature.)</li>

      <li>Moderately Unforgeable against Tampering and Chosen-Message Attacks <span class="math">((\\beta,\\epsilon)</span>-MUTCMA): This property is akin to the property of existential unforgeability under chosen-message attacks of digital signatures (EU-CMA). It captures the fact that producing a sequence of SoWs, for chosen messages, does not provide an advantage to an adversary in terms of running time. Specifically, the chances to produce more than <span class="math">\\beta\\cdot t</span> SoWs in <span class="math">t</span> steps (for any <span class="math">t</span>) are less than <span class="math">\\epsilon</span>. Further, this should hold against an adversary able to tamper with the keys, and even in the presence of a Sign oracle.</li>

      <li>Run-time independent: This final property captures the setting where honest signers are potentially invoked on adversarial inputs and ensures that their running time enjoys some degree of independence. Specifically, the random variables defined as the running time of each Sign invocation is a set of almost independent random variables (cf. <em>[1]</em>). We stress that the adversarial signing algorithm may not satisfy this property.</li>

    </ul>

    <p class="text-gray-300">As a “sanity check,” we show in the full version of the paper that a SoW scheme can be easily designed and proven secure in the random oracle model (or by using <span class="math">\\mathcal{F}_{\\text{\\tiny TREE}}</span>), and hence in practice can be instantiated by a cryptographic hash function such as SHA-256.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consensus from SoW. Next, we design a consensus protocol for an honest majority of computational power that can be reduced to the SoW primitive above. The core idea behind our new protocol is as follows. First, the parties build a blockchain using SoWs in a way reminiscent of the Bitcoin blockchain. Using SoWs we show how to emulate the Bitcoin backbone protocol <em>[31]</em> by having parties compute a SoW in parallel, “on top” of the current view that incorporates the largest number of SoWs, i.e., the longest chain. However, in contrast with the consensus protocol of <em>[31]</em>, to generate a block, the parties include not only their input to the consensus protocol, but also the headers of “orphan” blocks that exist in forks stemming off their main chain and which have not been included so far, where the header of a block contains the hash of the previous block in the chain, the signature, the input to the consensus protocol, and a hash of the block’s contents.</li>

    </ol>

    <p class="text-gray-300">Using this mechanism, as shown in Figure 1, we prove that it is possible to reconstruct the whole tree of block headers from the blockchain contents, and thus in this way preserve all block headers produced by the honest parties. This ensures that the resulting ledger will reflect the number of parties and hence a consensus protocol may now be easily reduced to this blockchain protocol.</p>

    <p class="text-gray-300">Our new consensus protocol relying on the SoW primitive in the setting where no PKI is available, exemplifies the contrast with consensus in the classical setting, relying on standard signatures and a PKI setup <em>[22]</em> (cf. <em>[29]</em>). It is worth noting that the only known blockchain-based provably secure and optimally resilient consensus protocol is given in <em>[31]</em>, using a technique called “2-for-1 PoW” where two PoW-based protocols can be run concurrently and create a blockchain where the number of honest-party contributions is proportional to their actual number, but which relies on the strong independence property of the RO model, discussed earlier, in a fundamental way. Indeed, in the RO model, each witness for a PoW can be rearranged in a certain way so as to obtain a test for a witness for another PoW in a way that is independent from the first solution. Our new protocol gets rid of</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The data structure maintained by the consensus protocol. Block  <span class="math">F</span>  has consensus input 1, and includes the headers of blocks  <span class="math">D</span>  and  <span class="math">G</span> , with input 1 and 0, respectively. Block  <span class="math">D</span>  includes the headers of invalid blocks. This is not a problem, since any chain that contains  <span class="math">D</span>  will be invalid and not selected by any party, while  <span class="math">D</span> 's consensus input is correctly counted as a valid block header.</p>

    <p class="text-gray-300">this need. The only other (non-blockchain) PoW-based consensus protocol [3] also relies on the RO model.</p>

    <p class="text-gray-300">As intermediate steps in our analysis, we first introduce an appropriate adaptation of the model of [31] that allows for a standard model analysis and which may be of independent interest. We then recall the three basic properties of the blockchain data structure presented in [31]: (strong) common prefix, chain quality and chain growth, and show how our SoW-based blockchain protocol satisfies them assuming, beyond the security of SoW, standard collision resistance from the underlying hash function that is used to "glue" the blocks together. This is achieved as follows: We first prove that using the MU-TCMA property and assuming the adversarial hashing power is suitably bounded, it is unlikely in any sufficiently long time window for the adversary to exceed the number of SoWs of the honest parties. Then, using the  <span class="math">(t,\\alpha)</span> -Successful and  <span class="math">(\\beta ,\\epsilon)</span> -MU-TCMA properties in conjunction with run-time independence, we establish that summations of running times of successive Sign invocations have the variance needed to ensure that "uniquely successful rounds" (i.e., rounds where exactly one of the honest parties produces a SoW) happen with high density in any sufficiently long time window. Using these last two core results, and under suitable constraints for the basic SoW parameters  <span class="math">\\alpha ,\\beta ,\\epsilon ,h</span>  and number of parties  <span class="math">n</span> , we prove that the security of the Bitcoin backbone protocol implements a robust transaction ledger [31]. Further, and as a sanity check, in the full version of the paper, we argue that the results we get from our black-box analysis (and the RO-based SoW construction mentioned earlier), are similar to those from the random-oracle analysis of [31].</p>

    <p class="text-gray-300">Our analysis is carried out in the synchronous setting. It is relatively straightforward to extend our results to the  <span class="math">\\Delta</span> -synchronous setting of [47], by using the same techniques as in [30] (Section 7)]. We leave as an open question extending our results to the variable difficulty setting of [32].</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Other applications. In addition to the blockchain and consensus applications of SoW, we note that the security properties we put forth are suitable for the more traditional DDOS setting, with considerable advantages over existing approaches (cf. [54]). The problem is as follows: A server wants to protect itself from malicious actors in the network which send network packets to eat up its resources. The canonical defense for this attack is for the server to run a PoW challenge-response protocol with the sender, in order to make sending a message costly. The MU-TCMA property, we have defined, directly implies exactly this property in the strongest sense: For any, adaptively selected, set of messages sent, the adversary must consume computational resources proportional to the number of messages, even if it can also see SoWs sent by other parties. Moreover, this process can be made non-interactive by delegating the generation of the verification key to some public randomness service, e.g., the NIST beacon, and only accept messages that include a SoW with respect to this key. Finally, note that the same security guarantees can be easily extended to multiple servers who use the same</li>

    </ol>

    <p class="text-gray-300">beacon, by requiring that the sent messages contain some unique identification string.</p>

    <p class="text-gray-300">Prior and related work. We have already mentioned above relevant related work regarding classical and blockchain-based consensus protocols. For a more exhaustive recent survey, refer to <em>[29]</em>. We also note that the focus of the paper is the original consensus problem <em>[48, 42]</em>, and not so-called “ledger consensus” (sometimes referred to as “Nakamoto consensus”), which is an instance of the state machine replication problem <em>[51]</em>; see also <em>[29]</em> for an overview of such protocols. The idea of referencing off-chain blocks has been considered early on in the ledger consensus literature (see, e.g., <em>[43, 53, 52, 14]</em>) as a way to obtain fairness, better throughput and faster confirmation times. Our novelty is that we leverage this technique along with the new SoW notion to build a provably secure consensus protocol, which, unlike prior results, is not based on the “2-for-1 PoW” technique described earlier.</p>

    <p class="text-gray-300">There have been a number of attempts to formalize a proof of work (PoW) primitive that it is also sufficient to imply the security of a blockchain protocol. Nevertheless, such works were either informal <em>[6, 50, 37]</em>, or they did not produce a correctness proof for a blockchain or consensus protocol, focusing instead on other applications <em>[16, 2, 17, 8, 35]</em>. We proceed to give a partial list of such considerations.</p>

    <p class="text-gray-300">In <em>[35]</em>, Garay et al. study the necessary hardness condition that the underlying computational problem should satisfy in order for Bitcoin to implement a public ledger. In contrast to our work, an enhanced version of that security notion is shown to be sufficient to implement a public ledger against an adversary controlling only 1/3 (as opposed to 1/2) of the computational power. Further, it is unclear whether such notion can be used to solve the original consensus problem.</p>

    <p class="text-gray-300">Another effort to formalize an intermediate PoW-like building block for the Bitcoin protocol was made in <em>[47]</em>. The proposed ideal functionality, <span class="math">\\mathcal{F}_{\\textsc{tree}}^{p}</span>, keeps track of a tree of messages, which both the honest parties and the adversary can extend with probability <span class="math">p</span>. The outcome of each such trial is independent of the others, even if it is made by the adversary. <span class="math">\\mathcal{F}_{\\textsc{tree}}^{p}</span> satisfies the strong independence property mentioned before, and hence it is not suitable for the goals of this paper. Moreover, we note that any protocol instantiating this functionality must necessarily be <em>interactive</em>, as two parties can use <span class="math">\\mathcal{F}_{\\textsc{tree}}^{p}</span> to communicate at least one bit. Finally, in <em>[47]</em>, it was shown how to implement a transaction ledger, but not how to achieve consensus; the techniques introduced in this paper can be adapted to implement a consensus protocol using <span class="math">\\mathcal{F}_{\\textsc{tree}}</span>.</p>

    <p class="text-gray-300">Another relevant work, is that of Back et al. <em>[6]</em> and of Poelstra <em>[50]</em>, where the concept of “dynamic membership multi-party signatures” (DMMS) is proposed to describe the underlying primitive used in Bitcoin. The author of the latter work also argues the security of Bitcoin, based on a DMMS scheme. While the properties described there bear some similarities to our work, the treatment is not formal.</p>

    <p class="text-gray-300">Another related work, is that of Dwork and Naor <em>[25]</em>, which considered PoWs under the term “pricing functions,” as a means of protection against spam e-mail. The main properties discussed in their work are amortization resistance, “moderate hardness” and the existence of trapdoors (“shortcuts” in their terms). Interestingly, among the three constructions described there, one of them is a partially “broken” signature scheme, i.e., while it is hard for an attacker to obtain the signing key, it is moderately hard to forge signatures.</p>

    <p class="text-gray-300">In a different direction, Juels and Jacobsson <em>[37]</em> and Back <em>[4, 5]</em> use PoWs to construct electronic payment systems. In <em>[37]</em>, the authors consider the following properties: Amortization resistance, fast verification, and some special “useful work” property which states that generating a PoW for some scheme may help in generating a PoW for another scheme. As acknowledged by the authors themselves, the definitions they provide are only sketches. In <em>[4, 5]</em> another set of closely related properties is considered, including amortization and “trapdoor-freeness.” Amortization refers to the ability to combine PoWs of lesser difficulty in order to construct PoWs of greater difficulty. “Trapdoor-freeness” dictates that the party which generates the initial parameters of the scheme should not be able to also generate a trapdoor regarding these parameters. Again the approach is not rigorous.</p>

    <p class="text-gray-300">Bitansky et al. <em>[16]</em> construct time-lock puzzles as well as PoW schemes from randomized encod</p>

    <p class="text-gray-300">ings. Since the focus of their work is time-lock puzzles, the properties of PoW schemes—amortization resistance, moderate hardness and fast verification—are only briefly investigated, although they do instantiate a PoW scheme based on randomized encodings and the existence of non-amortizing languages in the worst case.</p>

    <p class="text-gray-300">Another interesting approach is that of Ball et al. <em>[8]</em>, who construct a PoW from worst case assumptions. They base the security of their PoW system on the worst case hardness of classical complexity theory problems, e.g., the Orthogonal Vectors problem. As many of the previously mentioned works, they also adopt a proof-system view in their security definitions.</p>

    <p class="text-gray-300">In <em>[2]</em>, Alwen and Tackmann study moderately hard functions (MoHF), providing simulation based definitions for what they call “non-interactive proofs of effort” (niPoE), which—as explicitly acknowledged by the authors—cannot be used to analyze Bitcoin. The main impediment is that the adversary can only invoke the same MoHF only once per protocol session, while for the Bitcoin protocol multiple invocations of the same MoHF should be allowed.</p>

    <p class="text-gray-300">Another related moderately hard (albeit in a sequential manner) primitive is the recently introduced notion of Verifiable Delay Functions (VDF) <em>[17]</em>. However, while the authors explicitly mention the encoding of messages using the primitive, the provided security definitions do not capture CMA security, a property which is necessary in a concurrent multi-party setting.</p>

    <p class="text-gray-300">Summary of differences with a previous version <em>[34]</em>. The most important difference of this version of the paper from <em>[34]</em> is the introduction of the notion of SoW, replacing the Proof of Work (PoW) notion. Moreover, many proofs have been rewritten in a clearer fashion, and the properties required from the underlying computational primitive have been simplified. Finally, additional related work regarding consensus protocols has been added.</p>

    <p class="text-gray-300">Organization of the paper. The basic computational model, definitions and cryptographic building blocks used by our constructions are presented in Section 2. Formal definition of the SoW primitive and its security properties are presented in Section 3. Section 4 is dedicated to applications of SoW: First, we introduce an appropriate model for our applications (Section 4.1). We then analyze the Bitcoin backbone protocol based on (and reducing its security to) SoW (Section 4.2), followed by the new blockchain-based consensus protocol (Section 4.3). Further, and as a “sanity check,” in Section 5 we show how to implement SoW in the RO model, or using <span class="math">\\mathcal{F}_{\\text{\\tiny TREE}}</span>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we introduce basic notation and definitions that are used in the rest of the paper. For <span class="math">k\\in\\mathbb{N}^{+}</span>, <span class="math">[k]</span> denotes the set <span class="math">\\{1,\\ldots,k\\}</span>. For strings <span class="math">x,z</span>, $x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z<span class="math"> is the concatenation of </span>x<span class="math"> and </span>z<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the length of </span>x<span class="math">. We denote sequences by </span>(a_{i})_{i\\in I}<span class="math">, where </span>I<span class="math"> is the index set. For a set </span>X<span class="math">, </span>x\\leftarrow X<span class="math"> denotes sampling a uniform element from </span>X<span class="math">. For a distribution </span>\\mathcal{U}<span class="math"> over a set </span>X<span class="math">, </span>x\\leftarrow\\mathcal{U}<span class="math"> denotes sampling an element of </span>X<span class="math"> according to </span>\\mathcal{U}<span class="math">. By </span>\\mathcal{U}_{\\lambda}<span class="math"> we denote the uniform distribution over </span>\\{0,1\\}^{\\lambda}<span class="math">. We denote the statistical distance between two random variables </span>X,Z<span class="math"> with range </span>\\mathcal{U}<span class="math"> by </span>\\Delta[X,Y]<span class="math">, i.e., </span>\\Delta[X,Z]=\\frac{1}{2}\\sum_{v\\in\\mathcal{U}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X=v]-\\Pr[Z=v]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For </span>\\epsilon>0<span class="math">, we say that </span>X,Y<span class="math"> are </span>\\epsilon<span class="math">-close when </span>\\Delta(X,Y)\\leq\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We let <span class="math">\\lambda</span> denote the security parameter. In this paper we will follow a more concrete (“exact”) approach <em>[12, 9, 36, 15]</em> to security evaluation rather than an asymptotic one. We will use functions <span class="math">t,\\epsilon</span>, whose ranges are <span class="math">\\mathbb{N},\\mathbb{R}</span>, respectively, and have possibly many different arguments, to denote concrete bounds on the running time (number of steps) and probability of adversarial success of an algorithm in some fixed computational model, respectively. When we speak about running time this will include the execution time plus the length of the code (cf. <em>[15]</em>; note also that we will be considering uniform machines). We will always assume that <span class="math">t</span> is a polynomial in the security parameter <span class="math">\\lambda</span>, although we will sometimes omit this dependency for brevity.</p>

    <p class="text-gray-300">Instead of using interactive Turing machines (ITMs) as the underlying model of distributed computation, we will use (interactive) RAMs. The reason is that we need a model where subroutine access and simulation do not incur a significant overhead. ITMs are not suitable for this purpose, since one needs to account for the additional steps to go back-and-forth all the way to the place where the subroutine is stored. A similar choice was made by Garay et al. <em>[36]</em>; refer to <em>[36]</em> for details on using interactive RAMs in a UC-like framework, as well as to Section 4.1. Given a RAM <span class="math">M</span>, we will denote by <span class="math">\\mathsf{Steps}_{M}(1^{\\lambda},x)</span> the random variable that corresponds to the number of steps of <span class="math">M</span> given as input the security parameter <span class="math">1^{\\lambda}</span> and <span class="math">x</span>. We will say that <span class="math">M</span> is <span class="math">t</span>-bounded if it holds that <span class="math">\\Pr[\\mathsf{Steps}_{M}(1^{\\lambda},x)\\leq t(\\lambda)]=1</span>.</p>

    <p class="text-gray-300">Finally, we remark that in our analyses there will be asymptotic terms of the form <span class="math">\\mathsf{negl}(\\lambda)</span> and concrete terms; throughout the paper, we will assume that <span class="math">\\lambda</span> is large enough to render the asymptotic terms insignificant compared to the concrete terms.</p>

    <p class="text-gray-300">Cryptographic hash functions. We will make use of the following notion of security for cryptographic hash functions:</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}=\\{\\{H_{k}:M(\\lambda)\\to Y(\\lambda)\\}_{k\\in K(\\lambda)}\\}_{\\lambda\\in\\mathbb{N}}</span> be a hash-function family, and <span class="math">\\mathcal{A}</span> be a PPT adversary. Then <span class="math">\\mathcal{H}</span> is <em>collision resistant</em> if and only if for any <span class="math">\\lambda\\in\\mathbb{N}</span> and corresponding <span class="math">\\{H_{k}\\}_{k\\in K}</span> in <span class="math">\\mathcal{H}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[k\\leftarrow K;(m,m^{\\prime})\\leftarrow\\mathcal{A}(1^{\\lambda},k);(m\\neq m^{\\prime})\\wedge(H_{k}(m)=H_{k}(m^{\\prime}))]\\leq\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Robust public transaction ledgers. The notion of a <em>public transaction ledger</em> was introduced in <em>[31]</em> to describe the functionality implemented by the Bitcoin protocol. It is defined with respect to a set of valid ledgers <span class="math">\\mathcal{L}</span> and a set of valid transactions <span class="math">\\mathcal{T}</span>, each one possessing an efficient membership test. A ledger <span class="math">\\mathbf{x}\\in\\mathcal{L}</span> is a vector of sequences of transactions <span class="math">\\mathrm{tx}\\in\\mathcal{T}</span>. Ledgers correspond to chains in the Bitcoin protocol. It is possible for the adversary to create two transactions that are conflicting; valid ledgers must not contain conflicting transaction. Moreover, it is assumed that in the protocol execution there also exists an oracle <span class="math">\\mathsf{Txgen}</span> that generates valid transactions, and is unambiguous, i.e., the adversary cannot create transactions that come in ‘conflict’ with the transactions generated by the oracle. A transaction is called <em>neutral</em> if there does not exist any transactions that comes in conflict with it.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> implements a <em>robust public transaction ledger</em> if it organizes the ledger as a chain of blocks of transactions and satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Persistence: Parameterized by <span class="math">k\\in\\mathbb{N}</span> (the “depth” parameter), if in a certain round an honest player reports a ledger that contains a transaction <span class="math">\\mathrm{tx}</span> in a block more than <span class="math">k</span> blocks away from the end of the ledger, then <span class="math">\\mathrm{tx}</span> will always be reported in the same position in the ledger by any honest player from this round on.</li>

      <li>Liveness: Parameterized by <span class="math">u,k\\in\\mathbb{N}</span> (the “wait time” and “depth” parameters, resp.), provided that a transaction either (i) issued by <span class="math">\\mathsf{Txgen}</span>, or (ii) is neutral, is given as input to all honest players continuously for <span class="math">u</span> consecutive rounds, then all honest parties will report this transaction at a block more than <span class="math">k</span> blocks from the end of the ledger.</li>

    </ul>

    <p class="text-gray-300">The consensus problem. Next, we give the definition of the well-known consensus problem (a.k.a. Byzantine agreement) <em>[48, 42]</em>. There are <span class="math">n</span> parties, <span class="math">t&lt;n</span> of which might be corrupted, taking an initial input <span class="math">x\\in V</span> (without loss of generality, we can assume <span class="math">V=\\{0,1\\}</span>).</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> solves the consensus problem provided it satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Agreement. All honest parties will output the same value eventually.</li>

      <li>Validity. If all the honest parties have the same input, then they all output this value.</li>

    </ul>

    <p class="text-gray-300">3 Signatures of Work</p>

    <p class="text-gray-300">The main goal of this paper is to implement consensus in the permissionless setting without relying on the strong independence property of the underlying computational resource. Towards that goal, in this section we introduce the signature of work (SoW) primitive. At a high level, a SoW enables one party to convince others that she has invested some computational power during some specific time interval and with respect to a “message.” Next, we formalize this notion and present its desired security properties.</p>

    <p class="text-gray-300">SoW syntax. Given a security parameter <span class="math">\\lambda</span>, let <span class="math">PP</span> be the public parameter space, <span class="math">HP\\subseteq\\mathbb{N}</span> the hardness parameter space, <span class="math">K</span> the key space, <span class="math">M</span> the message space, and <span class="math">S</span> the signature space. With foresight, the role of the key is to provide “freshness” for the signature computation, thus certifying that the signature was computed in the given time interval.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">A SoW scheme consists of four algorithms <span class="math">\\mathsf{SoW}=(\\mathsf{PPub},\\mathsf{KeyGen},\\mathsf{Sign},\\mathsf{Verify})</span>, where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PPub}(1^{\\lambda})</span> is a randomized algorithm that takes as input the security parameter <span class="math">\\lambda</span>, and returns a set of public parameters <span class="math">pp\\in PP</span>.</li>

      <li><span class="math">\\mathsf{KeyGen}(pp)</span> is a randomized algorithm that takes as input the public parameters <span class="math">pp</span>, and returns a key <span class="math">vk\\in K</span>. (See Remark 1 below on the role of keys in <span class="math">\\mathsf{SoW}</span> schemes.)</li>

      <li><span class="math">\\mathsf{Sign}(pp,vk,msg,h)</span> is a randomized algorithm that takes as input public parameters <span class="math">pp\\in PP</span>, a key <span class="math">vk\\in K</span>, a message <span class="math">msg\\in M</span> and hardness parameter <span class="math">h\\in HP</span>, and returns a signature (of work) <span class="math">\\sigma\\in S</span>.</li>

      <li><span class="math">\\mathsf{Verify}(pp,vk,msg,h,\\sigma)</span> is a deterministic algorithm that takes as input public parameters <span class="math">pp\\in PP</span>, a key <span class="math">vk\\in K</span>, message <span class="math">msg\\in M</span>, hardness parameter <span class="math">h\\in HP</span> and a signature <span class="math">\\sigma\\in S</span>, and returns <span class="math">\\mathsf{true}</span> or <span class="math">\\mathsf{false}</span> to indicate the validity of the signature.</li>

    </ul>

    <h6 id="sec-9" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">SoW schemes only have a public verification key. The role of this key is to guarantee that the computational work spent in order to create a signature of work is “fresh,” i.e., executed during a specific time interval (say, from the time the key became known to the signer). In contrast, classical digital signatures also have a secret key that serves as a trapdoor to compute signatures. In the applications we consider, the existence of trapdoor information is not meaningful, and in fact may hurt the security of the respective constructions.</p>

    <p class="text-gray-300">Security properties. Next, we present a number of security properties that we will require SoW schemes to satisfy. We start with the correctness property.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">We say that a SoW scheme is correct if for every <span class="math">\\lambda\\in\\mathbb{N},pp\\in PP,vk\\in K,h\\in HP</span>, and <span class="math">msg\\in M</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}\\mathsf{Verify}(pp,vk,msg,h,\\mathsf{Sign}(pp,vk,msg,h))=\\mathsf{true}\\quad\\big{]}\\geq 1-\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Next, we require that the time to verify a signature be upper bounded.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">We say that a SoW scheme is <span class="math">t</span>-verifiable, if <span class="math">\\mathsf{Verify}</span> takes time at most <span class="math">t</span> (on all inputs).</p>

    <p class="text-gray-300">Next, we capture the case of a malicious signer (resp., verifier) in the context of SoWs. In the first case, the adversary’s objective is to compute a number of signatures a lot faster than an honest signer would, while in the second case it is to make the honest signer take too much time to generate a signature.</p>

    <p class="text-gray-300">We deal with malicious signers first. We put forth an attack that we will use to express a class of adversaries that attempt to forge signatures faster than expected. Intuitively, this constitutes an attack against an honest verifier that may be trying to gauge a certain measure using the number</p>

    <p class="text-gray-300">of signatures. The game defining the attack is shown in Figure 2; we call the corresponding security property Moderate Unforgeability against Tampering and Chosen Message Attack (MU-TCMA). As in the security definitions of standard signatures (e.g., EU-CMA), we allow the adversary to have access to a signing oracle <span class="math">\\mathcal{S}</span>. Every time the oracle is queried, we assume that it runs the <span class="math">\\mathsf{Sign}</span> procedure with uniformly sampled randomness. A subtle point in the modeling of security in the presence of such oracle is that <span class="math">\\mathcal{S}</span> should also “leak” the number of steps it took for a query to be processed. In an actual execution while interacting with honest parties that are producing signatures, time is a side channel that may influence the adversarial strategy; in order to preserve the dependency on this side channel we will require from <span class="math">\\mathcal{S}</span> to leak this information. We note that in the classical signatures literature, timing attacks have also been a serious consideration <em>[41]</em>.</p>

    <p class="text-gray-300">In addition, we require that the key used by the adversary to construct signatures be fresh, i.e., we want to avoid situations where the adversary outputs signatures that he has precomputed a long time ago. We model this by providing the fresh key after the adversary has finished running his precomputation phase. Further, we allow the adversary to tamper with the key by manipulating it via tampering functions belonging to a family of functions <span class="math">\\mathcal{F}</span>.</p>

    <p class="text-gray-300">Looking ahead, the tampering function in our applications will be related to a keyed hash function, where the key of the hash is part of a common random string (CRS). Hence, we choose to model functions in <span class="math">\\mathcal{F}</span> to have two inputs: <span class="math">\\Sigma</span> (the CRS) and <span class="math">vk</span>. Moreover, the output of the adversary is deemed invalid if he tampers <span class="math">vk</span> with functions <span class="math">f_{1},f_{2}</span> in such a way that <span class="math">f_{1}(\\Sigma,vk)=f_{2}(\\Sigma,vk)</span>. Otherwise, the adversary could launch a generic attack that is unrelated to the <span class="math">\\mathsf{SoW}</span> scheme, and produce signatures at twice the rate of an honest signer, as follows. The adversary first finds <span class="math">f_{1},f_{2}</span> that have this property, and then computes signatures using the tampered key <span class="math">f_{1}(\\Sigma,vk)</span>. The trick is that each of them will also correspond to a signature with key <span class="math">f_{2}(\\Sigma,vk)</span>. Hence, he effectively can double the rate at which he produces signatures.</p>

    <p class="text-gray-300">Formally, the adversary will have access to <span class="math">\\mathcal{S}(\\cdot,\\cdot)</span>, an SoW oracle that on input <span class="math">(vk^{\\prime},msg)</span>, where <span class="math">vk^{\\prime}\\in K</span> and <span class="math">msg\\in M</span>, returns the pair <span class="math">(\\sigma,t)</span> where <span class="math">\\sigma</span> is the output of <span class="math">\\mathsf{Sign}(pp,vk^{\\prime},msg,h)</span> and <span class="math">t</span> is the number of steps taken by the <span class="math">\\mathsf{Sign}</span> algorithm on these parameters. Function <span class="math">\\mathsf{Asked}(vk^{\\prime},msg,\\sigma)</span> is true if <span class="math">\\sigma</span> was the response of <span class="math">\\mathcal{S}</span> to some query <span class="math">(vk^{\\prime},msg)</span>.</p>

    <p class="text-gray-300">We are now ready to formulate the security property of Moderate Unforgeability against Tampering and Chosen Message Attacks (MU-TCMA). It has two parameters, <span class="math">\\beta</span> and <span class="math">\\epsilon</span>, and, informally, it states that no adversary <span class="math">\\mathcal{A}</span> exists in the experiment of Figure 2 that takes at most <span class="math">t</span> steps after receiving key <span class="math">vk</span> and produces <span class="math">\\ell\\geq\\beta\\cdot t</span> signatures with probability better than <span class="math">\\epsilon</span>. Note that in total we allow <span class="math">\\mathcal{A}</span> to take any polynomial number of steps, i.e., the adversary is allowed to execute a precomputation stage that permits it to obtain an arbitrary number of signatures before learning <span class="math">vk</span>. In the definition below, we allow <span class="math">\\beta</span> to depend on the hardness level <span class="math">h</span>, and <span class="math">\\epsilon</span> on <span class="math">h,t</span> and <span class="math">q_{\\mathcal{S}}</span>, the number of queries the adversary makes to the signing oracle.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}=\\{F_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span>, where <span class="math">F_{\\lambda}</span> is a family of functions <span class="math">f:\\{0,1\\}^{\\lambda}\\times K\\to K</span>. A SoW scheme is <span class="math">(\\beta,\\epsilon)</span>-Moderately Unforgeable against Tampering and Chosen-Message Attacks (MU-TCMA) with respect to tampering function class <span class="math">\\mathcal{F}</span>, if for any polynomially large <span class="math">t_{1},t_{2}</span>, any adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span>, where <span class="math">\\mathcal{A}_{1}</span> is <span class="math">t_{1}</span>-bounded and <span class="math">\\mathcal{A}_{2}</span> is <span class="math">t_{2}</span>-bounded and makes at most <span class="math">q_{\\mathcal{S}}</span> queries to oracle <span class="math">\\mathcal{S}</span>, for any <span class="math">\\lambda\\in\\mathbb{N}</span>, and any <span class="math">h\\in HP</span>, the probability of <span class="math">\\mathcal{A}</span> winning in <span class="math">\\mathsf{Exp}^{\\text{MU-TCMA}}_{\\mathcal{A},\\mathcal{F}}(1^{\\lambda},h,\\lfloor\\beta(h)\\cdot t_{2}\\rfloor)</span> (Figure 2) is less than <span class="math">\\epsilon(h,t_{2},q_{\\mathcal{S}})</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">As mentioned in Section 1, unlike previous unforgeability definitions (e.g, <em>[12]</em>), Definition 7 is parameterized by the rate at which the adversary can produce signatures, instead of the number of steps it needs to compute one, which is more appropriate for the moderate unforgeability game where the adversary tries to produce multiple signatures.</p>

    <p class="text-gray-300">|  ExpMU-TCMA(1λ,h,ℓ)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">st←A1(1λ,Σ,pp);</td>

            <td class="px-3 py-2 border-b border-gray-700">(Precomputation)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">vk←KeyGen(pp);</td>

            <td class="px-3 py-2 border-b border-gray-700">(Verification key)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(fi,msg_i,σi)i∈[ℓ]←A2S(·,·)(1λ,vk,st);</td>

            <td class="px-3 py-2 border-b border-gray-700">(SoW computation)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  return Λℓi=1(Verify(pp, fi(Σ,vk), msg_i, σi) ∧ ¬Asked(fi(Σ,vk), msg_i, σi) ∧ (fi∈Fλ) ∧ (∀j∈[ℓ]: fi(Σ,vk) = fj(Σ,vk) ⇒ i = j) |   |</p>

    <p class="text-gray-300">Figure 2: The Moderate Unforgeability against Tampering and Chosen-Message Attack (MU-TCMA) experiment for a SoW scheme.</p>

    <p class="text-gray-300">In the MU-TCMA definition we are going to consider tampering functions classes that at the very least preserve the unpredictability of  <span class="math">vk</span> . Otherwise, the adversary can generically attack any SoW scheme by predicting the tampered key and precomputing signatures. Formally, we will say that  <span class="math">\\mathcal{F}</span>  is computationally unpredictable if the adversary, given the CRS  <span class="math">\\Sigma</span> , cannot guess a value  <span class="math">y</span>  that he will be able to "hit" when he gains access to  <span class="math">vk</span>  through some  <span class="math">f \\in \\mathcal{F}</span> .</p>

    <p class="text-gray-300">Definition 8. Let  <span class="math">\\mathcal{F} = \\{F_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span> , where  <span class="math">F_{\\lambda}</span>  is a family of functions  <span class="math">f: \\{0,1\\}^{\\lambda} \\times K \\to K</span> . We say that  <span class="math">\\mathcal{F}</span>  is computationally unpredictable with respect to a SoW scheme SoW, if for any PPT RAM  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , and for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\substack{pp\\gets \\mathsf{PPub}(1^{\\lambda});\\\\ vk\\gets \\mathsf{KeyGen}(pp);\\\\ \\Sigma \\gets \\mathcal{U}_{\\lambda}}}\\left[ \\begin{array}{l}(st,y)\\gets \\mathcal{A}_{1}(1^{\\lambda},\\Sigma ,pp);f\\gets \\mathcal{A}_{2}(1^{\\lambda},st,vk):\\\\ f\\in F_{\\lambda}\\wedge f(\\Sigma ,vk) = y \\end{array} \\right]\\leq \\mathsf{negl}(\\lambda).</span></div>

    <p class="text-gray-300">Next, we consider the case of attacking an honest signer. Attacking an honest signer amounts to finding a certain set of keys over which the honest signer algorithm fails to produce SoWs sufficiently fast and regularly. We say that a SoW scheme is  <span class="math">(t,\\alpha)</span> -successful when the probability that the signer computes a signature in  <span class="math">t</span>  steps is at least  <span class="math">\\alpha</span> .</p>

    <p class="text-gray-300">Definition 9. We say that SoW scheme is  <span class="math">(t,\\alpha)</span> -successful if for any  <span class="math">\\lambda \\in \\mathbb{N}</span>  and any  <span class="math">h\\in HP</span> , it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\substack{pp\\gets \\mathsf{PPub}(1^{\\lambda});\\\\ vk\\gets \\mathsf{KeyGen}(pp);\\\\ msg\\gets M}}\\left[\\mathsf{Steps}_{\\mathsf{Sign}}(pp,vk,msg,h)\\leq t\\right]\\geq \\alpha (h).</span></div>

    <p class="text-gray-300">Finally, in the same corrupt-verifier setting, we will require the signing time of honest signers to have some (limited) independence, which will be important for the applications we have in mind. This property, in combination with the efficiency and MU-TCMA properties, will prove crucial in ensuring that when multiple signers work together, the distribution of the number of them who succeed in producing a signature has some "good" variance and concentration properties.</p>

    <p class="text-gray-300">Definition 10. We say that a SoW scheme has almost-independent runtime iff for any polynomial  <span class="math">p(\\cdot)</span> , any  <span class="math">\\lambda \\in \\mathbb{N}</span> , any  <span class="math">h \\in HP</span> , there exists a set of mutually independent random variables  <span class="math">\\{Y_i\\}_{i \\in [p(\\lambda)]}</span>  such that for any  <span class="math">pp \\in PP, ((vk_i, m_i))_{i \\in [p(\\lambda)]} \\in (K \\times M)^{p(\\lambda)}</span>  it holds that  <span class="math">\\Delta[(\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_i, m_i, h))_i, (Y_i)_i] \\leq \\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Independence assumptions. As mentioned earlier, MU-TCMA does not enforce any independence assumption, and only bounds the probability that the rate at which the adversary computes SoWs is high. In contrast, the independent-routine property does so, but only for honest signers. We remark</p>

    <p class="text-gray-300">that achieving such property is considerably easier for the honest case, as we can be sure that signers will use independently sampled coins if instructed; a guarantee that we cannot have for the adversary.</p>

    <p class="text-gray-300">Parameters’ range. Let SoW be a scheme that is <span class="math">(t_{\\sf sign},\\alpha)</span>-Successful. SoW trivially satisfies the MU-TCMA property for <span class="math">\\beta(h)&gt;1</span>, since the adversary does not have enough time to output the signatures it has computed. On the other hand, assuming <span class="math">\\epsilon(h,t,q_{\\mathcal{S}})</span> is a negligible function of <span class="math">t</span>, <span class="math">\\alpha(h)</span> must be smaller than <span class="math">\\beta(h)\\cdot t_{\\sf sign}</span>, otherwise the expected number of SoWs computed by the Sign function would exceed that allowed by the MU-TCMA property. Hence, for optimal security, it should hold that <span class="math">\\alpha(h)</span> is close to <span class="math">\\beta(h)\\cdot t_{\\sf sign}</span>.</p>

    <p class="text-gray-300">Next, we turn to applications of our SoW primitive.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Applications</h2>

    <p class="text-gray-300">In this section we showcase applications of SoWs, the first one being implementing robust transaction ledgers: Using our primitive and standard properties of the underlying hash function, we establish the security of the Bitcoin backbone protocol <em>[31]</em>. The second application is realizing consensus in the permisionless setting: We construct a new blockchain-based consensus protocol for an honest majority provably secure under the same assumptions as above, thus providing a blockchain counterpart to the classical result in the cryptographic setting with a trusted (PKI) setup <em>[22]</em>.</p>

    <p class="text-gray-300">In both applications we assume the existence of a SoW scheme with the security properties defined bellow.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Assumption 1 (SoW Assumption).</h6>

    <p class="text-gray-300">For parameters <span class="math">\\beta,\\epsilon,t^{\\prime}_{\\mathcal{H}},\\alpha</span> and <span class="math">t_{\\sf ver}</span> we assume that <span class="math">\\mathsf{SoW}=(\\mathsf{PPub},\\mathsf{KeyGen},\\mathsf{Sign},\\mathsf{Verify})</span> is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correct;</li>

      <li><span class="math">(\\beta,\\epsilon)</span>-MU-TCMA with respect to any computationally unpredictable tampering function class (cf. Definition 8);</li>

      <li><span class="math">(t^{\\prime}_{\\mathcal{H}},\\alpha)</span>-successful;</li>

      <li>almost run-time independent; and</li>

      <li><span class="math">t_{\\sf ver}</span>-verifiable,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\epsilon(h,t,q_{\\mathcal{S}})\\in\\mathsf{negl}(\\beta(h)\\cdot t)</span>. Moreover, we assume that the parameter spaces <span class="math">K,M,S</span> of the scheme are equal to $\\{0,1\\}^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\{0,1\\}^{*},\\{0,1\\}^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For a SoW scheme to be used in the context of the Bitcoin protocol, choosing <span class="math">K,M,S</span> as above is important due to the underlying hash-chain structure of the blockchain: The hash of each block acts as a key of the SoW scheme, thus the output of the hash function should match the key space of the SoW.</p>

    <p class="text-gray-300">We start with some pertinent details about the model that the two applications mentioned above will be analyzed under.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.1 The Permissionless Model, Revisited</h3>

    <p class="text-gray-300">All the security models proposed for the analysis of PoW-based blockchain protocols <em>[31, 47]</em> rely on bounding the number of queries to an idealized functionality to model limited computational resources. In contrast, we do not wish to restrict the way the adversary accesses the computational resource, and thus we model limited computational resources in a more general manner, i.e., by limiting the exact number of steps parties take. Next, we present a revised version of the model of <em>[31]</em> that captures our considerations.</p>

    <p class="text-gray-300">For the reasons explained in Section 2, we substitute IRAMs for ITMs. The execution of a protocol <span class="math">\\Pi</span> is driven by an “environment” program <span class="math">\\mathcal{Z}</span> that may spawn multiple instances running the protocol <span class="math">\\Pi</span> . The programs in question can be thought of as “interactive RAMs” communicating through registers in a well-defined manner, with instances and their spawning at the discretion of a control program which is also an IRAM and is denoted by <span class="math">C</span>. In particular, the control program <span class="math">C</span> forces the environment to perform a “round-robin” participant execution sequence for a fixed set of parties.</p>

    <p class="text-gray-300">Specifically, the execution driven by <span class="math">\\mathcal{Z}</span> is defined with respect to a protocol <span class="math">\\Pi</span>, an adversary <span class="math">\\mathcal{A}</span> (also an IRAM) and a set of parties <span class="math">P_{1},...,P_{n}</span>; these are hardcoded in the control program <span class="math">C</span>. The protocol <span class="math">\\Pi</span> is defined in a “hybrid” setting and has access to one “ideal functionality,” called the diffusion channel (see below). It is used as subroutine by the programs involved in the execution (the IRAMs of <span class="math">\\Pi</span> and <span class="math">\\mathcal{A}</span>) and is accessible by all parties once they are spawned.</p>

    <p class="text-gray-300">Initially, the environment <span class="math">\\mathcal{Z}</span> is restricted by <span class="math">C</span> to spawn the adversary <span class="math">\\mathcal{A}</span>. Each time the adversary is activated, it may communicate with <span class="math">C</span> via messages of the form (Corrupt, <span class="math">P_{i}</span>). The control program <span class="math">C</span> will register party <span class="math">P_{i}</span> as corrupted, only provided that the environment has previously given an input of the form (Corrupt, <span class="math">P_{i}</span>) to <span class="math">\\mathcal{A}</span> and that the number of corrupted parties is less or equal <span class="math">t</span>, a bound that is also hardcoded in <span class="math">\\mathcal{C}</span>. The first party to be spawned running protocol <span class="math">\\Pi</span> is restricted by <span class="math">C</span> to be party <span class="math">P_{1}</span>. After a party <span class="math">P_{i}</span> is activated, the environment is restricted to activate party <span class="math">P_{i+1}</span> , except when <span class="math">P_{n}</span> is activated in which case the next party to be activated is always the adversary <span class="math">\\mathcal{A}</span>. Note that when a corrupted party <span class="math">P_{i}</span> is activated the adversary <span class="math">\\mathcal{A}</span> is activated instead.</p>

    <p class="text-gray-300">Next, we describe how different parties communicate. Initially, the diffusion functionality sets the variable round to be 1. It also maintains a Receive() string defined for each party <span class="math">P_{i}</span>. A party is allowed at any moment to fetch the messages sent to it at the previous round that are contained in its personal Receive() string. Moreover, when the functionality receives an instruction to diffuse a message <span class="math">m</span> from party <span class="math">P_{i}</span> it marks the party as complete for the current round and forwards the message to the adversary; note that <span class="math">m</span> is allowed to be empty. At any moment, the adversary <span class="math">\\mathcal{A}</span> is allowed to specify the contents of the Receive() string for each party <span class="math">P_{i}</span>. The adversary has to specify when it is complete for the current round. When all parties are complete for the current round, the functionality inspects the contents of all Receive() strings and includes any messages that were diffused by the parties in the current round but not contributed by the adversary to the Receive() tapes. The variable round is then incremented.</p>

    <p class="text-gray-300">Based on the above, we denote by <span class="math">\\{\\textsc{view}^{P,t,n}_{\\Pi,\\mathcal{A},\\mathcal{Z}}(z)\\}_{z\\in\\{0,1\\}^{*}}</span> the random variable ensemble that corresponds to the view of party <span class="math">P</span> at the end of an execution where <span class="math">\\mathcal{Z}</span> takes <span class="math">z</span> as input. We will consider stand-alone executions, hence <span class="math">z</span> will always be of the form <span class="math">1^{\\lambda}</span>, for <span class="math">\\lambda\\in\\mathbb{N}</span>. For simplicity, to denote this random variable ensemble we will use <span class="math">\\textsc{view}^{P,t,n}_{\\Pi,\\mathcal{A},\\mathcal{Z}}</span>. By <span class="math">\\textsc{view}^{t,n}_{\\Pi,\\mathcal{A},\\mathcal{Z}}</span> we denote the concatenation of the views of all parties. The probability space where these variables are defined depends on the coins of all honest parties, <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span>.</p>

    <p class="text-gray-300">Next, we consider the complications in the modeling due to the analysis of Bitcoin in the concrete security setting. Both in <em>[31]</em> and <em>[47]</em> a modified version of the standard simulation-based paradigm of <em>[19]</em> is followed, where there exist both a malicious environment and a malicious adversary. In addition, the SoW scheme (called PoW in <em>[31, 47]</em>) is modeled in a non black-box way using a random oracle (RO), and the computational power of the adversary is then bounded by limiting the number of queries it can make to the RO per round. Since in this work the SoW scheme is modeled in a black-box way, an alternative approach to bound the adversary’s power is needed.</p>

    <p class="text-gray-300">A naïve first approach is to only bound the computational power of <span class="math">\\mathcal{A}</span>. Unfortunately this will not work for several reasons. Firstly, nothing stops the environment from aiding the adversary, i.e., computing signatures, and then communicating with it through their communication channel or some other subliminal channel. Secondly, even if we bound the total number of steps of <span class="math">\\mathcal{A}</span>, it is not clear how to bound the steps it is taking per round in the model of <em>[19]</em>, which we build on. Lastly, another issue arising is that if the adversary is able to send, say, <span class="math">\\theta</span> messages in each round, it can force each</p>

    <p class="text-gray-300">honest party to take <span class="math">\\theta \\cdot t_{\\mathrm{ver}}</span> extra steps per round. If we don't bound <span class="math">\\theta</span>, then the adversary will be able to launch a DOS attack and spend all the resources the honest parties have⁵.</p>

    <p class="text-gray-300">In order to capture these considerations we are going to define a predicate on executions and prove our properties in disjunction with this predicate, i.e., either the property holds or the execution is not good.</p>

    <p class="text-gray-300"><strong>Definition 11.</strong> Let <span class="math">(t_{\\mathcal{A}},\\theta)</span>-good be a predicate defined on executions in the hybrid setting described above. Then <span class="math">\\mathsf{E}</span> is <span class="math">(t_{\\mathcal{A}},\\theta)</span>-good, where <span class="math">\\mathsf{E}</span> is one such execution, if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the total number of steps taken by <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span> per round is no more than <span class="math">t_{\\mathcal{A}}</span>;</li>

      <li>the adversary sends at most <span class="math">\\theta</span> messages per round.</li>

    </ul>

    <p class="text-gray-300">Finally, we assume the existence of a common reference string (CRS), that becomes available to all parties at the start of the execution. This is also implicitly assumed in previous models, where either parties have access to a special "genesis" block at the beginning of the execution [47], or they do not have access to the RO before the beginning of the execution [31].</p>

    <p class="text-gray-300"><strong>Definition 12.</strong> Given a predicate <span class="math">Q</span> and bounds <span class="math">t_{\\mathcal{A}}, \\theta, t, n \\in \\mathbb{N}</span>, with <span class="math">t &amp;lt; n</span>, we say that protocol <span class="math">\\Pi</span> satisfies property <span class="math">Q</span> for <span class="math">n</span> parties assuming the number of corruptions is bounded by <span class="math">t</span>, provided that for all PPT <span class="math">\\mathcal{Z}, \\mathcal{A}</span>, the probability that <span class="math">Q(\\mathrm{view}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n})</span> is false and the execution is <span class="math">(t_{\\mathcal{A}}, \\theta)</span>-good is negligible in <span class="math">\\lambda</span>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4.2 Public Transaction Ledger from Signatures of Work</h2>

    <p class="text-gray-300">Next, we take a reduction approach to the underlying cryptographic primitive—SoW, as defined in Section 3—to prove the security of the Bitcoin backbone protocol [31]. We start with a description of the protocol based on SoW, and then continue with the security proof.</p>

    <h2 id="sec-18" class="text-2xl font-bold">4.2.1 The Bitcoin backbone protocol.</h2>

    <p class="text-gray-300">The Bitcoin backbone protocol [31], parameterized by functions <span class="math">\\mathrm{V}(\\cdot), \\mathrm{R}(\\cdot), \\mathrm{I}(\\cdot)</span>, is an abstraction of the Bitcoin protocol. First, we introduce some notation needed to understand the description of the algorithms, and then cast the protocol making use of our SoW primitive.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will use the terms block and chain to refer to tuples of the form <span class="math">\\langle s, x, \\sigma \\rangle</span> and sequences of such tuples, respectively. The rightmost (resp. leftmost) block of chain <span class="math">\\mathcal{C}</span> is denoted by <span class="math">\\mathrm{head}(\\mathcal{C})</span> (resp. <span class="math">\\mathrm{tail}(\\mathcal{C})</span>). Each block contains a seed, data, and a signature denoted by <span class="math">s, x, \\sigma</span>, respectively. As mentioned, all parties have access to a CRS at the beginning of the execution that contains: the public parameter <span class="math">pp</span> of the SoW scheme, a verification key <span class="math">vk</span> generated by <span class="math">\\mathrm{KeyGen}(pp)</span>, and the key <span class="math">k</span> of the hash functions <span class="math">H, G</span> used later. We will refer to $\\langle 0^{\\lambda}, pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k, 0^{\\lambda} \\rangle<span class="math"> as the genesis block </span>B_{\\mathrm{Gen}}<span class="math">. A chain </span>\\mathcal{C} = B_1 \\ldots B_m<span class="math"> is valid with respect to the CRS if and only if (i) </span>B_1<span class="math"> is the genesis block, (ii) for any two consecutive blocks </span>\\langle s_i, x_i, \\sigma_i \\rangle, \\langle s_{i+1}, x_{i+1}, \\sigma_{i+1} \\rangle<span class="math"> it holds that </span>H_k(s_i, G_k(x_i), \\sigma_i) = s_{i+1}<span class="math">, (iii) each block, besides </span>B_{\\mathrm{Gen}}<span class="math">, contains a valid SoW, i.e., </span>\\mathrm{Verify}(pp, s_i, x_i, \\sigma_i) = \\mathrm{true}<span class="math">, and (iv) the content validation predicate </span>\\mathrm{V}(\\langle x_1, \\ldots, x_m \\rangle)<span class="math"> outputs true. We call </span>H_k(s_i, G_k(x_i), \\sigma_i)<span class="math"> the hash of block </span>B_i<span class="math"> and denote it by </span>H_k(B_i)<span class="math">. Moreover, we define </span>H(\\mathcal{C})<span class="math"> to be equal to the hash of the head of chain </span>\\mathcal{C}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At each round, each party chooses the longest valid chain amongst the ones it has received and tries to extend it by computing (mining) another valid block. If it succeeds, it diffuses the new block to the network. In more detail, each party will run the Sign procedure, with the message parameter being determined by the input contribution function <span class="math">\\mathrm{I}(\\cdot)</span>, and the key parameter being the hash of the</p>

    <p class="text-gray-300">⁵This problem is extensively discussed in [3], Section 3.4.</p>

    <p class="text-gray-300">⁶The adversary cannot use the running time of honest parties that it has corrupted; it is activated instead of them during their turn. Also, note that it is possible to compute this number by counting the number of configurations that <span class="math">\\mathcal{A}</span> or <span class="math">\\mathcal{Z}</span> are activated per round.</p>

    <p class="text-gray-300">last block. We assume that the hardness parameter  <span class="math">h</span>  is fixed for all executions. Finally, if the party is queried by the environment, it outputs  <span class="math">\\mathrm{R}(\\mathcal{C})</span>  where  <span class="math">\\mathcal{C}</span>  is the chain selected by the party; the chain reading function  <span class="math">\\mathrm{R}(\\cdot)</span>  interprets  <span class="math">\\mathcal{C}</span>  differently depending on the higher-level application running on top of the backbone protocol. Each honest party runs for at most  <span class="math">t_{\\mathcal{H}}</span>  steps per round. We summarize the modifications with respect to the original [31] protocol: In Algorithm 1 (signature of work function) the Sign function of the underlying SoW scheme is invoked for a limited number of steps so that the total number of steps of the invoking party does not exceed the  <span class="math">t_{\\mathcal{H}}</span>  bound per round; in Algorithm 2 (chain validation predicate) the Verify predicate is replaced with a call to the Verify algorithm of the SoW scheme; and in Algorithm 3 (backbone protocol) we assume that the honest parties start the execution with a "genesis" block. We leave Algorithm 4 intact.</p>

    <p class="text-gray-300">Algorithm 1 The signature of work function, parameterized by  <span class="math">pp, h</span>  and hash functions  <span class="math">H(\\cdot), G(\\cdot)</span> . The input is  <span class="math">(x, \\mathcal{C})</span> .</p>

    <pre><code class="language-latex">1: function sow(x, C)
2:  $s \\gets H(\\text{head}(\\mathcal{C}))$
3:  $\\sigma \\gets \\text{Sign}(pp, s, x, h)$
4:  $B \\gets \\varepsilon$
5: if  $\\sigma \\neq \\bot$  then
6:  $B \\gets \\langle s, x, \\sigma \\rangle$
7: end if
8:  $\\mathcal{C} \\gets \\mathcal{C}B$
9: return C
10: end function</code></pre>

    <p class="text-gray-300">Algorithm 2 The chain validation predicate, parameterized by  <span class="math">pp,h,B_{\\mathrm{Gen}}</span> , the hash functions  <span class="math">G(\\cdot),H(\\cdot)</span> , and the input validation predicate  <span class="math">V(\\cdot)</span> . The input is  <span class="math">\\mathcal{C}</span> .</p>

    <pre><code class="language-latex">1: function validate  $(\\mathcal{C})$
2:  $b\\gets \\mathrm{V}(\\mathbf{x}_{\\mathcal{C}})\\wedge (\\mathrm{tail}(\\mathcal{C}) = B_{\\mathrm{Gen}})$ $\\triangleright$  xC describes the contents of chain C.
3: if  $b =$  True then  $\\triangleright$  The chain is non-empty and meaningful w.r.t.  $V(\\cdot)$
4:  $s^{\\prime}\\gets H(\\mathrm{head}(\\mathcal{C}))$
5: while  $(\\mathcal{C}\\neq B_{\\mathrm{Gen}})\\wedge (b = \\mathrm{True})$  do
6:  $\\langle s,x,\\sigma \\rangle \\leftarrow \\mathrm{head}(\\mathcal{C})$
7: if Verify  $(pp,s,x,h,\\sigma)\\wedge (H(\\mathrm{head}(\\mathcal{C})) = s^{\\prime})$  then
8:  $s^{\\prime}\\gets s$ $\\triangleright$  Retain hash value
9:  $\\mathcal{C}\\gets \\mathcal{C}^{\\lceil 1}$ $\\triangleright$  Remove the head from C
10: else
11:  $b\\gets$  False
12: end if
13: end while
14: end if
15: return (b)
16: end function</code></pre>

    <p class="text-gray-300">In order to turn the backbone protocol into a protocol realizing a public transaction ledger suitable definitions were given for functions  <span class="math">\\mathrm{V}(\\cdot), \\mathrm{R}(\\cdot), \\mathrm{I}(\\cdot)</span>  in [31]. We change these definitions slightly as shown in Table 1, to ensure two things: Firstly, that the data contained in the hash chain is encoded with</p>

    <p class="text-gray-300">|  Algorithm 3 The Bitcoin backbone protocol, parameterized by the input contribution function I(·) and the chain reading function R(·).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2: st← ε |   |</p>

    <p class="text-gray-300">|  3: round← 0 |   |</p>

    <p class="text-gray-300">|  4: while TRUE do |   |</p>

    <p class="text-gray-300">|  5: C← maxvalid(C, any chain C' found in RECEIVE()) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: ⟨st, x⟩← I(st, C, round, INPUT(), RECEIVE())</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Determine the x-value.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7: Cnew← sow(x, C) |   |</p>

    <p class="text-gray-300">|  8: if C ≠ Cnew then |   |</p>

    <p class="text-gray-300">|  9: C← Cnew |   |</p>

    <p class="text-gray-300">|  10: BROADCAST(C) |   |</p>

    <p class="text-gray-300">|  11: end if |   |</p>

    <p class="text-gray-300">|  12: round← round + 1 |   |</p>

    <p class="text-gray-300">|  13: if INPUT() contains READ then |   |</p>

    <p class="text-gray-300">|  14: write R(xC) to OUTPUT() |   |</p>

    <p class="text-gray-300">|  15: end if |   |</p>

    <p class="text-gray-300">|  16: end while |   |</p>

    <p class="text-gray-300">|  Algorithm 4 The function that finds the “best” chain, parameterized by function max(·). The input is {C1, ..., Ck}.  |   |</p>

    <p class="text-gray-300">|  1: function maxvalid(C1, ..., Ck) |   |</p>

    <p class="text-gray-300">|  2: temp← ε |   |</p>

    <p class="text-gray-300">|  3: for i = 1 to k do |   |</p>

    <p class="text-gray-300">|  4: if validate(Ci) then |   |</p>

    <p class="text-gray-300">|  5: temp← max(C, temp) |   |</p>

    <p class="text-gray-300">|  6: end if |   |</p>

    <p class="text-gray-300">|  7: end for |   |</p>

    <p class="text-gray-300">|  8: return temp |   |</p>

    <p class="text-gray-300">|  9: end function |   |</p>

    <p class="text-gray-300">a suffix-free code; this is important to ensure that no collisions occur [10] as we show later. And, secondly, to ensure that any block created by an honest party contains sufficient entropy, thus the adversary will not be able to use blocks that it has precomputed to extend this block. We call the resulting protocol  <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{SoW}}</span> .</p>

    <p class="text-gray-300">A number of desired basic properties for the blockchain were introduced in [31, 40, 47]. At a high level, the first property, called common prefix, has to do with the existence, as well as persistence in time, of a common prefix of blocks among the chains of honest players. Here we will consider a stronger variant of the property, presented in [47], which allows for the black-box proof of application-level properties (such as the persistence of transactions entered in a public transaction ledger built on top of the Bitcoin backbone).</p>

    <p class="text-gray-300">We will use  <span class="math">\\mathcal{C} \\preceq \\mathcal{C}&#x27;</span>  to denote that some chain  <span class="math">\\mathcal{C}</span>  is a prefix of some other chain  <span class="math">\\mathcal{C}&#x27;</span> , and  <span class="math">\\mathcal{C}^{\\lceil k \\rceil}</span>  to denote the chain resulting from removing the last  <span class="math">k</span>  blocks of  <span class="math">\\mathcal{C}</span> . We will call a block honest, if it was</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Content validation pre-dicate V(·)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(·) is true if its input ⟨x1, ...,xm⟩ is a valid ledger, i.e., it is in L, and each xi starts with a neutral transaction of the form r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i, where r is a string of length log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and i is the “height” of the respective block.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Chain reading function R(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">R(·) returns the contents of the chain if they constitute a valid ledger, otherwise it is undefined.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Input contribution function I(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">I(·) returns the largest subsequence of transactions in the input and receive registers that constitute a valid ledger, with respect to the contents of the chain</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">the party already has, preceded by a neutral transaction of the form KeyGen(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: The instantiation of functions  <span class="math">\\mathrm{I}\\left( \\cdot \\right) ,\\mathrm{V}\\left( \\cdot \\right) ,\\mathrm{R}\\left( \\cdot \\right)</span>  for protocol  <span class="math">{\\Pi }_{\\mathrm{{PL}}}^{\\mathrm{{SoW}}}</span>  .</p>

    <p class="text-gray-300">diffused for the first time in the execution by some honest party, and adversarial otherwise.</p>

    <p class="text-gray-300">Definition 13 ((Strong) Common Prefix). The strong common prefix property  <span class="math">Q_{\\mathsf{cp}}</span>  with parameter  <span class="math">k \\in \\mathbb{N}</span>  states that the chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  reported by two, not necessarily distinct honest parties  <span class="math">P_1, P_2</span> , at rounds  <span class="math">r_1, r_2</span>  in  <span class="math">\\mathrm{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n}</span> , with  <span class="math">r_1 \\leq r_2</span> , satisfy  <span class="math">\\mathcal{C}_1^{\\lceil k \\rceil} \\preceq \\mathcal{C}_2</span> .</p>

    <p class="text-gray-300">The next property relates to the proportion of honest blocks in any portion of some honest player's chain.</p>

    <p class="text-gray-300">Definition 14 (Chain Quality). The chain quality property  <span class="math">Q_{\\mathrm{cq}}</span>  with parameters  <span class="math">\\mu \\in \\mathbb{R}</span>  and  <span class="math">k \\in \\mathbb{N}</span>  states that for any honest party  <span class="math">P</span>  with chain  <span class="math">\\mathcal{C}</span>  in  <span class="math">\\mathrm{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n}</span>  it holds that for any  <span class="math">k</span>  consecutive blocks of  <span class="math">\\mathcal{C}</span>  the ratio of adversarial blocks is at most  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300">Further, in the derivations in [31] an important lemma was established relating to the rate at which the chains of honest players were increasing as the Bitcoin backbone protocol was run. This was explicitly considered in [40] as a property under the name chain growth.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 15 (Chain Growth). The chain growth property  <span class="math">Q_{\\mathrm{cg}}</span>  with parameters  <span class="math">\\tau \\in \\mathcal{R}</span>  (the "chain speed" coefficient) and  <span class="math">s, r_0 \\in \\mathbb{N}</span>  states that for any round  <span class="math">r &amp;gt; r_0</span> , where honest party  <span class="math">P</span>  has chain  <span class="math">\\mathcal{C}_1</span>  at round  <span class="math">r</span>  and chain  <span class="math">\\mathcal{C}_2</span>  at round  <span class="math">r + s</span>  in  <span class="math">\\mathrm{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{t,n}</span> , it holds that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\tau \\cdot s$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now prove that  <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{SoW}}</span>  implements a robust public transaction ledger (Definition 2), assuming the underlying SoW scheme satisfies Assumption 1 for appropriate parameters, related to the running time of honest parties and the adversary. First, we formalize this relation.</p>

    <p class="text-gray-300">Let  <span class="math">t_{\\mathsf{bb}}</span>  (bb for backbone) be an upper bound on the number of steps needed to run the code of an honest party in one round, besides the Sign and Verify calls. By carefully analyzing the backbone protocol one can extract an upper bound on this value. To aid our presentation, we will use  <span class="math">t_{\\mathcal{A}}&#x27;</span>  and  <span class="math">t_{\\mathcal{H}}&#x27;</span>  to denote: (i) the time needed by a RAM machine to simulate one round in the execution of the Bitcoin protocol, without taking into account calls made to the Sign routine by the honest parties, and (ii) the minimum number of steps that an honest party takes running the Sign routine per round, respectively.</p>

    <div class="my-4 text-center"><span class="math-block">t _ {\\mathcal {A}} ^ {\\prime} = t _ {\\mathcal {A}} + n \\cdot t _ {\\mathrm {b b}} + \\theta t _ {\\mathrm {v e r}} \\quad \\text {a n d} \\quad t _ {\\mathcal {H}} ^ {\\prime} = t _ {\\mathcal {H}} - t _ {\\mathrm {b b}} - \\theta t _ {\\mathrm {v e r}}</span></div>

    <p class="text-gray-300">It holds that at least <span class="math">n-t</span> (non-corrupted) parties will run the <span class="math">\\mathsf{Sign}</span> routine for at least <span class="math">t_{\\mathcal{H}}^{\\prime}</span> steps at every round.</p>

    <p class="text-gray-300">In previous works <em>[31, 33, 47]</em>, the security assumptions regarding the computational power of the parties participating in the protocol were twofold: (1) The total running time of honest parties per round should exceed that of the adversary, and (2) the rate at which parties produce blocks at each round should be bounded. More realistically, in our approach the running time of the adversary and the running time of honest parties do not have the same <em>quality</em>, as the adversary may use a superior signing algorithm. To take this into account, we additionally need to assume that the efficiency of the adversarial signing algorithm, i.e., <span class="math">\\beta</span>, is close to that of the honest parties. Finally, note that if SoW is close to optimal, i.e., <span class="math">\\alpha(h)\\approx\\beta t_{\\mathcal{H}}^{\\prime}</span>, and the block generation rate is a lot less than <span class="math">1</span>, our assumption holds as long as the honest parties control the majority of the computational power.</p>

    <p class="text-gray-300">We now state the computational power assumption formally. The second and the third conditions are similar to the ones already found in previous works, while the first one is the new condition we introduce regarding the underlying computational primitive.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Assumption 2 (Computational Power Assumption).</h6>

    <p class="text-gray-300">There exist <span class="math">\\delta_{\\mathsf{SoW}},\\delta_{\\mathsf{Steps}},\\delta\\in(0,1)</span>, such that for sufficiently large <span class="math">\\lambda\\in\\mathbb{N}</span>, there exists an <span class="math">h\\in HP</span>, such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\alpha(h)\\geq(1-\\delta_{\\mathsf{SoW}})\\beta t_{\\mathcal{H}}^{\\prime}&gt;\\mathsf{negl}(\\lambda)</span> (signatures generation rate gap)</li>

      <li><span class="math">(n-t)t_{\\mathcal{H}}^{\\prime}(1-\\delta_{\\mathsf{Steps}})\\geq t_{\\mathcal{A}}^{\\prime}</span> (steps gap)</li>

      <li><span class="math">\\frac{\\delta_{\\mathsf{Steps}}-\\delta_{\\mathsf{SoW}}}{2}\\geq\\delta&gt;\\beta(h)(t_{\\mathcal{A}}^{\\prime}+nt_{\\mathcal{H}})</span> (bounded block generation rate)</li>

    </ul>

    <p class="text-gray-300">From now on, we will assume that the hardness parameter used in our protocols, is one satisfying the above conditions.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">The better the adversarial signing algorithm may be compared to the honest one, the closer <span class="math">\\delta_{\\mathsf{SoW}}</span> is to <span class="math">0</span>, while the closer the number of adversarial steps <span class="math">t_{\\mathcal{A}}^{\\prime}</span> are to that of the honest parties, the closer <span class="math">\\delta_{\\mathsf{Steps}}</span> is to <span class="math">0</span>. Assumption 2 implies, in a quantitative manner, that the better the adversarial signing algorithm, the smaller the computational power of the adversary we can tolerate.</p>

    <p class="text-gray-300">We introduce some additional notation. For each round <span class="math">j</span>, we define the Boolean random variables <span class="math">X_{j}</span> and <span class="math">Y_{j}</span> as follows. Let <span class="math">X_{j}=1</span> if and only if <span class="math">j</span> was a <em>successful round</em>, i.e., at least one honest party computed a SoW at round <span class="math">j</span>, and let <span class="math">Y_{j}=1</span> if and only if <span class="math">j</span> was a <em>uniquely successful round</em>, i.e., exactly one honest party computed a SoW at round <span class="math">j</span>. With respect to a set of rounds <span class="math">S</span>, let <span class="math">X(S)=\\sum_{j\\in S}X_{j}</span> and define <span class="math">Y(S)</span> similarly. Moreover, with respect to some block <span class="math">B</span> computed by an honest party <span class="math">P</span> at some round <span class="math">r</span>, let <span class="math">Z_{B}(S)</span> denote the number of distinct blocks broadcast by the adversary during <span class="math">S</span> that have <span class="math">B</span> as their ancestor. Define <span class="math">X_{B}(S)</span> similarly.</p>

    <p class="text-gray-300">Next, we focus on the hash functions used by Bitcoin, and the necessary security assumptions to avoid cycles in the blockchains. First, note that in the actual implementation of Bitcoin an unkeyed hash function is used, namely, a double invocation of SHA-256. In previous analyses of the protocol this was modeled as a random oracle. We choose to model it in a strictly weaker way, as a keyed hash function family:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{H}=\\{H_{k}:\\{0,1\\}^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\lambda+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\to\\{0,1\\}^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}_{k\\in K^{\\prime}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">that is <em>collision resistant</em> (Definition 1); the CRS we have already assumed will contain the key of our hash function. Moreover, as depicted in Figure 3, the protocol makes use of another hash function <span class="math">G</span> to compress the input <span class="math">x</span> of each block, which may be of arbitrary size. In our analysis we will require <span class="math">G</span> to be collision resistant. It is well known (see, e.g., <em>[21, 10]</em>) that given a fixed-length collision-resistant hash function family, we can construct an arbitrary-length collision-resistant hash function family. To aid readability, we will sometimes omit the keys of both functions (as we already do in the description of the protocol). Furthermore, observe that the hash structure of any blockchain (depicted in Figure 3)</p>

    <p class="text-gray-300">is similar to the Merkle-Damgaard transform [21]:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{MD}_k(IV,(x_i)_{i\\in [m]}):z = IV;\\text{for} i = 1\\text{to} m\\text{do} z = H_k(z,x_i);\\text{return} z,</span></p>

    <p class="text-gray-300">where the fixed-length hash function family used is always assumed to be  <span class="math">\\mathcal{H}</span> . To show that the adversary cannot find distinct chains with the same hash, we are going to take advantage of the following property of the MD transform.</p>

    <p class="text-gray-300">Fact 1. For any non-empty valid chain  <span class="math">\\mathcal{C} = B_1, \\ldots, B_k</span> , where  <span class="math">B_i = \\langle s_i, x_i, \\sigma_i \\rangle</span> , it holds that for any  <span class="math">j \\in [k]</span> :  <span class="math">H_k(\\mathrm{head}(\\mathcal{C})) = \\mathsf{MD}_k(H_k(B_j), ((G_k(x_i), \\sigma_i))_{i \\in \\{j+1, \\ldots, k\\}})</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: The hash structure of the blocks in the Bitcoin protocol.</p>

    <p class="text-gray-300">Lemma 16. The probability that any PPT RAM  <span class="math">\\mathcal{A}</span>  can find two distinct valid chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  such that  <span class="math">H(\\mathcal{C}_1) = H(\\mathcal{C}_2)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  $\\mathcal{C}_1 = B_{\\mathrm{Gen}}, B_1, \\ldots, B_{[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}<span class="math"> ,  </span>\\mathcal{C}_2 = B_{\\mathrm{Gen}}, B_1', \\ldots, B_{[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}'<span class="math"> ,  </span>m_1 = ((G(x_i), \\sigma_i))_{i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}<span class="math">  and  </span>m_2 = ((G(x_i'), \\sigma_i'))_{i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}<span class="math"> . For the sake of contradiction, assume that the lemma does not hold and there exists an adversary  </span>\\mathcal{A}<span class="math">  that can find valid chains  </span>\\mathcal{C}_1, \\mathcal{C}_2<span class="math">  such that  </span>H(\\mathcal{C}_1) = H(\\mathcal{C}_2)<span class="math"> , with non-negligible probability. By Fact 1, this implies that  </span>\\mathsf{MD}(H(B_{\\mathrm{Gen}}), m_1) = \\mathsf{MD}(H(B_{\\mathrm{Gen}}), m_2)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  that breaks the collision resistance of  <span class="math">H</span>  also with non-negligible probability. We take two cases. In the first case,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Then, since the height of the chain is included in a fixed position in  </span>x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}'<span class="math">  (cf. Table 1), it follows that  </span>x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\neq x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}'<span class="math">  and with overwhelming probability  </span>G(x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) \\neq G(x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}')<span class="math"> , which in turn implies that  </span>B_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\neq B_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}'<span class="math"> . Since  </span>H(\\mathrm{head}(\\mathcal{C}_1)) = H(\\mathrm{head}(\\mathcal{C}_2))<span class="math"> , it follows that a collision in  </span>H<span class="math">  has been found. In the second case, where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , following the classical inductive argument for the MD transform, it can be shown that there exists  </span>\\ell<span class="math">  less or equal to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , such that  </span>\\mathsf{MD}(H(\\mathsf{Gen}), ((G(x_i), \\sigma_i))_{i \\in [\\ell]}) = \\mathsf{MD}(H(\\mathsf{Gen}), ((G(x_i'), \\sigma_i'))_{i \\in [\\ell]})<span class="math">  and  </span>(G(x_\\ell), \\sigma_\\ell) \\neq (G(x_\\ell'), \\sigma_\\ell')$ . The lemma follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following two properties, introduced in [31], regarding the way blocks are connected are implied by Lemma 16.</p>

    <p class="text-gray-300">Definition 17. An insertion occurs when, given a chain  <span class="math">\\mathcal{C}</span>  with two consecutive blocks  <span class="math">B</span>  and  <span class="math">B_0</span> , a block  <span class="math">B^<em></span>  created after  <span class="math">B_0</span>  is such that  <span class="math">B, B^</em></span> ,  <span class="math">B_0</span>  form three consecutive blocks of a valid chain. A copy occurs if the same block exists in two different positions.</p>

    <p class="text-gray-300">Corollary 18. Let  <span class="math">\\{H_k(\\cdot)\\}_{k\\in K}</span>  and  <span class="math">\\{G_k(\\cdot)\\}_{k\\in K}</span>  be collision-resistant hash functions. Then, no insertions and no copies occur with probability  <span class="math">1 - \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Next, we prove that the adversary cannot mine blocks that extend an honest block created recently at a very high rate with probability better than that of breaking the MU-TCMA property. For a summary of our notation we refer to Table 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security parameter</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n:</td>

            <td class="px-3 py-2 border-b border-gray-700">number of parties</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tH:</td>

            <td class="px-3 py-2 border-b border-gray-700">number of steps per round per honest party</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tA:</td>

            <td class="px-3 py-2 border-b border-gray-700">total number of adversarial steps per round</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">θ:</td>

            <td class="px-3 py-2 border-b border-gray-700">upper bound on the number of messages sent by the adversary per round</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β:</td>

            <td class="px-3 py-2 border-b border-gray-700">upper bound on SoW computation rate per step</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">γ:</td>

            <td class="px-3 py-2 border-b border-gray-700">lower bound on the rate of uniquely successful rounds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f:</td>

            <td class="px-3 py-2 border-b border-gray-700">lower bound on the rate of successful rounds</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ:</td>

            <td class="px-3 py-2 border-b border-gray-700">advantage from the Computational Power Assumption (Assumption 2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">k:</td>

            <td class="px-3 py-2 border-b border-gray-700">number of blocks for the common-prefix property</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l:</td>

            <td class="px-3 py-2 border-b border-gray-700">number of blocks for the chain-quality property</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: The parameters in our analysis.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 19. For any set of consecutive rounds  <span class="math">S</span>  and for any party  <span class="math">P</span> , the probability that  <span class="math">P</span>  mined some honest block  <span class="math">B</span>  at some round  <span class="math">i \\in S</span>  and  $Z_B(S) \\geq \\beta t_{\\mathcal{A}}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , is at most  </span>\\epsilon(h, t_{\\mathcal{A}}' \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, n \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. W.l.o.g., assume that  <span class="math">i</span>  is the first round of  $S = \\{i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i\\leq i' &lt; i + s\\}<span class="math"> , and let  </span>E<span class="math">  be the event where in  </span>\\mathrm{VIEW}_{\\Pi ,\\mathcal{A},\\mathcal{Z}}^{t,n}<span class="math">  the adversary has mined at least  </span>\\beta t_{\\mathcal{A}}^{\\prime}s<span class="math">  blocks until round  </span>i + s<span class="math">  that descend some honest block  </span>B<span class="math">  mined by party  </span>P<span class="math">  at round  </span>i<span class="math"> . For the sake of contradiction, assume that the lemma does not hold, and thus the probability that  </span>E<span class="math">  holds is greater than  </span>\\epsilon (h,t_{\\mathcal{A}}^{\\prime}\\cdot s,n\\cdot s)<span class="math"> . Using  </span>\\mathcal{A}<span class="math"> , we will construct an adversary  </span>\\mathcal{A}'<span class="math">  that wins the MU-TCMA game with probability greater than that.  </span>\\mathcal{A}'<span class="math">  is going to run internally  </span>\\mathcal{A}<span class="math">  and  </span>\\mathcal{Z}<span class="math"> , while at the same time perfectly simulating the view of honest parties using the signing oracle that he has in his disposal on the MU-TCMA game. This way, the view of  </span>\\mathcal{A},\\mathcal{Z}<span class="math">  will be indistinguishable both in the real and the simulated runs, and thus the probability that  </span>E$  happens will be the same in both cases.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are going to describe the two stages of  <span class="math">\\mathcal{A}&#x27;</span>  separately, i.e. before and after obtaining  <span class="math">vk</span> . First,  <span class="math">\\mathcal{A}_1&#x27;</span>  creates the genesis block and sets the fixed length hash key and the SoW public parameters to be  <span class="math">\\Sigma</span>  and  <span class="math">pp</span> , respectively. Then, he perfectly simulates honest parties up to round  <span class="math">i - 1</span>  and at the same time runs  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  in a black-box way. Finally, it outputs the contents of the registers of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  as variable  <span class="math">st</span> . He can do this since he has polynomial time on  <span class="math">\\lambda</span>  on his disposal. Note, that up until this point in the eyes of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  the simulated execution is indistinguishable compared to the real one.</p>

    <p class="text-gray-300">For the second stage,  <span class="math">\\mathcal{A}_2&#x27;</span> , is first going to use  <span class="math">st</span>  to reset  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  to the same state that they were. We assume that this can be done efficiently, e.g., by having  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  read from the registers where  <span class="math">st</span>  is stored whenever they perform some operation on their registers. Moreover, it is again going to simulate honest parties behavior, from round  <span class="math">i</span>  until round  <span class="math">i + s</span> , but in a different way. Instead of running the Sign algorithm for each non-corrupted honest party at every round, it makes a query to the signing oracle  <span class="math">\\mathcal{S}</span>  with the respective parameters. Then, it checks if the honest party succeeded in making a signature in this round by comparing the number of steps needed to make this signature to the number of steps available to the party at this round. Hence,  <span class="math">\\mathcal{A}_2&#x27;</span>  has to do  <span class="math">n</span>  queries to the signing oracle per round. The adversary can also send up to  <span class="math">\\theta</span>  messages per round to honest parties which they have to verify, thus inducing an additional  <span class="math">\\theta \\cdot t_{\\mathrm{ver}}</span>  overhead in the simulation. Note that  <span class="math">\\mathcal{A}_2&#x27;</span>  has to run the verification procedure only once per message.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Continuing with the description of  <span class="math">\\mathcal{A}_2&#x27;</span> , as shown in Figure 4, it takes as input a key  <span class="math">vk</span>  generated from  <span class="math">\\mathrm{KeyGen}(pp)</span> . We should somehow relate  <span class="math">vk</span>  to the blocks the internal adversary is going to produce. In our reduction, this is achieved by: (i) relating the block  <span class="math">B</span>  that party  <span class="math">P</span>  generates at round  <span class="math">i</span>  with  <span class="math">vk</span>  through the input contribution function  <span class="math">I(\\cdot)</span> , and (ii) by the fact that the seed of all blocks that have  <span class="math">B</span>  as an ancestor is related to  <span class="math">H(B)</span> . In more detail, at round  <span class="math">i</span> ,  <span class="math">\\mathcal{A}_2&#x27;</span>  will use  <span class="math">vk</span>  in the neutral transaction included in  <span class="math">I(\\cdot)</span>  for  <span class="math">P</span> ; denote by  $vk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_0<span class="math">  the output of  </span>I<span class="math">  for  </span>P$  at this round. If</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">P</span> is successful at this round and mines a block $B=\\langle s_{0},vk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{0},\\sigma_{0}\\rangle<span class="math"> (this can be simulated using </span>\\mathcal{S}<span class="math">), then any block </span>B^{\\prime}=\\langle s,x,\\sigma\\rangle<span class="math"> descending </span>B$ will be related to it as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">s</span> <span class="math">=\\mathsf{MD}(H_{\\Sigma}(B),((G_{\\Sigma}(x_{i}),\\sigma_{i}))_{i})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$=\\mathsf{MD}(H_{\\Sigma}(s,G_{\\Sigma}(vk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{0}),\\sigma_{0}),((G_{\\Sigma}(x_{i}),\\sigma_{i}))_{i})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\stackrel{{\\scriptstyle\\rm def}}{{=}}f_{(s,\\{x_{i},\\sigma_{i}\\}_{i})}(\\Sigma,vk)</span></p>

    <p class="text-gray-300">for some <span class="math">((x_{i},\\sigma_{i}))_{i}</span> due to Fact 1. Observe, that the seed of <span class="math">B^{\\prime}</span> is a function of <span class="math">\\Sigma</span> and <span class="math">vk</span>, as required by the MU-TCMA game. In fact the tampering function class we will consider is going to be exactly the set of all these functions <span class="math">f</span>. More formally, let <span class="math">C</span> be the set of sequences <span class="math">((x_{i},\\sigma_{i}))_{i}</span> that correspond to a valid chain in the way described before. Then, the tampering function class we will be considering is defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}=\\{f_{s,a}\\}_{s\\in\\{0,1\\}^{\\lambda},a\\in C}</span></p>

    <p class="text-gray-300">We show next, that <span class="math">\\mathcal{F}</span> is computationally unpredictable as required by our assumption regarding the signature scheme.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Claim 1.</h6>

    <p class="text-gray-300"><span class="math">\\mathcal{F}</span> is computationally unpredictable.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For the sake of contradiction, assume that there exists a PPT adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> that breaks the computational unpredictability property of <span class="math">\\mathcal{F}</span>. This implies that</p>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}pp\\leftarrow\\mathsf{PPub}(1^{\\lambda});\\\\ vk\\leftarrow\\mathsf{KeyGen}(pp);\\\\ \\Sigma\\leftarrow\\mathcal{U}_{\\lambda};\\end{subarray}}\\begin{bmatrix}(st,y)\\leftarrow\\mathcal{A}_{1}(\\Sigma,pp);\\\\ f\\leftarrow\\mathcal{A}_{2}(st,vk):\\\\ f\\in\\mathcal{F}\\wedge f(\\Sigma,vk)=y\\end{bmatrix} \\]</p>

    <p class="text-gray-300">is non-negligible. We are going to describe an adversary <span class="math">\\mathcal{A}^{\\prime}</span> that uses <span class="math">\\mathcal{A}</span> to break the collision resistance property of <span class="math">H</span>. Given <span class="math">\\Sigma</span>, <span class="math">\\mathcal{A}^{\\prime}</span> first runs <span class="math">\\mathcal{A}_{1}(\\Sigma,pp)</span> and obtains a prediction <span class="math">y</span> and state <span class="math">st</span>. Next, <span class="math">\\mathcal{A}^{\\prime}</span> randomly samples <span class="math">vk_{1},vk_{2}</span> using KeyGen and runs <span class="math">\\mathcal{A}_{2}</span> twice on inputs <span class="math">st,vk_{1}</span> and <span class="math">st,vk_{2}</span> respectively. By an application of the splitting lemma we can show that with non-negligible probability <span class="math">\\mathcal{A}_{2}</span> will output (not necessarily different) functions <span class="math">f_{1},f_{2}</span> such that <span class="math">y=f_{1}(\\Sigma,vk_{1})=f_{2}(\\Sigma,vk_{2})</span>. As noted earlier, this corresponds to the hash of two chains, that due to the entropy of <span class="math">vk_{1},vk_{2}</span> and the collision resistance of <span class="math">G</span> start with different honestly mined blocks. Using similar techniques as in Lemma 16, we can show that <span class="math">\\mathcal{A}^{\\prime}</span> can find a collision in <span class="math">H</span> using <span class="math">f_{1},f_{2},vk_{1},vk_{2}</span> with non-negligible probability in <span class="math">\\lambda</span>, which is a contradiction. <span class="math">\\dashv</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span> cannot distinguish between the bitcoin execution and the one we described above, <span class="math">E</span> will occur with probability at least <span class="math">\\epsilon(h,t^{\\prime}_{\\mathcal{A}}s,ns)</span>, i.e. <span class="math">\\mathcal{A}</span> will compute at least <span class="math">\\beta t^{\\prime}_{\\mathcal{A}}s</span> blocks starting from round <span class="math">i</span> and up to round <span class="math">i+s</span> that descend <span class="math">B</span>. Note, that these blocks are also valid signatures, whose keys are of the form <span class="math">f(\\Sigma,vk)</span>, for (possibly different) <span class="math">f</span>’s. Moreover, the event that the adversary outputs different <span class="math">f_{i},f_{j}</span> such that <span class="math">f_{i}(\\Sigma,vk)=f_{j}(\\Sigma,vk)</span>, corresponds to finding chains <span class="math">\\mathcal{C}_{1},\\mathcal{C}_{2}</span> such that <span class="math">H(\\mathcal{C}_{1})=H(\\mathcal{C}_{2})</span>. By Lemma 16, this happens with negligible probability. Hence, <span class="math">\\mathcal{A}^{\\prime}</span> will win the MU-TCMA game with respect to tampering function class <span class="math">\\mathcal{F}</span> with probability greater than <span class="math">\\epsilon(h,t^{\\prime}_{\\mathcal{A}}s,ns)</span>, while being <span class="math">s\\cdot(t_{\\mathcal{A}}+\\theta\\cdot t_{\\mathsf{ver}}+t_{\\mathsf{bb}}\\cdot n)=s\\cdot t^{\\prime}_{\\mathcal{A}}</span>-bounded and having made at most <span class="math">ns</span> queries to the signing oracle, which is a contradiction to our initial assumption. A sketch of the reduction is given at Figure 4.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">Note that we can do exactly the same reduction without using the oracle to simulate the signing procedure of the honest parties. Then, the total running time of the second stage of <span class="math">\\mathcal{A}^{\\prime}</span> is on the worst</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 4: The figure depicts a schematic of the reduction from the Bitcoin backbone to the MU-TCMA game of Lemma 19.</p>

    <p class="text-gray-300">case  <span class="math">s \\cdot (t_{\\mathcal{A}} + nt_{\\mathcal{H}})</span> -bounded and hence the probability he can win is  <span class="math">\\epsilon(h, s \\cdot (t_{\\mathcal{A}} + nt_{\\mathcal{H}}), 0)</span> . Hence, we can derive the following bound on the total number of blocks produced by both honest and malicious parties during a certain number of rounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 20. For any set of consecutive rounds  <span class="math">S</span>  and for any party  <span class="math">P</span> , the probability that  <span class="math">P</span>  mined some honest block  <span class="math">B</span>  at some round  <span class="math">i \\in S</span>  and  $Z_B(S) + X_B(S) \\geq \\beta (t_{\\mathcal{A}} + nt_{\\mathcal{H}}) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is less than  </span>\\epsilon(h,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (t_{\\mathcal{A}} + nt_{\\mathcal{H}}), 0)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we prove lower bounds on the rate of successful and uniquely successful rounds. Our proof crucially depends on the runtime independence property of the SoW scheme. More specifically, the property implies that for some set of rounds the sum of the Bernoulli random variables of the event that a round is uniquely successful, concentrate around the mean. Which in turn, implies that we can lower-bound the rate of uniquely successful rounds with good probability.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 21. Let  <span class="math">\\gamma = (n - t)\\cdot \\alpha (h)\\cdot (1 - \\beta t_{\\mathcal{H}})^{n - 1}</span> ,  <span class="math">f = (1 - (1 - \\alpha (h))^{n - t})</span> . For any set of consecutive rounds  <span class="math">S</span> , with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\frac{\\lambda}{\\gamma\\delta^2}<span class="math"> , the following two events occur with negligible probability in  </span>\\lambda$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The number of uniquely successful rounds in  <span class="math">S</span>  is less or equal to  $(1 - \\frac{\\delta}{4})\\gamma \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. For some fixed execution we will denote by the array  $\\mathbf{T}_{S\\times n} = (t_{i,j})\\in \\mathbb{N}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times n}<span class="math">  the number of steps each honest party takes running the Sign routine, for each round in the set  </span>S<span class="math"> . It holds that at most  </span>t<span class="math">  elements of each column are zero, i.e. corrupted, and the rest are lower bounded by  </span>t_\\mathcal{H}'<span class="math">  and upper bounded by  </span>t_\\mathcal{H}<span class="math"> . W.l.o.g let  </span>S = \\{1,\\dots ,s\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since this lemma talks about the steps taken by the Sign function, we are going to use the almost independent runtimes property of the SoW scheme, and do all the analysis on the independent random variable defined by this property. For the rest of this proof, unless explicitly stated, assume that the  <span class="math">\\mathsf{Steps}_{\\mathsf{Sign}}(pp,vk,m,h)</span>  random variable refers to its idealized independent version. We first buildup some notation to help in our analysis. For  <span class="math">pp\\in PP</span> , arrays  <span class="math">(vk_{i,j})\\in K^{s\\times n},(msg_{i,j})\\in M^{s\\times n}</span>  and for  <span class="math">h\\in \\mathbb{N}</span>  let:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>random variable  <span class="math">P_{i,j} = 1</span>  if  <span class="math">\\mathsf{Steps}_{\\mathsf{Sign}}(pp, vk_{i,j}, msg_{i,j}, h) \\leq t_{i,j}</span> , and 0 otherwise;</li>

      <li>random variable  <span class="math">Y_{i} = 1</span>  if  <span class="math">\\sum_{j=1}^{n} P_{i,j} = 1</span>  and 0 otherwise.</li>

      <li>random variable  <span class="math">X_{i} = 1</span>  if  <span class="math">\\sum_{j=1}^{n} P_{i,j} \\geq 1</span> , and 0 otherwise.</li>

      <li>random variable  <span class="math">Y = \\sum_{i\\in [s]}Y_{i}</span> ,  <span class="math">X = \\sum_{i\\in [s]}X_{i}</span> .</li>

    </ul>

    <p class="text-gray-300">It easily follows from the Successful property that <span class="math">\\operatorname<em>{Pr}[P_{i,j} = 1] \\geq \\alpha(h)</span>. Moreover, it holds that <span class="math">\\operatorname</em>{Pr}[P_{i,j} = 1] \\leq \\beta t_{\\mathcal{H}}</span>. Otherwise, the honest solving algorithm would produce signatures with a rate bigger than <span class="math">\\beta</span>, which contradicts the MU-TCMA property. Next, we show that the random variables we have defined are mutually independent.</p>

    <p class="text-gray-300"><strong>Claim 2.</strong> The random variable families <span class="math">(P_{i,j})_{i\\in [s],j\\in [n]}</span>, <span class="math">(Y_{i})_{i\\in [s]}</span>, <span class="math">(X_{i})_{i\\in [s]}</span> are mutually independent.</p>

    <p class="text-gray-300"><strong>Proof.</strong> First, notice that the runtime independence of the scheme implies independence of <span class="math">(P_{i,j})</span>. We will show this for two random variables and the extension to <span class="math">m</span> variables will be obvious. Let <span class="math">P_{1}, P_{2} \\in (P_{i,j})_{i,j}</span> and <span class="math">x_{1}, x_{2} \\in \\{0,1\\}</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ P _ {1} = x _ {1} \\wedge P _ {2} = x _ {2} \\right] = \\Pr \\left[ \\text{Steps}_{\\text{Sign}} \\left(p p, v k _ {1}, m _ {1}, h\\right) \\in S _ {1} \\wedge \\text{Steps}_{\\text{Sign}} \\left(p p, v k _ {2}, m _ {2}, h\\right) \\in S _ {2} \\right] \\\\ = \\sum_ {(s _ {1}, s _ {2}) \\in S _ {1} \\times S _ {2}} \\Pr \\left[ \\text{Steps}_{\\text{Sign}} (p p, v k _ {1}, m _ {1}, h) = s _ {1} \\wedge \\text{Steps}_{\\text{Sign}} (p p, v k _ {2}, m _ {2}, h) = s _ {2} \\right] \\\\ = \\sum_ {(s _ {1}, s _ {2}) \\in S _ {1} \\times S _ {2}} \\Pr \\left[ \\text{Steps}_{\\text{Sign}} (p p, v k _ {1}, m _ {1}, h) = s _ {1} \\right] \\cdot \\Pr \\left[ \\text{Steps}_{\\text{Sign}} (p p, v k _ {2}, m _ {2}, h) = s _ {2} \\right] \\\\ = \\sum_ {s _ {1} \\in S _ {1}} \\Pr \\left[ \\text{Steps}_{\\text{Sign}} (p p, v k _ {1}, m _ {1}, h) = s _ {1} \\right] \\cdot \\sum_ {s _ {2} \\in S _ {2}} \\Pr \\left[ \\text{Steps}_{\\text{Sign}} (p p, v k _ {2}, m _ {2}, h) = s _ {2} \\right] \\\\ = \\Pr \\left[ \\text{Steps}_{\\text{Sign}} \\left(p p, v k _ {1}, m _ {1}, h\\right) \\in S _ {1} \\right] \\cdot \\Pr \\left[ \\text{Steps}_{\\text{Sign}} \\left(p p, v k _ {2}, m _ {2}, h\\right) \\in S _ {2} \\right] \\\\ = \\Pr \\left[ P _ {1} = x _ {1} \\right] \\cdot \\Pr \\left[ P _ {2} = x _ {2} \\right] \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">S_{1}, S_{2}</span> are either <span class="math">[0, t]</span> or <span class="math">(t, \\infty)</span> depending on <span class="math">x_{1}, x_{2}</span>, and <span class="math">pp, vk_{1}, m_{1}, vk_{2}, m_{2}</span> are the parameters of the random processes. We use the independence property on the third line.</p>

    <p class="text-gray-300">Next, we prove the second point of the claim. Again, w.l.o.g we only show it for 2 random variables, <span class="math">Y_{1}, Y_{2}</span> and the extension to <span class="math">m</span> is obvious. Let <span class="math">y_{1}, y_{2} \\in \\{0,1\\}</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ Y _ {1} = y _ {1} \\wedge Y _ {2} = y _ {2} \\right] = \\Pr \\left[ \\sum_ {j \\in [ n ]} P _ {1, j} \\in S _ {1} \\wedge \\sum_ {j \\in [ n ]} P _ {2, j} \\in S _ {2} \\right] \\\\ = \\sum_ {(s _ {1}, s _ {2}) \\in S _ {1} \\times S _ {2}} \\Pr \\left[ \\sum_ {j \\in [ n ]} P _ {1, j} = s _ {1} \\wedge \\sum_ {j \\in [ n ]} P _ {2, j} = s _ {2} \\right] \\\\ = \\sum_ {(s _ {1}, s _ {2}) \\in S _ {1} \\times S _ {2}} \\Pr \\left[ \\sum_ {j \\in [ n ]} P _ {1, j} = s _ {1} \\right] \\cdot \\Pr \\left[ \\sum_ {j \\in [ n ]} P _ {2, j} = s _ {2} \\right] \\\\ = \\sum_ {s _ {1} \\in S _ {1}} \\Pr \\left[ \\sum_ {j \\in [ n ]} P _ {1, j} = s _ {1} \\right] \\cdot \\sum_ {s _ {2} \\in S _ {2}} \\Pr \\left[ \\sum_ {j \\in [ n ]} P _ {2, j} = s _ {2} \\right] \\\\ = \\Pr \\left[ Y _ {1} = y _ {1} \\right] \\cdot \\Pr \\left[ Y _ {2} = y _ {2} \\right] \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">S_{1}, S_{2}</span> are <span class="math">\\{1\\}</span> or <span class="math">\\{0, 2, 3, \\ldots\\}</span> depending on <span class="math">y_{1}, y_{2}</span>. The same follows for <span class="math">(X_{i})_{i \\in [s]}</span>.</p>

    <p class="text-gray-300">Next, we lower bound the expected value of random variables <span class="math">(Y_{i})_{i}</span> and <span class="math">(X_{i})_{i}</span>.</p>

    <p class="text-gray-300"><strong>Claim 3.</strong> It holds that for any <span class="math">i \\in S: \\mathbb{E}[Y_i] \\geq \\gamma</span></p>

    <p class="text-gray-300">Proof of Claim.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb{E}[Y_i] = \\Pr[Y_i = 1] = \\Pr[\\sum_{j \\in [n]} P_{i,j} = 1] \\\\ = \\sum_{j \\in [n]} \\Pr[P_{i,j} = 1] \\cdot \\prod_{m \\in [n] \\setminus \\{j\\}} \\Pr[P_{i,m} = 0] \\\\ \\geq \\sum_{j \\in [n]} \\alpha(h, t_{i,j}) \\prod_{m \\in [n] \\setminus \\{j\\}} (1 - Pr[P_{i,m} = 1]) \\\\ \\geq (n - t) \\cdot \\alpha(h) \\cdot (1 - \\beta t_{\\mathcal{H}})^{n-1} = \\gamma \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The inequalities follow from the efficiency and MU-TCMA properties. Note, that in order for <span class="math">\\mathbb{E}[Y_i]</span> to be big, <span class="math">\\alpha</span> must be as big as possible, and <span class="math">\\beta t_{\\mathcal{H}}</span> must be as small as possible.</p>

    <p class="text-gray-300"><strong>Claim 4.</strong> It holds that for any <span class="math">i \\in S: \\mathbb{E}[X_i] \\geq f</span></p>

    <p class="text-gray-300">Proof.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb{E}[X_i] = \\Pr[X_i = 1] = \\Pr[\\sum_{j \\in [n]} P_{i,j} \\geq 1] \\\\ = 1 - \\Pr[\\sum_{j \\in [n]} P_{i,j} = 0] \\\\ = 1 - \\prod_{m \\in [n]} \\Pr[P_{i,m} = 0] \\\\ \\geq 1 - (1 - \\alpha(h))^{n-t} = f \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The inequality follows from the Successful property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the linearity of expectation we have that $\\mathbb{E}[Y(S)] \\geq \\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\mathbb{E}[X(S)] \\geq f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since all variables in </span>(Y_i)_i<span class="math"> and </span>(X_i)_i<span class="math"> are mutually independent and </span>\\delta \\in (0,1)$, by an application of the Chernoff Bound it holds that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[Y(S) \\leq (1 - \\frac{\\delta}{4})\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] \\leq \\Pr[Y(S) \\leq (1 - \\frac{\\delta}{4})\\mathbb{E}[Y(S)]] \\leq e^{-\\Omega(\\delta^2 \\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, we can show that $\\Pr[X(S) \\leq (1 - \\frac{\\delta}{4})f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] \\leq e^{-\\Omega(\\delta^2 f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These results, with only negligible difference in probability, follow for the random variables in the real execution due to the almost runtime independence property, and the fact that <span class="math">Y</span> and <span class="math">X</span> are functions of the joint distribution referred by this property.</p>

    <p class="text-gray-300">Next, we show that <span class="math">\\gamma</span>, the rate at which uniquely successful rounds occur, is lower bounded by <span class="math">\\beta t_{\\mathcal{A}}&#x27;</span>, which corresponds to the rate at which the adversary is producing blocks.</p>

    <p class="text-gray-300"><strong>Lemma 22.</strong> <span class="math">\\gamma \\geq (1 + \\delta)\\beta t_{\\mathcal{A}}&#x27;</span></p>

    <p class="text-gray-300"><strong>Proof.</strong> It holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\gamma = (n - t) \\cdot \\alpha(h) \\cdot (1 - \\beta t_{\\mathcal{H}})^{n-1} \\geq (n - t) \\cdot \\alpha(h) \\cdot (1 - \\beta t_{\\mathcal{H}}n) \\\\ \\geq (n - t) \\cdot (1 - \\delta_{\\mathsf{SoW}}) \\cdot \\beta t_{\\mathcal{H}}&#x27; \\cdot (1 - \\delta) \\geq \\frac{(1 - \\delta_{\\mathsf{SoW}})(1 - \\delta)}{(1 - \\delta_{\\mathsf{Steps}})} \\cdot \\beta t_{\\mathcal{A}}&#x27; \\geq (1 + \\delta)\\beta t_{\\mathcal{A}}&#x27; \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where we have first used Bernoulli's inequality, and then the three conditions from Assumption 2 (the Computational Power Assumption). The last inequality follows from the fact that <span class="math">\\frac{\\delta_{\\mathrm{Steps}} - \\delta_{\\mathrm{SoW}}}{2} \\geq \\delta</span>.</p>

    <p class="text-gray-300">We are now ready to define the set of <em>typical executions</em> for this setting. This strategy was also followed in <em>[31]</em>. However, here we will need to adapt the definition due to the difficulties associated with performing a reduction to the security of the SoW scheme.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 23.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[Typical execution] An execution is <em>typical</em> if and only if for any set <span class="math">S</span> of consecutive rounds with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{2\\lambda}{\\gamma\\delta^{2}}$, the following hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $Y(S)>(1-\\frac{\\delta}{4})\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>X(S)>(1-\\frac{\\delta}{4})f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>no insertions and no copies occurred.</li>

    </ol>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 24.</h6>

    <p class="text-gray-300">An execution is typical with overwhelming probability in <span class="math">\\lambda</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order for an execution to not be typical, one of the three points of Definition 23 must not hold with non-negligible probability for some big enough set of rounds. Point 3 is implied by Corollary 18. For a specific set of rounds <span class="math">S</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{2\\lambda}{\\gamma\\delta^{2}}<span class="math">, point 1 is implied by Lemma 21 with overwhelming probability in </span>\\lambda<span class="math">. Regarding point 2, by an application of Lemma 19 for </span>t^{\\prime}_{\\mathcal{A}}=\\frac{\\gamma}{(1+\\delta)\\beta}<span class="math">, it follows that </span>Z_{B}(S)<\\frac{\\gamma}{1+\\delta}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with probability </span>\\mathsf{negl}(\\beta\\cdot t^{\\prime}_{\\mathcal{A}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Note, that this is w.l.o.g., due to Lemma 22, and that </span>\\beta t^{\\prime}_{\\mathcal{A}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\beta\\frac{\\gamma}{(1+\\delta)\\beta}\\cdot\\frac{2\\lambda}{\\gamma\\delta^{2}}=\\Omega(\\lambda)<span class="math">. Moreover, using the fact that </span>\\beta t_{\\mathcal{H}}\\geq\\alpha<span class="math"> argued in Lemma 21 and due to the definition of </span>\\gamma<span class="math">, it holds that </span>\\beta(t_{\\mathcal{A}}+nt_{\\mathcal{H}})\\cdot\\frac{2\\lambda}{\\gamma\\delta^{2}}\\geq\\frac{2\\lambda}{\\delta}=\\Omega(\\lambda)<span class="math">, which in turn implies that Corollary 20 is sufficient to imply point 2 with overwhelming probability in </span>\\lambda<span class="math">. Hence, we can bound the probability that an execution is not typical by applying the union bound on the negation of these events over all sets of consecutive rounds of sufficiently large size, where the probability of each event occurring is negligible in </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Next, taking advantage of the Computational Power Assumption (Assumption 2, we show that the rate at which the adversary computes blocks in a typical execution, is bounded by the rate at which uniquely successful rounds occur. With foresight, we note that this relation is going to be at the core of our security proof.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 25.</h6>

    <p class="text-gray-300">For any set <span class="math">S</span> of at least <span class="math">\\frac{2\\lambda}{\\gamma\\delta^{2}}</span> rounds in a typical execution and for any block <span class="math">B</span> mined by an honest party during <span class="math">S</span>, it holds that <span class="math">Z_{B}(S)&lt;(1-\\frac{\\delta}{4})Y(S)</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It holds that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Z_{B}(S)<\\frac{1}{1+\\delta}\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(1-\\frac{\\delta}{4})Y(S)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where, the first inequality follows from the assumption that the execution is typical.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We can now use the machinery built in <em>[31]</em> to prove the common prefix, chain quality and chain growth properties, and eventually Persistence and Liveness, with only minor changes. Using these properties we prove that the modified Bitcoin backbone protocol implements a robust transaction ledger.</p>

    <p class="text-gray-300">Higher level properties. The notion of a typical execution is at the core of the proof of security of Bitcoin in <em>[31]</em>. Here, we describe the minor changes one has to do after proving the typical execution theorem with respect to the analysis of <em>[31]</em>, in order to prove the security of the protocol in our model. We only give brief proof sketches of lemmas or theorems from <em>[31]</em> that are exactly the same for our own setting.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 26.</h6>

    <p class="text-gray-300">(Chain-Growth Lemma). Suppose that at round <span class="math">r</span> an honest party has a chain of length <span class="math">\\ell</span>. Then, by round <span class="math">s\\geq r</span>, every honest party has adopted a chain of length at least <span class="math">\\ell+\\sum_{i=r}^{s-1}X_{i}</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The main idea of the proof of this lemma is that, after each successful round at least one honest party will have received a chain that is at least one block longer than the chain it had, and all parties pick only chains that are longer than the ones they had. ∎</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 27.</h6>

    <p class="text-gray-300">(Chain-Growth). In a typical execution the chain-growth property holds with parameters <span class="math">\\tau=(1-\\frac{\\delta}{4})f</span> and <span class="math">s\\geq\\frac{2\\lambda}{\\gamma\\delta^{2}}</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">S</span> be any set of at least <span class="math">s</span> consecutive rounds. Then, since the execution is typical: $X(S)\\geq(1-\\frac{\\delta}{4})f\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\tau\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. By Lemma 26, each honest player’s chain will have grown by that amount of blocks at the end of this round interval. Hence, the chain growth property follows. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-34" class="text-base font-medium mt-4">Lemma 28.</h6>

    <p class="text-gray-300">Let <span class="math">B</span> be some honest block or the genesis block in a typical execution. Any sequence of <span class="math">k\\geq\\frac{2\\lambda}{\\gamma\\delta}</span> consecutive blocks in some chain <span class="math">\\mathcal{C}</span>, where the first block in the sequence directly descends <span class="math">B</span>, have been computed in at least <span class="math">k/\\delta</span> rounds, starting from the round that <span class="math">B</span> was computed.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, note that due to the Computational Power Assumption it holds that <span class="math">\\beta(t_{\\mathcal{A}}+nt_{\\mathcal{H}})&lt;\\delta</span>. For some <span class="math">k\\geq\\frac{2\\lambda}{\\gamma\\delta}</span>, assume there is a set of rounds <span class="math">S^{\\prime}</span>, such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><k/\\delta<span class="math">, and more than </span>k<span class="math"> blocks that descend block </span>B<span class="math"> have been computed. This implies that there is a set of rounds </span>S<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{2\\lambda}{\\gamma\\delta^{2}}<span class="math">, such that </span>X(S)+Z_{B}(S)\\geq k\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta(t_{\\mathcal{A}}+nt_{\\mathcal{H}})$. This contradicts the typicality of the execution, hence the lemma follows. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 29.</h6>

    <p class="text-gray-300">(Common-prefix Lemma). Assume a typical execution and consider two chains <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> such that <span class="math">len(\\mathcal{C}_{2})\\geq len(\\mathcal{C}_{1})</span>. If <span class="math">\\mathcal{C}_{1}</span> is adopted by an honest party at round <span class="math">r</span>, and <span class="math">\\mathcal{C}_{2}</span> is either adopted by an honest party or diffused at round <span class="math">r</span>, then <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\leq\\mathcal{C}_{2}</span> and <span class="math">\\mathcal{C}_{2}^{\\lceil k}\\leq\\mathcal{C}_{1}</span>, for <span class="math">k\\geq\\frac{2\\lambda}{\\gamma\\delta}</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In Lemma 19, instead of bounding the number of blocks mined by the adversary in a set of rounds, we bound the number of blocks mined by the adversary with the additional condition that these blocks extend some specific honest block. If we also use the previous lemma, the proof is exactly the same as in <em>[31]</em>. Note, that all adversarial blocks in the matching between uniquely successful rounds and adversarial blocks are descendants of the last honest block in the common prefix of <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span>. ∎</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 30.</h6>

    <p class="text-gray-300">(Common-prefix). In a typical execution the common-prefix property holds with parameter <span class="math">k\\geq\\frac{2\\lambda}{\\gamma\\delta}</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The main idea of the proof is that if there exists a deep enough fork between two chains, then the previously proved lemma cannot hold. Hence, the theorem follows. ∎</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 31.</h6>

    <p class="text-gray-300">(Chain-Quality). In a typical execution the chain-quality property holds with parameter <span class="math">\\mu&lt;1-\\delta/4</span> and <span class="math">\\ell\\geq\\frac{2\\lambda}{\\gamma\\delta}</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The main idea of the proof is the following: a large enough number of consecutive blocks will have been mined in a set rounds that satisfies the properties of Definition 23. Hence, the number of blocks that belong to the adversary will be upper bounded, and all other blocks will have been mined by honest parties. ∎</p>

    <p class="text-gray-300">Finally, the Persistence and Liveness properties follow from the three basic properties, albeit with different parameters than in *[31]</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 32.</h6>

    <p class="text-gray-300">(Persistence). It holds that <span class="math">\\Pi_{\\sf PL}</span> with <span class="math">k=\\frac{2\\lambda}{\\gamma\\delta}</span> satisfies Persistence with overwhelming probability in <span class="math">\\lambda</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The main idea is that if persistence is violated, then the common-prefix property will also be violated. Hence, if the execution is typical the lemma follows. ∎</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Lemma 33.</h6>

    <p class="text-gray-300">(Liveness). It holds that <span class="math">\\Pi_{\\sf PL}</span> with <span class="math">u=\\frac{2k}{(1-\\frac{2}{3})f}</span> rounds and <span class="math">k=\\frac{2\\lambda}{\\gamma\\delta}</span> satisfies Liveness with overwhelming probability in <span class="math">\\lambda</span>.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The main idea here is that after <span class="math">u</span> rounds at least <span class="math">2k</span> successful rounds will have occurred. Thus, by the chain growth lemma the chain of each honest party will have grown by <span class="math">2k</span> blocks, and by the chain quality property at least one of these blocks that is deep enough in the chain, is honest. ∎</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Theorem 34.</h6>

    <p class="text-gray-300">Assuming the existence of a collision-resistant hash function and a SoW scheme that complies with Assumption 1 and 2, protocol <span class="math">\\Pi_{\\sf PL}^{\\sf SoW}</span> implements a robust public transaction ledger with parameters <span class="math">u=\\frac{2k}{(1-\\frac{2}{3})f}</span> and <span class="math">k=\\frac{2\\lambda}{\\gamma\\delta}</span> except with negligible probability in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">As a “sanity check,” we show in in the full version of the paper that the Bitcoin SoW scheme we outline there, is secure both in the random oracle and the <span class="math">\\mathcal{F}_{\\mbox{\\tiny TREE}}</span> model <em>[47]</em> according to our definitions; moreover, according to the security parameters we obtain for the scheme, the security guarantees we get from our black-box analysis of the Bitcoin backbone are similar to those proved in <em>[31, 47]</em>.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">4.3 Consensus from Signatures of Work</h3>

    <p class="text-gray-300">In this section we show how to achieve consensus (a.k.a. Byzantine agreement <em>[48, 42]</em>) under exactly the same assumptions used for proving the security of the Bitcoin backbone protocol in Section 4.2.</p>

    <p class="text-gray-300">As mentioned earlier, in <em>[31]</em> consensus is achieved under the Honest Majority Assumption by using a proof-of-work construction in a non-black-box way, through a mining technique called “2-for-1 PoWs.” In more detail, the technique shows how miners can compute proofs of work for two different PoW schemes at the cost of one, while at the same time ensuring that their resources cannot be used in favor of one of the two schemes. However, the security proof for the resulting protocol crucially relies on the fact that each of the bits of the strings output by the random oracle are independently sampled, and thus goes again our stated goal of designing a SoW scheme that does not make such a strong independence assumption.</p>

    <p class="text-gray-300">Here we get rid of this requirement, by showing how blockchain-based consensus can be achieved by only using the security properties we have defined, directly, and without the extra non-black-box machinery used in <em>[31]</em>. This yields the first consensus protocol for honest majority reducible to a SoW primitive in the permissionless setting. The protocol is based on the Bitcoin backbone protocol, and formally specified by providing adequate definitions for the <span class="math">\\mathrm{V},\\mathrm{R},\\mathrm{I}</span> functions presented in Section 4.2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we define some additional notation and terminology that will be used in the remainder of the section. We will use the terms “input” and “vote” interchangeably, referring to the parties’ input to the consensus problem. We will use $header(\\langle s,x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote,\\sigma\\rangle)<span class="math"> to denote the “compressed” version of block </span>\\langle s,x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote,\\sigma\\rangle<span class="math">, equal to </span>\\langle s,G(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote,\\sigma\\rangle<span class="math">. Note that, as defined, the header of any block is of a fixed size. We also extend the definition of our hash function </span>H<span class="math"> as applied to headers of blocks. The hash of the header of some block </span>B<span class="math"> will be equal to the hash of </span>B<span class="math">, i.e., </span>H((header(B))=H(B)=H(s,G(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote,\\sigma)<span class="math"> (note that the header of </span>B<span class="math"> provides all the information needed to calculate the hash of </span>B$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now present a high-level description of the protocol. The basic idea is that during block mining, parties are going to include in their blocks not only their own votes, but also headers of other blocks that they have seen and that are not part of their chain. Then, after a predetermined number of rounds, the parties will count the votes “referenced” in a prefix of their chain, including the votes found in the headers of the blocks referenced. In this way, they can take advantage of the robust transaction ledger built in Section 4.2. The Persistence property implies that the honest parties will all agree on which votes should be counted, while the Liveness property guarantees that the majority of the counted votes come from honest parties.</p>

    <p class="text-gray-300">The reader may wonder about the reason behind honest parties including in their blocks also headers of other blocks that they have seen but that are not part of their chain. It’s because, as shown in <em>[31]</em>, the adversary is able to add more blocks in the main chain than his ratio of mining power (e.g., using a selfish-mining attack). This does not hold if the honest parties are able to also count off-chain blocks as our protocol does.</p>

    <p class="text-gray-300">Algorithm 5 The content validation predicate. The input is the contents of the blocks of some chain. 1: function V(<span class="math">\\langle x_{1},\\ldots,x_{m}\\rangle</span>) 2: <span class="math">D\\leftarrow</span> new AVL() <span class="math">\\triangleright</span> Create a new (empty) AVL tree. 3: <span class="math">D.add(H(B_{\\text{Gen}}))</span> <span class="math">\\triangleright</span> Add the hash of the genesis block on the tree. 4: for <span class="math">i=1,...,m</span> do 5: <span class="math">queue\\leftarrow</span> references(<span class="math">x_{i}</span>) <span class="math">\\triangleright</span> Add all block references in a queue.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: $\\langle r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathit{height}\\rangle\\leftarrow queue.top()$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7: if <span class="math">\\mathit{height}\\neq i</span> then 8: return False <span class="math">\\triangleright</span> Check for the correct block “height”. 9: end if 10: while <span class="math">queue\\neq\\emptyset</span> do</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11: $\\langle s,G(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote,w\\rangle\\leftarrow queue.top()$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13: $D.add(H(\\langle s,G(x)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">vote,w\\rangle))<span class="math"> </span>\\triangleright$ Add new entry on the tree.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">14: <span class="math">queue.pop()</span> 15: else 16: return False <span class="math">\\triangleright</span> If not, the chain is invalid. 17: end if 18: end while 19: end for 20: return True 21: end function</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A main technical challenge is to be able to add the block references without making the honest parties’ chains grow too large, and at the same time to ensure that the number of honest votes exceeds the adversarial ones. To overcome this challenge, we modify the Sign algorithm so that it is run on the header of the block, i.e., $\\text{Sign}(pp,s,G(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote,h)<span class="math"> and </span>\\text{Verify}(pp,s,G(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote,h,\\sigma)$, respectively. This way we are able to verify the validity of a block as a SoW and determine the block’s vote by only knowing its header. These are exactly the properties we need for the consensus application.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, we should be able to tell whether the referenced blocks are “fresh”; that is, the adversary should not be able to reference blocks that it has precomputed and are not related to the genesis block. We achieve this by requiring blockchain contents to have a special structure in order to be considered valid by the content validation predicate V(<span class="math">\\cdot</span>) (Algorithm 5). A chain will be valid when the referenced blocks on every prefix of the chain form a tree that has the genesis block at its root. In order to check</p>

    <p class="text-gray-300">this efficiently, we require that the block headers listed in each block are ordered, so that each entry extends some block header found in previous entries of the same or parent blocks.</p>

    <p class="text-gray-300">In more detail, to efficiently check for membership in the hash tree, in line 2 of Algorithm 5 we use an AVL tree. (Any other data structure supporting efficient updates and search would also work.) In line 5 the referenced blocks are extracted and pushed into a queue. We note that during this process it is checked that: (i) the contents of the block have a correct format, i.e., a vote field and list of block headers, (ii) each header in the list is a valid SoW and extends a chain starting from the genesis block, and (iii) that the first reference includes a string  <span class="math">r</span>  and the height of the block as required in the security analysis of Section 4.2.3 and described in Table 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Content validation pre-dicate V(·)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As defined in Algorithm 5.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Chain reading function R(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">R(·) outputs the majority of the votes found in the block headers of the first M blocks of the selected chain.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Input contribution function I(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">The input function I(·) maintains state of which blocks have been received, and outputs an input value x that contains (i) the headers of all valid blocks that extend the genesis and are not mentioned in the chain C that the party is currently extending, (ii) a neutral transaction of the form KeyGen(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">, and (iii) the party's input (i.e., 0 or 1).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: The instantiation of functions  <span class="math">\\mathrm{I}\\left( \\cdot \\right) ,\\mathrm{V}\\left( \\cdot \\right) ,\\mathrm{R}\\left( \\cdot \\right)</span>  for protocol  <span class="math">{\\Pi }_{\\mathrm{{BA}}}^{\\mathrm{{SoW}}}</span>  .</p>

    <p class="text-gray-300">The algorithm runs for  <span class="math">L</span>  rounds, after which it outputs the majority of the votes found in a prefix of the selected chain, of a predetermined length  <span class="math">M</span> . We call the resulting protocol  <span class="math">\\Pi_{\\mathrm{BA}}^{\\mathrm{SoW}}</span>  ("BA" for Byzantine agreement). A description of the consensus protocol (specifically, the V, R, I functions) is presented in Table 3, and also recall the example in Figure 1. Note that all parties terminate the protocol simultaneously.</p>

    <p class="text-gray-300">Theorem 35. Assuming the existence of a collision-resistant hash function and a SoW scheme that complies with Assumptions 1 and 2. Protocol  <span class="math">\\Pi_{\\mathrm{BA}}^{\\mathrm{SoW}}</span>  solves consensus in  <span class="math">O\\left(\\frac{\\lambda}{\\gamma^{\\alpha}\\delta}\\right)</span>  rounds with overwhelming probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Proof. We are going to show that protocol  <span class="math">\\Pi_{\\mathrm{BA}}^{\\mathrm{SoW}}</span> , parameterized with  <span class="math">k = \\frac{2\\lambda}{\\gamma\\delta}</span> ,  <span class="math">M = k + \\frac{8k}{\\gamma}</span>  number of blocks, and  <span class="math">L = \\frac{M + k}{(1 - \\frac{2}{\\lambda})\\gamma}</span>  number of rounds solves consensus with overwhelming probability in  <span class="math">\\lambda</span> . Our analysis uses many of the intermediate lemmas established for the proof of Theorem 34.</p>

    <p class="text-gray-300">We start, by proving that the Agreement property holds. First, note that our definition of  <span class="math">\\mathrm{V}(\\cdot)</span>  guarantees that if an honest party accepts a chain as valid, all other parties are also going to accept it as valid, since the validation predicate only depends on the chain that is being validated. Assume that an execution is  <span class="math">\\delta</span> -typical. Since  <span class="math">L \\geq \\frac{2\\lambda}{\\gamma\\delta}</span> , after  <span class="math">L</span>  rounds: (i) due to chain growth the chains of all honest parties will have length at least  <span class="math">M + k</span>  blocks, and (ii) due to the common prefix property they will all agree on the first  <span class="math">M</span>  blocks of their chains. Hence, all honest parties will decide on their output values based on the "votes" mentioned in the same blocks, and thus they will all agree on the same value.</p>

    <p class="text-gray-300">Regarding Validity, we are going to show that the majority of the counted "votes," i.e., from blocks and block headers found in blocks  <span class="math">B_{1}, \\ldots, B_{M}</span>  of the common prefix, have been mined by honest parties. Due to the chain quality property at least one block from  <span class="math">B_{M - k}, \\ldots, B_{M}</span>  is honest. Assume that the last honest block in this chain has been diffused in the network at round  <span class="math">r</span> . Since  <span class="math">M - k \\geq \\frac{8k}{\\gamma} \\geq k</span> , by an application of Lemma 28 starting from the genesis block, it holds that  <span class="math">r \\geq \\frac{8k}{\\gamma\\delta}</span> . Hence, at round  <span class="math">r + \\frac{2k}{(1 - \\frac{2}{\\lambda})\\gamma}</span> , by the chain growth property all parties will have chains of length at least  <span class="math">M + k</span> , and by the common-prefix property all blocks up to the  <span class="math">M</span> -th position will be fixed for the rest</p>

    <p class="text-gray-300">of the execution. Hence, the last adversarial block in <span class="math">B_{1},\\ldots,B_{M}</span> must have been computed before round <span class="math">r+\\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span>.</p>

    <p class="text-gray-300">Let <span class="math">r^{\\prime}=r+\\frac{2k}{(1-\\frac{\\delta}{4})\\gamma}</span>. It remains to show that for <span class="math">S_{1}=\\{1,\\ldots,r\\}</span> and <span class="math">S_{2}=\\{1,\\ldots,r^{\\prime}\\}</span> it holds that <span class="math">Z(S_{2})&lt;X(S_{1})</span>:</p>

    <p class="text-gray-300"><span class="math">Z(S_{2})&lt;\\frac{1}{1+\\delta}\\gamma r^{\\prime}\\leq(1-\\frac{\\delta}{4})(1-\\frac{\\delta}{4})\\gamma r^{\\prime}\\leq(1-\\frac{\\delta}{4})\\gamma r\\leq X(S_{1}).</span></p>

    <p class="text-gray-300">The first and the last inequalities hold due to the fact that the execution is typical. The fourth inequality follows by the size of <span class="math">r</span>. The theorem follows since the majority of the referenced blocks in the chain agreed upon, have been mined by honest parties.</p>

    <p class="text-gray-300">Concluding, notice that the total size of any chain is bounded by the total number of blocks mined, since each block’s header is mentioned at most once in a single chain. Hence, in <span class="math">s</span> rounds of a typical execution a chain has size at most <span class="math">O(s\\cdot\\lambda)</span> bits. ∎</p>

    <h2 id="sec-48" class="text-2xl font-bold">5 SoW Constructions from Idealized Assumptions</h2>

    <p class="text-gray-300">In this section, and as a sanity check, we outline a SoW scheme that is secure both in the random oracle and the <span class="math">\\mathcal{F}_{\\text{\\tiny TREE}}</span> model <em>[47]</em>. Moreover, according to the security parameters we obtain for the scheme, the security guarantees we get from our black-box analysis of the Bitcoin backbone are similar to those proved in <em>[31, 47]</em>.</p>

    <p class="text-gray-300">SoW in the RO model. Our first step is to show that the SoW scheme used in the Bitcoin protocol (call it <span class="math">\\mathtt{BSOW}</span>) is secure in the random oracle model according to our definitions. In a nutshell, Bitcoin’s <span class="math">\\mathsf{Sign}</span> algorithm tries to find a block header with a small hash. The main components of the header are as follows: (i) the hash of the header of the previous block, (ii) the hash of the root of the Merkle tree of the transactions that are going to be added to Bitcoin’s ledger, including the <em>randomly</em> created coinbase transaction, and (iii) a counter. The algorithm works by first fetching available transactions from the network, then computing a random public key that will be used for the coinbase transaction, and then iteratively incrementing the counter and calculating the hash of the header of the block until a small value is found. Casting this in our terms, the key is the hash of the previous block, which by itself depends on Bitcoin’s genesis block, while the transactions received by the network as well as the coinbase transaction constitute the message. It is important to note that it is not possible to consider the key to be the coinbase transaction, as there is no guarantee it has any entropy when produced by an adversarial signer. To abstract the randomization of the signing procedure, which in the actual implementation is captured by the coinbase transaction, we hash <em>msg</em> together with a randomly generated string. This should be part of the signature in our SoW syntax since it is produced by the signing process and is necessary for verification. Similarly, the counter is also part of the signature produced by the signing process. <span class="math">\\mathtt{BSOW}</span>, a simplified version of the scheme described above with the transaction semantics omitted for simplicity, is presented in Figure 6.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">In the Bitcoin implementation, the hash of the root of the Merkle tree of the transactions is not “<em>salted</em>.” This means that if we consider the adversary to be non-uniform, she could get collisions for free in her advice string and use them to compute two SoWs at the cost of one. This would be problematic for our MU-TCMA security game. Thus, in order to strengthen the security of the scheme, we choose to also include the key in the hash of the message.</p>

    <p class="text-gray-300">We will assume that <span class="math">H</span> is an idealized hash function, i.e., our analysis is in the random oracle, and <span class="math">G_{k}</span> is sampled from a collision resistant hash function family.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 36.</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{G}</span> is a collision resistant hash function family, and <span class="math">H</span> is modeled as a Random Oracle, then for any <span class="math">\\sigma\\in(0,1)</span>, Algorithm 6 is</p>

    <p class="text-gray-300">Algorithm 6 Bitcoin's SoW implementation based on the ROM.  <span class="math">H</span>  is modeled as a RO, while  <span class="math">G_{k}</span>  is sampled from a collision resistant hash function family  <span class="math">\\mathcal{G}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">function PPub(1λ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2:</td>

            <td class="px-3 py-2 border-b border-gray-700">k← K(λ) ▷ Sample the key of hash function G.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3:</td>

            <td class="px-3 py-2 border-b border-gray-700">return (1λ,k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4:</td>

            <td class="px-3 py-2 border-b border-gray-700">end function</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">function KeyGen(pp)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8:</td>

            <td class="px-3 py-2 border-b border-gray-700">return vk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9:</td>

            <td class="px-3 py-2 border-b border-gray-700">end function</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  10: |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">function Sign(pp = (1λ,k), vk, msg, h)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13:</td>

            <td class="px-3 py-2 border-b border-gray-700">σ1← Uλ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14:</td>

            <td class="px-3 py-2 border-b border-gray-700">dig← Gk(vk, σ1, msg)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15:</td>

            <td class="px-3 py-2 border-b border-gray-700">for σ2 = 0λ</td>

            <td class="px-3 py-2 border-b border-gray-700">2 to 1λ</td>

            <td class="px-3 py-2 border-b border-gray-700">2 do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16:</td>

            <td class="px-3 py-2 border-b border-gray-700">if (H(vk, dig, σ2) < 2λ - h) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">17:</td>

            <td class="px-3 py-2 border-b border-gray-700">return (σ1, σ2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18:</td>

            <td class="px-3 py-2 border-b border-gray-700">end if</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">19:</td>

            <td class="px-3 py-2 border-b border-gray-700">end for</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20:</td>

            <td class="px-3 py-2 border-b border-gray-700">end while</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21:</td>

            <td class="px-3 py-2 border-b border-gray-700">end function</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  22: |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">23:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">function Verify(pp = (1λ,k), vk, msg, h, σ = (σ1, σ2))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25:</td>

            <td class="px-3 py-2 border-b border-gray-700">end function</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>correct;</li>

      <li><span class="math">O(\\lambda)</span> -verifiable;</li>

      <li><span class="math">(t_{sign}, 1 - \\left(\\frac{h}{2^{\\lambda}}\\right)^{t_{sign}})</span> -successful, for  <span class="math">h \\in [2^{\\lambda} - 1]</span> ;</li>

      <li>run-time independent;</li>

      <li><span class="math">((1 + \\sigma)(1 - \\frac{h}{2^{\\lambda}}), e^{-\\frac{\\beta(h)t\\sigma^{2}}{6}} + \\mathsf{negl}(\\lambda))</span> -MU-TCMA secure w.r.t. any computationally unpredictable function family  <span class="math">\\mathcal{F}</span> , for  <span class="math">h \\in [2^{\\lambda} - 1]</span> .</li>

    </ul>

    <p class="text-gray-300">Proof. Let  <span class="math">p_h = 1 - \\frac{h}{2^\\lambda}</span>  be the probability that a query to the random oracle returns a value less than  <span class="math">2^\\lambda - h</span> , and let  <span class="math">q_{\\mathcal{H}}</span>  be the number of queries the adversary makes to the RO. We consider each property in turn.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Correct. By the collision resistance of  <span class="math">G</span> , it follows that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{G(vk, \\sigma_1, msg)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_1 \\in \\{0, 1\\}^\\lambda\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is greater than  </span>\\lambda<span class="math">  with overwhelming probability in  </span>\\lambda<span class="math"> . Hence, the probability that the Sign algorithm cannot find any signature for the given parameters is upper bounded by the probability that  </span>\\lambda \\cdot 2^\\lambda<span class="math">  different queries to the  </span>\\mathcal{RO}<span class="math">  return a value greater or equal than  </span>2^\\lambda - h$ . This is upper bounded by:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(\\frac {h}{2 ^ {\\lambda}}) ^ {\\lambda 2 ^ {\\lambda}} \\leq (1 - \\frac {1}{2 ^ {\\lambda}}) ^ {\\lambda 2 ^ {\\lambda}} \\leq e ^ {- \\lambda}</span></div>

    <p class="text-gray-300">The correctness property follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MU-TCMA. Let <span class="math">\\ell=\\beta(h)t</span>. W.l.o.g., assume <span class="math">\\ell\\geq 1</span>, since if <span class="math">\\ell&lt;1</span> there exists a trivial adversary that wins with probability 1. First, we show that for any adversary <span class="math">\\mathcal{A}</span> there exists an adversary <span class="math">\\mathcal{A}^{\\prime}</span> that succeeds in winning <span class="math">\\mathsf{Exp}_{\\mathcal{A}^{\\prime},\\mathcal{F}}^{\\text{MU-TCMA}}</span> (Figure 2) with almost the same time complexity and probability that <span class="math">\\mathcal{A}</span> wins, without using the signing oracle <span class="math">\\mathcal{S}</span>. <span class="math">\\mathcal{A}^{\\prime}</span> is going to run <span class="math">\\mathcal{A}</span> internally, and all calls made by <span class="math">\\mathcal{A}</span> to <span class="math">\\mathcal{S}</span> are going to be simulated, i.e., assuming <span class="math">\\mathcal{A}</span> queries <span class="math">\\mathcal{S}</span> with values <span class="math">(k,msg)</span>, <span class="math">\\mathcal{A}^{\\prime}</span> will respond with some number <span class="math">t^{\\prime}</span> sampled from the time distribution of <span class="math">\\mathcal{S}</span> (<span class="math">t^{\\prime}</span> can be efficiently sampled from a geometric distribution, since queries are i.i.d Bernoulli trials) and some random signature <span class="math">\\sigma=(\\sigma_{1},\\sigma_{2})</span>, where <span class="math">\\sigma_{2}&lt;t^{\\prime}</span>. <span class="math">\\mathcal{A}^{\\prime}</span> is also going to store this query in some efficient data structure that allows for search in logarithmic time. Any calls made by the adversary afterwards to the RO that are related to <span class="math">(k,msg)</span> will be answered accordingly; if <span class="math">\\mathcal{A}_{2}</span> queries the RO with some string $k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(k,\\sigma_{1},msg)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{2}^{\\prime}<span class="math">, where </span>\\sigma_{2}^{\\prime}=\\sigma_{2}<span class="math">, then </span>\\mathcal{A}^{\\prime}<span class="math"> will respond with the same value he responded on the initial query to </span>\\mathcal{S}<span class="math">, otherwise if </span>\\sigma_{2}^{\\prime}<\\sigma_{2}<span class="math">, he responds by </span>2^{\\lambda}-h+(y\\mod h)<span class="math">, where </span>y<span class="math"> is the output of the real RO in this query. Note, that since </span>\\sigma_{1}<span class="math"> is chosen at random and RO is unpredictable, the probability that </span>\\mathcal{A}<span class="math"> has queried the RO with a string of this format before querying </span>\\mathcal{S}<span class="math"> is negligible. Hence, the view of </span>\\mathcal{A}<span class="math"> in both experiments is computationally indistinguishable, and he will output </span>\\ell$ valid SoWs with respect to the simulated view with the same probability that he wins in the real experiment.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We next have to show that <span class="math">\\mathcal{A}^{\\prime}</span> can use the output of <span class="math">\\mathcal{A}</span> to win in the real experiment. The only case this will not happen, is if the output of <span class="math">\\mathcal{A}</span> contains a SoW related to the queries asked to (the simulated) oracle <span class="math">\\mathcal{S}</span>, and thus it does not correspond to a winning output for <span class="math">\\mathcal{A}^{\\prime}</span>, i.e., <span class="math">\\mathcal{A}^{\\prime}</span> has set the value of this SoW to be small enough, while this does not necessarily hold for the actual RO. This implies, that there exists a SoW on the output of <span class="math">\\mathcal{A}</span> of the form <span class="math">\\langle f,msg,(\\sigma_{1},\\sigma_{2})\\rangle</span> and a query <span class="math">\\langle(k,msg^{\\prime}),(\\sigma_{1}^{\\prime},\\sigma_{2}^{\\prime})\\rangle</span> on <span class="math">\\mathcal{S}</span>, such that $f(\\Sigma,vk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(f(\\Sigma,vk),\\sigma_{1},msg)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{2}=k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(k,\\sigma_{1}^{\\prime},msg^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{2}^{\\prime}<span class="math">. In order for this to be a winning output for </span>\\mathcal{A}<span class="math">, it must not correspond to the asked query, and thus it should hold that either </span>msg\\neq msg^{\\prime}<span class="math"> or </span>\\sigma_{1}\\neq\\sigma_{1}^{\\prime}<span class="math">. This implies that the adversary has found a collision in </span>G<span class="math">, which only happens with negligible probability in </span>\\lambda<span class="math">. Hence, </span>\\mathcal{A}^{\\prime}<span class="math"> will win </span>\\mathsf{Exp}_{\\mathcal{A}^{\\prime},\\mathcal{F}}^{\\text{MU-TCMA}}<span class="math"> with the same probability (minus some negligible term in </span>\\lambda<span class="math">) as </span>\\mathcal{A}<span class="math">. Moreover, the overhead incurred to </span>\\mathcal{A}^{\\prime}<span class="math">’s running time will be only logarithmic on </span>q_{\\mathcal{S}}<span class="math"> i.e. </span>\\mathcal{A}^{\\prime}<span class="math"> can simulate the </span>t<span class="math"> steps taken by </span>\\mathcal{A}_{2}<span class="math"> in time </span>t^{\\prime}=t\\cdot(1+\\log(q_{\\mathcal{S}}))<span class="math">; he has to maintain a heap of the queries made to </span>\\mathcal{S}<span class="math"> and search it each time the RO is queried. Note, that </span>\\mathcal{A}^{\\prime}<span class="math"> queries the real RO at most </span>t$ times.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">A_{\\ell}</span> be the event where <span class="math">\\mathcal{A}^{\\prime}</span> asks <span class="math">t</span> queries the RO after receiving <span class="math">vk</span>, and receives at least <span class="math">\\ell</span> responses that have value less than <span class="math">2^{\\lambda}-h</span>. Let random variable <span class="math">X</span> be equal to the number of these responses that are less than <span class="math">2^{\\lambda}-h</span>. Since the queries are i.i.d. Bernoulli random variables with probability of success <span class="math">p_{h}</span>, we can use the Chernoff bound to bound the probability of <span class="math">A_{\\ell}</span>. For any <span class="math">\\sigma\\in(0,1)</span>, since <span class="math">\\ell=\\beta t\\geq(1+\\sigma)p_{h}t</span>, it follows that:</p>

    <p class="text-gray-300"><span class="math">\\Pr[A_{\\ell}]=\\Pr[X\\geq\\ell]</span> <span class="math">\\leq</span> <span class="math">\\Pr[X\\geq(1+\\sigma)p_{h}t]</span> <span class="math">=</span> <span class="math">\\Pr[X\\geq(1+\\sigma)\\mathbb{E}[X]]\\leq e^{-\\frac{\\mathbb{E}[X]\\sigma^{2}}{3}}\\leq e^{-\\frac{(1+\\sigma)p_{h}t\\sigma^{2}}{6}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">B</span> be the event where <span class="math">\\mathcal{A}_{2}^{\\prime}</span> outputs <span class="math">f,m,\\sigma</span> such that <span class="math">f\\in\\mathcal{F}</span> and there exists a query made to the random oracle by <span class="math">\\mathcal{A}_{1}^{\\prime}</span> of the form $f(\\Sigma,vk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma<span class="math">, for some </span>x\\in\\{0,1\\}^{*}<span class="math">. We will show that </span>B<span class="math"> happens with only negligible probability in </span>\\lambda<span class="math">. For the sake of contradiction, assume that </span>B<span class="math"> happens with non-negligible probability. Then, we can use </span>\\mathcal{A}^{\\prime}<span class="math"> to break the computational unpredictability of </span>\\mathcal{F}<span class="math">. Let </span>\\mathcal{A}^{\\prime\\prime}=(\\mathcal{A}_{1}^{\\prime\\prime},\\mathcal{A}_{2}^{\\prime\\prime})<span class="math"> be the attacker in the computational unpredictability game. </span>\\mathcal{A}_{1}^{\\prime\\prime}<span class="math"> on input </span>(1^{\\lambda},\\Sigma,pp)<span class="math"> will first run </span>\\mathcal{A}_{1}^{\\prime}(1^{\\lambda},\\Sigma,pp)<span class="math">. It will output </span>st^{\\prime}=st</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y<span class="math">, where </span>st<span class="math"> is the output of </span>\\mathcal{A}_{1}<span class="math">, and </span>y<span class="math"> the prefix of a random query that </span>\\mathcal{A}_{1}^{\\prime}<span class="math"> made to the RO with length equal to the size of a verification key. Then, </span>\\mathcal{A}_{2}^{\\prime\\prime}<span class="math"> on input </span>(st^{\\prime},vk)<span class="math"> will run </span>\\mathcal{A}_{2}^{\\prime}(1^{\\lambda},vk,st)<span class="math">, until it halts and possibly outputs a number of SoWs. Since </span>\\mathcal{A}^{\\prime}<span class="math"> is a PPT algorithm, the number of queries made to the RO is at most polynomial in number. Hence, with non-negligible probability </span>B<span class="math"> will occur and </span>y$ will be the prefix of the RO query that matches the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">key of the SoW output by <span class="math">\\mathcal{A}&#x27;</span>. This violates the computational unpredictability property, and hence <span class="math">B</span> only occurs with negligible probability.</p>

    <p class="text-gray-300">Let <span class="math">C</span> be the event where the adversary wins and outputs two distinct SoWs that correspond to the same query to the RO. This implies that the adversary can find a collision on <span class="math">G</span>. In time <span class="math">L = t&#x27; + t_{\\text{pre}}</span> polynomial in <span class="math">\\lambda</span>, the probability that <span class="math">\\mathcal{A}&#x27;</span> finds a collision is <span class="math">\\binom{L}{2} 2^{-\\lambda+1} = e^{-\\Omega(\\lambda)} = \\text{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Finally, note that if <span class="math">A_{\\ell}, B, C</span> do not occur, it is implied that <span class="math">\\mathcal{A}&#x27;</span> will lose in the MU-TCMA experiment. Thus:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\operatorname {E x p} _ {\\mathcal {A}, \\mathcal {F}} ^ {\\mathrm {M U - T C M A}} \\left(1 ^ {\\lambda}, h, \\ell\\right) = 1 \\right] = \\Pr \\left[ \\operatorname {E x p} _ {\\mathcal {A} ^ {\\prime}, \\mathcal {F}} ^ {\\mathrm {M U - T C M A}} \\left(1 ^ {\\lambda}, h, \\ell\\right) = 1 \\right] \\\\ \\leq \\Pr [ A _ {\\ell} \\vee B \\vee C ] \\\\ \\leq \\Pr [ A _ {\\ell} ] + \\Pr [ B ] + \\Pr [ C ] \\\\ \\leq \\Pr [ A _ {\\ell} ] + \\operatorname {n e g l} (\\lambda) \\\\ \\leq e ^ {- \\frac {(1 + \\sigma) p _ {h} t \\sigma^ {2}}{6}} + \\operatorname {n e g l} (\\lambda) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where we have used the union bound for the third inequality.</p>

    <p class="text-gray-300"><strong>Verifiability.</strong> Assuming <span class="math">H</span> and <span class="math">G</span> take constant time, verification takes time <span class="math">c_{\\text{ver}}\\lambda</span>, for some small constant <span class="math">c_{\\text{ver}}</span> which can be easily computed by careful inspection of the verification protocol.</p>

    <p class="text-gray-300"><strong>Successful.</strong> Let <span class="math">E</span> be the event that in an execution of the Sign function no collisions occur. By the collision resistance property of <span class="math">H</span> and <span class="math">G</span>, it holds that <span class="math">\\operatorname*{Pr}[\\neg E] \\leq \\operatorname{negl}(\\lambda)</span>. For any <span class="math">t \\in \\mathbb{N}</span>, <span class="math">pp \\in PP</span>, <span class="math">vk \\in K</span>, <span class="math">msg \\in M</span> and <span class="math">h \\in \\mathbb{N}</span> it follows that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {S t e p s} _ {\\text {S i g n}} (p p, v k, m s g, h) &amp;lt;   t \\right] \\geq 1 - \\left(1 - p _ {h}\\right) ^ {t} - \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300"><strong>Independence.</strong> Let <span class="math">\\{Y_{i}\\}_{i\\in I}</span> be the same as <span class="math">\\{X_{i}\\}_{i\\in I} = \\{\\mathsf{Steps}_{\\mathsf{Sign}}(pp,vk_{i},m_{i},h_{i})\\}_{i\\in I}</span> with the only difference that the random oracle is replaced with a random function, i.e., every time Sign is called and the oracle <span class="math">H</span> is queried it generates a random output. Obviously the random variables in <span class="math">\\{Y_{i}\\}_{i\\in I}</span> are mutually independent, since their output only depends on their own local coins.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Regarding the second property, let <span class="math">E</span> be the event that all <span class="math">\\sigma_{1}</span> sampled are different among all the invocations of Sign, and that no collisions occurs in <span class="math">G</span>. Note, for polynomially big <span class="math">I</span>, this event happens with overwhelming probability in <span class="math">\\lambda</span>. Moreover, conditioned <span class="math">E</span>, it holds that $\\operatorname*{Pr}[\\{X_i\\}_{i\\in I} = z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E]<span class="math"> is equal to </span>\\operatorname*{Pr}[\\{Y_i\\}_{i\\in I} = z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E]<span class="math">, for any </span>z<span class="math">, since the random oracle behaves exactly as the random function we have replaced it with. Therefore, if </span>p(\\cdot)<span class="math"> is a polynomial that upper bounds the number of steps of Sign, it holds that for any </span>z\\in [p(\\lambda)]^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Pr \\left[ \\left\\{X _ {i} \\right\\} _ {i \\in I} = z \\right] - \\Pr \\left[ \\left\\{Y _ {i} \\right\\} _ {i \\in I} = z \\right] = \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Pr \\left[ \\left\\{X _ {i} \\right\\} _ {i \\in I} = z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E \\right] \\Pr [ E ] + \\Pr \\left[ \\left\\{X _ {i} \\right\\} _ {i \\in I} = z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E \\right] \\Pr [ \\neg E ] \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\left(\\Pr \\left[ \\left\\{X _ {i} \\right\\} _ {i \\in I} = z</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neg E \\right] - \\Pr \\left[ \\left\\{Y _ {i} \\right\\} _ {i \\in I} = z</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neg E \\right]\\right) \\Pr [ \\neg E ] \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Hence, it follows that the two distributions are <span class="math">\\operatorname{negl}(\\lambda)</span>-close:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\Delta [ \\{X _ {i} \\} _ {i \\in I}, \\{Y _ {i} \\} _ {i \\in I} ] = \\sum_ {z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\{X _ {i} \\} _ {i \\in I} = z ] - \\Pr [ \\{Y _ {i} \\} _ {i \\in I} = z ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\Pr [ \\neg E ] \\sum_ {z}</td>

            <td class="px-3 py-2 border-b border-gray-700">(\\Pr [ \\{X _ {i} \\} _ {i \\in I} = z</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neg E ] - \\Pr [ \\{Y _ {i} \\} _ {i \\in I} = z</td>

            <td class="px-3 py-2 border-b border-gray-700">\\neg E ])</td>

            <td class="px-3 py-2 border-b border-gray-700">\\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq \\operatorname {n e g l} (\\lambda) \\left(\\sum_ {z} \\Pr \\left[ \\left\\{X _ {i} \\right\\} _ {i \\in I} = z \\mid \\neg E \\right] + \\sum_ {z} \\Pr \\left[ \\left\\{Y _ {i} \\right\\} _ {i \\in I} = z \\mid \\neg E \\right]\\right) \\leq \\operatorname {n e g l} (\\lambda) \\\\ \\end{array} $$</p>

    <p class="text-gray-300">The last inequality follows from the fact that each of the sums should be less or equal to 1, as the events described are disjoint and their union covers the entire sample space. <span class="math">\\square</span></p>

    <p class="text-gray-300">SoW in the <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> model. Next, we argue that we can use the <span class="math">\\mathcal{F}_{\\mathrm{TREE}}^{p}</span> functionality from <em>[47]</em> to realize a secure SoW scheme.</p>

    <p class="text-gray-300">We start by reciting the <span class="math">\\mathcal{F}_{\\mathrm{TREE}}^{p}</span> description. <span class="math">\\mathcal{F}_{\\mathrm{TREE}}^{p}</span> is parametrized by some hardness parameter <span class="math">p</span> and keeps track of records on a tree. Initially, the tree contains <span class="math">\\bot</span>. On invocation of <span class="math">extend((m_{1},\\ldots,m_{\\ell-1}),m)</span>, <span class="math">\\mathcal{F}_{\\mathrm{TREE}}^{p}</span> checks if <span class="math">(m_{1},\\ldots,m_{\\ell-1})</span> is a valid path on the tree, and if yes with probability <span class="math">p</span> extends this path by <span class="math">m</span> and returns 1. Otherwise, returns 0. On invocation of <span class="math">ver(m_{1},\\ldots,m_{\\ell})</span>, <span class="math">\\mathcal{F}_{\\mathrm{TREE}}^{p}</span> returns 1 if <span class="math">m_{1},\\ldots,m_{\\ell}</span> is a valid path, and 0 otherwise. For simplicity, here we assume that <span class="math">extend</span> and <span class="math">ver</span> take one computational step each.</p>

    <p class="text-gray-300">The SoW protocol is constructed in a similar way as in the ROM; we only have to replace the “<span class="math">H(\\ldots)&lt;2^{\\lambda}-h</span>” checks in Sign and Verify, with invocations to <span class="math">extend</span> and <span class="math">ver</span> on <span class="math">\\mathcal{F}_{\\mathrm{TREE}}^{(2^{\\lambda}-h)/2^{\\lambda}}</span>, respectively (see Algorithm 7). We will consider a slightly stronger version of <span class="math">\\mathcal{F}_{\\mathrm{TREE}}</span>, where the hardness parameter <span class="math">p</span> is a parameter of the function calls. That is because SoW schemes allow for different hardness levels, while the original <span class="math">\\mathcal{F}_{\\mathrm{TREE}}</span> functionality has a fixed hardness level. We note, that the results of <em>[47]</em> can be easily proved for the strengthened functionality.</p>

    <p class="text-gray-300">Algorithm 7 Bitcoin’s SoW implementation based on functionality <span class="math">\\mathcal{F}_{\\mathrm{TREE}}</span>. <span class="math">H</span> is modeled as a RO, while <span class="math">G_{k}</span> is sampled from a collision resistant hash function family <span class="math">\\mathcal{G}</span>. We omit functions PPub, KeyGen which are exactly the same as in Algorithm 6, while differences in Sign, Verify are depicted in red.</p>

    <p class="text-gray-300">1:function <span class="math">\\mathrm{Sign}(pp=(1^{\\lambda},k),vk,msg,h)</span> 2: while <span class="math">true</span> do 3: <span class="math">\\sigma_{1}\\leftarrow\\mathcal{U}_{\\lambda}</span> 4: <span class="math">dig\\leftarrow G_{k}(vk,\\sigma_{1},msg)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: for $\\sigma_{2}=0^{\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> to </span>1^{\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}$ do</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7: return <span class="math">(\\sigma_{1},\\sigma_{2})</span> 8: end if 9: end for 10: end while 11:end function 12: 13:function <span class="math">\\mathrm{Verify}(pp=(1^{\\lambda},k),vk,msg,h,\\sigma=(\\sigma_{1},\\sigma_{2}))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14: return $\\mathcal{F}_{\\mathrm{TREE}}^{(2^{\\lambda}-h)/2^{\\lambda}}.ver(\\bot,vk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(vk,\\sigma_{1},msg)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{2})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">15:end function</p>

    <p class="text-gray-300">The proof that Algorithm 7 implements a secure SoW scheme follows the same arguments as the proof of Theorem 36. We omit the details for the full version of the paper.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 37.</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{G}</span> is a collision resistant hash function family, and we are in the <span class="math">\\mathcal{F}_{\\mathrm{TREE}}</span>-hybrid world, then for any <span class="math">\\sigma\\in(0,1)</span>, Algorithm 7 is</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>correct;</li>

      <li><span class="math">O(\\lambda)</span>-verifiable;</li>

      <li><span class="math">(t_{sign},1-\\left(\\frac{h}{2^{\\lambda}}\\right)^{t_{sign}})</span>-successful, for <span class="math">h\\in[2^{\\lambda}-1]</span>;</li>

      <li>run-time independent;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">((1+\\sigma)(1-\\frac{h}{2^{\\lambda}}),e^{-\\frac{\\beta(h)t\\sigma^{2}}{6}}+\\mathsf{negl}(\\lambda))</span>-MU-TCMA secure w.r.t. any computationally unpredictable function family <span class="math">\\mathcal{F}</span>, for <span class="math">h\\in[2^{\\lambda}-1]</span>.</li>

    </ul>

    <p class="text-gray-300">Comparison with the results of <em>[31]</em>. Since parameter <span class="math">\\epsilon</span> of the MU-TCMA property of <span class="math">\\mathtt{BSOW}</span> is negligible in <span class="math">\\beta(h)\\cdot t</span> and the scheme is runtime independent, we can use Theorem 36 and obtain meaningful bounds for the <span class="math">\\gamma,f</span> quantities introduced in the previous subsection. These quantities are important since <span class="math">\\gamma</span> determines how powerful the adversary our system can handle can be, and <span class="math">f</span> is related to how fast blocks are produced. Replacing with the parameters proved for <span class="math">\\mathtt{BPOW}</span>, for <span class="math">\\sigma\\ll 1</span>, <span class="math">\\gamma</span> and <span class="math">f</span> are equal to:</p>

    <p class="text-gray-300"><span class="math">\\gamma=(n-t)\\cdot(1-\\left(\\frac{h}{2^{\\lambda}}\\right)^{t^{\\prime}_{\\mathcal{H}}})\\cdot\\left(\\frac{h}{2^{\\lambda}}\\right)^{(n-1)t_{\\mathcal{H}}},\\,f=1-\\left(\\frac{h}{2^{\\lambda}}\\right)^{t^{\\prime}_{\\mathcal{H}}(n-t)}</span></p>

    <p class="text-gray-300">Both of these quantities appear in <em>[31]</em> and are well approximated by our results. Hence, <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathtt{BSOW}}</span> implements a robust transaction ledger with overwhelming probability in <span class="math">\\lambda</span> and with bounds comparable to those in <em>[31]</em>, and achieves consensus when the honest parties have the honest majority of the computational power.</p>

    <h2 id="sec-52" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] N. Alon, O. Goldreich, J. Håstad, and R. Peralta. Simple construction of almost k-wise independent random variables. Random Struct. Algorithms, 3(3):289–304, 1992.</li>

      <li>[2] J. Alwen and B. Tackmann. Moderately hard functions: Definition, instantiations, and applications. In Theory of Cryptography - 15th International Conference, TCC 2017, Baltimore, MD, USA, November 12-15, 2017, Proceedings, Part I, pages 493–526, 2017.</li>

      <li>[3] M. Andrychowicz and S. Dziembowski. Pow-based distributed cryptography with no trusted setup. In R. Gennaro and M. Robshaw, editors, Advances in Cryptology - CRYPTO 2015 - 35th Annual Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2015, Proceedings, Part II, volume 9216 of Lecture Notes in Computer Science, pages 379–399. Springer, 2015.</li>

      <li>[4] A. Back. Hashcash-amortizable publicly auditable cost functions. Early draft of paper, 2000.</li>

      <li>[5] A. Back. Hashcash–a denial of service counter-measure, 2002.</li>

      <li>[6] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra, J. Timón, and P. Wuille. Enabling blockchain innovations with pegged sidechains. URL: http://www. opensciencereview. com/papers/123/enablingblockchain-innovations-with-pegged-sidechains, 2014.</li>

      <li>[7] C. Badertscher, U. Maurer, D. Tschudi, and V. Zikas. Bitcoin as a transaction ledger: A composable treatment. In Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I, pages 324–356, 2017.</li>

      <li>[8] M. Ball, A. Rosen, M. Sabin, and P. N. Vasudevan. Proofs of work from worst-case assumptions. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I, pages 789–819, 2018.</li>

      <li>[9] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete security treatment of symmetric encryption. In 38th Annual Symposium on Foundations of Computer Science, FOCS ’97, Miami Beach, Florida, USA, October 19-22, 1997, pages 394–403, 1997.</li>

      <li>[10] M. Bellare, J. Jaeger, and J. Len. Better than advertised: Improved collision-resistance guarantees for md-based hash functions. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS ’17, pages 891–906, New York, NY, USA, 2017. ACM.</li>

      <li>[11] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In CCS ’93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993, pages 62–73, 1993.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[12] M. Bellare and P. Rogaway. The exact security of digital signatures - how to sign with RSA and rabin. In Advances in Cryptology - EUROCRYPT ’96, International Conference on the Theory and Application of Cryptographic Techniques, Saragossa, Spain, May 12-16, 1996, Proceeding, pages 399–416, 1996.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[13] M. Ben-Or. Another advantage of free choice: Completely asynchronous agreement protocols (extended abstract). In R. L. Probert, N. A. Lynch, and N. Santoro, editors, Proceedings of the Second Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, Montreal, Quebec, Canada, August 17-19, 1983, pages 27–30. ACM, 1983.</li>

      <li>[14] I. Bentov, P. Hub’avcek, T. Moran, and A. Nadler. Tortoise and hares consensus: the meshcash framework for incentive-compatible, scalable cryptocurrencies. IACR Cryptology ePrint Archive, 2017:300, 2017.</li>

      <li>[15] D. J. Bernstein and T. Lange. Non-uniform cracks in the concrete: The power of free precomputation. In Advances in Cryptology - ASIACRYPT 2013 - 19th International Conference on the Theory and Application of Cryptology and Information Security, Bengaluru, India, December 1-5, 2013, Proceedings, Part II, pages 321–340, 2013.</li>

      <li>[16] N. Bitansky, S. Goldwasser, A. Jain, O. Paneth, V. Vaikuntanathan, and B. Waters. Time-lock puzzles from randomized encodings. In M. Sudan, editor, Proceedings of the 2016 ACM Conference on Innovations in Theoretical Computer Science, Cambridge, MA, USA, January 14-16, 2016, pages 345–356. ACM, 2016.</li>

      <li>[17] D. Boneh, J. Bonneau, B. Bünz, and B. Fisch. Verifiable delay functions. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I, pages 757–788, 2018.</li>

      <li>[18] M. Borderding. Levels of authentication in distributed agreement. In Ö. Babaoglu and K. Marzullo, editors, Distributed Algorithms, 10th International Workshop, WDAG ’96, Bologna, Italy, October 9-11, 1996, Proceedings, volume 1151 of Lecture Notes in Computer Science, pages 40–55. Springer, 1996.</li>

      <li>[19] R. Canetti. Security and composition of multiparty cryptographic protocols. J. Cryptology, 13(1):143–202, 2000.</li>

      <li>[20] R. Canetti, O. Goldreich, and S. Halevi. The random oracle methodology, revisited. J. ACM, 51(4):557–594, July 2004.</li>

      <li>[21] I. Damgård. A design principle for hash functions. In Advances in Cryptology - CRYPTO ’89, 9th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 1989, Proceedings, pages 416–427, 1989.</li>

      <li>[22] D. Dolev and H. R. Strong. Authenticated algorithms for byzantine agreement. SIAM J. Comput., 12(4):656–666, 1983.</li>

      <li>[23] J. R. Douceur. The sybil attack. In P. Druschel, M. F. Kaashoek, and A. I. T. Rowstron, editors, Peerto-Peer Systems, First International Workshop, IPTPS 2002, Cambridge, MA, USA, March 7-8, 2002, Revised Papers, volume 2429 of Lecture Notes in Computer Science, pages 251–260. Springer, 2002.</li>

      <li>[24] C. Dwork, N. A. Lynch, and L. J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288–323, 1988.</li>

      <li>[25] C. Dwork and M. Naor. Pricing via processing or combatting junk mail. In Proceedings of the 12th Annual International Cryptology Conference on Advances in Cryptology, CRYPTO ’92, pages 139–147, London, UK, UK, 1993. Springer-Verlag.</li>

      <li>[26] P. Feldman and S. Micali. An optimal probabilistic protocol for synchronous byzantine agreement. SIAM J. Comput., 26(4):873–933, 1997.</li>

      <li>[27] M. J. Fischer, N. A. Lynch, and M. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374–382, 1985.</li>

      <li>[28] M. Fitzi. Generalized communication and security models in Byzantine agreement. PhD thesis, ETH Zurich, Zürich, Switzerland, 2003.</li>

      <li>[29] J. A. Garay and A. Kiayias. SoK: A consensus taxonomy in the blockchain era. IACR Cryptology ePrint Archive, 2018:754, 2018.</li>

    </ul>

    <p class="text-gray-300">[30] J. A. Garay, A. Kiayias, and N. Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. IACR Cryptology ePrint Archive, 2014:765, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[31] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology - EUROCRYPT 2015, pages 281–310, 2015.</li>

      <li>[32] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol with chains of variable difficulty. In Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I, pages 291–323, 2017.</li>

      <li>[33] J. A. Garay, A. Kiayias, N. Leonardos, and G. Panagiotakos. Bootstrapping the blockchain, with applications to consensus and fast PKI setup. In Public-Key Cryptography - PKC 2018 - 21st IACR International Conference on Practice and Theory of Public-Key Cryptography, Rio de Janeiro, Brazil, March 25-29, 2018, Proceedings, Part II, pages 465–495, 2018.</li>

      <li>[34] J. A. Garay, A. Kiayias, and G. Panagiotakos. Consensus from signatures of work. Cryptology ePrint Archive, Report 2017/775, 2017. https://eprint.iacr.org/2017/775.</li>

      <li>[35] J. A. Garay, A. Kiayias, and G. Panagiotakos. Iterated search problems and blockchain security under falsifiable assumptions. Cryptology ePrint Archive, Report 2019/315, 2019. https://eprint.iacr.org/2019/315.</li>

      <li>[36] J. A. Garay, P. MacKenzie, M. Prabhakaran, and K. Yang. Resource fairness and composability of cryptographic protocols. Journal of cryptology, 24(4):615–658, 2011.</li>

      <li>[37] M. Jakobsson and A. Juels. Proofs of work and bread pudding protocols. In Proceedings of the IFIP TC6/TC11 Joint Working Conference on Secure Information Networks: Communications and Multimedia Security, CMS ’99, pages 258–272, Deventer, The Netherlands, The Netherlands, 1999. Kluwer, B.V.</li>

      <li>[38] A. Juels and J. G. Brainard. Client puzzles: A cryptographic countermeasure against connection depletion attacks. In Proceedings of the Network and Distributed System Security Symposium, NDSS 1999, San Diego, California, USA. The Internet Society, 1999.</li>

      <li>[39] J. Katz, A. Miller, and E. Shi. Pseudonymous secure computation from time-lock puzzles. IACR Cryptology ePrint Archive, 2014:857, 2014.</li>

      <li>[40] A. Kiayias and G. Panagiotakos. Speed-security tradeoffs in blockchain protocols. Technical report, IACR: Cryptology ePrint Archive, 2015.</li>

      <li>[41] P. C. Kocher. Timing attacks on implementations of diffie-hellman, rsa, dss, and other systems. In Advances in Cryptology - CRYPTO ’96, 16th Annual International Cryptology Conference, Santa Barbara, California, USA, August 18-22, 1996, Proceedings, pages 104–113, 1996.</li>

      <li>[42] L. Lamport, R. E. Shostak, and M. C. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, 1982.</li>

      <li>[43] Y. Lewenberg, Y. Sompolinsky, and A. Zohar. Inclusive block chain protocols. In Financial Cryptography and Data Security, 2015, 2015.</li>

      <li>[44] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>[45] M. Okun. Agreement among unacquainted byzantine generals. In P. Fraigniaud, editor, DISC, volume 3724 of Lecture Notes in Computer Science, pages 499–500. Springer, 2005.</li>

      <li>[46] M. Okun. Distributed computing among unacquainted processors in the presence of byzantine distributed computing among unacquainted processors in the presence of byzantine failures. Ph.D. Thesis Hebrew University of Jerusalem, 2005.</li>

      <li>[47] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In J. Coron and J. B. Nielsen, editors, Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II, volume 10211 of Lecture Notes in Computer Science, pages 643–673, 2017.</li>

    </ul>

    <p class="text-gray-300">[48] M. C. Pease, R. E. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27(2):228–234, 1980.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[49] B. Pfitzmann and M. Waidner. Unconditional byzantine agreement for any number of faulty processors. In STACS 92, 9th Annual Symposium on Theoretical Aspects of Computer Science, Cachan, France, February 13-15, 1992, Proceedings, pages 339–350, 1992.</li>

      <li>[50] A. Poelstra. On stake and consensus (2015). URL https://download. wpsoftware. net/bitcoin/pos. pdf.</li>

      <li>[51] F. B. Schneider. Implementing fault-tolerant services using the state machine approach: A tutorial. ACM Comput. Surv., 22(4):299–319, Dec. 1990.</li>

      <li>[52] Y. Sompolinsky, Y. Lewenberg, and A. Zohar. SPECTRE: A fast and scalable cryptocurrency protocol. IACR Cryptology ePrint Archive, 2016:1159, 2016.</li>

      <li>[53] Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers, pages 507–527, 2015.</li>

      <li>[54] D. Stebila, L. Kuppusamy, J. Rangasamy, C. Boyd, and J. M. G. Nieto. Stronger difficulty notions for client puzzles and denial-of-service-resistant protocols. In Topics in Cryptology - CT-RSA 2011 - The Cryptographers’ Track at the RSA Conference 2011, San Francisco, CA, USA, February 14-18, 2011. Proceedings, pages 284–301, 2011.</li>

    </ul>`;
---

<BaseLayout title="Consensus from Signatures of Work (2017/775)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/775
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
