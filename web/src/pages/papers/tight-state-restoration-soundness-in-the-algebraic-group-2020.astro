---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1351';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Tight State-Restoration Soundness in the Algebraic Group Model';
const AUTHORS_HTML = 'Ashrujit Ghoshal, Stefano Tessaro';

const CONTENT = `    <p class="text-gray-300">Tight State-Restoration Soundness in the Algebraic Group Model</p>

    <p class="text-gray-300">Ashrujit Ghoshal and Stefano Tessaro</p>

    <p class="text-gray-300">Paul G. Allen School of Computer Science & Engineering</p>

    <p class="text-gray-300">University of Washington, Seattle, USA</p>

    <p class="text-gray-300">{ashrujit,tessaro}@cs.washington.edu</p>

    <p class="text-gray-300">Abstract. Most efficient zero-knowledge arguments lack a concrete security analysis, making parameter choices and efficiency comparisons challenging. This is even more true for non-interactive versions of these systems obtained via the Fiat-Shamir transform, for which the security guarantees generically derived from the interactive protocol are often too weak, even when assuming a random oracle.</p>

    <p class="text-gray-300">This paper initiates the study of state-restoration soundness in the algebraic group model (AGM) of Fuchsbauer, Kiltz, and Loss (CRYPTO '18). This is a stronger notion of soundness for an interactive proof or argument which allows the prover to rewind the verifier, and which is tightly connected with the concrete soundness of the non-interactive argument obtained via the Fiat-Shamir transform.</p>

    <p class="text-gray-300">We propose a general methodology to prove tight bounds on state-restoration soundness, and apply it to variants of Bulletproofs (Bootle et al, S&amp;P '18) and Sonic (Maller et al., CCS '19). To the best of our knowledge, our analysis of Bulletproofs gives the first non-trivial concrete security analysis for a non-constant round argument combined with the Fiat-Shamir transform.</p>

    <p class="text-gray-300">Keywords. Zero-knowledge proof systems, concrete security, Fiat-Shamir transform, Algebraic Group Model, state-restoration soundness.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A preliminary version of this paper appears in the proceedings of CRYPTO 2021. This is the full version.</li>

    </ul>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The last decade has seen zero-knowledge proof systems <em>[1]</em> gain enormous popularity in the design of efficient privacy-preserving systems. Their concrete efficiency is directly affected by the choice of a security parameter, yet <em>concrete security</em> analyses are rare and, as we explain below, hit upon technical barriers, even in ideal models (such as the random-oracle <em>[2]</em> or the generic-group models <em>[3, 4]</em>). This has led to parameter choices not backed by proofs, and to efficiency comparisons across protocols with possibly incomparable levels of security. This paper addresses the question of narrowing this gap for protocols whose security can be analyzed in the Algebraic Group Model <em>[5]</em>.</p>

    <p class="text-gray-300">A concrete example. It is convenient to start with an example to illustrate the challenges encountered in proving concrete security of proof systems. We focus on Bulletproofs <em>[6]</em>, which are argument systems with applications across the cryptocurrencies and in verifiably deterministic signatures <em>[9]</em>, which in turn optimize prior work <em>[10]</em>. The soundness analysis (of their interactive version) is asymptotic, based on the hardness of the <em>discrete logarithm problem</em> (DLP). Even when instantiated from 256-bit elliptic curves, due to the absence of a tight, concrete, reduction, we have no formal guarantee on concrete security. Indeed, recent work <em>[11]</em> gives concrete soundness bounds in the generic-group model with somewhat unfavorable dependence on the size of the statement being proved, and no better analysis is known.</p>

    <p class="text-gray-300">Even more importantly, existing bounds are for the <em>interactive</em> version of the protocol, but Bulletproofs are meant to be used <em>non-interactively</em> via the Fiat-Shamir (FS) transform <em>[12]</em>. However, the (folklore) analysis of the FS transform gives no useful guarantees: Namely, for a soundness bound <span class="math">\\varepsilon</span> on the <em>interactive</em> ZK proof system, the resulting NIZK has soundness <span class="math">q^{r}\\varepsilon</span>, where <span class="math">q</span> is the number of random-oracle queries, and <span class="math">r</span> is the number of challenges sent by the verifier. For Bulletproofs, we have <span class="math">\\varepsilon\\geqslant 2^{-256}</span> (this is the probability of merely <em>guessing</em> the discrete log), and if (say) <span class="math">r=\\Theta(\\log(n))\\geqslant 16</span>, we only get security for (<em>at best</em>) <span class="math">q\\leqslant 2^{16}</span> queries, which is clearly insufficient.</p>

    <p class="text-gray-300">Overview of this paper. This paper studies the concrete security of succinct proof systems in the <em>algebraic group model</em> (AGM) <em>[5]</em>, with the goal of developing (near-)exact security bounds. The AGM considers in particular <em>algebraic</em> provers that provide representations of group elements to the reduction (or to the extractor), and has been successful to study security in a variety of contexts. More specifically, this work is the first to look at <em>multi</em>-round <em>public-coin</em> protocols <em>and</em> their non-interactive version obtained via the Fiat-Shamir transform. For the latter, we aim for bounds with <em>linear</em> degradation in the number of random oracle queries <span class="math">q</span> even for a large number of rounds <span class="math">r</span>, as opposed to the <span class="math">q^{r}</span> degradation obtained from naïve analyses. Prior work <em>[5]</em> has focused on the simpler case of linear-PCP based SNARKs <em>[13]</em>, which are built from two-move interactive proofs and without the FS transform.</p>

    <p class="text-gray-300">The soundness of non-interactive systems resulting from the FS transform is tightly related to the <em>state-restoration soundness</em> <em>[14, 15]</em> of the underlying interactive protocol, where the cheating prover can <em>rewind</em> the verifier as it pleases, until it manages to complete a full accepting interaction with the verifier. No non-trivial bounds on state-restoration soundness are currently known on any non-constant round <em>argument</em>.</p>

    <p class="text-gray-300">We propose a general framework to quantitatively study state-restoration version of <em>witness-extended emulation</em> (wee) <em>[16, 17]</em> (which implies both state-restoration soundness and a proof-of-knowledge property) in the AGM. We then and apply it to three case studies, which include two variants of Bulletproofs, as well as Sonic <em>[18]</em>. These protocols have previously been analyzed only with respect to plain soundness in the interactive setting. The analysis of Bulletproofs relies in particular on the Forking Lemma of Bootle <em>et al</em>. <em>[10]</em>, which was only very recently made concrete <em>[11]</em>. We believe that our framework can be applied to a number of other protocols, such as Hyrax <em>[19]</em>, Dory <em>[20]</em> or pairing-based instantiations of IOPs <em>[21, 22]</em>, and leave their analysis for future work.</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">We stress that our approach differs formally from prior and concurrent works (e.g., <em>[18, 22]</em>) which use the AGM to give a heuristic validation of the security of a <em>component</em> of a protocol, which is then however assumed to satisfy extractability properties compatible with a standard-model proof (i.e., an AGM extractor is used as a standard-model extractor.) Here, we aim for full analyses in the AGM, and as we point out in our technical overview below, these approaches actually do not give a full-fledged proof in the AGM (beyond not giving a proof in the standard model either).</p>

    <p class="text-gray-300">Bulletproofs. We apply our framework to two instantiations of Bulletproofs – the first is for <em>range proofs</em>, and the other is for general satisfiability of arithmetic circuits. For example, in the former, a prover shows in <span class="math">O(\\log n)</span> rounds that for a given Pedersen commitment <span class="math">C=g^{v}h^{r}</span> in a cyclic group <span class="math">\\mathbb{G}</span> of prime order <span class="math">p</span> we have <span class="math">v\\in[0,2^{n})</span>. (Here, clearly, <span class="math">2^{n}\\leqslant p</span>.)</p>

    <p class="text-gray-300">For the final non-interactive protocol obtained via the FS transform, our result implies that an (algebraic) <span class="math">t</span>-time prover making <span class="math">q</span> random-oracle queries can break security as a Proof of Knowledge (when properly formalized) with advantage roughly</p>

    <p class="text-gray-300"><span class="math">\\varepsilon(t,q)\\leqslant O(qn/p)+\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)\\;,</span> (1)</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)</span> is the advantage of breaking the DLP within time <span class="math">t</span>. In the generic group model, this is roughly <span class="math">O(t^{2}/p)</span>, and this bound justifies the instantiation of Bulletproofs from a 256-bit curve. For arithmetic circuit satisfiability, we obtain a similar bound.</p>

    <p class="text-gray-300">Tightness and discussion. Assuming <span class="math">\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)\\sim t^{2}/p</span> (which is true in the generic group model), the above bound implies in particular that for most values of <span class="math">n</span>, the term <span class="math">O(qn/p)</span> is not leading. Still, we show that the dependence on <span class="math">n</span> is necessary – in particular, we show that there exist <span class="math">n,p</span> for which we can construct a cheating prover that can break soundness with probability <span class="math">\\Omega(qn/p)</span>, meaning that this part of the bound is tight. (Our argument can be extended to all bounds claimed in the paper.) Also, the term <span class="math">\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)</span> is clearly necessary, given that breaking the DLP would directly give us an attack. This makes our bound essentially exact (up to small constants).</p>

    <p class="text-gray-300">AGM and composition. A challenging aspect of our analysis is the difficulty of dealing with composition. The core of the Bulletproofs is indeed its <span class="math">O(\\log(n))</span>-round <em>inner-product argument</em>. In the standard model, and in the interactive case, it is not hard to reduce the security (as a proof of knowledge) of the full-fledged system using Bulletproofs to the analysis of the underlying inner-product argument, but it is not that clear how to do this generically in the AGM. In particular, in the AGM, the adversary provides representations of group elements to the reduction (or the</p>

    <p class="text-gray-300">extractor), and these are as a function of all priorly given group elements. The problem is that when analyzing a protocol in <em>isolation</em> (such as the inner-product argument) the bases to which elements are described are not necessarily the same as those that would be available to a cheating algebraic prover against the <em>full</em> protocol. This makes it hard to use an extractor for the inner-product argument in isolation as a sub-routine to obtain an extractor for a protocol using it. Also, because we consider state-restoration soundness, a sub-protocol can be initiated by a cheating prover several times, with several choices of these basis elements.</p>

    <p class="text-gray-300">The downside of this is that our analyses are not modular, at least not at a level which considers sub-protocols are isolated building blocks – we give two different analyses for two different instantiations of Bulletproofs, and the shared modularity is at the algebraic level.</p>

    <p class="text-gray-300">We discuss this further at the end of our technical overview below.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Sonic.</h4>

    <p class="text-gray-300">As a second application, we study Sonic <em>[18]</em>. This is a constant-round protocol, and in particular with <span class="math">3M+2</span> challenges for some constant <span class="math">M\\geq 1</span>. In this case, the folklore analysis of the FS transform can be used to obtain a non-trivial bound, incurring a multiplicative loss of <span class="math">q^{3M+2}</span> from the soundness of the interactive version. Here, we want to show that this loss is not necessary and also obtain a bound which degrades linearly in <span class="math">q</span>. Moreover, no concrete bound on the concrete soundness of Sonic was given in the interactive setting.</p>

    <p class="text-gray-300">We ignore the stronger requirement of updatable witness-extended emulation because our pedagogical point here is that our framework can improve soundness even for constant-round protocols.</p>

    <p class="text-gray-300">We also note that Sonic’s proof already uses the AGM to justify security of the underlying polynomial commitment scheme, but follows a (heuristic) pattern described above where the resulting extractor is expected to behave as a standard-model one, and is used within a standard-model proof.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Adaptive vs non-adaptive soundness.</h4>

    <p class="text-gray-300">It is important to understand that one can consider both <em>adaptive</em> and <em>non-adaptive</em> provers, where the former also chooses the <em>input</em> for which it attempts to provide a proof. Clearly, one expects adaptive provers to be harder to handle, but this is not necessarily true for <em>algebraic</em> provers – in particular, <em>if</em> the input contains group elements, the extractor can obtain useful information (and, possibly, directly extract) from their group representation. While this does not render the proof trivial at all, it turns out that for non-adaptive security, the proof is <em>even harder</em>. In this paper, we deal mostly with adaptive provers, but for the case of range proofs (where the inputs are commitments in a group), we also give a proof for non-adaptive security – the resulting bound is increased to the square root of the adaptive bound, due to our limited use of rewinding.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Related work: Proofs vs arguments.</h4>

    <p class="text-gray-300">We clarify that state-restoration soundness has been studied for several forms of interactive <em>proofs</em> <em>[14, 15, 23, 24]</em>, also in its equivalent form of “round-by-round” soundness. Some proof systems satisfy it directly (such as those based on the sumcheck protocol <em>[25]</em>), whereas any proof with non-trivial (plain) soundness can be amplified into one with sufficient stare-restoration soundness (e.g., with parallel repetition). This is because (similar to our statement about the Fiat-Shamir transform above) one can naïvely infer that a concrete soundness bound <span class="math">\\varepsilon</span> implies a state-restoration soundness bound <span class="math">q^{r}\\varepsilon</span>, where <span class="math">r</span> is the number of challenges, and thus <span class="math">\\varepsilon</span> needs to be smaller than <span class="math">q^{-r}</span>.</p>

    <p class="text-gray-300">However, we do not know of any non-trivial bounds on state-restoration soundness for multi-round arguments based on computational assumptions (as opposed to, say, arguments in the</p>

    <p class="text-gray-300">ROM), and moreover, soundness amplification (e.g., <em>[26, 27, 28, 29]</em>) does not reduce soundness beyond the largest negligible function, and this is insufficient to absorb the <span class="math">q^{r}</span> loss.</p>

    <p class="text-gray-300">Beyond the AGM. Our results are inherently based on online extraction, which is only meaningful in ideal models or using knowledge assumptions. One scenario where ideal models are inherently used is in the compilation of IOPs into NIZKs in the ROM via the BCS transform <em>[14]</em> – it is unclear whether our technique can be used to give tight state-restoration soundness bounds for systems such as Aurora <em>[30]</em> and STARK <em>[31]</em>.</p>

    <p class="text-gray-300">Concurrent Work. In a recently updated version of <em>[32]</em>, Bünz et. al. analyse the soundness of the non-interactive inner-product argument of Bulletproofs in the AGM. We provide a brief comparison with their result Appendix A,but note here that their analysis is asymptotic, and gives weaker concrete security (insufficient for instantiations on 256-bit curves) when made concrete.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Overview of our Techniques</h3>

    <p class="text-gray-300">We give a general framework to derive tight bounds on state-restoration soundness in the AGM. In fact, we will target the stronger notion of <em>witness-extended emulation</em> <em>[16, 17]</em>, which we adapt to state-restoration provers. Recall first that the main characteristic of the AGM is that it allows the reduction, or in our case the extractor, to access representations of group elements. A contribution of independent interest is to set up a formal framework to define extraction in the AGM.</p>

    <p class="text-gray-300">Preface: Online Extraction in the AGM. In the AGM, the reduction (or an extractor) obtains <em>representations</em> of each group element in terms of all previously seen group elements. A useful feature of the AGM is that it often (but not always) allows us to achieve <em>online witness extraction</em>, as already observed in <em>[5, 33]</em>. In other words, by looking at the representation of the group elements provided by the prover <em>in a single interaction</em>, the extractor is able to extract a witness, without the need of rewinding.</p>

    <p class="text-gray-300">Online extraction however immediately appears to be very useful to tame the complexity of state-restoration provers. Indeed, one can visualize an interaction of an adversarial state-restoration prover <span class="math">\\mathcal{P}^{<em>}</span> with the verifier <span class="math">V</span> as defining an </em>execution tree<em>. In particular, <span class="math">\\mathcal{P}^{</em>}</span> wins if it manages to create a path in the execution tree associated with an accepting (simple) transcript</p>

    <p class="text-gray-300"><span class="math">\\tau=\\left(a_{1},c_{1},a_{2},\\ldots,c_{r},a_{r+1}\\right)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">a_{1},a_{2},\\ldots,a_{r+1}</span> are <span class="math">\\mathcal{P}^{<em>}</span>’s messages, and <span class="math">c_{1},\\ldots,c_{r}</span> are the verifier’s challenges. (We focus on public-coin protocols here.) Online extraction from a single transcript <span class="math">\\tau</span> </em>directly<em> implies extraction here, because a witness can directly be extracted </em>locally<em> from the path <span class="math">\\tau</span> (and the corresponding representations of group elements), disregarding what happened in the rest of the execution tree. In particular, the probability that <span class="math">\\mathcal{P}^{</em>}</span> succeeds equals the probability that a witness is extracted. Without online extraction, we would have to use rewinding – but current techniques <em>[10, 11]</em> do not seem to easily extend to state-restoration provers.</p>

    <p class="text-gray-300">However, this only holds for <em>perfect</em> online extraction – in general, we may be able to generate transcripts which are accepting, but for which no witness can be extracted. This is typically because of two reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bad Challenges. A bad choice of challenges may prevent witness extraction.</li>

      <li>Violating an assumption. A transcript is accepting, but the resulting interaction corresponds to a violation of some underlying assumption (i.e., one can extract a non-trivial discrete logarithm relation).</li>

    </ul>

    <p class="text-gray-300">Our framework will exactly follow this pattern. For an <span class="math">r</span>-challenge public-coin protocol, we identify bad challenges, i.e., for each <span class="math">i\\in[r]</span>, input <span class="math">x</span>, and partial transcript <span class="math">\\tau^{\\prime}=(a_{1},c_{1},\\ldots,a_{i-1},c_{i-1},a_{i})</span>, we define a set of bad challenges <span class="math">c_{i}</span> which would make extraction impossible. Crucially, these sets are defined according to a <em>simple interaction transcript</em> (i.e., not a state-restoration one) and can be defined according to the representation of group elements in the transcript so far. Then, given a transcript <span class="math">\\tau</span> with no bad challenges, we show that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We can either extract a witness for <span class="math">x</span> from <span class="math">\\tau</span> (and the representations of the group elements in <span class="math">\\tau</span>).</li>

      <li>We can use <span class="math">\\tau</span> (and the representation of the group elements in terms of the public parameters) to break some underlying assumption.</li>

    </ul>

    <p class="text-gray-300">To illustrate this, we give a non-trivial example next, which considers a simplified instance of the inner product argument at the core of Bulletproofs, but which already captures all subtleties of the model.</p>

    <p class="text-gray-300">Inner-Product Argument of Bulletproofs. In the inner product argument the prover proves that a group element <span class="math">P\\in\\mathbb{G}</span> is a well-formed commitment to vectors <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}</span> and their inner-product <span class="math">\\langle\\mathbf{a},\\mathbf{b}\\rangle</span>. More precisely, the prover wants to prove to the verifier that <span class="math">P=\\mathbf{g^{a}h^{b}}u^{\\langle\\mathbf{a},\\mathbf{b}\\rangle}</span> where <span class="math">\\mathbf{g}\\in\\mathbb{G}^{n},\\mathbf{h}\\in\\mathbb{G}^{n},u\\in\\mathbb{G}</span> are independent generators of <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">Here, we shall focus on the special case <span class="math">n=2</span> first, and below discuss challenges in scaling our analysis up to any <span class="math">n</span>. The prover first sends to the verifier group elements <span class="math">L,R</span> where</p>

    <p class="text-gray-300"><span class="math">L=g_{2}^{a_{1}}h_{1}^{b_{2}}u^{a_{1}b_{2}}\\ ,\\ R=g_{1}^{a_{2}}h_{2}^{b_{1}}u^{a_{2}b_{1}}\\ .</span></p>

    <p class="text-gray-300">The verifier samples <span class="math">x</span> uniformly at random from <span class="math">\\mathbb{Z}_{p}^{*}</span> and sends it to the prover. We then define</p>

    <p class="text-gray-300"><span class="math">P^{\\prime}=L^{x^{2}}PR^{x^{-2}}\\ ,\\ g^{\\prime}=g_{1}^{x^{-1}}g_{2}^{x}\\ ,\\ h^{\\prime}=h_{1}^{x}h_{2}^{x^{-1}}\\ .</span></p>

    <p class="text-gray-300">The prover sends <span class="math">a^{\\prime}=a_{1}x+a_{2}x^{-1}</span> and <span class="math">b^{\\prime}=b_{1}x^{-1}+b_{2}x</span> to the verifier, which in turns accepts if and only if</p>

    <p class="text-gray-300"><span class="math">P^{\\prime}=(g^{\\prime})^{a^{\\prime}}(h^{\\prime})^{b^{\\prime}}u^{a^{\\prime}b^{\\prime}}\\ .</span></p>

    <p class="text-gray-300">Extraction for <span class="math">n=2</span>. For this discussion, we focus in particular on the notion of <em>adaptive</em> soundness – i.e., the prover provides <span class="math">P</span> along with its representation, i.e, we get <span class="math">\\mathbf{a}^{\\prime}=(p_{g_{1}},p_{g_{2}})</span>, <span class="math">\\mathbf{b}^{\\prime}=(p_{h_{1}},p_{h_{2}})</span> and <span class="math">p_{u}</span> such that <span class="math">P=\\mathbf{g^{a^{\\prime}}h^{b^{\\prime}}}u^{p_{u}}</span>. At first, it looks like we are done – after all, we can just check whether <span class="math">\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle=p_{u}</span>, and if so, output <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime})</span> as our witness. Unfortunately, things are not <em>that</em> simple – we need to ensure that no accepting transcript <span class="math">\\tau=((L,R),x,(a^{\\prime},b^{\\prime}))</span>, i.e., such that <span class="math">P^{\\prime}=(g^{\\prime})^{a^{\\prime}}(h^{\\prime})^{b^{\\prime}}u^{a^{\\prime}b^{\\prime}}</span>, is ever produced if <span class="math">\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle\\neq p_{u}</span>, for otherwise our naïve extraction would fail.</p>

    <p class="text-gray-300">To this end, we will prove that if the cheating prover can produce an accepting interaction such while <span class="math">\\langle\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime}\\rangle\\neq p_{u}</span>, then we can solve the discrete logarithm problem in the group <span class="math">\\mathbb{G}</span>. We construct an adversary <span class="math">\\mathcal{A}</span> that takes as inputs <span class="math">g_{1},g_{2},h_{1},h_{2},u</span> and attempts to return a non-trivial discrete logarithm relation between them. (Breaking this is <em>tightly</em> equivalent to breaking the discrete logarithm problem.) Concretely, the adversary <span class="math">\\mathcal{A}</span> gives <span class="math">g_{1},g_{2},h_{1},h_{2},u</span> as input to the cheating prover <span class="math">\\mathcal{P}</span>, which first returns an adaptively chosen input <span class="math">P\\in\\mathbb{G}</span>, along with is algebraic representation</p>

    <p class="text-gray-300"><span class="math">P=g_{1}^{p_{g_{1}}}g_{2}^{p_{g_{2}}}h_{1}^{p_{h_{1}}}h_{2}^{p_{h_{2}}}u^{p_{u}}\\ .</span></p>

    <p class="text-gray-300">The adversary then simulates the execution of <span class="math">\\mathcal{P}</span> with a honest verifier further, and assumes it generates an accepting transcript <span class="math">\\tau=((L,R),x,(a^{\\prime},b^{\\prime}))</span> – this transcript contains the representations of <span class="math">L,R</span> such that <span class="math">L=g_{1}^{l_{g_{1}}}g_{2}^{l_{g_{2}}}h_{1}^{l_{h_{1}}}h_{2}^{l_{h_{2}}}u^{l_{u}}</span> and <span class="math">R=g_{1}^{r_{g_{1}}}g_{2}^{r_{g_{2}}}h_{1}^{r_{h_{1}}}h_{2}^{r_{h_{2}}}u^{r_{u}}</span> and since it is an accepting transcript we have</p>

    <p class="text-gray-300"><span class="math">L^{x^{2}}PR^{x^{-2}}=g_{1}^{x^{-1}a^{\\prime}}g_{2}^{x^{1}a^{\\prime}}h_{1}^{x^{1}b^{\\prime}}h_{2}^{x^{-1}b^{\\prime}}u^{a^{\\prime}b^{\\prime}}\\;.</span></p>

    <p class="text-gray-300">We can plug in the representations of <span class="math">L</span>, <span class="math">R</span> into the equality and obtain values <span class="math">e_{g_{1}},e_{g_{2}},e_{h_{1}},e_{h_{2}},e_{u}</span> such that</p>

    <p class="text-gray-300"><span class="math">g_{1}^{e_{g_{1}}}g_{2}^{e_{g_{2}}}h_{1}^{e_{h_{1}}}h_{2}^{e_{h_{2}}}u^{e_{u}}=1\\;.</span> (2)</p>

    <p class="text-gray-300">For example <span class="math">e_{g_{1}}=x^{-1}a^{\\prime}-l_{g_{1}}x^{2}-r_{g_{1}}x^{-2}-p_{g_{1}}</span> and <span class="math">e_{u}=a^{\\prime}b^{\\prime}-l_{u}x^{2}-r_{u}x^{-2}-p_{u}</span>.</p>

    <p class="text-gray-300">The adversary <span class="math">\\mathcal{A}</span> then simply outputs <span class="math">(e_{g_{1}},e_{g_{2}},e_{h_{1}},e_{h_{2}},e_{u})</span> – it has found a non-trivial discrete logarithm relation if <span class="math">(e_{g_{1}},e_{g_{2}},e_{h_{1}},e_{h_{2}},e_{u})\\neq(0,0,0,0,0)</span>, which we next show happens with very high probability if <span class="math">p_{u}\\neq p_{g_{1}}p_{h_{1}}+p_{g_{2}}p_{h_{2}}</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">(e_{g_{1}},e_{g_{2}},e_{h_{1}},e_{h_{2}},e_{u})=(0,0,0,0,0)</span>. From <span class="math">e_{g_{1}}=0</span>, we have that <span class="math">x^{-1}a^{\\prime}-l_{g_{1}}x^{2}-r_{g_{1}}x^{-2}-p_{g_{1}}=0</span>. Since <span class="math">x\\neq 0</span>, we get that <span class="math">a^{\\prime}=l_{g_{1}}x^{3}+r_{g_{1}}x^{-1}+p_{g_{1}}x</span>. Similarly from <span class="math">e_{g_{2}}=0</span>, we would get <span class="math">a^{\\prime}=l_{g_{2}}x+p_{g_{2}}x^{-1}+r_{g_{2}}x^{-3}</span>. With high probability over the choice of <span class="math">x</span>’s, by the Schwartz-Zippel Lemma, we can infer by equating both right-hand sides that</p>

    <p class="text-gray-300"><span class="math">a^{\\prime}=xp_{g_{1}}+x^{-1}p_{g_{2}}\\;.</span></p>

    <p class="text-gray-300">Similarly, from <span class="math">e_{h_{1}}=0</span> and <span class="math">e_{h_{2}}=0</span>, we obtain that</p>

    <p class="text-gray-300"><span class="math">b^{\\prime}=x^{-1}p_{h_{1}}+xp_{h_{2}}</span></p>

    <p class="text-gray-300">for most <span class="math">x</span>’s. Finally, from <span class="math">e_{u}=0</span>, we similarly learn that</p>

    <p class="text-gray-300"><span class="math">a^{\\prime}b^{\\prime}=x^{2}l_{u}+p_{u}+x^{-2}r_{u}\\;.</span></p>

    <p class="text-gray-300">Hence from the above</p>

    <p class="text-gray-300"><span class="math">x^{2}l_{u}+p_{u}+x^{-2}r_{u}=p_{g_{1}}p_{h_{1}}+p_{g_{2}}p_{h_{2}}+p_{g_{1}}p_{h_{2}}x^{2}+p_{g_{2}}p_{h_{1}}x^{-2}\\;.</span></p>

    <p class="text-gray-300">Since we have that <span class="math">p_{g_{1}}p_{h_{1}}+p_{g_{2}}p_{h_{2}}\\neq p_{u}</span>, the above equality holds with very small probability over the choice of <span class="math">x</span>’s.</p>

    <p class="text-gray-300">Hence we have shown that <span class="math">(e_{g_{1}},e_{g_{2}},e_{h_{1}},e_{h_{2}},e_{u})=(0,0,0,0,0)</span> with very small probability. Therefore <span class="math">\\mathcal{A}</span> succeeds with high probability.</p>

    <p class="text-gray-300">Non-adaptive security. The above proof exploits the fact that the prover provides a representation of <span class="math">P</span> – this corresponds to the case of an adaptive prover. But there are scenarios where the prover may be non-adaptive and not be able to do that – for example, the input <span class="math">P</span> has been generated by another party, and the prover tries to prove knowledge with respect to this <span class="math">P</span>. It turns out that in this case, one needs a different proof. In fact, one could give an extraction strategy which does not require knowing an initial representation for <span class="math">P</span>, but it is then hard to give a reduction to the discrete logarithm problem to show correctness.</p>

    <p class="text-gray-300">We stress that non-adaptive provers and adaptive provers are equivalent in many applications – they only differ when the input includes group elements. We give a formalization and a case study (for Bulletproofs range proofs) in Section 7. There, we can actually give a reduction to the discrete logarithm problem (to bound the probability of failing to extract), but this requires rewinding once – this allows us to prove a bound which is the square root of the bound for adaptive provers.</p>

    <p class="text-gray-300">The recursive protocol for <span class="math">n=4</span>. Scaling the protocol to an arbitrary <span class="math">n</span> proceeds via recursion. For concreteness, let us focus on the case <span class="math">n=4</span>. The prover first sends to the verifier group elements <span class="math">L,R</span> where</p>

    <p class="text-gray-300"><span class="math">L=g_{3}^{a_{1}}g_{4}^{a_{2}}h_{1}^{b_{3}}h_{2}^{b_{4}}u^{a_{1}b_{3}+a_{2}b_{4}}\\ ,\\ R=g_{1}^{a_{3}}g_{2}^{a_{4}}h_{3}^{b_{1}}h_{4}^{b_{2}}u^{a_{3}b_{1}+a_{4}b_{2}}\\ .</span></p>

    <p class="text-gray-300">The verifier samples <span class="math">x</span> uniformly at random from <span class="math">\\mathbb{Z}_{p}^{*}</span> and sends it to the prover. The prover and the verifier both compute</p>

    <p class="text-gray-300"><span class="math">P^{\\prime}=L^{x^{2}}PR^{x^{-2}}\\ ,\\ g_{1}^{\\prime}=g_{1}^{x^{-1}}g_{3}^{x}\\ ,\\ g_{2}^{\\prime}=g_{2}^{x^{-1}}g_{4}^{x}\\ ,\\ h_{1}^{\\prime}=h_{1}^{x}h_{3}^{x^{-1}}\\ ,\\ h_{2}^{\\prime}=h_{2}^{x}h_{4}^{x^{-1}}\\ .</span></p>

    <p class="text-gray-300">The prover also computes <span class="math">a_{1}^{\\prime}=a_{1}x+a_{3}x^{-1}</span>, <span class="math">a_{2}^{\\prime}=a_{2}x+a_{4}x^{-1}</span>, <span class="math">b_{1}^{\\prime}=b_{1}x^{-1}+b_{3}x</span> and <span class="math">b_{2}^{\\prime}=b_{2}x^{-1}+b_{4}x</span>. Observe that</p>

    <p class="text-gray-300"><span class="math">P^{\\prime}=(g_{1}^{\\prime})^{a_{1}^{\\prime}}(g_{2}^{\\prime})^{a_{2}^{\\prime}}(h_{1}^{\\prime})^{b_{1}^{\\prime}}(h_{3}^{\\prime})^{b_{2}^{\\prime}}u^{a_{1}^{\\prime}b_{1}^{\\prime}+a_{2}^{\\prime}b_{2}^{\\prime}}\\ .</span></p>

    <p class="text-gray-300">Now, the prover and the verifier engage, recursively, in the protocol for <span class="math">n=2</span> with inputs</p>

    <p class="text-gray-300"><span class="math">(g_{1}^{\\prime},g_{2}^{\\prime}),(h_{1}^{\\prime},h_{2}^{\\prime}),u,P^{\\prime},(a_{1}^{\\prime},a_{2}^{\\prime}),(b_{1}^{\\prime},b_{2}^{\\prime})\\ .</span></p>

    <p class="text-gray-300">The difficulty in analyzing this is that we would like our proof strategy to be recursive, i.e., given we analyzed the protocol for <span class="math">n</span> secure, we can now infer that the one for <span class="math">2n</span> also is secure. This will not be so direct, unfortunately. One major technical issue is for example that the recursive call uses different generators than the ones used for the calling protocol – in our case, here, <span class="math">(g_{1}^{\\prime},g_{2}^{\\prime}),(h_{1}^{\\prime},h_{2}^{\\prime})</span> – however, when looking at the combined protocol in the AGM, all element representations would be with respect to the generators <span class="math">g_{1},\\ldots,g_{4},h_{1},\\ldots,h_{4}</span>, and this makes it difficult to directly recycle the above analysis.</p>

    <p class="text-gray-300">The challenges with composition. The inability to leverage recursion to simplify the approach from the previous paragraph is not an isolated incident. We note that a non-trivial aspect of our analyses is due to the lack of easy composition properties in the AGM. In particular, we encounter the following problem – if we have a protocol <span class="math">\\Pi^{\\prime}</span> (e.g., the inner-product argument) which is used as a sub-protocol for <span class="math">\\Pi</span> (a Bulletproofs range proof), and we prove extractability for <span class="math">\\Pi^{\\prime}</span>, it is not clear we can infer extractability for <span class="math">\\Pi</span> in a modular way by just calling the extractor for <span class="math">\\Pi^{\\prime}</span>. This is because a stand-alone analysis of <span class="math">\\Pi^{\\prime}</span> may assume group elements output by a malicious prover <span class="math">\\mathcal{P}^{\\prime}</span> are represented with respect to some set of basis elements – say, the generators <span class="math">g_{1},\\ldots,g_{n},h_{1},\\ldots,h_{n},u</span> in the concrete example of inner-product argument described above. However, when <span class="math">\\Pi^{\\prime}</span> is used within <span class="math">\\Pi</span>, the generators of the inner-product argument are functions of different group elements. When studying a prover <span class="math">\\mathcal{P}</span> attacking <span class="math">\\Pi</span>, then, representations of group elements are with respect to this different set of group elements, and this makes it hard to use an extractor for <span class="math">\\Pi^{\\prime}</span> directly, as it assumes different representations.</p>

    <p class="text-gray-300">This is a problem we encounter in our analyses, and which prevents us from abstracting a theorem for the inner-product argument which we could use, in a plug-and-play way, to imply security of higher-level protocols using it. The flip side is that this lack of composability also comes to our advantage – our extractors will in fact not even need to extract anything from the transcript of an accepting execution of the inner-product argument, but only use the fact that it is accepting to infer correctness of the extracted value.</p>

    <p class="text-gray-300">The issue with prior AGM analyses. Composition issues seemingly affect existing analyses of proof systems in the literature (e.g., <em>[18, 22]</em>), whenever some components are analyzed in the AGM (typically, a polynomial commitment scheme), but the overall proof is expressed in the standard model. As far as we can tell, unlike this work, one cannot directly extract a full AGM analysis from these works – let us elaborate on this.</p>

    <p class="text-gray-300">Obviously, from a purely formal perspective, the standard model and the algebraic group model cannot be quite mixed, as in particular the AGM extractor for the component cannot be used in the standard model – the only formally correct way to interpret the analysis is as <em>fully</em> in the AGM, but part of the analysis does not leverage the full power of the model, and is effectively a standard-model reduction. Yet, in order for composition to be meaningful, it is important to verify that the basis elements assumed in the AGM analysis of the components are the same available to a prover attacking the complete protocol. While we cannot claim any issues (in fact, we give an analysis of Sonic in this paper with a concrete bound), it does appear that all existing works do not attempt to provide a formal composition – they use the existence of an AGM extractor as a heuristic validation for the existence of a standard-model extractor, rather than making formally correct use as an AGM extractor within an AGM proof. Making this composition sound is potentially non-trivial. Having said this, for pairing-based polynomial commitment schemes, the basis elements are generally the same, and thus this can likely be made rigorous fairly easily (unlike the case of inner-product arguments).</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Let <span class="math">\\mathbb{N}=\\{0,1,2,\\ldots\\}</span> represent the set of all natural numbers and let <span class="math">\\mathbb{N}^{+}=\\mathbb{N}\\backslash\\{0\\}</span>. For <span class="math">N\\in\\mathbb{N}^{+}</span>, let <span class="math">[N]=\\{1,\\ldots,N\\}</span>. We use <span class="math">\\mathsf{Pr}\\left[\\mathsf{G}\\right]</span> to denote the probability that the game <span class="math">\\mathsf{G}</span> returns true. Let <span class="math">\\mathbb{G}</span> be a cyclic group of prime order <span class="math">p</span> with identity <span class="math">1</span> and let <span class="math">\\mathbb{G}^{*}=\\mathbb{G}\\backslash\\{1\\}</span> be the set of its generators. We use boldface to denote a vector, e.g., <span class="math">\\mathbf{g}\\in\\mathbb{G}^{n}</span> is a vector of <span class="math">n</span> group elements with its <span class="math">i^{\\text{th}}</span> element being <span class="math">g_{i}</span>, i.e., <span class="math">\\mathbf{g}=(g_{1},\\ldots,g_{n})</span>. For two vectors <span class="math">\\mathbf{a}=(a_{1},\\ldots,a_{n}),\\mathbf{g}=(g_{1},\\ldots,g_{n})</span>, we use <span class="math">\\mathbf{g}^{\\mathbf{a}}</span> to denote <span class="math">\\prod_{i=1}^{n}g_{i}^{a_{i}}</span>. We use python notation to denote slices of vectors:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}_{[:l]}=(g_{1},\\ldots,g_{l})\\in\\mathbb{G}^{l}\\ ,\\ \\mathbf{g}_{[l:]}=(g_{l+1},\\ldots,g_{n})\\in\\mathbb{G}^{n-l}\\ .</span></p>

    <p class="text-gray-300">For <span class="math">z\\in\\mathbb{Z}_{p}^{*}</span>, we use <span class="math">\\mathbf{z}^{n}</span> to denote the vector <span class="math">(1,z,z^{2},\\ldots,z^{n-1})</span>. Similarly, we use <span class="math">\\mathbf{z}^{-n}</span> to denote the vector <span class="math">(1,z^{-1},z^{-2},\\ldots,z^{-n+1})</span>. If <span class="math">Z</span> is a variable, <span class="math">\\mathbf{Z}^{n}</span> represents the vector <span class="math">(1,Z,Z^{2},\\ldots,Z^{n-1})</span>. Our vectors are indexed starting from <span class="math">1</span>, so <span class="math">\\mathbf{z}^{n+1}_{[1:]}</span> is the vector <span class="math">(z,z^{2},\\ldots,z^{n})</span>. The operator <span class="math">\\circ</span> denotes the Hadamard product of two vectors, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}=(a_{1},\\ldots,a_{n})\\ ,\\ \\mathbf{b}=(b_{1},\\ldots,b_{n})\\ ,\\ \\mathbf{a}\\circ\\mathbf{b}=(a_{1}b_{1},\\ldots,a_{n}b_{n})\\ .</span></p>

    <p class="text-gray-300">We use capitalized boldface letters to denote matrices, e.g., <span class="math">\\mathbf{W}\\in\\mathbb{Z}_{p}^{n\\times m}</span> is a matrix with <span class="math">n</span> rows and <span class="math">m</span> columns.</p>

    <p class="text-gray-300">We denote the inner product of two vectors <span class="math">\\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}_{p}^{n}</span> using <span class="math">\\langle\\mathbf{a},\\mathbf{b}\\rangle</span>. We also define vector polynomials, e.g., <span class="math">f(X)=\\sum_{i=0}^{d}\\mathbf{f}_{i}X^{i}</span>, where each coefficient <span class="math">\\mathbf{f}_{i}</span> is a vector in <span class="math">\\mathbb{Z}_{p}^{n}</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{bit}(k,i,t)</span> returns the bit <span class="math">k_{i}</span> where <span class="math">(k_{1},\\ldots,k_{t})</span> is the <span class="math">t</span>-bit representation of <span class="math">k</span>.</p>

    <p class="text-gray-300">Schwartz-Zippel Lemma. The polynomial ring in variables <span class="math">X_{1},\\ldots,X_{n}</span> over the field <span class="math">\\mathbb{F}</span> is denoted by <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{n}]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game GdG(A,λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game GdG,rel(A,λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game GdGrd(A,λ):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g←S Gλ*; h←S Gλ</td>

            <td class="px-3 py-2 border-b border-gray-700">g1, ..., gn←S Gλ</td>

            <td class="px-3 py-2 border-b border-gray-700">g←S Gλ*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">a←Aλ(g,h)</td>

            <td class="px-3 py-2 border-b border-gray-700">(a1, ..., an)←Aλ(g1, ..., gn)</td>

            <td class="px-3 py-2 border-b border-gray-700">x←Zp(λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (ga=h)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return (∫i=1gai=1 ∧ (a1, ..., an) ≠ 0n)</td>

            <td class="px-3 py-2 border-b border-gray-700">x'←Aλ(∫gaddg=q)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">i=1</td>

            <td class="px-3 py-2 border-b border-gray-700">Return (x=x')</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig.1. The games used to define the advantage of a non-uniform adversary  <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  against the discrete logarithm problem, the discrete logarithm relation problem and the  <span class="math">q</span> -DLOG problem in a family of cyclic groups  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  with prime order order  <span class="math">p = p(\\lambda)</span> . The set  <span class="math">\\mathbb{G}_{\\lambda}^{*}</span>  is the set of generators of  <span class="math">\\mathbb{G}_{\\lambda}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 1 (Schwartz-Zippel Lemma). Let  <span class="math">\\mathbb{F}</span>  be a finite field and let  <span class="math">f\\in \\mathbb{F}[X_1,\\ldots ,X_n]</span>  be a non-zero  <span class="math">n</span>  variate polynomial with maximum degree  <span class="math">d</span> . Let  <span class="math">S</span>  be a subset of  <span class="math">\\mathbb{F}</span> . Then  $\\operatorname*{Pr}\\left[f(x_1,\\dots,x_n) = 0\\right]\\leqslant d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , where the probability is over the choice of  </span>x_{1},\\ldots ,x_{n}<span class="math">  according to  </span>x_{i}\\gets s S$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In particular if  <span class="math">p</span>  is a prime and  <span class="math">f \\in \\mathbb{Z}_p[X]</span>  is a polynomial of degree  <span class="math">d</span>  and  <span class="math">x</span>  is sampled uniformly at random from  <span class="math">\\mathbb{Z}_p^<em></span> , then  <span class="math">\\operatorname</em>{Pr}[f(x) = 0] \\leqslant d / (p - 1)</span> . Further this implies that if  <span class="math">g(X) = f(X) / X^i</span>  for  <span class="math">i \\in \\mathbb{N}</span>  and  <span class="math">x</span>  is sampled uniformly at random from  <span class="math">\\mathbb{Z}_p^<em></span> , then  <span class="math">\\operatorname</em>{Pr}[g(x) = 0] = \\operatorname*{Pr}[f(x) = 0] \\leqslant d / (p - 1)</span> .</p>

    <p class="text-gray-300">THE DISCRETE LOGARITHM PROBLEM. The game  <span class="math">\\mathsf{G}_{\\mathbb{G}}^{\\mathrm{dl}}</span>  in Figure 1 is used for defining the advantage of a non-uniform adversary  <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  against the discrete logarithm problem in a family of cyclic groups  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  of prime order  <span class="math">p = p(\\lambda)</span>  with identity 1 and set of generators  <span class="math">\\mathbb{G}^{<em>} = \\{\\mathbb{G}_{\\lambda}^{</em>}\\}_{\\lambda \\in \\mathbb{N}^{+}} = \\{\\mathbb{G}_{\\lambda} \\backslash \\{1\\}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> . We define</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} (\\mathcal {A}, \\lambda) = \\Pr \\left[ \\mathsf {G} _ {\\mathbb {G}} ^ {\\mathrm {d l}} (\\mathcal {A}, \\lambda) \\right].</span></div>

    <p class="text-gray-300">THE DISCRETE LOGARITHM RELATION PROBLEM. The game  <span class="math">\\mathsf{G}_{\\mathbb{G},n}^{\\mathrm{dl - rel}}</span>  in Figure 1 is used for defining the advantage of a non-uniform adversary  <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  against the discrete logarithm relation problem in a family of cyclic groups  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> . We define  <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathbb {G}, n} ^ {\\mathrm {d l - r e l}} (\\mathcal {A}, \\lambda) = \\Pr \\left[ \\mathbb {G} _ {\\mathbb {G}, n} ^ {\\mathrm {d l - r e l}} (\\mathcal {A}, \\lambda) \\right].</span></div>

    <p class="text-gray-300">The following lemma shows that hardness of the discrete logarithm relation problem in  <span class="math">\\mathbb{G}</span>  is tightly implied by the hardness of discrete logarithm problem in a family of cyclic groups  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> .</p>

    <p class="text-gray-300">Lemma 2. Let  <span class="math">n \\in \\mathbb{N}^+</span> . Let  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  be a family of cyclic groups with order  <span class="math">p = p(\\lambda)</span> . For every non-uniform adversary  <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  there exists a non-uniform adversary  <span class="math">\\mathcal{B} = \\{\\mathcal{B}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  such that for all  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span> ,  <span class="math">\\operatorname{Adv}_{\\mathbb{G},n}^{\\mathrm{dl - rel}}(\\mathcal{A},\\lambda) \\leqslant \\operatorname{Adv}_{\\mathbb{G}}^{\\mathrm{dl}}(\\mathcal{B},\\lambda) + 1 / p</span> . Moreover,  <span class="math">\\mathcal{B}</span>  is nearly as efficient as  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">We refer the reader to [11] for a proof of this lemma.</p>

    <p class="text-gray-300">THE  <span class="math">q</span> -DLOG PROBLEM. The game  <span class="math">\\mathsf{G}_{\\mathbb{G}}^{q\\text{-dl}}</span>  in Figure 1 is used for defining the advantage of a non-uniform adversary  <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  against the  <span class="math">q</span> -DLOG problem in a family of groups  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> . We define</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathbb {G}} ^ {q - \\mathrm {d l}} (\\mathcal {A}, \\lambda) = \\Pr \\left[ \\mathbb {G} _ {\\mathbb {G}} ^ {q - \\mathrm {d l}} (\\mathcal {A}, \\lambda) \\right].</span></div>

    <p class="text-gray-300">We note that there are other problems known as  <span class="math">q</span> -DLOG which are not equivalent to the one we use here. We use the version stated above because it was the version used in the analysis of Sonic [18] which we analyse in this paper.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game SRSp(λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Oracle Oext(τ = (a1, c1, ..., ai-1, ci-1), ai):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">win ← false; tr ← ε</td>

            <td class="px-3 py-2 border-b border-gray-700">If τ ∈ tr then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp ← IP.Setup(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">If i ≤ r then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(x, stP) ← Pλ(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">ci ← Chi; tr ← tr</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(τ, ai, ci); Return ci</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run PλOext(stP)</td>

            <td class="px-3 py-2 border-b border-gray-700">Else if i = r + 1 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return win</td>

            <td class="px-3 py-2 border-b border-gray-700">d ← IP.V(pp, x, (τ, ai)); tr ← tr</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(τ, ai)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | If d = 1 then win ← true  |</p>

    <p class="text-gray-300">|   | Return d  |</p>

    <p class="text-gray-300">|   | Return ⊥  |</p>

    <p class="text-gray-300">Fig. 2. Definition of state-restoration soundness. The game SRS defines state-restoration soundness for a non-uniform prover  <span class="math">\\mathcal{P}</span>  and a public-coin interactive proof IP. Here, IP has  <span class="math">r = r(\\lambda)</span>  challenges and the  <span class="math">i</span> -th challenge is sampled from  <span class="math">\\mathrm{Ch}_i</span> .</p>

    <p class="text-gray-300">We introduce our formalism for handling interactive proofs and arguments, which is particularly geared towards understanding their concrete state-restoration soundness.</p>

    <p class="text-gray-300">INTERACTIVE PROOFS. An interactive proof [1] IP is a triple of algorithms: (1) the setup algorithm IP.Setup which generates the public parameters pp, (2) the prover IP.P and (3) the verifier IP.V. In particular, the prover and the verifier are interactive machines which define a two-party protocol, where the prover does not produce any output, and the verifier outputs a decision bit  <span class="math">d \\in \\{0, 1\\}</span> . We let  <span class="math">\\langle \\mathsf{IP.P}(x), \\mathsf{IP.V}(y) \\rangle</span>  denote the algorithm which runs an execution of the prover and the verifier on inputs  <span class="math">x</span>  and  <span class="math">y</span> , respectively, and outputs the verifier's decision bit. We say that IP is public coin if all messages sent from IP.V to IP.P are fresh random values from some understood set (which we refer to as challenges).</p>

    <p class="text-gray-300">COMPLETENESS. A relation  <span class="math">R</span>  is (without loss of generality) a subset of  <span class="math">\\{0,1\\}^<em> \\times \\{0,1\\}^</em> \\times \\{0,1\\}^*</span> . We denote a relation  <span class="math">R</span>  that uses specified public parameters  <span class="math">\\mathfrak{pp}</span> , instance  <span class="math">x</span>  and witness  <span class="math">w</span>  as  <span class="math">\\{(\\mathfrak{pp},x,w):f_R(\\mathfrak{pp},x,w)\\}</span>  where  <span class="math">f_{R}(\\mathfrak{pp},x,w)</span>  is a function that returns true if  <span class="math">(\\mathfrak{pp},x,w) \\in R</span>  and false otherwise. For every  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span>  and every  <span class="math">\\mathcal{A}</span> , define the following experiment:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {p p} \\leftarrow \\mathsf {s I P . S e t u p} (1 ^ {\\lambda}), (x, w) \\leftarrow \\mathsf {s A} (\\mathsf {p p}), d \\leftarrow \\mathsf {s} \\langle \\mathsf {I P . P} (\\mathsf {p p}, x, w), \\mathsf {I P . V} (\\mathsf {p p}, x) \\rangle .</span></div>

    <p class="text-gray-300">Then, we say that  <span class="math">\\mathsf{IP}</span>  is an interactive proof for the relation  <span class="math">R</span>  if for all  <span class="math">\\mathcal{A}</span>  and all  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span> , in the above experiment the event  <span class="math">(d = 1) \\vee ((\\mathsf{pp}, x, w) \\notin R)</span>  holds with probability one.</p>

    <p class="text-gray-300">STATE-RESTORATION SOUNDNESS. We target a stronger notion of soundness - state-restoration soundness (SRS) [14,15] - which (as we show below) tightly reduces to the soundness of the non-interactive proof obtained via the Fiat-Shamir transform. The SRS security game allows the cheating prover to rewind the verifier as it pleases, and wins if and only if it manages to produce some accepting interaction. We only consider an  <span class="math">r(\\lambda)</span> -challenge public-coin interactive proof IP, and consider the case where challenges are drawn uniformly from some sets  <span class="math">\\mathsf{Ch}_1, \\ldots, \\mathsf{Ch}_r</span> . We also assume that the verifier is described by an algorithm which given pp,  <span class="math">x</span> , and a transcript  <span class="math">\\tau = (a_1, c_1, \\ldots, a_r, c_r, a_{r+1})</span> , outputs a decision bit  <span class="math">d \\in \\{0, 1\\}</span> . We overload notation and write IP.V(pp,  <span class="math">x, \\tau</span> ) for this output.</p>

    <p class="text-gray-300">Our definition considers a game  <span class="math">\\mathsf{SRS}_{\\mathsf{IP}}^{\\mathcal{P}}(\\lambda)</span>  (which is formalized in Figure 2) that involves a non-uniform cheating prover  <span class="math">\\mathcal{P} = \\{\\mathcal{P}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span> . (Henceforth, whenever we have any non-uniform adversary  <span class="math">\\mathcal{A}</span> , it is understood  <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span>  - we shall not specify this explicitly). The prover is</p>

    <p class="text-gray-300">initially responsible for generating the input <span class="math">x</span> on which it attempts to convince the verifier on some execution. Its rewinding access to the verifier is ensured by an oracle <span class="math">\\mathbf{O}_{\\mathrm{ext}}</span>, to which it has access. Roughly speaking, the oracle allows the prover to build an execution tree, which is extended with each query to it by the prover. This execution tree can be inferred from <span class="math">\\mathsf{tr}</span>, which sequentially logs all (valid) queries to <span class="math">\\mathbf{O}_{\\mathrm{ext}}</span> by the prover. For a partial transcript <span class="math">\\tau^{\\prime}</span>, we write <span class="math">\\tau^{\\prime}\\in\\mathsf{tr}</span> to mean that a partial execution corresponding to <span class="math">\\tau^{\\prime}</span> can be inferred from <span class="math">\\mathsf{tr}</span>.</p>

    <p class="text-gray-300">We then associate the probability of winning the game with the srs advantage metric,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{srs}}_{\\mathsf{IP}}(\\mathcal{P},\\lambda)=\\mathsf{Pr}\\left[\\mathsf{SRS}^{\\mathsf{IP}}_{\\mathcal{P}}(\\lambda)\\right]\\;.</span></p>

    <p class="text-gray-300">For notational convenience, we do not restrict the input <span class="math">x</span> not to have a witness. Therefore, if <span class="math">\\mathsf{IP}</span> is an interactive proof for a relation <span class="math">R</span>, we cannot hope to show that <span class="math">\\mathsf{Adv}^{\\mathsf{srs}}_{\\mathsf{IP}}(\\mathcal{P},\\lambda)</span> is small for all <span class="math">\\mathcal{P}</span>. Clearly, if <span class="math">\\mathcal{P}</span> outputs <span class="math">(x,a)</span> such that <span class="math">(\\mathsf{pp},x,a)\\in R</span>, then <span class="math">a</span> is a witness and <span class="math">\\mathcal{P}</span> can simply (honestly) convince the verifier. The classical notion of state-restoration soundness is recovered by only considering <span class="math">\\mathcal{P}</span>’s which output <span class="math">x</span> such that <span class="math">(\\mathsf{pp},x,w)\\notin R</span> for any <span class="math">w</span>.</p>

    <p class="text-gray-300">The following lemma shows a (generally loose) connection between (plain) soundness and state restoration soundness.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 3 (Naïve Reduction).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{IP}</span> be a <span class="math">r(\\lambda)</span>-challenge public-coin interactive proof. Then, for every non-uniform prover <span class="math">\\mathcal{P}</span> invoking <span class="math">\\mathbf{O}_{\\mathrm{ext}}</span> at most <span class="math">q=q(\\lambda)</span> times, there exists a <em>linear</em> prover <span class="math">\\mathcal{P}^{\\prime}</span> (with complexity similar to that of <span class="math">\\mathcal{P}</span>) such that for all <span class="math">\\lambda\\in\\mathbb{N}^{+}</span>, <span class="math">\\mathsf{Adv}^{\\mathsf{srs}}_{\\mathsf{IP}}(\\mathcal{P},\\lambda)\\leqslant\\binom{q(\\lambda)}{r(\\lambda)+1}\\cdot\\mathsf{Adv}^{\\mathsf{srs}}_{\\mathsf{IP}}(\\mathcal{P}^{\\prime},\\lambda)</span>.</p>

    <p class="text-gray-300">We omit the (simple) proof – the adversary <span class="math">\\mathcal{P}^{\\prime}</span> simply “guesses” the accepting path, which consists of <span class="math">r+1</span> queries.</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{IP}</span> is publicly verifiable, we can prove the following slightly improved bound.<span class="math">\\mathsf{Adv}^{\\mathsf{srs}}_{\\mathsf{IP}}(\\mathcal{P},\\lambda)\\leqslant\\binom{q(\\lambda)}{r(\\lambda)}\\cdot\\mathsf{Adv}^{\\mathsf{srs}}_{\\mathsf{IP}}(\\mathcal{P}^{\\prime},\\lambda)</span>. In this case the adversary <span class="math">\\mathcal{P}^{\\prime}</span> would need to guess only the first <span class="math">r</span> messages and use the public verification procedure to check if any of the <span class="math">q</span> queries is a valid last message.</p>

    <h2 id="sec-9" class="text-2xl font-bold">4 Proofs of Knowledge in the AGM</h2>

    <p class="text-gray-300">The Algebraic Group Model. We start here with a brief review of the AGM <em>[5]</em>. For an understood group <span class="math">\\mathbb{G}</span> with prime order <span class="math">p</span>, an <em>algebraic</em> algorithm <span class="math">\\mathcal{A}_{\\mathsf{alg}}</span> is an interactive algorithm whose inputs and outputs are made of distinct group elements and strings. Furthermore, each (encoding) of a group element <span class="math">X</span> output by <span class="math">\\mathcal{A}_{\\mathsf{alg}}</span> is accompanied by a <em>representation</em> <span class="math">(x_{A_{1}},x_{A_{2}},\\ldots,x_{A_{k}})\\in\\mathbb{Z}_{p}^{k}</span> such that <span class="math">X=\\prod_{i=1}^{k}A_{i}^{x_{A_{i}}}</span>, where <span class="math">A_{1},\\ldots,A_{k}</span> are all group elements previously input <em>and</em> output by <span class="math">\\mathcal{A}_{\\mathsf{alg}}</span>. Generally, we write <span class="math">[X]</span> for a group element <span class="math">X</span> <em>enhanced</em> with its representation, e.g.,<span class="math">[X]=(X,x_{A_{1}},x_{A_{2}},\\ldots,x_{A_{k}})</span>. In particular, when we use a group element <span class="math">X</span> output by <span class="math">\\mathcal{A}_{\\mathsf{alg}}</span>, e.g. it is <em>input</em> to a reduction or used in a cryptographic game, we write <span class="math">[X]</span> to make explicit that the representation is available, whereas write <span class="math">X</span> only when the representation is omitted. The notation extends to a mix of group elements and strings <span class="math">a</span> – <span class="math">[a]</span> enhances each group element with its representation.</p>

    <p class="text-gray-300">Defining AGM extraction. We formalize a notion of proof-of-knowledge (PoK) security in the AGM, following the lines of witness-extended emulation <em>[16, 17]</em>, which we extend to provers that can rewind the verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game WEE-1Palg, D(λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Oracle Oλext(τ=(a1,c1,...,ai-1,ci-1),ai):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tr←ε</td>

            <td class="px-3 py-2 border-b border-gray-700">If τ∈tr then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp←IP.Setup(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">If i≤r then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">([x],stP)←Palg,λ(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">ci←Ch; tr←tr</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(τ,ai,ci); return ci</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run POλext(STP)</td>

            <td class="px-3 py-2 border-b border-gray-700">Else if i=r+1 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b←D(tr)</td>

            <td class="px-3 py-2 border-b border-gray-700">d←IP.V(pp,x,τ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ai)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (b=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return d</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Game WEE-0E,Palg, D(λ):</td>

            <td class="px-3 py-2 border-b border-gray-700">Return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tr←ε</td>

            <td class="px-3 py-2 border-b border-gray-700">Oracle O0ext(τ=(a1,c1,...,ai-1,ci-1),ai):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp←IP.Setup(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">If τ∈tr then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">([x],stP)←Palg,λ(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">If i≤r then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">stE←(1λ,pp,[x])</td>

            <td class="px-3 py-2 border-b border-gray-700">(resp,stE)←E(stE,[(τ,ai)])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run POλext(STP)</td>

            <td class="px-3 py-2 border-b border-gray-700">tr←tr</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(τ,ai,resp)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w←E(stE,⊥)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return resp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b←D(tr)</td>

            <td class="px-3 py-2 border-b border-gray-700">Else if i=r+1 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (b=1) ∧ (Acc(tr) ⇒ (pp,x,w)∈R)</td>

            <td class="px-3 py-2 border-b border-gray-700">d←IP.V(pp,x,τ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ai)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Return d  |</p>

    <p class="text-gray-300">|   | Return ⊥  |</p>

    <p class="text-gray-300">Fig. 3. Definition of online srs-wee security in the AGM. The games WEE-1, WEE-0 define online srs-wee security in the AGM for a non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> , a distinguisher  <span class="math">\\mathcal{D}</span> , an extractor  <span class="math">\\mathcal{E}</span>  and a public-coin interactive proof IP. We assume here that IP has  <span class="math">r = r(\\lambda)</span>  challenges and the  <span class="math">i</span> -th challenge is sampled from  <span class="math">\\mathrm{Chi}_i</span> .</p>

    <p class="text-gray-300">We will be interested in cases where the AGM allows for online extraction, i.e., the additional group representations will allow for extraction without rewinding the prover. We target an adaptive notion of security, where the input is generated by the adversarial prover itself, depending on the public parameters pp, and can contain group elements.</p>

    <p class="text-gray-300">ONLINE SRS-WEE SECURITY. The definition consists of two games - denoted WEE-1 <span class="math">_{\\mathrm{IP}}^{\\mathcal{P}_{\\mathrm{alg}},\\mathcal{D}}</span>  and WEE-0 <span class="math">_{\\mathrm{IP},R}^{\\mathcal{E},\\mathcal{P}_{\\mathrm{alg}},\\mathcal{D}}</span> , and described in Figure 3. The former captures the real game, lets our prover  <span class="math">\\mathcal{P} = \\{\\mathcal{P}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span>  interact with an oracle  <span class="math">\\mathbf{O}_{\\mathrm{ext}}^{1}</span>  as in the state-restoration soundness game defined above, which additionally stores a transcript tr. The latter is finally given to a distinguisher  <span class="math">\\mathcal{D}</span>  which outputs a decision bit. In contrast, the ideal game delegates the role of answering  <span class="math">\\mathcal{P}</span> 's oracle queries to a (stateful) extractor  <span class="math">\\mathcal{E}</span> . The extractor, at the end of the execution, also outputs a witness candidate for  <span class="math">w</span> . The extractor in particular exploits here the fact that  <span class="math">\\mathcal{P}</span>  is algebraic by learning the representation of every input to the oracle  <span class="math">\\mathbf{O}_{\\mathrm{ext}}^{0}</span> . (This representation can be thought, without loss of generality, as being in terms of all group elements contained in pp.) Here, the final output of the game is not merely  <span class="math">\\mathcal{D}</span> 's decision bit - should the latter output 1, the output of the game is true only if additionally the extracted witness is correct assuming the interaction with  <span class="math">\\mathbf{O}_{\\mathrm{ext}}^{0}</span>  resulted in an accepting execution - a condition we capture via the predicate Acc(tr).</p>

    <p class="text-gray-300">For an interactive proof IP and an associated relation  <span class="math">R</span> , non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> , a distinguisher  <span class="math">\\mathcal{D}</span> , and an extractor  <span class="math">\\mathcal{E}</span> , we define</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathrm {I P}, R} ^ {\\text {s r - w e e}} \\left(\\mathcal {P} _ {\\text {a l g}}, \\mathcal {D}, \\mathcal {E}, \\lambda\\right) = \\Pr \\left[ \\operatorname {W E E} - 1 _ {\\mathrm {I P}} ^ {\\mathcal {P} _ {\\text {a l g}}, \\mathcal {D}} (\\lambda) \\right] - \\Pr \\left[ \\operatorname {W E E} - 0 _ {\\mathrm {I P}, R} ^ {\\mathcal {E}, \\mathcal {P} _ {\\text {a l g}}, \\mathcal {D}} (\\lambda) \\right]. \\tag {3}</span></div>

    <p class="text-gray-300">One can consider also scenarios where the prover may be non-adaptive – for example, the input has been generated by another party, and the prover tries to prove knowledge with respect to this input. For this reason, introduce the notion of non-adaptive srs-wee in Section 7.</p>

    <p class="text-gray-300">Soundness from PoK. The definition of state-restoration soundness from Section 3 also applies to any algebraic prover. The following theorem relates soundness to the witness-extended emulation – the proof is immediate.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{IP}</span> be an interactive proof for a relation <span class="math">R</span>, and let <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> an algebraic prover which, on input <span class="math">\\mathsf{pp}</span>, outputs <span class="math">x</span> such that <span class="math">(\\mathsf{pp},x,w)\\notin R</span> for all <span class="math">w</span>. Then, for any extractor <span class="math">\\mathcal{E}</span>, and <span class="math">\\mathcal{D}(\\cdot)=\\mathsf{Acc}(\\cdot)</span>, we have for all <span class="math">\\lambda\\in\\mathbb{N}^{+}</span>, <span class="math">\\mathsf{Adv}^{\\mathsf{srs}}_{\\mathsf{IP}}(\\mathcal{P}_{\\mathsf{alg}},\\lambda)\\leqslant\\mathsf{Adv}^{\\mathsf{sr}-\\mathsf{wee}}_{\\mathsf{IP},R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)</span>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.1 The Basic Framework</h3>

    <p class="text-gray-300">We develop a general framework that we will use, via Theorem 1, to derive concrete AGM bounds on srs-wee security. Our goal, in particular, is to give conditions on <em>single</em> path executions – i.e., executions not involving any rewinding of the verifier by the prover, which could be seen as root-to-leaf paths in an execution tree generated by the interaction of a state-restoration prover.</p>

    <p class="text-gray-300">Transcripts. From now on, let us fix an interactive <em>public-coin</em> proof <span class="math">\\mathsf{IP}=(\\mathsf{IP}.{\\mathsf{Setup}},\\mathsf{IP}.{\\mathsf{P}},\\mathsf{IP}.{\\mathsf{V}})</span> for a relation <span class="math">R</span>. Assume further this protocol has exactly <span class="math">r</span> rounds of challenges. Then, we represent a (potential) <em>single-execution</em> transcript generated by an algebraic prover in different forms, depending on whether we include the representations of group elements or not. Specifically, we let the (plain) transcript be <span class="math">\\tau=(\\mathsf{pp},x,a_{1},c_{1},a_{2},c_{2},\\ldots,a_{r},c_{r},a_{r+1})</span>, where <span class="math">\\mathsf{pp}</span> are the generated parameters, <span class="math">x</span> is the input produced by <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span>, <span class="math">c_{i}\\in\\mathsf{Ch}_{i}</span> for all <span class="math">i\\in\\{1,\\ldots,r\\}</span> are the challenges, and <span class="math">a_{1},\\ldots,a_{r+1}</span> are the prover’s messages. The corresponding <em>extended transcript</em> with representations is denoted as <span class="math">[\\tau]=(\\mathsf{pp},[x],[a_{1}],c_{1},[a_{2}],c_{2},\\ldots,[a_{r}],c_{r},[a_{r+1}])</span>.</p>

    <p class="text-gray-300">In particular, the representation of each group element contained in <span class="math">a_{i}</span> is with respect to all elements contained in <span class="math">\\mathsf{pp},x,a_{1},\\ldots,a_{i-1}</span>. We let <span class="math">\\mathcal{T}^{\\mathsf{IP}}</span> be the set of all possible extended transcripts <span class="math">[\\tau]</span>. We also let <span class="math">\\mathcal{T}^{\\mathsf{IP}}_{\\mathsf{Acc}}\\subseteq\\mathcal{T}^{\\mathsf{IP}}</span> be the set of <em>accepting</em> transcripts <span class="math">[\\tau]</span>, i.e., <span class="math">\\mathsf{IP}.{\\mathsf{V}}(\\tau)=1</span>.</p>

    <p class="text-gray-300">Path Extraction. We now would like to define a function <span class="math">\\mathsf{e}</span> which extracts a witness from any accepting transcript <span class="math">[\\tau]\\in\\mathcal{T}^{\\mathsf{IP}}_{\\mathsf{Acc}}</span>. For a particular function <span class="math">\\mathsf{e}</span> we now define the set of extended transcripts on which it succeeds in extracting a valid witness, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{T}^{\\mathsf{IP},\\mathsf{e},R}_{\\mathsf{correct}}=\\left\\{[\\tau]=(\\mathsf{pp},[x],\\ldots)\\in\\mathcal{T}^{\\mathsf{IP}}_{\\mathsf{Acc}}~{}:~{}w\\leftarrow\\mathsf{e}([\\tau]),~{}(\\mathsf{pp},x,w)\\in R\\right\\}~{}.</span></p>

    <p class="text-gray-300">Therefore, a natural extractor <span class="math">\\mathcal{E}</span> just answers challenges honestly, and applies <span class="math">\\mathsf{e}</span> to a path in the execution tree which defines an accepting transcript, and returns the corresponding witness <span class="math">w</span>. The probability of this extractor failing can be upper bounded naïvely by the probability that the prover generates, in its execution tree, a path corresponding to an extended transcript <span class="math">[\\tau]\\in\\mathcal{T}^{\\mathsf{IP}}_{\\mathsf{Acc}}\\backslash\\mathcal{T}^{\\mathsf{IP},\\mathsf{e},R}_{\\mathsf{correct}}</span>. This is however not directly helpful, as the main challenge is to actually estimate this probability.</p>

    <p class="text-gray-300">Bad Challenges. In all of our examples, the analysis of the probability of generating a transcript in <span class="math">\\mathcal{T}^{\\mathsf{IP}}_{\\mathsf{Acc}}\\backslash\\mathcal{T}^{\\mathsf{IP},\\mathsf{e},R}_{\\mathsf{correct}}</span> will generally consist of an <em>information-theoretic</em> and a <em>computational part</em>.</p>

    <p class="text-gray-300">The information-theoretic part will account to choosing some <em>bad challenges</em>. We capture such choices of bad challenges by defining, for any partial extended transcript</p>

    <p class="text-gray-300"><span class="math">\\left[\\tau^{\\prime}\\right]=(\\mathsf{pp},[x],[a_{1}],c_{1},\\ldots,[a_{i}])~{},</span></p>

    <p class="text-gray-300">a set <span class="math">\\mathsf{BadCh}(\\tau^{\\prime})\\subseteq\\mathsf{Ch}_{i}</span> of such bad challenges. (Crucially, whether a challenge is bad or not only depends on the extended transcript so far.) We now denote as <span class="math">\\mathcal{T}^{\\mathsf{IP}}_{\\mathsf{BadCh}}</span> the set of all extended transcripts which contain at least one bad challenge. It turns out that the probability of generating</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">such a bad challenge is easily bounded by <span class="math">q\\cdot\\varepsilon</span> for a prover making <span class="math">q</span> oracle queries, assuming $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant\\varepsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The only case that the extractor can now fail is if the execution tree contains an extended transcript <span class="math">[\\tau]</span> in the set <span class="math">\\mathcal{T}_{\\mathsf{fail}}^{\\mathsf{IP},\\mathsf{e},R}=\\mathcal{T}_{\\mathsf{Acc}}^{\\mathsf{IP}}\\setminus(\\mathcal{T}_{\\mathsf{correct}}^{\\mathsf{IP},\\mathsf{e},R}\\cup\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{IP}})</span>. We denote the probability that this happens in <span class="math">\\mathsf{SRS}^{\\mathcal{P}_{\\mathsf{alg}}}_{\\mathsf{IP}}(\\lambda)</span> as <span class="math">p_{\\mathsf{fail}}(\\mathsf{IP},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)</span>. Generally, in all of our applications, upper bounding this probability for a suitably defined extractor will constitute the computational core of the proof – i.e., we will prove (generally tight) reductions to breaking some underlying assumption.</p>

    <p class="text-gray-300">The Master Theorem. We are now ready to state our master theorem, which assumes the formal set up.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1 (Master Theorem).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{IP}</span> be an <span class="math">r=r(\\lambda)</span>-challenge public coin interactive proof for a relation <span class="math">R</span>. Assume there exist functions <span class="math">\\mathsf{BadCh}</span> and <span class="math">\\mathsf{e}</span> for <span class="math">\\mathsf{IP}</span> as described above, and let <span class="math">p_{\\mathsf{fail}}</span> be as defined above. Let <span class="math">\\tau^{\\prime}</span> be a partial transcript such that the challenge that comes right after is sampled from <span class="math">\\mathsf{Ch}_{i}</span>. Assume that for all <span class="math">i\\in\\{1,\\ldots,r\\}</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant\\varepsilon<span class="math">, for some </span>\\varepsilon\\in[0,1]<span class="math">. Then, there exists an extractor </span>\\mathcal{E}<span class="math"> that uses </span>\\mathsf{e}<span class="math"> such that for any non-uniform algebraic prover </span>\\mathcal{P}_{\\mathsf{alg}}<span class="math"> making at most </span>q=q(\\lambda)<span class="math"> queries to its oracle, and any (computationally unbounded) distinguisher </span>\\mathcal{D}<span class="math">, for all </span>\\lambda\\in\\mathbb{N}^{+}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{sr}\\text{-wee}}_{\\mathsf{IP},R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)\\leqslant q\\varepsilon+p_{\\mathsf{fail}}(\\mathsf{IP},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)\\;.</span></p>

    <p class="text-gray-300">The time complexity of the extractor <span class="math">\\mathcal{E}</span> is <span class="math">O(q\\cdot t_{V}+t_{\\mathsf{e}})</span> where <span class="math">t_{V}</span> is the time required to run <span class="math">\\mathsf{IP.V}</span> and <span class="math">t_{\\mathsf{e}}</span> is the time required to run <span class="math">\\mathsf{e}</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}</span>, as stated in Section 4.1, just answers challenges honestly, and applies <span class="math">\\mathsf{e}</span> to a path in the execution tree which defines an accepting transcript, and returns whatever <span class="math">\\mathsf{e}</span> returns. The running time of the extractor <span class="math">\\mathcal{E}</span> consists of the time required to answers <span class="math">q</span> queries, run <span class="math">\\mathsf{IP.V}</span> in at most <span class="math">q</span> paths in the execution tree and the time required to run <span class="math">\\mathsf{e}</span>. Hence it’s time complexity is <span class="math">O(q\\cdot t_{V}+t_{\\mathsf{e}})</span>.</p>

    <p class="text-gray-300">Since, <span class="math">\\mathcal{E}</span> answers challenges honestly, the view of <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> is identical in the games <span class="math">\\mathsf{WEE-1}^{\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP}}</span> and <span class="math">\\mathsf{WEE-0}^{\\mathcal{E},\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP},R}</span>. So, <span class="math">\\mathsf{tr}</span> will be identical in both games and hence <span class="math">b</span> will be identical in both games. Therefore, the output of <span class="math">\\mathsf{WEE-0}^{\\mathcal{E},\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP},R}</span> differs from the output of <span class="math">\\mathsf{WEE-1}^{\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP}}</span> only if <span class="math">(\\mathsf{Acc}(\\mathsf{tr})\\Rightarrow(\\mathsf{pp},x,w)\\in R)=\\texttt{false}</span> i.e., if <span class="math">\\mathsf{Acc}(\\mathsf{tr})</span> is true but <span class="math">(\\mathsf{pp},x,w)\\notin R</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\mathsf{Acc}(\\mathsf{tr})</span> is true, there is an accepting transcript <span class="math">\\tau</span> such that <span class="math">\\mathcal{E}</span> gives <span class="math">[\\tau]</span> as input to <span class="math">\\mathsf{e}</span>. Now, <span class="math">\\mathsf{e}</span> outputs <span class="math">w</span> such that <span class="math">(\\mathsf{pp},x,w)\\notin R</span> only if <span class="math">\\tau\\in\\mathcal{T}_{\\mathsf{fail}}^{\\mathsf{IP},\\mathsf{e},R}</span> or <span class="math">\\tau\\in\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{IP}}</span> (these sets are defined in Section 4.1).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By definition, <span class="math">\\tau\\in\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{IP}}</span> only if any of the challenges <span class="math">c_{i}\\in\\mathsf{BadCh}(\\tau^{\\prime})</span> for some partial transcript <span class="math">\\tau^{\\prime}</span> that is a prefix of <span class="math">\\tau</span>. Now, since there are at most <span class="math">q</span> queries and each of the challenges are sampled uniformly at random from <span class="math">\\mathsf{Ch}_{i}</span>, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant\\varepsilon<span class="math">, the probability that </span>\\tau\\in\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{IP}}<span class="math"> is at most </span>q\\cdot\\varepsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The probability that <span class="math">\\tau\\in\\mathcal{T}_{\\mathsf{fail}}^{\\mathsf{IP},\\mathsf{e},R}</span> is <span class="math">p_{\\mathsf{fail}}(\\mathsf{IP},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)</span> in game <span class="math">\\mathsf{SRS}^{\\mathcal{P}}_{\\mathsf{IP}}</span>. Since <span class="math">\\mathcal{E}</span> answers challenges honestly, the probability that <span class="math">\\tau\\in\\mathcal{T}_{\\mathsf{fail}}^{\\mathsf{IP},\\mathsf{e},R}</span> in <span class="math">\\mathsf{WEE-0}^{\\mathcal{E},\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP},R}</span> is <span class="math">p_{\\mathsf{fail}}(\\mathsf{IP},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)</span> as well.</p>

    <p class="text-gray-300">Therefore, the probability that the output of <span class="math">\\mathsf{WEE-0}^{\\mathcal{E},\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP},R}</span> differs from the output of <span class="math">\\mathsf{WEE-1}^{\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP}}</span> is at most <span class="math">q\\varepsilon+p_{\\mathsf{fail}}(\\mathsf{IP},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{sr}\\text{-wee}}_{\\mathsf{IP},R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)\\leqslant q\\varepsilon+p_{\\mathsf{fail}}(\\mathsf{IP},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)\\;.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Game FS-EXT-1 <span class="math">\\mathcal{P}_{\\mathrm{alg}},\\mathcal{E}(\\lambda)</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}\\longleftrightarrow \\mathsf{IP}.Setup(1^{\\lambda});([x],\\mathsf{st}_{\\mathcal{P}})\\longleftrightarrow \\mathcal{P}_{\\mathrm{alg},\\lambda}(\\mathsf{pp});H\\longleftrightarrow \\Omega_{\\mathsf{hLen}(\\lambda)}</span></p>

    <p class="text-gray-300"><span class="math">[\\pi] \\longleftrightarrow \\mathcal{P}_{\\mathrm{alg},\\lambda}^{H}(\\mathrm{st}_{\\mathcal{P}}); (a_{1}, c_{1}, \\ldots, a_{r}, c_{r}, a_{r+1}) \\gets \\pi</span></p>

    <p class="text-gray-300">accept  <span class="math">\\leftarrow</span>  (IP.V(pp,  <span class="math">x,\\pi) = 1</span>  )  <span class="math">\\wedge</span> <span class="math">(\\forall i\\in [r]:c_{i} = H(\\mathsf{pp},x,a_{1},c_{1},\\ldots ,a_{i})[:cLen_{i}])</span></p>

    <p class="text-gray-300"><span class="math">w\\longleftrightarrow \\mathcal{E}(1^{\\lambda},\\mathsf{pp},[x],[\\pi])</span>  ; Return (accept  <span class="math">\\wedge</span>  (pp,  <span class="math">x,w)\\notin R</span></p>

    <p class="text-gray-300">Fig. 4. Definition of fs-ext-1 security in the AGM. The game FS-EXT-1 defines fs-ext-1 security in the AGM for a non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> , an extractor  <span class="math">\\mathcal{E}</span>  and a non-interactive argument obtained by applying the Fiat-Shamir transform to an interactive protocol IP. Here, IP has  <span class="math">r = r(\\lambda)</span>  challenges where the  <span class="math">i^{\\mathrm{th}}</span>  challenge is of length  <span class="math">\\mathsf{cLen}_i = \\mathsf{cLen}_i(\\lambda)</span>  such that  <span class="math">\\mathsf{sLen}(\\lambda) \\leqslant \\mathsf{cLen}_i(\\lambda) \\leqslant \\mathsf{hLen}(\\lambda)</span> . The set  <span class="math">\\Omega_{\\mathsf{hLen}(\\lambda)}</span>  contains all functions mapping  <span class="math">\\{0,1\\}^{*}</span>  to  <span class="math">\\{0,1\\}^{\\mathsf{hLen}(\\lambda)}</span> .</p>

    <p class="text-gray-300">The Fiat-Shamir transform uses a family of hash functions  <span class="math">\\mathcal{H}</span>  to convert a  <span class="math">r</span> -challenge public coin interactive protocol (proof or argument) IP to a non-interactive argument FS[IP,  <span class="math">\\mathcal{H}</span> ]. When  <span class="math">\\mathcal{H}</span>  is modelled as a random oracle, we denote the non-interactive argument using FS <span class="math">^{\\mathbf{RO}}</span>  [IP]. In FS[IP,  <span class="math">\\mathcal{H}</span> ], a hash function  <span class="math">H</span>  is first sampled from  <span class="math">\\mathcal{H}</span> . A proof on public parameters pp and input  <span class="math">x</span>  is  <span class="math">\\pi = (a_1, c_1, a_2, c_2, \\ldots, a_r, c_r, a_{r+1})</span> , such that</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = H (\\mathsf {p p}, x, a _ {1}, c _ {1}, \\dots , a _ {i - 1}, c _ {i - 1}, a _ {i}) [: \\mathsf {c L e n} _ {i} ]</span></div>

    <p class="text-gray-300">for  <span class="math">i\\in \\{1,\\ldots ,r\\}</span> , and IP.V returns 1 on input  <span class="math">(\\mathsf{pp},x,\\pi)</span> .</p>

    <p class="text-gray-300">FS-EXT-1 SECURITY. We formalize a notion of proof-of-knowledge (PoK) security in the AGM for non-interactive arguments obtained by applying the Fiat-Shamir transform to an interactive protocol IP. For simplicity, this notion just captures extractability instead of witness-extended emulation. We define a notion of soundness called fs-ext-1 that captures the setting where the prover has to commit to the instance beforehand. It is formally defined using the game FS-EXT-1 in Figure 4.</p>

    <p class="text-gray-300">For an interactive proof IP and an associated relation  <span class="math">R</span> , algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> , and an extractor  <span class="math">\\mathcal{E}</span> , we define  <span class="math">\\mathsf{Adv}_{\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}],R}^{\\mathsf{fs - ext - 1}}(\\mathcal{P}_{\\mathrm{alg}},\\mathcal{E},\\lambda) = \\mathsf{Pr}\\left[\\mathsf{FS - EXT - 1}_{\\mathsf{IP},R}^{\\mathcal{P}_{\\mathrm{alg}},\\mathcal{E}}(\\lambda)\\right]</span> .</p>

    <p class="text-gray-300">The following theorem connects the online srs-wee security of a public-coin protocol IP and the fs-ext-1 soundness of non-interactive protocol  <span class="math">\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{IP}]</span> , obtained by applying the Fiat-Shamir transform using a random oracle.</p>

    <p class="text-gray-300">Theorem 2. Let  <span class="math">R</span>  be a relation. Let  <span class="math">\\mathsf{IP}</span>  be a  <span class="math">r = r(\\lambda)</span> -challenge public coin interactive protocol for the relation  <span class="math">R</span>  where the length of the  <span class="math">i^{th}</span>  challenge is  <span class="math">\\mathsf{cLen}_i(\\lambda)</span>  such that  <span class="math">\\mathsf{sLen}(\\lambda) \\leqslant \\mathsf{cLen}_i(\\lambda) \\leqslant \\mathsf{hLen}(\\lambda)</span>  for  <span class="math">i \\in \\{1, \\ldots, r\\}</span> . Let  <span class="math">\\mathcal{E}</span>  be an extractor for  <span class="math">\\mathsf{IP}</span> . We can construct an extractor  <span class="math">\\mathcal{E}^<em></span>  for  <span class="math">\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{IP}]</span>  such that for every non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}^</em></span>  against  <span class="math">\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{IP}]</span>  that makes  <span class="math">q = q(\\lambda)</span>  random oracle queries, there exists a non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  and  <span class="math">\\mathcal{D}</span>  such that for all  <span class="math">\\lambda \\in \\mathbb{N}^+</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathsf {F S} ^ {\\mathsf {R O}} [ \\mathsf {I P} ], R} ^ {\\mathsf {f s - e x t - 1}} \\left(\\mathcal {P} _ {\\mathsf {a l g}} ^ {*}, \\mathcal {E} ^ {*}, \\lambda\\right) \\leqslant \\operatorname {A d v} _ {\\mathsf {I P}, R} ^ {\\mathsf {s r - w e e}} \\left(\\mathcal {P} _ {\\mathsf {a l g}}, \\mathcal {D}, \\mathcal {E}, \\lambda\\right) + (q + 1) / 2 ^ {\\mathsf {s L e n} (\\lambda)}.</span></div>

    <p class="text-gray-300">Moreover,  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  makes at most  <span class="math">q</span>  queries to its oracle and is nearly as efficient as  <span class="math">\\mathcal{P}_{\\mathrm{alg}}^<em></span> . The extractor  <span class="math">\\mathcal{E}^</em></span>  is nearly as efficient as  <span class="math">\\mathcal{E}</span> .</p>

    <p class="text-gray-300">Proof. Without loss of generality we assume that  <span class="math">\\mathcal{P}_{\\mathrm{alg}}^*</span>  does not repeat random oracle queries. Let  <span class="math">r = r(\\lambda)</span> ,  <span class="math">\\mathsf{hLen} = \\mathsf{hLen}(\\lambda)</span> ,  <span class="math">\\mathsf{sLen} = \\mathsf{sLen}(\\lambda)</span>  and  <span class="math">\\mathsf{cLen}_i = \\mathsf{cLen}_i(\\lambda)</span>  for  <span class="math">i = 1, \\ldots, r</span> . Let the length of the  <span class="math">i^{\\text{th}}</span>  prover message in IP be  <span class="math">l_i = l_i(\\lambda)</span>  bits for  <span class="math">i \\in \\{1, \\ldots, r + 1\\}</span> .</p>

    <p class="text-gray-300">First we define the extractor <span class="math">\\mathcal{E}^{<em>}</span> – it simply outputs whatever <span class="math">\\mathcal{E}</span> returns. It follows that <span class="math">\\mathcal{E}^{</em>}</span> is no less efficient than <span class="math">\\mathcal{E}</span>.</p>

    <p class="text-gray-300">We set <span class="math">\\mathcal{D}(\\cdot)=\\mathsf{Acc}(\\cdot)</span>. So, <span class="math">\\mathsf{Adv}_{\\mathsf{IP},R}^{\\mathsf{sr}\\text{-}\\mathsf{wee}}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)</span> is essentially the probability that in WEE-0, <span class="math">\\mathsf{Acc}</span> returns true and <span class="math">\\mathcal{E}</span> fails to return a valid witness.</p>

    <p class="text-gray-300">We define adversary <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> that runs simulates the game FS-EXT-1 to <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{<em>}</span>. The first stage of <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> on input pp shall run the first stage of the <span class="math">\\mathcal{P}^{</em>}</span> on pp. If <span class="math">\\mathcal{P}^{<em>}</span> returns <span class="math">(x,\\mathsf{st}_{\\mathcal{P}^{</em>}})</span>, <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> returns <span class="math">(x,\\mathsf{st}_{\\mathcal{P}}=(s_{\\mathcal{P}^{<em>}},\\mathsf{pp},x))</span>. The second stage of <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> maintains set of states called <span class="math">\\mathcal{S}</span> – each state is of the form <span class="math">(a_{1},c_{1},a_{2},c_{2},\\ldots,a_{i},c_{i})</span>. We say the length of such a state is <span class="math">i</span>. On input <span class="math">\\mathsf{st}_{\\mathcal{P}}=(s_{\\mathcal{P}^{</em>}},\\mathsf{pp},x)</span>, it first initializes <span class="math">\\mathcal{S}</span> to <span class="math">\\{\\varepsilon\\}</span> where <span class="math">\\varepsilon</span> is the empty string . Then it runs <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{<em>}</span> on <span class="math">\\mathsf{st}_{\\mathcal{P}^{</em>}}</span>. It simulates the random oracle <span class="math">H</span> to <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{*}</span> as follows. On receiving a <span class="math">H</span> query on <span class="math">y</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> first checks if there exists <span class="math">s\\in\\mathcal{S}</span> of length <span class="math">i</span> such that <span class="math">(\\mathsf{pp},x,s)</span> is a prefix of <span class="math">y</span> i.e. <span class="math">y=(\\mathsf{pp},x,s,t)</span> and <span class="math">t</span> is of length <span class="math">l_{i+1}</span>. If the check fails, <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> returns a randomly sampled string from <span class="math">\\{0,1\\}^{\\mathsf{hLen}}</span>. If the check succeeds, <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> chooses the longest such state <span class="math">s</span>.</li>

      <li><span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> parses as <span class="math">y</span> as <span class="math">(\\mathsf{pp},x,s,t)</span> and makes a query to <span class="math">\\mathbf{O}_{\\mathrm{ext}}</span> on <span class="math">(s,t)</span> ans receives <span class="math">c</span> as the response. <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> adds <span class="math">(s,t,c)</span> to the set <span class="math">\\mathcal{S}</span>, samples a string <span class="math">c^{\\prime}</span> from <span class="math">\\{0,1\\}^{\\mathsf{hLen}-\\mathsf{cLen}_{i+1}}</span> and returns <span class="math">(c,c^{\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">Finally, when <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{<em>}</span> returns an output <span class="math">\\pi</span>, <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> queries <span class="math">\\mathbf{O}_{\\mathrm{ext}}</span> on <span class="math">\\pi</span> and stops. It follows that <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> makes no more than <span class="math">q</span> queries to its oracle and is nearly as efficient as <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{</em>}</span>.</p>

    <p class="text-gray-300">Suppose the game FS-EXT-1 returns true. In other words <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{<em>}</span> returns an accepting proof, i.e., it returns <span class="math">\\tau=(a_{1},c_{1},\\ldots,a_{r},c_{r},a_{r+1})</span> and <span class="math">\\mathcal{E}^{</em>}</span> fails to extract a witness <span class="math">w</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\tau_{i}=(a_{1},c_{1},\\ldots,a_{i-1},c_{i-1},a_{i})</span>. Now, let <span class="math">E</span> be the event that <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{<em>}</span> made <span class="math">H</span> queries on all of <span class="math">(\\mathsf{pp},x,\\tau_{1}),\\ldots,(\\mathsf{pp},x,\\tau_{r})</span> </em>in order<em>, i.e., for all <span class="math">i\\in\\{1,\\ldots,r-1\\}</span>, it queried <span class="math">H(\\mathsf{pp},x,\\tau_{i})</span> before <span class="math">H(\\mathsf{pp},x,\\tau_{i-1})</span>. If <span class="math">E</span> happens, it is easy to see that <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> must have succeeded and <span class="math">\\mathcal{E}</span> must have failed (since <span class="math">\\mathcal{E}^{</em>}</span> fails only when <span class="math">\\mathcal{E}</span> fails).</p>

    <p class="text-gray-300">Hence, we need to upper bound the probability that <span class="math">\\tau</span> is an accepting transcript and the event <span class="math">E</span> does not happen. If <span class="math">\\tau</span> is an accepting transcript and the event <span class="math">E</span> does not happen either there exists an <span class="math">i\\in\\{1,\\ldots,r\\}</span> such that <span class="math">H(\\mathsf{pp},x,\\tau_{i})</span> was never queried by <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{<em>}</span> or there exists <span class="math">i\\in\\{1,\\ldots,r-1\\}</span> such that <span class="math">H(\\mathsf{pp},x,\\tau_{i+1})</span> was queried before <span class="math">H(\\mathsf{pp},x,\\tau_{i})</span>. The probability of the former happening is at most <span class="math">1/2^{\\mathsf{sLen}}</span> since <span class="math">H(\\mathsf{pp},x,\\tau_{i})</span> was never queried but <span class="math">c_{i}=H(\\mathsf{pp},x,\\tau_{i})[: \\mathsf{cLen}_{i}]</span> is satisfied. The probability of the latter is upper bounded by the probability that a <span class="math">H</span> query was made on some <span class="math">y</span> before the <span class="math">H</span> query on <span class="math">(\\mathsf{pp},x,\\tau_{i})</span> such that the last <span class="math">\\mathsf{cLen}_{i}+l_{i+1}</span> bits of <span class="math">y</span> were <span class="math">(c_{i},a_{i+1})</span>. Since <span class="math">c_{i}</span> was not fixed before the <span class="math">H</span> query on <span class="math">(\\mathsf{pp},x,\\tau_{i})</span>, this happens with probability no more than <span class="math">1/2^{\\mathsf{sLen}}</span> for every query before the <span class="math">H</span> query on <span class="math">(\\mathsf{pp},x,\\tau_{i})</span>. Hence, the probability that for all <span class="math">i\\in\\{1,\\ldots,r\\}</span>, <span class="math">H(\\mathsf{pp},x,\\tau_{i})</span> was queried by <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{</em>}</span> but there exists <span class="math">i\\in\\{1,\\ldots,r-1\\}</span> such that <span class="math">H(\\mathsf{pp},x,\\tau_{i+1})</span> was queried before <span class="math">H(\\mathsf{pp},x,\\tau_{i})</span> is <span class="math">q/2^{\\mathsf{sLen}}</span>. Therefore, the probability that <span class="math">\\tau</span> is an accepting transcript, but <span class="math">E</span> does not happen is at most <span class="math">(q+1)/2^{\\mathsf{sLen}}</span>. Hence</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}],R}^{\\mathsf{fs}\\text{-}\\mathsf{ext}\\text{-}1}(\\mathcal{P}_{\\mathsf{alg}}^{<em>},\\mathcal{E}^{</em>},\\lambda)\\leqslant\\mathsf{Adv}_{\\mathsf{IP},R}^{\\mathsf{sr}\\text{-}\\mathsf{wee}}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)+\\frac{q+1}{2^{\\mathsf{sLen}(\\lambda)}}\\;.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">In the above theorem we considered challenges in IP to be bitstrings – however, this can be adapted to protocols where the challenges are from sets that are not bitstrings. The denominator of the fraction of the bound would become the size of smallest set from which the challenges are sampled, e.g., if the challenges in the a protocol were all from the set <span class="math">\\mathbb{Z}_{p}^{*}</span>, the fraction would become <span class="math">(q+1)/(p-1)</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Game FS-EXT-2Palg. 5. Definition of fs-ext-2 security in the AGM. The game FS-EXT-2 defines fs-ext-2 security in the AGM for a non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> , an extractor  <span class="math">\\mathcal{E}</span>  and a non-interactive argument obtained by applying the Fiat-Shamir transform to an interactive protocol IP. Here, IP has  <span class="math">r = r(\\lambda)</span>  challenges where the  <span class="math">i^{\\mathrm{th}}</span>  challenge is of length  <span class="math">\\mathsf{cLen}_i = \\mathsf{cLen}_i(\\lambda)</span>  such that  <span class="math">\\mathsf{sLen}(\\lambda) \\leqslant \\mathsf{cLen}_i(\\lambda) \\leqslant \\mathsf{hLen}(\\lambda)</span> . The set  <span class="math">\\Omega_{\\mathsf{hLen}(\\lambda)}</span>  contains all functions mapping  <span class="math">\\{0,1\\}^*</span>  to  <span class="math">\\{0,1\\}^{\\mathsf{hLen}(\\lambda)}</span> .</p>

    <p class="text-gray-300">We can also consider an adaptive notion of soundness where the prover can output the instance and proof together – we call this notion fs-ext-2. It is formally defined using the game FS-EXT-2 in Figure 5. Unlike fs-ext-1, here the prover need not commit to the instance beforehand and can output the instance and proof together. For an interactive proof IP and an associated relation  <span class="math">R</span> , algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> , and an extractor  <span class="math">\\mathcal{E}</span> , we define  <span class="math">\\mathsf{Adv}_{\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}],R}^{\\mathsf{fs - ext - 2}}(\\mathcal{P}_{\\mathrm{alg}},\\mathcal{E},\\lambda) = \\mathsf{Pr}\\left[\\mathsf{FS - EXT - 2}_{\\mathsf{IP},R}^{\\mathcal{P}_{\\mathrm{alg}},\\mathcal{E}}(\\lambda)\\right]</span> .</p>

    <p class="text-gray-300">We assume that IP has BadCh, e functions as described previously. Further, we assume  <span class="math">\\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{IP}}</span>  is defined as above. We use  <span class="math">p_{\\mathrm{fail,FS}}(\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{IP}],\\mathcal{P}_{\\mathrm{alg}},\\mathsf{e},R,\\lambda)</span>  to denote the probability that in the game FS-EXT-2 <span class="math">_{\\mathrm{IP},R}^{\\mathcal{P}_{\\mathrm{alg}},\\mathcal{E}}</span> ,  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  outputs  <span class="math">([x],[\\pi])</span> , accept is true,  <span class="math">\\pi \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{IP}}</span>  but e on input  <span class="math">([x],[\\pi])</span>  fails to produce a valid witness. The following theorem upper bounds the fs-ext-2 soundness of non-interactive protocol  <span class="math">\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{IP}]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3. Let IP be an  <span class="math">r = r(\\lambda)</span> -challenge public coin interactive proof for a relation  <span class="math">R</span>  where the length of the  <span class="math">i^{th}</span>  challenge is  <span class="math">\\mathsf{cLen}_i(\\lambda)</span>  such that  <span class="math">\\mathsf{sLen}(\\lambda) \\leqslant \\mathsf{cLen}_i(\\lambda) \\leqslant \\mathsf{hLen}(\\lambda)</span>  for  <span class="math">i \\in \\{1, \\dots, r\\}</span> . Assume there exist functions BadCh and e as described previously and let  <span class="math">p_{\\mathrm{fail,FS}}</span>  be as described above. Let  <span class="math">\\tau&#x27;</span>  be a partial transcript such that the challenge that comes right after is sampled from  <span class="math">\\mathsf{Ch}_i</span> . Assume that for all  <span class="math">i \\in \\{1, \\dots, r\\}</span> , we have that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant \\varepsilon<span class="math">  for some  </span>\\varepsilon \\in [0,1]<span class="math"> . Then, there exists an extractor  </span>\\mathcal{E}^<em><span class="math">  that uses e such that for any non-uniform algebraic prover  </span>\\mathcal{P}_{\\mathrm{alg}}^</em><span class="math">  for  </span>\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{IP}]<span class="math">  making at most  </span>q = q(\\lambda)<span class="math">  queries to its random oracle, for all  </span>\\lambda \\in \\mathbb{N}^+$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathsf {F S} ^ {\\mathsf {R O}} [ \\mathsf {I P} ], R} ^ {\\mathsf {f s - e x t - 2}} \\left(\\mathcal {P} _ {\\mathsf {a l g}} ^ {*}, \\mathcal {E} ^ {*}, \\lambda\\right) \\leqslant q \\varepsilon + p _ {\\mathsf {f a i l}, \\mathsf {F S}} \\left(\\mathsf {F S} ^ {\\mathbf {R O}} [ \\mathsf {I P} ], \\mathcal {P} _ {\\mathsf {a l g}} ^ {*}, \\mathsf {e}, R, \\lambda\\right).</span></div>

    <p class="text-gray-300">The time complexity of the extractor  <span class="math">\\mathcal{E}^*</span>  is  <span class="math">O(q\\cdot t_V + t_{\\mathrm{e}})</span>  where  <span class="math">t_V</span>  is the time required to run IP.V and  <span class="math">t_{\\mathrm{e}}</span>  is the time required to run e.</p>

    <p class="text-gray-300">The proof of this theorem is similar to Theorem 1 and has been omitted.</p>

    <p class="text-gray-300">In this section, we shall apply our framework to prove online srs-wee security in the AGM for two instantiations of Bulletproofs- range proofs (RngPf) and proofs for arithmetic circuit satisfiability (ACSPf). We first introduce the Bulletproofs inner product argument (InPrd) in Section 5.1 which forms the core of both RngPf and ACSPf. Then, in Sections 5.2 and 5.3 we introduce and analyze online srs-wee security of RngPf and ACSPf respectively.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 6. Bulletproofs inner-product argument InPrd.</p>

    <p class="text-gray-300">We shall assume that  <span class="math">\\mathsf{InPrd} = \\mathsf{InPrd}[\\mathbb{G}]</span>  is instantiated on an understood family of groups  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  of order  <span class="math">p = p(\\lambda)</span> . Using  <span class="math">\\mathsf{InPrd}</span> , a prover can convince a verifier that  <span class="math">P \\in \\mathbb{G}</span>  is a well-formed commitment to vectors  <span class="math">\\mathbf{a}, \\mathbf{b} \\in \\mathbb{Z}_p^n</span>  and their inner-product  <span class="math">\\langle \\mathbf{a}, \\mathbf{b} \\rangle</span> . More precisely, the prover wants to prove to the verifier that  <span class="math">P = \\mathbf{g}^{\\mathbf{a}} \\mathbf{h}^{\\mathbf{b}} u^{\\langle \\mathbf{a}, \\mathbf{b} \\rangle}</span>  where  <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> ,  <span class="math">\\mathbf{h} \\in \\mathbb{G}^n</span> ,  <span class="math">u \\in \\mathbb{G}</span>  are independent generators of  <span class="math">\\mathbb{G}</span> . We assume that  <span class="math">n</span>  is a power of 2 without loss of generality since if needed, one can pad the input appropriately to ensure that this holds. The prover and the verifier for  <span class="math">\\mathsf{InPrd}</span>  is formally defined in Figure 6.</p>

    <p class="text-gray-300">We shall assume that  <span class="math">\\mathsf{RngPf} = \\mathsf{RngPf}[\\mathbb{G}]</span>  is instantiated on an understood family of groups  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  of order  <span class="math">p = p(\\lambda)</span> . The argument  <span class="math">\\mathsf{RngPf}</span>  is an argument of knowledge for the relation</p>

    <div class="my-4 text-center"><span class="math-block">R = \\left\\{\\left((n \\in \\mathbb {N}, g, h \\in \\mathbb {G}), V \\in \\mathbb {G}, (v, \\gamma \\in \\mathbb {Z} _ {p})\\right): g ^ {v} h ^ {\\gamma} = V \\wedge v \\in [ 0, 2 ^ {n} - 1 ] \\right\\}. \\tag {4}</span></div>

    <p class="text-gray-300">DESCRIPTION OF RngPf. RngPf. Setup returns  <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> ,  <span class="math">\\mathbf{h} \\in \\mathbb{G}^n</span> ,  <span class="math">g, h, u \\in \\mathbb{G}</span>  where  <span class="math">\\mathbf{g}, \\mathbf{h}</span>  are vectors of independent generators and  <span class="math">g, h, u</span>  are other independent generators of the group  <span class="math">\\mathbb{G}</span> . The prover and verifier for RngPf are defined in Figure 7.</p>

    <p class="text-gray-300">In Theorem 4, we analyze the online srs-wee security for RngPf. Since RngPf has a group element  <span class="math">V</span>  in its input, the analysis of non-adaptive srs-wee security would differ from the online srs-wee analysis. In Section 7, we analyse the non-adaptive srs-wee security of RngPf – it turns out that the proof is even harder for this case because the function  <span class="math">\\mathbf{e}</span>  does not have the representation of  <span class="math">V</span> . The resulting bound is increased to the square root of the adaptive bound, due to our limited use of rewinding.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 7. Prover and Verifier for RngPf. The function  <span class="math">\\mathrm{BinRep}(v,n)</span>  outputs the  <span class="math">n</span> -bit representation of  <span class="math">v</span> . The symbol  <span class="math">\\Longleftrightarrow</span>  denotes the interaction between InPrd.P and InPrd.V with the output of the InPrd.V being  <span class="math">b</span> .</p>

    <p class="text-gray-300">Theorem 4. Let  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  be a family of groups of order  <span class="math">p = p(\\lambda)</span> . Let  <span class="math">\\mathsf{RngPf} = \\mathsf{RngPf}[\\mathbb{G}]</span>  be the interactive argument as defined in Figure 7, for the relation  <span class="math">R</span>  in (4). We can construct an extractor  <span class="math">\\mathcal{E}</span>  such that for any non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  making at most  <span class="math">q = q(\\lambda)</span>  queries to its oracle, there exists a non-uniform adversary  <span class="math">\\mathcal{F}</span>  with the property that for any (computationally unbounded) distinguisher  <span class="math">\\mathcal{D}</span> , for all  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\operatorname {R n g P f}, R} ^ {\\operatorname {s r - w e e}} \\left(\\mathcal {P} _ {\\text {a l g}}, \\mathcal {D}, \\mathcal {E}, \\lambda\\right) \\leqslant (1 4 n + 8) q / (p - 1) + \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} (\\mathcal {F}, \\lambda) + 1 / p.</span></div>

    <p class="text-gray-300">Moreover, the time complexity of the extractor  <span class="math">\\mathcal{E}</span>  is  <span class="math">O(q\\cdot n)</span>  and that of adversary  <span class="math">\\mathcal{F}</span>  is  <span class="math">O(q\\cdot n)</span> .</p>

    <p class="text-gray-300">We show that the bound above is tight in Theorem 5. Using Theorem 2, we get the following corollary.</p>

    <p class="text-gray-300">Corollary 1. Let  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  be a family of groups of order  <span class="math">p = p(\\lambda)</span> . Let  <span class="math">\\mathsf{RngPf} = \\mathsf{RngPf}[\\mathbb{G}]</span>  be the interactive argument as defined in Figure 7, for the relation  <span class="math">R</span>  in (4). We can construct an extractor  <span class="math">\\mathcal{E}</span>  such that for any non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  making at most  <span class="math">q = q(\\lambda)</span>  queries to its oracle, there exists a non-uniform adversary  <span class="math">\\mathcal{F}</span>  with the property that for any (computationally unbounded) distinguisher  <span class="math">\\mathcal{D}</span> , for all  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\operatorname {R n g P f}, R} ^ {\\operatorname {s r - w e e}} \\left(\\mathcal {P} _ {\\text {a l g}}, \\mathcal {D}, \\mathcal {E}, \\lambda\\right) \\leqslant (1 4 n + 8) q / (p - 1) + \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} (\\mathcal {F}, \\lambda) + 1 / p.</span></div>

    <p class="text-gray-300">Moreover, the time complexity of the extractor  <span class="math">\\mathcal{E}</span>  is  <span class="math">O(q\\cdot n)</span>  and that of adversary  <span class="math">\\mathcal{F}</span>  is  <span class="math">O(q\\cdot n)</span> .</p>

    <p class="text-gray-300">We show that the bound above is tight in Theorem 5. Using Theorem 2, we get the following corollary.</p>

    <p class="text-gray-300">Corollary 1. Let  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  be a family of groups of order  <span class="math">p = p(\\lambda)</span> . Let  <span class="math">\\mathsf{RngPf} = \\mathsf{RngPf}[\\mathbb{G}]</span>  be the interactive argument as defined in Figure 7, for the relation  <span class="math">R</span>  in (4). Let  <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{RngPf}]</span>  be the non-interactive argument obtained by applying the Fiat-Shamir transform to  <span class="math">\\mathsf{RngPf}</span>  using a random oracle. We can construct an extractor  <span class="math">\\mathcal{E}</span>  such that for any non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  making at most  <span class="math">q = q(\\lambda)</span>  queries to the random oracle there exists a non-uniform adversary  <span class="math">\\mathcal{F}</span>  with the property that for all  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathsf {F S} ^ {\\mathsf {R O}} [ \\mathsf {R n g P f} ], R} ^ {\\mathsf {f s - e x t - 1}} \\left(\\mathcal {P} _ {\\mathsf {a l g}}, \\mathcal {E}, \\lambda\\right) \\leqslant \\left((1 4 n + 9) q + 1\\right) / (p - 1) + \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathsf {d l}} (\\mathcal {F}, \\lambda) + 1 / p.</span></div>

    <p class="text-gray-300">Moreover, the time complexity of the extractor  <span class="math">\\mathcal{E}</span>  is  <span class="math">O(q\\cdot n)</span>  and that of adversary  <span class="math">\\mathcal{F}</span>  is  <span class="math">O(q\\cdot n)</span> .</p>

    <p class="text-gray-300">In order to prove Theorem 4, we invoke Theorem 1 by defining <span class="math">\\mathsf{BadCh}</span> and <span class="math">\\mathsf{e}</span> and showing that <span class="math">\\varepsilon\\leqslant(14n+8)/(p-1)</span> and there exists an adversary <span class="math">\\mathcal{F}</span> such that <span class="math">p_{\\mathsf{fail}}(\\mathsf{RngPf},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)\\leqslant\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(\\mathcal{F})+1/p</span>. In more detail, we construct a function <span class="math">\\mathsf{h}</span> such that for an accepting transcript <span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{RngPf}}</span> if <span class="math">\\mathsf{e}([\\tau])</span> fails to produce a valid witness, then <span class="math">\\mathsf{h}([\\tau])</span> returns a non-trivial discrete logarithm relation with respect to the generators. This <span class="math">\\mathsf{h}</span> is used to construct an adversary <span class="math">\\mathcal{H}</span> against the discrete logarithm relation problem and we invoke Lemma 2 to transform into adversary <span class="math">\\mathcal{F}</span> against the discrete logarithm problem, thus upper bounding <span class="math">p_{\\mathsf{fail}}(\\mathsf{RngPf},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)</span> using <span class="math">\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(\\mathcal{F})</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof (Theorem 4).</h6>

    <p class="text-gray-300">We extend the notation for representation of group elements introduced in Section 4 for representation with respect to vector of group elements like <span class="math">\\mathbf{g}</span>. The representation of a group element <span class="math">A=\\mathbf{g}^{a_{\\mathbf{g}}}g^{a_{g}}</span> with respect to <span class="math">(\\mathbf{g},g)</span> is <span class="math">[A]=(A,a_{\\mathbf{g}},a_{g})</span> where <span class="math">a_{\\mathbf{g}}=(a_{g_{1}},\\cdots,a_{g_{n}})</span>.</p>

    <p class="text-gray-300">Defining <span class="math">\\mathsf{BadCh}</span> and upper bounding <span class="math">\\varepsilon</span>. To start off, we define <span class="math">\\mathsf{BadCh}(\\tau^{\\prime})</span> for all partial transcripts <span class="math">\\tau^{\\prime}</span>. Let <span class="math">\\mathsf{Ch}</span> be the set from which the challenge that just follows <span class="math">\\tau^{\\prime}</span> is sampled. We use a helper function <span class="math">\\mathsf{CheckBad}</span> to define <span class="math">\\mathsf{BadCh}(\\tau^{\\prime})</span>. The function <span class="math">\\mathsf{CheckBad}</span> takes as input a partial extended transcript <span class="math">[\\tau^{\\prime}]</span> and a challenge <span class="math">c\\in\\mathsf{Ch}</span> and returns true if and only if <span class="math">c\\in\\mathsf{BadCh}(\\tau^{\\prime})</span>. For each verifier challenge in <span class="math">\\mathsf{RngPf}</span>, there is a definition of <span class="math">\\mathsf{CheckBad}</span> in Figure 8. Every <span class="math">\\mathsf{CheckBad}</span> function defines several bad conditions that depend on <span class="math">\\tau^{\\prime}</span> – most of these bad conditions are checked using the predicate <span class="math">\\mathsf{SZ}</span>. This predicate takes as input a vector of polynomials and a corresponding vector of points to evaluate the polynomial on and returns true iff any of the polynomials is non-zero but its evaluation at the corresponding point is zero. One can safely ignore the details of the definitions of <span class="math">\\mathsf{CheckBad}</span> functions for now – the rationale behind their definitions shall become apparent later on.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following lemma establishes an upper bound of <span class="math">(14n+8)/(p-1)</span> on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\tau^{\\prime}</span> be a partial transcript for <span class="math">\\mathsf{RngPf}</span>. Let <span class="math">\\mathsf{Ch}</span> be the set from which the challenge that comes right after <span class="math">\\tau^{\\prime}</span> is sampled. Then, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant(14n+8)/(p-1)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof of this lemma proceeds by computing an upper bound on the maximum fraction of <span class="math">c^{\\prime}</span>s in <span class="math">\\mathsf{Ch}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},c)</span> will return true, for all the definitions of <span class="math">\\mathsf{CheckBad}</span>, using the Schwartz-Zippel Lemma.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},(y,z))</span> returns true if <span class="math">\\mathsf{SZ}(f(Y,Z),(y,z))</span> is true. The polynomial <span class="math">f(Y,Z)</span> is a polynomial of degree at most <span class="math">n+1</span>. So, the fraction of <span class="math">(y,z)</span>’s for which <span class="math">\\mathsf{SZ}(f(Y,Z),(y,z))</span> is true is at most <span class="math">(n+1)/(p-1)</span> using the Schwartz-Zippel Lemma. Hence, the fraction of <span class="math">y,z\\in\\mathbb{Z}_{p}^{*}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},(y,z))</span> returns true is at most <span class="math">(n+1)/(p-1)</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},x)</span> returns true if any of <span class="math">\\mathsf{SZ}(f_{i}(X),x)</span> for <span class="math">i=1,2,3,4</span> is true. Since <span class="math">f_{1}(X)</span> and <span class="math">f_{2}(X)</span> are vectors of <span class="math">n</span> polynomials, each polynomial of degree <span class="math">2</span>, we get that the fraction of <span class="math">x^{\\prime}</span>s in <span class="math">\\mathbb{Z}_{p}^{<em>}</span> for which <span class="math">\\mathsf{SZ}(f_{i}(X),x)</span> is true for <span class="math">i=1,2</span> is at most <span class="math">2n/(p-1)</span>. The polynomials <span class="math">f_{3}(X),f_{4}(X)</span> are polynomials of degree at most <span class="math">2</span>. The fraction of <span class="math">x^{\\prime}</span>s in <span class="math">\\mathbb{Z}_{p}^{</em>}</span> for which <span class="math">\\mathsf{SZ}(f_{3}(X),x)</span> or <span class="math">\\mathsf{SZ}(f_{4}(X),x)</span> is true is at most <span class="math">2/(p-1)</span>. Using the union bound, the fraction of <span class="math">x^{\\prime}</span>s in <span class="math">\\mathbb{Z}_{p}^{*}</span> such that <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},x)</span> returns true is at most <span class="math">(4n+4)/(p-1)</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},w)</span> returns true if <span class="math">\\mathsf{SZ}(f(W),w)</span> is true. The polynomial <span class="math">f(W)</span> is a polynomial of degree <span class="math">1</span>, hence using the Schwartz-Zippel Lemma the fraction of <span class="math">w^{\\prime}</span>s in <span class="math">\\mathbb{Z}_{p}^{*}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},w)</span> returns true is at most <span class="math">1/(p-1)</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},x_{m})</span> returns true if and only if <span class="math">\\mathsf{SZ}</span> is true for any of the <span class="math">\\sum_{t=1}^{m-1}2n/2^{t}</span> polynomials of degree at most <span class="math">4</span> (the degree here is the difference between highest and lowest degree), <span class="math">2n/2^{m}</span> polynomials of degree at most <span class="math">6</span> and one polynomial of degree at most <span class="math">8</span>. Using</p>

    <p class="text-gray-300">Procedure CheckBad([τ'], (y, z)):</p>

    <p class="text-gray-300">//[τ'] = ((n, g, h, u, g, h), [V], ([A], [S])) f(Y, Z) ← Z²(v_g - <ag, 2^n>) - Z<ag - ah - 1^n, Y^n> - <ag ∘ ah, Y^n></p>

    <p class="text-gray-300">Return SZ(f(Y, Z), (y, z))</p>

    <p class="text-gray-300">Procedure CheckBad([τ'], x):</p>

    <p class="text-gray-300">//[τ'] = ((n, g, h, u, g, h), [V], ([A], [S]), (y, z), ([T1], [T2])) f_1(X) ← v_g z^2 + t_{1g}X + t_{2g}X^2; f_2(X) ← v_h z^2 + t_{1h}X + t_{2h}X^2 f_3(X) ← v_u z^2 + t_{1u}X + t_{2u}X^2; \\delta(y, z) ← (z - z^2) &lt; 1^n, y^n &gt; -z^3 &lt; 1^n, 2^n &gt; l(X) ← (ag - z · 1^n) + sg · X; r(X) ← y^n ∘ (ah + z · 1^n + sh · X) + z^2 · 2^n; f_4(X) ← v_g z^2 + δ(y, z) + t_{1g}X + t_{2g}X^2 - &lt; l(X), r(X) &gt; Return SZ(f_1(X), x) ∨ SZ(f_2(X), x) ∨ SZ(f_3(X), x) ∨ SZ(f_4(X), x)</p>

    <p class="text-gray-300">Procedure CheckBad([τ'], w):</p>

    <p class="text-gray-300">//[τ'] = ((n, g, h, u, g, h), [V], ([A], [S]), (y, z), ([T1], [T2]), x, (β_x, μ, t)) l ← (ag - z · 1^n) + sg · x; r ← (ah + xs_h + z1^n) ∘ y^n + z^22^n; f(W) ← Wt - W&lt;1, r&gt; Return SZ(f(W), w)</p>

    <p class="text-gray-300">Procedure CheckBad([τ'], x_m):</p>

    <p class="text-gray-300">//[τ'] = ((n, g, h, u, g, h), [V], ([A], [S]), (y, z), ([T1], [T2]), x, (β_x, μ, t), w, ([L1], [R1]), x_1, ..., ([L_m], [R_m])) p'_g ← ag + xs_g - z1^n; p'_h ← ah + xs_h + y^{-n} ∘ (zy^n + z^22^n); p'_u ← au + xs_u + wt For j = 0, ..., n-1 do f_g_m, j(X) ← l_mg_{1+j} + X^2 + r_mg_{1+j}X^{-2} + p'_g_{1+j} + \\sum_{i=1}^{m-1} (l_{ig_{1+j}}x_i^2 + r_{ig_{1+j}}x_i^{-2}) f_h_m, j(X) ← l_mh_{1+j}X^2 + r_mh_{1+j}X^{-2} + p'_h_{1+j} + \\sum_{i=1}^{m-1} (l_{ih_{1+j}}x_i^2 + r_{ih_{1+j}}x_i^{-2}) f_n^u(X) ← l_muX^2 + r_muX^{-2} + p'_u + \\sum_{i=1}^{m-1} (l_{iu}x_i^2 + r_{iu}x_i^{-2}) flag ← false For t = 1, ..., m-1 do for j = 0, ..., n/2^t - 1 do flag ← flag ∨ SZ(f_g_m, j(X) · x_i^2 - f_g_m, j+n/2^t(X), x_m) ∨ SZ(f_h_m, j(X) - f_h_m, j+n/2^t(X) · x_i^2, x_m) For j = 0, ..., n/2^m - 1 do flag ← flag ∨ SZ(f_g_m, j(X) · X^2 - f_g_m, j+n/2^m(X), x_m) ∨ SZ(f_h_m, j(X) - f_h_m, j+n/2^m(X) · X^2, x_m) flag ← flag ∨ SZ(f_n^u(X) - w · \\sum_{j=0}^{n/2^m-1} f_g_m, j(X) · f_h_m, j(X) · y^j, x_m) Return flag</p>

    <p class="text-gray-300">Fig. 8. The functions CheckBad function for the RngPf.</p>

    <p class="text-gray-300">Schwartz Zippel Lemma and the union bound the fraction of <span class="math">x_m</span>'s for which CheckBad(<span class="math">\\tau&#x27;, x_m</span>) returns true is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{8}{p - 1} \\left(\\sum_{t = 1}^{m - 1} \\frac{n}{2^t}\\right) + \\frac{12n}{2^m(p - 1)} + \\frac{8}{p - 1}.</span></div>

    <p class="text-gray-300">This fraction is at most <span class="math">(14n + 8)/(p - 1)</span> for <span class="math">m \\in \\{1, \\ldots, \\log n\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore the maximum value of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{BadCh}(\\tau')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Ch}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for any partial transcript </span>\\tau'<span class="math">, i.e., the maximum fraction of </span>c<span class="math">&#x27;s for which CheckBad(</span>\\tau', c<span class="math">) is true is upper bounded by </span>(14n + 8)/(p - 1)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">DEFINING e. Let <span class="math">\\tau</span> be a transcript of RngPf as defined below.</p>

    <div class="my-4 text-center"><span class="math-block">\\tau = \\left((n, \\mathbf{g}, \\mathbf{h}, u, g, h), V; (A, S), (y, z), (T_1, T_2), x, (\\beta_x, \\mu, \\hat{t}), w, (L_1, R_1), x_1, (L_2, R_2), x_2, \\dots, (L_{\\log n}, R_{\\log n}), x_{\\log n}, (a, b)\\right). \\tag{5}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us represent using $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_c<span class="math"> the prefix of </span>\\tau<span class="math"> just before the challenge </span>c$. For example</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(y, z)} = \\left((n, \\mathbf{g}, \\mathbf{h}, u, g, h), V, (A, S)\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$</ag></ag,></p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathsf{e}([\\tau])</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text {P r o c e d u r e e} (\\left[ \\tau \\right]): \\\\ \\text {I n e f u n c i o n} (\\left[ \\tau \\right]) = \\left(\\left(n, \\mathbf {g}, \\mathbf {h}, u, g, h\\right), [ V ]; ([ A ], [ S ]), (y, z), ([ T _ {1} ], [ T _ {2} ]), x, (\\beta_ {x}, \\mu , \\hat {t}), w, ([ L _ {1} ], [ R _ {1} ]), x _ {1}, \\dots , ([ L _ {\\log n} ], [ R _ {\\log n} ]), x _ {\\log n}, \\right. \\\\ \\left. \\left(a, b\\right)\\right) \\\\ v ^ {*} \\leftarrow v _ {g}; \\gamma^ {*} \\leftarrow v _ {h}; \\text {R e t u r n} \\left(v ^ {*}, \\gamma^ {*}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Fig. 9. The function e for RngPf.</p>

    <p class="text-gray-300">The function  <span class="math">\\mathsf{e}</span>  simply returns  <span class="math">(v_{g}, v_{h})</span> . However, its output is a valid witness only if  <span class="math">v_{\\mathbf{g}} = v_{\\mathbf{h}} = \\mathbf{0}^{n}</span> ,  <span class="math">v_{u} = 0</span>  and  <span class="math">v_{g} \\in [0, 2^{n} - 1]</span> .</p>

    <p class="text-gray-300">PROVING AN UPPER BOUND ON  <span class="math">p_{\\mathrm{fail}}(\\mathsf{RngPf}, \\mathcal{P}_{\\mathrm{alg}}, \\mathsf{e}, R, \\lambda)</span> . We construct an adversary  <span class="math">\\mathcal{H}</span>  against the discrete logarithm relation problem that takes as input independent generators  <span class="math">\\mathbf{g}, \\mathbf{h}, g, h, u</span>  of the group  <span class="math">\\mathbb{G}</span>  and works as follows. It simulates the game  <span class="math">\\mathsf{SRS}_{\\mathsf{RngPf}}</span>  to  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  using public parameters  <span class="math">n, \\mathbf{g}, \\mathbf{h}, g, h, u</span> . If  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  manages to produce an accepting transcript  <span class="math">\\tau</span> ,  <span class="math">\\mathcal{H}</span>  calls a helper function  <span class="math">\\mathsf{h}</span>  on input  <span class="math">[\\tau]</span>  and outputs whatever  <span class="math">\\mathsf{h}</span>  outputs. We shall define  <span class="math">\\mathsf{h}</span>  in such a way that for  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{RngPf}}</span>  if  <span class="math">\\mathsf{e}([\\tau])</span>  does not return a valid witness, then  <span class="math">\\mathsf{h}([\\tau])</span>  returns a non-trivial discrete logarithm relation. In other words, we have that whenever  <span class="math">\\mathsf{e}([\\tau])</span>  fails to extract a valid witness for an accepting transcript  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{RngPf}}</span> ,  <span class="math">\\mathcal{H}</span>  succeeds. So we have that  <span class="math">p_{\\mathrm{fail}}(\\mathsf{RngPf}, \\mathcal{P}_{\\mathrm{alg}}, \\mathsf{e}, R, \\lambda) \\leqslant \\mathsf{Adv}_{\\mathbb{G}, 2n + 3}^{\\mathsf{dl - rel}}(\\mathcal{H})</span> . Using Lemma 2 we would have that there exists an adversary  <span class="math">\\mathcal{F}</span>  such that  <span class="math">p_{\\mathrm{fail}}(\\mathsf{RngPf}, \\mathcal{P}_{\\mathrm{alg}}, \\mathsf{e}, R, \\lambda) \\leqslant \\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(\\mathcal{F}) + 1 / p</span> . We also have that  <span class="math">\\mathcal{F}</span>  is nearly as efficient as  <span class="math">\\mathcal{H}</span> .</p>

    <p class="text-gray-300">DEFINING h. We next describe the h function. Let  <span class="math">\\tau</span> , as defined in (5), be an accepting transcript.  <span class="math">V^{z^2}g^{\\delta(y,z)}T_1^x T_2^{x^2} = g^{\\hat{t}}h^{\\beta_x}</span> . must hold since  <span class="math">\\tau</span>  is an accepting transcript.</p>

    <p class="text-gray-300">The function  <span class="math">\\mathsf{h}</span>  can plug in the representations of  <span class="math">T_{1}, T_{2}, V</span>  into the above equation and compute  <span class="math">e_{\\mathbf{g}}^{(1)}, e_{\\mathbf{h}}^{(1)}, e_{g}^{(1)}, e_{h}^{(1)}, e_{u}^{(1)}</span>  such that  <span class="math">\\mathbf{g}^{e_{\\mathbf{g}}^{(1)}} \\mathbf{h}^{e_{\\mathbf{h}}^{(1)}} g^{e_{g}^{(1)}} h^{e_{h}^{(1)}} u^{e_{u}^{(1)}} = 1</span> . If not all of these are zero,  <span class="math">\\mathsf{h}</span>  returns  <span class="math">e_{\\mathbf{g}}^{(1)}, e_{\\mathbf{h}}^{(1)}, e_{g}^{(1)}, e_{h}^{(1)}, e_{u}^{(1)}</span> .</p>

    <p class="text-gray-300">Again since  <span class="math">\\tau</span>  is an accepting transcript, InPrd.V must have returned 1 and hence  <span class="math">P^{(\\log n)} = (\\mathbf{g}^{(\\log n)})^a (\\mathbf{h}^{(\\log n)})^b u^{ab}</span>  must hold. All the terms in the above equality can be expressed in terms of  <span class="math">\\mathbf{g},\\mathbf{h},g,h,u</span>  and one can compute  <span class="math">e_{\\mathbf{g}}^{(2)},e_{\\mathbf{h}}^{(2)},e_{g}^{(2)},e_{h}^{(2)},e_{u}^{(2)}</span>  such that  <span class="math">\\mathbf{g}^{e_{\\mathbf{g}}^{(2)}}\\mathbf{h}^{e_{\\mathbf{h}}^{(2)}}g^{e_{g}^{(2)}}h^{e_{h}^{(2)}}u^{e_{u}^{(2)}} = 1</span> . The function  <span class="math">\\mathsf{h}</span>  computes and returns  <span class="math">e_{\\mathbf{g}}^{(2)},e_{\\mathbf{h}}^{(2)},e_{g}^{(2)},e_{h}^{(2)},e_{u}^{(2)}</span> . We define the function  <span class="math">\\mathsf{h}</span>  formally in Figure 10. It follows from the description of  <span class="math">\\mathsf{h}</span>  that it runs in time  <span class="math">O(n)</span> . The running time of  <span class="math">\\mathcal{H}</span>  consists of the time required to answer  <span class="math">q</span>  queries, run RngPf.V in at most  <span class="math">q</span>  paths in the execution tree and the time required to run  <span class="math">\\mathsf{h}</span> . Hence its time complexity is  <span class="math">O(q\\cdot n)</span> . Using Lemma 2, time complexity of  <span class="math">\\mathcal{F}</span>  is  <span class="math">O(q\\cdot n)</span> .</p>

    <p class="text-gray-300">RELATING h, e. In order to complete the proof of Theorem 4, in the following lemma we show that - for an accepting transcript  <span class="math">\\tau</span>  such that  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{RngPf}}</span>  if  <span class="math">\\mathsf{e}([\\tau])</span>  does not return a valid witness, then  <span class="math">\\mathsf{h}([\\tau])</span>  returns a non-trivial discrete logarithm relation. Proving this lemma would conclude the proof of Theorem 4.</p>

    <p class="text-gray-300">Lemma 6. Let  <span class="math">\\tau</span> , as defined in (5), be an accepting transcript of  <span class="math">\\mathsf{RngPf}</span>  such that  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{RngPf}}</span> . If  <span class="math">\\mathsf{e}([\\tau])</span>  returns  <span class="math">(v^{<em>},\\gamma^{</em>})</span>  such that at least one of the following hold:  <span class="math">g^{v^{<em>}}h^{\\gamma^{</em>}} \\neq V</span>  or  <span class="math">v^{*} \\notin [0,2^{n} - 1]</span> , then  <span class="math">\\mathsf{h}([\\tau])</span>  returns a non-trivial discrete logarithm relation.</p>

    <p class="text-gray-300">Proof (Lemma 6). For simplicity, we shall prove the contrapositive of the statement, i.e., assuming  <span class="math">\\mathsf{h}([\\tau])</span>  returns a trivial discrete logarithm relation, then  <span class="math">g^{v^<em>}h^{\\gamma^</em>} = V</span>  and  <span class="math">v^{*}\\in [0,2^{n} - 1]</span></p>

    <p class="text-gray-300">Procedure h([τ]):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} / / [ \\tau ] = ((n, \\mathbf {g}, \\mathbf {h}, u, g, h), [ V ]; ([ A ], [ S ]), (y, z), ([ T _ {1} ], [ T _ {2} ]), x, (\\beta_ {x}, \\mu , \\hat {t}), w, ([ L _ {1} ], [ R _ {1} ]), x _ {1}, \\dots , \\\\ \\left(\\left[ L _ {\\log n} \\right], \\left[ R _ {\\log n} \\right]\\right), x _ {\\log n}, (a, b)) \\\\ \\delta (y, z) \\leftarrow (z - z ^ {2}) \\langle \\mathbf {1} ^ {n}, \\mathbf {y} ^ {n} \\rangle - z ^ {3} \\langle \\mathbf {1} ^ {n}, \\mathbf {2} ^ {n} \\rangle \\\\ e _ {\\mathbf {g}} ^ {(1)} \\leftarrow v _ {\\mathbf {g}} z ^ {2} + t _ {1 \\mathbf {g}} x + t _ {2 \\mathbf {g}} x ^ {2}; e _ {\\mathbf {h}} ^ {(1)} \\leftarrow v _ {\\mathbf {h}} z ^ {2} + t _ {1 \\mathbf {h}} x + t _ {2 \\mathbf {h}} x ^ {2}; e _ {u} ^ {(1)} \\leftarrow v _ {u} z ^ {2} + t _ {1 u} x + t _ {2 u} x ^ {2}; e _ {g} ^ {(1)} \\leftarrow v _ {g} z ^ {2} + \\delta (y, z) + t _ {1 g} x + t _ {2 g} x ^ {2} - \\hat {t}; \\\\ e _ {h} ^ {(1)} \\leftarrow v _ {h} z ^ {2} + t _ {1 h} x + t _ {2 h} x ^ {2} - \\beta_ {x} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If  <span class="math">(e_{\\mathbf{g}}^{(1)}, e_{\\mathbf{h}}^{(1)}, e_{u}^{(1)}, e_{g}^{(1)}, e_{h}^{(1)}) \\neq (\\mathbf{0}^n, \\mathbf{0}^n, 0, 0, 0)</span>  then return  <span class="math">(e_{\\mathbf{g}}^{(1)}, e_{\\mathbf{h}}^{(1)}, e_{u}^{(1)}, e_{g}^{(1)}, e_{h}^{(1)})</span></p>

    <p class="text-gray-300"><span class="math">p_{\\mathbf{g}}^{\\prime}\\gets (a_{\\mathbf{g}}) + xs_{\\mathbf{g}} - z\\mathbf{1}^{n};p_{\\mathbf{h}}^{\\prime}\\gets a_{\\mathbf{h}} + xs_{\\mathbf{h}} + \\mathbf{y}^{-n}\\circ (z\\mathbf{y}^{n} + z^{2}\\mathbf{2}^{n})</span></p>

    <p class="text-gray-300"><span class="math">p_g^\\prime \\gets a_g + xs_g;p_h^\\prime \\gets a_h + xs_h - \\mu ;p_u^\\prime \\gets a_u + xs_u + w\\hat{t}</span></p>

    <p class="text-gray-300">For  <span class="math">k = 0</span>  to  <span class="math">n - 1</span>  do</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e _ {g _ {k + 1}} ^ {(2)} \\leftarrow p _ {g _ {1 + k}} ^ {\\prime} + \\sum_ {i = 1} ^ {\\log n} l _ {i g _ {1 + k}} x _ {i} ^ {2} + r _ {i g _ {1 + k}} x _ {i} ^ {- 2} - a \\cdot \\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {1 - \\operatorname {b i t} (k, i, \\log n)}} \\\\ e _ {h _ {k + 1}} ^ {(2)} \\leftarrow p _ {h _ {1 + k}} ^ {\\prime} + \\sum_ {i = 1} ^ {\\log n} l _ {i h _ {1 + k}} x _ {i} ^ {2} + r _ {i h _ {1 + k}} + x _ {i} ^ {- 2} - b y ^ {(- (k))} \\cdot \\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {\\mathrm {b i t} (k, i, \\log n)}} \\\\ e _ {\\mathbf {g}} ^ {(2)} \\leftarrow \\left(e _ {g _ {1}} ^ {(2)}, \\dots , e _ {g _ {n}} ^ {(2)}\\right); e _ {\\mathbf {h}} ^ {(2)} \\leftarrow \\left(e _ {h _ {1}} ^ {(2)}, \\dots , e _ {h _ {n}} ^ {(2)}\\right); e _ {u} ^ {(2)} \\leftarrow p _ {u} ^ {\\prime} + \\sum_ {i = 1} ^ {\\log n} l _ {i u} x _ {i} ^ {2} + r _ {i u} x _ {i} ^ {- 2} - w \\cdot a b \\\\ e _ {g} ^ {(2)} \\leftarrow \\sum_ {i = 1} ^ {\\log n} l _ {i g} x _ {i} ^ {2} + r _ {i g} x _ {i} ^ {- 2} + p _ {g} ^ {\\prime}; e _ {h} ^ {(2)} \\leftarrow \\sum_ {i = 1} ^ {\\log n} l _ {i h} x _ {i} ^ {2} + r _ {i h} x _ {i} ^ {- 2} + p _ {h} ^ {\\prime} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Return  <span class="math">(e_{\\mathbf{g}}^{(2)}, e_{\\mathbf{h}}^{(2)}, e_{u}^{(2)}, e_{g}^{(2)}, e_{h}^{(2)})</span></p>

    <p class="text-gray-300">Fig. 10. The function  <span class="math">h</span>  for  <span class="math">RngPf</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to prove  <span class="math">g^{v^<em>}h^{\\gamma^</em>} = V</span>  and  <span class="math">v^{*}\\in [0,2^{n} - 1]</span> , it suffices to show that  <span class="math">v_{\\mathbf{g}} = v_{\\mathbf{h}} = \\mathbf{0}^{n}</span> ,  <span class="math">v_{u} = 0</span>  and  <span class="math">v_{g}\\in [0,2^{n} - 1]</span> . Let us denote using  $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{c}<span class="math">  the partial transcript that is the prefix of  </span>\\tau<span class="math">  just before the challenge  </span>c$ . For example</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {(y, z)} = \\left((n, \\mathbf {g}, \\mathbf {h}, u, g, h), V, (A, S)\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since we assumed that  <span class="math">\\mathsf{h}([\\tau])</span>  returns  <span class="math">(\\mathbf{0}^n, \\mathbf{0}^n, 0, 0, 0)</span> , we have that for  <span class="math">i = 1, 2</span> ,  <span class="math">(e_{\\mathbf{g}}^{(i)}, e_{\\mathbf{h}}^{(i)}, e_{g}^{(i)}, e_{h}^{(i)}, e_{u}^{(i)}) = (\\mathbf{0}^n, \\mathbf{0}^n, 0, 0, 0)</span> .</p>

    <p class="text-gray-300">Writing out the expression for  <span class="math">e_{\\mathbf{g}}^{(1)}</span>  we get</p>

    <div class="my-4 text-center"><span class="math-block">v _ {\\mathbf {g}} z ^ {2} + t _ {1 \\mathbf {g}} x + t _ {2 \\mathbf {g}} x ^ {2} = \\mathbf {0} ^ {n}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  <span class="math">\\tau \\notin T_{\\mathrm{BadCh}}^{\\mathrm{RngPf}}</span> , we have that  $x \\notin \\mathrm{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x)<span class="math"> . Therefore,  </span>\\mathsf{SZ}(f_1(X), x)<span class="math">  is false where  </span>f_1<span class="math">  is as defined in CheckBad  </span>(\\tau', x)<span class="math"> . Since we have here that  </span>f_1(x) = 0<span class="math"> , the polynomial  </span>f_1(X)<span class="math">  is the zero vector polynomial. In particular, its constant term  </span>v_{\\mathbf{g}}z^2 = \\mathbf{0}^n<span class="math"> . Since  </span>z \\neq 0<span class="math">  it follows that  </span>v_{\\mathbf{g}} = \\mathbf{0}^n<span class="math"> . Similarly using  </span>e_{\\mathbf{h}}^{(1)} = \\mathbf{0}^n<span class="math">  and  </span>e_u^{(1)} = 0<span class="math">  we can show that  </span>v_{\\mathbf{h}} = \\mathbf{0}^n<span class="math">  and  </span>v_u = 0<span class="math">  respectively. Writing out the expression for  </span>e_g^{(1)}<span class="math">  we have  </span>v_g z^2 + \\delta(y, z) + t_{1g}x + t_{2g}x^2 - \\hat{t} = 0$ . Hence,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\hat {t} = v _ {g} z ^ {2} + \\delta (y, z) + t _ {1 g} x + t _ {2 g} x ^ {2}. \\tag {6}</span></div>

    <p class="text-gray-300">Using  <span class="math">e_{\\mathbf{g}}^{(2)} = \\mathbf{0}^n</span>  we get for all  <span class="math">k \\in \\{0, \\dots, n - 1\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">p _ {g _ {1 + k}} ^ {\\prime} + \\sum_ {i = 1} ^ {\\log n} \\left(l _ {i g _ {1 + k}} x _ {i} ^ {2} + r _ {i g _ {1 + k}} x _ {i} ^ {- 2}\\right) - a \\cdot \\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {1 - \\operatorname {b i t} (k, i, \\log n)}} = 0. \\tag {7}</span></div>

    <p class="text-gray-300">Using <span class="math">e_{\\mathbf{h}}^{(2)} = \\mathbf{0}^n</span> we get for all <span class="math">k \\in \\{0, \\dots, n - 1\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">p _ {h _ {1 + k}} ^ {\\prime} + \\sum_ {i = 1} ^ {\\log n} \\left(l _ {i h _ {1 + k}} x _ {i} ^ {2} + r _ {i h _ {1 + k}} x _ {i} ^ {- 2}\\right) - b y ^ {(- (k))} \\cdot \\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {\\mathrm {b i t} (k, i, \\log n)}} = 0. \\tag {8}</span></div>

    <p class="text-gray-300">Using <span class="math">e_u^{(2)} = 0</span> we get that</p>

    <div class="my-4 text-center"><span class="math-block">p _ {u} ^ {\\prime} + \\sum_ {i = 1} ^ {\\log n} \\left(l _ {i u} x _ {i} ^ {2} + r _ {i u} x _ {i} ^ {- 2}\\right) - w \\cdot a b = 0. \\tag {9}</span></div>

    <p class="text-gray-300">We shall next use the following lemma which essentially says that if all of <span class="math">e_{\\mathbf{g}}^{(2)}, e_{\\mathbf{h}}^{(2)}, e_{u}^{(2)}, e_{g}^{(2)}, e_{h}^{(2)}</span> are zero and <span class="math">\\tau \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{RngPf}}</span>, then <span class="math">w \\cdot \\langle p_{\\mathbf{g}}&#x27;, p_{\\mathbf{h}}&#x27; \\circ \\mathbf{y}^n \\rangle = p_u&#x27;</span>.</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let <span class="math">\\tau</span>, as shown in (5), be an accepting transcript of RngPf such that <span class="math">\\tau \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{RngPf}}</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">p _ {\\mathbf {g}} ^ {\\prime} = a _ {\\mathbf {g}} + x s _ {\\mathbf {g}} - z \\mathbf {1} ^ {n}, p _ {\\mathbf {h}} ^ {\\prime} = a _ {\\mathbf {h}} + x s _ {\\mathbf {h}} + \\mathbf {y} ^ {- n} \\circ (z \\mathbf {y} ^ {n} + z ^ {2} \\mathbf {2} ^ {n}), p _ {u} ^ {\\prime} = a _ {u} + x s _ {u} + w \\hat {t}.</span></div>

    <p class="text-gray-300">Suppose, the for all <span class="math">k \\in \\{0, \\dots, n - 1\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i = 1} ^ {\\log n} \\left(l _ {i g _ {1 + k}} x _ {i} ^ {2} + r _ {i g _ {1 + k}} x _ {i} ^ {- 2}\\right) + p _ {g _ {1 + k}} ^ {\\prime}\\right) - a \\cdot \\left(\\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {1 - \\mathrm {b i t} (k, i, \\log n)}}\\right) = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i = 1} ^ {\\log n} \\left(l _ {i h _ {1 + k}} x _ {i} ^ {2} + r _ {i h _ {1 + k}} x _ {i} ^ {- 2}\\right) + p _ {h _ {1 + k}} ^ {\\prime}\\right) - b y ^ {(- (k))} \\cdot \\left(\\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {\\mathrm {b i t} (k, i, \\log n)}}\\right) = 0.</span></div>

    <p class="text-gray-300">Also, <span class="math">\\left(\\sum_{i = 1}^{\\log n}\\left(l_{iu}x_i^2 +r_{iu}x_i^{-2}\\right)\\right) + p_u&#x27; - w\\cdot ab = 0.</span> Then <span class="math">w\\cdot \\langle p_{\\mathbf{g}}&#x27;,p_{\\mathbf{h}}&#x27;\\circ \\mathbf{y}^n\\rangle = p_u&#x27;</span></p>

    <p class="text-gray-300">The proof of this lemma is a generalization of the proof that we gave for the inner product argument for <span class="math">n = 2</span> in the technical overview.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> We define a function Bad in Figure 11 that takes as input <span class="math">x \\in \\mathbb{Z}_p^*</span> and an index <span class="math">m \\in \\{1, \\dots, \\log n\\}</span>. It returns true if and only if $x \\in \\mathrm{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x_m})$. We shall then use Lemma 8, which is a purely algebraic lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 8.</strong> Let <span class="math">n \\in \\mathbb{N}^+</span> be a power of 2. Let <span class="math">\\{l_{i\\mathbf{g}} \\in \\mathbb{Z}_p^n, l_{i\\mathbf{h}} \\in \\mathbb{Z}_p^n, l_{iu} \\in \\mathbb{Z}_p, r_{i\\mathbf{g}} \\in \\mathbb{Z}_p^n, r_{i\\mathbf{h}} \\in \\mathbb{Z}_p^n, r_{iu} \\in \\mathbb{Z}_p\\}_{i=1}^{\\log n}</span>. Let <span class="math">a, b, p_{\\mathbf{g}}&#x27;, p_{\\mathbf{h}}&#x27;, p_u&#x27; \\in \\mathbb{Z}_p</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\text {p a r a m s} = \\left\\{\\left\\{l _ {i \\mathbf {g}}, l _ {i \\mathbf {h}}, l _ {i u}, r _ {i \\mathbf {g}}, r _ {i \\mathbf {h}}, r _ {i u} \\right\\} _ {i = 1} ^ {\\log n}, p _ {\\mathbf {g}} ^ {\\prime}, p _ {\\mathbf {h}} ^ {\\prime}, p _ {u} ^ {\\prime} \\right\\}.</span></div>

    <p class="text-gray-300">Let <span class="math">x_{1}, \\ldots, x_{\\log n} \\in \\mathbb{Z}_{p}^{*}</span> such that <span class="math">\\operatorname{Bad}(\\text{params}, x_{i}, i) = \\text{false}</span> for <span class="math">i = 1, \\ldots, \\log n</span> where <span class="math">\\operatorname{Bad}</span> is defined in Figure 11. Suppose, the following equalities hold.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">k \\in \\{0, \\dots, n - 1\\}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i = 1} ^ {\\log n} \\left(l _ {i g _ {1 + k}} x _ {i} ^ {2} + r _ {i g _ {1 + k}} x _ {i} ^ {- 2}\\right) + p _ {g _ {1 + k}} ^ {\\prime}\\right) - a \\cdot \\left(\\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {1 - \\mathrm {b i t} (k, i, \\log n)}}\\right) = 0.</span></div>

    <p class="text-gray-300">Procedure Bad.params,  <span class="math">x,m</span>  .. //params  <span class="math">\\equiv</span> <span class="math">\\left\\{\\{l_{i\\mathbf{g}},l_{i\\mathbf{h}},l_{iu},r_{i\\mathbf{g}},r_{i\\mathbf{h}},r_{iu}\\}_{i = 1}^{\\log n},p_{\\mathbf{g}}^{\\prime},p_{\\mathbf{h}}^{\\prime},p_{u}^{\\prime}\\right\\}</span> For  <span class="math">j = 0,\\dots ,n - 1</span>  do <span class="math">f_{m,j}^{\\mathbf{g}}(X)\\gets l_{mg_{1 + j}} + X^{2} + r_{mg_{1 + j}}X^{-2} + p_{g_{1 + j}}^{\\prime} + \\sum_{i = 1}^{m - 1}(l_{ig_{1 + j}}x_i^2 +r_{ig_{1 + j}}x_i^{-2})</span> <span class="math">f_{m,j}^{\\mathbf{h}}(X)\\gets l_{mh_{1 + j}}X^{2} + r_{mh_{1 + j}}X^{-2} + p_{h_{1 + j}}^{\\prime} + \\sum_{i = 1}^{m - 1}(l_{ih_{1 + j}}x_i^2 +r_{ih_{1 + j}}x_i^{-2})</span> <span class="math">f_{m}^{u}(X)\\gets l_{mu}X^{2} + r_{mu}X^{-2} + p_{u}^{\\prime} + \\sum_{i = 1}^{m - 1}(l_{iu}x_i^2 +r_{iu}x_i^{-2})</span> For  <span class="math">t = 1,\\ldots ,m - 1</span>  do For  <span class="math">j = 0,\\dots ,n / 2^{t} - 1</span>  do flag  <span class="math">\\leftarrow</span>  flag  <span class="math">\\vee</span>  SZ(fgM,j(X)  <span class="math">\\cdot x_{t}^{2} - f_{m,j + n / 2^{t}}^{\\mathbf{g}}(X),x)\\vee</span>  SZ(fhM,j(X)-fhM,j+n/2t(X)  <span class="math">\\cdot x_{t}^{2},x)</span> For  <span class="math">j = 0,\\dots ,n / 2^{m} - 1</span>  do flag  <span class="math">\\leftarrow</span>  flag  <span class="math">\\vee</span>  SZ(fgM,j(X)  <span class="math">\\cdot X^{2} - f_{m,j + n / 2^{m}}^{\\mathbf{g}}(X),x)\\vee</span>  SZ(fhM,j(X)-fhM,j+n/2m(X)  <span class="math">\\cdot X^{2},x)</span> flag  <span class="math">\\leftarrow</span>  flag  <span class="math">\\vee</span>  SZ(fuM,(X)-w  <span class="math">\\cdot \\sum_{j = 0}^{n / 2^m -1}f_{m,j}^{\\mathbf{g}}(X)\\cdot f_{m,j}^{\\mathbf{h}}(X)\\cdot y^j,x)</span> Return flag</p>

    <p class="text-gray-300">Fig. 11. The function Bad for Lemma 8.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all  <span class="math">k \\in \\{0, \\dots, n - 1\\}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i = 1} ^ {\\log n} \\left(l _ {i h _ {1 + k}} x _ {i} ^ {2} + r _ {i h _ {1 + k}} x _ {i} ^ {- 2}\\right) + p _ {h _ {1 + k}} ^ {\\prime}\\right) - b y ^ {(- (k))} \\cdot \\left(\\prod_ {i = 1} ^ {\\log n} x _ {i} ^ {(- 1) ^ {\\mathrm {b i t} (k, i, \\log n)}}\\right) = 0.</span></div>

    <p class="text-gray-300">3.</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i = 1} ^ {\\log n} \\left(l _ {i u} x _ {i} ^ {2} + r _ {i u} x _ {i} ^ {- 2}\\right)\\right) + p _ {u} ^ {\\prime} - w \\cdot a b = 0.</span></div>

    <p class="text-gray-300">Then</p>

    <div class="my-4 text-center"><span class="math-block">w \\cdot \\left\\langle p _ {\\mathbf {g}} ^ {\\prime}, p _ {\\mathbf {h}} ^ {\\prime} \\circ \\mathbf {y} ^ {n} \\right\\rangle = p _ {u} ^ {\\prime}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\text{params} = \\left\\{\\{l_{i\\mathbf{g}}, l_{i\\mathbf{h}}, l_{iu}, r_{i\\mathbf{g}}, r_{i\\mathbf{h}}, r_{iu}\\}_{i=1}^{\\log n}, p_{\\mathbf{g}}&#x27;, p_{\\mathbf{h}}&#x27;, p_{u}&#x27;\\right\\}</span> . Note that  <span class="math">\\text{Bad}(\\text{params}, x, j)</span>  returns true if and only if  $x \\in \\text{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x_j})<span class="math"> . Therefore, we have that  </span>x_1, \\ldots, x_{\\log n}<span class="math">  in  </span>\\tau<span class="math">  satisfy the condition for  </span>x_i<span class="math"> &#x27;s in Lemma 8. Moreover all the equalities required in Lemma 8 hold and  </span>p_{\\mathbf{g}}', p_{\\mathbf{h}}', p_{u}' \\in \\mathbb{Z}_p$ . So we using Lemma 8 we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">w \\cdot \\left\\langle p _ {\\mathbf {g}} ^ {\\prime}, p _ {\\mathbf {h}} ^ {\\prime} \\circ \\mathbf {y} ^ {n} \\right\\rangle = p _ {u} ^ {\\prime}.</span></div>

    <p class="text-gray-300">The proof of Lemma 8 is deferred to Section 5.4.</p>

    <p class="text-gray-300">Since  <span class="math">\\tau</span>  is an accepting transcript of RngPf and  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{RngPf}}</span>  and (7) to (9) hold, using Lemma 7, we get  <span class="math">w\\langle p_{\\mathbf{g}}&#x27;,p_{\\mathbf{h}}&#x27;\\circ \\mathbf{y}^n\\rangle = p_u&#x27;</span> . Plugging in the values of  <span class="math">p_{\\mathbf{g}}&#x27;,p_{\\mathbf{h}}&#x27;,p_u&#x27;</span>  we get</p>

    <div class="my-4 text-center"><span class="math-block">w \\cdot \\left\\langle a _ {\\mathbf {g}} + x s _ {\\mathbf {g}} - z \\mathbf {1} ^ {n}, \\left(a _ {\\mathbf {h}} + x s _ {\\mathbf {h}} + z \\mathbf {1} ^ {n}\\right) \\circ \\mathbf {y} ^ {n} + z ^ {2} \\mathbf {2} ^ {n} \\right\\rangle = a _ {u} + x s _ {u} + w \\hat {t}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{RngPf}}</span> , we have that  $w \\notin \\mathrm{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_w)<span class="math"> . Therefore,  </span>\\mathsf{SZ}(f(W), w)<span class="math">  is false where  </span>f<span class="math">  is as defined in CheckBad  </span>(\\tau', w)<span class="math"> . Since we have here that  </span>f(w) = 0<span class="math"> , the polynomial  </span>f(W)<span class="math">  must be the zero polynomial. In particular its  </span>W$  term must be zero, i.e.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left\\langle a _ {\\mathbf {g}} + x s _ {\\mathbf {g}} - z \\mathbf {1} ^ {n}, \\left(a _ {\\mathbf {h}} + x s _ {\\mathbf {h}} + z \\mathbf {1} ^ {n}\\right) \\circ \\mathbf {y} ^ {n} + z ^ {2} \\mathbf {2} ^ {n} \\right\\rangle = \\hat {t}.</span></div>

    <p class="text-gray-300"><span class="math">\\hat{t}</span> obtained in (6), we have that</p>

    <p class="text-gray-300"><span class="math">(v_{g}z^{2}+\\delta(y,z)+t_{1g}x+t_{2g}x^{2})-\\langle a_{\\mathbf{g}}+xs_{\\mathbf{g}}-z\\mathbf{1}^{n},(a_{\\mathbf{h}}+xs_{\\mathbf{h}}+z\\mathbf{1}^{n})\\circ\\mathbf{y}^{n}</span> <span class="math">+z^{2}\\mathbf{2}^{n}\\rangle=0\\ .</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, using $x\\notin\\mathsf{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x})$, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">v_{g}z^{2}+\\delta(y,z)-\\langle a_{\\mathbf{g}}-z\\mathbf{1}^{n},(a_{\\mathbf{h}}+z\\mathbf{1}^{n})\\circ\\mathbf{y}^{n}+z^{2}\\mathbf{2}^{n}\\rangle=0\\ .</span></p>

    <p class="text-gray-300">Plugging in the value of <span class="math">\\delta(y,z)</span>, rearranging and simplifying we get</p>

    <p class="text-gray-300"><span class="math">z^{2}(v_{g}-\\langle a_{\\mathbf{g}},\\mathbf{2}^{n}\\rangle)-z\\langle a_{\\mathbf{g}}-a_{\\mathbf{h}}-\\mathbf{1}^{n},\\mathbf{y}^{n}\\rangle-\\langle a_{\\mathbf{g}}\\circ a_{\\mathbf{h}},\\mathbf{y}^{n}\\rangle=0\\ .</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using $(y,z)\\notin\\mathsf{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(y,z)})<span class="math">, we get that </span>v_{g}-\\langle a_{\\mathbf{g}},\\mathbf{2}^{n}\\rangle=0<span class="math">, </span>a_{\\mathbf{g}}-a_{\\mathbf{h}}-\\mathbf{1}^{n}=\\mathbf{0}^{n}<span class="math">, </span>a_{\\mathbf{g}}\\circ a_{\\mathbf{h}}=\\mathbf{0}^{n}<span class="math">. Note that </span>a_{\\mathbf{g}}-a_{\\mathbf{h}}-\\mathbf{1}^{n}=\\mathbf{0}^{n}<span class="math"> and </span>a_{\\mathbf{g}}\\circ a_{\\mathbf{h}}=\\mathbf{0}^{n}<span class="math"> imply that </span>a_{\\mathbf{g}}\\in\\{0,1\\}^{n}<span class="math">. Further </span>v_{g}-\\langle a_{\\mathbf{g}},\\mathbf{2}^{n}\\rangle=0<span class="math">, i.e., </span>v_{g}=\\langle a_{\\mathbf{g}},\\mathbf{2}^{n}\\rangle<span class="math">. So, </span>v_{g}\\in[0,2^{n}-1]<span class="math">. Therefore, </span>v^{<em>},\\gamma^{</em>}<span class="math"> output by </span>\\mathsf{e}([\\tau])<span class="math"> satisfy </span>V=g^{v^{<em>}}h^{\\gamma^{</em>}}<span class="math"> and </span>v^{*}\\in[0,2^{n}-1]$. This concludes the proof of Lemma 6 and Theorem 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <p class="text-gray-300">Further for a prover <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> for <span class="math">\\mathsf{FS^{RO}}[\\mathsf{RngPf}]</span>, and the <span class="math">\\mathsf{e}</span> we define in the proof of Theorem 4, we can upper bound <span class="math">p_{\\mathsf{fail},\\mathsf{FS}}(\\mathsf{FS^{RO}}[\\mathsf{RngPf}],\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)</span> using techniques very similar to those used in the proof of Theorem 4. This is because we can prove that if the prover outputs an instance and an accepting proof and <span class="math">\\mathsf{e}</span> fails to produce a valid witness, then we can compute a non-trivial discrete logarithm relation from the representation of the transcript and instance unless one of the challenges in the transcript are bad which we can show happens with small probability. Then using Theorem 3 we obtain a bound for the fs-ext-2 security of <span class="math">\\mathsf{FS^{RO}}[\\mathsf{RngPf}]</span> similar to the one we obtained for fs-ext-1 security in Corollary 1.</p>

    <p class="text-gray-300">Tightness of Theorem 4. We next argue that the factor <span class="math">O(nq/(p-1))</span> in Theorem 4 is tight. We first note that the protocol <span class="math">\\mathsf{RngPf}</span> can be used for the following relation</p>

    <p class="text-gray-300"><span class="math">R^{\\prime}=\\left\\{\\,(n\\in\\mathbb{N},g,V\\in\\mathbb{G},v\\in\\mathbb{Z}_{p}):g^{v}=V\\wedge v\\in[0,2^{n}-1]\\right\\}\\,,</span> (10)</p>

    <p class="text-gray-300">by fixing <span class="math">\\gamma</span> to <span class="math">0</span>.</p>

    <p class="text-gray-300">We shall construct a cheating prover <span class="math">\\mathcal{P}</span> (that makes <span class="math">O(q)</span> queries to <span class="math">\\mathbf{O}_{\\mathsf{ext}}</span>) for the relation <span class="math">R^{\\prime}</span> that outputs an instance <span class="math">V=g^{v}</span> such that <span class="math">v\\notin[0,2^{n}-1]</span> but can still convince the <span class="math">\\mathsf{RngPf}</span> verifier with probability <span class="math">\\Omega(nq/(p-1))</span> if <span class="math">n</span> divides <span class="math">p-1</span>. In other words, we show that there exist <span class="math">n,p</span> such that <span class="math">\\mathsf{Adv^{yrs}_{\\mathsf{RngPf}}}(\\mathcal{P},\\lambda)=\\Omega(nq/(p-1))</span>. This would imply that for any <span class="math">\\lambda\\in\\mathbb{N}^{+}</span>, <span class="math">\\mathcal{D}=\\mathsf{Acc}(.)</span>, <span class="math">\\mathsf{Adv^{sr-week}_{\\mathsf{RngPf}},}_{R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)=\\Omega(nq/(p-1))</span> for any extractor <span class="math">\\mathcal{E}</span> – meaning that the bound in Theorem 4 is tight up to constant factors.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}=\\{\\mathbb{G}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}^{+}}</span> be a family of groups of prime order <span class="math">p=p(\\lambda)</span>. Let <span class="math">\\mathsf{RngPf}=\\mathsf{RngPf}[\\mathbb{G}]</span> be the interactive argument for the relation <span class="math">R^{\\prime}</span> in (10) obtained by setting <span class="math">\\gamma=0</span> in the protocol defined in Figure 7. If <span class="math">n</span> divides <span class="math">p-1</span>, we can construct a non-uniform prover <span class="math">\\mathcal{P}</span> making at most <span class="math">q+\\log n+1</span> queries to its oracle, such that for all <span class="math">\\lambda\\in\\mathbb{N}^{+}</span>, <span class="math">\\mathsf{Adv^{yrs}_{\\mathsf{RngPf}}}(\\mathcal{P},\\lambda)=(n-1)q/(p-1)</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In <span class="math">\\mathsf{SRS}_{\\mathsf{RngPf}}</span>, on receiving <span class="math">n,\\mathbf{g},\\mathbf{h},g,h,u</span> as input, the first stage of <span class="math">\\mathcal{P}</span> fixes <span class="math">v=2^{n+1}-2</span> and outputs <span class="math">\\mathsf{st}_{\\mathcal{P}}=v</span> and <span class="math">V=g^{v}</span>. The second stage of the cheating prover <span class="math">\\mathcal{P}</span> interacts with the game <span class="math">\\mathsf{SRS}_{\\mathsf{RngPf}}</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It initializes attempts <span class="math">\\leftarrow 0</span>.</li>

      <li>If attempts <span class="math">&gt;=</span> <span class="math">q</span>, it just aborts. Otherwise it increments attempts by <span class="math">1</span>.</li>

      <li>It sets <span class="math">\\mathbf{a}_{L}=2\\cdot\\mathbf{1}^{n},\\mathbf{a}_{R}=\\mathbf{1}^{n}</span>. It samples <span class="math">\\mathbf{s}_{L},\\mathbf{s}_{R}</span> uniformly at random from <span class="math">\\mathbb{Z}_{p}^{n}</span> and <span class="math">\\alpha,\\rho</span> uniformly at random from <span class="math">\\mathbb{Z}_{p}</span>. It computes <span class="math">A=h^{\\alpha},S=h^{\\rho}\\mathbf{g}^{\\mathbf{s}_{L}}\\mathbf{h}^{\\mathbf{s}_{R}}</span> and queries <span class="math">\\mathbf{O}_{\\mathrm{ext}}</span> with <span class="math">(\\varepsilon,(A,S))</span> and receives <span class="math">y,z</span>. In other words, it restores the state of the verifier to the initial state and sends <span class="math">A,S</span> as the first message and receives <span class="math">y,z</span>.</li>

      <li>It checks if <span class="math">\\sum_{i=0}^{n-1}y^{i}=0</span>. If the check succeeds, it moves to step 5. Otherwise it moves to step 2.</li>

      <li>It now behaves like the honest prover <span class="math">\\mathsf{RngPf}.\\mathsf{P}</span> till the end of the protocol. In particular, it does not attempt any more state-restorations.</li>

    </ol>

    <p class="text-gray-300">First, we claim that if <span class="math">\\mathcal{P}</span> reaches step 5, the game <span class="math">\\mathsf{SRS}_{\\mathsf{RngPf}}</span> outputs true. Since <span class="math">\\mathcal{P}</span> behaves like the honest prover after it has sent <span class="math">A,S</span> and received <span class="math">y,z</span> it is easy to see that the <span class="math">\\mathsf{InPrd}.\\mathsf{V}</span> shall return <span class="math">1</span>. We need to argue that the check <span class="math">R=g^{\\hat{t}}h^{\\tau}</span> succeeds. Since <span class="math">\\mathcal{P}</span> behaves like an honest prover after receiving <span class="math">y,z</span>, we have that</p>

    <p class="text-gray-300"><span class="math">\\hat{t}=t(x)=\\langle l(x),r(x)\\rangle=t_{0}+t_{1}x+t_{2}x^{2}\\;.</span></p>

    <p class="text-gray-300">This would give us</p>

    <p class="text-gray-300"><span class="math">t_{0}=\\langle\\mathbf{a}_{L}-z\\cdot\\mathbf{1}^{n},\\mathbf{y}^{n}\\circ(\\mathbf{a}_{R}+z\\cdot\\mathbf{1}^{n})+z^{2}\\cdot\\mathbf{2}^{n}\\rangle</span></p>

    <p class="text-gray-300">Further, <span class="math">\\beta_{x}=\\beta_{1}x+\\beta_{2}x^{2}</span>, <span class="math">R=V^{z^{2}}g^{\\delta(y,z)}T_{1}^{x}T_{2}^{x^{2}}=g^{z^{2}v+t_{1}x+t_{2}x^{2}+\\delta(y,z)}h^{\\beta_{1}x+\\beta_{2}x^{2}}</span>. Now since <span class="math">\\hat{t}=t_{0}+t_{1}x+t_{2}x^{2}</span> we have</p>

    <p class="text-gray-300">\\[ (z^{2}v+t_{1}x+t_{2}x^{2}+\\delta(y,z))-\\hat{t}=z^{2}v+\\delta(y,z)-t_{0}=z^{2}(v-\\langle\\mathbf{a}_{L},\\mathbf{2}^{n}\\rangle)\\\\ -z\\langle\\mathbf{a}_{L}-\\mathbf{a}_{R}-\\mathbf{1}^{n},\\mathbf{y}^{n}\\rangle-\\langle\\mathbf{a}_{L}\\circ\\mathbf{a}_{R},\\mathbf{y}^{n}\\rangle\\;. \\]</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{P}</span> had set <span class="math">v=2^{n+1}-2,\\mathbf{a}_{L}=2\\cdot\\mathbf{1}^{n},\\mathbf{a}_{R}=\\mathbf{1}^{n}</span> we have</p>

    <p class="text-gray-300"><span class="math">(z^{2}v+t_{1}x+t_{2}x^{2}+\\delta(y,z))-\\hat{t}=-2\\sum_{i=0}^{n-1}y^{i}=0\\;.</span></p>

    <p class="text-gray-300">Therefore</p>

    <p class="text-gray-300"><span class="math">R=g^{z^{2}v+t_{1}x+t_{2}x^{2}+\\delta(y,z)}h^{\\beta_{1}x+\\beta_{2}x^{2}}=g^{\\hat{t}}h^{\\beta_{x}}\\;.</span></p>

    <p class="text-gray-300">Hence, if <span class="math">\\mathcal{P}</span> reaches step 5, the game <span class="math">\\mathsf{SRS}_{\\mathsf{RngPf}}</span> outputs true. We need to compute the probability that <span class="math">\\sum_{i=0}^{n-1}y^{i}=0</span> for a random <span class="math">y</span> in <span class="math">\\mathbb{Z}_{p}^{*}</span>. First, we observe that</p>

    <p class="text-gray-300"><span class="math">(y-1)\\sum_{i=0}^{n-1}y^{i}=0=y^{n}-1\\;.</span></p>

    <p class="text-gray-300">Now, if <span class="math">n</span> divides <span class="math">p-1</span>, we claim that there are <span class="math">n</span> distinct <span class="math">y</span>’s in <span class="math">\\mathbb{Z}_{p}^{<em>}</span> that satisfy <span class="math">y^{n}-1=0</span>. Consider a generator <span class="math">g</span> of <span class="math">\\mathbb{Z}_{p}^{</em>}</span> (since <span class="math">p</span> is a prime, the group <span class="math">\\mathbb{Z}_{p}^{<em>}</span> is cyclic). Now <span class="math">g^{j}</span> is a root of the equation <span class="math">y^{n}-1=0</span> if <span class="math">g^{jn}-1=0</span>, i.e., if <span class="math">p-1</span> divides <span class="math">jn</span>. Since <span class="math">n</span> divides <span class="math">p-1</span>, this condition is equivalent to <span class="math">(p-1)/n</span> divides <span class="math">j</span>. So, <span class="math">g^{j}</span> is a root of the equation <span class="math">y^{n}-1=0</span> for <span class="math">j=\\{0,(p-1)/n,2(p-1)/n,\\ldots,(n-1)(p-1)/n\\}</span>. In other words <span class="math">y^{n}-1=0</span> has <span class="math">n</span> distinct roots in <span class="math">\\mathbb{Z}_{p}^{</em>}</span>. So, the equation <span class="math">\\sum_{i=0}^{n-1}y^{i}=0</span> has <span class="math">n-1</span> distinct roots because the factorization of a polynomial in a finite field is unique. Since <span class="math">y</span> is picked uniformly at random, the probability that <span class="math">\\sum_{i=0}^{n-1}y^{i}=0</span> is <span class="math">(n-1)/(p-1)</span>. Since <span class="math">\\mathcal{P}</span> tries at most <span class="math">q</span> different <span class="math">(A,S)</span>, the probability that it reaches step 5, is <span class="math">(n-1)q/(p-1)</span> – therefore <span class="math">\\mathsf{Adv}_{\\mathsf{RngPf}}^{\\mathsf{srs}}(\\mathcal{P},\\lambda)=(n-1)q/(p-1)</span>. ∎</p>

    <p class="text-gray-300">5.3 Online srs-wee Security for ACSPf</p>

    <p class="text-gray-300">In this section, we introduce ACSPf and apply our framework to prove online srs-wee security. As shown in <em>[10]</em>, any arithmetic circuit with <span class="math">n</span> multiplication gates can be represented using a constraint system that has three vectors <span class="math">\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{a}_{O}\\in\\mathbb{Z}_{p}^{n}</span> representing the left inputs, right inputs, and outputs of multiplication gates respectively, so that <span class="math">\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=\\mathbf{a}_{O}</span>, with additional <span class="math">Q\\leqslant 2n</span> linear constraints. The linear constraints can be represented as <span class="math">\\mathbf{a}_{L}\\cdot\\mathbf{W}_{L}+\\mathbf{a}_{R}\\cdot\\mathbf{W}_{R}+\\mathbf{a}_{O}\\cdot\\mathbf{W}_{O}=\\mathbf{c}</span>, where <span class="math">\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O}\\in\\mathbb{Z}_{p}^{Q\\times n}</span>.</p>

    <p class="text-gray-300">We shall assume that <span class="math">\\mathsf{ACSPf}=\\mathsf{ACSPf}[\\mathbb{G}]</span> is instantiated on an understood family of groups <span class="math">\\mathbb{G}=\\{\\mathbb{G}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}^{+}}</span> of order <span class="math">p=p(\\lambda)</span>. The argument <span class="math">\\mathsf{ACSPf}</span> is an argument of knowledge for the relation</p>

    <p class="text-gray-300"><span class="math">R=</span> <span class="math">\\Big{\\{}\\left((n,Q\\in\\mathbb{N}),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O}\\in\\mathbb{Z}_{p}^{Q\\times n},\\mathbf{c}\\in\\mathbb{Z}_{p}^{Q}),(\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{a}_{O}\\in\\mathbb{Z}_{p}^{n})\\right):</span> (11) <span class="math">\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=\\mathbf{a}_{O}\\wedge\\mathbf{W}_{L}\\cdot\\mathbf{a}_{L}+\\mathbf{W}_{R}\\cdot\\mathbf{a}_{R}+\\mathbf{W}_{O}\\cdot\\mathbf{a}_{O}=\\mathbf{c}\\Big{\\}}\\ .</span></p>

    <p class="text-gray-300">We note that in <em>[6]</em>, an argument for a more generalized relation was given of which this is a special case. We can extend our proof for the more general relation. Here, for simplicity we only consider the above relation <span class="math">R</span> that is enough for proving arithmetic circuit satisfiability.</p>

    <p class="text-gray-300">Description of ACSPf. The ACSPf.Setup procedure returns independent generators <span class="math">\\mathbf{g}\\in\\mathbb{G}^{n},\\mathbf{h}\\in\\mathbb{G}^{n},g,h,u\\in\\mathbb{G}</span> of the group <span class="math">\\mathbb{G}</span>. The instance for <span class="math">\\mathsf{ACSPf}</span> is <span class="math">\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O}\\in\\mathbb{Z}_{p}^{Q\\times n},\\mathbf{c}\\in\\mathbb{Z}_{p}^{Q}</span> such that an honest prover knows a witness <span class="math">(\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{a}_{O})</span> that satisfies <span class="math">\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=\\mathbf{a}_{O}</span> and <span class="math">\\mathbf{W}_{L}\\cdot\\mathbf{a}_{L}+\\mathbf{W}_{R}\\cdot\\mathbf{a}_{R}+\\mathbf{W}_{O}\\cdot\\mathbf{a}_{O}=\\mathbf{c}</span>.</p>

    <p class="text-gray-300">The prover and verifier for <span class="math">\\mathsf{ACSPf}</span> is shown in Figure 12. The prover commits to <span class="math">\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{a}_{O}</span> and proves to the verifier that these vectors satisfy the relation in (11). The prover and the verifier of <span class="math">\\mathsf{ACSPf}</span> engage in <span class="math">\\mathsf{InPrd}</span> in the final step to avoid the prover sending over vectors of length <span class="math">n</span>.</p>

    <p class="text-gray-300">We prove the following theorem that gives an upper bound on the advantage against online srs-wee security of <span class="math">\\mathsf{ACSPf}</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}=\\{\\mathbb{G}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}^{+}}</span> be a family of groups of order <span class="math">p=p(\\lambda)</span>. Let <span class="math">\\mathsf{ACSPf}=\\mathsf{ACSPf}[\\mathbb{G}]</span> be the interactive argument as defined in Figure 12,for the relation <span class="math">R</span> in (11). We can construct an extractor <span class="math">\\mathcal{E}</span> such that for any non-uniform algebraic prover <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> making at most <span class="math">q=q(\\lambda)</span> queries to its oracle, there exists a non-uniform adversary <span class="math">\\mathcal{F}</span> with the property that for any (computationally unbounded) distinguisher <span class="math">\\mathcal{D}</span>, for all <span class="math">\\lambda\\in\\mathbb{N}^{+}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{tr-wee}}_{\\mathsf{ACSPf},R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)\\leqslant((14n+8)q)/p-1+\\mathsf{Adv}^{\\mathsf{dl}}_{\\mathbb{G}}(\\mathcal{F},\\lambda)+1/p\\ .</span></p>

    <p class="text-gray-300">Moreover, the time complexity of the extractor <span class="math">\\mathcal{E}</span> is <span class="math">O(q\\cdot n)</span> and that of adversary <span class="math">\\mathcal{F}</span> is <span class="math">O(q\\cdot n)</span>.</p>

    <p class="text-gray-300">We can show that the bound in Theorem 6 is tight by constructing a cheating prover like we did in Theorem 5.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">Using Theorem 2, we get a corollary about fs-ext-1 security of <span class="math">\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{ACSPf}]</span>. Let <span class="math">\\mathbb{G}=\\{\\mathbb{G}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}^{+}}</span> be a family of groups of order <span class="math">p=p(\\lambda)</span>. Let <span class="math">\\mathsf{ACSPf}=\\mathsf{ACSPf}[\\mathbb{G}]</span> be the interactive argument as defined in Figure 12, for the relation <span class="math">R</span> in (11). Let <span class="math">\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{ACSPf}]</span> be the non-interactive argument obtained by applying the Fiat-Shamir transform to <span class="math">\\mathsf{ACSPf}</span> using a random oracle. We can construct an extractor <span class="math">\\mathcal{E}</span> such that for any non-uniform algebraic prover <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> making at most <span class="math">q=q(\\lambda)</span> queries to the random oracle there exists a non-uniform adversary <span class="math">\\mathcal{F}</span> with the property that for all <span class="math">\\lambda\\in\\mathbb{N}^{+}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{fs-ext-1}}_{\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{ACSPf}],R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{E},\\lambda)\\leqslant((14n+9)q+1)/(p-1)+\\mathsf{Adv}^{\\mathsf{dl}}_{\\mathbb{G}}(\\mathcal{F},\\lambda)+1/p\\ .</span></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 12. Bulletproofs argument for arithmetic circuit satisfiability ACSPf.</p>

    <p class="text-gray-300">Moreover, the time complexity of the extractor <span class="math">\\mathcal{E}</span> is <span class="math">O(q\\cdot n)</span> and that of adversary <span class="math">\\mathcal{F}</span> is <span class="math">O(q\\cdot n)</span>.</p>

    <p class="text-gray-300">Additionally, using techniques similar to those in the proof of Theorem 6, we can prove a similar bound for fs-ext-2 security of <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{ACSPf}]</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof (Theorem 6).</h6>

    <p class="text-gray-300">In order to prove this theorem, we invoke Theorem 1 by defining <span class="math">\\mathsf{BadCh}</span> and <span class="math">\\mathsf{e}</span> and showing that <span class="math">\\varepsilon\\leqslant\\frac{14n+8}{p-1}</span> and there exists an adversary <span class="math">\\mathcal{F}</span> such that <span class="math">p_{\\mathsf{fail}}(\\mathsf{ACSPf},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)\\leqslant\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(\\mathcal{F})+\\frac{1}{p}</span>.</p>

    <p class="text-gray-300">Defining <span class="math">\\mathsf{BadCh}</span> and upper bounding <span class="math">\\varepsilon</span>. To start off, we shall define <span class="math">\\mathsf{BadCh}(\\tau^{\\prime})</span> for all partial extended transcripts <span class="math">\\tau^{\\prime}</span>. Let <span class="math">\\mathsf{Ch}</span> be the set from which the challenge that comes right after <span class="math">\\tau^{\\prime}</span> is sampled. We define a helper function <span class="math">\\mathsf{CheckBad}</span> that takes as input a partial extended transcripts <span class="math">[\\tau^{\\prime}]</span> and a challenge <span class="math">c\\in\\mathsf{Ch}</span> and returns true if and only if <span class="math">c\\in\\mathsf{BadCh}(\\tau^{\\prime})</span>. For each verifier challenge in <span class="math">\\mathsf{ACSPf}</span>, there is a definition of <span class="math">\\mathsf{CheckBad}</span> in Figure 8. Every <span class="math">\\mathsf{CheckBad}</span> function defines several bad conditions that depend on <span class="math">\\tau^{\\prime}</span> – most of these bad conditions are checked using the predicate <span class="math">\\mathsf{SZ}</span> (as defined before). One can safely ignore the details of the definitions of <span class="math">\\mathsf{CheckBad}</span> functions for now – the rationale behind their definitions shall become apparent later on.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we need to compute an upper bound <span class="math">\\varepsilon</span> on the size of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. To this end, we compute an upper bound on the maximum fraction of </span>c<span class="math">’s in </span>\\mathsf{Ch}<span class="math"> for which </span>\\mathsf{CheckBad}(\\tau^{\\prime},c)<span class="math"> will return true, for all the definitions of </span>\\mathsf{CheckBad}$, using the Schwartz-Zippel Lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},(y,z))</span> returns true if <span class="math">\\mathsf{SZ}(f(Y,Z),(y,z))</span> is true. The polynomial <span class="math">f(Y,Z)</span> is a polynomial of degree at most <span class="math">n+1</span>. So, the fraction of <span class="math">y,z</span> for which <span class="math">\\mathsf{SZ}(f(Y,Z),(y,z))</span> is true is at most <span class="math">(n+1)/(p-1)</span>. So the the fraction of <span class="math">y,z</span> in <span class="math">\\mathbb{Z}_{p}^{*}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},(y,z))</span> returns true is at most <span class="math">(n+1)/(p-1)</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},x)</span> returns true if at least one of <span class="math">\\mathsf{SZ}(f_{i}(X),x)</span> is true for <span class="math">i\\in[4]</span>. Since <span class="math">f_{1}(X)</span> and <span class="math">f_{2}(X)</span> are vector of <span class="math">n</span> polynomials, each polynomial of degree <span class="math">6</span>, using the union bound the fraction of <span class="math">x</span>’s in <span class="math">\\mathbb{Z}_{p}^{<em>}</span> for which <span class="math">\\mathsf{SZ}(f_{1}(X),x)</span> or <span class="math">\\mathsf{SZ}(f_{2}(X),x)</span> is true is at most <span class="math">12n/(p-1)</span>. The polynomial <span class="math">f_{3}(X)</span> is a polynomial of degree at most <span class="math">6</span>. The fraction of <span class="math">x</span>’s in <span class="math">\\mathbb{Z}_{p}^{</em>}</span> for which <span class="math">\\mathsf{SZ}(f_{3}(X),x)</span> is true is at most <span class="math">6/(p-1)</span>. The polynomial <span class="math">f_{4}(X)</span> is a polynomial of degree at most <span class="math">4</span>. The fraction of <span class="math">x</span>’s for which <span class="math">\\mathsf{SZ}(f_{4}(X),x)</span> is true is at most <span class="math">4/(p-1)</span>. Using the union bound, the fraction of <span class="math">x</span>’s in <span class="math">\\mathbb{Z}_{p}^{*}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},x)</span> returns true is at most <span class="math">(12n+10)/((p-1))</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},w)</span> returns true if <span class="math">\\mathsf{SZ}(f(W),w)</span> is true. The polynomial <span class="math">f(W)</span> is a polynomial of degree <span class="math">1</span>, hence using the Schwartz-Zippel Lemma the fraction of <span class="math">w</span>’s in <span class="math">\\mathbb{Z}_{p}^{*}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},w)</span> returns true is at most <span class="math">1/(p-1)</span>.</p>

    <p class="text-gray-300">The function <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},x_{m})</span> for <span class="math">m\\in\\{1,\\ldots,\\log n\\}</span> returns true if and only if <span class="math">\\mathsf{SZ}</span> is true for any of the <span class="math">\\sum_{t=1}^{m-1}2n/2^{t}</span> polynomials of degree at most <span class="math">4</span>, <span class="math">2n/2^{m}</span> polynomials of degree at most <span class="math">6</span> and one polynomial of degree at most <span class="math">8</span>. Using Schwartz Zippel Lemma and the union bound the fraction of <span class="math">x_{m}</span>’s in <span class="math">\\mathbb{Z}_{p}^{*}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},x_{m})</span> is true is at most</p>

    <p class="text-gray-300"><span class="math">\\frac{8}{p-1}\\left(\\sum_{t=1}^{m-1}\\frac{n}{2^{t}}\\right)+\\frac{12n}{2^{m}(p-1)}+\\frac{8}{p-1}\\ .</span></p>

    <p class="text-gray-300">This fraction is at most <span class="math">(14n+8)/(p-1)</span> for <span class="math">m\\in\\{1,\\ldots,\\log n\\}</span>. Therefore the fraction of <span class="math">c</span>’s in <span class="math">\\mathsf{Ch}</span> for which <span class="math">\\mathsf{CheckBad}(\\tau^{\\prime},c)</span> will return true for any partial transcript <span class="math">\\tau^{\\prime}</span> is upper bounded by <span class="math">(14n+8)/(p-1)</span>, i.e., in the context of Theorem 1, <span class="math">\\varepsilon\\leqslant\\frac{14n+8}{p-1}</span>.</p>

    <p class="text-gray-300">Defining <span class="math">\\mathsf{e}</span> and proving an upper bound on <span class="math">p_{\\mathsf{fail}}(\\mathsf{ACSPf},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)</span>. The function <span class="math">\\mathsf{e}</span> simply outputs <span class="math">(a_{I\\mathsf{g}},a_{I\\mathsf{h}},a_{O\\mathsf{g}})</span> and outputs them. It follows from the description of <span class="math">\\mathsf{e}</span> that it runs in time</p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">\\left[\\left[\\tau^{\\prime}\\right],(y,z)\\right)</span>  ..  <span class="math">/ / \\left[\\tau^{\\prime}\\right] = \\left((n,Q,\\mathbf{g},\\mathbf{h},u,g,h),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O},\\mathbf{c});([A_{I}],[A_{O}],[S])\\right)</span> <span class="math">f(Y,Z)\\gets \\langle \\mathbf{Z}_{[1:]}^Q +1,\\mathbf{c} - \\mathbf{W}_L\\cdot a_{I\\mathbf{g}} - \\mathbf{W}_R\\cdot a_{I\\mathbf{h}} - \\mathbf{W}_O\\cdot a_{O\\mathbf{g}}\\rangle -\\langle a_{I\\mathbf{g}}\\circ a_{I\\mathbf{h}} - a_{O\\mathbf{g}},\\mathbf{Y}^n\\rangle</span>  Return SZ(f(Y,Z),(y,z))</p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">\\left[\\left[\\tau^{\\prime}\\right],x\\right)</span>  ..  <span class="math">/ / \\left[\\tau^{\\prime}\\right] = \\left((n,Q,\\mathbf{g},\\mathbf{h},u,g,h),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O},\\mathbf{c});([A_{I}],[A_{O}],[S]),(y,z),([T_{1}],[T_{3}],[T_{4}],[T_{5}],[T_{6}])\\right)</span> <span class="math">f_{1}(X)\\gets t_{1\\mathbf{g}}X + \\sum_{i = 3}^{6}t_{i\\mathbf{g}}X^{i};f_{2}(X)\\gets t_{1\\mathbf{h}}X + \\sum_{i = 3}^{6}t_{i\\mathbf{h}}X^{i};f_{3}(X)\\gets t_{1u}X + \\sum_{i = 3}^{6}t_{iu}X^{i}</span> <span class="math">l(X)\\gets a_{I\\mathbf{g}}\\cdot X + a_{O\\mathbf{g}}\\cdot X^2 +\\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_R)\\cdot X + s_{\\mathbf{h}}\\cdot X^3;r(X)\\gets \\mathbf{y}^n\\circ a_{I\\mathbf{h}}\\cdot X - \\mathbf{y}^n +\\mathbf{z}_{[1:]}^Q +1\\cdot (\\mathbf{W}_L\\cdot X + \\mathbf{W}_O) + \\mathbf{y}^n\\circ s_{\\mathbf{h}}</span> <span class="math">\\delta (y,z)\\gets \\langle \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_R),\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_L\\rangle ;f_4(X)\\gets X^2 (\\delta (y,z) + \\langle \\mathbf{z}_{[1:]}^Q +1,\\mathbf{c}\\rangle) + t_{1g}X + \\sum_{i = 1}^{3}t_{ig}X^{i} - \\langle l(X),r(X)\\rangle</span>  Return SZ(f1(X),x)  <span class="math">\\vee</span>  SZ(f2(X),x)  <span class="math">\\vee</span>  SZ(f3(X),x)  <span class="math">\\vee</span>  SZ(f4(X),x)</p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">\\left[\\left[\\tau^{\\prime}\\right],w\\right)</span>  ..  <span class="math">/ / \\left[\\tau^{\\prime}\\right] = \\left((n,Q,\\mathbf{g},\\mathbf{h},u,g,h),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O},\\mathbf{c});([A_{I}],[A_{O}],[S]),(y,z),([T_{1}],[T_{3}],[T_{4}],[T_{5}],[T_{6}]),x,(\\beta_{x},\\mu ,\\hat{t})\\right)</span> <span class="math">\\mathbf{l}\\gets a_{I\\mathbf{g}}\\cdot x + a_{O\\mathbf{g}}\\cdot x^{2} + \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_R)\\cdot x + s_{\\mathbf{h}}\\cdot x^3</span> <span class="math">\\mathbf{r}\\gets \\mathbf{y}^n\\circ a_{I\\mathbf{h}}\\cdot x - \\mathbf{y}^n +\\mathbf{z}_{[1:]}^Q +1\\cdot (\\mathbf{W}_L\\cdot x + \\mathbf{W}_O) + \\mathbf{y}^n\\circ s_{\\mathbf{h}};f(W)\\gets W\\hat{t} -W\\langle \\mathbf{l},\\mathbf{r}\\rangle</span>  Return SZ(f(W),w)</p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">\\left[\\left[\\tau^{\\prime}\\right],x_{m}\\right)</span>  ..  <span class="math">/ / \\left[\\tau^{\\prime}\\right] = \\left((n,Q,\\mathbf{g},\\mathbf{h},u,g,h),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O},\\mathbf{c});([A_{I}],[A_{O}],[S]),(y,z),([T_{1}],[T_{3}],[T_{4}],[T_{5}],[T_{6}]),x,(\\beta_{x},\\mu ,\\hat{t}),w,</span> <span class="math">([L_1],[R_1]),x_1,\\ldots ,([L_m],[R_m]))</span> <span class="math">p_{\\mathbf{g}}^{\\prime}\\gets a_{I\\mathbf{g}}\\cdot x + a_{O\\mathbf{g}}\\cdot x^{2} + \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_R)\\cdot x + s_{\\mathbf{g}}\\cdot x^3;p_u&#x27;\\gets a_{Iu}\\cdot x + a_{Iu}\\cdot x^2 +s_u\\cdot x^3 +w\\hat{t}</span> <span class="math">p_{\\mathbf{h}}^{\\prime}\\gets a_{I\\mathbf{h}}\\cdot x + a_{O\\mathbf{h}}\\cdot x^{2} - \\mathbf{1}^{n} + \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_L)\\cdot x + \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_O) + s_{\\mathbf{g}}\\cdot x^3</span>  For  <span class="math">j = 0,\\dots ,n - 1</span>  do  <span class="math">f_{m,j}^{\\mathbf{g}}(X)\\gets l_{mg_{1 + j}} + X^{2} + r_{mg_{1 + j}}X^{-2} + p_{g_{1 + j}}^{\\prime} + \\sum_{i = 1}^{m - 1}(l_{ig_{1 + j}}x_i^2 +r_{ig_{1 + j}}x_i^{-2})</span> <span class="math">f_{m,j}^{\\mathbf{h}}(X)\\gets l_{mh_{1 + j}}X^{2} + r_{mh_{1 + j}}X^{-2} + p_{h_{1 + j}}^{\\prime} + \\sum_{i = 1}^{m - 1}(l_{ih_{1 + j}}x_i^2 +r_{ih_{1 + j}}x_i^{-2})</span> <span class="math">f_{m}^{u}(X)\\gets l_{mu}X^{2} + r_{mu}X^{-2} + p_{u}^{\\prime} + \\sum_{i = 1}^{m - 1}(l_{iu}x_i^2 +r_{iu}x_i^{-2})</span>  flag  <span class="math">\\leftarrow</span>  false For  <span class="math">t = 1,\\dots ,m - 1</span>  do For  <span class="math">j = 0,\\dots ,n / 2^{t} - 1</span>  do flag  <span class="math">\\leftarrow</span>  flag  <span class="math">\\vee</span>  SZ(fgM,j(X)·x2-fgM,j+n/2t(X),xm)  <span class="math">\\vee</span>  SZ(fhM,j(X)-fhM,j+n/2t(X)·x2,t,xm) For  <span class="math">j = 0,\\dots ,n / 2^{m} - 1</span>  do flag  <span class="math">\\leftarrow</span>  flag  <span class="math">\\vee</span>  SZ(fgM,j(X)·X2-fgM,j+n/2m(X),xm)  <span class="math">\\vee</span>  SZ(fhM,j(X)-fhM,j+n/2m(X)·X2,xm) flag  <span class="math">\\leftarrow</span>  flag  <span class="math">\\vee</span>  SZ(fuM,j(X)-w·n/2m-1fgM,j(X)·fhM,j(X)·yj,xm) Return flag</p>

    <p class="text-gray-300">Fig. 13. The function CheckBad function for the ACSPf.</p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathsf{e}([\\tau])</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} / / [ \\tau ] = ((n, Q, \\mathbf {g}, \\mathbf {h}, u, g, h), (\\mathbf {W} _ {L}, \\mathbf {W} _ {R}, \\mathbf {W} _ {O}, \\mathbf {c}); ([ A ], [ S ]), (y, z), ([ T _ {1} ], [ T _ {3} ], [ T _ {4} ], [ T _ {5} ], [ T _ {6} ]), x, (\\beta_ {x}, \\mu , \\hat {t}), w, \\\\ \\left(\\left[ L _ {1} \\right], \\left[ R _ {1} \\right]\\right), x _ {1}, \\dots , \\left(\\left[ L _ {\\log n} \\right], \\left[ R _ {\\log n} \\right]\\right), x _ {\\log n}, (a, b)) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Return  <span class="math">(a_{I\\mathbf{g}},a_{I\\mathbf{h}},a_{O\\mathbf{g}})</span></p>

    <p class="text-gray-300">Fig. 14. The function e for ACSPf.</p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathsf{h}([\\tau])</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} / / [ \\tau ] = ((n, Q, \\mathbf {g}, \\mathbf {h}, u, g, h), (\\mathbf {W} _ {L}, \\mathbf {W} _ {R}, \\mathbf {W} _ {O}, \\mathbf {c}); ([ A ], [ S ]), (y, z), ([ T _ {1} ], [ T _ {3} ], [ T _ {4} ], [ T _ {5} ], [ T _ {6} ]), x, (\\beta_ {x}, \\mu , \\hat {t}), w, \\\\ \\left(\\left[ L _ {1} \\right], \\left[ R _ {1} \\right]\\right), x _ {1}, \\dots , \\left(\\left[ L _ {\\log n} \\right], \\left[ R _ {\\log n} \\right]\\right), x _ {\\log n}, (a, b)) \\\\ \\delta (y, z) \\leftarrow \\langle \\mathbf {y} ^ {- n} \\circ (\\mathbf {z} _ {[ 1: ]} ^ {Q + 1} \\cdot \\mathbf {W} _ {R}), \\mathbf {z} _ {[ 1: ]} ^ {Q + 1} \\cdot \\mathbf {W} _ {L} \\rangle ; e _ {\\mathbf {g}} ^ {(1)} \\leftarrow t _ {1 \\mathbf {g}} x + \\sum_ {i = 3} ^ {6} t _ {i \\mathbf {g}} x ^ {i}; e _ {\\mathbf {h}} ^ {(1)} \\leftarrow t _ {1 \\mathbf {h}} x + \\sum_ {i = 3} ^ {6} t _ {i \\mathbf {h}} x ^ {i}; e _ {u} ^ {(1)} \\leftarrow t _ {1 u} x + \\sum_ {i = 3} ^ {6} t _ {i u} x ^ {i} \\\\ e _ {g} ^ {(1)} \\leftarrow x ^ {2} \\left(\\delta (y, z) + \\langle \\mathbf {z} _ {[ 1: ]} ^ {Q + 1}, \\mathbf {c} \\rangle\\right) + t _ {1 g} x + \\sum_ {i = 3} ^ {6} t _ {i g} x ^ {i} - \\hat {t}; e _ {h} ^ {(1)} \\leftarrow t _ {1 h} x + \\sum_ {i = 3} ^ {6} t _ {i h} x ^ {i} - \\beta_ {x} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If  <span class="math">(e_{\\mathbf{g}}^{(1)}, e_{\\mathbf{h}}^{(1)}, e_{u}^{(1)}, e_{g}^{(1)}, e_{h}^{(1)}) \\neq (\\mathbf{0}^{n}, \\mathbf{0}^{n}, 0, 0, 0)</span>  then</p>

    <p class="text-gray-300">Return  <span class="math">(e_{\\mathbf{g}}^{(1)}, e_{\\mathbf{h}}^{(1)}, e_{u}^{(1)}, e_{g}^{(1)}, e_{h}^{(1)})</span></p>

    <p class="text-gray-300"><span class="math">p_{\\mathbf{g}}^{\\prime}\\gets a_{I\\mathbf{g}}\\cdot x + a_{O\\mathbf{g}}\\cdot x^{2} + \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_R)\\cdot x + s_{\\mathbf{g}}\\cdot x^3</span></p>

    <p class="text-gray-300"><span class="math">p_{\\mathbf{h}}^{\\prime}\\gets a_{I\\mathbf{h}}\\cdot x + a_{O\\mathbf{h}}\\cdot x^{2} - \\mathbf{1}^{n} + \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_L)\\cdot x + \\mathbf{y}^{-n}\\circ (\\mathbf{z}_{[1:]}^Q +1\\cdot \\mathbf{W}_O) + s_{\\mathbf{g}}\\cdot x^3</span></p>

    <p class="text-gray-300"><span class="math">p_{g}^{\\prime}\\gets a_{Ig}\\cdot x + a_{Ig}\\cdot x^{2} + s_{g}\\cdot x^{3};p_{h}^{\\prime}\\gets a_{Ih}\\cdot x + a_{Ih}\\cdot x^{2} + s_{h}\\cdot x^{3} - \\mu ;p_{u}^{\\prime}\\gets a_{Iu}\\cdot x + a_{Ju}\\cdot x^{2} + s_{u}\\cdot x^{3} + w\\hat{t};p_{V}^{\\prime}\\gets a_{V} + xs_{V}</span></p>

    <p class="text-gray-300">For  <span class="math">k = 0</span>  to  <span class="math">n - 1</span>  do</p>

    <p class="text-gray-300"><span class="math">e_{g_{k + 1}}^{(2)}\\gets \\left(\\sum_{i = 1}^{\\log n}(l_{ig_{1 + k}}x_i^2 +r_{ig_{1 + k}}x_i^{-2}) + p_{g_{1 + k}}&#x27;\\right) - a\\cdot \\left(\\prod_{i = 1}^{\\log n}x_i^{(-1)^{1 - b\\aleph (k,i,\\log n)}}\\right)</span></p>

    <p class="text-gray-300"><span class="math">e_{h_{k + 1}}^{(2)}\\gets \\left(\\sum_{i = 1}^{\\log n}(l_{ih_{1 + k}}x_i^2 +r_{ih_{1 + k}}x_i^{-2}) + p_{h_{1 + k}}&#x27;\\right) - by^{(-k)})\\cdot \\left(\\prod_{i = 1}^{\\log n}x_i^{(-1)^{b\\aleph (k,i,\\tau)}}\\right)</span></p>

    <p class="text-gray-300"><span class="math">e_{\\mathbf{g}}^{(2)}\\gets (e_{g_1}^{(2)},\\ldots ,e_{g_n}^{(2)});e_{\\mathbf{h}}^{(2)}\\gets (e_{h_1}^{(2)},\\ldots ,e_{h_n}^{(2)})</span></p>

    <p class="text-gray-300"><span class="math">e_{u}^{(2)}\\gets \\left(\\sum_{i = 1}^{\\log n}(l_{iu}x_{i}^{2} + r_{iu}x_{i}^{-2}) + p_{u}^{\\prime}\\right) - w\\cdot ab;e_{g}^{(2)}\\gets \\left(\\sum_{i = 1}^{\\log n}l_{ig}x_{i}^{2} + r_{ig}x_{i}^{-2}\\right) + p_{g}^{\\prime};e_{h}^{(2)}\\gets \\left(\\sum_{i = 1}^{\\log n}l_{ih}x_{i}^{2} + r_{ih}x_{i}^{-2}\\right) + p_{h}^{\\prime}</span></p>

    <p class="text-gray-300">Return  <span class="math">(e_{\\mathbf{g}}^{(2)}, e_{\\mathbf{h}}^{(2)}, e_{u}^{(2)}, e_{g}^{(2)}, e_{h}^{(2)})</span></p>

    <p class="text-gray-300">Fig. 15. The function  <span class="math">h</span>  for ACSPf.</p>

    <p class="text-gray-300"><span class="math">O(n)</span> . Note that ACSPf.V runs in time  <span class="math">O(n)</span> . Therefore, using Theorem 1, the time complexity of  <span class="math">\\mathcal{E}</span>  is  <span class="math">O(q\\cdot n)</span> .</p>

    <p class="text-gray-300">In order to complete our proof we need to upper bound  <span class="math">p_{\\mathrm{fail}}(\\mathrm{ACSPf}, \\mathcal{P}_{\\mathrm{alg}}, \\mathsf{e}, R, \\lambda)</span> . To do so we shall construct an adversary  <span class="math">\\mathcal{H}</span>  (that runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> ) against that takes as input independent generators  <span class="math">\\mathbf{g}, \\mathbf{h}, g, h, u</span>  of the group  <span class="math">\\mathbb{G}</span>  and finds a non-trivial discrete logarithm relation between them, i.e., computes  <span class="math">(e_{\\mathbf{g}}, e_{\\mathbf{h}}, e_g, e_h, e_u) \\neq (\\mathbf{0}^n, \\mathbf{0}^n, 0, 0, 0)</span>  such that  <span class="math">\\mathbf{g}^{e_{\\mathbf{g}}} \\mathbf{h}^{e_{\\mathbf{h}}} g^{e_g} h^{e_h} u^{e_u} = 1</span> . Then we shall invoke Lemma 2 to transform  <span class="math">\\mathcal{H}</span>  into an  <span class="math">\\mathcal{F}</span>  against the discrete logarithm problem.</p>

    <p class="text-gray-300">The adversary  <span class="math">\\mathcal{H}</span>  has inputs  <span class="math">\\mathbf{g},\\mathbf{h},g,h,u</span> , it chooses  <span class="math">Q\\leqslant 2n</span>  and runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  on public parameters  <span class="math">n,Q,\\mathbf{g},\\mathbf{h},g,h,u</span>  and simulates the game  <span class="math">\\mathsf{SRS}_{\\mathsf{ACSPf}}</span>  to it. If  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  manages to produce an accepting transcript  <span class="math">\\tau</span> ,  <span class="math">\\mathcal{H}</span>  calls a helper function  <span class="math">\\mathsf{h}</span>  on input  <span class="math">[\\tau]</span>  and outputs whatever  <span class="math">\\mathsf{h}</span>  outputs.</p>

    <p class="text-gray-300">DEFINING h. The function h is defined in Figure 15. It follows from the description of h that it runs time at most  <span class="math">O(n)</span> . The running time of  <span class="math">\\mathcal{H}</span>  consists of the time required to answer  <span class="math">q</span>  queries, run ACSPf.V in at most  <span class="math">q</span>  paths in the execution tree and the time required to run h. Hence its time complexity is  <span class="math">O(q \\cdot n)</span> . Using Lemma 2, time complexity of  <span class="math">\\mathcal{F}</span>  is  <span class="math">O(q \\cdot n)</span> .</p>

    <p class="text-gray-300">We shall next discuss the rationale behind the definition of h. Let <span class="math">\\tau</span> be a transcript of ACSPf as shown below.</p>

    <p class="text-gray-300"><span class="math">\\tau=</span> <span class="math">\\big{(}(n,Q,\\mathbf{g},\\mathbf{h},u,g,h),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O},\\mathbf{c});(A_{I},A_{O},S),(y,z),(T_{1},T_{3},T_{4},T_{5},T_{6}),x,(\\beta_{x},\\mu,\\hat{t}),w,</span> <span class="math">(L_{1},R_{1}),x_{1},(L_{2},R_{2}),x_{2},\\ldots,(L_{\\log n},R_{\\log n}),x_{\\log n},(a,b)\\big{)}\\ .</span></p>

    <p class="text-gray-300">The following equality must hold if <span class="math">\\tau</span> is an accepting transcript.</p>

    <p class="text-gray-300"><span class="math">g^{\\hat{t}}h^{\\beta_{x}}=g^{x^{2}(\\delta(y,z)+\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{c}\\rangle)}T_{1}^{x}\\cdot\\prod_{i=3}^{6}T_{i}^{x^{i}}\\ .</span></p>

    <p class="text-gray-300">Writing out <span class="math">T_{1},T_{3},T_{4},T_{5},T_{6}</span> in terms of their representations and rearranging we shall get that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}^{c_{\\mathbf{g}}^{(1)}}\\mathbf{h}^{c_{\\mathbf{h}}^{(1)}}g^{c_{g}^{(1)}}h^{c_{h}^{(1)}}u^{c_{u}^{(1)}}=1\\ ,</span></p>

    <p class="text-gray-300">where <span class="math">e_{\\mathbf{g}}^{(1)},e_{\\mathbf{h}}^{(1)},e_{g}^{(1)},e_{h}^{(1)},e_{u}^{(1)}</span> are as defined in h. Again since <span class="math">\\tau</span> is an accepting transcript the inner product verifier must have returned <span class="math">1</span> and hence the following equality must hold.</p>

    <p class="text-gray-300"><span class="math">P^{(\\log n)}=(\\mathbf{g}^{(\\log n)})^{a}(\\mathbf{h}^{(\\log n)})^{b}u^{ab}\\ .</span></p>

    <p class="text-gray-300">Now we can write the left hand side of the above equality as</p>

    <p class="text-gray-300"><span class="math">\\left(\\prod_{i=1}^{\\log n}L_{i}^{x_{i}^{2}}\\right)h^{-\\mu}A_{I}^{x}\\cdot A_{O}^{x^{2}}\\cdot\\mathbf{h}^{-\\mathbf{1}^{n}}\\cdot(\\mathbf{h}^{\\mathbf{y}^{-n}})^{\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L}}^{x}\\cdot\\mathbf{g}^{\\mathbf{y}^{-n}\\diamond(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R})^{x}}</span> <span class="math">\\cdot(\\mathbf{h}^{\\mathbf{y}^{-n}})^{\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{O}}\\cdot S^{x^{3}}\\cdot(u^{w})^{\\hat{t}}\\cdot\\left(\\prod_{i=1}^{\\log n}R_{i}^{x_{i}^{-2}}\\right)\\ .</span></p>

    <p class="text-gray-300">Let the function <span class="math">\\mathsf{bit}(k,i,t)</span> return the bit <span class="math">k_{i}</span> where <span class="math">(k_{1},\\ldots,k_{t})</span> is the <span class="math">t</span>-bit representation of <span class="math">k</span>. Then we can write</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}^{(\\log n)}=\\prod_{k=0}^{n-1}g_{1+k}^{\\log n}x_{1}^{(-1)^{1-\\mathsf{bit}(k,i,\\log n)}}\\ ,</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{h}^{(\\log n)}=\\prod_{k=0}^{n-1}h_{1+k}^{y^{(-1+k)}\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{\\mathsf{bit}(k,i,\\log n)}}}\\ .</span></p>

    <p class="text-gray-300">Plugging these into the inequality and rearranging we shall get that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}^{c_{\\mathbf{g}}^{(2)}}\\mathbf{h}^{c_{\\mathbf{h}}^{(2)}}g^{c_{g}^{(2)}}h^{c_{h}^{(2)}}u^{c_{u}^{(2)}}=1\\ ,</span></p>

    <p class="text-gray-300">where <span class="math">e_{\\mathbf{g}}^{(2)},e_{\\mathbf{h}}^{(2)},e_{g}^{(2)},e_{h}^{(2)},e_{u}^{(2)}</span> are as defined in h.</p>

    <p class="text-gray-300">Therefore, h always returns a valid discrete logarithm relation when it gets an accepting transcript as input.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{h},\\mathsf{e}</span>. In order to complete the proof of Theorem 6, in the following lemma we show that – on an accepting transcript <span class="math">\\tau</span> such that <span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{ACSPf}}</span> if <span class="math">\\mathsf{h}([\\tau])</span> returns a trivial discrete logarithm relation, then <span class="math">\\mathsf{e}([\\tau])</span> returns a valid witness.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">Let <span class="math">\\tau</span>, as shown in (12), be an accepting transcript of <span class="math">\\mathsf{ACSPf}</span> such that <span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{ACSPf}}</span>. If <span class="math">\\mathsf{h}([\\tau])</span> returns <span class="math">(\\mathbf{0}^{n},\\mathbf{0}^{n},0,0,0)</span> then <span class="math">\\mathsf{e}([\\tau])</span> returns <span class="math">(\\mathbf{a}_{L}^{<em>},\\mathbf{a}_{R}^{</em>},\\mathbf{a}_{O}^{*})</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{L}^{<em>}\\circ\\mathbf{a}_{R}^{</em>}=\\mathbf{a}_{O}^{<em>}\\text{ and }\\mathbf{W}_{L}\\cdot\\mathbf{a}_{L}^{</em>}+\\mathbf{W}_{R}\\cdot\\mathbf{a}_{R}^{<em>}+\\mathbf{W}_{O}\\cdot\\mathbf{a}_{O}^{</em>}=\\mathbf{c}\\ .</span></p>

    <p class="text-gray-300">Taking the contrapositive, we have that whenever <span class="math">\\mathsf{e}([\\tau])</span> fails to extract a valid witness for an accepting transcript <span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{ACSPf}}</span>, <span class="math">\\mathsf{h}([\\tau])</span> outputs a non-trivial discrete logarithm relation, i.e., <span class="math">\\mathcal{H}</span> succeeds. So we have that</p>

    <p class="text-gray-300"><span class="math">p_{\\mathsf{fail}}(\\mathsf{ACSPf},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)\\leqslant\\mathsf{Adv}_{\\mathsf{G},2n+3}^{\\mathsf{dl-rel}}(\\mathcal{H})</span></p>

    <p class="text-gray-300">Using Lemma 2 we would have that there exists an adversary <span class="math">\\mathcal{F}</span> such that</p>

    <p class="text-gray-300"><span class="math">p_{\\mathsf{fail}}(\\mathsf{ACSPf},\\mathcal{P}_{\\mathsf{alg}},\\mathsf{e},R,\\lambda)\\leqslant\\mathsf{Adv}_{\\mathsf{G}}^{\\mathsf{dl}}(\\mathcal{F})+\\frac{1}{p}\\ .</span></p>

    <p class="text-gray-300">Moreover, <span class="math">\\mathcal{F}</span> is nearly as efficient as <span class="math">\\mathcal{H}</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We next prove Lemma 9.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof (Lemma 9).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For simplicity let us represent using $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{c}<span class="math"> the prefix of </span>\\tau<span class="math"> just before the challenge </span>c$. For example</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(y,z)}=\\big{(}(n,Q,\\mathbf{g},\\mathbf{h},u,g,h),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O},\\mathbf{c}),(A_{I},A_{O},S)\\big{)}\\ .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since <span class="math">\\mathsf{h}([\\tau])</span> returns <span class="math">(\\mathbf{0}^{n},\\mathbf{0}^{n},0,0,0)</span>, we have that for <span class="math">i=1,2</span></p>

    <p class="text-gray-300"><span class="math">(e_{\\mathbf{g}}^{(i)},e_{\\mathbf{h}}^{(i)},e_{g}^{(i)},e_{h}^{(i)},e_{u}^{(i)})=(\\mathbf{0}^{n},\\mathbf{0}^{n},0,0,0)\\ .</span></p>

    <p class="text-gray-300">Since <span class="math">e_{g}^{(1)}=0</span> we have that <span class="math">x^{2}(\\delta(y,z)+\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{c}\\rangle)+t_{1g}x+\\sum\\limits_{i=3}^{6}t_{ig}x^{i}-\\hat{t}=0</span>. Hence</p>

    <p class="text-gray-300"><span class="math">\\hat{t}=x^{2}(\\delta(y,z)+\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{c}\\rangle)+t_{1g}x+\\sum\\limits_{i=3}^{6}t_{ig}x^{i}\\ .</span> (13)</p>

    <p class="text-gray-300">We define <span class="math">p_{\\mathbf{g}}^{\\prime},p_{\\mathbf{h}}^{\\prime},p_{u}^{\\prime}</span> as defined in <span class="math">\\mathsf{h}</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">p_{\\mathbf{g}}^{\\prime}</span> <span class="math">=a_{I\\mathbf{g}}\\cdot x+a_{O\\mathbf{g}}\\cdot x^{2}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R})\\cdot x+s_{\\mathbf{g}}\\cdot x^{3}\\ ,</span> <span class="math">p_{\\mathbf{h}}^{\\prime}</span> <span class="math">=a_{I\\mathbf{h}}\\cdot x+a_{O\\mathbf{h}}\\cdot x^{2}-\\mathbf{1}^{n}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L})\\cdot x+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{O})+s_{\\mathbf{g}}\\cdot x^{3}\\ ,</span> <span class="math">p_{u}^{\\prime}</span> <span class="math">=a_{Iu}\\cdot x+a_{Iu}\\cdot x^{2}+s_{u}\\cdot x^{3}+w\\hat{t}\\ .</span></p>

    <p class="text-gray-300">Since <span class="math">e_{\\mathbf{g}}^{(2)}=\\mathbf{0}^{n}</span>, we have that for all <span class="math">k\\in\\{0,\\ldots,n-1\\}</span></p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\sum\\limits_{i=1}^{\\log n}(l_{ig_{1+k}}x_{i}^{2}+r_{ig_{1+k}}x_{i}^{-2})+p_{g_{1+k}}^{\\prime}\\Big{)}-a\\cdot\\left(\\prod\\limits_{i=1}^{\\log n}x_{i}^{(-1)^{1-\\text{bit}(k,i,\\log n)}}\\right)=0\\ .</span> (14)</p>

    <p class="text-gray-300">We also have <span class="math">e^{(2)}_{\\mathbf{h}}=\\mathbf{0}^{n}</span>, i.e., for all <span class="math">k\\in\\{0,\\ldots,n-1\\}</span></p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\sum_{i=1}^{\\log n}(l_{ih_{1+k}}x_{i}^{2}+r_{ih_{1+k}}x_{i}^{-2})+p^{\\prime}_{h_{1+k}}\\Big{)}-by^{(-(k))}\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{\\text{bit}(k,i,\\log n)}}\\right)=0\\;.</span> (15)</p>

    <p class="text-gray-300">From <span class="math">e^{(2)}_{u}=0</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i=1}^{\\log n}(l_{iu}x_{i}^{2}+r_{iu}x_{i}^{-2})\\right)+p^{\\prime}_{u}-w\\cdot ab=0\\;.</span> (16)</p>

    <p class="text-gray-300">We shall next use the following lemma which essentially says that if none of <span class="math">e^{(2)}_{\\mathbf{g}},e^{(2)}_{\\mathbf{h}},e^{(2)}_{u},e^{(2)}_{g},e^{(2)}_{h}</span> are non-zero and <span class="math">\\tau\\notin\\mathcal{T}_{\\textsf{BadCh}}^{\\textsf{ACSPf}}</span>, then <span class="math">w\\cdot\\langle p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}}\\circ\\mathbf{y}^{n}\\rangle=p^{\\prime}_{u}</span>. It is very similar to Lemma 7 that we encountered in the analysis of RngPf. This similarity is due to both ACSPf and RngPf use the inner-product argument.</p>

    <p class="text-gray-300">The equalities in the statement of this lemma hold if the inner-product argument verifier accepts and the discrete logarithm problem is hard in group <span class="math">\\mathbb{G}</span>. The lemma shows that if none of the challenges in the inner-product argument were bad, then the inner-product of the vectors <span class="math">p^{\\prime}_{\\mathbf{g}}</span> and <span class="math">p^{\\prime}_{\\mathbf{h}}\\circ\\mathbf{y}^{n}</span> is <span class="math">p^{\\prime}_{u}/w</span>. This is a generalization of the proof that we saw in the technical overview where we analysed the inner-product argument for <span class="math">n=2</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">Let <span class="math">\\tau</span>, as shown in (12), be an accepting transcript of ACSPf such that <span class="math">\\tau\\notin\\mathcal{T}_{\\textsf{BadCh}}^{\\textsf{ACSPf}}</span>. Let</p>

    <p class="text-gray-300"><span class="math">p^{\\prime}_{\\mathbf{g}}=</span> <span class="math">a_{I\\mathbf{g}}\\cdot x+a_{O\\mathbf{g}}\\cdot x^{2}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}^{Q+1}_{[1:]}\\cdot\\mathbf{W}_{R})\\cdot x+s_{\\mathbf{g}}\\cdot x^{3}\\;,</span> <span class="math">p^{\\prime}_{\\mathbf{h}}=</span> <span class="math">a_{I\\mathbf{h}}\\cdot x+a_{O\\mathbf{h}}\\cdot x^{2}-\\mathbf{1}^{n}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}^{Q+1}_{[1:]}\\cdot\\mathbf{W}_{L})\\cdot x+\\mathbf{y}^{-n}\\circ(\\mathbf{z}^{Q+1}_{[1:]}\\cdot\\mathbf{W}_{O})+s_{\\mathbf{g}}\\cdot x^{3}\\;,</span> <span class="math">p^{\\prime}_{u}=</span> <span class="math">a_{Iu}\\cdot x+a_{Iu}\\cdot x^{2}+s_{u}\\cdot x^{3}+w\\hat{t}\\;.</span></p>

    <p class="text-gray-300">Suppose, the for all <span class="math">k\\in\\{0,\\ldots,n-1\\}</span></p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\sum_{i=1}^{\\log n}(l_{ig_{1+k}}x_{i}^{2}+r_{ig_{1+k}}x_{i}^{-2})+p^{\\prime}_{g_{1+k}}\\Big{)}-a\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{1-\\text{bit}(k,i,\\log n)}}\\right)=0\\;,</span> <span class="math">\\Big{(}\\sum_{i=1}^{\\log n}(l_{ih_{1+k}}x_{i}^{2}+r_{ih_{1+k}}x_{i}^{-2})+p^{\\prime}_{h_{1+k}}\\Big{)}-by^{(-(k))}\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{\\text{bit}(k,i,\\log n)}}\\right)=0\\;.</span></p>

    <p class="text-gray-300">Additionally,</p>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i=1}^{\\log n}(l_{iu}x_{i}^{2}+r_{iu}x_{i}^{-2})\\right)+p^{\\prime}_{u}-w\\cdot ab=0\\;.</span> (17)</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">w\\cdot\\langle p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}}\\circ\\mathbf{y}^{n}\\rangle=p^{\\prime}_{u}\\;.</span></p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof (Lemma 10).</h6>

    <p class="text-gray-300">We shall invoke Lemma 8 to prove this lemma. Let</p>

    <p class="text-gray-300"><span class="math">\\textsf{params}=\\left\\{\\{l_{i\\mathbf{g}},l_{i\\mathbf{h}},l_{iu},r_{i\\mathbf{g}},r_{i\\mathbf{h}},r_{iu}\\}_{i=1}^{\\log n},p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}},p^{\\prime}_{u}\\right\\}\\;.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the function <span class="math">\\mathsf{Bad}</span> defined in Figure 11. Note that since <span class="math">\\mathsf{Bad}(\\textsf{params},x,j)</span> returns true if and only if $x\\in\\mathsf{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x_{j}})<span class="math">, </span>x_{1},\\ldots,x_{\\log n}<span class="math"> in </span>\\tau<span class="math"> satisfy the condition for </span>x_{i}<span class="math">’s in Lemma 8. Moreover all the equalities required in Lemma 8 hold and </span>p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}},p^{\\prime}_{u}\\in\\mathbb{Z}_{p}$. So we using Lemma 8 we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">w\\cdot\\langle p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}}\\circ\\mathbf{y}^{n}\\rangle=p^{\\prime}_{u}\\;.</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">Since <span class="math">\\tau</span> is an accepting transcript of ACSPf and <span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{ACSPf}}</span> and (14) to (16) hold, using Lemma 10, we get</p>

    <p class="text-gray-300"><span class="math">w\\langle p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}}\\circ\\mathbf{y}^{n}\\rangle=p^{\\prime}_{u}\\;.</span></p>

    <p class="text-gray-300">Plugging in the values of <span class="math">p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}},p^{\\prime}_{u}</span> we get</p>

    <p class="text-gray-300"><span class="math">w\\cdot</span> <span class="math">\\left\\langle\\left(a_{I\\mathbf{g}}x+a_{O\\mathbf{g}}x^{2}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R})x+s_{\\mathbf{g}}x^{3}\\right),\\mathbf{y}^{n}\\circ\\left(a_{I\\mathbf{h}}x+a_{O\\mathbf{h}}x^{2}-\\mathbf{1}^{n}\\right.\\right.</span> <span class="math">\\left.\\left.+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L})\\cdot x+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{O})+s_{\\mathbf{g}}x^{3}\\right)\\right\\rangle=a_{Iu}x+a_{Iu}x^{2}+s_{u}x^{3}+w\\hat{t}\\;.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{ACSPf}}</span>, we have that $w\\notin\\mathsf{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{w})<span class="math">. Therefore, </span>\\mathsf{SZ}(f(W),w)<span class="math"> is false where </span>f<span class="math"> is as defined in </span>\\mathsf{CheckBad}(\\tau^{\\prime},w)<span class="math">. Since we have here that </span>f(w)=0<span class="math">, the polynomial </span>f(W)<span class="math"> must be the zero polynomial. In particular its </span>W$ term must be zero, i.e.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{t}=\\left\\langle\\left(a_{I\\mathbf{g}}x+a_{O\\mathbf{g}}x^{2}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R})x+s_{\\mathbf{g}}x^{3}\\right),\\right.</span> <span class="math">\\left.\\left.\\mathbf{y}^{n}\\circ\\left(a_{I\\mathbf{h}}x+a_{O\\mathbf{h}}x^{2}-\\mathbf{1}^{n}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L})x+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{O})+s_{\\mathbf{g}}x^{3}\\right)\\right\\rangle\\;.</span></p>

    <p class="text-gray-300">Plugging in the value of <span class="math">\\hat{t}</span> obtained in (13), we have that</p>

    <p class="text-gray-300"><span class="math">x^{2}(\\delta(y,z)+\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{c}\\rangle)+t_{1g}x+\\sum_{i=3}^{6}t_{ig}x^{i}-\\left\\langle a_{I\\mathbf{g}}x+a_{O\\mathbf{g}}x^{2}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R})x+s_{\\mathbf{g}}x^{3},\\right.</span> <span class="math">\\left.\\left.\\mathbf{y}^{n}\\circ\\left(a_{I\\mathbf{h}}x+a_{O\\mathbf{h}}x^{2}-\\mathbf{1}^{n}+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L})x+\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{O})+s_{\\mathbf{g}}x^{3}\\right)\\right\\rangle=0\\;.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{ACSPf}}</span>, we have that $x\\notin\\mathsf{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x})<span class="math">. Therefore, </span>\\mathsf{SZ}(f_{4}(X),x)<span class="math"> is false where </span>f_{4}<span class="math"> is as defined in </span>\\mathsf{CheckBad}(\\tau^{\\prime},x)<span class="math">. Since we have here that </span>f_{4}(x)=0<span class="math">, the polynomial </span>f_{4}(X)<span class="math"> must be the zero polynomial. In particular its </span>X^{2}$ term must be zero, i.e.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\delta(y,z)+\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{c}\\rangle-\\langle a_{I\\mathbf{g}},\\mathbf{y}^{n}\\circ a_{I\\mathbf{h}}\\rangle-\\langle a_{I\\mathbf{g}},\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L}\\rangle+\\langle a_{O\\mathbf{g}},\\mathbf{y}^{n}\\rangle</span> <span class="math">-\\langle\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R}),\\mathbf{y}^{n}\\circ a_{I\\mathbf{h}}\\rangle-\\langle\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R}),(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L})\\rangle=0\\;.</span></p>

    <p class="text-gray-300">Plugging in <span class="math">\\delta(y,z)=\\langle\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R}),(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L})\\rangle</span>, we get</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{c}\\rangle-\\langle a_{I\\mathbf{g}},\\mathbf{y}^{n}\\circ a_{I\\mathbf{h}}\\rangle-\\langle a_{I\\mathbf{g}},\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{L}\\rangle+\\langle a_{O\\mathbf{g}},\\mathbf{y}^{n}\\rangle-\\langle\\mathbf{y}^{-n}\\circ(\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{R}),\\mathbf{y}^{n}\\circ a_{I\\mathbf{h}}\\rangle</span> <span class="math">-\\langle a_{O\\mathbf{g}},\\mathbf{z}_{[1:]}^{Q+1}\\cdot\\mathbf{W}_{O}\\rangle=0\\;.</span></p>

    <p class="text-gray-300">Simplifying and rearranging we get</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{z}_{[1:]}^{Q+1},\\mathbf{c}-\\mathbf{W}_{L}\\cdot a_{I\\mathbf{g}}-\\mathbf{W}_{R}\\cdot a_{I\\mathbf{h}}-\\mathbf{W}_{O}\\cdot a_{O\\mathbf{g}}\\rangle-\\langle a_{I\\mathbf{g}}\\circ a_{I\\mathbf{h}}-a_{O\\mathbf{g}},\\mathbf{y}^{n}\\rangle=0\\;.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\tau\\notin\\mathcal{T}_{\\mathsf{BadCh}}^{\\mathsf{ACSPf}}</span>, we have that $(y,z)\\notin\\mathsf{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(y,z)})<span class="math">. Therefore, </span>\\mathsf{SZ}(f(Y,Z),(y,z))<span class="math"> is false where </span>f<span class="math"> is as defined in </span>\\mathsf{CheckBad}(\\tau^{\\prime},(y,z))<span class="math">. Since we have here that </span>f(y,z)=0<span class="math">, the polynomial </span>f(Y,Z)$ is the vector polynomial. Equating all its coefficients to zero, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{W}_{L}\\cdot a_{I\\mathbf{g}}+\\mathbf{W}_{R}\\cdot a_{I\\mathbf{h}}+\\mathbf{W}_{O}\\cdot a_{O\\mathbf{g}}=\\mathbf{c}\\ ,a_{I\\mathbf{g}}\\circ a_{I\\mathbf{h}}=a_{O\\mathbf{g}}\\ .</span></p>

    <p class="text-gray-300">Since <span class="math">(\\mathbf{a}_{L}^{<em>},\\mathbf{a}_{R}^{</em>},\\mathbf{a}_{O}^{*})</span> returned by <span class="math">\\mathsf{e}</span> is <span class="math">(a_{I\\mathbf{g}},a_{I\\mathbf{h}},a_{O\\mathbf{g}})</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{L}^{<em>}\\circ\\mathbf{a}_{R}^{</em>}=\\mathbf{a}_{O}^{<em>}\\text{ and }\\mathbf{W}_{L}\\cdot\\mathbf{a}_{L}^{</em>}+\\mathbf{W}_{R}\\cdot\\mathbf{a}_{R}^{<em>}+\\mathbf{W}_{O}\\cdot\\mathbf{a}_{O}^{</em>}=\\mathbf{c}\\ .</span></p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">5.4 Proof of Lemma 8</h3>

    <p class="text-gray-300">From the statement of the algebraic lemma, it is evident that we need to eliminate everything except for <span class="math">p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}},y,p^{\\prime}_{u},w</span> to obtain a relation between them. Our first step would be to plug in the values of <span class="math">a,b</span> from the first two sets of equalities into the third – this would eliminate <span class="math">a,b</span>. Then we shall exploit the first two sets of equalities and the definition of <span class="math">\\mathsf{Bad}</span> to arrive at an equation solely in terms of <span class="math">p^{\\prime}_{\\mathbf{g}},p^{\\prime}_{\\mathbf{h}},y,p^{\\prime}_{u},w</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof (Lemma 8).</h6>

    <p class="text-gray-300">First we observe that given that <span class="math">\\mathsf{Bad}(\\mathsf{params},x,j)\\neq\\mathtt{true}</span>, if for any of the polynomials <span class="math">p(X)</span> on which <span class="math">\\mathsf{SZ}</span> is called in <span class="math">\\mathsf{Bad}</span>, <span class="math">p(x)</span> is zero, then the polynomial <span class="math">p(X)</span> is the zero polynomial. We shall use this observation repeatedly in this proof.</p>

    <p class="text-gray-300">Simplifying notation. We introduce some new notation for simplicity. We define the following polynomials. For all <span class="math">k\\in\\{1,\\ldots,\\log n\\},\\text{ for all }j\\in\\{0,\\ldots,n-1\\}</span></p>

    <p class="text-gray-300"><span class="math">f^{\\mathbf{g}}_{k,j}(X)</span> <span class="math">=l_{kg_{1+j}}X^{2}+r_{kg_{1+j}}X^{-2}+p^{\\prime}_{g_{1+j}}+\\sum_{i=1}^{k-1}(l_{ig_{1+j}}x_{i}^{2}+r_{ig_{1+j}}x_{i}^{-2})\\ ,</span> (18) <span class="math">f^{\\mathbf{h}}_{k,j}(X)</span> <span class="math">=l_{kh_{1+j}}X^{2}+r_{kh_{1+j}}X^{-2}+p^{\\prime}_{h_{1+j}}+\\sum_{i=1}^{k-1}(l_{ih_{1+j}}x_{i}^{2}+r_{ih_{1+j}}x_{i}^{-2})\\ .</span></p>

    <p class="text-gray-300">For all <span class="math">k\\in\\{1,\\ldots,\\log n\\}</span></p>

    <p class="text-gray-300"><span class="math">f^{u}_{k}(X)=l_{ku}X^{2}+r_{ku}X^{-2}+p^{\\prime}_{u}+\\sum_{i=1}^{k-1}(l_{iu}x_{i}^{2}+r_{iu}x_{i}^{-2})\\ .</span> (19)</p>

    <p class="text-gray-300">Using our notation in (18) and (19), we can re-write our given equalities as</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">k=0,\\ldots,n-1</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">a=f^{\\mathbf{g}}_{\\log n,k}(x_{\\log n})\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{\\text{bit}(k,i,\\log n)}}\\right)\\ .</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">k=0,\\ldots,n-1</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">b=f^{\\mathbf{h}}_{\\log n,k}(x_{\\log n})\\cdot y^{((k))}\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{1-\\text{bit}(k,i,\\log n)}}\\right)\\ .</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f^{u}_{\\log n}(x_{\\log n})-w\\cdot ab=0\\ .</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">a,b</span> in the third equality. First off, we plug the values of <span class="math">a,b</span> we obtain for <span class="math">k=0</span> into the third equality. We obtain</p>

    <p class="text-gray-300"><span class="math">f_{\\log n}^{u}(x_{\\log n})-w\\cdot f_{\\log n,1}^{\\mathbf{g}}(x_{\\log n})\\cdot f_{\\log n,1}^{\\mathbf{h}}(x_{\\log n})=0\\ .</span> (20)</p>

    <p class="text-gray-300">In order to eliminate all variable except <span class="math">p_{\\mathbf{g}}^{\\prime},p_{\\mathbf{h}}^{\\prime},y,p_{u}^{\\prime},w</span>, we need to use the first two sets of equalities to obtain relations that we can plug back into (20).</p>

    <p class="text-gray-300">Relations from the first set of equalities. The first set of equalities gave us that for <span class="math">k=0,\\ldots,n-1</span></p>

    <p class="text-gray-300"><span class="math">a=f_{\\log n,k}^{\\mathbf{g}}(x_{\\log n})\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{\\text{bit}(k,i,\\log n)}}\\right)\\ .</span> (21)</p>

    <p class="text-gray-300">Let <span class="math">t\\in\\{1,\\ldots,\\log n\\}</span> and <span class="math">j\\in\\{0,\\ldots,n/2^{t}-1\\}</span>. Equating the values of <span class="math">a</span> for <span class="math">k=j</span> and <span class="math">k=j+n/2^{t}</span>, we get</p>

    <p class="text-gray-300"><span class="math">f_{\\log n,j}^{\\mathbf{g}}(x_{\\log n})\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{\\text{bit}(j,i,\\log n)}}\\right)=f_{\\log n,j+n/2^{t}}^{\\mathbf{g}}(x_{\\log n})\\cdot\\left(\\prod_{i=1}^{\\log n}x_{i}^{(-1)^{\\text{bit}(j+n/2^{t},i,\\log n)}}\\right)\\ .</span></p>

    <p class="text-gray-300">Since <span class="math">j\\in\\{0,\\ldots,n/2^{t}-1\\}</span>, <span class="math">j</span> and <span class="math">j+n/2^{t}</span> differ only in the <span class="math">t^{\\text{th}}</span> bit. So, we have for <span class="math">t\\in\\{1,\\ldots,\\log n\\}</span>, <span class="math">j\\in\\{0,\\ldots,n/2^{t}-1\\}</span></p>

    <p class="text-gray-300"><span class="math">f_{\\log n,j}^{\\mathbf{g}}(x_{\\log n})\\cdot x_{t}^{2}=f_{\\log n,j+n/2^{t}}^{\\mathbf{g}}(x_{\\log n})\\ .</span> (22)</p>

    <p class="text-gray-300">We shall next show that for all <span class="math">t\\in\\{1,\\ldots,\\log n\\},\\text{ for all }j\\in\\{0,\\ldots,n/2^{t}-1\\}</span></p>

    <p class="text-gray-300"><span class="math">l_{tg_{1+j}}=0\\ ,r_{tg_{1+j}}=f_{t-1,j+n/2^{t}}^{\\mathbf{g}}(x_{t-1})\\ .</span></p>

    <p class="text-gray-300">First we show it for <span class="math">t=\\log n</span>- in this case <span class="math">j</span> can take the value only <span class="math">0</span>. We have that</p>

    <p class="text-gray-300"><span class="math">f_{\\log n,0}^{\\mathbf{g}}(x_{\\log n})\\cdot x_{\\log n}^{2}-f_{\\log n,1}^{\\mathbf{g}}(x_{\\log n})=0\\ .</span></p>

    <p class="text-gray-300">Since <span class="math">\\textsf{Bad}(\\textsf{params},x_{\\log n},\\log n)=\\texttt{false}</span></p>

    <p class="text-gray-300"><span class="math">f_{\\log n,0}^{\\mathbf{g}}(X)\\cdot X^{2}-f_{\\log n,1}^{\\mathbf{g}}(X)</span></p>

    <p class="text-gray-300">is the zero polynomial. Equating the constant term to <span class="math">0</span> we get</p>

    <p class="text-gray-300"><span class="math">r_{(\\log n)g_{1}}=f_{\\log n-1,1}^{\\mathbf{g}}(x_{\\log n-1})\\ ,</span></p>

    <p class="text-gray-300">Equating the <span class="math">X^{4}</span> term to <span class="math">0</span> we get,</p>

    <p class="text-gray-300"><span class="math">l_{(\\log n)g_{1}}=0\\ .</span></p>

    <p class="text-gray-300">Hence, it holds for <span class="math">t=\\log n</span>. Now let <span class="math">t=t^{\\prime}&lt;\\log n</span>. We have that for <span class="math">j\\in\\{0,\\ldots,n/2^{t^{\\prime}}-1\\}</span>.</p>

    <p class="text-gray-300"><span class="math">f_{\\log n,j}^{\\mathbf{g}}(x_{\\log n})\\cdot x_{t^{\\prime}}^{2}-f_{\\log n,j+n/2^{t^{\\prime}}}^{\\mathbf{g}}(x_{\\log n})=0\\ .</span></p>

    <p class="text-gray-300">Since <span class="math">\\textsf{Bad}(\\textsf{params},x_{\\log n},\\log n)=\\texttt{false}</span></p>

    <p class="text-gray-300"><span class="math">f_{\\log n,j}^{\\mathbf{g}}(X)\\cdot x_{t^{\\prime}}^{2}-f_{\\log n,j+n/2^{t^{\\prime}}}^{\\mathbf{g}}(X)</span></p>

    <p class="text-gray-300">is the zero polynomial. Therefore, its constant term is <span class="math">0</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">f_{\\log n-1,j}^{\\mathbf{g}}(x_{\\log n-1})\\cdot x_{t^{\\prime}}^{2}-f_{\\log n,j+n/2^{t^{\\prime}}}^{\\mathbf{g}}(x_{\\log n-1})=0\\;.</span></p>

    <p class="text-gray-300">Using similar series of arguments (since for all <span class="math">j\\in\\{\\log n-1,\\log n-2,\\ldots,t^{\\prime}\\}:\\mathsf{Bad}(\\mathsf{params},x_{j},j)=\\texttt{false}</span>) we can arrive at</p>

    <p class="text-gray-300"><span class="math">f_{t^{\\prime},j}^{\\mathbf{g}}(x_{t^{\\prime}})\\cdot x_{t^{\\prime}}^{2}-f_{t^{\\prime},j+n/2^{t^{\\prime}}}^{\\mathbf{g}}(x_{t^{\\prime}})=0\\;.</span></p>

    <p class="text-gray-300">Now, since <span class="math">\\mathsf{Bad}(\\mathsf{params},x_{t}^{\\prime},t^{\\prime})=\\texttt{false}</span></p>

    <p class="text-gray-300"><span class="math">f_{t^{\\prime},j}^{\\mathbf{g}}(X)\\cdot X^{2}-f_{t^{\\prime},j+n/2^{t^{\\prime}}}^{\\mathbf{g}}(X)</span></p>

    <p class="text-gray-300">must be the zero polynomial. Equating the constant term to <span class="math">0</span> we get for <span class="math">t^{\\prime}&gt;1</span></p>

    <p class="text-gray-300"><span class="math">r_{t^{\\prime}g_{j}}=f_{t^{\\prime}-1,j+n/2^{t^{\\prime}}}^{\\mathbf{g}}(x_{t^{\\prime}-1})\\;,</span></p>

    <p class="text-gray-300">and for <span class="math">t^{\\prime}=1</span></p>

    <p class="text-gray-300"><span class="math">r_{1g_{1+j}}=p_{g_{1+j+n/2}}^{\\prime}\\;.</span></p>

    <p class="text-gray-300">Equating the <span class="math">X^{4}</span> term to <span class="math">0</span> we get,</p>

    <p class="text-gray-300"><span class="math">l_{t^{\\prime}g_{j}}=0\\;.</span></p>

    <p class="text-gray-300">Hence for all <span class="math">t\\in\\{2,\\ldots,\\log n\\},\\text{ for all }j\\in\\{0,\\ldots,n/2^{t}-1\\}</span></p>

    <p class="text-gray-300"><span class="math">l_{tg_{1+j}}=0\\;,r_{tg_{1+j}}=f_{t-1,j+n/2^{t}}^{\\mathbf{g}}(x_{t-1})\\;,</span> (23)</p>

    <p class="text-gray-300">and for all <span class="math">j\\in\\{0,\\ldots,n/2-1\\}</span></p>

    <p class="text-gray-300"><span class="math">r_{1g_{1+j}}=p_{g_{1+j+n/2}}^{\\prime}\\;,l_{1g_{1+j}}=0\\;.</span> (24)</p>

    <p class="text-gray-300">Relations from the second set of equalities. Now, we can go through an identical process for the second set of equalities and obtain that (we omit the calculations since they are identical to the ones we saw previously)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all <span class="math">t\\in\\{2,\\ldots,\\log n\\},\\text{ for all }j\\in\\{0,\\ldots,n/2^{t}-1\\}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">r_{th_{1+j}}=0\\;,l_{th_{1+j}}=f_{t-1,j+n/2^{t}}^{\\mathbf{h}}(x_{t})\\cdot y^{n/2^{t}}\\;.</span> (25)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all <span class="math">j\\in\\{0,\\ldots,n/2-1\\}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">r_{1h_{1+j}}=0\\;,l_{1h_{1+j}}=p_{h_{1+j+n/2}}^{\\prime}\\cdot y^{n/2}\\;.</span> (26)</p>

    <p class="text-gray-300">Putting it all together. Finally, we are ready to use the obtained relations. We shall show using induction on <span class="math">k</span> that for all <span class="math">k\\in\\{1,\\ldots,\\log n\\}</span></p>

    <p class="text-gray-300"><span class="math">f_{k}^{u}(x_{k})-w\\cdot\\sum_{j=0}^{n/2^{k}-1}f_{k,j}^{\\mathbf{g}}(x_{k})\\cdot f_{k,j}^{\\mathbf{h}}(x_{k})\\cdot y^{j}=0\\;.</span></p>

    <p class="text-gray-300">The base case for <span class="math">k=\\log n</span> is true since (20) holds.</p>

    <p class="text-gray-300">Now assuming it holds for some <span class="math">k=k^{\\prime}</span> we shall show that it holds for <span class="math">k^{\\prime}-1</span> as well. Using induction hypothesis we have that</p>

    <p class="text-gray-300"><span class="math">f_{k^{\\prime}}^{u}(x_{k^{\\prime}})-w\\cdot\\sum_{j=0}^{n/2^{k^{\\prime}}-1}f_{k^{\\prime},j}^{\\mathbf{g}}(x_{k^{\\prime}})\\cdot f_{k^{\\prime},j}^{\\mathbf{h}}(x_{k^{\\prime}})\\cdot y^{j}=0\\;.</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathsf{Bad}(\\mathsf{params},x_{k}^{\\prime},k^{\\prime})\\neq\\mathtt{true}</span>, the polynomial</p>

    <p class="text-gray-300"><span class="math">f_{k^{\\prime}}^{u}(X)-w\\cdot\\sum_{j=0}^{n/2^{k^{\\prime}}-1}f_{k^{\\prime},j}^{\\mathbf{g}}(X)\\cdot f_{k^{\\prime},j}^{\\mathbf{h}}(X)\\cdot y^{j}</span></p>

    <p class="text-gray-300">must be the zero polynomial, i.e., in particular its constant term is zero. It’s constant term can be written as</p>

    <p class="text-gray-300"><span class="math">f_{k^{\\prime}-1}^{u}(x_{k^{\\prime}-1})-w\\cdot\\sum_{j=0}^{n/2^{k^{\\prime}}-1}f_{k^{\\prime}-1,j}^{\\mathbf{g}}(x_{k^{\\prime}-1})\\cdot f_{k^{\\prime}-1,j}^{\\mathbf{h}}(x_{k^{\\prime}-1})\\cdot y^{j}</span> <span class="math">-w\\cdot\\sum_{j=0}^{n/2^{k^{\\prime}}-1}\\left(l_{k^{\\prime}g_{1+j}}\\cdot r_{k^{\\prime}h_{1+j}}+r_{k^{\\prime}g_{1+j}}\\cdot l_{k^{\\prime}h_{1+j}}\\right)\\cdot y^{j})\\;.</span></p>

    <p class="text-gray-300">From (23) and (25) we have that for <span class="math">j\\in\\{0,\\ldots,n/2^{k^{\\prime}}-1\\}</span></p>

    <p class="text-gray-300"><span class="math">r_{k^{\\prime}g_{1+j}}=f_{k^{\\prime}-1,j+n/2^{k^{\\prime}}}^{\\mathbf{g}}(x_{k^{\\prime}-1})\\;,\\;l_{k^{\\prime}g_{1+j}}=0\\;,\\;r_{k^{\\prime}h_{1+j}}=0\\;,\\;l_{k^{\\prime}h_{1+j}}=f_{k^{\\prime}-1,j+n/2^{k^{\\prime}}}^{\\mathbf{h}}(x_{k^{\\prime}-1})\\cdot y^{n/2^{k^{\\prime}}}\\;.</span></p>

    <p class="text-gray-300">So, equating the constant term to <span class="math">0</span> we have that</p>

    <p class="text-gray-300"><span class="math">f_{k^{\\prime}-1}^{u}(x_{k^{\\prime}-1})-w\\cdot\\sum_{j=0}^{n/2^{k^{\\prime}}-1}(f_{k^{\\prime}-1,j}^{\\mathbf{g}}(x_{k^{\\prime}-1})\\cdot f_{k^{\\prime}-1,j}^{\\mathbf{h}}(x_{k^{\\prime}-1})\\cdot y^{j})</span> <span class="math">-w\\cdot\\sum_{j=0}^{n/2^{k^{\\prime}}-1}\\left((f_{k^{\\prime}-1,j+n/2^{k^{\\prime}}}^{\\mathbf{g}}(x_{k^{\\prime}-1})\\cdot f_{k^{\\prime}-1,j+n/2^{k^{\\prime}}}^{\\mathbf{h}}(x_{k^{\\prime}-1}))\\cdot y^{j+n/2^{k^{\\prime}}}\\right)=0\\;.</span></p>

    <p class="text-gray-300">This can be simplified to</p>

    <p class="text-gray-300"><span class="math">f_{k^{\\prime}-1}^{u}(x_{k^{\\prime}-1})-w\\cdot\\sum_{j=0}^{n/2^{k^{\\prime}-1}-1}(f_{k^{\\prime}-1,j}^{\\mathbf{g}}(x_{k^{\\prime}-1})\\cdot f_{k^{\\prime}-1,j}^{\\mathbf{h}}(x_{k^{\\prime}-1})\\cdot y^{j}=0\\;.</span></p>

    <p class="text-gray-300">Hence we have shown that it holds for <span class="math">k=k^{\\prime}-1</span>. Hence, by induction we arrive at</p>

    <p class="text-gray-300"><span class="math">f_{1}^{u}(x_{1})-w\\cdot\\sum_{j=0}^{n/2-1}(f_{1,j}^{\\mathbf{g}}(x_{1})\\cdot f_{1,j}^{\\mathbf{h}}(x_{1})\\cdot y^{j}=0\\;.</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathsf{Bad}(\\mathsf{params},x_{k}^{\\prime},k^{\\prime})\\neq\\mathtt{true}</span>, the polynomial</p>

    <p class="text-gray-300"><span class="math">f_{1}^{u}(X)-w\\cdot\\sum_{j=0}^{n/2-1}(f_{1,j}^{\\mathbf{g}}(X)\\cdot f_{1,j}^{\\mathbf{h}}(X)\\cdot y^{j})</span></p>

    <p class="text-gray-300">is the zero polynomial, i.e., in particular its constant term is <span class="math">0</span>. So, we have that</p>

    <p class="text-gray-300"><span class="math">p_{u}^{\\prime}-w\\sum_{j=0}^{n/2-1}p_{g_{1+j}}^{\\prime}\\cdot p_{h_{1+j}}^{\\prime}\\cdot y^{j}-w\\sum_{j=0}^{n/2-1}(l_{1g_{1+j}}\\cdot r_{1h_{1+j}}+r_{1g_{1+j}}\\cdot l_{1h_{1+j}})\\cdot y^{j}=0\\;.</span></p>

    <p class="text-gray-300">From (24) and (26) we have that for <span class="math">j\\in\\{0,\\ldots,n/2-1\\}</span></p>

    <p class="text-gray-300"><span class="math">r_{1g_{1+j}}=p_{g_{1+j+n/2}}^{\\prime}\\;,l_{1g_{1+j}}=0,r_{1h_{1+j}}=0\\;,l_{1h_{1+j}}=p_{h_{1+j+n/2}}^{\\prime}\\cdot y^{n/2}\\;.</span></p>

    <p class="text-gray-300">So, we have that</p>

    <p class="text-gray-300"><span class="math">p_{u}^{\\prime}-w\\sum_{j=0}^{n/2-1}p_{g_{1+j}}^{\\prime}\\cdot p_{h_{1+j}}^{\\prime}\\cdot y^{j}-w\\sum_{j=0}^{n/2-1}(l_{1g_{1+j}}\\cdot r_{1h_{1+j}}+r_{1g_{1+j}}\\cdot l_{1h_{1+j}}\\cdot y^{n/2})\\cdot y^{j}=0\\;.</span></p>

    <p class="text-gray-300">Simplifying we get that</p>

    <p class="text-gray-300"><span class="math">p_{u}^{\\prime}=w\\cdot\\left&lt;p_{\\mathbf{g}}^{\\prime},p_{\\mathbf{h}}^{\\prime}\\circ\\mathbf{y}^{n}\\right&gt;.</span></p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-32" class="text-2xl font-bold">6 Online srs-wee Security of Sonic</h2>

    <p class="text-gray-300">We apply our framework to prove srs-wee security of Sonic <em>[18]</em> which is an interactive argument for arithmetic circuit satisfiability based on pairings (we refer to this argument as SnACSPf). The argument SnACSPf is again an argument of knowledge for the relation (11). Sonic represents arithmetic circuits using the same constraint system as the one used in Bulletproofs. The constraint system has three vectors <span class="math">\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{a}_{O}\\in\\mathbb{Z}_{p}^{n}</span> representing the left inputs, right inputs, and outputs of multiplication gates respectively, so that <span class="math">\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=\\mathbf{a}_{O}</span>, with additional <span class="math">Q\\leqslant 2n</span> linear constraints. The linear constraints can be represented as <span class="math">\\mathbf{a}_{L}\\cdot\\mathbf{W}_{L}+\\mathbf{a}_{R}\\cdot\\mathbf{W}_{R}+\\mathbf{a}_{O}\\cdot\\mathbf{W}_{O}=\\mathbf{c}</span>, where <span class="math">\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O}\\in\\mathbb{Z}_{p}^{Q\\times n}</span>.</p>

    <p class="text-gray-300">Pairings. As stated before, SnACSPf is based on pairings. Let <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span> be groups of prime order <span class="math">p</span> with generators <span class="math">g\\in\\mathbb{G}_{1},h\\in\\mathbb{G}_{2}</span>. A pairing is a bilinear map <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> such that <span class="math">e(g^{a},h^{b})=e(g,h)^{ab}</span> for all <span class="math">a,b\\in\\mathbb{Z}_{p}</span> and <span class="math">e(g,h)</span> is a generator of <span class="math">\\mathbb{G}_{T}</span>. In our AGM analysis, we shall consider symmetric pairings, i.e., <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}=\\mathbb{G}</span>. We shall assume that SnACSPf <span class="math">=\\textsf{SnACSPf}[\\mathbb{G},\\mathbb{G}_{T},e]</span> is instantiated on the understood families of groups <span class="math">\\mathbb{G}=\\{\\mathbb{G}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}^{+}}</span> (with order <span class="math">p=p(\\lambda)</span>) and <span class="math">\\mathbb{G}_{T}=\\{\\mathbb{G}_{T,\\lambda}\\}_{\\lambda\\in\\mathbb{N}^{+}}</span> such that there exists a bilinear map <span class="math">e:\\mathbb{G}\\times\\mathbb{G}\\to\\mathbb{G}_{T}</span>.</p>

    <p class="text-gray-300">The interactive argument SnACSPf. is a argument of knowledge for the following relation.</p>

    <p class="text-gray-300"><span class="math">R=</span> <span class="math">\\{\\big{(}</span> <span class="math">((n,Q\\in\\mathbb{N}^{+}),(\\mathbf{W}_{L},\\mathbf{W}_{R},\\mathbf{W}_{O}\\in\\mathbb{Z}_{p}^{Q\\times n},\\mathbf{c}\\in\\mathbb{Z}_{p}^{Q})),(\\mathbf{a}_{L},\\mathbf{a}_{R},\\mathbf{a}_{O}\\in\\mathbb{Z}_{p}^{n})\\big{)}:</span> <span class="math">\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=\\mathbf{a}_{O}\\wedge\\mathbf{W}_{L}\\cdot\\mathbf{a}_{L}+\\mathbf{W}_{R}\\cdot\\mathbf{a}_{R}+\\mathbf{W}_{O}\\cdot\\mathbf{a}_{O}=\\mathbf{c}\\}\\;.</span></p>

    <p class="text-gray-300">The setup algorithm SnACSPf.Setup fixes an integer <span class="math">d</span> such that <span class="math">4n&gt;d&gt;3n</span>. It generates the bilinear parameters <span class="math">\\mathsf{bp}=((p,\\mathbb{G},\\mathbb{G}_{T},e,g,h))</span>. It then samples <span class="math">\\alpha,x</span> uniformly at random from <span class="math">\\mathbb{Z}_{p}</span>. It sets</p>

    <p class="text-gray-300"><span class="math">\\mathsf{srs}=\\{g,\\{g^{x^{i}}\\}_{i=-d}^{d},\\{h^{x^{i}}\\}_{i=-d}^{d},\\{h^{\\alpha x^{i}}\\}_{i=-d}^{d},\\{g^{\\alpha x^{i}}\\}_{i=-d}^{d},\\{e(g,h^{\\alpha})\\}\\;.</span></p>

    <p class="text-gray-300">It returns <span class="math">(\\mathsf{bp},\\mathsf{srs})</span> as its output.</p>

    <p class="text-gray-300">As shown in [18] the argument for the above relation proceeds by defining following polynomials <span class="math">r(X,Y),k(Y),s(X,Y),t(X,Y)</span> and proving that the constant term of <span class="math">t(X,Y)</span> is zero.</p>

    <div class="my-4 text-center"><span class="math-block">r(X,Y) \\leftarrow \\langle \\mathbf{a}_L, \\mathbf{X}_{[1:]}^{n+1} \\circ \\mathbf{Y}_{[1:]}^{n+1} \\rangle + \\langle \\mathbf{a}_R, \\mathbf{X}_{[1:]}^{-n-1} \\circ \\mathbf{Y}_{[1:]}^{n+1} \\rangle + \\langle \\mathbf{a}_O, \\mathbf{X}_{[n+1:]}^{-2n-1} \\circ \\mathbf{Y}_{[n+1:]}^{-2n-1} \\rangle,</span></div>

    <div class="my-4 text-center"><span class="math-block">k(Y) \\leftarrow \\langle \\mathbf{c}, \\mathbf{Y}_{[n+1:]}^{Q+n+1} \\rangle,</span></div>

    <div class="my-4 text-center"><span class="math-block">s(X,Y) \\leftarrow \\mathbf{Y}_{[n+1:]}^{Q+n+1} \\cdot \\left(\\mathbf{W}_L \\cdot \\mathbf{X}_{[1:]}^{-n-1} + \\mathbf{W}_R \\cdot \\mathbf{X}_{[1:]}^{n+1} + \\mathbf{W}_O \\cdot \\mathbf{X}_{[n+1:]}^{2n+1}\\right) + \\langle -\\mathbf{Y}_{[1:]}^{n+1} - \\mathbf{Y}_{[1:]}^{-n-1}, \\mathbf{X}_{[n+1:]}^{2n+1} \\rangle,</span></div>

    <div class="my-4 text-center"><span class="math-block">t(X,Y) \\leftarrow r(X,1) \\left(r(X,Y) + s(X,Y)\\right) - k(Y).</span></div>

    <p class="text-gray-300">Note that the verifier can evaluate <span class="math">s(X,Y), k(Y)</span> without the witness. However evaluating <span class="math">s(X,Y)</span> is expensive, hence the prover the prover computes the value and the prover and the verifier engages in an argument for signature of correct computation where the prover demonstrates to the verifier that it sent the correct evaluation. This argument for signature of correct computation assumes that the polynomial <span class="math">s(X,Y)</span> can be expressed as a sum of <span class="math">M</span> polynomials of the form <span class="math">\\psi_j(X,Y) = \\sum_{i=1}^n \\psi_{j,\\sigma_{j,i}} X^i Y^{\\sigma_{j,i}}</span> where <span class="math">\\sigma_j = (\\sigma_{j,1}, \\dots, \\sigma_{j,n})</span> is a permutation of <span class="math">(1, \\dots, n)</span>. As stated in [18], for any given arithmetic circuit, one can devise a constraint system such that <span class="math">s(X,Y)</span> can be represented as a sum of <span class="math">M = O(1)</span> such polynomials.</p>

    <p class="text-gray-300">The prover and the verifier algorithms, SnACSPf.P, SnACSPf.V are shown in Figure 16 with all sub-components defined in Figures 17 to 21. The complexity of the protocol necessitates this modular description. Figure 17 describes the polynomial commitments used in Sonic and Figure 18 describes the signature of correct computation which uses the polynomial permutation argument defined in Figure 19 which in turn uses the grand product argument in Figure 20. The argument for well-formedness of commitments used by the grand product argument is defined in Figure 21.</p>

    <p class="text-gray-300">In the soundness analysis of SnACSPf in [18], only the bounded polynomial extractibility and evaluation binding of the commitment scheme is analysed in the AGM. Here we give an analysis of the srs-wee of SnACSPf in the AGM.</p>

    <p class="text-gray-300">We prove the following theorem that establishes an upper bound on the advantage against online srs-wee security of SnACSPf.</p>

    <p class="text-gray-300">Theorem 7. Let <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> be a family of groups with order <span class="math">p = p(\\lambda)</span>. Let <span class="math">\\mathbb{G}_T = \\{\\mathbb{G}_{T,\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> be a family of groups such that there exists a bilinear map <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span>. Let <span class="math">\\text{SnACSPf} = \\text{SnACSPf}[\\mathbb{G}, \\mathbb{G}_T, e]</span> be the interactive argument system as described in Figure 16, for the relation <span class="math">R</span> in (11). We can construct an extractor <span class="math">\\mathcal{E}</span> such that for any non-uniform algebraic prover <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> making at most <span class="math">q = q(\\lambda)</span> queries to its oracle, there exist non-uniform adversaries <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span> with the property that for any (computationally unbounded) distinguisher <span class="math">\\mathcal{D}</span>, for all <span class="math">\\lambda \\in \\mathbb{N}^{+}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Adv}_{\\text{SnACSPf}, R}^{\\text{sr-wee}}(\\mathcal{P}_{\\text{alg}}, \\mathcal{D}, \\mathcal{E}, \\lambda) \\leqslant \\frac{18nq}{p - 1} + \\operatorname{Adv}_{\\mathbb{G}}^{4n - \\text{dl}}(\\mathcal{F}_1, \\lambda) + \\operatorname{Adv}_{\\mathbb{G}}^{\\text{dl}}(\\mathcal{F}_2, \\lambda) + \\operatorname{Adv}_{\\mathbb{G}}^{\\text{dl}}(\\mathcal{F}_3, \\lambda).</span></div>

    <p class="text-gray-300">Moreover, the time complexities of the extractor <span class="math">\\mathcal{E}</span> and adversaries <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span> are all <span class="math">O(q \\cdot n)</span>.</p>

    <p class="text-gray-300">We can show that the bound in Theorem 7 is tight by constructing a cheating prover like we did in Theorem 5. Using Theorem 2, we get a corollary about fs-ext-1 security of <span class="math">\\mathsf{FS}^{\\mathbf{RO}}[\\mathsf{SnACSPf}]</span>.</p>

    <p class="text-gray-300">Corollary 3. Let <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> be a family of groups with order <span class="math">p = p(\\lambda)</span>. Let <span class="math">\\mathbb{G}_T = \\{\\mathbb{G}_{T,\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span> be a family of groups such that there exists a bilinear map <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span>. Let <span class="math">\\text{SnACSPf} = \\text{SnACSPf}[\\mathbb{G}, \\mathbb{G}_T, e]</span></p>

    <p class="text-gray-300">6 The reduction of bounded polynomial extractibility to the variant of <span class="math">q</span>-dl defined in the paper does not seem to account for the fact that an algebraic adversary can represent the commitments in terms of powers of <span class="math">h</span> as well.</p>

    <p class="text-gray-300">42</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 16. The interactive argument for arithmetic circuit satisfiability in Sonic.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 17. Polynomial commitments in Sonic</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 18. The signature of correct computation in Sonic.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 19. The polynomial permutation argument in Sonic.</p>

    <p class="text-gray-300">be the interactive argument as described in Figure 16, for the relation  <span class="math">R</span>  in (11). Let  <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{SnACSPf}]</span>  be the non-interactive argument obtained by applying the Fiat-Shamir transform to SnACSPf using a random oracle. We can construct an extractor  <span class="math">\\mathcal{E}</span>  such that for any non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  making at most  <span class="math">q = q(\\lambda)</span>  queries to the random oracle there exist non-uniform adversaries  <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span>  with the property that for all  <span class="math">\\lambda \\in \\mathbb{N}^+</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathsf {F S} ^ {\\mathsf {R O}} [ \\mathsf {S n A C S P f} ], R} ^ {\\mathsf {f s - e x t - 1}} \\left(\\mathcal {P} _ {\\mathsf {a l g}}, \\mathcal {E}, \\lambda\\right) \\leqslant \\frac {1 8 n q + q + 1}{p - 1} + \\operatorname {A d v} _ {\\mathbb {G}} ^ {4 n - \\mathsf {d l}} \\left(\\mathcal {F} _ {1}, \\lambda\\right) + \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathsf {d l}} \\left(\\mathcal {F} _ {2}, \\lambda\\right) + \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathsf {d l}} \\left(\\mathcal {F} _ {3}, \\lambda\\right).</span></div>

    <p class="text-gray-300">Moreover, the time complexities of the extractor  <span class="math">\\mathcal{E}</span>  and adversaries  <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span>  are all  <span class="math">O(q \\cdot n)</span> .</p>

    <p class="text-gray-300">Additionally, using techniques similar to those in the proof of Theorem 7, we can prove a similar bound for fs-ext-2 security of  <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{SnACSPf}]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SnGP.P((bp, srs, U, V),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SnGP.V(bp, srs, U, V)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  (u(X) = ∑i=1n uiXi, v(X) = ∑i=1n viXi)) |   |</p>

    <p class="text-gray-300">|  (a1, ..., an) ← (u1, ..., un) |   |</p>

    <p class="text-gray-300">|  (an+2, ..., a2n+1) ← (v1, ..., vn) |   |</p>

    <p class="text-gray-300">|  an+1 ← (Πi=1n ai)−1 |   |</p>

    <p class="text-gray-300">|  c1 ← a1 |   |</p>

    <p class="text-gray-300">|  For i = 2 to 2n + 1 do |   |</p>

    <p class="text-gray-300">|  ci ← ci-1 · ai |   |</p>

    <p class="text-gray-300">|  c(X) ← ∑i=12n+1 ciXi; a(X) ← ∑i=12n+1 aiXi |   |</p>

    <p class="text-gray-300">|  r(X, Y) ← Y(∑i=12n+1 aiXiYi |   |</p>

    <p class="text-gray-300">|  +an+1Xn+1Yn+1) |   |</p>

    <p class="text-gray-300">|  s(X, Y) ← Xn+2 + Xn+1Y - X2n+2Y |   |</p>

    <p class="text-gray-300">|  r'(X, Y) ← X-1 + ∑i=1n ciX-i-1 |   |</p>

    <p class="text-gray-300">|  k(Y) ← 1 + ∑i=1n ciYi+1 |   |</p>

    <p class="text-gray-300">|  t(X, Y) ← (r(X, Y) + s(X, Y))r'(X, Y) |   |</p>

    <p class="text-gray-300">|  -k(Y) |   |</p>

    <p class="text-gray-300">|  A ← gαn+1αxn+1UVxn+1 |   |</p>

    <p class="text-gray-300">|  C ← PC.C(bp, srs, d, c(X)) |   |</p>

    <p class="text-gray-300">|  Cw ← SnWF.Prv(bp, srs, 2n + 1, c(X)) |   |</p>

    <p class="text-gray-300">|  Uw ← SnWF.Prv(bp, srs, n, u(X)) |   |</p>

    <p class="text-gray-300">|  Vw ← SnWF.Prv(bp, srs, n, v(X)) A,C,Cw,Uw,Vw,an+1 |   |</p>

    <p class="text-gray-300">|  T ← PC.C(bp, srs, d, t(X, y)) y ← z |   |</p>

    <p class="text-gray-300">|  (a, Wa) ← PC.O(bp, srs, A, yz, a(X)) |   |</p>

    <p class="text-gray-300">|  (c, Wc) ← PC.O(bp, srs, C, z-1, c(X)) |   |</p>

    <p class="text-gray-300">|  (k, Wk) ← PC.O(bp, srs, C, y, c(X)) |   |</p>

    <p class="text-gray-300">|  (t, Wt) ← PC.O(bp, srs, T, z, t(X, y))Wa,b,Wb,k,Wk,Wt |   |</p>

    <p class="text-gray-300">|  t ← (ya + zn+2 + zn+1y |   |</p>

    <p class="text-gray-300">|  -z2n+2y)(c+1)z-1 - ky - 1 |   |</p>

    <p class="text-gray-300">|  If e(gαan+1xn+1U, h)e(V, hxn+1) |   |</p>

    <p class="text-gray-300">|  ≠ e(A, h) |   |</p>

    <p class="text-gray-300">|  √PC.V(bp, srs, d, A, yz, (a, Wa)) = 0 |   |</p>

    <p class="text-gray-300">|  √PC.V(bp, srs, d, C, z-1, (c, Wc)) = 0 |   |</p>

    <p class="text-gray-300">|  √PC.V(bp, srs, d, C, y, (k, Wk)) = 0 |   |</p>

    <p class="text-gray-300">|  √PC.V(bp, srs, d, T, z, (t, Wt)) = 0 |   |</p>

    <p class="text-gray-300">|  √SnWF.V(bp, srs, 2n + 1, C, Cw) = 0 |   |</p>

    <p class="text-gray-300">|  √SnWF.V(bp, srs, n, U, Uw) = 0 |   |</p>

    <p class="text-gray-300">|  √SnWF.V(bp, srs, n, V, Vw) = 0 |   |</p>

    <p class="text-gray-300">|  Return 0 |   |</p>

    <p class="text-gray-300">|  Return 1 |   |</p>

    <p class="text-gray-300">Fig. 20. The grand product argument in Sonic.</p>

    <p class="text-gray-300">SnWF.Prv(bp,srs,n,f(X))</p>

    <p class="text-gray-300">W\\gets (g^{x^{-d}f(x)},g^{x^{d - n}f(x)})</p>

    <p class="text-gray-300">Return W</p>

    <p class="text-gray-300">SnWF.V(bp, sr, n, F, W = (L, R))</p>

    <p class="text-gray-300">If e(F,h) = e(L,h^{nx^d})\\wedge e(F,h) = e(R,h^{nx^{n - d}}) then</p>

    <p class="text-gray-300">Return 1</p>

    <p class="text-gray-300">Return 0</p>

    <p class="text-gray-300">Fig. 21. Well-formedness argument in Sonic</p>

    <p class="text-gray-300">Proof. (Theorem 7) We shall invoke Theorem 1 by defining BadCh and e and showing that  <span class="math">\\varepsilon \\leqslant \\frac{18n}{p - 1}</span>  and there exists adversaries  <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">p _ {\\text {f a i l}} (\\mathrm {S n A C S P f}, \\mathcal {P} _ {\\text {a l g}}, \\mathrm {e}, R, \\lambda) \\leqslant \\mathrm {A d v} _ {\\mathbb {G}} ^ {4 n - \\mathrm {d l}} (\\mathcal {F} _ {1}) + \\mathrm {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} (\\mathcal {F} _ {2}) + \\mathrm {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} (\\mathcal {F} _ {3}).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DEFINING BadCh AND UPPER BOUNDING  <span class="math">\\varepsilon</span> . To start off, we shall define  <span class="math">\\mathsf{BadCh}(\\tau&#x27;)</span>  for all partial extended transcripts  <span class="math">\\tau&#x27;</span> . Let Ch be the set from which the challenge that comes right after  <span class="math">\\tau&#x27;</span>  is sampled. We define a helper function CheckBad that takes as input a partial extended transcripts  <span class="math">[\\tau&#x27;]</span>  and a challenge  <span class="math">c \\in \\mathsf{Ch}</span>  and returns true if and only if  <span class="math">c \\in \\mathsf{BadCh}(\\tau&#x27;)</span> . Since SnACSPf has two challenges, there are two definitions of CheckBad in Figure 22. We again use the predicate SZ here like before. Next, we need to compute an upper bound  <span class="math">\\varepsilon</span>  on the size of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{BadCh}(\\tau')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ch}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In other words, we need to compute an upper bound on the fraction of  </span>c<span class="math"> &#x27;s in Ch that CheckBad  </span>(\\tau', c)$  will return true for all the definitions of CheckBad.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The function CheckBad  <span class="math">(\\tau&#x27;, y)</span>  returns true if  <span class="math">\\mathsf{SZ}(f(Y), y)</span>  is true. We shall use the Schwartz-Zippel lemma to fraction bound the number of  <span class="math">y</span> 's that  <span class="math">\\mathsf{SZ}(f(Y), y)</span>  is true for  <span class="math">y \\in \\mathbb{Z}_p^<em></span> . The polynomial  <span class="math">f(Y)</span>  is a polynomial of degree at most  <span class="math">2n + Q</span>  (the maximum positive degree is  <span class="math">n + Q</span>  while the maximum negative degree is  <span class="math">-n</span> ). Since  <span class="math">Q \\leqslant 2n</span> , the degree of  <span class="math">f(Y)</span>  is at most  <span class="math">4n</span> . So, for at most at most  <span class="math">4n</span>  values of  <span class="math">y \\in \\mathbb{Z}_p^</em></span> ,  <span class="math">\\mathsf{SZ}(f(Y), y)</span>  is true. So the CheckBad  <span class="math">(\\tau&#x27;, y)</span>  returns true for at most  <span class="math">4n / (p - 1)</span>  fraction of  <span class="math">y</span> 's.</p>

    <p class="text-gray-300">The function CheckBad  <span class="math">(\\tau&#x27;, z)</span>  returns true if  <span class="math">\\mathsf{SZ}(f(Z), z)</span>  is true. The polynomial  <span class="math">f(Z)</span>  is a polynomial of degree at most  <span class="math">18n</span>  (the maximum positive degree is  <span class="math">d &amp;lt; 4n</span>  while the maximum negative degree is  <span class="math">2n - 4d &amp;gt; -16d</span> ). So, the fraction of  <span class="math">z</span> 's in  <span class="math">\\mathbb{Z}_p^<em></span>  for which  <span class="math">\\mathsf{SZ}(f(Z), z)</span>  is true is at most  <span class="math">18n / (p - 1)</span> . So the fraction of  <span class="math">z</span> 's in  <span class="math">\\mathbb{Z}_p^</em></span>  for which CheckBad  <span class="math">(\\tau&#x27;, z)</span>  returns true is at most  <span class="math">18n / (p - 1)</span> .</p>

    <p class="text-gray-300">Similarly we can argue that for  <span class="math">j = 1, \\ldots, M</span> , CheckBad  <span class="math">(\\tau&#x27;, z_j)</span>  returns true with probability at most  <span class="math">(10n + 1) / (p - 1)</span> , CheckBad  <span class="math">(\\tau&#x27;, y_j)</span>  returns true with probability at most  <span class="math">(2n + 2) / (p - 1)</span> , CheckBad  <span class="math">(\\tau&#x27;, (\\beta_j, \\gamma_j))</span>  returns true with probability at most  <span class="math">n / (p - 1)</span> , CheckBad  <span class="math">(\\tau&#x27;, \\delta_j)</span>  returns true with probability at most  <span class="math">8n / (p - 1)</span> .</p>

    <p class="text-gray-300">Therefore CheckBad  <span class="math">(\\tau&#x27;, c)</span>  will return true for any partial transcript  <span class="math">\\tau&#x27;</span>  for a no more than  <span class="math">18n / (p - 1)</span>  values of  <span class="math">c</span> , i.e., in the context of the Master Theorem  <span class="math">\\varepsilon \\leqslant \\frac{18n}{p - 1}</span> .</p>

    <p class="text-gray-300">DEFINING e. Next, we define the function e for SnACSPf in Figure 23. It gets as input an extended accepting transcript  <span class="math">[\\tau]</span>  with the representation of the input removed. Without loss of generality we assume that the representations of all the messages of the prover in the transcript that are from  <span class="math">\\mathbb{G}</span>  are in terms of the elements of  <span class="math">\\mathbb{G}</span>  in srs. The function e computes  <span class="math">(\\mathbf{a}_L^<em>, \\mathbf{a}_R^</em>, \\mathbf{a}_O^*)</span>  and outputs them. It follows from the description of e that it runs in time  <span class="math">O(n)</span> . Note that SnACSPf.V runs in time  <span class="math">O(n)</span> . Therefore, using Theorem 1, the time complexity of  <span class="math">\\mathcal{E}</span>  is  <span class="math">O(q \\cdot n)</span> .</p>

    <p class="text-gray-300">PROVING AN UPPER BOUND ON  <span class="math">p_{\\mathrm{fail}}(\\mathsf{SnACSPf}, \\mathcal{P}_{\\mathrm{alg}}, \\mathsf{e}, R, \\lambda)</span> . To that end, we construct the following three adversaries  <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span> .</p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">([\\tau^{\\prime}],z)</span></p>

    <div class="my-4 text-center"><span class="math-block">f(Z)\\leftarrow \\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}Z^{i}t_{g^{\\alpha x^{i}}}\\right) - \\left(\\sum_{\\substack{i = n - 2d\\\\ i\\neq n - d}}^{n}Z^{i}r_{g^{\\alpha x^{i - n + d}}}\\right)\\left(\\sum_{\\substack{i = n - 2d\\\\ i\\neq n - d}}^{n}(yZ)^{i}r_{g^{\\alpha x^{i - n + d}}} - s(Z,y)\\right) + k(y)</span></div>

    <p class="text-gray-300">Return  <span class="math">\\mathsf{SZ}(f(Z),z)</span></p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">([\\tau^{\\prime}],y)</span></p>

    <p class="text-gray-300">For  <span class="math">i = 1,\\dots ,n</span>  do</p>

    <p class="text-gray-300"><span class="math">a_{i}^{<em>}\\gets r_{g^{\\alpha x^{d - n + i}}};b_{i}^{</em>}\\gets r_{g^{\\alpha x^{d - n - i}}};c_{i}^{*}\\gets r_{g^{\\alpha x^{d - 2n - i}}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_L^<em> \\gets (a_1^</em>, \\ldots, a_n^<em>); \\mathbf{a}_R^</em> \\gets (b_1^<em>, \\ldots, b_n^</em>); \\mathbf{a}_O^<em> \\gets (c_1^</em>, \\ldots, c_n^*)</span></p>

    <p class="text-gray-300"><span class="math">f(Y)\\gets r_{g^{\\alpha x^{d - n}}}r_{g^{\\alpha x^{d - n}}} + \\langle \\mathbf{a}_L^<em>\\circ \\mathbf{a}_R^</em> -\\mathbf{a}_O^<em>,\\mathbf{Y}_{[1:]}^{n + 1} + \\mathbf{Y}_{[1:]}^{-n - 1}\\rangle +\\mathbf{Y}_{[n + 1:]}^Q +n + 1\\cdot (\\mathbf{W}_L\\cdot \\mathbf{a}_L^</em> +\\mathbf{W}_R\\cdot \\mathbf{a}_R^<em> +\\mathbf{W}_O\\cdot \\mathbf{a}_O^</em>) - \\langle \\mathbf{c},\\mathbf{Y}_{[n + 1:]}^Q +n + 1\\rangle</span></p>

    <p class="text-gray-300">Return  <span class="math">\\mathsf{SZ}(f(Y),y)</span></p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">([\\tau^{\\prime}],z_{j})</span></p>

    <div class="my-4 text-center"><span class="math-block">f (Z) \\leftarrow \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} Z ^ {i} t _ {j g ^ {\\alpha x ^ {i}}}\\right) - \\left(y _ {j} \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} (y _ {j} Z) ^ {i} a _ {j g ^ {\\alpha x ^ {i}}}\\right) + Z ^ {n + 2} + Z ^ {n + 1} y - Z ^ {2 n + 2} y _ {j}\\right) \\cdot \\left(\\sum_ {i = 1} ^ {2 n + 1} Z ^ {- i} c _ {j g ^ {\\alpha x ^ {i}}} + 1\\right) Z ^ {- 1} +</span></div>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i = 1}^{2n + 1}y_j^i c_{jg^{\\alpha x^i}}\\right)y_j + 1</span></p>

    <p class="text-gray-300">Return  <span class="math">\\mathsf{SZ}(f(Z),z_j)</span></p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">([\\tau^{\\prime}],y_{j})</span></p>

    <div class="my-4 text-center"><span class="math-block">f (Y) \\leftarrow \\sum_ {i = 1} ^ {2 n + 1} Y ^ {i + 1} \\left(a _ {j g ^ {\\alpha x ^ {i}}} c _ {j g ^ {\\alpha x ^ {i - 1}}} - c _ {j g ^ {\\alpha x ^ {i - 1}}}\\right) + \\left(c _ {j g ^ {\\alpha x ^ {n + 1}}} - 1\\right) + Y \\left(c _ {j g ^ {\\alpha x ^ {n}}} - c _ {j g ^ {\\alpha x ^ {2 n + 1}}}\\right)</span></div>

    <p class="text-gray-300">Return  <span class="math">\\mathsf{SZ}(f(Y),y_j)</span></p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">([\\tau^{\\prime}],(\\beta_{j},\\gamma_{j})</span></p>

    <div class="my-4 text-center"><span class="math-block">f (\\mathrm {B}, \\Gamma) \\leftarrow \\prod_ {i = 1} ^ {n} \\left(s _ {j g ^ {\\alpha x ^ {i}}} + \\mathrm {B} \\sigma_ {j, i} + \\Gamma\\right) - \\prod_ {i = 1} ^ {n} \\left(s _ {j g ^ {\\alpha x ^ {i}}} ^ {\\prime} + \\mathrm {B} i + \\Gamma\\right)</span></div>

    <p class="text-gray-300">Return  <span class="math">\\mathsf{SZ}(f(\\mathsf{B},\\Gamma),(\\beta_j,\\gamma_j))</span></p>

    <p class="text-gray-300">Procedure CheckBad  <span class="math">([\\tau^{\\prime}],\\delta_{j})</span></p>

    <div class="my-4 text-center"><span class="math-block">f (\\Delta) \\leftarrow \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\Delta^ {i} s _ {g ^ {\\alpha x ^ {i}}} ^ {\\prime}\\right) - \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} (\\Delta y _ {j}) ^ {i} \\psi_ {i}\\right)</span></div>

    <p class="text-gray-300">Return  <span class="math">\\mathsf{SZ}(f(\\Delta),\\delta_j)</span></p>

    <p class="text-gray-300">Fig. 22. The function CheckBad function for the SnACSPf.</p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathsf{e}([\\tau])</span></p>

    <div class="my-4 text-center"><span class="math-block">/ / [ \\tau ] = \\left(\\mathsf {b p}, \\mathsf {s r s}, n, d, s (X, Y), k (Y), \\{\\psi_ {j} (X, Y), \\sigma_ {j} \\} _ {j = 1} ^ {M}; [ R ], y, [ T ], z, (a, [ W _ {a} ], b, [ W _ {b} ], [ W _ {t} ], s), \\{([ S _ {i}, S _ {i} ^ {\\prime} ]), (\\delta_ {i}, \\beta_ {i}, \\gamma_ {i}), \\right.</span></div>

    <p class="text-gray-300"><span class="math">(s_i, [W_i], v_i, [W_i&#x27;], [Q_i&#x27;]), ([A_i, C_i, C_{i,w}, U_{i,w}, V_{i,w}], a_{i,n+1}), y_i, T_i, z_i, (a_i, [W_{i,a}], b_i, [W_{i,b}], k_i, [W_{i,k}], [W_{i,t}]) \\}_{i=1}^M)</span></p>

    <p class="text-gray-300"><span class="math">a_{i}^{<em>}\\gets r_{g^{\\alpha x^{d - n + i}}};b_{i}^{</em>}\\gets r_{g^{\\alpha x^{d - n - i}}};c_{i}^{*}\\gets r_{g^{\\alpha x^{d - 2n - i}}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_L^<em> \\gets (a_1^</em>, \\ldots, a_n^<em>); \\mathbf{a}_R^</em> \\gets (b_1^<em>, \\ldots, b_n^</em>); \\mathbf{a}_O^<em> \\gets (c_1^</em>, \\ldots, c_n^*)</span></p>

    <p class="text-gray-300">Return  <span class="math">(\\mathbf{a}_L^<em>,\\mathbf{a}_R^</em>,\\mathbf{a}_O^*)</span></p>

    <p class="text-gray-300">Fig. 23. The function e for SnACSPf.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adversary  <span class="math">\\mathcal{F}_1</span>  is an adversary against  <span class="math">d</span> -DLOG in the group  <span class="math">\\mathbb{G}</span>  that runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> . It has inputs  <span class="math">(g, g^x, g^{x^2}, \\ldots, g^{x^d})</span> . It fixes a positive integer  <span class="math">n</span>  such that  <span class="math">4n &amp;gt; d &amp;gt; 3n</span> . It samples  <span class="math">\\alpha, \\beta \\in \\mathbb{Z}_p</span> , and</li>

    </ol>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 24. The function  <span class="math">\\mathsf{h}_1</span>  for SnACSPf.</p>

    <p class="text-gray-300">sets  <span class="math">\\mathsf{bp} = (p,\\mathbb{G},\\mathbb{G}_T,e,g,g^\\beta)</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {s r s} = \\left\\{g, \\left\\{g ^ {x ^ {i}} \\right\\} _ {i = - d} ^ {d}, \\left\\{g ^ {x ^ {i} \\beta} \\right\\} _ {i = - d} ^ {d}, \\left\\{g ^ {x ^ {i} \\alpha \\beta} \\right\\} _ {i = - d} ^ {d}, \\left\\{g ^ {x ^ {i} \\alpha} \\right\\} _ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d}, e (g, g ^ {\\alpha \\beta}) \\right\\}.</span></div>

    <p class="text-gray-300">Note that  <span class="math">(n,d,\\mathsf{bp},\\mathsf{srs})</span>  is a valid output of SnACSPf.Setup. Adversary  <span class="math">\\mathcal{F}_1</span>  runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  on public parameters  <span class="math">(n,d,\\mathsf{bp},\\mathsf{srs})</span>  and simulates the game  <span class="math">\\mathsf{SRS}_{\\mathsf{SnACSPf}}</span>  to it. If  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  manages to produce an accepting transcript  <span class="math">\\tau</span> ,  <span class="math">\\mathcal{F}_1</span>  calls a helper function  <span class="math">\\mathsf{h}_1</span>  on input  <span class="math">[\\tau]</span> ,  <span class="math">\\alpha</span> ,  <span class="math">\\beta</span> ,  <span class="math">g^x</span>  and outputs whatever  <span class="math">\\mathsf{h}_1</span>  outputs. The function  <span class="math">\\mathsf{h}_1</span>  is defined in Figure 24. The subroutines used in  <span class="math">\\mathsf{h}_1</span>  are defined in Figures 27 to 29.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adversary  <span class="math">\\mathcal{F}_2</span>  is an adversary against DLOG in the group  <span class="math">\\mathbb{G}</span>  that runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> . It has inputs  <span class="math">(g,V)</span> . It fixes a positive integer  <span class="math">n</span>  such that  <span class="math">4n &amp;gt; d &amp;gt; 3n</span> . It samples  <span class="math">\\alpha, x \\in \\mathbb{Z}_p</span> , and sets  <span class="math">\\mathsf{bp} = (p,\\mathbb{G},\\mathbb{G}_T,e,g,V)</span>  and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {s r s} = \\left\\{g, \\left\\{g ^ {x ^ {i}} \\right\\} _ {i = - d} ^ {d}, \\left\\{V ^ {x ^ {i}} \\right\\} _ {i = - d} ^ {d}, \\left\\{V ^ {x ^ {i} \\alpha} \\right\\} _ {i = - d} ^ {d}, \\left\\{g ^ {x ^ {i} \\alpha} \\right\\} _ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d}, e (g, V ^ {\\alpha}) \\right\\}.</span></div>

    <p class="text-gray-300">Note that  <span class="math">(n,d,\\mathsf{bp},\\mathsf{srs})</span>  is a valid output of SnACSPf.Setup. Adversary  <span class="math">\\mathcal{F}_2</span>  runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  on public parameters  <span class="math">(n,d,\\mathsf{bp},\\mathsf{srs})</span>  and simulates the game  <span class="math">\\mathsf{SRS}_{\\mathsf{SnACSPf}}</span>  to it. If  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  manages to produce an accepting transcript  <span class="math">\\tau</span> ,  <span class="math">\\mathcal{F}_1</span>  calls a helper function  <span class="math">\\mathsf{h}_1</span>  on input  <span class="math">[\\tau]</span> ,  <span class="math">\\alpha</span> ,  <span class="math">\\beta</span> ,  <span class="math">g^x</span>  and outputs whatever  <span class="math">\\mathsf{h}_1</span>  outputs. The function  <span class="math">\\mathsf{h}_2</span>  is defined in Figure 24. The subroutines used in  <span class="math">\\mathsf{h}_2</span>  are defined in Figures 27 to 29.</p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathsf{h}_2([\\tau ],\\alpha ,x,X)</span></p>

    <pre><code class="language-latex">$//[\\tau] = \\left(\\mathsf{bp},\\mathsf{srs},n,d,s(X,Y),k(Y),\\{\\psi_j(X,Y),\\sigma_j\\}_{j=1}^M;[R],y,[T],z,(a,[W_a],b,[W_b],[W_t],s),\\{([S_i,S_i&#x27;]),\\{\\delta_i,\\beta_i,\\gamma_i\\}, (s_i,[W_i],v_i,[W_i&#x27;],[Q_i&#x27;]),([A_i,C_i,C_{i,w},U_{i,w},V_{i,w}],a_{i,n+1}),y_i,T_i,z_i,(a_i,[W_{i,a}],b_i,[W_{i,b}],k_i,[W_{i,k}],[W_{i,t}])\\}_{i=1}^M\\right)$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[R],[W_{a}],a,z,n)$
If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[R],[W_{b}],b,yz,n)$
If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $t\\gets a(b + s) - k(y)$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[T],[W_{t}],t,z,d)$
If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$
For  $i = 1,\\dots ,M$  do
$\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[S_i],[W_i],s_i,z,d)x;$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[S_i&#x27;],[Q_i],v_i,\\delta_i,d);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[P_{2,t}],[Q_i&#x27;],v_i,\\delta_iy,d);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[C_i],[W_{i,t}],c_i,z^{-1},d);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[C_i],[W_{i,k}],k_i,y,d);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{ComHelper}_{2}(X,x,\\alpha ,[T_i],[W_{i,t}],t_i,z,d);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{EqHelper}_{2}(X,x,\\alpha ,[U_i],[V_i],[A_i],a_{i,n + 1},n);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{WfHelper}_{2}(X,x,\\alpha ,[C],[C_{i,w,1},C_{i,w,2}],2n + 1);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{WfHelper}_{2}(X,x,\\alpha ,[U],[U_{i,w,1},U_{i,w,2}],n);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$ $\\beta^{*}\\gets \\mathrm{WfHelper}_{2}(X,x,\\alpha ,[V],[V_{i,w,1},V_{i,w,2}],n);$  If  $\\beta^{*}\\neq \\bot$  then return  $\\beta^{*}$</code></pre>

    <p class="text-gray-300">Fig. 25. The function  <span class="math">\\mathsf{h}_2</span>  for SnACSPf.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adversary  <span class="math">\\mathcal{F}_3</span>  is an adversary against DLOG in the group  <span class="math">\\mathbb{G}</span>  that runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> . It has inputs  <span class="math">(g,V)</span> . It fixes a positive integer  <span class="math">n</span>  such that  <span class="math">4n &amp;gt; d &amp;gt; 3n</span> . It samples  <span class="math">\\beta, x \\in \\mathbb{Z}_p</span> , and sets  <span class="math">\\mathsf{bp} = (p,\\mathbb{G},\\mathbb{G}_T,e,g,g^\\beta)</span>  and</li>

    </ol>

    <pre><code class="language-latex">$\\mathsf{srs} = \\{g,\\{g^{x^i}\\}_{i = -d}^d,\\{g^{\\beta x^i}\\}_{i = -d}^d,\\{V^{x^i\\beta}\\}_{i = -d}^d,\\{V^{x^i}\\}_{\\substack{i = -d\\\\ i\\neq 0}}^d,e(g,V^\\beta)\\} .$</code></pre>

    <p class="text-gray-300">Note that  <span class="math">(n,d,\\mathsf{bp},\\mathsf{srs})</span>  is a valid output of SnACSPf.Setup. Adversary  <span class="math">\\mathcal{F}_3</span>  runs  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  on public parameters  <span class="math">(n,d,\\mathsf{bp},\\mathsf{srs})</span>  and simulates the game  <span class="math">\\mathsf{SRS}_{\\mathsf{SnACSPf}}</span>  to it. If  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  manages to produce an accepting transcript  <span class="math">\\tau</span> ,  <span class="math">\\mathcal{F}_3</span>  calls a helper function  <span class="math">\\mathsf{h}_3</span>  on input  <span class="math">[\\tau], x, \\beta, V</span>  and outputs whatever  <span class="math">\\mathsf{h}_3</span>  outputs. The function  <span class="math">\\mathsf{h}_3</span>  is defined in Figure 26. The subroutines used in  <span class="math">\\mathsf{h}_3</span>  are defined in Figures 27 to 29.</p>

    <p class="text-gray-300">Note that the definitions of the helper functions are modular, i.e.,  <span class="math">\\mathsf{h}_i</span>  use the subroutines  <span class="math">\\mathsf{PC}_i</span> ,  <span class="math">\\mathsf{EqHelper}_i</span> ,  <span class="math">\\mathsf{WfHelper}_i</span>  for  <span class="math">i = 1,2,3</span> . The subroutine  <span class="math">\\mathsf{PC}_i</span>  produces a solution to the relevant hard problem if the prover manages to break the binding of any of the commitment. Similarly the subroutine  <span class="math">\\mathsf{WfHelper}_i</span>  produces a solution to the relevant hard problem if the prover manages to pass the well-formedness verification for a commitment that is not well-formed.</p>

    <p class="text-gray-300">We now make the following observations about adversaries  <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adversary  <span class="math">\\mathcal{F}_1</span>  succeeds if  <span class="math">\\mathsf{h}_1([\\tau], \\alpha, \\beta)</span>  computes  <span class="math">x^<em></span>  such that  <span class="math">(g^{x^</em>} = g^x)</span> . From the code of  <span class="math">\\mathsf{h}_1</span>  it is easy to see that whenever  <span class="math">\\mathsf{h}_1</span>  returns a non- <span class="math">\\perp</span>  value  <span class="math">x^<em></span> , it satisfies  <span class="math">(g^{x^</em>} = g^x)</span> , i.e., adversary  <span class="math">\\mathcal{F}_1</span>  succeeds. Also, it follows from the description of  <span class="math">\\mathsf{h}_1</span>  that it runs in time at  <span class="math">O(n)</span></li>

    </ul>

    <p class="text-gray-300">Procedure  <span class="math">\\mathsf{h}_3([\\tau ],x,\\beta ,X)</span></p>

    <pre><code class="language-txt">//[τ] = (bp, srs, n, d, s(X, Y), k(Y), {ψj(X, Y), σj}Mj=1; [R], y, [T], z, (a, [W_a], b, [W_b], [W_t], s), {([S_i, S_i&#x27;]), (δ_i, β_i, γ_i),
(s_i, [W_i], v_i, [W_i&#x27;], [Q_i&#x27;]), ([A_i, C_i, C_{i,w}, U_{i,w}, V_{i,w}], a_{i,n+1}), y_i, T_i, z_i, (a_i, [W_{i,a}], b_i, [W_{i,b}], k_i, [W_{i,k}], [W_{i,t}])]Mj=1)
α* ← ComHelper_3(X, x, [R], [W_a], a, z, n)
If α* ≠ ⊥ then return α*
α* ← ComHelper_3(X, x, [R], [W_b], b, yz, n)
If α* ≠ ⊥ then return α*
t ← a(b + s) - k(y)
α* ← ComHelper_3(X, x, [T], [W_t], t, z, d)
If α* ≠ ⊥ then return α*
For i = 1, ..., M do
α* ← ComHelper_3(X, a, x, [S_i], [W_i], s_i, z, d) x; If α* ≠ ⊥ then return α*
α* ← ComHelper_3(X, x, [S_i&#x27;], [Q_i], v_i, δ_i, d); If α* ≠ ⊥ then return α*
α* ← ComHelper_3(X, x, [P2,i], [Q_i&#x27;], v_i, δ_i y, d); If α* ≠ ⊥ then return α*
α* ← ComHelper_3(X, x, [C_i], [W_i,c], c_i, z^-1, d); If α* ≠ ⊥ then return α*
α* ← ComHelper_3(X, x, [C_i], [W_i,k], k_i, y, d); If α* ≠ ⊥ then return α*
α* ← ComHelper_3(X, x, [T_i], [W_i,t], t_i, z, d); If α* ≠ ⊥ then return α*
α* ← EqHelper_3(X, x, [U_i], [V_i], [A_i], a_{i,n+1}, n); If α* ≠ ⊥ then return α*
α* ← WfHelper_3(X, x, [C], [C_i,w,1, C_i,w,2], 2n + 1); If α* ≠ ⊥ then return α*
α* ← WfHelper_3(X, x, [U], [U_i,w,1, U_i,w,2], n); If α* ≠ ⊥ then return α*
α* ← WfHelper_3(X, x, [V], [V_i,w,1, V_i,w,2], n); If α* ≠ ⊥ then return α*
Return ⊥</code></pre>

    <p class="text-gray-300">Fig. 26. The function  <span class="math">\\mathsf{h}_3</span>  for SnACSPf.</p>

    <p class="text-gray-300">(since  <span class="math">M = O(1)</span> ). The running time of  <span class="math">\\mathcal{F}_1</span>  consists of the time required to answers  <span class="math">q</span>  queries, run SnACSPf.V in at most  <span class="math">q</span>  paths in the execution tree and the time required to run  <span class="math">\\mathsf{h}_1</span> . Hence its time complexity is  <span class="math">O(qn)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adversary  <span class="math">\\mathcal{F}_2</span>  succeeds if  <span class="math">\\mathsf{h}_2([\\tau], x, \\alpha)</span>  computes  <span class="math">\\beta^<em></span>  such that  <span class="math">g^{\\beta^</em>} = V</span> . From the code of  <span class="math">\\mathsf{h}_2</span>  it is easy to see that whenever  <span class="math">\\mathsf{h}_2</span>  returns a non- <span class="math">\\perp</span>  value  <span class="math">\\beta^<em></span> , it satisfies  <span class="math">(g^{\\beta^</em>} = h)</span> , i.e., adversary  <span class="math">\\mathcal{F}_2</span>  succeeds. Also, it follows from the description of  <span class="math">\\mathsf{h}_2</span>  that it runs in time  <span class="math">O(n)</span>  (since  <span class="math">M = O(1)</span> ). The running time of  <span class="math">\\mathcal{F}_2</span>  consists of the time required to answers  <span class="math">q</span>  queries, run SnACSPf.V in at most  <span class="math">q</span>  paths in the execution tree and the time required to run  <span class="math">\\mathsf{h}_2</span> . Hence its time complexity is  <span class="math">O(qn)</span> .</li>

      <li>Adversary  <span class="math">\\mathcal{F}_3</span>  succeeds if  <span class="math">\\mathsf{h}_3(\\tau, x, \\beta)</span>  computes  <span class="math">\\alpha^<em></span>  such that  <span class="math">g^{\\alpha^</em>} = V</span> . From the code of  <span class="math">\\mathsf{h}_3</span>  it is easy to see that whenever  <span class="math">\\mathsf{h}_3</span>  returns a non- <span class="math">\\perp</span>  value  <span class="math">\\alpha^<em></span> , it satisfies  <span class="math">(g^{\\alpha^</em>} = g^x)</span> , i.e., adversary  <span class="math">\\mathcal{F}_3</span>  succeeds. Also, it follows from the description of  <span class="math">\\mathsf{h}_3</span>  that it runs in time  <span class="math">O(n)</span>  (since  <span class="math">M = O(1)</span> ). The running time of  <span class="math">\\mathcal{F}_3</span>  consists of the time required to answers  <span class="math">q</span>  queries, run SnACSPf.V in at most  <span class="math">q</span>  paths in the execution tree and the time required to run  <span class="math">\\mathsf{h}_3</span> . Hence its time complexity is  <span class="math">O(qn)</span> .</li>

    </ul>

    <p class="text-gray-300">We shall prove the following lemma showing that if  <span class="math">\\tau</span>  is an accepting transcript such that  <span class="math">\\tau \\notin T_{\\mathrm{BadCh}}^{\\mathrm{SnACSPf}}</span>  and  <span class="math">\\mathsf{h}_1([\\tau], \\alpha, \\beta)</span> ,  <span class="math">\\mathsf{h}_2([\\tau], x, \\alpha)</span> ,  <span class="math">\\mathsf{h}_3(\\tau, x, \\beta)</span>  all return  <span class="math">\\perp</span> , then  <span class="math">\\mathsf{e}([\\tau])</span>  returns a valid witness.</p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathrm{ComHelper}_1(X, [C], [W], v, z, n)</span></p>

    <div class="my-4 text-center"><span class="math-block">f (X) \\leftarrow (X - z) \\left(\\sum_ {i = - d} ^ {d} X ^ {i} w _ {g ^ {x ^ {i}}}\\right) + v - X ^ {- d + n} \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} X ^ {i} c _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f(X) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">x^{<em>}</span>  such that  <span class="math">f(x^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{x^<em>}</span>  then return  <span class="math">x^</em></span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathrm{ComHelper}_2(X,x,\\alpha ,[C],[W],v,z,n)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f (\\mathrm {B}) \\leftarrow \\mathrm {B} \\left(\\alpha (x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} w _ {h ^ {\\alpha x ^ {i}}}\\right) - x ^ {- d + n} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} c _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} c _ {h ^ {\\alpha x ^ {i}}}\\right)\\right) \\\\ + \\alpha (x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} w _ {g ^ {\\alpha x ^ {i}}}\\right) + \\alpha v - x ^ {- d + n} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} c _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} c _ {g ^ {\\alpha x ^ {i}}}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If  <span class="math">f(\\mathrm{B})\\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\beta^{<em>}</span>  such that  <span class="math">f(\\beta^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\beta^{<em>}}</span>  then return  <span class="math">\\beta^{</em>}</span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Procedure  <span class="math">\\mathrm{ComHelper}_3(X,x,[C],[W],v,z,n)</span></p>

    <div class="my-4 text-center"><span class="math-block">f (\\mathrm {A}) \\leftarrow \\mathrm {A} (x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} w _ {g ^ {\\alpha x ^ {i}}}\\right) + \\mathrm {A} v - x ^ {- d + n} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} c _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} c _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f(\\mathrm{A})\\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\alpha^{<em>}</span>  such that  <span class="math">f(\\alpha^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\alpha^{<em>}}</span>  then return  <span class="math">\\alpha^{</em>}</span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Fig. 27. Subroutines for  <span class="math">\\mathsf{h}_1, \\mathsf{h}_2, \\mathsf{h}_3</span> .</p>

    <p class="text-gray-300">Lemma 11. Let  <span class="math">n, d \\in \\mathbb{N}</span>  such that  <span class="math">d &amp;gt; 3n</span> . Let  <span class="math">x, \\alpha, \\beta \\in \\mathbb{Z}_{p}</span> ,  <span class="math">\\mathsf{bp} = (p, \\mathbb{G}, \\mathbb{G}_T, e, g, h)</span> . Let  <span class="math">\\mathsf{srs} = \\{g, \\{g^{x^i}\\}_{i=-d}^d, \\{g^{\\beta x^i}\\}_{i=-d}^d, \\{g^{\\alpha \\beta x^i}\\}_{i=-d}^d, \\{g^{\\alpha x^i}\\}_{i=0}^d, e(g, h^\\alpha)\\}</span> . Let</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tau = \\left(\\mathsf {b p}, \\mathsf {s r s}, n, d, s (X, Y), k (Y), \\{\\psi_ {j} (X, Y), \\sigma_ {j} \\} _ {j = 1} ^ {M}; [ R ], y, [ T ], z, (a, [ W _ {a} ], b, [ W _ {b} ], \\right. \\\\ \\left[ W _ {t} \\right], s), \\left\\{\\left(\\left[ S _ {i}, S _ {i} ^ {\\prime} \\right]\\right), \\left(\\delta_ {i}, \\beta_ {i}, \\gamma_ {i}\\right), \\left(s _ {i}, \\left[ W _ {i} \\right], v _ {i}, \\left[ W _ {t} ^ {\\prime} \\right], \\left[ Q _ {i} ^ {\\prime} \\right]\\right), \\left(\\left[ A _ {i}, C _ {i}, C _ {i, w}, U _ {i, w}, V _ {i, w} \\right], \\right. \\right. \\\\ \\left. a _ {i, n + 1}\\right), y _ {i}, T _ {i}, z _ {i}, \\left(a _ {i}, \\left[ W _ {i, a} \\right], b _ {i}, \\left[ W _ {i, b} \\right], k _ {i}, \\left[ W _ {i, k} \\right], \\left[ W _ {i, t} \\right]\\right) \\} _ {i = 1} ^ {M} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">be an accepting transcript of SnACSPf such that  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{SnACSPf}}</span> . If  <span class="math">\\mathsf{h}_1([\\tau], \\alpha, \\beta, g^x)</span> ,  <span class="math">\\mathsf{h}_2([\\tau], x, \\alpha, V)</span>  and  <span class="math">\\mathsf{h}_3([\\tau], x, \\beta, V)</span>  return  <span class="math">\\perp</span> , then  <span class="math">\\mathsf{e}([\\tau])</span>  returns  <span class="math">(\\mathbf{a}_L^<em>, \\mathbf{a}_R^</em>, \\mathbf{a}_O^*)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} _ {L} ^ {*} \\circ \\mathbf {a} _ {R} ^ {*} = \\mathbf {a} _ {O} ^ {*} \\quad a n d \\quad \\mathbf {a} _ {L} ^ {*} \\cdot \\mathbf {W} _ {L} + \\mathbf {a} _ {R} ^ {*} \\cdot \\mathbf {W} _ {R} + \\mathbf {a} _ {O} ^ {*} \\cdot \\mathbf {W} _ {O} = \\mathbf {c}.</span></div>

    <p class="text-gray-300">Taking the contrapositive, we get that if  <span class="math">\\tau</span>  is an accepting transcript such that  <span class="math">\\tau \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{SnACSPf}}</span>  and  <span class="math">\\mathsf{e}([\\tau])</span>  fails to return a valid witness, then one of  <span class="math">\\mathsf{h}_1([\\tau], \\alpha, \\beta, g^x)</span> ,  <span class="math">\\mathsf{h}_2([\\tau], x, \\alpha, V)</span> ,  <span class="math">\\mathsf{h}_3(\\tau, x, \\beta, V)</span>  returns a non- <span class="math">\\perp</span>  value, i.e., one of adversaries  <span class="math">\\mathcal{F}_1, \\mathcal{F}_2, \\mathcal{F}_3</span>  succeed. Therefore</p>

    <div class="my-4 text-center"><span class="math-block">p _ {\\text {f a i l}} \\left(\\operatorname {S n A C S P f}, \\mathcal {P} _ {\\text {a l g}}, \\mathrm {e}, R, \\lambda\\right) \\leqslant \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d n} - \\mathrm {d l}} \\left(\\mathcal {F} _ {1}\\right) + \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} \\left(\\mathcal {F} _ {2}\\right) + \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} \\left(\\mathcal {F} _ {3}\\right).</span></div>

    <p class="text-gray-300">We shall next prove Lemma 11.</p>

    <p class="text-gray-300">Procedure EqHelper <span class="math">_1(X, [U], [V], [A], a_{n+1}, n)</span></p>

    <div class="my-4 text-center"><span class="math-block">f (X) \\leftarrow \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} X ^ {i} u _ {g ^ {\\alpha x ^ {i}}} + X ^ {i + n + 1} v _ {g ^ {\\alpha x ^ {i}}}\\right) + a _ {n + 1} X ^ {n + 1} - \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} X ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f(X) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">x^{<em>}</span>  such that  <span class="math">f(x^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{x^<em>}</span>  then return  <span class="math">x^</em></span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Procedure EqHelper <span class="math">_2(X, x, \\alpha, [U], [V], [A], a_{n+1}, n)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f (\\mathrm {B}) \\leftarrow \\left(\\sum_ {i = - d} ^ {d} x ^ {i} u _ {g ^ {x ^ {i}}} + x ^ {i + n + 1} v _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} u _ {g ^ {\\alpha x ^ {i}}} + x ^ {i + n + 1} v _ {g ^ {\\alpha x ^ {i}}}\\right) \\\\ + \\mathrm {B} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} u _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} u _ {h ^ {\\alpha x ^ {i}}} + x ^ {i + n + 1} v _ {h ^ {x ^ {i}}} + \\alpha x ^ {i + n + 1} v _ {h ^ {\\alpha x ^ {i}}} - \\sum_ {i = - d} ^ {d} x ^ {i} a _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} a _ {h ^ {\\alpha x ^ {i}}}\\right) + \\alpha a _ {n + 1} x ^ {n + 1} \\\\ - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If  <span class="math">f(\\mathrm{B}) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\beta^{<em>}</span>  such that  <span class="math">f(\\beta^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\beta^{<em>}}</span>  then return  <span class="math">\\beta^{</em>}</span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Procedure EqHelper <span class="math">_3(X, x, [U], [V], [A], a_{n+1}, n)</span></p>

    <div class="my-4 text-center"><span class="math-block">f (\\mathrm {A}) \\leftarrow \\left(\\sum_ {i = - d} ^ {d} x ^ {i} u _ {g ^ {x ^ {i}}} + x ^ {i + n + 1} v _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} u _ {g ^ {\\alpha x ^ {i}}} + x ^ {i + n + 1} v _ {g ^ {\\alpha x ^ {i}}}\\right) + \\mathrm {A} a _ {n + 1} x ^ {n + 1} - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f(\\mathrm{A}) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\alpha^{<em>}</span>  such that  <span class="math">f(\\alpha^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\alpha^{<em>}}</span>  then return  <span class="math">\\alpha^{</em>}</span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Fig. 28. Subroutines for  <span class="math">\\mathsf{h}_1, \\mathsf{h}_2, \\mathsf{h}_3</span> .</p>

    <p class="text-gray-300">Proof (Lemma 11). Since  <span class="math">\\tau</span>  is an accepting transcript the following equality holds.</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(W _ {a}, h ^ {\\alpha x}\\right) e \\left(g ^ {a} W _ {a} ^ {z}, h ^ {\\alpha}\\right) = e \\left(R, h ^ {x ^ {- d + n}}\\right).</span></div>

    <p class="text-gray-300">We can express  <span class="math">W_{a}</span>  in terms of its representations, let  <span class="math">h = g^{\\beta}</span>  and re-write the first equality as</p>

    <div class="my-4 text-center"><span class="math-block">e (g, h) ^ {f} = 1,</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f = \\alpha (x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {a g ^ {x ^ {i}}} + \\beta x ^ {i} w _ {a h ^ {x ^ {i}}} + \\alpha \\beta x ^ {i} w _ {a h ^ {\\alpha x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} w _ {a g ^ {\\alpha x ^ {i}}}\\right) + \\alpha a \\\\ - x ^ {- d + n} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} r _ {g ^ {x ^ {i}}} + \\beta x ^ {i} r _ {h ^ {x ^ {i}}} + \\alpha \\beta x ^ {i} r _ {h ^ {\\alpha x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} r _ {g ^ {\\alpha x ^ {i}}}\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Procedure WfHelper  <span class="math">_{1}(X,[A],[L,R],n)</span>  ..</p>

    <div class="my-4 text-center"><span class="math-block">f _ {1} (X) \\leftarrow x ^ {d} \\left(\\sum_ {i = - d} ^ {d} X ^ {i} l _ {g ^ {x ^ {i}}}\\right) - \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} A X ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f_{1}(X) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">x^{<em>}</span>  such that  <span class="math">f_{1}(x^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{x^<em>}</span>  then return  <span class="math">x^</em></span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <div class="my-4 text-center"><span class="math-block">f _ {2} (X) \\leftarrow X ^ {n - d} \\left(\\sum_ {i = - d} ^ {d} X ^ {i} r _ {g ^ {x ^ {i}}}\\right) - \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} X ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f_{2}(X) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">x^{<em>}</span>  such that  <span class="math">f_{2}(x^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{x^<em>}</span>  then return  <span class="math">x^</em></span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Procedure WfHelper  <span class="math">_{2}(X,x,\\alpha ,[A],[L,R],n)</span>  ..</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {1} (\\mathrm {B}) \\leftarrow \\mathrm {B} \\left(\\alpha x ^ {d} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} l _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} l _ {h ^ {\\alpha x ^ {i}}}\\right) - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} a _ {h ^ {\\alpha x ^ {i}}}\\right)\\right) + \\alpha x ^ {d} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} l _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} l _ {g ^ {\\alpha x ^ {i}}}\\right) \\\\ - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If  <span class="math">f_{1}(\\mathrm{B}) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\beta^{<em>}</span>  such that  <span class="math">f_{1}(\\beta^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\beta^{<em>}}</span>  then return  <span class="math">\\beta^{</em>}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {2} (\\mathrm {B}) \\leftarrow \\mathrm {B} \\left(\\alpha x ^ {n - d} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} r _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} r _ {h ^ {\\alpha x ^ {i}}}\\right) - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} a _ {h ^ {\\alpha x ^ {i}}}\\right)\\right) + \\alpha x ^ {n - d} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} r _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} r _ {g ^ {\\alpha x ^ {i}}}\\right) \\\\ - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If  <span class="math">f_{2}(\\mathrm{B}) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\beta^{<em>}</span>  such that  <span class="math">f_{2}(\\beta^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\beta^{<em>}}</span>  then return  <span class="math">\\beta^{</em>}</span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Procedure WfHelper  <span class="math">_{3}(X,x,[A],[L,R],n)</span>  ..</p>

    <div class="my-4 text-center"><span class="math-block">f _ {1} (\\mathrm {A}) \\leftarrow \\mathrm {A} x ^ {d} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} l _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} l _ {g ^ {\\alpha x ^ {i}}}\\right) - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f_{1}(\\mathrm{A}) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\alpha^{<em>}</span>  such that  <span class="math">f_{1}(\\alpha^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\alpha^{<em>}}</span>  then return  <span class="math">\\alpha^{</em>}</span></p>

    <div class="my-4 text-center"><span class="math-block">f _ {2} (\\mathrm {A}) \\leftarrow \\mathrm {A} x ^ {n - d} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} r _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} r _ {g ^ {\\alpha x ^ {i}}}\\right) - \\left(\\sum_ {i = - d} ^ {d} x ^ {i} a _ {g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\mathrm {A} x ^ {i} a _ {g ^ {\\alpha x ^ {i}}}\\right)</span></div>

    <p class="text-gray-300">If  <span class="math">f_{2}(\\mathrm{A}) \\neq 0</span>  then</p>

    <p class="text-gray-300">Solve for  <span class="math">\\alpha^{<em>}</span>  such that  <span class="math">f_{2}(\\alpha^{</em>}) = 0</span></p>

    <p class="text-gray-300">If  <span class="math">X = g^{\\alpha^{<em>}}</span>  then return  <span class="math">\\alpha^{</em>}</span></p>

    <p class="text-gray-300">Return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Fig. 29. Subroutines for  <span class="math">\\mathsf{h}_1, \\mathsf{h}_2, \\mathsf{h}_3</span> .</p>

    <p class="text-gray-300">We therefore have</p>

    <p class="text-gray-300">$$ \\alpha (x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {a g ^ {x ^ {i}}} + \\beta x ^ {i} w _ {a h ^ {x ^ {i}}} + \\alpha \\beta x ^ {i} w _ {a h ^ {\\alpha x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} w _ {a g ^ {\\alpha x ^ {i}}}\\right) \\tag{27}</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\alpha a - x ^ {- d + n} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} r _ {g ^ {x ^ {i}}} + \\beta x ^ {i} r _ {h ^ {x ^ {i}}} + \\alpha \\beta x ^ {i} r _ {h ^ {\\alpha x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} r _ {g ^ {\\alpha x ^ {i}}}\\right) = 0.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Therefore <span class="math">\\beta</span> is a root <span class="math">f(\\mathrm{B}) = 0</span> in <span class="math">\\mathrm{ComHelper}_2(X,x,\\alpha ,[R],[W_a],a,z,n)</span> invoked by <span class="math">\\mathsf{h}_2</span>. Since <span class="math">\\mathsf{h}_2([\\tau ],x,\\alpha ,V)</span> returned <span class="math">\\perp</span> we have that <span class="math">f(\\mathrm{B})</span> must be the zero polynomial, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha (x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {a h ^ {x ^ {i}}} + \\alpha x ^ {i} w _ {a h ^ {\\alpha x ^ {i}}}\\right) - x ^ {- d + n} \\left(\\sum_ {i = - d} ^ {d} x ^ {i} r _ {h ^ {x ^ {i}}} + \\alpha x ^ {i} r _ {h ^ {\\alpha x ^ {i}}}\\right) = 0.</span></div>

    <p class="text-gray-300">Plugging this into (27) we get that</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha (x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {a g ^ {x ^ {i}}} + \\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} \\alpha x ^ {i} w _ {a g ^ {\\alpha x ^ {i}}}\\right) + \\alpha a</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>x^{-d + n}\\left(\\sum_{i = -d}^{d}x^{i}r_{g^{x^{i}}} + \\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}\\alpha x^{i}r_{g^{\\alpha x^{i}}}\\right) = 0.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Therefore <span class="math">\\alpha</span> is a root <span class="math">f(\\mathrm{A}) = 0</span> in <span class="math">\\mathrm{ComHelper}_3(X,x,[R],[W_a],a,z,n)</span> invoked by <span class="math">\\mathsf{h}_3</span>. Since <span class="math">\\mathsf{h}_3([\\tau ],x,\\beta ,V)</span> returned <span class="math">\\perp</span> it means that <span class="math">f(\\mathrm{A})</span> is the zero polynomial. In particular its A term is 0 i.e.</p>

    <div class="my-4 text-center"><span class="math-block">(x - z) \\left(\\sum_ {i = - d} ^ {d} x ^ {i} w _ {a g ^ {x ^ {i}}}\\right) + a - x ^ {- d + n} \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} x ^ {i} r _ {g ^ {\\alpha x ^ {i}}}\\right) = 0.</span></div>

    <p class="text-gray-300">Therefore <span class="math">x</span> is a root <span class="math">f(X) = 0</span> in <span class="math">\\mathrm{ComHelper}_1(X, [R], [W_a], a, z, n)</span> invoked by <span class="math">h_1</span>. Now, since <span class="math">h_1([\\tau], x, \\beta, g^x)</span> returned <span class="math">\\perp</span> we have that <span class="math">f_1(X)</span> is the zero polynomial, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">(X - z) \\left(\\sum_ {i = - d} ^ {d} X ^ {i} w _ {a g ^ {x ^ {i}}}\\right) + a - X ^ {- d + n} \\left(\\sum_ {\\substack {i = - d \\\\ i \\neq 0}} ^ {d} X ^ {i} r _ {g ^ {\\alpha x ^ {i}}}\\right).</span></div>

    <p class="text-gray-300">is the zero polynomial. The above polynomial is an zero for any value of <span class="math">X</span>. So, plugging in <span class="math">X = z</span> we get</p>

    <div class="my-4 text-center"><span class="math-block">a - z^{-d + n}\\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}z^{i}r_{g^{\\alpha x^{i}}}\\right) = 0.</span></div>

    <p class="text-gray-300">So,</p>

    <div class="my-4 text-center"><span class="math-block">a = \\left(\\sum_{\\substack{i = n - 2d\\\\ i\\neq n - d}}^{n}z^{i}r_{g^{\\alpha x^{i - n + d}}}\\right).</span></div>

    <p class="text-gray-300">Similarly, since <span class="math">\\tau</span> is an accepting transcript, the equalities</p>

    <div class="my-4 text-center"><span class="math-block">e (W _ {b}, h ^ {\\alpha x}) e (g ^ {b} W _ {b} ^ {y z}, h ^ {\\alpha}) = e (R, h ^ {x ^ {- d + n}}), e (W _ {t}, h ^ {\\alpha x}) e (g ^ {t} W _ {t} ^ {z}, h ^ {\\alpha}) = e (T, h)</span></div>

    <p class="text-gray-300">hold. Using arguments similar to the ones we used above, we can show that</p>

    <div class="my-4 text-center"><span class="math-block">b = \\left(\\sum_{\\substack{i = n - 2d\\\\ i\\neq n - d}}^{n}(yz)^{i}r_{g^{\\alpha x^{i - n + d}}}\\right),\\ t = \\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}z^{i}t_{g^{\\alpha x^{i}}}\\right).</span></div>

    <p class="text-gray-300">Next we can show that for the opening of commitments <span class="math">T_{j}, C_{j}, A_{j}</span> (similar to how we derived the value for <span class="math">a</span> above) for <span class="math">j = 1, \\ldots, M</span></p>

    <div class="my-4 text-center"><span class="math-block">t_{j} = \\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}z_{j}^{i}t_{jg^{\\alpha x^{i}}}\\right),k_{j} = \\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}y_{j}^{i}c_{jg^{\\alpha x^{i}}}\\right),c_{j} = \\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}z_{j}^{-i}c_{jg^{\\alpha x^{i}}}\\right),a_{j} = \\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}(y_{j}z_{j})^{i}a_{jg^{\\alpha x^{i}}}\\right).</span></div>

    <p class="text-gray-300">Also using that for <span class="math">j = 1,\\ldots ,M</span></p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {W f H e l p e r} _ {1} \\left(g ^ {x}, [ C ], \\left[ C _ {j, w, 1}, C _ {j, w, 2} \\right], 2 n + 1\\right) = \\bot ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {W f H e l p e r} _ {2} (V, x, \\alpha , [ C ], [ C _ {j, w, 1}, C _ {j, w, 2} ], 2 n + 1) = \\bot ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {W f H e l p e r} _ {3} (X, x, [ C ], [ C _ {j, w, 1}, C _ {j, w, 2} ], 2 n + 1) = \\bot ,</span></div>

    <p class="text-gray-300">we can show that <span class="math">c_{jg^{\\alpha x^i}} = 0</span> for <span class="math">i &amp;lt;= 0</span> and for <span class="math">i &amp;gt; 2n + 1</span> and <span class="math">c_{jg^{xi}} = 0</span>, <span class="math">c_{jh^{\\alpha x^i}} = 0</span>, <span class="math">c_{jh^{xi}} = 0</span> for all <span class="math">i</span>. Similarly, we can show that <span class="math">u_{jg^{\\alpha x^i}} = 0</span> for <span class="math">i &amp;lt;= 0</span> and for <span class="math">i &amp;gt; n</span> and <span class="math">u_{jg^{xi}} = 0</span>, <span class="math">u_{jh^{\\alpha x^i}} = 0</span>, <span class="math">u_{jh^{xi}} = 0</span> for all <span class="math">i</span> and <span class="math">v_{jg^{\\alpha x^i}} = 0</span> for <span class="math">i &amp;lt;= 0</span> and for <span class="math">i &amp;gt; n</span> and <span class="math">v_{jg^{xi}} = 0</span>, <span class="math">v_{jh^{\\alpha x^i}} = 0</span>, <span class="math">v_{jh^{xi}} = 0</span> for all <span class="math">i</span>.</p>

    <p class="text-gray-300">Hence <span class="math">c_{j} = \\left(\\sum_{i=1}^{2n+1} z_{j}^{-i} c_{jg^{\\alpha x^{i}}}\\right)</span>. We also have that <span class="math">t_{j} = (y a_{j} + z_{j}^{n+2} + z_{j}^{n+1} y_{j} - z_{j}^{2n+2} y_{j}) (c_{j} + 1) z_{j}^{-1} - y_{j} k_{j} - 1</span>. Therefore, for <span class="math">j = 1, \\ldots, M</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}z_{j}^{i}t_{jg^{\\alpha x^{i}}}\\right) = \\left(y_{j}\\left(\\sum_{\\substack{i = -d\\\\ i\\neq 0}}^{d}(y_{j}z_{j})^{i}a_{jg^{\\alpha x^{i}}}\\right) + z_{j}^{n + 2} + z_{j}^{n + 1}y - z_{j}^{2n + 2}y_{j}\\right). \\right. \\\\ \\left. \\left(\\sum_ {i = 1} ^ {2 n + 1} z _ {j} ^ {- i} c _ {j g ^ {\\alpha x ^ {i}}} + 1\\right) z _ {j} ^ {- 1} - \\left(\\sum_ {i = 1} ^ {2 n + 1} y _ {j} ^ {i} c _ {j g ^ {\\alpha x ^ {i}}}\\right) y _ {j} - 1 \\right). \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{z_j} \\notin T_{\\mathsf{BadCh}}^{\\mathsf{SnACSPf}}<span class="math">, we have that </span>z_j \\notin \\mathsf{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{z_j})<span class="math">. Therefore, </span>\\mathsf{SZ}(f(Z), z_j)<span class="math"> is false where </span>f<span class="math"> is as defined in </span>\\mathsf{CheckBad}(\\tau', z_j)<span class="math">. Since we have here that </span>f(z_j) = 0<span class="math">, the polynomial </span>f(Z)$ is the zero polynomial. In particular, its constant term is zero, i.e.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 1} ^ {2 n + 1} y _ {j} ^ {i + 1} \\left(a _ {j g ^ {\\alpha x ^ {i}}} c _ {j g ^ {\\alpha x ^ {i - 1}}} - c _ {j g ^ {\\alpha x ^ {i - 1}}}\\right) + \\left(c _ {j g ^ {\\alpha x ^ {n + 1}}} - 1\\right) + y _ {j} \\left(c _ {j g ^ {\\alpha x ^ {n}}} - c _ {j g ^ {\\alpha x ^ {2 n + 1}}}\\right) = 0.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{y_j} \\notin \\mathcal{T}_{\\text{BadCh}}^{\\text{SnACSPf}}<span class="math">, we have that </span>y_j \\notin \\text{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{y_j})<span class="math">. Therefore, </span>\\mathsf{SZ}(f(Y), y_j)<span class="math"> is false where </span>f<span class="math"> is as defined in </span>\\text{CheckBad}(\\tau', y_j)<span class="math">. Since we have here that </span>f(y_j) = 0<span class="math">, the polynomial </span>f(Y)<span class="math"> is the zero polynomial. In particular, its constant term is zero and we have that for </span>j = \\{1, \\ldots, M\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">c_{j g^{\\alpha x}} = a_{j g^{\\alpha x}}, \\; c_{j g^{\\alpha x^{n+1}}} = 1, \\; c_{j g^{\\alpha x^{n}}} = c_{j g^{\\alpha x^{2n+1}}},</span></div>

    <p class="text-gray-300">for <span class="math">i = 2, \\ldots, 2n + 1</span></p>

    <div class="my-4 text-center"><span class="math-block">c_{j g^{\\alpha x^i}} = c_{j g^{\\alpha x^{i-1}}} a_{j g^{\\alpha x^i}}.</span></div>

    <p class="text-gray-300">Combining, we get that</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} a_{j g^{\\alpha x^i}} = \\prod_{i=n+2}^{2n+1} a_{j g^{\\alpha x^i}}. \\tag{28}</span></div>

    <p class="text-gray-300">We also have that</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(g^{\\alpha a_{j,n+1} x^{n+1}} U_j, h\\right) e \\left(V_j, h^{x^{n+1}}\\right) = e \\left(A_j, h\\right)</span></div>

    <p class="text-gray-300">Using that for <span class="math">j = 1, \\ldots, M</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{EqHelper}_1(X, [U_i], [V_i], [A_i], a_{i,n+1}, n) = \\bot, \\\\ \\operatorname{EqHelper}_2(X, x, \\alpha, [U_i], [V_i], [A_i], a_{i,n+1}, n) = \\bot, \\\\ \\operatorname{EqHelper}_3(X, x, [U_i], [V_i], [A_i], a_{i,n+1}) = \\bot, \\end{array}</span></div>

    <p class="text-gray-300">we can show that</p>

    <div class="my-4 text-center"><span class="math-block">a_{j g^{\\alpha x^i}} = \\begin{cases} u_{j g^{\\alpha x^i}} &amp;amp; \\text{for } 1 \\leqslant i \\leqslant n \\\\ v_{j g^{\\alpha x^{i-n-1}}} &amp;amp; \\text{for } n + 2 \\leqslant i \\leqslant 2n + 1 \\end{cases}.</span></div>

    <p class="text-gray-300">Combining with (28) we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} u_{j g^{\\alpha x^i}} = \\prod_{i=1}^{n} v_{j g^{\\alpha x^i}}.</span></div>

    <p class="text-gray-300">Now from the definition of <span class="math">U_j, V_j</span> we have that <span class="math">u_{j g^{\\alpha x^i}} = \\alpha s_{j g^{\\alpha x^i}} x^i + \\beta_j \\alpha \\sigma_{j,i} x^i + \\gamma_j \\alpha x^i</span> and <span class="math">v_{j g^{\\alpha x^i}} = \\alpha s_{g^{\\alpha x^i}}&#x27; x^i + \\beta \\alpha i x^i + \\gamma_j \\alpha x^i</span>. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} \\left(\\alpha s_{j g^{\\alpha x^i}} x^i + \\beta_j \\alpha \\sigma_{j,i} x^i + \\gamma_j \\alpha x^i\\right) = \\prod_{i=1}^{n} \\left(\\alpha s_{g^{\\alpha x^i}}&#x27; x^i + \\beta \\alpha i x^i + \\gamma_j \\alpha x^i\\right)</span></div>

    <p class="text-gray-300">Simplifying we get,</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} \\left(s_{j g^{\\alpha x^i}} + \\beta_j \\sigma_{j,i} + \\gamma_j\\right) = \\prod_{i=1}^{n} \\left(s_{j g^{\\alpha x^i}}&#x27; + \\beta_j i + \\gamma_j\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\beta_j, \\gamma_j)} \\notin \\mathcal{T}_{\\text{BadCh}}^{\\text{SnACSPf}}<span class="math">, we have that </span>(\\beta_j, \\gamma_j) \\notin \\text{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\beta_j, \\gamma_j)})<span class="math">. Therefore, </span>\\mathsf{SZ}(f(\\mathrm{B}, \\Gamma), (\\beta_j, \\gamma_j))<span class="math"> is false where </span>f<span class="math"> is as defined in </span>\\text{CheckBad}(\\tau', (\\beta_j, \\gamma_j))<span class="math">. Since we have here that </span>f(\\beta_j, \\gamma_j) = 0<span class="math">, the polynomial </span>f(\\mathrm{B}, \\Gamma)<span class="math"> is the zero polynomial. Hence we have that for </span>j = \\{1, \\ldots, M\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">s_{j g^{\\alpha x^i}} = s_{j g^{\\alpha x^{\\sigma_i}}}.</span></div>

    <p class="text-gray-300">Additionally we can infer the following from the opening of the commitments <span class="math">W_j&#x27;, Q_j&#x27;</span> (similar to how we derived the value for <span class="math">a</span> above)</p>

    <div class="my-4 text-center"><span class="math-block">v_j = \\left(\\sum_{\\substack{i = -d \\\\ i \\neq 0}}^{d} \\delta_j^i s_{g^{\\alpha x^i}}&#x27;\\right), \\quad v_j = \\left(\\sum_{\\substack{i = -d \\\\ i \\neq 0}}^{d} (\\delta_j y_j)^i \\psi_i\\right).</span></div>

    <p class="text-gray-300">Equating the two values of <span class="math">v_j</span> we get that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{\\substack{i = -d \\\\ i \\neq 0}}^{d} \\delta_j^i s_{g^{\\alpha x^i}}&#x27;\\right) = \\left(\\sum_{\\substack{i = -d \\\\ i \\neq 0}}^{d} (\\delta_j y_j)^i \\psi_i\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\delta_j} \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{SnACSPf}}<span class="math">, we have that </span>\\delta_j \\notin \\mathrm{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\delta_j})<span class="math">. Therefore, </span>\\mathsf{SZ}(f(\\Delta), \\delta_j)<span class="math"> is false where </span>f<span class="math"> is as defined in </span>\\mathrm{CheckBad}(\\tau', \\delta_j)<span class="math">. Since we have here that </span>f(\\delta_j) = 0<span class="math">, the polynomial </span>f(Y)<span class="math"> is the zero polynomial. In particular, its constant term is zero and we have that for </span>j = \\{1, \\dots, M\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">s_{j g^{\\alpha x^i}}&#x27; = \\psi_i y^i \\quad \\text{for } i = 1, \\dots, n,</span></div>

    <p class="text-gray-300">and <span class="math">s_{j g^{\\alpha x^i}}&#x27; = 0</span> for <span class="math">i &amp;lt;= 0</span> and <span class="math">i &amp;gt; n</span>. Since we derived <span class="math">s_{j g^{\\alpha x^i}} = s_{j g^{\\alpha x^{\\sigma_i}}}</span> above, we have that</p>

    <div class="my-4 text-center"><span class="math-block">s_{j g^{\\alpha x^i}} = \\psi_{\\sigma_i} y^{\\sigma_i},</span></div>

    <p class="text-gray-300">and <span class="math">s_{j g^{\\alpha x^i}} = 0</span> for <span class="math">i &amp;lt;= 0</span> and <span class="math">i &amp;gt; n</span>. Additionally we can infer the following from the opening of the commitment <span class="math">W_j</span> (similar to how we derived the value for <span class="math">a</span> above)</p>

    <div class="my-4 text-center"><span class="math-block">s_j = \\left(\\sum_{\\substack{i = -d \\\\ i \\neq 0}}^{d} z^i s_{j g^{\\alpha x^i}}\\right).</span></div>

    <p class="text-gray-300">Plugging in the values of <span class="math">s_{j g^{\\alpha x^i}}</span></p>

    <div class="my-4 text-center"><span class="math-block">s_j = \\left(\\sum_{i = 1}^{n} z^i \\psi_{\\sigma_i} y^{\\sigma_i}\\right).</span></div>

    <p class="text-gray-300">Since <span class="math">s(X,Y) = \\sum_{j=1}^{M} \\sum_{i=1}^{n} X^i \\psi_{\\sigma_{j,i}} Y^{\\sigma_{j,i}}</span>, we have that <span class="math">s = \\sum_{i=1}^{M} s_i = s(z,y)</span>. So, we have that</p>

    <div class="my-4 text-center"><span class="math-block">t = a(b + s(z,y)) - k(y).</span></div>

    <p class="text-gray-300">Plugging the values of <span class="math">a, b, t, s(z,y)</span> we get that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\sum_{\\substack{i = -d \\\\ i \\neq 0}}^{d} z^i t_{g^{\\alpha x^i}}\\right) = \\left(\\sum_{\\substack{i = n - 2d \\\\ i \\neq n - d}}^{n} z^i r_{g^{\\alpha x^{i - n + d}}}\\right) \\left(\\sum_{\\substack{i = n - 2d \\\\ i \\neq n - d}}^{n} (yz)^i r_{g^{\\alpha x^{i - n + d}}} + s(z,y)\\right) \\\\ \\quad - k(y) \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_z \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{SnACSPf}}<span class="math">, we have that </span>z \\notin \\mathrm{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_z)<span class="math">. Therefore, </span>\\mathsf{SZ}(f(Z), z)<span class="math"> is false where </span>f<span class="math"> is as defined in </span>\\mathrm{CheckBad}(\\tau', z)<span class="math">. Since we have here that </span>f(z) = 0<span class="math">, the polynomial </span>f(Z)$ must</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">57</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game NWEE-1Palg:D IP,Gen (λ): tr← ε</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Oracle O1out(τ=(a1,c1,...,ai-1,ci-1),ai):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp←IP.Setup(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">If τ∈tr then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x←Gen(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">If i≤r then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run PO1out(pp,x)</td>

            <td class="px-3 py-2 border-b border-gray-700">ci←Ch; tr←tr</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(τ,ai,ci); return ci</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b←D(tr)</td>

            <td class="px-3 py-2 border-b border-gray-700">Else if i=r+1 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (b=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">d←IP.V(pp,x,τ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ai)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Game NWEE-0E,Palg:D IP,R,Gen (λ): tr← ε</td>

            <td class="px-3 py-2 border-b border-gray-700">Return d</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp←IP.Setup(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return ↓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x←Gen(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oracle O0out(τ=(a1,c1,...,ai-1,ci-1),ai):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">stE←(1λ,pp,x)</td>

            <td class="px-3 py-2 border-b border-gray-700">If τ∈tr then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run PO1out(pp,x)</td>

            <td class="px-3 py-2 border-b border-gray-700">If i≤r then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w'←E(stE,⊥)</td>

            <td class="px-3 py-2 border-b border-gray-700">(resp,stE)←E(stE,[(τ,ai)])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b←D(tr)</td>

            <td class="px-3 py-2 border-b border-gray-700">tr←tr</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(τ,ai,resp)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (b=1) ∧ (Acc(tr) ⇒ (pp,x,w')∈R)</td>

            <td class="px-3 py-2 border-b border-gray-700">Return resp</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Else if i=r+1 then  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d←IP.V(pp,x,τ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ai)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Return d  |</p>

    <p class="text-gray-300">|   | Return ↓  |</p>

    <p class="text-gray-300">Fig. 30. Definition of the security notion n-srs-wee. The games NWEE-1, NWEE-0 define n-srs-wee security in the AGM for a non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> , a distinguisher  <span class="math">\\mathcal{D}</span> , an extractor  <span class="math">\\mathcal{E}</span> , generator Gen and a public-coin interactive proof IP. We assume here that IP has  <span class="math">r = r(\\lambda)</span>  challenges and the  <span class="math">i</span> -th challenge is sampled from  <span class="math">\\mathrm{Ch}_i</span> .</p>

    <p class="text-gray-300">be the zero polynomial. In particular, its constant term must be zero. Writing out the constant term of  <span class="math">f(Z)</span>  and using  <span class="math">\\mathbf{a}_L^<em> = (r_{g^{\\alpha x^{1 - n + d}},\\ldots ,r_{g^{\\alpha x^d}}})</span> ,  <span class="math">\\mathbf{a}_R^</em> = (r_{g^{\\alpha x^{-1 - n + d}},\\ldots ,r_{g^{\\alpha x^{d - 2n}}})</span>  and  <span class="math">\\mathbf{a}_O^* = (r_{g^{\\alpha x^{-1 - 2n + d}},\\ldots ,r_{g^{\\alpha x^{d - 3n}}})</span>  we get</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} r _ {g ^ {\\alpha x d - n}} r _ {g ^ {\\alpha x d - n}} + \\left\\langle \\mathbf {a} _ {L} ^ {*} \\circ \\mathbf {a} _ {R} ^ {*} - \\mathbf {a} _ {O} ^ {*}, \\mathbf {y} _ {[ 1: ]} ^ {n + 1} + \\mathbf {y} _ {[ 1: ]} ^ {- n - 1} \\right\\rangle \\\\ + \\mathbf {y} _ {[ n + 1: ]} ^ {Q + n + 1} \\cdot \\left(\\mathbf {W} _ {L} \\cdot \\mathbf {a} _ {L} ^ {*} + \\mathbf {W} _ {R} \\cdot \\mathbf {a} _ {R} ^ {*} + \\mathbf {W} _ {O} \\cdot \\mathbf {a} _ {O} ^ {*}\\right) - \\langle \\mathbf {c}, \\mathbf {y} _ {[ n + 1: ]} ^ {Q + n + 1} \\rangle = 0 \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_y \\notin \\mathcal{T}_{\\mathrm{BadCh}}^{\\mathrm{SnACSPf}}<span class="math">  we have that  </span>y \\notin \\mathrm{BadCh}(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_y)<span class="math"> . Therefore,  </span>\\mathsf{SZ}(f(Y), y)<span class="math">  is false where  </span>f<span class="math">  is as defined in CheckBad  </span>(\\tau', y)<span class="math"> . Since we have here that  </span>f(y) = 0<span class="math"> , the polynomial  </span>f(Y)<span class="math">  is the zero polynomial. Therefore, equating all the coefficients of  </span>f(Y)$  to zero, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} _ {L} ^ {*} \\circ \\mathbf {a} _ {R} ^ {*} = \\mathbf {a} _ {O} ^ {*} \\text {a n d} \\mathbf {a} _ {L} ^ {*} \\cdot \\mathbf {W} _ {L} + \\mathbf {a} _ {R} ^ {*} \\cdot \\mathbf {W} _ {R} + \\mathbf {a} _ {O} ^ {*} \\cdot \\mathbf {W} _ {O} = \\mathbf {c}.</span></div>

    <p class="text-gray-300">The notion of srs-wee security that we defined in Section 4 allows the prover to adaptively choose its input. In the srs-wee analysis the extractor had access to the representation of the instance since the algebraic prover generated the instance. But there are scenarios where the prover may be non-adaptive and not be able to do that – for example, the input could be generated by another party, and the prover tries to prove knowledge with respect to this input. Hence this section, we consider a setting where instead of the prover adaptively choosing its input, an instance generator generates an instance which is given to the prover. For protocols where the instance contains group elements, we need an analysis entirely different from the analysis for srs-ews because here the representation of the instance will not available to the extractor.</p>

    <p class="text-gray-300">Formalizing n-srs-wee security. We formalize another notion of proof-of-knowledge (PoK) security in the AGM where the input is not generated by the prover, instead the prover is given an instance generated by an instance generator (we assume that <span class="math">\\mathsf{Gen}</span> is an algorithm that takes as input the public parameters and returns an instance <span class="math">x</span>). We give a definition along the lines of srs-wee. This new security notion called non-adaptive srs-wee or n-srs-wee is formally defined using games <span class="math">\\mathsf{NWEE-0},\\mathsf{NWEE-1}</span> in Figure 30. For an interactive proof <span class="math">\\mathsf{IP}</span>, an associated relation <span class="math">R</span> and an instance generator <span class="math">\\mathsf{Gen}</span>, non-uniform algebraic prover <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span>, a distinguisher <span class="math">\\mathcal{D}</span>, and an extractor <span class="math">\\mathcal{E}</span>, we define</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{n-sr-wee}}_{\\mathsf{IP},R,\\mathsf{Gen}}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)=\\mathsf{Pr}\\left[\\mathsf{NWEE-1}^{\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP},\\mathsf{Gen}}(\\lambda)\\right]-\\mathsf{Pr}\\left[\\mathsf{NWEE-0}^{\\mathcal{E},\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D}}_{\\mathsf{IP},R,\\mathsf{Gen}}(\\lambda)\\right]\\ .</span> (29)</p>

    <p class="text-gray-300">n-fs-ext security. We can formalize a notion of non-adaptive proof-of-knowledge (PoK) security in the AGM for non-interactive arguments obtained by applying the Fiat-Shamir transform to an interactive protocol <span class="math">\\mathsf{IP}</span> analogous to fs-ext-1 security. We can define it through a game <span class="math">\\mathsf{N-FS-EXT}</span> whose only difference from the game <span class="math">\\mathsf{FS-EXT-1}</span> is that there is an instance generator <span class="math">\\mathsf{Gen}</span> which outputs an instance <span class="math">x</span> and the prover has to output a proof for the instance <span class="math">x</span> instance of being able to choose it adaptively. For an interactive proof <span class="math">\\mathsf{IP}</span> and an associated relation <span class="math">R</span>, instance generator <span class="math">\\mathsf{Gen}</span> algebraic prover <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> and an extractor <span class="math">\\mathcal{E}</span>, we define</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{n-fs-ext}}_{\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}],\\mathsf{Gen},R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{E},\\lambda)=\\mathsf{Pr}\\left[\\mathsf{N-FS-EXT}^{\\mathcal{P}_{\\mathsf{alg}},\\mathcal{E}}_{\\mathsf{IP},R}(\\lambda)\\right]\\ .</span></p>

    <p class="text-gray-300">The following theorem connects the n-srs-wee of a public-coin protocol <span class="math">\\mathsf{IP}</span> and the n-fs-ext soundness of non-interactive protocol <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}]</span>, obtained by applying the Fiat-Shamir transform using a random oracle. Its proof is very similar to the proof of Theorem 2 and has been omitted.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">Let <span class="math">R</span> be a relation. Let <span class="math">\\mathsf{IP}</span> be a <span class="math">r=r(\\lambda)</span>-challenge public coin interactive protocol for the relation <span class="math">R</span> where the length of the <span class="math">i^{\\text{th}}</span> challenge is <span class="math">\\mathsf{cLen}_{i}(\\lambda)</span> such that <span class="math">\\mathsf{sLen}(\\lambda)\\leqslant\\mathsf{cLen}_{i}(\\lambda)\\leqslant\\mathsf{hLen}(\\lambda)</span> for <span class="math">i\\in\\{1,\\ldots,r\\}</span>. Let <span class="math">\\mathsf{Gen}</span> be an instance generator for the relation <span class="math">R</span>. Let <span class="math">\\mathcal{E}</span> be an extractor for <span class="math">\\mathsf{IP}</span> such that it always responds to queries with bit-strings of appropriate length chosen uniformly at random. We can construct an extractor <span class="math">\\mathcal{E}^{<em>}</span> for <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}]</span> such that for every non-uniform algebraic prover <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{</em>}</span> against <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}]</span> that makes <span class="math">q=q(\\lambda)</span> random oracle queries, there exists a non-uniform algebraic prover <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> and <span class="math">\\mathcal{D}</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}^{+}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{n-fs-ext}}_{\\mathsf{FS}^{\\mathsf{RO}}[\\mathsf{IP}],R}(\\mathcal{P}_{\\mathsf{alg}}^{*},\\mathcal{E},\\lambda)\\leqslant\\mathsf{Adv}^{\\mathsf{n-sr-wee}}_{\\mathsf{IP},R}(\\mathcal{P}_{\\mathsf{alg}},\\mathcal{D},\\mathcal{E},\\lambda)+\\frac{q+1}{2^{\\mathsf{sLen}(\\lambda)}}\\ .</span></p>

    <p class="text-gray-300">Moreover, <span class="math">\\mathcal{P}_{\\mathsf{alg}}</span> makes at most <span class="math">q</span> queries to its oracle and is nearly as efficient as <span class="math">\\mathcal{P}_{\\mathsf{alg}}^{<em>}</span>. The extractor <span class="math">\\mathcal{E}^{</em>}</span> is nearly as efficient as <span class="math">\\mathcal{E}</span>.</p>

    <p class="text-gray-300">n-srs-wee security of <span class="math">\\mathsf{RngPf}</span>. Among the protocols whose srs-wee security we analysed earlier, the only protocol which had a group element in its input was <span class="math">\\mathsf{RngPf}</span>. The protocols <span class="math">\\mathsf{ACSPf}</span>, <span class="math">\\mathsf{SnACSPf}</span> do not have a group element in their input and therefore their n-srs-wee security analysis would be identical to the analysis for srs-wee security. For <span class="math">\\mathsf{RngPf}</span> however, since we needed to use the representation of the element <span class="math">V</span>, which is not available in the n-srs-wee setting, we need to give a new analysis. Next, in the following theorem we analyse the n-srs-wee security of <span class="math">\\mathsf{RngPf}</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}=\\{\\mathbb{G}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}^{+}}</span> be a family of groups of order <span class="math">p=p(\\lambda)</span>. Let <span class="math">\\mathsf{RngPf}=\\mathsf{RngPf}[\\mathbb{G}]</span> be the interactive argument as defined in Figure 7, for the relation <span class="math">R</span> in (4). Let <span class="math">\\mathsf{Gen}</span> be an instance generator for</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 31. The function e for RangeProof.</p>

    <p class="text-gray-300">the relation  <span class="math">R</span> . We can construct an extractor  <span class="math">\\mathcal{E}</span>  such that for any non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  making at most  <span class="math">q = q(\\lambda)</span>  queries to its oracle, there exists a non-uniform adversary  <span class="math">\\mathcal{F}</span>  with the property that for any (computationally unbounded) distinguisher  <span class="math">\\mathcal{D}</span> , for all  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\text {R n g P f}, R, \\text {G e n}} ^ {\\text {n - s r - w e e}} \\left(\\mathcal {P} _ {\\text {a l g}}, \\mathcal {D}, \\mathcal {E}, \\lambda\\right) \\leqslant \\sqrt {\\operatorname {A d v} _ {\\mathbb {G}} ^ {\\text {d l}} (\\mathcal {F}) + \\frac {2 q (1 4 n + 8)}{p - 1} + \\frac {1}{p}}.</span></div>

    <p class="text-gray-300">Moreover, the time complexity of the extractor  <span class="math">\\mathcal{E}</span>  is  <span class="math">O(q\\cdot n)</span>  and that of adversary  <span class="math">\\mathcal{F}</span>  is  <span class="math">O(q\\cdot n)</span> .</p>

    <p class="text-gray-300">Using Theorem 8, we get the following corollary.</p>

    <p class="text-gray-300">Corollary 4. Let  <span class="math">\\mathbb{G} = \\{\\mathbb{G}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}^{+}}</span>  be a family of groups of order  <span class="math">p = p(\\lambda)</span> . Let  <span class="math">\\mathsf{RngPf} = \\mathsf{RngPf}[\\mathbb{G}]</span>  be the interactive argument as defined in Figure 7, for the relation  <span class="math">R</span>  in (4). Let  <span class="math">\\mathsf{Gen}</span>  be an instance generator for the relation  <span class="math">R</span> . Let  <span class="math">\\mathsf{FSRO}[\\mathsf{RngPf}]</span>  be the non-interactive argument obtained by applying the Fiat-Shamir transform to  <span class="math">\\mathsf{RngPf}</span>  using a random oracle. We can construct an extractor  <span class="math">\\mathcal{E}</span>  such that for any non-uniform algebraic prover  <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>  making at most  <span class="math">q = q(\\lambda)</span>  queries to the random oracle there exists a non-uniform adversary  <span class="math">\\mathcal{F}</span>  with the property that for all  <span class="math">\\lambda \\in \\mathbb{N}^{+}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathsf {F S R O} [ \\mathsf {R n g P f} ], \\mathsf {G e n}, R} ^ {\\mathsf {n - f s - e x t}} (\\mathcal {P} _ {\\mathsf {a l g}}, \\mathcal {E}, \\lambda) \\leqslant \\sqrt {\\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathsf {d l}} (\\mathcal {F}) + \\frac {2 q (1 4 n + 8)}{p - 1} + \\frac {1}{p}} + \\frac {q + 1}{p - 1}.</span></div>

    <p class="text-gray-300">Moreover, the time complexity of the extractor  <span class="math">\\mathcal{E}</span>  is  <span class="math">O(q\\cdot n)</span>  and that of adversary  <span class="math">\\mathcal{F}</span>  is  <span class="math">O(q\\cdot n)</span> .</p>

    <p class="text-gray-300">We cannot reuse the framework we developed in section 4 to prove theorem 9 because the representation of  <span class="math">V</span>  is not available. However, at the algebraic level this proof shares similarities with the proof of Theorem 4. So we provide a proof sketch omitting some details which are similar to that in Theorem 4.</p>

    <p class="text-gray-300">Proof (Sketch).</p>

    <p class="text-gray-300">Like previously, we construct an extractor  <span class="math">\\mathcal{E}</span>  that just answers challenges honestly, and applies the function e (defined in Figure 31) to a path in the execution tree which defines an accepting transcript, and returns whatever e returns. Observe from the definition of RngPf.V that if  <span class="math">\\tau</span>  as defined in (5) is an accepting transcript,</p>

    <div class="my-4 text-center"><span class="math-block">V ^ {z ^ {2}} g ^ {\\delta (y, z)} T _ {1} ^ {x} T _ {2} ^ {x ^ {2}} = g ^ {\\hat {t}} h ^ {\\beta_ {x}}.</span></div>

    <p class="text-gray-300">Now, e can plug in the representations of  <span class="math">T_{1}, T_{2}</span>  into the above equation and compute the values  <span class="math">e_{V}, e_{\\mathbf{g}}, e_{\\mathbf{h}}, e_{u}, e_{g}, e_{h}</span>  such that  <span class="math">V^{e_{V}} = \\mathbf{g}^{e_{\\mathbf{g}}} \\mathbf{h}^{e_{\\mathbf{h}}} u^{e_{u}} g^{e_{g}} h^{e_{h}}</span> . For example</p>

    <div class="my-4 text-center"><span class="math-block">e _ {g} = \\hat {t} - \\delta (y, z) - t _ {1 g} x - t _ {2 g} x ^ {2}, e _ {V} = z ^ {2} + t _ {1 V} x + t _ {2 V} x ^ {2}.</span></div>

    <p class="text-gray-300">The procedure e returns <span class="math">e_g / e_V</span> and <span class="math">e_h / e_V</span>. However, its output is a valid witness only if <span class="math">e_{\\mathbf{g}} = e_{\\mathbf{h}} = \\mathbf{0}^n, e_u = 0</span> and <span class="math">e_g / e_V \\in [0,2^n - 1]</span>.</p>

    <p class="text-gray-300">In order to upper bound the failure probability of <span class="math">\\mathbf{e}</span>, we shall again construct an adversary <span class="math">\\mathcal{H}</span> against the discrete logarithm relation problem. In this case, it would first run <span class="math">\\mathsf{Gen}</span> with its inputs and get <span class="math">V</span>. Like previously, it would run <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> on <span class="math">n, \\mathbf{g}, \\mathbf{h}, g, h, u, V</span>. If <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> manages to produce an accepting transcript <span class="math">\\tau_1</span>, <span class="math">\\mathcal{H}</span> runs <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> on <span class="math">n, \\mathbf{g}, \\mathbf{h}, g, h, u, V</span> with fresh randomness. The adversary <span class="math">\\mathcal{H}</span> needs to re-run <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> twice because the representation of <span class="math">V</span> is not available.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> manages to produce an accepting transcript <span class="math">\\tau_2</span>, <span class="math">\\mathcal{H}</span> calls a helper function <span class="math">h</span> on input <span class="math">([\\tau_1], [\\tau_2])</span> and outputs whatever <span class="math">h</span> outputs. The definition of <span class="math">h</span> is given in Figure 32.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define <span class="math">E</span> as the event that <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span> succeeds in producing an accepting transcript but <span class="math">\\mathcal{E}</span> fails. Let <span class="math">\\operatorname{Pr}[E] = \\delta</span>. Let $\\delta_V = \\operatorname{Pr}[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V]<span class="math"> and output by </span>\\mathsf{Gen}<span class="math">. It follows that </span>\\delta = \\mathsf{E}[\\delta_V]<span class="math"> where the expectation is over all </span>V<span class="math"> output by </span>\\mathsf{Gen}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We shall show that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Adv}_{\\mathbb{G}, 2n + 3}^{\\mathrm{dl-rel}}(\\mathcal{H}) \\geqslant \\mathsf{E}\\left[\\delta_V^2\\right] - \\frac{2q(14n + 8)}{p - 1}.</span></div>

    <p class="text-gray-300">Using Lemma 2 we would have that there exists an adversary <span class="math">\\mathcal{F}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{E}\\left[\\delta_V^2\\right] \\leqslant \\mathsf{Adv}_{\\mathbb{G}}^{\\mathrm{dl}}(\\mathcal{F}) + \\frac{2q(14n + 8)}{p - 1} + \\frac{1}{p}.</span></div>

    <p class="text-gray-300">Using Jensen's inequality we have that <span class="math">\\mathsf{E}\\left[\\delta_V^2\\right] \\geqslant \\left(\\mathsf{E}\\left[\\delta_V\\right]\\right)^2 = \\delta^2</span>.</p>

    <p class="text-gray-300">So, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\delta \\leqslant \\sqrt{\\operatorname{Adv}_{\\mathbb{G}}^{\\mathrm{dl}}(\\mathcal{F}) + \\frac{2q(14n + 8)}{p - 1} + \\frac{1}{p}}.</span></div>

    <p class="text-gray-300">Then, it is easy to see that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Adv}_{\\text{RngPT}, R, \\text{Gen}}^{\\text{n-sr-wee}}(\\mathcal{P}_{\\text{alg}}, \\mathcal{D}, \\mathcal{E}, \\lambda) \\leqslant \\sqrt{\\operatorname{Adv}_{\\mathbb{G}}^{\\mathrm{dl}}(\\mathcal{F}) + \\frac{2q(14n + 8)}{p - 1} + \\frac{1}{p}}.</span></div>

    <p class="text-gray-300">To conclude the proof of the theorem we need to show that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Adv}_{\\mathbb{G}, 2n + 3}^{\\mathrm{dl-rel}}(\\mathcal{H}) \\geqslant \\mathsf{E}\\left[\\delta_V^2\\right] - \\frac{2q(14n + 8)}{p - 1}.</span></div>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{H}</span> runs <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>, and it succeeds in producing accepting transcripts <span class="math">\\tau_1, \\tau_2</span> where for <span class="math">i = 1, 2</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} [\\tau_i] = \\left((n, \\mathbf{g}, \\mathbf{h}, u, g, h), V; ([A_i], [S_i]), (y_i, z_i), ([T_{i1}], [T_{i2}]), x_i, (\\beta_{ix}, \\mu_i, \\hat{t}_i), w_i, \\right. \\\\ \\left. \\left. \\left([L_{i1}], [R_{i1}]\\right), x_{i1}, \\dots, \\left([L_{i\\log n}], [R_{i\\log n}]\\right), x_{i\\log n}, (a_i, b_i)\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Define for <span class="math">i = 1, 2</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\delta(y_i, z_i) = (z_i - z_i^2) \\langle \\mathbf{1}^n, \\mathbf{y_i}^n \\rangle - z_i^3 \\langle \\mathbf{1}^n, \\mathbf{2}^n \\rangle, \\\\ v_i^* = (\\hat{t}_i - \\delta(y_i, z_i) - t_{i1g}x_i - t_{i2g}x_i^2)(z_i^2 + t_{i1V}x_i + t_{i2V}x_i^2)^{-1}, \\\\ \\gamma_i^* = (\\beta_{ix} - t_{i1h}x_i - t_{i2h}x_i^2)(z_i^2 + t_{i1V}x_i + t_{i2V}x_i^2)^{-1}. \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">E_1</span> be the event that <span class="math">\\mathcal{H}</span> runs <span class="math">\\mathcal{P}_{\\mathrm{alg}}</span>, and it succeeds in producing accepting transcripts <span class="math">\\tau_1, \\tau_2</span> and both of the following are true</p>

    <p class="text-gray-300">61</p>

    <p class="text-gray-300">Procedure h([τ1], [τ2]):</p>

    <pre><code>$//[\\tau_i] = ((n,\\mathbf{g},\\mathbf{h},u,g,h),V;([A_i],[S_i]),(y_i,z_i),([T_{i1}],[T_{i2}]),x_i,(\\beta_{ix},\\mu_i,\\dot{t}_i),w_i,([L_{i1}],[R_{i1}]),x_{i1},\\ldots ,$ $\\left([L_{i\\log n}],[R_{i\\log n}]\\right),x_{i\\log n},(a_i,b_i)$ $\\delta (Y,Z)\\gets (Z - Z^2)\\langle \\mathbf{1}^n,\\mathbf{Y}^n\\rangle -Z^3\\langle \\mathbf{1}^n,\\mathbf{2}^n\\rangle$ $e_{\\mathbf{g}}^{(1)}\\gets (z_2^2 +t_{21V}x_2 + t_{22V}x_2^2)(t_{11\\mathbf{g}}x_1 + t_{12\\mathbf{g}}x_1^2) - (z_1^2 +t_{11V}x_1 + t_{12V}x_1^2)(t_{21\\mathbf{g}}x_2 + t_{22\\mathbf{g}}x_2^2);e_{\\mathbf{h}}^{(1)}\\gets (z_2^2 +t_{21V}x_2+$ $t_{22V}x_2^2)(t_{11\\mathbf{h}}x_1 + t_{12\\mathbf{h}}x_1^2) - (z_1^2 +t_{11V}x_1 + t_{12V}x_1^2)(t_{21\\mathbf{h}}x_2 + t_{22\\mathbf{h}}x_2^2)$ $e_u^{(1)}\\gets (z_2^2 +t_{21V}x_2 + t_{22V}x_2^2)(t_{11u}x_1 + t_{12u}x_1^2) - (z_1^2 +t_{11V}x_1 + t_{12V}x_1^2)(t_{21u}x_2 + t_{22u}x_2^2);e_g^{(1)}\\gets (z_2^2 +t_{21V}x_2+$ $t_{22V}x_2^2)(\\delta (y_1,z_1) + t_{11g}x_1 + t_{12g}x_1^2 -\\dot{t}_1) - (z_1^2 +t_{11V}x_1 + t_{12V}x_1^2)(t_{21h}x_2 + t_{22h}x_2^2 -\\beta_{2x})$ $e_h^{(1)}\\gets (z_2^2 +t_{21V}x_2 + t_{22V}x_2^2)(t_{11h}x_1 + t_{12h}x_1^2 -\\beta_{1x}) - (z_1^2 +t_{11V}x_1 + t_{12V}x_1^2)(t_{21h}x_2 + t_{22h}x_2^2 -\\beta_{2x})$  If  $(e_{\\mathbf{g}}^{(1)},e_{\\mathbf{h}}^{(1)},e_{u}^{(1)},e_{g}^{(1)},e_{h}^{(1)})\\neq (\\mathbf{0}^{n},\\mathbf{0}^{n},0,0,0)$  then return  $(e_{\\mathbf{g}}^{(1)},e_{\\mathbf{h}}^{(1)},e_{u}^{(1)},e_{g}^{(1)},e_{h}^{(1)})$
For  $i = 1,2$  do
$v_{ig}\\gets (\\delta (y_i,z_i) + t_{i1g}x_i + t_{i2g}x_i^2 -\\dot{t}_i)(z_i^2 +t_{i1V}x_i + t_{i2V}x_i^2)^{-1}$ $v_{ih}\\gets (t_{i1h}x_i + t_{i2h}x_i^2 -\\beta_{ix})(z_i^2 +t_{i1V}x_i + t_{i2V}x_i^2)^{-1}$ $p_{iV}^{\\prime}\\gets a_{iV} + x_{i}s_{iV};p_{i\\mathbf{g}}^{\\prime}\\gets (a_{i\\mathbf{g}}) + x_{i}s_{i\\mathbf{g}} - z_{i}\\mathbf{1}^{n}$ $p_{i\\mathbf{h}}^{\\prime}\\gets a_{i\\mathbf{h}} + xs_{i\\mathbf{h}} + \\mathbf{y}_1^{-n}\\circ (z_i\\mathbf{y}_1^n +z_i^2\\mathbf{2}^n);p_{ig}^{\\prime}\\gets a_{ig} + x_iss_g$ $p_{ih}^{\\prime}\\gets a_{ih} + x_iss_h - \\mu_i;p_{iu}^{\\prime}\\gets a_{iu} + x_iss_u + w_i\\dot{t}_i$
For  $k = 0$  to  $n - 1$  do
$e_{g_{k + 1}}^{(i,2)}\\gets \\left(p_{ig_{1 + k}}^i +\\sum_{m = 1}^{\\log n}l_{img_{1 + k}}x_m^2 +r_{img_{1 + k}}x_m^{-2}\\right) - a\\cdot \\left(\\prod_{m = 1}^{\\log n}x_m^{(-1)^{1 - 60(k,m,\\log n)}}\\right)$ $e_{h_{k + 1}}^{(i,2)}\\gets \\left(p_{ih_{1 + k}}^i +\\sum_{m = 1}^{\\log n}l_{imh_{1 + k}}x_m^2 +r_{imh_{1 + k}}x_m^{-2}\\right) - by^{(-k)}\\cdot \\left(\\prod_{m = 1}^{\\log n}x_m^{-1})^{60(k,m,\\log n)}\\right)$ $e_{\\mathbf{g}}^{(i,2)}\\gets (e_{g_1}^{(i,2)},\\dots ,e_{g_n}^{(i,2)});\\quad e_{\\mathbf{h}}^{(i,2)}\\gets (e_{h_1}^{(i,2)},\\dots ,e_{h_n}^{(i,2)})$ $e_u^{(i,2)}\\gets \\left(p_{iu}&#x27; + \\sum_{m = 1}^{\\log n}l_{imu}x_m^2 +r_{imu}x_m^{-2}\\right) - w_i\\cdot a_ib_i$ $e_g^{(2)}\\gets \\left(\\sum_{m = 1}^{\\log n}(l_{img} + l_{imV}v_{ig})x_m^2 +(r_{img} + r_{imV}v_{ig})x_m^{-2}\\right) + p_{ig}&#x27; + p_{iV}&#x27;v_{ig}$ $e_h^{(2)}\\gets \\left(\\sum_{m = 1}^{\\log n}(l_{imh} + l_{imV}v_{ih})x_m^2 +(r_{imh} + r_{imV}v_{ih})x_m^{-2}\\right) + p_{ih}&#x27; + p_{iV}&#x27;v_{ih}$
If  $(e_{\\mathbf{g}}^{(1,2)},e_{\\mathbf{h}}^{(1,2)},e_{u}^{(1,2)},e_{g}^{(1,2)},e_{h}^{(1,2)})\\neq (\\mathbf{0}^{n},\\mathbf{0}^{n},0,0,0)$  then return  $(e_{\\mathbf{g}}^{(1,2)},e_{\\mathbf{h}}^{(1,2)},e_{u}^{(1,2)},e_{g}^{(1,2)},e_{h}^{(1,2)})$
Return  $(e_{\\mathbf{g}}^{(2,2)},e_{\\mathbf{h}}^{(2,2)},e_{u}^{(2,2)},e_{g}^{(2,2)},e_{h}^{(2,2)})$

Fig. 32. The function h for RngPf.

-  $v_{1}^{\\star} \\notin [0, 2^{n} - 1] \\vee g^{v_{1}^{\\star}} h^{\\gamma_{1}^{\\star}} \\neq V$
-  $v_{2}^{\\star} \\notin [0, 2^{n} - 1] \\vee g^{v_{2}^{\\star}} h^{\\gamma_{2}^{\\star}} \\neq V$

It is easy to see that  $\\operatorname{Pr}[E_1] = \\mathsf{E}\\left[\\delta_V^2\\right]$ . We define the pair of transcripts  $(\\tau_{1},\\tau_{2})$  to be bad if any of the following is true.

- CheckBad  $\\left[\\tau_{i}|_{w_{i}}\\right], w_{i}$  is false for  $i = 1,2$  where CheckBad  $\\left[\\tau^{\\prime}\\right], w$  is defined in Figure 8.
- CheckBad  $\\left[\\tau_{i}|_{x_{im}}\\right], x_{im}$  is false for  $i = 1,2$  and  $m = 1,\\ldots,\\log n$  where CheckBad  $\\left[\\tau^{\\prime}\\right], x_{m}$  is defined in Figure 8.
- CheckBad  $\\left[\\left[\\tau_{1}\\right], \\left[\\tau_{2}\\right], x_{1}, x_{2}\\right)$  is false where CheckBad  $\\left[\\left[\\tau_{1}\\right], \\left[\\tau_{2}\\right], x_{1}, x_{2}\\right)$  is defined in Figure 33.
- CheckBad  $\\left[\\left[\\tau_{1}\\right], \\left[\\tau_{2}\\right], \\left(y_{1}, y_{2}\\right), \\left(z_{1}, z_{2}\\right)\\right)$  is false where CheckBad  $\\left[\\left[\\tau_{1}\\right], \\left[\\tau_{2}\\right], \\left(y_{1}, y_{2}\\right), \\left(z_{1}, z_{2}\\right)\\right)$  is defined in Figure 33.

It can be shown that if  $\\mathcal{P}_{\\mathrm{alg}}$  makes at most  $q$  queries in each execution, the probability that the transcripts  $(\\tau_{1},\\tau_{2})$  are bad is at most  $\\frac{2q(14n + 8)}{p - 1}$ . The proof of this statement is similar to the proof of 5 and we omit the proof here.

First it is easy to see that the output  $h$  is always a discrete logarithm relation between  $\\mathbf{g}, \\mathbf{h}, u, g, h$  but might be a trivial relation. Now we shall show that for a fixed  $(\\tau_1, \\tau_2), h(\\tau_1, \\tau_2)$  returns a trivial

![img-9.jpeg](img-9.jpeg)
Fig. 33. The functions CheckBad function for the RngPf.

discrete logarithm relation and transcripts  $(\\tau_{1},\\tau_{2})$  are not bad then the event  $E_{1}$  cannot happen. In other words, if  $E_{1}$  happens then either  $\\mathsf{h}$  returns a non-trivial discrete logarithm relation or transcripts  $(\\tau_{1},\\tau_{2})$  are bad i.e.,

$$
\\Pr \\left[ E _ {1} \\right] \\leqslant \\operatorname {A d v} _ {\\mathbb {G}} ^ {\\mathrm {d l}} (\\mathcal {F}) + \\frac {2 q (1 4 n + 8)}{p - 1}.
$$

This would give us

$$
\\operatorname {A d v} _ {\\mathbb {G}, 2 n + 3} ^ {\\mathrm {d l - r e l}} (\\mathcal {H}) \\geqslant \\mathsf {E} \\left[ \\delta_ {V} ^ {2} \\right] - \\frac {2 q (1 4 n + 8)}{p - 1}.
$$

We shall use the approach we used in the proof of Lemma 6 to prove that for a fixed  $(\\tau_1,\\tau_2)$ ,  $\\mathsf{h}(\\tau_1,\\tau_2)$  returns a trivial discrete logarithm relation and transcripts  $(\\tau_{1},\\tau_{2})$  are not bad then the event  $E_{1}$  cannot happen. We shall first use that  $(e_{\\mathbf{g}}^{(1)},e_{\\mathbf{h}}^{(1)},e_{u}^{(1)},e_{g}^{(1)},e_{h}^{(1)}) = (\\mathbf{0}^{n},\\mathbf{0}^{n},0,0,0)$  and  $(\\tau_{1},\\tau_{2})$  is not bad to conclude that  $g^{v_1^{\\mathbf{g}}}h^{\\gamma_1^{\\mathbf{g}}} = V$  holds. First using  $e_{\\mathbf{g}}^{(1)} = \\mathbf{0}^{n}$  we get that

$$
\\left(z _ {2} ^ {2} + t _ {2 1 V} x _ {2} + t _ {2 2 V} x _ {2} ^ {2}\\right) \\left(t _ {1 1 \\mathbf {g}} x _ {1} + t _ {1 2 \\mathbf {g}} x _ {1} ^ {2}\\right) - \\left(z _ {1} ^ {2} + t _ {1 1 V} x _ {1} + t _ {1 2 V} x _ {1} ^ {2}\\right) \\left(t _ {2 1 \\mathbf {g}} x _ {2} + t _ {2 2 \\mathbf {g}} x _ {2} ^ {2}\\right) = 0
$$

Since  $(\\tau_{1},\\tau_{2})$  is not a bad transcript we can show that  $t_{11\\mathbf{g}} = \\mathbf{0}^n$ ,  $t_{12\\mathbf{h}} = \\mathbf{0}^n$ ,  $t_{21\\mathbf{g}} = \\mathbf{0}^n$ ,  $t_{21\\mathbf{h}} = \\mathbf{0}^n$ . Similarly using  $e_{\\mathbf{h}}^{(1)} = \\mathbf{0}^n$  and  $e_{u}^{(1)} = 0$  we can show that  $t_{i1\\mathbf{h}} = \\mathbf{0}^n$ ,  $t_{i2\\mathbf{h}} = \\mathbf{0}^n$ ,  $t_{iu} = 0$  for  $i = 1,2$ .

This means that we have that

$$
V ^ {z _ {1} ^ {2} + t _ {1 1 v} x _ {1} + t _ {1 2 v} x _ {1} ^ {2}} = g ^ {\\hat {t} _ {1} - \\delta (y _ {1}, z _ {1}) - t _ {1 1 g} x _ {1} - t _ {1 2 g} x _ {1} ^ {2}} h ^ {\\beta_ {1 x} - t _ {1 1 h} x _ {1} - t _ {1 2 h} x _ {1} ^ {2}}.
$$

$\\tau_{1},\\tau_{2})$ are not bad, we have that $z_{1}^{2}+t_{11v}x_{1}+t_{12v}x_{1}^{2}\\neq 0$, so $g^{v_{1}^{*}}h^{\\gamma_{1}^{*}}=V$.

Now, using $(e_{\\mathbf{g}}^{(i,2)},e_{\\mathbf{h}}^{(i,2)},e_{u}^{(i,2)},e_{g}^{(i,2)},e_{h}^{(i,2)})=(\\mathbf{0}^{n},\\mathbf{0}^{n},0,0,0)$ for $i=1,2$ and that $\\tau_{1},\\tau_{2}$ are not bad, we can conclude like in Theorem 4 (since the values ($(e_{\\mathbf{g}}^{(2)},e_{\\mathbf{h}}^{(2)},e_{u}^{(2)},e_{g}^{(2)},e_{h}^{(2)})$ and bad challenge function for challenges $w$ and $x_{i}$’s are defined identically to here) that for $i=1,2$

$\\langle a_{i\\mathbf{g}}+x_{i}s_{i\\mathbf{g}}-z_{i}\\mathbf{1}^{n},(a_{i\\mathbf{h}}+x_{i}s_{i\\mathbf{h}}+z_{i}\\mathbf{1}^{n})\\circ\\mathbf{y_{i}}^{n}+z_{i}^{2}\\mathbf{2}^{n}\\rangle=\\hat{t}_{i}\\;.$

Now, using $e_{g}^{(1)}=0$, we get that

\\[ (z_{2}^{2}+t_{21V}x_{2}+t_{22V}x_{2}^{2})(\\delta(y_{1},z_{1})+t_{11g}x_{1}+t_{12g}x_{1}^{2}-\\hat{t}_{1})=\\\\
(z_{1}^{2}+t_{11V}x_{1}+t_{12V}x_{1}^{2})(\\delta(y_{2},z_{2})+t_{21g}x_{2}+t_{22g}x_{2}^{2}\\\\
-(\\langle a_{2\\mathbf{g}}+x_{2}s_{2\\mathbf{g}}-z_{2}\\mathbf{1}^{n},(a_{2\\mathbf{h}}+x_{2}s_{2\\mathbf{h}}+z_{2}\\mathbf{1}^{n})\\circ\\mathbf{y_{2}}^{n}+z_{2}^{2}\\mathbf{2}^{n}\\rangle))\\;. \\]

Since $(\\tau_{1},\\tau_{2})$ are not bad we can show that

$(\\delta(y_{1},z_{1})+t_{11g}x_{1}+t_{12g}x_{1}^{2}-\\hat{t}_{1})(z_{1}^{2}+t_{11V}x_{1}+t_{12V}x_{1}^{2})^{-1}=\\langle a_{2\\mathbf{g}},\\mathbf{2}^{n}\\rangle\\;.$

This means that $v_{1}^{*}=\\langle a_{2\\mathbf{g}},\\mathbf{2}^{n}\\rangle$. Now plugging in the value of $\\hat{t}_{1}$ into above and using $(\\tau_{1},\\tau_{2})$ are not bad we can show that

$\\langle a_{2\\mathbf{g}},\\mathbf{2}^{n}\\rangle=\\langle a_{1\\mathbf{g}},\\mathbf{2}^{n}\\rangle\\;,\\;a_{1\\mathbf{h}}=a_{1\\mathbf{g}}-\\mathbf{1}^{n}\\;,\\;a_{1\\mathbf{h}}\\circ a_{1\\mathbf{g}}=\\mathbf{0}^{n}\\;.$

From this it follows that $\\langle a_{2\\mathbf{g}},\\mathbf{2}^{n}\\rangle\\in[0,2^{n}-1]$ i.e., $v_{1}^{*}\\in[0,2^{n}-1]$. So we have shown that $v_{1}^{*}\\in[0,2^{n}-1]$ and $g^{v_{1}^{*}}h^{\\gamma_{1}^{*}}=V$. Hence we proved that for a fixed $(\\tau_{1},\\tau_{2})$, $\\mathsf{h}(\\tau_{1},\\tau_{2})$ returns a trivial discrete logarithm relation and transcripts $(\\tau_{1},\\tau_{2})$ are not bad then the event $E_{1}$ cannot happen. This concludes the proof. ∎

Acknowledgements. We thank Joseph Jaeger for extensive discussions and his involvement in the earlier stages of this work. We thank the anonymous reviewers for helpful comments. This work was partially supported by NSF grants CNS-1930117 (CAREER), CNS-1926324, CNS-2026774, a Sloan Research Fellowship, and a JP Morgan Faculty Award.

## References

- [1] S. Goldwasser, S. Micali, and C. Rackoff, “The knowledge complexity of interactive proof-systems (extended abstract),” in *17th ACM STOC*, pp. 291–304, ACM Press, May 1985.
- [2] M. Bellare and P. Rogaway, “Random oracles are practical: A paradigm for designing efficient protocols,” in *ACM CCS 93* (D. E. Denning, R. Pyle, R. Ganesan, R. S. Sandhu, and V. Ashby, eds.), pp. 62–73, ACM Press, Nov. 1993.
- [3] V. Shoup, “Lower bounds for discrete logarithms and related problems,” in *EUROCRYPT’97* (W. Fumy, ed.), vol. 1233 of *LNCS*, pp. 256–266, Springer, Heidelberg, May 1997.
- [4] U. M. Maurer, “Abstract models of computation in cryptography (invited paper),” in *10th IMA International Conference on Cryptography and Coding* (N. P. Smart, ed.), vol. 3796 of *LNCS*, pp. 1–12, Springer, Heidelberg, Dec. 2005.
- [5] G. Fuchsbauer, E. Kiltz, and J. Loss, “The algebraic group model and its applications,” in *CRYPTO 2018, Part II* (H. Shacham and A. Boldyreva, eds.), vol. 10992 of *LNCS*, pp. 33–62, Springer, Heidelberg, Aug. 2018.
- [6] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell, “Bulletproofs: Short proofs for confidential transactions and more,” in *2018 IEEE Symposium on Security and Privacy*, pp. 315–334, IEEE Computer Society Press, May 2018.
- [7] “Monero to become first billion-dollar crypto to implement ‘bulletproofs’ tech.” https://www.coindesk.com/monero-to-become-first-billion-dollar-crypto-to-implement-bulletproofs-tech.
-

8. “Signal adds a payments feature—with a privacy-focused cryptocurrency.” https://www.wired.com/story/signal-mobilecoin-payments-messaging-cryptocurrency/.
- [9] J. Nick, T. Ruffing, Y. Seurin, and P. Wuille, “MuSig-DN: Schnorr multi-signatures with verifiably deterministic nonces.” Cryptology ePrint Archive, Report 2020/1057, 2020. https://eprint.iacr.org/2020/1057.
- [10] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit, “Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting,” in EUROCRYPT 2016, Part II (M. Fischlin and J.-S. Coron, eds.), vol. 9666 of LNCS, pp. 327–357, Springer, Heidelberg, May 2016.
- [11] J. Jaeger and S. Tessaro, “Expected-time cryptography: Generic techniques and applications to concrete soundness,” in TCC 2020, Part III (R. Pass and K. Pietrzak, eds.), vol. 12552 of LNCS, pp. 414–443, Springer, Heidelberg, Nov. 2020.
- [12] A. Fiat and A. Shamir, “How to prove yourself: Practical solutions to identification and signature problems,” in CRYPTO’86 (A. M. Odlyzko, ed.), vol. 263 of LNCS, pp. 186–194, Springer, Heidelberg, Aug. 1987.
- [13] J. Groth, “On the size of pairing-based non-interactive arguments,” in EUROCRYPT 2016, Part II (M. Fischlin and J.-S. Coron, eds.), vol. 9666 of LNCS, pp. 305–326, Springer, Heidelberg, May 2016.
- [14] E. Ben-Sasson, A. Chiesa, and N. Spooner, “Interactive oracle proofs,” in TCC 2016-B, Part II (M. Hirt and A. D. Smith, eds.), vol. 9986 of LNCS, pp. 31–60, Springer, Heidelberg, Oct. / Nov. 2016.
- [15] J. Holmgren, “On round-by-round soundness and state restoration attacks.” Cryptology ePrint Archive, Report 2019/1261, 2019. https://eprint.iacr.org/2019/1261.
- [16] Y. Lindell, “Parallel coin-tossing and constant-round secure two-party computation,” in CRYPTO 2001 (J. Kilian, ed.), vol. 2139 of LNCS, pp. 171–189, Springer, Heidelberg, Aug. 2001.
- [17] J. Groth and Y. Ishai, “Sub-linear zero-knowledge argument for correctness of a shuffle,” in EUROCRYPT 2008 (N. P. Smart, ed.), vol. 4965 of LNCS, pp. 379–396, Springer, Heidelberg, Apr. 2008.
- [18] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn, “Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings,” in ACM CCS 2019 (L. Cavallaro, J. Kinder, X. Wang, and J. Katz, eds.), pp. 2111–2128, ACM Press, Nov. 2019.
- [19] R. S. Wahby, I. Tzialla, a. shelat, J. Thaler, and M. Walfish, “Doubly-efficient zkSNARKs without trusted setup,” in 2018 IEEE Symposium on Security and Privacy, pp. 926–943, IEEE Computer Society Press, May 2018.
- [20] J. Lee, “Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments,” Cryptology ePrint Archive:2020/1274, 2020.
- [21] B. Bünz, B. Fisch, and A. Szepieniec, “Transparent SNARKs from DARK compilers,” in EUROCRYPT 2020, Part I (A. Canteaut and Y. Ishai, eds.), vol. 12105 of LNCS, pp. 677–706, Springer, Heidelberg, May 2020.
- [22] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. P. Ward, “Marlin: Preprocessing zkSNARKs with universal and updatable SRS,” in EUROCRYPT 2020, Part I (A. Canteaut and Y. Ishai, eds.), vol. 12105 of LNCS, pp. 738–768, Springer, Heidelberg, May 2020.
- [23] R. Canetti, Y. Chen, J. Holmgren, A. Lombardi, G. N. Rothblum, and R. D. Rothblum, “Fiat-Shamir from simpler assumptions.” Cryptology ePrint Archive, Report 2018/1004, 2018. https://eprint.iacr.org/2018/1004.
- [24] R. Canetti, Y. Chen, J. Holmgren, A. Lombardi, G. N. Rothblum, R. D. Rothblum, and D. Wichs, “Fiat-Shamir: from practice to theory,” in 51st ACM STOC (M. Charikar and E. Cohen, eds.), pp. 1082–1090, ACM Press, June 2019.
- [25] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan, “Algebraic methods for interactive proof systems,” in 31st FOCS, pp. 2–10, IEEE Computer Society Press, Oct. 1990.
- [26] I. Haitner, “A parallel repetition theorem for any interactive argument,” in 50th FOCS, pp. 241–250, IEEE Computer Society Press, Oct. 2009.
- [27] J. Håstad, R. Pass, D. Wikström, and K. Pietrzak, “An efficient parallel repetition theorem,” in TCC 2010 (D. Micciancio, ed.), vol. 5978 of LNCS, pp. 1–18, Springer, Heidelberg, Feb. 2010.
- [28] K.-M. Chung and F.-H. Liu, “Parallel repetition theorems for interactive arguments,” in TCC 2010 (D. Micciancio, ed.), vol. 5978 of LNCS, pp. 19–36, Springer, Heidelberg, Feb. 2010.
- [29] I. Berman, I. Haitner, and E. Tsfadia, “A tight parallel repetition theorem for partially simulatable interactive arguments via smooth KL-divergence,” in CRYPTO 2020, Part III (D. Micciancio and T. Ristenpart, eds.), vol. 12172 of LNCS, pp. 544–573, Springer, Heidelberg, Aug. 2020.
- [30] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward, “Aurora: Transparent succinct arguments for R1CS,” in EUROCRYPT 2019, Part I (Y. Ishai and V. Rijmen, eds.), vol. 11476 of LNCS, pp. 103–128, Springer, Heidelberg, May 2019.
- [31] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev, “Scalable zero knowledge with no trusted setup,” in CRYPTO 2019, Part III (A. Boldyreva and D. Micciancio, eds.), vol. 11694 of LNCS, pp. 701–732, Springer, Heidelberg, Aug. 2019.
- [32] B. Bünz, M. Maller, P. Mishra, N. Tyagi, and P. Vesely, “Proofs for inner pairing products and applications,” Cryptology ePrint Archive:2019/1177, 2020.

33. G. Fuchsbauer, A. Plouviez, and Y. Seurin, “Blind schnorr signatures and signed ElGamal encryption in the algebraic group model,” in *EUROCRYPT 2020, Part II* (A. Canteaut and Y. Ishai, eds.), vol. 12106 of *LNCS*, pp. 63–95, Springer, Heidelberg, May 2020.
34. A. Ghoshal and S. Tessaro, “Tight state-restoration soundness in the algebraic group model.” Cryptology ePrint Archive, Report 2020/1351, 2020. https://eprint.iacr.org/2020/1351.

## Supplementary Materials

## Appendix A Concurrent work by Bünz et. al.

Bünz et. al. *[32]* analyse the soundness of the non-interactive protocol obtained by applying the Fiat-Shamir transform to a generalized version of the inner-product argument of Bulletproofs in the AGM. Their analysis is asymptotic and they do not give a concrete bound in the paper.

However, as far as we can tell, making their analysis concrete against an algebraic $t$-time prover making $q$ random oracle queries would give a bound which contains the term $\\sqrt{q\\cdot\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)}$. In fact, we think this term may be larger, and of order $q\\sqrt{q\\cdot\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)}=\\sqrt{q^{3}\\cdot\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)}$, but we are not sure due to a lack of concrete analysis in the paper. This bound is not tight – the multiplicative factor of $q$ before the $\\mathsf{Adv}_{\\mathbb{G}}^{\\mathsf{dl}}(t)$ term is due to reduction to a problem that does not have a tight reduction to the discrete logarithm problem.

This multiplicative factor of $q$ would already be a problem. In the generic-group model, for example, this would result in a term $qt^{2}/p\\approx t^{3}/p$ (assuming $q\\approx t$), which only gives us roughly $85$ bits of security on a $256$-bit curve.

In our analysis, we give a single reduction to the discrete logarithm relation problem whose hardness is tightly implied by the hardness of discrete logarithm problem, we avoid this multiplicative factor.

Additionally, analysing the inner product argument in the AGM in isolation does not directly give the soundness bound for the full protocol because the bases to which elements are described are not necessarily the same as those that would be available to a cheating algebraic prover against the full protocol.</code></pre>`;
---

<BaseLayout title="Tight State-Restoration Soundness in the Algebraic Group Mod... (2020/1351)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1351
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
