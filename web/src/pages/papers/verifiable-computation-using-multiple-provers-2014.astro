---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/846';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Verifiable computation using multiple provers';
const AUTHORS_HTML = 'Andrew J.  Blumberg, Justin Thaler, Victor Vu, Michael Walfish';

const CONTENT = `    <p class="text-gray-300">Andrew J. Blumberg\\* Justin Thaler† Victor Vu‡ Michael Walfish§</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">The increasing ubiquity of the cloud computing paradigm has renewed focus on the classical problem of allowing weak clients to check the results of computation <em>delegated</em> to powerful servers. Recent advances in proof-based verifiable computation have led to several near-practical protocols. Protocols based on <em>interactive proofs</em> (IPs) work with highly restrictive models of computation and are thus efficient only for a limited class of computations. In contrast, protocols based on <em>argument systems</em> apply to a much larger class of computations, but efficiency requires amortization of very expensive setup costs.</p>

    <p class="text-gray-300">This paper initiates the study of the practical efficiency of <em>multiprover interactive proofs</em> (MIPs). We present a new MIP for delegating computation that extends insights from a powerful IP protocol (Goldwasser et al., STOC, 2008). Without reductions or amplification, our protocol uses only two provers (departing from prior work on MIPs), and achieves both the efficiency of interactive proof-based protocols and the generality of argument system-based protocols. Also, this result, together with recently developed machinery, creates a potential avenue toward concretely efficient arguments <em>without</em> setup costs.</p>

    <p class="text-gray-300">We describe Clover, a built system for verifiable computation, based on our protocol. Although Clover does not implement the full theory (it has setup costs), it applies to problems that existing IPs cannot efficiently handle, and achieves performance comparable to, or better than, the best argument systems.</p>

    <p class="text-gray-300"><sup>\\*</sup>The University of Texas at Austin</p>

    <p class="text-gray-300"><sup>†</sup>Yahoo! Labs. The majority of this work was performed while the author was a graduate student at Harvard University. Supported by an NSF Graduate Research Fellowship.</p>

    <p class="text-gray-300"><sup>‡</sup> Sandia National Laboratories</p>

    <p class="text-gray-300"><sup>§</sup>New York University</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">In recent years, the rise of cloud computing has renewed interest in the problem of how a weak client can verifiably outsource computation to a powerful but untrusted server. As a motivating example, suppose that a client wants to use the cloud to perform an expensive computation. There are many potential sources of error in the results, including bugs in the server, hardware failures, and malicious behavior. In such applications, it is often infeasible for the client to locally verify the correctness of the results.</p>

    <p class="text-gray-300">There are many solutions to this problem (e.g., replication <a href="#page-15-0">\\[6,</a> <a href="#page-16-0">29,</a> <a href="#page-16-1">45,</a> <a href="#page-17-0">50,</a> [55\\]](#page-17-1), trusted hardware <a href="#page-16-2">\\[30,</a> [65\\]](#page-17-2), attestation <a href="#page-15-1">\\[5,</a> <a href="#page-17-3">56,</a> <a href="#page-17-4">62,</a> <a href="#page-17-5">66,</a> <a href="#page-17-6">67,</a> [73\\]](#page-17-7), or auditing <a href="#page-16-1">\\[45,</a> <a href="#page-16-3">47,</a> [59\\]](#page-17-8)) that make strong assumptions about the usage model or setup (e.g., uncorrelated errors, a chain of trust, intermediate results amenable to checking, etc.).</p>

    <p class="text-gray-300">It has long been known that there are theoretical solutions to this problem that make no such assumptions other than perhaps standard cryptographic ones <a href="#page-15-2">\\[8,</a> <a href="#page-15-3">9,</a> <a href="#page-16-4">40,</a> <a href="#page-16-4">40,</a> <a href="#page-16-5">42,</a> <a href="#page-16-6">46,</a> <a href="#page-17-9">51,</a> <a href="#page-17-10">54,</a> [72\\]](#page-17-11). Roughly speaking, the client, or <em>verifier</em>, and server, or <em>prover</em>, represent a high-level program as a circuit; verification consists of the prover using cryptographic or complexity-theoretic machinery to convince the verifier that it holds a valid assignment to the wires of the circuit. Recently, there has emerged a new area of secure systems research, called proof-based verifiable computation [\\[78\\]](#page-17-12), that strives to build real systems using refinements of the theory <a href="#page-15-4">\\[17,</a> <a href="#page-15-5">18,</a> <a href="#page-16-7">26,</a> <a href="#page-16-8">31,</a> <a href="#page-17-13">61,</a> <a href="#page-17-14">68</a><a href="#page-17-15">–71,</a> <a href="#page-17-16">75,</a> [76\\]](#page-17-17). Principal goals of these systems are to have minimal overhead for the prover and for verification to be cheaper for the verifier than doing the computation locally.</p>

    <p class="text-gray-300">Three approaches have been implemented. The first is based on <em>interactive proofs</em> (IPs) <a href="#page-15-6">\\[11,</a> <a href="#page-16-4">40,</a> <a href="#page-16-5">42,</a> <a href="#page-17-10">54,</a> [72\\]](#page-17-11) and is due to Cormode et al. (CMT) <a href="#page-16-8">\\[31,</a> <a href="#page-17-18">74,</a> [75\\]](#page-17-16), who refined the GKR protocol [\\[40\\]](#page-16-4). The second approach combines cryptographic commitments [\\[51\\]](#page-17-9) with probabilistically checkable circuit encodings (of the kind that appear in probabilistically checkable proofs, or PCPs <a href="#page-15-2">\\[8,</a> [9\\]](#page-15-3)) to obtain efficient <em>argument systems</em> [\\[25\\]](#page-16-9) (i.e., interactive proofs secure only against polynomial-time provers). Setty et al. <a href="#page-16-7">\\[26,</a> <a href="#page-17-19">69–</a>[71\\]](#page-17-15) build on work of Ishai et al. [\\[46\\]](#page-16-6) and GGPR [\\[37\\]](#page-16-10). The third approach is based on <em>non-interactive</em> arguments (also known as SNARGs [\\[39\\]](#page-16-11) or SNARKs [\\[21\\]](#page-16-12)). Parno et al. describe a system [\\[61\\]](#page-17-13) that realizes the full promise of GGPR [\\[37\\]](#page-16-10); Ben-Sasson et al. <a href="#page-15-4">\\[17,</a> [18\\]](#page-15-5) likewise build on GGPR and several other works <a href="#page-15-7">\\[15,</a> [24\\]](#page-16-13).</p>

    <p class="text-gray-300">The IP-based approach of CMT has a number of advantages. Most notably, for circuits with <em>regular</em> wiring patterns (defined formally in <a href="#page-11-0">§4.5.3;</a> roughly, the circuit consists of repeated, structurally similar blocks <a href="#page-16-8">\\[31,</a> [74\\]](#page-17-18)), CMT does not require preprocessing, has a highly efficient verifier, and achieves extremely low overhead for the prover [\\[74\\]](#page-17-18) (small constant factors over native execution). By contrast, the argument systems require an expensive preprocessing stage for the verifier and have very high prover overhead. On the other hand, CMT is less general. It applies only to small-depth circuits (i.e., parallelizable computation). And it does not support <em>non-deterministic circuits</em>, which can be extremely useful for representing high-level programs as circuits <a href="#page-15-7">\\[15,</a> <a href="#page-15-4">17,</a> <a href="#page-16-7">26,</a> <a href="#page-17-13">61,</a> <a href="#page-17-19">69,</a> [71\\]](#page-17-15); operations such as random memory access and comparisons, among others, are problematic for interactive proofs but not argument systems.</p>

    <p class="text-gray-300">Our goal in this paper is to develop a protocol that simultaneously achieves the efficiency of CMT and the generality of the argument systems. To accomplish this, we give up on the single prover of prior built systems. Instead, we develop a practical implementation of <em>multi-prover interactive proofs</em> (MIPs), using CMT as a base. Specifically, our protocol uses <em>two</em> provers, and provided that the provers do not communicate once the interrogation phase of the protocol begins, the verifier will detect arbitrary error or misbehavior on their part.</p>

    <p class="text-gray-300">Motivation. We have two reasons to study the practical efficiency of MIPs. First, although the MIP model (stated above) is not always appropriate, it does correspond to some realistic scenarios: namely, those in which there is replication but in which we do not want to assume that at least one of the replicas functions correctly. (Indeed, if we are willing to assume that at least one of the replicas performs correctly, one can use Refereed games and related protocols <a href="#page-16-14">\\[27,</a> <a href="#page-16-15">28,</a> [52\\]](#page-17-20), as noted in Section <a href="#page-2-0">2.</a>) Examples include the growing use of efficient yet unreliable hardware, or a single cloud provider with a homogenous platform. In these cases, many nodes (and hence both "provers") can fail simultaneously. More broadly, the MIP model applies whenever one would use (Byzantine Fault-Tolerant) replication <a href="#page-15-8">\\[4,</a> <a href="#page-15-0">6,</a> <a href="#page-16-0">29,</a> [55\\]](#page-17-1); however, unlike replication, the MIP model tolerates correlated error.</p>

    <p class="text-gray-300">Our second motivation stems from intense recent interest in non-interactive and succint arguments [17, 21, 22, 24, 32, 33, 37, 41, 43, 53, 58, 61], especially SNARKs (succinct non-interactive arguments of knowledge) without preprocessing. Bitansky and Chiesa [23] give a powerful technique for obtaining such SNARKs; using fully-homomorphic encryption (FHE) [38], they compile any complexity preserving MIP that also has a proof-of-knowledge (PoK) property into a complexity preserving SNARK (under a natural but non-standard assumption). This reduction (and other closely related ones [3, 35, 48, 49]) creates a potential avenue toward a concretely efficient SNARK: (1) develop a more practical compiler (in particular, one not based on FHE), and (2) develop a complexity preserving MIP with PoK that has inexpensive concrete costs (few provers, few queries, etc.). In this work, we focus on the second of these prongs, in the hope that future work will target the first. Of course, Bitansky and Chiesa also describe a complexity preserving MIP with PoK, but it has substantially higher quantitative costs, as discussed in Sections 2 and 4.5.3.</p>

    <p class="text-gray-300"><strong>Summary of contributions.</strong> This paper contains both theoretical contributions and systems innovations. As our primary contribution, we describe a new MIP (with PoK) for the problem of non-deterministic circuit evaluation (§3–§4). Our MIP improves on prior work by several logarithmic factors (which reduces concrete costs substantially). Also, ours is the first complexity preserving MIP that has two provers and requires only one protocol repetition. Our protocol combines several new ideas (a new circuit arithmetization and a soundness analysis that avoids repetition, as outlined in Section 4), with existing ideas [12, 31, 40, 76].</p>

    <p class="text-gray-300">We also describe a built system, called <em>Clover</em> (Section 5); given code written in a subset of C, Clover produces a verifier and provers that implement the protocol. This system allows us to perform a preliminary evaluation of the concrete efficiency properties of our MIP (§6). We find that Clover has better applicability than existing IP-based approaches (i.e., CMT) and better efficiency than existing argument-based approaches. However, Clover does not implement our MIP in full generality; specifically, Clover requires preprocessing (also known as setup costs for the verifier). The reason for the discrepancy is that our MIP avoids preprocessing only for regular circuits and Clover does not yet produce such circuits for general-purpose computations. (However, such circuits exist in principle: we show that the RAM-into-circuit techniques of Ben-Sasson et al. [15] can be modified to yield regular circuits.) Instead, Clover applies techniques [70, 71, 76] that produce <em>ir</em> regular circuits. Amortizing the resulting setup costs requires working over a <em>batch</em> of computation instances (the same computation, with different inputs). While not ideal, the restriction is not disastrous: this model is encountered in realistic applications of cloud computing (MapReduce, other data parallel computations, etc.).</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2 Related work</h4>

    <p class="text-gray-300">Although there has been a great deal of classical systems work on verifiable computation, the majority of the literature either makes strong assumptions about the usage model (e.g., trusted hardware) or is special-purpose. See for example [61, 62, 70] for partial surveys of the area. Herein we focus on the recent body of work on proof-based verifiable computation, and the tools it draws on.</p>

    <p class="text-gray-300"><strong>GKR-CMT.</strong> We described GKR-CMT [31, 40, 74, 76] in the introduction; our MIP extends several ideas from this protocol, achieving the following advantages. First, our protocol's costs depend logarithmically on the circuit's size, with no dependence on the depth. In GKR-CMT, by contrast, the verifier's costs grow logarithmically in the circuit's size and <em>linearly</em> in the depth, rendering the protocol inapplicable to deep circuits. Second, our protocol does not require circuits to be layered, leading to much smaller circuit representations. Third, our protocol requires fewer rounds, improving over GKR-CMT by a factor equal to the circuit depth. Fourth, our protocol handles non-deterministic circuits; this permits the use of efficient reductions from high-level programs to circuits [15, 61, 69, 76], a point we elaborate on below.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>1</sup>An argument system or MIP is <em>complexity preserving</em> if when applied to a computation that can be solved by a (non-deterministic) Random Access Machine that runs in time T(n) and space S(n), the verifier runs in time  <span class="math">\\tilde{O}(n)</span> , and the provers run in total time  <span class="math">\\tilde{O}(T(n))</span>  and space  <span class="math">\\tilde{O}(S(n))</span> . Here, n is the size of the input to the RAM, and the  <span class="math">\\tilde{O}</span>  notation hides factors polylogarithmic in T(n).</p>

    <p class="text-gray-300"><strong>Fast reductions from RAMs to circuits.</strong> Ben-Sasson et al. [15], building on foundational work by, e.g., Gurevich and Shelah [44] and Robson [63], develop efficient methods for turning high-level programs (non-deterministic RAMs) into non-deterministic circuits. We adapt the techniques of [15] to construct circuits that compose with our MIP.</p>

    <p class="text-gray-300"><strong>Prior work on MIPs.</strong> Babai et al. famously proved that MIP=NEXP [12]: the class of problems solvable by multi-prover interactive proofs with a polynomial-time verifier equals the class of languages solvable in non-deterministic exponential time. The protocol that they use in their proof inspired a number of our techniques. In both protocols, the verifier runs a sum-check protocol (§3.3) with one prover to determine whether some polynomial identity holds, and then asks another prover for help in performing the final check.</p>

    <p class="text-gray-300">The actual polynomial identity that we use differs substantially from that of Babai et al. Moreover, their analysis assumes that provers are non-adaptive. While a protocol secure against non-adaptive provers can always be transformed into one secure against adaptive provers [14, 36], these transformations either use many provers or require repeating the protocol many times, leading to unacceptable concrete costs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As stated in the introduction, Bitansky and Chiesa also do foundational work in MIPs, in particular giving the first (and, prior to our work, the only) complexity preserving MIP [23]. However, their MIP has substantially higher quantitative costs than ours, particularly for the provers. In our MIP, both provers run in  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time for a given circuit  </span>\\mathcal{C}<span class="math"> . While [23] does not include a careful accounting of logarithmic factors, we estimate that even an optimized implementation of the MIP described in [23] requires total runtime at least  </span>\\tilde{\\Omega}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  for the provers, where  </span>\\tilde{\\Omega}<span class="math">  hides factors of  </span>\\log\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ . (In Section 4, we briefly describe the reasons for these higher costs.) In addition, the MIP of [23] requires either hundreds of provers or else thousands of repetitions.<sup>2</sup></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One might wonder whether state of the art PCPs, together with parallel repetition, would lead to 2-prover complexity preserving MIPs. The answer is no, because the work required to construct the PCP does not preserve the prover's space complexity.</p>

    <p class="text-gray-300"><strong>Refereed games and refereed delegation of computation.</strong> Recent work in the setting of <em>refereed games</em> [28, 52] and <em>refereed delegation of computation</em> (RDoC) [27] has provided verifiable computation protocols using two provers. These approaches assume that at least one of the provers is honest (the difference between them is that refereed games provide information-theoretic security, while RDoC protocols are secure against polynomial time provers). By contrast, MIPs do not assume that <em>either</em> of the provers is honest.</p>

    <p class="text-gray-300">Canetti et al. [27] report on an RDoC implementation that, for some computations, achieves a slowdown for the prover of a factor of 8. While our MIPs cannot compete with this efficiency, the assumption of a correct and honest prover is not suitable for all cryptographic settings, as noted in the introduction. Moreover, it is MIPs' combination of information-theoretic security and security, even when all provers are dishonest, that allows them to be compiled into single-prover arguments [23, 49].</p>

    <p class="text-gray-300"><strong>Argument systems without pre-processing.</strong> A standard technique for producing argument systems is to compile one from a short PCP [8, 9, 19, 20, 34], using collision-resistant hash functions [13, 51, 57]. Ben-Sasson et al. [15, 16] focus on reducing the concrete costs of short PCPs, toward a potentially practical solution. On the one hand, such an approach is appealing: there is no preprocessing for the verifier. On the other, although we do not know the concrete costs (existing work on this topic is still theoretical, though implementation efforts are reportedly underway), they are likely to be quite high: the short PCPs in [16] require many repetitions for soundness amplification.</p>

    <p class="text-gray-300"><strong>Argument systems with pre-processing.</strong> Ishai et al. [46] obtain interactive argument systems, using <em>long</em> PCPs (short PCPs are complicated and often a bottleneck); however, the verifier requires pre-processing. Gennaro et al. (GGPR) [37], working in a similar model to [43, 53], use an ingenious encoding of circuits to</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>2</sup>The reason for this tradeoff is that a generic reduction [14] from m to 2 provers yields a soundness error of 1 - 1/m, which in turn would require thousands of repetitions to drive the soundness error below, say, one part in one million.</p>

    <p class="text-gray-300">construct efficient <em>non-interactive</em> argument systems that also avoid short PCPs. This work is the theoretical foundation of several of the built systems described below.</p>

    <p class="text-gray-300">SNARKs. SNARKs are a kind of non-interactive argument. At a high level, there are four known techniques for constructing SNARKs. We break these down into two sub-classes:</p>

    <p class="text-gray-300"><em>Non-complexity preserving SNARKs.</em> One can construct SNARKs by compiling them from short PCPs using <em>extractable collision resistant hash functions</em> <a href="#page-16-12">\\[21,</a> <a href="#page-16-17">32,</a> <a href="#page-16-18">33,</a> <a href="#page-16-19">41,</a> [58\\]](#page-17-22). However, this approach does not directly yield complexity preserving SNARKs because existing fast constructions of short PCPs do not preserve the space complexity of the prover. A second approach avoids short PCPs but requires a costly pre-processing stage for the verifier (see argument systems with pre-processing above) <a href="#page-16-13">\\[24,</a> <a href="#page-16-10">37,</a> <a href="#page-16-20">43,</a> [53\\]](#page-17-21).</p>

    <p class="text-gray-300"><em>Complexity preserving SNARKs.</em> A third approach to constructing SNARKs is compiling them from MIPs of knowledge [\\[23\\]](#page-16-21), as discussed in the introduction. If the original MIP is complexity preserving, the resulting SNARK is too (the resulting SNARK is <em>designated-verifier</em>). A fourth method, <em>bootstrapping</em> [\\[22\\]](#page-16-16), uses an "inefficient" SNARK to produce one that is both publicly verifiable and complexity preserving. While bootstrapping yields remarkable asymptotic results, the approach is intrinsically indirect (roughly speaking, it requires running the inefficient SNARK on many sub-computations).</p>

    <p class="text-gray-300">Built systems. CMT [\\[31\\]](#page-16-8) implements the interactive proof of GKR [\\[40\\]](#page-16-4); Vu et al. incorporate refinements into a system called Allspice [\\[76\\]](#page-17-17), and Thaler [\\[74\\]](#page-17-18) accelerates the prover. In another line of work, Setty et al. <a href="#page-17-19">\\[69–</a>[71\\]](#page-17-15) refine the argument protocol of Ishai et al. [\\[46\\]](#page-16-6); the best-performing in this line is called Zaatar.<sup>3</sup> Parno et al. realize the SNARKs of GGPR [\\[37\\]](#page-16-10) in Pinocchio [\\[61\\]](#page-17-13). Ben-Sasson et al. <a href="#page-15-4">\\[17,</a> [18\\]](#page-15-5) borrow and optimize this SNARK and combine it with the RAM-to-circuit reductions described above [\\[15\\]](#page-15-7); we will refer to this work as BCTV. Pantry [\\[26\\]](#page-16-7) builds on Zaatar [\\[69\\]](#page-17-19) and Pinocchio; it compiles C to SNARKs (as does BCTV), handles programs that work with RAM (as does BCTV), and computations that work with external state (which BCTV does not handle). Finally, Buffet [\\[77\\]](#page-17-26) incorporates the best features of Pantry and BCTV.</p>

    <p class="text-gray-300">Each of these systems separates into a front-end (an algorithm that transforms a high-level program into a circuit) and a back-end (the "proof machinery"). The approaches built on GKR-CMT have the most efficient back-end when they apply, but their applicability is limited, as noted earlier. The back-ends of Zaatar and Pinocchio have the same rough efficiency as each other. However, Pinocchio provides non-interactivity and zero-knowledge (by definition), which Zaatar does not (neither does GKR-CMT). The remaining differences in the systems (Pinocchio, Pantry, BCTV, Buffet) concern the <em>front-ends</em>; this is because all of these systems are built on the same back-end, namely the protocol of Pinocchio (whose parameters are optimized by BCTV). Of these systems, Buffet's circuits are equal or better in efficiency than its predecessors (the differences approach two orders of magnitude for computations that interact with RAM), with almost no sacrifice of expressiveness relative to the most expressive system (which is BCTV).</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 Problem statement: multi-prover interactive proofs</h3>

    <p class="text-gray-300">We begin by defining multi-prover interactive proofs (MIPs). We primarily consider two-prover protocols and specialize the definition to this case.</p>

    <p class="text-gray-300">Definition 3.1. A two-prover interactive proof protocol for a language L ⊆ {0, 1} ∗ involves three parties: a probabilistic <em>verifier</em> and two <em>provers</em>. The verifier exchanges a sequence of messages with each prover; each prover's message is a function of the input message and the messages that it has seen so far. At the end of the interaction, the verifier outputs 0 or 1. (V,P1,P2) form a two-prover interactive protocol for L if the following two conditions are satisfied, where the probabilities below are taken over V's internal randomness.</p>

    <p class="text-gray-300"><sup>3</sup>The argument protocol underlying <a href="#page-17-19">\\[69</a>[–71\\]](#page-17-15) can also be modified to yield a two-prover MIP. The major advantage of our MIP over this alternative is that the latter inherently requires an expensive pre-processing phase for the verifier that we can avoid.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Completeness</em>: For any input  <span class="math">x \\in \\mathcal{L}</span> , the verifier  <span class="math">\\mathcal{V}</span>  outputs 1 with probability 1 when interacting with provers  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span> .</li>

      <li><em>Soundness</em>: For all  <span class="math">x \\notin \\mathcal{L}</span>  and all provers  <span class="math">\\mathcal{P}_1^<em></span> ,  <span class="math">\\mathcal{P}_2^</em></span> , the probability that  <span class="math">\\mathcal{V}</span>  outputs 1 on input x when interacting with  <span class="math">\\mathcal{P}_1^<em></span>  and  <span class="math">\\mathcal{P}_2^</em></span>  is at most  <span class="math">\\epsilon</span> , for some  <span class="math">\\epsilon &lt; 1/3</span> . The parameter  <span class="math">\\epsilon</span>  is called the <em>soundness error</em> of the protocol.</li>

    </ul>

    <p class="text-gray-300">For simplicity, we will often refer to two-prover interactive proofs simply as MIPs. We also consider functions  <span class="math">f: \\{0,1\\}^<em> \\to \\mathcal{R}</span> , for a finite range  <span class="math">\\mathcal{R}</span> , rather than languages. An </em>MIP for f* is an MIP for the language  <span class="math">\\{(x,f(x))\\}</span> . We will sometimes consider MIPs for functions f with k>1 outputs; to apply the definition above to such functions, we interpret a k-tuple of outputs over range  <span class="math">\\mathcal{R}</span>  as a single output over the larger range  <span class="math">\\mathcal{R}^k</span> . Clearly an MIP for f is interesting only if it is cheaper for  <span class="math">\\mathcal{V}</span>  than computing f unaided. We remark that the requirement of  <span class="math">\\epsilon &lt; 1/3</span>  is chosen for consistency with the MIP literature (see e.g. [7, Chapter 8]); in our implementation,  <span class="math">\\epsilon</span>  will be less than  <span class="math">2^{-23}</span> . Finally, a prover may in practice not be a single machine (e.g., a prover may be implemented on a compute cluster).</p>

    <p class="text-gray-300"><strong>Cost model.</strong> Whenever we work over a finite field  <span class="math">\\mathbb{F}</span> , we assume that a single field operation can be computed in a single machine operation.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">3.2 Other definitions</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Circuits and transcripts.</strong> A <em>arithmetic circuit</em>  <span class="math">\\mathcal{C}</span>  is defined over a field  <span class="math">\\mathbb{F}</span>  and has input gates, output gates, intermediate gates, and directed wires between them. Each gate computes addition or multiplication over  <span class="math">\\mathbb{F}</span> .  <span class="math">\\mathcal{C}</span>  can be <em>non-deterministic</em> (i.e., it can take auxiliary inputs). We will describe the gates in  <span class="math">\\mathcal{C}</span>  as having <em>values</em>: the value of an addition (multiplication) gate is set to be the sum (product) of its in-neighbors. We refer to the number of gates in  <span class="math">\\mathcal{C}</span>  as its <em>size</em>, and denote this quantity by  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . A fundamental notion used by our MIP is that of a <em>correct transcript</em> for a circuit  </span>\\mathcal{C}<span class="math">  given input  </span>x \\in \\{0,1\\}^n<span class="math">  and output(s)  </span>y \\in \\mathcal{R}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-5-1"></span><strong>Definition 3.2.</strong> A <em>transcript</em> for an arithmetic circuit  <span class="math">\\mathcal{C}</span>  is an assignment of values to the circuit gates; a <em>correct</em> transcript for  <span class="math">\\{\\mathcal{C}, x, y\\}</span>  is a transcript in which the values assigned to the input gates are those of x, the intermediate values correspond to the correct operation of each gate in  <span class="math">\\mathcal{C}</span> , and the values assigned to the output gates are y. Given a triple  <span class="math">\\{\\mathcal{C}, x, y\\}</span> , we refer to the problem of determining whether there is a correct transcript for  <span class="math">\\{\\mathcal{C}, x, y\\}</span>  as the non-deterministic circuit evaluation problem.</p>

    <p class="text-gray-300"><strong>Low-degree extensions.</strong> Let  <span class="math">g: \\{0,1\\}^m \\to \\mathbb{F}</span>  be any function. We say that a polynomial  <span class="math">\\tilde{g}: \\mathbb{F}^m \\to \\mathbb{F}</span>  is a <em>polynomial extension</em> of g if  <span class="math">\\tilde{g}</span>  agrees with g everywhere that g is defined; i.e., if  <span class="math">\\tilde{g}(x) = g(x)</span>  for all  <span class="math">x \\in \\{0,1\\}^m</span> . Notice that  <span class="math">\\tilde{g}</span>  is defined over  <span class="math">\\mathbb{F}^m</span>  whereas g is defined only over  <span class="math">\\{0,1\\}^m</span> . We will often work with <em>multilinear extensions</em>, meaning that  <span class="math">\\tilde{g}</span>  has degree at most one in each of its m variables.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.3 Technical background</h4>

    <p class="text-gray-300"><strong>Schwartz-Zippel lemma.</strong> We will often make use of the following basic property of polynomials.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-5-3"></span><strong>Lemma 3.1</strong> ([79]). Let  <span class="math">\\mathbb{F}</span>  be any field, and let  <span class="math">f: \\mathbb{F}^m \\to \\mathbb{F}</span>  be a nonzero polynomial of total degree d. Then on any finite set  <span class="math">S \\subseteq \\mathbb{F}</span> ,  $\\Pr_{x \\leftarrow S^m}[f(x) = 0] \\le d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . In particular, any two distinct polynomials of total degree d can agree on at most d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fraction of points in  <span class="math">S^m</span> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-5-0"></span><strong>Sum-check protocol.</strong> Our MIP makes essential use of two standard tools from the literature on IPs and MIPs: sum-check protocols [54, 72] (see also [7, §8.3.1] and [64, §3.2.3]), and low-degree tests [10, 12, 60]. We describe sum-check protocols here and low-degree tests in context (§4.4).</p>

    <p class="text-gray-300">Sum-check protocols are interactive; there is a verifier  <span class="math">\\mathcal{V}_{SC}</span>  and a prover  <span class="math">\\mathcal{P}_{SC}</span> , and  <span class="math">\\mathcal{V}_{SC}</span>  begins with an m-variate polynomial  <span class="math">g \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  as well as with a claim K (which is often originated by  <span class="math">\\mathcal{P}_{SC}</span> ). The protocol allows  <span class="math">\\mathcal{P}_{SC}</span>  to prove to  <span class="math">\\mathcal{V}_{SC}</span>  that K equals the sum of the evaluations of g over all  <span class="math">2^m</span>  Boolean inputs, namely:</p>

    <p class="text-gray-300"> <span class="math">K = \\sum_{u_1 \\in \\{0,1\\}} \\sum_{u_2 \\in \\{0,1\\}} \\cdots \\sum_{u_m \\in \\{0,1\\}} g(u_1,\\ldots,u_m)</span> . If the true sum is K, then a correct  <span class="math">\\mathcal{P}_{SC}</span>  can convince  <span class="math">\\mathcal{V}_{SC}</span> ; otherwise,  <span class="math">\\mathcal{V}_{SC}</span>  is highly unlikely to be convinced.</p>

    <p class="text-gray-300">The power of this protocol is that  <span class="math">\\mathcal{V}_{SC}</span>  has to do far less work than the apparently exponential work that is required to compute the sum locally.  <span class="math">\\mathcal{V}_{SC}</span> 's main burden is to perform a <em>single</em> evaluation of  <span class="math">g(r_1, \\ldots, r_m)</span> , for a point  <span class="math">(r_1, \\ldots, r_m)</span>  chosen uniformly at random from  <span class="math">\\mathbb{F}^m</span> . Moreover, the protocol requires only 2m-1 messages to be exchanged over m rounds, with each message consisting of a small number of field elements.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">3.4 Framework</h4>

    <p class="text-gray-300">Here we introduce the framework around which our MIP is designed. This high-level description also loosely applies to many of the recently implemented systems for proof-based verifiable computation [17, 18, 26, 31, 61, 69–71, 75, 76]; the primary difference is our use of two provers.</p>

    <p class="text-gray-300">Our MIP has three steps, depicted in Figure 1. In Step 1,  <span class="math">\\mathcal{V}</span>  starts with a specification  <span class="math">\\Psi</span>  of a Random Access Machine computing a function f, and sends  <span class="math">\\Psi</span>  to the provers. In practice,  <span class="math">\\Psi</span>  will typically be a program expressed in a high-level language (in our prototype implementation, a subset of C). The provers and the verifier compile  <span class="math">\\Psi</span>  into a (non-deterministic) arithmetic circuit  <span class="math">\\mathcal{C}</span> .<sup>4</sup></p>

    <p class="text-gray-300">In Step 2,  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  execute the computation  <span class="math">\\Psi</span>  on input x, and  <span class="math">\\mathcal{P}_1</span>  returns output y. In performing this step, the provers are expected to obtain a correct transcript for  <span class="math">\\{\\mathcal{C}, x, y\\}</span> . Notice that if the claimed output is incorrect—that is, if  <span class="math">y \\neq f(x)</span> —then a correct transcript for  <span class="math">\\{\\mathcal{C}, x, y\\}</span>  simply does not exist: in any transcript that represents the inputs and the computation of each gate correctly, the output wires would not be y.</p>

    <p class="text-gray-300"><img src="_page_6_Figure_6.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-6-1"></span>Figure 1—Our high-level framework. In step ①, a verifier  <span class="math">\\mathcal V</span>  and two provers  <span class="math">\\mathcal P_1, \\mathcal P_2</span>  compile a computation  <span class="math">\\Psi</span>  to an arithmetic circuit,  <span class="math">\\mathcal C</span> . In step ②,  <span class="math">\\mathcal V</span>  requests evaluation of  <span class="math">\\Psi</span>  on input x;  <span class="math">\\mathcal P_1</span>  returns purported output y, and both provers obtain a transcript for the execution of  <span class="math">\\mathcal C</span>  on x. In step ③,  <span class="math">\\mathcal V</span>  queries  <span class="math">\\mathcal P_1</span>  in rounds and submits a final query to  <span class="math">\\mathcal P_2</span> ; if  <span class="math">y{\\ne}\\Psi(x)</span> , then the responses from non-colluding  <span class="math">\\mathcal P_1, \\mathcal P_2</span>  do not, except with very low probability, convince  <span class="math">\\mathcal V</span>  that  <span class="math">\\Psi</span>  was executed correctly.</p>

    <p class="text-gray-300">In Step 3,  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  want to prove to  <span class="math">\\mathcal{V}</span>  that a correct transcript for  <span class="math">\\{\\mathcal{C}, x, y\\}</span>  exists. Of course, there is a simple proof that a correct transcript exists: the transcript itself. Unfortunately,  <span class="math">\\mathcal{V}</span>  can check this transcript for correctness only by examining all of it, which would be as much work as having executed  <span class="math">\\Psi</span>  in the first place. Instead,  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  use low-degree extensions to <em>encode</em> the transcript (as a much longer string) in such a way that a transcript's correctness (or lack thereof) can be determined by inspecting only a few of the locations in the encoded version; this "inspection" will take the form of queries from the verifier to the provers.</p>

    <p class="text-gray-300">Herein, our primary focus will be on Step 3, i.e., on giving a novel two-prover protocol for (non-deterministic) circuit evaluation.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">4 An MIP for non-deterministic circuit evaluation</h4>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.1 Overview of the ideas</h4>

    <p class="text-gray-300">Given an arithmetic circuit C, input x, and claimed outputs y, our protocol <em>encodes</em> a purported transcript W (Defn. 3.2) as a polynomial  <span class="math">\\widetilde{G}_{x,y}</span>  in such a way that  <span class="math">\\widetilde{G}_{x,y}</span>  evaluates to 0 on a particular subset of its domain if and only if W is correct for  <span class="math">\\{C, x, y\\}</span> . Omitting many details, our MIP then uses a sum-check protocol (§3.3), run with  <span class="math">\\mathcal{P}_1</span> , to check that  <span class="math">\\widetilde{G}_{x,y}</span>  in fact evaluates to 0 all over the subset in question. At the end of this sum-check protocol,  <span class="math">\\mathcal{P}_1</span>  is forced to make a claim about  <span class="math">\\widetilde{W}(w_4)</span>  for a point  <span class="math">w_4</span>  chosen at random by the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><sup>&</sup>lt;sup>4</sup>If  <span class="math">\\mathcal{C}</span>  satisfies certain regularity conditions (made formal in §4.5.3), our protocol will allow  <span class="math">\\mathcal{V}</span>  to avoid materializing the full circuit  <span class="math">\\mathcal{C}</span>  during this step, enabling  <span class="math">\\mathcal{V}</span>  to run in time sub-linear in  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">verifier, where <em><sup>W</sup></em><sup>e</sup> is the multilinear extension of <em><sup>W</sup></em>. Even checking this claim is too expensive for <sup>V</sup>, so <sup>V</sup> outsources it to P2, using a low-degree test (<a href="#page-10-0">§4.4\\)</a>.</p>

    <p class="text-gray-300">In many respects, our approach can be seen as a careful adaptation of the ideas underlying the GKR protocol [\\[40\\]](#page-16-4) to the multi-prover setting. While GKR verifies the correctness of a transcript for {C, <em>x</em>, <em>y</em>} layer by layer, with a a different instance of the sum-check protocol required for each layer of C, our MIP verifies the whole computation in one shot, using a single invocation of the sum-check protocol.</p>

    <p class="text-gray-300">While this "sum-check protocol + low-degree test" paradigm for constructing two-prover MIPs is not new [\\[12\\]](#page-15-10), several aspects of our protocol require new ideas. One is the choice of the polynomial <em><sup>G</sup></em>e<em>x</em>,<em>y</em>, which is meant to vanish at all Boolean inputs if and only P1's answers are consistent with a correct transcript <em>W</em>. The difficulty in defining a suitable polynomial is that, for each output gate <em><sup>a</sup></em>, <em><sup>G</sup></em>e<em>x</em>,<em><sup>y</sup></em> must ensure both that <em><sup>W</sup></em>(<em>a</em>) is consistent with claimed output <em>y and</em> that <em>W</em>(<em>a</em>) is correct, given the values of <em>a</em>'s in-neighbors. Though our definition of <em><sup>G</sup></em>e<em>x</em>,<em><sup>y</sup></em> may appear obvious in hindsight, it carefully exploits cancellation to achieve this property (Lemma <a href="#page-8-0">4.1</a> has details).</p>

    <p class="text-gray-300">To the best of our knowledge, some aspects of our soundness analysis are also novel. In particular, in standard analyses of low-degree tests, the assumption is that a prover is a function only of the queries issued by the verifier within the test. However, recall that in our context V uses a low-degree test to check P1's claim about <em><sup>W</sup></em><sup>e</sup> (<em>w</em>4), and <sup>P</sup>1's claim can depend not just on <em><sup>w</sup></em>4, but instead on the entire sequence of messages exchanged with V over the course of the protocol. This makes it non-trivial to apply existing analyses of low-degree tests to our setting, without resorting to expensive generic reductions or the use of additional provers to force P<sup>1</sup> to be non-adaptive.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4.2 Details of the MIP</h2>

    <p class="text-gray-300">We imagine a single input vector <em>x</em> and a claimed output <em>y</em> (which may be a vector), for a given computation Ψ, compiled to an arithmetic circuit C of fan-in two. We stress that C may be non-deterministic. Each entry in <em>x</em>, <em>y</em>, and all intermediate values, are contained in a finite field F = F<em><sup>p</sup></em> (the integers mod a large prime <em>p</em>). In our built system, <em>p</em> will always be 300 or 400 bits (<a href="#page-13-1">§5\\)</a>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Denote the number of gates in C, or its size, as</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, and take <em>s</em> = dlog</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e. Now, assume we have fixed an ordering of the gates. Associate with every gate in C a label of <em>s</em> bits, in the natural way: the zero'th gate gets the label 0, the next gate gets the label 1, etc. We will move back and forth between representing a label as an integer (for example, 0, 1, etc.) and as a bit vector: (0,0,. . . ,0), (0,0,. . . ,1), etc.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, we will model a transcript of C as a list of every gate in C (including the input gates) together with a purported value for that gate. It is convenient to represent that list as a function <em>W</em> : {0, 1} <em><sup>s</sup></em> → F that maps a gate's label to the gate's purported value; it is also convenient to imagine that P<sup>1</sup> is holding such a function <em>W</em>. At this point, V wants to know whether <em>W</em> is a correct transcript (Defn. <a href="#page-5-1">3.2\\)</a>.</p>

    <p class="text-gray-300">How can V check <em>W</em> for correctness? If V asks P<sup>1</sup> only for the values of <em>W</em> for the input and output gates, V has no way of knowing if the answers are correct. If V asks P<sup>1</sup> for all of <em>W</em>, then V does not save work. Instead, V translates the claim that <em>W</em> is correct into an equivalent algebraic claim that is amenable to probabilistic checking. This algebraic claim concerns the properties of a carefully constructed polynomial.</p>

    <p class="text-gray-300">To present this polynomial, we must introduce some functions that capture C's structure: add, mult, and io. Let add: {0, 1} <sup>3</sup><em><sup>s</sup></em> → {0, 1} denote a function that takes as input three gate labels:</p>

    <div class="my-4 text-center"><span class="math-block">add(a, b, c) = \\begin{cases} 1 &amp; \\text{if gate } a \\text{ adds the outputs of gates } b \\text{ and } c \\\\ 0 &amp; \\text{otherwise} \\end{cases}</span></div>

    <p class="text-gray-300">Likewise, mult: {0, 1} <sup>3</sup><em><sup>s</sup></em> → {0, 1} returns 1 when gate <em>a</em> is the product of gates <em>b</em> and <em>c</em>, and 0 otherwise. These two functions, add(·, ·, ·) and mult(·, ·, ·), are used in GKR [\\[40\\]](#page-16-4), and are called <em>wiring predicates</em> by CMT [\\[31\\]](#page-16-8).<sup>5</sup> We add a third wiring predicate: let io: {0, 1} <sup>3</sup><em><sup>s</sup></em> → {0, 1} denote a function that takes as input</p>

    <p class="text-gray-300"><sup>5</sup>A difference is that in those works, a circuit must be layered, and there are separate wiring predicates for each layer.</p>

    <p class="text-gray-300">gate labels (a, b, c) and returns 1 when gate a is a (non-auxiliary) input gate or one of the output gates, and b and c are the in-neighbors of a (input gates have in-neighbors b = c = 0); otherwise, io returns 0.</p>

    <p class="text-gray-300">Notice that add, mult, and io are independent of the inputs and purported outputs. Our last function, however, depends on the inputs and purported outputs. Define  <span class="math">I_{x,y}</span> :  <span class="math">\\{0,1\\}^s \\to \\mathbb{F}</span>  such that  <span class="math">I_{x,y}(a) = x_a</span>  if a is the label of an input gate,  <span class="math">I_{x,y}(a) = y_a</span>  if a is the label of an output gate, and  <span class="math">I_{x,y}(a) = 0</span>  otherwise.</p>

    <p class="text-gray-300">We now use add, mult, io, and  <span class="math">I_{x,y}</span>  to write a function that captures whether a transcript W is correct for  <span class="math">\\{C, x, y\\}</span> .</p>

    <p class="text-gray-300"><span id="page-8-0"></span><strong>Lemma 4.1.</strong> For  <span class="math">G_{x,y}(a,b,c)</span>  defined as below,  <span class="math">G_{x,y}(a,b,c) = 0</span>  for all  <span class="math">(a,b,c) \\in \\{0,1\\}^{3s}</span>  if and only if W is a correct transcript for  <span class="math">\\{\\mathcal{C},x,y\\}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">G_{x,y}(a,b,c) = \\mathrm{io}(a,b,c) \\cdot (I_{x,y}(a) - W(a)) + \\mathrm{add}(a,b,c) \\cdot (W(a) - (W(b) + W(c))) + \\mathrm{mult}(a,b,c) \\cdot (W(a) - W(b) \\cdot W(c)).</span></div>

    <p class="text-gray-300"><em>Proof.</em> If W is not a correct transcript, there are five cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Suppose  <span class="math">a \\in \\{0,1\\}^s</span>  is the label of an input gate. If  <span class="math">W(a) \\neq x_a</span> , then  <span class="math">G_{x,y}(a,0,0) = I_{x,y}(a) W(a) = x_a W(a) \\neq 0</span> .</li>

      <li>2. Suppose  <span class="math">a \\in \\{0,1\\}^s</span>  is the label of a non-output addition gate with in-neighbors b and c. If  <span class="math">W(a) \\neq W(b) + W(c)</span> , then  <span class="math">G_{x,y}(a,b,c) = W(a) (W(b) + W(c)) \\neq 0</span> .</li>

      <li>3. Suppose  <span class="math">a \\in \\{0,1\\}^s</span>  is the label of a non-output multiplication gate with in-neighbors b and c. If  <span class="math">W(a) \\neq W(b) \\cdot W(c)</span> , then  <span class="math">G_{x,y}(a,b,c) = W(a) (W(b) \\cdot W(c)) \\neq 0</span> .</li>

      <li>4. Suppose  <span class="math">a \\in \\{0, 1\\}^s</span>  is the label of an output addition gate with in-neighbors b and c. If  <span class="math">y_a \\neq W(b) + W(c)</span> , then  <span class="math">G_{x,y}(a,b,c) = I_{x,y}(a) W(a) + (W(a) (W(b) + W(c))) = y_a (W(b) + W(c)) \\neq 0</span> .</li>

      <li>5. Suppose  <span class="math">a \\in \\{0,1\\}^s</span>  is the label of an output multiplication gate with in-neighbors b and c. If  <span class="math">y_a \\neq W(b) \\cdot W(c)</span> , then  <span class="math">G_{x,y}(a,b,c) = I_{x,y}(a) W(a) + (W(a) (W(b) \\cdot W(c))) = y_a (W(b) \\cdot W(c)) \\neq 0</span> . On the other hand, if W is a correct transcript then it is immediate from the definition of  <span class="math">G_{x,y}</span>  that  <span class="math">G_{x,y}(a,b,c) = 0</span>  for all  <span class="math">(a,b,c) \\in \\{0,1\\}^{3s}</span> .</li>

    </ul>

    <p class="text-gray-300">The lemma implies that in order for  <span class="math">\\mathcal V</span>  to check that W is a correct transcript, it suffices for  <span class="math">\\mathcal V</span>  to check that  <span class="math">G_{x,y}</span>  vanishes on all inputs in the Boolean hypercube. However, this check must be "outsourced" because  <span class="math">\\mathcal V</span>  cannot handle all of  <span class="math">G_{x,y}</span> . We briefly consider a straw man approach to such outsourcing: use a sum-check protocol (§3.3) to check whether  <span class="math">0\\stackrel{?}{=}\\sum_{a,b,c\\in\\{0,1\\}^s}G_{x,y}(a,b,c)</span> . This is a straw man because, first, the sum-check protocol works with a polynomial (and  <span class="math">G_{x,y}</span>  is not a polynomial), and, second, a sum of zero does not actually imply that  <span class="math">G_{x,y}</span>  vanishes on the desired subspace (the evaluations of  <span class="math">G_{x,y}(a,b,c)</span>  could "cancel out").</p>

    <p class="text-gray-300">As a next step, consider the following polynomial extension  <span class="math">\\widetilde{G}_{x,y} \\colon \\mathbb{F}^{3s} \\to \\mathbb{F}</span>  of  <span class="math">G_{x,y}</span> :</p>

    <p class="text-gray-300"><span id="page-8-1"></span> <span class="math-block">\\widetilde{G}_{x,y}(u_1, u_2, u_3) = \\widetilde{\\text{io}}(u_1, u_2, u_3) \\cdot (\\widetilde{I}_{x,y}(u_1) - \\widetilde{W}(u_1))</span></p>

    <div class="my-4 text-center"><span class="math-block">+ \\widetilde{\\text{add}}(u_1, u_2, u_3) \\cdot (\\widetilde{W}(u_1) - (\\widetilde{W}(u_2) + \\widetilde{W}(u_3)))</span></div>

    <div class="my-4 text-center"><span class="math-block">+ \\widetilde{\\text{mult}}(u_1, u_2, u_3) \\cdot (\\widetilde{W}(u_1) - \\widetilde{W}(u_2) \\cdot \\widetilde{W}(u_3)).</span></div>

    <div class="my-4 text-center"><span class="math-block">(1)</span></div>

    <p class="text-gray-300">Here,  <span class="math">\\widetilde{\\text{io}}</span> ,  <span class="math">\\widetilde{I_{x,y}}</span> ,  <span class="math">\\widetilde{W}</span> ,  <span class="math">\\widetilde{\\text{add}}</span> , and  <span class="math">\\widetilde{\\text{mult}}</span>  respectively denote polynomial extensions of io,  <span class="math">I_{x,y}</span> , W, add, and mult. For efficiency, all of the polynomial extensions appearing in Equation (1) must be low-degree. We will always use the <em>multilinear</em> extension  <span class="math">\\widetilde{W}</span>  of W, and we will always use multilinear or carefully chosen <em>cubic</em> extensions io, add and mult of io, add, and mult (these choices are essential for practical efficiency, as discussed in Section 4.5.2). At this point, we have a polynomial (in 3s variables) over  <span class="math">\\mathbb{F}</span> , and we want to use the sum-check protocol directly to prove to  <span class="math">\\mathcal{V}</span>  that  <span class="math">0 = \\sum_{a,b,c \\in \\{0,1\\}^s} \\widetilde{G}_{x,y}(a,b,c)</span> . However, as noted above, cancellations mean that a sum of zero does not guarantee that  <span class="math">\\widetilde{G}_{x,y}(a,b,c)</span>  evaluates to 0 over all  <span class="math">(a,b,c) \\in \\{0,1\\}^{3s}</span> , which was the algebraic property that we were trying to establish. This brings us to the actual protocol.</p>

    <p class="text-gray-300">We consider a polynomial  <span class="math">F_{x,y}</span>  whose <em>coefficients</em> are given by the evaluations of  <span class="math">\\widetilde{G}_{x,y}</span>  on  <span class="math">\\{0,1\\}^{3s}</span> .</p>

    <p class="text-gray-300">Specifically, define</p>

    <p class="text-gray-300"><span id="page-9-0"></span> <span class="math-block">F_{x,y}(t) = \\sum_{u \\in \\{0,1\\}^{3s}} \\widetilde{G}_{x,y}(u) \\cdot t^{u}.</span>  (2)</p>

    <p class="text-gray-300">Here, the bit string  <span class="math">u \\in \\{0,1\\}^{3s}</span>  in the exponent denotes the integer  <span class="math">\\sum_{i=0}^{3s-1} u_i \\cdot 2^i</span>  (i.e., the integer whose binary representation is u). Notice that  <span class="math">F_{x,y}</span>  is the zero polynomial if and only if  <span class="math">\\widetilde{G}_{x,y}</span>  vanishes on  <span class="math">\\{0,1\\}^{3s}</span>  (and hence if and only if  <span class="math">\\widetilde{G}_{x,y}</span>  encodes a correct transcript, and hence if and only if y is the correct output). But by the Schwartz-Zippel lemma, any non-zero low-degree polynomial has few roots, so if  <span class="math">\\mathcal{V}</span>  picks a random point  <span class="math">q \\in \\mathbb{F}</span>  and determines that  <span class="math">F_{x,y}(q) = 0</span> , it is safe for  <span class="math">\\mathcal{V}</span>  to believe that  <span class="math">F_{x,y}</span>  is the zero polynomial and hence that  <span class="math">\\widetilde{G}_{x,y}</span>  vanishes on  <span class="math">\\{0,1\\}^{3s}</span>  as claimed by  <span class="math">\\mathcal{P}_1</span>  (our soundness analysis is made formal in Appendix A).</p>

    <p class="text-gray-300">Thus, in our MIP, V chooses q uniformly at random from  <span class="math">\\mathbb{F}</span> , and is convinced that W is a correct transcript for  <span class="math">(\\mathcal{C}, x, y)</span>  as long as  <span class="math">F_{x,y}(q) = 0</span> . As explained below, V will outsource the computation of  <span class="math">F_{x,y}(q)</span>  by writing  <span class="math">F_{x,y}(q)</span>  in a form that is amenable to checking via the sum-check protocol (this approach was first proposed by Babai et al. in the original MIP=NEXP proof [12]).</p>

    <p class="text-gray-300">To this end, notice that for any  <span class="math">q \\in \\mathbb{F}</span>  and  <span class="math">u \\in \\{0,1\\}^{3s}</span> , we can write  <span class="math">q^u</span>  as a multilinear polynomial  <span class="math">g_q</span>  in the coordinates of u as follows. Define  <span class="math">q^{(i)} = q^{2^i}</span> . Then it holds that  <span class="math">q^u = \\prod_{i=0}^{3s-1} q^{(i)^{u_i}} = \\prod_{i=0}^{3s-1} \\left(1 + (q^{(i)} - 1)u_i\\right) := g_q(u)</span> . Defining the polynomial  <span class="math">h_q</span>  as  <span class="math">\\widetilde{G}_{x,y} \\cdot g_q</span> , we obtain the following identity:</p>

    <p class="text-gray-300"><span id="page-9-1"></span> <span class="math-block">F_{x,y}(q) = \\sum_{u \\in \\{0,1\\}^{3s}} \\widetilde{G}_{x,y}(u) \\cdot g_q(u) = \\sum_{u \\in \\{0,1\\}^{3s}} h_q(u).</span>  (3)</p>

    <p class="text-gray-300">Notice that  <span class="math">h_q</span>  is a low-degree polynomial in the coordinates of u ( <span class="math">h_q</span>  has degree at most 3 in each variable, if the multilinear extensions of add, mult and io are used in the definition of  <span class="math">\\widetilde{G}_{x,y}</span> ). We now describe how  <span class="math">\\mathcal{V}</span>  outsources computation of  <span class="math">\\sum_{u \\in \\{0,1\\}^{3s}} h_q(u)</span>  to  <span class="math">\\mathcal{P}_1</span>  using a sum-check protocol.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4.3 Interaction with the first prover</h2>

    <p class="text-gray-300">The full protocol is given in Figure 5 (in Appendix E) and proceeds as follows.  <span class="math">\\mathcal{V}</span>  picks a random  <span class="math">q \\in \\mathbb{F}</span>  (see above for motivation) and sends it to the prover  <span class="math">\\mathcal{P}_1</span> . The two parties then run the sum-check protocol over the polynomial  <span class="math">h_q</span>  to prove to  <span class="math">\\mathcal{V}</span>  that  <span class="math">0 = \\sum_{u \\in \\{0,1\\}^{3s}} h_q(u) = F_{x,y}(q)</span> .</p>

    <p class="text-gray-300">Now, the final check in the sum-check protocol requires  <span class="math">\\mathcal{V}</span>  to evaluate  <span class="math">h_q(\\cdot)</span>  at a randomly selected point  <span class="math">(w_1, w_2, w_3)</span>  (see Section 3.3). If  <span class="math">\\mathcal{V}</span>  could do this efficiently, we would be done. However, in our setting  <span class="math">\\mathcal{V}</span>  cannot evaluate  <span class="math">h_q(w_1, w_2, w_3)</span> : doing so would require evaluating  <span class="math">\\widetilde{G}_{x,y}(w_1, w_2, w_3)</span>  and hence (by the definition of  <span class="math">\\widetilde{G}_{x,y}</span> ) evaluating  <span class="math">\\widetilde{W}(w_1)</span> ,  <span class="math">\\widetilde{W}(w_2)</span> , and  <span class="math">\\widetilde{W}(w_3)</span> , which in turn would require constructing  <span class="math">\\widetilde{W}(\\cdot)</span> , which would be at least as much work as handling the unencoded transcript W.</p>

    <p class="text-gray-300">Instead,  <span class="math">\\mathcal{V}</span>  asks  <span class="math">\\mathcal{P}_1</span>  for help:  <span class="math">\\mathcal{P}_1</span>  gives  <span class="math">\\mathcal{V}</span>  three field elements that are purported to be  <span class="math">\\widetilde{W}(w_1)</span> ,  <span class="math">\\widetilde{W}(w_2)</span> , and  <span class="math">\\widetilde{W}(w_3)</span> . Then, using a now-standard technique (see, e.g. [40]) the protocol reduces the uncertainty surrounding the correctness of these values to a claim:  <span class="math">v_4 \\stackrel{?}{=} \\widetilde{W}(w_4)</span> . This reduction is the content of lines 7–21 in Figure 5, and occurs as follows. Let  <span class="math">\\ell(t)</span>  be the degree-two curve passing through the points  <span class="math">w_1, w_2</span> , and  <span class="math">w_3</span>  defined via  <span class="math">\\ell(0) = w_1, \\ell(1) = w_2</span> , and  <span class="math">\\ell(2) = w_3</span> .  <span class="math">\\mathcal{V}</span>  asks  <span class="math">\\mathcal{P}_1</span>  to send her a degree 2s univariate polynomial  <span class="math">H^<em></span>  claimed to equal  <span class="math">\\widetilde{W} \\circ \\ell</span> , i.e.,  <span class="math">\\widetilde{W}</span>  restricted to the curve  <span class="math">\\ell</span> .  <span class="math">\\mathcal{V}</span>  checks that  <span class="math">H^</em>(0), H^<em>(1)</span> , and  <span class="math">H^</em>(2)</span>  equal  <span class="math">v_1, v_2</span> , and  <span class="math">v_3</span>  respectively.  <span class="math">\\mathcal{V}</span>  then picks a random point  <span class="math">\\tau \\in \\mathbb{F}</span> , chooses  <span class="math">w_4</span>  as  <span class="math">\\ell(\\tau)</span> , evaluates  <span class="math">H(\\tau)</span> , and treats  <span class="math">H(\\tau)</span>  as an implicit claim by  <span class="math">\\mathcal{P}_1</span>  about the value of  <span class="math">\\widetilde{W}(w_4)</span> . The Schwartz-Zippel lemma implies that if  <span class="math">H^<em> \\neq \\widetilde{W} \\circ \\ell</span> , then  <span class="math">H^</em>(\\tau) \\neq \\widetilde{W}(\\ell(\\tau))</span>  with probability  <span class="math">1 - 2s/\\mathbb{F}</span>  over  <span class="math">\\tau \\stackrel{R}{\\leftarrow} \\mathbb{F}</span> . Hence,  <span class="math">\\mathcal{V}</span>  chooses  <span class="math">\\tau</span>  at random from  <span class="math">\\mathbb{F}</span> , and is convinced that  <span class="math">H^<em> = \\widetilde{W} \\circ \\ell</span>  (and hence that  <span class="math">v_i = \\widetilde{W}(w_i)</span>  for  <span class="math">i \\in \\{1, 2, 3\\}</span> ) as long as  <span class="math">H^</em>(\\tau) = \\widetilde{W}(w_4)</span>  (again, our formal proof of soundness appears in Appendix A).</p>

    <p class="text-gray-300">At this point, the protocol has provided the following guarantee to V, which we state loosely. V should believe that  <span class="math">0 = F_{x,y}(q)</span> —and hence that a correct transcript exists and hence that the computation was done correctly—if and only if V can establish that  <span class="math">v_4 = \\widetilde{W}(w_4)</span>  for some low-degree polynomial  <span class="math">\\widetilde{W}</span> . But how can</p>

    <p class="text-gray-300"> <span class="math">\\mathcal{V}</span>  check this? As noted, it would be too expensive for  <span class="math">\\mathcal{V}</span>  to evaluate  <span class="math">\\widetilde{W}</span> . For this purpose,  <span class="math">\\mathcal{V}</span>  turns to the second prover.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4.4 Interaction with the second prover</h2>

    <p class="text-gray-300">To validate  <span class="math">\\mathcal{P}_1</span> 's claim that  <span class="math">v_4 = \\widetilde{W}(w_4)</span> ,  <span class="math">\\mathcal{V}</span>  engages the second prover,  <span class="math">\\mathcal{P}_2</span> , using a low-degree test [10, 60] (see Figure 5, lines 23–24). We use the point vs. plane low-degree test, as analyzed by Moshkovitz and Raz [60]. This test works by asking  <span class="math">\\mathcal{P}_2</span>  to send a very small "excerpt" of the encoded transcript  <span class="math">\\widetilde{W}</span> ; to get this transcript,  <span class="math">\\mathcal{P}_2</span>  must execute the computation, just as  <span class="math">\\mathcal{P}_1</span>  does. The "excerpt" is a low-degree polynomial claimed to equal  <span class="math">\\widetilde{W}</span>  restricted to a low-dimensional subspace. In the test we use, this subspace is a plane that passes through  <span class="math">w_4</span> , and  <span class="math">\\mathcal{V}</span>  conceals which point in the subspace is  <span class="math">w_4</span> . Because  <span class="math">\\mathcal{V}</span>  obtains (a description of)  <span class="math">\\widetilde{W}</span>  over the entire subspace,  <span class="math">\\mathcal{V}</span>  extracts an implicit claim by  <span class="math">\\mathcal{P}_2</span>  about the value of  <span class="math">\\widetilde{W}(w_4)</span> . At this point,  <span class="math">\\mathcal{V}</span>  rejects if there is a discrepancy in the two provers' claims about  <span class="math">\\widetilde{W}(w_4)</span>  (see Figure 5, line 24).</p>

    <p class="text-gray-300">In more detail, in the point vs. plane test, V sends  <span class="math">\\mathcal{P}_2</span>  a random plane Q (i.e., a two-dimensional affine subspace of  <span class="math">\\mathbb{F}^s</span> ) through the point  <span class="math">w_4</span> , parameterized in a way that reveals no information about the point  <span class="math">w_4</span>  to  <span class="math">\\mathcal{P}_2</span> , other than that  <span class="math">w_4</span>  lies somewhere on Q.  <span class="math">\\mathcal{P}_2</span>  responds with a bivariate polynomial  <span class="math">H_Q^<em></span>  of degree s in each variable claimed to equal  <span class="math">\\widetilde{W} \\circ Q</span> . Let  <span class="math">(t_1, t_2)</span>  be the point such that  <span class="math">Q(t_1, t_2) = w_4</span> . V considers  <span class="math">H_Q^</em>(t_1, t_2)</span>  to be  <span class="math">\\mathcal{P}_2</span> 's claim about the value of  <span class="math">\\widetilde{W}(w_4)</span> .</p>

    <p class="text-gray-300">Moshkovitz and Raz [60] have analyzed the point vs. plane test to be sound for reasonable field sizes (see Lemma A.1 in Appendix A for details). Note that Moshkovitz and Raz state explicitly that they made no attempt to optimize the constants appearing in their analysis, and even small improvements in the constants would yield substantial improvements to the soundness guarantee for our protocol. This would allow us to work over smaller fields; the current implementation works over a very large field so as to achieve low soundness error, and the field size is a substantial contributor to the costs of our implementation.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">4.5 Guarantees and costs</h4>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">4.5.1 Correctness</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our MIP guarantees completeness and soundness, as defined in Section 3.1. An upper-bound on our MIP's soundness error,  <span class="math">\\epsilon</span> , assuming  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^8<span class="math"> , is  </span>(2^9 \\cdot \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/8}<span class="math"> . Thus, for a field size of 300 bits,  </span>\\epsilon < 2^{-23}<span class="math">  for any circuit  </span>\\mathcal{C}<span class="math">  with fewer than  </span>2^{40}<span class="math">  gates, and for a field size of 400 bits,  </span>\\epsilon < 2^{-35}$ . We establish this formally in Appendix A.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">4.5.2 Overview of Costs</h4>

    <p class="text-gray-300">We now give a brief overview of the costs of our MIP, before formalizing them in Theorem 4.1.</p>

    <p class="text-gray-300"> <span class="math">\\mathcal{V}</span> 's costs. The principal bottleneck in  <span class="math">\\mathcal{V}</span> 's running time is that  <span class="math">\\mathcal{V}</span> 's final check in the sum-check protocol requires evaluating the low-degree extensions add and mult at  <span class="math">(w_1, w_2, w_3) \\in \\mathbb{F}^{3s}</span> . We take two approaches. The first approach requires pre-processing but applies to arbitrary circuits; we use this approach in our prototype implementation (cf. §5). The second uses carefully generated circuits for which the verifier can evaluate add and mult in polylogarithmic time, and hence avoid a pre-processing phase. We have not yet implemented this circuit generator, leaving it to near-term future work. In more detail:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Approach 1. Our implemented compiler from high-level programs to circuits uses the multilinear extensions add and mult. While this leads to  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  pre-processing time for  </span>\\mathcal{V}$ , the costs can be amortized (§5 gives details).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Approach 2. We adapt work of Ben-Sasson et al. [15] to turn arbitrary RAMs into small circuits with repeated structure. There are <em>cubic</em> extensions of the wiring predicate of these circuits that V can evaluate at any point in polylogarithmic time (and  <span class="math">P_1</span> 's costs can be controlled when using these extensions, using techniques of Thaler [74]; see below). Using this approach, V does not need to materialize the circuit, and thus does not</p>

    <p class="text-gray-300">incur the cost of compiling the high-level program into the circuit. In this approach, the verifier processes the input in O(n) time, and the rest of the protocol requires polylogarithmic time in <em>total</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-11-1"></span> <span class="math">\\mathcal{P}_1</span> 's and  <span class="math">\\mathcal{P}_2</span> 's costs. In both Approach 1 and Approach 2,  <span class="math">\\mathcal{P}_1</span>  in each round has to compute a univariate polynomial, defined as a sum of up to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3<span class="math">  other univariate polynomials. However, techniques of CMT [31] and Thaler [74] show that under both approaches, each gate in  </span>\\mathcal{C}<span class="math">  contributes to O(1) terms in the sum, allowing  </span>\\mathcal{P}_1<span class="math">  to run in  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time.  </span>\\mathcal{P}_2<span class="math"> &#x27;s computation is identical in both approaches: the point-vs-plane test requires  </span>\\mathcal{P}_2<span class="math">  to evaluate  </span>\\widetilde{W}(\\cdot)<span class="math">  at  </span>(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1)^2<span class="math">  points. This can be done with  </span>4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  field multiplications per point using a memoization idea from [76, §5.1]. In settings (such as our built system) in which  </span>\\mathcal{V}<span class="math">  wants to evaluate a circuit  </span>\\mathcal{C}<span class="math">  on many inputs, both  </span>\\mathcal{P}_1<span class="math">  and  </span>\\mathcal{P}_2<span class="math">  can reuse some work across instances. In §5, we describe such reusable work as <em>setup costs</em> for  </span>\\mathcal{P}_1<span class="math">  and  </span>\\mathcal{P}_2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark. Thaler [74] also shows how to reduce the prover's total work in the GKR-CMT protocol to be proportional to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  rather than  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  for a large class of wiring patterns, and demonstrates experimentally that these techniques can reduce the prover's runtime by two orders of magnitude relative to the original CMT implementation that appeared in [31]. These techniques apply equally well to the first prover in our MIP protocol. However, we have not yet incorporated them into our prototype implementation (indeed, our prototype currently uses circuits that do not satisfy the conditions required by the optimizations of [74]).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The next subsection formalizes the costs and guarantees of Approach 2.</p>

    <h2 id="sec-18" class="text-2xl font-bold">4.5.3 A complexity preserving MIP</h2>

    <p class="text-gray-300"><span id="page-11-2"></span><strong>Theorem 4.1.</strong> There is a two-prover MIP protocol satisfying the following properties. In order to check that a T(n)-time S(n)-space Random-Access Machine M non-deterministically accepts an input x of length n, the MIP verifier runs in time  <span class="math">O(n \\cdot \\operatorname{polylog}(T(n)))</span> , and both MIP provers run in time  <span class="math">O(T(n) \\cdot \\operatorname{polylog}(T(n)))</span>  and space  <span class="math">O(S(n) \\cdot \\operatorname{polylog}(T(n)))</span>  if given an (input, witness) pair (x ; w) for M. Moreover, each MIP prover can be computed "gate-by-gate" as a circuit by an evaluator algorithm in time  <span class="math">O(T(n) \\cdot \\operatorname{polylog}(T(n)))</span>  and space  <span class="math">O(S(n) \\cdot \\operatorname{polylog}(T(n)))</span> .</p>

    <p class="text-gray-300">To clarify, Bitansky and Chiesa [23] obtained an identical result to Theorem 4.1 up to factors hidden by the polylog(T(n)) terms, using very different techniques from our own (their MIP uses  <span class="math">m = \\Theta(\\log S(n)/\\log\\log(S(n)))</span>  many provers, but one can obtain a two-prover MIP from their construction using a generic reduction that "only" blows up the costs by logarithmic factors). We state Theorem 4.1 not for its novelty, but because it formalizes the costs and properties of our MIP.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note, however, that our MIP has substantially improved quantitative costs compared to [23]. When instantiated on a particular circuit  <span class="math">\\mathcal{C}</span> , both of our provers run in time  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , whereas the provers in the MIP of [23] appear to require total time at least  </span>\\tilde{\\Omega}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , even before invoking the reduction to two provers. There are two main reasons for their higher costs. First, their protocol requires running  </span>\\Omega(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\log \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  low-degree tests, compared to our single low-degree test. Second, each of the polynomials to which they apply a low-degree test has total degree  </span>\\tilde{\\Omega}(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> ; in comparison, the polynomial used in our MIP has total degree  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . This means that each low-degree test in the MIP of [23] requires the prover to either evaluate the relevant polynomial at  </span>\\tilde{\\Omega}(\\log^4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  points or compute this many coefficients, and each such evaluation appears to require  </span>\\tilde{\\Omega}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Bitansky and Chiesa also showed how to transform any MIP with the properties guaranteed by Theorem 4.1 into a four-message complexity preserving argument system.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-11-3"></span><em>Proof of Theorem 4.1.</em> The proof relies on the following lemma, which shows that it is possible to very efficiently transform an arbitrary RAM program into an arithmetic circuit  <span class="math">\\mathcal{C}</span>  for which there exist <em>cubic</em> extensions of add and mult can be evaluated in polylogarithmic time. Moreover, when applying the sum-check protocol to the polynomial  <span class="math">h_q</span>  derived from these extensions, the prover  <span class="math">\\mathcal{P}_1</span>  can still be made to run in time  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 4.2. Let <em>M</em> be an arbitrary (non-deterministic) Random Access Machine that on inputs of length <em>n</em> runs in time <em>T</em>(<em>n</em>) and space <em>S</em>(<em>n</em>). <em>M</em> can be transformed into an equivalent (non-deterministic) arithmetic circuit <sup>C</sup> over a field <sup>F</sup> of size polylog(<em>T</em>(<em>n</em>)). Moreover, there exist cubic extensions add <sup>f</sup> and mult <sup>g</sup> of the wiring predicates add and mult of C that satisfy the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. C has size <em>O</em>(<em>T</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))).</li>

      <li>2. The cubic extensions add and <sup>f</sup> mult of <sup>g</sup> <sup>C</sup> can each be evaluated in time <em><sup>O</sup></em>(polylog(<em>T</em>(<em>n</em>))).</li>

      <li>3. An (input, witness) pair (<em>x</em> ; <em>w</em>) that makes <em>M</em> accept can be mapped to a correct transcript <em>W</em> for C in time <em>O</em>(<em>T</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))) and space <em>O</em>(<em>S</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))). Furthermore, <em>w</em> is a substring of the transcript <em>W</em>, and any correct transcript <em>W</em><sup>0</sup> for C possesses a witness <em>w</em> 0 for (<em>M</em>, <em>x</em>) as a substring.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 4. <sup>P</sup><sup>1</sup> can run in time <em><sup>O</sup></em>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) when applying the sum-check protocol to the polynomial <em><sup>h</sup><sup>q</sup></em> <sup>=</sup> <em><sup>G</sup></em>e<em>x</em>,<em><sup>y</sup></em> ·<em>g<sup>q</sup></em> derived from add, <sup>f</sup> mult, and the transcript <sup>g</sup> <em><sup>W</sup></em> (see Equation <a href="#page-8-1">\\(1\\)</a>).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5. C can be evaluated "gate-by-gate" in time <em>O</em>(<em>T</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))) and space <em>O</em>(<em>S</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))).</li>

    </ul>

    <p class="text-gray-300">The proof of Lemma <a href="#page-11-3">4.2</a> adapts techniques for transforming RAMs into circuits pursued by Ben-Sasson et al. [\\[15\\]](#page-15-7), combined with techniques of Thaler [\\[74\\]](#page-17-18) for obtaining the appropriate cubic extensions. A detailed sketch of this result is in Appendix <a href="#page-25-0">D.</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a (non-deterministic) Random Access Machine <em>M</em>, let C be the circuit whose existence is guaranteed by Lemma <a href="#page-11-3">4.2.</a> Insights of CMT [\\[31\\]](#page-16-8) show that each gate in the circuit C contributes independently to each of P1's messages. Thus, P<sup>1</sup> can compute each message in time <em>O</em>(<em>T</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))) and space <em>O</em>(<em>S</em>(<em>n</em>)· polylog(<em>T</em>(<em>n</em>))) by evaluating the circuit gate-by-gate, computing the contribution of each gate to the current message, and "forgetting" the value of the gate immediately after. While this requires P to reevaluate the circuit for every message, P<sup>1</sup> sends only 3 log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">many messages in total, and therefore revaluation of C introduces only a <em>O</em>(log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) factor overhead in P1's runtime. (To clarify, if we did not care about keeping the space complexity of P<sup>1</sup> small, then P<sup>1</sup> can store the value of each gate and avoid this overhead). We conclude that when applying our MIP protocol to C, P<sup>1</sup> runs in total time <em>O</em>(<em>T</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))) and space <em>O</em>(<em>S</em>(<em>n</em>) · polylog(<em>T</em>(<em>n</em>))).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similar observations imply that P<sup>2</sup> can be made to run within the same time and space bounds when applied to the circuit C, completing the proof of the theorem.</p>

    <p class="text-gray-300">Proof-of-Knowledge. Bitansky and Chiesa [\\[23\\]](#page-16-21) also give a hardness assumption under which any complexity preserving MIP that satisfies a <em>proof-of-knowledge</em> (PoK) property can be transformed into a complexity preserving SNARK. In Appendix <a href="#page-23-0">C,</a> we show that our MIP satisfies this PoK property, and hence the transformation of [\\[23\\]](#page-16-21) can turn it into a complexity-preserving SNARK.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5 Clover, the built system</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As discussed earlier, Clover (the built system) does not yet incorporate complexity-preserving reductions from high-level programs into the circuits required by Theorem <a href="#page-11-2">4.1.</a> Instead, Clover relies on an existing approach to circuit generation <a href="#page-16-7">\\[26,</a> <a href="#page-17-13">61,</a> <a href="#page-17-23">70,</a> <a href="#page-17-15">71,</a> [76\\]](#page-17-17) that produces circuits for which the verifier cannot evaluate low-degree extensions add <sup>f</sup> and mult <sup>g</sup> in polylogarithmic time. However, even for these circuits, the multilinear extensions can be evaluated in time proportional to</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">by iterating over every gate in C and computing its contribution to the evaluation <a href="#page-16-8">\\[31,</a> [76\\]](#page-17-17). Borrowing an idea from Allspice <a href="#page-17-17">\\[76,</a> §4.2], we move this computation to a setup phase and amortize its cost by reusing this work across a <em>batch</em> of inputs <em>x</em> (1) , . . . , <em>x</em> (β) . Our built system includes some additional optimizations that require pre-processing (full details in Appendix <a href="#page-22-0">B.2\\)</a>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-13-1"></span>Costs of Clover. Figure <a href="#page-13-2">2</a> reports the concrete costs of our built system. To briefly compare these costs to those of built systems based on arguments with preprocessing <a href="#page-15-4">\\[17,</a> <a href="#page-15-5">18,</a> <a href="#page-16-7">26,</a> <a href="#page-17-13">61,</a> [69\\]](#page-17-19), the costs for the prover and verifier in these systems are the same as, or lower than, Clover's—in <em>asymptotic</em> terms. However, in <em>concrete</em> terms, the argument systems require many expensive cryptographic operations. For instance, in Zaatar [\\[69\\]](#page-17-19), each operation in the setup phase requires a modular exponentiation that costs two orders of magnitude more <a href="#page-17-19">\\[69,</a> §5.1] than a field operation—the only kind of operation required for Clover. Additional comparisons are in <a href="#page-2-0">§2.</a></p>

    <h2 id="sec-20" class="text-2xl font-bold">6 Experimental evaluation</h2>

    <p class="text-gray-300">We are interested in two performance metrics: (1) the verifier's <em>break-even batch size</em>, i.e., the minimum number of computation instances that the verifier must outsource</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V's setup costs<br>V's per-instance costs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f · (9 ·  C  + 3 · ( x  +  y ))<br>2 +<br><br><br>f ·<br>(log  C  + 1)<br>11 log  C  +  x  +  y</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P1's setup costs<br>P1's per-instance cost</td>

            <td class="px-3 py-2 border-b border-gray-700">f · (22.5 C  log  C  + 3 C )<br>f · (18.5 C  log  C  + 7 C )</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P2's setup costs<br>P2's per-instance cost</td>

            <td class="px-3 py-2 border-b border-gray-700">2<br>f · 3 C  · (1 + log  C )<br>2<br>f ·  C  · (1 + log  C )</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Network costs<br>Protocol rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">p  · (log2<br> C  + 15 · log  C  + 5)<br>3 · log  C  + 1 with P1, 1 with P2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Soundness error (§A)</td>

            <td class="px-3 py-2 border-b border-gray-700">−23 when<br>Clover<br>< 2<br> p  ≥ 300<br>−35 when<br>Clover<br>< 2<br> p  ≥ 400</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>x</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>y</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: number of elements in input, output</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: number of gates in C</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>p</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">: length of an element in F</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-13-2"></span>Figure 2—Costs of Clover (the built system) for a computation represented as an arithmetic circuit C with</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">gates. <em>f</em> represents the cost of field multiplication.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">in a batch before the cost of local execution exceeds the cost of verification, and (2) the prover's overhead, split into per-instance and setup costs (see Figure <a href="#page-13-2">2\\)</a>. We note that item (1) accounts for the verifier's per-instance verification time and per-computation setup cost (which is the dominant cost in all of the protocols in the literature).</p>

    <p class="text-gray-300">Points of comparison. Besides local computation, our points of comparison are CMT-batching [\\[76\\]](#page-17-17) (the refinement to CMT that is part of Allspice) and Zaatar [\\[69\\]](#page-17-19). To explain this choice of baseline, we give a ballpark comparison among three systems for verifiable computation: Zaatar [\\[69\\]](#page-17-19), Pinocchio [\\[61\\]](#page-17-13), and CMT-batching [\\[76\\]](#page-17-17). We choose these three because we are focused on the "back-end" in this paper. As noted in Section <a href="#page-2-0">2,</a> the other systems for general-purpose verifiable computation—BCTV <a href="#page-15-4">\\[17,</a> [18\\]](#page-15-5), Pantry [\\[26\\]](#page-16-7), and Buffet [\\[77\\]](#page-17-26)—differ primarily in their "front-ends"; their back-end is Pinocchio or optimizations thereof.</p>

    <p class="text-gray-300">For the verifier's costs, Zaatar's per-instance verification time is roughly three times Pinocchio's, but Pinocchio's setup costs are considerably larger <a href="#page-17-12">\\[78,</a> Figs. 2-3]; as a result, Pinocchio's break-even point is roughly twice Zaatar's <a href="#page-17-12">\\[78,</a> Fig. 4]. And when CMT is applicable, it has the best batch sizes in the literature, by several orders of magnitude [\\[76\\]](#page-17-17). For the prover's costs, Pinocchio's prover costs roughly twice Zaatar's; for details, see <a href="#page-17-12">\\[78,</a> Fig. 5]<a href="#page-17-17">\\[76,</a> §8]<a href="#page-17-17">\\[76,</a> Fig. 10]<a href="#page-16-7">\\[26,</a> §2.3,§9]. Summarizing, CMT-batching and Zaatar do better on the key metrics (prover costs, verifier break-even points), so these are the comparison points for Clover.6,7</p>

    <p class="text-gray-300">Top-level summary of results. Clover achieves break-even batch sizes that are competitive with CMTbatching (for computations for which CMT-batching even <em>has</em> a break-even batch size) and are significantly superior to Zaatar, while simultaneously yielding prover costs that are competitive to both.</p>

    <p class="text-gray-300">Method and setup. We evaluate Clover on the following benchmark computations: (1) <em>m</em> × <em>m</em> matrix multiplication (<em>m</em>=128), (2) evaluating a degree-2 polynomial in <em>m</em> variables (<em>m</em>=512), (3) finding the roots</p>

    <p class="text-gray-300"><sup>6</sup>An area where Zaatar is not the best is amortization behavior. Whereas Zaatar's setup costs amortize only over a batch, Pinocchio's set-up costs amortize over an indefinite number of instances of the same computation. And BCTV's amortize over an indefinite number of instances of all computations of the same length. Clover and Zaatar work under the same amortization model.</p>

    <p class="text-gray-300"><sup>7</sup>Our comparison here has considered the original version of Pinocchio. Very recently, BCTV [\\[18\\]](#page-15-5) have released an optimized implementation of this protocol that achieves approximately a 5× performance improvement [\\[2\\]](#page-15-18), which would imply a performance improvement over Zaatar of roughly 2.5×. Work is underway to incorporate this optimized protocol as a comparison point. In the meantime, our comparison to Zaatar provides a high-level illustration of Clover's costs compared to the systems based on arguments.</p>

    <p class="text-gray-300"><span id="page-14-0"></span><img src="_page_14_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><img src="_page_14_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">(a) Break-even batch sizes for matrix multiplication (m=128), polynomial evaluation (m=512), and root finding by bisection (m=256, L=8) under CMT-batching and Clover.</p>

    <p class="text-gray-300"><span id="page-14-1"></span>(b) Break-even batch sizes for PAM clustering (d=128, m=20), all-pairs shortest path (m=25), and longest common subsequence (m=300) under Zaatar and Clover. The y-axis is log-scaled.</p>

    <p class="text-gray-300">Figure 3—Clover has a superior break-even size in all of our experiments.</p>

    <p class="text-gray-300">of a degree-2 polynomial in m variables using bisection (m=256, L=8), (4) clustering a set of m data points, where each data points have d dimensions, using PAM clustering (d=128, m=20), (5) Floyd-Warshall all-pairs shortest paths in a graph with m vertices (m=25), and (6) finding the longest common subsequence of two length-m strings (m=300). These computations were expressed in a high-level language and automatically compiled into circuits. The sizes of the resulting circuits range from 1 million gates for polynomial evaluation to 12.6 million gates for longest common subsequence. We evaluated Clover against CMT-batching for the first three computations, and against Zaatar for the remaining ones.</p>

    <p class="text-gray-300">We run CMT-batching and Zaatar over a finite field with a 128-bit prime modulus for computations that take integer inputs and a field with a 220-bit prime modulus for computations that take floating-point inputs. We run Clover with a 300-bit prime modulus field for all computations, corresponding to soundness error of at most  <span class="math">2^{-23}</span> . Costs grow roughly linearly with the bit length; for example, increasing the modulus to 400 bits to guarantee soundness error  <span class="math">2^{-35}</span>  results in a 20–41% increase in the numbers reported below.</p>

    <p class="text-gray-300">We run the verifier and provers on different machines in the same local cluster and use getrusage to measure their CPU usages. Each machine has two Intel Xeon E5-2680 2.7 GHz processors with 32GB of RAM (Clover required approximately 8GB of RAM in our largest experiment.) To compute the verifier's break-even batch size, we run one instance locally and one instance under verification (splitting the verifier's costs into setup and per-instance costs), then solve for the point  <span class="math">\\beta</span>  at which verification of  <span class="math">\\beta</span>  instances is cheaper running them locally.</p>

    <p class="text-gray-300">Clover's break-even batch size. Figures 3(a) and 3(b) show Clover's break-even batch sizes in comparison to CMT-batching and Zaatar, respectively. Clover's break-even batch size is slightly smaller than CMT-batching's for matrix multiplication and polynomial evaluation and much smaller for root finding by bisection. Against Zaatar, Clover fared even better, achieving a break-even batch size that is  <span class="math">20{\\text -}40\\times</span>  smaller.</p>

    <p class="text-gray-300">Clover's prover overhead. Figures 4(a) and 4(b) show the running time of Clover's two provers in comparison to the two baseline protocols' provers and to local execution of the computation. Clover's provers' per-instance costs are competitive with both baseline protocols' provers for all computations, despite having to work in a larger 300-bit modulus field. Its total per-instance prover overhead is no more than twice that of the baseline protocols, and it beats CMT-batching in the root finding computation. Clover's provers have setup costs that are not shown in the referenced figures. However, these costs are no more than  <span class="math">3 \\times</span>  each prover's per-instance costs; they can be easily amortized away at reasonable batch sizes.</p>

    <p class="text-gray-300">In summary, while we have not yet implemented the full theory, we are encouraged by our results: Clover handles problems that existing interactive proofs cannot, and achieves performance comparable to, or better than, state of the art single-prover protocols that inherently require a pre-processing phase for the verifier.</p>

    <p class="text-gray-300"><span id="page-15-19"></span><img src="_page_15_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><img src="_page_15_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">(a) Per-instance running time of local executions and of the CMT-batching and Clover provers for matrix multiplication (m=128), polynomial evaluation (m=512), and root finding by bisection (m=256, L=8). The y-axis is log-scaled.</p>

    <p class="text-gray-300"><span id="page-15-20"></span>(b) Per-instance running time of local execution and of the Zaatar and Clover provers for PAM clustering (d=128, m=20), all-pairs shortest path (m=25), and longest common subsequence (m=300). The y-axis is log-scaled.</p>

    <p class="text-gray-300">Figure 4—Clover's provers are competitive with both CMT-batching's and Zaatar's provers. Clover's first prover's setup costs (not shown) are  <span class="math">1.5 \\times</span>  its per-instance costs; Clover's second provers's setup costs are  <span class="math">2-3 \\times</span>  its per-instance costs; CMT-batching's prover's setup costs are  <span class="math">0.3 \\times</span>  its per-instance costs; and Zaatar's prover has no significant setup costs.</p>

    <h2 id="sec-21" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-15-21"></span>[1] Open MPI (http://www.open-mpi.org).</li>

      <li><span id="page-15-18"></span>[2] https://github.com/scipr-lab/libsnark, 2014.</li>

      <li><span id="page-15-9"></span>[3] W. Aiello, S. N. Bhatt, R. Ostrovsky, and S. Rajagopalan. Fast verification of any remote procedure call: Short witness-indistinguishable one-round proofs for np. In U. Montanari, J. D. P. Rolim, and E. Welzl, editors, <em>ICALP</em>, volume 1853 of <em>Lecture Notes in Computer Science</em>, pages 463–474. Springer, 2000.</li>

      <li><span id="page-15-8"></span>[4] P. A. Alsberg and J. D. Day. A principle for resilient sharing of distributed resources. pages 562–570, 1976.</li>

      <li><span id="page-15-1"></span>[5] S. Alsouri, S. Katzenbeisser, and S. Biedermann. Trustable outsourcing of business processes to cloud computing environments. In <em>The Conference on Network and System Security (NSS)</em>, 2011.</li>

      <li><span id="page-15-0"></span>[6] D. P. Anderson, J. Cobb, E. Korpela, M. Lebofsky, and D. Werthimer. SETI@home: An experiment in public-resource computing. <em>CACM</em>, 45(11):56–61, Nov. 2002.</li>

      <li><span id="page-15-16"></span>[7] S. Arora and B. Barak. Computational Complexity: A modern approach. Cambridge University Press, 2009.</li>

      <li><span id="page-15-2"></span>[8] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. Proof verification and the hardness of approximation problems. <em>J. of the ACM</em>, 45(3):501–555, May 1998.</li>

      <li><span id="page-15-3"></span>[9] S. Arora and S. Safra. Probabilistic checking of proofs: a new characterization of NP. <em>J. of the ACM</em>, 45(1):70–122, Jan. 1998.</li>

      <li><span id="page-15-17"></span>[10] S. Arora and M. Sudan. Improved low-degree testing and its applications. Combinatorica, 23(3):365–426, 2003.</li>

      <li><span id="page-15-6"></span>[11] L. Babai. Trading group theory for randomness. In STOC, 1985.</li>

      <li><span id="page-15-10"></span>[12] L. Babai, L. Fortnow, and C. Lund. Non-deterministic exponential time has two-prover interactive protocols. <em>Computational Complexity</em>, 1(1):3–40, 1991.</li>

      <li><span id="page-15-14"></span>[13] B. Barak and O. Goldreich. Universal arguments and their applications. <em>SIAM J. Comput.</em>, 38(5):1661–1694, 2008.</li>

      <li><span id="page-15-11"></span>[14] M. Ben-Or, S. Goldwasser, J. Kilian, and A. Wigderson. Multi-prover interactive proofs: How to remove intractability assumptions. In J. Simon, editor, <em>STOC</em>, pages 113–131. ACM, 1988.</li>

      <li><span id="page-15-7"></span>[15] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems. In <em>ITCS</em>, Jan. 2013.</li>

      <li><span id="page-15-15"></span>[16] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. On the concrete-efficiency threshold of probabilistically-checkable proofs. In <em>STOC</em>, June 2013.</li>

      <li><span id="page-15-4"></span>[17] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In <em>CRYPTO</em>, pages 90–108, Aug. 2013.</li>

      <li><span id="page-15-5"></span>[18] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In <em>USENIX Security</em>, Aug. 2014.</li>

      <li><span id="page-15-12"></span>[19] E. Ben-Sasson, O. Goldreich, P. Harsha, M. Sudan, and S. Vadhan. Robust PCPs of proximity, shorter PCPs and applications to coding. <em>SIAM J. on Comp.</em>, 36(4):889–974, Dec. 2006.</li>

      <li><span id="page-15-13"></span>[20] E. Ben-Sasson and M. Sudan. Short PCPs with polylog query complexity. SIAM J. on Comp., 38(2):551-607,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>May 2008.</li>

      <li><span id="page-16-12"></span>[21] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>ITCS</em>, pages 326–349, Jan. 2012.</li>

      <li><span id="page-16-16"></span>[22] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In <em>STOC</em>, pages 111–120, June 2013.</li>

      <li><span id="page-16-21"></span>[23] N. Bitansky and A. Chiesa. Succinct arguments from multi-prover interactive proofs and their efficiency benefits. In <em>CRYPTO</em>, pages 255–272, 2012.</li>

      <li><span id="page-16-13"></span>[24] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In <em>IACR TCC</em>, Mar. 2013.</li>

      <li><span id="page-16-9"></span>[25] G. Brassard, D. Chaum, and C. Crepeau. Minimum disclosure proofs of knowledge. ´ <em>J. of Comp. and Sys. Sciences</em>, 37(2):156–189, 1988.</li>

      <li><span id="page-16-7"></span>[26] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Walfish. Verifying computations with state. In <em>SOSP</em>, 2013.</li>

      <li><span id="page-16-14"></span>[27] R. Canetti, B. Riva, and G. Rothblum. Practical delegation of computation using multiple servers. In <em>ACM CCS</em>, 2011.</li>

      <li><span id="page-16-15"></span>[28] R. Canetti, B. Riva, and G. N. Rothblum. Refereed delegation of computation. <em>Inf. Comput.</em>, 226:16–36, 2013.</li>

      <li><span id="page-16-0"></span>[29] M. Castro and B. Liskov. Practical Byzantine fault tolerance and proactive recovery. <em>ACM Trans. on Comp. Sys.</em>, 20(4):398–461, Nov. 2002.</li>

      <li><span id="page-16-2"></span>[30] A. Chiesa and E. Tromer. Proof-carrying data and hearsay arguments from signature cards. In <em>ICS</em>, 2010.</li>

      <li><span id="page-16-8"></span>[31] G. Cormode, M. Mitzenmacher, and J. Thaler. Practical verified computation with streaming interactive proofs. In <em>ITCS</em>, 2012.</li>

      <li><span id="page-16-17"></span>[32] G. D. Crescenzo and H. Lipmaa. Succinct NP proofs from an extractability assumption. In A. Beckmann, C. Dimitracopoulos, and B. Lowe, editors, ¨ <em>CiE</em>, volume 5028 of <em>Lecture Notes in Computer Science</em>, pages 175–185. Springer, 2008.</li>

      <li><span id="page-16-18"></span>[33] I. Damgard, S. Faust, and C. Hazay. Secure two-party computation with low communication. In R. Cramer, editor, ˚ <em>TCC</em>, volume 7194 of <em>Lecture Notes in Computer Science</em>, pages 54–74. Springer, 2012.</li>

      <li><span id="page-16-28"></span>[34] I. Dinur. The PCP theorem by gap amplification. <em>J. of the ACM</em>, 54(3):12:1–12:44, June 2007.</li>

      <li><span id="page-16-23"></span>[35] C. Dwork, M. Langberg, M. Naor, K. Nissim, and O. Reingold. Succinct proofs for NP and spooky interactions. <em>Manuscript, available at</em> http: // www. cs. bgu. il/ ~ <a href="http://www.cs.bgu.il/~kobbi/papers/spooky_sub_crypto.pdf">kobbi/ papers/ spooky\\\\_ sub\\\\_ crypto. pdf</a> , 2004.</li>

      <li><span id="page-16-27"></span>[36] L. Fortnow, J. Rompel, and M. Sipser. On the power of multi-power interactive protocols. In <em>Structure in Complexity Theory Conference</em>, pages 156–161. IEEE Computer Society, 1988.</li>

      <li><span id="page-16-10"></span>[37] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>EUROCRYPT</em>, May 2013.</li>

      <li><span id="page-16-22"></span>[38] C. Gentry. <em>A fully homomorphic encryption scheme</em>. PhD thesis, Stanford University, 2009.</li>

      <li><span id="page-16-11"></span>[39] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In <em>STOC</em>, pages 99–108, June 2011.</li>

      <li><span id="page-16-4"></span>[40] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. Delegating computation: Interactive proofs for muggles. In <em>STOC</em>, 2008.</li>

      <li><span id="page-16-19"></span>[41] S. Goldwasser, H. Lin, and A. Rubinstein. Delegation of computation without rejection problem from designated verifier CS-proofs. <em>IACR Cryptology ePrint Archive</em>, 2011:456, 2011.</li>

      <li><span id="page-16-5"></span>[42] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof systems. <em>SIAM J. on Comp.</em>, 18(1):186–208, 1989.</li>

      <li><span id="page-16-20"></span>[43] J. Groth. Short pairing-based non-interactive zero-knowledge arguments. In <em>ASIACRYPT</em>, 2010.</li>

      <li><span id="page-16-26"></span>[44] Y. Gurevich and S. Shelah. Nearly linear time. In A. R. Meyer and M. A. Taitslin, editors, <em>Logic at Botik</em>, volume 363 of <em>Lecture Notes in Computer Science</em>, pages 108–118. Springer, 1989.</li>

      <li><span id="page-16-1"></span>[45] A. Haeberlen, P. Kouznetsov, and P. Druschel. PeerReview: Practical accountability for distributed systems. In <em>SOSP</em>, 2007.</li>

      <li><span id="page-16-6"></span>[46] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Efficient arguments without short PCPs. In <em>Conference on Computational Complexity (CCC)</em>, 2007.</li>

      <li><span id="page-16-3"></span>[47] S. Jha, S. Katzenbeisser, C. Schallhart, H. Veith, and S. Chenney. Semantic integrity in large-scale online simulations. <em>ACM Transactions on Internet Technology (TOIT)</em>, 10(1), Feb. 2010.</li>

      <li><span id="page-16-24"></span>[48] Y. T. Kalai, R. Raz, and R. Rothblum. How to delegate computations: The power of no-signaling proofs. <em>Electronic Colloquium on Computational Complexity (ECCC)</em>, 20:183, 2013.</li>

      <li><span id="page-16-25"></span>[49] Y. T. Kalai, R. Raz, and R. D. Rothblum. Delegation for bounded space. In D. Boneh, T. Roughgarden, and</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>J. Feigenbaum, editors, <em>STOC</em>, pages 565–574. ACM, 2013.</li>

      <li><span id="page-17-0"></span>[50] G. O. Karame, M. Strasser, and S. Capkun. Secure remote execution of sequential computations. In <em>Intl. Conf. on Information and Communications Security</em>, 2009.</li>

      <li><span id="page-17-9"></span>[51] J. Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In <em>STOC</em>, 1992.</li>

      <li><span id="page-17-20"></span>[52] G. Kol and R. Raz. Competing provers protocols for circuit evaluation. In R. D. Kleinberg, editor, <em>ITCS</em>, pages 473–484. ACM, 2013.</li>

      <li><span id="page-17-21"></span>[53] H. Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In <em>IACR TCC</em>, 2011.</li>

      <li><span id="page-17-10"></span>[54] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan. Algebraic methods for interactive proof systems. <em>J. of the ACM</em>, 39(4):859–868, 1992.</li>

      <li><span id="page-17-1"></span>[55] D. Malkhi and M. Reiter. Byzantine quorum systems. <em>Distributed Computing</em>, 11(4):203–213, 1998.</li>

      <li><span id="page-17-3"></span>[56] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and H. Isozaki. Flicker: An execution infrastructure for TCB minimization. In <em>EuroSys</em>, 2008.</li>

      <li><span id="page-17-25"></span>[57] S. Micali. Computationally sound proofs. <em>SIAM J. on Comp.</em>, 30(4):1253–1298, 2000.</li>

      <li><span id="page-17-22"></span>[58] T. Mie. Polylogarithmic two-round argument systems. <em>J. Mathematical Cryptology</em>, 2(4):343–363, 2008.</li>

      <li><span id="page-17-8"></span>[59] F. Monrose, P. Wycko, and A. D. Rubin. Distributed execution with remote audit. In <em>NDSS</em>, 1999.</li>

      <li><span id="page-17-29"></span>[60] D. Moshkovitz and R. Raz. Sub-constant error low degree test of almost-linear size. <em>SIAM J. Comput.</em>, 38(1):140–180, 2008.</li>

      <li><span id="page-17-13"></span>[61] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In <em>IEEE Symposium on Security and Privacy</em>, 2013.</li>

      <li><span id="page-17-4"></span>[62] B. Parno, J. M. McCune, and A. Perrig. <em>Bootstrapping Trust in Modern Computers</em>. Springer, 2011.</li>

      <li><span id="page-17-24"></span>[63] J. M. Robson. An <em>O</em>(<em>T</em> log <em>T</em>) reduction from RAM computations to satisfiability. <em>Theor. Comput. Sci.</em>, 82(1):141–149, 1991.</li>

      <li><span id="page-17-28"></span>[64] G. N. Rothblum. <em>Delegating Computation Reliably: Paradigms and Constructions</em>. PhD thesis, Massachusetts Institute of Technology, 2009.</li>

      <li><span id="page-17-2"></span>[65] A.-R. Sadeghi, T. Schneider, and M. Winandy. Token-based cloud computing: secure outsourcing of data and arbitrary computations with lower latency. In <em>TRUST</em>, 2010.</li>

      <li><span id="page-17-5"></span>[66] R. Sailer, X. Zhang, T. Jaeger, and L. van Doorn. Design and implementation of a TCG-based integrity measurement architecture. In <em>USENIX Security</em>, 2004.</li>

      <li><span id="page-17-6"></span>[67] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. van Doorn, and P. Khosla. Pioneer: Verifying integrity and guaranteeing execution of code on legacy platforms. In <em>SOSP</em>, 2005.</li>

      <li><span id="page-17-14"></span>[68] S. Setty, A. J. Blumberg, and M. Walfish. Toward practical and unconditional verification of remote computations. In <em>HotOS</em>, 2011.</li>

      <li><span id="page-17-19"></span>[69] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In <em>EuroSys</em>, Apr. 2013.</li>

      <li><span id="page-17-23"></span>[70] S. Setty, R. McPherson, A. J. Blumberg, and M. Walfish. Making argument systems for outsourced computation practical (sometimes). In <em>NDSS</em>, 2012.</li>

      <li><span id="page-17-15"></span>[71] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish. Taking proof-based verified computation a few steps closer to practicality. In <em>USENIX Security</em>, 2012.</li>

      <li><span id="page-17-11"></span>[72] A. Shamir. IP = PSPACE. <em>J. of the ACM</em>, 39(4):869–877, 1992.</li>

      <li><span id="page-17-7"></span>[73] F. Stumpf, A. Fuchs, S. Katzenbeisser, and C. Eckert. Improving the scalability of platform attestation. In <em>ACM Workshop on Scalable Trusted Computing</em>, 2008.</li>

      <li><span id="page-17-18"></span>[74] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In <em>CRYPTO</em>, 2013.</li>

      <li><span id="page-17-16"></span>[75] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pfister. Verifiable computation with massively parallel interactive proofs. In <em>USENIX HotCloud Workshop</em>, 2012.</li>

      <li><span id="page-17-17"></span>[76] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for interactive verifiable computation. In <em>IEEE Symposium on Security and Privacy</em>, 2013.</li>

      <li><span id="page-17-26"></span>[77] R. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. Cryptology ePrint Archive, Report 2014/674, 2014.</li>

      <li><span id="page-17-12"></span>[78] M. Walfish and A. J. Blumberg. Verifying computations without reexecuting them: from theoretical possibility to near practicality. Technical Report TR13-165, Electronic Colloquium on Computational Complexity (ECCC), Nov. 2013. <http://eccc.hpi-web.de/report/2013/165/>. Forthcoming in <em>Communications of the ACM (CACM)</em>.</li>

      <li><span id="page-17-27"></span>[79] R. Zippel. Probabilistic algorithms for sparse polynomials. In E. W. Ng, editor, <em>EUROSAM</em>, volume 72 of <em>Lecture</em></li>

    </ul>

    <h2 id="sec-22" class="text-2xl font-bold">A Soundness analysis</h2>

    <p class="text-gray-300">In this section, we detail our proof of soundness for our MIP. The starting point is the soundness guarantee for the point vs. plane low-degree test obtained by Moshkovitz and Raz [60].</p>

    <p class="text-gray-300">In the following, let A denote an oracle that on input  <span class="math">w_4 \\in \\mathbb{F}^s</span>  returns some value  <span class="math">A(w_4)</span>  (purported to be  <span class="math">\\widetilde{W}(w_4)</span> ). Let Q denote the set of all planes in  <span class="math">\\mathbb{F}^s</span> . Let A' denote an oracle that on input  <span class="math">Q \\in Q</span>  returns some bivariate polynomial A'(Q) of degree s in each variable (purported to be  <span class="math">\\widetilde{W} \\circ Q</span> , the restriction of  <span class="math">\\widetilde{W}</span>  to the plane specified by Q).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-18-1"></span><strong>Lemma A.1</strong> ([60]). Denote  $\\epsilon = 2^7 s \\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/8} + s^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/4} \\right)<span class="math"> . For every pair of oracles A, A&#x27;, the following holds. For every  </span>\\delta > 2\\epsilon<span class="math"> , there exist  </span>t \\leq 2/\\delta<span class="math">  polynomials  </span>T_1, \\ldots, T_t : \\mathbb{F}^m \\to \\mathbb{F}<span class="math">  with  </span>\\deg(T_i) \\leq s^2<span class="math"> , such that with probability at least  </span>1 - \\delta - 2\\epsilon<span class="math"> , either A and A&#x27; make conflicting claims about  </span>\\widetilde{W}(w_4)<span class="math"> , or the test picks a point  </span>w_4 \\in \\mathbb{F}^s<span class="math">  such that  </span>A(w_4) = T_i(w_4)<span class="math">  for some  </span>i \\in \\{1, \\ldots, 2/\\delta\\}$  (or both).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In our setting,  <span class="math">\\mathcal{P}_2</span>  is equivalent to the oracle A' in Lemma A.1, as  <span class="math">\\mathcal{V}</span>  poses just a single question to  <span class="math">\\mathcal{P}_2</span> . Nonetheless, we still cannot directly apply Lemma A.1. The problem is that invoking the lemma would require us to view  <span class="math">\\mathcal{P}_1</span>  as an oracle mapping  <span class="math">w_4</span>  to  <span class="math">v_4</span>  (i.e. mapping  <span class="math">w_4</span>  to the claimed value of  <span class="math">\\widetilde{W}(w_4)</span> ). However,  <span class="math">\\mathcal{P}_1</span> 's claim about the value of  <span class="math">\\widetilde{W}(w_4)</span>  can depend not just on  <span class="math">w_4</span> , but instead on the entire <em>protocol history</em>, i.e., the entire sequence of messages exchanged with  <span class="math">\\mathcal{V}</span>  over the course of the protocol. Hence,  <span class="math">\\mathcal{P}_1</span>  cannot be viewed as an oracle mapping  <span class="math">w_4</span>  to  <span class="math">v_4</span> , and this complicates the application of Lemma A.1.</p>

    <p class="text-gray-300">Nonetheless, we are able to obtain the following variant of Lemma A.1 that suffices for our analysis. A key observation in obtaining this lemma is that although  <span class="math">\\mathcal{P}_1</span>  can provide different answers on different histories that lead to the query  <span class="math">w_4</span> , only  <span class="math">\\frac{10}{\\delta}</span>  of these answers can be consistent with  <span class="math">\\mathcal{P}_2</span> 's claim about  <span class="math">w_4</span>  with probability at least  <span class="math">\\delta/10</span>  over  <span class="math">\\mathcal{V}</span> 's choice of a random plane through  <span class="math">w_4</span> . We can safely ignore all other answers on  <span class="math">w_4</span>  without significantly affecting our estimate of the soundness error of the protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-18-2"></span><strong>Lemma A.2.</strong> Denote  $\\epsilon = 2^7 s \\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/8} + s^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/4} \\right)<span class="math"> . For every pair of prover strategies  </span>\\mathcal{P}_1<span class="math"> ,  </span>\\mathcal{P}_2$  in our protocol, the following holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For every  <span class="math">\\delta &gt; 2\\epsilon</span> , there exist  <span class="math">t \\leq 200/\\delta^3</span>  polynomials  <span class="math">T_1, \\ldots, T_t : \\mathbb{F}^m \\to \\mathbb{F}</span>  with  <span class="math">\\deg(T_i) \\leq s^2</span> , such that with probability at least  <span class="math">1 - 1.25\\delta - 2\\epsilon</span> , either  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  make conflicting claims about  <span class="math">\\widetilde{W}(w_4)</span> , or the low-degree test picks a point  <span class="math">w_4 \\in \\mathbb{F}^s</span>  such that  <span class="math">v_4 = T_i(w_4)</span>  for some  <span class="math">i \\in \\{1, \\ldots, 200/\\delta^3\\}</span>  (or both).</p>

    <p class="text-gray-300"><em>Proof.</em> Over the course of the protocol, V sends  <span class="math">\\mathcal{P}_1</span>  one field element per round, ultimately specifying  <span class="math">\\mathbf{h} = (w_1, w_2, w_3, \\tau) \\in \\mathbb{F}^{3s+1}</span> , eventually leading  <span class="math">\\mathcal{P}_1</span>  to make a claim that  <span class="math">\\widetilde{W}(w_4) = v_4</span> , where  <span class="math">w_4 = \\ell_{\\mathbf{h}}(\\tau)</span> , and  <span class="math">\\ell_{\\mathbf{h}}</span>  is the degree-two curve passing through  <span class="math">(w_1, v_1), (w_2, v_2), (w_3, v_3)</span> .</p>

    <p class="text-gray-300">In order to invoke Lemma A.1, we would like to view  <span class="math">\\mathcal{P}_1</span>  as an oracle mapping  <span class="math">w_4</span>  to  <span class="math">v_4</span>  (i.e., mapping  <span class="math">w_4</span>  to the claimed value of  <span class="math">\\widetilde{W}(w_4)</span> ). However, for each  <span class="math">w_4 \\in \\mathbb{F}^{3s}</span> , there are many <strong>h</strong>'s such that  <span class="math">w_4 = \\ell_{\\mathbf{h}}(\\tau)</span> , and  <span class="math">\\mathcal{P}_1</span>  may not provide the same answer on every history <strong>h</strong> such that  <span class="math">\\ell_{\\mathbf{h}}(\\tau) = w_4</span> . Thus, it is not straightforward to view  <span class="math">\\mathcal{P}_1</span>  as an oracle as in Lemma A.1.</p>

    <p class="text-gray-300">We observe that although  <span class="math">\\mathcal{P}_1</span>  can provide different answers  <span class="math">v_4</span>  on different <strong>h</strong>'s that lead to the query  <span class="math">w_4</span> , only  <span class="math">\\frac{10}{\\delta}</span>  of these answers can pass the point vs. plane test (conditioned on the point being  <span class="math">w_4</span> ) with probability  <span class="math">\\delta/10</span> . Formally, this follows from Markov's inequality as explained next.</p>

    <p class="text-gray-300">Recall that in the point vs. plane test, V sends  <span class="math">\\mathcal{P}_2</span>  a random plane Q through the point  <span class="math">w_4</span> .  <span class="math">\\mathcal{P}_2</span>  responds with a bivariate polynomial  <span class="math">H_Q^<em></span>  of degree s in each variable claimed to equal  <span class="math">\\widetilde{W} \\circ Q</span> . Let  <span class="math">(t_1, t_2)</span>  be the point such that  <span class="math">Q(t_1, t_2) = w_4</span> . V considers  <span class="math">H_Q^</em>(t_1, t_2)</span>  to be  <span class="math">\\mathcal{P}_2</span> 's claim about the value of  <span class="math">\\widetilde{W}(w_4)</span> .</p>

    <p class="text-gray-300">Call a value  <span class="math">v_4 \\in \\mathbb{F}</span>  good for query  <span class="math">\\tilde{w}_4 \\in \\mathbb{F}^s</span>  if  <span class="math">\\Pr_{Q:w_4 \\in Q}[H_Q^*(t_1, t_2) = v_4] \\ge \\delta/10</span> , Here, the probability is taken over all planes Q containing  <span class="math">w_4</span> . Let  <span class="math">S_{w_4} \\subseteq \\mathbb{F}</span>  denote that set of all good values for the query  <span class="math">w_4</span> . Then it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$1 \\geq \\sum_{\\nu_4 \\in \\mathcal{S}_{w_4}} \\Pr_{Q:w_4 \\in \\mathcal{Q}} [H_Q^*(t_1, t_2) = \\nu_4] \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{w_4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta/10.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{w_4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 10/\\delta<span class="math">  as claimed. We can safely ignore all <em>bad</em> answers on  </span>w_4<span class="math">  without affecting our estimate of the acceptance probability of the point vs. line test by more than an additive  </span>\\delta/10<span class="math">  factor (we absorb this additive factor into the statement of the theorem). We henceforth assume that on query  </span>w_4<span class="math"> ,  </span>\\mathcal{P}_1<span class="math">  outputs a value  </span>v_4 \\in S_{w_4}<span class="math">  regardless of the history <strong>h</strong> that led to the query  </span>w_4$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">At this point, we can view  <span class="math">\\mathcal{P}_1</span>  as a probabilistic function that on query  <span class="math">w_4 \\in \\mathbb{F}^s</span>  outputs  <span class="math">v_4 \\in \\mathcal{S}_{w_4}</span>  with some probability  $p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4)<span class="math"> , where  </span>\\mathcal{S}_{w_4}<span class="math">  has size at most  </span>10/\\delta<span class="math"> . Formally, let  </span>\\mathbf{H}_{w_4} = \\{\\mathbf{h} = (w_1, w_2, w_3, \\tau) : \\ell_{\\mathbf{h}}(\\tau) = w_4\\}<span class="math">  denote the set of histories that lead to the query  </span>w_4<span class="math"> , and let  </span>\\mathbf{H}_{w_4,v_4} \\subseteq \\mathbf{H}_{w_4}<span class="math">  denote the set of histories that lead to query  </span>w_4<span class="math">  for which  </span>\\mathcal{P}_1<span class="math">  outputs the value  </span>v_4<span class="math"> . Define  </span>p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{H}_{w_4,v_4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{H}_{w_4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Notice that  </span>p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4)<span class="math">  is the probability  </span>\\mathcal{P}_1<span class="math">  outputs  </span>v_4<span class="math">  conditioned on the query being  </span>w_4$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We further assume that  $p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4)<span class="math">  is an integer multiple of  </span>(\\delta/10)^2<span class="math">  for all pairs  </span>(w_4, v_4)<span class="math">  – if this is not the case, we round  </span>p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4)<span class="math">  to the nearest integer multiple of  </span>(\\delta/10)^2<span class="math">  and re-normalize to ensure that for each  </span>w_4 \\in \\mathbb{F}^s<span class="math"> ,  </span>\\sum_{v_4 \\in \\mathbb{F}} p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4) = 1<span class="math"> . For each  </span>w_4<span class="math"> , the total variation distance between the rounded distribution  </span>p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4)<span class="math">  and the original distribution is at most  </span>\\frac{1}{2} \\sum_{v_4 \\in \\mathcal{S}_{w_4}} (\\delta/10)^2 \\le \\delta/20<span class="math"> , and we absorb this  </span>\\delta/20<span class="math">  factor into the statement of the theorem. For any query  </span>w_4<span class="math"> , we can now think of  </span>p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4)<span class="math">  as the uniform distribution over a multiset  </span>\\mathcal{M}_{w_4}<span class="math">  of  </span>(10/\\delta^2)<span class="math">  items, where we include an item  </span>v_4<span class="math">  in the multiset with multiplicity c if  </span>p(v_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_4) = c \\cdot (\\delta/10)^2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This enables us to view  <span class="math">\\mathcal{P}_1</span>  as a convex combination of  <span class="math">(10/\\delta)^2</span>  oracles  <span class="math">A_j</span> , where  <span class="math">A_j(w_4)</span>  is the jth item in  <span class="math">\\mathcal{M}_{w_4}</span> . That is, for <em>every</em>  <span class="math">w_4 \\in \\mathbb{F}^{3s}</span> ,  <span class="math">\\mathcal{P}_1(w_4)</span>  is distributed identically to the prover that chooses a j at random from  <span class="math">\\{1, \\ldots, (10/\\delta)^2\\}</span>  and outputs  <span class="math">A_j(w_4)</span>  (where the probability is taken over all histories  <span class="math">\\mathbf{h} = (w_1, w_2, w_3, \\tau) \\in \\mathbb{F}^{3s+1}</span>  that lead to the query  <span class="math">w_4 = \\ell_{\\mathbf{h}}(\\tau)</span> ).</p>

    <p class="text-gray-300">Lemma A.1 guarantees that for each such oracle  <span class="math">A_j</span> , there is a set  <span class="math">\\mathcal{T}_j</span>  of  <span class="math">2/\\delta</span>  polynomials  <span class="math">T_{j,i}</span>  such that with probability at least  <span class="math">1 - \\delta - 2\\epsilon</span> , either the low-degree test fails or it encounters a query  <span class="math">w_4</span>  such that  <span class="math">A_j(w_4) = T_{j,i}</span>  for some  <span class="math">i \\in \\{1, \\ldots, 2/\\delta\\}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{T}</span>  be the union of the  <span class="math">T_{j,i}</span> 's over all  <span class="math">A_j</span> 's.  <span class="math">\\mathcal{T}</span>  is a set of  <span class="math">200/\\delta^3</span>  polynomials. Let  <span class="math">E_j</span>  denote the event that given oracles  <span class="math">A_j</span>  and A', the low-degree test encounters a point that disagrees with all  <span class="math">T_{j,i}</span> 's and still accepts. The probability that  <span class="math">\\mathcal{V}</span>  encounters a point  <span class="math">w_4</span>  for which  <span class="math">\\mathcal{P}_1</span>  claims  <span class="math">\\widetilde{W}(w_4) = v_4</span> ,  <span class="math">T_{j,i}(w_4) \\neq v_4</span>  for all (j,i), and the low-degree test passes is at most</p>

    <div class="my-4 text-center"><span class="math-block">(\\delta/10)^2 \\sum_{1 \\le j \\le (10/\\delta)^2} \\Pr[E_j] \\le (\\delta/10)^2 \\left( \\sum_{j \\le (10/\\delta)^2} \\delta + 2\\epsilon \\right) = \\delta + 2\\epsilon.</span></div>

    <p class="text-gray-300">Notice that the size t of the set of polynomials  <span class="math">\\{T_i: i \\leq t\\}</span>  in Lemma A.2 is much larger than the size t appearing in Lemma A.1. It turns out that this weakening is not significant in our setting, because the set size t still contributes only low-order terms in our analysis. With Lemma A.2 in hand, the remainder of our analysis shows that if  <span class="math">\\mathcal{P}_1</span>  passes both the sum-check protocol and the low-degree test even with small probability, then there must be a single polynomial in the set  <span class="math">\\{T_i: i \\leq t\\}</span>  whose existence is guaranteed by Lemma A.2 with which  <span class="math">\\mathcal{P}_1</span> 's messages in all rounds of our MIP are consistent. Moreover, this polynomial must be an extension of a correct transcript. We obtain the following theorem.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-19-0"></span><strong>Theorem A.1.</strong> Denote  $\\epsilon = 2^7 s \\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/8} + s^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/4} \\right)<span class="math"> . Let  </span>\\delta > 2\\epsilon<span class="math"> . Suppose  </span>\\mathcal{P}_1<span class="math">  and  </span>\\mathcal{P}_2<span class="math">  pass the low-degree test with probability  </span>1 - 1.25\\delta - 2\\epsilon<span class="math"> . Let  </span>\\mathcal{T}<span class="math">  be the set of at most  </span>200/\\delta^3<span class="math">  polynomials whose existence is guaranteed by Lemma A.2. Then if no  </span>T_i \\in \\mathcal{T}<span class="math">  is an extension of a valid transcript,  </span>\\mathcal{P}_1<span class="math">  will fail some consistency test in our MIP with probability at least  </span>1 - \\frac{601s^3 + 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\delta^3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The  $\\delta' := \\frac{601s^3}{\\delta^3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  term in Theorem A.1 is a low-order term for the field sizes used in our implementation, because  </span>\\epsilon<span class="math"> &#x27;s dependence on  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is worse than that of  </span>\\delta'$  by a factor of 8 in the exponent.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> We begin by considering the final round of  <span class="math">\\mathcal{P}_1</span> 's interaction with  <span class="math">\\mathcal{V}</span> . Recall that this round is devoted to reducing a claim about  <span class="math">\\widetilde{W}(w_1)</span> ,  <span class="math">\\widetilde{W}(w_2)</span> , and  <span class="math">\\widetilde{W}(w_3)</span>  to a claim about  <span class="math">\\widetilde{W}(w_4)</span>  for a single point  <span class="math">w_4</span>  (see lines 7–21 in Figure 5). We show the following easy lemma.</p>

    <p class="text-gray-300"><span id="page-20-0"></span><strong>Lemma A.3.</strong> In the final round of our MIP, if  <span class="math">\\mathcal{P}_1</span>  does not send a polynomial K (cf. Line 12 of Figure 5) of the form  <span class="math">T_i \\circ \\ell_W</span>  for some  <span class="math">T_i \\in \\mathcal{T}</span> , then  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  will fail the low-degree test with probability  <span class="math">1 - 1.25\\delta - 2\\epsilon</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Proof of Lemma A.3.</em> The polynomial K that  <span class="math">\\mathcal{P}_1</span>  sends in the final round of the MIP must be of degree at most 2s, and each  <span class="math">T_i \\circ \\ell_W</span>  is a polynomial of degree at most  <span class="math">s^2</span> . Thus, if K does not equal  <span class="math">T_i \\circ \\ell_W</span>  for some  <span class="math">T_i \\in \\mathcal{T}</span> , then the Schwartz-Zippel lemma along with a union bound implies that  <span class="math">K(\\tau)</span>  disagrees with <em>all</em> polynomials of the form  <span class="math">T_i \\circ \\ell_W</span>  with probability  $1 - \\frac{200s^2}{\\delta^3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over the random choice of  </span>\\tau<span class="math"> . In this event, Lemma A.2 implies that the low-degree test rejects with probability  </span>1 - 1.25\\delta - 2\\epsilon$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recall that in our MIP, V first sends a random element  <span class="math">q \\in \\mathbb{F}</span>  to  <span class="math">\\mathcal{P}_1</span>  (cf. Line 5 of Figure 5), and then V and  <span class="math">\\mathcal{P}_1</span>  apply the sum-check protocol to the polynomial</p>

    <p class="text-gray-300"><span id="page-20-1"></span> <span class="math-block">h_q(u_1, u_2, u_3) = \\widetilde{G}_{x,y}(u_1, u_2, u_3) \\cdot g_q(u_1, u_2, u_3), \\tag{4}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math-block">\\widetilde{G}_{x,y}(u_1, u_2, u_3) = \\left(\\widetilde{io}(u_1, u_2, u_3) \\cdot (\\widetilde{I}_{x,y}(u_1) - \\widetilde{W}(u_1)) + \\widetilde{add}(u_1, u_2, u_3) \\cdot (\\widetilde{W}(u_1) - (\\widetilde{W}(u_2) + \\widetilde{W}(u_3))) + \\widetilde{mult}(u_1, u_2, u_3) \\cdot (\\widetilde{W}(u_1) - \\widetilde{W}(u_2) \\cdot \\widetilde{W}(u_3))\\right),</span> (5)</p>

    <p class="text-gray-300">and  <span class="math">g_q(u_1, u_2, u_3)</span>  is the multilinear extension of the function  <span class="math">(u_1, u_2, u_3) \\mapsto q^{(u_1, u_2, u_3)}</span> . For notational simplicity, throughout the remainder of the proof, we will assume that the polynomials  <span class="math">\\widetilde{io}</span> ,  <span class="math">\\widetilde{add}</span> , and  <span class="math">\\widetilde{mult}</span>  in the definition of  <span class="math">h_q</span>  are multilinear – the analysis is identical even if their degree is larger, and our stated soundness bound is unaffected as long as the degree of each polynomial in each variable is at most  <span class="math">s^2</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\widetilde{G}_{x,y}^{T_i}</span>  denote the polynomial obtained by substituting the polynomial  <span class="math">T_i</span>  in place of the polynomial  <span class="math">\\widetilde{W}</span>  within the right hand side of Equation (5), and let  <span class="math">h_q^{T_i}(u_1,u_2,u_3)=\\widetilde{G}_{x,y}^{T_i}(u_1,u_2,u_3)\\cdot g_q(u_1,u_2,u_3)</span> . Similarly, let  <span class="math">H_j^{T_i}</span>  denote the message from  <span class="math">\\mathcal{P}_1</span>  prescribed in round j by the sum-check protocol when applied to the polynomial  <span class="math">h_q^{T_i}</span> . Let  <span class="math">H_j</span>  denote the message  <span class="math">\\mathcal{P}_1</span>  actually sends in round j of the sum-check protocol. If  <span class="math">H_j=H_j^{T_i}</span> , we say  <span class="math">H_j</span>  is based on polynomial  <span class="math">T_i</span> . We also say that  <span class="math">\\mathcal{P}_1</span>  is left with a consistent claim in round j+1 if  <span class="math">H_j(r_j)=H_{j+1}^{T_i}(0)+H_{j+1}^{T_i}(1)</span>  for some  <span class="math">T_i\\in\\mathcal{T}</span> , and we say that  <span class="math">\\mathcal{P}_1</span>  is left with an inconsistent claim otherwise.</p>

    <p class="text-gray-300"><span id="page-20-2"></span><strong>Lemma A.4.</strong> If  <span class="math">\\mathcal{P}_1</span>  is left with an inconsistent claim in round j of the sum-check protocol, then either  <span class="math">\\mathcal{V}</span> 's check at round j will fail (cf. Line 11 of Figure 6), or  <span class="math">\\mathcal{P}_1</span>  will be left with an inconsistent claim at round j+1 with probability at least  <span class="math">1 - \\frac{200s^2 + 2}{\\delta^3 \\mathbb{I}\\mathbb{F}^1}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Theorem A.1, assuming Lemma A.4. Lemma A.4 implies that if  <span class="math">\\mathcal{P}_1</span> 's message in the first round of the sum-check protocol is not based on a polynomial  <span class="math">T_i \\in \\mathcal{T}</span> , then either  <span class="math">\\mathcal{V}</span>  will halt and reject at some round during the sum-check protocol, or  <span class="math">\\mathcal{P}_1</span>  will be left with an inconsistent claim in round 3s (i.e., in the final round) of the sum-check protocol with probability at least  $1 - \\frac{600s^3}{\\delta^3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . In the latter event,  </span>\\mathcal{P}_1<span class="math">  will be forced to send values  </span>v_1<span class="math"> ,  </span>v_2<span class="math"> , and  </span>v_3<span class="math">  (Line 22 of Figure 6) such that there is no  </span>T_i \\in \\mathcal{T}<span class="math">  satisfying  </span>T_i(w_i) = v_i$  for all</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> <span class="math">j \\in \\{1, 2, 3\\}</span> ; otherwise,  <span class="math">\\mathcal{V}</span>  will reject in Line 32 of Figure 6 (i.e.,  <span class="math">v_1, v_2</span> , and  <span class="math">v_3</span>  will be inconsistent with  <span class="math">\\mathcal{P}_1</span> 's claim in the final round of the sum-check protocol). But if there is no  <span class="math">T_i \\in \\mathcal{T}</span>  satisfying  <span class="math">T_i(w_j) = v_j</span>  for all  <span class="math">j \\in \\{1, 2, 3\\}</span> , then  <span class="math">\\mathcal{P}_1</span>  will be forced to send a polynomial K in the final round of the entire MIP (cf. Line 12 of Figure 5) that is not of the form  <span class="math">T_i \\circ \\ell_W</span>  for any  <span class="math">T_i \\in \\mathcal{T}</span> ; otherwise,  <span class="math">\\mathcal{V}</span>  will reject in Line 18 of Figure 5 (i.e., K will be inconsistent with  <span class="math">v_1, v_2</span> , and  <span class="math">v_3</span> ). By Lemma A.3, this implies that  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  will fail the low-degree test with probability at least  <span class="math">1 - 1.25\\delta - 2\\epsilon</span> .</p>

    <p class="text-gray-300">Hence, if  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  fail the low-degree test with probability less than  <span class="math">1 - 1.25\\delta - 2\\epsilon</span> , then  <span class="math">\\mathcal{P}_1</span> 's message in the first round of the sum-check protocol is based on a polynomial  <span class="math">T_i \\in \\mathcal{T}</span> . By design, this implies that  <span class="math">0 = \\sum_{u \\in \\{0,1\\}^{3s}} h_q^{T_i}(u)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">F_{x,y}^{T_i}(t)</span>  denote the polynomial  <span class="math">\\sum_{\\{0,1\\}^{3s}} \\widetilde{G}_{x,y}^{T_i}(u) \\cdot g_q(u)</span>  (i.e.,  <span class="math">F_{x,y}^{T_i}(t)</span>  is the polynomial obtained by substituting  <span class="math">\\widetilde{G}_{x,y}^{T_i}</span>  for  <span class="math">\\widetilde{G}_{x,y}</span>  in Equation (2)). Then  <span class="math">F_{x,y}^{T_i}(q) = \\sum_{u \\in \\{0,1\\}^{3s}} h_q^{T_i}(u) = 0</span> . Since  <span class="math">F_{x,y}^{T_i}</span>  has degree at most  $3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and q was chosen at random from  </span>\\mathbb{F}<span class="math">  by  </span>\\mathcal{V}<span class="math"> , the Schwartz-Zippel lemma implies that with probability at least  </span>1 - 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\mathbb{F}<span class="math"> ,  </span>F_{x,y}^{T_i}<span class="math">  must be the zero polynomial. This in turn implies that  </span>T_i<span class="math">  vanishes at all points in  </span>\\{0,1\\}^{3s}<span class="math"> , and hence that  </span>T_i<span class="math">  is an extension of a valid transcript for the circuit C. This completes the proof.  </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Lemma A.4. For notational simplicity, we assume that j < s. If  <span class="math">\\mathcal{P}_1</span>  is left with an inconsistent claim at round j, then  <span class="math">\\mathcal{P}_1</span>  must send a message  <span class="math">H_j</span>  that does not equal  <span class="math">H_j^{T_i}</span>  for any polynomial  <span class="math">T_i \\in \\mathcal{T}</span>  (otherwise,  <span class="math">\\mathcal{V}</span> 's check in round j will fail, and  <span class="math">\\mathcal{V}</span>  will reject – see Line 11 of Figure 5). We argue that if this is the case, then  <span class="math">\\mathcal{P}_1</span> 's message will disagree at all but a  $\\frac{200s^2}{\\delta^3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  fraction of points with all  </span>200/\\delta^3<span class="math">  messages  </span>H_k^{T_i}<span class="math">  that are based on a  </span>T_i \\in \\mathcal{T}<span class="math"> . This holds by the Schwartz-Zippel lemma, as  </span>\\mathcal{P}_1<span class="math"> &#x27;s message in each round is required to be a polynomial of degree at most 3, and each message based on  </span>T_i \\in \\mathcal{T}<span class="math">  is of degree at most  </span>s^2 + 2<span class="math"> , since each  </span>T_i<span class="math">  itself has degree at most  </span>s^2<span class="math"> . In the event that  </span>\\mathcal{V}<span class="math">  picks a point  </span>w_{1,j}<span class="math">  in Round j such that  </span>\\mathcal{P}_1<span class="math"> &#x27;s message disagrees with all polynomials based on  </span>T_i \\in \\mathcal{T}<span class="math">  at this point, then  </span>\\mathcal{P}_1<span class="math">  is left with a claim in round j + 1 that is inconsistent with all  </span>T_i \\in \\mathcal{T}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-23" class="text-2xl font-bold"><strong>B</strong> Systems innovations and optimizations in Clover</h2>

    <h4 id="sec-24" class="text-lg font-semibold mt-6"><strong>B.1</strong> Systems innovations</h4>

    <p class="text-gray-300">As previously mentioned (§5), Clover works with irregular circuits and relies on batching to achieve a cost savings for the verifier. It is implemented in 9839 lines of C++ code; a verifier process communicates with two prover processes via Open MPI [1].</p>

    <p class="text-gray-300"><strong>Expressiveness.</strong> Clover adapts the approach to circuit generation that was implemented in prior work on Zaatar [69] and Allspice [76]. The Zaatar compiler transforms high-level programs into <em>constraints</em>, which are slightly more general than arithmetic circuits: a constraint can involve a large number of variables, in contrast to a gate of fan-in 2. To produce arithmetic circuits, the Clover compiler post-processes Zaatar constraints, breaking any constraint involving a large number of variables into many gates of fan-in two.</p>

    <p class="text-gray-300">Clover handles inequalities and comparisons by adding a <em>compute-advice</em> and a <em>check-advice</em> subcircuit for each such operation; the approach is borrowed from Allspice [76, §4.1]. We modify the io(a, b, c) function to output 1 when a is the output of a <em>check-advice</em> circuit. The end result is a built system that is just as general as Zaatar.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Memory management.</strong> A fundamental issue in realizing our MIP protocol in a built system is that the entire transcript must be kept in a prover's memory at once. The high-level solution consists of several pieces. First, we develop a cache tailored to our application. Our cache provides an array-like interface, and its user can pretend that all of the field elements in the transcript are in a contiguous array. The cache transparently evicts elements to disk when it runs out of memory and reads in elements from disk as needed. Second, we compute multilinear extensions using memory that is linear in  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , building on an idea of Allspice We describe our technique in Appendix B.2.2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-25" class="text-lg font-semibold mt-6"><strong>B.2</strong> Algorithmic optimizations in Clover</h4>

    <h2 id="sec-26" class="text-2xl font-bold">B.2.1 Optimizing <span class="math">\\mathcal{P}_1</span> 's runtime</h2>

    <p class="text-gray-300">Each of  <span class="math">\\mathcal{P}_1</span> 's prescribed messages within the sum-check protocol applied to the polynomial  <span class="math">h_q</span>  defined in Section 4.2 is a univariate polynomial  <span class="math">H_j</span>  of degree at most 3, which can be specified via its evaluations at inputs  <span class="math">\\{0, 1, 2, 3\\}</span> . Vu et al. [76] showed that, given  <span class="math">H_j(0)</span> , the evaluation  <span class="math">H_j(1)</span>  can be computed in constant time. Thus, computing  <span class="math">H_j(1)</span>  is essentially free for  <span class="math">\\mathcal{P}_1</span> , and  <span class="math">\\mathcal{P}_1</span>  must only do substantial work to compute  <span class="math">H_j(0)</span>  and  <span class="math">H_j(2)</span> ,  <span class="math">H_j(3)</span> .</p>

    <p class="text-gray-300">Thus, if  <span class="math">H_j</span>  had degree 2,  <span class="math">\\mathcal{P}_1</span>  would run approximately 30% faster, as  <span class="math">\\mathcal{P}_1</span>  would not have to compute  <span class="math">H_j(3)</span> . We show how to achieve this.</p>

    <p class="text-gray-300">In Equation (3) of Section 4.2, we showed how to compute the quantity  <span class="math">F_{x,y}(q)</span>  by applying the sum-check protocol to a polynomial  <span class="math">h_q</span>  of degree at most 3 in each variable. Here, we give a polynomial  <span class="math">h_q&#x27;</span>  of degree only two in each variable that can be used in place of  <span class="math">h_q</span> . When we use  <span class="math">h_q&#x27;</span>  in place of  <span class="math">h_q</span> , verifier in the resulting MIP protocol may require a pre-processing phase <em>regardless</em> of whether the circuit  <span class="math">\\mathcal{C}</span>  satisfies the regularity conditions required by Lemma 4.2. However, our built system requires a pre-processing phase anyway, and hence there is no reason not to use the polynomial  <span class="math">h_q&#x27;</span>  in our built system. We define the polynomial  <span class="math">h_q&#x27;</span>  as follows.</p>

    <p class="text-gray-300">Let ioq denote the unique multilinear polynomial satisfying the following property: for each Boolean input  <span class="math">(u_1, u_2, u_3) \\in \\{0, 1\\}^{3s}</span> ,  <span class="math">\\widetilde{\\log}(u_1, u_2, u_3) = \\widetilde{\\mathrm{io}}(u_1, u_2, u_3) q^{(u_1, u_2, u_3)}</span> . Similarly, let  <span class="math">\\widetilde{\\mathrm{addq}}</span>  and  <span class="math">\\widetilde{\\mathrm{multq}}</span>  denote the multilinear polynomials defined such that for each Boolean input  <span class="math">(u_1, u_2, u_3) \\in \\{0, 1\\}^{3s}</span> ,  <span class="math">\\widetilde{\\mathrm{addq}}(u_1, u_2, u_3) = \\widetilde{\\mathrm{add}}(u_1, u_2, u_3) q^{(u_1, u_2, u_3)}</span> , and  <span class="math">\\widetilde{\\mathrm{multq}}(u_1, u_2, u_3) = \\widetilde{\\mathrm{mult}}(u_1, u_2, u_3) q^{(u_1, u_2, u_3)}</span> .</p>

    <p class="text-gray-300">Then we easily obtain the following analog of Equation (3):</p>

    <div class="my-4 text-center"><span class="math-block">F_{x,y}(q) = \\sum_{(u_1,u_2,u_3)\\in\\{0,1\\}^{3s}} h&#x27;_q(u_1,u_2,u_3),</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} h_q&#x27;(u_1,u_2,u_3) &amp;= \\widetilde{\\operatorname{ioq}}(u_1,u_2,u_3) \\cdot (\\widetilde{I_{x,y}}(u_1) - \\widetilde{W}(u_1)) \\\\ &amp;+ \\widetilde{\\operatorname{addq}}(u_1,u_2,u_3) \\cdot (\\widetilde{W}(u_1) - (\\widetilde{W}(u_2) + \\widetilde{W}(u_3))) \\\\ &amp;+ \\widetilde{\\operatorname{multq}}(u_1,u_2,u_3) \\cdot (\\widetilde{W}(u_1) - \\widetilde{W}(u_2) \\cdot \\widetilde{W}(u_3)). \\end{split}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This completes the description of the polynomial  <span class="math">h&#x27;_q</span> . At the end of the sum-check protocol applied to  <span class="math">h&#x27;_q</span> ,  <span class="math">\\mathcal{V}</span>  must evaluate  <span class="math">h&#x27;_q</span>  at a random point  <span class="math">(w_1, w_2, w_3) \\in \\mathbb{F}^{3s}</span> . Given the evaluations  <span class="math">\\widetilde{W}(w_1)</span> ,  <span class="math">\\widetilde{W}(w_2)</span>  and  <span class="math">\\widetilde{W}(w_3)</span> , the bottleneck in  <span class="math">\\mathcal{V}</span> 's computation of  <span class="math">h&#x27;_q(w_1, w_2, w_3)</span>  is in the evaluation of  <span class="math">\\widetilde{\\operatorname{addq}}(w_1, w_2, w_3)</span> , and  <span class="math">\\operatorname{multq}(w_1, w_2, w_3)</span> . Using the techniques of CMT combined with memoization ideas of Allspice, each of these quantities can be evaluated in time  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  by enumerating over each gate in  </span>\\mathcal{C}<span class="math">  and computing that gate&#x27;s contribution to  </span>\\widetilde{\\operatorname{addq}}(w_1, w_2, w_3)<span class="math">  and  </span>\\widetilde{\\operatorname{multq}}(w_1, w_2, w_3)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># <span id="page-22-1"></span>B.2.2 Computing <span class="math">\\widetilde{W}</span> in $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ space.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{P}_2</span> 's message (and  <span class="math">\\mathcal{P}_1</span> 's message after the sum-check protocol) requires it to evaluate  <span class="math">\\widetilde{W}</span>  at many points. Vu et al. [76, §5.1] showed that it is possible to perform this evaluation in  $4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  field multiplications using  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  space. We build upon this approach to develop a way to evaluate  </span>\\widetilde{W}<span class="math">  with the same number of field multiplications but using  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  space. §</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First, let  <span class="math">\\chi^{(0)}(t) = 1 - t</span>  and  <span class="math">\\chi^{(1)}(t) = t</span> . We define a family of functions  <span class="math">\\chi_{g_1,\\dots,g_s} : \\mathbb{F}^s \\to \\mathbb{F}</span> , where  <span class="math">\\chi_{g_1,\\dots,g_s}(u_1,\\dots,u_s) = \\prod_{i=1}^n \\chi^{(g_i)}(u_i)</span>  (note that in this context,  <span class="math">g = (g_1,\\dots,g_s)</span>  is a gate label). (note that in this context, g is a gate label).  <span class="math">\\widetilde{W}</span>  can be written as  <span class="math">\\widetilde{W}(u) = \\sum_{g \\in \\{0,1\\}^s} \\chi_g(u) \\cdot W(g)</span> .</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>8</sup>We do not consider the space required to store the gate values (i.e., the evaluations of <em>W</em>) as they can be easily streamed in from disk.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vu et al.'s technique involves using  $3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  field multiplications to computing a table containing the value of  </span>\\chi_g(u)<span class="math">  for all g where  </span>W(g) \\neq 0<span class="math"> , thus requiring space to store  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  field elements. However, notice that there is no need to store all such evaluations of  </span>\\chi_g<span class="math"> , since we only ever use each evaluation once. Instead, we do the following. When computing  </span>\\chi_g(u)<span class="math">  for some g, we save the partial products  </span>\\prod_{i=1}^k \\chi_{g_i}(u_i)<span class="math">  for  </span>k \\in [s]<span class="math"> . This requires space linear in  </span>s = \\lceil \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> . Then, when we must compute  </span>\\chi_{g'}(u)<span class="math">  for some other  </span>g' \\in \\{0,1\\}^s<span class="math"> , we need only use s-k multiplications, where k is the number of consecutive leading bits of g and g&#x27; that agree. In the worst case, this is simply s multiplications, but at best it is 1. We then save the new partial products of  </span>\\chi_{g'}(u)<span class="math"> , throwing away those for  </span>\\chi_g(u)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our technique, as described so far, requires space linear in  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , but by itself does not guarantee that we can compute  </span>\\widetilde{W}<span class="math">  in  </span>4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications. To achieve this, we must compute the needed evaluations of  </span>\\chi_g(u)<span class="math">  in a well-defined order: specifically, we begin with  </span>\\chi_{0,\\dots,0}(u)<span class="math">  then  </span>\\chi_{0,\\dots,1}(u)<span class="math"> , then  </span>\\chi_{0,\\dots,1,0}(u)<span class="math"> , and so on in lexicographic order until we reach  </span>\\chi_{1,\\dots,1}(u)<span class="math"> . Evaluating  </span>\\chi_{(0,\\dots,0,0)}(u)<span class="math">  requires n multiplications, but  </span>\\chi_{(0,\\dots,0,1)}(u)<span class="math">  only requires one, and  </span>\\chi_{(0,\\dots,1,0)}(u)<span class="math">  requires two. In fact, if we evaluate in this order, we need to do one multiply for each of the  </span>2^n<span class="math">  evaluations, then another for each of the  </span>2^{n-1}<span class="math">  evaluations where 2 divides g, another for the  </span>2^{n-2}<span class="math">  where 4 divides g, etc. The total number of multiplication is  </span>\\sum_{i=1}^n 2^i < 2^{n+1}<span class="math"> . By skipping any evaluations of  </span>\\chi_g(u)<span class="math">  where W(g)=0, the number of multiplications is reduced to  </span>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Thus, we require  </span>4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications to evaluate  </span>\\widetilde{W}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This technique can also be used to compute  <span class="math">\\widetilde{\\text{addq}}</span> ,  <span class="math">\\widetilde{\\text{multq}}</span> , and  <span class="math">\\widetilde{\\text{ioq}}</span>  in  $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  space.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section, we will use  <span class="math">\\widetilde{I_{x,y}}^{(i)}</span>  and  <span class="math">\\widetilde{W}^{(i)}</span>  to refer to the multilinear extensions of the input/output gates and the evaluation function, respectively, for the <em>i</em>th instance.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Because Clover re-uses randomness across all instances in a batch, there are points within the protocol where  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{P}_1</span> , or  <span class="math">\\mathcal{P}_2</span>  must, evaluate  <span class="math">\\widetilde{W}^{(i)}</span>  or  <span class="math">\\widetilde{I_{x,y}}^{(i)}</span>  at the same point for every i. Instead of evaluating each  <span class="math">\\widetilde{W}^{(i)}</span>  independently (thereby taking  $4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  field multiplications per instance), Clover merges the evaluations that share an input point into a setup phase requiring  </span>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications, and an online phase requiring  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications per instance. We will describe how Clover does this for  </span>\\widetilde{W}^{(i)}<span class="math"> . The  </span>\\widetilde{I_{x,y}}^{(i)}$  case is analogous.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall from Appendix B.2.2 that for every instance i,  <span class="math">\\widetilde{W}^{(i)} = \\sum_{g \\in \\{0,1\\}^s} \\chi_g(u) \\cdot W^{(i)}(g)</span> , where  <span class="math">W^{(i)}</span>  is the ith instance's evaluation function. Note that the factors  <span class="math">\\chi_g(u)</span>  for  <span class="math">g \\in \\{0,1\\}^s</span>  are constant across all instances (because u is constant), so we need only compute them once per batch. Clover can compute all required factors in  $3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications. Then for every instance, Clover must expend another  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplications to multiply the factors with  </span>W^{(i)}(b_1,\\ldots,b_n)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-28" class="text-2xl font-bold">C Proof of Knowledge</h2>

    <p class="text-gray-300">Bitansky and Chiesa [23] show that under a certain natural but non-standard hardness assumption, any complexity preserving MIP of knowledge can be transformed into a complexity preserving non-interactive succinct argument of knowledge (SNARK). Here, we show that our MIP for circuit satisfiability in fact satisfies this proof-of-knowledge property, and hence can be transformed into a complexity-preserving SNARK.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bitansky and Chiesa's formalization of their transformation from MIPs of knowledge to SNARKs utilizes the <em>universal relation</em>  <span class="math">\\mathcal{R}_{\\mathcal{U}}</span>  and its associated language, defined as follows. Let M denote a specification of a non-deterministic RAM.  <span class="math">\\mathcal{R}_{\\mathcal{U}}</span>  is the relation of instance-witness pairs (y; w), where  $y = (M; x; T),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq T<span class="math"> , and M accepts (x; w) after at most T steps. Let  </span>\\mathcal{L}_{\\mathcal{R}_{\\mathcal{U}}}<span class="math">  denote the language  </span>\\{y: \\exists w \\text{ such that}(y, w) \\in \\mathcal{R}_{\\mathcal{U}}\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Bitansky and Chiesa show how to transform an MIP of knowledge for  <span class="math">\\mathcal{L}_{\\mathcal{R}_{\\mathcal{U}}}</span>  into a corresponding SNARK. Their construction of an MIP of knowledge for  <span class="math">\\mathcal{L}_{\\mathcal{R}_{\\mathcal{U}}}</span>  works as follows. They first use the circuit-generation techniques of Ben-Sasson et al. [15] to reduce an instance of  <span class="math">\\mathcal{L}_{\\mathcal{R}_{\\mathcal{U}}}</span>  to an instance circuit satisfiability, and</p>

    <p class="text-gray-300">then they run their MIP of knowledge for circuit satisfiability. We will take the same approach, using our MIP protocol for circuit satisfiability in place of Bitansky and Chiesa's.</p>

    <p class="text-gray-300"><strong>Definition C.1.</strong> A two-prover MIP protocol with verifier  <span class="math">\\mathcal{V}</span>  for  <span class="math">\\mathcal{L}_{\\mathcal{R}_{\\mathcal{U}}}</span>  is an MIP of knowledge with knowledge threshold  <span class="math">\\tau</span>  if the following property holds. There is a polynomial time probabilistic oracle machine E, referred to as the extractor algorithm, such that for any pair of provers  <span class="math">(\\mathcal{P}_1^<em>, \\mathcal{P}_2^</em>)</span>  that cause  <span class="math">\\mathcal{V}</span>  to accept on input y = (M; x; T) with probability at least  <span class="math">\\tau</span> , it holds that  <span class="math">(y, E^{(\\mathcal{P}_1^<em>, \\mathcal{P}_2^</em>)}(y, 1^T)) \\in \\mathcal{R}_{\\mathcal{U}}</span>  with probability at least  <span class="math">1/n^c</span>  for some universal constant c > 0.</p>

    <p class="text-gray-300"><strong>Theorem C.1.</strong> The MIP protocol of Theorem 4.1 is an MIP of knowledge with knowledge threshold  <span class="math">\\tau = .96</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> In the MIP protocol of Theorem 4.1, the instance (M, x, t) is transformed into a circuit  <span class="math">\\mathcal{C}</span>  using the techniques of Ben-Sasson et al. [15], in such a way that any correct transcript W for  <span class="math">\\mathcal{C}</span>  possesses a witness w for (M, x) as a substring (see Lemma 4.2). In the MIP protocol,  <span class="math">\\mathcal{P}_1</span>  then claims to be holding an extension  <span class="math">\\widetilde{W}</span>  of a valid transcript W for  <span class="math">\\mathcal{C}</span> , and  <span class="math">\\mathcal{V}</span>  forces  <span class="math">\\mathcal{P}_1</span>  to send a value  <span class="math">v_4</span>  claimed to equal  <span class="math">\\widetilde{W}(w_4)</span> , for a value  <span class="math">w_4</span>  of the verifier's choosing. We let A denote the function  <span class="math">w_4 \\mapsto v_4</span>  represented by  <span class="math">\\mathcal{P}_1</span> . (Strictly speaking,  <span class="math">\\mathcal{P}_1</span>  may not be a <em>function</em> from  <span class="math">w_4</span>  to  <span class="math">v_4</span> , as there are many different "histories" that lead  <span class="math">\\mathcal{V}</span>  to ultimately query the point  <span class="math">w_4</span> , and  <span class="math">\\mathcal{P}_1</span> 's response may depend on this history. Assume for the moment, however, that  <span class="math">\\mathcal{P}_1</span>  is indeed a function  <span class="math">w_4 \\mapsto v_4</span> .)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our soundness analysis (Appendix A) exploits the so-called <em>list-decoding</em> property of the point vs. plane low-degree test [60, Theorem 1]. In order to establish our proof-of-knowledge property, we need only invoke the simpler <em>decoding</em> property of the point vs. plane test [60, Theorem 1]. This property guarantees that if  <span class="math">\\mathcal{P}_1</span>  and  <span class="math">\\mathcal{P}_2</span>  pass the low-degree test with probability  <span class="math">1-\\gamma</span> , then there is a polynomial T of degree at most  $O(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  such that  </span>\\Pr[A(w_4) = T(w_4)] > 1-\\gamma-\\epsilon<span class="math"> , where  </span>\\epsilon = 2^7 \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/8} + \\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/4}\\right)<span class="math"> . For fields of size  </span>\\operatorname{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> ,  </span>\\epsilon < .01<span class="math"> , and we conclude that for any constant  </span>\\gamma > 0<span class="math"> , the following holds: let  </span>\\gamma' = \\gamma - .01<span class="math"> . If the verifier accepts input  </span>\\gamma<span class="math">  with probability equal to  </span>\\gamma' = 1-\\gamma'<span class="math"> , then there is some polynomial  </span>\\gamma' = 1-\\gamma'<span class="math">  that agrees with  </span>\\gamma' = 1-\\gamma'$  fraction of points.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">With this property in hand, our analysis in Appendix A straightforwardly implies the following: if  <span class="math">\\mathcal{P}_1^*</span>  passes all of  <span class="math">\\mathcal{V}</span> 's checks within the sum-check protocol with probability  $\\omega(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ , then T extends a valid transcript W. This transcript must contain a witness w for (M, x) as a substring.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  <span class="math">\\gamma&#x27; &lt; .04</span> , then T is the closest polynomial of degree  $O(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  to A. Indeed, if there is another polynomial T&#x27; or degree  </span>O(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  that agrees with A at a  </span>.99 - \\gamma' > .95<span class="math">  fraction of points, then T and T&#x27; must agree on at least a .9 fraction of points. But the Schwartz-Zippel lemma (Lemma 3.1) implies that T and T&#x27; agree on at most  </span>O(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\ll 2\\gamma$  fraction of points.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, given oracle access to  <span class="math">\\mathcal{P}_1</span>  (and hence to A), E can recover any desired evaluation of T using local Reed-Muller decoding. Since any correct transcript (and hence the also extension T) must contain the value of a witness w for (M, x) as a sub-function, this permits the extractor E to recover w.</p>

    <p class="text-gray-300">In the case that  <span class="math">\\mathcal{P}_1</span>  is <em>not</em> a function  <span class="math">w_4 \\mapsto v_4</span>  (i.e., if  <span class="math">\\mathcal{P}_1</span> 's responses depend on the "history" of queries that led to the final query  <span class="math">w_4</span> ), we let  <span class="math">A(w_4)</span>  denote the value  <span class="math">\\mathcal{P}_1</span>  is most likely to output conditioned on the final query being  <span class="math">w_4</span> , breaking ties arbitrarily. As above, suppose  <span class="math">\\mathcal{P}_1^<em></span>  and  <span class="math">\\mathcal{P}_2^</em></span>  pass the point vs. plane test with probability at least  <span class="math">1-\\gamma&#x27;</span> . If E plays the verifier  <span class="math">\\mathcal{V}</span> 's role in our MIP, ultimately querying  <span class="math">\\mathcal{P}_1</span>  at a point  <span class="math">w_4</span>  determined by  <span class="math">\\mathcal{V}</span> 's internal randomness, then the probability that  <span class="math">\\mathcal{P}_1</span> 's response disagrees with  <span class="math">A(w_4)</span>  is  <span class="math">p \\leq 2\\gamma&#x27;</span> . Indeed, if this is not the case, then the probability that  <span class="math">\\mathcal{P}_1^<em></span>  and  <span class="math">\\mathcal{P}_2^</em></span> 's claims within the low-degree test agree is at most  <span class="math">1-1/2 \\cdot p \\leq 1-\\gamma&#x27;</span> , contradicting the assumption that  <span class="math">\\mathcal{P}_1^<em></span>  and  <span class="math">\\mathcal{P}_2^</em></span>  pass the low-degree test with probability at least  <span class="math">1-\\gamma&#x27;</span> .</p>

    <p class="text-gray-300">Thus, E can run Reed-Muller decoding as above, treating  <span class="math">\\mathcal{P}_1</span> 's responses  <span class="math">as\\ A(w_4)</span> . Standard Chernoff bounds imply that, with high probability, if E queries the Reed-Muller codeword at poly(n) many points,  <span class="math">\\mathcal{P}_1</span> 's responses for at most a  <span class="math">3\\gamma&#x27;</span>  fraction of the queried points will disagree with  <span class="math">A(w_4)</span> . For  <span class="math">\\gamma&#x27; &lt; .04</span> , we can repeat our earlier analysis, in which we assumed that  <span class="math">\\mathcal{P}_1</span> 's responses are independent of the history  <span class="math">w_4</span> , to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conclude that there is a polynomial <em>T</em> of degree <em>O</em>(log<sup>2</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) that agrees with <em>A</em> at a .99 − 4γ <sup>0</sup> > .83 fraction of points, and <em>T</em> extends a correct transcript for C. Moreover, just as we argued above, <em>T</em> must be the closest polynomial of degree <em>O</em>(log<sup>2</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) to <em>A</em>. Hence, local Reed-Muller decoding can still be used to recover the witness <em>w</em> for (<em>M</em>, <em>x</em>) that appears as a substring in the transcript that <em>T</em> extends.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-29" class="text-2xl font-bold">D Proof of Lemma <a href="#page-11-3">4.2</a></h2>

    <h2 id="sec-30" class="text-2xl font-bold">D.1 Description of the Circuit</h2>

    <p class="text-gray-300">Given a Random Access Machine <em>M</em> that runs in time <em>T</em>(<em>n</em>) and space <em>S</em>(<em>n</em>), we adapt techniques of Ben Sasson et al. [\\[15\\]](#page-15-7) to describe an arithmetic circuit C of size <em>O</em>(<em>T</em>(<em>n</em>)polylog(<em>T</em>(<em>n</em>))) that is equivalent to <em>M</em> and can be evaluated gate-by-gate in space <em>O</em>(<em>S</em>(<em>n</em>)polylog(<em>T</em>(<em>n</em>)). In this subsection, it will be convenient to describe a <em>Boolean</em> circuit, i.e., a circuit consisting of AND, OR, and NOT gates that takes bits as input. Standard techniques allow one to transform the Boolean circuit to an equivalent arithmetic circuit over a finite field with at most a constant-factor blowup in size and depth (e.g., by replacing each AND gate with multiplication over the underlying field, and each OR and NOT gate with a corresponding arithmetic operation).</p>

    <p class="text-gray-300">At a high level, the circuit takes an entire transcript (sorted by time) of the RAM computation as a non-deterministic input (we refer to these non-deterministic input bits as <em>transcript bits</em>), where a transcript consists of (timestamp, configuration) pairs, one for each step taken by the RAM. Here, a configuration of <em>M</em> specifies the bits contained in the current program counter and the values of all of <em>M</em>'s registers. The circuit then checks that the transcript is valid. This requires checking the transcript for both <em>time consistency</em> (i.e., that the claimed state of the machine at time <em>i</em> correctly follows from the machine's claimed state at time <em>i</em> − 1) and <em>memory consistency</em> (i.e., that every time a value is read from memory location, the value that is returned is equal to the last value written to that location).</p>

    <p class="text-gray-300">The circuit checks time-consistency by representing the transition function of the RAM as a small sub-circuit – if the RAM has a word-size of <em>O</em>(log <em>n</em>), then the transition function can always be represented as a circuit of size polylog(<em>n</em>). It then applies this sub-circuit to each entry <em>i</em> of the transcript and checks that the output is equal to entry <em>i</em> + 1 of the transcript. The circuit checks memory consistency by using routing techniques to re-sort the transcript based on memory location (with ties broken by time), at which point it is straightforward to check that every memory read from a given location returns the last value written to that location. We give more detail on these routing techniques below, closely following some of the exposition of Ben-Sasson et al. [\\[15\\]](#page-15-7).</p>

    <p class="text-gray-300">Routing networks. A routing network is a graph with a designated set of <em>source vertices</em> and a designated set of <em>sink vertices</em> (both sets of the same cardinality) satisfying the following property: for any perfect matching between sources and sinks, there is a set of node-disjoint paths that connects each source to the sink to which it is matched. This property is referred to as <em>rearrangability</em>.</p>

    <p class="text-gray-300"><em>De Bruijn graphs</em> are a class of routing networks that play a central role in the circuits we will use.</p>

    <p class="text-gray-300">Definition D.1. Let <em>L</em> = 2 \` be a power of 2. The (κ, <em>L</em>) De Bruijn graph, denoted DB(κ, <em>L</em>) is a directed 2-regular graph with <em>L</em> layers, where each layer contains 2<sup>κ</sup> vertices identified by κ-bit strings. The nodes in layer 0 are considered the <em>sources</em> and the nodes in layer <em>L</em> − 1 are the <em>sinks</em>.</p>

    <p class="text-gray-300">A vertex in layer <em>i</em> ∈ {0, . . . , <em>L</em> − 2} with identifier <em>w</em> ∈ {0, 1} <sup>κ</sup> has two neighbors at layer <em>i</em> + 1, with identifiers sr(<em>w</em>) and sr(<em>w</em>) ⊕ <em>e</em>1, where sr denotes the shift-right operation, <em>e</em><sup>1</sup> is the κ-bit string with first entry equal to 1 and all other entries equal to zero, and ⊕ denotes the bitwise XOR operation.</p>

    <p class="text-gray-300">De Bruijn graphs of logarithmic width are rearrangeable, as stated in the next theorem.</p>

    <p class="text-gray-300"><span id="page-25-1"></span>Theorem D.1. <a href="#page-15-7">\\[15,</a> Claim 6.5] Let κ be a positive integer and π : {0, 1} <sup>κ</sup> → {0, 1} κ a permutation. There exists a set <em>S</em><sup>π</sup> of 2<sup>κ</sup> node-disjoint paths such that each vertex (0,<em>w</em>) in DB(κ, 4κ − 1) is connected to (<em>L</em> − 1, π(<em>w</em>)). Moreover, <em>S</em><sup>π</sup> can be found in time and space <em>O</em>(κ · 2 κ ) and parallel time <em>O</em>(κ 2 ).</p>

    <p class="text-gray-300">We will refer to the set of node-disjoint paths whose existence is guaranteed by Theorem <a href="#page-25-1">D.1</a> as a <em>routing</em>. Notice that in a routing, each node <em>v</em> in layers {1, . . . <em>L</em> − 1} is in exactly one of the paths, and therefore <em>v</em> has a single in-neighbor in the routing (we think of this in-neighbor as forwarding its packet to <em>v</em>), and each node <em>v</em> in layers {0, . . . , <em>L</em> − 2} has exactly one out-neighbor in the routing. Thus, a routing in DB(κ, 4κ − 1) can be specified by assigning each node <em>v</em> in layers {0, . . . <em>L</em> − 2} a single bit that specifies which of <em>v</em>'s two out-neighbors in DB(κ, 4κ − 1) get forwarded a packet by <em>v</em>.</p>

    <p class="text-gray-300">Using routing networks to ensure memory consistency. Recall that our circuit will take an entire transcript (sorted by time) of the RAM computation as non-deterministic (i.e., auxiliary) input, and checks that the transcript is valid. This requires checking the transcript for both time consistency and memory consistency.</p>

    <p class="text-gray-300">To check memory consistency, our circuit will sort the transcript based on <em>memory-order</em>, which is a partial order on (timestamp, configuration) pairs. Intuitively, sorting a transcript into memory-order is equivalent to sorting the transcript based on memory location with ties broken by time. In more detail, a (time-stamp, configuration) pair (τ , <em>S</em>) precedes a configuration (τ 0 , <em>S</em> 0 ) in memory-order if configurations <em>S</em> and <em>S</em> 0 are the immediate result of loads or stores from memory (say, to memory locations <em>r</em> and <em>r</em> 0 respectively), and one of the following properties is satisfied: 1) <em>r</em> < <em>r</em> 0 (i.e., if <em>S</em> and <em>S</em> <sup>0</sup> operate on different memory locations, we sort based on this location) and 2) τ < τ <sup>0</sup> and <em>r</em> = <em>r</em> 0 (i.e., if <em>S</em> and <em>S</em> <sup>0</sup> operate on the same memory location, we break the tie based on time).</p>

    <p class="text-gray-300">Given a sorting of the transcript that respects memory-order, the transcript satisfies memory-consistency if and only if for all pairs (τ , <em>S</em>), (τ 0 , <em>S</em>) satisfying Condition 2 above for which <em>S</em> 0 is the immediate result of a load operation from memory location <em>r</em> 0 , the value just loaded in configuration <em>S</em> 0 equals the value just loaded from or written to this memory location in configuration <em>S</em>. Thus, our circuit will sort the (timestamp, configuration) pairs to respect memory-order, and then check for all adjacent pairs in the sorting that this property holds.</p>

    <p class="text-gray-300">To perform the sorting step, the circuit will take additional bits as non-deterministic input. These bits represent the bit-wise specification of a routing as described above, and we refer to these auxiliary input bits as <em>routing bits</em>. In practice, the prover would find the necessary routing bits using the algorithm referred to in Theorem <a href="#page-25-1">D.1.</a></p>

    <p class="text-gray-300"><em>Remark:</em> The space requirements of the routing algorithm described in Theorem <a href="#page-25-1">D.1</a> are linear in the size of the De Bruijn graph, which is in turn quasilinear in the runtime <em>T</em>(<em>n</em>) of the original RAM <em>M</em>. This will exceed the space complexity <em>S</em>(<em>n</em>) of the of the original Random Access Machine <em>M</em> unless <em>S</em>(<em>n</em>) = Θ( ˜ <em>T</em>(<em>n</em>)). Ben-Sasson et al. [\\[15\\]](#page-15-7) briefly sketch the following approach to circumvent this issue: they first transform the RAM <em>M</em> into a new RAM <em>M</em><sup>0</sup> that, every <em>S</em>(<em>n</em>) time-steps, reads all <em>S</em>(<em>n</em>) memory cells in order twice in a row. Note this transformation only increases the runtime of <em>M</em> by a constant factor. Now when sorting the transcript of <em>M</em><sup>0</sup> from time-order into memory-order, no (timestamp, configuration) pair needs to be routed more than 2<em>S</em>(<em>n</em>) locations away from its time-ordered position, as every memory location is accessed by <em>M</em><sup>0</sup> every (at most) 2<em>S</em>(<em>n</em>) steps. This enables use of a routing algorithm that uses space <em>O</em>˜(<em>S</em>(<em>n</em>)). We omit further details for brevity.</p>

    <p class="text-gray-300">Putting it all together. Let <em>M</em> be an arbitrary (non-deterministic) Random Access Machine that on an input <em>x</em> of length <em>n</em> runs in time at most <em>T</em>(<em>n</em>). We turn <em>M</em> into an equivalent non-deterministic circuit C. The explicit input of C is <em>x</em>, and the non-deterministic inputs of C specify a sequence of <em>T</em>(<em>n</em>) (timestamp, configuration) pairs representing a computation transcript sorted by timestep, followed by routing bits that are used in conjunction with a De Bruijn graph to sort the transcript into memory-order. Let <em>b</em>(<em>M</em>) be the number of bits required to specify a configuration of <em>M</em>; assuming that <em>M</em> has logarithmic word size and a constant number of registers, it holds that <em>b</em>(<em>M</em>) = <em>O</em>(log <em>n</em>).</p>

    <p class="text-gray-300">Our circuit C consists of several different parts, and each part has a hierarchical structure. These parts can be summarized as follows. The first part checks the transcript for time-consistency. The second part sorts the transcript into memory-order using the routing bits. The third part checks that the routing bits in fact specify a valid routing (this is essential to ensure that the routing part did not duplicate or erase any (timestamp, configuration) pairs from the transcript). The fourth part checks that the output of the routing part is indeed in memory-order. The fifth part checks the output of the routing part for memory consistency. Details of each part follow.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first part of the circuit checks the transcript for memory consistency, and we refer to this as the <em>time-consistency check part</em> of  <span class="math">\\mathcal{C}</span> . There exists a polylogarithmic-sized sub-circuit  <span class="math">\\mathcal{C}_1</span>  that takes as input two (timestamp, configuration) pairs (i,S) and (i',S'), and outputs 1 if and only if i'=i+1 and configuration S' correctly follows from executing one step of the RAM on configuration S. The time-consistency check part of  <span class="math">\\mathcal{C}</span>  thus consists of a two-level hierarchy. The top level of the hierarchy contains a gate for each time step  <span class="math">i \\in [T(n)]</span> . At the second level of the hierarchy, each gate i < T(n) 1 at the top level is expanded into a copy of  <span class="math">\\mathcal{C}_1</span>  that is applied to the i'th and (i+1)'th (timestamp, configuration) pairs in the computation transcript that is provided to  <span class="math">\\mathcal{C}</span>  as auxiliary input.</li>

      <li>The second part of  <span class="math">\\mathcal C</span>  is devoted to sorting the transcript of the RAM computation into memory-order. We refer to this as the <em>routing part</em> of the circuit. The routing part contains a three-level hierarchy of gates. At the highest level of the routing part's hierarchy is a  <span class="math">(\\kappa, 4\\kappa 1)</span>  De Bruijn graph used to sort the transcript into memory-order. Here,  <span class="math">\\kappa = \\log T(n)</span> .</li>

    </ul>

    <p class="text-gray-300">Because each vertex in the De Bruijn graph is used to route an entire (timestamp, configuration) pair rather than a single bit, at the second level of the routing part's hierarchy, each vertex u in the De Bruijn graph is expanded into  <span class="math">b(M) + \\log T(n)</span>  gates used to "store" the (timestamp, configuration) pair that was forwarded to u in the routing. We can identify any gate at the second level of the hierarchy as (u, v), where u specifies the vertex in the De Bruijn graph, and v specifies which bit of the corresponding (timestamp, configuration) pair is stored at this node.</p>

    <p class="text-gray-300">At the third level of the routing part's hierarchy, each gate (u, v) is expanded into a constant-sized sub-circuit  <span class="math">C_2</span>  meant to accomplish the following:  <span class="math">C_2</span>  looks at the routing bit for u to determine which of u's in-neighbors forwards a packet to u (let f(u) denote the identity of this in-neighbor) and then sets the value of its output gate to equal the value of gate (f(u), v). Thus, we can let  <span class="math">C_2</span>  be the circuit that takes 3 bits as input and outputs its second input if the first input equals 0, and otherwise outputs its third input. We expand gate (u, v) at the second level of the hierarchy into the sub-circuit  <span class="math">C_2</span>  applied to the routing bit for u, and the output of the copies of  <span class="math">C_2</span>  corresponding to the two in-neighbors of gate (u, v).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The third part of  <span class="math">\\mathcal{C}</span>  is devoted to ensuring that the routing bits indeed specify a valid routing we refer to this as the <em>routing-validity check</em> part of the circuit. This simply requires checking that each node u in the De Bruijn graph at the highest level of the routing part's hierarchy is forwarded a packet by exactly one of its in-neighbors in DB( <span class="math">\\kappa</span> ,  <span class="math">4\\kappa-1</span> ) (this is equivalent to ensuring that the routing bits of both of its in-neighbors are 1). Thus, we can let  <span class="math">C_3</span>  simply be an AND gate, and for each node u in the De Bruijn graph, we feed the routing bits of each of the in-neighbors of u into  <span class="math">C_3</span> .</li>

      <li>The fourth part of  <span class="math">\\mathcal{C}</span>  is devoted ensuring that the output of the routing part is indeed in memory-order. We refer to this part as the <em>memory-order check</em> part of the circuit. There exists a polylogarithmic-sized sub-circuit  <span class="math">\\mathcal{C}_4</span>  that takes as input two (timestamp, configuration) pairs and outputs 1 if and only if the second pair does not precede the first in memory-order. Thus, the memory-order check part of  <span class="math">\\mathcal{C}</span>  consists of a two-level hierarchy entirely analogous to the time-consistency check part. The top level of the hierarchy contains a gate for each time step  <span class="math">i \\in [T(n)]</span> . At the second level of the hierarchy, each gate i < T(n) 1 at the top level is expanded into a copy of  <span class="math">\\mathcal{C}_4</span>  that is applied to the i'th and (i + 1)'th (timestamp, configuration) pairs in the computation transcript output by the routing part of  <span class="math">\\mathcal{C}</span> .</li>

    </ul>

    <p class="text-gray-300">• The fifth part of C checks the output of the routing part for memory consistency. We refer to this part as the <em>memory-consistency check</em> part of the circuit. There exists a polylogarithmic-sized sub-circuit <em>C</em><sup>5</sup> that takes as input two (timestamp, configuration) pairs and outputs 1 if and only if the second pair is memory-consistent with the first pair (that is, if the two configurations access the same memory location and the second configuration corresponds to a load operation, then the value loaded in the second configuration must equal the value loaded from or read to that location by the first configuration).</p>

    <p class="text-gray-300">Thus, the memory-order check part of C consists of a two-level hierarchy entirely analogous to the time-consistency check and memory-order check parts. The top level of the hierarchy contains a gate for each time step <em>i</em> ∈ [<em>T</em>(<em>n</em>)]. At the second level of the hierarchy, each gate <em>i</em> < <em>T</em>(<em>n</em>) − 1 at the top level is expanded into a copy of C<sup>5</sup> that is applied to the <em>i</em>'th and (<em>i</em> + 1)'th (timestamp, configuration) pairs in the computation transcript output by the routing part of C.</p>

    <h2 id="sec-31" class="text-2xl font-bold">D.2 Arithmetizing the Circuit</h2>

    <p class="text-gray-300">In this subsection, we use C to denote the arithmetic circuit that is equivalent to the Boolean circuit described in Section <a href="#page-25-2">D.1.</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A labeling of the gates in C. Recall from Section <a href="#page-7-0">4.2</a> that the function add(<em>a</em>, <em>b</em>, <em>c</em>) (resp., mult) take as input 3 gate labels each consisting of <em>s</em> bits, and outputs 1 if and only if the gate with label <em>a</em> in C adds (resp., multiplies) the outputs of gates <em>b</em> and <em>c</em>. To define these functions for C, we must therefore label each gate with a binary string of length <em>s</em> = <em>O</em>(log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first 3 bits of the string identify which part of the circuit the gate is in (here, we consider there to be exactly eight parts of the circuit, as in addition to the five parts described in Section <a href="#page-25-2">D.1,</a> we consider the input <em>x</em>, the non-deterministic transcript bits, and the non-deterministic routing bits to each be a separate part). We will refer to these as the <em>part-specifiers</em> within a gate label. For concreteness, we let the part specifiers of the label of every gate comprising the input <em>x</em> be 000, those of gates in the time-consistency check part be 001, those of gates in the routing part be 010, and so on. We let the part specifiers in the label of every transcript gate be 110, and the part specifiers in the label of every routing bit be 111. We choose this numbering scheme for ease of exposition and notation, as this ensures that the part specifier of part <em>j</em> of C for <em>j</em> ∈ {1, . . . , 5} (i.e. the non-input parts of the circuit specified above) is precisely the binary representation of <em>j</em>.</p>

    <p class="text-gray-300">Notice also that each part <em>j</em> ∈ {1, . . . , 5} of our circuit ultimately consists of many repeated instances of some sub-circuit C<em><sup>j</sup></em> , with each instance of C<em><sup>j</sup></em> being fed different inputs. While it is typical to think of a circuit C<em><sup>j</sup></em> as having input <em>wires</em>, we replace each input wire of C<em><sup>j</sup></em> with a <em>gate</em>. We call this an input gate to C<em><sup>j</sup></em> , and we implement it as an addition gate with its first in-neighbor set to the corresponding value being fed into C<em><sup>j</sup></em> , and its second in-neighbor set to a fixed gate z ∈ {0, 1} <em><sup>s</sup></em> whose value is fixed to 0.</p>

    <p class="text-gray-300">We let the 4th bit of each gate label be an <em>input-gate indicator bit</em>. That is, we set this bit to 1 if and only if the gate is an input gate for C<em><sup>j</sup></em> .</p>

    <p class="text-gray-300">The remaining bits specify a gate's label within its part – this simply involves specifying which copy of C<em>j</em> the gate is in, followed by the identify of the actual gate within C<em><sup>j</sup></em> . For example, the label of a gate in the routing part of C will be of the form 010 ◦ <em>b</em><sup>4</sup> ◦ (<em>u</em>, <em>v</em>, <em>w</em>), where ◦ denotes concatenation, <em>b</em><sup>4</sup> is set to 1 if and only if the gate is an input gate of the constant-sized sub-circuit C2, <em>u</em> specifies a node in the (κ, 4κ − 1) De Bruijn graph, <em>v</em> ∈ [<em>b</em>(<em>M</em>) + log <em>T</em>(<em>n</em>)] specifies a bit in a (timestamp, configuration) pair, and <em>w</em> specifies a gate within the constant-sized sub-circuit C2. Notice that the hierarchical structure of each part of C easily lends itself to a labeling plan obtained by labeling each level of the hierarchy separately and concatenating the labels together to obtain a single label. In general, we will denote a gate's label as (<em>b</em>1, <em>b</em>2, <em>b</em>3, <em>b</em>4, <em>u</em>, <em>v</em>) where (<em>b</em>1, <em>b</em>2, <em>b</em>3) specify the part of C in which the gate resides, <em>b</em><sup>4</sup> specifies whether or not the gate is an input gate to C<em><sup>i</sup></em> , <em>u</em> specifies the copy of C<em><sup>i</sup></em> in which the gate resides, and <em>v</em> identifies the actual gate within C<em><sup>i</sup></em> .</p>

    <p class="text-gray-300">To clarify, each gate in C must have a label of the <em>same</em> length <em>s</em> – to cope with the fact that some parts of C have more gates than other parts, we simply pad out the labels of gates in smaller parts to ensure that every gate in C is assigned a binary string of length exactly s. In what follows, we will suppress reference to these padding bits to simplify notation.</p>

    <p class="text-gray-300">A low-degree extension of the wiring predicates. We will focus on specifying a low-degree extension of the wiring predicate add :  <span class="math">\\{0,1\\}^s \\to \\{0,1\\}</span>  for  <span class="math">\\mathcal{C}</span>  as the case of mult :  <span class="math">\\{0,1\\}^s \\to \\{0,1\\}</span>  is entirely analogous.</p>

    <p class="text-gray-300">An essential consequence of the fact that our circuit  <span class="math">\\mathcal{C}</span>  consists of five independent parts is that we can arithmetize the wiring predicate of each part separately and combine the results into a single unified wiring predicate whose degree in each variable is no larger than each of the parts individually. That is, let  <span class="math">\\operatorname{add}_i(a,b,c):\\{0,1\\}^{3s}\\to\\{0,1\\}</span>  denote the function that takes as input three gate labels, and outputs 1 only if the gate with label a is in part i of  <span class="math">\\mathcal{C}</span> , and gate a adds the outputs of gates b and c. Let  <span class="math">\\operatorname{add}_i</span>  be any low-degree extension of  <span class="math">\\operatorname{add}_i</span> . Then the polynomial</p>

    <p class="text-gray-300"><span class="math-block">\\widetilde{\\operatorname{add}}(a,b,c) := \\sum_{i=1}^{5} \\widetilde{\\operatorname{add}}_{i}(a,b,c)</span> (6)</p>

    <p class="text-gray-300">is an extension of add; to see this, note that for any  <span class="math">(a,b,c) \\in \\{0,1\\}^{3s}</span>  for which gate a is in Part i of C,  <span class="math">\\widetilde{\\mathrm{add}}_j(a,b,c) = 0</span>  for all  <span class="math">j \\neq i</span> , and hence  <span class="math">\\widetilde{\\mathrm{add}}(a,b,c) = \\widetilde{\\mathrm{add}}_i(a,b,c) = \\mathrm{add}(a,b,c)</span> . Furthermore, the degree of  <span class="math">\\widetilde{\\mathrm{add}}</span>  in each variable is no larger than (the maximum degree of) each of the constituent polynomials  <span class="math">\\widetilde{\\mathrm{add}}_i</span> .</p>

    <p class="text-gray-300">Since each part i consists of many repeated applications of an (at most) polylogarithmic-sized sub-circuit  <span class="math">C_i</span> , it is relatively straightforward to compute  <span class="math">\\widetilde{\\text{add}}_i</span>  for each i. Essentially, for each copy of  <span class="math">C_i</span> , we arithmetize the wiring information of the input gates of  <span class="math">C_i</span>  and the internal gates of  <span class="math">C_i</span>  separately.</p>

    <p class="text-gray-300"><strong>Notation.</strong> Fix an  <span class="math">s^<em> &gt; 0</span> . Let  <span class="math">\\beta^{(2,s^</em>)}(p,p&#x27;) : \\mathbb{F}^{2s^*} \\to \\mathbb{F}</span>  denote the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">\\beta^{(2,s^*)}(p,p) = \\prod_{j=1}^{s^*} \\left( p_j p_j&#x27; + (1-p_j)(1-p_j&#x27;) \\right).</span></div>

    <p class="text-gray-300">It is easy to check that if  <span class="math">(p,p&#x27;) \\in \\{0,1\\}^{2s^<em>}</span> , then  <span class="math">\\beta^{(2,s^</em>)}(p,p&#x27;) = 1</span>  if p = p' and  <span class="math">\\beta(p,p&#x27;) = 0</span>  otherwise. That is,  <span class="math">\\beta^{(2,s^<em>)}</span>  is the multilinear extension of the function that takes two length- <span class="math">s^</em></span>  Boolean vectors as inputs and outputs 1 if and only if the two vectors are equal. Similarly, let</p>

    <div class="my-4 text-center"><span class="math-block">\\beta^{(3,s^*)}(p,p&#x27;,p&#x27;&#x27;) = \\prod_{j=1}^{s^*} (p_j p_j&#x27; p_j&#x27;&#x27; + (1-p_j)(1-p_j&#x27;)(1-p_j&#x27;&#x27;))</span></div>

    <p class="text-gray-300">denote the multilinear extension of the function that takes three Boolean vectors as inputs and outputs 1 if and only if all three vectors are equal, and  <span class="math">\\beta^{(4,s^*)}(p,p&#x27;,p&#x27;&#x27;,p&#x27;&#x27;&#x27;)</span>  denote the analogous function that takes 4 vectors as inputs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">s_i</span>  denote  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and let  </span>t_i<span class="math">  denote the number of copies of  </span>C_i<span class="math">  that appear in part i of C. For a part  </span>i \\in \\{1, ..., 5\\}<span class="math"> , let  </span>(i_1, i_2, i_3) \\in \\{0, 1\\}^3$  denote the binary representation of i.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Handling the internal gates of</strong>  <span class="math">C_i</span> . Let  <span class="math">\\widetilde{\\text{add}}_{C_i}: \\mathbb{F}^{3s_i} \\to \\mathbb{F}</span>  denote the multilinear extension of the wiring predicate  <span class="math">\\text{add}_{C_i}: \\{0,1\\}^{3s_i} \\to \\{0,1\\}</span>  for the sub-circuit  <span class="math">C_i</span> . Notice that  <span class="math">\\widetilde{\\text{add}}_{C_i}</span>  can be written as an arithmetic circuit of size  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_i)$  using the expression</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathrm{add}}_{\\mathcal{C}_{i}}(u_{1}, u_{2}, u_{3}) = \\sum_{a \\in \\{0,1\\}^{s_{i}}} \\beta^{(2,3s_{i})}\\left(\\left(a, \\operatorname{in}_{1}(a), \\operatorname{in}_{2}(a)\\right), \\left(u_{1}, u_{2}, u_{3}\\right)\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">in_1(a)</span>  denotes the label of the first in-neighbor of gate a in  <span class="math">C_i</span> .</p>

    <p class="text-gray-300">Recall that each gate label in C is of the form  <span class="math">(b_1, b_2, b_3, b_4, u, v)</span>  where  <span class="math">(b_1, b_2, b_3)</span>  specifies which part i of C the gate is in,  <span class="math">b_4</span>  specifies whether the gate is an input gate to  <span class="math">C_i</span> ,  <span class="math">u \\in \\{0, 1\\}^{t_i}</span>  specifies which</p>

    <p class="text-gray-300">copy of  <span class="math">C_i</span>  the gate is in, and  <span class="math">v \\in \\{0,1\\}^{s_i}</span>  specifies the gate within  <span class="math">C_i</span> . Consider three gate labels  <span class="math">\\ell_1 = (b_1^{(1)}, b_2^{(1)}, b_3^{(1)}, b_4^{(1)}, u^{(1)}, v^{(1)}), \\ell_2 = (b_1^{(2)}, b_2^{(2)}, b_3^{(2)}, b_4^{(2)}, u^{(2)}, v^{(2)}), \\text{ and } \\ell_3 = (b_1^{(3)}, b_2^{(3)}, b_3^{(3)}, b_4^{(3)}, u^{(3)}, v^{(3)}),</span>  and consider the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\widetilde{\\mathrm{add}}_{i,\\mathrm{internal}}(\\ell_1,\\ell_2,\\ell_3) &amp;= \\beta^{(4,3)} \\left( i_1,i_2,i_3,b_1^{(1)},b_2^{(1)},b_3^{(1)},b_1^{(2)},b_2^{(2)},b_3^{(2)},b_1^{(3)},b_2^{(3)},b_3^{(3)} \\right) \\cdot \\\\ \\beta^{(4,1)}(0,b_4^{(1)},b_4^{(2)},b_4^{(3)}) \\cdot \\beta^{(3,t_i)}(u^{(1)},u^{(2)},u^{(3)}) \\cdot \\widetilde{\\mathrm{add}}_{\\mathcal{C}_i}(v^{(1)},v^{(2)},v^{(3)}). \\end{split}</span></div>

    <p class="text-gray-300">Intuitively, in the right hand side of the equation above, the first term in the product ensures that all three gates are in part i of  <span class="math">\\mathcal{C}</span> , the second term ensures that each gate  <span class="math">\\ell_1, \\ell_2, \\ell_3</span>  is not a (copy of) an input gate to  <span class="math">\\mathcal{C}_i</span> , the third term ensures that all three gates are in the same copy of  <span class="math">\\mathcal{C}_i</span> , and the  <span class="math">\\operatorname{add}_{\\mathcal{C}_i}(v^{(1)}, v^{(2)}, v^{(3)})</span>  term ensures that  <span class="math">\\ell_2</span>  and  <span class="math">\\ell_3</span>  are (copies of) the in-neighbors of  <span class="math">\\ell_1</span>  within  <span class="math">\\mathcal{C}_i</span> .</p>

    <p class="text-gray-300">It is straightforward to check that  <span class="math">add_{i,internal}</span>  is a multilinear polynomial that satisfies the following property:  <span class="math">add_{i,internal}</span>  evaluates to 1 on input  <span class="math">(\\ell_1,\\ell_2,\\ell_3) \\in \\{0,1\\}^{3s}</span>  if all three gates are in part i of  <span class="math">\\mathcal{C}</span> , and  <span class="math">\\ell_1</span>  is not a (copy of) an input gate to  <span class="math">\\mathcal{C}_i</span> , and  <span class="math">\\ell_2</span>  and  <span class="math">\\ell_3</span>  are indeed the first and second in-neighbors of gate  <span class="math">\\ell_1</span>  in  <span class="math">\\mathcal{C}</span> . Moreover,  <span class="math">add_{i,internal}</span>  evaluates to 0 on all other Boolean inputs.</p>

    <p class="text-gray-300"><strong>Handling the input gates of</strong>  <span class="math">C_i</span> . Handling input gates to  <span class="math">C_i</span>  is somewhat more complicated: each part must be handled separately, and this is where the use of cubic rather than multilinear extensions will be necessary.</p>

    <p class="text-gray-300">Our goal is to construct a low-degree extension of the function  <span class="math">add_{i,input}(\\ell_1,\\ell_2,\\ell_3): \\{0,1\\}^s \\to \\{0,1\\}</span>  that given three gate-labels as input outputs 1 if and only if  <span class="math">\\ell_1</span>  is a (copy of) an input gate to  <span class="math">\\mathcal{C}_i</span>  and  <span class="math">\\ell_2</span>  and  <span class="math">\\ell_3</span>  are its first and second in-neighbors in  <span class="math">\\mathcal{C}</span>  respectively. If we succeed in this task, then it will suffice to define  <span class="math">\\widetilde{add}_i(\\ell_1,\\ell_2,\\ell_3) := \\widetilde{add}_{i,internal} + \\widetilde{add}_{i,input}</span> .</p>

    <p class="text-gray-300">We will work through the details in the context of the time-consistency check part and routing part of  <span class="math">\\mathcal{C}</span>  respectively, as the case of the remaining parts are similar.</p>

    <p class="text-gray-300">• Recall that in the time-consistency check part of C, the u'th copy of the sub-circuit  <span class="math">C_1</span>  is fed the u'th and (u+1)'th (timestamp, configuration) pairs in the computation transcript that is provided to C as auxiliary input. Here  <span class="math">C_1</span>  is a circuit that takes two (timestamp, configuration) pairs (i, S) and (i', S'), and outputs 1 if and only if i' = i + 1 and configuration S' correctly follows from executing one step of the RAM on configuration S.</p>

    <p class="text-gray-300">We associate the input gates to  <span class="math">\\mathcal{C}_1</span>  with the labels  <span class="math">(d_1,v&#x27;)\\in\\{0,1\\}^{1+b_M}</span> , where the bit  <span class="math">d_1</span>  specifies whether the input is in the first or second (timestamp, configuration) pair, the  <span class="math">v&#x27;\\in\\{0,1\\}^{b_M}</span>  specifies the bit within the (timestamp, configuration) pair. Notice that any gate in  <span class="math">\\mathcal{C}</span>  that is a copy of an input gate to  <span class="math">\\mathcal{C}_1</span>  has a label of the form  <span class="math">\\ell_1=(0,0,1,1,u,v)</span>  with  <span class="math">u\\in\\{0,1\\}^{t_1}</span>  and  <span class="math">v=(d_1,v&#x27;)\\in\\{0,1\\}^{1+b_M}</span> . The first in-neighbor of  <span class="math">\\ell_1</span>  in  <span class="math">\\mathcal{C}</span>  is the gate  <span class="math">(1,1,0,0,u+d_1,v&#x27;)</span> , where the expression  <span class="math">u+d_1</span>  interprets u and  <span class="math">d_1</span>  as integers and denotes the binary representation of their sum. The second in-neighbor of  <span class="math">\\ell_1</span>  is the designated gate  <span class="math">\\mathbf{z}</span>  whose value is fixed to 0.</p>

    <p class="text-gray-300">To arithmetize this wiring pattern, we would ideally like to use the multilinear extension of the function that takes binary vectors  <span class="math">u, u&#x27; \\in \\{0, 1\\}^{\\log T(n)}</span>  and outputs 1 if and only if u' = u + 1. Unfortunately, it is not at all evident that the multilinear extension of this function can be evaluated in time polynomial in the length of the vectors u and u'. Fortunately, Thaler [74] considers essentially the same scenario. More specifically, Thaler analyzes a wiring predicate that arises in a circuit solving the pattern matching problem – in this circuit, the first in-neighbor of a gate with label (i,j) of the circuit is the (i+j)'th input to the circuit, and handling this pattern necessitated developing techniques that broadly applied to wiring patterns involving interpreting labels as integers and adding or subtracting them. For completeness, we work through the details of this technique in our setting below.</p>

    <p class="text-gray-300"><strong>Details of the arithmetization of</strong> add<sub>1</sub>. Essentially, the technique in our context appends  <span class="math">t_1 = \\log T(n)</span>  "dummy bits" to the label of each gate of C corresponding to a (timestamp, configuration) pair in the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">computation transcript that is provided to  <span class="math">\\mathcal{C}</span>  as auxiliary input. The value of the dummy bits appended to the label of a gate in the u'th (timestamp, configuration) pair is the "carry bits" that arise when adding together 1 and u in binary. Thaler shows that under this labeling, there is a cubic extension of the wiring predicate that the verifier can evaluate in polylogarithmic time, and the prover can still be made to run in time  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  when using this extension of the wiring predicate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More formally, let  <span class="math">\\operatorname{inc}(u, c, u&#x27;): \\{0, 1\\}^{3 \\log T(n)} \\to \\{0, 1\\}</span>  denote the function that takes 3 Boolean vectors of length  <span class="math">\\log T(n)</span>  as input and outputs 1 if and only if u' = u + 1 and the vector c equals the vector of carry bits that arise when adding 1 to u in binary.</p>

    <p class="text-gray-300">Let  <span class="math">\\phi: \\{0,1\\}^4 \\to \\{0,1\\}</span>  be the function that evaluates to 1 on input  <span class="math">(i_1,k_1,c_0,c_1)</span>  if and only if  <span class="math">c_1=0</span>  and  <span class="math">i_1+k_1+c_0&lt;2</span>  or  <span class="math">c_1=1</span>  and  <span class="math">i_1+k_1+c_0\\geq 2</span> . That is,  <span class="math">\\phi</span>  outputs 1 if and only if  <span class="math">c_1</span>  is equal to the carry bit when adding  <span class="math">i_1,k_1</span> , and  <span class="math">c_0</span> . Let  <span class="math">\\tilde{\\phi}</span>  be the multilinear extension of  <span class="math">\\phi</span> . Notice  <span class="math">\\tilde{\\phi}</span>  can be evaluated at any point  <span class="math">r\\in\\mathbb{F}^4</span>  in O(1) time.</p>

    <p class="text-gray-300">Now let (i, c) denote a vector in  <span class="math">\\mathbb{F}^{2 \\log T(n)}</span>  and define</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi(i,c) := \\tilde{\\phi}(i_1,1,0,c_1) \\cdot \\prod_{j=2}^{\\log T(n)} \\tilde{\\phi}(i_j,0,c_{j-1},c_j).</span></div>

    <p class="text-gray-300">For any Boolean vector  <span class="math">(i, c) \\in \\{0, 1\\}^{2 \\log T(n)}</span> , it is easily verified that  <span class="math">\\Phi(u, c) = 1</span>  if and only if for all  <span class="math">j, c_j</span>  equals the jth carry bit when adding the numbers u and 1 in binary.</p>

    <p class="text-gray-300">Finally, let  <span class="math">\\gamma:\\{0,1\\}^3 \\to \\{0,1\\}</span>  be the function that evaluates to 1 on input  <span class="math">(i_1,k_1,c_1)</span>  if and only if  <span class="math">i_1+k_1+c_1=1 \\mod 2</span> . Let  <span class="math">\\tilde{\\gamma}</span>  be the multilinear extension of  <span class="math">\\gamma</span> . Notice  <span class="math">\\tilde{\\gamma}</span>  can be evaluated at any point  <span class="math">r \\in \\mathbb{F}^3</span>  in O(1) time.</p>

    <p class="text-gray-300">Now consider the following  <span class="math">(3 \\log T(n))</span> -variate polynomial over  <span class="math">\\mathbb{F}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathrm{inc}}(u,c,u&#x27;) = \\Phi(u,c) \\cdot \\beta^{(2,1)}(\\widetilde{\\gamma}(u_1,1,0),u_1&#x27;) \\cdot \\prod_{j=2}^{\\log T(n)} \\beta^{(2,1)}(\\widetilde{\\gamma}(u_j,0,c_j),u_j&#x27;).</span></div>

    <p class="text-gray-300">It is straightforward to check that inc has degree at most three in each variable of (u, c, u'), and that inc extends the function inc. Intuitively, the  <span class="math">\\Phi(u, c)</span>  term in the above expression checks that the vector c contains the carry bits obtained when adding 1 to u, while the remaining terms ensure that u' is the result of applying the grade school addition algorithm to compute u+1 given that the carry bits are c. At last we are in a position to define  <span class="math">\\widetilde{\\operatorname{add}}_{1,\\operatorname{input}}(\\ell_1,\\ell_2,\\ell_3)</span> . For purposes of this definition, for  <span class="math">i\\in\\{1,2,3\\}</span>  we parse the gate labels as  <span class="math">\\ell_i=(b_1^{(i)},b_2^{(i)},b_3^{(i)},b_4^{(i)},u^{(i)},c^{(i)},v^{(i)})</span> . Intuitively,  <span class="math">u^{(1)}\\in\\{0,1\\}^{t_1}</span>  will be interpreted as specifying a (timestamp, configuration) pair,  <span class="math">c^{(1)}</span>  will be interpreted as specifying carry bits, and  <span class="math">v^{(1)}=(d_1^{(1)},v&#x27;^{(1)})\\in\\{0,1\\}^{1+b_M}</span>  will be interpreted as specifying whether  <span class="math">\\ell_1</span>  is a (copy of) a gate in the first or second (timestamp, configuration) pair being fed into  <span class="math">\\mathcal{C}_1</span> , as well as the bit within the (timestamp, configuration) pair. We define:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp; \\widetilde{\\mathsf{add}}_{1,\\mathsf{input}}(\\ell_1,\\ell_2,\\ell_3) = \\beta^{(2,4)}(0,0,1,1,b_1^{(1)},b_2^{(1)},b_3^{(1)},b_4^{(1)}) \\cdot \\beta^{(2,4)} \\left(1,1,0,0,b_1^{(2)},b_2^{(2)},b_3^{(2)},b_4^{(2)}\\right) \\\\ &amp; \\cdot \\left((1-d_1^{(1)}) \\cdot \\beta^{(2,t_1)}(u^{(1)},u^{(2)}) + d_1^{(1)} \\cdot \\widetilde{\\mathsf{inc}} \\left(u^{(1)},c^{(1)},u^{(2)}\\right)\\right) \\cdot \\beta^{(2,\\log b_M)}(v&#x27;^{(1)},v&#x27;^{(2)}) \\cdot \\beta^{(2,s)}(\\mathbf{z},\\ell_3) \\end{split}</span></div>

    <p class="text-gray-300">It can be seen that  <span class="math">\\widetilde{\\mathrm{add}}_{1,\\mathrm{input}}</span>  is a polynomial of degree (at most) 3 in each variable, and that it extends the function  <span class="math">\\mathrm{add}_{1,\\mathrm{input}}(\\ell_1,\\ell_2,\\ell_3):\\{0,1\\}^s\\to\\{0,1\\}</span> . Intuitively, the first term in the equation above</p>

    <p class="text-gray-300">ensures that  <span class="math">\\ell_1</span>  is the label of an input gate to  <span class="math">\\mathcal{C}_1</span> , the second term ensures that  <span class="math">\\ell_2</span>  is a (non-deterministic) transcript gate to  <span class="math">\\mathcal{C}</span> , the third term ensures that  <span class="math">\\ell_2</span>  is in the appropriate (timestamp, configuration) pair (i.e., is in the u'th pair if  <span class="math">d_1^{(1)}=0</span>  and the (u+1)'th pair if  <span class="math">d_1^{(1)}=1</span> ). The fourth term ensures that  <span class="math">\\ell_2</span>  is the appropriate gate within the u'th or (u+1)'th (timestamp, configuration) pair. The final term ensures that  <span class="math">\\ell_3</span>  is equal to  <span class="math">\\mathbf{z}</span> , the label of the designated gate whose value is fixed to zero.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Sketch of Prover's computation.</strong> Thaler's observations in Appendix B of the full version of [74] imply that  <span class="math">\\mathcal{P}_1</span>  can be made to run in O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) time even if we use the cubic extension add<sub>1</sub> of add<sub>1</sub> described above. We briefly sketch these observations. Recall that the sum-check protocol allows the verifier to outsource computation of the quantity  <span class="math">\\sum_{x \\in \\{0,1\\}^{3s}} h_q(x)</span> , and that the sum-check protocol requires one round for each of the 3s variables being summed over. In each round i of the sum-check protocol,  <span class="math">\\mathcal{P}_1</span>  must compute a sum over  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3/2^i<span class="math">  terms, and therefore  </span>\\mathcal{P}_1$  may not have the time even to consider each term in the sum explicitly. It is therefore crucial that we argue that in all rounds, all but O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) of the terms in the sum are zero. This property is guaranteed if we use the cubic extension add<sub>1</sub>, as long as the sum-check protocol considers the variables in the vector in a specific order. More specifically, recall that when arithmetizing the wiring predicate of the time-consistency check part of  <span class="math">\\mathcal{C}</span> , we parse gate labels as  <span class="math">\\ell_i = (b_1^{(i)}, b_2^{(i)}, b_3^{(i)}, b_4^{(i)}, u^{(i)}, c^{(i)}, v^{(i)})</span> . To ensure  <span class="math">\\mathcal{P}_1</span>  is efficient, for each  <span class="math">i \\in \\{1, \\ldots, \\log(T(n))\\}</span> , the sum-check protocol must consider variables  <span class="math">u_i^{(1)}, c_i^{(1)}</span>  and  <span class="math">u_i^{(2)}</span>  in consecutive rounds for all  <span class="math">j \\in \\{1, \\dots, \\log(T(n))\\}</span> . This ensures that the following property holds: each gate in  <span class="math">\\mathcal{C}</span>  contributes to only O(1) terms of the sum, and the contribution of each gate can be computed independently in logarithmic time. At a high level, this property holds because add<sub>1</sub> is multilinear in all variables except those of  <span class="math">u^{(1)}</span>  and  <span class="math">c^{(1)}</span> , and it is only non-multilinear in the remaining variables because of use of the function  <span class="math">\\Phi(u,c)</span>  within the definition of add<sub>1</sub>. Fortunately,  <span class="math">\\Phi(u,c)</span>  considers each triple of variables  <span class="math">(u_i, c_i, c_{i-1})</span>  independently, and thus when considering any Boolean setting of the variables  <span class="math">u_i</span>  and  <span class="math">c_{i-1}</span>  within the sum defining one of  <span class="math">\\mathcal{P}_1</span> 's messages in the sum-check protocol, the only setting of  <span class="math">c_i</span>  that  <span class="math">\\mathcal{P}_1</span>  must consider is the setting corresponding to the carry bit of  <span class="math">u_i + c_{i-1}</span> , i.e.,  <span class="math">\\mathcal{P}_1</span>  need only consider the unique setting of  <span class="math">c_i \\in \\{0, 1\\}</span>  such that  <span class="math">\\phi(u_i, c_i, c_{i-1}) = 1</span> . For the other setting of  <span class="math">c_i</span> ,  <span class="math">\\phi(u_j, 0, c_{j-1}, c_j)</span>  will evaluate to zero, ensuring that the corresponding term in the sum defining  <span class="math">\\mathcal{P}_1</span> 's message within the sum-check protocol is zero. This ensures that  <span class="math">\\mathcal{P}_1</span>  need not consider all possible settings of the variables in  <span class="math">(u^{(1)}, c^{(1)})</span> , but only the settings of these variables such that  <span class="math">c^{(1)}</span>  indeed corresponds to the carry bits obtained when interpreting  <span class="math">u^{(1)}</span>  as an integer and computing  <span class="math">u^{(1)} + 1</span> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, when using the cubic extension  <span class="math">\\operatorname{add}_1</span>  of  <span class="math">\\operatorname{add}_1</span> ,  <span class="math">\\mathcal{P}_1</span>  can compute each message in the sum-check protocol with a single pass over the gates of  <span class="math">\\mathcal{C}</span> . This pass requires time  $\\tilde{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , and there are only  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  rounds in total, resulting in a total runtime of  </span>\\tilde{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We remark that when using the multilinear extensions of add and mult, each gate contributes to <em>exactly</em> 1 term in the sum, and it is irrelevant what order the sum is computed in – in our case, the order in which the sum is computed is crucial, and each gate contributes to O(1) rather than exactly 1 term in the sum.</p>

    <p class="text-gray-300">• Recall that the label  <span class="math">\\ell_1</span>  of a gate in the routing part of  <span class="math">\\mathcal{C}</span>  will be parsed as  <span class="math">\\ell_1 = 010 \\circ b_4 \\circ (u, v, w)</span> , where  <span class="math">\\circ</span>  denotes concatenation,  <span class="math">b_4</span>  is set to 1 if and only if the gate is an input gate of the constant-sized sub-circuit  <span class="math">\\mathcal{C}_2</span> , u = (i, u') specifies a node in the  <span class="math">(\\kappa, 4\\kappa - 1)</span>  De Bruijn graph (here, i denotes the layer of the De Bruijn graph in which the node resides, and u denotes the identity of the gate within the layer),  <span class="math">v \\in [b(M) + \\log T(n)]</span>  specifies a bit in a (timestamp, configuration) pair, and w specifies a gate within the constant-sized sub-circuit  <span class="math">\\mathcal{C}_2</span> . Since  <span class="math">\\mathcal{C}_2</span>  has three inputs and one output, we will let  <span class="math">w^{\\text{in}_j}</span>  denote the label of the jth input gate to  <span class="math">\\mathcal{C}_2</span>  for  <span class="math">j \\in \\{1, 2, 3\\}</span> , and  <span class="math">w^{\\text{out}}</span>  denote the label of the unique output gate of  <span class="math">\\mathcal{C}_2</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\ell_1</span>  is a (copy of) an input gate to  <span class="math">\\mathcal{C}_2</span> , then its second in-neighbor is always the designated gate  <span class="math">\\mathbf{z}</span>  whose value is fixed to 0, and its first in-neighbor is one of the following: 1) If  <span class="math">w = w^{\\mathrm{in}_1}</span> , then the first in-neighbor of  <span class="math">\\ell_1</span>  is the routing bit corresponding to node u in the De Bruijn graph that was supplied as non-deterministic input to the circuit  <span class="math">\\mathcal{C}</span>  – this routing bit has label  <span class="math">111 \\circ 0 \\circ u</span> . 2) If  <span class="math">w = w^{\\mathrm{in}_2}</span> , then the first in-neighbor of  <span class="math">\\ell_1</span>  is the output gate of the copy of  <span class="math">\\mathcal{C}_2</span>  corresponding to u's first in-neighbor in the De Bruijn graph and to the vth bit of the (timestamp, configuration) pair. This gate has label  <span class="math">010 \\circ 0 \\circ ((i-1,\\mathrm{sr}(u&#x27;)),v,w^{\\mathrm{out}})</span> , where as usual sr denotes the shift-right operation. 3) If  <span class="math">w = w^{\\mathrm{in}_3}</span> , then the first in-neighbor of  <span class="math">\\ell_1</span>  is the output gate of the copy of  <span class="math">\\mathcal{C}_2</span>  corresponding to u's second in-neighbor in the De Bruijn graph and to the vth bit of the (timestamp, configuration) pair. This gate has label  <span class="math">010 \\circ 0 \\circ ((i-1,\\mathrm{sr}(u&#x27;)) \\oplus e_1), v, w^{\\mathrm{out}})</span> .</p>

    <p class="text-gray-300">A crucial observation in arithmetizing this wiring predicate is that the wiring pattern of De Bruijn graphs are "algebraically regular": the in-neighbors of gate u=(i,u') in the De Bruijn graph are of the form and  <span class="math">(i-1,\\operatorname{sr}(u&#x27;))</span>  and  <span class="math">(i-1,\\operatorname{sr}(u)\\oplus e_1)</span> . The transformation  <span class="math">i\\mapsto i-1</span>  can be handled exactly as in Part 1 of the circuit (alternatively, as there are only  <span class="math">\\log T(n)</span>  layers in the De Bruijn graph, we can afford to represent each layer of the De Bruijn in <em>unary</em> rather than binary. This will increase the bit-length of each gate label by at most an additive  <span class="math">\\log T(n)</span>  factor, and permits use of the multilinear extension of add<sub>2</sub> rather than a cubic extension). Meanwhile, the transformations  <span class="math">u&#x27;\\mapsto\\operatorname{sr}(u&#x27;)</span>  and  <span class="math">u&#x27;\\mapsto\\operatorname{sr}(u&#x27;)\\oplus e_1</span>  are easy to arithmetize using multilinear extensions. For example, the multilinear extension of the function  <span class="math">\\operatorname{sr-func}(u_1,u_2):\\{0,1\\}^{2\\log T(n)}\\to\\{0,1\\}</span>  that takes as input two binary vectors  <span class="math">u_1,u_2</span>  of length T(n) and outputs 1 if and only if  <span class="math">u_2=\\operatorname{sr}(u_1)</span>  is simply the function  <span class="math">\\operatorname{sr-func}(u_1,u_2)=\\beta^{2,1}(u_{1,1},u_{2,2})\\cdot\\beta^{2,1}(u_{1,2}u_{2,3})\\cdot\\cdots\\cdot\\beta^{2,1}(u_{1,\\log T(n)},u_{2,1})</span> .</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">E Pseudocode</h4>

    <pre><code class="language-text">1: function VERIFYOUTPUTS(Circuit C, Input x, Output y)
           // s is the number of bits needed to represent a gate label.
           s \\leftarrow \\lceil \\log(\\operatorname{Size}(C)) \\rceil
 3:
           q \\stackrel{R}{\\leftarrow} \\mathbb{F}
 4:
 5:
           SendToProver(\\mathcal{P}_1, q)
           // sum-check protocol is being applied to polynomial h_a
 6:
           (w_1, w_2, w_3, v_1, v_2, v_3) \\leftarrow \\text{SUMCHECK}(\\mathcal{P}_1, q, \\mathcal{C}, x, y)
 7:
 8:
           // reduce v_1 \\stackrel{?}{=} \\widetilde{W}(w_1), v_2 \\stackrel{?}{=} \\widetilde{W}(w_2), v_3 \\stackrel{?}{=} \\widetilde{W}(w_3)
 9:
           // to v_4 \\stackrel{?}{=} \\widetilde{W}(w_4)
10:
11:
           k_0, k_1, \\ldots, k_{2s} \\leftarrow \\text{GetFromProver}(\\mathcal{P}_1)
12:
           // above, correct prover returns 2s + 1 field elements,
13:
           // specifically K(0), K(1), \\ldots, K(2s) \\in \\mathbb{F}, where
14:
           // K = \\widetilde{W} \\circ \\ell, for \\ell : \\mathbb{F} \\to \\mathbb{F}^s, where
15:
           // \\ell(t) = 2^{-1}(t-2)(t-1) \\cdot w_1 - (t-2)t \\cdot w_2 + 2^{-1}t(t-1) \\cdot w_3
16:
           if k_0 \\neq v_1 or k_1 \\neq v_2 or k_2 \\neq v_3 then
17:
                  return reject
18:
           \\tau \\stackrel{R}{\\leftarrow} \\mathbb{F}
19:
           w_4 \\leftarrow \\ell(\\tau)
20:
           v_4 \\leftarrow K^*(\\tau) // K^* is poly. interpolation of k_0, \\ldots, k_{2s}
21:
22:
           v_4&#x27; \\leftarrow \\text{LowDegreeQuery}(\\mathcal{P}_2, w_4)
23:
           if v_4&#x27; = v_4 then
24:
                 return accept
25:
26:
           return reject</code></pre>

    <p class="text-gray-300"><span id="page-34-0"></span>Figure 5—V's side of our MIP protocol. The SUMCHECK and LOWDEGREEQUERY protocols are given in Figures 6 and 7.</p>

    <pre><code class="language-text">1: function SUMCHECK((\\mathcal{P}_i, q, \\mathcal{C}, x, y))
           s \\leftarrow \\lceil \\log(|\\mathcal{C}|) \\rceil
           r \\stackrel{R}{\\leftarrow} \\mathbb{F}^{3s}
 3:
           e \\leftarrow 0
 4:
           for j = 1, 2, ..., 3s do
 5:
                 H_i(\\cdot) \\leftarrow \\text{GetFromProver}(\\mathcal{P}_i)
 6:
                 // \\mathcal{P}_i returns H_i(\\cdot) as \\{H_i(0), H_i(1), H_i(2), H_i(3)\\}, which
 7:
 8:
                 // is sufficient to reconstruct H_i because H_i is degree-3
 9:
10:
                 if H_i(0) + H_i(1) \\neq e then
                      return reject
11:
12:
                 SendToProver(\\mathcal{P}_i, r_i)
13:
                 e \\leftarrow H_i(r_i)
14:
15:
           // notation
16:
           w_1 \\leftarrow (r_1, \\ldots, r_s)
17:
           w_2 \\leftarrow (r_{s+1}, \\dots, r_{2s})
18:
           w_3 \\leftarrow (r_{2s+1}, \\dots, r_{3s})
19:
20:
           // \\mathcal{P}_i is supposed to set v_i = \\tilde{W}(w_i), for i = 1, 2, 3.
21:
           v_1, v_2, v_3 \\leftarrow \\text{GetFromProver}(\\mathcal{P}_i)
22:
23:
           // Below, V performs the final check. In preparation:
24:
25:
           // locally evaluate io(w_1, w_2, w_3), add(w_1, w_2, w_3),
           // \\text{mult}(w_1, w_2, w_3), g_a(w_1, w_2, w_3), \\text{ and } I_{x,y}(w_1).
26:
27:
          a&#x27; \\leftarrow g_a(w_1, w_2, w_3) \\cdot (\\widetilde{io}(w_1, w_2, w_3) \\cdot (\\widetilde{I_{x,y}}(w_1) - v_1) +
28:
                          add(w_1, w_2, w_3) \\cdot (v_1 - (v_2 + v_3)) +
29:
                          \\text{mult}(w_1, w_2, w_3) \\cdot (v_1 - v_2 \\cdot v_3)
30:
31:
           if a&#x27; \\neq e then
32:
                 return reject
33:
           return (w_1, w_2, w_3, v_1, v_2, v_3)</code></pre>

    <p class="text-gray-300"><span id="page-35-0"></span>Figure 6— <span class="math">\\mathcal{V}</span> 's side of the sum-check protocol within our MIP. The intent of the protocol is to prove to  <span class="math">\\mathcal{V}</span>  that  <span class="math">0 = \\sum_{u \\in \\{0,1\\}^{3s}} h_q(u)</span> . The inputs are  <span class="math">\\mathcal{P}_i</span>  (the identity of the prover), q (used in the definition of the polynomial  <span class="math">h_q</span> ), the circuit  <span class="math">\\mathcal{C}</span> , the input x, and the purported output y; the protocol returns  <span class="math">(w_1, w_2, w_3, v_1, v_2, v_3)</span> . Roughly speaking, the protocol's guarantee is that if  <span class="math">\\mathcal{V}</span>  does not reject and if there is a low-degree polynomial  <span class="math">\\widetilde{W}</span>  such that  <span class="math">\\widetilde{W}(w_1) = v_1</span> ,  <span class="math">\\widetilde{W}(w_2) = v_2</span> , and  <span class="math">\\widetilde{W}(w_3) = v_3</span> , then with high probability  <span class="math">\\widetilde{W}</span>  is an extension of a correct transcript for  <span class="math">\\mathcal{C}</span>  on input x and purported outputs y.</p>

    <pre><code class="language-text">1: function LOWDEGREEQUERY((\\mathcal{P}_i, w))
          s \\leftarrow \\lceil \\log |\\mathcal{C}| \\rceil
          Let Q: \\mathbb{F}^2 \\to \\mathbb{F}^s be a random plane passing through w.
          Let (r_1, r_2) \\in \\mathbb{F}^2 be such that Q(r_1, r_2) = w.
 4:
          SendToProver(\\mathcal{P}_i, \\mathcal{Q})
 5:
          // above, Q can be specified by sending Q(0,0), Q(0,1),
 6:
          // and Q(1,1).
 7:
 8:
          k_{0,0}, \\dots k_{s,s} \\leftarrow \\text{GetFromProver}(\\mathcal{P}_i)
 9:
          // above, correct prover returns (s+1)^2 field elements,
10:
          // specifically K(i,j) \\in \\mathbb{F} for
11:
          //(i,j) \\in \\{0,\\ldots,s\\} \\times \\{0,\\ldots,s\\}, where K = \\widetilde{W} \\circ Q.
12:
          v \\leftarrow K^*(r_1, r_2) // K^* is poly. interpolation of k_{0,0}, \\dots, k_{s,s}
13:</code></pre>

    <p class="text-gray-300"><span id="page-36-0"></span>Figure 7— <span class="math">\\mathcal{V}</span> 's side of the point vs. plane low-degree test [60]. This protocol forces  <span class="math">\\mathcal{P}_i</span>  to make an independent claim about  <span class="math">\\widetilde{W}(w)</span> .</p>`;
---

<BaseLayout title="Verifiable computation using multiple provers (2014/846)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/846
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
