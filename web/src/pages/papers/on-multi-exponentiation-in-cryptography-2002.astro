---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/154';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'ON MULTI-EXPONENTIATION IN CRYPTOGRAPHY';
const AUTHORS_HTML = 'ROBERTO M. AVANZI&lt;sup&gt;∗&lt;/sup&gt; (IEM ESSEN) Email: mocenigo@exp-math.uni-essen.de';

const CONTENT = `    <p class="text-gray-300">ROBERTO M. AVANZI&lt;sup&gt;∗&lt;/sup&gt; (IEM ESSEN) Email: mocenigo@exp-math.uni-essen.de</p>

    <p class="text-gray-300">October 8, 2002. Revised: October 28, 2002.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6"><strong>Abstract</strong></h4>

    <p class="text-gray-300">We describe and analyze new combinations of multi-exponentiation algorithms with representations of the exponents. We deal mainly but not exclusively with the case where the inversion of group elements is fast: This is true for example for elliptic curves, groups of rational divisor classes of hyperelliptic curves, trace zero varieties and XTR.</p>

    <p class="text-gray-300">These methods are most attractive with exponents in the range from 80 to 256 bits, and can also be used for computing <em>single</em> exponentiations in groups which admit an automorphism satisfying a monic equation of small degree over the integers.</p>

    <p class="text-gray-300">The choice of suitable exponent representations allows us to match or improve the running time of the best multi-exponentiation techniques in the aforementioned range, while keeping the memory requirements as small as possible. Hence some of the methods presented here are particularly attractive for deployment in memory constrained environments such as smart cards. By construction, such methods provide good resistance against side channel attacks.</p>

    <p class="text-gray-300">We also describe some applications of these algorithms.</p>

    <p class="text-gray-300"><em>Keywords and phrases: Cryptographic protocols, Exponentiation, Integer recoding, Scalar multiplication, Elliptic and Hyperelliptic curves, Trace zero varieties, XTR, Groups with automorphisms, Smart card applications</em></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Introduction</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">2</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The algorithm</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity analysis</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Unsigned binary inputs&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Using the NAF&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Using the JSF</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt;The work described in this paper has been supported by the Commission of the European Communities through the IST Programme under Contract IST-2001-32613 (see http://www.arehcc.com). The information in this document is provided as is, and no guarantee or warranty is given or implied that the information is fit for any particular purpose. The user thereof uses the information at its sole risk and liability. The views expressed are those of the author and do not represent an official view or position of the AREHCC project (as a whole).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Comparisons</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">12</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 2.2: Optimal parameters for d = 2 and 3&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Interleaved exponentiation and exponent representations&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2.1&lt;br&gt;Radix-r representation&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2.2&lt;br&gt;The generalized non-adjacent form&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2.3&lt;br&gt;Width-w left-to-right sliding windows</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2.4&lt;br&gt;The flexible window exponentiation algorithm and the wNAF&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Comparing the two algorithms&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Applications</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Elliptic and hyperelliptic curves&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Trace zero varieties&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">XTR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Some public-key cryptographic protocols such as the verification of digital signatures require the computation of the product of powers of two [1], three [12] or more elements of a group. Furthermore, in some algebraic structures the computation of a single exponentiation can be reduced to such a product: If a commutative group G admits an automorphism σ satisfying a monic equation over the integers of degree d then g e can be computed as g e0 · σ(g) e1 · · · σ d−1 (g) &lt;sup&gt;e&lt;/sup&gt;d−&lt;sup&gt;1&lt;/sup&gt; for suitable integers e0, . . . , ed−&lt;sup&gt;1&lt;/sup&gt; which in many practical instances have size O(e &lt;sup&gt;1&lt;/sup&gt;/d) (see [15, 27]). In this context, too, the cases d = 2 and d = 3 are of particular practical relevance because of trace zero varieties and XTR (see Section 5).</p>

    <p class="text-gray-300">Such computations can be performed by computing the various powers separately and then multiplying them together. If one of the bases is known in advance and one can afford to store a lot of precomputed values, one can obtain very good performance from this idea [10]. However, if the intermediate results are not needed elsewhere, one can do much better in the general case.</p>

    <p class="text-gray-300">Shamir's trick can be extended in a straightforward way by using sliding windows: To our knowledge this was first reported in [33]. So far, this generalisation of Shamir's trick has been applied only to the usual binary representation of the exponents, and only in this basic form Moller has compared it ¨ to other methods such as <em>interleaved exponentiation</em> [23]. We combine the idea of [33] with different exponent recodings and compare these variants with interleaved multiexponentiation, thus extending Moller's analysis. One of our main concerns is to keep the memory requirements as small as possible, ¨ which is important for smart card implementations. Our results can be summarized as follows:</p>

    <p class="text-gray-300">(1) We propose and analyze variants of the algorithm from [33] which are better suited to groups where inversion is cheap. This is done by considering signed digit representations – first introduced in [6] – of the exponents. In particular we consider the <em>non-adjacent form</em> [26, 24] (see Theorem 3.6 and Remark 3.7) and a new representation of pairs of integers due to Solinas [30] (see Theorem 3.12).</p>

    <p class="text-gray-300"><em>Our best algorithms perform double exponentiations with similar performance as the best previous methods while having much smaller memory requirements: See Tables 5 and 6 (the number of operations there does not include the number of squarings, which is essentially the same in all methods which we consider) and Remark 4.6 (2). For example for a bit length</em> n <em>with</em> 124 &lt; n ≤ 354 <em>a double exponentiation is done by</em> 9 + 3n/8 <em>multiplications on average and about</em> n <em>squarings, using only</em> 12 <em>precomputed values: the precomputations can be reduced further paying only a minimal performance penalty.</em></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The algorithm 3</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(2) To our knowledge Theorem 3.6 complements existing literature on single exponentiations.</li>
      <li>(3) We show in Section 5 how all these methods can be used to speed up current and proposed cryptosystems.</li>
    </ul>

    <p class="text-gray-300">Power analysis of cryptosystems has aroused a lot of attention in the last years. It attempts to guess secret keys by monitoring power signals of cryptographic devices. Since distinct operations have different power consumptions, the use of simple square-and-multiply exponentiation methods can allow a potential attacker to recover the binary representation of the exponent. If, for example, digits  <span class="math">\\pm 1</span>  are used like in the NAF, the attacker can gain less information. Window methods are even better and the adoption of multi-exponentiation algorithms such as those presented in this paper hide the secret information very efficiently.</p>

    <p class="text-gray-300">In the next section we will introduce the general form of the algorithm from [33], which will be analysed in detail in Section 3: this forms the main part of this paper. In Section 4 the optimal parameters will be discussed and the resulting time and space complexities will be compared against those of interleaved exponentiation. Next, some applications will be outlined.</p>

    <p class="text-gray-300">Acknowledgements. This paper would not exist, at least not in its present form, without Professor Gerhard Frey's steady encouragement and support. The author is grateful to Tanja Lange who drew the author's attention to Solinas' work and proofread the manuscript. Many thanks also to Arjen Lenstra for kindly providing a reprint of [33].</p>

    <p class="text-gray-300">Some computations have been performed using the maple computer algebra system [8].</p>

    <p class="text-gray-300">We now proceed with the derivation and the description of the algorithm from [33]. Let G be a commutative group of order  <span class="math">q \\approx 2^n</span>  and d a (small) integer. Suppose we are given elements  <span class="math">g_1, \\ldots, g_d \\in G</span>  and integers  <span class="math">e_1, \\ldots, e_d</span>  and want to compute  <span class="math">x := \\prod_{i=1}^d g_i^{e_i}</span> . Write</p>

    <p class="text-gray-300"><span class="math">$e_i = \\sum_{j=0}^{n-1} e_{i,j} \\, 2^j \\tag{1}</span>$</p>

    <p class="text-gray-300">with  <span class="math">e_{i,j} \\in \\{0, \\pm 1\\}</span> . The coefficients  <span class="math">e_{i,j}</span>  are called bits (bit means binary digit): unsigned bits if the value -1 is not allowed, signed bits otherwise. In this paper, as it is now customary,  <span class="math">\\bar{1}</span>  means -1 in signed bit expansions of integers.</p>

    <p class="text-gray-300">For the moment we assume that the chosen representation is the unsigned binary one.</p>

    <p class="text-gray-300">The most obvious way of performing the desired computation, as already mentioned, consists in computing the powers separately and multiplying them together. The second most obvious way is perhaps the following one, which saves some squarings.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Algorithm 2.1 Simple multi-exponentiation</h4>

    <p class="text-gray-300">INPUT: Group elements  <span class="math">g_1, \\ldots, g_d</span>  and corresponding exponents  <span class="math">e_1, \\ldots, e_d</span>  written as in (1) in base 2 (i.e. with  <span class="math">e_{i,j} \\in \\{0,1\\}</span> )</p>

    <p class="text-gray-300">Output:  <span class="math">\\prod_{i=1}^d g_i^{e_i}</span></p>

    <pre><code class="language-text">Step 1. x\\leftarrow 1\\in G
Step 2. for j=n-1\\dots 0 do \\{   x\\leftarrow x^2    [Skip at first iteration] for i=1\\dots d do \\{ if e_{i,j}=1 then x\\leftarrow x\\cdot g_i \\} \\}
Step 3. return x
</code></pre>

    <p class="text-gray-300">Shamir's trick improves Algorithm 2.1 as follows: First precompute the  <span class="math">2^d</span>  values  <span class="math">\\prod_{i=1}^d g_i^{\\{0,1\\}}</span> . Then put  <span class="math">x = \\prod_{i=1}^d g_i^{e_{i,n-1}}</span>  by one table look-up. Finally, for  <span class="math">j = n-2,\\ldots,1,0</span> , replace x by  <span class="math">x^2 \\cdot \\prod_{i=1}^d g_i^{e_{i,j}}</span>  by one squaring, one table look-up and one multiplication. Shamir's method requires  <span class="math">2^d - d - 1</span>  multiplications to prepare the table, n squarings and on average  <span class="math">(1-2^{-d})n</span>  multiplications,  <span class="math">2^{-d}</span>  being the probability that for a fixed j,  <span class="math">e_{i,j}</span>  is 0 for all  <span class="math">i = 1, 2, \\ldots, d</span> . If the exponents are written in a signed binary representation, the table  <span class="math">\\mathcal E</span>  can be formed from the products  <span class="math">\\prod_{i=1}^d g_i^{k_i}</span>  with  <span class="math">k_i \\in \\{0,\\pm 1\\}</span> . If the cost of an inversion in the group G is negligible, which is usually the main reason for adopting a signed binary representation, one only needs a half of those values, i.e. those where the first nonzero  <span class="math">k_i</span>  equals 1. Then some products are replaced by divisions. This method can be improved by means of sliding windows [19] in the same way as the square-and-multiply method. We describe the resulting algorithm.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6"><strong>Algorithm 2.2</strong> Multi-exponentiation with parallel sliding windows</h4>

    <p class="text-gray-300">INPUT: A window size w, integers  <span class="math">e_1, \\ldots, e_d</span>  as in (1) and a set  <span class="math">\\mathcal E</span>  of precomputed elements of the group G of the form  <span class="math">\\prod_{i=1}^d g_i^{k_i}</span>  including  <span class="math">g_1, \\ldots, g_d</span>  (the set  <span class="math">\\mathcal E</span>  depends on w and on the chosen representation for the integers  <span class="math">e_i</span> : see Remarks 2.3 (3–4) for examples)</p>

    <p class="text-gray-300">Output:  <span class="math">\\prod_{i=1}^d g_i^{e_i}</span></p>

    <pre><code class="language-text">Step 1. t \\leftarrow n and x \\leftarrow 1 \\in G

Step 2. if (e_{i,t-1} = 0 \\text{ for } i = 1,2,\\ldots,d) then \\{
(a) t \\leftarrow t-1 and x \\leftarrow x^2
\\} else \\{
(b) if t \\geq w then t \\leftarrow t-w else \\{ w \\leftarrow t \\text{ and } t \\leftarrow 0 \\}
(c) for i=1,2,\\ldots,d do f_i \\leftarrow \\sum_{j=0}^{w-1} e_{i,t+j} 2^j
(d) Let s be the largest integer s \\geq 0 such that 2^s | f_i for all i
(e) for i=1,2,\\ldots,d do f_i \\leftarrow f_i/2^s
(f) (i) x \\leftarrow x^{2^{w-s}}; (ii) x \\leftarrow x \\cdot \\prod_{i=1}^d g_i^{f_i} and (iii) x \\leftarrow x^{2^s}
\\}
Step 3. if t=0 then return x else goto Step 2
</code></pre>

    <p class="text-gray-300"><strong>Remarks 2.3</strong> (1) In the case d = 1 the above algorithm is the usual sliding window exponentiation algorithm. If w = 1 then it is just Shamir's trick.</p>

    <p class="text-gray-300">(2) At the beginning of Step 2 (c)  <span class="math">f_i</span>  is the integer represented by a string of w consecutive bits from the exponent  <span class="math">e_i</span> . Now s is the largest non-negative integer such that  <span class="math">e_{i,t+u} = 0</span>  for all i and all u with  <span class="math">0 \\le u \\le s</span> . The normalisation Step 2 (e) is performed such that at least one of the integers  <span class="math">f_i</span>  is</p>

    <p class="text-gray-300">odd, in order to reduce the number of elements of  <span class="math">\\mathcal{E}</span>  without impacting the total number of operations done in Step 2 (f).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(3) In Step 2 (f) the first time it is x = 1, so one multiplication can be saved and only s squarings are needed.</li>
      <li>(4) If the exponents are written in base 2, then  <span class="math">\\mathcal{E}</span>  consists of all elements of the form  <span class="math">\\prod_{i=1}^d g_i^{k_i}</span>  such that  <span class="math">0 \\leq k_i &lt; 2^w</span>  and at least one of the  <span class="math">k_i</span>  is odd. Then Step 2 (f) is done with one table look-up, one multiplication and w squarings.</li>
      <li>(5) The changes to Algorithm 2.2 required to work with the NAF are straightforward. A detailed discussion of this case is found in Subsection 3.2. One important consequence of the fact that inversion is free is that the size of  <span class="math">\\mathcal E</span>  can be reduced: In fact in Step 2 (f,ii) one can compute either  <span class="math">x \\leftarrow x \\cdot \\prod_{i=1}^d g_i^{f_i}</span>  or  <span class="math">x \\leftarrow x/\\prod_{i=1}^d g_i^{-f_i}</span>  so only a half of the full table is required.</li>
    </ul>

    <h2 id="sec-4" class="text-2xl font-bold">3 Complexity analysis</h2>

    <p class="text-gray-300">In this section we are concerned only with Algorithm 2.2 and its complexity.</p>

    <p class="text-gray-300"><strong>Definition 3.1</strong> A column is defined as a d-tuple of digits  <span class="math">e^{(t)} = (e_{1,t}, \\ldots, e_{d,t})</span>  of the representation of integers (1) and the ordered sequence  <span class="math">e^{(n-1)}, e^{(n-2)}, \\ldots, e^{(0)}</span>  of such columns is called joint representation of the d exponents  <span class="math">e_1, \\ldots, e_d</span> .</p>

    <p class="text-gray-300">If  <span class="math">e^{(n-1)} \\neq 0</span>  then the joint representation is said to be proper and n is its length.</p>

    <p class="text-gray-300">The number of nonzero colums in the joint representation is called its Hamming weight, and its density is the ratio of the Hamming weight to the length.</p>

    <p class="text-gray-300">For simplicity we require that the joint representation of the exponents  <span class="math">e_1, \\ldots, e_d</span>  is proper. Thus at the first iteration of Step (2), substeps (b)–(f) are always performed. To evaluate the number of squarings one should not consider those which can be avoided in the first iteration, which are w minus the expected first value of s.</p>

    <p class="text-gray-300">Algorithm 2.2 scans the joint representation of the d exponents  <span class="math">e_1, \\ldots, e_d</span>  one column at a time, starting with the column formed by the most significant digits in the chosen representation. Step 2 is iterated until the joint representation has been scanned completely. At each iteration one column is read and the algorithm enters in one of two possible distinct states:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">S_0</span> . A zero column is found, so the scanning advances by one column (Step 2 (a)).</li>
      <li><span class="math">S_1</span> . A nonzero column is found and the scanning advances by w columns (Steps 2 (b)–(f)).</li>
    </ul>

    <p class="text-gray-300">The number of multiplications (excluding squarings) performed by the algorithm equals the number of times we are in the second state. Let  <span class="math">\\pi</span>  be the probability that the column read in Step 2 is zero. After m iterations, the expected number of columns read by the scanning process is  <span class="math">(\\pi + w(1 - \\pi))m</span> . Suppose that for some m this number is n. The number of multiplications performed by Algorithm 2.2 in Step 2 (d) is then  <span class="math">(1 - \\pi)m - 1</span>  (remember that the first multiplication can be replaced by an assignment) <em>i.e.</em></p>

    <p class="text-gray-300"><span class="math">$n \\cdot \\frac{1-\\pi}{\\pi + w(1-\\pi)} - 1. \\tag{2}</span>$</p>

    <p class="text-gray-300">This is, with some adaptations, the approach followed in the next two subsections.</p>

    <p class="text-gray-300"><strong>Definition 3.2</strong> Let  <span class="math">e = \\sum_{j=0}^{n-1} e_j 2^j</span>  be an integer. We say that an algorithm scans (generates, rewrites...) the bits  <span class="math">e_j</span>  right-to-left (resp. left-to-right) if it scans (generates, rewrites...) them from</p>

    <p class="text-gray-300">the least significant ones to the most significant ones, i.e. first  <span class="math">e_0</span> , then  <span class="math">e_1</span> ,  <span class="math">e_2</span> , etc. (resp. from the most significant ones to the least significant ones, i.e. first  <span class="math">e_{n-1}</span> , then  <span class="math">e_{n-2}</span> , and so on).</p>

    <p class="text-gray-300">Similar definitions hold for algorithms which deal with the colums of a joint representation of several integers.</p>

    <p class="text-gray-300"><strong>Remark 3.3</strong> Algorithm 2.2 processes the columns of the chosen joint representation of the exponents left-to-right. However most recoding algorithms for producing signed binary representations, such as Reitwiesner's algorithm [26] and Solinas' own algorithm for the Joint Sparse Form, rewrite the exponents right-to-left. In such situations recoding and (multi-)exponentiation cannot be interleaved, and the recoded representations must be stored explicitly. This is a general problem with window methods.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8"><strong>Unsigned binary inputs</strong></h3>

    <p class="text-gray-300">Here the exponents are written in base 2, i.e.  <span class="math">e_{i,j} \\in \\{0,1\\}</span> . The set  <span class="math">\\mathcal{E}</span>  consists of all elements of the form  <span class="math">\\prod_{i=1}^d g_i^{k_i}</span>  such that  <span class="math">0 \\le k_i &lt; 2^w</span>  and at least one of the  <span class="math">k_i</span>  is odd. It has cardinality  <span class="math">2^{wd} - 2^{(w-1)d}</span> . Half of the powers of the base elements  <span class="math">g_i</span>  can be computed by squarings and all other elements by products.</p>

    <p class="text-gray-300">The bits in each representation are assumed to be zero or one with equal probability and independent from the adjacent bits, so  <span class="math">\\pi = 2^{-d}</span> . To evaluate the number of squarings in the main loop of the algorithm we must determine the expected value of s at the first iteration. As all the bits are independent from each other,  <span class="math">s \\ge u</span>  with  <span class="math">1 \\le u &lt; w</span>  with probability  <span class="math">2^{-ud}</span> . Hence the expected value of s is  <span class="math">\\sum_{u=1}^{w-1} 2^{-ud} = \\frac{1-2^{-d(w-1)}}{2^d-1}</span> . We have thus the following result:</p>

    <p class="text-gray-300">Theorem 3.4 Suppose that in Algorithm 2.2 the unsigned binary representation is used for the exponents and that their joint representation has length n.</p>

    <p class="text-gray-300">Then the set  <span class="math">\\mathcal{E}</span>  has cardinality  <span class="math">2^{wd} - 2^{(w-1)d}</span>  and requires  <span class="math">2^{wd} - 2^{(w-1)d} - d</span>  operations to be computed: of these at least  <span class="math">d(2^{w-1} - 1)</span>  can be assumed to be squarings.</p>

    <p class="text-gray-300">The expected number of multiplications in the algorithm is  <span class="math">n \\frac{1}{w + (2^d - 1)^{-1}} - 1</span>  and that of the</p>

    <p class="text-gray-300">squarings is  <span class="math">n - w + \\frac{1 - 2^{-d(w-1)}}{2^d - 1}</span> .</p>

    <p class="text-gray-300"><strong>Remark 3.5</strong> In the case w=d=2, the set  <span class="math">\\mathcal{E}</span>  consists of the values  <span class="math">g_1^ag_2^b</span>  with  <span class="math">0\\leq a,b\\leq 3</span>  and at least one of a, b odd. To determine them one has to compute and store  <span class="math">g_1^2</span>  and  <span class="math">g_1^3</span> , as well as  <span class="math">g_2^2</span>  and  <span class="math">g_2^3</span> . This requires 2 squarings and 2 multiplications. Computing the remaining 8 values requires 8 further multiplications.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">3.2 Using the NAF</h4>

    <p class="text-gray-300">A non-adjacent form (abbreviated as NAF) is a signed binary representation of an integer e = <span class="math">\\sum_{j=0}^{n-1} b_j 2^j</span>  with  <span class="math">b_j \\in \\{0,\\pm 1\\}</span>  and  <span class="math">b_j b_{j-1} = 0</span> . Each integer admits a NAF, which is uniquely determined. It is the signed binary representation of minimal Hamming weight and it has expected density 1/3 (see [24] and [2] for proofs).</p>

    <p class="text-gray-300">Reading NAFs through non-sliding windows has been considered already but only for a single NAF (i.e. d=1) and not in the case of joint representations: See the paper [13], of which we use some arguments in this subsection. We consider here sliding windows, which lead to lower complexity. Hence, even in the case d=1 our results will complement existing literature. This must not be confused with the wNAF, cfr. §4.2.4.</p>

    <p class="text-gray-300"><strong>Theorem 3.6</strong> Suppose that in Algorithm 2.2 the exponents are input in NAF, and that their joint representation is n bits long.</p>

    <p class="text-gray-300">The set  <span class="math">\\mathcal E</span>  has cardinality  <span class="math">(I_w^d-I_{w-1}^d)/2</span>  where  <span class="math">I_w=\\frac{2^{w+2}-(-1)^w}{3}</span> . The number of squarings in the main loop of the algorithm is between n-w and n-1, with an heuristically expected value  <span class="math">n-w+\\left(\\frac{4}{3}\\right)^d\\frac{1-2^{-d(w-1)}}{2^d-1}</span> . In the cases d=1,2 and 3 respectively, the expected number of multiplications is  <span class="math">n\\cdot\\frac{1-\\pi^{(d)}}{w-(w-1)\\pi^{(d)}}-1</span>  where</p>

    <p class="text-gray-300"><span class="math">$\\pi^{(1)} = \\frac{4(2^{w} - (-1)^{w})}{7 \\cdot 2^{w} - 4 \\cdot (-1)^{w}}, \\quad \\pi^{(2)} = \\frac{16(4^{w} - 1)}{43 \\cdot 4^{w} + 24 \\cdot (-2)^{w} - 16} \\quad and</span>$</p>

    <p class="text-gray-300"><span class="math">$\\pi^{(3)} = \\frac{64(2^{w} + (-1)^{w})(8^{w} - (-1)^{w})}{253 \\cdot 16^{w} + 397 \\cdot (-8)^{w} + 324 \\cdot 4^{w} + 80 \\cdot (-2)^{w} - 64}.</span>$
(3)</p>

    <p class="text-gray-300">In particular for d=1 the expected number of multiplications is  <span class="math">n \\cdot \\frac{1}{w + \\frac{4}{5}(1 - (-\\frac{1}{5})^w)} - 1</span> .</p>

    <p class="text-gray-300"><strong>Remark 3.7</strong> In the case w = d = 2, the set  <span class="math">\\mathcal{E}</span>  consists of the values  <span class="math">g_1^a g_2^b</span>  with either  <span class="math">0 &lt; a \\le 2</span> and  <span class="math">-2 \\le b \\le 2</span>  where at least one of a, b odd, or a = 0 and b = 1. A chain for computing  <span class="math">\\mathcal{E}</span>  by 6 multiplications or multiplications with the inverse is</p>

    <p class="text-gray-300"><span class="math">$\\{g_1, g_2, g_1g_2, g_1g_2^{-1}, g_1g_2^{2}, g_1g_2^{-2}, g_1^2g_2, g_1^2g_2^{-1}\\}.</span>$</p>

    <p class="text-gray-300">The remainder of this subsection is devoted to the proof of Theorem 3.6.</p>

    <p class="text-gray-300">First note that the largest integer representable by a w-bit number in NAF is  <span class="math">(10...01)_2</span>  for odd w and  <span class="math">(10...10)_2</span>  for even w: It is easy to see that this number is  <span class="math">T_w = (2^{w+2} - 3 - (-1)^w)/6</span> . Hence, there are  <span class="math">I_w = (2^{w+2} - (-1)^w)/3</span>  integers in the interval  <span class="math">[-T_w, \\ldots, T_w]</span> . Now  <span class="math">\\mathcal E</span>  consists of all elements of the form  <span class="math">\\prod_{i=1}^d g_i^{k_i}</span>  such that  <span class="math">|k_i| \\leq T_w</span>  for  <span class="math">i=1,2,\\ldots,d</span> , at least one of the  <span class="math">k_i</span>  is odd and the first nonzero element in the sequence  <span class="math">k_1,k_2,\\ldots,k_p</span>  is positive. In this way, if in Step 2 (f,ii) the first nonzero  <span class="math">f_i</span>  is positive we compute  <span class="math">x \\leftarrow x \\cdot \\prod_{i=1}^d g_i^{f_i}</span>  otherwise we compute  <span class="math">x \\leftarrow x / \\prod_{i=1}^d g_i^{f_i}</span> . Hence we need only  <span class="math">(I_w^d - I_{w-1}^d)/2</span>  elements in  <span class="math">\\mathcal{E}</span> .</p>

    <p class="text-gray-300"><strong>Definition 3.8</strong> A joint representation of integers in NAF will be called a joint NAF.</p>

    <p class="text-gray-300"><strong>Definition 3.9</strong> Let  <span class="math">e = (e_1, \\dots, e_d)</span>  be a d-tuple of n-bit integers so that (1) is proper. The bit-reversing  <span class="math">\\hat{e}</span>  of e is the d-tuple formed by the numbers  <span class="math">\\hat{e}_i = \\sum_{j=0}^{n-1} e_{i,(n-1)-j} 2^j</span> .</p>

    <p class="text-gray-300">To avoid ambiguity, we define bit-reversing only for proper joint representations. The mapping which associates to a proper joint NAF its bit-reversing induces a bijection between the set of proper joint NAF's of d integers of n bits and the set of joint NAF's (not necessarily proper) of d integers of n bits, at least one of the integers being odd. Hence the expected number of windows made by Algorithm 2.2 on n-bit proper joint NAF's of d integers equals the expected number of windows formed by a sliding window algorithm which scans from right to left joint NAF's of d integers of n bits, at least one odd. The parity condition amounts to the fact that at the first iteration a nonzero column is found, exactly as in the original algorithm.</p>

    <p class="text-gray-300">Consequently we will consider an algorithm which forms sliding windows on joint NAF's from right to left, and we will model it as a Markov chain: At each iteration one column is read and the algorithm enters in one of d+1 possible distinct states, defined by the number of nonzero entries in the colums:</p>

    <p class="text-gray-300"><span class="math">S_0&#x27;</span> . A zero column is found, so the scanning advances by one column.</p>

    <p class="text-gray-300"><span class="math">S_k&#x27;</span>  (for  <span class="math">1 \\le k \\le d</span> ). A column is found with exactly k nonzero entries and the scanning advances by w columns.</p>

    <p class="text-gray-300">To determine the transition probability from state  <span class="math">\\mathcal{S}&#x27;_{\\ell}</span>  to state  <span class="math">\\mathcal{S}&#x27;_{k}</span>  we need a few preliminary results. We begin with a review of Reitwiesner's algorithm for recoding the unsigned binary representation of a number  <span class="math">e = \\sum_{j=0}^{n-1} b_{j} 2^{j}</span>  into a NAF  <span class="math">\\sum_{j=0}^{n} e_{j} 2^{j}</span> . For  <span class="math">j=0,1,\\ldots,n-1</span> , the digit  <span class="math">e_{j}</span>  of the NAF is a function of the values of  <span class="math">b_{j+1}</span> ,  <span class="math">b_{j}</span>  and of the j-th carry  <span class="math">c_{j}</span> , which is equal to one if the NAF of the truncated number  <span class="math">e = \\sum_{i=0}^{j-1} b_{i} 2^{i}</span>  is one bit longer than its unsigned binary representation. At the beginning  <span class="math">c_{0}=0</span> . The recoding is then done as shown in Table 1 – where we also write the admissible following state according to the value of  <span class="math">e_{i+2}</span>  and the corresponding output – and at the end  <span class="math">e_{n}=c_{n-1}</span> . If  <span class="math">e_{n}\\neq 0</span>  then the NAF is longer than the original representation. Since in the</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">State</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Input</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Output</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Next State (and <span class="math">e_{i+1}</span> )</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(b_{i+1} b_i)_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">c_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">e_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">c_{i+1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">if <span class="math">b_{i+2} = 0</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">if <span class="math">b_{i+2} = 1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_0</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(00)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_0(0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_4(0)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(00)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_0(0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_4(0)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(01)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_0(0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_4(0)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(01)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_1</span> (1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_5</span> <span class="math">(\\bar{1})</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_4</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(10)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_2</span> (1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_6</span> <span class="math">(\\bar{1})</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_5</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(10)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_3(0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_7(0)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_6</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(11)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_3(0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_7(0)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_7</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(11)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_3(0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_7(0)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: States of Reitwiesner's Algorithm</p>

    <p class="text-gray-300">unsigned binary representation each bit assumes a value of zero or one with equal probability and there is no dependency between any two bits, it is clear that all admissible transitions from a state  <span class="math">s_{\\ell}</span>  to a state  <span class="math">s_{\\ell}</span>  occur with probability  <span class="math">\\frac{1}{2}</span> . It is straightforward to write down the corresponding transition probability matrix P. The resulting limiting probabilities for the states  <span class="math">s_0, \\ldots, s_7</span>  are thus [13] given by the vector</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{v} = \\left[ \\frac{1}{6}, \\frac{1}{12}, \\frac{1}{12}, \\frac{1}{6}, \\frac{1}{6}, \\frac{1}{12}, \\frac{1}{12}, \\frac{1}{6} \\right]</span>$</p>

    <p class="text-gray-300">whose components add up to 1 and which satisfies  <span class="math">P \\cdot \\mathbf{v}^{\\perp} = \\mathbf{v}^{\\perp}</span> . (Here the symbol  <span class="math">\\perp</span>  denotes matrix transposition.) From this it is immediate, upon summing the probabilities for states  <span class="math">s_1, s_2, s_5</span>  and  <span class="math">s_6</span> , to obtain the known result that the expected Hamming weight of a NAF is  <span class="math">\\frac{1}{3}</span> . The fact which is more relevant to us here is that states  <span class="math">s_0, s_3, s_4</span>  and  <span class="math">s_7</span> , which all output a zero, occur with equal probabilities, and that in two cases another zero will be output by the next state, whereas in the other two a nonzero bit will be output. We have thus proved the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 3.10</strong> The probability that in a NAF the digit immediately to the left of a 0 is another 0 is  <span class="math">\\frac{1}{2}</span>  and that it is 1 or -1 is in each case  <span class="math">\\frac{1}{4}</span> .</p>

    <p class="text-gray-300">We now generalize this by determining the probabilities that a bit  <span class="math">e_{j,i+w}</span>  which is w places to the left of  <span class="math">e_{j,i}</span>  is zero or one, depending on the value of  <span class="math">e_{j,i}</span>  and w.</p>

    <p class="text-gray-300"><strong>Lemma 3.11</strong> If  <span class="math">e_{j,i} = 0</span> , then  <span class="math">e_{j,i+w} = 0</span>  with probability  <span class="math">\\pi_{w,0}</span>  and  <span class="math">e_{j,i+w} \\neq 0</span>  with probability  <span class="math">\\pi_{w,*}</span> , where</p>

    <p class="text-gray-300"><span class="math">$\\pi_{w,0} = \\frac{2^{w+1} + (-1)^w}{3 \\cdot 2^w}</span>$
and  <span class="math">\\pi_{w,*} = 1 - \\pi_{w,0} = \\frac{1}{2} \\pi_{w-1,0} = \\frac{2^w - (-1)^w}{3 \\cdot 2^w}</span> . (4)</p>

    <p class="text-gray-300">Since a nonzero bit is always followed by a zero, we also have that if  <span class="math">e_{j,i} \\neq 0</span> , then  <span class="math">e_{j,i+w} = 0</span>  with probability  <span class="math">\\pi_{w-1,0}</span>  and  <span class="math">e_{j,i+w} \\neq 0</span>  with probability  <span class="math">\\pi_{w-1,*}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Clearly  <span class="math">\\pi_{w,0} + \\pi_{w,*} = 1</span> . By Lemma 3.10 we have  <span class="math">\\pi_{1,0} = \\pi_{1,*} = \\frac{1}{2}</span>  and</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} \\pi_{i+1,0} = \\pi_{i,*} + \\frac{1}{2}\\pi_{i,0} = 1 - \\frac{1}{2}\\pi_{i,0} \\\\ \\pi_{i+1,*} = \\frac{1}{2}\\pi_{i,0}. \\end{cases}</span>$</p>

    <p class="text-gray-300">Now (4) follows easily by induction.</p>

    <p class="text-gray-300">We are now in the position to model the right-to-left scanning process as a Markov chain with states  <span class="math">S&#x27;_0, \\ldots, S&#x27;_d</span>  defined in (*). Denote by  <span class="math">\\tau_{\\ell,k}</span>  the transition probability from state  <span class="math">S&#x27;_\\ell</span>  to state  <span class="math">S&#x27;_k</span> .</p>

    <p class="text-gray-300">Suppose that a zero column is read. Then no window is being formed and at the next iteration the scanning algorithm will read the next column to the left. The probability  <span class="math">\\tau_{0,k}</span>  that this column contains exactly k nonzero entries is  <span class="math">\\binom{d}{k} \\frac{1}{2k}</span> .</p>

    <p class="text-gray-300">On the other hand suppose that a column c with exactly  <span class="math">\\ell \\neq 0</span>  nonzero entries has been read. The bit-reversing of the numbers represented by this column and the next w-1 columns at its left are the exponents  <span class="math">f_1,\\ldots,f_d</span>  in Step 2(c). The next column checked by the right-to-left scanning process, say c', will be then that which is exactly w places to the left of c. Now  <span class="math">\\tau_{\\ell,k}</span>  is the probability that c' has exactly k nonzero entries (where  <span class="math">0 \\leq k \\leq d</span> ). For some integer r, in exactly r of the positions occupied by the  <span class="math">\\ell</span>  nonzero digits in c there will be nonzero bits in the respective positions in c', and in the positions of the remaining  <span class="math">\\ell-r</span>  nonzero bits in c there will be zeros in c'. Therefore, to exactly k-r of the zero bits in c will correspond nonzero bits in c', and to the other  <span class="math">d-\\ell-(k-r)</span>  zeros of c will correspond zeros in c'. Finally</p>

    <p class="text-gray-300"><span class="math">$\\tau_{\\ell,k} = \\sum_{\\substack{r : 0 \\le r \\le \\ell \\\\ 0 \\le k - r \\le d - \\ell}} {\\ell \\choose r} {d - \\ell \\choose k - r} \\pi_{w-1,*}^r \\pi_{w-1,0}^{\\ell-r} \\pi_{w,*}^{k-r} \\pi_{w,0}^{d-\\ell-(k-r)}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\substack{r : 0 \\le r \\le \\ell \\\\ k + \\ell - d \\le r \\le k}} {\\ell \\choose r} {d - \\ell \\choose k - r} (1 - 2\\pi_{w,*})^r 2^{\\ell-r} \\pi_{w,*}^{\\ell-r} \\pi_{w,*}^{k-r} (1 - \\pi_{w,*})^{d-\\ell-(k-r)}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\substack{r : min \\{\\ell,k\\} \\\\ r = max \\{0,k+\\ell-d\\}}} {\\ell \\choose r} {d - \\ell \\choose k - r} 2^{\\ell-r} \\pi_{w,*}^{\\ell+k-2r} (1 - \\pi_{w,*})^{(d-\\ell-k)+r} (1 - 2\\pi_{w,*})^r.</span>$</p>

    <p class="text-gray-300">Put</p>

    <p class="text-gray-300"><span class="math">$T_{d} = (\\tau_{\\ell,k})_{\\ell,k=0}^{d} = \\begin{pmatrix} 1/2^{d} &amp; \\tau_{1,0} &amp; \\tau_{2,0} &amp; \\cdots &amp; \\tau_{d,0} \\\\ \\binom{d}{1}/2^{d} &amp; \\tau_{1,1} &amp; \\tau_{2,1} &amp; \\cdots &amp; \\tau_{d,1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\binom{d}{d-1}/2^{d} &amp; \\tau_{1,d-1} &amp; \\tau_{2,d-1} &amp; \\cdots &amp; \\tau_{d,d-1} \\\\ 1/2^{d} &amp; \\tau_{1,d} &amp; \\tau_{2,d} &amp; \\cdots &amp; \\tau_{d,d} \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">The limiting probabilities  <span class="math">\\sigma_0, \\ldots, \\sigma_d</span>  of the algorithm being in state  <span class="math">\\mathcal{S}&#x27;_0, \\ldots, \\mathcal{S}&#x27;_d</span>  respectively satisfy</p>

    <p class="text-gray-300"><span class="math">\\sum_{k=1}^{d} \\sigma_k = 1</span>  and  <span class="math">T_d \\cdot (\\sigma_0 \\cdots \\sigma_d)&#x27; = (\\sigma_0 \\cdots \\sigma_d)&#x27;</span> . Hence, upon putting</p>

    <p class="text-gray-300"><span class="math">$U_{d} = \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ d/2^{d} &amp; \\tau_{1,1} - 1 &amp; \\tau_{2,1} &amp; \\cdots &amp; \\tau_{d,1} \\\\ \\binom{d}{2}/2^{d} &amp; \\tau_{1,2} &amp; \\tau_{2,2} - 1 &amp; \\cdots &amp; \\tau_{d,2} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ d/2^{d} &amp; \\tau_{1,d-1} &amp; \\tau_{2,d-1} &amp; \\cdots &amp; \\tau_{d,d-1} \\\\ 1/2^{d} &amp; \\tau_{1,d} &amp; \\tau_{2,d} &amp; \\cdots &amp; \\tau_{d,d} - 1 \\end{pmatrix},</span>$</p>

    <p class="text-gray-300">we have  <span class="math">U_d \\cdot (\\sigma_0 \\cdots \\sigma_d)^{\\perp} = (1, 0, \\dots, 0)^{\\perp}</span> . Hence, provided that  <span class="math">U_d</span>  is invertible,  <span class="math">(\\sigma_0 \\cdots \\sigma_d)^{\\perp} = U_d^{-1} \\cdot (1, 0, \\dots, 0)^{\\perp}</span>  and in particular  <span class="math">\\sigma_0</span>  is the value in the top left corner of  <span class="math">U_d^{-1}</span> .</p>

    <p class="text-gray-300">We are interested in  <span class="math">U_d</span>  only in the cases d=1,2 and 3. Upon putting  <span class="math">\\alpha=2^w</span>  and  <span class="math">\\beta=(-1)^w</span>  we obtain</p>

    <p class="text-gray-300"><span class="math">$U_1 = \\begin{pmatrix} 1 &amp; 1 \\\\ \\frac{1}{2} &amp; \\frac{\\alpha+2\\beta}{3\\alpha} - 1 \\end{pmatrix}, \\qquad U_2 = \\begin{pmatrix} 1 &amp; 1 &amp; 1 \\\\ \\frac{1}{2} &amp; \\frac{4\\alpha^2 + \\alpha\\beta + 4\\beta^2}{9\\alpha^2} - 1 &amp; \\frac{4(\\alpha-\\beta)(\\alpha+2\\beta)}{9\\alpha^2} \\\\ \\frac{1}{4} &amp; \\frac{(\\alpha-\\beta)(\\alpha+2\\beta)}{9\\alpha^2} &amp; \\frac{(\\alpha+2\\beta)^2}{9\\alpha^2} - 1 \\end{pmatrix} \\quad \\text{and} \\quad U_3 = \\begin{pmatrix} 1 &amp; 1 &amp; 1 \\\\ \\frac{1}{2} &amp; \\frac{4\\alpha^2 + \\alpha\\beta + 4\\beta^2}{9\\alpha^2} - 1 &amp; \\frac{4(\\alpha-\\beta)(\\alpha+2\\beta)}{9\\alpha^2} \\\\ \\frac{1}{2} &amp; \\frac{(\\alpha-\\beta)(\\alpha+2\\beta)}{9\\alpha^2} &amp; \\frac{(\\alpha+2\\beta)^2}{9\\alpha^2} - 1 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300"><span class="math">$U_{3} = \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1 \\\\ \\frac{3}{8} &amp; \\frac{(2\\alpha+\\beta)(2\\alpha^{2}-\\alpha\\beta+2\\beta^{2})}{9\\alpha^{3}} - 1 &amp; \\frac{4(\\alpha^{3}-\\beta^{3})}{9\\alpha^{3}} &amp; \\frac{4(\\alpha-\\beta)^{2}(\\alpha+2\\beta)}{9\\alpha^{3}} \\\\ \\frac{3}{8} &amp; \\frac{2(\\alpha^{3}-\\beta^{3})}{9\\alpha^{3}} &amp; \\frac{(\\alpha+2\\beta)(2\\alpha^{2}-\\alpha\\beta+2\\beta^{2})}{9\\alpha^{3}} - 1 &amp; \\frac{2(\\alpha-\\beta)(\\alpha+2\\beta)^{2}}{9\\alpha^{3}} \\\\ \\frac{1}{8} &amp; \\frac{(\\alpha-\\beta)^{2}(\\alpha+2\\beta)}{27\\alpha^{3}} &amp; \\frac{(\\alpha-\\beta)(\\alpha+2\\beta)^{2}}{27\\alpha^{3}} &amp; \\frac{(\\alpha+2\\beta)^{3}}{27\\alpha^{3}} - 1 \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">The above matrices have been written down using simple maple [8] code. With he same software it is immediate to verify that for d=1,2 and 3 the matrix  <span class="math">U_d</span>  is invertible and to compute  <span class="math">\\sigma_0</span> , <em>i.e.</em> the value of  <span class="math">\\pi</span>  in the introductory part of this section. We thus obtain the values  <span class="math">\\pi=\\pi^{(d)}</span>  given in equation (3), Theorem 3.6.</p>

    <p class="text-gray-300">To estimate the value of s at the first iteration of the main loop, we proceed heuristically. [13, Theorem 1] states that the probability that a length u bit section of a number in NAF is zero is  <span class="math">\\frac{4}{3}(\\frac{1}{2})^u</span> . For  <span class="math">u=1,\\ldots,w-1</span>  we apply this result to the u least significant bits used to form each of the integers  <span class="math">f_1,\\ldots,f_d</span>  in Step 2 (c) at the first iteration of the loop of Algorithm 2.2. We then proceed as in the proof of Theorem 3.4, the only difference consisting in the multiplicative factor  <span class="math">\\left(\\frac{4}{3}\\right)^d</span> .</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">3.3 Using the JSF</h4>

    <p class="text-gray-300">The Joint Sparse Form has been introduced by Solinas [30] to make Shamir's trick more effective for elliptic curves. It applies however to all groups where inversion is for free. It has been defined only for <em>pairs</em> of integers: accordingly we will restrict ourselves to the case d=2 here. We shall also assume that w=2: this assumption fits naturally with the defining properties of the JSF, and by a good stoke of luck this brings the highest improvement over the methods studied before for exponents in the range in which we are interested. For more precise statements see Subsection 4.1, in particular the row for w=2 in Table 2 and Remark 4.1.</p>

    <p class="text-gray-300">In this subsection we prove the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 3.12</strong> Suppose that in Algorithm 2.2 Solinas' JSF is used for the exponents, and w = d = 2. Assume further that the JSF of the exponents has length n.</p>

    <p class="text-gray-300">The expected number of multiplications in the main loop of the algorithm is  <span class="math">\\frac{3}{8}n-1</span> , and the heuristically expected number of squarings is  <span class="math">n-2+\\frac{1}{2}=n-\\frac{3}{2}</span> .</p>

    <p class="text-gray-300">The set  <span class="math">\\mathcal{E}</span>  consists of the 10 elements  <span class="math">g_1^a g_2^b</span>  with: (i) a=0 and b=1; (ii) a=1 and  <span class="math">-2 \\le b \\le 2</span> ; (iii) a=2 and  <span class="math">b \\in \\{\\pm 1, \\pm 3\\}</span>  and (iv) a=3 and  <span class="math">b=\\pm 2</span> . A chain for precomputing all the 10 required values other than  <span class="math">g_1</span>  and  <span class="math">g_2</span>  and requiring 10 multiplications or divisions is</p>

    <p class="text-gray-300">$$\\begin{cases}
g_1, &amp; g_2, &amp; g_1g_2, &amp; g_1g_2^{-1}, &amp; g_1g_2^{2}, &amp; g_1g_2^{-2}, \\
g_1^2g_2, &amp; g_1^2g_2^{-1}, &amp; g_1^2g_2^{3}, &amp; g_1^2g_2^{-3}, &amp; g_1^3g_2^{2}, &amp; g_1^3g_2^{-2}.
\\end{cases}$$
(5)</p>

    <p class="text-gray-300">We assume that the reader is acquainted with the results in Solinas' cited technical report, from which we recall however a few important facts. The joint Hamming weight of the JSF of two integers is minimal among all (un)signed joint binary representations of the same pair of integers. Its average density is 1/2 – which gives the heuristical estimate of the squarings in the main loop – whereas that of the joint unsigned binary representation and of the joint NAF is 3/4 and 5/9 respectively. It is natural then to expect that using the JSF in Algorithm 2.2 would lead to an improvement over the complexities of the other two cases even if w &gt; 1.</p>

    <p class="text-gray-300">The JSF is uniquely determined by the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(JSF-1) Of any three consecutive columns, at least one is zero.</li>
      <li>(JSF-2) Adjacent nonzero bits have the same sign. In other words,  <span class="math">e_{i,j+1}e_{i,j}=0</span>  or 1.</li>
    </ul>

    <p class="text-gray-300">(<strong>JSF-3</strong>) If
<span class="math">$e_{i,j+1}e_{i,j} \\neq 0</span>$
then  <span class="math">e_{3-i,j+1} \\neq 0</span>  and  <span class="math">e_{3-i,j} = 0</span> .</p>

    <p class="text-gray-300">Solinas provides proofs for existence and uniqueness of the JSF, as well as an algorithm for determining it. His algorithm generates the JSF right-to-left. Analysing it Solinas considers three states which he simply calls A, B and C. In state C this algorithm outputs a zero column. In states A or B it outputs nonzero columns. The transition probabilities between these states are explicitly given: we return to this later.</p>

    <p class="text-gray-300">Property (JSF-1) suggests that the representation is particularly suitable for an implementation of Algorithm 2.2 with a window width w=2. As already announced we restrict ourselves to this case in the sequel. Further, this choice also simplifies the complexity analysis, by the following observation: Algorithm 2.2 scans a joint representation left-to-right in order to form windows, but consecutive nonzero columns always belong to one window regardless of the direction in which we are scanning the joint representation. This is easy to see, as by property (JSF-1) there can be at most two consecutive nonzero columns, which must be preceded and followed by zero columns or by the boundaries of the representation.</p>

    <p class="text-gray-300">Therefore to estimate the number of nonzero windows (which corresponds to the number of multiplications performed by Algorithm 2.2 plus one) we scan our input right-to-left. In Solinas' algorithm State A is always followed by State B, State B by State C, and there are the following transition probabilities:  <span class="math">\\mathcal{P}(C \\mapsto A) = 1/4</span> ,  <span class="math">\\mathcal{P}(C \\mapsto B) = 1/2</span>  and  <span class="math">\\mathcal{P}(C \\mapsto C) = 1/4</span> . We thus consider a Markov chain with <em>three</em> states, which correspond to those in Solinas' algorithm, as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">S_0^*</span> . A nonzero column is output by State A of Solinas' algorithm: this column will be the second column in a &quot;square&quot; window when read left-to-right, as the next state in Solinas' algorithm is always State B.</li>
      <li><span class="math">S_1^*</span> . A nonzero column is output by State B of Solinas' algorithm: this column will be the first column in a window when read left-to-right, whereas the second column is non-zero if we are coming from state A or zero if we come from State C.</li>
    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_2^*</span> . A zero column is output by State C of Solinas' algorithm.</p>

    <p class="text-gray-300">The number of times we enter in  <span class="math">S_1^*</span>  corresponds to the number of windows formed and thus to the number of multiplications performed by our algorithm. The transition probability matrix is</p>

    <p class="text-gray-300"><span class="math">$T = (\\mathcal{P}(\\mathcal{S}_i^* \\mapsto \\mathcal{S}_j^*))_{i,j=0}^2 = \\begin{pmatrix} 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ 1/4 &amp; 1/2 &amp; 1/4 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">which yields limiting probabilities  <span class="math">\\pi_0 = \\frac{1}{8}</span> ,  <span class="math">\\pi_1 = \\frac{3}{8}</span>  and  <span class="math">\\pi_2 = \\frac{1}{2}</span> . Hence the expected number of multiplications performed by Algorithm 2.2 is  <span class="math">\\frac{3}{8}n - 1</span>  with n-bit inputs.</p>

    <p class="text-gray-300">According to the defining properties of the JSF, the admissible nonzero colums  <span class="math">\\begin{pmatrix} e_{1,j} \\\\ e_{2,j} \\end{pmatrix}</span>  and windows  <span class="math">\\begin{pmatrix} e_{1,j} &amp; e_{1,j-1} \\\\ e_{2,j} &amp; e_{2,j-1} \\end{pmatrix}</span>  with both columns non zero that, up to sign, can be found are</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\ \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\ \\begin{bmatrix} 1 \\\\ \\pm 1 \\end{bmatrix}, \\ \\begin{bmatrix} 0 &amp; 1 \\\\ \\pm 1 &amp; 0 \\end{bmatrix}, \\ \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; \\pm 1 \\end{bmatrix}, \\ \\begin{bmatrix} 1 &amp; 0 \\\\ \\epsilon &amp; \\epsilon \\end{bmatrix} \\text{ with } \\epsilon = \\pm 1, \\text{ and } \\begin{bmatrix} 1 &amp; 1 \\\\ \\pm 1 &amp; 0 \\end{bmatrix},</span>$</p>

    <p class="text-gray-300">thus proving the statements about  <span class="math">\\mathcal{E}</span> .</p>

    <h2 id="sec-8" class="text-2xl font-bold">4 Comparisons</h2>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">4.1 Algorithm 2.2: Optimal parameters for d = 2 and 3</h4>

    <p class="text-gray-300">First of all, it is important to know for which values of the parameter w the algorithms run fastest, given the bit length n of the inputs and the number d of the exponents. For simplicity we ignore the number of squarings performed in the main loop and we consider it only for d=2 and 3.</p>

    <p class="text-gray-300">Suppose first d=2: Table 2 contains the cardinality of  <span class="math">\\mathcal{E}</span>  and the sum of the number of operations needed to build it with the expected number of multiplications in the main loop of the algorithm. This performance parameter (similar to that used for instance in [23]) is a natural way of comparing exponentiation algorithms. In fact, it is easy to adapt these values to the relative costs of squarings by adding  <span class="math">c_s n</span> , where  <span class="math">c_s</span>  is the cost of a squaring relative to that of a multiplication. In the column for the JSF there is of course no entry for w=3.</p>

    <p class="text-gray-300">Table 3 collects the analogous data for d=3: Note that the JSF, being defined only for d=2, is not represented.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\overline{w}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">l .</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Unsigned&lt;br&gt;&lt;sup&gt;4&lt;/sup&gt; € and # Ops</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">=</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{aligned} NAF \\\\ \\#\\mathcal{E} \\ and \\ \\# \\ Ops \\end{aligned}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">JSF&lt;br&gt;#E and # Ops</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{3}{4}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 + \\frac{5}{9}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 + \\frac{1}{2}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">9 + \\frac{3}{7}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">5 + \\frac{11}{27}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">9 + \\frac{3}{8}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45 + \\frac{3}{10}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45 + \\frac{32}{117}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Cardinality of  <span class="math">\\mathcal{E}</span>  and number of operations for d=2</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Comparisons 13</li>
    </ol>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\overline{w}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Jnsigned&lt;br&gt;€ E and # Ops</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{aligned} NAF \\\\ \\#\\mathcal{E} \\ and \\ \\# \\ Ops \\end{aligned}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3 + \\frac{7}{8}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">9 + \\frac{19}{27}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">52 + \\frac{7}{15}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45 + \\frac{131}{297}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">448</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">444 + \\frac{7}{22}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">603</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">599 + \\frac{1082}{3645}n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: Cardinality of  <span class="math">\\mathcal{E}</span>  and number of operations for d=3</p>

    <p class="text-gray-300"><strong>Remark 4.1</strong> Assume d=2 and consider Table 2. Using the unsigned binary representation, the optimal choice of w is w=1 for  <span class="math">n \\leq 28</span> , and w=2 for  <span class="math">28 \\leq n \\leq 280</span> . In particular the parameter w=2 is optimal for the exponents sizes which interests us.</p>

    <p class="text-gray-300">With the NAF the thresholds are n=27 and  <span class="math">n=\\frac{14040}{47}=298.72</span>  respectively.</p>

    <p class="text-gray-300">With the JSF the parameter w=1 is optimal for  <span class="math">n \\le 64</span> . Furthermore, using the JSF with w=2 is better than using the NAF with either w=2 or 3 when  <span class="math">124 &lt; n \\le 354</span> : in the range which concerns us most however using the NAF can be marginally slower but requires fewer precomputations.</p>

    <p class="text-gray-300"><strong>Remark 4.2</strong> In the case d=3 (see Table 3) the thresholds are higher, as intuition suggests. Using the unsigned binary representation, the optimal choice of w is w=1 for  <span class="math">n\\leq 120</span> , and w=2 for  <span class="math">121\\leq n\\leq 2640</span> . In the NAF case, w=1 is optimal for  <span class="math">n\\leq 137</span>  and w=2 for  <span class="math">138\\leq n\\leq 3841</span> .</p>

    <p class="text-gray-300">If w = 1, the NAF leads to better performance as long as n &gt; 35, if w = 2 the NAF will always yield a better algorithm. However, if w = 3, the much larger constant term in the complexity when using the NAF has a price: for n &lt; 7264 it is better to use the unsigned binary representation.</p>

    <p class="text-gray-300"><strong>Remark 4.3</strong> As already mentioned, the algorithms of Reitwiesner and Solinas recode the exponents right-to-left, so extra storage must be reserved for the recoded representations. There exists an alternative to the NAF with the same Hamming weight and which can be computed from left to right [17] by a simple algorithm. However this representation dispenses with the non-adjacency property, which has a very negative impact on memory usage. For instance for w = d = 2 the set of precomputations  <span class="math">\\mathcal{E}</span>  consists of the values  <span class="math">g_1^a g_2^b</span>  with either  <span class="math">0 &lt; a \\leq 3</span>  and  <span class="math">-3 \\leq b \\leq 3</span> , at least one of a, b odd or a = 0 and b = 1 or a = 0 or a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 or a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0 and a = 0</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">4.2 Interleaved exponentiation and exponent representations</h4>

    <p class="text-gray-300">A multi-exponentiation algorithm called <em>interleaved exponentiation</em> has been described by Möller [23]. It is better understood in terms of exponent recording, and it is nothing but Algorithm 2.1 applied to a different representation of the exponents. Suppose that the exponents  <span class="math">e_1, \\ldots, e_d</span>  are written as</p>

    <p class="text-gray-300"><span class="math">$e_i = \\sum_{j=0}^{n-1} e_{i,j} \\, 2^j \\tag{6}</span>$</p>

    <p class="text-gray-300">where the coefficients  <span class="math">e_{i,j}</span>  are allowed to vary in a set larger than  <span class="math">\\{0,\\pm 1\\}</span> . Then the following generalization of the left-to-right exponentiation algorithm computes  <span class="math">x:=\\prod_{i=1}^d g_i^{e_i}</span> .</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Algorithm 4.4 Left-to-right interleaved multi-exponentiation</h4>

    <p class="text-gray-300">INPUT: Group elements  <span class="math">g_1, \\ldots, g_d</span>  of which some powers have been precomputed and exponents  <span class="math">e_i = \\sum_{j=0}^{n-1} e_{i,j} 2^j</span> Output:  <span class="math">\\prod_{i=1}^d g_i^{e_i}</span></p>

    <p class="text-gray-300">Step 1.  <span class="math">x \\leftarrow 1 \\in G</span></p>

    <p class="text-gray-300"><strong>Step 2.</strong> for  <span class="math">j = n - 1 \\dots 0</span>  do { (a)  <span class="math">x \\leftarrow x^2</span></p>

    <p class="text-gray-300">[Skip at first iteration]</p>

    <p class="text-gray-300"><strong>for</strong>  <span class="math">i = 1 \\dots d</span>  <strong>do</strong> {</p>

    <p class="text-gray-300">if  <span class="math">e_{i,j} \\neq 0</span>  then  <span class="math">x \\leftarrow x \\cdot g_i^{e_{i,j}}</span>  }</p>

    <p class="text-gray-300">Step 3. return x</p>

    <p class="text-gray-300">This algorithm becomes efficient if a careful choice of the recoding of the exponents is done. balancing a low density of the representations with the work done in the precomputation stage: this should allow Step 2 (b) to be done always with a table access and a single multiplication (or multiplication with the inverse). We see now four candidates for the representations.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">4.2.1 Radix-r representation</h4>

    <p class="text-gray-300">A first possibility is offered by radix-r recoding where  <span class="math">r=2^w</span>  is a power of 2. We embed this representation into a redundant base 2: If  <span class="math">e = \\sum_{i=0}^{n-1} b_i 2^i</span>  we put</p>

    <p class="text-gray-300"><span class="math">$b_k&#x27; = \\begin{cases} \\sum_{\\ell=0}^{w-1} b_{wk+\\ell} 2^{\\ell} &amp; \\text{if } k \\equiv 0 \\text{ (mod } w) \\\\ 0 &amp; \\text{otherwise,} \\end{cases}</span>$</p>

    <p class="text-gray-300">for  <span class="math">0 \\le k \\le n-1</span>  and assuming  <span class="math">b_i = 0</span>  for  <span class="math">i \\ge n</span> , then consider  <span class="math">e = \\sum_{k=0}^{\\lceil n/w \\rceil - 1} b&#x27;_{kw} 2^{kw} = \\sum_{i=0}^{n-1} b&#x27;_i 2^i</span> . The last representation is that which is actually used to represent the exponents in Algorithm 4.4. This is very easy to implement, for exponents are scanned online w bits at a time and all blocks of multiplications are done only every w squarings. The density of a radix-r representation is  <span class="math">\\frac{r-1}{r}</span>  and so Algorithm 4.4 requires about  <span class="math">\\frac{dn}{w} \\frac{2^w - 1}{2^w}</span>  multiplications and n squarings.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">The generalized non-adjacent form 4.2.2</h4>

    <p class="text-gray-300">A better alternative, assuming free inversion, can be the generalized non-adjacent form, or GNAF, which is a <em>signed</em> radix-r recoding. A radix-r GNAF of the integer e is a representation  <span class="math">e = \\sum_{i=0}^{n-1} b_i r^i</span> with  <span class="math">-r &lt; b_i &lt; r</span>  and satisfying the following two properties</p>

    <p class="text-gray-300"><strong>(GNAF-1)</strong>
<span class="math">$|b_i + b_{i+1}| &lt; r</span>$
for all <em>i</em>.</p>

    <p class="text-gray-300"><strong>(GNAF-2)</strong> If
<span class="math">$b_i b_{i+1} &lt; 0</span>$
then  <span class="math">|b_i| &lt; |b_{i+1}|</span> .</p>

    <p class="text-gray-300">This form coincides with the definition of the NAF when r=2. Moreover, as for the NAF, it can be proven that this form is unique and has minimal Hamming weight among signed radix-r representations [7]. Here we consider only the case that r is a power of 2 and we embed the representation into a redundant base 2 one as in the previous paragraph.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Comparisons 15</li>
    </ol>

    <p class="text-gray-300">Using the GNAF the density of the nonzero digits decreases from  <span class="math">\\frac{r-1}{r}</span>  of the radix-r representation to  <span class="math">\\frac{r-1}{r+1}</span> , hence it leads to a multi-exponentiation algorithm requiring  <span class="math">\\frac{dn}{w}\\frac{\\overline{r}^w-1}{2^w+1}</span>  multiplications and about n squarings to compute the product of d powers with n-bit exponents.</p>

    <p class="text-gray-300">The GNAF is recoded right-to-left, and thus cannot be used online.</p>

    <p class="text-gray-300">There exists a left-to-right recoding with the same weight as the GNAF [18].</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">4.2.3 Width-w left-to-right sliding windows</h4>

    <p class="text-gray-300">One can let a sliding window of size w scan right-to-left the binary representation of an integer, skipping zeros and reading the value contained in the window only if a bit equal to 1 is found. This gives a recoding  <span class="math">e = \\sum_{j=0}^{n-1} b_j 2^j</span>  where the coefficients  <span class="math">b_j</span>  are either zero or odd, satisfy  <span class="math">0 \\le b_j &lt; 2^w</span>  and of any w consecutive of them at most one is nonzero. It is very well known that this representation has density 1/(w+1).</p>

    <p class="text-gray-300">We want however a left-to-right sliding window algorithm. In the most naïve way it produces a recoding where the coefficients  <span class="math">b_j</span>  are either zero or and satisfy  <span class="math">2^{w-1} \\le b_j &lt; 2^w</span> , except perhaps for the least significant nonzero coefficient. Clearly this representation has the same expected density 1/(w+1). If however we do not include always w bits in the window but only as many bit as possible as long as they are at most w and not only the most significant one but also the least significant one is 1, we get a recoding where the  <span class="math">b_j</span>  are zero or odd and satisfy  <span class="math">0 \\le b_j &lt; 2^w</span>  and with the same weight as before. Note that two nonzero coefficients need no longer to be separated by at least w-1 zero coefficients. We call this recoding the width w sliding window recoding, or wSWR for short. It can be used online but some care is required in the implementation.</p>

    <p class="text-gray-300">The wSWR is better than radix- <span class="math">2^w</span>  as long as w &gt; 1 (and equal if w = 1) and also better than the GNAF if  <span class="math">w \\ge 3</span> . Moreover only about a half of the elements need to be precomputed compared to those needed for the radix- <span class="math">2^w</span>  and GNAF for the same w.</p>

    <p class="text-gray-300">The result is that the wSWR is preferable over using the radix- <span class="math">2^w</span>  form or the GNAF for the optimal value of w for a given exponent size (which is either 4 or 5 for  <span class="math">160 \\le n \\le 256</span> ).</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">4.2.4 The flexible window exponentiation algorithm and the wNAF</h4>

    <p class="text-gray-300">Cohen's <em>flexible window</em> exponentiation algorithm [10, 9] which was also proposed independently by Solinas [28, 29] consists in the application of Algorithm 4.4 with d=1 to the wNAF of the exponent. The wNAF of the integer e is a representation  <span class="math">e = \\sum_{j=0}^{n-1} b_j 2^j</span>  where the integer coefficients  <span class="math">b_j</span>  satisfy the following two conditions:</p>

    <p class="text-gray-300">(wNAF-1) Either  <span class="math">b_i = 0</span>  or  <span class="math">b_i</span>  is odd and  <span class="math">|b_i| \\leq 2^w</span> .</p>

    <p class="text-gray-300">(wNAF-2) Of any w+1 consecutive coefficients  <span class="math">b_{j+w},\\ldots,b_j</span>  at most one is nonzero.</p>

    <p class="text-gray-300">It is also called width-(w+1) NAF and it must not be confused with the GNAF. The special case w=1 is the usual NAF. Every integer admits a wNAF which is uniquely determined. In the cited papers by Solinas and by Cohen et al. there are algorithms for computing it. The density of the representation is 1/(w+2). This immediately leads to an exponentiation algorithm requiring about n/(w+2) multiplications for an n-bit exponent. The wNAF recoding algorithm works right-to-left, therefore it cannot be used online.</p>

    <p class="text-gray-300"><strong>Remark 4.5</strong> In general the recoding of choice for Algorithm 4.4 is the wSWR if inversion is expensive, and the wNAF otherwise, because of their better densities and smaller precomputation tables</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">l=2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d=3</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 2.2 (base-2) #$\\mathcal{E}$ and # Ops (w)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 4.4 <span class="math">(wSWR)</span>&lt;br&gt;# <span class="math">\\mathcal{E}</span> and # Ops (w)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 2.2 (base-2) # <span class="math">\\varepsilon</span> and # Ops (w)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 4.4 <span class="math">(wSWR)</span>&lt;br&gt;# <span class="math">\\mathcal{E}</span> and # Ops (w)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2) 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36.43 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42.43 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">71</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50.14 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 (w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">87</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63.86 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20 (w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">111.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">107</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">77.57 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">79</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">126.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">131</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">91.28 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">91.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30 (w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">141.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">138.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0  (w=4)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">240</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">111.86 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2) 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">111</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">164</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">167</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=4)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">118.71 (w=2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">117.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 (w=4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">176.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 (w=4)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Complexity of multi-exponentiation using unsigned representations</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm 2.2&lt;br&gt;(NAF)&lt;br&gt;#E and # Ops (w)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm 2.2 (JSF) #$\\mathcal{E}$ and # Ops (w)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm 4.4 (wNAF) #$\\mathcal{E}$ and # Ops (w)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27.81 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29.40 (w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.07  (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32.60  (w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37.59  (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39 (w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44.11 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.40  (w=3)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57.15 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57.66 (w=4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">70.19  (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">69</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68.33  (w=4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83.22 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">79 (w=4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">240</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">102.78  (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">99</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">95 (w=4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">109.30  (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100.33  (w=4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5: Complexity of multi-exponentiation using signed representations, d=2</p>

    <p class="text-gray-300">with respect to the simpler radix-r form and GNAF. The wSWR can be a good backup choice for Algorithm 4.4 even if inversion is free if memory usage is critical. For the corresponding penalty hit see the tables in the next subsection.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">4.3 Comparing the two algorithms</h4>

    <p class="text-gray-300">If inversion in the group is not for free, we recode online the exponents as wSWR's in Algorithm 4.4. One requires then d squarings and  <span class="math">d(2^{w-1}-1)</span>  multiplications in the precomputation stage and  <span class="math">\\frac{dn}{w+1}-1</span>  multiplications and about n-1 squarings in the main loop (note that the first multiplication is just a variable assignment). In Table 4 we add the total number of operations in the precomputation stage to the number of multiplications in the main loop of the algorithms. (This is the same performance parameter used before.) In each case the value of w which minimizes the running time is chosen.</p>

    <p class="text-gray-300">If inversion in the group is cheap, we write the exponents as wNAF's. Algorithm 4.4 needs d squarings and  <span class="math">d(2^{w-1}-1)</span>  multiplications for the precomputations and  <span class="math">\\frac{dn}{w+2}-1</span>  multiplications and about n squarings in the main loop. Tables 5 and 6 collect the complexity data for these algorithms which exploit signed representations in the cases d=2 and d=3 respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>APPLICATIONS 17</li>
    </ol>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm 2.2&lt;br&gt;(NAF)&lt;br&gt;#E and # Ops (w)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm 4.4&lt;br&gt;(wNAF)&lt;br&gt;#E and # Ops (w)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48.40 (w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44.60 (w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54.03 (w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49.40 (w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65.29 (w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76.55 (w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68.60 (w=3)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">99.07 (w=1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">87</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=4)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115.57 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">103</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=4)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">129.69 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">119</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=4)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">240</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">150.86 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">143</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=4)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">157.91 (w=2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">151</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w=4)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6: Complexity of multi-exponentiation using signed representations, d = 3</p>

    <p class="text-gray-300"><strong>Remarks 4.6</strong> (1) <em>Only implementation can decide which of the algorithms is fastest for a particular purpose if the number of operations is similar. In these cases memory usage can be the decisive factor. In the case of double exponentiations with unsigned representations Algorithm 2.2 seems the best choice, either yielding better performance than Algorithm 4.4 or yielding similar performance while requiring less memory.</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(2) <em>Algorithm 2.2 with the NAF or with the JSF seems be preferable to Algorithm 4.4 for double exponentiations with exponents from</em> 160 <em>to</em> 256 <em>bits in memory constrained environments. In particular the use of the NAF reduces considerably the number of required precomputations, saving RAM and, in the case of one fixed base, also ROM. The use of the NAF is undisputably preferable also for smaller bit sizes, i.e.</em> 80 <em>to</em> 128 <em>bits, and this gives the method of choice for implementing single exponentiations in groups with an automorphism of degree</em> 2<em>, such as trace zero varieties or XTR subgroups as described in Section 5.</em></li>
      <li>(3) <em>For triple exponentiations Algorithm 4.4 seems always preferable with unsigned representations (using the</em> w<em>SWR) and</em> n ≥ 128 <em>or with signed representations (using the</em> w<em>NAF).</em></li>
    </ul>

    <p class="text-gray-300">In this section we show a few applications of the above multi-exponentiation algorithms.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8"><strong>5.1 Elliptic and hyperelliptic curves</strong></h3>

    <p class="text-gray-300"><em>Here, as well as in the next subsection, we shall use additive terminology (and shall speak, for example, of a scalar product</em> r · P <em>instead of an exponentiation</em> P r <em>).</em></p>

    <p class="text-gray-300">The natural application of Algorithm 2.2 is to electronic signature schemes based on the discrete logarithm problem in the rational point group of an elliptic curve (ecc) or of the Jacobian variety of an hyperelliptic curve (hec) over a finite field. Hence d = 2 and for the current applications (where exponent sizes are between 160 and 256 bits) we have already seen that the optimal value of the parameter is w = 2.</p>

    <p class="text-gray-300">In the ecc case we observe that mixed coordinate systems can be used exactly as in [11], as we have sequences of repeated doublings (always at least two of them) alternated with single additions of points from a precomputed table. We compute directly the double scalar product, whereas Cohen et al. compute the two scalar products separately and then they add the results: For the fixed base scalar</p>

    <p class="text-gray-300">multiplication they use essentially a comb method and for the variable base scalar product the flexible window algorithm (see  <span class="math">\\S 4.2.4</span> ). For brevity we call the resulting method the CMO method.</p>

    <p class="text-gray-300">We work out the costs in the case of an elliptic curve defined over a prime field of about  <span class="math">2^n</span>  elements, where n = 160 and 240. We shall denote by M, S and I the timings of a multiplication, of a squaring and of an inversion respectively in the base field of our curve.</p>

    <p class="text-gray-300">In [11] five coordinate systems for elliptic curves are described, namely affine (A) projective (P), jacobian  <span class="math">(\\mathcal{J})</span> , Chudnovsky jacobian  <span class="math">(\\mathcal{J}^c)</span>  and modified jacobian  <span class="math">(\\mathcal{J}^m)</span>  coordinates. Adding points in coordinate systems  <span class="math">\\mathcal{C}_1</span>  and  <span class="math">\\mathcal{C}_2</span>  yielding a result in system  <span class="math">\\mathcal{C}_3</span>  is denoted by  <span class="math">\\mathcal{C}_1 + \\mathcal{C}_2 = \\mathcal{C}_3</span> , doubling is notated as  <span class="math">2\\mathcal{C}_1 = \\mathcal{C}_2</span> . If the coordinate systems are the same one writes simply  <span class="math">\\mathcal{C}_1 + \\mathcal{C}_1</span>  and  <span class="math">2\\mathcal{C}_1</span> . Timings are denoted by  <span class="math">t(\\cdots)</span> . The gist is that all these operations have different costs (explicitly given in the cited paper), so a different system can be selected for each operation. Three coordinate systems are employed: the first system  <span class="math">(\\mathcal{C}_1)</span>  is used for all the doublings but the final one before an addition with a precomputed point, the second one  <span class="math">(\\mathcal{C}_2)</span>  for the result of a final doubling, and the third one  <span class="math">(\\mathcal{C}_3)</span>  for the precomputed points. Therefore, if Algorithm 2.2 requires  <span class="math">N_+</span>  additions and  <span class="math">N_2</span>  doublings, its total cost is</p>

    <p class="text-gray-300"><span class="math">$(N_2 - N_+)t(2C_1) + N_+(t(2C_1 = C_2) + t(C_2 + C_3 = C_1)) + t_p</span>$</p>

    <p class="text-gray-300">where  <span class="math">t_p</span>  is the cost of the precomputations. Since doublings in  <span class="math">C_1</span>  are the most frequent operation,  <span class="math">C_1</span>  should be the system with fastest doubling, i.e.  <span class="math">C_1 = \\mathcal{J}^m</span>  with cost  <span class="math">t(2\\mathcal{J}^m) = 4M + 4S</span> . The result of a final doubling is done in  <span class="math">C_2 = \\mathcal{J}</span> , and  <span class="math">t(2\\mathcal{J}^m = \\mathcal{J}) = 3M + 4S</span> .</p>

    <p class="text-gray-300">Now we consider two possible choices for C: A and  <span class="math">\\mathcal{J}^c</span> .</p>

    <p class="text-gray-300">If  <span class="math">C_3 = A</span> , all additions with a precomputed point are as fast as possible:  <span class="math">t(\\mathcal{J} + A = \\mathcal{J}^m) = 9M + 5S</span> . The total running-time is</p>

    <p class="text-gray-300"><span class="math">$N_2(4M+4S) + N_+(8M+5S) + t_n(\\mathcal{A}).</span>$</p>

    <p class="text-gray-300">We proceed to estimate  <span class="math">t_p = t_p(\\mathcal{A})</span> . Since  <span class="math">g_1</span>  is the fixed point of the system, we assume that it is given in  <span class="math">\\mathcal{A}</span> , whereas  <span class="math">g_2</span> , belonging to the signature to be verified, is in  <span class="math">\\mathcal{P}</span> . In the NAF (resp. JSF) case we have 4 (resp. 6) additions of type  <span class="math">\\mathcal{A} + \\mathcal{J} = \\mathcal{P}</span> , and 2 (resp. 4) of type  <span class="math">\\mathcal{P} + \\mathcal{P}</span> . Then we convert the results to affine coordinates, which can be done naïvely by inverting 7 (resp. 11) field elements and performing 14 (resp. 22) multiplications. Using Montgomery's trick, one can invert m numbers by one inversion and 3(m-1) multiplications. So in the NAF case the total precomputation cost is  <span class="math">t_p(\\mathcal{A}, \\mathrm{NAF}) = 4t(\\mathcal{A} + \\mathcal{P} = \\mathcal{P}) + 2t(\\mathcal{P} + \\mathcal{P}) + (14 + 3 \\cdot 6) M + I = 4(8M + 2S) + 2(12M + 2S) + 32M + I = 88M + 12S + I</span>  whereas in the JSF case it is  <span class="math">t_p(\\mathcal{A}, \\mathrm{JSF}) = 148M + 20S + I</span> . If  <span class="math">\\mathcal{C}_3 = \\mathcal{J}^c</span> , we have  <span class="math">t(\\mathcal{J} + \\mathcal{J}^c = \\mathcal{J}^m) = 12M + 5S</span>  and the total running-time is</p>

    <p class="text-gray-300"><span class="math">$N_2(4M+4S) + N_+(11M+5S) + t_n(\\mathcal{J}^c).</span>$</p>

    <p class="text-gray-300">To estimate  <span class="math">t_p(\\mathcal{J}^c)</span>  we first have to convert  <span class="math">g_2</span>  from  <span class="math">\\mathcal{P}</span>  to  <span class="math">\\mathcal{J}^c</span> , requiring 1M+1S. Then in the NAF (resp. JSF) case we have 4 (resp. 6) additions of type  <span class="math">\\mathcal{A}+\\mathcal{J}^c=\\mathcal{J}^c</span> , and 2 (resp. 4) of type  <span class="math">\\mathcal{J}^c+\\mathcal{J}^c</span> . The total precomputation costs are  <span class="math">t_p(\\mathcal{J}^c, \\mathrm{NAF}) = (1M+1S)+4(8M+3S)+2(11M+3S)=55M+19S</span>  and  <span class="math">t_p(\\mathcal{J}^c, \\mathrm{JSF}) = (1M+1S)+6(8M+3S)+4(11M+3S)=93M+31S</span> .</p>

    <p class="text-gray-300">Algorithm 2.2 with the NAF has  <span class="math">N_2=n-\\frac{10}{9}</span>  and  <span class="math">N_+=\\frac{11}{27}n-1</span>  (cfr. Theorem 3.6). With the JSF  <span class="math">N_2=n-\\frac{3}{2}</span>  and  <span class="math">N_+=\\frac{3}{8}n-1</span> .</p>

    <p class="text-gray-300">In what follows we shall assume  <span class="math">S \\approx 0.8M</span> , which is confirmed by experience.</p>

    <p class="text-gray-300">The scalar multiplication of the variable point in the CMO method for n=160 and n=240 has costs 1488.4M+4I and 2228+4I if the coordinates  <span class="math">(\\mathcal{J}^m,\\mathcal{J},\\mathcal{A})</span>  are used, and 1610.2M and 2400M</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Applications 19</li>
    </ol>

    <p class="text-gray-300">respectively with the coordinates  <span class="math">(\\mathcal{J}^m, \\mathcal{J}, \\mathcal{J}^c)</span> . The cost of the scalar multiplication of the fixed point is 454.4M and 620.8M in the cases n=160 and 240 respectively. We have computed these values by adapting their comb algorithm also to n=240 (in which case it requires a precomputed table of 93 elements), assuming that the precomputed table is in  <span class="math">\\mathcal{A}</span> , and computing the results in  <span class="math">\\mathcal{J}</span> . For n=160 there are 15 doublings  <span class="math">(2\\mathcal{J})</span>  and 31 additions  <span class="math">(\\mathcal{J}+\\mathcal{A}=\\mathcal{J})</span> . If n=240 the doublings remain 15 and the additions increase to 47. Note that our cost for n=160 is better than the value (474) stated in [10]. A further addition in jacobian coordinates yielding a projective result is needed, with cost  <span class="math">12M+2S\\approx 13.6M</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Upon</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">nutting</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">a11</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">nieces</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">together</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">we get th</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">e results</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">of Table 7.</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Opon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">putting</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">un</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">proces</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">together,</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">we get in</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">C 1 CSults</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">or radic /.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\overline{n}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Coordinate systems</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm 2.2&lt;br&gt;(NAF)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm 2.2&lt;br&gt;(JSF)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">CMO method</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(\\mathcal{J}^m,\\mathcal{J},\\mathcal{A}) \\ (\\mathcal{J}^m,\\mathcal{J},\\mathcal{J}^c)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{ c c c c c c c c c c c c c c c c c c c$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2013.2M + I <span class="math">2144M</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$   \\begin{array}{r}     1956.4M + 4I \\     2078.2M   \\end{array} $</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">240</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(\\mathcal{J}^m,\\mathcal{J},\\mathcal{A}) \\ (\\mathcal{J}^m,\\mathcal{J},\\mathcal{J}^c)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{array}{c} 2978.93M + I \\\\ 3256.86M \\end{array}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2949.2 + IM&lt;br&gt;3170M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{2862.4M + 4I}{3034.4M}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 7: Comparison of double scalar multiplication methods on ecc</p>

    <p class="text-gray-300">Whereas on modern CPUs  <span class="math">I \\approx 20M</span>  for n=160 and  <span class="math">I \\approx 40M</span>  for n=240, on smart card architectures these values are much worse, even 50 for n=160 and 100 for n=240, or higher. One sees at once that the different methods have comparable performance. One advantage of our method is that it does not require a table of 62 to 93 fixed precomputed points to be stored in ROM, as in the CMO method, where the cost of computing those points has not been taken into account. The size of such tables varies from 2480 bytes for n=160 to 5580 bytes for n=240. In the CMO method the fixed base scalar multiplication needs to be reengineered for each exponent range for best performance. This is not necessary with our method. The conclusion is that our method can be used much more efficiently in systems which do not assume a fixed point (this is optimal if fast system configuration is an issue).</p>

    <p class="text-gray-300">We note that mixed coordinate systems also exist for hyperelliptic curves of genus 2 [22].</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8"><strong>5.2</strong> Trace zero varieties</h3>

    <p class="text-gray-300">Trace zero varieties are abelian varieties constructed essentially by Weil Descent from other varieties, such as elliptic curves [25, 14] or Jacobians of hyperelliptic curves [20, 21].</p>

    <p class="text-gray-300">Construction and security parameters. We start with an elliptic curve (resp. hyperelliptic curve of genus g) defined over a prime field  <span class="math">\\mathbb{F}_p</span>  where  <span class="math">p^2</span>  (resp.  <span class="math">p^{2g}</span> ) has the order of magnitude of the desired group size. We also assume that the characteristic polynomial of the Frobenius endomorphism is known. Next, we consider the group of rational points of the elliptic curve (resp. ideal class group) over the finite field extension  <span class="math">\\mathbb{F}_{p^3}</span>  and consider the elements defined by the property that its elements D are of trace zero, i.e. they satisfy  <span class="math">(\\sigma^2 + \\sigma + 1)(D) = 0</span> . In general for a genus g curve considered over  <span class="math">\\mathbb{F}_{p^d}</span>  the elements of trace zero form a subgroup as they are the kernel of a homomorphism. Therefore they form an abelian subvariety of dimension g(d-1), which is called the <em>trace zero variety</em>. We shall denote it by G in the sequel and call  <span class="math">G_0</span>  the subgroup of large prime order  <span class="math">\\ell</span>  in which we actually implement the cryptographic primitives. As usual we want to choose it so that it has a cofactor in G as small as possible, i.e.  <span class="math">\\ell \\approx p^{2g}</span> .</p>

    <p class="text-gray-300">It has been noted that for g(d−1) ≤ 4 the best attacks known to work on trace zero varieties have complexity O( √ G0) [25, 21].</p>

    <p class="text-gray-300"><em>In what follows we consider only the case where</em> d = 3 <em>for simplicity.</em></p>

    <p class="text-gray-300">As we require the same level of security offered by, say, elliptic curves over fields of 160 bits, we have \` ≈ 2 &lt;sup&gt;160&lt;/sup&gt; also for trace zero varieties and the field F&lt;sup&gt;p&lt;/sup&gt; must satisfy p ≈ 2 80/g .</p>

    <p class="text-gray-300"><strong>Performance advantages in cryptographic applications.</strong> The main performance advantages of trace zero varieties come from the fast arithmetic in the extension field (where explicit closed formulae can be given for multiplication and squaring: if furthermore the polynomial defining the extension field is chosen carefully one can even use short convolutions [5, 4]), and by the presence of the automorphism σ of small degree.</p>

    <p class="text-gray-300">The latter fact enables one to speed-up even <em>single</em> exponentiations. Instead of using single scalars to compute r·D for an ideal class D, one considers a pair (r0, r1) of scalars bounded by some quantity which is O(p g ), and computes the double scalar product r&lt;sup&gt;0&lt;/sup&gt; · D + r&lt;sup&gt;1&lt;/sup&gt; · σ(D). For r&lt;sup&gt;0&lt;/sup&gt; and r&lt;sup&gt;1&lt;/sup&gt; suitably bounded (see [25, 21]) all such double scalar products are distinct. Shamir's trick can be used and the result is that the number of doublings needed in cryptographic operations is roughly halved with respect to generic elliptic and hyperelliptic curves. Further savings can be achieved by the use of Algorithms 2.2 and 4.4, depending on the parameters.</p>

    <p class="text-gray-300">All the usual cryptographic protocols can be adapted to this new setting, in particular those for key exchange and electronic signatures.</p>

    <p class="text-gray-300">The Frobenius operates on G, and thus on G0, like the scalar multiple by a constant s with s &lt;sup&gt;2&lt;/sup&gt; + s + 1 ≡ 0 mod <code>. For the verification of signatures, in place of the scalar product r · D + u · E one is temped to write r ≡ r&lt;sup&gt;0&lt;/sup&gt; + r1s and u ≡ u&lt;sup&gt;0&lt;/sup&gt; + u1s mod </code> and to consider the <em>quadruple</em> product r&lt;sup&gt;0&lt;/sup&gt; · D + r&lt;sup&gt;1&lt;/sup&gt; · σ(D) + u&lt;sup&gt;0&lt;/sup&gt; · E + u&lt;sup&gt;1&lt;/sup&gt; · σ(E). The problem is bounding, if possible, the coefficients by kp&lt;sup&gt;g&lt;/sup&gt; where k is a small constant. In the example above we did not have this problem because we started with a pair (r0, r1), however for the verification of digital signatures one needs to start with the given value r. To keep the coefficient reasonably bounded can be cumbersome, but we observe that the results in [27, §2 and §5] actually apply to any automorphism of the group with given degree 2 minimal polynomial. In particular they apply to σ on the trace-zero variety with equation σ &lt;sup&gt;2&lt;/sup&gt; + σ + 1 = 0 and a bound O(p g ) on r&lt;sup&gt;i&lt;/sup&gt; , u&lt;sup&gt;i&lt;/sup&gt; holds.</p>

    <p class="text-gray-300">To perform the quadruple exponentiation we suggest the use of Algorithm 4.4 and the wNAF with d = 4. Since two of the base divisors are images of D and E under σ, and the cost of the Frobenius is on average approximately 1/25-th of the cost of an addition or of a doubling (this value is obtained heuristically by considering the cases g = 1 and 2), we first precompute the necessary multiples of D and E, then we apply σ to the resulting sets. To determine the optimal value of w we have thus to minimize the number of operations, which is</p>

    <p class="text-gray-300"><span class="math">$n+2\\left(1+\\frac{1}{25}\\right)\\left(2^{w-1}-[1=w]\\right)+\\frac{4n}{w+2}-1</span>$</p>

    <p class="text-gray-300">where [expr] evaluates to 1 is expr is true, to 0 otherwise. For n = log&lt;sup&gt;2&lt;/sup&gt; (p g ) ≈ 80 the minimum 148.97 is achieved for w = 4. If w = 3 the amount of operations is 151.32. For a minimal trade-off, one can also store only the multiples of D and E and apply the frobenius on-the-fly when multiples of σ(D) or σ(E) are needed.</p>

    <p class="text-gray-300"><em>Let us consider signature verification using a trace zero variety arising from a genus</em> g <em>curve over a finite field of about</em> 2 &lt;sup&gt;80&lt;/sup&gt;/g <em>elements (so</em> n = 80<em>): It may be done with about</em> 150 <em>group operations. For comparison, using the ECDSA or hyperelliptic curve variants thereof of comparable security requires</em></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Applications 21</li>
    </ol>

    <p class="text-gray-300">a minimum of 229 group operations (see Table 5 with n=160 and d=2). Furthermore, one should note that group operations on the trace zero variety are faster than on a elliptic or hyperelliptic curve of comparable size.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">5.3 XTR</h4>

    <p class="text-gray-300">The XTR cryptosystem was initially proposed by Lenstra and Verheul [32] and makes use of the subgroup G of order  <span class="math">p^2-p+1</span>  of the multiplicative group of the cyclotomic extension  <span class="math">\\mathbb{F}_{p^6}/\\mathbb{F}_p</span> . Let g be an element of  <span class="math">\\mathbb{F}_{p^6}^{\\times}</span>  of order q&gt;6 dividing  <span class="math">p^2-p+1</span> . Since q does not divide  <span class="math">p^s-1</span>  for s=1,2,3 the subgroup generated by g cannot be embedded in the multiplicative group of any proper subfield of  <span class="math">\\mathbb{F}_{p^6}</span> . Hence it appears that solving the discrete logarithm problem in  <span class="math">\\langle g \\rangle</span>  is at least as difficult as solving it in the large field. In the XTR cryptosystem elements from the field  <span class="math">\\mathbb{F}_{p^6}</span>  are replaced by their traces over  <span class="math">\\mathbb{F}_{p^2}</span>  and Lenstra et al. show how one can work only with these – actually with triples of traces – instead of using the original elements from the bigger field. This leads to very efficient arithmetic even though it is definitely not straightforward to port the usual exponentiation algorithms to this new setting. Recently, Lenstra and Stam [31] observed that one can also compute directly in an efficient manner in the field  <span class="math">\\mathbb{F}_{p^6}</span>  by using a suitable representation of the extension. This allows the implementor to use all possible (multi-)exponentiation methods without change.</p>

    <p class="text-gray-300">Independently, Frey suggested a similar idea which we sketch here (the following text is taken, abridged, from [3]). Let  <span class="math">\\sigma</span>  be the Frobenius map  <span class="math">x\\mapsto x^p</span> . One observes at once that for  <span class="math">z\\in G</span>  the Frobenius satisfies  <span class="math">z^{\\sigma^2-\\sigma+1}=1</span>  and that G is the intersection of the two trace zero varieties relative to <em>both</em> intermediate extensions, so that the elements satisfy  <span class="math">\\sigma^3+1=0</span>  and also  <span class="math">\\sigma^4+\\sigma^2+1=0</span> . The first relation immediately gives a simple inversion formula:  <span class="math">z^{-1}=\\sigma^3(z)</span> . The field  <span class="math">\\mathbb{F}_{p^6}</span>  is then constructed as the composite of two extensions of  <span class="math">\\mathbb{F}_p</span> : the first is  <span class="math">\\mathbb{F}_{p^3}</span>  and the second is  <span class="math">\\mathbb{F}_{p^2}=\\mathbb{F}_p(\\sqrt{\\delta})</span>  where  <span class="math">\\delta\\in\\mathbb{F}_p\\setminus(\\mathbb{F}_p)^2</span> . Ideally  <span class="math">|\\delta|</span>  should be small (for instance  <span class="math">\\delta=-1</span> : to allow this one needs  <span class="math">-1\\in\\mathbb{F}_p\\setminus(\\mathbb{F}_p)^2</span>  and therefore  <span class="math">p\\equiv 3 \\mod 4</span> ). Also  <span class="math">\\delta=2</span>  is a good option.</p>

    <p class="text-gray-300"><span class="math">-1 \\in \\mathbb{F}_p \\setminus (\\mathbb{F}_p)^2</span>  and therefore  <span class="math">p \\equiv 3 \\mod 4</span> ). Also  <span class="math">\\delta = 2</span>  is a good option. For  <span class="math">z \\in G</span>  write  <span class="math">z = x + y\\sqrt{\\delta}</span>  where  <span class="math">x, y \\in \\mathbb{F}_{p^3}</span> . The map  <span class="math">\\sigma^3</span>  generates the group  <span class="math">\\operatorname{Gal}(\\mathbb{F}_{p^6}/\\mathbb{F}_{p^3})</span>  of order 2, hence  <span class="math">\\sigma^3(\\sqrt{\\delta}) = -\\sqrt{\\delta}</span>  and  <span class="math">z^{-1} = x - y\\sqrt{\\delta}</span>  is essentially for free.</p>

    <p class="text-gray-300">One can then apply the considerations made about trace zero varieties to XTR subgroups. In particular, single and double exponentiations found in cryptographic protocols can be transformed into double and quadruple exponentiations with exponents of halved bit length.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">References</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] ANSI X9.62, Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA). 1999.</p></li>
      <li><p class="text-gray-300">[2] S. Arno and F.S. Wheeler, <em>Signed digit representations of minimal Hamming weight</em>. IEEE Transactions on Computers <strong>42</strong> (1993), 1007–1010.</p></li>
      <li><p class="text-gray-300">[3] R. Avanzi and T. Lange, Überlegungen zu XTR. Unpublished manuscript.</p></li>
      <li><p class="text-gray-300">[4] R. Avanzi and P. Mihăilescu, Generic efficient arithmetic algorithms for Processor Adequate Finite Fields. A manuscript.</p></li>
      <li><p class="text-gray-300">[5] R.E. Blahut, Fast algorithms for digital signal processing. Addison-Wesley, Reading, MA, 1985.</p></li>
      <li><p class="text-gray-300">[6] A.D. Booth, A signed binary multiplication technique. The Quarterly Journal of Mechanics and Applied Mathematics 4 (1951), 236–240.</p></li>
      <li><p class="text-gray-300">[7] W.E. Clark and J.J. Liang, On arithmetic weight for a general radix representation of integers. IEEE Transactions on Information Theory IT-19 (1973), 823–826.</p></li>
      <li><p class="text-gray-300">[8] B.W. Char, K.O. Geddes, G.H. Gonnet, B.L. Leong, M.B. Monagan and S.M. Watt, Maple V Language Reference Manual. Springer, 1991.</p></li>
      <li><p class="text-gray-300">[9] H. Cohen, <em>Analysis of the flexible window powering algorithm</em>. Preprint. Available from: http://www.math.u-bordeaux.fr/~cohen/</p></li>
      <li><p class="text-gray-300">[10] H. Cohen, A. Miyaji and T. Ono, <em>Efficient elliptic curve exponentiation</em>. In <em>Proceedings ICICS'97</em>, Lecture Notes in Computer Science, vol. 1334, Springer-Verlag, 1997, pp. 282–290.</p></li>
      <li><p class="text-gray-300">[11] H. Cohen, A. Miyaji and T. Ono, <em>Efficient elliptic curve exponentiation using mixed coordinates</em>. In <em>Advances in Cryptology – ASIACRYPT '98 (1998)</em>, K. Ohta and D. Pei, Eds., vol. 1514 of Lecture Notes in Computer Science, pp. 51–65.</p></li>
      <li><p class="text-gray-300">[12] T. ElGamal, <em>A public-key cryptosystem and a signature scheme based on discrete logarithms</em>. IEEE Transactions on Information Theory IT-31 (1985), 469-472.</p></li>
      <li><p class="text-gray-300">[13] O. E ¨ gecio ˇ glu and C¸ . K. Koc¸. ˇ <em>Exponentiation using canonical recoding.</em> Theoretical Computer Science, 129(2):407– 417, 1994.</p></li>
      <li><p class="text-gray-300">[14] G. Frey, <em>Applications of arithmetical geometry to cryptographic constructions.</em> In <em>Finite fields and applications (Augsburg, 1999)</em>, pages 128–161. Springer, Berlin, 2001.</p></li>
      <li><p class="text-gray-300">[15] R.P. Gallant, R.J. Lambert, S.A. Vanstone, <em>Faster Point Multiplication on Elliptic Curves with Efficient Endomorphisms</em> In <em>Advances in Cryptology – CRYPTO 2001 Proceedings</em>, pp. 190–200, Springer Verlag, 2001.</p></li>
      <li><p class="text-gray-300">[16] P. Gaudry, <em>An algorithm for solving the discrete log problem on hyperelliptic curves</em>. In <em>Advances in Cryptology, Eurocrypt '2000</em>, vol. 1807 of Lecture Notes in Computer Science, pp. 19–34. Springer-Verlag, 2000.</p></li>
      <li><p class="text-gray-300">[17] M. Joye and S.-M. Yen, <em>Optimal left-to-right binary signed-digit recoding</em>. IEEE Transactions on Computers <strong>(49) 7</strong>, 740–748 (2000).</p></li>
      <li><p class="text-gray-300">[18] M. Joye and S.-M. Yen, <em>New Minimal Modified Radix-r Representation</em> In <em>Public Key Cryptography 5th International Workshop on Practice and Theory in Public Key Cryptosystems, PKC 2002, Paris, France, February 2002</em>, D. Naccache and P. Paillier Eds., Lecture Notes in Computer Science, vol 2274, pp. 375–384.</p></li>
      <li><p class="text-gray-300">[19] D. E. Knuth, <em>The art of computer programming. Vol. 2, Seminumerical algorithms</em>, third ed., <em>Addison-Wesley Series in Computer Science and Information Processing.</em> Addison-Wesley, Reading, MA, 1997.</p></li>
      <li><p class="text-gray-300">[20] T. Lange, <em>Efficient Arithmetic on Hyperelliptic Curves</em>. Ph.D. Thesis, Universitat Essen, 2001. ¨</p></li>
      <li><p class="text-gray-300">[21] T. Lange, <em>Trace-Zero Subvariety for Cryptosystems</em>. Preprint.</p></li>
      <li><p class="text-gray-300">[22] T. Lange, <em>Weighted Coordinates on Genus 2 Hyperelliptic Curves</em>. Preprint. See: http://eprint.iacr.org/</p></li>
      <li><p class="text-gray-300">[23] B. Moller, ¨ <em>Algorithms for Multi-exponentiation</em> in S. Vaudenay, A.M. Youssef (Eds.): <em>Selected Areas in Cryptography - SAC 2001</em>. Springer-Verlag Lecture Notes in Computer Science vol. 2259, pp. 165-180.</p></li>
      <li><p class="text-gray-300">[24] F. Morain and J. Olivos, <em>Speeding up the computations on an elliptic curve using addition-subtraction chains</em>. RAIRO Inform. Theory <strong>24</strong> (1990), 531–543.</p></li>
      <li><p class="text-gray-300">[25] N. Naumann, <em>Weil-Restriktion abelscher Varietaten ¨</em> . Master's thesis, Universitat Essen, 1999. ¨</p></li>
      <li><p class="text-gray-300">[26] G. W. Reitwiesner. <em>Binary arithmetic.</em> Advances in Computers <strong>1</strong>, 231–308, 1960.</p></li>
      <li><p class="text-gray-300">[27] F. Sica, M. Ciet and J.-J. Quisquater, <em>Analysis of the Gallant-Lambert-Vanstone Method based on Efficient Endomorphisms: Elliptic and Hyperelliptic Curves.</em> In <em>Proceedings of Selected Areas of Cryptography 2002 (SAC 2002), St. John's, Newfoundland (Canada), August 2002.</em> To appear.</p></li>
      <li><p class="text-gray-300">[28] J.A. Solinas, <em>An improved algorithm for arithmetic on a family of elliptic curves.</em> In <em>Advances in Cryptology CRYPTO '97 (1997)</em>, B. S. Kaliski, Jr., Ed., Lecture Notes in Computer Science vol. 1294, pp. 357–371.</p></li>
      <li><p class="text-gray-300">[29] J.A. Solinas, <em>Efficient arithmetic on Koblitz curves</em>. Designs, Codes and Cryptography <strong>19</strong> (2000), 195–249.</p></li>
      <li><p class="text-gray-300">[30] J.A. Solinas, <em>Low-Weight Binary Representations for Pairs of Integers</em>. Centre for Applied Cryptographic Research, University of Waterloo, Combinatorics and Optimization Research Report <strong>CORR 2001-41</strong>, 2001. Available from: http://www.cacr.math.uwaterloo.ca/techreports/2001/corr2001-41.ps</p></li>
      <li><p class="text-gray-300">[31] M. Stam and A.K. Lenstra, <em>Efficient subgroup exponentiation in quadratic and sixth degree extensions</em>. In <em>Proceedings of Workshop on Cryptographic Hardware and Embedded Systems CHES 2002, August 13 - 15, 2002</em>, to be published by Springer–Verlag.</p></li>
      <li><p class="text-gray-300">[32] E.R. Verheul and A.K. Lenstra. <em>The XTR public key system.</em> In <em>Advances in Cryptography Crypto'00</em>, M. Bellare, ed., Lecture Notes in Computer Science vol. 1880, pages 1–19. Springer-Verlag, 2000.</p></li>
      <li><p class="text-gray-300">[33] S.-M. Yen, C.-S. Laih and A.K. Lenstra, <em>Multi-exponentiation</em>. IEE proceedings: computers and digital techniques vol. 141, No. 6, november 1994.</p></li>
    </ul>

`;
---

<BaseLayout title="ON MULTI-EXPONENTIATION IN CRYPTOGRAPHY (2002/154)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/154
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="on-multi-exponentiation-in-cryptography-2002" />
  </article>
</BaseLayout>
