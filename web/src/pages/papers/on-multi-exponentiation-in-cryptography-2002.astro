---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/154';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On multi-exponentiation in cryptography';
const AUTHORS_HTML = 'Roberto M.  Avanzi';

const CONTENT = `    <p class="text-gray-300">ON MULTI-EXPONENTIATION IN CRYPTOGRAPHY</p>

    <p class="text-gray-300">ROBERTO M. AVANZI* (IEM ESSEN) Email: mocenigo@exp-math.uni-essen.de</p>

    <p class="text-gray-300">October 8, 2002. Revised: October 28, 2002.</p>

    <h2 id="sec-1" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">We describe and analyze new combinations of multi-exponentiation algorithms with representations of the exponents. We deal mainly but not exclusively with the case where the inversion of group elements is fast: This is true for example for elliptic curves, groups of rational divisor classes of hyperelliptic curves, trace zero varieties and XTR.</p>

    <p class="text-gray-300">These methods are most attractive with exponents in the range from 80 to 256 bits, and can also be used for computing single exponentiations in groups which admit an automorphism satisfying a monic equation of small degree over the integers.</p>

    <p class="text-gray-300">The choice of suitable exponent representations allows us to match or improve the running time of the best multi-exponentiation techniques in the aforementioned range, while keeping the memory requirements as small as possible. Hence some of the methods presented here are particularly attractive for deployment in memory constrained environments such as smart cards. By construction, such methods provide good resistance against side channel attacks.</p>

    <p class="text-gray-300">We also describe some applications of these algorithms.</p>

    <p class="text-gray-300">Keywords and phrases: Cryptographic protocols, Exponentiation, Integer recoding, Scalar multiplication, Elliptic and Hyperelliptic curves, Trace zero varieties, XTR, Groups with automorphisms, Smart card applications</p>

    <h2 id="sec-2" class="text-2xl font-bold">Contents</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Introduction  2</li>

      <li>The algorithm  3</li>

      <li>Complexity analysis  5</li>

    </ol>

    <p class="text-gray-300">3.1. Unsigned binary inputs  6 3.2. Using the NAF  6 3.3. Using the JSF  10</p>

    <p class="text-gray-300">*The work described in this paper has been supported by the Commission of the European Communities through the IST Programme under Contract IST-2001-32613 (see http://www.arehcc.com). The information in this document is provided as is, and no guarantee or warranty is given or implied that the information is fit for any particular purpose. The user thereof uses the information at its sole risk and liability. The views expressed are those of the author and do not represent an official view or position of the AREHCC project (as a whole).</p>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <p class="text-gray-300">4 Comparisons</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4.1 Algorithm 2.2: Optimal parameters for <span class="math">d</span> = 2 and 3</li>

      <li>4.2 Interleaved exponentiation and exponent representations</li>

      <li>4.2.1 Radix-<span class="math">r</span> representation</li>

      <li>4.2.2 The generalized non-adjacent form</li>

      <li>4.2.3 Width-<span class="math">w</span> left-to-right sliding windows</li>

      <li>4.2.4 The flexible window exponentiation algorithm and the <span class="math">w</span>NAF</li>

      <li>4.3 Comparing the two algorithms</li>

      <li>5 Applications</li>

      <li>5.1 Elliptic and hyperelliptic curves</li>

      <li>5.2 Trace zero varieties</li>

      <li>5.3 XTR</li>

    </ul>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Some public-key cryptographic protocols such as the verification of digital signatures require the computation of the product of powers of two <em>[1]</em>, three <em>[12]</em> or more elements of a group. Furthermore, in some algebraic structures the computation of a single exponentiation can be reduced to such a product: If a commutative group <span class="math">G</span> admits an automorphism <span class="math">\\sigma</span> satisfying a monic equation over the integers of degree <span class="math">d</span> then <span class="math">g^{e}</span> can be computed as <span class="math">g^{e_{0}}\\cdot\\sigma(g)^{e_{1}}\\cdots\\sigma^{d-1}(g)^{e_{d-1}}</span> for suitable integers <span class="math">e_{0},\\ldots,e_{d-1}</span> which in many practical instances have size <span class="math">O(e^{1/d})</span> (see <em>[15, 27]</em>). In this context, too, the cases <span class="math">d=2</span> and <span class="math">d=3</span> are of particular practical relevance because of trace zero varieties and XTR (see Section 5).</p>

    <p class="text-gray-300">Such computations can be performed by computing the various powers separately and then multiplying them together. If one of the bases is known in advance and one can afford to store a lot of precomputed values, one can obtain very good performance from this idea <em>[10]</em>. However, if the intermediate results are not needed elsewhere, one can do much better in the general case.</p>

    <p class="text-gray-300">Shamir’s trick can be extended in a straightforward way by using sliding windows: To our knowledge this was first reported in <em>[33]</em>. So far, this generalisation of Shamir’s trick has been applied only to the usual binary representation of the exponents, and only in this basic form Möller has compared it to other methods such as <em>interleaved exponentiation</em> <em>[23]</em>. We combine the idea of <em>[33]</em> with different exponent recodings and compare these variants with interleaved multiexponentiation, thus extending Möller’s analysis. One of our main concerns is to keep the memory requirements as small as possible, which is important for smart card implementations. Our results can be summarized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We propose and analyze variants of the algorithm from <em>[33]</em> which are better suited to groups where inversion is cheap. This is done by considering signed digit representations – first introduced in <em>[6]</em> – of the exponents. In particular we consider the <em>non-adjacent form</em> <em>[26, 24]</em> (see Theorem 3.6 and Remark 3.7) and a new representation of pairs of integers due to Solinas <em>[30]</em> (see Theorem 3.12).</li>

    </ul>

    <p class="text-gray-300"><em>Our best algorithms perform double exponentiations with similar performance as the best previous methods while having much smaller memory requirements: See Tables 5 and 6 (the number of operations there does not include the number of squarings, which is essentially the same in all methods which we consider) and Remark 4.6 (2). For example for a bit length <span class="math">n</span> with <span class="math">124&amp;lt;n\\leq 354</span> a double exponentiation is done by <span class="math">9+3n/8</span> multiplications on average and about <span class="math">n</span> squarings, using only <span class="math">12</span> precomputed values: the precomputations can be reduced further paying only a minimal performance penalty.</em></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To our knowledge Theorem 3.6 complements existing literature on single exponentiations.</li>

      <li>We show in Section 5 how all these methods can be used to speed up current and proposed cryptosystems.</li>

    </ol>

    <p class="text-gray-300">Power analysis of cryptosystems has aroused a lot of attention in the last years. It attempts to guess secret keys by monitoring power signals of cryptographic devices. Since distinct operations have different power consumptions, the use of simple square-and-multiply exponentiation methods can allow a potential attacker to recover the binary representation of the exponent. If, for example, digits <span class="math">\\pm 1</span> are used like in the NAF, the attacker can gain less information. Window methods are even better and the adoption of multi-exponentiation algorithms such as those presented in this paper hide the secret information very efficiently.</p>

    <p class="text-gray-300">In the next section we will introduce the general form of the algorithm from <em>[33]</em>, which will be analysed in detail in Section 3: this forms the main part of this paper. In Section 4 the optimal parameters will be discussed and the resulting time and space complexities will be compared against those of interleaved exponentiation. Next, some applications will be outlined.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Acknowledgements.</h6>

    <p class="text-gray-300">This paper would not exist, at least not in its present form, without Professor Gerhard Frey’s steady encouragement and support. The author is grateful to Tanja Lange who drew the author’s attention to Solinas’ work and proofread the manuscript. Many thanks also to Arjen Lenstra for kindly providing a reprint of <em>[33]</em>.</p>

    <p class="text-gray-300">Some computations have been performed using the maple computer algebra system <em>[8]</em>.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 The algorithm</h2>

    <p class="text-gray-300">We now proceed with the derivation and the description of the algorithm from <em>[33]</em>. Let <span class="math">G</span> be a commutative group of order <span class="math">q\\approx 2^{n}</span> and <span class="math">d</span> a (small) integer. Suppose we are given elements <span class="math">g_{1},\\ldots,g_{d}\\in G</span> and integers <span class="math">e_{1},\\ldots,e_{d}</span> and want to compute <span class="math">x:=\\prod_{i=1}^{d}g_{i}^{e_{i}}</span>. Write</p>

    <p class="text-gray-300"><span class="math">e_{i}=\\sum_{j=0}^{n-1}e_{i,j}\\,2^{j}</span> (1)</p>

    <p class="text-gray-300">with <span class="math">e_{i,j}\\in\\{0,\\pm 1\\}</span>. The coefficients <span class="math">e_{i,j}</span> are called bits (bit means binary digit): unsigned bits if the value <span class="math">-1</span> is not allowed, signed bits otherwise. In this paper, as it is now customary, <span class="math">\\bar{1}</span> means <span class="math">-1</span> in signed bit expansions of integers.</p>

    <p class="text-gray-300">For the moment we assume that the chosen representation is the unsigned binary one.</p>

    <p class="text-gray-300">The most obvious way of performing the desired computation, as already mentioned, consists in computing the powers separately and multiplying them together. The second most obvious way is perhaps the following one, which saves some squarings.</p>

    <p class="text-gray-300">Input: Group elements <span class="math">g_{1},\\ldots,g_{d}</span> and corresponding exponents <span class="math">e_{1},\\ldots,e_{d}</span> written as in (1) in base <span class="math">2</span> (i.e. with <span class="math">e_{i,j}\\in\\{0,1\\}</span>) Output: <span class="math">\\prod_{i=1}^{d}g_{i}^{e_{i}}</span></p>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <p class="text-gray-300">Step 1.  <span class="math">x\\gets 1\\in G</span></p>

    <p class="text-gray-300">Step 2. for  <span class="math">j = n - 1 \\ldots 0</span>  do  <span class="math">\\{</span></p>

    <div class="my-4 text-center"><span class="math-block">x \\leftarrow x ^ {2} \\quad [ \\text {S k i p a t f i r s t i t e r a t i o n} ]</span></div>

    <p class="text-gray-300">for  <span class="math">i = 1\\ldots d</span>  do  <span class="math">\\{\\mathbf{if}e_{i,j} = 1</span>  then  <span class="math">x\\gets x\\cdot g_i\\}</span>  }</p>

    <p class="text-gray-300">Step 3. return  <span class="math">x</span></p>

    <p class="text-gray-300">Shamir's trick improves Algorithm 2.1 as follows: First precompute the  <span class="math">2^{d}</span>  values  <span class="math">\\prod_{i=1}^{d} g_{i}^{\\{0,1\\}}</span> . Then put  <span class="math">x = \\prod_{i=1}^{d} g_{i}^{e_{i,n-1}}</span>  by one table look-up. Finally, for  <span class="math">j = n-2,\\ldots,1,0</span> , replace  <span class="math">x</span>  by  <span class="math">x^{2} \\cdot \\prod_{i=1}^{d} g_{i}^{e_{i,j}}</span>  by one squaring, one table look-up and one multiplication. Shamir's method requires  <span class="math">2^{d}-d-1</span>  multiplications to prepare the table,  <span class="math">n</span>  squarings and on average  <span class="math">(1-2^{-d})n</span>  multiplications,  <span class="math">2^{-d}</span>  being the probability that for a fixed  <span class="math">j</span> ,  <span class="math">e_{i,j}</span>  is 0 for all  <span class="math">i = 1,2,\\ldots,d</span> . If the exponents are written in a signed binary representation, the table  <span class="math">\\mathcal{E}</span>  can be formed from the products  <span class="math">\\prod_{i=1}^{d} g_{i}^{k_{i}}</span>  with  <span class="math">k_{i} \\in \\{0,\\pm 1\\}</span> . If the cost of an inversion in the group  <span class="math">G</span>  is negligible, which is usually the main reason for adopting a signed binary representation, one only needs a half of those values, i.e. those where the first nonzero  <span class="math">k_{i}</span>  equals 1. Then some products are replaced by divisions. This method can be improved by means of sliding windows [19] in the same way as the square-and-multiply method. We describe the resulting algorithm.</p>

    <p class="text-gray-300">INPUT: A window size  <span class="math">w</span> , integers  <span class="math">e_1, \\ldots, e_d</span>  as in (1) and a set  <span class="math">\\mathcal{E}</span>  of precomputed elements of the group  <span class="math">G</span>  of the form  <span class="math">\\prod_{i=1}^{d} g_i^{k_i}</span>  including  <span class="math">g_1, \\ldots, g_d</span>  (the set  <span class="math">\\mathcal{E}</span>  depends on  <span class="math">w</span>  and on the chosen representation for the integers  <span class="math">e_i</span> : see Remarks 2.3 (3-4) for examples)</p>

    <p class="text-gray-300">OUTPUT:  <span class="math">\\prod_{i=1}^{d} g_i^{e_i}</span></p>

    <p class="text-gray-300">Step 1.  <span class="math">t\\gets n</span>  and  <span class="math">x\\gets 1\\in G</span></p>

    <p class="text-gray-300">Step 2. if  <span class="math">(e_{i,t - 1} = 0</span>  for  <span class="math">i = 1,2,\\ldots ,d)</span>  then  <span class="math">\\{(</span></p>

    <p class="text-gray-300">(a)  <span class="math">t\\gets t - 1</span>  and  <span class="math">x\\gets x^2</span> } else { (b) if  <span class="math">t \\geq w</span>  then  <span class="math">t \\gets t - w</span>  else  <span class="math">\\{w \\gets t \\text{ and } t \\gets 0\\}</span> (c) for  <span class="math">i = 1,2,\\ldots ,d</span>  do  <span class="math">f_{i}\\gets \\sum_{j = 0}^{w - 1}e_{i,t + j}2^{j}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(d) Let  <span class="math">s</span>  be the largest integer  <span class="math">s \\geq 0</span>  such that  $2^s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i<span class="math">  for all  </span>i$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(e) for  <span class="math">i = 1,2,\\ldots ,d</span>  do  <span class="math">f_{i}\\gets f_{i} / 2^{s}</span> (f) (i)  <span class="math">x \\gets x^{2^{w - s}}</span> ; (ii)  <span class="math">x \\gets x \\cdot \\prod_{i=1}^{d} g_i^{f_i}</span>  and (iii)  <span class="math">x \\gets x^{2^s}</span> .</p>

    <p class="text-gray-300">Step 3. if  <span class="math">t = 0</span>  then return  <span class="math">x</span>  else goto Step 2</p>

    <p class="text-gray-300">Remarks 2.3 (1) In the case  <span class="math">d = 1</span>  the above algorithm is the usual sliding window exponentiation algorithm. If  <span class="math">w = 1</span>  then it is just Shamir's trick.</p>

    <p class="text-gray-300">(2) At the beginning of Step 2(c)  <span class="math">f_{i}</span>  is the integer represented by a string of  <span class="math">w</span>  consecutive bits from the exponent  <span class="math">e_{i}</span> . Now  <span class="math">s</span>  is the largest non-negative integer such that  <span class="math">e_{i,t + u} = 0</span>  for all  <span class="math">i</span>  and all  <span class="math">u</span>  with  <span class="math">0 \\leq u \\leq s</span> . The normalisation Step 2(e) is performed such that at least one of the integers  <span class="math">f_{i}</span>  is</p>

    <p class="text-gray-300">odd, in order to reduce the number of elements of <span class="math">\\mathcal{E}</span> without impacting the total number of operations done in Step 2 (f).</p>

    <p class="text-gray-300">(3) In Step 2 (f) the first time it is <span class="math">x=1</span>, so one multiplication can be saved and only <span class="math">s</span> squarings are needed.</p>

    <p class="text-gray-300">(4) If the exponents are written in base <span class="math">2</span>, then <span class="math">\\mathcal{E}</span> consists of all elements of the form <span class="math">\\prod_{i=1}^{d}g_{i}^{k_{i}}</span> such that <span class="math">0\\leq k_{i}&lt;2^{w}</span> and at least one of the <span class="math">k_{i}</span> is odd. Then Step 2 (f) is done with one table look-up, one multiplication and <span class="math">w</span> squarings.</p>

    <p class="text-gray-300">(5) The changes to Algorithm 2.2 required to work with the NAF are straightforward. A detailed discussion of this case is found in Subsection 3.2. One important consequence of the fact that inversion is free is that the size of <span class="math">\\mathcal{E}</span> can be reduced: In fact in Step 2 (f,ii) one can compute either <span class="math">x\\leftarrow x\\cdot\\prod_{i=1}^{d}g_{i}^{f_{i}}</span> or <span class="math">x\\leftarrow x/\\prod_{i=1}^{d}g_{i}^{-f_{i}}</span> so only a half of the full table is required.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Complexity analysis</h2>

    <p class="text-gray-300">In this section we are concerned only with Algorithm 2.2 and its complexity.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 3.1</h6>

    <p class="text-gray-300">A <em>column</em> is defined as a <span class="math">d</span>-tuple of digits <span class="math">e^{(t)}=(e_{1,t},\\ldots,e_{d,t})</span> of the representation of integers (1) and the ordered sequence <span class="math">e^{(n-1)},e^{(n-2)},\\ldots,e^{(0)}</span> of such columns is called <em>joint representation</em> of the <span class="math">d</span> exponents <span class="math">e_{1},\\ldots,e_{d}</span>.</p>

    <p class="text-gray-300">If <span class="math">e^{(n-1)}\\neq 0</span> then the joint representation is said to be <em>proper</em> and <span class="math">n</span> is its <em>length</em>.</p>

    <p class="text-gray-300">The number of nonzero columns in the joint representation is called its <em>Hamming weight</em>, and its <em>density</em> is the ratio of the Hamming weight to the length.</p>

    <p class="text-gray-300">For simplicity we require that the joint representation of the exponents <span class="math">e_{1},\\ldots,e_{d}</span> is proper. Thus at the first iteration of Step (2), substeps (b)–(f) are always performed. To evaluate the number of squarings one should not consider those which can be avoided in the first iteration, which are <span class="math">w</span> minus the expected first value of <span class="math">s</span>.</p>

    <p class="text-gray-300">Algorithm 2.2 scans the joint representation of the <span class="math">d</span> exponents <span class="math">e_{1},\\ldots,e_{d}</span> one column at a time, starting with the column formed by the most significant digits in the chosen representation. Step 2 is iterated until the joint representation has been scanned completely. At each iteration one column is read and the algorithm enters in one of two possible distinct states:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{0}.</span> A zero column is found, so the scanning advances by one column (Step 2 (a)).</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{1}.</span> A nonzero column is found and the scanning advances by <span class="math">w</span> columns (Steps 2 (b)–(f)).</p>

    <p class="text-gray-300">The number of multiplications (excluding squarings) performed by the algorithm equals the number of times we are in the second state. Let <span class="math">\\pi</span> be the probability that the column read in Step 2 is zero. After <span class="math">m</span> iterations, the expected number of columns read by the scanning process is <span class="math">(\\pi+w(1-\\pi))m</span>. Suppose that for some <span class="math">m</span> this number is <span class="math">n</span>. The number of multiplications performed by Algorithm 2.2 in Step 2 (d) is then <span class="math">(1-\\pi)m-1</span> (remember that the first multiplication can be replaced by an assignment) <em>i.e.</em></p>

    <p class="text-gray-300"><span class="math">n\\cdot\\frac{1-\\pi}{\\pi+w(1-\\pi)}-1.</span> (2)</p>

    <p class="text-gray-300">This is, with some adaptations, the approach followed in the next two subsections.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 3.2</h6>

    <p class="text-gray-300">Let <span class="math">e=\\sum_{j=0}^{n-1}e_{j}\\,2^{j}</span> be an integer. We say that an algorithm scans (generates, rewrites…) the <em>bits <span class="math">e_{j}</span> right-to-left</em> (resp. <em>left-to-right</em>) if it scans (generates, rewrites…) them from</p>

    <p class="text-gray-300">the least significant ones to the most significant ones, i.e. first <span class="math">e_{0}</span>, then <span class="math">e_{1}</span>, <span class="math">e_{2}</span>, etc. (resp. from the most significant ones to the least significant ones, i.e. first <span class="math">e_{n-1}</span>, then <span class="math">e_{n-2}</span>, and so on).</p>

    <p class="text-gray-300">Similar definitions hold for algorithms which deal with the colums of a joint representation of several integers.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Remark 3.3</h6>

    <p class="text-gray-300">Algorithm 2.2 processes the columns of the chosen joint representation of the exponents left-to-right. However most recoding algorithms for producing signed binary representations, such as Reitwiesner’s algorithm <em>[26]</em> and Solinas’ own algorithm for the Joint Sparse Form, rewrite the exponents right-to-left. In such situations recoding and (multi-)exponentiation cannot be interleaved, and the recoded representations must be stored explicitly. This is a general problem with window methods.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 Unsigned binary inputs</h3>

    <p class="text-gray-300">Here the exponents are written in base <span class="math">2</span>, i.e. <span class="math">e_{i,j}\\in\\{0,1\\}</span>. The set <span class="math">\\mathcal{E}</span> consists of all elements of the form <span class="math">\\prod_{i=1}^{d}g_{i}^{k_{i}}</span> such that <span class="math">0\\leq k_{i}&lt;2^{w}</span> and at least one of the <span class="math">k_{i}</span> is odd. It has cardinality <span class="math">2^{wd}-2^{(w-1)d}</span>. Half of the powers of the base elements <span class="math">g_{i}</span> can be computed by squarings and all other elements by products.</p>

    <p class="text-gray-300">The bits in each representation are assumed to be zero or one with equal probability and independent from the adjacent bits, so <span class="math">\\pi=2^{-d}</span>. To evaluate the number of squarings in the main loop of the algorithm we must determine the expected value of <span class="math">s</span> at the first iteration. As all the bits are independent from each other, <span class="math">s\\geq u</span> with <span class="math">1\\leq u&lt;w</span> with probability <span class="math">2^{-ud}</span>. Hence the expected value of <span class="math">s</span> is <span class="math">\\sum_{u=1}^{w-1}2^{-ud}=\\frac{1-2^{-d(w-1)}}{2^{d}-1}</span>. We have thus the following result:</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 3.4</h6>

    <p class="text-gray-300">Suppose that in Algorithm 2.2 the unsigned binary representation is used for the exponents and that their joint representation has length <span class="math">n</span>.</p>

    <p class="text-gray-300">Then the set <span class="math">\\mathcal{E}</span> has cardinality <span class="math">2^{wd}-2^{(w-1)d}</span> and requires <span class="math">2^{wd}-2^{(w-1)d}-d</span> operations to be computed: of these at least <span class="math">d(2^{w-1}-1)</span> can be assumed to be squarings.</p>

    <p class="text-gray-300">The expected number of multiplications in the algorithm is <span class="math">n\\frac{1}{w+(2^{d}-1)^{-1}}-1</span> and that of the squarings is <span class="math">n-w+\\frac{1-2^{-d(w-1)}}{2^{d}-1}</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Remark 3.5</h6>

    <p class="text-gray-300">In the case <span class="math">w=d=2</span>, the set <span class="math">\\mathcal{E}</span> consists of the values <span class="math">g_{1}^{a}g_{2}^{b}</span> with <span class="math">0\\leq a,b\\leq 3</span> and at least one of <span class="math">a,b</span> odd. To determine them one has to compute and store <span class="math">g_{1}^{2}</span> and <span class="math">g_{1}^{3}</span>, as well as <span class="math">g_{2}^{2}</span> and <span class="math">g_{2}^{3}</span>. This requires <span class="math">2</span> squarings and <span class="math">2</span> multiplications. Computing the remaining <span class="math">8</span> values requires <span class="math">8</span> further multiplications.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.2 Using the NAF</h3>

    <p class="text-gray-300">A non-adjacent form (abbreviated as NAF) is a signed binary representation of an integer <span class="math">e=\\sum_{j=0}^{n-1}b_{j}2^{j}</span> with <span class="math">b_{j}\\in\\{0,\\pm 1\\}</span> and <span class="math">b_{j}b_{j-1}=0</span>. Each integer admits a NAF, which is uniquely determined. It is the signed binary representation of minimal Hamming weight and it has expected density <span class="math">1/3</span> (see <em>[24]</em> and <em>[2]</em> for proofs).</p>

    <p class="text-gray-300">Reading NAFs through non-sliding windows has been considered already but only for a single NAF (i.e. <span class="math">d=1</span>) and not in the case of joint representations: See the paper <em>[13]</em>, of which we use some arguments in this subsection. We consider here sliding windows, which lead to lower complexity. Hence, even in the case <span class="math">d=1</span> our results will complement existing literature. This must not be confused with the <span class="math">w</span>NAF, cfr. §4.2.4.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 3.6</h6>

    <p class="text-gray-300">Suppose that in Algorithm 2.2 the exponents are input in NAF, and that their joint representation is <span class="math">n</span> bits long.</p>

    <p class="text-gray-300">The set <span class="math">\\mathcal{E}</span> has cardinality <span class="math">(I_{w}^{d}-I_{w-1}^{d})/2</span> where <span class="math">I_{w}=\\frac{2^{w+2}-(-1)^{w}}{3}</span>.</p>

    <p class="text-gray-300">The number of squarings in the main loop of the algorithm is between <span class="math">n-w</span> and <span class="math">n-1</span>, with an heuristically expected value <span class="math">n-w+\\left(\\frac{4}{3}\\right)^{d}\\frac{1-2^{-d(w-1)}}{2^{d}-1}</span>. In the cases <span class="math">d=1,2</span> and <span class="math">3</span> respectively, the expected number of multiplications is <span class="math">n\\cdot\\frac{1-\\pi^{(d)}}{w-(w-1)\\pi^{(d)}}-1</span> where</p>

    <p class="text-gray-300"><span class="math">\\pi^{(1)}=\\frac{4\\left(2^{w}-(-1)^{w}\\right)}{7\\cdot 2^{w}-4\\cdot(-1)^{w}}\\;,\\quad\\pi^{(2)}=\\frac{16\\left(4^{w}-1\\right)}{43\\cdot 4^{w}+24\\cdot(-2)^{w}-16}\\quad\\text{and}</span> (3) <span class="math">\\pi^{(3)}=\\frac{64\\left(2^{w}+(-1)^{w}\\right)\\left(8^{w}-(-1)^{w}\\right)}{253\\cdot 16^{w}+397\\cdot(-8)^{w}+324\\cdot 4^{w}+80\\cdot(-2)^{w}-64}.</span></p>

    <p class="text-gray-300">In particular for <span class="math">d=1</span> the expected number of multiplications is <span class="math">n\\cdot\\frac{1}{w+\\frac{4}{3}\\left(1-\\left(-\\frac{1}{2}\\right)^{w}\\right)}-1</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 3.7</h6>

    <p class="text-gray-300">In the case <span class="math">w=d=2</span>, the set <span class="math">\\mathcal{E}</span> consists of the values <span class="math">g_{1}^{a}g_{2}^{b}</span> with either <span class="math">0&lt;a\\leq 2</span> and <span class="math">-2\\leq b\\leq 2</span> where at least one of <span class="math">a,b</span> odd, or <span class="math">a=0</span> and <span class="math">b=1</span>. A chain for computing <span class="math">\\mathcal{E}</span> by <span class="math">6</span> multiplications or multiplications with the inverse is</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\;g_{1},\\quad g_{2},\\quad g_{1}g_{2},\\quad g_{1}g_{2}^{-1},\\quad g_{1}g_{2}^{2},\\quad g_{1}g_{2}^{-2},\\quad g_{1}^{2}g_{2},\\quad g_{1}^{2}g_{2}^{-1}\\,\\right\\}.</span></p>

    <p class="text-gray-300">The remainder of this subsection is devoted to the proof of Theorem 3.6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First note that the largest integer representable by a <span class="math">w</span>-bit number in NAF is <span class="math">(10\\ldots 01)_{2}</span> for odd <span class="math">w</span> and <span class="math">(10\\ldots 10)_{2}</span> for even <span class="math">w</span>: It is easy to see that this number is <span class="math">T_{w}=(2^{w+2}-3-(-1)^{w})/6</span>. Hence, there are <span class="math">I_{w}=(2^{w+2}-(-1)^{w})/3</span> integers in the interval <span class="math">[-T_{w},\\ldots,T_{w}]</span>. Now <span class="math">\\mathcal{E}</span> consists of all elements of the form <span class="math">\\prod_{i=1}^{d}g_{i}^{k_{i}}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq T_{w}<span class="math"> for </span>i=1,2,\\ldots,d<span class="math">, at least one of the </span>k_{i}<span class="math"> is odd and the first nonzero element in the sequence </span>k_{1},k_{2},\\ldots,k_{p}<span class="math"> is positive. In this way, if in Step 2 (f,ii) the first nonzero </span>f_{i}<span class="math"> is positive we compute </span>x\\leftarrow x\\cdot\\prod_{i=1}^{d}g_{i}^{f_{i}}<span class="math"> otherwise we compute </span>x\\leftarrow x/\\prod_{i=1}^{d}g_{i}^{-f_{i}}<span class="math">. Hence we need only </span>(I_{w}^{d}-I_{w-1}^{d})/2<span class="math"> elements in </span>\\mathcal{E}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 3.8</h6>

    <p class="text-gray-300">A joint representation of integers in NAF will be called a joint NAF.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 3.9</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{e}=(e_{1},\\ldots,e_{d})</span> be a <span class="math">d</span>-tuple of <span class="math">n</span>-bit integers so that (1) is proper. The bit-reversing <span class="math">\\widehat{\\mathbf{e}}</span> of <span class="math">\\mathbf{e}</span> is the <span class="math">d</span>-tuple formed by the numbers <span class="math">\\widehat{e}_{i}=\\sum_{j=0}^{n-1}e_{i,(n-1)-j}\\,2^{j}</span>.</p>

    <p class="text-gray-300">To avoid ambiguity, we define bit-reversing only for proper joint representations. The mapping which associates to a proper joint NAF its bit-reversing induces a bijection between the set of proper joint NAF’s of <span class="math">d</span> integers of <span class="math">n</span> bits and the set of joint NAF’s (not necessarily proper) of <span class="math">d</span> integers of <span class="math">n</span> bits, at least one of the integers being odd. Hence the expected number of windows made by Algorithm 2.2 on <span class="math">n</span>-bit proper joint NAF’s of <span class="math">d</span> integers equals the expected number of windows formed by a sliding window algorithm which scans from right to left joint NAF’s of <span class="math">d</span> integers of <span class="math">n</span> bits, at least one odd. The parity condition amounts to the fact that at the first iteration a nonzero column is found, exactly as in the original algorithm.</p>

    <p class="text-gray-300">Consequently we will consider an algorithm which forms sliding windows on joint NAF’s from right to left, and we will model it as a Markov chain: At each iteration one column is read and the algorithm enters in one of <span class="math">d+1</span> possible distinct states, defined by the number of nonzero entries in the colum</p>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_0^{\\prime}</span> . A zero column is found, so the scanning advances by one column.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_k^\\prime</span>  (for  <span class="math">1\\leq k\\leq d</span> ). A column is found with exactly  <span class="math">k</span>  nonzero entries and  <span class="math">(\\ast)</span>  the scanning advances by  <span class="math">w</span>  columns.</p>

    <p class="text-gray-300">To determine the transition probability from state  <span class="math">S_{\\ell}^{\\prime}</span>  to state  <span class="math">S_{k}^{\\prime}</span>  we need a few preliminary results.</p>

    <p class="text-gray-300">We begin with a review of Reitwiesner's algorithm for recoding the unsigned binary representation of a number  <span class="math">e = \\sum_{j=0}^{n-1} b_j 2^j</span>  into a NAF  <span class="math">\\sum_{j=0}^{n} e_j 2^j</span> . For  <span class="math">j = 0, 1, \\ldots, n-1</span> , the digit  <span class="math">e_j</span>  of the NAF is a function of the values of  <span class="math">b_{j+1}</span> ,  <span class="math">b_j</span>  and of the  <span class="math">j</span> -th carry  <span class="math">c_j</span> , which is equal to one if the NAF of the truncated number  <span class="math">e = \\sum_{i=0}^{j-1} b_i 2^i</span>  is one bit longer than its unsigned binary representation. At the beginning  <span class="math">c_0 = 0</span> . The recoding is then done as shown in Table 1 - where we also write the admissible following state according to the value of  <span class="math">e_{i+2}</span>  and the corresponding output - and at the end  <span class="math">e_n = c_{n-1}</span> . If  <span class="math">e_n \\neq 0</span>  then the NAF is longer than the original representation. Since in the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">State</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Input</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Output</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next State (and ei+1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(bi+1bi)2</td>

            <td class="px-3 py-2 border-b border-gray-700">ci</td>

            <td class="px-3 py-2 border-b border-gray-700">ei</td>

            <td class="px-3 py-2 border-b border-gray-700">ci+1</td>

            <td class="px-3 py-2 border-b border-gray-700">if bi+2=0</td>

            <td class="px-3 py-2 border-b border-gray-700">if bi+2=1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s0</td>

            <td class="px-3 py-2 border-b border-gray-700">(00)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">s0(0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s4(0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s1</td>

            <td class="px-3 py-2 border-b border-gray-700">(00)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">s0(0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s4(0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s2</td>

            <td class="px-3 py-2 border-b border-gray-700">(01)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">s0(0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s4(0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s3</td>

            <td class="px-3 py-2 border-b border-gray-700">(01)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">s1(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">s5(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s4</td>

            <td class="px-3 py-2 border-b border-gray-700">(10)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">s2(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">s6(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s5</td>

            <td class="px-3 py-2 border-b border-gray-700">(10)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">s3(0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s7(0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s6</td>

            <td class="px-3 py-2 border-b border-gray-700">(11)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">s3(0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s7(0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s7</td>

            <td class="px-3 py-2 border-b border-gray-700">(11)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">s3(0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s7(0)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: States of Reitwiesner's Algorithm</p>

    <p class="text-gray-300">unsigned binary representation each bit assumes a value of zero or one with equal probability and there is no dependency between any two bits, it is clear that all admissible transitions from a state  <span class="math">s_{\\ell}</span>  to a state  <span class="math">s_k</span>  occur with probability  <span class="math">\\frac{1}{2}</span> . It is straightforward to write down the corresponding transition probability matrix  <span class="math">P</span> . The resulting limiting probabilities for the states  <span class="math">s_0, \\ldots, s_7</span>  are thus [13] given by the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {v} = \\left[ \\frac {1}{6}, \\frac {1}{1 2}, \\frac {1}{1 2}, \\frac {1}{6}, \\frac {1}{6}, \\frac {1}{1 2}, \\frac {1}{1 2}, \\frac {1}{6} \\right]</span></div>

    <p class="text-gray-300">whose components add up to 1 and which satisfies  <span class="math">P \\cdot \\mathbf{v}^{\\perp} = \\mathbf{v}^{\\perp}</span> . (Here the symbol  <span class="math">\\perp</span>  denotes matrix transposition.) From this it is immediate, upon summing the probabilities for states  <span class="math">s_1, s_2, s_5</span>  and  <span class="math">s_6</span> , to obtain the known result that the expected Hamming weight of a NAF is  <span class="math">\\frac{1}{3}</span> . The fact which is more relevant to us here is that states  <span class="math">s_0, s_3, s_4</span>  and  <span class="math">s_7</span> , which all output a zero, occur with equal probabilities, and that in two cases another zero will be output by the next state, whereas in the other two a nonzero bit will be output. We have thus proved the following lemma.</p>

    <p class="text-gray-300">Lemma 3.10 The probability that in a NAF the digit immediately to the left of a 0 is another 0 is  <span class="math">\\frac{1}{2}</span>  and that it is 1 or  <span class="math">-1</span>  is in each case  <span class="math">\\frac{1}{4}</span> .</p>

    <p class="text-gray-300">We now generalize this by determining the probabilities that a bit  <span class="math">e_{j,i + w}</span>  which is  <span class="math">w</span>  places to the left of  <span class="math">e_{j,i}</span>  is zero or one, depending on the value of  <span class="math">e_{j,i}</span>  and  <span class="math">w</span> .</p>

    <p class="text-gray-300">Lemma 3.11 If  <span class="math">e_{j,i} = 0</span> , then  <span class="math">e_{j,i + w} = 0</span>  with probability  <span class="math">\\pi_{w,0}</span>  and  <span class="math">e_{j,i + w} \\neq 0</span>  with probability  <span class="math">\\pi_{w,*}</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {w, 0} = \\frac {2 ^ {w + 1} + (- 1) ^ {w}}{3 \\cdot 2 ^ {w}} \\quad \\text {and} \\quad \\pi_ {w, *} = 1 - \\pi_ {w, 0} = \\frac {1}{2} \\pi_ {w - 1, 0} = \\frac {2 ^ {w} - (- 1) ^ {w}}{3 \\cdot 2 ^ {w}}. \\tag {4}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>COMPLEXITY ANALYSIS</li>

    </ol>

    <p class="text-gray-300">Since a nonzero bit is always followed by a zero, we also have that if <span class="math">e_{j,i} \\neq 0</span>, then <span class="math">e_{j,i + w} = 0</span> with probability <span class="math">\\pi_{w - 1,0}</span> and <span class="math">e_{j,i + w} \\neq 0</span> with probability <span class="math">\\pi_{w - 1,*}</span>.</p>

    <p class="text-gray-300">Proof. Clearly <span class="math">\\pi_{w,0} + \\pi_{w,<em>} = 1</span>. By Lemma 3.10 we have <span class="math">\\pi_{1,0} = \\pi_{1,</em>} = \\frac{1}{2}</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\pi_{i + 1, 0} = \\pi_{i, *} + \\frac {1}{2} \\pi_{i, 0} = 1 - \\frac {1}{2} \\pi_{i, 0} \\\\ \\pi_{i + 1, *} = \\frac {1}{2} \\pi_{i, 0}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Now (4) follows easily by induction.</p>

    <p class="text-gray-300">We are now in the position to model the right-to-left scanning process as a Markov chain with states <span class="math">S_0&#x27;, \\ldots, S_d&#x27;</span> defined in (*). Denote by <span class="math">\\tau_{\\ell,k}</span> the transition probability from state <span class="math">S_\\ell&#x27;</span> to state <span class="math">S_k&#x27;</span>.</p>

    <p class="text-gray-300">Suppose that a zero column is read. Then no window is being formed and at the next iteration the scanning algorithm will read the next column to the left. The probability <span class="math">\\tau_{0,k}</span> that this column contains exactly <span class="math">k</span> nonzero entries is <span class="math">\\binom{d}{k} \\frac{1}{2^k}</span>.</p>

    <p class="text-gray-300">On the other hand suppose that a column <span class="math">\\mathbf{c}</span> with exactly <span class="math">\\ell \\neq 0</span> nonzero entries has been read. The bit-reversing of the numbers represented by this column and the next <span class="math">w - 1</span> columns at its left are the exponents <span class="math">f_{1},\\ldots ,f_{d}</span> in Step 2(c). The next column checked by the right-to-left scanning process, say <span class="math">\\mathbf{c}&#x27;</span>, will be then that which is exactly <span class="math">w</span> places to the left of <span class="math">\\mathbf{c}</span>. Now <span class="math">\\tau_{\\ell ,k}</span> is the probability that <span class="math">\\mathbf{c}&#x27;</span> has exactly <span class="math">k</span> nonzero entries (where <span class="math">0\\leq k\\leq d</span>). For some integer <span class="math">r</span>, in exactly <span class="math">r</span> of the positions occupied by the <span class="math">\\ell</span> nonzero digits in <span class="math">\\mathbf{c}</span> there will be nonzero bits in the respective positions in <span class="math">\\mathbf{c}&#x27;</span>, and in the positions of the remaining <span class="math">\\ell -r</span> nonzero bits in <span class="math">\\mathbf{c}</span> there will be zeros in <span class="math">\\mathbf{c}&#x27;</span>. Therefore, to exactly <span class="math">k - r</span> of the zero bits in <span class="math">\\mathbf{c}</span> will correspond nonzero bits in <span class="math">\\mathbf{c}&#x27;</span>, and to the other <span class="math">d - \\ell -(k - r)</span> zeros of <span class="math">\\mathbf{c}</span> will correspond zeros in <span class="math">\\mathbf{c}&#x27;</span>. Finally</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tau_{\\ell ,k} = \\sum_{\\substack{r: 0\\leq r\\leq \\ell \\\\ 0\\leq k - r\\leq d - \\ell}}\\binom {\\ell}{r}\\binom {d - \\ell}{k - r}\\pi_{w - 1,*}^{r}\\pi_{w - 1,0}^{\\ell -r}\\pi_{w,*}^{k - r}\\pi_{w,0}^{d - \\ell -(k - r)} \\\\ = \\sum_{\\substack{r: 0\\leq r\\leq \\ell \\\\ k + \\ell -d\\leq r\\leq k}}\\binom {\\ell}{r}\\binom {d - \\ell}{k - r}\\left(1 - 2\\pi_{w,*}\\right)^{r}2^{\\ell -r}\\pi_{w,*}^{\\ell -r}\\pi_{w,*}^{k - r}\\left(1 - \\pi_{w,*}\\right)^{d - \\ell -(k - r)} \\\\ = \\sum_ {r = \\max  \\{0, k + \\ell - d \\}} ^ {\\min  \\{\\ell , k \\}} \\binom {\\ell} {r} \\binom {d - \\ell} {k - r} 2 ^ {\\ell - r} \\pi_ {w, *} ^ {\\ell + k - 2 r} \\left(1 - \\pi_ {w, *}\\right) ^ {(d - \\ell - k) + r} \\left(1 - 2 \\pi_ {w, *}\\right) ^ {r}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Put</p>

    <div class="my-4 text-center"><span class="math-block">T _ {d} = (\\tau_ {\\ell , k}) _ {\\ell , k = 0} ^ {d} = \\left( \\begin{array}{c c c c c} 1 / 2 ^ {d} &amp;amp; \\tau_ {1, 0} &amp;amp; \\tau_ {2, 0} &amp;amp; \\dots &amp;amp; \\tau_ {d, 0} \\\\ \\binom {d} {1} / 2 ^ {d} &amp;amp; \\tau_ {1, 1} &amp;amp; \\tau_ {2, 1} &amp;amp; \\dots &amp;amp; \\tau_ {d, 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\binom {d} {d - 1} / 2 ^ {d} &amp;amp; \\tau_ {1, d - 1} &amp;amp; \\tau_ {2, d - 1} &amp;amp; \\dots &amp;amp; \\tau_ {d, d - 1} \\\\ 1 / 2 ^ {d} &amp;amp; \\tau_ {1, d} &amp;amp; \\tau_ {2, d} &amp;amp; \\dots &amp;amp; \\tau_ {d, d} \\end{array} \\right).</span></div>

    <p class="text-gray-300">The limiting probabilities <span class="math">\\sigma_0, \\ldots, \\sigma_d</span> of the algorithm being in state <span class="math">S_0&#x27;, \\ldots, S_d&#x27;</span> respectively satisfy</p>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <p class="text-gray-300"><span class="math">\\sum_{k=1}^{d} \\sigma_k = 1</span> and <span class="math">T_d \\cdot (\\sigma_0 \\cdots \\sigma_d)&#x27; = (\\sigma_0 \\cdots \\sigma_d)&#x27;</span>. Hence, upon putting</p>

    <div class="my-4 text-center"><span class="math-block">U _ {d} = \\left( \\begin{array}{c c c c c} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \\dots &amp;amp; 1 \\\\ d / 2 ^ {d} &amp;amp; \\tau_ {1, 1} - 1 &amp;amp; \\tau_ {2, 1} &amp;amp; \\dots &amp;amp; \\tau_ {d, 1} \\\\ \\binom {d} {2} / 2 ^ {d} &amp;amp; \\tau_ {1, 2} &amp;amp; \\tau_ {2, 2} - 1 &amp;amp; \\dots &amp;amp; \\tau_ {d, 2} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ d / 2 ^ {d} &amp;amp; \\tau_ {1, d - 1} &amp;amp; \\tau_ {2, d - 1} &amp;amp; \\dots &amp;amp; \\tau_ {d, d - 1} \\\\ 1 / 2 ^ {d} &amp;amp; \\tau_ {1, d} &amp;amp; \\tau_ {2, d} &amp;amp; \\dots &amp;amp; \\tau_ {d, d} - 1 \\end{array} \\right),</span></div>

    <p class="text-gray-300">we have <span class="math">U_{d} \\cdot (\\sigma_{0} \\cdots \\sigma_{d})^{\\perp} = (1, 0, \\ldots, 0)^{\\perp}</span>. Hence, provided that <span class="math">U_{d}</span> is invertible, <span class="math">(\\sigma_{0} \\cdots \\sigma_{d})^{\\perp} = U_{d}^{-1} \\cdot (1, 0, \\ldots, 0)^{\\perp}</span> and in particular <span class="math">\\sigma_{0}</span> is the value in the top left corner of <span class="math">U_{d}^{-1}</span>.</p>

    <p class="text-gray-300">We are interested in <span class="math">U_{d}</span> only in the cases <span class="math">d = 1,2</span> and 3. Upon putting <span class="math">\\alpha = 2^{w}</span> and <span class="math">\\beta = (-1)^{w}</span> we obtain</p>

    <div class="my-4 text-center"><span class="math-block">U _ {1} = \\left( \\begin{array}{c c} 1 &amp;amp; 1 \\\\ \\frac {1}{2} &amp;amp; \\frac {\\alpha + 2 \\beta}{3 \\alpha} - 1 \\end{array} \\right), \\qquad U _ {2} = \\left( \\begin{array}{c c c} 1 &amp;amp; 1 &amp;amp; 1 \\\\ \\frac {1}{2} &amp;amp; \\frac {4 \\alpha^ {2} + \\alpha \\beta + 4 \\beta^ {2}}{9 \\alpha^ {2}} - 1 &amp;amp; \\frac {4 (\\alpha - \\beta) (\\alpha + 2 \\beta)}{9 \\alpha^ {2}} \\\\ \\frac {1}{4} &amp;amp; \\frac {(\\alpha - \\beta) (\\alpha + 2 \\beta)}{9 \\alpha^ {2}} &amp;amp; \\frac {(\\alpha + 2 \\beta) ^ {2}}{9 \\alpha^ {2}} - 1 \\end{array} \\right) \\quad \\text{and}</span></div>

    <div class="my-4 text-center"><span class="math-block">U _ {3} = \\left( \\begin{array}{c c c c} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\\\ \\frac {3}{8} &amp;amp; \\frac {(2 \\alpha + \\beta) (2 \\alpha^ {2} - \\alpha \\beta + 2 \\beta^ {2})}{9 \\alpha^ {3}} - 1 &amp;amp; \\frac {4 (\\alpha^ {3} - \\beta^ {3})}{9 \\alpha^ {3}} &amp;amp; \\frac {4 (\\alpha - \\beta) ^ {2} (\\alpha + 2 \\beta)}{9 \\alpha^ {3}} \\\\ \\frac {3}{8} &amp;amp; \\frac {2 (\\alpha^ {3} - \\beta^ {3})}{9 \\alpha^ {3}} &amp;amp; \\frac {(\\alpha + 2 \\beta) (2 \\alpha^ {2} - \\alpha \\beta + 2 \\beta^ {2})}{9 \\alpha^ {3}} - 1 &amp;amp; \\frac {2 (\\alpha - \\beta) (\\alpha + 2 \\beta) ^ {2}}{9 \\alpha^ {3}} \\\\ \\frac {1}{8} &amp;amp; \\frac {(\\alpha - \\beta) ^ {2} (\\alpha + 2 \\beta)}{2 7 \\alpha^ {3}} &amp;amp; \\frac {(\\alpha - \\beta) (\\alpha + 2 \\beta) ^ {2}}{2 7 \\alpha^ {3}} &amp;amp; \\frac {(\\alpha + 2 \\beta) ^ {3}}{2 7 \\alpha^ {3}} - 1 \\end{array} \\right).</span></div>

    <p class="text-gray-300">The above matrices have been written down using simple maple [8] code. With the same software it is immediate to verify that for <span class="math">d = 1,2</span> and 3 the matrix <span class="math">U_{d}</span> is invertible and to compute <span class="math">\\sigma_0</span>, i.e. the value of <span class="math">\\pi</span> in the introductory part of this section. We thus obtain the values <span class="math">\\pi = \\pi^{(d)}</span> given in equation (3), Theorem 3.6.</p>

    <p class="text-gray-300">To estimate the value of <span class="math">s</span> at the first iteration of the main loop, we proceed heuristically. [13, Theorem 1] states that the probability that a length <span class="math">u</span> bit section of a number in NAF is zero is <span class="math">\\frac{4}{3}\\left(\\frac{1}{2}\\right)^u</span>. For <span class="math">u = 1,\\dots ,w - 1</span> we apply this result to the <span class="math">u</span> least significant bits used to form each of the integers <span class="math">f_{1},\\ldots ,f_{d}</span> in Step 2 (c) at the first iteration of the loop of Algorithm 2.2. We then proceed as in the proof of Theorem 3.4, the only difference consisting in the multiplicative factor <span class="math">\\left(\\frac{4}{3}\\right)^d</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3.3 Using the JSF</h2>

    <p class="text-gray-300">The Joint Sparse Form has been introduced by Solinas [30] to make Shamir's trick more effective for elliptic curves. It applies however to all groups where inversion is for free. It has been defined only for pairs of integers: accordingly we will restrict ourselves to the case <span class="math">d = 2</span> here. We shall also assume that <span class="math">w = 2</span>: this assumption fits naturally with the defining properties of the JSF, and by a good stoke of luck this brings the highest improvement over the methods studied before for exponents in the range in which we are interested. For more precise statements see Subsection 4.1, in particular the row for <span class="math">w = 2</span> in Table 2 and Remark 4.1.</p>

    <p class="text-gray-300">In this subsection we prove the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 3.12</strong> Suppose that in Algorithm 2.2 Solinas' JSF is used for the exponents, and <span class="math">w = d = 2</span>. Assume further that the JSF of the exponents has length <span class="math">n</span>.</p>

    <p class="text-gray-300">The expected number of multiplications in the main loop of the algorithm is <span class="math">\\frac{3}{8}n-1</span>, and the heuristically expected number of squarings is <span class="math">n-2+\\frac{1}{2}=n-\\frac{3}{2}</span>.</p>

    <p class="text-gray-300">The set <span class="math">\\mathcal{E}</span> consists of the <span class="math">10</span> elements <span class="math">g_{1}^{a}g_{2}^{b}</span> with: (i) <span class="math">a=0</span> and <span class="math">b=1</span>; (ii) <span class="math">a=1</span> and <span class="math">-2\\leq b\\leq 2</span>; (iii) <span class="math">a=2</span> and <span class="math">b\\in\\{\\pm 1,\\pm 3\\}</span> and (iv) <span class="math">a=3</span> and <span class="math">b=\\pm 2</span>. A chain for precomputing all the <span class="math">10</span> required values other than <span class="math">g_{1}</span> and <span class="math">g_{2}</span> and requiring <span class="math">10</span> multiplications or divisions is</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{cccc}\\big{\\{}g_{1},&g_{2},&g_{1}g_{2},&g_{1}g_{2}^{-1},&g_{1}g_{2}^{2},&g_{1}g_{2}^{-2},\\\\ g_{1}^{2}g_{2},&g_{1}^{2}g_{2}^{-1},&g_{1}^{2}g_{2}^{3},&g_{1}^{2}g_{2}^{-3},&g_{1}^{3}g_{2}^{2},&g_{1}^{3}g_{2}^{-2}.\\big{\\}}\\end{array} \\] (5)</p>

    <p class="text-gray-300">We assume that the reader is acquainted with the results in Solinas’ cited technical report, from which we recall however a few important facts. The joint Hamming weight of the JSF of two integers is minimal among all (un)signed joint binary representations of the same pair of integers. Its average density is <span class="math">1/2</span> – which gives the heuristical estimate of the squarings in the main loop – whereas that of the joint unsigned binary representation and of the joint NAF is <span class="math">3/4</span> and <span class="math">5/9</span> respectively. It is natural then to expect that using the JSF in Algorithm 2.2 would lead to an improvement over the complexities of the other two cases even if <span class="math">w&gt;1</span>.</p>

    <p class="text-gray-300">The JSF is uniquely determined by the following properties:</p>

    <p class="text-gray-300">Of any three consecutive columns, at least one is zero. Adjacent nonzero bits have the same sign. In other words, <span class="math">e_{i,j+1}e_{i,j}=0</span> or <span class="math">1</span>. If <span class="math">e_{i,j+1}e_{i,j}\\neq 0</span> then <span class="math">e_{3-i,j+1}\\neq 0</span> and <span class="math">e_{3-i,j}=0</span>.</p>

    <p class="text-gray-300">Solinas provides proofs for existence and uniqueness of the JSF, as well as an algorithm for determining it. His algorithm generates the JSF right-to-left. Analysing it Solinas considers three states which he simply calls <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span>. In state <span class="math">C</span> this algorithm outputs a zero column. In states <span class="math">A</span> or <span class="math">B</span> it outputs nonzero columns. The transition probabilities between these states are explicitly given: we return to this later.</p>

    <p class="text-gray-300">Property (JSF-1) suggests that the representation is particularly suitable for an implementation of Algorithm 2.2 with a window width <span class="math">w=2</span>. As already announced we restrict ourselves to this case in the sequel. Further, this choice also simplifies the complexity analysis, by the following observation: Algorithm 2.2 scans a joint representation left-to-right in order to form windows, but <em>consecutive nonzero columns always belong to one window regardless of the direction in which we are scanning the joint representation</em>. This is easy to see, as by property (JSF-1) there can be at most two consecutive nonzero columns, which must be preceded and followed by zero columns or by the boundaries of the representation.</p>

    <p class="text-gray-300">Therefore to estimate the number of nonzero windows (which corresponds to the number of multiplications performed by Algorithm 2.2 plus one) we scan our input right-to-left. In Solinas’ algorithm State <span class="math">A</span> is always followed by State <span class="math">B</span>, State <span class="math">B</span> by State <span class="math">C</span>, and there are the following transition probabilities: <span class="math">\\mathcal{P}(C\\mapsto A)=1/4</span>, <span class="math">\\mathcal{P}(C\\mapsto B)=1/2</span> and <span class="math">\\mathcal{P}(C\\mapsto C)=1/4</span>. We thus consider a Markov chain with <em>three</em> states, which correspond to those in Solinas’ algorithm, as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{0}^{<em>}</span>. A nonzero column is output by State <span class="math">A</span> of Solinas’ algorithm: this column will be the second column in a “square” window when read left-to-right, as the next state in Solinas’ algorithm is always State <span class="math">B</span>. <span class="math">\\mathcal{S}_{1}^{</em>}</span>. A nonzero column is output by State <span class="math">B</span> of Solinas’ algorithm: this column will be the first column in a window when read left-to-right, whereas the second column is non-zero if we are coming from state <span class="math">A</span> or zero if we come from State <span class="math">C</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_2^*</span> . A zero column is output by State  <span class="math">C</span>  of Solinas' algorithm.</p>

    <p class="text-gray-300">The number of times we enter in  <span class="math">S_1^*</span>  corresponds to the number of windows formed and thus to the number of multiplications performed by our algorithm. The transition probability matrix is</p>

    <div class="my-4 text-center"><span class="math-block">T = \\left(\\mathcal {P} (\\mathcal {S} _ {i} ^ {*} \\mapsto \\mathcal {S} _ {j} ^ {*})\\right) _ {i, j = 0} ^ {2} = \\left( \\begin{array}{c c c} 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 / 4 &amp;amp; 1 / 2 &amp;amp; 1 / 4 \\end{array} \\right)</span></div>

    <p class="text-gray-300">which yields limiting probabilities  <span class="math">\\pi_0 = \\frac{1}{8}</span> ,  <span class="math">\\pi_1 = \\frac{3}{8}</span>  and  <span class="math">\\pi_2 = \\frac{1}{2}</span> . Hence the expected number of multiplications performed by Algorithm 2.2 is  <span class="math">\\frac{3}{8} n - 1</span>  with  <span class="math">n</span> -bit inputs.</p>

    <p class="text-gray-300">According to the defining properties of the JSF, the admissible nonzero columns  <span class="math">\\binom{e_1,j}{e_2,j}</span>  and windows  <span class="math">\\binom{e_1,j}{e_2,j} \\binom{e_1,j-1}{e_2,j-1}</span>  with both columns non zero that, up to sign, can be found are</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} 0 \\\\ 1 \\end{array} \\right], \\left[ \\begin{array}{c} 1 \\\\ 0 \\end{array} \\right], \\left[ \\begin{array}{c} 1 \\\\ \\pm 1 \\end{array} \\right], \\left[ \\begin{array}{c c} 0 &amp;amp; 1 \\\\ \\pm 1 &amp;amp; 0 \\end{array} \\right], \\left[ \\begin{array}{c c} 1 &amp;amp; 0 \\\\ 0 &amp;amp; \\pm 1 \\end{array} \\right], \\left[ \\begin{array}{c c} 1 &amp;amp; 0 \\\\ \\epsilon &amp;amp; \\epsilon \\end{array} \\right] \\text {w i t h} \\epsilon = \\pm 1, \\text {a n d} \\left[ \\begin{array}{c c} 1 &amp;amp; 1 \\\\ \\pm 1 &amp;amp; 0 \\end{array} \\right],</span></div>

    <p class="text-gray-300">thus proving the statements about  <span class="math">\\mathcal{E}</span> .</p>

    <h2 id="sec-21" class="text-2xl font-bold">4.1 Algorithm 2.2: Optimal parameters for  <span class="math">d = 2</span>  and 3</h2>

    <p class="text-gray-300">First of all, it is important to know for which values of the parameter  <span class="math">w</span>  the algorithms run fastest, given the bit length  <span class="math">n</span>  of the inputs and the number  <span class="math">d</span>  of the exponents. For simplicity we ignore the number of squarings performed in the main loop and we consider it only for  <span class="math">d = 2</span>  and 3.</p>

    <p class="text-gray-300">Suppose first  <span class="math">d = 2</span> : Table 2 contains the cardinality of  <span class="math">\\mathcal{E}</span>  and the sum of the number of operations needed to build it with the expected number of multiplications in the main loop of the algorithm. This performance parameter (similar to that used for instance in [23]) is a natural way of comparing exponentiation algorithms. In fact, it is easy to adapt these values to the relative costs of squarings by adding  <span class="math">c_{s} n</span> , where  <span class="math">c_{s}</span>  is the cost of a squaring relative to that of a multiplication. In the column for the JSF there is of course no entry for  <span class="math">w = 3</span> .</p>

    <p class="text-gray-300">Table 3 collects the analogous data for  <span class="math">d = 3</span> : Note that the JSF, being defined only for  <span class="math">d = 2</span> , is not represented.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unsigned #E and #Ops</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NAF #E and #Ops</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">JSF #E and #Ops</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3/4n</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">1 + 5/9n</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">1 + 1/2n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">9 + 3/7n</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">5 + 11/27n</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">9 + 3/8n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">45 + 3/10n</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">45 + 32/117n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Cardinality of  <span class="math">\\mathcal{E}</span>  and number of operations for  <span class="math">d = 2</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>COMPARISONS</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unsigned #E and #Ops</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NAF #E and #Ops</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">3 + 7/8n</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">9 + 19/27n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">52 + 7/15n</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">45 + 131/297n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

            <td class="px-3 py-2 border-b border-gray-700">444 + 7/22n</td>

            <td class="px-3 py-2 border-b border-gray-700">603</td>

            <td class="px-3 py-2 border-b border-gray-700">599 + 1082/3645n</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Cardinality of  <span class="math">\\mathcal{E}</span>  and number of operations for  <span class="math">d = 3</span></p>

    <p class="text-gray-300">Remark 4.1 Assume  <span class="math">d = 2</span>  and consider Table 2. Using the unsigned binary representation, the optimal choice of  <span class="math">w</span>  is  <span class="math">w = 1</span>  for  <span class="math">n \\leq 28</span> , and  <span class="math">w = 2</span>  for  <span class="math">28 \\leq n \\leq 280</span> . In particular the parameter  <span class="math">w = 2</span>  is optimal for the exponents sizes which interests us.</p>

    <p class="text-gray-300">With the NAF the thresholds are  <span class="math">n = 27</span>  and  <span class="math">n = \\frac{14040}{47} = 298.72</span>  respectively.</p>

    <p class="text-gray-300">With the JSF the parameter  <span class="math">w = 1</span>  is optimal for  <span class="math">n \\leq 64</span> . Furthermore, using the JSF with  <span class="math">w = 2</span>  is better than using the NAF with either  <span class="math">w = 2</span>  or 3 when  <span class="math">124 &amp;lt; n \\leq 354</span> : in the range which concerns us most however using the NAF can be marginally slower but requires fewer precomputations.</p>

    <p class="text-gray-300">Remark 4.2 In the case  <span class="math">d = 3</span>  (see Table 3) the thresholds are higher, as intuition suggests. Using the unsigned binary representation, the optimal choice of  <span class="math">w</span>  is  <span class="math">w = 1</span>  for  <span class="math">n \\leq 120</span> , and  <span class="math">w = 2</span>  for  <span class="math">121 \\leq n \\leq 2640</span> . In the NAF case,  <span class="math">w = 1</span>  is optimal for  <span class="math">n \\leq 137</span>  and  <span class="math">w = 2</span>  for  <span class="math">138 \\leq n \\leq 3841</span> .</p>

    <p class="text-gray-300">If  <span class="math">w = 1</span> , the NAF leads to better performance as long as  <span class="math">n &amp;gt; 35</span> , if  <span class="math">w = 2</span>  the NAF will always yield a better algorithm. However, if  <span class="math">w = 3</span> , the much larger constant term in the complexity when using the NAF has a price: for  <span class="math">n \\leq 7264</span>  it is better to use the unsigned binary representation.</p>

    <p class="text-gray-300">Remark 4.3 As already mentioned, the algorithms of Reitwiesner and Solinas recode the exponents right-to-left, so extra storage must be reserved for the recoded representations. There exists an alternative to the NAF with the same Hamming weight and which can be computed from left to right [17] by a simple algorithm. However this representation dispenses with the non-adjacency property, which has a very negative impact on memory usage. For instance for  <span class="math">w = d = 2</span>  the set of precomputations  <span class="math">\\mathcal{E}</span>  consists of the values  <span class="math">g_1^a g_2^b</span>  with either  <span class="math">0 &amp;lt; a \\leq 3</span>  and  <span class="math">-3 \\leq b \\leq 3</span> , at least one of  <span class="math">a, b</span>  odd or  <span class="math">a = 0</span>  and  <span class="math">b = 1</span>  or 3, a total of 20 values instead of 8 or 12. Therefore both the total memory usage of Algorithm 2.2 combined with this recoding and its running time would be worse than the variants we analysed. For this reason it should not be considered.</p>

    <p class="text-gray-300">A multi-exponentiation algorithm called interleaved exponentiation has been described by Möller [23]. It is better understood in terms of exponent recording, and it is nothing but Algorithm 2.1 applied to a different representation of the exponents. Suppose that the exponents  <span class="math">e_1, \\ldots, e_d</span>  are written as</p>

    <div class="my-4 text-center"><span class="math-block">e _ {i} = \\sum_ {j = 0} ^ {n - 1} e _ {i, j} 2 ^ {j} \\tag {6}</span></div>

    <p class="text-gray-300">where the coefficients  <span class="math">e_{i,j}</span>  are allowed to vary in a set larger than  <span class="math">\\{0, \\pm 1\\}</span> . Then the following generalization of the left-to-right exponentiation algorithm computes  <span class="math">x := \\prod_{i=1}^{d} g_i^{e_i}</span> .</p>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <p class="text-gray-300">Algorithm 4.4 Left-to-right interleaved multi-exponentiation INPUT: Group elements  <span class="math">g_{1},\\ldots ,g_{d}</span>  of which some powers have been precomputed and exponents  <span class="math">e_i = \\sum_{j = 0}^{n - 1}e_{i,j}2^j</span> OUTPUT:  <span class="math">\\prod_{i = 1}^{d}g_{i}^{e_{i}}</span></p>

    <p class="text-gray-300">Step 1.  <span class="math">x\\gets 1\\in G</span></p>

    <p class="text-gray-300">Step 2. for  <span class="math">j = n - 1 \\ldots 0</span>  do { (a)  <span class="math">x \\gets x^2</span>  [Skip at first iteration] for  <span class="math">i = 1 \\ldots d</span>  do { (b) if  <span class="math">e_{i,j} \\neq 0</span>  then  <span class="math">x \\gets x \\cdot g_i^{e_{i,j}}</span>  } }</p>

    <p class="text-gray-300">Step 3. return  <span class="math">x</span></p>

    <p class="text-gray-300">This algorithm becomes efficient if a careful choice of the recoding of the exponents is done, balancing a low density of the representations with the work done in the precomputation stage: this should allow Step 2 (b) to be done always with a table access and a single multiplication (or multiplication with the inverse). We see now four candidates for the representations.</p>

    <p class="text-gray-300">A first possibility is offered by radix- <span class="math">r</span>  recoding where  <span class="math">r = 2^w</span>  is a power of 2. We embed this representation into a redundant base 2: If  <span class="math">e = \\sum_{i=0}^{n-1} b_i 2^i</span>  we put</p>

    <div class="my-4 text-center"><span class="math-block">b _ {k} ^ {\\prime} = \\left\\{ \\begin{array}{l l} \\sum_ {\\ell = 0} ^ {w - 1} b _ {w k + \\ell} 2 ^ {\\ell} &amp;amp; \\text {i f} k \\equiv 0 (\\bmod w) \\\\ 0 &amp;amp; \\text {o t h e r w i s e}, \\end{array} \\right.</span></div>

    <p class="text-gray-300">for  <span class="math">0 \\leq k \\leq n - 1</span>  and assuming  <span class="math">b_{i} = 0</span>  for  <span class="math">i \\geq n</span> , then consider  <span class="math">e = \\sum_{k=0}^{\\lceil n/w\\rceil - 1} b_{kw}&#x27; 2^{kw} = \\sum_{i=0}^{n-1} b_{i}&#x27; 2^{i}</span> . The last representation is that which is actually used to represent the exponents in Algorithm 4.4. This is very easy to implement, for exponents are scanned online  <span class="math">w</span>  bits at a time and all blocks of multiplications are done only every  <span class="math">w</span>  squarings. The density of a radix- <span class="math">r</span>  representation is  <span class="math">\\frac{r-1}{r}</span>  and so Algorithm 4.4 requires about  <span class="math">\\frac{dn}{w} \\frac{2^{w}-1}{2^{w}}</span>  multiplications and  <span class="math">n</span>  squarings.</p>

    <p class="text-gray-300">A better alternative, assuming free inversion, can be the generalized non-adjacent form, or GNAF, which is a signed radix- <span class="math">r</span>  recoding. A radix- <span class="math">r</span>  GNAF of the integer  <span class="math">e</span>  is a representation  <span class="math">e = \\sum_{i=0}^{n-1} b_i r^i</span>  with  <span class="math">-r &amp;lt; b_i &amp;lt; r</span>  and satisfying the following two properties</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(GNAF-1)  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{i} + b_{i + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; r<span class="math">  for all  </span>i$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(GNAF-2) If  <span class="math">b_{i}b_{i + 1} &amp;lt; 0</span>  then  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{i + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This form coincides with the definition of the NAF when  <span class="math">r = 2</span> . Moreover, as for the NAF, it can be proven that this form is unique and has minimal Hamming weight among signed radix- <span class="math">r</span>  representations [7]. Here we consider only the case that  <span class="math">r</span>  is a power of 2 and we embed the representation into a redundant base 2 one as in the previous paragraph.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>COMPARISONS</li>

    </ol>

    <p class="text-gray-300">Using the GNAF the density of the nonzero digits decreases from <span class="math">\\frac{r-1}{r}</span> of the radix-<span class="math">r</span> representation to <span class="math">\\frac{r-1}{r+1}</span>, hence it leads to a multi-exponentiation algorithm requiring <span class="math">\\frac{dn}{w}\\frac{2^{w}-1}{2^{w}+1}</span> multiplications and about <span class="math">n</span> squarings to compute the product of <span class="math">d</span> powers with <span class="math">n</span>-bit exponents.</p>

    <p class="text-gray-300">The GNAF is recoded right-to-left, and thus cannot be used online.</p>

    <p class="text-gray-300">There exists a left-to-right recoding with the same weight as the GNAF <em>[18]</em>.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">4.2.3 Width-<span class="math">w</span> left-to-right sliding windows</h4>

    <p class="text-gray-300">One can let a sliding window of size <span class="math">w</span> scan right-to-left the binary representation of an integer, skipping zeros and reading the value contained in the window only if a bit equal to <span class="math">1</span> is found. This gives a recoding <span class="math">e=\\sum_{j=0}^{n-1}b_{j}\\,2^{j}</span> where the coefficients <span class="math">b_{j}</span> are either zero or odd, satisfy <span class="math">0\\leq b_{j}&amp;lt;2^{w}</span> and of any <span class="math">w</span> consecutive of them at most one is nonzero. It is very well known that this representation has density <span class="math">1/(w+1)</span>.</p>

    <p class="text-gray-300">We want however a <em>left-to-right sliding window algorithm</em>. In the most naïve way it produces a recoding where the coefficients <span class="math">b_{j}</span> are either zero or and satisfy <span class="math">2^{w-1}\\leq b_{j}&amp;lt;2^{w}</span>, except perhaps for the least significant nonzero coefficient. Clearly this representation has the same expected density <span class="math">1/(w+1)</span>. If however we do not include always <span class="math">w</span> bits in the window but <em>only as many bit as possible as long as they are at most <span class="math">w</span> and not only the most significant one but also the least significant one is <span class="math">1</span></em>, we get a recoding where the <span class="math">b_{j}</span> are zero or odd and satisfy <span class="math">0\\leq b_{j}&amp;lt;2^{w}</span> and with the same weight as before. Note that two nonzero coefficients need no longer to be separated by at least <span class="math">w-1</span> zero coefficients. We call this recoding the <em>width <span class="math">w</span> sliding window recoding</em>, or <span class="math">w</span>SWR for short. It can be used online but some care is required in the implementation.</p>

    <p class="text-gray-300">The <span class="math">w</span>SWR is better than radix-<span class="math">2^{w}</span> as long as <span class="math">w&amp;gt;1</span> (and equal if <span class="math">w=1</span>) and also better than the GNAF if <span class="math">w\\geq 3</span>. Moreover only about a half of the elements need to be precomputed compared to those needed for the radix-<span class="math">2^{w}</span> and GNAF for the same <span class="math">w</span>.</p>

    <p class="text-gray-300">The result is that the <span class="math">w</span>SWR is preferable over using the radix-<span class="math">2^{w}</span> form or the GNAF for the optimal value of <span class="math">w</span> for a given exponent size (which is either <span class="math">4</span> or <span class="math">5</span> for <span class="math">160\\leq n\\leq 256</span>).</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">4.2.4 The flexible window exponentiation algorithm and the <span class="math">w</span>NAF</h4>

    <p class="text-gray-300">Cohen’s <em>flexible window</em> exponentiation algorithm <em>[10, 9]</em> which was also proposed independently by Solinas <em>[28, 29]</em> consists in the application of Algorithm 4.4 with <span class="math">d=1</span> to the <span class="math">w</span>NAF of the exponent. The <span class="math">w</span>NAF of the integer <span class="math">e</span> is a representation <span class="math">e=\\sum_{j=0}^{n-1}b_{j}\\,2^{j}</span> where the integer coefficients <span class="math">b_{j}</span> satisfy the following two conditions:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Either <span class="math">b_{j}=0</span> or <span class="math">b_{j}</span> is odd and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{w}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Of any <span class="math">w+1</span> consecutive coefficients <span class="math">b_{j+w},\\ldots,b_{j}</span> at most one is nonzero.</li>

    </ul>

    <p class="text-gray-300">It is also called <em>width</em>-<span class="math">(w+1)</span> NAF and it must not be confused with the GNAF. The special case <span class="math">w=1</span> is the usual NAF. Every integer admits a <span class="math">w</span>NAF which is uniquely determined. In the cited papers by Solinas and by Cohen et al. there are algorithms for computing it. The density of the representation is <span class="math">1/(w+2)</span>. This immediately leads to an exponentiation algorithm requiring about <span class="math">n/(w+2)</span> multiplications for an <span class="math">n</span>-bit exponent. The <span class="math">w</span>NAF recoding algorithm works right-to-left, therefore it cannot be used online.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 4.5</h6>

    <p class="text-gray-300">In general the recoding of choice for Algorithm 4.4 is the wSWR if inversion is expensive, and the wNAF otherwise, because of their better densities and smaller precomputation tables</p>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 2.2 (base-2) #E and #Ops (w)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 4.4 (wSWR) #E and #Ops (w)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 2.2 (base-2) #E and #Ops (w)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 4.4 (wSWR) #E and #Ops (w)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">33 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">35 (w=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">52 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">53 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">36.43 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">39 (w=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">59 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">59 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">42.43 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">47 (w=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">73 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">71 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">50.14 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">53.40 (w=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">87 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">83 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">63.86 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">66.20 (w=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">111.86 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">107 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">77.57 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">79 (w=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">126.67 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">131 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">91.28 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">91.80 (w=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">141.60 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">138.20 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">111.86 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">111 (w=4)</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">164 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">167 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">118.71 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">117.40 (w=4)</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">171.47 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">176.60 (w=4)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Complexity of multi-exponentiation using unsigned representations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2.2 (NAF) #E and #Ops (w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2.2 (JSF) #E and #Ops (w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 4.4 (wNAF) #E and #Ops (w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">27.81 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">29 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">29.40 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">31.07 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">33 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">32.60 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">37.59 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">39 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">39 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">44.11 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">45 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">45.40 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">57.15 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">57 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">57.66 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">70.19 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">69 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">68.33 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">83.22 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">81 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">79 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">102.78 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">99 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">95 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">109.30 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">105 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">100.33 (w=4)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Complexity of multi-exponentiation using signed representations,  <span class="math">d = 2</span></p>

    <p class="text-gray-300">with respect to the simpler radix-r form and GNAF. The wSWR can be a good backup choice for Algorithm 4.4 even if inversion is free if memory usage is critical. For the corresponding penalty hit see the tables in the next subsection.</p>

    <p class="text-gray-300">If inversion in the group is not for free, we recode online the exponents as  <span class="math">w</span>  SWR's in Algorithm 4.4. One requires then  <span class="math">d</span>  squarings and  <span class="math">d(2^{w - 1} - 1)</span>  multiplications in the precomputation stage and  <span class="math">\\frac{dn}{w + 1} - 1</span>  multiplications and about  <span class="math">n - 1</span>  squarings in the main loop (note that the first multiplication is just a variable assignment). In Table 4 we add the total number of operations in the precomputation stage to the number of multiplications in the main loop of the algorithms. (This is the same performance parameter used before.) In each case the value of  <span class="math">w</span>  which minimizes the running time is chosen.</p>

    <p class="text-gray-300">If inversion in the group is cheap, we write the exponents as  <span class="math">w</span>  NAF's. Algorithm 4.4 needs  <span class="math">d</span>  squarings and  <span class="math">d(2^{w - 1} - 1)</span>  multiplications for the precomputations and  <span class="math">\\frac{dn}{w + 2} - 1</span>  multiplications and about  <span class="math">n</span>  squarings in the main loop. Tables 5 and 6 collect the complexity data for these algorithms which exploit signed representations in the cases  <span class="math">d = 2</span>  and  <span class="math">d = 3</span>  respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>APPLICATIONS</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2.2 (NAF) #E and #Ops (w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 4.4 (wNAF) #E and #Ops (w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">48.40 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">44.60 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">54.03 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">49.40 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">65.29 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">59 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">76.55 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">68.60 (w=3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">99.07 (w=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">87 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">115.57 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">103 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">129.69 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">119 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">150.86 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">143 (w=4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">157.91 (w=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">151 (w=4)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Complexity of multi-exponentiation using signed representations,  <span class="math">d = 3</span></p>

    <p class="text-gray-300">Remarks 4.6 (1) Only implementation can decide which of the algorithms is fastest for a particular purpose if the number of operations is similar. In these cases memory usage can be the decisive factor. In the case of double exponentiations with unsigned representations Algorithm 2.2 seems the best choice, either yielding better performance than Algorithm 4.4 or yielding similar performance while requiring less memory.</p>

    <p class="text-gray-300">(2) Algorithm 2.2 with the NAF or with the JSF seems to be preferable to Algorithm 4.4 for double exponentiations with exponents from 160 to 256 bits in memory constrained environments. In particular the use of the NAF reduces considerably the number of required precomputations, saving RAM and, in the case of one fixed base, also ROM. The use of the NAF is undisputably preferable also for smaller bit sizes, i.e. 80 to 128 bits, and this gives the method of choice for implementing single exponentiations in groups with an automorphism of degree 2, such as trace zero varieties or XTR subgroups as described in Section 5. (3) For triple exponentiations Algorithm 4.4 seems always preferable with unsigned representations (using the wSWR) and  <span class="math">n \\geq 128</span>  or with signed representations (using the wNAF).</p>

    <p class="text-gray-300">In this section we show a few applications of the above multi-exponentiation algorithms.</p>

    <p class="text-gray-300">Here, as well as in the next subsection, we shall use additive terminology (and shall speak, for example, of a scalar product  <span class="math">r \\cdot P</span>  instead of an exponentiation  <span class="math">P^r</span> ).</p>

    <p class="text-gray-300">The natural application of Algorithm 2.2 is to electronic signature schemes based on the discrete logarithm problem in the rational point group of an elliptic curve (ecc) or of the Jacobian variety of an hyperelliptic curve (hec) over a finite field. Hence  <span class="math">d = 2</span>  and for the current applications (where exponent sizes are between 160 and 256 bits) we have already seen that the optimal value of the parameter is  <span class="math">w = 2</span> .</p>

    <p class="text-gray-300">In the ecc case we observe that mixed coordinate systems can be used exactly as in [11], as we have sequences of repeated doublings (always at least two of them) alternated with single additions of points from a precomputed table. We compute directly the double scalar product, whereas Cohen et al. compute the two scalar products separately and then they add the results: For the fixed base scalar</p>

    <p class="text-gray-300">multiplication they use essentially a comb method and for the variable base scalar product the flexible window algorithm (see § 4.2.4). For brevity we call the resulting method the CMO method.</p>

    <p class="text-gray-300">We work out the costs in the case of an elliptic curve defined over a prime field of about <span class="math">2^{n}</span> elements, where <span class="math">n=160</span> and <span class="math">240</span>. We shall denote by <span class="math">M</span>, <span class="math">S</span> and <span class="math">I</span> the timings of a multiplication, of a squaring and of an inversion respectively in the base field of our curve.</p>

    <p class="text-gray-300">In <em>[11]</em> five coordinate systems for elliptic curves are described, namely affine (<span class="math">\\mathcal{A}</span>) projective (<span class="math">\\mathcal{P}</span>), jacobian (<span class="math">\\mathcal{J}</span>), Chudnovsky jacobian (<span class="math">\\mathcal{J}^{c}</span>) and modified jacobian (<span class="math">\\mathcal{J}^{m}</span>) coordinates. Adding points in coordinate systems <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> yielding a result in system <span class="math">\\mathcal{C}_{3}</span> is denoted by <span class="math">\\mathcal{C}_{1}+\\mathcal{C}_{2}=\\mathcal{C}_{3}</span>, doubling is notated as <span class="math">2\\mathcal{C}_{1}=\\mathcal{C}_{2}</span>. If the coordinate systems are the same one writes simply <span class="math">\\mathcal{C}_{1}+\\mathcal{C}_{1}</span> and <span class="math">2\\mathcal{C}_{1}</span>. Timings are denoted by <span class="math">t(\\cdots)</span>. The gist is that all these operations have different costs (explicitly given in the cited paper), so a different system can be selected for each operation. Three coodinate systems are employed: the first system (<span class="math">\\mathcal{C}_{1}</span>) is used for all the doublings but the final one before an addition with a precomputed point, the second one (<span class="math">\\mathcal{C}_{2}</span>) for the result of a final doubling, and the third one (<span class="math">\\mathcal{C}_{3}</span>) for the precomputed points. Therefore, if Algorithm 2 requires <span class="math">N_{+}</span> additions and <span class="math">N_{2}</span> doublings, its total cost is</p>

    <p class="text-gray-300"><span class="math">(N_{2}-N_{+})t(2\\mathcal{C}_{1})+N_{+}\\big{(}t(2\\mathcal{C}_{1}=\\mathcal{C}_{2})+t(\\mathcal{C}_{2}+\\mathcal{C}_{3}=\\mathcal{C}_{1})\\big{)}+t_{p}</span></p>

    <p class="text-gray-300">where <span class="math">t_{p}</span> is the cost of the precomputations. Since doublings in <span class="math">\\mathcal{C}_{1}</span> are the most frequent operation, <span class="math">\\mathcal{C}_{1}</span> should be the system with fastest doubling, i.e. <span class="math">\\mathcal{C}_{1}=\\mathcal{J}^{m}</span> with cost <span class="math">t(2\\mathcal{J}^{m})=4M+4S</span>. The result of a final doubling is done in <span class="math">\\mathcal{C}_{2}=\\mathcal{J}</span>, and <span class="math">t(2\\mathcal{J}^{m}=\\mathcal{J})=3M+4S</span>.</p>

    <p class="text-gray-300">Now we consider two possible choices for <span class="math">\\mathcal{C}</span>: <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{J}^{c}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{C}_{3}=\\mathcal{A}</span>, all additions with a precomputed point are as fast as possible: <span class="math">t(\\mathcal{J}+\\mathcal{A}=\\mathcal{J}^{m})=9M+5S</span>. The total running-time is</p>

    <p class="text-gray-300"><span class="math">N_{2}(4M+4S)+N_{+}(8M+5S)+t_{p}(\\mathcal{A}).</span></p>

    <p class="text-gray-300">We proceed to estimate <span class="math">t_{p}=t_{p}(\\mathcal{A})</span>. Since <span class="math">g_{1}</span> is the fixed point of the system, we assume that it is given in <span class="math">\\mathcal{A}</span>, whereas <span class="math">g_{2}</span>, belonging to the signature to be verified, is in <span class="math">\\mathcal{P}</span>. In the NAF (resp. JSF) case we have <span class="math">4</span> (resp. <span class="math">6</span>) additions of type <span class="math">\\mathcal{A}+\\mathcal{J}=\\mathcal{P}</span>, and <span class="math">2</span> (resp. <span class="math">4</span>) of type <span class="math">\\mathcal{P}+\\mathcal{P}</span>. Then we convert the results to affine coordinates, which can be done naïvely by inverting <span class="math">7</span> (resp. <span class="math">11</span>) field elements and performing <span class="math">14</span> (resp. <span class="math">22</span>) multiplications. Using Montgomery’s trick, one can invert <span class="math">m</span> numbers by one inversion and <span class="math">3(m-1)</span> multiplications. So in the NAF case the total precomputation cost is <span class="math">t_{p}(\\mathcal{A},\\mathrm{NAF})=4\\,t(\\mathcal{A}+\\mathcal{P}=\\mathcal{P})+2\\,t(\\mathcal{P}+\\mathcal{P})+(14+3\\cdot 6)\\,M+I=4\\,(8M+2S)+2\\,(12M+2S)+32M+I=88M+12S+I</span> whereas in the JSF case it is <span class="math">t_{p}(\\mathcal{A},\\mathrm{JSF})=148M+20S+I</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{C}_{3}=\\mathcal{J}^{c}</span>, we have <span class="math">t(\\mathcal{J}+\\mathcal{J}^{c}=\\mathcal{J}^{m})=12M+5S</span> and the total running-time is</p>

    <p class="text-gray-300"><span class="math">N_{2}(4M+4S)+N_{+}(11M+5S)+t_{p}(\\mathcal{J}^{c}).</span></p>

    <p class="text-gray-300">To estimate <span class="math">t_{p}(\\mathcal{J}^{c})</span> we first have to convert <span class="math">g_{2}</span> from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{J}^{c}</span>, requiring <span class="math">1M+1S</span>. Then in the NAF (resp. JSF) case we have <span class="math">4</span> (resp. <span class="math">6</span>) additions of type <span class="math">\\mathcal{A}+\\mathcal{J}^{c}=\\mathcal{J}^{c}</span>, and <span class="math">2</span> (resp. <span class="math">4</span>) of type <span class="math">\\mathcal{J}^{c}+\\mathcal{J}^{c}</span>. The total precomputation costs are <span class="math">t_{p}(\\mathcal{J}^{c},\\mathrm{NAF})=(1M+1S)+4\\,(8M+3S)+2\\,(11M+3S)=55M+19S</span> and <span class="math">t_{p}(\\mathcal{J}^{c},\\mathrm{JSF})=(1M+1S)+6\\,(8M+3S)+4\\,(11M+3S)=93M+31S</span>.</p>

    <p class="text-gray-300">Algorithm 2 with the NAF has <span class="math">N_{2}=n-\\frac{10}{9}</span> and <span class="math">N_{+}=\\frac{11}{27}n-1</span> (cfr. Theorem 3.6). With the JSF <span class="math">N_{2}=n-\\frac{3}{2}</span> and <span class="math">N_{+}=\\frac{3}{8}n-1</span>.</p>

    <p class="text-gray-300">In what follows we shall assume <span class="math">S\\approx 0.8M</span>, which is confirmed by experience.</p>

    <p class="text-gray-300">The scalar multiplication of the variable point in the CMO method for <span class="math">n=160</span> and <span class="math">n=240</span> has costs <span class="math">1488.4M+4I</span> and <span class="math">2228+4I</span> if the coordinates <span class="math">(\\mathcal{J}^{m},\\mathcal{J},\\mathcal{A})</span> are used, and <span class="math">1610.2M</span> and <span class="math">2400M</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>APPLICATIONS</li>

    </ol>

    <p class="text-gray-300">respectively with the coordinates  <span class="math">(\\mathcal{J}^m,\\mathcal{J},\\mathcal{J}^c)</span> . The cost of the scalar multiplication of the fixed point is  <span class="math">454.4M</span>  and  <span class="math">620.8M</span>  in the cases  <span class="math">n = 160</span>  and 240 respectively. We have computed these values by adapting their comb algorithm also to  <span class="math">n = 240</span>  (in which case it requires a precomputed table of 93 elements), assuming that the precomputed table is in  <span class="math">\\mathcal{A}</span> , and computing the results in  <span class="math">\\mathcal{J}</span> . For  <span class="math">n = 160</span>  there are 15 doublings  <span class="math">(2\\mathcal{J})</span>  and 31 additions  <span class="math">(\\mathcal{J} + \\mathcal{A} = \\mathcal{J})</span> . If  <span class="math">n = 240</span>  the doublings remain 15 and the additions increase to 47. Note that our cost for  <span class="math">n = 160</span>  is better than the value (474) stated in [10]. A further addition in jacobian coordinates yielding a projective result is needed, with cost  <span class="math">12M + 2S \\approx 13.6M</span> .</p>

    <p class="text-gray-300">Upon putting all pieces together, we get the results of Table 7.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Coordinate systems</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2.2 (NAF)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2.2 (JSF)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CMO method</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">(Jm, J, A) (Jm, J, Jc)</td>

            <td class="px-3 py-2 border-b border-gray-700">2011.82M + I 2177.03M</td>

            <td class="px-3 py-2 border-b border-gray-700">2013.2M + I 2144M</td>

            <td class="px-3 py-2 border-b border-gray-700">1956.4M + 4I 2078.2M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">(Jm, J, A) (Jm, J, Jc)</td>

            <td class="px-3 py-2 border-b border-gray-700">2978.93M + I 3256.86M</td>

            <td class="px-3 py-2 border-b border-gray-700">2949.2 + IM 3170M</td>

            <td class="px-3 py-2 border-b border-gray-700">2862.4M + 4I 3034.4M</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7: Comparison of double scalar multiplication methods on ecc</p>

    <p class="text-gray-300">Whereas on modern CPUs  <span class="math">I \\approx 20M</span>  for  <span class="math">n = 160</span>  and  <span class="math">I \\approx 40M</span>  for  <span class="math">n = 240</span> , on smart card architectures these values are much worse, even 50 for  <span class="math">n = 160</span>  and 100 for  <span class="math">n = 240</span> , or higher. One sees at once that the different methods have comparable performance. One advantage of our method is that it does not require a table of 62 to 93 fixed precomputed points to be stored in ROM, as in the CMO method, where the cost of computing those points has not been taken into account. The size of such tables varies from 2480 bytes for  <span class="math">n = 160</span>  to 5580 bytes for  <span class="math">n = 240</span> . In the CMO method the fixed base scalar multiplication needs to be reengineered for each exponent range for best performance. This is not necessary with our method. The conclusion is that our method can be used much more efficiently in systems which do not assume a fixed point (this is optimal if fast system configuration is an issue).</p>

    <p class="text-gray-300">We note that mixed coordinate systems also exist for hyperelliptic curves of genus 2 [22].</p>

    <p class="text-gray-300">Trace zero varieties are abelian varieties constructed essentially by Weil Descent from other varieties, such as elliptic curves [25, 14] or Jacobians of hyperelliptic curves [20, 21].</p>

    <p class="text-gray-300">Construction and security parameters. We start with an elliptic curve (resp. hyperelliptic curve of genus  <span class="math">g</span> ) defined over a prime field  <span class="math">\\mathbb{F}_p</span>  where  <span class="math">p^2</span>  (resp.  <span class="math">p^{2g}</span> ) has the order of magnitude of the desired group size. We also assume that the characteristic polynomial of the Frobenius endomorphism is known. Next, we consider the group of rational points of the elliptic curve (resp. ideal class group) over the finite field extension  <span class="math">\\mathbb{F}_{p^3}</span>  and consider the elements defined by the property that its elements  <span class="math">D</span>  are of trace zero, i.e. they satisfy  <span class="math">(\\sigma^2 + \\sigma + 1)(D) = 0</span> . In general for a genus  <span class="math">g</span>  curve considered over  <span class="math">\\mathbb{F}_{p^d}</span>  the elements of trace zero form a subgroup as they are the kernel of a homomorphism. Therefore they form an abelian subvariety of dimension  <span class="math">g(d - 1)</span> , which is called the trace zero variety. We shall denote it by  <span class="math">G</span>  in the sequel and call  <span class="math">G_0</span>  the subgroup of large prime order  <span class="math">\\ell</span>  in which we actually implement the cryptographic primitives. As usual we want to choose it so that it has a cofactor in  <span class="math">G</span>  as small as possible, i.e.  <span class="math">\\ell \\approx p^{2g}</span> .</p>

    <p class="text-gray-300">It has been noted that for <span class="math">g(d-1)\\leq 4</span> the best attacks known to work on trace zero varieties have complexity <span class="math">O(\\sqrt{G_{0}})</span> <em>[25, 21]</em>.</p>

    <p class="text-gray-300">In what follows we consider only the case where <span class="math">d=3</span> for simplicity.</p>

    <p class="text-gray-300">As we require the same level of security offered by, say, elliptic curves over fields of <span class="math">160</span> bits, we have <span class="math">\\ell\\approx 2^{160}</span> also for trace zero varieties and the field <span class="math">\\mathbb{F}_{p}</span> must satisfy <span class="math">p\\approx 2^{80/g}</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Performance advantages in cryptographic applications.</h4>

    <p class="text-gray-300">The main performance advantages of trace zero varieties come from the fast arithmetic in the extension field (where explicit closed formulae can be given for multiplication and squaring: if furthermore the polynomial defining the extension field is chosen carefully one can even use short convolutions <em>[5, 4]</em>), and by the presence of the automorphism <span class="math">\\sigma</span> of small degree.</p>

    <p class="text-gray-300">The latter fact enables one to speed-up even single exponentiations. Instead of using single scalars to compute <span class="math">r\\cdot D</span> for an ideal class <span class="math">D</span>, one considers a pair <span class="math">(r_{0},r_{1})</span> of scalars bounded by some quantity which is <span class="math">O(p^{g})</span>, and computes the double scalar product <span class="math">r_{0}\\cdot D+r_{1}\\cdot\\sigma(D)</span>. For <span class="math">r_{0}</span> and <span class="math">r_{1}</span> suitably bounded (see <em>[25, 21]</em>) all such double scalar products are distinct. Shamir’s trick can be used and the result is that the number of doublings needed in cryptographic operations is roughly halved with respect to generic elliptic and hyperelliptic curves. Further savings can be achieved by the use of Algorithms 2.2 and 4.4, depending on the parameters.</p>

    <p class="text-gray-300">All the usual cryptographic protocols can be adapted to this new setting, in particular those for key exchange and electronic signatures.</p>

    <p class="text-gray-300">The Frobenius operates on <span class="math">G</span>, and thus on <span class="math">G_{0}</span>, like the scalar multiple by a constant <span class="math">s</span> with <span class="math">s^{2}+s+1\\equiv 0\\mod\\ell</span>. For the verification of signatures, in place of the scalar product <span class="math">r\\cdot D+u\\cdot E</span> one is temped to write <span class="math">r\\equiv r_{0}+r_{1}s</span> and <span class="math">u\\equiv u_{0}+u_{1}s\\mod\\ell</span> and to consider the quadruple product <span class="math">r_{0}\\cdot D+r_{1}\\cdot\\sigma(D)+u_{0}\\cdot E+u_{1}\\cdot\\sigma(E)</span>. The problem is bounding, if possible, the coefficients by <span class="math">kp^{g}</span> where <span class="math">k</span> is a small constant. In the example above we did not have this problem because we started with a pair <span class="math">(r_{0},r_{1})</span>, however for the verification of digital signatures one needs to start with the given value <span class="math">r</span>. To keep the coefficient reasonably bounded can be cumbersome, but we observe that the results in <em>[27, §2 and §5]</em> actually apply to any automorphism of the group with given degree <span class="math">2</span> minimal polynomial. In particular they apply to <span class="math">\\sigma</span> on the trace-zero variety with equation <span class="math">\\sigma^{2}+\\sigma+1=0</span> and a bound <span class="math">O(p^{g})</span> on <span class="math">r_{i},u_{i}</span> holds.</p>

    <p class="text-gray-300">To perform the quadruple exponentiation we suggest the use of Algorithm 4.4 and the <span class="math">w</span>NAF with <span class="math">d=4</span>. Since two of the base divisors are images of <span class="math">D</span> and <span class="math">E</span> under <span class="math">\\sigma</span>, and the cost of the Frobenius is on average approximately 1/25-th of the cost of an addition or of a doubling (this value is obtained heuristically by considering the cases <span class="math">g=1</span> and <span class="math">2</span>), we first precompute the necessary multiples of <span class="math">D</span> and <span class="math">E</span>, then we apply <span class="math">\\sigma</span> to the resulting sets. To determine the optimal value of <span class="math">w</span> we have thus to minimize the number of operations, which is</p>

    <p class="text-gray-300"><span class="math">n+2\\left(1+\\frac{1}{25}\\right)(2^{w-1}-[1=w])+\\frac{4n}{w+2}-1</span></p>

    <p class="text-gray-300">where <span class="math">[\\mathrm{expr}]</span> evaluates to <span class="math">1</span> is <span class="math">\\mathrm{expr}</span> is true, to <span class="math">0</span> otherwise. For <span class="math">n=\\log_{2}(p^{g})\\approx 80</span> the minimum <span class="math">148.97</span> is achieved for <span class="math">w=4</span>. If <span class="math">w=3</span> the amount of operations is <span class="math">151.32</span>. For a minimal trade-off, one can also store only the multiples of <span class="math">D</span> and <span class="math">E</span> and apply the frobenius on-the-fly when multiples of <span class="math">\\sigma(D)</span> or <span class="math">\\sigma(E)</span> are needed.</p>

    <p class="text-gray-300">Let us consider signature verification using a trace zero variety arising from a genus <span class="math">g</span> curve over a finite field of about <span class="math">2^{80/g}</span> elements (so <span class="math">n=80</span>): It may be done with about <span class="math">150</span> group operations. For comparison, using the ECDSA or hyperelliptic curve variants thereof of comparable security requires</p>

    <p class="text-gray-300">minimum of <span class="math">229</span> group operations (see Table 5 with <span class="math">n=160</span> and <span class="math">d=2</span>). Furthermore, one should note that group operations on the trace zero variety are faster than on a elliptic or hyperelliptic curve of comparable size.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">5.3 XTR</h3>

    <p class="text-gray-300">The XTR cryptosystem was initially proposed by Lenstra and Verheul <em>[32]</em> and makes use of the subgroup <span class="math">G</span> of order <span class="math">p^{2}-p+1</span> of the multiplicative group of the cyclotomic extension <span class="math">\\mathbb{F}_{p^{6}}/\\mathbb{F}_{p}</span>. Let <span class="math">g</span> be an element of <span class="math">\\mathbb{F}_{p^{6}}^{\\times}</span> of order <span class="math">q&gt;6</span> dividing <span class="math">p^{2}-p+1</span>. Since <span class="math">q</span> does not divide <span class="math">p^{s}-1</span> for <span class="math">s=1,2,3</span> the subgroup generated by <span class="math">g</span> cannot be embedded in the multiplicative group of any proper subfield of <span class="math">\\mathbb{F}_{p^{6}}</span>. Hence it appears that solving the discrete logarithm problem in <span class="math">\\langle g\\rangle</span> is at least as difficult as solving it in the large field. In the XTR cryptosystem elements from the field <span class="math">\\mathbb{F}_{p^{6}}</span> are replaced by their traces over <span class="math">\\mathbb{F}_{p^{2}}</span> and Lenstra et al. show how one can work only with these – actually with triples of traces – instead of using the original elements from the bigger field. This leads to very efficient arithmetic even though it is definitely not straightforward to port the usual exponentiation algorithms to this new setting. Recently, Lenstra and Stam <em>[31]</em> observed that one can also compute directly in an efficient manner in the field <span class="math">\\mathbb{F}_{p^{6}}</span> by using a suitable representation of the extension. This allows the implementor to use all possible (multi-)exponentiation methods without change.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Independently, Frey suggested a similar idea which we sketch here (the following text is taken, abridged, from <em>[3]</em>). Let <span class="math">\\sigma</span> be the Frobenius map <span class="math">x\\mapsto x^{p}</span>. One observes at once that for <span class="math">z\\in G</span> the Frobenius satisfies <span class="math">z^{\\sigma^{2}-\\sigma+1}=1</span> and that <span class="math">G</span> is the intersection of the two trace zero varieties relative to <em>both</em> intermediate extensions, so that the elements satisfy <span class="math">\\sigma^{3}+1=0</span> and also <span class="math">\\sigma^{4}+\\sigma^{2}+1=0</span>. The first relation immediately gives a simple inversion formula: <span class="math">z^{-1}=\\sigma^{3}(z)</span>. The field <span class="math">\\mathbb{F}_{p^{6}}</span> is then constructed as the composite of two extensions of <span class="math">\\mathbb{F}_{p}</span>: the first is <span class="math">\\mathbb{F}_{p^{3}}</span> and the second is <span class="math">\\mathbb{F}_{p^{2}}=\\mathbb{F}_{p}(\\sqrt{\\delta})</span> where <span class="math">\\delta\\in\\mathbb{F}_{p}\\setminus(\\mathbb{F}_{p})^{2}</span>. Ideally $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> should be small (for instance </span>\\delta=-1<span class="math">: to allow this one needs </span>-1\\in\\mathbb{F}_{p}\\setminus(\\mathbb{F}_{p})^{2}<span class="math"> and therefore </span>p\\equiv 3\\bmod 4<span class="math">). Also </span>\\delta=2$ is a good option.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">z\\in G</span> write <span class="math">z=x+y\\sqrt{\\delta}</span> where <span class="math">x,y\\in\\mathbb{F}_{p^{3}}</span>. The map <span class="math">\\sigma^{3}</span> generates the group <span class="math">\\mathrm{Gal}(\\mathbb{F}_{p^{6}}/\\mathbb{F}_{p^{3}})</span> of order <span class="math">2</span>, hence <span class="math">\\sigma^{3}(\\sqrt{\\delta})=-\\sqrt{\\delta}</span> and <span class="math">z^{-1}=x-y\\sqrt{\\delta}</span> is essentially for free.</p>

    <p class="text-gray-300"><em>One can then apply the considerations made about trace zero varieties to XTR subgroups. In particular, single and double exponentiations found in cryptographic protocols can be transformed into double and quadruple exponentiations with exponents of halved bit length.</em></p>

    <h2 id="sec-34" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] ANSI X9.62, <em>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</em>. 1999.</li>

      <li>[2] S. Arno and F.S. Wheeler, <em>Signed digit representations of minimal Hamming weight</em>. IEEE Transactions on Computers 42 (1993), 1007–1010.</li>

      <li>[3] R. Avanzi and T. Lange, <em>Überlegungen zu XTR</em>. Unpublished manuscript.</li>

      <li>[4] R. Avanzi and P. Mihăilescu, <em>Generic efficient arithmetic algorithms for Processor Adequate Finite Fields</em>. A manuscript.</li>

      <li>[5] R.E. Blahut, <em>Fast algorithms for digital signal processing</em>. Addison-Wesley, Reading, MA, 1985.</li>

      <li>[6] A.D. Booth, <em>A signed binary multiplication technique</em>. The Quarterly Journal of Mechanics and Applied Mathematics 4 (1951), 236–240.</li>

      <li>[7] W.E. Clark and J.J. Liang, <em>On arithmetic weight for a general radix representation of integers</em>. IEEE Transactions on Information Theory IT-19 (1973), 823–826.</li>

      <li>[8] B.W. Char, K.O. Geddes, G.H. Gonnet, B.L. Leong, M.B. Monagan and S.M. Watt, <em>Maple V Language Reference Manual</em>. Springer, 1991.</li>

    </ul>

    <p class="text-gray-300">ROBERTO M. AVANZI</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] H. Cohen, Analysis of the flexible window powering algorithm. Preprint.</li>

    </ul>

    <p class="text-gray-300">Available from: http://www.math.u-bordeaux.fr/~cohen/</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[10] H. Cohen, A. Miyaji and T. Ono, Efficient elliptic curve exponentiation. In Proceedings ICICS’97, Lecture Notes in Computer Science, vol. 1334, Springer-Verlag, 1997, pp. 282–290.</li>

      <li>[11] H. Cohen, A. Miyaji and T. Ono, Efficient elliptic curve exponentiation using mixed coordinates. In Advances in Cryptology – ASIACRYPT ’98 (1998), K. Ohta and D. Pei, Eds., vol. 1514 of Lecture Notes in Computer Science, pp. 51–65.</li>

      <li>[12] T. ElGamal, A public-key cryptosystem and a signature scheme based on discrete logarithms. IEEE Transactions on Information Theory IT-31 (1985), 469-472.</li>

      <li>[13] Ö. Eğecioğlu and Ç. K. Koç. Exponentiation using canonical recoding. Theoretical Computer Science, 129(2):407–417, 1994.</li>

      <li>[14] G. Frey, Applications of arithmetical geometry to cryptographic constructions. In Finite fields and applications (Augsburg, 1999), pages 128–161. Springer, Berlin, 2001.</li>

      <li>[15] R.P. Gallant, R.J. Lambert, S.A. Vanstone, Faster Point Multiplication on Elliptic Curves with Efficient Endomorphisms In Advances in Cryptology – CRYPTO 2001 Proceedings, pp. 190–200, Springer Verlag, 2001.</li>

      <li>[16] P. Gaudry, An algorithm for solving the discrete log problem on hyperelliptic curves. In Advances in Cryptology, Eurocrypt ’2000, vol. 1807 of Lecture Notes in Computer Science, pp. 19–34. Springer-Verlag, 2000.</li>

      <li>[17] M. Joye and S.-M. Yen, Optimal left-to-right binary signed-digit recoding. IEEE Transactions on Computers (49) 7, 740–748 (2000).</li>

      <li>[18] M. Joye and S.-M. Yen, New Minimal Modified Radix-r Representation In Public Key Cryptography – 5th International Workshop on Practice and Theory in Public Key Cryptosystems, PKC 2002, Paris, France, February 2002, D. Naccache and P. Paillier Eds., Lecture Notes in Computer Science, vol 2274, pp. 375–384.</li>

      <li>[19] D. E. Knuth, The art of computer programming. Vol. 2, Seminumerical algorithms, third ed., Addison-Wesley Series in Computer Science and Information Processing. Addison-Wesley, Reading, MA, 1997.</li>

      <li>[20] T. Lange, Efficient Arithmetic on Hyperelliptic Curves. Ph.D. Thesis, Universität Essen, 2001.</li>

      <li>[21] T. Lange, Trace-Zero Subvariety for Cryptosystems. Preprint.</li>

      <li>[22] T. Lange, Weighted Coordinates on Genus 2 Hyperelliptic Curves. Preprint.</li>

    </ul>

    <p class="text-gray-300">See: http://eprint.iacr.org/</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[23] B. Möller, Algorithms for Multi-exponentiation in S. Vaudenay, A.M. Youssef (Eds.): Selected Areas in Cryptography - SAC 2001. Springer-Verlag Lecture Notes in Computer Science vol. 2259, pp. 165-180.</li>

      <li>[24] F. Morain and J. Olivos, Speeding up the computations on an elliptic curve using addition-subtraction chains. RAIRO Inform. Theory 24 (1990), 531–543.</li>

      <li>[25] N. Naumann, Weil-Restriktion abelscher Varietäten. Master’s thesis, Universität Essen, 1999.</li>

      <li>[26] G. W. Reitwiesner. Binary arithmetic. Advances in Computers 1, 231–308, 1960.</li>

      <li>[27] F. Sica, M. Ciet and J.-J. Quisquater, Analysis of the Gallant-Lambert-Vanstone Method based on Efficient Endomorphisms: Elliptic and Hyperelliptic Curves. In Proceedings of Selected Areas of Cryptography 2002 (SAC 2002), St. John’s, Newfoundland (Canada), August 2002. To appear.</li>

      <li>[28] J.A. Solinas, An improved algorithm for arithmetic on a family of elliptic curves. In Advances in Cryptology – CRYPTO ’97 (1997), B. S. Kaliski, Jr., Ed., Lecture Notes in Computer Science vol. 1294, pp. 357–371.</li>

      <li>[29] J.A. Solinas, Efficient arithmetic on Koblitz curves. Designs, Codes and Cryptography 19 (2000), 195–249.</li>

      <li>[30] J.A. Solinas, Low-Weight Binary Representations for Pairs of Integers. Centre for Applied Cryptographic Research, University of Waterloo, Combinatorics and Optimization Research Report CORR 2001-41, 2001. Available from: http://www.cacr.math.uwaterloo.ca/techreports/2001/corr2001-41.ps</li>

      <li>[31] M. Stam and A.K. Lenstra, Efficient subgroup exponentiation in quadratic and sixth degree extensions. In Proceedings of Workshop on Cryptographic Hardware and Embedded Systems CHES 2002, August 13 - 15, 2002, to be published by Springer–Verlag.</li>

      <li>[32] E.R. Verheul and A.K. Lenstra. The XTR public key system. In Advances in Cryptography – Crypto’00, M. Bellare, ed., Lecture Notes in Computer Science vol. 1880, pages 1–19. Springer-Verlag, 2000.</li>

      <li>[33] S.-M. Yen, C.-S. Laih and A.K. Lenstra, Multi-exponentiation. IEE proceedings: computers and digital techniques vol. 141, No. 6, november 1994.</li>

    </ul>`;
---

<BaseLayout title="On multi-exponentiation in cryptography (2002/154)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/154
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
