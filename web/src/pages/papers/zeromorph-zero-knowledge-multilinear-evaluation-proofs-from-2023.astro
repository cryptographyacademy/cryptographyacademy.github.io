---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/917';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zeromorph: Zero-Knowledge Multilinear-Evaluation Proofs from Homomorphic Univariate Commitments';
const AUTHORS_HTML = 'Tohru Kohrita, Patrick Towa';

const CONTENT = `    <p class="text-gray-300">Tohru Kohrita and Patrick Towa</p>

    <p class="text-gray-300">Aztec Labs</p>

    <p class="text-gray-300">Abstract. A multilinear polynomial is a multivariate polynomial of degree at most one in each variable. This paper introduces a new scheme to commit to multilinear polynomials and to later prove evaluations thereof. The scheme exponentially improves on the added prover costs for evaluation proofs to be zero-knowledge.</p>

    <p class="text-gray-300">The construction of the scheme is generic and relies only on the additive homomorphic property of any scheme to commit to univariate polynomials, and on a protocol to prove that committed polynomials satisfy public degree bounds. As the construction requires to check that several committed univariate polynomials do not exceed given, separate bounds, the paper also gives a method to batch executions of any degree-check protocol on homomorphic commitments.</p>

    <p class="text-gray-300">For an <span class="math">n</span>-linear polynomial, the instantiation of the scheme with a hiding version of KZG commitments (Kate, Zaverucha and Goldberg at Asiacrypt 2010) leads to a scheme with an evaluation prover that performs only <span class="math">n + 5</span> extra (i.e., compared to the variant of the same scheme that is not zero-knowledge) first-group operations to achieve the zero-knowledge property. In contrast, previous constructions require an extra <span class="math">2^n</span> multiscalar multiplication. The instantiation does so without any concessions on the other performance measures compared to the state of the art.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1.1 Context</h2>

    <p class="text-gray-300">The sum-check protocol [22] is at the heart of many an efficient proof system for arithmetic-circuit satisfiability [2, 7–9, 11, 17, 26, 27, 29–32]. Given a prime-order field <span class="math">\\mathbb{F}</span>, a public polynomial <span class="math">f</span> in <span class="math">n</span> variables with coefficients in <span class="math">\\mathbb{F}</span> and a set <span class="math">H \\subseteq \\mathbb{F}</span>, the sum-check protocol is a two-party interactive protocol [18] in which a prover shows to a verifier that the sum of the evaluations of <span class="math">f</span> over <span class="math">H^n</span> is a given public value. At the end of the protocol, the verifier must evaluate <span class="math">f</span> at a random point determined by its own challenges. In this sense, the protocol reduces for the verifier the expensive task of computing the sum of the evaluations to the task of evaluating <span class="math">f</span> at a random point.</p>

    <p class="text-gray-300">In the context of arithmetic circuits, a circuit "arithmetisation" (e.g., R1CS, also called quadratic-span programs [16], or Plonk [14]) refers to a set of polynomial equations which are satisfied by the circuit-wire values if and only if the</p>

    <p class="text-gray-300">output of each circuit gate is correctly computed from its inputs. When the sum-check protocol is applied to prove the satisfiability of a circuit arithmetisation, the input <span class="math">f</span> is then just a set of wire values in <span class="math">\\mathbb{F}</span>, and not a polynomial in a given number <span class="math">n</span> of variables together with a domain <span class="math">H</span>. It is then up to the protocol designer to specify <span class="math">H</span> and a polynomial <span class="math">f</span> such that the input values are interpreted as its evaluation over <span class="math">H</span>.</p>

    <p class="text-gray-300">Assume for simplicity that there are <span class="math">N\\coloneqq 2^{n}</span> such values for some positive integer <span class="math">n</span>. When the input values are interpreted as the evaluations over <span class="math">\\{0,1\\}^{n}</span> of a multilinear polynomial <span class="math">f</span> in <span class="math">n</span> variables, Thaler <em>[29]</em> showed that proving the satisfiability of an arithmetic circuit can be reduced via the sum-check protocol, and in <span class="math">O(N)</span> field operations (which is optimal), to proving the evaluations of the input polynomials at random points chosen by the verifier. His techniques are still prevalent in several proof systems for circuit satisfiability with the lowest prover computational costs.</p>

    <p class="text-gray-300">However, evaluating an input polynomial <span class="math">f</span> may still be too expensive in practice when <span class="math">N</span> is large. An alternative is to have the prover initially commit to <span class="math">f</span> with a <em>polynomial-commitment scheme</em>, i.e., the prover sends a commitment to values representing <span class="math">f</span> before the start of the sum-check protocol. At the end of the sum-check execution, instead of having the verifier compute the evaluation at a random point, the prover computes it and shows to the verifier that the evaluation is correct with respect to the commitment to <span class="math">f</span>. If checking an evaluation proof is significantly less expensive than computing the evaluation, this results in significant computational savings for the verifier.</p>

    <p class="text-gray-300">Moreover, if <span class="math">f</span> is committed with a hiding scheme and if the evaluation of <span class="math">f</span> does not reveal any information about the wire values (this generally requires to commit to a randomised version of <span class="math">f</span>), then committing to <span class="math">f</span> also enables circuit-satisfiability proofs that reveal no information beyond the fact that the circuit is satisfiable, i.e., <em>zero-knowledge</em> satisfiability proofs. Naturally, to achieve this property, the evaluation proofs must also reveal no information beyond the claimed evaluations. That is, for the circuit-satisfiability proof to be zero-knowledge, the evaluation proofs of committed polynomial must also be zero-knowledge.</p>

    <p class="text-gray-300">Zero-Knowledge Costs in Practice. There exists a generic technique to turn hitherto known evaluation proofs into zero-knowledge ones, assuming the commitment scheme to be additively homomorphic. It requires the prover to generate and commit to a degree-<span class="math">N</span> masking polynomial with uniformly random coefficients, ahead of the execution of the evaluation protocol. In the case of commitments in prime-order groups, although the prover asymptotically still performs overall a number of group operations linear in <span class="math">N</span>, this additional multi-scalar multiplication to achieve zero-knowledge means at least around a <span class="math">1/3</span> increase in prover group operations for the most efficient schemes. And this must be done for each polynomial of which evaluations are to be proved! Besides, the <span class="math">1/3</span> estimate is conservative as in satisfiability proofs, the coefficients of the committed polynomials are witness data, and therefore usually within a range much smaller than the field size (e.g., 32-bit integers and a field of size</p>

    <p class="text-gray-300">256]*.) One can then, as in sliding-window methods, pre-compute multiplications with all possible scalars in a small range and already have in memory the result for the witness-related multiplications during the online phase; and that would be the case for the multiplications with random scalars with only low probability. It means that pre-computation can generally not be leveraged for random scalars as effectively as for witness scalars.</p>

    <p class="text-gray-300">For large <span class="math">N</span>, e.g., <span class="math">2^{20}</span> as it arises in practice, these extra zero-knowledge costs take their toll on practical performance and may hinder the deployment of privacy-preserving applications in which provers are resource-constrained and short proving time is paramount. It is the case when proofs are executed client-side on a phone or embedded device, e.g., to prove that they have a valid credential from an authority, or to privately prove the correct execution of a program. The latter example arises in the context of privacy layers that complement a consensus network. Therein, a client shows that a new state that it submits to the network results from the correct execution an allowed function without revealing any information beyond that. In such privacy-sensitive applications, short proving time is not just a convenience but actually necessary for the vast majority of users which compute proofs on non-dedicated hardware with average performance.</p>

    <p class="text-gray-300">Before this paper, only the polynomial-commitment scheme derived from the zero-knowledge vSQL <em>[34]</em> polynomial-delegation scheme (i.e., a commitment scheme with committed evaluations) could achieve the zero-knowledge property with a sub-linear extra number (<span class="math">O(\\log N)</span>) of prover group operations. Nonetheless, that scheme entails <span class="math">\\Omega(\\log N)</span> pairing computations for the verifier, which pales in comparison with the state of the art which requires only a constant number of verifier pairing computations. Besides, Section B.2.2 highlights a critical flaw in its proof of soundness and proposes an alternative proof.</p>

    <p class="text-gray-300">In other words, no polynomial-commitment scheme thus far achieves the zero-knowledge property with even a sub-linear supplemental amount of prover group operations without any sacrifice on the other performance criteria.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Contributions</h3>

    <p class="text-gray-300">Multilinear Commitments. This paper proposes (in Section 4) a generic construction of a multilinear commitment scheme from any additively homomorphic scheme to commit to univariate polynomials, as well as any protocol to check degree bounds on committed polynomials. The construction is later instantiated with a hiding version (inspired by a polynomial-delegation scheme due to Zhang et al. <em>[34]</em>) of univariate KZG commitments <em>[20]</em>, and with new techniques (in Section 5.3) to efficiently batch degree-check protocols on KZG commitments. The evaluation proofs of the resulting scheme satisfy the zero-knowledge property with only extra <span class="math">n+5</span> group operations for the prover, i.e., <em>exponentially fewer</em> than the traditional approach with a degree-<span class="math">N</span> uniformly random masking polynomial. Moreover, it does so without any compromise on the other performance metrics compared to the state of the art (except for higher power of the reference-string trapdoor to be committed in the second group).</p>

    <p class="text-gray-300">More precisely, the evaluation proofs are constant-round (five), the prover sends <span class="math">n+3</span> first-group elements and performs at most <span class="math">5N/2+\\log N+2</span> first-group scalar multiplications (in addition to <span class="math">O(N)</span> field operations with small constants). One of the first-group elements sent by the prover and only <span class="math">\\log N+5</span> of the group operations are due to the zero-knowledge property. That is less group operations for the prover than in any scheme in the existing literature of pairing-based schemes, except for multilinear KZG commitments <em>[25]</em> in which the verifier performs <span class="math">n</span> pairing computations. Even a combination of optimised Gemini commitments <em>[8]</em> which use a single point to check consistency of folded polynomials (as in the FRI protocol <em>[1]</em>) with KZG and Shplonk <em>[5]</em> requires at least <span class="math">3N</span> first-group scalar multiplications for the prover; and the evaluation proofs are not even zero-knowledge unless one uses the generic method with a degree-<span class="math">N</span> random hiding polynomial.</p>

    <p class="text-gray-300">As for the verifier, it carries out <span class="math">O(\\log N)</span> field operations, at most <span class="math">2\\log N+2</span> first-group scalar multiplications, a scalar multiplication and an addition in the second second group, and three pairing computations.</p>

    <p class="text-gray-300">Batched Degree Checks. Section 5.4 shows that the techniques used to batch degree checks on KZG commitments in the algebraic-group model can also be used to batch executions of any degree-check protocol (e.g., the FRI proximity test <em>[1]</em>) on univariate commitments that are additively homomorphic. If the degree-check and evaluation protocols are knowledge-sound in the standard model, then so is the batched degree-check protocol. Giving a proof in the standard model means that if the batched protocol is used in a larger protocol where everything else is proved in the standard model, then the whole protocol can be proved secure in the standard model. This generic batching technique is of independent interest and could potentially be useful in future proof-system constructions.</p>

    <p class="text-gray-300">Shift Evaluations. The generic construction in Section 4 also leads to an efficient way to evaluate shifts of polynomials with only a commitment to the original polynomial. If <span class="math">(a_{0},\\ldots,a_{N-1})</span> is the vector of evaluations of a multilinear polynomial <span class="math">f</span>, the shift of <span class="math">f</span> is defined by the vector of its evaluations <span class="math">(a_{1},\\ldots,a_{N-1},a_{0})</span>.</p>

    <p class="text-gray-300">Evaluating polynomial shifts is necessary in Plonk permutation arguments, as well as in some <em>[13]</em> look-up arguments which show that the values of a committed field-element vector appear in a public table. For circuits in which proving input-output relations for sub-parts of a circuit is less expensive than evaluating the sub-circuit, these look-up arguments result in colossal computational savings when computing satisfiability proofs, and all the more so when such sub-circuits are repeated.</p>

    <p class="text-gray-300">Section 7 leverages a simple univariate identity which relates a polynomial to its shift. There is no known multilinear counterpart to this univariate polynomial identity that can be used to evaluate a polynomial shifts with only commitments</p>

    <p class="text-gray-300">to the original polynomial. Section 7 gives a protocol to evaluate shifts of polynomials committed with the generic scheme. Furthermore, as the aforementioned look-up arguments often require evaluating polynomials and their shifts at the same point, Section 8 provides a protocol to batch evaluations of polynomials and polynomial shifts.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 Key Technical Ideas</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}[X_{0},\\ldots,X_{n-1}]^{\\preceq 1}</span> denote the set of multilinear polynomials in <span class="math">n</span> variables. Lemma 2.3.1 shows that a polynomial <span class="math">f\\in\\mathbb{F}[X_{0},\\ldots,X_{n-1}]^{\\preceq 1}</span> satisfies <span class="math">f(\\bm{u})=v</span>, for <span class="math">\\bm{u}=(u_{0},\\ldots,u_{n-1})\\in\\mathbb{F}^{n}</span> and <span class="math">v\\in\\mathbb{F}</span>, if and only if there exist polynomials <span class="math">q_{k}</span> in the first <span class="math">k</span> variables <span class="math">X_{0},\\ldots,X_{k-1}</span> (<span class="math">q_{0}</span> is constant) for all <span class="math">k=0,\\ldots,n-1</span> such that</p>

    <p class="text-gray-300"><span class="math">f-v=\\sum_{k=0}^{n-1}(X_{k}-u_{k})q_{k}.</span></p>

    <p class="text-gray-300">Instead of directly proving the existence of polynomials <span class="math">q_{k}</span> such that this multilinear-polynomial identity is satisfied (which may lead to a <span class="math">n</span> pairing computations for the evaluation verifier), the main idea of the generic construction is to use a linear isomorphism between the vector space of multilinear polynomials in <span class="math">n</span> variables and the space <span class="math">\\mathbb{F}[X]^{&lt;2^{n}}</span> of univariate polynomial of degree at most <span class="math">2^{n}-1</span>. This isomorphism arises from identifying an integer in <span class="math">\\{0,\\ldots,2^{n}-1\\}</span> with its binary representation in <span class="math">\\{0,1\\}^{n}</span> and is defined as</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{n}\\colon\\mathbb{F}[X_{0},\\ldots,X_{n-1}]^{\\preceq 1}</span> <span class="math">\\to\\mathbb{F}[X]^{&lt;2^{n}}</span> <span class="math">\\prod_{j=0}^{n-1}\\left(i_{j}\\cdot X_{j}+(1-i_{j})\\cdot(1-X_{j})\\right)</span> <span class="math">\\mapsto\\left(X^{2^{0}}\\right)^{i_{0}}\\cdots\\left(X^{2^{n-1}}\\right)^{i_{n-1}}.</span></p>

    <p class="text-gray-300">For instance, in case <span class="math">n=2</span>, a polynomial</p>

    <p class="text-gray-300"><span class="math">a_{00}(1-X)(1-Y)+a_{01}X(1-Y)+a_{10}(1-X)Y+a_{11}XY\\in\\mathbb{F}[X,Y]</span></p>

    <p class="text-gray-300">is sent to the univariate polynomial</p>

    <p class="text-gray-300"><span class="math">a_{00}+a_{01}\\left(Z^{2^{0}}\\right)^{1}\\left(Z^{2^{1}}\\right)^{0}+a_{10}\\left(Z^{2^{0}}\\right)^{0}\\left(Z^{2^{1}}\\right)^{1}+a_{11}\\left(Z^{2^{0}}\\right)^{1}\\left(Z^{2^{1}}\\right)^{1}</span> <span class="math">=a_{00}+a_{01}Z+a_{10}Z^{2}+a_{11}Z^{3}\\in\\mathbb{F}[Z].</span></p>

    <p class="text-gray-300">The construction then aims at proving the existence of polynomials <span class="math">q_{k}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{n}(f)-v\\cdot\\mathcal{U}_{n}(1)=\\sum_{k=0}^{n-1}\\mathcal{U}_{n}(X_{k}q_{k})-u_{k}\\cdot\\mathcal{U}_{n}(q_{k}).</span></p>

    <p class="text-gray-300">To commit a polynomial <span class="math">f</span> given as a vector of evaluations over <span class="math">\\{0,1\\}^{n}</span>, the construction uses a univariate commitment scheme to commit to the image of</p>

    <p class="text-gray-300">under <span class="math">\\mathcal{U}_{n}</span>. Various lemmas in Section 2 give expressions for <span class="math">\\mathcal{U}_{n}(1)</span>, <span class="math">\\mathcal{U}_{n}(X_{k})</span>, and for <span class="math">\\mathcal{U}_{n}(X_{k}q_{k})</span> in terms of <span class="math">\\mathcal{U}_{n}(q_{k})</span>. This leads to a univariate polynomial identity that involves <span class="math">\\mathcal{U}_{n}(f)</span> and <span class="math">\\mathcal{U}_{n}(q_{0}),\\ldots,\\mathcal{U}_{n}(q_{n-1})</span>, which in turns leads to the protocol in Section 4. Lemma 2.5.2 shows that the coefficients of <span class="math">\\mathcal{U}_{n}(q_{k})</span> are <span class="math">2^{k}</span>-periodic, so the prover only commits to the sum of its first <span class="math">2^{k}</span> monomials, and proves that the underlying polynomial is of degree at most <span class="math">2^{k}-1</span>.</p>

    <p class="text-gray-300">Section 5 introduces methods to efficiently batch such degree checks. In particular, Section 5.3 gives a technique to batch degree checks so that the verifier only performs a <em>constant</em> number of pairing computations. Note that batching methods with folklore linear combinations would lead to a linear number of pairings. The instantiation of the generic protocol with hiding KZG commitments in Section 6 then uses these batching techniques to improve the efficiency of the protocol.</p>

    <p class="text-gray-300">The protocol (in Section 7) to evaluate the shift <span class="math">f_{\\leftarrow}</span> of a polynomial <span class="math">f\\coloneqq(a_{0},\\ldots,a_{N-1})</span>, given a commitment to <span class="math">f</span> (which is a univariate commitment) is based on the observation that <span class="math">X\\cdot\\mathcal{U}_{n}\\left(f_{\\leftarrow}\\right)=\\mathcal{U}_{n}\\left(f\\right)-a_{0}+a_{0}X^{N}</span>.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.4 Related Work</h3>

    <p class="text-gray-300">Appendix A.5 in HyperPlonk <em>[11]</em> refers to Halo Infinite <em>[6]</em> as a generic method to make evaluation proofs zero-knowledge. However, the transformation in Figure 6 therein is given for univariate polynomials and it is not clear how to immediately adapt to the multivariate case. Moreover, even if that issue were resolved, Theorem 10 claims an overheard of at least <span class="math">O(N)</span> group operations for the prover, so not better than the generic technique previously mentioned.</p>

    <p class="text-gray-300">The evaluation proofs of the straightforward adaption of KZG commitments to multilinear polynomials <em>[25]</em> also consist in proving knowledge of a form of quotients of multi-variate Euclidian division. However, that scheme requires <span class="math">\\log N</span> trapdoors and the verifier must do <span class="math">\\log N+1</span> pairing computations. Besides, the scheme is not zero-knowledge without the generic technique.</p>

    <p class="text-gray-300">The ZK vSQL scheme <em>[34]</em> is similar to the multilinear KZG scheme <em>[25]</em> but can achieve zero-knowledge with only <span class="math">O(\\log N)</span> extra group operations for the prover by leveraging the periodicity in quotient polynomials that Lemma 2.3.1 shows and some pre-computation (otherwise the complexity is <span class="math">\\Omega(N\\log N)</span>). However, it also requires <span class="math">\\Omega(\\log N)</span> pairings for the verifier.</p>

    <p class="text-gray-300">The multilinear commitment scheme used in the Virgo proof system <em>[33]</em> is the first one to exploit univariate commitments and a one-to-one correspondence between multilinear polynomials and univariate polynomials. It then applies the Aurora <em>[3]</em> univariate-sum-check argument to prove evaluations. The prover has to commit to three univariate polynomials and later prove evaluations thereof, and the verifier must evaluate a circuit of size <span class="math">\\Omega(N\\log N)</span> and depth <span class="math">\\Omega(\\log N)</span>. The verifier can delegate this computation to the prover via the GKR protocol <em>[17]</em> and only perform <span class="math">O\\left(\\log^{2}N\\right)</span> field operations (in addition to verifying the three univariate evaluations), but the prover then has to carry out <span class="math">\\Omega(N\\log N)</span> field operations, and the number of rounds increases to <span class="math">\\Omega\\left(\\log^{2}N\\right)</span></p>

    <p class="text-gray-300">Gemini commitments <em>[8]</em> also use a one-to-one correspondence which, in case <span class="math">n=2</span>, sends a multilinear polynomial <span class="math">f=a_{00}+a_{01}X+a_{10}Y+a_{11}XY\\in\\mathbb{F}[X,Y]</span> to <span class="math">a_{00}+a_{01}Z+a_{10}Z^{2}+a_{11}Z^{3}\\in\\mathbb{F}[Z]</span>. Since</p>

    <p class="text-gray-300"><span class="math">v=f(u_{0},u_{1})</span> <span class="math">=(a_{00}+a_{10}u_{1})+u_{0}\\left(a_{01}+a_{11}u_{1}\\right)</span> <span class="math">=\\left<a href="u_{0}">\\left(a_{00}+a_{10}Y\\right)(u_{1})+X\\left(a_{01}+a_{11}Y\\right)(u_{1})\\right</a></span> <span class="math">=\\left(f(u_{0},Y)\\right)(u_{1}),</span></p>

    <p class="text-gray-300">The prover sends a commitment to <span class="math">f(u_{0},Z)=(a_{00}+a_{10}Z)+u_{0}\\left(a_{01}+a_{11}Z\\right)</span>, the verifier checks its consistency with respect to (a commitment to) the image of <span class="math">f</span> under the isomorphism, and the verifier uses a similar consistency check to ensure that <span class="math">f(u_{0},Z)(u_{1})=f(u_{0},u_{1})=v</span> given the commitment to <span class="math">f(u_{0},Z)</span>. The instantiation of the scheme with hiding KZG commitments together with Shplonk evaluation-batching techniques lead to a scheme with an efficiency similar to that of the protocol in Section 6 (even though the prover in the latter scheme performs around <span class="math">N/2</span> less first-group scalar multiplications, which matters in practical implementations with large values of <span class="math">N</span>). The evaluation protocol is however not zero-knowledge unless one applies the standard technique of first committing to a masking polynomial with <span class="math">N</span> random coefficients, i.e., exponentially more extra group operations than the scheme in Section 6.</p>

    <p class="text-gray-300">Bulletproofs <em>[10]</em> and Dory <em>[21]</em> have the advantage of being transparent, but verifying evaluation proofs entails <span class="math">\\Omega(N)</span> scalar multiplications for Bulletproofs (they do not use pairings) and <span class="math">\\Omega(\\log N)</span> operations in the target group for Dory. Evaluation proofs are also not zero-knowledge unless one applies the standard technique with <span class="math">N</span> random field elements.</p>

    <p class="text-gray-300">Table 1 gives a comparison of these schemes with the instantiation from Section 6.</p>

    <p class="text-gray-300">Concerning shift evaluations, HyperPlonk <em>[11]</em> treats shifts only as part of a multivariate version of Plookup <em>[13]</em> whereas Section 7 gives a stand-alone protocol which can be applied in other contexts (e.g., permutation arguments <em>[14]</em>). Yet, Lemma 3.9 in the HyperPlonk paper readily leads to a stand-alone protocol for shift evaluations. It requires two multilinear evaluations of the committed polynomial, and is therefore less efficient than the scheme is Section 7. The scheme in Section 8 also shows how to batch shift evaluations (and even with standard evaluations), which the construction in HyperPlonk does not achieve. HyperPlonk also left as an open problem the task of proving evaluations of shifts of degree greater than one, and the method underpinning the construction in Section 7 readily leads to such proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transp.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mult. KZG [25]</td>

            <td class="px-3 py-2 border-b border-gray-700">(n+1)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">(N-1+N)G1+O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(n+1)·e(·,·)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ZK vSQL [34]</td>

            <td class="px-3 py-2 border-b border-gray-700">(n+1)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">(N+3 log N)G1+O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(n+2)·e(·,·)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Virgo [33] + [34]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)G1+Ω(nN)F</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(N)G1+Ω(nN)F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)e(·,·)+Ω(n2)F</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Gemini [8] + [34] + [5]</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ (n+4)G1+(n+1)F</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ (3N+N)G1+O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(2n+2)G1+2G2+3e(·,·)</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs [10]</td>

            <td class="px-3 py-2 border-b border-gray-700">>2nG1</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ (2N+N)G1+O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(N)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dory [21]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(n)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(√N+N)e(·,·)+O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(n)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Section 6</td>

            <td class="px-3 py-2 border-b border-gray-700">(n+3)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">(5N/2-3+log N+5)G1+O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(2n+2)G1+2G2+3e(·,·)</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Comparison between polynomial-evaluation protocols and the instantiation in Section 6. It is assumed that except for Virgo (for which the authors propose a zero-knowledge version of their scheme), ZK vSQL and the scheme in Section 6, to prove in zero-knowledge that a committed  <span class="math">n</span> -linear ( <span class="math">N := 2^n</span> ) polynomial  <span class="math">f</span>  is such that  <span class="math">f(\\boldsymbol{u}) = v_f</span> , the schemes first let the prover commit to a polynomial  <span class="math">g</span>  with  <span class="math">N</span>  uniformly random coefficients and send  <span class="math">v_g := g(\\boldsymbol{u})</span> , the verifier sends a random challenge  <span class="math">x \\in \\mathbb{F}</span> , and they run the original schemes on  <span class="math">xf + g</span>  and  <span class="math">xv_f + v_g</span> . The part of the prover costs highlighted in bold font and colour denotes the extra group-operations necessary for the proofs to be zero-knowledge. Note that although ZK vSQL only has a sub-linear number of extra group operations for the prover, it requires a logarithmic number of pairings for the verifier.</p>

    <p class="text-gray-300">Fields and Vectors. Throughout this document,  <span class="math">\\mathbb{F}</span>  denotes a field of prime order  <span class="math">p</span> . Vectors are denoted in bold font. For any  <span class="math">n \\in \\mathbb{N}_{\\geq 1}</span> , unless explicitly stated otherwise, the elements of a vector of size  <span class="math">n</span>  are always labelled from 0 to  <span class="math">n - 1</span> . For any  <span class="math">1 \\leq i \\leq n</span> ,  <span class="math">\\boldsymbol{a}_{&amp;lt;i}</span>  denotes  <span class="math">(a_0, \\ldots, a_{i-1})</span> . If  <span class="math">n \\geq 3</span> , for any  <span class="math">0 \\leq i &amp;lt; j &amp;lt; n</span> ,  <span class="math">\\boldsymbol{a}_{[i;j[}</span>  denotes  <span class="math">(a_{i+1}, \\ldots, a_{j-1})</span> . Vectors  <span class="math">\\boldsymbol{a}_{[i;j]}</span> ,  <span class="math">\\boldsymbol{a}_{[i;j[}</span>  and  <span class="math">\\boldsymbol{a}_{[i;j]}</span>  are defined in a similar way.</p>

    <p class="text-gray-300">Polynomials. For  <span class="math">n \\in \\mathbb{N}_{\\geq 1}</span>  and  <span class="math">d \\in \\mathbb{N}</span> ,  <span class="math">\\mathbb{F}[X_0, \\ldots, X_{n-1}]^{\\preceq d}</span>  denotes the set of  <span class="math">n</span> -variate polynomials with coefficients in  <span class="math">\\mathbb{F}</span>  and of individual degree at most  <span class="math">d</span> . In particular,  <span class="math">\\mathbb{F}[X_0, \\ldots, X_{n-1}]^{\\preceq 1}</span>  stands for the set of multilinear polynomials.</p>

    <p class="text-gray-300">Given integers  <span class="math">0 &amp;lt; k \\leq n</span>  and a univariate polynomial  <span class="math">f = \\sum_{i=0}^{n} a_i X^i</span> ,  <span class="math">f^{&amp;lt;k}</span>  denotes the polynomial  <span class="math">\\sum_{i=0}^{k-1} a_i X^i</span> .</p>

    <p class="text-gray-300">Definition 2.1.1. For any  <span class="math">n \\in \\mathbb{N}</span> , let  <span class="math">\\varPhi_{n}(X) \\coloneqq \\sum_{i=0}^{2^{n}-1} X^{i}</span> .</p>

    <p class="text-gray-300">Note that  <span class="math">(X - 1)\\varPhi_{n}(X) = X^{2^{n}} - 1</span> , which implies that evaluations of  <span class="math">\\varPhi_{n}</span>  can be computed in  <span class="math">n + 1</span>  multiplications and 2 additions.</p>

    <p class="text-gray-300">2.2 Conditional Probabilities</p>

    <p class="text-gray-300">The following lemma, proved in Appendix A.1, is used in the analysis of various protocols presented below.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 2.1.</h6>

    <p class="text-gray-300">Let <span class="math">n</span> be a positive integer and <span class="math">E_{0},\\ldots,E_{n-1}</span>, <span class="math">H_{0},\\ldots,H_{n-1}</span> denote probability events in a discrete probability space. Suppose that <span class="math">P[E_{0}\\cup\\cdots\\cup E_{n-1}]&gt;0</span>. Then,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P[H_{0}\\cap\\cdots\\cap H_{n-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{0}\\cup\\cdots\\cup E_{n-1}]\\leq\\sum_{i\\colon P[E_{i}]\\neq 0}P[H_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{i}].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.3 Polynomial Identities</h3>

    <p class="text-gray-300">The following lemma gives the multilinear-polynomial identity that all the evaluation protocols in this paper aim to verify.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Lemma 2.3.1.</h6>

    <p class="text-gray-300">Let <span class="math">n</span> be a positive integer. Consider <span class="math">\\bm{u}\\in\\mathbb{F}^{n}</span> and <span class="math">v\\in\\mathbb{F}</span>. A polynomial <span class="math">f\\in\\mathbb{F}[X_{0},\\ldots,X_{n-1}]^{\\preceq 1}</span> satisfies <span class="math">f(\\bm{u})=v</span> if and only if there exist <span class="math">q_{k}\\in\\mathbb{F}[X_{0},\\ldots,X_{k-1}]^{\\preceq 1}</span> for all <span class="math">0&lt;k&lt;n</span> and <span class="math">q_{0}\\in\\mathbb{F}</span> such that</p>

    <p class="text-gray-300"><span class="math">f-v=\\sum_{k=0}^{n-1}(X_{k}-u_{k})q_{k}.</span></p>

    <p class="text-gray-300">Moreover,</p>

    <p class="text-gray-300"><span class="math">q_{k}=f\\left(\\bm{X}_{&lt;k},u_{k}+1,\\bm{u}_{[k;n]}\\right)-f\\left(\\bm{X}_{&lt;k},\\bm{u}_{[k;n]}\\right).</span></p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If there exist polynomials <span class="math">q_{k}\\in\\mathbb{F}[X_{0},\\ldots,X_{n-1}]</span> (and a fortiori if <span class="math">q_{k}\\in\\mathbb{F}[X_{0},\\ldots,X_{k-1}]^{\\preceq 1}</span>) such that <span class="math">f-v=\\sum_{k=0}^{n-1}(X_{k}-u_{k})q_{k}</span>, then <span class="math">f(\\bm{u})-v=0</span> necessarily.</p>

    <p class="text-gray-300">The converse can be proved by induction on <span class="math">n</span> as follows. If <span class="math">n=1</span>, then there exists <span class="math">q_{0}\\in\\mathbb{F}</span> such that <span class="math">f-v=(X-u_{0})q_{0}</span> by univariate Euclidian division. If <span class="math">n&gt;1</span>, assume the statement to be true for all integers less than <span class="math">n</span>. The surjective map</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}[X_{0},\\ldots,X_{n-1}]\\to\\mathbb{F}[X_{0},\\ldots,X_{n-1}]/(X_{n-1}-u_{n-1})</span></p>

    <p class="text-gray-300">sends <span class="math">f-f(X_{0},\\ldots,X_{n-2},u_{n-1})</span> to <span class="math">0</span>, i.e., it is in the ideal <span class="math">(X_{n-1}-u_{n-1})</span>, or equivalently, there exists a polynomial <span class="math">q_{n-1}\\in\\mathbb{F}[X_{0},\\ldots,X_{n-1}]</span> such that <span class="math">f-f(X_{0},\\ldots,X_{n-2},u_{n-1})=(X_{n-1}-u_{n-1})q_{n-1}</span>. Polynomial <span class="math">q_{n-1}</span> is the quotient of the Euclidian division of <span class="math">f-f(X_{0},\\ldots,X_{n-2},u_{n-1})</span> by <span class="math">(X_{n-1}-u_{n-1})</span> in the ring <span class="math">\\mathbb{F}[X_{0},\\ldots,X_{n-2}][X_{n-1}]</span> (the division successfully terminates because <span class="math">X_{n-1}-u_{n-1}</span> is monic). Besides, as the polynomial <span class="math">f-f(X_{0},\\ldots,X_{n-2},u_{n-1})</span> is of degree at most <span class="math">1</span> in each variable, <span class="math">q_{n-1}</span> must be of degree at most <span class="math">1</span> in <span class="math">X_{0},\\ldots,X_{n-2}</span>, and <span class="math">0</span> in <span class="math">X_{n-1}</span>, i.e., <span class="math">q_{n-1}\\in\\mathbb{F}[X_{0},\\ldots,X_{n-2}]^{\\preceq 1}</span>. Therefore, <span class="math">f=(X_{n-1}-u_{n-1})\\,q_{n-1}+f(X_{0},\\ldots,X_{n-2},u_{n-1})</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">By induction hypothesis, since the evaluation of <span class="math">f(X_0,\\ldots,X_{n-2},u_{n-1})</span> at <span class="math">(u_0,\\ldots,u_{n-2})</span> is <span class="math">v</span>, there exist <span class="math">q_0\\in \\mathbb{F}</span> and <span class="math">q_{k}\\in \\mathbb{F}[X_{0},\\dots,X_{k-1}]^{\\preceq 1}</span> for all <span class="math">k &amp;lt; n-1</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">f (X _ {0}, \\dots , X _ {n - 2}, u _ {n - 1}) - v = \\sum_ {k = 0} ^ {n - 2} (X _ {k} - u _ {k}) q _ {k}.</span></div>

    <p class="text-gray-300">It follows that <span class="math">f - v = \\sum_{k=0}^{n-1}(X_k - u_k)q_k</span>.</p>

    <p class="text-gray-300">It remains to show that <span class="math">q_{k} = f\\left(\\mathbf{X}_{&amp;lt;k}, u_{k} + 1, \\mathbf{u}_{[k; n]}\\right) - f\\left(\\mathbf{X}_{&amp;lt;k}, \\mathbf{u}_{[k; n]}\\right)</span>. Note that</p>

    <div class="my-4 text-center"><span class="math-block">f \\left(X _ {0}, \\dots , X _ {k - 1}, u _ {k} + 1, u _ {k + 1}, \\dots , u _ {n - 1}\\right) - v = \\sum_ {j = 0} ^ {k - 1} \\left(X _ {j} - u _ {j}\\right) q _ {j} + q _ {k}</span></div>

    <p class="text-gray-300">as <span class="math">q_{k}\\in \\mathbb{F}[X_{0},\\ldots ,X_{k - 1}]</span>, and that</p>

    <div class="my-4 text-center"><span class="math-block">f \\left(X _ {0}, \\dots , X _ {k - 1}, u _ {k}, u _ {k + 1}, \\dots , u _ {n - 1}\\right) - v = \\sum_ {j = 0} ^ {k - 1} \\left(X _ {j} - u _ {j}\\right) q _ {j}.</span></div>

    <p class="text-gray-300">These two equalities yield the result.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2.4 Polynomial Interpolation</h2>

    <p class="text-gray-300">This section recalls the definition and properties of Lagrange interpolation for univariate and multilinear polynomials.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.4.1 Univariate Polynomials.</h3>

    <p class="text-gray-300">Let <span class="math">A</span> a subset of <span class="math">\\mathbb{F}</span> of cardinality at least 2. For any <span class="math">a \\in A</span>, the Lagrange interpolation polynomial at <span class="math">a</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">L _ {a, A} (X) := \\prod_ {b \\in A \\backslash \\{a \\}} (X - b) \\cdot (a - b) ^ {- 1}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">L_{a,A}</span> is the unique polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> such that for any </span>b \\in A<span class="math">, </span>L_{a,A}(b) = 1<span class="math"> if </span>b = a$ and 0 otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.4.2 Multilinear Polynomials.</h3>

    <p class="text-gray-300">Let <span class="math">n</span> be a positive integer. For all <span class="math">i =: (i_0, \\ldots, i_{n-1}) \\in \\{0, 1\\}^n</span>, let</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} L _ {\\boldsymbol {i}} = L _ {\\boldsymbol {i}} \\left(X _ {0}, \\dots , X _ {n - 1}\\right) := L _ {i _ {0}, \\{0, 1 \\}} \\left(X _ {0}\\right) \\dots L _ {i _ {n - 1}, \\{0, 1 \\}} \\left(X _ {n - 1}\\right) \\\\ = \\prod_ {j = 0} ^ {n - 1} \\left(i _ {j} \\cdot X _ {j} + (1 - i _ {j}) \\cdot (1 - X _ {j})\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">For all <span class="math">i \\in \\{0,1\\}^n</span>, <span class="math">L_i</span> is the unique multilinear polynomial that evaluates to 1 at <span class="math">i</span> and 0 at any other point on <span class="math">\\{0,1\\}^n</span>. The polynomial family <span class="math">(L_i)_{i \\in \\{0,1\\}^n}</span> constitute the Lagrange basis of multilinear polynomials over the boolean hypercube.</p>

    <p class="text-gray-300"><strong>Lemma 2.4.1.</strong> For any multilinear polynomial <span class="math">f</span>, <span class="math">\\sum_{i\\in \\{0,1\\} ^n}f(\\pmb {i})\\cdot L_i = f</span></p>

    <p class="text-gray-300"><strong>Corollary 2.4.1.1.</strong> <span class="math">\\sum_{i\\in \\{0,1\\} ^n}L_i = 1</span></p>

    <p class="text-gray-300">2.5 Multilinear-to-Univariate Correspondence</p>

    <p class="text-gray-300">Motivation and Definition. As mentioned in Section 2.3, the polynomial-evaluation protocols to follow are based on the fact that a multilinear polynomial <span class="math">f</span> in <span class="math">n</span> variables satisfies <span class="math">f(\\boldsymbol{u}) = v</span>, for <span class="math">\\boldsymbol{u} \\in \\mathbb{F}^n</span> and <span class="math">v \\in \\mathbb{F}</span>, if and only if there exist <span class="math">q_0 \\in \\mathbb{F}</span> and polynomials <span class="math">q_k</span> in <span class="math">\\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\leq 1}</span> for all <span class="math">k &amp;gt; 0</span> such that <span class="math">f - v = \\sum_{k=0}^{n-1} (X_k - u_k) q_k</span>.</p>

    <p class="text-gray-300">However, instead of testing this identity over multi-variate polynomials, the idea in these protocols is to test the identity over univariate polynomials of degree at most <span class="math">2^n - 1</span> by leveraging the isomorphism of <span class="math">\\mathbb{F}</span>-vector spaces</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal{U}_n \\colon \\mathbb{F}[X_0, \\dots, X_{n-1}]^{\\leq 1} \\to \\mathbb{F}[X]^{&amp;lt;2^n} \\\\ L_i \\mapsto \\left(X^{2^0}\\right)^{i_0} \\cdots \\left(X^{2^{n-1}}\\right)^{i_{n-1}}, \\end{array}</span></div>

    <p class="text-gray-300">which stems from identifying an integer in <span class="math">\\{0, \\ldots, 2^n - 1\\}</span> with its binary representation in <span class="math">\\{0, 1\\}^n</span>. The image of a multilinear polynomial under <span class="math">\\mathcal{U}_n</span> is later referred to as its “univariatisation”.</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{U}_n</span> is a linear isomorphism, <span class="math">f - v = \\sum_{k=0}^{n-1} (X_k - u_k) q_k</span> if and only if <span class="math">\\mathcal{U}_n(f) - \\mathcal{U}_n(v) = \\sum_{k=0}^{n-1} \\mathcal{U}_n(q_k X_k) - u_k \\mathcal{U}_n(q_k)</span>. To design a test over univariate polynomials, it is then necessary to give more explicit expressions of <span class="math">\\mathcal{U}_n(v)</span>, <span class="math">\\mathcal{U}_n(q_k)</span> and <span class="math">\\mathcal{U}_n(q_k X_k)</span>, i.e., to study the image under <span class="math">\\mathcal{U}_n</span> of <span class="math">\\mathbb{F}</span>, and for all <span class="math">0 &amp;lt; k &amp;lt; n</span>, <span class="math">\\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\leq 1}</span> and <span class="math">X_k \\cdot \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\leq 1}</span>.</p>

    <p class="text-gray-300">Properties. The first lemma below shows that <span class="math">\\mathcal{U}_n(\\mathbb{F})</span> is the line generated by <span class="math">\\varPhi_n</span>.</p>

    <p class="text-gray-300">Lemma 2.5.1. Let <span class="math">n</span> be a positive integer. For any constant polynomial <span class="math">a \\in \\mathbb{F}</span>, <span class="math">\\mathcal{U}_n(a)(X) = a \\sum_{i=0}^{2^n-1} X^i = a \\cdot \\varPhi_n(X)</span>.</p>

    <p class="text-gray-300">Proof. Corollary 2.4.1.1 implies that <span class="math">a = a \\cdot 1 = a \\sum_{\\boldsymbol{i} \\in \\{0,1\\}^n} L_{\\boldsymbol{i}}</span>, and the result follows by linearity of <span class="math">\\mathcal{U}_n</span>.</p>

    <p class="text-gray-300">The next lemma characterises the image under <span class="math">\\mathcal{U}_n</span> of the space of multilinear polynomials in <span class="math">k \\leq n</span> variables.</p>

    <p class="text-gray-300">Lemma 2.5.2. Let <span class="math">n</span> be a positive integer. Consider <span class="math">\\hat{f} \\in \\mathbb{F}[X]^{\\leq 2^n - 1}</span> and let <span class="math">f \\coloneqq \\mathcal{U}_n^{-1}(\\hat{f})</span>. Then, for any <span class="math">0 &amp;lt; k \\leq n</span>, <span class="math">f \\in \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\leq 1}</span> if and only if <span class="math">\\hat{f}(X) = \\varPhi_{n-k}(X^{2^k}) \\hat{f}^{&amp;lt;2^k}</span>. Furthermore, <span class="math">\\hat{f}^{&amp;lt;2^k} = \\mathcal{U}_k(f)</span>.</p>

    <p class="text-gray-300">Proof. Suppose that <span class="math">f \\in \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\leq 1}</span>. For any <span class="math">i \\in \\{0,1\\}^k</span>,</p>

    <div class="my-4 text-center"><span class="math-block">L_i(\\boldsymbol{X}_{&amp;lt;k}) = L_i(\\boldsymbol{X}_{&amp;lt;k}) \\cdot 1 \\stackrel{2.4.1.1}{=} L_i(\\boldsymbol{X}_{&amp;lt;k}) \\sum_{\\boldsymbol{j} \\in \\{0,1\\}^{n-k}} L_j(\\boldsymbol{X}_{[k;n[]}).</span></div>

    <p class="text-gray-300">Then,</p>

    <div class="my-4 text-center"><span class="math-block">f = \\sum_{\\boldsymbol{i} \\in \\{0,1\\}^k} f(\\boldsymbol{i}) L_{\\boldsymbol{i}}(\\boldsymbol{X}_{&amp;lt;k}) = \\sum_{\\boldsymbol{i},\\boldsymbol{j}} f(\\boldsymbol{i}) L_{\\boldsymbol{i}}(\\boldsymbol{X}_{&amp;lt;k}) L_{\\boldsymbol{j}}\\left(\\boldsymbol{X}_{[k;n[}\\right),</span></div>

    <p class="text-gray-300">which implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\hat{f} = \\sum_{\\boldsymbol{i}, \\boldsymbol{j}} f(\\boldsymbol{i}) \\left(X^{2^0}\\right)^{i_0} \\cdots \\left(X^{2^{k-1}}\\right)^{i_{k-1}} \\left(X^{2^k}\\right)^{j_k} \\cdots \\left(X^{2^{n-1}}\\right)^{j_{n-1}} \\\\ = \\sum_{\\boldsymbol{j}} \\left(X^{2^k}\\right)^{j_k} \\cdots \\left(X^{2^{n-1}}\\right)^{j_{n-1}} \\cdot \\underbrace{\\sum_{\\boldsymbol{i}} f(\\boldsymbol{i}) \\left(X^{2^0}\\right)^{i_0} \\cdots \\left(X^{2^{k-1}}\\right)^{i_{k-1}}}_{\\hat{g}(X)} \\\\ = \\left(1 + X^{2^k} + \\left(X^{2^k}\\right)^2 + \\cdots + \\left(X^{2^k}\\right)^{2^{n-k-1}}\\right) \\cdot \\hat{g}(X) \\\\ = \\Phi_{n-k} \\left(X^{2^k}\\right) \\cdot \\hat{g}(X). \\end{array}</span></div>

    <p class="text-gray-300">The definition of <span class="math">\\hat{g}</span> shows that it is the image of <span class="math">f</span> under <span class="math">\\mathcal{U}_k</span>, and the last equality shows that it is indeed <span class="math">\\hat{f}^{&amp;lt;2^k}</span>.</p>

    <p class="text-gray-300">What precedes shows that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{U}_n \\left(\\mathbb{F}[X_0, \\dots, X_{k-1}]^{\\preceq 1}\\right) \\subseteq \\Phi_{n-k} \\left(X^{2^k}\\right) \\cdot \\mathbb{F}[X]^{\\leq 2^k - 1}.</span></div>

    <p class="text-gray-300">To show that <span class="math">f \\in \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\preceq 1}</span> if <span class="math">\\hat{f} = \\Phi_{n-k} \\left(X^{2^k}\\right) \\hat{f}^{&amp;lt;2^k}</span>, it suffices to show that the above inclusion is in fact an equality. This is however immediate since the two are <span class="math">\\mathbb{F}</span> vector spaces of the same dimension <span class="math">2^k</span>.</p>

    <p class="text-gray-300">Next comes a polynomial identity which characterises the image under <span class="math">\\mathcal{U}_n</span> of <span class="math">X_k \\cdot \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\preceq 1}</span> for all <span class="math">k &amp;lt; n</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2.5.3.</strong> Consider integers <span class="math">0 &amp;lt; k &amp;lt; n</span> as well as a polynomial <span class="math">f \\in \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\preceq 1}</span>. Then, <span class="math">\\left(X^{2^k} + 1\\right) \\mathcal{U}_n(X_k f) = X^{2^k} \\mathcal{U}_n(f)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> As in the proof of Lemma 2.5.2, write</p>

    <div class="my-4 text-center"><span class="math-block">f = \\sum_{\\boldsymbol{i} \\in \\{0,1\\}^k} f(\\boldsymbol{i}) L_{\\boldsymbol{i}}(\\boldsymbol{X}_{&amp;lt;k}).</span></div>

    <p class="text-gray-300">Then, denoting <span class="math">\\mathcal{U}_n(f)</span> by <span class="math">\\hat{f}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal{U}_n(X_k f) = \\sum_{\\boldsymbol{j} \\in \\{0,1\\}^{n-k-1}} X^{2^k} \\left(X^{2^{k+1}}\\right)^{j_{k+1}} \\cdots \\left(X^{2^{n-1}}\\right)^{j_{n-1}} \\hat{f}^{&amp;lt;2^k}(X) \\\\ = \\hat{f}^{&amp;lt;2^k}(X) \\sum_{j=0}^{2^{n-k-1}-1} \\left(X^{2^k}\\right)^{2j+1}. \\end{array}</span></div>

    <p class="text-gray-300">However,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(Y + Y^3 + Y^5 + \\cdots + Y^{2^{\\ell-1}}\\right)(Y + 1) = Y + Y^2 + \\cdots + Y^{2^{\\ell}} = Y \\cdot \\Phi_{\\ell}(Y).</span></div>

    <p class="text-gray-300">The change of variable <span class="math">Y \\leftarrow X^{2^k}</span> and <span class="math">\\ell \\leftarrow n - k</span> implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(X^{2^k} + 1\\right) \\mathcal{U}_n(X_k f) = X^{2^k} \\Phi_{n-k} \\left(X^{2^k}\\right) \\cdot \\hat{f}^{&amp;lt;2^k} (X) \\\\ = X^{2^k} \\mathcal{U}_n(f), \\end{array}</span></div>

    <p class="text-gray-300">with the last equality stemming from Lemma 2.5.2.</p>

    <p class="text-gray-300">Corollary 2.5.3.1. Let <span class="math">0 &amp;lt; k &amp;lt; n</span> be integers. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(X^{2^k} + 1\\right) (X - 1) \\mathcal{U}_n(X_k) = X^{2^k} \\left(X^{2^n} - 1\\right).</span></div>

    <p class="text-gray-300">Proof. Apply Lemma 2.5.3 to <span class="math">f = 1</span>. Lemma 2.5.1 shows that that <span class="math">\\mathcal{U}_n(1) = \\Phi_n(X)</span>, and since <span class="math">(X - 1)\\Phi_n(X) = X^{2^n} - 1</span>, the result follows.</p>

    <p class="text-gray-300">Corollary 2.5.3.2. Consider integers <span class="math">0 &amp;lt; k &amp;lt; n</span> as well as a polynomial <span class="math">f \\in \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\leq 1}</span>. Then, <span class="math">\\mathcal{U}_n(X_k f) = X^{2^k} \\Phi_{n-k-1} \\left(X^{2^{k+1}}\\right) \\mathcal{U}_n(f)^{&amp;lt;2^k}</span>.</p>

    <p class="text-gray-300">Proof. Lemma 2.5.3 shows that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(X^{2^k} + 1\\right) \\mathcal{U}_n(X_k f) = X^{2^k} \\mathcal{U}_n(f),</span></div>

    <p class="text-gray-300">and Lemma 2.5.2 implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(X^{2^k} + 1\\right) \\mathcal{U}_n(X_k f) = X^{2^k} \\Phi_{n-k} \\left(X^{2^k}\\right) \\mathcal{U}_n(f)^{&amp;lt;2^k}.</span></div>

    <p class="text-gray-300">Setting <span class="math">Y \\leftarrow X^{2^k}</span> and multiplying both sides of the equality by <span class="math">(Y - 1)</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(Y^2 - 1\\right) \\mathcal{U}_n(X_k f) = Y (Y - 1) \\Phi_{n-k} (Y) \\mathcal{U}_n(f)^{&amp;lt;2^k}.</span></div>

    <p class="text-gray-300">However,</p>

    <div class="my-4 text-center"><span class="math-block">(Y - 1) \\Phi_{n-k} (Y) = Y^{2^{n-k}} - 1 = \\left(Y^2\\right)^{2^{n-k-1}} - 1 = \\left(Y^2 - 1\\right) \\Phi_{n-k-1} \\left(Y^2\\right),</span></div>

    <p class="text-gray-300">and since <span class="math">\\mathbb{F}[X]</span> is an integral ring, the statement follows.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3.1 Notation and Convention</h2>

    <p class="text-gray-300">All algorithms are assumed to return a special error symbol <span class="math">\\perp</span> whenever they are run on an input not in their defined input sets. An algorithm is termed "efficient" if its runtime is a polynomial function of its input size. Probabilistic algorithms which run in Polynomial Time are referred to as PPT algorithms. Given a PPT algorithm A and bit strings <span class="math">x</span> and <span class="math">r</span>, <span class="math">A(x; r)</span> denotes the output of A on input <span class="math">x</span> and random string <span class="math">r</span>.</p>

    <p class="text-gray-300">Given a binary relation <span class="math">R</span> in the complexity class NP, <span class="math">L_R</span> denotes the corresponding language, i.e., <span class="math">L_R \\coloneqq \\{x: \\exists w, (x, w) \\in R\\}</span>. For a pair <span class="math">(x, w) \\in R</span>, <span class="math">x</span> is referred to as an instance and <span class="math">w</span> as witness for the membership of <span class="math">x</span> in <span class="math">L_R</span>. A relation generator is a PPT algorithm that returns, on the input of a security parameter, a binary relation decidable in polynomial time.</p>

    <p class="text-gray-300">3.2 Bilinear-Group Structures</p>

    <p class="text-gray-300">An asymmetric bilinear group structure consists of a tuple <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)</span>, with <span class="math">p</span> a prime integer, <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> groups of order <span class="math">p</span>, and <span class="math">e\\colon\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\mapsto\\mathbb{G}_{T}</span> a non-degenerate bilinear map. Generators of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> are respectively denoted <span class="math">[1]_{1}</span> and <span class="math">[1]_{2}</span>. Define <span class="math">[1]_{T}\\coloneqq e\\left([1]_{1},[1]_{2}\\right).</span> For any <span class="math">x\\in\\mathbb{F}</span>, <span class="math">[x]_{i}</span> is defined as <span class="math">x\\cdot[1]_{i}</span> for all <span class="math">i\\in\\{1,2,T\\}</span>.</p>

    <p class="text-gray-300">A bilinear group structure is of type 3 if there is no efficiently computable homomorphism from <span class="math">\\mathbb{G}_{2}</span> to <span class="math">\\mathbb{G}_{1}</span>. All pairings considered herein are of type 3.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">3.2.1 Hardness Assumptions</h4>

    <p class="text-gray-300">The constructions to come rely on the following computational assumption.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4"><span class="math">q</span>-Discrete–Logarithm Assumption</h5>

    <p class="text-gray-300">The discrete-logarithm assumption, parametrised by a positive integer <span class="math">q</span> (i.e., the <span class="math">q</span>-DLOG assumption <em>[12]</em>), over a generator Gen of bilinear-group structures, is that for any PPT algorithm A,</p>

    <p class="text-gray-300">\\[ P\\left[y=x\\colon\\begin{array}[]{c}\\mathbb{G}\\coloneqq(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)\\leftarrow\\textsc{Gen}\\left(1^{\\lambda}\\right);x\\leftarrow_{\\$}\\mathbb{F}^{*}\\\\ y\\leftarrow\\text{A}\\left(\\mathbb{G},[1]_{1},[x]_{1},\\ldots,[x^{q}]_{1},[1]_{2},[x]_{2},\\ldots,[x^{q}]_{2}\\right)\\end{array}\\right] \\]</p>

    <p class="text-gray-300">is a negligible function of <span class="math">\\lambda</span>.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.3 Algebraic-Group Model</h3>

    <p class="text-gray-300">The security analysis of the schemes herein (except for the generic constructions in Sections 4 and 5.4) is restricted to algebraic adversaries. That is, if a scheme specifies in its parameter a group and elements which belong to it, the analysis only applies to adversaries which can compute new group elements only by composing, with the group law, elements they receive as input and from the security-game challenger. This idea was formalised by Paillier and Vergnaud <em>[24]</em>, and by Fuchsbauer, Kiltz and Loss <em>[12]</em> in their algebraic-group model. It essentially amounts to requiring that whenever an adversary outputs a group element, it also outputs its representation as a linear combination of the group elements it has thus far received.</p>

    <p class="text-gray-300">As any analysis and conclusion in this model is restricted to the class of algebraic adversaries, a security reduction in the algebraic-group model may seem unconvincing since real-world adversaries could in principle perform a wider range of attacks. At the very least, it is not unlikely that a real-world adversary could have access to group elements other than those it is provided in a reduction to a computational problem. This situation could for instance occur if two parties use the same elliptic curve and independently generate group elements: the algebraic reduction for a scheme built by one party would not take into account the group elements generated by the other.</p>

    <p class="text-gray-300">Rather than a “proof” of security under a computational assumption, a reduction in the algebraic-group model should rather be interpreted as a formalisation</p>

    <p class="text-gray-300">of the idea that, if the underlying computational problem is hard, algebraic attacks as allowed in the model are definitely not a threat to the scheme, and that only a different class of attacks could potentially put the scheme in jeopardy. On the other hand, for existing schemes, no practical attack exploiting other information that the group elements relevant to the schemes are currently known, so the algebraic-group model captures the range of attacks hitherto known in practice, and there is no reason for the situation to be different for schemes based on similar computational assumptions.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.4 Proof Systems</h3>

    <p class="text-gray-300">A proof system for an NP-relation generator R consists of a set-up algorithm <span class="math">\\textsc{Setup}(R)\\rightarrow(par,\\tau)</span> that returns public parameters and a trapdoor (which may be an empty string) on the input of a relation <span class="math">R\\leftarrow\\textsc{R}\\left(1^{\\lambda}\\right)</span>, and of a pair</p>

    <p class="text-gray-300"><span class="math">\\langle\\textsc{P}(par,x,w),\\textsc{V}(par,x)\\rangle\\eqqcolon\\langle\\textsc{P},\\textsc{V}\\rangle(par,x;w)</span></p>

    <p class="text-gray-300">of interactive algorithms. The transcript of a protocol execution is later denoted <span class="math">\\{\\langle\\textsc{P},\\textsc{V}\\rangle(par,x;w)\\}</span>. In the instantiations given in this paper, generator R calls on a generator of bilinear group structures, and the NP relation for which proofs are computed is defined over the generated bilinear group structure.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">3.4.1 Properties</h4>

    <p class="text-gray-300">A proof system is expected to be complete and sound. It may additionally satisfy knowledge soundness and the honest-verifier zero-knowledge property. These properties are formally defined in Section B.1.1.</p>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Completeness</h5>

    <p class="text-gray-300">A proof system is complete if V accepts any interaction with P on an instance <span class="math">x</span> if the latter is given an input <span class="math">w</span> such that <span class="math">(x,w)\\in R</span>.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Soundness</h5>

    <p class="text-gray-300">A proof system is sound if no PPT prover can make the verifier accept false statements, i.e., make the verifier accept on the input of an instance <span class="math">x\\notin L_{R}</span> with non-negligible probability.</p>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Knowledge Soundess</h5>

    <p class="text-gray-300">Stronger than the former notion of soundness, knowledge soundness (also called extractability) requires the existence of a probabilistic algorithm, called extractor, that runs in expected polynomial time and computes a witness for any instance for which the prover makes the verifier accept with a probability above a certain threshold. This threshold is called knowledge-soundness error. The knowledge-soundness error is a function of the security parameter and the size of the instance. The extractor is given black-box access to the prover algorithm and also has control over its random tape.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Honest-Verifier Zero-Knowledge</h5>

    <p class="text-gray-300">The notion of honest-verifier zero-knowledge formalises the idea that a proof should reveal no information beyond the fact that <span class="math">x\\in L_{R}</span> to the verification algorithm of the proof system.</p>

    <p class="text-gray-300">3.5 Polynomial Commitments</p>

    <p class="text-gray-300">A polynomial-commitment scheme allows a party to commit to a polynomial and to later convince another party of evaluations of the committed polynomial.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">3.5.1 Syntax</h4>

    <p class="text-gray-300">Given a field <span class="math">\\mathbb{F}</span>, a scheme to commit to univariate polynomials consists of a set of algorithms as defined below.</p>

    <p class="text-gray-300">Given <span class="math">\\left(1^{\\lambda},N_{\\max}\\in\\mathbb{N}_{\\geq 1}\\right)\\rightarrow par</span> : generates public parameters on the input of a security parameter encoded in unary and of a positive integer <span class="math">N_{\\max}</span>. The latter indicates a strict upper-bound on the maximum degree of the polynomials that are committed to, i.e., the polynomials to be committed to are of degree at most <span class="math">N_{\\max}-1</span>. It is here tacitly assumed that the set-up algorithm also expects an auxiliary input which may for instance specify the basis (e.g., monomial or Lagrange) in which the polynomials to be committed to are represented. For simplicity, this input is omitted from the syntax. To lighten the notation, the parameters are given as an implicit input to the algorithms to follow whenever they are clear from the context. <span class="math">\\mathsf{Com}\\left(f\\in\\mathbb{F}[X]^{&lt;N_{\\max}}\\right)\\rightarrow(C,r)</span> : computes a commitment to <span class="math">f</span> (represented as a tuple of at most <span class="math">N_{\\max}</span> field elements) and a piece of de-commitment information <span class="math">r</span>, which typically is a random value used to compute the commitment. <span class="math">\\mathsf{Open}\\left(C,f,r\\right)\\rightarrow b\\in\\left\\{0,1\\right\\}</span> : returns a bit indicating whether <span class="math">C</span> is a valid commitment to <span class="math">f</span> w.r.t. the de-commitment information <span class="math">r</span>. The algorithm is said to accept if it returns <span class="math">1</span> and to reject otherwise. is a proof system for the language</p>

    <p class="text-gray-300"><span class="math">\\left\\{(C,u,v):\\exists\\left(f\\in\\mathbb{F}[X]^{&lt;N_{\\max}},r\\right),\\mathrm{Open}(C,f,r)=1,f(u)=v\\right\\}.</span></p>

    <p class="text-gray-300">The bound <span class="math">N_{\\max}</span> on the degree of the witness <span class="math">f</span> is here determined by <span class="math">par</span>.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Commitments to Multilinear Polynomials.</h4>

    <p class="text-gray-300">The above definition is readily adapted to the case of multilinear polynomials: polynomials are also given as a tuple of field elements to the commitment and opening algorithm. However, since the degree in each variable is known in advance to be at most <span class="math">1</span>, the integer received by the set-up algorithm, now denoted <span class="math">n_{\\max}</span>, instead represents the maximum number of variables of the polynomials to which the scheme allows to commit. The commitment and opening algorithms additionally take an integer <span class="math">1\\leq n\\leq n_{\\max}</span> specifying the number of variables of their input polynomials, now represented as a vector in <span class="math">\\mathbb{F}^{2^{n}}</span>.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">3.5.2 Properties</h4>

    <p class="text-gray-300">A polynomial commitment scheme is expected to satisfy the following requirements.</p>

    <p class="text-gray-300">This property holds if the opening algorithm accepts all honestly computed commitments.</p>

    <p class="text-gray-300">A scheme is considered binding if no two distinct polynomials can be successfully opened to the same commitment. A scheme is hiding if no PPT adversary can infer, with non-negligible probability, any information about the polynomial underlying a commitment. The evaluation protocol is required to satisfy the following conditions.</p>

    <p class="text-gray-300">In addition to the completeness property, the evaluation protocol of a polynomial-commitment scheme is expected to be (knowledge) sound. The protocol may additionally be required to satisfy the (honest-verifier) zero-knowledge property. the evaluation protocol of a polynomial-commitment scheme is also required to be evaluation binding, meaning that a commitment binds the prover to a function. That is, no malicious prover has a non-negligible probability to make the verifier accept in two protocol executions with the same commitment and evaluation point, but with two distinct claimed evaluations.</p>

    <p class="text-gray-300">See Section B.2.1 for formal definitions.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Remark.</h6>

    <p class="text-gray-300">The evaluation protocol of a binding scheme is necessarily evaluation binding if it is extractable. This can be shown by contrapositive as follows. Suppose that the evaluation protocol of a scheme is extractable but not evaluation binding. It suffices to show that the scheme cannot be binding.</p>

    <p class="text-gray-300">If the scheme is not evaluation binding, then with non-negligible probability, a PPT adversary can compute valid proofs for two distinct evaluations at the same point w.r.t. the same commitment. Two polynomials which correspond to the commitment and which satisfy the evaluations can be extracted with non-negligible probability from the two valid proofs. However, since the evaluations are distinct at the same point, the two polynomials are necessarily distinct. This implies that two distinct openings for the same commitment can be computed with non-negligible probability and the scheme is therefore not binding.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">3.5.3 Hiding KZG Commitments.</h4>

    <p class="text-gray-300">Polynomial-delegation schemes are similar to polynomial-commitment schemes, except that the evaluations for which proofs are computed are also committed. Zhang, Genkin, Katz, Papdopoulos and Papamanthou <em>[34]</em> proposed a polynomial-delegation scheme which is similar in spirit to the pairing-based polynomial-commitment scheme due to Kate, Zaverucha and Goldberg <em>[20]</em>. The latter scheme stems from the observation that a polynomial <span class="math">f\\in\\mathbb{F}[X]</span> satisfies <span class="math">f(u)=v</span> if and only if there exists a polynomial <span class="math">q\\in\\mathbb{F}[X]</span> such that <span class="math">f-v=(X-u)q</span>, i.e., if and only if <span class="math">X-u</span> divides <span class="math">f-v</span> in <span class="math">\\mathbb{F}[X]</span>. Evaluation proofs are non-interactive and consist of a single group element, which is a commitment to <span class="math">q</span>.</p>

    <p class="text-gray-300">The scheme which follows is a variation of standard KZG commitments and is inspired by their construction. Its main benefit is that it is hiding and only uses a single random field element to achieve this property. The standard KZG</p>

    <p class="text-gray-300">evaluation proofs are now also randomised. As a result, the prover must also send a corrective term to account for both random terms. In stark contrast, the hiding version of KZG commitments given in the original paper relies on a random hiding polynomial of the same degree as the committed polynomial.</p>

    <p class="text-gray-300">SETUP <span class="math">\\left(1^{\\lambda}, N_{\\max} \\in \\mathbb{N}_{\\geq 1}\\right)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb{G} := (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e) \\leftarrow \\operatorname{Gen} \\left(1^{\\lambda}\\right) \\\\ srs \\leftarrow \\left([1]_1, [\\tau]_1, \\dots, \\left[\\tau^{N_{\\max}-1}\\right]_1, [\\xi]_1, [1]_2, [\\tau]_2, [\\xi]_2\\right) \\text{ for } \\tau, \\xi \\leftarrow_{\\S} \\mathbb{F}^* \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Return <span class="math">par \\leftarrow (\\mathbb{G}, srs)</span>.</p>

    <p class="text-gray-300">COM <span class="math">(f := (a_0, \\ldots, a_{N-1}))</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} r \\leftarrow_{\\S} \\mathbb{F} \\\\ C \\leftarrow a_0 \\cdot [1]_1 + a_1 \\cdot [\\tau]_1 + \\dots + a_{N-1} \\cdot \\left[\\tau^{N-1}\\right]_1 + r \\cdot [\\xi]_1 = [f(\\tau)]_1 + r \\cdot [\\xi]_1 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Return <span class="math">(C, r)</span>.</p>

    <p class="text-gray-300">OPEN <span class="math">(C, f := (a_0, \\ldots, a_{N-1}), r)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">C \\stackrel{?}{=} a_0 \\cdot [1]_1 + a_1 \\cdot [\\tau]_1 + \\dots + a_{N-1} \\cdot \\left[\\tau^{N-1}\\right]_1 + r \\cdot [\\xi]_1.</span></div>

    <p class="text-gray-300">EVAL:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\rightarrow \\mathbf{V}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\pi \\leftarrow [q(\\tau)]_1 + s \\cdot [\\xi]_1 \\text{ for } q \\text{ such that } f - v = (X - u)q \\text{ and } s \\leftarrow_{\\S} \\mathbb{F}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta \\leftarrow r \\cdot [1]_1 - s \\cdot [\\tau]_1 + (s \\cdot u) \\cdot [1]_1 = [r - s(\\tau - u)]_1</span></div>

    <p class="text-gray-300">Output <span class="math">(\\pi, \\delta)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{V} : e(C - v \\cdot [1]_1, [1]_2) \\stackrel{?}{=} e(\\pi, [\\tau]_2 - u \\cdot [1]_2) + e(\\delta, [\\xi]_2).</span></p>

    <p class="text-gray-300">Properties. The scheme is correct and perfectly hiding by construction. It is also binding under the <span class="math">(N_{\\max} - 1)</span> discrete-logarithm assumption.</p>

    <p class="text-gray-300">The soundness of the evaluation protocol is irrelevant as the language is trivial as soon as <span class="math">N_{\\max} \\geq 2</span>: by simple Lagrange interpolation, there is always a polynomial of degree 1 that takes the value <span class="math">\\mathrm{dlog}_{[1]_1}(C)</span> at <span class="math">\\tau</span> and satisfies the evaluation. The pair consisting of such a polynomial and zero as randomness is thus a valid witness.</p>

    <p class="text-gray-300">Zhang et al. gave a proof [34, Proof of Theorem 1] that their polynomial-delegation satisfies, under the <span class="math">q</span>-Strong-Diffie-Hellman (<span class="math">q</span>-SDH) assumption [4], a binding property which amounts to the knowledge soundness property for polynomial-commitment schemes (as defined above). However, as explained in Section B.2.2, there is unfortunately a critical flaw in their proof⁴. Section B.2.2 gives a proof that the hiding KZG scheme is knowledge sound under the <span class="math">q</span>-DLOG assumption, which is weaker than the <span class="math">q</span>-SDH assumption. The approach in the proof is readily generalised to the case of multivariate polynomials as in the delegation scheme due to Zhang et al.</p>

    <p class="text-gray-300">³ With asymmetric bilinear group structures, the SDH assumption needed in their proof of the binding property of the scheme is symmetric: all powers of the trapdoor must be committed in both groups.</p>

    <p class="text-gray-300">⁴ This issue has been discussed with the authors, and the proof in Section B.2.2 stems from discussions with them.</p>

    <p class="text-gray-300">4 Generic Construction</p>

    <p class="text-gray-300">To prove that a multilinear polynomial <span class="math">f</span> satisfies <span class="math">f(\\bm{u})=v</span> for public <span class="math">\\bm{u}</span> and <span class="math">v</span>, Lemma 2.3.1 shows that it is enough to prove the existence of <span class="math">q_{0}\\in\\mathbb{F}</span> and of multilinear polynomials <span class="math">q_{1},\\ldots,q_{n-1}</span>, with each <span class="math">q_{k}</span> in the first <span class="math">k</span> variables, such that <span class="math">f-v=\\sum_{k}(X_{k}-u_{k})q_{k}</span>. Since the map <span class="math">\\mathcal{U}_{n}</span> defined in Section 2.5 is an isomorphism, it is enough to prove the above equality over the image under <span class="math">\\mathcal{U}_{n}</span> of the polynomials in the identity. The lemmas in Section 2.5 imply a univariate polynomial identity that these images must satisfy, in terms of <span class="math">\\mathcal{U}_{n}(f)</span>, <span class="math">\\mathcal{U}_{n}(q_{k})</span> and the public input.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Outline.</h4>

    <p class="text-gray-300">The idea of the generic construction which follows is to commit to the image of <span class="math">f</span> under <span class="math">\\mathcal{U}_{n}</span>. The definition of <span class="math">\\mathcal{U}_{n}</span> implies that the multilinear polynomials are given in the Lagrange basis, and the univariate scheme allows to commit to polynomials given in the monomial basis. As <span class="math">\\mathcal{U}_{n}</span> is an isomorphism, <span class="math">f-v=\\sum_{k}(X_{k}-u_{k})q_{k}</span> if and only if <span class="math">\\mathcal{U}_{n}(f)-\\mathcal{U}_{n}(v)=\\sum_{k}\\mathcal{U}_{n}(q_{k}X_{k})-u_{k}\\mathcal{U}_{n}(q_{k})</span>, and Lemmas 2.5.1 and 2.5.2, and Corollary 2.5.3.2 show that the latter identity holds if and only if</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{n}(f)-v\\cdot\\Phi_{n}(X)=\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}}.</span></p>

    <p class="text-gray-300">In the evaluation protocol, the prover starts by sending commitments to <span class="math">\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}}</span>. The verifier first checks that the committed polynomials are of degree at most <span class="math">2^{k}-1</span> via a degree-check protocol, and then sends a uniformly random value <span class="math">x</span> to the prover. The prover then shows that</p>

    <p class="text-gray-300"><span class="math">Z_{x}(X)</span> <span class="math">\\coloneqq\\mathcal{U}_{n}(f)(X)-v\\cdot\\Phi_{n}(x)</span> <span class="math">-\\ \\sum_{k}\\left(x^{2^{k}}\\Phi_{n-k-1}\\left(x^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(x^{2^{k}}\\right)\\right)\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}}(X)</span></p>

    <p class="text-gray-300">evaluates to <span class="math">0</span> at <span class="math">x</span> via the evaluation protocol of the univariate scheme. Assuming the univariate scheme to be additively homomorphic, the verifier can compute a commitment to this polynomial, as it results from partially evaluating at <span class="math">x</span> the terms in the above polynomial identity that the verifier can compute on its own. If the degree-check and univariate-evaluation protocols are secure in the standard model, then so is the generic construction.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Building Blocks.</h4>

    <p class="text-gray-300">The scheme assumes the existence of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Uni, a univariate-polynomial commitment scheme that is additively homomorphic</li>

      <li>Deg, a proof system for the language</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left\\{(C,d\\in\\mathbb{N}_{\\geq 0}):\\exists\\left(f\\in\\mathbb{F}[X]^{\\leq d},r\\right),\\textsc{Uni.Open}(C,f,r)=1\\right\\}.</span></p>

    <p class="text-gray-300">The public inputs and witness are in the sets determined by Uni.Setup.</p>

    <p class="text-gray-300">SETUP <span class="math">(1^{\\lambda}, n_{\\max})</span> : Return <span class="math">par \\gets \\mathrm{UNI.SETUP}(1^{\\lambda}, 2^{n_{\\max}})</span>.</p>

    <p class="text-gray-300">COM <span class="math">(f,n)</span> : Return <span class="math">(C,r) \\gets \\mathrm{UNI.COM}(\\mathcal{U}_n(f))</span>.</p>

    <p class="text-gray-300">OPEN <span class="math">(C, f, n, r) \\to b \\in \\{0, 1\\}</span> : Return <span class="math">b \\gets \\mathrm{UNI.OPEN}(C, \\mathcal{U}_n(f), r)</span>.</p>

    <p class="text-gray-300">EVAL :</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}(C,\\mathbf{u} = (u_0,\\dots ,u_{n - 1}),v,f,r)\\to \\mathbf{V}(C,\\mathbf{u},v):</span></p>

    <div class="my-4 text-center"><span class="math-block">\\text{For } (k = 0, \\dots , n - 1) \\left\\{ \\left(C _ {k}, r _ {k}\\right) \\leftarrow \\operatorname {UNI.COM} \\left(\\mathcal {U} _ {n} \\left(q _ {k}\\right) ^ {&amp;lt;   2 ^ {k}}\\right) \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Output } (C _ {0}, \\dots , C _ {n - 1})</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\rightleftharpoons \\mathbf{V}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathrm {DEG.P}, \\mathrm {DEG.V} \\rangle (C, 2 ^ {n} - 1; \\mathcal {U} _ {n} (f), r)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{For } (k = 0, \\dots , n - 1)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathrm {DEG.P}, \\mathrm {DEG.V} \\rangle \\left(C _ {k}, 2 ^ {k} - 1; \\mathcal {U} _ {n} (q _ {k}) ^ {&amp;lt;   2 ^ {k}}, r _ {k}\\right)</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\gets \\mathbf{V}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">x \\leftarrow_ {\\S} \\mathbb {F}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(C _ {v, x}, 0\\right) \\leftarrow \\operatorname {UNI.COM} \\left(v \\cdot \\Phi_ {n} (x); 0\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {Z _ {x}} \\leftarrow C - C _ {v, x} - \\sum_ {k} \\left(x ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(x ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(x ^ {2 ^ {k}}\\right)\\right) C _ {k}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Output } x</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{P} : r_Z \\gets r - \\sum_k \\left(x^{2^k} \\Phi_{n-k-1} \\left(x^{2^{k+1}}\\right) - u_k \\cdot \\Phi_{n-k} \\left(x^{2^k}\\right)\\right) \\cdot r_k</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\rightleftharpoons \\mathbf{V}</span> : <span class="math">\\langle \\mathrm{UNI.Eval.P}, \\mathrm{UNI.Eval.V} \\rangle (C_{Z_x}, x, 0; Z_x, r_Z)</span>.</p>

    <p class="text-gray-300">Properties. The correctness of UNI implies the correctness of the scheme. The binding property of the scheme follows from that of UNI and the fact that <span class="math">\\mathcal{U}_n</span> is an isomorphism. The hiding property follows from that of UNI. The completeness of the evaluation protocol follows from the correctness of UNI and the completeness of UNI.Eval and DEG.</p>

    <p class="text-gray-300">As for the knowledge soundness of the evaluation protocol, if DEG is knowledge sound, a polynomial <span class="math">\\hat{f}</span> of degree at most <span class="math">2^{n} - 1</span> and polynomials <span class="math">\\hat{f}_k</span> of degree at most <span class="math">2^k - 1</span> corresponding to <span class="math">C</span> and <span class="math">C_k</span> can be efficiently extracted from a prover that makes the verifier accept with non-negligible probability. Assuming UNI.Eval to be sound, for a uniformly random <span class="math">x \\in \\mathbb{F}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\hat {f} - v \\cdot \\Phi_ {n} (x) - \\sum_ {k} \\left(x ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(x ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(x ^ {2 ^ {k}}\\right)\\right) \\hat {f} _ {k}\\right) (x) \\\\ = \\hat {f} (x) - v \\cdot \\Phi_ {n} (x) - \\sum_ {k} \\left(x ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(x ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(x ^ {2 ^ {k}}\\right)\\right) \\hat {f} _ {k} (x) \\\\ = \\left(\\hat {f} - v \\cdot \\Phi_ {n} - \\sum_ {k} \\left(X ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(X ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(X ^ {2 ^ {k}}\\right)\\right) \\hat {f} _ {k}\\right) (x) \\\\ = 0. \\end{array}</span></div>

    <p class="text-gray-300">By the polynomial-identity lemma, this means that</p>

    <p class="text-gray-300"><span class="math">\\hat{f}-v\\cdot\\Phi_{n}(X)-\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\hat{f}_{k}=0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with probability at least $1-2^{n}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, with probability at least $1-2^{n}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, for </span>f\\coloneqq\\mathcal{U}_{n}^{-1}\\left(\\hat{f}\\right)<span class="math"> and </span>q_{k}\\coloneqq\\mathcal{U}_{n}^{-1}\\left(\\hat{f}_{k}\\right)<span class="math">, the equality </span>f-v=\\sum_{k}(X_{k}-u_{k})q_{k}<span class="math"> holds and </span>f(\\boldsymbol{u})=v$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lastly, if Uni is hiding and Deg and Uni.Eval are zero-knowledge, then the evaluation protocol is zero-knowledge: to simulate a protocol transcript, it suffices to commit to dummy polynomials (the commitments are indistinguishable from real ones by the hiding property of Uni) and to then run the simulators of Deg and Uni.Eval.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">On Efficiency.</h4>

    <p class="text-gray-300">The prover needs randomness only to compute commitments to the <span class="math">\\mathcal{U}_{n}(q_{k})^{\\leq 2^{k}}</span> polynomials, and in the degree-check and univariate-evaluation sub-protocols. The computational efficiency of the evaluation protocol is contingent on the efficiency of the degree-check protocol and of the univariate evaluation protocol. Batching degree-check protocol executions would improve the efficiency of the protocol. In the instantiation of the protocol with hiding KZG univariate commitments, the degree checks are not only batched, but also merged with the last evaluation step for increased efficiency. As a consequence, the knowledge soundness of the scheme does not directly follow from that of the generic construction and requires extra arguments.</p>

    <h2 id="sec-36" class="text-2xl font-bold">5 Degree-Check Protocols</h2>

    <p class="text-gray-300">This section first gives a protocol to check the degree of univariate polynomials committed with the hiding KZG scheme (Section 3.5.3), as a building block for the instantiation (in Section 6) of the multilinear scheme with hiding KZG commitments. It is inspired by the polynomial identity that the variant of KZG due to Maller, Bower, Kohlweiss and Meiklejohn <em>[23, Figure 3]</em> enables the verifier to check. Next comes a protocol to jointly verify an evaluation and a degree bound of a committed polynomial.</p>

    <p class="text-gray-300">The latter protocol serves as a building block for a following protocol to efficiently batch degree-check proofs. In the instantiation of this batch protocol with hiding KZG commitments, the verifier performs only a <em>constant number of pairings</em>. In contrast, the standard technique with random linear combinations would lead to a linear number of pairings.</p>

    <p class="text-gray-300">The last protocol of the section allows to batch evaluation proofs with degree check if the evaluation point and the degree bound is the same for all polynomials; it will enable an optimisation of the instantiation of the Section-4 protocol with hiding KZG commitments.</p>

    <p class="text-gray-300">All these protocols come at the cost of requiring, in the reference string, higher (compared to the description in Section 3.5.3) powers of the first trapdoor to be committed in the second group.</p>

    <p class="text-gray-300">5.1 Single KZG Degree Check</p>

    <p class="text-gray-300">Given a hiding KZG commitment to a polynomial <span class="math">f\\in\\mathbb{F}[X]</span> and a non-negative integer <span class="math">d&lt;N_{\\max}</span>, to check that <span class="math">\\deg f\\leq d</span>, the idea of the protocol is to simply check that <span class="math">f\\cdot X^{N_{\\max}-1-d}=fX^{N_{\\max}-1-d}\\cdot 1</span> via pairing computations. If <span class="math">\\deg f&gt;d</span>, then the prover would not be able to commit to <span class="math">fX^{N_{\\max}-1-d}</span>, as its degree <span class="math">N_{\\max}+\\deg(f)-1-d</span> would exceed <span class="math">N_{\\max}-1</span>, the maximum degree in the reference string. The proof that <span class="math">\\deg f\\leq d</span> thus precisely consists in such a commitment.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Formal Description</h4>

    <p class="text-gray-300">Let KZG denote the scheme recalled in Section 3.5.3. Given parameters <em>par</em> generated by KZG.Setup, the protocol which follows is for the language</p>

    <p class="text-gray-300"><span class="math">\\left\\{(C,0\\leq d&lt;N_{\\max})\\colon\\exists\\left(f\\in\\mathbb{F}[X]^{\\leq d},r\\in\\mathbb{F}\\right),\\text{KZG.Open}(C,f,r)=1\\right\\}.</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\to\\mathbf{V}:</span></p>

    <p class="text-gray-300"><span class="math">\\pi\\leftarrow\\left[f(\\tau)\\tau^{N_{\\max}-1-d}\\right]_{1}+s\\cdot[\\xi]_{1}\\text{ for }s\\leftarrow_{\\</span>}\\mathbb{F}$</p>

    <p class="text-gray-300"><span class="math">\\delta\\leftarrow r\\cdot\\left[\\tau^{N_{\\max}-1-d}\\right]_{1}-s\\cdot[1]_{1}</span></p>

    <p class="text-gray-300">Output <span class="math">(\\pi,\\delta)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{V}:\\ e\\left(C,\\left[\\tau^{N_{\\max}-1-d}\\right]_{2}\\right)\\stackrel{{\\scriptstyle!}}{{=}}e\\left(\\pi,[1]_{2}\\right)+e\\left(\\delta,[\\xi]_{2}\\right).</span></p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Properties</h4>

    <p class="text-gray-300">Completeness follows from the fact that</p>

    <p class="text-gray-300"><span class="math">(f(\\tau)+r\\xi)\\cdot\\tau^{N_{\\max}-1-d}</span> <span class="math">=(f(\\tau)+r\\xi)\\tau^{N_{\\max}-1-d}+s\\xi-s\\xi</span> <span class="math">=\\left(f(\\tau)\\tau^{N_{\\max}-1-d}+s\\xi\\right)\\cdot 1+\\left(r\\tau^{N_{\\max}-1-d}-s\\right)\\cdot\\xi.</span></p>

    <p class="text-gray-300">The knowledge soundness of the protocol can be proved in the algebraic-group model under the DLOG assumption with parameter <span class="math">N_{\\max}-1</span> as follows. Suppose that there exists a PPT algebraic adversary <span class="math">(\\text{A},\\text{P}^{*})</span> which makes the verifier accept with non-negligible probability. A polynomial <span class="math">f</span> of degree at most <span class="math">N_{\\max}-1</span> and a field element <span class="math">r\\in\\mathbb{F}</span> such that <span class="math">C=[f(\\tau)+r\\xi]_{1}</span> can be extracted from the commitment <span class="math">C</span> computed by A because the latter is algebraic. If <span class="math">\\deg f\\leq d</span>, then <span class="math">(f,r)</span> is a valid witness.</p>

    <p class="text-gray-300">Otherwise, i.e., in the event that <span class="math">\\deg f&gt;d</span>, let B be a reduction algorithm which interacts with the DLOG challenger and runs the adversary as sub-routine. Upon receiving a DLOG challenge tuple, algorithm B chooses <span class="math">\\xi\\leftarrow_{\\</span>}\\mathbb{F}^{*}$ and sets the SRS as in the scheme.</p>

    <p class="text-gray-300">Given a proof <span class="math">(\\pi,\\delta)</span> computed by <span class="math">\\text{P}^{*}</span>, algorithm B can extract polynomials <span class="math">g</span> and <span class="math">h</span> of degree at most <span class="math">N_{\\max}-1</span> and field elements <span class="math">s</span> and <span class="math">t</span> such that <span class="math">\\pi=[g(\\tau)+s\\xi]_{1}</span> and <span class="math">\\delta=[h(\\tau)+t\\xi]_{1}</span>. Since the verifier accepts,</p>

    <p class="text-gray-300"><span class="math">(f(\\tau)+r\\xi)\\cdot\\tau^{N_{\\max}-1-d}=g(\\tau)+s\\xi+(h(\\tau)+t\\xi)\\cdot\\xi.</span></p>

    <p class="text-gray-300">It means that <span class="math">\\tau</span> is a root of polynomial</p>

    <p class="text-gray-300"><span class="math">k\\coloneqq(f+r\\xi)X^{N_{\\max}-1-d}-g-s\\xi-(h+t\\xi)\\cdot\\xi</span></p>

    <p class="text-gray-300">which is of degree at most <span class="math">2(N_{\\max}-1)-d</span>. If <span class="math">\\deg(f)&gt;d</span>, then this polynomial is necessarily non-zero as <span class="math">fX^{N_{\\max}-1-d}</span> is of degree at least <span class="math">N_{\\max}</span> and <span class="math">r\\xi X^{N_{\\max}-1-d}-g-s\\xi-(h+t\\xi)\\cdot\\xi</span> is of degree at most <span class="math">N_{\\max}-1</span>. Therefore, polynomial <span class="math">k</span> can be factorised in polynomial time <em>[15, 28]</em>, which allows B to recover <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">In other words, the probability that a valid witness can be extracted is at least the probability that <span class="math">(\\mathrm{A},\\mathrm{P}^{*})</span> makes the verifier accept minus the supremal advantage of any PPT algorithm in solving the <span class="math">(N_{\\max}-1)</span>-DLOG problem. The latter assumed to be negligible, the probability that a valid witness is extracted is negligibly close to the probability that the verifier accepts.</p>

    <p class="text-gray-300">Given the trapdoor <span class="math">(\\tau,\\xi)</span>, a proof on a commitment <span class="math">C</span> can be simulated by choosing <span class="math">\\pi\\gets_{\\</span>}\\mathbb{G}_{1}<span class="math"> and computing </span>\\delta\\leftarrow(\\tau^{N_{\\max}-1-d}C-\\pi)\\xi^{-1}$.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">5.2 KZG Evaluation Proofs with Degree Check</h3>

    <p class="text-gray-300">In preparation of the protocol to batch degree checks on KZG commitments, the following protocol allows to simultaneously prove an evaluation (at non-zero points) and the degree of a non-constant polynomial committed with KZG. Unlike the scheme in Sonic <em>[23, Figure 3]</em>, the commitment algorithm remains the standard (hiding) KZG algorithm, which gives the flexibility to compute evaluation proofs on hiding KZG commitments with or without degree bounds, depending on the need.</p>

    <p class="text-gray-300">More precisely, given parameters <em>par</em> generated by KZG.Setup, the following protocol is for the language</p>

    <p class="text-gray-300"><span class="math">\\left\\{(C,0&lt;d&lt;N_{\\max},u\\neq 0,v)\\colon\\exists\\left(f\\in\\mathbb{F}[X]^{\\leq d},r\\in\\mathbb{F}\\right),\\mathrm{KZG.Open}(C,f,r)\\right.</span> <span class="math">=1,</span> <span class="math">\\left.f(u)\\right.=\\left.v\\right\\}.</span></p>

    <p class="text-gray-300">It is based on the observation that</p>

    <p class="text-gray-300"><span class="math">f-v=q(X-u)\\Leftrightarrow(f-v)\\cdot X^{N_{\\max}-d}=qX^{N_{\\max}-d}\\cdot(X-u)</span></p>

    <p class="text-gray-300">by integrality of <span class="math">\\mathbb{F}[X]</span>. Proving that identity is enough to show that <span class="math">f(u)=v</span>, but in addition to that, if <span class="math">\\deg f&gt;d</span>, then the degree of <span class="math">qX^{N_{\\max}-d}</span> would be at least <span class="math">N_{\\max}</span> and the prover would not be able to commit to it, so a commitment to <span class="math">qX^{N_{\\max}-d}</span> is also a proof that <span class="math">\\deg f\\leq d</span>.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Formal Description.</h4>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\rightarrow\\mathbf{V}:</span> <span class="math">\\pi\\leftarrow\\left[q(\\tau)\\tau^{N_{\\max}-d}\\right]_{1}+s\\cdot[\\xi]_{1}\\text{, for </span>q<span class="math"> s.t. }f-v=(X-u)q\\text{ and }s\\leftarrow_{\\</span>}\\mathbb{F}<span class="math"> </span>\\delta\\leftarrow r\\cdot\\left[\\tau^{N_{\\max}-d}\\right]_{1}-s\\cdot[\\tau]_{1}+(s\\cdot u)\\cdot[1]_{1}=\\left[r\\tau^{N_{\\max}-d}-s(\\tau-u)\\right]_{1}<span class="math"> </span>\\text{Output }(\\pi,\\delta)<span class="math"> </span>\\mathbf{V}:\\ e\\left(C-v\\cdot[1]_{1},\\left[\\tau^{N_{\\max}-d}\\right]_{2}\\right)\\stackrel{{\\scriptstyle\\scriptscriptstyle\\scriptscriptstyle.}}{{=}}e\\left(\\pi,[\\tau]_{2}-u\\cdot[1]_{2}\\right)+e\\left(\\delta,[\\xi]_{2}\\right).$</p>

    <p class="text-gray-300">Properties. The completeness of the protocol stems from the fact that</p>

    <p class="text-gray-300"><span class="math">(f(\\tau)+r\\xi-v)\\cdot\\tau^{N_{\\max}-d}</span> <span class="math">=(q(\\tau-u)+r\\xi)\\cdot\\tau^{N_{\\max}-d}</span> <span class="math">=q\\tau^{N_{\\max}-d}\\cdot(\\tau-u)+\\left(r\\tau^{N_{\\max}-d}\\right)\\cdot\\xi</span> <span class="math">=\\left(q\\tau^{N_{\\max}-d}+s\\xi-s\\xi\\right)\\cdot(\\tau-u)+\\left(r\\tau^{N_{\\max}-d}\\right)\\cdot\\xi</span> <span class="math">=\\left(q\\tau^{N_{\\max}-d}+s\\xi\\right)\\cdot(\\tau-u)</span> <span class="math">+\\left(r\\tau^{N_{\\max}-d}-s(\\tau-u)\\right)\\cdot\\xi.</span></p>

    <p class="text-gray-300">It remains to show that the protocol is knowledge sound. It can be proved under the <span class="math">(2N_{\\max}-1)</span>-DLOG assumption in the algebraic-group model as follows. Suppose that there exists a PPT algebraic adversary <span class="math">(\\mathrm{A},\\mathrm{P}^{*})</span> which makes the verifier accept with non-negligible probability.</p>

    <p class="text-gray-300">Since the adversary is algebraic, a polynomial <span class="math">f\\in\\mathbb{F}[X]</span> of degree at most <span class="math">N_{\\max}-1</span> and a field element <span class="math">r</span> such that <span class="math">C=\\left[f(\\tau)+r\\xi\\right]_{1}</span> can be extracted from the commitment computed by A. If <span class="math">\\deg f\\leq d</span> and <span class="math">f(u)=v</span>, then <span class="math">(f,r)</span> is a valid witness.</p>

    <p class="text-gray-300">Otherwise, i.e., in the event that <span class="math">\\deg f&gt;d</span> or <span class="math">f(u)\\neq v</span>, let B be a reduction algorithm which interacts with the DLOG challenger and runs the adversary as sub-routine. Upon receiving a DLOG challenge tuple</p>

    <p class="text-gray-300"><span class="math">\\left([1]_{1},[\\tau]_{1},\\ldots,\\left[\\tau^{2N_{\\max}-1}\\right]_{1},[1]_{2},[\\tau]_{2},\\ldots,\\left[\\tau^{2N_{\\max}-1}\\right]_{2}\\right),</span></p>

    <p class="text-gray-300">B chooses <span class="math">\\rho\\leftarrow_{\\</span>}\\mathbb{F}^{*}$, and sets the SRS as</p>

    <p class="text-gray-300"><span class="math">\\left([1]_{i},[\\tau]_{i},\\ldots,\\left[\\tau^{N_{\\max}-1}\\right]_{i},\\rho\\cdot\\left[\\tau^{2N_{\\max}-1}\\right]_{i}\\right)_{i\\in\\{1,2\\}},</span></p>

    <p class="text-gray-300">i.e., <span class="math">\\xi</span> is implicitly set as <span class="math">\\rho\\tau^{2N_{\\max}-1}</span>. Note that because <span class="math">\\rho</span> and <span class="math">\\tau</span> are independent, the distribution of this SRS is the same as that of the SRS in the scheme.</p>

    <p class="text-gray-300">Given a proof <span class="math">(\\pi,\\delta)</span> computed by <span class="math">\\mathrm{P}^{*}</span>, algorithm B can extract polynomials <span class="math">g</span> and <span class="math">h</span> of degree at most <span class="math">N_{\\max}-1</span> and field elements <span class="math">s</span> and <span class="math">t</span> such that <span class="math">\\pi=[g(\\tau)+s\\xi]_{1}</span> and <span class="math">\\delta=[h(\\tau)+t\\xi]_{1}</span>. Since the verifier accepts,</p>

    <p class="text-gray-300"><span class="math">\\left(f(\\tau)+r\\rho\\tau^{2N_{\\max}-1}-v\\right)\\cdot\\tau^{N_{\\max}-d}</span> <span class="math">=\\left(g(\\tau)+s\\rho\\tau^{2N_{\\max}-1}\\right)\\cdot(\\tau-u)</span> <span class="math">+\\left(h(\\tau)+t\\rho\\tau^{2N_{\\max}-1}\\right)\\cdot\\rho\\tau^{2N_{\\max}-1},</span></p>

    <p class="text-gray-300">i.e., <span class="math">\\tau</span> is a root of</p>

    <p class="text-gray-300"><span class="math">k(X)\\coloneqq\\left(f+r\\rho X^{2N_{\\max}-1}-v\\right)X^{N_{\\max}-d}</span> <span class="math">-\\left(g+s\\rho X^{2N_{\\max}-1}\\right)(X-u)</span> <span class="math">-\\left(h+t\\rho X^{2N_{\\max}-1}\\right)\\rho X^{2N_{\\max}-1}.</span></p>

    <p class="text-gray-300">If <span class="math">k</span> is non-zero, then B can recover <span class="math">\\tau</span> via factorisation <em>[15, 28]</em> and solve the DLOG problem. Consider</p>

    <p class="text-gray-300"><span class="math">\\ell(X,Y)\\coloneqq(f(X)+rY-v)X^{N_{\\max}-d}-(g(X)+sY)(X-u)-(h+tY)\\,Y.</span></p>

    <p class="text-gray-300">It is the pre-image of <span class="math">k</span> under the linear map</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}[X,Y]^{\\preceq 2(N_{\\max}-1)}\\to\\mathbb{F}[X]^{\\leq(2N_{\\max}-1)^{2}-1}</span></p>

    <p class="text-gray-300">which sends <span class="math">X^{i}Y^{j}</span> to <span class="math">X^{i}\\left(\\rho X^{2N_{\\max}-1}\\right)^{j}</span> for all <span class="math">i,j\\in\\{0,\\ldots,2N_{\\max}-2\\}</span>. It is an isomorphism because <span class="math">\\rho\\neq 0</span> and the <span class="math">2(N_{\\max}-1)</span>-ary decomposition of integers in <span class="math">\\{0,\\ldots,(2N_{\\max}-1)^{2}-1\\}</span> is unique, i.e., any integer in this set is uniquely written as <span class="math">i+2(N_{\\max}-1)\\cdot j</span> with <span class="math">i,j\\in\\{0,\\ldots,2N_{\\max}-2\\}</span>.</p>

    <p class="text-gray-300">To show that <span class="math">k</span> is non-zero in the event that <span class="math">\\deg f&gt;d</span> or <span class="math">f(u)\\neq v</span>, it suffices to show that <span class="math">\\ell</span> is non-zero. If <span class="math">\\deg f&gt;d</span>, then the term <span class="math">fX^{N_{\\max}-d}</span> has degree at least <span class="math">N_{\\max}+1</span>, whereas all the other terms in <span class="math">\\ell\\in\\mathbb{F}[Y][X]</span> are of degree at most <span class="math">N_{\\max}</span> in <span class="math">X</span>. If <span class="math">\\deg f\\leq d</span> but <span class="math">f(u)\\neq v</span>, then the constant term of <span class="math">\\ell</span> as a polynomial in <span class="math">\\mathbb{F}[X][Y]</span> is <span class="math">(f-v)X^{N_{\\max}-d}-(X-u)g</span>. If it were zero, then <span class="math">X^{N_{\\max}-d}</span> would divide <span class="math">g</span> because <span class="math">X^{N_{\\max}-d}</span> and <span class="math">X-u</span> are co-prime since <span class="math">u\\neq 0</span>, i.e., there would exist <span class="math">q\\in\\mathbb{F}[X]</span> such that <span class="math">f-v=(X-u)q</span>, which is equivalent to <span class="math">f(u)=v</span>. The constant term can thus not be zero, and <span class="math">\\ell</span> is non-zero, i.e., <span class="math">k</span> is non-zero. In other words, in the event that <span class="math">\\deg f&gt;d</span> or <span class="math">f(u)\\neq v</span>, <span class="math">k</span> is necessarily non-zero and B can recover <span class="math">\\tau</span> by factorisation <em>[15, 28]</em>.</p>

    <p class="text-gray-300">Given the trapdoor <span class="math">(\\tau,\\xi)</span>, a proof on a commitment <span class="math">C</span> can be simulated by choosing <span class="math">\\pi\\longleftarrow_{\\S}\\mathbb{G}_{1}</span> and computing <span class="math">\\delta\\leftarrow\\left(\\tau^{N_{\\max}-d}(C-v)-\\pi(\\tau-u)\\right)\\xi^{-1}</span>.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.3 Batched Degree Checks</h3>

    <p class="text-gray-300">The following protocol allows to prove, at once, that the degree of committed polynomials do not exceed individual, public bounds, more efficiently than performing independent single degree checks. The naive approach which consists in simultaneously checking the bounds via a random linear combination would incur a number of pairings that is linear in the number of tested polynomials. The protocol instead hinges on the following lemma which addresses the case where the bound is the same for all polynomials. The lemma is then applied in a way that incurs only a <em>constant</em> number of pairing computations for the verifier.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">m\\in\\mathbb{N}_{\\geq 1}</span> and let <span class="math">I=\\{i_{0},\\ldots,i_{m-1}\\}</span> be a set of <span class="math">m</span> pairwise distinct non-negative integers. Consider <span class="math">g_{0},\\ldots,g_{m-1}\\in\\mathbb{F}[X]</span>. For any non-negative integer <span class="math">d</span>, there are at most <span class="math">\\max(I)</span> values <span class="math">y\\in\\mathbb{F}</span> such that <span class="math">\\deg\\left(\\sum_{j=0}^{m-1}y^{i_{j}}g_{j}\\right)\\leq d</span> if <span class="math">\\deg g_{j}&gt;d</span> for some <span class="math">j\\in\\{0,\\ldots,m-1\\}</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">g_{j}\\eqqcolon\\sum_{k\\geq 0}a_{j,k}X^{k}</span>. Suppose that for some non-negative integer <span class="math">j&lt;m</span>, there exists an integer <span class="math">d^{\\prime}&gt;d</span> such that <span class="math">a_{j,d^{\\prime}}\\neq 0</span>. The term of degree <span class="math">d^{\\prime}</span> in <span class="math">X</span> of <span class="math">\\sum_{j=0}^{m-1}Y^{i_{j}}g_{j}\\in\\mathbb{F}[X][Y]</span> is <span class="math">\\sum_{j}Y^{i_{j}}a_{j,d^{\\prime}}</span>. It is a polynomial in <span class="math">Y</span> of degree at most <span class="math">\\max(I)</span>, so it has at most <span class="math">\\max(I)</span> roots, hence the claim. ∎</p>

    <p class="text-gray-300">Given integers <span class="math">d_{0},\\ldots,d_{n-1}\\in\\{0,\\ldots,N_{\\max}-1\\}</span>, to check that polynomials <span class="math">f_{0},\\ldots,f_{n-1}\\in\\mathbb{F}[X]</span> satisfy <span class="math">\\deg f_{k}\\leq d_{k}</span> for all <span class="math">k</span>, the most straightforward way</p>

    <p class="text-gray-300">is to leverage the polynomial identity underlying the protocol for single degree checks. That is, checking at once that</p>

    <p class="text-gray-300"><span class="math">f_{k}\\cdot X^{N_{\\max}-1-d_{k}}-f_{k}X^{N_{\\max}-1-d_{k}}\\cdot 1=0</span></p>

    <p class="text-gray-300">for all <span class="math">0\\leq i&lt;n</span>. To do so, it suffices to consider each polynomial on the left-hand side in the above identities as the coefficients of a polynomial in <span class="math">\\mathbb{F}[X][Y]</span>, so by the polynomial-identity lemma, it suffices to check that</p>

    <p class="text-gray-300"><span class="math">\\sum_{k=0}^{n-1}y^{k}f_{k}\\cdot X^{N_{\\max}-1-d_{k}}=\\left(\\sum_{k=0}^{n-1}y^{k}f_{k}X^{N_{\\max}-1-d_{k}}\\right)\\cdot 1,</span></p>

    <p class="text-gray-300">for a uniformly random <span class="math">y</span> chosen by the verifier. However, performing this check via pairings would incur <span class="math">n</span> pairing computations. The root cause is that this approach essentially performs a degree check for each bound <span class="math">d_{k}</span> at each power <span class="math">y^{k}</span>. Alternatively, at the cost of an increase in prover computation and two extra rounds of interaction, it is possible to check a polynomial identity that requires only two pairings.</p>

    <h5 id="sec-44" class="text-base font-semibold mt-4">Outline.</h5>

    <p class="text-gray-300">The main idea is to lift the degree of all polynomials <span class="math">f_{0},\\ldots,f_{n-1}</span> to the same degree (without introducing new non-zero terms) and perform a single degree check. More concretely, for an integer <span class="math">d^{<em>}\\geq\\max d_{k}</span> and a random <span class="math">y\\in\\mathbb{F}</span> chosen by the verifier, the prover first commits to <span class="math">f\\coloneqq\\sum_{k=0}^{n-1}y^{k}X^{d^{</em>}-d_{k}+1}f_{k}</span>. Note that each polynomial <span class="math">X^{d^{<em>}-d_{k}+1}f_{k}</span> is of degree <span class="math">d^{</em>}+1</span>. The verifier then sends to the prover a random <span class="math">x\\in\\mathbb{F}^{*}</span>, and they run a single degree check on polynomial</p>

    <p class="text-gray-300"><span class="math">\\zeta_{x}</span> <span class="math">\\coloneqq f-\\sum_{k=0}^{n-1}y^{k}x^{d^{<em>}-d_{k}+1}f_{k}</span> <span class="math">=f-\\sum_{d\\in\\{d_{0},\\ldots,d_{n-1}\\}}x^{d^{</em>}-d+1}\\sum_{k\\colon d_{k}=d}y^{k}f_{k}</span></p>

    <p class="text-gray-300">with degree bound <span class="math">d^{*}+1</span>, and the prover also shows that <span class="math">\\zeta_{x}(x)=0</span>. The verifier leverages the homomorphic property of the scheme to compute a commitment to <span class="math">\\zeta_{x}</span> given the commitments to <span class="math">f_{0},\\ldots,f_{n-1}</span> and <span class="math">f</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\deg f&gt;d^{<em>}+1</span> or <span class="math">f-\\sum_{k}y^{k}X^{d^{</em>}-d_{k}+1}f_{k}\\neq 0</span> with non-negligible probability for adversarially computed polynomials <span class="math">f_{0},\\ldots,f_{n-1},f</span>, the probability that the value <span class="math">x</span> chosen by the verifier is both a root of <span class="math">f-\\sum_{k}y^{k}X^{d^{<em>}-d_{k}+1}f_{k}</span> and in the set of values <span class="math">\\alpha\\in\\mathbb{F}</span> such that <span class="math">\\deg\\left(f-\\sum_{k}y^{k}\\alpha^{d^{</em>}-d_{k}+1}f_{k}\\right)\\leq d^{<em>}+1</span> is negligible. Indeed, if <span class="math">\\deg f&gt;d^{</em>}+1</span>, then the probability that <span class="math">x</span> is in the set of such values <span class="math">\\alpha</span> is at most $(d^{*}-\\min d_{k}+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by Lemma 5.1, and if </span>f-\\sum_{k}y^{k}X^{d^{<em>}-d_{k}+1}f_{k}\\neq 0<span class="math">, then the probability that </span>x<span class="math"> is one of its roots is at most </span>(N_{\\max}-1)\\cdot(d^{</em>}-\\min d_{k}+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore, by Lemma 2.1, if an adversary could compute with non-negligible probability commitments to polynomials </span>f<span class="math"> and </span>f_{k}<span class="math"> such that </span>\\deg f>d^{<em>}+1<span class="math"> or </span>f-\\sum_{k}y^{k}X^{d^{</em>}-d_{k}+1}f_{k}\\neq 0<span class="math">, the probability that the verifier accepts would be negligible. In other words, if the verifier accepts, then </span>\\deg f\\leq d^{*}+1$ and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">f - \\sum_{k} y^{k} X^{d^{<em>} - d_{k} + 1} f_{k} = 0</span> with overwhelming probability. A second application of Lemma 5.1 applied to <span class="math">X^{d^{</em>} - d_{0} + 1} f_{0}, \\ldots, X^{d^{*} - d_{n - 1} + 1} f_{n - 1}</span> implies that with probability at least $1 - n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the choice of </span>y<span class="math">, </span>\\deg \\left(X^{d^{<em>} - d_{k} + 1} f_{k}\\right) \\leq d^{</em>} + 1<span class="math">, i.e., </span>\\deg f_{k} \\leq d_{k}<span class="math"> for all </span>k \\in \\{0, \\dots, n - 1\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The KZG evaluation proof and the degree-check protocol from Section 5.1 allow to separately prove both statements <span class="math">\\zeta_{x}(x) = 0</span> and <span class="math">\\deg (\\zeta_x)\\leq d^* +1</span>. These statements can however be simultaneously proved in a single proof using the protocol from Section 5.2 (that is why challenge <span class="math">x</span> must be non-zero).</p>

    <p class="text-gray-300"><strong>Formal Description.</strong> Given parameters <span class="math">par</span> generated by KZG.SETUP, the protocol which follows is for the language⁵</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{(C _ {k}, 0 \\leq d _ {k} &amp;lt; N _ {\\max } - 1) _ {k = 0} ^ {n - 1}: \\forall k, \\exists (f _ {k} \\in \\mathbb {F} [ X ] ^ {\\leq d _ {k}}, r _ {k} \\in \\mathbb {F}), \\right. \\\\ \\left. \\quad \\mathrm {K Z G . O P E N} \\left(C _ {k}, f _ {k}, r _ {k}\\right) = 1 \\right\\}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">d^{*} \\in \\{\\max(d_{k}), \\ldots, N_{\\max} - 2\\}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P} \\leftarrow \\mathbf {V}: y \\leftarrow_ {\\S} \\mathbb {F}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P} \\rightarrow \\mathbf {V}: \\text {O u t p u t} C _ {f} \\text {f o r} (C _ {f}, r) \\leftarrow \\mathrm {K Z G . C o m} \\left(f := \\sum_ {k = 0} ^ {n - 1} y ^ {k} X ^ {d ^ {*} - d _ {k} + 1} f _ {k}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P} \\leftarrow \\mathbf {V}: x \\leftarrow_ {\\S} \\mathbb {F} ^ {*}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P} \\rightarrow \\mathbf {V}: \\quad \\begin{array}{l} \\zeta_ {x} := f - \\sum_ {k = 0} ^ {n - 1} y ^ {k} x ^ {d ^ {*} - d _ {k} + 1} f _ {k} \\\\ \\pi \\leftarrow \\left[ q (\\tau) \\tau^ {N _ {\\max } - d ^ {*} - 1} \\right] _ {1} + s \\cdot [ \\xi ] _ {1}, \\text {f o r} q \\text {s u c h t h a t} \\zeta_ {x} = (X - x) q \\\\ \\delta \\leftarrow \\left(r - \\sum_ {k = 0} ^ {n - 1} y ^ {k} x ^ {d ^ {*} - d _ {k} + 1} r _ {k}\\right) \\cdot \\left[ \\tau^ {N _ {\\max } - d ^ {*} - 1} \\right] _ {1} - s \\cdot [ \\tau ] _ {1} + (s \\cdot x) \\cdot [ 1 ] _ {1} \\\\ \\text {O u t p u t} (\\pi , \\delta) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {V}: \\quad \\begin{array}{l} C _ {\\zeta_ {x}} \\leftarrow C _ {f} - \\sum_ {k = 0} ^ {n - 1} y ^ {k} x ^ {d ^ {*} - d _ {k} + 1} C _ {k} \\\\ e \\left(C _ {\\zeta_ {x}}, \\left[ \\tau^ {N _ {\\max } - (d ^ {*} + 1)} \\right] _ {2}\\right) \\stackrel {?} {=} e (\\pi , [ \\tau ] _ {2} - x \\cdot [ 1 ] _ {2}) + e (\\delta , [ \\xi ] _ {2}). \\end{array}</span></div>

    <p class="text-gray-300"><strong>Properties.</strong> The completeness of the protocol is implied by the homomorphic property of KZG commitments and the completeness of the protocol from Section 5.2.</p>

    <p class="text-gray-300">As for its knowledge soundness, the knowledge soundness of the protocol in Section 5.2 guarantees that a valid opening <span class="math">\\zeta</span> to <span class="math">C_f - \\sum_{k=0}^{n-1} y^k x^{d^<em> - d_k + 1} C_k</span>, such that <span class="math">\\deg(\\zeta_x) \\leq d^</em> + 1</span> and <span class="math">\\zeta_x(x) = 0</span>, can be extracted in the algebraic-group</p>

    <p class="text-gray-300">⁵ The protocol does not support <span class="math">N_{\\max} - 1</span> as a bound for any polynomial since the protocol from Section 5.2 is applied with degree bound <span class="math">d^{*} \\geq \\max(d_k) + 1</span>, and the latter cannot exceed <span class="math">N_{\\max} - 1</span>, the size of the reference reference. This is however without any loss of generality as any polynomial computed by the adversary necessarily has degree at most <span class="math">N_{\\max} - 1</span> in the algebraic-group model.</p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300">model given a valid proof <span class="math">\\pi</span>. For openings <span class="math">f, f_0, \\ldots, f_{n-1}</span> to <span class="math">C_f, C_0, \\ldots, C_{n-1}</span> extracted from an algebraic adversary, it follows that <span class="math">\\zeta_x</span> and <span class="math">f - \\sum_{k=0}^{n-1} y^k x^{d^<em> - d_k + 1} f_k</span> are both valid openings to <span class="math">C_f - \\sum_{k=0}^{n-1} y^k x^{d^</em> - d_k + 1} C_k</span>. If <span class="math">\\zeta_x</span> were not equal to <span class="math">f - \\sum_{k=0}^{n-1} y^k x^{d^* - d_k + 1} f_k</span>, then trapdoor <span class="math">\\tau</span> would be a root of their difference and could be recovered by factorisation [15,28]. On this account, under the <span class="math">(N_{\\max} - 1)</span>-DLOG assumption (and a fortiori under the <span class="math">(2N_{\\max} - 1)</span>-DLOG assumption), they are both equal with overwhelming probability. The reasoning given in the preamble then allows conclude that <span class="math">\\deg f_k \\leq d_k</span> for all <span class="math">k \\in \\{0, \\ldots, n-1\\}</span>.</p>

    <p class="text-gray-300">Given the trapdoor <span class="math">(\\tau, \\xi)</span>, a proof on commitments <span class="math">C_0, \\ldots, C_{n-1}</span> can be simulated by choosing <span class="math">y \\gets_{\\mathfrak{F}} \\mathbb{F}</span>, <span class="math">C_f \\gets_{\\mathfrak{F}} \\mathbb{G}_1</span>, <span class="math">x \\gets_{\\mathfrak{F}} \\mathbb{F}^<em></span>, <span class="math">C_{\\zeta_x}</span> as in the scheme, <span class="math">\\pi \\gets_{\\mathfrak{F}} \\mathbb{G}_1</span> and computing <span class="math">\\delta \\gets \\left( \\tau^{N_{\\max} - (d^</em> + 1)} C_{\\zeta_x} - \\pi(\\tau - x) \\right) \\xi^{-1}</span>.</p>

    <h2 id="sec-45" class="text-2xl font-bold">5.4 Generic Batched Degree Checks</h2>

    <p class="text-gray-300">The technique in Section 5.3 to batch degree-checks with multiple degree bounds is not limited to KZG commitments. It also applies to any knowledge sound degree-check protocol on homomorphic univariate commitments if the evaluation protocol is knowledge sound.</p>

    <p class="text-gray-300">The main difficulty is to prove the protocol knowledge sound in the standard model – which implies that if the resulting protocol is used in a larger protocol in which everything else is proved secure in the standard model, then the overall protocol is secure in the standard model. The idea to do so is, for enough values of <span class="math">y</span> that lead to a successful execution, to rewind any successful prover to the step right after it outputs <span class="math">C_f</span>, and obtain accepting protocol executions for enough values of <span class="math">x</span>. Openings to the input commitments <span class="math">C_0, \\ldots, C_{n-1}</span> can then be recovered by linear combination of openings extracted from the various executions of EVAL.</p>

    <p class="text-gray-300"><strong>Building Blocks.</strong> The scheme assumes the existence of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(SETUP, COM, OPEN, EVAL), a univariate-polynomial commitment scheme that is additively homomorphic</li>

      <li>DEG, a proof system for the language</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\{(C, d \\in \\mathbb {N} _ {\\geq 0}): \\exists (f \\in \\mathbb {F} [ X ] ^ {\\leq d}, r), \\operatorname {O P E N} (C, f, r) = 1 \\right\\}.</span></div>

    <p class="text-gray-300">The public inputs and witness are in the sets determined by SETUP.</p>

    <p class="text-gray-300"><strong>Formal Description.</strong> Given parameters <span class="math">par</span> generated by SETUP, the protocol which follows is for the language</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{(C_k, 0 \\leq d_k &amp;lt; N_{\\max} - 1) \\right\\}_{k=0}^{n-1}: \\forall k, \\exists (f_k \\in \\mathbb{F}[X]^{\\leq d_k}, r_k \\in \\mathbb{F}), \\\\ \\operatorname{Open}(C_k, f_k, r_k) = 1 \\}. \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">d^{*} \\in \\mathbb{Z}_{\\geq \\max(d_{k})}</span>.</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\leftarrow\\mathbf{V}: y\\leftarrow_{\\S}\\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\rightarrow\\mathbf{V}:</span> Output <span class="math">C_{f}</span> for <span class="math">(C_{f},r)\\leftarrow\\mathrm{COM}\\left(f\\coloneqq\\sum_{k=0}^{n-1}y^{k}X^{d^{*}-d_{k}+1}f_{k}\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\leftarrow\\mathbf{V}:</span></p>

    <p class="text-gray-300"><span class="math">x\\leftarrow_{\\S}\\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">C_{\\zeta_{x}}\\leftarrow C_{f}-\\sum_{k=0}^{n-1}y^{k}x^{d^{*}-d_{k}+1}C_{k}</span></p>

    <p class="text-gray-300">Output <span class="math">x</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}:</span></p>

    <p class="text-gray-300"><span class="math">\\zeta_{x}\\coloneqq f-\\sum_{k=0}^{n-1}y^{k}x^{d^{*}-d_{k}+1}f_{k}</span></p>

    <p class="text-gray-300"><span class="math">r_{\\zeta}\\leftarrow r-\\sum_{k=0}^{n-1}y^{k}x^{d^{*}-d_{k}+1}r_{k}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\rightleftharpoons\\mathbf{V}:</span> <span class="math">\\langle\\mathrm{DEG.P},\\mathrm{DEG.V}\\rangle\\left(C_{\\zeta_{x}},d^{*}+1;\\zeta_{x},r_{\\zeta}\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\rightleftharpoons\\mathbf{V}:</span> <span class="math">\\langle\\mathrm{Eval.P},\\mathrm{Eval.V}\\rangle\\left(C_{\\zeta_{x}},x,0;\\zeta_{x},r_{\\zeta}\\right).</span></p>

    <p class="text-gray-300">Properties. The completeness of the protocol is implied by the homomorphic property of the commitment scheme and the completeness of <span class="math">\\mathrm{DEG}</span> and <span class="math">\\mathrm{Eval}</span>.</p>

    <p class="text-gray-300">As regards the knowledge soundness of the protocol, consider an adversary <span class="math">(\\mathrm{A},\\mathrm{P}^{<em>})</span> which makes the verifier accept with probability <span class="math">p_{\\mathrm{P}^{</em>}}</span>. Suppose that <span class="math">\\mathrm{Eval}</span> is knowledge sound with error <span class="math">\\kappa_{\\mathrm{Eval}}</span>, and that <span class="math">p_{\\mathrm{P}^{<em>}}</span> is at least <span class="math">16\\kappa_{\\mathrm{Eval}}</span>. Let <span class="math">\\mathrm{E}_{\\mathrm{Eval}}</span> denote an extractor for <span class="math">\\mathrm{Eval}</span> that returns valid witnesses with a probability close to the success probability and up to a multiplicative polynomial factor <span class="math">p_{\\mathrm{Eval}}</span>. Similarly, suppose that <span class="math">\\mathrm{DEG}</span> is knowledge sound with error <span class="math">\\kappa_{\\mathrm{DEG}}</span> and that <span class="math">p_{\\mathrm{P}^{</em>}}</span> is at least <span class="math">16\\kappa_{\\mathrm{DEG}}</span>, and let <span class="math">\\mathrm{E}_{\\mathrm{DEG}}</span> denote an extractor for protocol <span class="math">\\mathrm{DEG}</span> (with factor <span class="math">p_{\\mathrm{DEG}}</span>).</p>

    <p class="text-gray-300">Let <span class="math">C_{0},\\ldots,C_{n-1}</span> denote the commitments returned by <span class="math">\\mathrm{A}</span> as part of the instance on which <span class="math">\\mathrm{P}^{*}</span> computes a proof. Those being valid commitments, let <span class="math">f_{0},\\ldots,f_{n-1}</span> be any corresponding openings, i.e., polynomials for which there exist <span class="math">r_{0},\\ldots,r_{n-1}\\in\\mathbb{F}</span> such that <span class="math">C_{k}=\\mathrm{COM}(f_{k};r_{k})</span>. The distribution of the tuple <span class="math">(f_{0},\\ldots,f_{n-1})</span> and <span class="math">y</span> (and <span class="math">x</span>) are independent, as the latter is chosen independently of the messages from the prover.</p>

    <p class="text-gray-300">Likewise, let <span class="math">C_{f}</span> denote the commitment output by <span class="math">\\mathrm{P}^{<em>}</span> in the second round of the protocol, and let <span class="math">f</span> be any opening to <span class="math">C_{f}</span>, i.e., any polynomial for which there exist <span class="math">r\\in\\mathbb{F}</span> such that <span class="math">C_{f}=\\mathrm{COM}(f;r)</span>. As above, the distributions of <span class="math">f</span> and <span class="math">x</span> are independent. It thus remains to define an extractor that can return, in expected polynomial time, such polynomials <span class="math">f_{0},\\ldots,f_{n-1}</span> with a probability that is close to <span class="math">p_{\\mathrm{P}^{</em>}}</span>, up to a factor that is polynomial in the security parameter and the size of the instance.</p>

    <p class="text-gray-300">For the upcoming analysis, it is important to stress that even though the choice of the specific openings returned by the extractor to follow may depend on <span class="math">y</span> and <span class="math">x</span>, the distribution of the extracted openings to <span class="math">C_{k}</span> are independent of</p>

    <p class="text-gray-300">6 This supposes that the verification algorithm can efficiently test whether a commitment is a valid.</p>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">any <span class="math">y</span> and <span class="math">x</span>. Moreover, given a fixed <span class="math">y</span>, the distribution of an extracted opening to <span class="math">C_f</span> is independent of <span class="math">x^7</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider now an algorithm E that is given black-box access to <span class="math">\\mathbf{P}^*</span>, and control over its randomness. For all <span class="math">d \\in \\{d_0, \\ldots, d_{n-1}\\}</span>, let $n_d :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{k : d_k = d\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (note that </span>\\sum_d n_d = n<span class="math">) and </span>m :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{d_0, \\ldots, d_{n-1}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Algorithm E proceeds as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For all <span class="math">d \\in \\{d_0, \\ldots, d_{n-1}\\}</span></p>

    <p class="text-gray-300">Repeat <span class="math">n_d</span> times</p>

    <p class="text-gray-300">Run <span class="math">\\langle \\mathbf{P}^*, \\mathbf{V} \\rangle</span></p>

    <p class="text-gray-300">If <span class="math">\\mathbf{V}</span> rejects, return <span class="math">\\perp</span></p>

    <p class="text-gray-300">Let <span class="math">y</span> denote the message <span class="math">\\mathbf{V}</span> sent in the first protocol round</p>

    <p class="text-gray-300">Repeat <span class="math">m + 1</span> times</p>

    <p class="text-gray-300">Rewind <span class="math">\\mathbf{P}^*</span> to the step right after it sends <span class="math">C_f</span></p>

    <div class="my-4 text-center"><span class="math-block">x \\leftarrow_{\\S} \\mathbb{F}</span></div>

    <p class="text-gray-300">Run <span class="math">\\langle \\mathbf{P}^*, \\mathbf{V} \\rangle</span> with <span class="math">y</span> and <span class="math">x</span> as first messages from <span class="math">\\mathbf{V}</span></p>

    <p class="text-gray-300">If <span class="math">\\mathbf{V}</span> rejects, return <span class="math">\\perp</span></p>

    <p class="text-gray-300">Rewind <span class="math">\\mathbf{P}^*</span> to the step right after <span class="math">\\mathbf{V}</span> sends <span class="math">x</span></p>

    <p class="text-gray-300">Run <span class="math">\\mathrm{E}_{\\mathrm{DEG}}</span> on <span class="math">\\mathbf{P}^*</span></p>

    <p class="text-gray-300">Rewind <span class="math">\\mathbf{P}^*</span> to the step right after DEG ends</p>

    <p class="text-gray-300">Run <span class="math">\\mathrm{E}_{\\mathrm{EVAL}}</span> on <span class="math">\\mathbf{P}^*</span></p>

    <p class="text-gray-300">If extract fails in either of the two steps, return <span class="math">\\perp</span></p>

    <p class="text-gray-300">If the two extracted polynomials are not equal, return <span class="math">\\perp</span></p>

    <p class="text-gray-300">End Repeat</p>

    <p class="text-gray-300">End Repeat</p>

    <p class="text-gray-300">End For</p>

    <p class="text-gray-300">Consider the event in which E does not abort, i.e., return <span class="math">\\perp</span>.</p>

    <p class="text-gray-300">For every <span class="math">(y,x)</span> generated, <span class="math">\\mathrm{E}_{\\mathrm{DEG}}</span> and <span class="math">\\mathrm{E}_{\\mathrm{EVAL}}</span> return an opening <span class="math">\\zeta_{y,x}</span> (the same) to</p>

    <div class="my-4 text-center"><span class="math-block">C_f - \\sum_{k=0}^{n-1} y^k x^{d^* - d_k + 1} C_k = C_f - \\sum_{d \\in \\{d_0, \\ldots, d_{n-1}\\}} x^{d^* - d + 1} \\sum_{k: d_k = d} y^k C_k</span></div>

    <p class="text-gray-300">such that <span class="math">\\zeta_{y,x}(x) = 0</span> and <span class="math">\\deg \\zeta_{y,x} \\leq d^* + 1</span>.</p>

    <p class="text-gray-300">For a given <span class="math">y</span>, there are <span class="math">m + 1</span> values <span class="math">x</span> which are generated. Consider the matrix consisting of rows <span class="math">\\left(1, (x^{d^* - d + 1})_{d \\in \\{d_0, \\ldots, d_{n-1}\\}}\\right)</span> for each value of <span class="math">x</span>. Regarding its determinant as a polynomial in each value <span class="math">x</span> generated, it is of total</p>

    <p class="text-gray-300">7 As a simplified example, if an adversary computes a commitment <span class="math">C</span> for which there are two possible openings <span class="math">f_0</span> and <span class="math">f_1</span>, even if the extractor has a much higher probability, depending on the prover, to return <span class="math">f_0</span> than to return <span class="math">f_1</span> via a computation that depends on <span class="math">y</span> and <span class="math">x</span>, the distribution of <span class="math">f_0</span> and <span class="math">f_1</span> are independent of <span class="math">y</span> and <span class="math">x</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">degree at most <span class="math">(d^{<em>}+1)(m+1)</span>, and it is non-zero because the monomial consisting of the product of its diagonal terms appears exactly once in the polynomial. The polynomial-identity lemma then implies that the matrix is singular with probability at most $(d^{</em>}+1)(m+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The probability that the matrix is singular for some </span>y<span class="math"> is thus at most </span>\\sum_{d}n_{d}(d^{*}+1)(m+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n(d^{*}+1)(m+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In case the matrix is invertible for all </span>y<span class="math">, algorithm E can recover, for all </span>y<span class="math">, an opening </span>\\zeta_{y}<span class="math"> to </span>\\sum_{k:\\,d_{k}=d}y^{k}C_{k}<span class="math"> via linear combination of the openings </span>\\zeta_{x,y}<span class="math">, and an opening </span>f_{y}<span class="math"> to </span>C_{f}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, for a given <span class="math">d\\in\\{d_{0},\\ldots,d_{n-1}\\}</span>, the determinant of the matrix consisting of rows <span class="math">\\left(y^{k}\\right)_{k:\\,d_{k}=d}</span> for each of the <span class="math">n_{d}</span> values <span class="math">y</span> generated has total degree at most <span class="math">n_{d}(n-1)</span>. It is also non-zero because the monomial consisting of the product of its diagonal terms appears exactly once in the polynomial. By the polynomial-identity lemma, the matrix is singular with probability at most $n_{d}(n-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Consequently, the probability that the matrix is singular for some </span>d<span class="math"> is at most </span>n(n-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If the matrix is invertible for all </span>d<span class="math">, algorithm E can recover, for all </span>d<span class="math">, an opening </span>f_{k}<span class="math"> to each </span>C_{k}<span class="math"> for all </span>k<span class="math"> such that </span>d_{k}=d<span class="math"> given openings </span>\\zeta_{y}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Although the choices of the extracted polynomials <span class="math">f_{k}</span> depend on the values <span class="math">x</span> and <span class="math">y</span>, the distributions of the extracted polynomials <span class="math">f_{k}</span> are independent of the values of <span class="math">x</span> and <span class="math">y</span> as explained above. Similarly, for a given <span class="math">y</span>, the choice of the extracted polynomial <span class="math">f_{y}</span> depends on the values <span class="math">x</span> but its distribution is independent of <span class="math">x</span>. Besides, for all <span class="math">y</span>, <span class="math">f_{y}=\\sum_{k}y^{k}X^{d^{*}-d_{k}+1}f_{k}</span> unless the binding property of the scheme is not satisfied, which occurs with probability at most <span class="math">\\varepsilon_{\\textsc{com}}</span>, if the supremal advantage of any expected PPT algorithm in the binding game of the commitment scheme is at most <span class="math">\\varepsilon_{\\textsc{com}}</span>. The arguments given in the preamble of Section 5.3 then apply.</p>

    <p class="text-gray-300">That is, for a given <span class="math">y</span>, if <span class="math">\\deg f_{y}&gt;d^{<em>}+1</span> or <span class="math">f_{y}-\\sum_{k}y^{k}X^{d^{</em>}-d_{k}+1}f_{k}\\neq 0</span>, then V accepts an interaction with a uniformly random <span class="math">x</span> with probability at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(d^{*}-\\min d_{k}+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(N_{\\max}-1)\\cdot(d^{*}-\\min d_{k}+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, the probability that V accepts <span class="math">m+1</span> interactions although <span class="math">\\deg f_{y}&gt;d^{<em>}+1</span> or <span class="math">f-\\sum_{k}y^{k}X^{d^{</em>}-d_{k}+1}f_{k}\\neq 0</span> is at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(N_{\\max}(d^{*}-\\min d_{k}+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{m+1}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, by Lemma 5.1 applied to <span class="math">X^{d^{<em>}-d_{0}+1}f_{0},\\ldots,X^{d^{</em>}-d_{n-1}+1}f_{n-1}</span>, the probability over the choice of <span class="math">y</span> that <span class="math">\\deg\\left(\\sum_{k}y^{k}X^{d^{<em>}-d_{k}+1}f_{k}\\right)\\leq d^{</em>}+1</span> although <span class="math">\\deg f_{k}\\leq d_{k}</span> for some <span class="math">k\\in\\{0,\\ldots,n-1\\}</span> is at most $n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore, the probability that for all </span>d<span class="math">, for all </span>n_{d}<span class="math"> values </span>y<span class="math"> generated uniformly at random, </span>\\deg\\left(\\sum_{k}y^{k}X^{d^{<em>}-d_{k}+1}f_{k}\\right)\\leq d^{</em>}+1<span class="math"> although </span>\\deg f_{k}\\leq d_{k}<span class="math"> for some </span>k\\in\\{0,\\ldots,n-1\\}$ is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\prod_{d}(n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{n_{d}}=(n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{n}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It remains to analyse the probability that E never aborts. Each initial run of <span class="math">\\langle\\mathrm{P}^{<em>},\\mathrm{V}\\rangle</span> succeeds with probability <span class="math">p_{\\mathrm{P}^{</em>}}</span> by assumption. E aborts due to a failed initial execution with probability at most <span class="math">1-\\prod_{d}p_{\\mathrm{P}^{<em>}}^{n_{d}}=1-p_{\\mathrm{P}^{</em>}}^{n}</span>.</p>

    <p class="text-gray-300">Moreover, by an averaging argument (sometimes referred to as a heavy-row argument), conditioned on the event that <span class="math">y</span> leads to a successful execution, for any real value <span class="math">0&lt;\\rho&lt;1</span>, with probability at least <span class="math">(1-\\rho)</span> over the choice of <span class="math">y</span>, the probability that <span class="math">\\mathrm{P}^{<em>}</span> convinces the verifier in a protocol execution with the first message being <span class="math">y</span> is at least <span class="math">\\rho\\cdot p_{\\mathrm{P}^{</em>}}</span>. For <span class="math">\\rho\\leftarrow 1/2</span>, with probability at least <span class="math">1/2</span> over the choice of <span class="math">y</span>, algorithm <span class="math">\\mathrm{P}^{<em>}</span> succeeds with probability at least <span class="math">p_{\\mathrm{P}^{</em>}}/2</span>, conditioned on the first message being <span class="math">y</span>. Consequently, the probability that <span class="math">\\mathrm{P}^{<em>}</span> succeeds with <span class="math">y</span> as first message given that <span class="math">y</span> leads to a success is at least <span class="math">(1/2)\\cdot(p_{\\mathrm{P}^{</em>}}/2)=p_{\\mathrm{P}^{*}}/4</span>.</p>

    <p class="text-gray-300">Similarly, with probability at least <span class="math">1/2</span> over the choice of <span class="math">x</span>, algorithm <span class="math">\\mathrm{P}^{<em>}</span> succeeds with probability at least <span class="math">p_{\\mathrm{P}^{</em>}}/8</span>, conditioned on the first and second messages from the verifier being <span class="math">y</span> and <span class="math">x</span>. On this account, the probability that <span class="math">\\mathrm{P}^{<em>}</span> succeeds with <span class="math">y</span> and <span class="math">x</span> as first messages from the verifier, conditioned on the event that they lead to a success, is at least <span class="math">p_{\\mathrm{P}^{</em>}}/16</span>. It means that E aborts due to a failed execution with <span class="math">y</span> and <span class="math">x</span> as first messages from the verifier with probability at most <span class="math">1-\\prod_{d}(p_{\\mathrm{P}^{<em>}}/16)^{n_{d}(m+1)}=1-(p_{\\mathrm{P}^{</em>}}/16)^{n(m+1)}</span>.</p>

    <p class="text-gray-300"><span class="math">p_{\\mathrm{P}^{*}}/16\\geq\\max(\\kappa_{\\textsc{deg}},\\kappa_{\\textsc{eval}})</span> by assumption, so for a given <span class="math">d</span>, <span class="math">y</span> and <span class="math">x</span>, extraction fails with probability at most</p>

    <p class="text-gray-300"><span class="math">1-\\left(p_{\\mathrm{P}^{<em>}}/16-\\kappa_{\\textsc{deg}}\\right)/p_{\\textsc{deg}}+1-\\left(p_{\\mathrm{P}^{</em>}}/16-\\kappa_{\\textsc{eval}}\\right)/p_{\\textsc{eval}}.</span></p>

    <p class="text-gray-300">If the supremal advantage of any expected PPT algorithm in the binding game of the commitment scheme is at most <span class="math">\\varepsilon_{\\textsc{com}}</span>, the extracted polynomials are not the same with probability at most <span class="math">\\varepsilon_{\\textsc{com}}</span>. It implies that E succeeds in the deg extraction, the eval extraction, and the extracted polynomials are equal with probability at least</p>

    <p class="text-gray-300"><span class="math">\\left(1-\\left(1-\\frac{(p_{\\mathrm{P}^{<em>}}/16-\\kappa_{\\textsc{deg}})}{p_{\\textsc{deg}}}+1-\\frac{(p_{\\mathrm{P}^{</em>}}/16-\\kappa_{\\textsc{eval}})}{p_{\\textsc{eval}}}+\\varepsilon_{\\textsc{com}}\\right)\\right)^{n(m+1)}</span> <span class="math">\\geq</span> <span class="math">\\exp\\left(-n(m+1)\\frac{\\varepsilon}{1-\\varepsilon}\\right)</span> <span class="math">=</span> <span class="math">\\exp\\left(-n(m+1)\\cdot\\varepsilon\\left(1+\\frac{\\varepsilon}{1-\\varepsilon}\\right)\\right)</span></p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\coloneqq 1-\\frac{(p_{\\mathrm{P}^{<em>}}/16-\\kappa_{\\textsc{deg}})}{p_{\\textsc{deg}}}+1-\\frac{(p_{\\mathrm{P}^{</em>}}/16-\\kappa_{\\textsc{eval}})}{p_{\\textsc{eval}}}+\\varepsilon_{\\textsc{com}}.</span></p>

    <p class="text-gray-300">That is because for any real number <span class="math">\\varepsilon\\neq 1</span>,</p>

    <p class="text-gray-300"><span class="math">1-\\varepsilon=\\frac{1-\\varepsilon}{1-\\varepsilon+\\varepsilon}=\\left(1+\\frac{\\varepsilon}{1-\\varepsilon}\\right)^{-1}\\geq\\exp\\left(-\\frac{\\varepsilon}{1-\\varepsilon}\\right),</span></p>

    <p class="text-gray-300">with the last inequality implied by the convexity of function <span class="math">\\exp</span>.</p>

    <p class="text-gray-300">In other words, E aborts because of a failed Deg extraction, a failed Eval extraction or non-equal extracted polynomials with probability at most</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 1 - \\exp \\left(- n (m + 1) \\cdot \\varepsilon \\left(1 + \\frac {\\varepsilon}{1 - \\varepsilon}\\right)\\right) \\\\ = 1 - \\exp \\left(- n (m + 1) \\cdot \\varepsilon (1 + o (1))\\right) \\quad \\text{as } \\varepsilon \\rightarrow 0. \\end{array}</span></div>

    <p class="text-gray-300">Overall, E extracts valid witness <span class="math">f_0, \\ldots, f_{n-1}</span> with probability at least</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 - n (m + 1) \\varepsilon_{\\mathrm{COM}} - n \\left(d^{*} + 1\\right) (m + 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- n (n - 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left(1 - p_{\\mathrm{P}^{<em>}}^{n}\\right) - \\left(1 - \\left(p_{\\mathrm{P}^{</em>}} / 16\\right)^{n (m + 1)}\\right) \\\\</li>

      <li>\\left(1 - \\exp \\left(- n (m + 1) \\cdot \\varepsilon \\left(1 + \\frac {\\varepsilon}{1 - \\varepsilon}\\right)\\right)\\right).</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">If necessary, algorithm E can be repeated enough times (up to a bound polynomial in <span class="math">\\lambda</span>) to make this probability as close to 1 as desired.</p>

    <p class="text-gray-300">To simulate the transcript of a protocol execution with V, assuming Com to be hiding and Deg and Eval to be honest-verifier zero-knowledge, it suffices to generate <span class="math">y</span> and <span class="math">x</span> independently and uniformly at random, send a commitment to a dummy value in lieu of <span class="math">C_f</span>, and to run the simulators for Deg and Eval.</p>

    <h2 id="sec-46" class="text-2xl font-bold">5.5 Batched KZG Evaluations with Degree Check</h2>

    <p class="text-gray-300">Lemma 5.1 and Lemma 5.2 below give a straightforward way to batch the evaluation proofs with degree check from Section 5.2 if the evaluation point and the degree bound is the same for all polynomials.</p>

    <p class="text-gray-300"><strong>Lemma 5.2.</strong> Let <span class="math">m</span> be a positive integer. Consider <span class="math">f_0, \\ldots, f_{m-1} \\in \\mathbb{F}[X]</span> as well as <span class="math">u, v_0, \\ldots, v_{n-1} \\in \\mathbb{F}</span>. If <span class="math">f_i(u) \\neq v_i</span> for some <span class="math">i \\in \\{0, \\ldots, m-1\\}</span>, then there are most <span class="math">m-1</span> values <span class="math">y \\in \\mathbb{F}</span> such that <span class="math">\\sum_i y^i (f_i - v_i) = 0 \\mod (X - u)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Polynomials <span class="math">\\sum_{i} Y^{i}(f_{i} - v_{i})</span> and <span class="math">\\sum_{i: f_{i}(u) \\neq v_{i}} Y^{i}(f_{i} - v_{i})</span> have the same image under the quotient map</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{F} [ X, Y ] \\to (\\mathbb{F} [ X ] / (X - u)) [ Y ].</span></div>

    <p class="text-gray-300">That image is non-zero as by assumption, <span class="math">X - u</span> does not divide <span class="math">f_{i} - v_{i}</span> for some <span class="math">i</span>. Since the ideal <span class="math">(X - u) \\cdot \\mathbb{F}[X]</span> is maximal in <span class="math">\\mathbb{F}[X]</span>, the integral ring <span class="math">\\mathbb{F}[X] / (X - u)</span> is a field, so the image of <span class="math">\\sum_{i: f_{i}(u) \\neq v_{i}} Y^{i}(f_{i} - v_{i})</span> under the above quotient map is a polynomial of degree at most <span class="math">m - 1</span>. Therefore, it has at most <span class="math">m - 1</span> roots in <span class="math">\\mathbb{F}[X] / (X - u)</span>, and thus also in <span class="math">\\mathbb{F}</span> because the restriction on <span class="math">\\mathbb{F}</span> of the quotient map <span class="math">\\mathbb{F}[X] \\to \\mathbb{F}[X] / (X - u)</span> is injective.</p>

    <p class="text-gray-300">33</p>

    <p class="text-gray-300">More precisely, for integers <span class="math">m \\geq 1</span> and <span class="math">0 \\leq d &amp;lt; N_{\\max}</span>, for committed polynomials <span class="math">f_0, \\ldots, f_{m-1}</span> with respective commitments <span class="math">C_0, \\ldots, C_{m-1}</span>, and for elements <span class="math">u \\in \\mathbb{F}^*, v_0, \\ldots, v_{m-1} \\in \\mathbb{F}</span>, proving that</p>

    <div class="my-4 text-center"><span class="math-block">f _ {0} (u) = v _ {0}, \\dots , f _ {m - 1} (u) = v _ {m - 1} \\text{ and } \\forall i \\in \\{0, \\dots , m - 1 \\}, \\deg (f _ {i}) \\leq d,</span></div>

    <p class="text-gray-300">is equivalent to proving that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{0, \\dots , m - 1 \\}, \\deg (f _ {i}) \\leq d, \\exists q _ {i} \\in \\mathbb {F} [ X ], f _ {i} - v _ {i} - (X - u) q _ {i} = 0.</span></div>

    <p class="text-gray-300">The idea is then to run the protocol from Section 5.2 with <span class="math">\\sum_{i}y^{i}C_{i}</span> as commitment, <span class="math">u</span> as evaluation point, <span class="math">\\sum_{i}y^{i}v_{i}</span> as target value, <span class="math">\\sum_{i}y^{i}f_{i}</span> as witness and <span class="math">\\left[\\sum_{i}y^{i}q_{i}\\right]_{1}</span> as proof, for a uniformly random <span class="math">y\\in \\mathbb{F}</span> chosen by the verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\deg f_i \\geq d</span> or <span class="math">f_i(u) \\neq v_i</span> for some <span class="math">0 \\leq i \\leq m-1</span> with non-negligible probability, given adversarial polynomials <span class="math">f_0, \\ldots, f_{m-1}</span> extracted from <span class="math">C_0, \\ldots, C_{m-1}</span> and a proof, then the probability that a uniformly random value <span class="math">y</span> chosen by the verifier is in both the set of values <span class="math">\\alpha \\in \\mathbb{F}</span> such that <span class="math">\\deg (\\sum_i \\alpha^i f_i) \\leq d</span> and the set of values <span class="math">\\alpha \\in \\mathbb{F}</span> such that <span class="math">\\sum_i \\alpha^i (f_i(u) - v_i) = 0</span> is negligible if $m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is. Indeed, if </span>\\deg f_i \\geq d<span class="math"> for some </span>i<span class="math">, then the probability that </span>y<span class="math"> is in the set of values </span>\\alpha \\in \\mathbb{F}<span class="math"> such that </span>\\deg (\\sum_i \\alpha^i f_i) \\leq d<span class="math"> is at most </span>(m-1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by Lemma 5.1. If </span>f_i(u) \\neq v_i<span class="math"> for some </span>i<span class="math">, then the probability that </span>y<span class="math"> is in the set of values </span>\\alpha \\in \\mathbb{F}<span class="math"> such that </span>\\sum_i \\alpha^i (f_i - v_i) = 0<span class="math"> mod </span>(X-u)<span class="math"> is at most </span>(m-1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by Lemma 5.2. Therefore, by Lemma 2.1, if an adversary could compute with non-negligible probability commitments to polynomials </span>f_0, \\ldots, f_{m-1}<span class="math">, as well as values </span>u, v_0, \\ldots, v_{n-1}<span class="math"> such that </span>\\deg f_i \\geq d<span class="math"> or </span>f_i(u) \\neq v<span class="math"> for some </span>i<span class="math">, then the soundness of the protocol from Section 5.2 implies that the probability that the verifier accepts is negligible. That is to say, if the verifier accepts, then with overwhelming probability, </span>\\deg f_i \\leq d<span class="math"> and </span>f_i(u) = v_i<span class="math"> for all </span>i \\in \\{0, \\ldots, m-1\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Formal Description.</strong> The protocol below is for the following language.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{\\left(\\left(C _ {i}, v _ {i}\\right) _ {i = 0} ^ {m - 1}, 0 &amp;lt; d &amp;lt; N _ {\\max }, u \\neq 0\\right): \\forall i, \\exists f _ {i} \\in \\mathbb {F} [ X ] ^ {\\leq d}, \\mathrm {K Z G . O P E N} \\left(C _ {i}, f _ {i}\\right) = 1, \\right. \\\\ \\left. f _ {i} (u) = v _ {i} \\right\\}. \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P} \\leftarrow \\mathbf {V}: y \\leftarrow_ {\\S} \\mathbb {F}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {P} \\rightarrow \\mathbf {V}: \\\\ s \\leftarrow_ {\\S} \\mathbb {F} \\\\ \\pi \\leftarrow \\left[ \\sum_ {i} y ^ {i} q _ {i} (\\tau) \\tau^ {N _ {\\max } - d} \\right] _ {1} + s \\cdot [ \\xi ] _ {1}, \\text{ for } q _ {i} \\text{ s.t. } f _ {i} - v _ {i} = (X - u) q _ {i} \\\\ \\delta \\leftarrow \\left(\\sum_ {i} y ^ {i} r _ {i}\\right) \\cdot \\left[ \\tau^ {N _ {\\max } - d} \\right] _ {1} - s \\cdot [ \\tau ] _ {1} + (s \\cdot u) \\cdot [ 1 ] _ {1} \\\\ \\text{Output} (\\pi , \\delta) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {V}: \\\\ C \\leftarrow \\sum_ {i} y ^ {i} C _ {i} \\\\ e \\left(C - \\left(\\sum_ {i} y ^ {i} v _ {i}\\right) \\cdot [ 1 ] _ {1}, \\left[ \\tau^ {N _ {\\max } - d} \\right] _ {2}\\right) \\stackrel {\\circ} {=} e \\left(\\pi , [ \\tau ] _ {2} - u \\cdot [ 1 ] _ {2}\\right) + e (\\delta , [ \\xi ] _ {2}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Properties.</p>

    <p class="text-gray-300">The completeness of the protocol stems from the homomorphic property of KZG commitments and the completeness of the protocol from Section 5.2.</p>

    <p class="text-gray-300">As for its knowledge soundness, the knowledge soundness of the protocol in Section 5.2 guarantees that a valid opening <span class="math">f</span> to the commitment <span class="math">\\sum_{i=0}^{m-1}y^{i}C_{i}</span> such that <span class="math">\\deg f\\leq d</span> and <span class="math">f(u)=\\sum_{i}y^{i}v_{i}</span>, can be extracted in the algebraic-group model given a valid proof <span class="math">\\pi</span>. For openings <span class="math">f_{0},\\ldots,f_{m-1}</span> to <span class="math">C_{0},\\ldots,C_{m-1}</span> extracted from an algebraic adversary, it follows that <span class="math">f</span> and <span class="math">\\sum_{i=0}^{m-1}f_{i}</span> are both valid openings to <span class="math">\\sum_{i=0}^{m-1}y^{i}f_{i}</span>. If <span class="math">f</span> were not equal to <span class="math">\\sum_{i=0}^{m-1}y^{i}f_{i}</span>, then the trapdoor <span class="math">\\tau</span> would be a root of their difference and could be recovered by factorisation <em>[15, 28]</em>. On this account, under the <span class="math">(N_{\\max}-1)</span>-DLOG assumption (and a fortiori under the <span class="math">(2N_{\\max}-1)</span>-DLOG assumption), they are both equal with overwhelming probability. The reasoning given in the preamble then allows to conclude that <span class="math">\\deg f_{i}\\leq d</span> and <span class="math">f_{i}(u)=v_{i}</span> for all <span class="math">i\\in\\{0,\\ldots,m-1\\}</span> with overwhelming probability.</p>

    <p class="text-gray-300">Given the trapdoor <span class="math">(\\tau,\\xi)</span>, a proof on commitments <span class="math">C_{0},\\ldots,C_{m-1}</span> can be simulated by choosing <span class="math">y\\leftarrow_{\\</span>}\\mathbb{F}<span class="math">, </span>\\pi\\leftarrow_{\\<span class="math">}\\mathbb{G}_{1}</span> and computing</p>

    <p class="text-gray-300"><span class="math">\\delta\\leftarrow\\left(\\tau^{N_{\\max}-d}\\sum_{i}y^{i}(C_{i}-v_{i})-\\pi(\\tau-u)\\right)\\xi^{-1}.</span></p>

    <h2 id="sec-47" class="text-2xl font-bold">6 Instantiation with Hiding KZG Commitments</h2>

    <p class="text-gray-300">This section instantiates the protocol from Section 4 with hiding KZG commitments. This results in a scheme in which the evaluation prover uses only <span class="math">n+2</span> random field elements for <span class="math">n</span>-linear polynomials, an exponential improvement w.r.t. traditional methods which require <span class="math">2^{n}</span> random nonces. That is made possible by the idea of checking a multivariate Euclidian-division equation (equivalent to correctness of the evaluation) via its image under the univariatisation map.</p>

    <p class="text-gray-300">To improve efficiency, the instantiation uses the protocol from Section 5.5 to batch the degree checks on the openings to commitments <span class="math">C_{k}</span>. This protocol ends by a check that a polynomial <span class="math">\\zeta_{x^{\\prime}}</span>, defined by a random <span class="math">x^{\\prime}</span> chosen by the verifier, satisfies <span class="math">\\zeta_{x^{\\prime}}(x^{\\prime})=0</span> and <span class="math">\\deg(\\zeta_{x^{\\prime}})\\leq d^{<em>}+1</span> for any <span class="math">d^{</em>}\\geq 2^{n-1}-1=\\deg\\left(\\mathcal{U}_{n}(q_{n-1})^{&lt;2^{n-1}}\\right)</span>.</p>

    <p class="text-gray-300">Moreover, since replacing the last check that <span class="math">Z_{x}(x)=0</span> in the generic protocol with a check that <span class="math">Z_{x}(x)=0</span> and <span class="math">\\deg Z_{x}\\leq 2^{n}-1</span> does not change the knowledge soundness of the scheme, the instantiation does so, uses <span class="math">x\\leftarrow x^{\\prime}</span>, and then using the protocol from Section 5.5, batches this check with the check that <span class="math">\\zeta_{x^{\\prime}}(x^{\\prime})=0</span> and <span class="math">\\deg(\\zeta_{x^{\\prime}})\\leq d^{<em>}+1</span>, for <span class="math">d^{</em>}\\coloneqq 2^{n}-2</span>. This means that the verifier ultimately need only do three pairing computations.</p>

    <p class="text-gray-300">Unfortunately, setting <span class="math">x\\leftarrow x^{\\prime}</span> implies that the knowledge soundness of the instantiation does not directly follows from that of the generic protocol and of the protocol in Section 5.5, and must be argued anew.</p>

    <p class="text-gray-300">Lastly, the following lemma shows that the degree check on the input commitment <span class="math">C</span> can be omitted since an opening polynomial can always be extracted from an algebraic adversary.</p>

    <p class="text-gray-300"><strong>Lemma 6.1.</strong> Let <span class="math">n</span> be a positive integer. Consider polynomials <span class="math">\\hat{f}, \\hat{q}_0, \\ldots, \\hat{q}_{n-1} \\in \\mathbb{F}[X]</span> and a tuple <span class="math">\\mathbf{u} \\in \\mathbb{F}^n</span>. Let <span class="math">f \\coloneqq \\mathcal{U}_n^{-1}\\left(\\hat{f}^{&amp;lt;2^n}\\right)</span>. If the equality</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{f} - v \\cdot \\Phi_n(X) = \\sum_k \\left(X^{2^k} \\Phi_{n-k-1} \\left(X^{2^{k+1}}\\right) - u_k \\cdot \\Phi_{n-k} \\left(X^{2^k}\\right)\\right) \\hat{q}_k</span></div>

    <p class="text-gray-300">holds and <span class="math">\\deg(\\hat{q}_k) &amp;lt; 2^k</span> for all <span class="math">0 \\leq i &amp;lt; n</span>, then <span class="math">\\deg(\\hat{f}) &amp;lt; 2^n</span> (hence <span class="math">\\hat{f} = \\hat{f}^{&amp;lt;2^n} = \\mathcal{U}_n(f)</span>) and <span class="math">f(\\mathbf{u}) = v</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By definition, <span class="math">\\deg(\\Phi_{n-k-1}) = 2^{n-k-1} - 1</span>, so <span class="math">\\deg\\left(\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)\\right) = 2^n - 2^{k+1}</span>, and <span class="math">\\deg\\left(X^{2^k} \\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)\\right) = 2^n - 2^k</span>. Since <span class="math">\\deg(\\hat{q}_k) \\leq 2^k - 1</span> by assumption, the equality implies that <span class="math">\\deg \\hat{f} \\leq 2^n - 1</span>.</p>

    <p class="text-gray-300">Besides, Lemmas 2.5.1 and 2.5.2, and Corollary 2.5.3.2 show that the equality holds if and only if <span class="math">f - v = \\sum_k (X_k - u_k) \\mathcal{U}_n^{-1}(\\hat{q}_k)</span>, which implies that <span class="math">f(\\mathbf{u}) = v</span>.</p>

    <p class="text-gray-300"><strong>Building Blocks</strong> The scheme assumes the existence of a generator GEN of bilinear group structures. In what follows, KZG denotes the univariate commitment scheme recalled in Section 3.5.3.</p>

    <p class="text-gray-300"><strong>Formal Description.</strong></p>

    <p class="text-gray-300"><strong>SETUP</strong> <span class="math">(1^\\lambda, n_{\\max} =: \\log_2 N_{\\max})</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbb{G} &amp;amp;\\coloneqq (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e) \\leftarrow \\mathrm{GEN} \\left(1^\\lambda\\right) \\\\ \\tau, \\xi &amp;amp;\\leftarrow \\mathbb{F}^* \\\\ srs &amp;amp;\\leftarrow \\left([1]_1, [\\tau]_1, \\ldots, \\left[\\tau^{N_{\\max}-1}\\right]_1, [\\xi]_1, [1]_2, [\\tau]_2, \\ldots, \\left[\\tau^{N_{\\max}-1}\\right]_2, [\\xi]_2\\right) \\\\ \\text{Return } par &amp;amp;\\leftarrow (\\mathbb{G}, srs). \\end{aligned}</span></div>

    <p class="text-gray-300"><strong>COM</strong> <span class="math">(f,n)</span>: Return <span class="math">(C,r) \\leftarrow \\mathrm{KZG.COM}(\\mathcal{U}_n(f))</span>.</p>

    <p class="text-gray-300"><strong>OPEN</strong> <span class="math">(C, f, n, r) \\to b \\in \\{0,1\\}</span>: Return <span class="math">b \\leftarrow \\mathrm{KZG.OPEN}(C, \\mathcal{U}_n(f), r)</span>.</p>

    <p class="text-gray-300"><strong>EVAL:</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbf{P}(C, \\mathbf{u} &amp;amp;= (u_0, \\ldots, u_{n-1}), v, f) \\to \\mathbf{V}(C, \\mathbf{u}, v): \\\\ \\text{For } (k = 0, \\ldots, n-1) \\left\\{ (C_k, r_k) \\leftarrow \\mathrm{KZG.COM} \\left( \\mathcal{U}_n(q_k)^{&amp;lt;2^k} \\right) \\right\\} \\\\ \\text{Output } (C_0, \\ldots, C_{n-1}) &amp;amp;\\quad d_k := 2^k - 1 \\end{aligned}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{P} \\leftarrow \\mathbf{V}: y \\leftarrow \\mathbb{F}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{P} \\to \\mathbf{V}:</span></div>

    <div class="my-4 text-center"><span class="math-block">(C_{\\hat{q}}, \\hat{r}) \\leftarrow \\mathrm{KZG.COM} \\left( \\hat{q} := \\sum_{k=0}^{n-1} y^k X^{2^n - d_k - 1} \\mathcal{U}_n(q_k)^{&amp;lt;2^k} \\right)</span></div>

    <p class="text-gray-300">Output <span class="math">C_{\\hat{q}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\leftarrow\\mathbf{V}:</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} x \\leftarrow_{\\S} \\mathbb{F}^*, z \\leftarrow_{\\S} \\mathbb{F} \\\\ \\left(C_{v,x}, 0\\right) &amp;amp;\\leftarrow \\mathrm{KZG.COM} \\left(v \\cdot \\Phi_n(x); 0\\right) \\\\ C_{Z_x} &amp;amp;\\leftarrow C - C_{v,x} - \\sum_k \\left(x^{2^k} \\Phi_{n-k-1} \\left(x^{2^{k+1}}\\right) - u_k \\cdot \\Phi_{n-k} \\left(x^{2^k}\\right)\\right) \\cdot C_k \\\\ \\text{Output } (x, z) \\end{aligned}</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\rightarrow \\mathbf{V}:</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} r_Z &amp;amp;\\leftarrow r - \\sum_k \\left(x^{2^k} \\Phi_{n-k-1} \\left(x^{2^{k+1}}\\right) - u_k \\cdot \\Phi_{n-k} \\left(x^{2^k}\\right)\\right) \\cdot r_k \\\\ r_\\zeta &amp;amp;\\leftarrow \\hat{r} - \\sum_{k=0}^{n-1} y^k x^{2^n - d_k - 1} r_k \\\\ \\text{Compute } q_\\zeta \\text{ and } q_Z \\text{ such that } \\zeta_x = (X - x) q_\\zeta \\text{ and } Z_x = (X - x) q_Z \\\\ \\pi &amp;amp;\\leftarrow \\left[(q_\\zeta(\\tau) + z \\cdot q_Z(\\tau)) \\tau^{N_{\\max} - (2^n - 1)} \\right]_1 + s \\cdot [\\xi]_1 \\text{ for } s \\leftarrow_{\\S} \\mathbb{F} \\\\ \\delta &amp;amp;\\leftarrow (r_\\zeta + z r_Z) \\cdot \\left[\\tau^{N_{\\max} - (2^n - 1)} \\right]_1 - s \\cdot [\\tau]_1 + (s \\cdot x) \\cdot [1]_1 \\\\ \\text{Output } (\\pi, \\delta) \\end{aligned}</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{V}:</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} C_{\\zeta_x} &amp;amp;\\leftarrow C_{\\hat{q}} - \\sum_{k=0}^{n-1} y^k x^{2^n - d_k - 1} C_k \\\\ C_{\\zeta,Z} &amp;amp;\\leftarrow C_{\\zeta_x} + z \\cdot C_{Z_x} \\\\ e \\left(C_{\\zeta,Z}, \\left[\\tau^{N_{\\max} - (2^n - 1)} \\right]_2\\right) &amp;amp;\\stackrel{\\circ}{=} e \\left(\\pi, [\\tau]_2 - x \\cdot [1]_2\\right) + e \\left(\\delta, [\\xi]_2\\right). \\end{aligned}</span></div>

    <p class="text-gray-300">Properties. The completeness of the evaluation protocol follows from the completeness of the generic protocol in Section 4, and of the protocols in Sections 5.3 and 5.5.</p>

    <p class="text-gray-300">As for the knowledge soundness of the protocol, given a commitment <span class="math">C</span> computed by an algebraic adversary, a polynomial <span class="math">\\hat{f} \\in \\mathbb{F}[X]</span> of degree at most <span class="math">N_{\\max} - 1</span> can be extracted. Likewise, a polynomial <span class="math">\\hat{q} \\in \\mathbb{F}[X]</span> and polynomials <span class="math">\\hat{q}_k \\in \\mathbb{F}[X]</span>, each of degree at most <span class="math">N_{\\max} - 1</span>, can be extracted from <span class="math">C_{\\hat{q}}</span> and <span class="math">C_k</span> for all <span class="math">k \\in \\{0, \\dots, n-1\\}</span>. The knowledge soundness of the protocol in Section 5.5 implies that polynomials <span class="math">\\zeta_x</span> and <span class="math">Z_x</span> of degree at most <span class="math">2^n - 1</span> such that <span class="math">\\zeta_x(x) = Z_x(x) = 0</span> can be extracted from <span class="math">C_{\\zeta_x}</span> and <span class="math">C_{Z_x}</span>. Under the <span class="math">(N_{\\max} - 1)</span>-DLOG assumption (and therefore also under the <span class="math">(2N_{\\max} - 1)</span>-DLOG assumption),</p>

    <div class="my-4 text-center"><span class="math-block">\\zeta_x = \\hat{q} - \\sum_{k=0}^{n-1} y^k x^{2^n - d_k - 1} \\hat{q}_k</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} Z_x &amp;amp;= \\hat{f} - v \\cdot \\Phi_n(x) \\\\ &amp;amp;\\quad - \\sum_k \\left(x^{2^k} \\Phi_{n-k-1} \\left(x^{2^{k+1}}\\right) - u_k \\cdot \\Phi_{n-k} \\left(x^{2^k}\\right)\\right) \\hat{q}_k. \\end{aligned}</span></div>

    <p class="text-gray-300">Similarly to the analysis of the protocol in Section 5.3, if <span class="math">\\deg\\hat{f}&gt;2^{n}-1</span> or <span class="math">\\hat{q}-\\sum_{k}y^{k}X^{2^{n}-d_{k}-1}\\hat{q}_{k}\\neq 0</span> or</p>

    <p class="text-gray-300"><span class="math">\\hat{f}\\neq v\\cdot\\Phi_{n}(X)+\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\hat{q}_{k},</span></p>

    <p class="text-gray-300">(this last “or” condition precisely comes from the fact that the same value <span class="math">x</span> was used to define both <span class="math">\\zeta_{x}</span> and <span class="math">Z_{x}</span>), then by Lemma 2.1, the probability that the verifier accepts, i.e., the probability that the value <span class="math">x</span> chosen by the verifier is a root of <span class="math">\\hat{q}-\\sum_{k}y^{k}X^{2^{n}-d_{k}-1}\\hat{q}_{k}</span>, a root of</p>

    <p class="text-gray-300"><span class="math">\\hat{f}-v\\cdot\\Phi_{n}(X)-\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\hat{q}_{k}</span></p>

    <p class="text-gray-300">and in the set of <span class="math">\\alpha\\in\\mathbb{F}</span> such that <span class="math">\\deg\\left(\\hat{q}-\\sum_{k}y^{k}\\alpha^{2^{n}-d_{k}-1}\\hat{q}_{k}\\right)\\leq 2^{n}-1</span> is negligible. That is, if the verifier accepts, then with overwhelming probability <span class="math">\\deg\\hat{q}_{k}\\leq d_{k}=2^{k}-1</span> for all <span class="math">k</span> by the analysis of knowledge soundness of the protocol in Section 5.3, and in addition to that,</p>

    <p class="text-gray-300"><span class="math">\\hat{f}-v\\cdot\\Phi_{n}(X)=\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\hat{q}_{k}.</span></p>

    <p class="text-gray-300">Lemma 6.1 shows that <span class="math">f\\coloneqq\\mathcal{U}_{n}^{-1}\\left(\\hat{f}\\right)</span> is such that <span class="math">f(\\boldsymbol{u})=v</span>. The multilinear polynomial <span class="math">f</span> is thus a valid witness.</p>

    <p class="text-gray-300">The honest-verifier zero-knowledge property of the protocol follows from that of the generic construction in Section 4 and of the protocols in Section 5.</p>

    <p class="text-gray-300">Efficiency. The protocol consists of 5 rounds of interaction during which the prover sends <span class="math">n+3</span> first-group elements and the verifier sends 3 field elements. The other costs are summarised in Table 2. The details are as follows.</p>

    <p class="text-gray-300">Computational Costs. The prover computes a <span class="math">\\mathbb{G}_{1}</span> Multi-Scalar Multiplication (MSM) of size <span class="math">2^{k}+1</span> for each commitment <span class="math">C_{k}</span> (one scalar multiplication is for the commitment to be hiding). It also computes an MSM of size at most <span class="math">N/2</span> to commit to <span class="math">\\hat{q}</span> as it has at most <span class="math">N/2-1</span> non-zero coefficients between degree <span class="math">2^{n-1}=2^{n}-d_{n-1}-1</span> and degree <span class="math">2^{n}-d_{0}-1=2^{n}-1</span>. Another MSM of size <span class="math">N=2^{n}</span> is necessary to compute <span class="math">\\pi</span> and a last one of size 3 to compute <span class="math">\\delta</span>. As shown in Section A.2, the prover can compute the coefficients of all <span class="math">\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}}</span> in <span class="math">2^{n+1}-3</span> additions and <span class="math">2^{n}-2</span> multiplications. Given that <span class="math">\\Phi_{n}</span> can be computed in <span class="math">n+1</span> multiplications and two additions (see Section 2.1), and that Ruffini’s rule can be used to compute <span class="math">q_{Z}</span> and <span class="math">q_{\\zeta}</span>, the prover can compute the coefficients for all these MSMs in <span class="math">O(N)</span> field operations with small constants.</p>

    <p class="text-gray-300">Note that in the non zero-knowledge variant of the scheme, standard KZG commitments are used and it reduces the number of prover group operations by <span class="math">\\log N+5</span>: one less per <span class="math">C_{k}</span> commitment, one less to commit to <span class="math">\\hat{q}</span>, one less to compute <span class="math">\\pi</span>, and there is no <span class="math">\\delta</span> term.</p>

    <p class="text-gray-300">The verifier computes  <span class="math">\\mathbb{G}_1</span>  MSMs of sizes 1,  <span class="math">n + 2</span> ,  <span class="math">n + 1</span>  and 2 to respectively compute  <span class="math">C_{v,x}</span> ,  <span class="math">C_{Z_x}</span> ,  <span class="math">C_{\\zeta_x}</span>  and  <span class="math">C_{\\zeta,Z}</span> . Four of the coefficients are 1, so the verifier does at most  <span class="math">2n + 2</span>  first-group scalar multiplications. It also performs a scalar multiplication and an addition in  <span class="math">\\mathbb{G}_2</span>  to compute  <span class="math">[\\tau]_2 - x \\cdot [1]_2</span> , and finally 3 pairing computations.</p>

    <p class="text-gray-300">Randomness Complexity. The prover generates  <span class="math">n</span>  uniformly random field elements for each commitment  <span class="math">C_k</span> , another one to compute  <span class="math">C_{\\hat{q}}</span>  and a last one to compute  <span class="math">\\pi</span> . The verifier generates three random nonces  <span class="math">x, y</span>  and  <span class="math">z</span> .</p>

    <p class="text-gray-300">Memory Costs. The memory costs on Table 2 do not take into account the input polynomial, commitment, evaluation point and claimed evaluation. They do not take into account the SRS either. Note however that the prover need not store any  <span class="math">\\mathbb{G}_2</span>  element from the SRS to compute evaluation proofs. As for the verifier, it must only store  <span class="math">[1]_1</span>  and  <span class="math">[\\xi]_1</span>  (to compute  <span class="math">C_{v,x}</span> ), and  <span class="math">[1]_2, [\\tau]_2, [\\xi]_2</span>  and  <span class="math">\\left[\\tau^{N_{\\max} - (2^n - 1)}\\right]_2</span>  for all  <span class="math">n \\in \\{1, \\ldots, \\log_2 N_{\\max}\\}</span> .</p>

    <p class="text-gray-300">Throughout the protocol, in addition to the field elements  <span class="math">x, y, z</span>  received from the verifier, the prover must store the coefficient of  <span class="math">\\mathcal{U}_n(q_k)</span>  (of degree at most  <span class="math">2^k - 1</span> ) for all  <span class="math">k \\in \\{0, \\dots, n-1\\}</span> , of  <span class="math">\\hat{q}</span>  (at most  <span class="math">N/2 - 1</span>  non-zero), of  <span class="math">q_Z</span>  (of degree at most  <span class="math">N - 2</span> ) and of  <span class="math">q_\\zeta</span>  (of degree at most  <span class="math">N/2 - 2</span> ). That is  <span class="math">3N - 3</span>  field elements.</p>

    <p class="text-gray-300">The verifier must store commitments  <span class="math">C_0, \\ldots, C_{n-1}</span> ,  <span class="math">C_{\\hat{q}}</span>  and proof  <span class="math">(\\pi, \\delta)</span>  in addition to its own challenges  <span class="math">x, y, z</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F ops.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e(·,·)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mem.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">∑n-1k=01·(2k+1)+1·N+1·N/2+1·3</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ (3N-3)·F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">1·1+1·(n+2)+1·(n+1)+1·2</td>

            <td class="px-3 py-2 border-b border-gray-700">1·2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ (n+3)·G+3·F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Costs for the prover and verifier.  <span class="math">N = 2^n</span>  is the number of coefficients of the input polynomial. The group operations are counted in terms of Multi-Scalar Multiplications (MSMs). For positive integers  <span class="math">k, \\ell, n, m</span> , the notation  <span class="math">k \\cdot n + \\ell \\cdot m</span>  means that the party must perform  <span class="math">k</span>  MSMs of size  <span class="math">n</span>  and  <span class="math">\\ell</span>  MSMs of size  <span class="math">m</span> . The memory costs do not account for the inputs to the parties, they only account for the costs of the field or group elements exchanged during the protocol and that the parties must maintain, once they are received, throughout the protocol to complete their computations.</p>

    <p class="text-gray-300">Recent SNARGs for arithmetic circuit-satisfiability leverage look-up arguments to improve efficiency. These allow provers to commit to the input and output of a function computed by a sub-part of the circuit, and to prove that they are in a pre-computed, public table of the function. This may in practice result</p>

    <p class="text-gray-300">in significant savings if computing the function is more resource-intensive than proving that the input-output pair is in the table, and even more so when the sub-circuit is repeated throughout the overall circuit.</p>

    <p class="text-gray-300">Some of these look-up arguments, e.g., Plookup <em>[13]</em>, require to prove evaluations of polynomials represented by a shift of witness values. That is, if <span class="math">\\bm{a}=(a_{0},\\ldots,a_{N-1})</span> represents witness values, these may be interpreted as the evaluations over <span class="math">\\{0,1\\}^{\\log N}</span> of a multilinear polynomial <span class="math">f</span> in <span class="math">\\log N</span> variables. The scheme in Section 4 gives a protocol to evaluate <span class="math">f</span> at any point <span class="math">\\bm{u}\\in\\mathbb{F}^{\\log N}</span>. If <span class="math">\\bm{a}_{\\leftarrow}</span> denotes the vector <span class="math">(a_{1},\\ldots,a_{N-1},a_{0})</span>, then these lookup arguments require to prove evaluations of the multilinear polynomial <span class="math">f_{\\leftarrow}</span> represented by <span class="math">\\bm{a}_{\\leftarrow}</span>.</p>

    <p class="text-gray-300">It is possible to commit to <span class="math">f</span> and <span class="math">f_{\\leftarrow}</span> and prove that the latter is the shift of the first, and then separately prove evaluations of these polynomials. A more efficient alternative is to only commit to <span class="math">f</span>, and use this commitment to prove evaluations of <span class="math">f_{\\leftarrow}</span>. This section covers this second approach.</p>

    <h5 id="sec-49" class="text-base font-semibold mt-4">Outline.</h5>

    <p class="text-gray-300">Given <span class="math">n\\in\\mathbb{N}_{\\geq 1}</span> (let <span class="math">N\\coloneqq 2^{n}</span>) and the evaluations <span class="math">\\bm{a}\\in\\mathbb{F}^{2^{n}}</span> over <span class="math">\\{0,1\\}^{n}</span> of a polynomial <span class="math">f\\in\\mathbb{F}[X_{0},\\ldots,X_{n-1}]^{\\preceq 1}</span>, with</p>

    <p class="text-gray-300"><span class="math">a_{i_{n-1},2^{n-1}+\\ldots+i_{0},2^{0}}\\coloneqq f(\\bm{i}),</span></p>

    <p class="text-gray-300">note that the polynomial <span class="math">f_{\\leftarrow}</span> corresponding to <span class="math">\\bm{a}_{\\leftarrow}\\coloneqq(a_{1},\\ldots,a_{N-1},a_{0})</span> satisfies the identity</p>

    <p class="text-gray-300"><span class="math">X\\cdot\\mathcal{U}_{n}\\left(f_{\\leftarrow}\\right)=\\mathcal{U}_{n}\\left(f\\right)-a_{0}+a_{0}X^{N}.</span></p>

    <p class="text-gray-300">To prove that <span class="math">f_{\\leftarrow}(\\bm{u})=v</span> for public <span class="math">\\bm{u}\\in\\mathbb{F}^{n}</span> and <span class="math">v\\in\\mathbb{F}</span>, by Lemma 2.3.1, it suffices to prove the existence of <span class="math">q_{f_{\\leftarrow},k}\\in\\mathbb{F}[X_{0},\\ldots,X_{k-1}]^{\\preceq 1}</span> for all <span class="math">0&lt;k&lt;n</span> and <span class="math">q_{f_{\\leftarrow},0}\\in\\mathbb{F}</span> such that <span class="math">f_{\\leftarrow}-v=\\sum_{k=0}^{n-1}(X_{k}-u_{k})q_{f_{\\leftarrow},k}</span>. From these two identities, and since <span class="math">\\mathcal{U}_{n}</span> is an isomorphism, it is sufficient to prove that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{n}(f)-a_{0}+a_{0}X^{N}-X\\cdot\\mathcal{U}_{n}(v)=X\\cdot\\left(\\sum_{k=0}^{n-1}\\mathcal{U}_{n}\\left(X_{k}q_{f_{\\leftarrow},k}\\right)-u_{k}\\mathcal{U}_{n}\\left(q_{f_{\\leftarrow},k}\\right)\\right).</span></p>

    <p class="text-gray-300">Lemmas 2.5.1 and 2.5.2, and Corollary 2.5.3.2 show that it is equivalent to prove that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{n}(f)-a_{0}+a_{0}X^{N}-X\\cdot\\mathcal{U}_{n}(v)</span> <span class="math">=X\\cdot\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\mathcal{U}_{n}(q_{f_{\\leftarrow},k})^{&lt;2^{k}}.</span></p>

    <p class="text-gray-300">Given a univariate commitment to <span class="math">\\mathcal{U}_{n}(f)</span>, which is a commitment to <span class="math">f</span> in the generic construction of Section 4, the idea of the protocol for shift evaluations is to test the above polynomial identity in the same manner as in the generic protocol. However, the verifier is not given <span class="math">a_{0}</span>, but it can be assumed without loss of practical generality that this value is always <span class="math">0</span>. Indeed, if <span class="math">\\bm{a}</span> represents the values of all the left inputs or all the right inputs or all the outputs across the entire circuit (as in the Plonk arithmetisation <em>[14]</em>), adding a leading <span class="math">0</span> to all input and output vectors corresponds to adding a dummy addition gate with <span class="math">0</span> as inputs and <span class="math">0</span> as output.</p>

    <p class="text-gray-300">Remark. Alternatively, if it is possible with the univariate scheme to prove committed evaluations, i.e., to prove knowledge of an opening <span class="math">v</span> to a public commitment and that it is the evaluation of a committed polynomial at a public point, and if the set of polynomial commitments and the set of committed evaluations are the same, then the prover can, in the first round of the protocol, send a commitment to <span class="math">a_0</span> and prove that it knows an opening that is the evaluation of the input polynomial at 0. The prover also sends a commitment to <span class="math">a_0X^N</span> and proves consistency with the commitment to <span class="math">a_0</span>. The verifier can leverage the homomorphic property of the commitments to proceed as in the generic protocol.</p>

    <p class="text-gray-300">Assuming that <span class="math">a_0 = 0</span>, the polynomial identity to check is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal{U}_n(f) - X \\cdot \\mathcal{U}_n(v) \\\\ = X \\cdot \\sum_k \\left(X^{2^k} \\Phi_{n-k-1} \\left(X^{2^{k+1}}\\right) - u_k \\cdot \\Phi_{n-k} \\left(X^{2^k}\\right)\\right) \\mathcal{U}_n(q_{f_{\\leftarrow}, k})^{&amp;lt;2^k}. \\end{array}</span></div>

    <p class="text-gray-300">A straightforward adaptation of the evaluation protocols in Sections 4 and 6 leads to a protocol to evaluate <span class="math">f_{\\leftarrow}</span> given a commitment to any multilinear polynomial <span class="math">f</span>. The only difference is that in the first rounds of those protocols, the prover commits in <span class="math">C_k</span> to <span class="math">\\mathcal{U}_n(q_{f_{\\leftarrow},k})^{&amp;lt;2^k}</span> instead of <span class="math">\\mathcal{U}_n(q_k)^{&amp;lt;2^k}</span>, and that the prover now computes <span class="math">C_{v,x}</span> as a commitment to <span class="math">v \\cdot x\\Phi_n(x)</span> and <span class="math">C_{Z_x}</span> as</p>

    <div class="my-4 text-center"><span class="math-block">C - C_{v,x} - x \\cdot \\sum_k \\left(x^{2^k} \\Phi_{n-k-1} \\left(x^{2^{k+1}}\\right) - u_k \\cdot \\Phi_{n-k} \\left(x^{2^k}\\right)\\right) \\cdot C_k.</span></div>

    <p class="text-gray-300">The proof of knowledge soundness is close to that of the protocol in Section 6.</p>

    <p class="text-gray-300">High-Degree Shifts. Assuming the first <span class="math">d</span> coefficients to be zero, i.e., <span class="math">a_0 = \\dots = a_{d-1} = 0</span>, the construction is readily adapted to shifts of degree <span class="math">d</span>, i.e., to prove evaluations of the polynomial defined by <span class="math">(a_d, \\ldots, a_{N-1}, a_0, \\ldots, a_{d-1})</span>. This assumption is once again attained in practice by adding to the execution trace as many dummy addition gates as necessary.</p>

    <p class="text-gray-300">The look-up techniques mentioned in Section 7 and which require evaluations of shifted polynomials typically require evaluations of a committed polynomial</p>

    <p class="text-gray-300">8 A straightforward way to do so with hiding KZG commitments is as follows. To prove that <span class="math">f - v = (X - u)q</span> while keeping <span class="math">v</span> private, the prover can compute a KZG commitment <span class="math">C_v</span> to <span class="math">v</span> with randomness <span class="math">r_v</span>, and in addition to a KZG proof <span class="math">\\pi</span> for the evaluation of <span class="math">f</span>, the prover also shows that <span class="math">C_v</span> is a commitment to a constant polynomial with the proof system from Section 5.1, i.e., the prover sends also <span class="math">\\pi_v \\leftarrow \\left[v \\cdot \\tau^{N_{\\max}-1}\\right]_1 + s_v \\cdot [1]_1</span> for <span class="math">s_v \\leftarrow \\mathbb{F}</span> and <span class="math">\\delta_v \\leftarrow r_v \\cdot \\left[\\tau^{N_{\\max}-1}\\right] - s_v \\cdot [1]_1</span>. The verifier then checks that <span class="math">e(C - C_v, [1]_2) = e([q(\\tau)]_1, [\\tau]_2 - u \\cdot [1]_2)</span> and that <span class="math">e(C_v, \\left[\\tau^{N_{\\max}-1}\\right]_2) = e(\\pi_v, [1]_2) + e(\\delta_v, [\\xi]_2)</span>.</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300">and its shift <em>at the same point</em>. This section then gives a technique to batch regular evaluations with those of shifted polynomials (assuming once again that the constant terms are zero) at the same point, in case the underlying univariate commitment is KZG.</p>

    <p class="text-gray-300">The main idea is to multiply by variable <span class="math">X</span> the polynomial identity that is checked for regular evaluations, so that the right-hand side of the equality has the same form as in the identity for shifted evaluations. More concretely, the identity that is now checked for regular evaluations is</p>

    <p class="text-gray-300"><span class="math">X\\left(\\mathcal{U}_{n}(f)-v\\cdot\\Phi_{n}(X)\\right)</span> <span class="math">=X\\cdot\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}},</span></p>

    <p class="text-gray-300">and recall from Section 7 that the identity for shifted evaluations is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{n}(f)-v\\cdot X\\Phi_{n}(X)</span> <span class="math">=X\\cdot\\sum_{k}\\left(X^{2^{k}}\\Phi_{n-k-1}\\left(X^{2^{k+1}}\\right)-u_{k}\\cdot\\Phi_{n-k}\\left(X^{2^{k}}\\right)\\right)\\mathcal{U}_{n}(q_{f_{\\leftarrow},k})^{&lt;2^{k}}.</span></p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">Outline</h3>

    <p class="text-gray-300">Given a positive integer <span class="math">n</span> and non-negative integers <span class="math">m</span> and <span class="math">\\ell</span>, commitments <span class="math">C_{0},\\ldots,C_{m-1}</span> and <span class="math">D_{0},\\ldots,D_{\\ell-1}</span> to multilinear polynomials <span class="math">f_{0},\\ldots,f_{m-1}</span> and <span class="math">g_{0},\\ldots,g_{\\ell-1}</span> in <span class="math">\\mathbb{F}[X_{0},\\ldots,X_{n-1}]^{\\leq 1}</span>, an evaluation point <span class="math">u\\in\\mathbb{F}^{n}</span> and claimed evaluations <span class="math">v_{0},\\ldots,v_{m-1}</span> and <span class="math">w_{0},\\ldots,w_{m-1}</span> in <span class="math">\\mathbb{F}</span>, to prove that <span class="math">f_{i}(u)=v_{i}</span> for all <span class="math">0\\leq i\\leq m-1</span> and that <span class="math">g_{i,\\leftarrow}(u)=w_{i}</span> for all <span class="math">0\\leq i\\leq\\ell-1</span>, the idea is to consider each term</p>

    <p class="text-gray-300"><span class="math">f_{i}-v_{i}-\\sum_{k}(X_{k}-u_{k})q_{f_{i},k}</span></p>

    <p class="text-gray-300">as the coefficients of degree <span class="math">0\\leq i\\leq m-1</span> of a polynomial in a variable <span class="math">X_{n}</span>, and each term</p>

    <p class="text-gray-300"><span class="math">g_{i,\\leftarrow}-w_{i}-\\sum_{k}(X_{k}-u_{k})q_{g_{i,\\leftarrow},k}</span></p>

    <p class="text-gray-300">as the coefficients of degree <span class="math">m\\leq i\\leq m+\\ell-1</span> of the same polynomial. The latter should be the zero polynomial (in <span class="math">X_{n}</span>), so the verifier tests it by checking it at a random point <span class="math">\\alpha\\in\\mathbb{F}</span>, i.e., the verifier sends it in the first round of the protocol. The verifier accepts if and only if the prover can show that the evaluation of <span class="math">f\\coloneqq\\sum_{i=0}^{m-1}\\alpha^{i}f_{i}+\\sum_{i=0}^{\\ell-1}\\alpha^{m+i}g_{i,\\leftarrow}</span> is <span class="math">v\\coloneqq\\sum_{i=0}^{m-1}\\alpha^{i}v_{i}+\\sum_{i=0}^{\\ell-1}\\alpha^{m+i}w_{i}</span>, i.e., if the prover can show that there exist polynomials <span class="math">q_{k}</span> such that <span class="math">f-v=\\sum_{k}(X_{k}-u_{k})q_{k}</span>. Note that the verifier can compute a commitment to <span class="math">f</span> given the input commitments, and that by uniqueness of polynomials <span class="math">q_{k}</span> (c.f. Lemma 2.3.1), <span class="math">q_{k}=\\sum_{i=0}^{m-1}\\alpha^{i}q_{f_{i},k}+\\sum_{i=0}^{\\ell-1}\\alpha^{m+i}q_{g_{i,\\leftarrow},k}</span>.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">Formal Description</h3>

    <p class="text-gray-300">The protocol is for the following language (algorithm Open denotes the algorithm from Section 6).</p>

    <p class="text-gray-300">\\[ \\left\\{(C_{i},v_{i})_{i=0}^{m-1},(D_{j},w_{j})_{j=0}^{\\ell-1},\\bm{u}\\colon\\forall i\\exists(f_{i},r_{i}),\\forall j\\exists(g_{j},r_{j}),\\textsc{Open}(C_{i},f_{i},r_{i})=1,\\right.\\\\ \\left.\\textsc{Open}(D_{j},g_{j},r_{j})=1,f_{i}(\\bm{u})=v_{i},g_{j,\\leftarrow}(\\bm{u})=w_{j}\\ \\right\\}. \\]</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\gets \\mathbf{V}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\leftarrow_ {\\S} \\mathbb {F}</span></div>

    <div class="my-4 text-center"><span class="math-block">v \\leftarrow \\sum_ {i = 0} ^ {m - 1} \\alpha^ {i} v _ {i} + \\sum_ {i = 0} ^ {\\ell - 1} \\alpha^ {m + i} w _ {i}</span></div>

    <p class="text-gray-300">Output  <span class="math">\\alpha</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\rightarrow \\mathbf{V}</span></p>

    <p class="text-gray-300">Compute  <span class="math">q_0,\\ldots ,q_{n - 1}</span>  such that  <span class="math">f - v = \\sum_{k}(X_{k} - u_{k})q_{k}</span></p>

    <p class="text-gray-300">For  <span class="math">(k = 0,\\dots ,n - 1)\\left\\{(C_{\\hat{q}_k},r_k)\\gets \\mathrm{KZG.COM}\\left(\\mathcal{U}_n(q_k)^{&amp;lt;  2^k}\\right)\\right\\}</span></p>

    <p class="text-gray-300">Output  <span class="math">\\left(C_{\\hat{q}_0},\\dots ,C_{\\hat{q}_{n - 1}}\\right)</span></p>

    <p class="text-gray-300"><span class="math">d_{k}\\coloneqq 2^{k} - 1</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\gets \\mathbf{V}:y\\gets_{\\S}\\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\rightarrow \\mathbf{V}</span></p>

    <p class="text-gray-300"><span class="math">(C_{\\hat{q}},\\hat{r})\\gets \\mathrm{KZG.COM}\\left(\\hat{q} := \\sum_{k = 0}^{n - 1}y^{k}X^{2^{n} - d_{k} - 1}\\mathcal{U}_{n}(q_{k})^{&amp;lt;  2^{k}}\\right)</span></p>

    <p class="text-gray-300">Output  <span class="math">C_{\\hat{q}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\gets \\mathbf{V}</span></p>

    <div class="my-4 text-center"><span class="math-block">x \\leftarrow_ {\\S} \\mathbb {F} ^ {*}, z \\leftarrow_ {\\S} \\mathbb {F}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(C _ {v, x}, 0\\right) \\leftarrow \\mathrm {K Z G . C O M} (v \\cdot x \\Phi_ {n} (x); 0)</span></div>

    <div class="my-4 text-center"><span class="math-block">C \\leftarrow x \\cdot \\sum_ {i = 0} ^ {m - 1} \\alpha^ {i} C _ {i} + \\sum_ {i = 0} ^ {\\ell - 1} \\alpha^ {m + i} D _ {i}</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {Z _ {x}} \\leftarrow C - C _ {v, x} - x \\cdot \\sum_ {k} \\left(x ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(x ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(x ^ {2 ^ {k}}\\right)\\right) \\cdot C _ {\\hat {q} _ {k}}</span></div>

    <p class="text-gray-300">Output  <span class="math">(x,z)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}\\rightarrow \\mathbf{V}</span></p>

    <div class="my-4 text-center"><span class="math-block">r \\leftarrow x \\cdot \\sum_ {i = 0} ^ {m - 1} \\alpha^ {i} r _ {i} + \\sum_ {i = 0} ^ {\\ell - 1} \\alpha^ {m + i} r _ {i}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {Z} \\leftarrow r - x \\cdot \\sum_ {k} \\left(x ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(x ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(x ^ {2 ^ {k}}\\right)\\right) \\cdot r _ {k}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {\\zeta} \\leftarrow \\hat {r} - \\sum_ {k = 0} ^ {n - 1} y ^ {k} x ^ {2 ^ {n} - d _ {k} - 1} r _ {k}</span></div>

    <p class="text-gray-300">Compute  <span class="math">q_{\\zeta}</span>  and  <span class="math">q_{Z}</span>  such that  <span class="math">\\zeta_{x} = (X - x)q_{\\zeta}</span>  and  <span class="math">Z_{x} = (X - x)q_{Z}</span></p>

    <p class="text-gray-300"><span class="math">\\pi \\gets \\left[(q_{\\zeta}(\\tau) + z\\cdot q_{Z}(\\tau))\\tau^{N_{\\max} - (2^{n} - 1)}\\right]_{1} + s\\cdot [\\xi ]_{1}</span>  for  <span class="math">s\\gets \\S \\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\delta \\gets (r_{\\zeta} + z r_{Z})\\cdot \\left[\\tau^{N_{\\max} - (2^{n} - 1)}\\right]_{1} - s\\cdot [\\tau ]_{1} + (s\\cdot x)\\cdot [1]_{1}</span></p>

    <p class="text-gray-300">Output  <span class="math">(\\pi ,\\delta)</span></p>

    <p class="text-gray-300">V:</p>

    <div class="my-4 text-center"><span class="math-block">C _ {\\zeta_ {x}} \\leftarrow C _ {\\hat {q}} - \\sum_ {k = 0} ^ {n - 1} y ^ {k} x ^ {2 ^ {n} - d _ {k} - 1} C _ {\\hat {q} _ {k}}</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {\\zeta , Z} \\leftarrow C _ {\\zeta_ {\\pi}} + z \\cdot C _ {Z _ {x}}</span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left(C _ {\\zeta , Z}, \\left[ \\tau^ {N _ {\\max } - (2 ^ {n} - 1)} \\right] _ {2}\\right) \\stackrel {?} {=} e \\left(\\pi , [ \\tau ] _ {2} - x \\cdot [ 1 ] _ {2}\\right) + e \\left(\\delta , [ \\xi ] _ {2}\\right).</span></div>

    <p class="text-gray-300">Properties. The completeness of the evaluation protocol follows by construction.</p>

    <p class="text-gray-300">Similarly to the proof of knowledge soundness of the protocol in Section 6, given a valid proof from an algebraic adversary, with overwhelming probability under the <span class="math">(N_{\\max} - 1)</span>-DLOG assumption, univariate polynomials <span class="math">\\hat{f}_0,\\dots ,\\hat{f}_{m - 1}</span> and <span class="math">\\hat{h}_0,\\dots ,\\hat{h}_{\\ell -1}</span>, and <span class="math">\\hat{q}_0,\\dots ,\\hat{q}_{n - 1}</span> can be extracted from <span class="math">C_0,\\ldots ,C_{m - 1}</span> and <span class="math">D_0,\\ldots ,D_{\\ell -1}</span>, and <span class="math">C_{\\hat{q}_0},\\ldots ,C_{\\hat{q}_{n - 1}}</span>, and are such that <span class="math">\\deg \\hat{q}_k\\leq 2^k -1</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} X \\sum_ {i = 0} ^ {m - 1} \\alpha^ {i} \\hat {f} _ {i} + \\sum_ {i = 0} ^ {\\ell - 1} \\alpha^ {m + i} \\hat {h} _ {i} \\\\ = v \\cdot X \\Phi_ {n} (X) + X \\sum_ {k} \\left(X ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(X ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(X ^ {2 ^ {k}}\\right)\\right) \\hat {q} _ {k}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This polynomial identity implies that <span class="math">X</span> divides <span class="math">\\sum_{i=0}^{\\ell-1} \\alpha^{m+i} h_i</span>, i.e., there exists a univariate polynomial <span class="math">\\hat{g}</span> such that <span class="math">\\sum_{i=0}^{\\ell-1} \\alpha^{m+i} \\hat{h}_i = X \\hat{g}</span>, which implies that <span class="math">\\sum_{i=0}^{\\ell-1} \\alpha^{m+i} \\hat{h}_i(0) = 0</span>.</p>

    <p class="text-gray-300">If there exists <span class="math">0 \\leq i \\leq \\ell - 1</span> such that <span class="math">\\hat{h}_i(0) \\neq 0</span>, then there at most <span class="math">m + \\ell - 1</span> values of <span class="math">\\alpha \\in \\mathbb{F}</span> such that <span class="math">\\sum_{i=0}^{\\ell-1} \\alpha^{m+i} \\hat{h}_i(0) = 0</span> because the polynomial <span class="math">X^m \\sum_{i=0}^{\\ell-1} \\hat{h}_i(0) X^i \\in \\mathbb{F}[X]</span> has at most <span class="math">\\ell</span> roots.</p>

    <p class="text-gray-300">In the event that <span class="math">h_i(0) = 0</span> for all <span class="math">i</span>, i.e., there exists <span class="math">\\hat{g}_i</span> such that <span class="math">\\hat{h}_i = X\\hat{g}_i</span> for all <span class="math">i</span>, then denoting</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\hat {f} := \\sum_ {i = 0} ^ {m - 1} \\alpha^ {i} \\hat {f} _ {i} + \\sum_ {i = 0} ^ {\\ell - 1} \\alpha^ {m + i} \\hat {g} _ {i} \\\\ = v \\cdot \\Phi_ {n} (X) + \\sum_ {k} \\left(X ^ {2 ^ {k}} \\Phi_ {n - k - 1} \\left(X ^ {2 ^ {k + 1}}\\right) - u _ {k} \\cdot \\Phi_ {n - k} \\left(X ^ {2 ^ {k}}\\right)\\right) \\hat {q} _ {k}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Lemma 6.1 shows that <span class="math">\\deg \\hat{f} \\leq 2^n - 1</span> and <span class="math">\\mathcal{U}_n^{-1}\\left(\\hat{f}\\right)(\\boldsymbol{u}) = v = \\sum_{i=0}^{m-1} \\alpha^i v_i + \\sum_{i=0}^{\\ell-1} \\alpha^{m+i} w_i</span>.</p>

    <p class="text-gray-300">Besides, Lemma 5.1 shows that there are at most <span class="math">m + \\ell - 1</span> values of <span class="math">\\alpha</span> such that <span class="math">\\deg \\hat{f} \\leq 2^n - 1</span> if <span class="math">\\deg \\hat{f}_i \\geq 2^n</span> for some <span class="math">0 \\leq i \\leq m - 1</span> or <span class="math">\\deg \\hat{g}_i \\geq 2^n</span> for some <span class="math">0 \\leq i \\leq \\ell - 1</span>.</p>

    <p class="text-gray-300">Moreover, there are at most <span class="math">m + \\ell - 1</span> values of <span class="math">\\alpha \\in \\mathbb{F}</span> such that <span class="math">\\mathcal{U}_n^{-1}\\left(\\hat{f}\\right)(u) = v</span> if <span class="math">\\mathcal{U}_n^{-1}\\left(\\hat{f}_i\\right)(u) \\neq v_i</span> for some <span class="math">0 \\leq i \\leq m - 1</span> or <span class="math">\\mathcal{U}_n^{-1}\\left(\\hat{g}_i\\right)(u) \\neq w_i</span> for some <span class="math">0 \\leq i \\leq \\ell - 1</span>.</p>

    <p class="text-gray-300">Lemma A.1 then implies that with overwhelming probability, <span class="math">\\mathcal{U}_n^{-1}\\left(\\hat{f}_i\\right)</span> and <span class="math">\\mathcal{U}_n^{-1}\\left(\\hat{g}_i\\right)</span> (and their respected randomness extracted from the commitments) are valid witnesses.</p>

    <p class="text-gray-300">Evaluations proofs can be simulated in a similar way as for the proofs in Section 6.</p>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">Acknowledgements. The authors thank Ariel Gabizon, Adrian Hamelink and Zachary J. Williamson for helpful discussions, and Sergei Iakovenko for corrections. Many thanks to Dimitrios Papadopoulos for helpful discussions about the zero-knowledge vSQL polynomial-delegation scheme <em>[34, Proof of Theorem 1]</em>.</p>

    <h2 id="sec-53" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Fast reed-solomon interactive oracle proofs of proximity. In: Chatzigiannakis, I., Kaklamanis, C., Marx, D., Sannella, D. (eds.) ICALP 2018. LIPIcs, vol. 107, pp. 14:1–14:17. Schloss Dagstuhl (Jul 2018). https://doi.org/10.4230/LIPIcs.ICALP.2018.14</li>

      <li>[2] Ben-Sasson, E., Chiesa, A., Gabizon, A., Riabzev, M., Spooner, N.: Interactive oracle proofs with constant rate and query complexity. In: Chatzigiannakis, I., Indyk, P., Kuhn, F., Muscholl, A. (eds.) ICALP 2017. LIPIcs, vol. 80, pp. 40:1–40:15. Schloss Dagstuhl (Jul 2017). https://doi.org/10.4230/LIPIcs.ICALP.2017.40</li>

      <li>[3] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for R1CS. In: Ishai, Y., Rijmen, V. (eds.) EUROCRYPT 2019, Part I. LNCS, vol. 11476, pp. 103–128. Springer, Heidelberg (May 2019). https://doi.org/10.1007/978-3-030-17653-2_4</li>

      <li>[4] Boneh, D., Boyen, X.: Short signatures without random oracles. In: Cachin, C., Camenisch, J. (eds.) EUROCRYPT 2004. LNCS, vol. 3027, pp. 56–73. Springer, Heidelberg (May 2004). https://doi.org/10.1007/978-3-540-24676-3_4</li>

      <li>[5] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive, Report 2020/081 (2020), https://eprint.iacr.org/2020/081</li>

      <li>[6] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Halo infinite: Proof-carrying data from additive polynomial commitments. In: Malkin, T., Peikert, C. (eds.) CRYPTO 2021, Part I. LNCS, vol. 12825, pp. 649–680. Springer, Heidelberg, Virtual Event (Aug 2021). https://doi.org/10.1007/978-3-030-84242-0_23</li>

      <li>[7] Bootle, J., Chiesa, A., Groth, J.: Linear-time arguments with sublinear verification from tensor codes. In: Pass, R., Pietrzak, K. (eds.) TCC 2020, Part II. LNCS, vol. 12551, pp. 19–46. Springer, Heidelberg (Nov 2020). https://doi.org/10.1007/978-3-030-64378-2_2</li>

      <li>[8] Bootle, J., Chiesa, A., Hu, Y., Orrù, M.: Gemini: Elastic SNARKs for diverse environments. In: Dunkelman, O., Dziembowski, S. (eds.) EUROCRYPT 2022, Part II. LNCS, vol. 13276, pp. 427–457. Springer, Heidelberg (May / Jun 2022). https://doi.org/10.1007/978-3-031-07085-3_15</li>

      <li>[9] Bootle, J., Chiesa, A., Liu, S.: Zero-knowledge IOPs with linear-time prover and polylogarithmic-time verifier. In: Dunkelman, O., Dziembowski, S. (eds.) EUROCRYPT 2022, Part II. LNCS, vol. 13276, pp. 275–304. Springer, Heidelberg (May / Jun 2022). https://doi.org/10.1007/978-3-031-07085-3_10</li>

      <li>[10] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: 2018 IEEE Symposium on Security and Privacy. pp. 315–334. IEEE Computer Society Press (May 2018). https://doi.org/10.1109/SP.2018.00020</li>

      <li>[11] Chen, B., Bünz, B., Boneh, D., Zhang, Z.: HyperPlonk: Plonk with linear-time prover and high-degree custom gates. In: Hazay, C., Stam, M. (eds.) EUROCRYPT 2023, Part II. LNCS, vol. 14005, pp. 499–530. Springer, Heidelberg (Apr 2023). https://doi.org/10.1007/978-3-031-30617-4_17</li>

    </ul>

    <p class="text-gray-300">12] Fuchsbauer, G., Kiltz, E., Loss, J.: The algebraic group model and its applications. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018, Part II. LNCS, vol. 10992, pp. 33–62. Springer, Heidelberg (Aug 2018). https://doi.org/10.1007/978-3-319-96881-0_2</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[13] Gabizon, A., Williamson, Z.J.: plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Report 2020/315 (2020), https://eprint.iacr.org/2020/315</li>

      <li>[14] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953 (2019), https://eprint.iacr.org/2019/953</li>

      <li>[15] von zur Gathen, J., Shoup, V.: Computing frobenius maps and factoring polynomials (extended abstract). In: 24th ACM STOC. pp. 97–105. ACM Press (May 1992). https://doi.org/10.1145/129712.129722</li>

      <li>[16] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: Johansson, T., Nguyen, P.Q. (eds.) EUROCRYPT 2013. LNCS, vol. 7881, pp. 626–645. Springer, Heidelberg (May 2013). https://doi.org/10.1007/978-3-642-38348-9_37</li>

      <li>[17] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: One-time programs. In: Wagner, D. (ed.) CRYPTO 2008. LNCS, vol. 5157, pp. 39–56. Springer, Heidelberg (Aug 2008). https://doi.org/10.1007/978-3-540-85174-5_3</li>

      <li>[18] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SIAM Journal on Computing 18(1), 186–208 (1989)</li>

      <li>[19] Groth, J.: Short pairing-based non-interactive zero-knowledge arguments. In: Abe, M. (ed.) ASIACRYPT 2010. LNCS, vol. 6477, pp. 321–340. Springer, Heidelberg (Dec 2010). https://doi.org/10.1007/978-3-642-17373-8_19</li>

      <li>[20] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: Abe, M. (ed.) ASIACRYPT 2010. LNCS, vol. 6477, pp. 177–194. Springer, Heidelberg (Dec 2010). https://doi.org/10.1007/978-3-642-17373-8_11</li>

      <li>[21] Lee, J.: Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. In: Nissim, K., Waters, B. (eds.) TCC 2021, Part II. LNCS, vol. 13043, pp. 1–34. Springer, Heidelberg (Nov 2021). https://doi.org/10.1007/978-3-030-90453-1_1</li>

      <li>[22] Lund, C., Fortnow, L., Karloff, H.J., Nisan, N.: Algebraic methods for interactive proof systems. In: 31st FOCS. pp. 2–10. IEEE Computer Society Press (Oct 1990). https://doi.org/10.1109/FSCS.1990.89518</li>

      <li>[23] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In: Cavallaro, L., Kinder, J., Wang, X., Katz, J. (eds.) ACM CCS 2019. pp. 2111–2128. ACM Press (Nov 2019). https://doi.org/10.1145/3319535.3339817</li>

      <li>[24] Paillier, P., Vergnaud, D.: Discrete-log-based signatures may not be equivalent to discrete log. In: Roy, B.K. (ed.) ASIACRYPT 2005. LNCS, vol. 3788, pp. 1–20. Springer, Heidelberg (Dec 2005). https://doi.org/10.1007/11593447_1</li>

      <li>[25] Papamanthou, C., Shi, E., Tamassia, R.: Signatures of correct computation. In: Sahai, A. (ed.) TCC 2013. LNCS, vol. 7785, pp. 222–242. Springer, Heidelberg (Mar 2013). https://doi.org/10.1007/978-3-642-36594-2_13</li>

      <li>[26] Ron-Zewi, N., Rothblum, R.D.: Local proofs approaching the witness length [extended abstract]. In: 61st FOCS. pp. 846–857. IEEE Computer Society Press (Nov 2020). https://doi.org/10.1109/FOCS46700.2020.00083</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setty, S.: Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In: Micciancio, D., Ristenpart, T. (eds.) CRYPTO 2020, Part III. LNCS, vol. 12172, pp. 704–737. Springer, Heidelberg (Aug 2020). https://doi.org/10.1007/978-3-030-56877-1_25</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>28. Shoup, V.: Factoring polynomials over finite fields: Asymptotic complexity vs. reality. In: Proceedings of the IMACS Symposium (1993)</li>

      <li>29. Thaler, J.: Time-optimal interactive proofs for circuit evaluation. In: Canetti, R., Garay, J.A. (eds.) CRYPTO 2013, Part II. LNCS, vol. 8043, pp. 71–89. Springer, Heidelberg (Aug 2013). https://doi.org/10.1007/978-3-642-40084-1_5</li>

      <li>30. Wahby, R.S., Tzialla, I., shelat, a., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: 2018 IEEE Symposium on Security and Privacy. pp. 926–943. IEEE Computer Society Press (May 2018). https://doi.org/10.1109/SP.2018.00060</li>

      <li>31. Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: Boldyreva, A., Micciancio, D. (eds.) CRYPTO 2019, Part III. LNCS, vol. 11694, pp. 733–764. Springer, Heidelberg (Aug 2019). https://doi.org/10.1007/978-3-030-26954-8_24</li>

      <li>32. Zhang, J., Liu, T., Wang, W., Zhang, Y., Song, D., Xie, X., Zhang, Y.: Doubly efficient interactive proofs for general arithmetic circuits with linear prover time. In: Vigna, G., Shi, E. (eds.) ACM CCS 2021. pp. 159–177. ACM Press (Nov 2021). https://doi.org/10.1145/3460120.3484767</li>

      <li>33. Zhang, J., Xie, T., Zhang, Y., Song, D.: Transparent polynomial delegation and its applications to zero knowledge proof. In: 2020 IEEE Symposium on Security and Privacy. pp. 859–876. IEEE Computer Society Press (May 2020). https://doi.org/10.1109/SP40000.2020.00052</li>

      <li>34. Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A zero-knowledge version of vSQL. Cryptology ePrint Archive, Report 2017/1146 (2017), https://eprint.iacr.org/2017/1146</li>

    </ul>

    <h2 id="sec-54" class="text-2xl font-bold">Appendix A Mathematical Preliminaries</h2>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">A.1 Conditional Probabilities</h3>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof (of Lemma 2.1).</h6>

    <p class="text-gray-300">As <span class="math">P[E_{0}\\cup\\cdots\\cup E_{n-1}]&gt;0</span> by hypothesis and</p>

    <p class="text-gray-300"><span class="math">P[E_{0}]+\\cdots+P[E_{n-1}]\\geq P[E_{0}\\cup\\cdots\\cup E_{n-1}],</span></p>

    <p class="text-gray-300">there exists <span class="math">0\\leq i\\leq n-1</span> such that <span class="math">P[E_{i}]&gt;0</span>.</p>

    <p class="text-gray-300">By definition of conditional probability,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P[\\cap_{i}H_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cup_{i}E_{i}]=P[(\\cap_{i}H_{i})\\cap(\\cup_{i}E_{i})]/P[\\cup_{i}E_{i}].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore,</p>

    <p class="text-gray-300">$$ \\begin{array}{l} P \\left[ \\cap_ {i} H _ {i} \\mid \\cup_ {i} E _ {i} \\right] \\leq \\sum_ {i: P \\left[ E _ {i} \\right] \\neq 0} P \\left[ \\left(H _ {0} \\cap \\dots \\cap H _ {n - 1}\\right) \\cap E _ {i} \\right] / P \\left[ E _ {0} \\cup \\dots \\cup E _ {n - 1} \\right] \\\\ \\leq \\sum_ {i: P [ E _ {i} ] \\neq 0} P \\left[ \\left(H _ {0} \\cap \\dots \\cap H _ {n - 1}\\right) \\cap E _ {i} \\right] / P [ E _ {i} ] \\\\ \\leq \\sum_ {i: P [ E _ {i} ] \\neq 0} P [ H _ {i} \\cap E _ {i} ] / P [ E _ {i} ] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_ {i: P [ E _ {i} ] \\neq 0} P [ H _ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E _ {i} ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300"><strong>Lemma A.1.</strong> Let <span class="math">n</span> be a positive integer and <span class="math">E_0, \\ldots, E_{n-1}, H_0, \\ldots, H_{n-1}</span> denote probability events in a discrete probability space. Suppose that <span class="math">P[E_0 \\cup \\dots \\cup E_{n-1}] &amp;gt; 0</span>. Then, for any <span class="math">0 \\leq i_0 \\leq n-1</span> such that <span class="math">P[E_{i_0}] &amp;gt; 0</span>,</p>

    <div class="my-4 text-center"><span class="math-block">P \\left[ \\cap_ {i} H _ {i} \\mid \\cup_ {i} E _ {i} \\right] \\leq P \\left[ H _ {i _ {0}} \\mid E _ {i _ {0}} \\right] + \\sum_ {i \\neq i _ {0}: P \\left[ E _ {i} \\overline {{E _ {i _ {0}}}} \\right] \\neq 0} P \\left[ H _ {i} \\mid E _ {i}, \\overline {{E _ {i _ {0}}}} \\right].</span></div>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} P \\left[ \\cap_ {i} H _ {i} \\mid \\cup_ {i} E _ {i} \\right] = P \\left[ \\cap_ {i} H _ {i} \\cap E _ {i _ {0}} \\cup \\left(\\cup_ {i \\neq i _ {0}} E _ {i} \\cap \\overline {{E _ {i _ {0}}}}\\right) \\right] / P \\left[ \\cup_ {i} E _ {i} \\right] \\\\ \\leq P \\left[ H _ {i _ {0}} \\mid E _ {i _ {0}} \\right] + \\sum_ {i \\neq i _ {0}: P \\left[ E _ {i} \\cap \\overline {{E _ {i _ {0}}}} \\right] \\neq 0} P \\left[ H _ {i} \\cap E _ {i} \\cap \\overline {{E _ {i _ {0}}}} \\right] / P \\left[ \\cup_ {j = 0} ^ {n - 1} E _ {j} \\right] \\\\ \\leq P \\left[ H _ {i _ {0}} \\mid E _ {i _ {0}} \\right] \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i \\neq i _ {0}: P [ E _ {i} \\cap \\overline {{E _ {i _ {0}}}} ] \\neq 0} P [ \\cap_ {i} H _ {i} \\cap E _ {i} \\cap \\overline {{E _ {i _ {0}}}} ] / P \\left[ E _ {i _ {0}} \\cup \\left(\\cup_ {j \\neq i _ {0}} E _ {j} \\cap \\overline {{E _ {i _ {0}}}}\\right) \\right] \\\\</li>

    </ul>

    <p class="text-gray-300">\\leq P \\left[ H _ {i _ {0}} \\mid E _ {i _ {0}} \\right] + \\sum_ {i \\neq i _ {0}: P \\left[ E _ {i} \\cap \\overline {{E _ {i _ {0}}}} \\right] \\neq 0} P \\left[ \\cap_ {i} H _ {i} \\cap E _ {i} \\cap \\overline {{E _ {i _ {0}}}} \\right] / P \\left[ E _ {i} \\cap \\overline {{E _ {i _ {0}}}} \\right] \\\\ \\leq P \\left[ H _ {i _ {0}} \\mid E _ {i _ {0}} \\right] + \\sum_ {i \\neq i _ {0}: P \\left[ E _ {i} \\overline {{E _ {i _ {0}}}} \\right] \\neq 0} P \\left[ H _ {i} \\mid E _ {i}, \\overline {{E _ {i _ {0}}}} \\right]. \\end{array} $$</p>

    <p class="text-gray-300">□</p>

    <h2 id="sec-57" class="text-2xl font-bold">A.2 Computation of the Quotient Polynomials.</h2>

    <p class="text-gray-300">Lemma 2.3.1 gives an expression for the <span class="math">q_{k}</span> polynomials in terms of <span class="math">f</span> and <span class="math">\\pmb{u}</span>. The following lemma and corollary give an explicit method to compute evaluations of these polynomials on <span class="math">\\{0,1\\}^n</span>, which is sufficient to compute their images under <span class="math">q_{n}</span>.</p>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">Lemma A.2.1. Let <span class="math">f</span> be an <span class="math">n</span>-linear polynomial with <span class="math">n &amp;gt; 1</span>. Consider <span class="math">\\mathbf{u} \\in \\mathbb{F}^n</span>. Let <span class="math">q_0 \\in \\mathbb{F}</span> and <span class="math">q_k \\in \\mathbb{F}[X_0, \\ldots, X_{k-1}]^{\\preceq 1}</span> for <span class="math">k \\in \\{1, \\ldots, n-1\\}</span> be such that <span class="math">f - f(\\mathbf{u}) = \\sum_k (X_k - u_k) q_k</span>. Define <span class="math">f_0 := f</span> and for any <span class="math">k = n-2</span> down to 0,</p>

    <div class="my-4 text-center"><span class="math-block">f_{n-1-k} := f - \\sum_{\\ell = k+1}^{n-1} (X_\\ell - u_\\ell) q_\\ell.</span></div>

    <p class="text-gray-300">Then, for any <span class="math">k \\in \\{0, \\ldots, n-1\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">q_k = f_{n-1-k} \\left(\\mathbf{X}_{&amp;lt;k}, u_k + 1, \\mathbf{X}_{&amp;gt;k}\\right) - f_{n-1-k} \\left(\\mathbf{X}_{&amp;lt;k}, u_k, \\mathbf{X}_{&amp;gt;k}\\right).</span></div>

    <p class="text-gray-300">Proof. By definition,</p>

    <div class="my-4 text-center"><span class="math-block">f_{n-1-k} = \\sum_{\\ell=0}^{k} (X_\\ell - u_\\ell) q_\\ell + f(\\mathbf{u}).</span></div>

    <p class="text-gray-300">Since <span class="math">q_\\ell \\in \\mathbb{F}[X_0, \\ldots, X_{\\ell-1}]^{\\preceq 1}</span>, it implies that</p>

    <div class="my-4 text-center"><span class="math-block">f_{n-1-k} \\left(\\mathbf{X}_{&amp;lt;k}, u_k + 1, \\mathbf{X}_{&amp;gt;k}\\right) = \\sum_{\\ell=0}^{k-1} (X_\\ell - u_\\ell) q_\\ell + q_k + f(\\mathbf{u})</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">f_{n-1-k} \\left(\\mathbf{X}_{&amp;lt;k}, u_k, \\mathbf{X}_{&amp;gt;k}\\right) = \\sum_{\\ell=0}^{k-1} (X_\\ell - u_\\ell) q_\\ell + f(\\mathbf{u}).</span></div>

    <p class="text-gray-300">The difference between the two equalities yields the result.</p>

    <p class="text-gray-300">Lemma A.2.2. For all <span class="math">k \\in \\{0, \\ldots, n-1\\}</span>, for all <span class="math">\\mathbf{i} \\in \\{0,1\\}^n</span>,</p>

    <div class="my-4 text-center"><span class="math-block">q_k(\\mathbf{i}) = f_{n-1-k} \\left(\\mathbf{i}_{&amp;lt;k}, 1, \\mathbf{i}_{&amp;gt;k}\\right) - f_{n-1-k} \\left(\\mathbf{i}_{&amp;lt;k}, 0, \\mathbf{i}_{&amp;gt;k}\\right).</span></div>

    <p class="text-gray-300">Proof. Lemma A.2.1 implies that</p>

    <div class="my-4 text-center"><span class="math-block">q_k(\\mathbf{i}) = f_{n-1-k} \\left(\\mathbf{i}_{&amp;lt;k}, u_k + 1, \\mathbf{i}_{&amp;gt;k}\\right) - f_{n-1-k} \\left(\\mathbf{i}_{&amp;lt;k}, u_k, \\mathbf{i}_{&amp;gt;k}\\right).</span></div>

    <p class="text-gray-300">Writing <span class="math">f_{n-1-k}</span> as <span class="math">\\sum_{\\mathbf{j} \\in \\{0,1\\}^n} f_{n-1-k}(\\mathbf{j}) L_{\\mathbf{j}}</span>, for <span class="math">\\mathbf{i} \\in \\{0,1\\}^n</span>,</p>

    <div class="my-4 text-center"><span class="math-block">f_{n-1-k} \\left(\\mathbf{i}_{&amp;lt;k}, u_k + 1, \\mathbf{i}_{&amp;gt;k}\\right) = \\sum_{\\mathbf{j} \\in \\{0,1\\}^n} f_{n-1-k}(\\mathbf{j}) L_{\\mathbf{j}} \\left(\\mathbf{i}_{&amp;lt;k}, u_k + 1, \\mathbf{i}_{&amp;gt;k}\\right).</span></div>

    <p class="text-gray-300">Notice that <span class="math">L_{\\mathbf{j}}(\\mathbf{i}_{&amp;lt;k}, u_k + 1, \\mathbf{i}_{&amp;gt;k})</span> is zero unless <span class="math">\\mathbf{i}_{&amp;lt;k} = \\mathbf{j}_{&amp;lt;k}</span> and <span class="math">\\mathbf{i}_{&amp;gt;k} = \\mathbf{j}_{&amp;gt;k}</span>. Therefore,</p>

    <p class="text-gray-300">$$ \\begin{array}{l} f_{n-1-k} \\left(\\mathbf{i}_{&lt;k}, u_k + 1, \\mathbf{i}_{&gt;k}\\right) \\\\ = f_{n-1-k} \\left(\\mathbf{i}_{&lt;k}, 1, \\mathbf{i}_{&gt;k}\\right) L_{\\left(\\mathbf{i}_{&lt;k}, 1, \\mathbf{i}_{&gt;k}\\right)} \\left(\\mathbf{i}_{&lt;k}, u_k + 1, \\mathbf{i}_{&gt;k}\\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>f_{n-1-k} \\left(\\mathbf{i}_{&lt;k}, 0, \\mathbf{i}_{&gt;k}\\right) L_{\\left(\\mathbf{i}_{&lt;k}, 0, \\mathbf{i}_{&gt;k}\\right)} \\left(\\mathbf{i}_{&lt;k}, u_k + 1, \\mathbf{i}_{&gt;k}\\right).</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Similarly,</p>

    <p class="text-gray-300"><span class="math">f_{n-1-k}\\left(\\bm{i}_{&lt;k},u_{k},\\bm{i}_{&gt;k}\\right)</span> <span class="math">=f_{n-1-k}\\left(\\bm{i}_{&lt;k},1,\\bm{i}_{&gt;k}\\right)L_{\\left(\\bm{i}_{&lt;k},1,\\bm{i}_{&gt;k}\\right)}\\left(\\bm{i}_{&lt;k},u_{k},\\bm{i}_{&gt;k}\\right)</span> <span class="math">+f_{n-1-k}\\left(\\bm{i}_{&lt;k},0,\\bm{i}_{&gt;k}\\right)L_{\\left(\\bm{i}_{&lt;k},0,\\bm{i}_{&gt;k}\\right)}\\left(\\bm{i}_{&lt;k},u_{k},\\bm{i}_{&gt;k}\\right).</span></p>

    <p class="text-gray-300">The difference of the two equalities and the observation that</p>

    <p class="text-gray-300"><span class="math">L_{\\left(\\bm{i}_{&lt;k},j_{k},\\bm{i}_{&gt;k}\\right)}\\left(\\bm{i}_{&lt;k},u_{k}+1,\\bm{i}_{&gt;k}\\right)-L_{\\left(\\bm{i}_{&lt;k},j_{k},\\bm{i}_{&gt;k}\\right)}\\left(\\bm{i}_{&lt;k},u_{k},\\bm{i}_{&gt;k}\\right)</span> <span class="math">=\\left(j_{k}+(-1)(1-j_{k})\\right)</span></p>

    <p class="text-gray-300">for any <span class="math">j_{k}\\in\\{0,1\\}</span> imply that</p>

    <p class="text-gray-300"><span class="math">q_{k}(\\bm{i})=f_{k}(\\bm{i}_{&lt;k},1,\\bm{i}_{&gt;k})-f_{k}(\\bm{i}_{&lt;k},0,\\bm{i}_{&gt;k}).</span></p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Corollary A.2.2.1.</h6>

    <p class="text-gray-300">For all <span class="math">k\\in\\{0,\\ldots,n-1\\}</span>, for all <span class="math">\\bm{i}\\in\\{0,1\\}^{k}</span>,</p>

    <p class="text-gray-300"><span class="math">q_{k}\\left(\\bm{i},\\bm{0}^{n-k}\\right)=f_{n-1-k}\\left(\\bm{i},1,\\bm{0}\\right)-f_{n-1-k}\\left(\\bm{i},0,\\bm{0}\\right).</span></p>

    <p class="text-gray-300">Moreover, if <span class="math">k&lt;n-1</span>, for any <span class="math">i_{k}\\in\\{0,1\\}</span>,</p>

    <p class="text-gray-300"><span class="math">f_{n-1-k}(\\bm{i},i_{k},\\bm{0})=f_{n-1-(k+1)}(\\bm{i},i_{k},0)+u_{k+1}q_{k+1}(\\bm{i},i_{k},\\bm{0}).</span></p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Lemma A.2.2 implies that</p>

    <p class="text-gray-300"><span class="math">q_{k}\\left(\\bm{i},\\bm{0}^{n-k}\\right)=f_{n-1-k}\\left(\\bm{i},1,\\bm{0}\\right)-f_{n-1-k}\\left(\\bm{i},0,\\bm{0}\\right).</span></p>

    <p class="text-gray-300">In addition to that, for <span class="math">k&lt;n-1</span>, by definition of <span class="math">f_{n-1-k}</span> and <span class="math">f_{n-1-(k+1)}</span>,</p>

    <p class="text-gray-300"><span class="math">f_{n-1-(k+1)}-f_{n-1-k}=(X_{k+1}-u_{k+1})q_{k+1}.</span></p>

    <p class="text-gray-300">Therefore, for any <span class="math">\\bm{j}\\in\\{0,1\\}^{n}</span> such that <span class="math">j_{k+1}=0</span>,</p>

    <p class="text-gray-300"><span class="math">f_{n-1-k}(\\bm{j})=f_{n-1-(k+1)}(\\bm{j})+u_{k+1}q_{k+1}(\\bm{j}).</span></p>

    <p class="text-gray-300">Applying this equality to <span class="math">(\\bm{i},0,\\bm{0})</span> and <span class="math">(\\bm{i},1,\\bm{0})</span> gives the claim. ∎</p>

    <p class="text-gray-300">Computation. The coefficient of the <span class="math">\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}}</span> polynomials for all <span class="math">0\\leq k\\leq n-1</span> can be computed as follows, in light of the expression in Lemma A.2.2 for the evaluations of <span class="math">q_{n-1}</span> in terms of <span class="math">f</span> and the relation in Corollary A.2.2.1 between the evaluations of <span class="math">q_{k}</span> and <span class="math">q_{k+1}</span>.</p>

    <p class="text-gray-300">By definition, the coefficients of <span class="math">\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}}</span> are the evaluations <span class="math">q_{k}\\left(\\bm{i},\\bm{0}^{n-k}\\right)</span> for all <span class="math">\\bm{i}\\in\\{0,1\\}^{k}.</span> Given the <span class="math">f(\\bm{i})</span> for all <span class="math">\\bm{i}\\in\\{0,1\\}^{n}</span> as input, the following algorithm computes the evaluations of <span class="math">\\mathcal{U}_{n}(q_{k})^{&lt;2^{k}}</span>.</p>

    <p class="text-gray-300">For <span class="math">k=n-1</span> down to <span class="math">0</span></p>

    <p class="text-gray-300">For <span class="math">\\bm{i}\\in\\{0,1\\}^{k}</span></p>

    <p class="text-gray-300">If <span class="math">k=n-1</span></p>

    <p class="text-gray-300"><span class="math">q_{n-1}(\\bm{i},0)\\leftarrow f_{0}(\\bm{i},1)-f_{0}(\\bm{i},0)</span></p>

    <p class="text-gray-300">Else</p>

    <p class="text-gray-300"><span class="math">q_{k}\\left(\\bm{i},\\bm{0}^{n-k}\\right)\\leftarrow f_{n-1-k}\\left(\\bm{i},1,\\bm{0}\\right)-f_{n-1-k}\\left(\\bm{i},0,\\bm{0}\\right)</span></p>

    <p class="text-gray-300">End If</p>

    <p class="text-gray-300">If <span class="math">k&gt;0</span></p>

    <p class="text-gray-300"><span class="math">f_{n-1-(k-1)}(\\bm{i},\\bm{0})\\leftarrow f_{n-1-k}(\\bm{i},\\bm{0})+u_{k}q_{k}(\\bm{i},\\bm{0})</span></p>

    <p class="text-gray-300">End If</p>

    <p class="text-gray-300">End For</p>

    <p class="text-gray-300">End For</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Costs.</h6>

    <p class="text-gray-300">In the above algorithm, for all <span class="math">\\bm{i}\\in\\{0,1\\}^{n-1}</span>, computing <span class="math">q_{n-1}(\\bm{i},0)</span> requires <span class="math">1</span> addition, and computing <span class="math">f_{1}(\\bm{i},0)</span> requires <span class="math">1</span> addition and <span class="math">1</span> multiplication. For <span class="math">1\\leq k\\leq n-2</span>, for all <span class="math">\\bm{i}\\in\\{0,1\\}^{k}</span>, computing <span class="math">q_{k}\\left(\\bm{i},\\bm{0}^{n-k}\\right)</span> entails <span class="math">1</span> addition, and computing <span class="math">f_{n-1-(k-1)}(\\bm{i},\\bm{0})</span> requires <span class="math">1</span> addition and <span class="math">1</span> multiplication. For <span class="math">k=0</span>, computing <span class="math">q_{0}</span> requires <span class="math">1</span> addition. In total, that is <span class="math">2^{n-1}<em>2+\\sum_{k=1}^{n-2}2^{k}</em>2+1=2^{n}+2*\\left(2^{n-1}-2\\right)+1=2^{n+1}-3</span> additions and <span class="math">2^{n-1}+\\sum_{k=1}^{n-2}2^{k}+1=2^{n-1}+\\left(2^{n-1}-2\\right)+1=2^{n}-2</span> multiplications.</p>

    <h2 id="sec-61" class="text-2xl font-bold">Appendix B Cryptographic Preliminaries</h2>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">B.1 Proof Systems</h3>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">B.1.1 Properties.</h4>

    <p class="text-gray-300">The properties of proof systems mentioned in Section 3.4 are defined as follows.</p>

    <h5 id="sec-64" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300">Formally, a proof system is sound if for all pairs <span class="math">(\\mathrm{A},\\mathrm{P}^{*})</span> of PPT algorithms,</p>

    <p class="text-gray-300">\\[ P\\left[\\mathrm{V}_{\\langle\\mathrm{P}^{*}(st),\\cdot\\rangle}(x)=1,x\\notin L_{R}\\colon\\begin{array}[]{c}R\\leftarrow\\mathrm{R}\\left(1^{\\lambda}\\right)\\\\ (par,\\tau)\\leftarrow\\mathrm{Setup}\\left(R\\right)\\\\ (st,x)\\leftarrow\\mathrm{A}(par)\\end{array}\\right] \\]</p>

    <p class="text-gray-300">is a negligible function of <span class="math">\\lambda</span>.</p>

    <h5 id="sec-65" class="text-base font-semibold mt-4">Knowledge Soundess.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A proof system is knowledge sound with error <span class="math">\\kappa</span> if for any PPT algorithm <span class="math">\\mathrm{P}^{<em>}</span>, there exists a real polynomial <span class="math">p</span> and an extractor <span class="math">\\mathrm{E}</span>, which runs in expected polynomial time and rewinding black-box access to <span class="math">\\mathrm{P}^{</em>}</span>, such that for any <span class="math">\\lambda\\in\\mathbb{Z}_{\\geq 1}</span>, for any <span class="math">R</span> in the range of <span class="math">\\mathrm{R}\\left(1^{\\lambda}\\right)</span> and any <span class="math">(par,\\tau)</span> in the range of <span class="math">\\mathrm{Setup}(R)</span>, for any PPT algorithm <span class="math">\\mathrm{A}</span>, for any <span class="math">(st\\in\\{0,1\\}^{<em>},x)\\leftarrow\\mathrm{A}(par)</span> such that $P\\left[\\mathrm{V}_{\\langle\\mathrm{P}^{</em>}(st),\\cdot\\rangle}(par,x)=1\\right]>\\kappa(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, the inequality</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P\\left[(x,w)\\in R\\colon w\\leftarrow\\mathrm{E}^{\\langle\\mathrm{P}^{*}(st),\\cdot\\rangle}(par,x)\\right]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\geq\\left(P\\left[\\mathrm{V}_{\\langle\\mathrm{P}^{*}(st),\\cdot\\rangle}(par,x)=1\\right]-\\kappa(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\right)/p(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">holds.</p>

    <p class="text-gray-300">Honest-Verifier Zero-Knowledge. A proof system is honest-verifier zero-knowledge if there exists a PPT simulator S such that for any PPT algorithm A, for all  <span class="math">R \\gets \\mathrm{R}(1^{\\lambda}), (par, \\tau) \\gets \\mathrm{SETUP}(R)</span> , for any state  <span class="math">st \\in \\{0, 1\\}^{*}</span>  and any instance-witness pair  <span class="math">(x, w) \\in R</span>  such that  <span class="math">P[(st, x, w) = \\mathrm{A}(par)]</span>  is nonnegligible,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P \\left[ \\mathrm {A} (s t, \\{\\langle P, V \\rangle (p a r, x; w) \\}) = 1 \\right] - P \\left[ \\mathrm {A} (s t, \\mathrm {S} (p a r, \\tau , x)) = 1 \\right] \\right</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">is a negligible function of  <span class="math">\\lambda</span> .</p>

    <h2 id="sec-66" class="text-2xl font-bold">B.2 Polynomial Commitments</h2>

    <p class="text-gray-300">B.2.1 Security Properties. A polynomial-commitment scheme is expected to satisfy the properties which follow.</p>

    <p class="text-gray-300"><strong>Biding.</strong> A polynomial-commitment scheme is computationally binding if for all  <span class="math">N \\in \\mathbb{N}_{\\geq 1}</span> , for any PPT algorithm A,</p>

    <div class="my-4 text-center"><span class="math-block">P \\left[ \\mathrm {O P E N} (p a r, C, f _ {i}, r _ {i}) = 1, f _ {0} \\neq f _ {1}: \\begin{array}{c} p a r \\leftarrow \\mathrm {S E T U P} \\left(1 ^ {\\lambda}, N\\right) \\\\ (C, (f _ {i}, r _ {i}) _ {i = 0, 1}) \\leftarrow \\mathrm {A} (p a r) \\end{array} \\right]</span></div>

    <p class="text-gray-300">is a negligible function of  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">A scheme is perfectly binding if for any valid commitment, there is exactly one polynomial to which it can be opened.</p>

    <p class="text-gray-300"><strong>Hiding.</strong> A polynomial-commitment scheme is computationally (resp. statistically) hiding if for all  <span class="math">N \\in \\mathbb{N}_{\\geq 1}</span> , for any PPT (resp. computationally unbounded) algorithm A,</p>

    <div class="my-4 text-center"><span class="math-block">P \\left[ \\begin{array}{c} p a r \\leftarrow \\mathrm {S E T U P} \\left(1 ^ {\\lambda}, N\\right) \\\\ (C, f _ {0}, f _ {1}, s t) \\leftarrow \\mathrm {A} (p a r) \\\\ b \\leftarrow_ {\\S} \\{0, 1 \\} \\\\ (C, r) \\leftarrow \\mathrm {C O M} (p a r, f _ {b}) \\\\ b ^ {\\prime} \\leftarrow \\mathrm {A} (s t, C) \\\\ \\text {f o r} \\beta \\in \\{0, 1 \\} \\\\ \\text {i f} f _ {\\beta} \\in \\mathbb {F} [ X ] ^ {&amp;lt;   N} \\text {a n d} f _ {1 - \\beta} \\notin \\mathbb {F} [ X ] ^ {&amp;lt;   N} \\\\ b ^ {\\prime} \\leftarrow_ {\\S} \\{0, 1 \\} \\end{array} \\right] - 1 / 2</span></div>

    <p class="text-gray-300">is a negligible function of  <span class="math">\\lambda</span> . A scheme is perfectly hiding if it is statistically hiding and the above difference is exactly nil.</p>

    <p class="text-gray-300"><strong>Evaluation Binding.</strong> A polynomial-commitment scheme is (computationally) evaluation biding if for all  <span class="math">N \\in \\mathbb{N}_{\\geq 1}</span> , for any pair  <span class="math">(\\mathrm{A}, \\mathrm{P}^{*})</span>  of PPT algorithms,</p>

    <div class="my-4 text-center"><span class="math-block">P \\left[ \\begin{array}{c c} \\mathrm {V} _ {\\langle \\mathrm {P} ^ {*} (s t), \\cdot \\rangle} (p a r, C, u, v) = 1, &amp;amp; p a r \\leftarrow \\mathrm {S E T U P} \\left(1 ^ {\\lambda}, N\\right) \\\\ \\mathrm {V} _ {\\langle \\mathrm {P} ^ {*} (s t), \\cdot \\rangle} (p a r, C, u, v ^ {\\prime}) = 1,: &amp;amp; (C, u, v, v ^ {\\prime}, s t) \\leftarrow \\mathrm {A} (p a r) \\end{array} \\right]</span></div>

    <p class="text-gray-300">is a negligible function of  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">B.2.2 Hiding KZG Commitments</p>

    <p class="text-gray-300">This section first explains the flaw in the proof <em>[34, Proof of Theorem 1]</em> of Zhang et al. for their polynomial-delegation scheme . Next comes a proof that the evaluation protocol of the hiding KZG commitment scheme (see Section 3.5.3) is knowledge sound under the <span class="math">q</span>-DLOG assumption in the algebraic-group model.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">On the Proof of Zhang et al.</h4>

    <p class="text-gray-300">The explanation which follows the notation and the page references of the e-print version <em>[34]</em> of the paper received on 2017-11-27. It is therefore not stand-alone as that would otherwise require to completely copy their proof until the critical step.</p>

    <p class="text-gray-300">In the proof, to compute a solution to the SDH problem, the reduction algorithm computes the Euclidian division of a univariate polynomial <span class="math">K^{\\prime}</span>, and it is crucial that it is non-constant. <span class="math">K^{\\prime}</span> is defined in terms of multivariate polynomials extracted from the adversary. To show that it is not constant, on page 9, a polynomial <span class="math">f^{{}^{\\prime\\prime}}</span> is defined in terms of polynomials <span class="math">q^{\\prime}_{1},...,q^{\\prime}_{\\ell+1}</span> extracted from the adversary, and in the second equality on page 10, variable <span class="math">x_{\\ell+1}</span> is substituted with <span class="math">0</span>.</p>

    <p class="text-gray-300">However, polynomial <span class="math">K^{\\prime}</span>, which is assumed for the sake of contradiction to be constant, is defined for specific values of <span class="math">\\rho_{2},...,\\rho_{\\ell+1}</span> chosen by the reduction algorithm and fixed in the parameters before the adversary chooses <span class="math">q^{\\prime}_{1},...,q^{\\prime}_{\\ell+1}</span>. These latter polynomials thus depend on <span class="math">\\rho_{2},...,\\rho_{\\ell+1}</span>. Substituting <span class="math">x_{\\ell+1}</span> with <span class="math">0</span> would amount to changing <span class="math">\\rho_{\\ell+1}</span> to <span class="math">0</span>, and therefore redefining these polynomials, i.e., redefining a new polynomial <span class="math">K^{\\prime}</span>, and the proof can therefore not hold.</p>

    <h4 id="sec-68" class="text-lg font-semibold mt-6">Knowledge Soundness</h4>

    <p class="text-gray-300">The knowledge soundness can be proved under the DLOG assumption with parameter <span class="math">N_{\\max}</span>. Suppose that there exists a PPT adversary <span class="math">(\\mathrm{A},\\mathrm{P}^{*})</span> which computes with non-negligible probability an instance <span class="math">(C,u,v)</span> and a valid proof <span class="math">(\\pi,\\delta)</span>.</p>

    <p class="text-gray-300">Since the adversary is algebraic, one can extract polynomials <span class="math">f</span>, <span class="math">g</span> and <span class="math">h</span> of degree at most <span class="math">N_{\\max}-1</span> as well as field elements <span class="math">r</span>, <span class="math">s</span> and <span class="math">t</span> such that</p>

    <p class="text-gray-300"><span class="math">C</span> <span class="math">=\\left[f(\\tau)+r\\xi\\right]_{1},\\quad\\pi=\\left[g(\\tau)+s\\xi\\right]_{1}</span> <span class="math">\\text{and}\\ \\ \\delta</span> <span class="math">=\\left[h(\\tau)+t\\xi\\right]_{1}.</span></p>

    <p class="text-gray-300">If <span class="math">f(u)=v</span>, then <span class="math">(f,r)</span> is a valid witness.</p>

    <p class="text-gray-300">Otherwise, i.e., in the event that <span class="math">f(u)\\neq v</span>, consider an algorithm <span class="math">\\mathrm{B}</span> that runs the adversary as sub-routine and interacts with a DLOG challenger with parameters <span class="math">N_{\\max}</span>. Upon receiving a DLOG tuple</p>

    <p class="text-gray-300"><span class="math">\\left([1]_{1},[\\tau]_{1},\\ldots,\\left[\\tau^{N_{\\max}}\\right]_{1},[1]_{2},[\\tau]_{2},\\ldots,\\left[\\tau^{N_{\\max}}\\right]_{2}\\right),</span></p>

    <p class="text-gray-300">algorithm <span class="math">\\mathrm{B}</span> chooses <span class="math">\\rho</span> uniformly at random in <span class="math">\\mathbb{F}^{*}</span>, computes <span class="math">[\\xi]_{1}\\leftarrow\\rho\\cdot\\left[x^{N_{\\max}+1}\\right]_{1}</span> and <span class="math">[\\xi]_{2}\\leftarrow\\rho\\cdot\\left[x^{N_{\\max}+1}\\right]_{2}</span> and sets the reference string as in the specification</p>

    <p class="text-gray-300">of the scheme. Note that the distribution of the SRS is the same as the one produced by the set-up algorithm.</p>

    <p class="text-gray-300">The pair <span class="math">(\\pi,\\delta)</span> being a valid proof w.r.t. <span class="math">(C,u,v)</span>, the verification pairing equation is satisfied, which means that</p>

    <p class="text-gray-300"><span class="math">f(\\tau)+r\\rho\\tau^{N_{\\max}}-v=\\left(g(\\tau)+s\\rho\\tau^{N_{\\max}}\\right)\\left(\\tau-u\\right)+\\left(h(\\tau)+t\\rho\\tau^{N_{\\max}}\\right)\\rho\\tau^{N_{\\max}}.</span></p>

    <p class="text-gray-300">Therefore, <span class="math">x</span> is a root of the polynomial</p>

    <p class="text-gray-300"><span class="math">k(X)\\coloneqq f+r\\rho X^{N_{\\max}}-v-\\left(g+s\\rho X^{N_{\\max}}\\right)\\left(X-u\\right)-\\left(h+t\\rho X^{N_{\\max}}\\right)\\rho X^{N_{\\max}}.</span></p>

    <p class="text-gray-300">The degree of <span class="math">k</span> is at most <span class="math">2N_{\\max}</span>, so if <span class="math">k</span> is a non-zero polynomial, B can recover <span class="math">\\tau</span> by factorisation in polynomial time <em>[15, 28]</em> and solve the DLOG problem. Therefore, it is enough to show that <span class="math">k\\neq 0</span>. Consider the linear map <span class="math">\\mathbb{F}[X,Y]^{\\leq N_{\\max}-1}\\to\\mathbb{F}_{N_{\\max}{}^{2}-1}[X]</span> that sends <span class="math">X^{i}Y^{j}</span> to <span class="math">X^{i}\\cdot\\left(\\rho X^{N_{\\max}}\\right)^{j}</span> for for <span class="math">0\\leq i,j\\leq N_{\\max}-1</span>. It is an isomorphism because <span class="math">\\rho\\neq 0</span> and the <span class="math">N_{\\max}</span>-ary decomposition of integers in <span class="math">\\left\\{0,\\ldots,{N_{\\max}}^{2}-1\\right\\}</span> is unique, i.e., any integer in this set is uniquely written as <span class="math">i+N_{\\max}\\cdot j</span> with <span class="math">i,j\\in\\left\\{0,\\ldots,N_{\\max}-1\\right\\}</span>. Note that</p>

    <p class="text-gray-300"><span class="math">\\ell(X,Y)\\coloneqq f(X)+rY-v-\\left(g(X)+sY\\right)\\left(X-u\\right)-\\left(h(X)+tY\\right)Y</span></p>

    <p class="text-gray-300">is the pre-image of <span class="math">k</span> under this isomorphism. On this account, it is enough to show that <span class="math">\\ell(X,Y)\\neq 0</span>.</p>

    <p class="text-gray-300">The constant term of <span class="math">\\ell(X,Y)</span> as a polynomial in <span class="math">\\mathbb{F}[X][Y]</span> is <span class="math">f-v-g(X-u)</span>. It cannot be zero as it would otherwise imply that <span class="math">f(u)=v</span>. Therefore, <span class="math">\\ell(X,Y)\\neq 0</span> and B can solve the <span class="math">N_{\\max}</span>-DLOG problem.</p>

    <p class="text-gray-300">In other words, the probability that a valid witness can be extracted is at least the probability that <span class="math">\\left(\\mathrm{A},\\mathrm{P}^{*}\\right)</span> makes the verifier accept minus the supremal advantage of any PPT algorithm in solving the <span class="math">N_{\\max}</span>-DLOG problem. The latter assumed to be negligible, the probability that a valid witness is extracted is negligibly close to the probability that the verifier accepts.</p>`;
---

<BaseLayout title="Zeromorph: Zero-Knowledge Multilinear-Evaluation Proofs from... (2023/917)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/917
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
