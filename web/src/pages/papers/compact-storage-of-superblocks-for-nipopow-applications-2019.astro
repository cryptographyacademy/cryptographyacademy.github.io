---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1444';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Compact Storage of Superblocks for NIPoPoW Applications';
const AUTHORS_HTML = 'Kostis Karantias, Aggelos Kiayias, Nikos Leonardos, Dionysis Zindros';

const CONTENT = `    <p class="text-gray-300">Kostis Karantias^{1} Aggelos Kiayias^{2,4} Nikos Leonardos^{3} and Dionysis Zindros^{3,4}</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Blocks in proof-of-work (PoW) blockchains satisfy the PoW equation <span class="math">H(B)\\leq T</span>. If additionally a block satisfies <span class="math">H(B)\\leq T2^{-\\mu}</span>, it is called a <span class="math">\\mu</span>-superblock. Superblocks play an important role in the construction of compact blockchain proofs which allows the compression of PoW blockchains into so-called Non-Interactive Proofs of Proof-of-Work (NIPoPoWs). These certificates are essential for the construction of <em>superlight</em> clients, which are blockchain wallets that can synchronize exponentially faster than traditional SPV clients.</p>

    <p class="text-gray-300">In this work, we measure the distribution of superblocks in the Bitcoin blockchain. We find that the superblock distribution within the blockchain follows expectation, hence we empirically verify that the distribution of superblocks within the Bitcoin blockchain has not been adversarially biased. NIPoPoWs require that each block in a blockchain points to a sample of previous blocks in the blockchain. These pointers form a data structure called the <em>interlink</em>. We give efficient ways to store the interlink data structure. Repeated superblock references within an interlink can be omitted with no harm to security. Hence, it is more efficient to store a <em>set</em> of superblocks rather than a <em>list</em>. We show that, in honest executions, this simple observation reduces the number of superblock references by approximately a half in expectation. We then verify our theoretical result by measuring the improvement over existing blockchains in terms of the interlink sizes (which we improve by 79%) and the sizes of succinct NIPoPoWs (which we improve by 25%). As such, we show that deduplication allows superlight clients to synchronize 25% faster.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Bitcoin <em>[20]</em> and other blockchains which use the same backbone consensus mechanism <em>[12]</em> use Simple Payment Verification (SPV) to shorten the synchronization time for lightweight clients, where the clients need to download block headers instead of whole blocks. Recently, a line of work has introduced <em>superlight</em> clients, which do not require all blockchain headers to be downloaded, but, rather, only a sample of them. This sample consists of blocks which happen to achieve a higher difficulty than the required one, and are thus termed <em>superblocks</em>.</p>

    <p class="text-gray-300">By sampling the superblocks of a chain, short proofs about a blockchain can be created, which allow a client to synchronize with the longest blockchain without downloading all blocks. These so-called <em>proofs of proof-of-work</em> contain only a small number of cleverly chosen superblocks which compact the proof-of-work of the blockchain into a succinct string, while maintaining the same security level as SPV clients. However, while the protocol has even been deployed in practice, the distribution of superblocks within a blockchain has not been previously measured. In this paper, we provide measurements of this distribution for the Bitcoin blockchain.</p>

    <p class="text-gray-300">In order for superblock sampling to work, it is necessary that each block contains, in addition to the standard pointer to its previous block, a few select pointers to some preceding superblocks. These pointers are organized in a special data structure, the <em>interlink</em>. For relevant applications such as superlite clients and cross-chain transfers, it is critical that the interlink structure is compact. We measure the size of the interlink structure and provide a simple novel optimization which can bring down its size to less than a half. We then study the impact of this improvement on the size of proofs of proof-of-work.</p>

    <p class="text-gray-300">Related work. Superblocks were first observed to exist in <em>[19]</em>. The interlink data structure was put forth in <em>[15]</em>, where it was also observed that it can be organized into a Merkle tree. Interlinks containing all the blocks of the blockchain have been proposed in <em>[4]</em>. Superblock interlinks have been included from genesis in cryptocurrencies such as ERGO <em>[8]</em> and nimiq <em>[9]</em>. Complete blockchain interlinks have been proposed for Ethereum <em>[6]</em>. Nimiq and ERGO have independently applied interlink deduplication in practice to save space <em>[5, 8]</em>. In <em>[16]</em>, the consumption of the interlink data to construct Non-Interactive Proofs of Proof-of-Work was presented and concrete numbers were given about the sizes of such proofs. They also presented a way to construct such a structure without a soft or hard fork, but a backwards compatible <em>velvet fork</em>, which was later explored in <em>[24]</em>. Bitcoin Cash has been velvet forked in this manner <em>[13]</em>. Beyond superlight clients, another application of NIPoPoWs are cross-chain transfers <em>[17]</em> between proof-of-work blockchains. Comparable constructions have also appeared for proof-of-stake blockchains <em>[14]</em>.</p>

    <p class="text-gray-300">Our contributions. The contributions of this paper are summarized as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We measure superblock distributions in Bitcoin. We observe that the distribution of superblocks follows expectation, indicating there are no ongoing or historical attempts to bias the distribution of superblocks</li>

    </ol>

    <p class="text-gray-300">(so-called badness attacks <em>[16]</em>). We are the first to collect any empirical measurements of superblocks on real blockchains.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We describe the simple but important optimization in regards to the way blocks are compactly stored in an interlink tree by observing that duplicate pointers can be removed without harming security. As such, we construct interlink block sets instead of interlink block lists.</li>

      <li>We prove that our optimization reduces the number of pointers in each interlink by a half in expectation.</li>

      <li>We evaluate our improvement on the Bitcoin blockchain and collect empirical data regarding the performance of our improvement, including concrete sizes of NIPoPoWs built. We experimentally demonstrate that our optimization reduces interlink vector sizes by 79% on average and the already very succinct NIPoPoW certificates by 25% on average.</li>

    </ol>

    <h2 id="sec-4" class="text-2xl font-bold">2 Superblocks and proofs-of-proofs</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Blocks generated in proof-of-work <em>[11]</em> systems must satisfy the proof-of-work equation <span class="math">H(B)\\leq T</span> where <span class="math">T</span> denotes the mining target <em>[3]</em> and <span class="math">B</span> denotes the block contents, which is a triplet including a representation of the application data and metadata, a nonce, and a reference to the previous block by its hash. The function <span class="math">H</span> is a hash function, modelled as a random oracle <em>[2]</em>, which outputs <span class="math">\\kappa</span> bits, where <span class="math">\\kappa</span> is the security parameter of the protocol and <span class="math">T&lt;2^{\\kappa}</span>. It sometimes happens that some blocks satisfy a stronger version of the equation <em>[15]</em>, namely that <span class="math">H(B)\\leq T2^{-\\mu}</span> for some <span class="math">\\mu\\in\\mathbb{N}</span>. Such blocks are called <span class="math">\\mu</span>-superblocks <em>[16]</em>. It follows directly from the Random Oracle model that $\\Pr[B\\text{ is a }\\mu\\text{-superblock}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\text{ is a valid block}]=2^{-\\mu}<span class="math">. Note that if a block is a </span>\\mu<span class="math">-superblock for some </span>\\mu>0<span class="math">, then it is also a </span>(\\mu-1)<span class="math">-superblock. We denote the maximum </span>\\mu<span class="math"> of a block </span>B<span class="math"> its </span>level(B)=\\lfloor\\lg(T)-\\lg(H(B))\\rfloor$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The count of superblocks in a chain decreases exponentially as <span class="math">\\mu</span> increases. If a blockchain <span class="math">\\mathcal{C}</span> generated in an honest execution has $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> blocks, it only has </span>2^{-\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> superblocks of level </span>\\mu<span class="math"> in expectation. Hence, the total number of levels is </span>\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ in expectation. It has been theoretically posed that the distribution of superblocks can be adversarially biased in so-called “badness” attacks <em>[16]</em> in which an adversary reduces the density of superblocks of a particular level within a blockchain. However, the actual distribution of superblocks in currently deployed blockchains</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">has not been measured. Therefore, it was previously unknown whether such attacks are taking place in the wild. In this paper, we make empirical measurements of superblock distributions and observe that they follow the expectation. Hence, we conclude that widespread badness attacks have not occurred in practice, confirming previous suspicions that such attacks are costly to mount.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any block <span class="math">B</span>, it is useful to be able to refer to its most recent preceding <span class="math">\\mu</span>-superblock for any <span class="math">\\mu\\in\\mathbb{N}</span>. In addition, it is useful to include this reference within the contents of the block to which proof-of-work is being applied so that the miner proves that she had knowledge of the preceding superblock when <span class="math">B</span> was generated. For this purpose, it has been recommended <em>[16]</em> that for each block <span class="math">B</span>, instead of including only a pointer to the previous block, $\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> pointers will be included, one for each level </span>\\mu<span class="math"> pointing to the most recent </span>\\mu<span class="math">-superblock preceding </span>B<span class="math">. Hence, under this modification, every block contains a pointer to its most recent </span>0<span class="math">-superblock ancestor, its most recent </span>1<span class="math">-superblock ancestor, and so on, of which there are </span>\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. These pointers change the blockchain into a block skiplist <em>[22, 21]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">These $\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> pointers per block are called the <em>interlink</em>. One way to include them is to replace the previd pointer, which in typical blockchains points to the previous block hash, with the interlink list of block hashes to be included <em>verbatim</em> in the block header. Alternatively, the interlink list of hashes can be organized into a compact data structure such as a Merkle tree <em>[18]</em> containing one leaf per superblock level </span>\\mu<span class="math">. The number of leafs in this Merkle tree is </span>\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and its height is </span>\\lg\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Hence, proofs-of-inclusion in this Merkle tree are of size </span>\\Theta(\\lg\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$. The root of this Merkle tree can be included in the block header, replacing previd. This is done in blockchains adopting interlinking from genesis or through a hard fork <em>[9, 8]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More commonly, to avoid modifying the block header format, the interlink Merkle tree root can be included in the block’s application data. In this case, the root of the Merkle tree appears as auxiliary data within a particular transaction which is included in the block. If the miners of the blockchain are aware of the interlink, then it can be required that they included it in their coinbase transaction. The veracity of the interlink data does not need to be verified when it is included in a block, as invalid or malicious data in the interlink does not harm security. Hence, it is possible to include the interlink data in a user transaction. In this case, the transaction which includes the root of the interlink is called a <em>velvet transaction</em> and its inclusion is termed a <em>user-activated velvet fork</em> <em>[13]</em>.</p>

    <p class="text-gray-300">In practice, this transaction is implemented using an OP_RETURN <em>[1]</em> committing to the Merkle tree root containing the interlink list in its leafs. User-activated velvet forks allow the adoption of a new rule without requiring miners to upgrade their software or be aware of the change, and are hence backwards-compatible.</p>

    <p class="text-gray-300">It is useful to be able to prove that a block <span class="math">B</span> contains a pointer to a particular ancestor <span class="math">B^{\\prime}</span> in its interlink. This statement is proven by a full node who holds all blockchain data, the <em>prover</em> <span class="math">P</span>, to a superlight <em>verifier</em> <span class="math">V</span> who holds only the header of block <span class="math">B</span>. This proof is straightforward. The header of block <span class="math">B</span> contains the Merkle tree root of the transactions tree <span class="math">mtr_{1}</span> and is hence known to <span class="math">V</span>. First, a Merkle tree proof-of-inclusion <span class="math">\\pi_{1}</span> proves that <span class="math">mtr_{1}</span> contains the velvet transaction <span class="math">tx</span>. The velvet transaction <span class="math">tx</span> commits to auxiliary data which includes the interlink Merkle tree root <span class="math">mtr_{2}</span>. Secondly, another Merkle tree proof-of-inclusion <span class="math">\\pi_{2}</span> proves that <span class="math">mtr_{2}</span> contains the hash of <span class="math">B^{\\prime}</span>. While we cannot improve the size of <span class="math">\\pi_{1}</span>, in this paper we describe the improvement in the size of <span class="math">\\pi_{2}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Superblock pointers can be used to traverse the blockchain from the tip back to Genesis in a manner which skips some unnecessary intermediary blocks and includes others. The idea is to convince a superlight verifier <span class="math">V</span>, which only has access to the Genesis block, that a particular blockchain is the longest one without presenting all block headers. Blocks of interest that are part of the longest chain can then be revealed to <span class="math">V</span> in order to convince them that a particular transaction has been confirmed. In order to do that, <span class="math">P</span> finds a succinct sample of blocks and places it in chronological order. That sample is chosen such that each next block within the sample contains a pointer to its immediate ancestor within the sample by a commitment in the interlink vector. The prover <span class="math">P</span> sends each block of the sample to <span class="math">V</span>, along with a proof-of-inclusion for the respective pointer. The verifier <span class="math">V</span> can check if the correct pointer has been included. By cleverly choosing which blocks to collect, a full node can prove to a superlight node that the currently adopted longest blockchain is the claimed one without presenting the whole blockchain. Hence, instead of transmitting data linear in the chain size $\\Theta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> as SPV clients do, it is sufficient to transmit succinct certificates which are only of size </span>\\Theta(\\textit{poly}\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$. Such certificates are called Non-Interactive Proofs of Proof-of-Work <em>[16]</em>. In this paper, we are not concerned about the mechanism by which the NIPoPoWs protocol samples blocks, but only the number of blocks in these samples and the sizes of their proofs-of-inclusion, which we optimize here.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The NIPoPoWs protocol is parameterized by a security parameter <span class="math">m</span>. The number of blocks $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ in a given Non-Interactive Proof of Proof-of-</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Work sample is as follows. For each superblock level <span class="math">\\mu\\in\\mathbb{N}</span>, consider the blocks in the honestly adopted blockchain <span class="math">\\mathcal{C}</span>. Among these, some are of level <span class="math">\\mu</span>, so denote the count of <span class="math">\\mu</span>-level superblocks in <span class="math">\\mathcal{C}</span> as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}\\uparrow^{\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}\\uparrow^{\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math">, then we call </span>\\mu<span class="math"> an included level. Consider the maximum included level </span>\\max\\mu<span class="math">. It has been proven <em>[16]</em> that </span>\\max\\mu=\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-\\lg(m)<span class="math">. The proof </span>\\pi<span class="math"> contains </span>1.5m<span class="math"> blocks for the maximum included level and </span>m<span class="math"> additional blocks for each lower level in expectation. Hence the number of blocks in a NIPoPoW is </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1.5m+m\\max\\mu=1.5m+m(\\lg(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-\\lg(m))<span class="math">. For each of these blocks, the proof contains the block hash and the respective proofs-of-inclusion for the pointer to the preceding ancestor. In this paper, we optimize the size of these proofs-of-inclusion, which gives a direct improvement to the size of such proofs </span>\\pi<span class="math">. We note that, in our proposed construction, we do not decrease the number of required blocks in </span>\\pi$, only the bytes that need to be transmitted for it on the network.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The size of these proofs is critical. As the majority of the time needed for mobile wallets to perform the initial synchronization with the network is spent on downloading block headers from the network, bringing down the proof size directly improves the performance of superlight clients. In the context of cross-chain transfers <em>[17]</em>, these proofs are posted and persistently stored in smart contracts <em>[7, 23]</em> within blockchains which function as SPV verifiers for other blockchains <em>[10]</em>. Improving their size has direct financial impact on the protocol, as a larger size incurs a larger gas cost for storage purposes in case such proofs are stored within Ethereum.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3 Superblock distributions in deployed cryptocurrencies</h2>

    <p class="text-gray-300">We measured the superblock distribution in the mainnet Bitcoin blockchain. Our results are illustrated in Figure 1. As expected, half the blockchain blocks are 1-superblocks, 1/4 of blocks are 2-superblocks and generally approximately <span class="math">2^{-\\mu}</span> of the blockchain blocks are <span class="math">\\mu</span>-superblocks. The horizontal axis denotes the block height, while the vertical axis denotes the superblock density with respect to the variable difficulty target of each block, in logarithmic scale.</p>

    <p class="text-gray-300">We performed these measurements as follows. We downloaded the whole bitcoin blockchain from the Genesis block up to the current tip of the blockchain (at the time of writing 563,451). We then plotted the density for each level <span class="math">\\mu=0\\ldots 6</span>. For the particular level, we traversed the blockchain using a sliding window of <span class="math">1000(2^{\\mu})+1</span> blocks. Within that sliding window, we measured how many blocks of level <span class="math">\\mu</span> exist, and plotted the ratio of the count of these superblocks within the window to</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Distribution of block levels in Bitcoin. Superblocks are with respect to variable difficulty targets. Shaded area indicates  <span class="math">\\pm 1\\sigma</span></p>

    <p class="text-gray-300">the window size. The plot for level 0 is flat, as all blocks are 0-superblocks. The high-frequency erratic behavior is due to the probabilistic nature of block generation. We conjecture that lower frequency patterns, especially those aligned between multiple levels, are due to difficulty adjustment which incorrectly predicted the underlying computational power for a given epoch (e.g., due to rapidly changing costs in mining hardware or cryptocurrency prices).</p>

    <p class="text-gray-300">In superblock-enabled blockchains, the interlink vector stored in each block  <span class="math">B</span>  contains one pointer per superblock level  <span class="math">\\mu</span> , namely a pointer to the most recent superblock preceding  <span class="math">B</span>  of the respective level  <span class="math">\\mu</span> . This construction, known as an interlink list, is realized by inductively updating the interlink of the previous block, as shown in Algorithm 1. The algorithm works as follows. Trivially, genesis has an empty interlink vector, which forms our inductive basis. Given a newly mined block  <span class="math">B&#x27;</span>  which</p>

    <p class="text-gray-300">already has an interlink vector (the inductive hypothesis), we wish to construct the interlink vector to be included in the next block, which will point to  <span class="math">B&#x27;</span>  itself as well as some of the blocks that  <span class="math">B&#x27;</span>  points to. This is done by inspecting the existing interlink,  <span class="math">B&#x27;</span> .interlink, and constructing a new interlink interlink by replacing all the entries in  <span class="math">B&#x27;</span> .interlink that are of level less than or equal to that of  <span class="math">B&#x27;</span>  with  <span class="math">B&#x27;</span>  itself.</p>

    <p class="text-gray-300">Algorithm 1 updateInterlink 1: function updateInterlink  <span class="math">(B^{\\prime})</span> 2: interlink  <span class="math">\\leftarrow B^{\\prime}</span>  .interlink 3: for  <span class="math">\\mu = 0</span>  to level  <span class="math">(B^{\\prime})</span>  do 4: interlink  <span class="math">[\\mu ]\\gets H(B^{\\prime})</span> 5: end for 6: return interlink 7: end function</p>

    <p class="text-gray-300">Algorithm 2 Our proposed algorithm, updateInterlinkSet 1: function updateInterlinkSet  <span class="math">(B^{\\prime})</span> 2: interlinkSet  <span class="math">\\leftarrow \\{H(B^{\\prime})\\}</span> 3: for  <span class="math">H(B)\\in B^{\\prime}</span>  .interlink do 4: if level  <span class="math">(B) &amp;gt; \\text{level}(B^{\\prime})</span>  then 5: interlinkSet  <span class="math">\\leftarrow</span>  interlinkSet  <span class="math">\\cup \\{H(B)\\}</span> 6: end if 7: end for 8: return interlinkSet 9: end function</p>

    <p class="text-gray-300">Here, we make the simple observation that the interlink structure constructed in this manner often contains duplicate pointers. In fact, as we will show, most of the interlink pointers are duplicate. Space can be saved by constructing an interlink set instead. This construction is shown in Algorithm 2. The algorithm returns the exact same data structure as Algorithm 1, but with duplicates removed. The algorithm operates as follows. Given an existing interlink set,  <span class="math">B&#x27;</span> .interlinkSet, it produces a new set interlinkSet which contains  <span class="math">B&#x27;</span>  and all the same blocks as  <span class="math">B&#x27;</span> .interlinkSet with the exception of those that are of equal or inferior superblock level to  <span class="math">B&#x27;</span> . Naturally, when this interlink set is to be committed to a Merkle tree, it must be ordered in a canonical matter (for example, by increasing block</p>

    <p class="text-gray-300">level) so that its root can be deterministically reproduced and detected. This canonical ordering may now not be trivial as was in the case for interlink lists and must be specified by the implementation.</p>

    <p class="text-gray-300">We remark that it does not matter for security purposes whether duplicates are removed. The reason is that the prover has access to the whole list of blocks references within the interlink Merkle tree, and hence can choose the one it needs. On the other hand, the verifier only needs to ensure that the claimed superblock level is attained, but this can be done directly by inspecting the hash sent to it by the prover.</p>

    <p class="text-gray-300">We now analyze the savings attained by the above method. We first analyze the savings in a thought experiment of an ideal, deterministic execution of the blockchain protocol. While this setting is not realistic, it provides good intuition about the interlink structure. Subsequently, we analyze the real probabilistic blockchain protocol. Consider a blockchain of <span class="math">n</span> blocks.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1 (Interlink mask)</h6>

    <p class="text-gray-300">Define the <em>interlink mask</em> of a block <span class="math">B</span> to be the bitstring containing one bit per superblock level <span class="math">\\mu</span>. At the position <span class="math">\\mu</span>, the bitstring contains a <span class="math">1</span> if the most recent <span class="math">\\mu</span>-superblock ancestor of <span class="math">B</span> differs from the most recent <span class="math">(\\mu+1)</span>-superblock ancestor of <span class="math">B</span>, or if no <span class="math">(\\mu+1)</span>-superblock ancestor exists. Otherwise, it contains a <span class="math">0</span>.</p>

    <p class="text-gray-300">This mask contains a <span class="math">0</span> at the position of duplicates which can be eliminated. To measure the efficiency of our optimization scheme, we wish to count how many <span class="math">0</span>s are contained in the interlink mask of a given block. Consider, for example, the block highlighted with a dashed border in Figure 2. Its interlink vector will have an interlink mask of <span class="math">0101</span>. The first <span class="math">0</span> is due to the previous block which happened to be a <span class="math">1</span>-superblock. The latter <span class="math">0</span> is due to the most recent <span class="math">3</span>-superblock overshadowing the preceding <span class="math">2</span>-superblock.</p>

    <p class="text-gray-300">In our deterministic thought experiment, consider a blockchain which grows as illustrated in Figure 2. In this blockchain, every block is a <span class="math">0</span>-superblock, every other block is a <span class="math">1</span>-superblock, every fourth block is a <span class="math">2</span>-superblock and generally every <span class="math">2^{\\mu}</span>-th block is a <span class="math">\\mu</span>-superblock. In this thought experiment, the interlink mask behaves like a binary number which is increased by <span class="math">1</span> after every block is generated. As such, it will be a <span class="math">\\mu</span>-digit binary number. As the process passes through all <span class="math">\\mu</span>-digit binary numbers, the number of <span class="math">0</span>s and <span class="math">1</span>s is on average equal. Hence, the savings obtained in the deterministic case are exactly <span class="math">50\\%</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: A thought experiment of a deterministically generated blockchain</p>

    <p class="text-gray-300">Algorithm 3 The Turing Machine modeling interlink generation. 1: function run(tape) 2:  <span class="math">\\mu \\gets 0</span> 3: while true do 4:  <span class="math">b \\gets \\{0,1\\}</span> 5: if  <span class="math">b = 1</span>  then 6:  <span class="math">\\text{tape}[\\mu] \\gets 1</span> 7: return 8: end if 9:  <span class="math">\\text{tape}[\\mu] \\gets 0</span> 10:  <span class="math">\\mu \\gets \\mu + 1</span> 11: end while 12: return tape 13: end function</p>

    <p class="text-gray-300">Consider now the probabilistic setting of a real blockchain in an honest execution, where each block generated has an independent probability of belonging to a given level. The process of block generation can be modelled precisely as follows. Consider the Turing Machine illustrated in Algorithm 3. We begin with a one-sided infinite tape filled with the special symbol  <span class="math">\\sqcup</span> . We then run the machine illustrated in Algorithm 3 repeatedly over the same tape  <span class="math">n</span>  times. Once we have completed the  <span class="math">n</span>  runs, the tape contains a binary string, which follows the same distribution as the interlink mask of the  <span class="math">n^{\\text{th}}</span>  block of a blockchain. Each run of Algorithm 3 corresponds to a generation of a block. The algorithm begins at the position  <span class="math">\\mu = 0</span>  of the tape. It flips a fair coin  <span class="math">b</span> . If the coin turns out to be 1, the machine writes 1 to the current position of the tape and exits. This is the event that the block generated has level exactly 0. Otherwise, if the coin  <span class="math">b</span>  is a 0, then the block generated has level above 0, and so the first</p>

    <p class="text-gray-300">position of the interlink mask will be overwritten by a 0. The machine then advances and continues to flip coins and overwriting the tape with 0s until a 1 coinflip is attained, at which point it writes a 1 and halts. The probability of the machine halting at position <span class="math">\\mu</span> or later is <span class="math">2^{-\\mu}</span>, modeling the probability of a block being a <span class="math">\\mu</span>-superblock. The machine overwrites with 0 the positions in the tape which are of inferior level compared to the block level it will generate at the given run. This is the same process by which superblocks of higher level overshadow preceding superblocks of lower levels by occupying their space with duplicate pointers that can be eliminated.</p>

    <p class="text-gray-300">Let <span class="math">B_{\\mu}^{n}\\in\\{0,1\\}</span> denote the random variable containing the value of the <span class="math">\\mu^{\\mathrm{th}}</span> digit after <span class="math">n</span> such runs. We have that:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}[B_{\\mu}^{n}=1]=\\sum_{i=1}^{n}2^{-\\mu}\\prod_{j=i+1}^{n}\\sum_{\\mu^{\\prime}=1}^{\\mu-1}2^{-\\mu^{\\prime}}=\\sum_{i=1}^{n}2^{-\\mu}\\prod_{j=i+1}^{n}(1-2^{1-\\mu})</span> <span class="math">=</span> <span class="math">\\sum_{i=1}^{n}2^{-\\mu}(1-2^{1-\\mu})^{n-(i+1)+1}=\\frac{1}{2}(1-(1-2^{1-\\mu})^{n})</span></p>

    <p class="text-gray-300">Let <span class="math">B^{n}</span> denote the number of 1s in the interlink mask after <span class="math">n</span> runs. Its expectation is then</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[B^{n}]=\\mathbb{E}[\\sum_{\\mu=1}^{\\infty}B_{\\mu}^{n}]=\\sum_{\\mu=1}^{\\infty}\\frac{1}{2}(1-(1-2^{1-\\mu})^{n})=\\frac{1}{2}\\sum_{i=1}^{n}(-1)^{i+1}\\binom{n}{i}\\frac{2^{i}}{2^{i}-1}</span></p>

    <p class="text-gray-300">We will now show that the savings from the interlink set technique are significant, specifically that <span class="math">\\mathbb{E}[B^{n}]&lt;\\frac{1}{2}\\lg(n)+O(1)</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">For any integers <span class="math">i&gt;0</span> and <span class="math">k\\geq 0</span>,</p>

    <p class="text-gray-300"><span class="math">\\frac{2^{i}}{2^{i}-1}=\\frac{1}{2^{(k+1)i}-2^{ki}}+\\sum_{j=0}^{k}2^{-ij}</span></p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">The left-hand side is an infinite geometric series:</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=0}^{\\infty}(2^{-i})^{j}=\\frac{2^{i}}{2^{i}-1}</span></p>

    <p class="text-gray-300">We can split it up at some arbitrary index <span class="math">k\\geq 0</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=0}^{\\infty} (2^{-i})^j = \\sum_{j=0}^{k} 2^{-ij} + \\sum_{j=k+1}^{\\infty} (2^{-i})^j</span></div>

    <p class="text-gray-300">Applying the formula for geometric series sum from <span class="math">j = k + 1</span> to <span class="math">\\infty</span> on the second term, we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=0}^{k} 2^{-ij} + \\sum_{j=k+1}^{\\infty} (2^{-i})^j = \\sum_{j=0}^{k} 2^{-ij} + \\frac{2^{-i(k+1)}}{1 - 2^{-i}} = \\sum_{j=0}^{k} 2^{-ij} + \\frac{1}{2^{i(k+1)} - 2^{ik}}</span></div>

    <p class="text-gray-300">Lemma 2. For any positive integers <span class="math">n</span> and <span class="math">k = \\lceil \\lg(n) \\rceil</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{i=1}^{n} (-1)^i \\binom{n}{i} \\sum_{j=0}^{k} 2^{-ij} &lt; \\lg(n) + 2</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{i=1}^{n} (-1)^i \\binom{n}{i} \\sum_{j=0}^{k} 2^{-ij} &amp;= k + 1 - \\sum_{j=0}^{k} \\sum_{i=0}^{n} (-1)^i \\binom{n}{i} 2^{-ij} \\\\</li>

    </ul>

    <p class="text-gray-300">&amp;= k + 1 - \\sum_{j=0}^{k} \\sum_{i=0}^{n} \\binom{n}{i} (-2^{-j})^i \\\\ &amp;= k + 1 - \\sum_{j=0}^{k} (1 - 2^{-j})^n &lt; \\lg(n) + 2 \\end{aligned} $$</p>

    <p class="text-gray-300">Lemma 3. For any positive integer <span class="math">n</span> and <span class="math">k = \\lceil \\lg(n) \\rceil</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{i=1}^{n} (-1)^i \\binom{n}{i} \\frac{1}{2^{(k+1)i} - 2^{ki}} &lt; e</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{i = 1}^{n} (-1)^{i} \\binom{n}{i} \\frac{1}{2^{(k + 1)i} - 2^{ki}} \\leq \\sum_{i = 1}^{n} \\binom{n}{i} \\frac{1}{2^{(k + 1)i} - 2^{ki}} \\\\</li>

    </ul>

    <p class="text-gray-300">= \\sum_{i = 1}^{n} \\binom{n}{i} \\frac{1}{2^{ki}(2^{i} - 1)} \\\\ \\leq \\sum_{i = 1}^{n} \\binom{n}{i} \\frac{1}{2^{ki}} \\\\ \\leq \\sum_{i = 0}^{n} \\binom{n}{i} \\frac{1}{n^{i}} \\\\ = (1 + \\frac{1}{n})^{n} &lt; e \\\\ \\end{array} $$</p>

    <p class="text-gray-300">Theorem 1 (Savings). <span class="math">\\mathbb{E}[B^n] &amp;lt; \\frac{1}{2} (\\lg(n) + 2 + e)</span>.</p>

    <p class="text-gray-300">Proof.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb{E}[B^n] = -\\frac{1}{2} \\sum_{i = 1}^{n} (-1)^{i} \\binom{n}{i} \\frac{2^{i}}{2^{i} - 1} \\\\ = \\frac{1}{2} \\left( \\left( - \\sum_{i = 1}^{n} (-1)^{i} \\binom{n}{i} \\sum_{j = 0}^{k} 2^{-ij} \\right) + \\left( - \\sum_{i = 1}^{n} (-1)^{i} \\binom{n}{i} \\frac{1}{2^{(k + 1)i} - 2^{ki}} \\right) \\right) \\\\ &amp;lt; \\frac{1}{2} ((\\lg(n) + 2) + e) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We obtain that <span class="math">\\mathbb{E}[B^n] &amp;lt; \\frac{1}{2} (\\lg(n) + 2 + e)</span>. Therefore the expected savings are <span class="math">\\lg(n) - \\mathbb{E}[B^n] &amp;gt; \\frac{1}{2} (\\lg(n) - 2 - e)</span>. Solving <span class="math">\\frac{1}{2} (\\lg(n) - 2 - e) &amp;gt; 0</span> we obtain that <span class="math">n &amp;gt; 26</span> is sufficient for savings to exist. We conclude that the interlink set method performs better for blockchains with more than 26 blocks.</p>

    <h2 id="sec-10" class="text-2xl font-bold">5 Empirical analysis of improvement</h2>

    <p class="text-gray-300">In order to empirically assess the space efficiency of our improvement, we measured the size of the interlink data structure in the case of interlink</p>

    <p class="text-gray-300">lists, the previously proposed format, and in the case of interlink sets, our newly proposed format. We performed our measurements on the mainnet for both Bitcoin and Litecoin. Our results are illustrated in Figure 3 and are similar for both of these coins. The figures assume that both coins have been velvet forked from their genesis blocks to include the particular interlink vector format. This is indicative of the future performance of velvet forking each blockchain to add the respective interlink vector format.</p>

    <p class="text-gray-300">The new data structure format yields savings of approximately  <span class="math">79\\%</span>  on average. Based on the theoretical analysis of Section 4, we expect to see approximately an improvement of  <span class="math">50\\%</span>  in this structure. The extra  <span class="math">29\\%</span>  is due to the historical explosion of difficulty in the mining power in both cryptocurrencies. The increased difficulty causes a lower variable difficulty target, meaning that the lowest portions of the superblock levels remain unoccupied, but are still accounted for in the interlink vector list approach.</p>

    <p class="text-gray-300">Based on the sizes attained in the interlink vector of the Bitcoin blockchain, we organized the interlink vector into Merkle trees for both the list and the set structure and created proofs-of-inclusion of which we measured the size. The sizes of the inclusion proofs for the two constructions are illustrated in Figure 4, while the percentile savings are illustrated in Figure 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Interlink size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof-of-inclusion size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NIPoPoW size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">blockhashes</td>

            <td class="px-3 py-2 border-b border-gray-700">bytes</td>

            <td class="px-3 py-2 border-b border-gray-700">hashes</td>

            <td class="px-3 py-2 border-b border-gray-700">bytes</td>

            <td class="px-3 py-2 border-b border-gray-700">KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Interlink lists</td>

            <td class="px-3 py-2 border-b border-gray-700">43.12</td>

            <td class="px-3 py-2 border-b border-gray-700">1380</td>

            <td class="px-3 py-2 border-b border-gray-700">5.7</td>

            <td class="px-3 py-2 border-b border-gray-700">183</td>

            <td class="px-3 py-2 border-b border-gray-700">65.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Interlink sets</td>

            <td class="px-3 py-2 border-b border-gray-700">9.04</td>

            <td class="px-3 py-2 border-b border-gray-700">289</td>

            <td class="px-3 py-2 border-b border-gray-700">3.6</td>

            <td class="px-3 py-2 border-b border-gray-700">116</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: A comparison of the two interlink constructions in terms of size.</p>

    <p class="text-gray-300">We summarize the savings of our construction in Table 1. The table was constructed by inspecting the Bitcoin blockchain at the time of writing. The interlink size column shows the average interlink vector size, in the number of block hashes and in concrete bytes assuming the SHA256 function is used (as in Bitcoin). The proof-of-inclusion size column shows the average size of a Merkle proof-of-inclusion, in the number of hashes and in bytes, when the interlink vector is compacted into a Merkle tree using SHA256. Finally, the NIPoPoW size column shows the size of a</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (a) Bitcoin</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (b) Litecoin Fig. 3: A comparison of interlink vector sizes for interlink block lists and interlink block sets in two popular blockchains (lower is better)</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 4: A comparison of a proof-of-inclusion size in the case of interlink block lists and interlink block sets in Bitcoin (lower is better)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NIPoPoW in kilobytes (excluding the last  <span class="math">k</span>  blocks of the chain which must be sent verbatim irrespectively of which synchronization protocol is used). The NIPoPoW sizes are calculated assuming Bitcoin had included the respective interlink Merkle tree root in their headers since genesis. We measured the size of suffix-proof NIPoPoWs based on the recommended parameter  <span class="math">m = 15</span>  [16] assuming a chain size of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 563,451<span class="math"> . The number of blocks in a NIPoPoW is  </span>(m(\\lg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\lg m) + 1.5m) = 250<span class="math">  in expectation. For the final size calculation of the NIPoPoW, we included all the data required: The proofs-of-inclusion (based on the size given on the previous column) and the block headers needed (80 bytes per block). Our results indicate  </span>79\\%<span class="math">  savings in the interlink sizes and  </span>25\\%$  savings in the NIPoPoW sizes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 5: Percentile savings of the block set construction compared to the block list construction.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Massimo Bartoletti and Livio Pompianu. An analysis of Bitcoin OP_RETURN metadata. In International Conference on Financial Cryptography and Data Security, pages 218-230. Springer, 2017.</li>

      <li>Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In V. Ashby, editor, ACM CCS 93, pages 62-73. ACM Press, November 1993.</li>

      <li>Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A. Kroll, and Edward W. Felten. SoK: Research perspectives and challenges for bitcoin and cryptocurrencies. In 2015 IEEE Symposium on Security and Privacy, pages 104-121. IEEE Computer Society Press, May 2015.</li>

      <li>Benedikt Bünz, Lucianna Kiffer, Loi Luu, and Mahdi Zamani. FlyClient: SuperLight Clients for Cryptocurrencies. Cryptology ePrint Archive, Report 2019/226. https://eprint.iacr.org/2019/226, 2019.</li>

      <li>Sven Buschbeck. Nimiq developer reference. Available at: https://nimiq-network.github.io/developer-reference/chapters/block.#interlink, 2018.</li>

      <li>Vitalik Buterin. EIP 210: Blockhash refactoring. Technical report, Feb 2017.</li>

      <li>Vitalik Buterin et al. A next-generation smart contract and decentralized application platform. white paper, 2014.</li>

    </ol>

    <p class="text-gray-300">8] Alexander Chepurnoy, Dmitry Meshkov, Ilya Oskin, Mike Aksarin, Andrey Andreev, Alexander Slesarenko, Denys Zadorozhnyi, and Guillermo Manzanares. Ergo. Available at: https://ergoplatform.org, 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] Elion Chin, Philipp von Styp-Rekowsky, and Robin Linus. Nimiq. Available at: https://nimiq.com, 2018.</li>

      <li>[10] Georgios Christoglou. Enabling crosschain transactions using NIPoPoWs. Master’s thesis, Imperial College London, 2018.</li>

      <li>[11] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 139–147. Springer, Heidelberg, August 1993.</li>

      <li>[12] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281–310. Springer, Heidelberg, April 2015.</li>

      <li>[13] Kostis Karantias. Enabling NIPoPoW Applications on Bitcoin Cash. Master’s thesis, University of Ioannina, Ioannina, Greece, 2019.</li>

      <li>[14] Aggelos Kiayias, Peter Gaži, and Dionysis Zindros. Proof-of-stake sidechains. In IEEE Symposium on Security and Privacy. IEEE, 2019.</li>

      <li>[15] Aggelos Kiayias, Nikolaos Lamprou, and Aikaterini-Panagiota Stouka. Proofs of proofs of work with sublinear complexity. In International Conference on Financial Cryptography and Data Security, pages 61–78. Springer, 2016.</li>

      <li>[16] Aggelos Kiayias, Andrew Miller, and Dionysis Zindros. Non-Interactive Proofs of Proof-of-Work, 2017.</li>

      <li>[17] Aggelos Kiayias and Dionysis Zindros. Proof-of-work sidechains. In International Conference on Financial Cryptography and Data Security. Springer, 2019.</li>

      <li>[18] Ralph C Merkle. A digital signature based on a conventional encryption function. In Conference on the theory and application of cryptographic techniques, pages 369–378. Springer, 1987.</li>

      <li>[19] Andrew Miller. The high-value-hash highway, bitcoin forum post, 2012.</li>

      <li>[20] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Available at: https://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>[21] Thomas Papadakis. Skip lists and probabilistic analysis of algorithms. PhD thesis, University of Waterloo, 1993.</li>

      <li>[22] William Pugh. Skip lists: A probabilistic alternative to balanced trees. In Workshop on Algorithms and Data Structures, pages 437–449. Springer, 1989.</li>

      <li>[23] Gavin Wood. Ethereum: A secure decentralised generalised transaction ledger. Ethereum Project Yellow Paper, 151:1–32, 2014.</li>

      <li>[24] Alexei Zamyatin, Nicholas Stifter, Aljosha Judmayer, Philipp Schindler, Edgar Weippl, William Knottenbelt, and Alexei Zamyatin. A wild velvet fork appears! inclusive blockchain protocol changes in practice. In International Conference on Financial Cryptography and Data Security. Springer, 2018.</li>

    </ul>`;
---

<BaseLayout title="Compact Storage of Superblocks for NIPoPoW Applications (2019/1444)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1444
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
