---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/731';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Pasta: A Case for Hybrid Homomorphic Encryption';
const AUTHORS_HTML = 'Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger, Roman Walch';

const CONTENT = `    <p class="text-gray-300">Christoph Dobraunig <span class="math">^{4}</span>, Lorenzo Grassi <span class="math">^{3}</span>, Lukas Helminger <span class="math">^{1,2}</span>, Christian Rechberger <span class="math">^{1}</span>, Markus Schofnegger <span class="math">^{1}</span> and Roman Walch <span class="math">^{1,2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> IAIK, Graz University of Technology firstname.lastname@iaik.tugraz.at <span class="math">^{2}</span> Know-Center GmbH, Graz, Austria <span class="math">^{3}</span> Digital Security Group, Radboud University, Nijmegen lgrassi@science.ru.nl <span class="math">^{4}</span> Lamarr Security Research, Graz, Austria christoph.dobraunig@lamarr.at</p>

    <p class="text-gray-300">Abstract. The idea of hybrid homomorphic encryption (HHE) is to drastically reduce bandwidth requirements when using homomorphic encryption (HE) at the cost of more expensive computations in the encrypted domain. To this end, various dedicated schemes for symmetric encryption have already been proposed. However, it is still unclear if those ideas are already practically useful, because (1) no cost-benefit analysis was done for use cases and (2) very few implementations are publicly available. We address this situation in several ways. We build an open-source benchmarking framework involving several use cases covering three popular libraries. Using this framework, we explore properties of the respective HHE proposals. It turns out that even medium-sized use cases are infeasible, especially when involving integer arithmetic. Next, we propose PASTA, a cipher thoroughly optimized for integer HHE use cases. PASTA is designed to minimize the multiplicative depth, while also leveraging the structure of two state-of-the-art integer HE schemes (BFV and BGV) to minimize the homomorphic evaluation latency. Using our new benchmarking environment, we extensively evaluate PASTA in SEAL and HElib and compare its properties to 8 existing ciphers in two use cases. Our evaluations show that PASTA outperforms its competitors for HHE both in terms of homomorphic evaluation time and noise consumption, showing its efficiency for applications in real-world HE use cases. Concretely, PASTA outperforms AgraSTA by a factor of up to 82, MASTA by a factor of up to 6 and HERA up to a factor of 11 when applied to the two use cases.</p>

    <p class="text-gray-300">Keywords: homomorphic encryption <span class="math">\\cdot</span> hybrid homomorphic encryption <span class="math">\\cdot</span> Pasta <span class="math">\\cdot</span> SEAL <span class="math">\\cdot</span> HElib <span class="math">\\cdot</span> TFHE</p>

    <p class="text-gray-300">In recent years, people have become increasingly concerned about the privacy of their data, and new regulations like the General Data Protection Regulation (GDPR)<span class="math">^{1}</span> forbid sharing and processing sensitive data. However, many applications, such as machine learning and statistics, require a vast amount of data to be as accurate as possible. With GDPR and similar regulations it is therefore difficult or even impossible to gather enough data to create useful and accurate models. One solution to this problem is employing privacy-preserving cryptographic protocols and primitives, such as secure multi-party computation (MPC) or homomorphic encryption (HE). Homomorphic encryption schemes allow performing</p>

    <p class="text-gray-300"><span class="math">^{1}</span>https://eur-lex.europa.eu/legal-content/EN/ALL/?uri=celex:32016R0679</p>

    <p class="text-gray-300">computations on encrypted data without having access to the secret decryption key. Many privacy-preserving applications which employ homomorphic encryption use the following design principle: First, the data holder encrypts their dataset using a homomorphic encryption scheme and sends the ciphertexts to a server. The server then performs the computations on the ciphertexts and produces an encrypted result. Only the data holder knows the secret decryption key, so the server has to send the encrypted result to the data holder who can then decrypt it to get the final result of the computation. While this approach protects both the privacy of the input data and the secrecy of the applied computations, it comes with several drawbacks: First, applying homomorphic encryption results in a drastic performance penalty. Secondly, HE schemes suffer from ciphertext expansion. This means that the ciphertexts in HE schemes are several orders of magnitude larger than the corresponding plaintexts. This expansion negatively impacts the amount of data which has to be transferred from the data holder to the server. Especially when the client is an embedded device with limited bandwidth, memory, and computing power, this expansion can have a considerable impact on the overall performance of the application. The academic literature proposes two orthogonal solutions to this ciphertext expansion: Using symmetric ciphers in hybrid homomorphic encryption, or using LWE encryption and efficient conversion algorithms <em>[x10]</em>. In this paper we focus on hybrid homomorphic encryption, its effect on integer HE use cases, and consequences of the chosen symmetric cipher.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Hybrid Homomorphic Encryption (HHE)</h3>

    <p class="text-gray-300">Hybrid homomorphic encryption was first mentioned in <em>[x23]</em>. The main idea behind HHE is the following: Instead of encrypting the data with HE schemes, encrypt the data with a symmetric cipher (expansion factor of 1) and send the symmetric ciphertexts to the server. The server then first homomorphically performs the symmetric decryption circuit to transform the symmetric ciphertext into a homomorphic ciphertext and then proceeds with performing the actual computations. This procedure trades bandwidth requirements with a more expensive computation on the server and requires that the data holder first sends the symmetric key encrypted under homomorphic encryption.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">HE Schemes and HE–Friendly Symmetric Ciphers.</h5>

    <p class="text-gray-300">Today, many HE schemes exist, such as BFV <em>[x1, x12]</em> and BGV <em>[x2]</em> which allow for integer plaintexts in <span class="math">\\mathbb{Z}_{q}</span> with <span class="math">q\\geq 2</span>, CKKS <em>[x11]</em> which allows HE for real numbers, the original TFHE scheme <em>[x12]</em> allowing only boolean plaintext, as well as the optimized TFHE version working over low-precision integers <em>[x14]</em>. These different schemes come with vastly different advantages and disadvantages and have diverging optimization criteria, such as minimizing the multiplicative depth in BFV/BGV/CKKS and minimizing the total number of gates when using the gate-bootstrapping mode of TFHE.</p>

    <p class="text-gray-300">At first, researchers tried to evaluate existing ciphers, like AES <em>[x16, x17]</em>, with homomorphic encryption <em>[x15, CCK^{+}13, x12]</em>. However, despite their plain efficiency, existing ciphers were not well-suited for HHE. Especially their large multiplicative depth deemed to be incompatible with modern HE schemes. As a consequence, researchers came up with symmetric cipher designs with different optimization criteria compared to, e.g., AES, mainly minimizing the multiplicative depth to be efficiently computable under HE. Many proposed HE–friendly symmetric ciphers, such as LowMC <em>[ARS^{+}15]</em>, Rasta <em>[DEG^{+}18]</em>, Agrasta <em>[DEG^{+}18]</em>, Dasta <em>[x13]</em>, Kreyvium <em>[CCF^{+}16]</em>, and FiLIP <em>[x18]</em>, are defined over <span class="math">\\mathbb{Z}_{2}</span>, i.e., plaintexts are binary values. Consequently, they can be used to combat ciphertext expansion in the original TFHE scheme, as well as in BFV/BGV when instantiated with <span class="math">q=2</span>. Follow-up work then also introduced efficient ciphers for the requirements of the updated TFHE scheme (e.g., Elisabeth <em>[x10]</em>), as well as ciphers tailored to CKKS, such as Rubato <em>[HKL^{+}22]</em>.</p>

    <p class="text-gray-300">###</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Open Problem.</h4>

    <p class="text-gray-300">However, despite there being a vast number of symmetric ciphers proposed in the literature, the real ramifications of applying HHE to any use case are not yet understood so far. This is a direct consequence of a lack of benchmark comparisons of different symmetric ciphers in different HE libraries when applied to different use cases. As a result, the inefficiency of existing symmetric ciphers when applied to BFV/BGV with <span class="math">q&gt;2</span> (which is required for many use cases involving statistics or integer arithmetic in general, e.g., <em>[x15, CMdG^{+}21, BBH^{+}22]</em>) was not yet realized so far: Once <span class="math">q</span> is chosen for BGV/BFV, it cannot be changed without knowledge of the secret decryption key or without bootstrapping which is still not supported by many major HE libraries. Thus, if one wants to use one of the vast ciphers over <span class="math">\\mathbb{Z}_{2}</span>, one needs to instantiate BGV/BFV with <span class="math">q=2</span> to be able to evaluate the boolean decryption circuit of these ciphers. This, however, results in also having to evaluate the use case in <span class="math">\\mathbb{Z}_{2}</span> which requires to build binary circuits with significantly larger multiplicative depth to realize integer arithmetic. For this reason, using HHE in use cases over integers already implies a heavy performance loss compared to just implementing the use case with homomorphic encryption.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Contribution</h3>

    <p class="text-gray-300">Having said that, in this paper we tackle these problems and close the gap by implementing a benchmarking framework comparing multiple symmetric ciphers in three HE libraries and two use cases. We then also introduce the novel family of stream ciphers (dubbed Pasta) which are defined over <span class="math">\\mathbb{F}_{p}</span>. More specifically, our contributions are the following:</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Extensive HHE Benchmarking Framework.</h4>

    <p class="text-gray-300">To the best of our knowledge, we are the first to provide an extensive comparison of different symmetric ciphers in the context of hybrid homomorphic encryption spanning over several libraries. Notably, this increases the number of publicly implemented HHE schemes from only one to a total of 17, aiding public verifiability. We come to the conclusion that most existing designs are not well-suited for large classes of use cases.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Designing an Efficient Cipher for HHE.</h4>

    <p class="text-gray-300">Based on the conclusions of our benchmarking framework, we explore the design space for efficient ciphers for HHE over <span class="math">\\mathbb{F}_{p}</span>. Starting from the cost metrics in BFV/BGV and the Rasta design strategy, we compare several different proposal for efficient S-box implementations and show how to instantiate the slowest part of the cipher – the linear layer – in an efficient way by splitting the design in two parallel branches.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Pasta.</h4>

    <p class="text-gray-300">Based on the analysis just described, we propose a new symmetric cipher, dubbed Pasta, optimized for integer HHE use cases. Pasta is defined to operate on plaintexts in <span class="math">\\mathbb{F}_{p}^{t}</span>, greatly increasing the performance compared to most previously proposed symmetric ciphers which are defined over <span class="math">\\mathbb{Z}_{2}</span>. Further, Pasta is designed to make use of the structure of two state-of-the-art integer HE cryptosystems (BFV and BGV) to minimize HHE decompression latency while still maintaining a small number of rounds and multiplicative depth. Our extensive benchmarks in our newly created framework confirm the advantage of Pasta compared to all other symmetric ciphers for HHE. Concretely, Pasta outperforms Agrasta <em>[DEG^{+}18]</em>, the currently fastest <span class="math">\\mathbb{Z}_{2}</span> cipher for HHE, by a factor of 82 when applied to a small use case in HElib, and it outperforms Masta <em>[HKC^{+}20]</em> and Hera <em>[CHK^{+}21]</em>, the two <span class="math">\\mathbb{F}_{p}^{t}</span> contenders, by a factor of up to 6 and 11 respectively when applied to a larger use case in SEAL.</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">Follow-Up Works.</h5>

    <p class="text-gray-300">Since we initially made our paper publicly available, our implementation framework has been used as a baseline for benchmarks in the followup designs proposed in <em>[x10]</em> and <em>[x11]</em>. Furthermore, the Rubato cipher <em>[HKL^{+}22]</em> directly uses the Feistel S-box (proposed in Section 6.4) as its non-linear layer.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.3 Outline</h3>

    <p class="text-gray-300">The remaining paper is structured as follows. We first start with a small introduction to homomorphic encryption in Section 2, before we discuss related work to combat ciphertext expansion in different HE libraries in Section 3. Then we proceed by showing the effect of HHE on the server and client side when applied to a specific use case in Section 4. This section concludes with the statement, that the choice of symmetric cipher mostly effects the server side, which is why we proceed investigating the server side when using <span class="math">\\mathbb{Z}_{2}</span> ciphers in Section 5. Since these ciphers are not suited for integer HE use cases, we design a new cipher in Section 6 and give the complete specification of the result, dubbed Pasta, in Section 7. We continue by analyzing the security of Pasta in Section 8 and finally benchmark it against its competitors in Section 9.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">About Benchmarks.</h5>

    <p class="text-gray-300">Throughout the paper, we run all benchmarks on a Linux server with an Intel Xeon E5-2699 v4 CPU (2.2 GHz, turboboost up to 3.6 GHz) and 512 GB RAM. Each individual benchmark only has access to one thread.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">1.4 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">t\\geq 1</span>. For each vector <span class="math">\\vec{x}\\in\\mathbb{F}_{p}^{2t}</span> we denote $\\vec{x}:=\\vec{x}_{L}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}_{R}<span class="math"> where </span>\\vec{x}_{L},\\vec{x}_{R}\\in\\mathbb{F}_{p}^{t}<span class="math"> are respectively the left and the right </span>t<span class="math"> words. Further, we write </span>\\texttt{rot}_{i}(\\vec{y})<span class="math"> to indicate a rotation of the vector </span>\\vec{y}\\in\\mathbb{F}_{p}^{t}<span class="math"> by </span>i<span class="math"> steps to the left. With </span>\\vec{y}\\odot\\vec{m}<span class="math"> we denote the element-wise product (Hadamard product) between two vectors </span>\\vec{y},\\vec{m}\\in\\mathbb{F}_{p}^{t}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-14" class="text-2xl font-bold">2 Homomorphic Encryption</h2>

    <p class="text-gray-300">Homomorphic encryption has often been labeled the holy grail of cryptography, since it allows to perform any computation on encrypted data without knowledge of the secret decryption key. The concept of HE was introduced by Rivest et al. <em>[x32]</em>, but the first schemes were only capable of performing one specific operation on encrypted data (e.g., multiplication with RSA <em>[x33]</em>, addition with Paillier <em>[x31]</em>). The breakthrough came with Gentry’s work from 2009 <em>[x16]</em>, showing the first fully homomorphic encryption (FHE) scheme which in theory can perform any computation on encrypted data. Although deemed impractical, this work led the way for many improvements and follow-up publications <em>[x1, x13, x2, x12, x14]</em>.</p>

    <p class="text-gray-300">Today’s HE schemes base their security on the <em>learning with errors</em> (LWE) hardness assumption <em>[x30]</em>, and its optimization over polynomial rings (Ring-LWE, or R-LWE) <em>[x26]</em>. In these schemes, random Gaussian noise is added during the encryption process. A homomorphic operation then increases this noise, negligible for homomorphic addition, but significant for homomorphic multiplication. Once the noise exceeds a specific threshold, the decryption will fail. The resulting schemes, therefore, allow the evaluation of arbitrary circuits over encrypted data up to a specific multiplicative depth which depends on the encryption parameters. Such a scheme is called a <em>somewhat homomorphic encryption</em> (SHE) scheme. In general, increasing the parameters to support a bigger circuit depth comes with a great performance penalty. In <em>[x16]</em>, Gentry introduced the bootstrapping technique, a method to reset the noise in a homomorphic ciphertext. Bootstrapping allows to evaluate circuits of arbitrary depth on encrypted data and turns a (bootstrappable) SHE</p>

    <p class="text-gray-300">scheme into an FHE scheme. However, bootstrapping comes with a significant performance overhead, which is why it is often faster to choose an SHE scheme with sufficiently large parameters.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.1 Packing</h3>

    <p class="text-gray-300">Many modern HE schemes allow to encode a vector of <span class="math">n</span> plaintexts into only one polynomial, and therefore, encrypt a vector into only one ciphertext <em>[x20]</em>. Thereby, the size of the ciphertext does not depend on the exact number of slots (<span class="math">\\leq n</span>) of the vector filled during encryption. Homomorphic operations on the ciphertexts then correspond to element-wise operations on the encrypted vector. This packing is similar to single-instruction-multiple-data (SIMD) instructions on modern CPUs and can be used to massively increase the throughput and decrease the ciphertext expansion of HE applications. Operations supported by this packing include addition, subtraction, multiplication, and slot rotation. However, once encrypted, one cannot directly access individual slots of the encrypted vector. The available number of slots <span class="math">n</span> depends on the parameters of the HE scheme and can range up to several thousand slots. Slot rotation is implemented by evaluating Galois automorphisms <span class="math">\\tau_{i}:a(X)\\mapsto a(X^{i})</span> on encoded polynomials.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.2 HE Schemes and Libraries</h3>

    <p class="text-gray-300">In this paper, we consider three HE schemes and their implementation in three libraries. We discuss the BFV <em>[x1, x12]</em> scheme (and its implementation in SEAL <em>[x23]</em>) in this section and for the sake of conciseness refer to Appendix A for a discussion of BGV <em>[x1]</em> in HElib <em>[x13]</em> and TFHE <em>[x6]</em> in the TFHE library <em>[x7]</em>. Furthermore, benchmarks in HElib and TFHE are later discussed in the appendix as well.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">BFV <em>[x1, x12]</em> in SEAL <em>[x23]</em>.</h4>

    <p class="text-gray-300">In BFV in SEAL plaintexts are elements in <span class="math">\\mathbb{Z}_{q}</span>. However, to support the packing described in the previous section, <span class="math">q</span> has to be a prime <span class="math">p</span> and packing is not supported for <span class="math">q=2</span>, i.e., one can not pack boolean plaintexts. We use SEAL version 3.6.2 in the paper. The runtime and added noise by homomorphic additions is negligible, which is why additions are considered free in the BFV cryptosystem. Therefore, the most relevant performance metric is the multiplicative depth of the evaluated circuit.</p>

    <h2 id="sec-18" class="text-2xl font-bold">3 Related Work</h2>

    <p class="text-gray-300">In this paper we focus on HHE for the BFV and BGV HE schemes, and also discuss the application to the gate-bootstrapping mode of the original TFHE library. Hence, we include the boolean ciphers LowMC <em>[ARS+15]</em>, Rasta <em>[DEG+18]</em>, Agrasta <em>[DEG+18]</em> (which is the “aggressive” version of Rasta, recently broken in <em>[x11]</em>), Dasta <em>[x10]</em>, Kreyvium <em>[CCF+16]</em>, and FiLIP <em>[x16]</em>, alongside the <span class="math">\\mathbb{F}_{p}</span> competitors Masta <em>[HKC+20]</em> and Hera <em>[CHK+21]</em>, in our comparison. However, other proposals for different HE schemes, such as CKKS and the Concrete library, exist which we shortly discuss in Section 3.1 and Section 3.2. Finally, in Section 3.3, we discuss an alternative approach to reducing bandwidth requirements for HE applications which does not involve symmetric encryption schemes.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.1 HHE for CKKS</h3>

    <p class="text-gray-300">The CKKS <em>[x5]</em> homomorphic encryption scheme is another HE scheme which is relevant for private statistics and machine learning <em>[x26, DSC+19, WSH+22, CGL+20]</em>.</p>

    <p class="text-gray-300">However, the scheme includes approximation errors, which makes it incompatible with directly evaluating symmetric ciphers under a CKKS encryption. In <em>[CHK+21]</em> the authors mitigate this problem by proposing a framework (alongside the stream cipher Hera), where the symmetric cipher is first evaluated under a BFV encryption, before it gets translated to a CKKS ciphertext. The currently fastest symmetric cipher proposed for this framework is Rubato <em>[HKL+22]</em>. Similar to CKKS, this cipher includes approximation errors, which allows it to greatly reduces the number of rounds. Consequently, it is very fast when used with CKKS, but incompatible with BFV and BGV. To highlight the impact of Pasta we want to mention that the S-Box used in Rubato is directly taken from Pasta as proposed in Section 6.4.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.2 HHE for Concrete</h3>

    <p class="text-gray-300">Recently, a new HE library, dubbed Concrete <em>[CJL+20]</em>, has emerged, which implements a newer variant of TFHE as proposed in <em>[CJP+21]</em>. This library is vastly different compared to SEAL/HElib: it allows to perform HE on plaintexts in the ring <span class="math">\\mathbb{Z}_{2^{q}}</span> for small <span class="math">q</span>, supports bootstrapping and evaluating lookup tables during bootstrapping. Packing, however, is not supported. In <em>[CHMS+22]</em>, the authors introduce Elisabeth-4, a <span class="math">\\mathbb{Z}_{2^{q}}</span> variant of FiLIP which is optimized for HHE using Concrete, and evaluate its performance when classifying the FMNIST dataset using a deep neural network with HHE. Using Elisabeth-4 (and consequently Concrete) leads to different tradeoffs compared to Pasta: On one hand HE use cases are not bound by the depth due to bootstrapping, on the other hand, it only allows small precision integers (<span class="math">q=4</span>) potentially limiting its applicability to high-precision use cases. Directly comparing Elisabeth and Pasta is difficult due to their different design criteria and optimizations for vastly different HE libraries. Nonetheless, in <em>[CHMS+22]</em> the authors compare Elisabeth to Pasta using our implementation framework, showing that a singlethreaded evaluation of Pasta-4 in HElib has a 1.26 times higher throughput than a multithreaded Elisabeth-4 in Concrete even though it is evaluated with 48 threads.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.3 LWE-Native Encryption</h3>

    <p class="text-gray-300">In <em>[CDKS+21]</em>, the authors describe efficient algorithms to convert many LWE ciphertexts into a packed (see Section 2.1) R-LWE one. These algorithms can also be used to reduce ciphertext expansion of homomorphic encryption. Their approach works as follows: First, they encrypt each plaintext <span class="math">m_{i}\\in\\mathbb{F}_{p}</span> under a secret key <span class="math">\\vec{s}\\in\\mathbb{Z}^{N}</span> using basic LWE encryption by sampling a random vector <span class="math">\\vec{a}_{i}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{Z}_{q}^{N}<span class="math"> and calculating </span>b_{i}=-\\langle\\vec{a}_{i},\\vec{s}\\rangle+\\mu_{i}<span class="math">, where </span>\\mu_{i}\\in\\mathbb{Z}_{q}<span class="math"> is a randomized encoding of </span>m_{i}<span class="math"> (with Gaussian noise). The LWE ciphertext then is </span>(b_{i},\\vec{a}_{i})\\in\\mathbb{Z}_{q}^{N+1}<span class="math">. To further reduce the size of the ciphertexts, one can use a random seed </span>\\mathfrak{se}<span class="math"> and generate </span>\\vec{a}_{i}<span class="math"> using a pseudo-random number generator (PRNG) </span>f<span class="math">. The seed can be reused to generate the random part of each ciphertext as </span>\\vec{a}_{i}=f(\\mathfrak{se};i)<span class="math">. The resulting ciphertexts are semantically secure in the random oracle model. The client then transmits all </span>b_{i}<span class="math"> alongside the seed </span>\\mathfrak{se}<span class="math"> to the server, which then transforms all LWE ciphertexts into a packed HE one using the algorithms described in <em>[CDKS+21]</em>. The total communication cost for this approach is one </span>\\mathbb{Z}_{q}<span class="math"> element for each plaintext </span>m_{i}\\in\\mathbb{F}_{p}<span class="math">, plus one seed </span>\\mathfrak{se}$ to generate the random part of the ciphertexts.</p>

    <p class="text-gray-300">According to the benchmarks in <em>[CDKS+21]</em>, the LWE encryption approach has a smaller multiplicative depth, and thus, less noise consumption compared to HHE. Depending on the actually evaluated use case, this smaller noise consumption can lead to requiring smaller HE parameters with less noise budget, and thus, a runtime advantage. However,</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">their algorithms do not achieve a ciphertext expansion factor of 1, but a factor of  $\\frac{\\log q}{\\log p} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{se}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . For many HE applications, the plaintext space defined by  </span>p<span class="math">  is in the range of 16 to 60 bit and the size of  </span>q$  can easily exceed 800 bits, resulting in big expansion factors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The performance, advantages, and disadvantages of HHE are not so well understood so far. Therefore, we start with an high-level investigation of the effects on both the client and server when applying HHE to a real use case before we investigate the choice of symmetric cipher in the next sections.</p>

    <p class="text-gray-300">Benchmarking a Generic Use Case. Matrix multiplications over integers are a basic building block in many applications involving statistics or machine learning. Hence, for our first look we choose to apply HE and HHE to a use case involving three affine transformations to a secret vector  <span class="math">\\vec{x}_0</span> . In other words, the layers have the form  <span class="math">\\vec{x}_i&#x27; = M_i \\cdot \\vec{x}_i + \\vec{b}_i</span> , where  <span class="math">\\vec{x}_i, \\vec{x}_i&#x27;, \\vec{b}_i \\in \\mathbb{F}_p^{200}</span> ,  <span class="math">M_i \\in \\mathbb{F}_p^{200 \\times 200}</span> , and  <span class="math">p</span>  is a 60-bit prime. To make the use case more generic, we elementwise square the output vector after the first two affine transformations. The final use case has a multiplicative depth of 3 plaintext-ciphertext and 2 ciphertext-ciphertext multiplications and can be seen as, e.g., a small 3-layer neural network with squaring activation functions. We benchmark this use case after the initial setup phase, i.e., the server knows an HE encryption of the symmetric key and all HE evaluation keys. Further, we repeat this 1000 times, and the server aggregates the final results before sending them back to the client. In a real-world scenario, this would be equivalent to, e.g., a sensor device sending measurements in fixed intervals to a server.</p>

    <p class="text-gray-300">In Table 1, we give results for evaluating this use case in the SEAL library, first by just using HE, then by applying HHE with 3 different ciphers, and finally by applying the alternative approach using LWE-native encryption [CDKS21] (i.e., transmitted ciphertext are essentially seeded LWE ciphertexts). To better show the effects of HHE, we instantiate the HHE benchmark once with a generic symmetric cipher (AES), once with a fast boolean HHE optimized cipher (AGRASTA), and once with a HHE optimized cipher defined over  <span class="math">\\mathbb{F}_p</span>  (PASTA-3 as defined in Section 7 - since we aim to investigate the general effects of applying HHE to a use case in this section, details on PASTA-3 are not important at this point).</p>

    <p class="text-gray-300">Table 1: Comparison of a use case with HHE to only using HE in SEAL.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Client</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Server</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Random Words</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. s</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM GB</td>

            <td class="px-3 py-2 border-b border-gray-700">Comm. kB</td>

            <td class="px-3 py-2 border-b border-gray-700">Runtime s</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM GB</td>

            <td class="px-3 py-2 border-b border-gray-700">Response kB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HE</td>

            <td class="px-3 py-2 border-b border-gray-700">65 536 000</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">0.550</td>

            <td class="px-3 py-2 border-b border-gray-700">7 404 700</td>

            <td class="px-3 py-2 border-b border-gray-700">61 900</td>

            <td class="px-3 py-2 border-b border-gray-700">2.24</td>

            <td class="px-3 py-2 border-b border-gray-700">987.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HHE (Pasta-3)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">0.005</td>

            <td class="px-3 py-2 border-b border-gray-700">1 500</td>

            <td class="px-3 py-2 border-b border-gray-700">669 400</td>

            <td class="px-3 py-2 border-b border-gray-700">23.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2 097.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HHE (AGRASTA)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2 200</td>

            <td class="px-3 py-2 border-b border-gray-700">0.004</td>

            <td class="px-3 py-2 border-b border-gray-700">1 500</td>

            <td class="px-3 py-2 border-b border-gray-700">?a</td>

            <td class="px-3 py-2 border-b border-gray-700">?a</td>

            <td class="px-3 py-2 border-b border-gray-700">>12 000 000b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HHE (AES)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0.040</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003</td>

            <td class="px-3 py-2 border-b border-gray-700">1 500</td>

            <td class="px-3 py-2 border-b border-gray-700">?a</td>

            <td class="px-3 py-2 border-b border-gray-700">?a</td>

            <td class="px-3 py-2 border-b border-gray-700">>12 000 000b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LWE [CDKS21]</td>

            <td class="px-3 py-2 border-b border-gray-700">200 000</td>

            <td class="px-3 py-2 border-b border-gray-700">4 229</td>

            <td class="px-3 py-2 border-b border-gray-700">0.361</td>

            <td class="px-3 py-2 border-b border-gray-700">22 025</td>

            <td class="px-3 py-2 border-b border-gray-700">165 900</td>

            <td class="px-3 py-2 border-b border-gray-700">28.1</td>

            <td class="px-3 py-2 border-b border-gray-700">987.3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a Multiplicative depth of binary circuit  <span class="math">(&amp;gt;400)</span>  far too large for feasible HE parameters. b No packing in SEAL for  <span class="math">\\mathbb{Z}_2</span>  plaintexts, i.e., one HE ciphertext per bit.</p>

    <p class="text-gray-300">HHE Results. As Table 1 shows, using HHE reduces the total client-to-server communication from 7.4GB to 1.5MB, the exact size of sending the input vector consisting of 200 60-bit field elements 1000 times. Furthermore, data encryption is also faster and requires less RAM, with the traditional cipher AES being the fastest option. However, to support the homomorphic evaluation of the HHE decompression circuit (i.e., homomorphically</p>

    <p class="text-gray-300">computing the symmetric decryption), the server-side requires larger HE parameters with higher noise budget, increasing the server-side runtime and RAM requirements. For HHE using the <span class="math">\\mathbb{F}_{p}</span> cipher (i.e., Pasta-3), the server-side runtime increases by a factor of 10. However, using HHE with <span class="math">\\mathbb{Z}_{2}</span> ciphers (e.g., Agrasta or AES) requires to implement binary circuits for the use case, resulting in a significant multiplicative depth requiring huge HE parameters, and thus in infeasibly long server runtimes.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">As discussed in Section 2, one can use bootstrapping to reset the noise in a homomorphic ciphertext to allow the evaluation of circuits with arbitrary multiplicative depth. However, SEAL does not support bootstrapping, and it is still very inefficient in HElib and does not result in faster runtimes for the <span class="math">\\mathbb{Z}_{2}</span> ciphers compared to Pasta in HHE. Thus, we omit explicit bootstrapping benchmarks in this paper.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">LWE Results.</h4>

    <p class="text-gray-300">As discussed in Section 3.3, LWE-native encryption <em>[x10]</em> has larger ciphertext expansion than HHE (Concretely an expansion factor of <span class="math">\\frac{881}{60}=14.68</span> for the used parameter set). However, its smaller multiplicative depth allows it to use the same HE parameters as just using homomorphic encryption, resulting in a smaller runtime overhead. Both using HE and using LWE-native encryption require sampling Gaussian noise during encryption. Constrained devices, however, often do not have access to a reliable source of randomness. Therefore, we also list the number of random Gaussian words required on the client side to perform the encryption in Table 1. HHE does not require sampling random values during encryption, which is why using HHE is the preferable choice on constrained devices without a reliable source of randomness. Consequently, the first benchmarks show that HHE has the preferable effect on the client side due to not requiring sampling Gaussian randomness, having faster plain performance, and requiring less communication. The LWE-native encryption approach, however, leads to a faster server side evaluation due to having a smaller multiplicative depth.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Client Side Performance.</h4>

    <p class="text-gray-300">Table 1 clearly shows that just using homomorphic encryption would result in unnecessarily large client-to-server communication. To further demonstrate the performance loss, we show the combined client timings (for encryption and client-to-server communication) for different network speeds in Figure 1. We depict timings for using only HE, HHE using Pasta-3, and for the LWE-native approach. We omit HHE using <span class="math">\\mathbb{Z}_{2}</span> ciphers, since they result in infeasible server runtimes. Figure 1 shows that using HHE always results in the fastest client-side latencies, especially for network speeds below <span class="math">1\\text{\\,}\\mathrm{Gbps}</span> (the average LTE upload speed in the USA is <span class="math">5\\text{\\,}\\mathrm{Mbps}</span>) where HE runtime is fully dominated by the data transmission.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Conclusion.</h4>

    <p class="text-gray-300">To summarize, if the encryption time on a client is the bottleneck, then using HHE with an <span class="math">\\mathbb{F}_{p}</span> cipher (in this case Pasta-3) is the preferred choice. Only HHE using traditional <span class="math">\\mathbb{Z}_{2}</span> ciphers (e.g., AES) is faster, but using them results in infeasibly long server-side computations. Furthermore, if the client bandwidth is the bottleneck, then HHE has a considerable advantage. The concrete communication advantage depends on the HE parameters. For our example use case HE requires a factor of <span class="math">4936\\times</span> more communication than HHE, the LWE-native approach a factor of <span class="math">14.86\\times</span>. Since HHE has the largest server-side runtime overhead, using HHE has the best effect on constrained clients or in slow network settings. The choice of the symmetric cipher used in HHE has similar effects on the client side (all have ciphertext expansion of 1), but severely affects the server-side runtime. Consequently, we investigate the server-side computation using different symmetric ciphers in the remainder of the paper, starting with the inefficiency of <span class="math">\\mathbb{Z}_{2}</span> ciphers.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Encryption + upload time of HE, HHE with PASTA, and LWE-native encryption [CDKS21] depending on network speed.</p>

    <p class="text-gray-300">We further want to note, that for sake of simplicity we assume plaintexts to have the exact size of the used prime  <span class="math">p</span>  (i.e., 60 bit) in this first example of HHE. In practice, the exact plaintext space might be smaller to prevent overflows in  <span class="math">\\mathbb{F}_p</span>  during homomorphic computations. Thus, while still instantiating the symmetric cipher and HE scheme with a 60 bit plaintext prime  <span class="math">p</span> , the actually used plaintexts might be significantly smaller. Since the size of HE and LWE ciphertexts in Table 1 do not depend on  <span class="math">p</span>  but on a ciphertext modulus  <span class="math">q</span> , the size of the used plaintext being undetectable once encrypted, and the need to instantiate  <span class="math">\\mathbb{F}_p</span>  ciphers with the same prime to allow decryption under HE, the values in Table 1 do not change for HE, LWE and HHE with the  <span class="math">\\mathbb{F}_p</span>  cipher PASTA-3. Only the  <span class="math">\\mathbb{Z}_2</span>  ciphers will benefit from the smaller plaintexts with smaller client to server communication. However, since the server side computation with its too large multiplicative depth is infeasibly long due to the need for binary circuits, this small advantage on the client side plays no role in practice.</p>

    <p class="text-gray-300">In this section, we evaluate the usability of proposed symmetric ciphers for HHE. We focus on boolean ciphers with plaintexts in  <span class="math">\\mathbb{Z}_2</span>  since these are the majority of ciphers proposed for HHE. The main design criterion of all these ciphers is to reduce the AND depth of the decryption circuit.</p>

    <p class="text-gray-300">Hybrid homomorphic encryption aims to reduce the communication overhead for outsourcing computations to a cloud. Therefore, we investigate not only the performance of the decryption circuit of each cipher under homomorphic encryption, but also the performance of the cipher in a complete HHE use case. The use case we benchmark in this section is very small, concretely a server which computes  <span class="math">\\vec{r} = M \\cdot \\vec{x} + \\vec{b}</span> , where  <span class="math">\\vec{r}, \\vec{x}, \\vec{b} \\in \\mathbb{Z}_{2^{16}}^{5}</span>  and  <span class="math">M \\in \\mathbb{Z}_{2^{16}}^{5 \\times 5}</span> , i.e., a  <span class="math">5 \\times 5</span>  matrix-vector multiplication of 16-bit integers. The matrix  <span class="math">M</span>  and the vector  <span class="math">\\vec{b}</span>  are private and owned by the server, whereas  <span class="math">\\vec{x}</span>  is a private vector owned by the client. The client uses HHE to send  <span class="math">\\vec{x}</span>  in encrypted form to the server, and will get  <span class="math">\\vec{r}</span>  in encrypted form as a result. As described above, the choice of a cipher over  <span class="math">\\mathbb{Z}_2</span>  also requires that we compute the integer matrix multiplication over  <span class="math">\\mathbb{Z}_2</span> . This requires the implementation of binary circuits for addition <span class="math">^5</span>  and multiplication, which have a much higher AND depth than performing the same operations over  <span class="math">\\mathbb{F}_p</span> . Despite being only a</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">very small matrix multiplication ( <span class="math">5 \\times 5</span>  with 16-bit integers), our benchmarks (given later in this section) show that the evaluation is already very slow, making it infeasible for  <span class="math">\\mathbb{Z}_2</span>  ciphers to be applied to real-world statistics or machine learning use cases with multiple chained matrix multiplications of larger integers with matrices consisting of hundreds of entries.</p>

    <p class="text-gray-300">In this paper, we benchmark 128-bit security instances of the ciphers LowMC [ARS+15], RASTA [DEG+18], AGRASTA [DEG+18], DASTA [HL20], KREYVIUM [CCF+16] (as stream cipher and in depth-bounded CTR mode), and FiLIP [MCJS19]. In Table 2 we summarize the parameters of the ciphers in their respective modes of operation.</p>

    <p class="text-gray-300">Table 2: Parameters of the benchmarked  <span class="math">\\mathbb{Z}_2</span>  ciphers in their respective modes of operations in bits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Blocksize</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Keysize</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AND-depth</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMC</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">525</td>

            <td class="px-3 py-2 border-b border-gray-700">525</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">351</td>

            <td class="px-3 py-2 border-b border-gray-700">351</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">525</td>

            <td class="px-3 py-2 border-b border-gray-700">525</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">351</td>

            <td class="px-3 py-2 border-b border-gray-700">351</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AGRASTA</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-12</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-13</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FtLIP-1216</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FtLIP-1280</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We start this section by first introducing RASTA, which is the baseline for many other proposals, before we discuss some followup-ciphers not included in our benchmark comparisons.</p>

    <p class="text-gray-300">Rasta. RASTA is a family of stream ciphers, in which a permutation is applied to the secret key to produce the keystream. The permutation consists of several rounds of affine layers and an S-box instantiated with the  <span class="math">\\chi</span> -transformation [Dae95]. The main design criteria of RASTA is that each affine layer is pseudorandomly generated from an extendable-output function (XOF) [NIS15] seeded with a nonce  <span class="math">N</span>  and the block counter  <span class="math">i</span> . This essentially prevents all attacks which require multiple plaintext/ciphertext pairs and allows to build a cipher with a low number of rounds. We depict the RASTA permutation in Figure 2.</p>

    <p class="text-gray-300">Fasta. Shortly after first releasing our paper to the public the cipher FASTA [CIR22] was published. FASTA is an optimization of RASTA in which the linear layer is adapted for faster packed evaluation for specific HElib parameters. However, since not every HE library (such as SEAL) allows packing for  <span class="math">\\mathbb{Z}_2</span>  ciphers, and FASTA's optimization directly benefits from very specific HElib parameters and does not translate to every use case or library, we do not include it in our comparisons. For benchmarks comparing RASTA to FASTA using our implementation framework we refer to [CIR22].</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus</p>

    <p class="text-gray-300">Schofnegger and Roman Walch</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: The  <span class="math">r</span> -round RASTA construction to generate the keystream  <span class="math">K_{N,i}</span>  for block  <span class="math">i</span>  under nonce  <span class="math">N</span>  with affine layers  <span class="math">A_{j,N,i}</span> . The picture is taken from [DEG+18].</p>

    <p class="text-gray-300">Chaghri. Very recently, another boolean ciphers, namely CHAGHRI [AMT22], was proposed in the literature. Following the Marvelous  <span class="math">\\mathrm{[AAB^{+}20]}</span>  design strategy, each round of CHAGHRI has a AND-depth of 2. Together with its comparably high number of rounds, CHAGHRI's total depth is 16, making it significantly deeper then any other symmetric cipher over  <span class="math">\\mathbb{Z}_2</span>  discussed in our work. Furthermore, this design is heavily optimized for using a special type of packing, where each slot encodes polynomials in  <span class="math">\\mathbb{F}_{2^{63}}</span> . While this allows them to use Frobenius automorphisms to evaluate  <span class="math">x^{2^k}</span>  for free, it also has the disadvantage that no technique (to the best of our knowledge) is known to homomorphically extract bits from these polynomials. Consequently, one either has to pack only one bit into these polynomials severely limiting throughput, or CHAGHRI can only be applied to very specific use cases using this packing. Furthermore, this type of packing is not available in some libraries, such as SEAL. Finally, each CHAGHRI round consists of two multiplications with  <span class="math">3\\times 3</span>  MDS matrices, which have to be implemented over polynomials with 63 elements, which is very expensive without this packing.</p>

    <p class="text-gray-300">Besides, CHAGHRI was broken shortly after publication, which is also confirmed by the authors [AMT22]. The attack  <span class="math">\\mathrm{[LAW^{+}22]}</span>  works in practical time and increases the number of rounds from 8 to at least 14. Based on the benchmarks given in [AMT22], this increase by  <span class="math">75\\%</span>  would result in a performance close to AES (i.e., the only other cipher they consider in their paper), which is severely outperformed by any other  <span class="math">\\mathbb{Z}_2</span>  cipher proposed for HHE. However, the authors of  <span class="math">\\mathrm{[LAW^{+}22]}</span>  propose a modification of CHAGHRI, which allows to keep the 8 rounds while maintaining roughly the same efficiency, which was then later adopted by the authors of CHAGHRI [AMT22].</p>

    <p class="text-gray-300">For all these reasons, CHAGHRI does not provide better performances than any other cipher considered in this paper, and we do not include it in our performance evaluation.</p>

    <p class="text-gray-300">In this section we discuss the benchmarks for the  <span class="math">\\mathbb{Z}_2</span>  ciphers in SEAL, for benchmarks in HElib and TFHE we refer to Appendix B.2.1 and Appendix B.1 respectively. In SEAL, the available noise budget (i.e., how much further noise can be introduced until decryption will fail) depends on the ciphertext modulus  <span class="math">q</span> . However, big moduli  <span class="math">q</span>  require a big degree  <span class="math">N</span>  of the cyclotomic reduction polynomial for security.  <span class="math">N</span> , which is always a power of two, has a severe impact on the performance of the HE scheme. While a larger  <span class="math">N</span>  allows for larger  <span class="math">q</span>  to increase the noise budget, it significantly increases the runtime of homomorphic operations.</p>

    <p class="text-gray-300">In Table 3 we present the benchmarks for the SEAL library, for homomorphically decrypting only one block, and for the small HHE use case, i.e., the 16-bit  <span class="math">5 \\times 5</span>  affine transformation. For both benchmarks we give timings for homomorphically encrypting the symmetric key and homomorphically decrypting the symmetric ciphertexts (i.e.,</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">decompressing the HHE ciphertext) for the smallest  <span class="math">N</span>  allowing enough noise budget for correct evaluation. We parameterize  <span class="math">q</span>  such that the HE scheme has a security of 128 bits. For the HHE use case we additionally give the runtime for the affine transformation. Since SEAL does not allow to use packing with plaintexts in  <span class="math">\\mathbb{Z}_2</span> , all implementations are bitsliced (i.e., one HE ciphertext per bit).</p>

    <p class="text-gray-300">Table 3: Benchmarks of the  <span class="math">\\mathbb{Z}_2</span>  ciphers in the SEAL library (security level  <span class="math">\\lambda = 128</span>  bit).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 Block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Small HHE use case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">Use Case s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LOWMC</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">1.75</td>

            <td class="px-3 py-2 border-b border-gray-700">613.9</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">6.12</td>

            <td class="px-3 py-2 border-b border-gray-700">2 702.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1 202.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">2.12</td>

            <td class="px-3 py-2 border-b border-gray-700">135.9</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">25.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2 618.5</td>

            <td class="px-3 py-2 border-b border-gray-700">1 201.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">1.42</td>

            <td class="px-3 py-2 border-b border-gray-700">88.5</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">17.1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 802.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1 199.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">2.20</td>

            <td class="px-3 py-2 border-b border-gray-700">134.1</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">25.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2 594.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1 209.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">1.49</td>

            <td class="px-3 py-2 border-b border-gray-700">88.7</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">17.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 811.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1 209.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AGRASTA</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">0.534</td>

            <td class="px-3 py-2 border-b border-gray-700">16.3</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">1.76</td>

            <td class="px-3 py-2 border-b border-gray-700">76.2</td>

            <td class="px-3 py-2 border-b border-gray-700">241.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">1.84</td>

            <td class="px-3 py-2 border-b border-gray-700">412.8</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">6.17</td>

            <td class="px-3 py-2 border-b border-gray-700">2 028.5</td>

            <td class="px-3 py-2 border-b border-gray-700">1 210.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-12</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">1.75</td>

            <td class="px-3 py-2 border-b border-gray-700">414.8</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">6.30</td>

            <td class="px-3 py-2 border-b border-gray-700">3 925.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1 217.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-13</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">1.83</td>

            <td class="px-3 py-2 border-b border-gray-700">442.1</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">6.18</td>

            <td class="px-3 py-2 border-b border-gray-700">1 999.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1 199.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FILIP-1216</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">66.1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 064.7</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">223.9</td>

            <td class="px-3 py-2 border-b border-gray-700">6 619.0</td>

            <td class="px-3 py-2 border-b border-gray-700">244.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FILIP-1280</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">16.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1 251.6</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">56.0</td>

            <td class="px-3 py-2 border-b border-gray-700">7 783.2</td>

            <td class="px-3 py-2 border-b border-gray-700">242.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our benchmarks show that the runtime of the whole HHE use case (including cipher evaluation) using the  <span class="math">\\mathbb{Z}_2</span>  ciphers is high, despite the tested use case being small. This emphasizes the requirement of  <span class="math">\\mathbb{F}_p</span>  ciphers for HHE with integer use cases. In SEAL and HElib, the fastest ciphers are the ciphers based on the RASTA design strategy (RASTA, DASTA, AGRASTA), with AGRASTA being the fastest due to its small multiplicative depth. Only FILIP has better noise propagation. However, due to its large symmetric key and long evaluation time, it is not competitive in the libraries we benchmarked. For figures comparing the runtime of HHE in SEAL and HElib and a comparison to  <span class="math">\\mathbb{F}_p</span>  ciphers, we refer to Section 9.1.</p>

    <p class="text-gray-300">Following the results from the previous section, we now want to design an efficient cipher for HHE for integer use cases. We will first have a look at existing related work (Section 6.1), before we identify the cost metric of the HE schemes in more detail (Section 6.2) and design a cipher accordingly.</p>

    <p class="text-gray-300">Masta. In an independent and concurrent work another symmetric cipher over  <span class="math">\\mathbb{F}_p^t</span>  created for HHE use cases is introduced, namely MASTA [HKC+20]. In their work, the  <span class="math">\\mathbb{F}_p</span>  cipher MASTA is proposed to increase throughput compared to boolean ciphers when evaluated under HE and its decryption runtime under HE is compared to RASTA when implemented in the HElib library.</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">MASTA can be seen as a direct translation of RASTA (Figure 2) to  <span class="math">\\mathbb{F}_p^t</span> , with the exception of a different strategy in sampling random invertible matrices. Their approach involves sampling a random polynomial  <span class="math">m \\in \\mathbb{Z}_p[X] / (X^t - \\alpha)</span>  and translating  <span class="math">m</span>  into a matrix  <span class="math">M</span> . This matrix is then invertible by design and they only have to sample  <span class="math">s</span>  field elements  <span class="math">\\in \\mathbb{F}_p</span> . Even though the S-box used in RASTA is in general not a permutation over  <span class="math">\\mathbb{F}_p^t</span> , and therefore limits the possible outputs of the S-box layer in MASTA, <span class="math">^8</span>  the designers did not consider any additional changes to the baseline design and do not leverage any advantages of HE over fields  <span class="math">\\mathbb{F}_p</span> . In this paper we consider the two 128-bit security instances of MASTA with the lowest depth and use SHAKE128 to pseudorandomly generate all affine layers.</p>

    <p class="text-gray-300">Since MASTA does not consider any additional changes to RASTA based on the properties of BGV/BFV, and the S-box is not a permutation in  <span class="math">\\mathbb{F}_p</span> , we aim to design a more optimized cipher in the next sections.</p>

    <p class="text-gray-300">Hera. Another  <span class="math">\\mathbb{F}_p</span>  cipher, namely HERA [CHK+21], was proposed in the literature alongside a framework for applying HHE to CKKS. Contrary to RUBATO, HERA can also be applied to BFV and BGV which is why we also consider it in our comparisons.</p>

    <p class="text-gray-300">The main design rationale behind HERA is to apply the RASTA design strategy in a different way to also benefit from the prevention of statistical attacks by randomizing the cipher, but with less preprocessing cost. They do this by fixing the affine layers and randomizing the key schedule by multiplying the key elements with pseudorandomly sampled  <span class="math">\\mathbb{F}_p</span>  elements. They also fix a small statesize of just 16 words and a round number of 5 for 128 bit security and instantiate their linear layers with efficient AES-like matrices. As nonlinear layer they use the well-known cubing layer (see Section 6.4).</p>

    <p class="text-gray-300">The goal is to design an efficient cipher for HHE over  <span class="math">\\mathbb{F}_p^t</span>  with  <span class="math">2^{16} &amp;lt; p &amp;lt; 2^{60}</span> . Since in both BGV and BFV (and their respective implementations in SEAL and HElib) the most significant performance metric is the multiplicative depth due to the absence of an efficient bootstrapping operation, our main goal is to reduce this metric. Since every round contributes to the multiplicative depth, and therefore to the overall noise consumption during a homomorphic evaluation of the cipher, we aim to design a secure cipher with a minimal number of rounds. Further, high-degree polynomials have a large multiplicative depth, and hence we consider low-degree S-boxes. Meeting both of these requirements usually requires a large state size for security. However, large state sizes lead to a high runtime of the cipher evaluation, especially in the linear layers. Therefore, our design will have to balance noise consumption and runtime to be efficiently usable in HHE. Furthermore, most HE applications leverage packing (Section 2.1) to increase performance, which is why we also aim to design a packing-friendly cipher which produces packed homomorphically encrypted ciphertexts. For a comparison of a word-sliced implementation of our final design to a packed implementation we refer to Appendix C. There we also compare a word-sliced implementation of HERA to PASTA.</p>

    <p class="text-gray-300">Cost of HE Operations. In Table 4 we summarize the cost of each HE operation in SEAL and HElib. Note that the key switching operation is free in terms of noise in SEAL, whereas it adds noise to the ciphertext in HElib. Key switching is required after a ciphertext-ciphertext multiplication and after an homomorphic Galois automorphism (required for rotation), which is why these operations require more noise in HElib. For</p>

    <p class="text-gray-300">SEAL does not allow larger field sizes.</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">both libraries the noise consumption depends on the size of the prime  <span class="math">p</span> , with larger  <span class="math">p</span>  implying higher noise consumption, especially in pt-ct and ct-ct multiplications. Therefore, one cannot consider plaintext-ciphertext multiplications as negligible when working over  <span class="math">\\mathbb{F}_p</span>  and we also have to consider the plaintext-ciphertext multiplicative depth when designing an efficient cipher over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">Table 4: Cost of HE operations in SEAL and HElib.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SEAL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HElib</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Noise</td>

            <td class="px-3 py-2 border-b border-gray-700">Runtime</td>

            <td class="px-3 py-2 border-b border-gray-700">Noise</td>

            <td class="px-3 py-2 border-b border-gray-700">Runtime</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pt-ct Add</td>

            <td class="px-3 py-2 border-b border-gray-700">negligible</td>

            <td class="px-3 py-2 border-b border-gray-700">cheap</td>

            <td class="px-3 py-2 border-b border-gray-700">negligible</td>

            <td class="px-3 py-2 border-b border-gray-700">cheap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ct-ct Add</td>

            <td class="px-3 py-2 border-b border-gray-700">negligible</td>

            <td class="px-3 py-2 border-b border-gray-700">cheap</td>

            <td class="px-3 py-2 border-b border-gray-700">negligible</td>

            <td class="px-3 py-2 border-b border-gray-700">cheap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pt-ct Mul</td>

            <td class="px-3 py-2 border-b border-gray-700">moderate</td>

            <td class="px-3 py-2 border-b border-gray-700">cheap</td>

            <td class="px-3 py-2 border-b border-gray-700">moderate</td>

            <td class="px-3 py-2 border-b border-gray-700">cheap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ct-ct Mul</td>

            <td class="px-3 py-2 border-b border-gray-700">expensive</td>

            <td class="px-3 py-2 border-b border-gray-700">expensive</td>

            <td class="px-3 py-2 border-b border-gray-700">expensive</td>

            <td class="px-3 py-2 border-b border-gray-700">expensive</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Automorphism</td>

            <td class="px-3 py-2 border-b border-gray-700">negligible</td>

            <td class="px-3 py-2 border-b border-gray-700">expensive</td>

            <td class="px-3 py-2 border-b border-gray-700">moderate</td>

            <td class="px-3 py-2 border-b border-gray-700">expensive</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 2. In the future, more efficient bootstrapping implementations might become available e.g. due to efficient HE hardware accelerators which implement this feature. Depending on the concrete efficiency of bootstrapping, the optimization angle of HE might shift from minimizing the multiplicative depth to minimizing the most expensive HE operations, such as multiplications. In this case, symmetric ciphers optimized for HHE will be allowed to have more rounds with higher degree S-Boxes and will more closely look like some ciphers optimized for e.g. MPC where the total number of multiplications is the main bottleneck.</p>

    <p class="text-gray-300">Since our  <span class="math">\\mathbb{Z}_2</span>  benchmarks indicate that designs based on RASTA are the preferred choice, we first consider an  <span class="math">\\mathbb{F}_p^t</span>  version of RASTA with equal text/key size, and then modify it for security and efficiency. In the following, we analyze several candidates for each of the operations defining the cipher, and we also determine their implementation efficiency. Based on these results, we then design PASTA in Section 7.</p>

    <p class="text-gray-300">The original RASTA design uses the  <span class="math">\\chi</span> -transformation [Dae95] over  <span class="math">\\mathbb{Z}_2^t</span>  as a single nonlinear layer. However, the  <span class="math">\\chi</span> -function is in general not a permutation when working over  <span class="math">\\mathbb{F}_p^t</span> , which is why we consider alternative building blocks. Since the affine layers in a RASTA-based permutation are pseudorandomly generated for each new block, many attacks (mainly statistical attacks) are already prevented. Hence, the main goal of the S-box in this setting is to provide a sufficiently high degree to prevent algebraic attacks - the concrete structure of the S-box plays a comparably minor role. Consequently, we propose invertible low-degree S-boxes, describe how they can be efficiently implemented in a packed homomorphic evaluation, and compare their efficiency. Despite not being a permutation, MASTA still uses the  <span class="math">\\chi</span> -function naturally defined over  <span class="math">\\mathbb{F}_p^t</span> , which is why we include it in our comparison.</p>

    <p class="text-gray-300"><span class="math">\\chi</span>  -S-box. The  <span class="math">\\chi</span>  -S-box is defined as</p>

    <div class="my-4 text-center"><span class="math-block">[ \\chi (\\vec {x}) ] _ {i} = x _ {i} + x _ {i + 2} + x _ {i + 1} \\cdot x _ {i + 2} = x _ {i} + x _ {i + 2} \\cdot (1 + x _ {i + 1}).</span></div>

    <p class="text-gray-300">The indices in the  <span class="math">\\chi</span> -S-box are taken modulo  <span class="math">t</span> , which is why  <span class="math">\\chi</span>  can be efficiently evaluated using rotations, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\chi (\\vec {x}) = \\vec {x} + \\operatorname {r o t} _ {2} (\\vec {x}) \\odot (\\vec {1} + \\operatorname {r o t} _ {1} (\\vec {x})).</span></div>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">This works if the rotation is cyclic for the vector of size  <span class="math">t</span> . However, once encrypted, homomorphic rotations are cyclic over a larger vector of size  <span class="math">n</span> . Hence, we need to simulate cyclic rotation by preprocessing the state first. However, the resulting vector has more than  <span class="math">t</span>  elements, which can influence further homomorphic operations. Thus, one has to apply a masking multiplication afterwards with a mask  <span class="math">\\vec{m} = \\vec{1} \\in \\mathbb{F}_p^t</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\vec {x} ^ {\\prime} = \\vec {x} + \\operatorname {r o t} _ {(- t)} (\\vec {x}) \\\\ \\Rightarrow \\chi (\\vec {x}) = \\left(\\vec {x} ^ {\\prime} + \\operatorname {r o t} _ {2} \\left(\\vec {x} ^ {\\prime}\\right) \\odot \\left(\\vec {1} + \\operatorname {r o t} _ {1} \\left(\\vec {x} ^ {\\prime}\\right)\\right)\\right) \\odot \\vec {m}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Cube S-box. Given a prime  <span class="math">p</span> ,  <span class="math">\\gcd(p - 1, 3) = 1</span> , let</p>

    <div class="my-4 text-center"><span class="math-block">[ S (\\vec {x}) ] _ {i} = (x _ {i}) ^ {3}.</span></div>

    <p class="text-gray-300">We recall that the cube S-box is the invertible power map with the smallest degree, and it can be efficiently evaluated by simply applying two homomorphic multiplications which affect the state elementwise, i.e.,  <span class="math">S(\\vec{x}) = \\vec{x} \\odot \\vec{x} \\odot \\vec{x}</span> .</p>

    <div class="my-4 text-center"><span class="math-block">[ S ^ {\\prime} (\\vec {x}) ] _ {i} = \\left\\{ \\begin{array}{l l} x _ {i} &amp;amp; \\text {i f} i = 0, \\\\ x _ {i} + (x _ {i - 1}) ^ {2} &amp;amp; \\text {o t h e r w i s e}, \\end{array} \\right.</span></div>

    <p class="text-gray-300">The Feistel-like S-box can also efficiently be implemented using rotations, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">S ^ {\\prime} (\\vec {x}) = \\vec {x} + \\left(\\operatorname {r o t} _ {(- 1)} (\\vec {x}) \\odot \\vec {m}\\right) ^ {2},</span></div>

    <p class="text-gray-300">where  <span class="math">\\vec{m} \\in \\mathbb{F}_p^t</span>  is a masking vector  <span class="math">\\vec{m} = [0,1,\\dots,1]^T</span> .</p>

    <div class="my-4 text-center"><span class="math-block">[ S ^ {\\prime} (\\vec {x}) ] _ {i} = \\left\\{ \\begin{array}{l l} x _ {i} &amp;amp; \\text {i f} i \\leq 1, \\\\ x _ {i} + x _ {i - 1} \\cdot x _ {i - 2} &amp;amp; \\text {o t h e r w i s e}, \\end{array} \\right.</span></div>

    <p class="text-gray-300">The alternative Feistel-like S-box can also efficiently be implemented using rotations, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">S ^ {\\prime \\prime} (\\vec {x}) = \\operatorname {r o t} _ {(- 1)} (\\vec {x}) \\odot \\operatorname {r o t} _ {(- 2)} (\\vec {x}) \\odot \\vec {m} + \\vec {x},</span></div>

    <p class="text-gray-300">where  <span class="math">\\vec{m} \\in \\mathbb{F}_p^s</span>  is a masking vector  <span class="math">\\vec{m} = [0, 0, 1, \\dots, 1]^T</span> .</p>

    <p class="text-gray-300">All S-box designs can efficiently be implemented on packed HE ciphertexts and require only a constant number of homomorphic operations independent of the state size. A summary of required homomorphic operations as well as the multiplicative depths of the different S-boxes is given in Table 5.</p>

    <p class="text-gray-300">Table 5: HE operations and depth of different S-boxes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S-box</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Depth</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Depth</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">χ</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S'</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S''</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Based on Table 5, we decide to choose the Feistel S-box  <span class="math">S&#x27;</span>  as the main S-box for our nonlinear layers, and to use the cube S-box  <span class="math">S</span>  to increase the degree of our cipher to combat linearization attacks and reduce the state size of the cipher. We further explore the choice of the two different S-boxes in Section 8.4.</p>

    <p class="text-gray-300">6.5 Linear Layer</p>

    <p class="text-gray-300">In Rasta, the homomorphic runtime is dominated by the linear layer. In this section we discuss how to efficiently implement matrix-vector multiplications on packed homomorphic ciphertexts and introduce optimizations to reduce the homomorphic evaluation time.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">6.5.1 Choice of Random Matrices</h4>

    <p class="text-gray-300">In the original Rasta design, each random <span class="math">t\\times t</span> matrix is directly sampled and checked for invertibility. However, doing the invertibility check is expensive in <span class="math">\\mathbb{F}_{p}</span> in terms of computational complexity. Therefore, in Pasta we choose a different approach and generate each matrix as a sequential matrix <em>[x10, x11]</em> (Section 7). These matrices are invertible by design and only require to sample <span class="math">t</span> field elements and performing <span class="math">t\\cdot(t-1)</span> field multiplications and <span class="math">(t-1)\\cdot(t-1)</span> field additions. Compared to sampling polynomials <span class="math">m_{i}\\in\\mathbb{Z}_{p}[X]/(X^{t}-\\alpha)</span> and translating them to matrices <span class="math">M_{i}</span> (like in Masta), sequential matrices require to sample equally many field elements, but need more field additions and multiplications. Sampling sequential matrices is thus slower with respect to the method used in Masta, but it comes with the cryptographic advantage of having less structure (see Section 8). Contrary to Hera, we do not fix the matrices and randomize key schedules due to the fact that in a packed implementation one can not leverage advantages of specially chosen matrices, such as implementation via only additions, and plain performance is insignificant compared to HE evaluation runtime.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">6.5.2 Babystep-Giantstep Matrix-Vector Multiplication</h4>

    <p class="text-gray-300">The most efficient way of evaluating the product between a plain matrix and an encrypted packed vector in HE is using the babystep-giantstep optimized diagonal method <em>[x16, x17, x18]</em>:</p>

    <p class="text-gray-300"><span class="math">M\\vec{x}=\\sum_{k=0}^{t_{2}-1}\\texttt{rot}_{(kt_{1})}\\left(\\sum_{j=0}^{t_{1}-1}\\texttt{diag}_{(kt_{1}+j)}^{\\prime}(M)\\odot\\texttt{rot}_{j}(\\vec{x})\\right),</span> (1)</p>

    <p class="text-gray-300">where <span class="math">t=t_{1}\\cdot t_{2}</span>, <span class="math">\\texttt{diag}_{i}^{\\prime}(M)=\\texttt{rot}_{(-\\lfloor i/t_{1}\\rfloor\\cdot t_{1})}\\left(\\texttt{diag}_{i}(M)\\right)</span>, and <span class="math">\\texttt{diag}_{i}(M)</span> expresses the <span class="math">i</span>-th diagonal of a matrix <span class="math">M</span> in a vector of size <span class="math">t</span>, with <span class="math">i=0</span> being the main diagonal. Note that <span class="math">\\texttt{rot}_{j}(\\vec{x})</span> only has to be computed once for each <span class="math">j&lt;t_{1}</span>. Therefore, a matrix multiplication requires <span class="math">t_{1}+t_{2}-2</span> rotations, <span class="math">t</span> plaintext-ciphertext multiplications, and <span class="math">t-1</span> additions, and the total depth is 1 plaintext-ciphertext multiplication. Thus, we add words to the final state size of our design for efficiency if <span class="math">t</span> does not nicely split into <span class="math">t=t_{1}\\cdot t_{2}</span>. Compared to the number of homomorphic operations required to evaluate the S-boxes (Table 5), it is clear that the runtime of the homomorphic evaluation of our cipher is dominated by the linear layer.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">6.5.3 Splitting the State</h4>

    <p class="text-gray-300">The babystep-giantstep algorithm dominates the runtime of the homomorphic Pasta evaluation and scales with the state size. Therefore, we propose to evaluate two individual instances of our cipher with state size <span class="math">t</span> in parallel, with an efficient mixing step after each affine layer, allowing for an overall smaller state size. The final output of the design is then the output of the first half, and the second half is discarded. The result is a cipher with the following properties: (1) The state size <span class="math">s=2\\cdot t</span> is an even number and we truncate <span class="math">t</span> words at the end. (2) Instead of evaluating one large <span class="math">s\\times s</span> matrix multiplication we perform two smaller <span class="math">t\\times t</span> matrix multiplications. (3) The S-box is applied on both branches individually. (4) The key has now double the size of the keystream. The latter has no effect on the</p>

    <p class="text-gray-300">HHE use case, since a packed homomorphic design still requires only one homomorphic ciphertext, with a size independent to the number of encoded words. However, we can use the inner structure of homomorphic ciphertexts to parallelize both cipher evaluations, cutting the runtime down to an evaluation of one cipher instance of state size <span class="math">t</span>.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Inner Structure of HE ciphertexts.</h4>

    <p class="text-gray-300">In R-LWE based homomorphic encryption schemes (like BFV and BGV) the plaintexts are polynomials <span class="math">\\in R_{p}=\\mathbb{F}_{p}[X]/\\Phi_{m}(X)</span>, with <span class="math">\\Phi_{m}(X)</span> being the <span class="math">m</span>-th cyclotomic polynomial. Using packing (Section 2.1) one can encode a vector of integers into one polynomial, homomorphic additions and multiplications then affect these vectors element-wise. Further, one can use Galois automorphisms to permute the encoded vector. Thus, the encoded vector can be seen as a hypercube <em>[x10]</em> and an automorphism rotates the data along one dimension. The precise structure of this hypercube depends on the choice of <span class="math">\\Phi_{m}(X)</span>. In general, it is possible to use these automorphisms to create linear rotations over the encrypted vector, but this requires masking multiplications <em>[x10]</em>, which when evaluated homomorphically require noise budget. In terms of implementation efficiency, <span class="math">\\Phi_{2n}(X)=X^{n}+1</span>, for <span class="math">n</span> being a power of two, is a good choice. This polynomial is negacyclic and allows efficient polynomial multiplications via a negacyclic number theoretic transformation (NTT). For this reason, the homomorphic encryption standardization project recommends using these power-of-two cyclotomic rings. Consequently, SEAL only implements HE with those rings and Masta is defined to use these rings as well <em>[HKC^{+}20]</em>. The hypercube generated by such rings also has a nice structure: It corresponds to a matrix of two rows, each of size <span class="math">\\frac{\\#\\text{slots}}{2}</span>. Galois automorphisms can then directly be used to either linearly rotate both rows at once or rotate all columns simultaneously, i.e.,</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}\\vec{x}_{L}\\\\ \\vec{x}_{R}\\end{bmatrix}\\stackrel{{\\scriptstyle\\text{encode}}}{{\\to}}x\\in R_{p}:\\qquad\\tau_{3^{i}}(x)\\stackrel{{\\scriptstyle\\text{decode}}}{{\\to}}\\begin{bmatrix}\\text{{rot}}_{i}(\\vec{x}_{L})\\\\ \\text{{rot}}_{i}(\\vec{x}_{R})\\end{bmatrix},\\qquad\\tau_{n-1}(x)\\stackrel{{\\scriptstyle\\text{decode}}}{{\\to}}\\begin{bmatrix}\\vec{x}_{R}\\\\ \\vec{x}_{L}\\end{bmatrix}, \\]</p>

    <p class="text-gray-300">for the Galois automorphism <span class="math">\\tau_{i}:a(X)\\mapsto a(X^{i})</span>.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">Parallelizing Two Cipher Evaluations.</h4>

    <p class="text-gray-300">In two state-of-the-art integer HE cryptosystems (BFV and BGV) we can use this inner structure of power-of-two homomorphic ciphertexts to parallelize both branches of our cipher. When encrypting the secret key and encoding vectors in the affine layer, one has to encode the vectors affecting the first branch of the cipher into the first row of the homomorphic ciphertext, and vectors affecting the second branch into the second row. As a result, all homomorphic operations are applied in parallel to both branches.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Efficient Linear Layer.</h4>

    <p class="text-gray-300">For security, we have to mix both branches of our cipher after each affine transformation. An efficiently implementable linear layer, which is also invertible, is the following matrix multiplication:</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}\\vec{y}_{L}\\\\ \\vec{y}_{R}\\end{bmatrix}=\\begin{bmatrix}2\\cdot I&I\\\\ I&2\\cdot I\\end{bmatrix}\\cdot\\begin{bmatrix}\\vec{x}_{L}\\\\ \\vec{x}_{R}\\end{bmatrix}=\\begin{bmatrix}\\vec{x}_{L}\\\\ \\vec{x}_{R}\\end{bmatrix}+\\begin{bmatrix}\\vec{x}_{L}\\\\ \\vec{x}_{R}\\end{bmatrix}+\\begin{bmatrix}\\vec{x}_{R}\\\\ \\vec{x}_{L}\\end{bmatrix}, \\]</p>

    <p class="text-gray-300">where <span class="math">I</span> is the <span class="math">t\\times t</span> identity matrix. This can be implemented by two homomorphic additions and a homomorphic rotation.</p>

    <p class="text-gray-300">In Table 6 we compare the cost of the new linear layer (two parallel instances of state size <span class="math">t</span>) to the cost of one larger linear layer of size <span class="math">s=2\\cdot t</span>. The new linear layer effectively requires half the homomorphic additions and multiplications, and choosing <span class="math">t</span> such that it splits nicely into <span class="math">t=t_{1}\\cdot t_{2}</span> the number of rotations is also halved.</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">Table 6: Homomorphic operations and multiplicative depth of the linear layers, with  <span class="math">t = t_1 \\cdot t_2</span>  and  <span class="math">2 \\cdot t = s_1 \\cdot s_2</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Linear Layer</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Depth</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Depth</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Split and Mix</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">t+2</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">t1+t2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">No Splitting</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2·t</td>

            <td class="px-3 py-2 border-b border-gray-700">2·t</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">s1+s2-1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Table 7 we summarize the number of homomorphic operations and the multiplicative depth of each individual part of our resulting new cipher, dubbed PASTA, as well as the total count for PASTA-3 (3 rounds) and PASTA-4 (4 rounds). The table also highlights that the multiplicative depth of PASTA, and therefore its noise consumption, only depends on the number of rounds. Further, the runtime of homomorphically evaluating PASTA is dominated by the affine layer and scales with the state size and the number of rounds.</p>

    <p class="text-gray-300">Table 7: Homomorphic operations and multiplicative depth of PASTA, with  <span class="math">t = {t}_{1} \\cdot  {t}_{2}</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pt-ct Depth</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct-ct Depth</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Affine</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">t1+t2-1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mix</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S'</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Round</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">t+3</td>

            <td class="px-3 py-2 border-b border-gray-700">t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">t1+t2+1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Last Round</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">t+2</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">t1+t2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PASTA-3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4t+10</td>

            <td class="px-3 py-2 border-b border-gray-700">4t+2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4(t1+t2)+2</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">5t+13</td>

            <td class="px-3 py-2 border-b border-gray-700">5t+3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">5(t1+t2)+3</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here we provide the full PASTA specification. PASTA is a family of stream ciphers which applies the PASTA- <span class="math">\\pi</span>  permutation under a nonce  <span class="math">N</span>  and a block counter  <span class="math">i</span>  to the secret key, followed by a truncation, to produce the final keystream. Keystream generation is shown in Figure 3. For a prime  <span class="math">p</span>  s.t.  <span class="math">\\gcd(p - 1, 3) = 1</span> , a PASTA encryption is defined as</p>

    <p class="text-gray-300">KGen(): sk  <span class="math">\\leftarrow</span>  F2t</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\mathsf{Enc}_{\\mathsf{sk}}(\\vec{m},N)</span> : To encrypt the message  <span class="math">\\vec{m} \\in \\mathbb{F}_p^l</span>  under the secret key  <span class="math">\\mathsf{sk}</span>  and nonce  <span class="math">N</span> , parse  $\\vec{m} = \\vec{m}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{m}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{m}_j<span class="math">  with  </span>\\vec{m}_i \\in \\mathbb{F}_p^t<span class="math">  and return  </span>\\vec{c} = \\vec{c}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{c}_j<span class="math"> , where  </span>\\vec{c}_i = \\vec{m}_i + \\mathrm{left}_t(\\mathrm{PASTA - }\\pi (\\mathsf{sk},N,i))<span class="math"> , where  </span>\\mathrm{left}_t(\\cdot)<span class="math">  returns the first  </span>t$  words.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The permutation  <span class="math">\\mathrm{PASTA - }\\pi (\\vec{x},N,i)</span>  on a vector  <span class="math">\\vec{x}\\in \\mathbb{F}_p^{2t}</span> , thereby, is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {P A S T A} - \\pi (\\vec {x}, N, i) = A _ {r, N, i} \\circ S _ {\\text {c u b e}} \\circ A _ {r - 1, N, i} \\circ S _ {\\text {f e i s t e l}} \\tag {2} \\\\ \\circ A _ {r - 2, N, i} \\dots \\circ A _ {1, N, i} \\circ S _ {\\text {f e i s t e l}} \\circ A _ {0, N, i} (\\vec {x}), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where  <span class="math">r\\geq 1</span>  is the number of rounds and where</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: The truncated  <span class="math">r</span> -round PASTA- <span class="math">\\pi</span>  permutation to generate the keystream  <span class="math">K_{N,i}</span>  for block  <span class="math">i</span>  under nonce  <span class="math">N</span>  with affine layers  <span class="math">A_{j,k,N,i}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">S_{\\mathrm{feistel}}</span>  is an S-box layer defined as  $S_{\\mathrm{feistel}}(\\vec{x}) = S'(\\vec{x}_L) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'(\\vec{x}_R)<span class="math"> , where  </span>S'<span class="math">  over  </span>\\mathbb{F}_p^t$  is a Feistel structure defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\forall l \\in \\{0, 1, \\ldots , t - 1 \\}: \\qquad [ S ^ {\\prime} (\\vec {y}) ] _ {l} = \\left\\{ \\begin{array}{l l} y _ {l} &amp;amp; \\text {if} l = 0, \\\\ y _ {l} + (y _ {l - 1}) ^ {2} &amp;amp; \\text {otherwise}, \\end{array} \\right.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $\\vec{y} = y_0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{t - 1}\\in \\mathbb{F}_p^t$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">S_{\\mathrm{cube}}</span>  is an S-box defined as  $S_{\\mathrm{cube}}(\\vec{x}) = x_0^3\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1^3\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{s - 1}^3$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for each  <span class="math">j\\in \\{0,\\dots ,r\\}</span> <span class="math">A_{j,N,i}</span>  is an affine layer</p>

    <div class="my-4 text-center"><span class="math-block">A _ {j, N, i} (\\vec {x}) = \\left[ \\begin{array}{c c} 2 \\cdot I &amp;amp; I \\\\ I &amp;amp; 2 \\cdot I \\end{array} \\right] \\left[ \\begin{array}{c} M _ {j, L, N, i} (\\vec {x} _ {L}) + \\vec {c} _ {j, L, N, i} \\\\ M _ {i, R, N, i} (\\vec {x} _ {R}) + \\vec {c} _ {j, R, N, i} \\end{array} \\right],</span></div>

    <p class="text-gray-300">where  <span class="math">I \\in \\mathbb{F}_p^{t \\times t}</span>  is the identity matrix and where  <span class="math">M_{j,L,N,i}, M_{j,R,N,i} \\in \\mathbb{F}_p^{t \\times t}</span>  and  <span class="math">\\vec{c}_{j,L,N,i}, \\vec{c}_{j,R,N,i} \\in \\mathbb{F}_p^t</span>  are generated for each round from an XOF seeded with a nonce  <span class="math">N</span>  and a counter  <span class="math">i</span> .</p>

    <p class="text-gray-300">To efficiently sample each invertible matrix  <span class="math">M_{j,k,N,i} \\in \\mathbb{F}_p^{t \\times t}</span> , we sample sequential matrices following [GPP11, GPPR11]. For each  <span class="math">k \\in \\{L,R\\}</span> , we define  <span class="math">M_{j,k,N,i} \\coloneqq \\left(\\tilde{M}_{j,k,N,i}\\right)^t</span>  where  <span class="math">\\tilde{M}_{j,k,N,i} \\in \\mathbb{F}_p^{t \\times t}</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {M} _ {j, k, N, i} = \\left[ \\begin{array}{c c c c c} 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; \\dots &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; \\dots &amp;amp; 0 \\\\ \\vdots &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; \\vdots \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \\dots &amp;amp; 1 \\\\ \\alpha_ {1} &amp;amp; \\alpha_ {2} &amp;amp; \\alpha_ {3} &amp;amp; \\dots &amp;amp; \\alpha_ {t} \\end{array} \\right]</span></div>

    <p class="text-gray-300">for  <span class="math">\\alpha_{1},\\ldots ,\\alpha_{t}\\in \\mathbb{F}_{p}\\setminus \\{0\\}</span> .  <span class="math">M_{j,k,N,i}</span>  is an invertible matrix which can be built by sampling  <span class="math">t</span>  random elements and performing  <span class="math">t\\cdot (t - 1)</span>  multiplications and  <span class="math">(t - 1)\\cdot (t - 1)</span>  additions.</p>

    <h2 id="sec-47" class="text-2xl font-bold">7.1 Concrete Instances</h2>

    <p class="text-gray-300">We propose a 3-round instance PASTA-3 as well as a 4-round instance PASTA-4 using SHAKE128 [NIS15] as XOF. These instances provide at least 128 bits of security for the prime fields  <span class="math">\\mathbb{F}_p</span>  with  <span class="math">\\log_2(p) &amp;gt; 16</span>  and  <span class="math">\\gcd(p - 1, 3) = 1</span> . Table 8 shows the block and key sizes and compares them to MASTA and HERA.</p>

    <p class="text-gray-300">Security Margin. In all cases, we add a security margin to our construction. Concretely, we take the largest number of words  <span class="math">s</span>  needed for security, we multiply this number by 1.2 for a  <span class="math">20\\%</span>  security margin, and we then take the smallest even integer larger than or equal to that.</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">Table 8: 128 bit security instances of PASTA, MASTA, and HERA.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instance</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Key Words</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Plain Words</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Cipher Words</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">XOF</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PASTA-3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">SHAKE128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">SHAKE128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">SHAKE128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">SHAKE128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">SHAKE128</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we summarize PASTA by comparing it to previous designs. Furthermore, in Section 9.3 we discuss  <span class="math">\\mathbb{F}_p</span>  primitives for different use cases and compare them to PASTA.</p>

    <p class="text-gray-300">S-box. RASTA and DASTA use the  <span class="math">\\chi</span> -transformation as single nonlinear layer. MASTA uses a translation of  <span class="math">\\chi</span>  to  <span class="math">\\mathbb{F}_p^t</span>  as nonlinear layer, despite it being no permutation, and HERA uses the cubing layer. In PASTA we introduce and use two different, bijective S-boxes. This is motivated by the desire of reducing the number of rounds while maintaining a reasonable state size. Having  <span class="math">r - 1</span>  Feistel S-boxes and a final cube S-box with higher degree and depth allows us to build PASTA instances with comparable number of plain/cipher words as MASTA with one round less. This implies both, a faster homomorphic evaluation time, as well as less noise consumption compared to MASTA. We further explore the choice of two different S-boxes in Section 8.4.</p>

    <p class="text-gray-300">Linear-Layer. PASTA, RASTA, DASTA, and MASTA use randomly generated linear layers to mitigate statistical attacks, and HERA has a randomized key schedule for the same reason. While RASTA just samples random invertible matrices, DASTA uses random permutations of the same fixed matrix. MASTA on the other hand samples random polynomials and translates them to matrices (which have lots of structure). These methods, however, all just differ in how the matrices are generated and do not effect the homomorphic evaluation time. Contrary, PASTA's linear layer is thoroughly optimized for efficient evaluation in HE. Indeed, instead of generating a  <span class="math">2t \\times 2t</span>  random invertible matrix directly, we pick up  <span class="math">2t</span>  random elements and construct two sequential matrices  <span class="math">M_i \\in \\mathbb{F}_p^{t \\times t}</span>  as given in [GPP11, GPPR11]. These two matrices are then combined into one  <span class="math">2t \\times 2t</span>  matrix via a cheap mixing operation, effectively cutting HE runtime in half.</p>

    <p class="text-gray-300">Truncation vs. Feed-Forward. PASTA discards the feed-forward addition of the secret key (as done in RASTA, DASTA, and MASTA) in favor of a truncation. This allows to prevent MITM attack in a more efficient way, at the cost of using a larger state. In the packed HE evaluation the truncated words, however, do not influence the runtime since they can be evaluated simultaneously to the non-truncated part of the state.</p>

    <p class="text-gray-300">Given a certain number of rounds (fixed in advance), our goal is to find the minimum number of key words  <span class="math">s = 2t</span>  for which we can guarantee security of at least  <span class="math">\\kappa</span>  bits. If not specified otherwise,  <span class="math">\\kappa \\approx \\log_2(p^s)</span> . This is slightly different from what is usually done in traditional symmetric cryptanalysis. Indeed, in general, given a state  <span class="math">\\mathbb{F}_p^s</span>  and a security level  <span class="math">\\kappa</span> , one looks for the minimum number of rounds which provide a security level of at least  <span class="math">\\kappa</span>  bits. Here we modify the approach since one of our main goals is to keep the depth as low as possible, focusing on 3 and 4 rounds.</p>

    <p class="text-gray-300">Remark 3.</p>

    <p class="text-gray-300">The design approach of Pasta is analogous to the one originally proposed for Rasta. For this reason, in many cases we limit ourselves to adapt the security argument proposed for Rasta to Pasta.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">8.1 Truncation versus Feed-Forward</h3>

    <p class="text-gray-300">Consider a permutation <span class="math">F:\\mathbb{F}_{p}^{s}\\to\\mathbb{F}_{p}^{s}</span>, and assume it can be split as <span class="math">F(\\cdot)=F_{2}\\circ F_{1}(\\cdot)</span>. The advantage of a truncation with respect to a feed-forward operation is that it prevents attacks using the backward direction without requiring a high degree of the inverse round function. Indeed, in the feed-forward case, given <span class="math">y=F(x)+x</span>, one can set up a system of equations of the form <span class="math">F_{1}(x)=F_{2}^{-1}(y-x)</span>. In order to prevent the possibility to solve it using algebraic techniques (e.g., Gröbner bases), we need that both <span class="math">F_{1}</span> and <span class="math">F_{2}^{-1}</span> have a high degree. In the case of truncation, given <span class="math">y=\\text{left}_{t}(F(x))</span>, the system of equations becomes <span class="math">F_{1}(x)=F_{2}^{-1}(y\\parallel y^{\\prime})</span> for a certain unknown <span class="math">y^{\\prime}\\in\\mathbb{F}_{p}^{t}</span>. If <span class="math">t</span> is large enough, the cost of solving it exceeds the security level. However, the overall size of the state must be larger than in the feed-forward case due to losing part of the state.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">8.2 Security against Statistical Attacks: Properties of the Linear Layer</h3>

    <p class="text-gray-300">As in Rasta, the security against statistical attacks as differential <em>[x10]</em> and linear <em>[x24]</em> ones (besides all their variants, as the truncated differential <em>[x18]</em>, zero–correlation linear <em>[x11]</em>, impossible differential <em>[x12]</em>, and so on) is achieved by changing the linear layers at every encryption. In a statistical attack, the attacker makes a statistical analysis of the ciphertexts generated by a set of chosen/known plaintexts in order to break the scheme. This strategy works under the assumption that the ciphertexts are generated via the same encryption scheme. By construction, this is not the case for Rasta–like designs as Pasta, which implies that statistical attacks are not a threat for our design.</p>

    <p class="text-gray-300">Having said that, it is important that the linear layers that instantiate Pasta do not have any weakness that could be exploited for an attack, and that full diffusion is achieved over the entire scheme. For this reason, we study the linear branch number of the random matrices that instantiate Pasta, and we show that it is sufficiently high in general. We recall that the branch number of a matrix is defined as the minimum number of non-zero entries that two <span class="math">t</span>-element mask vectors <span class="math">\\alpha</span> and <span class="math">\\beta</span> that satisfy <span class="math">\\alpha=M^{T}\\times\\beta</span> could have – we refer to <em>[x13]</em> for an overview of correlation analysis in <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Since Pasta’s linear layer is defined as</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}\\vec{x}_{L}\\\\ \\vec{x}_{R}\\end{bmatrix}\\mapsto\\begin{bmatrix}2\\cdot I&I\\\\ I&2\\cdot I\\end{bmatrix}\\times\\begin{bmatrix}M_{j,L,N,i}\\times\\vec{x}_{L}\\\\ M_{i,R,N,i}\\times\\vec{x}_{R}\\end{bmatrix}\\,, \\]</p>

    <p class="text-gray-300">we have the following scenario:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the fixed matrix <span class="math">\\text{circ}(2,1)\\in\\mathbb{F}_{p}^{2\\times 2}</span> is MDS, which implies that full diffusion among the <span class="math">l</span>-th element of <span class="math">\\vec{x}_{L}</span> and the <span class="math">l</span>-th element of <span class="math">\\vec{x}_{R}</span> is achieved for each <span class="math">l\\in\\{0,1,\\ldots,t-1\\}</span>;</li>

      <li>the invertible matrices <span class="math">M_{j,L,N,i}</span> and <span class="math">M_{j,R,N,i}</span> are randomly generated for each new encryption, hence, we cannot guarantee a certain branch number a priori.</li>

    </ul>

    <p class="text-gray-300">For this reason, we estimate a lower bound of the probability that a randomly picked matrix <span class="math">M\\in\\mathbb{F}_{p}^{t\\times t}</span> allows for transitions on the <span class="math">t</span>-element mask vectors <span class="math">\\alpha</span> to <span class="math">\\beta</span>, <span class="math">\\alpha=M^{T}\\times\\beta</span>, where <span class="math">\\alpha</span> and <span class="math">\\beta</span> have many zeros (which corresponds to the best scenario for an attacker).</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Let <span class="math">M\\in\\mathbb{F}_{p}^{t\\times t}</span> be a random invertible matrix. Its branch number satisfies the following for <span class="math">p&gt;t\\geq 6</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{branch number}\\geq t/2]\\geq 1-\\frac{2}{p^{t/2-2}}\\,.</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">Proof. By definition:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\text {b r a n c h n u m b e r} \\geq z ] = 1 - \\Pr [ \\text {b r a n c h n u m b e r} &lt;   z ] = 1 - \\frac {\\sum_ {\\alpha , \\beta \\text {s . t .} \\# (\\alpha) + \\# (\\beta) &lt;   z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {X} _ {\\alpha , \\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\# (\\gamma)</span>  denotes the number of non-zero entries of the vector  <span class="math">\\gamma</span> ;</li>

      <li><span class="math">\\mathfrak{X}_{\\alpha, \\beta}</span>  denotes the set of invertible matrices that satisfy  <span class="math">\\alpha = M^T \\beta</span> ;</li>

      <li><span class="math">\\Im</span>  denotes the set of invertible matrices.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First of all, we are interested in the number  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Im</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  of all possible bijective matrices  </span>M<span class="math"> . A matrix  </span>M<span class="math">  is bijective, if all its row vectors are linearly independent and different from the all 0 vector. So, for the first row, we have  </span>p^t - 1<span class="math">  possibilities to choose a row vector. For the second row, we have  </span>p^t<span class="math">  possibilities to choose the coefficients minus  </span>p<span class="math">  choices that is just the linear combination of the first row. In the third row, we now have  </span>p^t - p^2$  choices, and so on. So we finally end up with</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Im</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\prod_ {i = 0} ^ {t - 1} \\left(p ^ {t} - p ^ {i}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Next, we consider the number of matrices  <span class="math">M</span> , that allow a transition  <span class="math">\\alpha = M^T\\beta</span>  for fixed non-zero  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> . For our goal, we are interested in an upper bound of such a number. Hence, we limit ourselves to consider a weaker condition, namely, that (i)  <span class="math">\\beta</span>  maps to the first coordinate of  <span class="math">\\alpha</span>  and that (ii) the matrix is invertible. It is simple to observe that the first condition is satisfied by at most  <span class="math">p^{t - 1}</span>  choices of the coefficients of the first row (note that if  <span class="math">\\alpha_0 = 0</span> , then we exclude the zero-vector as first row of  <span class="math">M</span> ). By combining this fact with the requirement that  <span class="math">M</span>  is bijective, we get the number of matrices  <span class="math">M</span>  that map  <span class="math">\\alpha</span>  to  <span class="math">\\beta</span>  is upper bounded by</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {X} _ {\\alpha , \\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\underbrace {p ^ {t - 1}} _ {\\text {d u e t o} \\alpha = M ^ {T} \\beta} \\cdot \\underbrace {\\prod_ {i = 1} ^ {t - 2} \\left(p ^ {t - 1} - p ^ {i}\\right)} _ {\\text {f o r i n v e r t i b i l i t y}} = p \\cdot \\prod_ {i = 2} ^ {t - 1} \\left(p ^ {t} - p ^ {i}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Finally, we have a look at how many different masks  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  exist, which have together  <span class="math">i</span>  non-zero entries. This number is simply given by  <span class="math">(p - 1)^i\\cdot \\binom{2t}{i}</span> .</p>

    <p class="text-gray-300">Now we have all ingredients we need to bound the probability that a randomly selected matrix  <span class="math">M</span>  has a branch number smaller than  <span class="math">z</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr [ \\text {b r a n c h n u m b e r} &lt;   z ] \\leq \\frac {\\overbrace {p \\cdot \\prod_ {i = 2} ^ {t - 1} \\left(p ^ {t} - p ^ {i}\\right)} ^ {\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak {X} _ {\\alpha , \\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\overbrace {\\sum_ {i = 1} ^ {t - 1} \\left((p - 1) ^ {i} \\binom {2 t} {i}\\right)} ^ {= \\sum_ {i = 1} ^ {z} \\left((p - 1) ^ {i} \\binom {2 t} {i}\\right)}}{\\prod_ {i = 0} ^ {t - 1} \\left(p ^ {t} - p ^ {i}\\right)} \\\\ \\leq \\frac {\\sum_ {i = 1} ^ {z} \\left((p - 1) ^ {i} \\binom {2 t} {i}\\right)}{(p ^ {t} - 1) (p ^ {t - 1} - 1)} \\leq \\frac {z (p - 1) ^ {z} \\binom {2 t} {t}}{(p ^ {t} - 1) (p ^ {t - 1} - 1)} \\leq \\frac {2 z p ^ {z} \\cdot t ^ {t}}{(p ^ {t} - 1) (p ^ {t - 1} - 1)}, \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\binom{2t}{t} = \\frac{2t \\cdot (2t-1) \\cdots (t+1)}{t!} \\leq \\frac{(2t)^t}{2^{t-1}} = 2 \\cdot t^t</span>  since  <span class="math">t! \\geq 2^{t-1}</span> . We now set  <span class="math">z = t/2</span>  and assume that  <span class="math">p &amp;gt; t \\geq 6</span> , we get</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ \\text {b r a n c h n u m b e r} &amp;lt;   t / 2 ] \\leq \\frac {p \\cdot p ^ {t / 2} \\cdot p ^ {t}}{(p ^ {t} - 1) (p ^ {t - 1} - 1)} \\leq \\frac {1 6 \\cdot p ^ {3 t / 2 + 1}}{9 \\cdot p ^ {2 t - 1}} \\leq \\frac {2 p ^ {2}}{p ^ {t / 2}} \\leq 1 / 2,</span></div>

    <p class="text-gray-300">where <span class="math">(x^{t}-1)\\geq 3/4\\cdot x^{t}</span> for <span class="math">x\\geq 3</span> and <span class="math">t\\geq 2</span>, which means that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{branch number}\\geq t/2]\\geq 1-\\frac{2}{p^{t/2-2}}</span></p>

    <p class="text-gray-300">for <span class="math">p\\gg t\\geq 6</span>. <span class="math">\\Box</span></p>

    <p class="text-gray-300">Thus, <span class="math">\\Pr[\\text{branch number}\\geq t/2]\\approx 1</span> for <span class="math">p\\gg t\\geq 6</span> .</p>

    <p class="text-gray-300">However, in our case, the total number of sequential matrices that we can generate is limited by the <span class="math">t</span> elements <span class="math">\\alpha_{i}</span> we can choose. Hence, in total we can generate <span class="math">\\hat{\\kappa}=(p-1)^{t}</span> invertible matrices. Considering this special case, we get that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{branch number}\\geq z]\\geq 1-\\frac{2\\cdot z\\cdot p^{z}\\cdot t^{t}}{(p-1)^{t}}\\geq 1-\\frac{2^{z}\\cdot z\\cdot t^{t}}{(p-1)^{t-z}}\\,,</span></p>

    <p class="text-gray-300">where <span class="math">2(p-1)\\geq p</span>. It follows that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{branch number}\\geq t/2]\\geq 1-\\frac{t}{2}\\cdot\\left(\\frac{2t^{2}}{p-1}\\right)^{t/2}\\,,</span></p>

    <p class="text-gray-300">i.e., <span class="math">\\Pr[\\text{branch number}\\geq t/2]\\approx 1</span> for <span class="math">p\\gg 2t^{2}</span>, as in our case.</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">8.3 Security against Algebraic Attacks</h3>

    <p class="text-gray-300">To describe our analysis, we focus on Pasta-3. Our input <span class="math">\\vec{x}</span> consists of <span class="math">s=2t</span> unknown key elements and the output <span class="math">\\vec{y}</span> consists of <span class="math">t</span> elements (after truncation). Hence, for a known nonce <span class="math">N</span> and block counter <span class="math">i</span> we have</p>

    <p class="text-gray-300"><span class="math">\\vec{x}</span> <span class="math">=k_{1}\\mid\\mid k_{2}\\mid\\mid\\cdots\\mid\\mid k_{s}\\,,</span> <span class="math">\\vec{y}</span> <span class="math">=\\text{left}_{t}(\\text{Pasta-}\\pi(\\vec{x},N,i))=y_{1}\\mid\\mid y_{2}\\mid\\mid\\cdots\\mid\\mid y_{t}\\,.</span></p>

    <h4 id="sec-54" class="text-lg font-semibold mt-6">8.3.1 Linearization</h4>

    <p class="text-gray-300">In a linearization approach, the attacker replaces all monomials of degrees greater than 1 by new variables, and finally tries to solve the resulting system of linear equations. Assuming <span class="math">n_{v}</span> variables and a maximum degree of <span class="math">d</span>, the number of possible monomials is</p>

    <p class="text-gray-300"><span class="math">n_{m}=\\sum_{i=1}^{d}{n_{v}+i-1\\choose i}.</span> (3)</p>

    <p class="text-gray-300">For Pasta-3 we have <span class="math">d=12</span>, and hence <span class="math">s</span> input words with degree 12 after one function call. Further, we obtain <span class="math">t</span> equations with each call. In order to get as many equations <span class="math">n_{e}</span> as variables <span class="math">n_{v}</span> for our equation system, we can simply request more data, which eventually results in <span class="math">n_{e}=n_{v}</span> after <span class="math">s/t=2</span> blocks (this has no effect on the efficiency of the linearization). Due to the complexity of solving a linear equation system in <span class="math">n_{m}</span> variables, we target <span class="math">\\log_{2}(n_{m})&gt;64</span>. Hence, <span class="math">s\\geq 207</span> input words for a security of 128 bits. Following the same analysis, we need <span class="math">s\\geq 51</span> for Pasta-4 and <span class="math">s\\geq 101</span> for a Masta-like 4-round instance using only degree-2 Feistel-like S-boxes.</p>

    <p class="text-gray-300">In this analysis, we assume that almost all monomials appear in the final representations, since our design provides strong diffusion in half of the state by using dense invertible matrices, and full diffusion after two full linear layers. In order to get more confidence in our design, we also did some practical tests and show the results in Figure 4. To avoid the effect of cancellations, we used prime numbers of sizes larger than <span class="math">2^{16}</span>. We observe that for the state sizes we tested, the actual number of monomials in the output word with the smallest number of monomials is always very close to the upper bound for the number of monomials given in Eq. (3).</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Comparison of the estimated number of monomials in each of the output words according to Eq. (3) and the lowest number of monomials found in a practical evaluation.</p>

    <p class="text-gray-300">Here we determine how large our key  <span class="math">s</span>  has to be in order to provide security with respect to Gröbner basis attacks up to a complexity of  <span class="math">2^{128}</span>  function calls. As was the case above, we can simply generate sufficiently many equations by requesting at least  <span class="math">s / t = 2</span>  blocks. Hence,  <span class="math">n_v = n_c</span> , and we can estimate the complexity of solving such a system of equations by using theoretical bounds. However, these bounds assume a regular system of equations, and in practical tests we quickly observed that this is not the case for PASTA. Indeed, when building more full-round equations and hence an overdetermined system, we can force the degree of regularity to reach a minimum of 12. By reusing the estimate for the complexity of computing a Gröbner basis [BFSY05] we need  <span class="math">s \\geq 207</span> . Similar results can be obtained by assuming  <span class="math">d = 24</span>  for PASTA-4.</p>

    <p class="text-gray-300">There is also a different way to argue the number of words to use. From the linearization analysis we know that there will be roughly  <span class="math">2^{64}</span>  different monomials in each of the resulting equations. Due to the internals of Gröbner basis algorithms, this results in around  <span class="math">\\left(2^{64}\\right)^{\\omega}</span>  operations being necessary to compute a basis. <span class="math">^{12}</span>  We pessimistically (from a designer's point of view) set  <span class="math">\\omega = 2</span>  and thus have  <span class="math">\\left(2^{64}\\right)^{\\omega} = 2^{128}</span> .</p>

    <p class="text-gray-300">Additional Strategies. The strategy presented above is only one way to attack the system using Gröbner bases. It is common to also consider approaches which introduce new variables in each state. The main idea of this technique is to reduce the degrees of the equations at the expense of more variables, which is particularly useful when trying to represent high-degree equations in a more efficient way. In more detail, we may introduce a new variable after each nonlinear operation. Considering a total state size of  <span class="math">s = 2t</span>  words, we need to introduce  <span class="math">2s(r - 1)</span>  new variables for an  <span class="math">r</span> -round construction (note that no new variables are needed after the final round, since the stream output added to a plaintext is a degree-3 combination of the previous variables). Using this many variables and equations of a degree larger than or equal to 2 results in a high solving complexity when assuming nontrivial (i.e., dense) equations (we refer to [JV17, NNY18], in which degree-2 equation systems over  <span class="math">\\mathbb{Z}_2</span>  are considered). We therefore conjecture that introducing intermediate variables will only increase the complexity needed to solve the final system when compared to using full-round equations.</p>

    <p class="text-gray-300">8.3.3 Other Algebraic Attacks</p>

    <p class="text-gray-300">Many other known attacks (including e.g. higher-order differential attack <em>[x14, x16]</em>, interpolation attack <em>[x17]</em>, and so on) are prevented by our random linear layers which are different in each Pasta-<span class="math">\\pi</span> evaluation. This is the same strategy as used by e.g. Rasta and Masta. We shortly discuss these attacks in this section. Furthermore, the recent attack proposed on Agrasta <em>[x13]</em> does not apply to Pasta, since it directly exploits the <span class="math">\\chi</span>-layer which is not present in Pasta, and it works differently over large prime fields.</p>

    <h5 id="sec-56" class="text-base font-semibold mt-4">Higher-Order Differential Attacks.</h5>

    <p class="text-gray-300">Higher-order differential attacks <em>[x14, x16]</em> are essentially prevented by the fact that the attacker is only allowed to evaluate a single instance once due to the different linear layers. Moreover, the only subspaces of a finite field <span class="math">\\mathbb{F}_{p}</span> with prime characteristic are <span class="math">\\{0\\}</span> and <span class="math">\\mathbb{F}_{p}</span> itself, which makes higher-order differential attacks even harder (however, there have been variations of this attack vector which also work over <span class="math">\\mathbb{F}_{p}</span> <em>[BCD^{+}20]</em>). This also includes higher-order differential distinguishers and attacks based on higher-order differential properties (e.g., cube attacks <em>[x20, x5]</em>).</p>

    <h5 id="sec-57" class="text-base font-semibold mt-4">Interpolation Attacks.</h5>

    <p class="text-gray-300">In an interpolation attack <em>[x17]</em>, the attacker tries to build an interpolation polynomial mapping an input to the corresponding output. This polynomial can then be used to recover the secret key. However, interpolation attacks need multiple evaluations of a fixed permutation, which is not possible when considering Pasta and its varying linear layers.</p>

    <h5 id="sec-58" class="text-base font-semibold mt-4">Guessing Attacks.</h5>

    <p class="text-gray-300">Guessing (or guess-and-determine) attacks combine the guessing of one or more variables with other attack strategies, potentially decreasing their complexities by fixing parts of the secret. However, due to the large number of state words and a minimum size of 17 bits for each of them, it is unlikely that guessing any of the state words (or even multiple of them) leads to an advantage. Indeed, using our analysis, guessing from 1 to <span class="math">\\lfloor 127/17\\rfloor</span> words does not lead to any improvement, but even makes the attacks worse. In more detail, we would need to improve the attack itself by a factor of at least <span class="math">2^{17w}</span> when guessing <span class="math">w</span> input words, which for all configurations we tested <span class="math">(1,\\ldots,\\lfloor 128/17\\rfloor</span> guesses) is not possible with our analysis. For example, in the 17-bit case with <span class="math">s=51</span> and when considering the linearization approach, the complexity is reduced by less than one bit when guessing a single variable. When assuming <span class="math">s=44</span> (guessing the maximum feasible number of variables), the complexity of the attack is still around 120 bits, which is much more than the allowed <span class="math">128-7\\cdot 17=9</span> bits. We remark that this is the “weakest” instance from the attacker’s perspective, and for all larger primes we would need an even higher performance increase for the actual attack. Further, given the density of the algebraic representation, we do not expect that the equation systems get significantly easier to solve by guessing any small number of variables.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">8.4 On Using Two Different S-Boxes</h3>

    <p class="text-gray-300">To be optimized for HHE, we designed Pasta to have a small number of rounds (implying less noise consumption) and a small state size (implying fast homomorphic evaluation time). Therefore, we make use of a Feistel S-box of degree 2 and a cube S-box of degree 3. Using only Feistel S-boxes would result in a design with worse performance: A 3-round design using only Feistel S-boxes would require <span class="math">t\\approx 500</span> plain/cipher words (based on the security analysis in Section 8), which results in significantly longer homomorphic evaluation times. A 4-round design would have the same multiplicative depth as Masta-4, leading to the same HE parameters and noise consumption as Masta-4. Therefore, this design would be faster then Masta due to the smaller size <span class="math">t</span> (<span class="math">t=55</span> as shown in Section 8) in one evaluation branch. However, it would not have a noise advantage. Pasta-3, on the</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">other hand, has both a runtime and a noise advantage due to requiring fewer rounds by having the same size  <span class="math">t</span>  as MASTA-4.</p>

    <p class="text-gray-300">The diffusion of a 2-round cipher based only on cube S-boxes would largely rely only on the single layer between the matrix multiplication. Thus the resulting diffusion is likely bad potentially allowing to separate the cipher  <span class="math">\\left[\\mathrm{CDK}^{+}18\\right]</span> . Therefore, we chose to instantiate PASTA-3 by using the smallest depth which allows a 3-round cipher with approximately the same number of plain/cipher words  <span class="math">t</span>  as MASTA-4, which is using two Feistel S-boxes and one cube S-box.</p>

    <p class="text-gray-300">In this section, we benchmark a packed implementation of our PASTA design in both SEAL and HElib. We also reimplemented a packed version of MASTA and HERA, using the same algorithms to generate random field elements and homomorphic matrix multiplications as in PASTA to compare these ciphers in a fair setting. Similar as in Section 5, we also benchmark the ciphers in a real HHE use case.</p>

    <p class="text-gray-300">We first compare PASTA, MASTA, and HERA to the  <span class="math">\\mathbb{Z}_2</span>  benchmarks from Section 5. Therefore, we instantiate these ciphers with a 17-bit prime and benchmark their performance for the small use case from Section 5. <span class="math">^{13}</span>  The resulting benchmarks can be seen in Table 9 where we depict both runtime and remaining noise budget after each step of the HHE use case for SEAL. For benchmarks in HElib we refer to Appendix B.2.2.</p>

    <p class="text-gray-300">Table 9: Runtime and noise budget of the small HHE use case in the SEAL library (security level  <span class="math">\\lambda = 128</span>  bit).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc. runtime s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key noise bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decomp. runtime s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">noise bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Small Use runtime s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case noise bit</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 65537 (17 bit):  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16384</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.017</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">364</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9.28</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">95</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.197</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">51</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.058</td>

            <td class="px-3 py-2 border-b border-gray-700">800</td>

            <td class="px-3 py-2 border-b border-gray-700">54.2</td>

            <td class="px-3 py-2 border-b border-gray-700">460</td>

            <td class="px-3 py-2 border-b border-gray-700">1.11</td>

            <td class="px-3 py-2 border-b border-gray-700">415</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.057</td>

            <td class="px-3 py-2 border-b border-gray-700">800</td>

            <td class="px-3 py-2 border-b border-gray-700">39.2</td>

            <td class="px-3 py-2 border-b border-gray-700">386</td>

            <td class="px-3 py-2 border-b border-gray-700">1.13</td>

            <td class="px-3 py-2 border-b border-gray-700">341</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.051</td>

            <td class="px-3 py-2 border-b border-gray-700">800</td>

            <td class="px-3 py-2 border-b border-gray-700">16.6</td>

            <td class="px-3 py-2 border-b border-gray-700">333</td>

            <td class="px-3 py-2 border-b border-gray-700">1.12</td>

            <td class="px-3 py-2 border-b border-gray-700">287</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following, we compare the runtime and noise consumption of all  <span class="math">\\mathbb{Z}_2</span>  and  <span class="math">\\mathbb{F}_p</span>  (with  <span class="math">p = 65537</span> ) ciphers, namely in Figure 5 for homomorphically decrypting one block in SEAL ( <span class="math">\\mathbb{F}_p</span>  values from Section 9.2), and in Figure 6 for the HHE use case (including HHE decompression) in SEAL. For HElib benchmarks we refer to Appendix B.2.2.</p>

    <p class="text-gray-300">Our figures indicate that PASTA is always the fastest cipher - mainly PASTA-4 due to the small number of encrypted words. However, PASTA-3 is faster when evaluating the whole HHE use case in SEAL due to the small multiplicative depth requiring smaller HE parameters for security. Comparing PASTA to the  <span class="math">\\mathbb{Z}_2</span>  ciphers, one can observe that homomorphically decrypting one block requires less noise budget for the  <span class="math">\\mathbb{Z}_2</span>  ciphers.</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">However, PASTA has (besides the runtime advantage) a noise advantage over the  <span class="math">\\mathbb{Z}_2</span>  ciphers when considering the HHE use case due to the significantly larger multiplicative depth of the binary circuits for integer arithmetic. Concretely, decompression and use case evaluation is  <span class="math">33\\times</span>  faster in SEAL using PASTA-3 and  <span class="math">82\\times</span>  faster in HElib using PASTA-4 compared to AGRASTA. Using TFHE in gate-bootstrapping mode for  <span class="math">\\mathbb{Z}_2</span>  ciphers instead of e.g. SEAL does not help the  <span class="math">\\mathbb{Z}_2</span>  ciphers either, since PASTA-3 in SEAL is  <span class="math">47\\times</span>  faster than using KREYVIUM in TFHE for the small HHE use case. Increasing the bitsize of the encrypted integers or chaining multiple matrix multiplications would further demonstrate the advantage of PASTA over  <span class="math">\\mathbb{Z}_2</span>  ciphers, since the drastic increase in the multiplicative depth of the use case would make using the  <span class="math">\\mathbb{Z}_2</span>  ciphers infeasible.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5: Runtime and noise comparison of  <span class="math">\\mathbb{Z}_2</span>  ciphers for homomorphically decrypting 1 Block in SEAL (security level  <span class="math">\\lambda = 128</span>  bit).</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6: Runtime and noise comparison for the small HHE use case in SEAL (security level  <span class="math">\\lambda = 128</span>  bit).</p>

    <p class="text-gray-300">Since all  <span class="math">\\mathbb{F}_p</span>  ciphers outperform the  <span class="math">\\mathbb{Z}_2</span>  ciphers for HHE, we continue with comparing these ciphers. Similar to the  <span class="math">\\mathbb{Z}_2</span>  benchmarks, we also compare PASTA, MASTA, and HERA in a real HHE use case. However, to further demonstrate the advantage of the  <span class="math">\\mathbb{F}_p</span>  ciphers in HHE, we benchmark a more extensive use case with a significantly higher multiplicative</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">depth. We reuse the same use case as in Section 4, i.e., three affine layers interleaved with squarings on a vector  <span class="math">\\vec{x} \\in \\mathbb{F}_p^{200}</span> . We benchmark the use case for 3 different primes  <span class="math">p</span> .</p>

    <p class="text-gray-300">In this section we discuss the benchmarks for the  <span class="math">\\mathbb{F}_p</span>  ciphers in SEAL, for benchmarks in HElib we refer to Appendix B.2.3. Furthermore, we provide CPU cycle counts for plain encryption with PASTA, MASTA, and HERA in Appendix B.3. In Table 10 we present the benchmarks for the packed implementation of PASTA, MASTA, and HERA in the SEAL library. We give timings for homomorphically decrypting one block and additionally timings for the bigger HHE use case. We parameterize SEAL to provide 128 bits of security and use the smallest  <span class="math">N</span>  allowing enough noise budget for correct evaluation.</p>

    <p class="text-gray-300">Table 10:  <span class="math">{\\mathbb{F}}_{p}</span>  benchmarks for the SEAL library (security level  <span class="math">\\lambda  = {128}</span>  bit).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 Block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bigger HHE use case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">Use Case s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 65537 (17 bit):  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16384</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.016</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9.22</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32768</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.056</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">86.2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">43.9</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">0.016</td>

            <td class="px-3 py-2 border-b border-gray-700">11.6</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.058</td>

            <td class="px-3 py-2 border-b border-gray-700">108.7</td>

            <td class="px-3 py-2 border-b border-gray-700">43.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.062</td>

            <td class="px-3 py-2 border-b border-gray-700">39.6</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.056</td>

            <td class="px-3 py-2 border-b border-gray-700">157.0</td>

            <td class="px-3 py-2 border-b border-gray-700">43.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.052</td>

            <td class="px-3 py-2 border-b border-gray-700">16.6</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.051</td>

            <td class="px-3 py-2 border-b border-gray-700">215.4</td>

            <td class="px-3 py-2 border-b border-gray-700">43.9</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 8088322049 (33 bit):  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32768</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.057</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">43.1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32768</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.055</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">86.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">43.9</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.058</td>

            <td class="px-3 py-2 border-b border-gray-700">54.4</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.215</td>

            <td class="px-3 py-2 border-b border-gray-700">568.5</td>

            <td class="px-3 py-2 border-b border-gray-700">221.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.055</td>

            <td class="px-3 py-2 border-b border-gray-700">39.3</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.215</td>

            <td class="px-3 py-2 border-b border-gray-700">852.6</td>

            <td class="px-3 py-2 border-b border-gray-700">220.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">32768</td>

            <td class="px-3 py-2 border-b border-gray-700">0.051</td>

            <td class="px-3 py-2 border-b border-gray-700">16.6</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.196</td>

            <td class="px-3 py-2 border-b border-gray-700">1227.7</td>

            <td class="px-3 py-2 border-b border-gray-700">220.7</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 1096486890805657601 (60 bit):  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32768</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.055</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">58.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">65536</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">448.6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220.8</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.220</td>

            <td class="px-3 py-2 border-b border-gray-700">284.3</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.212</td>

            <td class="px-3 py-2 border-b border-gray-700">571.9</td>

            <td class="px-3 py-2 border-b border-gray-700">223.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.219</td>

            <td class="px-3 py-2 border-b border-gray-700">213.3</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.212</td>

            <td class="px-3 py-2 border-b border-gray-700">853.3</td>

            <td class="px-3 py-2 border-b border-gray-700">220.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.200</td>

            <td class="px-3 py-2 border-b border-gray-700">94.6</td>

            <td class="px-3 py-2 border-b border-gray-700">65536a</td>

            <td class="px-3 py-2 border-b border-gray-700">0.193</td>

            <td class="px-3 py-2 border-b border-gray-700">1228.3</td>

            <td class="px-3 py-2 border-b border-gray-700">221.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a Noise budget did not suffice and bigger parameters are not available in SEAL. Thus, bootstrapping is required.</p>

    <p class="text-gray-300">In the following figures we compare the runtime and noise consumption of PASTA, MASTA, and HERA for 3 different prime fields  <span class="math">\\mathbb{F}_p</span> , in Figure 7 for homomorphically decrypting one block in SEAL, and in Figure 8 for the HHE use case (including HHE decompression) in SEAL. For HElib benchmarks we refer to Appendix B.2.3.</p>

    <p class="text-gray-300">The figures show the advantage of PASTA compared to its competitors. In all figures, PASTA-3 has a smaller runtime and noise consumption than MASTA, especially when the smaller multiplicative depth allows for smaller HE parameters (compare, e.g., 33-bit prime fields in Figure 8, where PASTA-3 is  <span class="math">6 \\times</span>  faster than MASTA-4). PASTA-3 is only outperformed by PASTA-4 and HERA for a small number of encrypted words (e.g., only encrypting one block as for the 33-bit prime for SEAL where HERA is slightly faster than</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">PASTA-4, or the small HHE use case from Section 9.1 in HElib where PASTA-4 is  <span class="math">2.7 \\times</span>  faster than MASTA-4) if the overall multiplicative depth allows PASTA-4 or HERA to use the same HE parameters as PASTA-3. Hence, we propose using PASTA-4 for HHE use cases with a small number of encrypted words, and PASTA-3 everywhere else.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 7: Runtime and noise comparison of  <span class="math">\\mathbb{F}_p</span>  ciphers for homomorphically decrypting 1 Block in SEAL (security level  <span class="math">\\lambda = 128</span>  bit).</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 8: Runtime and noise comparison for the bigger HHE use case in SEAL (security level  <span class="math">\\lambda = 128</span>  bit). Ciphers marked with a * did not have enough noise budget.</p>

    <p class="text-gray-300">In recent years, many symmetric primitives defined over  <span class="math">\\mathbb{F}_p^t</span> , such as GMiMC [AGP+19], HADESMiMC [GLR+20], POSEIDON [GKR+21], Rescue [AAB+20], CIMINION [DGGK21], GRIFFIN [GHR+22], Reinforced Concrete [GKL+22], and HYDRA [GOSW22], have been proposed in the literature. However, contrary to PASTA, these primitives were not designed for HHE, but for MPC and zk-SNARK/STARK use cases, which is why they were optimized for different metrics. While having a low multiplicative depth is the most important design criterion for use cases involving homomorphic encryption, the other use cases usually just require a small total number of multiplications. Therefore, these aforementioned symmetric primitives have a significant larger number of rounds and, consequently, a large multiplicative depth which makes them infeasible for HE use cases. PASTA on the</p>

    <p class="text-gray-300">other hand has a very small depth, but the significantly larger statesize results in a large total number of multiplications. In HE use cases many of these multiplications are performed in parallel using packing, but this large number of multiplications makes Pasta worse for MPC and zk-SNARK/STARK applications. In some MPC scenarios (e.g., scenarios with a very high-delay, low bandwidth WAN connection between the parties), the low multiplicative depth of Pasta may, however, give it an advantage over the other constructions.</p>

    <h2 id="sec-67" class="text-2xl font-bold">Conclusion</h2>

    <p class="text-gray-300">In this paper, we investigated hybrid homomorphic encryption, a technique to combat ciphertext expansion in homomorphic encryption applications at the cost of more expensive computations in the encrypted domain. Since HHE was first mentioned in <em>[x20]</em>, many symmetric ciphers for HHE have been proposed in the literature. However, the effects of applying HHE to any use case were not really understood so far. In our work, we tackled this issue in several ways: First, we for the first time investigate the high-level impact on the server and client when applying HHE to a practical use case in Section 4. Secondly, we implement a framework which for the first time compares many different symmetric ciphers when used with HHE in three popular HE libraries. Finally, to improve the performance of HHE, we propose a new symmetric cipher, dubbed Pasta, which outperforms the state-of-the-art for integer use cases over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">The main take-aways of this paper are the following: Our investigations show, that HHE achieves the best results when the clients are embedded devices with limited computational power and bandwidth. Furthermore, many state-of-the-art ciphers are not well suited for many HHE applications due to being defined over <span class="math">\\mathbb{Z}_{2}</span>. Finally, while HHE is very beneficial for clients, the actual computation in the encrypted domain suffers. This is due to first having to decrypt the symmetric ciphertexts under homomorphic encryption before computing the actual use case. While this extra work naturally contributes to the computation runtime, it also contributes to the multiplicative depth of the whole HE computation. Since an efficient bootstrapping operation is still missing from most state-of-the-art HE libraries (such as the ones considered in this paper), this additional multiplicative depth significantly contributes to the whole computaiton runtime. As a consequence, we show that only evaluating a cipher under HE is not enough to estimate its performance in HHE, one has to consider the whole HHE use case instead.</p>

    <h2 id="sec-68" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">This work was supported by EU’s Horizon 2020 project Safe-DEED under grant agreement n°825225, and by the "DDAI" COMET Module within the COMET – Competence Centers for Excellent Technologies Programme, funded by the Austrian Federal Ministry for Transport, Innovation and Technology (bmvit), the Austrian Federal Ministry for Digital and Economic Affairs (bmdw), the Austrian Research Promotion Agency (FFG), the province of Styria (SFG) and partners from industry and academia. The COMET Programme is managed by FFG. Lorenzo Grassi is supported by the European Research Council under the ERC advanced grant agreement under grant ERC-2017-ADG Nr. 788980 ESCADA.</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AAB^{+}20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. IACR Trans. Symmetric Cryptol., 2020(3):1–45, 2020.</li>

      <li>[AGP^{+}19] Martin R. Albrecht, Lorenzo Grassi, Léo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, and Markus Schofnegger. Feistel Structures for MPC, and More. In ESORICS, volume 11736 of LNCS, pages 151–171. Springer, 2019.</li>

      <li>[AMT22] Tomer Ashur, Mohammad Mahzoun, and Dilara Toprakhisar. Chaghri - an FHE-friendly Block Cipher. IACR Cryptol. ePrint Arch., page 592, 2022. accepted at ACM CCS 2022.</li>

      <li>[ARS^{+}15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In EUROCRYPT, volume 9056 of LNCS, pages 430–454. Springer, 2015.</li>

      <li>[BBH^{+}22] Alexandros Bampoulidis, Alessandro Bruni, Lukas Helminger, Daniel Kales, Christian Rechberger, and Roman Walch. Privately connecting mobility to infectious diseases via applied cryptography. Proc. Priv. Enhancing Technol., 2022(4):768–788, 2022.</li>

      <li>[BBS99] Eli Biham, Alex Biryukov, and Adi Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In EUROCRYPT, volume 1592 of LNCS, pages 12–23. Springer, 1999.</li>

      <li>[BCD^{+}20] Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Gaëtan Leurent, María Naya-Plasencia, Léo Perrin, Yu Sasaki, Yosuke Todo, and Friedrich Wiemer. Out of Oddity - New Cryptanalytic Techniques Against Symmetric Primitives Optimized for Integrity Proof Systems. In CRYPTO, volume 12172 of LNCS, pages 299–328. Springer, 2020.</li>

      <li>[BFSY05] Magali Bardet, Jean-Charles Faugere, Bruno Salvy, and Bo-Yin Yang. Asymptotic behaviour of the degree of regularity of semi-regular polynomial systems. In Proc. of MEGA, volume 5, pages 2–2, 2005.</li>

      <li>[BGV12] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. In ITCS, pages 309–325. ACM, 2012.</li>

      <li>[Bra12] Zvika Brakerski. Fully Homomorphic Encryption without Modulus Switching from Classical GapSVP. In CRYPTO, volume 7417 of LNCS, pages 868–886. Springer, 2012.</li>

      <li>[BS90] Eli Biham and Adi Shamir. Differential Cryptanalysis of DES-like Cryptosystems. In CRYPTO, volume 537 of LNCE, pages 2–21. Springer, 1990.</li>

      <li>[BW12] Andrey Bogdanov and Meiqin Wang. Zero Correlation Linear Cryptanalysis with Reduced Data Complexity. In FSE, volume 7549 of LNCS, pages 29–48. Springer, 2012.</li>

      <li>[CCF^{+}16] Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancrède Lepoint, María Naya-Plasencia, Pascal Paillier, and Renaud Sirdey. Stream Ciphers: A Practical Solution for Efficient Homomorphic-Ciphertext Compression. In FSE, volume 9783 of LNCS, pages 313–333. Springer, 2016.</li>

    </ul>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CCK^{+}13] Jung Hee Cheon, Jean-Sébastien Coron, Jinsu Kim, Moon Sung Lee, Tancrède Lepoint, Mehdi Tibouchi, and Aaram Yun. Batch Fully Homomorphic Encryption over the Integers. In EUROCRYPT, volume 7881 of LNCS, pages 315–335. Springer, 2013.</li>

      <li>[CDK^{+}18] Benoît Cogliati, Yevgeniy Dodis, Jonathan Katz, Jooyoung Lee, John P. Steinberger, Aishwarya Thiruvengadam, and Zhe Zhang. Provable Security of (Tweakable) Block Ciphers Based on Substitution-Permutation Networks. In CRYPTO, volume 10991 of LNCS, pages 722–753. Springer, 2018.</li>

      <li>[CDKS21] Hao Chen, Wei Dai, Miran Kim, and Yongsoo Song. Efficient Homomorphic Conversion Between (Ring) LWE Ciphertexts. In ACNS, volume 12726 of LNCS, pages 460–479. Springer, 2021.</li>

      <li>[CGGI16] Ilaria Chillotti, Nicolas Gama, Mariya Georgieva, and Malika Izabachène. TFHE: Fast fully homomorphic encryption library, August 2016. https://tfhe.github.io/tfhe/.</li>

      <li>[CGGI20] Ilaria Chillotti, Nicolas Gama, Mariya Georgieva, and Malika Izabachène. TFHE: Fast Fully Homomorphic Encryption Over the Torus. J. Cryptol., 33(1):34–91, 2020.</li>

      <li>[CGL^{+}20] Edward J. Chou, Arun Gururajan, Kim Laine, Nitin Kumar Goel, Anna Bertiger, and Jack W. Stokes. Privacy-preserving phishing web page classification via fully homomorphic encryption. In ICASSP, pages 2792–2796. IEEE, 2020.</li>

      <li>[CHK^{+}21] Jihoon Cho, Jincheol Ha, Seongkwang Kim, ByeongHak Lee, Joohee Lee, Jooyoung Lee, Dukjae Moon, and Hyojin Yoon. Transciphering Framework for Approximate Homomorphic Encryption. In ASIACRYPT, volume 13092 of LNCS, pages 640–669. Springer, 2021.</li>

      <li>[CHMS22] Orel Cosseron, Clément Hoffmann, Pierrick Méaux, and François-Xavier Standaert. Towards Globally Optimized Hybrid Homomorphic Encryption - Featuring the Elisabeth Stream Cipher. IACR Cryptol. ePrint Arch., page 180, 2022.</li>

      <li>[CIR22] Carlos Cid, John Petter Indrøy, and Håvard Raddum. FASTA - A Stream Cipher for Fast FHE Evaluation. In CT-RSA, volume 13161 of LNCS, pages 451–483. Springer, 2022.</li>

      <li>[CJL^{+}20] Ilaria Chillotti, Marc Joye, Damien Ligier, Jean-Baptiste Orfila, and Samuel Tap. CONCRETE: Concrete Operates oN Ciphertexts Rapidly by Extending TfhE. In WAHC 2020–8th Workshop on Encrypted Computing &amp; Applied Homomorphic Cryptography, volume 15, 2020.</li>

      <li>[CJP21] Ilaria Chillotti, Marc Joye, and Pascal Paillier. Programmable Bootstrapping Enables Efficient Homomorphic Inference of Deep Neural Networks. In CSCML, volume 12716 of LNCS, pages 1–19. Springer, 2021.</li>

      <li>[CKKS17] Jung Hee Cheon, Andrey Kim, Miran Kim, and Yong Soo Song. Homomorphic Encryption for Arithmetic of Approximate Numbers. In ASIACRYPT, volume 10624 of LNCS, pages 409–437. Springer, 2017.</li>

      <li>[CLT14] Jean-Sébastien Coron, Tancrède Lepoint, and Mehdi Tibouchi. Scale-Invariant Fully Homomorphic Encryption over the Integers. In Public Key Cryptography, volume 8383 of LNCS, pages 311–328. Springer, 2014.</li>

    </ul>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CMdG^{+}21] Kelong Cong, Radames Cruz Moreno, Mariana Botelho da Gama, Wei Dai, Ilia Iliashenko, Kim Laine, and Michael Rosenberg. Labeled PSI from homomorphic encryption with reduced computation and communication. In CCS, pages 1135–1150. ACM, 2021.</li>

      <li>[Dae95] Joan Daemen. Cipher and hash function design, strategies based on linear and differential cryptanalysis, PhD Thesis. K.U.Leuven, 1995. http://jda.noekeon.org/.</li>

      <li>[DEG^{+}18] Christoph Dobraunig, Maria Eichlseder, Lorenzo Grassi, Virginie Lallemand, Gregor Leander, Eik List, Florian Mendel, and Christian Rechberger. Rasta: A Cipher with Low ANDdepth and Few ANDs per Bit. In CRYPTO, volume 10991 of LNCS, pages 662–692. Springer, 2018.</li>

      <li>[DGGK21] Christoph Dobraunig, Lorenzo Grassi, Anna Guinet, and Daniël Kuijsters. Ciminion: Symmetric Encryption Based on Toffoli-Gates over Large Finite Fields. In EUROCRYPT, volume 12697 of LNCS, pages 3–34. Springer, 2021.</li>

      <li>[DR00] Joan Daemen and Vincent Rijmen. Rijndael for AES. In AES Candidate Conference, pages 343–348. National Institute of Standards and Technology,, 2000.</li>

      <li>[DR02] Joan Daemen and Vincent Rijmen. The Design of Rijndael: AES - The Advanced Encryption Standard. Information Security and Cryptography. Springer, 2002.</li>

      <li>[DS09] Itai Dinur and Adi Shamir. Cube Attacks on Tweakable Black Box Polynomials. In EUROCRYPT, volume 5479 of LNCS, pages 278–299, 2009.</li>

      <li>[DSC^{+}19] Roshan Dathathri, Olli Saarikivi, Hao Chen, Kim Laine, Kristin E. Lauter, Saeed Maleki, Madanlal Musuvathi, and Todd Mytkowicz. CHET: an optimizing compiler for fully-homomorphic neural-network inferencing. In PLDI, pages 142–156. ACM, 2019.</li>

      <li>[Fau99] Jean-Charles Faugére. A new efficient algorithm for computing gröbner bases (f4). Journal of Pure and Applied Algebra, 139(1):61–88, 1999.</li>

      <li>[FV12] Junfeng Fan and Frederik Vercauteren. Somewhat Practical Fully Homomorphic Encryption. IACR Cryptol. ePrint Arch., 2012:144, 2012.</li>

      <li>[Gen09] Craig Gentry. Fully homomorphic encryption using ideal lattices. In STOC, pages 169–178. ACM, 2009.</li>

      <li>[GHR^{+}22] Lorenzo Grassi, Yonglin Hao, Christian Rechberger, Markus Schofnegger, Roman Walch, and Qingju Wang. A New Feistel Approach Meets Fluid-SPN: Griffin for Zero-Knowledge Applications. IACR Cryptol. ePrint Arch., page 403, 2022.</li>

      <li>[GHS12] Craig Gentry, Shai Halevi, and Nigel P. Smart. Homomorphic Evaluation of the AES Circuit. In CRYPTO, volume 7417 of LNCS, pages 850–867. Springer, 2012.</li>

      <li>[GKL^{+}22] Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, Markus Schofnegger, and Roman Walch. Reinforced concrete: A fast hash function for verifiable computation. In CCS, pages 1323–1335. ACM, 2022.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GKR^{+}21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In 30th USENIX Security Symposium (USENIX Security 21). USENIX Association, 2021.</li>

      <li>[GLR^{+}20] Lorenzo Grassi, Reinhard Lüftenegger, Christian Rechberger, Dragos Rotaru, and Markus Schofnegger. On a Generalization of Substitution-Permutation Networks: The HADES Design Strategy. In EUROCRYPT, volume 12106 of LNCS, pages 674–704. Springer, 2020.</li>

      <li>[GØSW22] Lorenzo Grassi, Morten Øygarden, Markus Schofnegger, and Roman Walch. From Farfalle to Megafono via Ciminion: The PRF Hydra for MPC Applications. IACR Cryptol. ePrint Arch., page 342, 2022.</li>

      <li>[GPP11] Jian Guo, Thomas Peyrin, and Axel Poschmann. The PHOTON Family of Lightweight Hash Functions. In CRYPTO, volume 6841 of LNCS, pages 222–239. Springer, 2011.</li>

      <li>[GPPR11] Jian Guo, Thomas Peyrin, Axel Poschmann, and Matthew J. B. Robshaw. The LED Block Cipher. In CHES, volume 6917 of LNCS, pages 326–341. Springer, 2011.</li>

      <li>[HKC^{+}20] Jincheol Ha, Seongkwang Kim, Wonseok Choi, Jooyoung Lee, Dukjae Moon, Hyojin Yoon, and Jihoon Cho. Masta: An HE-Friendly Cipher Using Modular Arithmetic. IEEE Access, 8:194741–194751, 2020.</li>

      <li>[HKL^{+}22] Jincheol Ha, Seongkwang Kim, ByeongHak Lee, Jooyoung Lee, and Mincheol Son. Rubato: Noisy Ciphers for Approximate Homomorphic Encryption. In EUROCRYPT, volume 13275 of LNCS, pages 581–610. Springer, 2022.</li>

      <li>[HL20] Phil Hebborn and Gregor Leander. Dasta - Alternative Linear Layer for Rasta. IACR Trans. Symmetric Cryptol., 2020(3):46–86, 2020.</li>

      <li>[HS14] Shai Halevi and Victor Shoup. Algorithms in HElib. In CRYPTO, volume 8616 of LNCS, pages 554–571. Springer, 2014.</li>

      <li>[HS15] Shai Halevi and Victor Shoup. Bootstrapping for HElib. In EUROCRYPT, volume 9056 of LNCS, pages 641–670. Springer, 2015.</li>

      <li>[HS18] Shai Halevi and Victor Shoup. Faster Homomorphic Linear Transformations in HElib. In CRYPTO, volume 10991 of LNCS, pages 93–120. Springer, 2018.</li>

      <li>[HS20] Shai Halevi and Victor Shoup. Design and implementation of HElib: a homomorphic encryption library. IACR Cryptol. ePrint Arch., 2020:1481, 2020.</li>

      <li>[JK97] Thomas Jakobsen and Lars R. Knudsen. The Interpolation Attack on Block Ciphers. In FSE, volume 1267 of LNCS, pages 28–40. Springer, 1997.</li>

      <li>[JV17] Antoine Joux and Vanessa Vitse. A Crossbred Algorithm for Solving Boolean Polynomial Systems. In NuTMiC, volume 10737 of LNCS, pages 3–21. Springer, 2017.</li>

      <li>[JVC18] Chiraag Juvekar, Vinod Vaikuntanathan, and Anantha P. Chandrakasan. GAZELLE: A low latency framework for secure neural network inference. In USENIX Security Symposium, pages 1651–1669. USENIX Association, 2018.</li>

    </ul>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Knu94] Lars R. Knudsen. Truncated and Higher Order Differentials. In FSE 1994, volume 1008 of LNCS, pages 196–211. Springer, 1994.</li>

      <li>[Lai94] Xuejia Lai. Higher Order Derivatives and Differential Cryptanalysis, pages 227–233. 1994.</li>

      <li>[LAW^{+}22] Fukang Liu, Ravi Anand, Libo Wang, Willi Meier, and Takanori Isobe. Coefficient grouping: Breaking chaghri and more. IACR Cryptol. ePrint Arch., page 991, 2022.</li>

      <li>[LPR10] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. On Ideal Lattices and Learning with Errors over Rings. In EUROCRYPT, volume 6110 of LNCS, pages 1–23. Springer, 2010.</li>

      <li>[LSMI21] Fukang Liu, Santanu Sarkar, Willi Meier, and Takanori Isobe. Algebraic Attacks on Rasta and Dasta Using Low-Degree Equations. In ASIACRYPT, volume 13090 of LNCS, pages 214–240. Springer, 2021.</li>

      <li>[Mat93] Mitsuru Matsui. Linear Cryptanalysis Method for DES Cipher. In EUROCRYPT, volume 765 of LNCS, pages 386–397. Springer, 1993.</li>

      <li>[MCJS19] Pierrick Méaux, Claude Carlet, Anthony Journault, and François-Xavier Standaert. Improved Filter Permutators for Efficient FHE: Better Instances and Implementations. In INDOCRYPT, volume 11898 of LNCS, pages 68–91. Springer, 2019.</li>

      <li>[NIS15] NIST. SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions. National Institute of Standards and Technology (NIST), FIPS PUB 202, U.S. Department of Commerce, 2015.</li>

      <li>[NLV11] Michael Naehrig, Kristin E. Lauter, and Vinod Vaikuntanathan. Can homomorphic encryption be practical? In CCSW, pages 113–124. ACM, 2011.</li>

      <li>[NNY18] Ruben Niederhagen, Kai-Chun Ning, and Bo-Yin Yang. Implementing Joux-Vitse’s Crossbred Algorithm for Solving MQ Systems over GF(2) on GPUs. In PQCrypto, volume 10786 of LNCS, pages 121–141. Springer, 2018.</li>

      <li>[Pai99] Pascal Paillier. Public-Key Cryptosystems Based on Composite Degree Residuosity Classes. In EUROCRYPT, volume 1592 of LNCS, pages 223–238. Springer, 1999.</li>

      <li>[RAD78] R L Rivest, L Adleman, and M L Dertouzos. On data banks and privacy homomorphisms. Foundations of Secure Computation, Academia Press, pages 169–179, 1978.</li>

      <li>[Reg05] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. In STOC, pages 84–93. ACM, 2005.</li>

      <li>[RSA78] Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Commun. ACM, 21(2):120–126, 1978.</li>

      <li>[SEA20] Microsoft SEAL (release 3.6). https://github.com/Microsoft/SEAL, November 2020. Microsoft Research, Redmond, WA.</li>

      <li>[SV14] Nigel P. Smart and Frederik Vercauteren. Fully homomorphic SIMD operations. Des. Codes Cryptogr., 71(1):57–81, 2014.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Vie07] Michael Vielhaber. Breaking ONE.FIVIUM by AIDA an Algebraic IV Differential Attack. IACR Cryptology ePrint Archive, 2007:413, 2007.</li>

      <li>[VJH21] Alexander Viand, Patrick Jattke, and Anwar Hithnawi. Sok: Fully homomorphic encryption compilers. In IEEE Symposium on Security and Privacy, pages 1092–1108. IEEE, 2021.</li>

      <li>[WSH^{+}22] Roman Walch, Samuel Sousa, Lukas Helminger, Stefanie N. Lindstaedt, Christian Rechberger, and Andreas Trügler. Cryptotl: Private, efficient and secure transfer learning. CoRR, abs/2205.11935, 2022.</li>

    </ul>

    <h2 id="sec-70" class="text-2xl font-bold">Appendix A HE Schemes and Libraries (cont.)</h2>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">BGV <em>[x1]</em> in HElib <em>[x10]</em>.</h4>

    <p class="text-gray-300">The BGV scheme, and its implementation in HElib, allows plaintexts in <span class="math">\\mathbb{Z}_{p^{r}}</span> and offers more flexibility for choosing HE parameters than SEAL. It allows arbitrary cyclotomic reduction polynomials and it is possible to find parameters which allow packing for <span class="math">\\mathbb{Z}_{2}</span> plaintexts. However, this flexibility comes with the drawback that parameterizing for HElib is more difficult than finding parameters in SEAL, and the limited parameter sets in SEAL allow for more optimized implementations. In this paper we use the HElib version 2.1.0. Similar to BFV in SEAL, additions are considered free in BGV, and the multiplicative depth of the circuit is the most relevant performance metric.</p>

    <h4 id="sec-72" class="text-lg font-semibold mt-6">TFHE <em>[x7]</em> in TFHE <em>[x8]</em>.</h4>

    <p class="text-gray-300">The TFHE library, more concretely the gate-bootstrapping version of the original TFHE library which we use in this paper, is vastly different from SEAL and HElib. It only allows the encryption of boolean values (i.e., plaintexts are in <span class="math">\\mathbb{Z}_{2}</span>), but it is optimized for fast gate bootstrapping. This basically means that after the evaluation of a homomorphic gate the noise in the ciphertext is reset. As a consequence, contrary to most other modern homomorphic encryption schemes, the multiplicative depth of a circuit is no relevant metric there. However, each homomorphically evaluated gate requires the same computational effort, thus additions are not considered to be free as in the BFV or BGV cryptosystems. The most relevant metric for TFHE in gate-bootstrapping mode is, therefore, the total number of gates. Furthermore, SIMD style packing is not supported in TFHE. Since TFHE only allows to encrypt boolean values, we do not implement and consider <span class="math">\\mathbb{F}_{p}</span> ciphers in this library.</p>

    <h2 id="sec-73" class="text-2xl font-bold">Appendix B Additional Benchmarks</h2>

    <p class="text-gray-300">In this section we give the benchmarks of all the ciphers in the original TFHE library (Appendix B.1), and in HElib (Appendix B.2). Finally, we compare the plain performance of Pasta and Masta in Appendix B.3.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">B.1 TFHE Benchmarks of <span class="math">\\mathbb{Z}_{2}</span> Ciphers</h3>

    <p class="text-gray-300">Since the noise in the ciphertexts is reset after every homomorphic operation due to gate-bootstrapping in TFHE, we do not have to choose any parameters for the benchmarks (except the security level, which we set to 128 bits). In Table 11 we present the benchmarks for the TFHE library for homomorphically decrypting only one block, and for the small HHE use case from Section 5. We give timings for homomorphically encrypting the symmetric key, homomorphically decrypting one block, and for the small HHE use case. Since TFHE does not support packing all implementations are bitsliced (i.e., one HE ciphertext per bit).</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">Table 11: Benchmarks for the TFHE library (security level  <span class="math">\\lambda = {128}</span>  bit).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc. Key s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 Block Decomp. s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Small HHE use case Decomp. s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Use Case s</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LOWMC</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003</td>

            <td class="px-3 py-2 border-b border-gray-700">6 120.5</td>

            <td class="px-3 py-2 border-b border-gray-700">6 310.6</td>

            <td class="px-3 py-2 border-b border-gray-700">175.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.013</td>

            <td class="px-3 py-2 border-b border-gray-700">5 728.8</td>

            <td class="px-3 py-2 border-b border-gray-700">5 807.8</td>

            <td class="px-3 py-2 border-b border-gray-700">164.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">0.009</td>

            <td class="px-3 py-2 border-b border-gray-700">3 275.0</td>

            <td class="px-3 py-2 border-b border-gray-700">3 293.6</td>

            <td class="px-3 py-2 border-b border-gray-700">162.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.013</td>

            <td class="px-3 py-2 border-b border-gray-700">5 642.6</td>

            <td class="px-3 py-2 border-b border-gray-700">5 664.7</td>

            <td class="px-3 py-2 border-b border-gray-700">165.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">0.009</td>

            <td class="px-3 py-2 border-b border-gray-700">3 272.7</td>

            <td class="px-3 py-2 border-b border-gray-700">3 293.0</td>

            <td class="px-3 py-2 border-b border-gray-700">162.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AGRASTA</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003</td>

            <td class="px-3 py-2 border-b border-gray-700">407.1</td>

            <td class="px-3 py-2 border-b border-gray-700">408.4</td>

            <td class="px-3 py-2 border-b border-gray-700">164.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003</td>

            <td class="px-3 py-2 border-b border-gray-700">284.1</td>

            <td class="px-3 py-2 border-b border-gray-700">290.4</td>

            <td class="px-3 py-2 border-b border-gray-700">162.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-12</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003</td>

            <td class="px-3 py-2 border-b border-gray-700">284.1</td>

            <td class="px-3 py-2 border-b border-gray-700">559.7</td>

            <td class="px-3 py-2 border-b border-gray-700">162.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-13</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003</td>

            <td class="px-3 py-2 border-b border-gray-700">310.1</td>

            <td class="px-3 py-2 border-b border-gray-700">290.4</td>

            <td class="px-3 py-2 border-b border-gray-700">162.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FILIP-1216</td>

            <td class="px-3 py-2 border-b border-gray-700">0.442</td>

            <td class="px-3 py-2 border-b border-gray-700">1 504.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1 886.9</td>

            <td class="px-3 py-2 border-b border-gray-700">164.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FILIP-1280</td>

            <td class="px-3 py-2 border-b border-gray-700">0.107</td>

            <td class="px-3 py-2 border-b border-gray-700">1 594.5</td>

            <td class="px-3 py-2 border-b border-gray-700">1 981.8</td>

            <td class="px-3 py-2 border-b border-gray-700">162.8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Discussion. In Figure 9 we compare the runtime of homomorphically decrypting one block and the whole HHE use case (including homomorphic decryption) of the  <span class="math">\\mathbb{Z}_2</span>  ciphers in TFHE. In the gate-bootstrapping version of TFHE the main performance metric is the total gate count, which is why KREYVIUM is the fastest choice. Since the TFHE library only allows plaintexts in  <span class="math">\\mathbb{Z}_2</span>  we do not implement and compare  <span class="math">\\mathbb{F}_p</span>  ciphers in TFHE.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 9: Runtime comparison of homomorphically decrypting one block and the small HHE use case (including HHE decompression) of  <span class="math">\\mathbb{Z}_2</span>  ciphers in TFHE (security level  <span class="math">\\lambda = 128</span>  bit).</p>

    <p class="text-gray-300">In this section, we give all the benchmarks in the HElib. First, we benchmark the  <span class="math">\\mathbb{Z}_2</span>  ciphers, before we compare them to the  <span class="math">\\mathbb{F}_p</span>  ciphers. Finally, we benchmark PASTA, MASTA, and HERA in a more extensive use case.</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">In HElib, the security and available noise budget mainly depend on the choice of the cyclotomic reduction polynomial, as well as the size of the ciphertext modulus. A bigger modulus provides a bigger noise budget at the cost of less security. A bigger cyclotomic polynomial provides more security, but is bad for performance. In our benchmarks, we use the tool provided by HElib to find suitable parameters given a target security level of 128 bits and a target noise budget which we gathered from the experiments. The resulting parameter sets provide  <span class="math">\\lambda&#x27; \\approx 128</span>  bits of security with the majority of sets providing slightly less.</p>

    <p class="text-gray-300">In Table 12 we present the benchmarks for the HElib library, for homomorphically decrypting only one block, and for the small HHE use case from Section 5. For both benchmarks we give timings alongside the chosen  <span class="math">m</span> -th cyclotomic reduction polynomial (chosen by HElib) and the estimated security  <span class="math">\\lambda&#x27;</span>  (estimated by HElib). For the HHE use case we additionally give the runtime for the affine transformation use case. To compare the benchmarks to SEAL and TFHE, all implementations are bitsliced (i.e., one HE ciphertext per bit).</p>

    <p class="text-gray-300">Remark 4. HElib supports packing for  <span class="math">\\mathbb{Z}_2</span>  plaintexts. Even though a packed implementation of the symmetric ciphers will increase their overall performance, it complicates the evaluation of an integer matrix-vector multiplication based on binary circuits. Therefore, packed implementations do not fix the main issue of  <span class="math">\\mathbb{Z}_2</span>  ciphers for HHE, which is supporting integer arithmetic over  <span class="math">\\mathbb{F}_p</span> . For this reason, we do not provide explicit packed benchmarks for the ciphers in the paper.</p>

    <p class="text-gray-300">Table 12: Benchmarks of the  <span class="math">\\mathbb{Z}_2</span>  ciphers in the HElib library.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 Block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Small HHE use case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">λ' bit</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">λ' bit</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">Use Case s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMC</td>

            <td class="px-3 py-2 border-b border-gray-700">23377</td>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">9.22</td>

            <td class="px-3 py-2 border-b border-gray-700">1 132.4</td>

            <td class="px-3 py-2 border-b border-gray-700">43691</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">27.5</td>

            <td class="px-3 py-2 border-b border-gray-700">3 708.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1 618.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">11441</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">11.7</td>

            <td class="px-3 py-2 border-b border-gray-700">284.2</td>

            <td class="px-3 py-2 border-b border-gray-700">31609</td>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

            <td class="px-3 py-2 border-b border-gray-700">57.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1 666.9</td>

            <td class="px-3 py-2 border-b border-gray-700">922.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">11441</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">7.79</td>

            <td class="px-3 py-2 border-b border-gray-700">207.7</td>

            <td class="px-3 py-2 border-b border-gray-700">31609</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">41.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1 401.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1 037.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">11441</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">11.8</td>

            <td class="px-3 py-2 border-b border-gray-700">276.7</td>

            <td class="px-3 py-2 border-b border-gray-700">31609</td>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

            <td class="px-3 py-2 border-b border-gray-700">57.9</td>

            <td class="px-3 py-2 border-b border-gray-700">1 608.4</td>

            <td class="px-3 py-2 border-b border-gray-700">922.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DASTA-6</td>

            <td class="px-3 py-2 border-b border-gray-700">11441</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">7.87</td>

            <td class="px-3 py-2 border-b border-gray-700">201.7</td>

            <td class="px-3 py-2 border-b border-gray-700">31609</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">41.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1 357.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1 042.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AGRASTA</td>

            <td class="px-3 py-2 border-b border-gray-700">10261</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">2.38</td>

            <td class="px-3 py-2 border-b border-gray-700">38.3</td>

            <td class="px-3 py-2 border-b border-gray-700">32767</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">13.7</td>

            <td class="px-3 py-2 border-b border-gray-700">276.9</td>

            <td class="px-3 py-2 border-b border-gray-700">853.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM</td>

            <td class="px-3 py-2 border-b border-gray-700">14351</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">3.97</td>

            <td class="px-3 py-2 border-b border-gray-700">497.0</td>

            <td class="px-3 py-2 border-b border-gray-700">43691</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">22.0</td>

            <td class="px-3 py-2 border-b border-gray-700">3 392.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1 431.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-12</td>

            <td class="px-3 py-2 border-b border-gray-700">14351</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">4.06</td>

            <td class="px-3 py-2 border-b border-gray-700">498.3</td>

            <td class="px-3 py-2 border-b border-gray-700">43691</td>

            <td class="px-3 py-2 border-b border-gray-700">147</td>

            <td class="px-3 py-2 border-b border-gray-700">22.0</td>

            <td class="px-3 py-2 border-b border-gray-700">6 657.1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 392.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KREYVIUM-13</td>

            <td class="px-3 py-2 border-b border-gray-700">15709</td>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

            <td class="px-3 py-2 border-b border-gray-700">4.38</td>

            <td class="px-3 py-2 border-b border-gray-700">577.1</td>

            <td class="px-3 py-2 border-b border-gray-700">43691</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">21.7</td>

            <td class="px-3 py-2 border-b border-gray-700">3 407.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1 420.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FiLIP-1216</td>

            <td class="px-3 py-2 border-b border-gray-700">5461</td>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

            <td class="px-3 py-2 border-b border-gray-700">131.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1 357.5</td>

            <td class="px-3 py-2 border-b border-gray-700">23311</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">1 010.0</td>

            <td class="px-3 py-2 border-b border-gray-700">17 919.7</td>

            <td class="px-3 py-2 border-b border-gray-700">566.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FiLIP-1280</td>

            <td class="px-3 py-2 border-b border-gray-700">8435</td>

            <td class="px-3 py-2 border-b border-gray-700">119</td>

            <td class="px-3 py-2 border-b border-gray-700">47.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2 197.4</td>

            <td class="px-3 py-2 border-b border-gray-700">24929</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">337.2</td>

            <td class="px-3 py-2 border-b border-gray-700">27 613.9</td>

            <td class="px-3 py-2 border-b border-gray-700">745.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The benchmarks for HElib can be seen in Table 13 where we depict both runtime and remaining noise budget after each step of the HHE use case from Section 5. In the following, we compare the runtime and noise consumption of all  <span class="math">\\mathbb{Z}_2</span>  and  <span class="math">\\mathbb{F}_p</span>  (with  <span class="math">p = 65537</span> ) ciphers, namely in Figure 10 for homomorphically decrypting one block in HElib ( <span class="math">\\mathbb{F}_p</span>  values from Appendix B.2.3), and in Figure 11 for the HHE use case (including HHE decompression) in HElib. Since MASTA and PASTA require to use the  <span class="math">m</span> -th cyclotomic reduction polynomial ( <span class="math">X^{m/2} + 1</span> ), where  <span class="math">m</span>  is a power-of-two, we chose parameters differently compared to Appendix B.2.1: We parameterize  <span class="math">q</span>  to provide enough noise budget to evaluate the benchmark and chose the  <span class="math">m</span>  to be the smallest power-of-two such that the parameters provide  <span class="math">\\geq 128</span>  bits security. Thereby, for a fixed  <span class="math">m</span> , a smaller  <span class="math">q</span>  provides both, larger security and faster performance. Consequently, greater  <span class="math">\\lambda&#x27;</span>  in Table 13 also lead to faster runtimes compared to instantiating the same benchmark with exactly 128 bits of security.</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">Table 13: Runtime and noise budget of the small HHE use case in the HElib library.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ' bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc. Key runtime s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">noise bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decomp. runtime s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">noise bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Small Use Caste runtime s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">noise bit</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 65537 (17 bit):  |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">65536</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">173</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.054</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">410</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">26.0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">74</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.754</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">23</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">0.054</td>

            <td class="px-3 py-2 border-b border-gray-700">502</td>

            <td class="px-3 py-2 border-b border-gray-700">36.7</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">0.740</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">0.116</td>

            <td class="px-3 py-2 border-b border-gray-700">566</td>

            <td class="px-3 py-2 border-b border-gray-700">55.4</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">1.71</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">234</td>

            <td class="px-3 py-2 border-b border-gray-700">0.124</td>

            <td class="px-3 py-2 border-b border-gray-700">632</td>

            <td class="px-3 py-2 border-b border-gray-700">20.9</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">1.74</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 10: Runtime and noise comparison of  <span class="math">\\mathbb{Z}_2</span>  ciphers for homomorphically decrypting 1 Block in HElib (HE security level  <span class="math">\\lambda&#x27;</span> ).</p>

    <p class="text-gray-300">In Table 14 we present the benchmarks for the packed implementation of PASTA, MASTA, and HERA in the HElib library. We give timings for homomorphically decrypting one block and additionally timings for the bigger HHE use case (Section 9.2). We chose parameters in the same fashion as in Appendix B.2.2, i.e., choosing  <span class="math">q</span>  to provide enough noise budget to evaluate the benchmark, and choose the  <span class="math">m</span> -th cyclotomic reduction polynomial, with  <span class="math">m</span>  being a power of two, such that the HE scheme provides  <span class="math">\\geq 128</span>  bits security.</p>

    <p class="text-gray-300">Remark 5. In Table 14, some benchmarks were run with  <span class="math">\\lambda &amp;lt; 128</span>  bits security. The reason for that is that  <span class="math">m = 262144</span>  unfortunately lead to infeasible runtimes. Consequently,  <span class="math">m = 131072</span>  seems to be an upper limit for feasible runtimes in HElib, and use cases requiring larger amounts of noise than can be provided by  <span class="math">m = 131072</span>  and  <span class="math">\\lambda \\geq 128</span>  would inevitably require an efficient bootstrapping operation.</p>

    <p class="text-gray-300">In the following figures we compare the runtime and noise consumption of the ciphers for 3 different prime fields  <span class="math">\\mathbb{F}_p</span> , in Figure 12 for homomorphically decrypting one block in HElib, and in Figure 13 for the HHE use case (including HHE decompression) in HElib.</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 11: Runtime and noise comparison for the small HHE use case in HElib (HE security level  <span class="math">\\lambda^{\\prime}</span> ).</p>

    <p class="text-gray-300">In Table 15 we compare the number of CPU cycles of the encryption circuit of PASTA to the encryption circuit of MASTA and HERA. Since these ciphers generate random matrices and/or round constants independent of the secret key, which can be precomputed before encryption, we additionally give CPU cycles for generating these affine layers and keys schedules and the encryption circuit with precomputed randomness. Table 15 shows that HERA, with its small block size and fixed matrices which can be evaluated purely by additions, is the fastest cipher in plain. However, this advantage comes at the cost of higher number of rounds, which worsenes homomorphic performance. Comparing PASTA to MASTA, one can observe that PASTA-4, due to its small state size, requires the smallest number of cycles to encrypt one block. PASTA-3, on the other hand, due to sampling sequential matrices instead of polynomials  <span class="math">m \\in \\mathbb{Z}_p[X] / (X^t - \\alpha)</span>  (as in MASTA) and requiring twice as many matrices per round, is the slowest cipher to encrypt one block in plain. However, the difference to MASTA-4 is only a factor of 3, which in practice corresponds to latencies in the order of milliseconds.</p>

    <p class="text-gray-300">In Section 6, we describe efficient SIMD algorithms to evaluate PASTA on a packed HE ciphertext. In this section, we want to compare them to a word-sliced implementation where one would encrypt only one field element  <span class="math">\\in \\mathbb{F}_p</span>  into one HE ciphertext. A word-sliced implementation has several disadvantages. First, the homomorphic evaluation time of PASTA would be much slower. In a packed implementation, the S-boxes can be evaluated with  <span class="math">\\mathcal{O}(1)</span>  homomorphic operations, and with  <span class="math">\\mathcal{O}(t)</span>  HE operations in a word-sliced implementation. The word-sliced affine layer requires  <span class="math">\\mathcal{O}(t^2)</span>  HE operations compared to  <span class="math">\\mathcal{O}(t)</span>  operations when using packing. Secondly, the initial setup in the HHE use case requires the transmission of the HE encrypted symmetric key. In a packed implementation, this is always only one HE ciphertext. However, in a word-sliced implementation, one has to transmit  <span class="math">2 \\cdot t</span>  HE ciphertexts, drastically increasing the communication cost of this setup phase. Finally, if the HHE use case leverages packing, one has to reconstruct a packed ciphertext from its word-sliced state using many rotations on the server.</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger and Roman Walch</p>

    <p class="text-gray-300">Table 14:  <span class="math">{\\mathbb{F}}_{p}</span>  benchmarks for the HElib library.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 Block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bigger HHE use case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">λ' bit</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">λ' bit</td>

            <td class="px-3 py-2 border-b border-gray-700">Enc. Key s</td>

            <td class="px-3 py-2 border-b border-gray-700">Decomp. s</td>

            <td class="px-3 py-2 border-b border-gray-700">Use Case s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 65537 (17 bit):  |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">65536</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">184</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.052</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">24.7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">65536</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.064</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">57.6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19.9</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">0.062</td>

            <td class="px-3 py-2 border-b border-gray-700">33.1</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">229</td>

            <td class="px-3 py-2 border-b border-gray-700">0.131</td>

            <td class="px-3 py-2 border-b border-gray-700">157.3</td>

            <td class="px-3 py-2 border-b border-gray-700">45.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">65536</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">0.064</td>

            <td class="px-3 py-2 border-b border-gray-700">27.1</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">199</td>

            <td class="px-3 py-2 border-b border-gray-700">0.135</td>

            <td class="px-3 py-2 border-b border-gray-700">252.8</td>

            <td class="px-3 py-2 border-b border-gray-700">48.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">0.116</td>

            <td class="px-3 py-2 border-b border-gray-700">19.7</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">189</td>

            <td class="px-3 py-2 border-b border-gray-700">0.121</td>

            <td class="px-3 py-2 border-b border-gray-700">315.1</td>

            <td class="px-3 py-2 border-b border-gray-700">48.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 8088322049 (33 bit):  |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">65536</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.057</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">28.7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">131072</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">162</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.166</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">187.7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">60.5</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">196</td>

            <td class="px-3 py-2 border-b border-gray-700">0.165</td>

            <td class="px-3 py-2 border-b border-gray-700">101.3</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">0.166</td>

            <td class="px-3 py-2 border-b border-gray-700">256.2</td>

            <td class="px-3 py-2 border-b border-gray-700">69.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">166</td>

            <td class="px-3 py-2 border-b border-gray-700">0.168</td>

            <td class="px-3 py-2 border-b border-gray-700">82.4</td>

            <td class="px-3 py-2 border-b border-gray-700">131072a</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">0.242</td>

            <td class="px-3 py-2 border-b border-gray-700">427.8</td>

            <td class="px-3 py-2 border-b border-gray-700">80.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

            <td class="px-3 py-2 border-b border-gray-700">0.179</td>

            <td class="px-3 py-2 border-b border-gray-700">29.6</td>

            <td class="px-3 py-2 border-b border-gray-700">131072a</td>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">0.239</td>

            <td class="px-3 py-2 border-b border-gray-700">526.1</td>

            <td class="px-3 py-2 border-b border-gray-700">82.4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 1096486890805657601 (60 bit):  |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">131072</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">162</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.185</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">94.1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">131072a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">97</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.285</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">268.8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">84.4</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">131072</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">0.208</td>

            <td class="px-3 py-2 border-b border-gray-700">144.7</td>

            <td class="px-3 py-2 border-b border-gray-700">131072a</td>

            <td class="px-3 py-2 border-b border-gray-700">83</td>

            <td class="px-3 py-2 border-b border-gray-700">0.289</td>

            <td class="px-3 py-2 border-b border-gray-700">387.4</td>

            <td class="px-3 py-2 border-b border-gray-700">101.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">131072a</td>

            <td class="px-3 py-2 border-b border-gray-700">99</td>

            <td class="px-3 py-2 border-b border-gray-700">0.233</td>

            <td class="px-3 py-2 border-b border-gray-700">122.1</td>

            <td class="px-3 py-2 border-b border-gray-700">131072a</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">0.300</td>

            <td class="px-3 py-2 border-b border-gray-700">635.5</td>

            <td class="px-3 py-2 border-b border-gray-700">111.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">131072a</td>

            <td class="px-3 py-2 border-b border-gray-700">89</td>

            <td class="px-3 py-2 border-b border-gray-700">0.249</td>

            <td class="px-3 py-2 border-b border-gray-700">44.2</td>

            <td class="px-3 py-2 border-b border-gray-700">131072a</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">0.318</td>

            <td class="px-3 py-2 border-b border-gray-700">816.3</td>

            <td class="px-3 py-2 border-b border-gray-700">124.1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a Further increasing  <span class="math">m</span>  for security resulted in infeasibly long runtimes.</p>

    <p class="text-gray-300">However, word-sliced implementations have an advantage as well. They do not require homomorphic rotations (and, therefore, no Galois keys) and one can access each word of the state individually. This is why one can implement the S-boxes from Section 6.4 without requiring masking multiplications. As a consequence, word-sliced implementations have less noise consumption. Splitting the state in our PASTA design is also beneficial for word-sliced implementations, since it reduces the number of homomorphic multiplications from  <span class="math">(2 \\cdot t)^{2}</span>  to  <span class="math">2 \\cdot t^{2}</span>  per affine layer, reducing the runtime.</p>

    <p class="text-gray-300">Since HERA has a small statesize (16) and a larger round number (5), it might be beneficial to have a word-sliced implementation instead of a packed one. Indeed, since the linear layers can purely be implemented by additions, the multiplicative depth gets reduced from 10 ct-ct multiplications and 7 pt-ct multiplications to a depth of 10 and 1 multiplications respectively. Comparing a word-sliced implementation to a packed PASTA-3 implementation, one can observe that PASTA-3 still is preferable. On one hand, PASTA-3 has a smaller depth (4 ct-ct and 6 pt-ct Multiplications) implying less noise consumption and smaller HE parameters. On the other hand, comparing the number of HE operations involved (96 pt-ct and 160 ct-ct multiplications for HERA and 514 pt-ct multiplications, 4 ct-ct multiplications and 98 rotations for PASTA-3) one can see that PASTA-3 requires significantly less of the more expensive rotations and ct-ct multiplications at the cost of more pt-ct multiplications. Thus, if there is a small advantage of HERA when evaluating one block with 16 output words (PASTA-3 has 128), then this advantage is already gone when evaluating two or more blocks. Consequently, we conjecture that PASTA-3 is still more beneficial in most use cases than a wordsliced HERA implementation.</p>

    <p class="text-gray-300">Pasta: A Case for Hybrid Homomorphic Encryption</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 12: Runtime and noise comparison of  <span class="math">\\mathbb{F}_p</span>  ciphers for homomorphically decrypting 1 Block in HElib (HE security level  <span class="math">\\lambda^{\\prime}</span> ). Ciphers marked with a * were evaluated with less than 128 bit HE security.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Figure 13: Runtime and noise comparison for the bigger HHE use case in HElib (HE security level  <span class="math">\\lambda^{\\prime}</span> ). Ciphers marked with a * were evaluated with less than 128 bit HE security.</p>

    <p class="text-gray-300">Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus</p>

    <p class="text-gray-300">Schofnegger and Roman Walch</p>

    <p class="text-gray-300">Table 15: Cycles for encrypting one block in plain, averaged over 1000 executions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Affine Generation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Encrypting</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 65537 (17 bit):  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">17 041 380</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9 196 314</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7 845 066</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">6 535 937</td>

            <td class="px-3 py-2 border-b border-gray-700">2 164 002</td>

            <td class="px-3 py-2 border-b border-gray-700">4 371 935</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">2 105 628</td>

            <td class="px-3 py-2 border-b border-gray-700">752 374</td>

            <td class="px-3 py-2 border-b border-gray-700">1 353 254</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">60 391</td>

            <td class="px-3 py-2 border-b border-gray-700">30 615</td>

            <td class="px-3 py-2 border-b border-gray-700">29 776</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 8088322049 (33 bit):  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">22 429 444</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11 637 800</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10 791 644</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">8 427 384</td>

            <td class="px-3 py-2 border-b border-gray-700">1 975 522</td>

            <td class="px-3 py-2 border-b border-gray-700">6 451 862</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">2 690 636</td>

            <td class="px-3 py-2 border-b border-gray-700">674 201</td>

            <td class="px-3 py-2 border-b border-gray-700">2 016 435</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">54 567</td>

            <td class="px-3 py-2 border-b border-gray-700">17 350</td>

            <td class="px-3 py-2 border-b border-gray-700">37 217</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = 1096486890805657601 (60 bit):  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PASTA-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">31 053 515</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16 067 138</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14 986 377</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-4</td>

            <td class="px-3 py-2 border-b border-gray-700">11 405 862</td>

            <td class="px-3 py-2 border-b border-gray-700">1 968 100</td>

            <td class="px-3 py-2 border-b border-gray-700">9 437 762</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MASTA-5</td>

            <td class="px-3 py-2 border-b border-gray-700">3 542 410</td>

            <td class="px-3 py-2 border-b border-gray-700">669 220</td>

            <td class="px-3 py-2 border-b border-gray-700">2 873 190</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HERA</td>

            <td class="px-3 py-2 border-b border-gray-700">61 360</td>

            <td class="px-3 py-2 border-b border-gray-700">16 873</td>

            <td class="px-3 py-2 border-b border-gray-700">44 487</td>

          </tr>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Pasta: A Case for Hybrid Homomorphic Encryption (2021/731)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/731
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
