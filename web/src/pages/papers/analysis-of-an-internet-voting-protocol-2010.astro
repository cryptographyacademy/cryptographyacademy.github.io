---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/380';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Analysis of an internet voting protocol';
const AUTHORS_HTML = 'Kristian Gjøsteen&lt;sup&gt;∗&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Kristian Gjøsteen&lt;sup&gt;∗&lt;/sup&gt;</p>

    <p class="text-gray-300">July 7, 2010</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">The Norwegian government is planning trials of internet voting in the 2011 local government elections. We describe and analyse the cryptographic protocol that will be used. In our opinion, the protocol is suitable for trials of internet voting, even though it is not perfect.</p>

    <p class="text-gray-300">This paper is a second&lt;sup&gt;1&lt;/sup&gt; step in an ongoing evaluation of the cryptographic protocol.</p>

    <p class="text-gray-300">The Norwegian government is planning trials of internet voting in the 2011 local government elections. One of the key requirements for elections is trust, and for many internet voting deployments this trust has been lacking.</p>

    <p class="text-gray-300">One reason is excessive secrecy. It is a well-established cryptographic and computer security principle that secrecy does not ensure security. Empirically, transparency seems to increase security. We observe that making system architecture, design and even implementation details available for inspection leads to increased security, at least in the long run.</p>

    <p class="text-gray-300">In order to build trust in internet voting, the Norwegian government has decided on nearly complete transparency. Most important documents from the tender process, including most technical details in every submitted proposal, has been made public (see www.evalg.dep.no). Before the 2011 trial, the architecture and even the source code for the deployed system will be made available to the public.</p>

    <p class="text-gray-300">At the heart of any internet voting system is a cryptographic protocol. The security of this protocol is a necessary requirement for trust in the internet voting solution. As part of the initial tender evaluation, a preliminary analysis of the cryptographic voting protocols was carried out. After the winning bid was selected, it was decided to make some modest</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt; kristian.gjosteen@math.ntnu.no, Department of Mathematical Sciences, NTNU.</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt;A previous version of this document, dated March 9, 2010, has been published at www.evalg.dep.no. A version dated December 23, 2009 describing the full protocol and sketches of security proofs has been circulated privately.</p>

    <p class="text-gray-300">changes to the cryptographic protocol, partially to get security proofs. This paper is a more extensive analysis of the resulting protocol.</p>

    <p class="text-gray-300">Internet voting in Norway Norwegian elections are somewhat complicated, but ballots essentially consists of a short sequence of options (a party list followed by selection of candidates, at most about a hundred options in total) chosen from a small set of possible options (at most a few thousand). Note that the entire sequence is required to properly interpret and count the ballot. For parliamentary elections order within the sequence is important, while order does not matter for county and municipal elections. There are no write-ins.</p>

    <p class="text-gray-300">There are significant functional constraints on any real-world voting system. The voter should not have to interact with the voting system more than once to submit a ballot. Most ballots will be submitted during peak hours, and the submitted ballots must be processed quickly. Once the ballot box closes, the result must be available as soon as possible.</p>

    <p class="text-gray-300">Since cost does matter and secure computing hardware is expensive, any election infrastructure will have quite limited computational resources available for the protocol execution.</p>

    <p class="text-gray-300">We also get functional constraints from security considerations. In practice, the two most significant security problems with internet voting in Norway will be compromised computers and coercion.</p>

    <p class="text-gray-300">Since a significant fraction of home computers are compromised, the protocol must allow voters to detect ballot tampering without relying on computers. This is complicated by the fact that voters are unable to do even the simplest cryptographic processing without computer assistance.</p>

    <p class="text-gray-300">When voting from home, no amount of cryptography can protect the voter from coercion. To defend against coercion, we mandate that the system must allow voters to vote multiple times, so-called revoting, counting only the final ballot. Voters may also vote once on paper and this vote should be counted instead of any electronic ballot, no matter when submitted. The internet voting system must essentially allow election administrators to cancel votes.</p>

    <p class="text-gray-300">Defending against coercion by election insiders is very difficult. Before anyone can cast their vote, they must somehow authenticate to the system. For most plausible authentication systems, anyone with access to the authentication system will be able to detect electronic revoting.</p>

    <p class="text-gray-300">In the Norwegian electoral system, for any ballot there will be a large number of valid ballots that are different, but have essentially the same effect on the final election result. Therefore, any coercer with access to the counted ballots (electronic or on paper) can tell his victim to submit an unlikely ballot with the desired effect, then verify that his victim did not revote by observing if the unlikely ballot is present among the counted ballots.</p>

    <p class="text-gray-300">We should also note that traditionally, the electoral roll is considered sensitive in Norway. This means that very little information about the count should be published, and that universal verifiability will be impractical.</p>

    <p class="text-gray-300">Related work We can roughly divide the literature into protocols suitable for voting booths [5, 6, 19, 20], and protocols suitable for remote internet voting [7, 8, 14, 16, 18], although protocols often share certain building blocks. One difference is that protocols for voting booths should be both coercion-resistant and voter verifiable, while realistic attack models (the attacker may know more than the voter knows) for remote internet voting probably make it impossible to achieve both true voter verifiability and coercion-resistance.</p>

    <p class="text-gray-300">For internet voting protocols, we can again roughly divide the literature into two main strands distinguished by the counting method. One is based on homomorphic tallying. Ballots are encrypted using a homomorphic cryptosystem, the product of all the ciphertexts is decrypted (usually using some form of threshold decryption) to reveal the sum of the ballots. For simple elections, this can be quite efficient, but for the Norwegian elections, this quickly becomes unwieldy.</p>

    <p class="text-gray-300">The other strand has its origins in mix nets [3]. Encrypted ballots are sent through a mix net. The mix net ensures that the mix net output cannot be correlated with the mix net input. There are many types of mixes, based on nested encryption [3] or reencryption, verifiable shuffles [12, 18] or probabilistic verification [1, 14], etc. These can be quite efficient, even for the Norwegian elections.</p>

    <p class="text-gray-300">Much of the literature ignores the fact that a voter simply will not do any computations. Instead, the voter delegates computations to a computer. Unfortunately, a voter's computer can be compromised, and once compromised may modify the ballot before submission.</p>

    <p class="text-gray-300">One approach is so-called preencrypted ballots and receipt codes [4, 2], where the voter well in advance of the election receives a table with candidate names, identification numbers and receipt codes. The voter inputs a candidate identification number to vote and receives a response. The voter can verify that his vote was correctly received by checking the response against the printed receipt codes.</p>

    <p class="text-gray-300">Note that unless such systems are carefully designed, privacy will be lost. Clearly, general multiparty computation techniques can be used to divide the processing among several computing nodes (presumably used by [4]). One approach for securely generating the receipt codes is to use a proxy oblivious transfer scheme [13]. A ballot box has a database of receipt codes and the voter's computer obliviously transfers the correct one to a messenger, who then sends the receipt to the voter. This approach seems to be very expensive for Norwegian elections.</p>

    <p class="text-gray-300">Another useful tool is the ability for out-of-band communication with voters [17]. This allows us to give the voter information directly, information that his computer should not know and not be able to tamper with. The scheme in [13] sends receipt codes to the voter out-of-band. This helps ensure that a voter is notified whenever a vote is recorded, preventing a compromised computer from undetectably submitting ballots on the voter's behalf.</p>

    <p class="text-gray-300">Our contribution The cryptographic protocol to be used in Norway is designed by Scytl, a Spanish electronic voting company. It is mostly a fairly standard internet voting system. Essentially, a voter uses his computers to submit a ballot to an election infrastructure. To defend against coercion, a voter is allowed to submit multiple ballots, where the final submission will be counted.</p>

    <p class="text-gray-300">The system works roughly as follows. The voter gives his ballot to a computer, which encrypts the ballot and submits it to a ballot box. Once the ballot box closes, the submitted ciphertexts are decrypted in some decryption service, based on a reencrypting mix net. An auditor supervises the entire process.</p>

    <p class="text-gray-300">The part of the system not usually found in other deployed internet voting systems is detecting when a compromised computer has altered the ballot. The ballot box and a receipt generator cooperate to compute a sequence of receipt codes for the submitted ballot. These codes are sent to the voter through an independent channel (most likely SMS messages to mobile phones). The voter verifies the receipt codes against a list of precomputed receipt codes printed on his voting card.</p>

    <p class="text-gray-300">Scytl originally proposed to use a pseudo-random function family to compute the receipt codes. While this would most likely be secure, it was difficult to prove anything about the proposal. It was therefore decided to use a slightly different construction. We use the fact that exponentiation is in some sense a pseudo-random function [9, 11], and since ElGamal is homomorphic, exponentiation can be efficiently done &quot;inside&quot; the ciphertext. This mechanism is the only significant cryptographic novelty described in this paper.</p>

    <p class="text-gray-300">Overview of the paper We describe the security goals for the protocol in Section 2. We discuss what capabilities an adversary will have what the protocol is supposed to achieve.</p>

    <p class="text-gray-300">A simplified protocol is specified and analysed in Section 3. We do this to focus on the only novel cryptographic construction in this scheme, which is how the receipt codes are computed.</p>

    <p class="text-gray-300">We describe the full protocol in Sect. 4 and analyse its security in Sect. 5.</p>

    <p class="text-gray-300">To define security for a protocol, we must define what kind of attackers we face and how we will allow them to influence the election.</p>

    <p class="text-gray-300">We stress that we do not consider coercion in this analysis, beyond the brief discussion in the introduction.</p>

    <p class="text-gray-300">The attacker We start with the standard premise that the attacker controls the network. What remains to decide is which players can be corrupted. Our players include a set of voters, a set of computers and four infrastructure players, the ballot box, a receipt generator, a decryption service, an auditor and a set of electoral board members.</p>

    <p class="text-gray-300">Remark 1. The electoral board members will only appear in subprotocols that we do not analyse. Therefore, we ignore the electoral board in this discussion.</p>

    <p class="text-gray-300">Any external attacker will clearly be able to compromise a number of voters as well as a larger number of computers. To simplify discussions, we shall assume that corrupt voters only use corrupt computers. Honest voters may use honest computers, corrupt computers or both.</p>

    <p class="text-gray-300">Since the infrastructure is divided into a small number of separate players, organizational and non-cryptographic technical measures may make it reasonable to assume that an inside attacker can compromise at most one infrastructure player.</p>

    <p class="text-gray-300">Remark 2. Suppose we have some protocol satisfying the following: (i) the voter submits his vote to the computer, the computer submits an encrypted ballot to the infrastructure, and the infrastructure players cooperate to generate a receipt code and send it directly to the voter; (ii) a single infrastructure player X is responsible for sending the receipt code to the voter.</p>

    <p class="text-gray-300">Consider the following attack where X and the voter's computer are corrupt. The computer submits a forged ballot to the infrastructure, leading to the computation of a receipt code. This code is discarded by X. A forged ballot has been submitted, and the voter has noticed nothing.</p>

    <p class="text-gray-300">The conclusion is that for protocols like ours, it is impossible to protect the voter against a corrupt computer cooperating with a corrupt receipt generator. For practical reasons, our protocol will be of this form. We therefore arrive at the following static corruption model:</p>

    <p class="text-gray-300">The attacker may corrupt either (i) the ballot box and any subset of voters and computers, or (ii) any single infrastructure player.</p>

    <p class="text-gray-300">For the simplified protocol, we use a weaker attack model:</p>

    <p class="text-gray-300">The attacker may corrupt either (i) any subset of voters and computers, or (ii) passively any one infrastructure player.</p>

    <p class="text-gray-300">The attacker's influence We shall allow corrupt voters to submit spoilt ballots.</p>

    <p class="text-gray-300">Since an attacker controls the network between a voter's computer and the election infrastructure, he will certainly be able to delay or block the submission of ballots. Obviously, any corrupt infrastructure player can halt and thereby stop the election. They can usually cause more suspicious integrity failures, again stopping the election.</p>

    <p class="text-gray-300">For usability reasons, the number of receipt codes must be equal to the number of options chosen. Therefore, if the receipt generator is corrupt, it is unavoidable that the number of options on a ballot leaks.</p>

    <p class="text-gray-300">If the voter's computer is compromised, the attacker will see the ballot. The attacker may also modify the ballot, but in this case, the voter should be able to notice with high probability.</p>

    <p class="text-gray-300">    <img src="_page_5_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: Communication between players. The infrastructure players are inside the box. The auditor A is not part of the simplified protocol.</p>

    <p class="text-gray-300">We arrive at the following security goal:</p>

    <p class="text-gray-300">At most one ballot per voter should be counted.</p>

    <p class="text-gray-300">Any vote submitted through an honest computer should remain confidential (up to information leaked through the receipt codes).</p>

    <p class="text-gray-300">If no infrastructure player is corrupt, the auditor will not fail the election.</p>

    <p class="text-gray-300">Suppose the auditor does not fail the election. If an honest voter has accepted a ballot as cast, the ballot should be counted unless the voter subsequently submitted another ballot (but he need not have accepted it as cast) or complained about a forgery.</p>

    <p class="text-gray-300">We describe the simplified protocol. The players in the protocol are the voter V , the voter's computer P, the ballot box B the receipt generator R, and the decryption service D. The auditor is not part of the simplified protocol. The players communicate via secure, authenticated channels, as described in Fig. 1. We note that in this simplified model, the ballot box knows which voter is communicating with which computer.</p>

    <p class="text-gray-300">The voter chooses as its ballot a sequence of options (v1, . . . , vk) from a set of options O = {1, 2, . . . }, the computer pads the ballots with zeros to a fixed length kmax , encrypts it with the election encryption key and submits the encrypted ballot to a ballot box. The ballot box, in cooperation with the receipt generator computes a sequence of receipt codes from a set C that are sent directly to the voter. The voter has a correspondence between options and receipt codes. If the receipt codes received match the options selected, the voter accepts, otherwise he knows something went wrong.</p>

    <p class="text-gray-300">When the ballot box closes, the ballot box submits the encrypted ballots to the decryption service, which decrypts the ballots and publishes the result.</p>

    <p class="text-gray-300"><strong>Prerequisites</strong> The system uses a finite cyclic group G of prime order q generated by g. We also have a pseudo-random function family F from G to C.</p>

    <p class="text-gray-300">An injective encoding function  <span class="math">f: \\mathcal{O} \\to G</span>  is chosen (the choice is not arbitrary and has implications for security, see Sect. 3.3 for details). We then extend the function by defining f(0) to be the identity element in G. Corrupt voters will be able to submit spoilt ballots, so we have a set  <span class="math">\\mathcal{O}&#x27; \\supseteq \\mathcal{O}</span>  and shall sometimes consider f as a function from  <span class="math">\\mathcal{O}&#x27;</span>  to G.</p>

    <p class="text-gray-300"><strong>Key generation</strong> For the simplified protocol, we shall assume that all key generation is done by a trusted third party.</p>

    <p class="text-gray-300">Before the election, three secret parameters  <span class="math">a_1</span> ,  <span class="math">a_2</span>  and  <span class="math">a_3</span>  are generated such that  <span class="math">a_1 + a_2 \\equiv a_3 \\pmod{q}</span> . The ballot box gets  <span class="math">a_2</span> , the receipt code generator gets  <span class="math">a_3</span>  and the decryption service gets  <span class="math">a_1</span> . Three public parameters for the election,  <span class="math">y_1</span> ,  <span class="math">y_2</span>  and  <span class="math">y_3</span> , are computed as  <span class="math">y_1 = g^{a_1}</span> ,  <span class="math">y_2 = g^{a_2}</span>  and  <span class="math">y_3 = g^{a_3}</span> .</p>

    <p class="text-gray-300">For every voter, s is sampled from  <span class="math">\\{0, 1, \\ldots, q-1\\}</span> , and d from F. The composition of f, the exponentiation map  <span class="math">x \\mapsto x^s</span>  and d gives a function  <span class="math">r: \\mathcal{O} \\to \\mathcal{C}</span>  for each user,  <span class="math">r(v) = d((f(v))^s)</span> . Before the election, the set  <span class="math">\\{(v, r(v)) \\mid v \\in \\mathcal{O}\\}</span>  is computed and given to V.</p>

    <p class="text-gray-300"><strong>Vote submission</strong> When the voter V wants to submit the ballot  <span class="math">(v_1, \\ldots, v_k)</span> , the protocol proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The voter sends  <span class="math">(v_1, \\ldots, v_k)</span>  to his computer P. The computer sets  <span class="math">v_i = 0</span>  for  <span class="math">i = k+1, \\ldots, k_{max}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For  <span class="math">1 \\le i \\le k_{max}</span> , the computer samples  <span class="math">t_i</span>  from  <span class="math">\\{0, 1, \\ldots, q-1\\}</span> , computes  <span class="math">(x_i, w_i) = (g^{t_i}, y_1^{t_i} f(v_i))</span>  and sends  <span class="math">((x_1, w_1), \\ldots, (x_{k_{max}}, w_{k_{max}})</span>  to the ballot box B.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The ballot box computes  <span class="math">\\check{x}_i = x_i^s</span>  and  <span class="math">\\check{w}_i = w_i^s \\check{x}_i^{a_2}</span> . The pairs  <span class="math">((\\check{x}_1, \\check{w}_1), \\dots, (\\check{x}_{k_{max}}, \\check{w}_{k_{max}}))</span>  and the voter's name is sent to R.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The receipt generator computes  <span class="math">\\check{r}_i = d(\\check{w}_i\\check{x}_i^{-a_3})</span>  and sends  <span class="math">(\\check{r}_1, \\ldots, \\check{r}_k)</span>  to the voter. (Note that k can be deduced from the number of non-identity decryptions.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The voter verifies that every pair  <span class="math">(v_i, \\check{r}_i)</span>  is in the set of receipt codes received before the election, and if so consideres the ballot cast.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The protocol is summarized in Fig. 2.</p>

    <p class="text-gray-300">The voter may submit multiple ballots electronically, and the final submission supercedes any previous submissions.</p>

    <p class="text-gray-300">Counting When the ballot box closes, superceded ballots are discarded, only the final submitted ballot should count. The ballot box sends the remaining encrypted ballots to the decryption service, in random order. The decryption service decrypts all the ciphertexts  <span class="math">(\\mu_i = w_i x_i^{-a_1})</span>  and outputs the resulting ballots in random order.</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Protocol for submission of one option and generation of one receipt code.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">3.1 Completeness</h3>

    <p class="text-gray-300">The protocol is <em>complete</em> if, when every participant is honest, the submitted ballots are eventually correctly decrypted, and the receipt codes sent to the voter matches the expected values.</p>

    <p class="text-gray-300">Completeness is obvious, except for the receipt code received by the voter. We only need to argue that  <span class="math">(v, \\check{r})</span>  will always be in the computed set of receipt codes, that is, that  <span class="math">\\check{r} = r(v)</span> . We compute</p>

    <p class="text-gray-300"><span class="math">$\\check{w}\\check{x}^{-a_3} = w^s\\check{x}^{a_2}\\check{x}^{-a_3} = w^s\\check{x}^{-a_1} = w^s(x^s)^{-a_1} = (wx^{-a_1})^s = (f(v))^s.</span>$</p>

    <p class="text-gray-300">Completeness follows.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">3.2 Security</h4>

    <p class="text-gray-300">This section argues informally about the security of the simplified protocol. We consider the following corruption model: (a) The voter and his computer are corrupted; (b) the voter's computer is corrupted; and (c) one of the infrastructure players is passively corrupt (or honest-but-curious: the adversary follows the protocol, but tries to deduce information about voters' ballots). We prove the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If a corrupt computer modifies a ballot, the voter will most likely notice.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>No honest-but-curious infrastructure player will learn any non-trivial information about the ballots.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We see that for the given corruption models, our security goal follows from these properties.</p>

    <p class="text-gray-300">(a) By the assumption of authenticated channels, the ballot box can trivially ensure that at most one ballot is counted per voter. Submitting malformed ciphertexts will at most invalidate the voter's ballot, which we expressly permit.</p>

    <p class="text-gray-300">(b) Suppose the computer submits  <span class="math">(v&#x27;_1, \\ldots, v&#x27;_{k&#x27;})</span>  instead of  <span class="math">(v_1, \\ldots, v_k)</span> .</p>

    <p class="text-gray-300">We know that the exponentiation map is a permutation on G and that f is an injection. Since d will look like a random function, f composed with a permutation composed with a random-looking function will again look like a random function from  <span class="math">\\mathcal{O}&#x27;</span>  to  <span class="math">\\mathcal{C}</span> .</p>

    <p class="text-gray-300">Any function from  <span class="math">\\mathcal{O}&#x27;</span>  to the set of receipt codes  <span class="math">\\mathcal{C}</span>  defines a partition of  <span class="math">\\mathcal{O}&#x27;</span> . A partition defines an equivalence relation. The uniform distribution on the set of functions from  <span class="math">\\mathcal{O}&#x27;</span>  to the receipt code set therefore induces a probability distribution on the set of equivalence relations on  <span class="math">\\mathcal{O}&#x27;</span> .</p>

    <p class="text-gray-300">We extend an equivalence relation  <span class="math">\\sim</span>  on  <span class="math">\\mathcal{O}&#x27;</span>  in the obvious way to strings of options, i.e.  <span class="math">(v_1, \\ldots, v_k) \\sim (v&#x27;_1, \\ldots, v&#x27;_{k&#x27;})</span>  if and only if k = k' and  <span class="math">v_i \\sim v&#x27;_i</span>  for  <span class="math">i = 1, \\ldots, k</span> .</p>

    <p class="text-gray-300">The voter will accept the manipulation if and only if  <span class="math">(v&#x27;_1, \\ldots, v&#x27;_{k&#x27;}) \\sim (v_1, \\ldots, v_k)</span> . As long as the set  <span class="math">\\mathcal{C}</span>  is sufficiently large, the probability of this happening will be small.</p>

    <p class="text-gray-300">(c) We consider the three infrastructure players in turn. Since they are honest-but-curious, we only need to simulate the input they would normally see, we do not need to model interaction with other parts of the system.</p>

    <p class="text-gray-300"><strong>The ballot box</strong> Suppose we have an honest-but-curious ballot box  <span class="math">B^*</span>  that after the election is over looks at the ciphertexts and outputs some information about the ballots submitted.</p>

    <p class="text-gray-300">Given a tuple  <span class="math">(g, y_1, u_1, u_2)</span>  of elements from G, we shall employ  <span class="math">B^*</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate  <span class="math">a_2</span>  and compute  <span class="math">y_3 = y_1 g^{a_2}</span> . Send  <span class="math">a_2</span>  to  <span class="math">B^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Instead of encrypting the encoded option  <span class="math">f(v_i)</span>  as usual, we compute the encryption as  <span class="math">(x_i, w_i) = (g^{t_i} u_1^{t_i&#x27;}, y_1^{t_i} u_2^{t_i&#x27;} f(v_i))</span> , for some random  <span class="math">t_i</span>  and  <span class="math">t_i&#x27;</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If  <span class="math">(g, y_1, u_1, u_2)</span>  is a Diffie-Hellman tuple, this will simulate the ballot box input perfectly. If  <span class="math">(g, y_1, u_1, u_2)</span>  is not a Diffie-Hellman tuple, the ballot box input will contain no information at all about the ballots.</p>

    <p class="text-gray-300">The conclusion is that if  <span class="math">B^*</span>  can extract some information about the ballots, we have a distinguisher for the Decision Diffie-Hellman problem.</p>

    <p class="text-gray-300">The receipt generator We shall now assume that the family of functions from  <span class="math">\\mathcal{O}</span>  to G given by  <span class="math">v \\mapsto f(v)^s</span>  is a pseudo-random function family, that is, functions sampled uniformly at random from the family are indistinguishable from functions sampled uniformly at random from the set of all possible functions from  <span class="math">\\mathcal{O}</span>  to G (subject to  <span class="math">1 \\mapsto 1</span> ). We shall discuss this assumption and the choice of function  <span class="math">f: \\mathcal{O} \\to G</span> , as well as an alternative assumption, in Sect. 3.3.</p>

    <p class="text-gray-300">Suppose we have an honest-but-curious receipt generator  <span class="math">R^*</span>  that after the election is over outputs some non-trivial information about the ballots submitted.</p>

    <p class="text-gray-300">Given an encoding function f, a function  <span class="math">\\rho: \\mathcal{O} \\to G</span>  and  <span class="math">j, 1 \\leq j \\leq N</span> , we use  <span class="math">R^*</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the voters  <span class="math">V_1, V_2, \\dots V_{j-1}</span> , we choose random functions  <span class="math">\\rho_l : \\mathcal{O} \\to G</span> ,  <span class="math">1 \\le l &lt; j</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate keys as usual for  <span class="math">V_{j+1}, \\ldots, V_N</span>  and use the functions  <span class="math">\\rho_l : v \\mapsto f(v)^{s_l}, j &lt; l \\leq N</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For  <span class="math">V_j</span> , we use the given function  <span class="math">\\rho</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every ballot  <span class="math">(v_1, \\ldots, v_{k_{max}})</span>  from a voter  <span class="math">V_l</span>  with function  <span class="math">\\rho_l</span> , we compute  <span class="math">(\\check{x}_i, \\check{w}_i)</span>  as  <span class="math">(g^{t&#x27;_i}, y_3^{t&#x27;_i} \\rho_l(v_i))</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If our function  <span class="math">\\rho</span>  comes from the family and j=1, this will simulate the receipt generator input perfectly. If our function  <span class="math">\\rho</span>  is a random function and j=N, the receipt generator input will contain no non-trivial information about the ballots submitted.</p>

    <p class="text-gray-300">After a standard hybrid argument, the conclusion is that if  <span class="math">R^*</span>  can extract some non-trivial information about the ballots, we have a distinguisher for the function family.</p>

    <p class="text-gray-300">The decryption service Since the decryption service sees the encrypted ballots in random order, it does not know which ballot originated with which voter, hence can extract no information about which ballot belongs to which voter.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">3.3 Encoding Options as Group Elements</h3>

    <p class="text-gray-300">The Decision Diffie-Hellman problem can be formulated as follows:</p>

    <pre><code class="language-text">Given (g_1, g_2) \\in G \\times G (where at least g_2 is sampled at random), decide if (x_1, x_2) \\in G \\times G was sampled uniformly from the powers of (g_1, g_2) (i.e. (x_1, x_2) = (g_1^s, g_2^s) for some s), or uniformly from G \\times G.
</code></pre>

    <p class="text-gray-300">It is well-known (e.g. [9, 11]) that this is equivalent to the following problem:</p>

    <pre><code class="language-text">Given (g_1, \\ldots, g_n) \\in G^n (where at least g_2, \\ldots, g_n are sampled at random), decide if (x_1, \\ldots, x_n) \\in G^n was sampled uniformly from the powers of (g_1, \\ldots, g_n) (i.e. (x_1, \\ldots, x_n) = (g_1^s, \\ldots, g_n^s) for some s), or uniformly from G^n.
</code></pre>

    <p class="text-gray-300">Therefore, if we choose a random injection  <span class="math">\\mathcal{O} \\to G</span>  as our encoding function f, the assumption used to prove privacy against the receipt generator in the previous section follows easily from Decision Diffie-Hellman.</p>

    <p class="text-gray-300">However, choosing a different encoding function will allow a significant (by a factor of 20-100) speedup of vote decryption. Let p be a randomly chosen safe prime, let G be the quadratic residues in  <span class="math">\\mathbb{F}_p^*</span>  and let L be a set of small primes whose images  <span class="math">\\{\\ell_1, \\ell_2, \\ldots, \\ell_n\\}</span>  in  <span class="math">\\mathbb{F}_p^*</span>  are quadratic residues. Consider the following problem:</p>

    <p class="text-gray-300">Given  <span class="math">(\\ell_1, \\ldots, \\ell_n) \\in G^n</span>  as above, decide if  <span class="math">(x_1, \\ldots, x_n) \\in G^n</span>  was sampled uniformly from the powers of  <span class="math">(\\ell_1, \\ldots, \\ell_n)</span>  (i.e.  <span class="math">(x_1, \\ldots, x_n) = (\\ell_1^s, \\ldots, \\ell_n^s)</span>  for some s), or uniformly from  <span class="math">G^n</span> .</p>

    <p class="text-gray-300">Now, if f is any injection from  <span class="math">\\mathcal{O}</span>  into  <span class="math">\\{\\ell_1, \\ldots, \\ell_n\\}</span> , the assumption used to prove privacy against the receipt generator in the previous section holds if the above problem is hard.</p>

    <p class="text-gray-300">While this assumption is very similar to Decision Diffie-Hellman, it seems unlikely that it will be possible to prove that it follows from Decision Diffie-Hellman.</p>

    <p class="text-gray-300">We currently believe that the best way to solve Decision Diffie-Hellman is to compute one of the corresponding discrete logarithms. It is known [15] that solving the static Diffie-Hellman problem with a fairly large number of oracle queries is easier than solving the discrete logarithm problem.</p>

    <p class="text-gray-300">For fairly large n, a static Diffie-Hellman solver could be applied to decide the above problem. This would be faster than the fastest known solver for the Decision Diffie-Hellman problem in the same group. However, for our application, n will always be small, hence the static Diffie-Hellman solver can not be applied. It seems as if the best approach to solving the above decision problem is computing discrete logarithms.</p>

    <p class="text-gray-300">Remark 3. It is important that the prime p is chosen verifiably at random. If it is not, it will probably be possible to choose the safe prime together with a relation among the small primes. Given such a relation, the decision problem will be easy.</p>

    <p class="text-gray-300"><strong>Other approaches</strong> While the assumption discussed above is sufficient for security, it is not necessary. A weaker, sufficient condition would be if, given a permutation of a subset of  <span class="math">\\{\\ell_1^s, \\ldots, \\ell_n^s\\}</span>  for some random s, it was hard to deduce any information about which primes were involved and what the permutation was.</p>

    <p class="text-gray-300">The simplest case, which fortunately corresponds to the most common voting pattern, is that the receipt generator sees one group element, and must decide which prime was used to generate it. For reasons explained in Sect. 4, the receipt generator is also given a random generator g and  <span class="math">g^s</span> .</p>

    <p class="text-gray-300">We do the calculations for the case when there are only two primes to decide between, say  <span class="math">\\ell_0</span>  and  <span class="math">\\ell_1</span> . Let  <span class="math">R^*</span>  be an algorithm that takes as input five group elements and outputs 0 or 1. Define</p>

    <p class="text-gray-300"><span class="math">$p_{00} = \\Pr[R^*(\\ell_0, \\ell_1, g, g^s, \\ell_0^s) = 0],</span>$</p>

    <p class="text-gray-300"><span class="math">$p_{11} = \\Pr[R^*(\\ell_0, \\ell_1, g, g^s, \\ell_1^s) = 1], \\text{ and}</span>$</p>

    <p class="text-gray-300"><span class="math">$p_{i,\\text{rnd}} = \\Pr[R^*(\\ell_0, \\ell_1, g, g^s, g^t) = i], i \\in \\{0, 1\\},</span>$</p>

    <p class="text-gray-300">where s and t are sampled uniformly at random from  <span class="math">\\{0, 1, ..., q - 1\\}</span> . Note that  <span class="math">p_{0,\\text{rnd}} = 1 - p_{1,\\text{rnd}}</span> , since the input distribution to  <span class="math">R^*</span>  is identical for both probabilities.</p>

    <p class="text-gray-300">We may define the advantage of  <span class="math">R^*</span>  as  <span class="math">|p_{00} + p_{11} - 1|</span> . Observe that if  <span class="math">|p_{00} - p_{0,\\text{rnd}}|</span>  or  <span class="math">|p_{11} - p_{1,\\text{rnd}}|</span>  are large, we have a trivial solver for Decision Diffie-Hellman with the generator fixed to either  <span class="math">\\ell_0</span>  or  <span class="math">\\ell_1</span> .</p>

    <p class="text-gray-300">We may assume that p&lt;sup&gt;00&lt;/sup&gt; +p&lt;sup&gt;11&lt;/sup&gt; −1 = 2 &gt; 0. Then either p&lt;sup&gt;00&lt;/sup&gt; ≥ 1/2 + or p&lt;sup&gt;11&lt;/sup&gt; ≥ 1/2 +, so assume the former. Furthermore, let p&lt;sup&gt;00&lt;/sup&gt; − p0,rnd = µ. If |µ| ≥ , we have an adversary against Decision Diffie-Hellman with the generator fixed to \`0, so assume |µ| &lt; . Then</p>

    <p class="text-gray-300"><span class="math">$p_{11} - p_{1,\\text{rnd}} = 1 + 2\\epsilon - p_{00} - (1 - p_{0,\\text{rnd}}) = 2\\epsilon - \\mu \\ge \\epsilon,</span>$</p>

    <p class="text-gray-300">which means that we must have an adversary with advantage against Decision Diffie-Hellman with the generator fixed to either <code>&lt;sup&gt;0&lt;/sup&gt; or </code>1.</p>

    <p class="text-gray-300">The same arguments applies to an R&lt;sup&gt;∗&lt;/sup&gt; that can decide between multiple primes, he must lead to a successful adversary against Decision Diffie-Hellman with the generator fixed to one of the primes.</p>

    <p class="text-gray-300">Unfortunately, the above argument breaks down if R&lt;sup&gt;∗&lt;/sup&gt; is allowed to see multiple primes raised to the same power, that is, given {\` s i | i ∈ I} for some small index set I, decide what I is. It is not unlikely that a careful analysis could reduce this problem to our alternative DDH problem (for a smaller number of primes), but such a result is of questionable value.</p>

    <p class="text-gray-300">In this section, we shall describe the full protocol and the measures required to defend against active attacks by infrastructure players. The basic idea is that everyone should prove that they have faithfully executed the simplified protocol. The computer proves knowledge of ciphertext content and the ballot box proves the correctness of its computations. In addition, the voter has the computer sign the submitted ballot on his behalf, and the receipt generator signs a hash of the ballot. Finally, the electoral board is responsible for key generation.</p>

    <p class="text-gray-300">Technically, we shall describe a protocol employing several subprotocols. To simplify analysis, we replace the subprotocols by so-called ideal functionalities, trusted third parties that every player can communicate securely with. These ideal functionalities are discussed in Sect. 4.1.</p>

    <p class="text-gray-300">We briefly discuss each player and give an intuitive discussion of the protocol elements and their purpose. The protocol messages are summarized in Fig. 3.</p>

    <p class="text-gray-300">The voter The voter tells the computer what ballot to submit and allows the computer to sign the encrypted ballot on his behalf. The voter then waits for an acceptance message from the computer, and for receipt codes to arrive out-of-band. The receipt codes are verified.</p>

    <p class="text-gray-300">Intuitively, the signature prevents a corrupt ballot box from inserting forged ballots, or falsely claiming that a given ballot belongs to someone else. With signed ballots, it is also easy for the ballot box and the auditor to ensure that at most one ballot is counted per voter.</p>

    <p class="text-gray-300">The computer The computer encrypts the voter's ballot and signs the ciphertext on the voter's behalf. The computer should also prove that it knows the content of the ciphertexts before submission. The computer then waits for the receipt generator's signature on a hash of the encrypted ballot, before sending an acceptance message to the voter.</p>

    <p class="text-gray-300">Intuitively, the receipt generator's signature ensures that the receipt generator has seen the encrypted ballot. The proof of knowledge is to prevent a corrupt ballot box from using a corrupt voter to submit an honest voter's ciphertexts as its own, then learn the ballot contents from the receipt codes.</p>

    <p class="text-gray-300">Proof-theoretically, we will need to extract the vote from the ballot. Therefore, in theory, the proof of knowledge should have a proper online extractor [10], but morally a more efficient non-interactive Schnorr proof will do, even if we do not have a knowledge extractor that works for parallel composition.</p>

    <p class="text-gray-300">The ballot box The ballot box receives signed, encrypted ballots from the voter's computer. It computes receipt code ciphertexts and proves to the receipt generator that its computations are correct. When the receipt generator replies with a signature, it passes this signature on to the voter's computer. The ballot box numbers received ballots sequentially when talking to the receipt generator.</p>

    <p class="text-gray-300">In order to verify correct computation and that this was a real ballot, the receipt generator must see the entire encrypted ballot, including the voter's signature and the computer's proofs of knowledge.</p>

    <p class="text-gray-300">When the ballot box closes, it selects the encrypted ballots that should be decrypted, sends them to the decryption service and reveals the entire content of the ballot box to the auditor.</p>

    <p class="text-gray-300">Intuitively, the ballot box proofs are there to prevent a corrupt ballot box cooperating with a corrupt computer from forging ciphertexts with correct receipt codes, or a corrupt ballot box cooperating with a corrupt voter from abusing the receipt generator's decryption capability. The sequence numbers are there so that the receipt generator and the ballot box explicitly agree on the order of submitted ballots.</p>

    <p class="text-gray-300">Receipt generator The receipt generator verifies the voter's signature and every proof, then generates the receipt codes and sends them directly to the voter. Also, the receipt generator signs a hash of the ballot and returns the signature to the ballot box. Without the signature, the voter's computer will not inform the user that the ballot has been accepted.</p>

    <p class="text-gray-300">Remark 4. If the ballot box discards a ballot, the hash and the signature would allow a voter to prove, in cooperation with an honest auditor, that his ballot was discarded. There is no need for this functionality in our corruption models, but we believe there are corruption models where this might be useful. We have not yet studied them.</p>

    <p class="text-gray-300">When the ballot box closes, the receipt generator gives the auditor a list of hashes of ballots with corresponding sequence numbers seen by the receipt generator.</p>

    <p class="text-gray-300">    <img src="_page_13_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: Protocol messages involved in submitting a ballot and receiving receipts (above) and counting (below). The players are: the voter V , the computer P, the ballot box B, the receipt generator R, the decryption service D and the auditor A.</p>

    <p class="text-gray-300">Decryption service The decryption service decrypts the incoming ciphertexts, shuffles the decryptions before output, then proves to the auditor that the input ciphertexts contain a shuffle of the decryptions. This is done using a mix net and standard Schnorr proofs of decryption. The mix net is similar to randomized partial checking [14] or &quot;almost entirely correct mixing&quot; [1].</p>

    <p class="text-gray-300">Auditor The auditor receives the entire content of the ballot box and a list of hashes of encrypted ballots seen by the receipt generator. The auditor verifies the content of the ballot box (signatures and proofs), that no ballots have been inserted or lost compared to the receipt generator list and computes on its own a list of encrypted ballots that should be counted. The auditor compares this list to the ciphertexts input to the decryption service, then verifies the proofs offered by the decryption service.</p>

    <p class="text-gray-300">Electoral board The electoral board is responsible for key generation, which must be done before ballot submission begins. The subprotocol used for key generation is not analysed in this document.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">4.1 Prerequisites</h3>

    <p class="text-gray-300">The full protocol uses a number of subprotocols for key generation, communication and non-interactive zero knowledge proofs. In order to focus on the e-voting protocol, we replace these subprotocols by so-called ideal functionalities and describe a hybrid protocol. We also discuss what protocols will replace these ideal functionalities, to the extent that these are known at this time.</p>

    <p class="text-gray-300">The ideal functionalities are trusted third parties that every player can communicate securely with. Standard protocol theory says that if we replace the ideal functionalities by secure subprotocols, we get a composed protocol and any attacks against this protocol can be translated into attacks on the hybrid protocols. If we know all possible attacks on the hybrid protocol, we will also know all the attacks on the composed protocol.</p>

    <p class="text-gray-300">Electronic identity We need some form of electronic identity to provide digital signatures. We also use the electronic identity to establish a secure channel between the voter's computer and the ballot box.</p>

    <p class="text-gray-300">The electronic identity is modeled using the following simplified ideal functionality, where we ignore key generation. The motivating idea is that for most electronic identity schemes, a voter essentially gives his computer custody of his electronic identity. If the computer is honest, it will do only as the voter intends, but if it is compromised it can usually abuse the voter's identity arbitrarily.</p>

    <pre><code class="language-text">On (key, Y, Σ,) from S:
  1. Store (key, Y, Σ).
On (use, P) from V , do:
  1. Record (use, P, V ).
On (establish, V, B) from P:
  1. Stop unless (use, P, V ) is recorded.
  2. Choose unique sid, send (establish, B, sid, V, P) to S, then record (sid, V, P, B).
  3. Send delayed, queued output (established, sid) to P and delayed, queued output
      (established, sid, V, P) to B.
On (send, sid, m) from X:
  1. Stop unless (sid, V, X, Y ) or (sid, V, Y, X) is recorded.
  2. Send (send, sid, |m|) to S and delayed, queued output (recv, sid, m) to Y .
On (sign, V, m) from P:
</code></pre>

    <p class="text-gray-300">Figure 4: Ideal functionality for electronic identity, Feid (continues).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Stop unless (use, P, V ) and (key, V, Σ) is recorded.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let σ ← Σ(m), record (signature, V, m, σ, 1) and output (signature, V, m, σ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">On (sign, R, m) from honest R:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Stop unless (key, R, Σ) is recorded.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let σ ← Σ(m), record (signature, V, m, σ, 1) and output (signature, V, m, σ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">On (verify, Y, m, σ) from X:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If no record (key, Y, Σ) exists, output (fail, Y, m, σ) and stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (signature, Y, m, σ, 1) is recorded, output (verified, Y, m, σ) and stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (signature, Y, m, σ, 0) is recorded, output (fail, Y, m, σ) and stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If Y is corrupt or (use, P, Y ) is recorded for some corrupt P, send (verify, Y, m, σ) to S and wait for (verify, Y, m, σ, b). Record (signature, Y, m, σ, b). If b = 1, output (verified, Y, m, σ), otherwise output (fail, Y, m, σ). Then stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Record (signature, Y, m, σ, 0) and output (fail, Y, m, σ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 4: Ideal functionality for electronic identity, Feid (final).</p>

    <p class="text-gray-300">Remark 5. Originally, the assumption was that an electronic identity smart card issued by the government coupled with a PKI would be available. This smart card would support signatures and secure, identified channels (probably using some variant of TLS). Unfortunately, this identity card has been delayed and will not be available for the trials.</p>

    <p class="text-gray-300">The electronic identity system to be used has not yet been finalized, but will probably be based on a government system using passwords and pins for identification, with some additional functionality for simulating digital signatures. It is currently unclear how much public documentation will be available for this system. Therefore, the assumptions on what security is provided (implicit in the ideal functionality) is deliberately quite conservative.</p>

    <p class="text-gray-300">Proofs of knowledge The computer and the ballot box need to prove that they have acted correctly. One method to do that is for them to prove that they know certain discrete logarithms. At some point, we shall also need to use that this proof is extractable. We model this using the proof-of-knowledge functionality given in Fig. 5.</p>

    <p class="text-gray-300">The actual proof is done as follows, where H is a hash function. On input of aux , n, ~ξ, ~η and ~ρ, do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose random numbers ~t and compute u&lt;sup&gt;i&lt;/sup&gt; = ξ ti i , i = 1, . . . , n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute e ← H(aux , n, ~ξ, ~η, ~u).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">On (setup, (Sim, Ver)) from S:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Store (Sim, Ver).</li>
    </ol>

    <p class="text-gray-300">On (prove,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\vec{\\rho}</span> ) from honest P:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\pi \\leftarrow Sim(aux, n, \\vec{\\xi}, \\vec{\\eta})</span> , store  <span class="math">(aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi)</span> , and output (proof,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi</span> ) to P.</li>
    </ol>

    <p class="text-gray-300">On (verify,  <span class="math">(aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi)</span> ) from Y:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If we have recorded  <span class="math">(aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi)</span> , output (verified,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi</span> ) and stop. If we have recorded (invalid,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi</span> ), output (invalid,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi</span> ) to Y.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify,  <span class="math">(aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi)</span> ) to  <span class="math">\\mathcal{S}</span> . If  <span class="math">\\mathcal{S}</span>  replies with (witness,  <span class="math">n, \\vec{\\rho}</span> ) such that  <span class="math">\\eta_i = \\xi_i^{\\rho_i}</span>  for  <span class="math">i = 1, \\ldots, n</span>  and  <span class="math">Ver(aux, n, \\vec{\\xi}, (\\xi_1^{\\rho_1}, \\ldots, \\xi_n^{\\rho_n}), \\pi) = 1</span> , store  <span class="math">(aux, n, \\vec{\\xi}, (\\xi_1^{\\rho_1}, \\ldots, \\xi_n^{\\rho_n}), \\pi)</span>  and output (verified,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi</span> ). Otherwise record (invalid,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi</span> ) and output (invalid,  <span class="math">aux, n, \\vec{\\xi}, \\vec{\\eta}, \\pi</span> ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Note:  <span class="math">\\vec{\\xi}</span>  and  <span class="math">\\vec{\\eta}</span>  are tuples of length n where the elements all come from either G,  <span class="math">G^2</span>  or  <span class="math">G^3</span> .</p>

    <p class="text-gray-300">Figure 5: Ideal functionality for discrete logarithm proof of knowledge,  <span class="math">\\mathcal{F}_{pok}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">z_i = t_i - e\\rho_i, i = 1, ..., n</span> .</li>
    </ol>

    <p class="text-gray-300">The proof is  <span class="math">\\pi=(e,\\vec{z})</span> . To verify the proof  <span class="math">\\pi</span>  for  <span class="math">aux, \\vec{\\xi}</span>  and  <span class="math">\\vec{\\eta}</span> , do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">u&#x27;_{i} = \\eta_{i}^{e} \\xi_{i}^{z_{i}}, i = 1, \\dots, n</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">e&#x27; = H(aux, n, \\vec{\\xi}, \\vec{\\eta}, \\vec{u}&#x27;)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Accept the proof of e' = e.</p>

    <p class="text-gray-300">Remark 6. This (parallel) non-interactive Schnorr proof of knowledge does not realize the ideal functionality, because it is not extractable when composed in parallel. In our opinion, this does not seem to be a deficiency in the Schnorr proof, but rather a technical obstruction. A protocol with an efficient online extractor [10] could have been used, but there seems little point in using a significantly more expensive proof of knowledge when no real security is gained.</p>

    <p class="text-gray-300">We note that the cost of generating a proof in  <span class="math">G^i</span>  is dominated by in exponentiations in G, while verifying the proof is dominated by 2in exponentiations in G.</p>

    <p class="text-gray-300"><strong>Collision resistant hashing</strong> The return code generator needs to sign hashes of votes. We denote by <em>Hash</em> some hash function. When needed, we shall assume that this hash function is collision resistant.</p>

    <p class="text-gray-300">Additional secure channels We assume that inside the infrastructure, every player communicates via secure channels. Also, there is a unidirectional out-of-band channel from the receipt generator to the voter. We model this using the following functionality, where V is the set of all voters and P is the set of all computers.</p>

    <pre><code class="language-text">On (send, X, ξ) from Y :
  1. If (X, Y ) is in V × P, P × V, V × {R} or
     {(R, B),(B, R),(D, B),(A, B),(A, R),(A, D)}, then send (recv, Y, ξ) to X. If
     (X, Y ) ∈ V × {R}, then the output to X is delayed.
On (flush) from R:
  1. Deliver any pending outputs to voters.
</code></pre>

    <p class="text-gray-300">Figure 6: Ideal functionality for secure communication, Fsc.</p>

    <p class="text-gray-300">Remark 7. The communication between the ballot box, receipt generator, decryption service and auditor is modeled as an untappable channel. Most likely, it will be realized by some standard protocol like TLS or IPSEC running over a public, reliable network. Some of the communication may also be out-of-band. We have not yet analyzed the realizing protocols.</p>

    <p class="text-gray-300">Remark 8. The out-of-band channel between the receipt generator and the voter will probably have unpredictable delivery scheduling. We (somewhat crudely) model this by allowing the adversary to schedule deliveries. The adversary cannot be allowed to postpone delivery indefinitely, however. The (flush) message is a technical trick to enforce this, not a real message in the real protocol.</p>

    <p class="text-gray-300">To simplify the description of protocols, we shall write &quot;Send ξ to X&quot; and &quot;Receive ξ from Y &quot; instead of &quot;Send (send, X, ξ) to Fsc&quot; and &quot;Receive (recv, Y, ξ) from Fsc&quot;. Since the channel established by the electronic identity functionality is susceptible to adversarial delay, we do not follow this convention there.</p>

    <p class="text-gray-300">Key generation Certain global parameters, such as the group G, its order q and the generator g are assumed to be public and known by everyone. The electoral board generates the three election keys, a1, a&lt;sup&gt;2&lt;/sup&gt; and a3, using a multiparty computation protocol. The pervoter keys are also generated by the electoral board. For simplicity, we model both of these processes as one simple ideal functionality.</p>

    <pre><code class="language-text">Once (start) has been received from every electoral board player:
  1. Choose the function f : O → G.
</code></pre>

    <p class="text-gray-300">Figure 7: Ideal functionality for key generation, Fkey (continues).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose random  <span class="math">a_1</span>  and  <span class="math">a_2</span> , and compute  <span class="math">a_3 = (a_1 + a_2) \\mod q</span> . Compute  <span class="math">y_1 = g^{a_1}</span> ,  <span class="math">y_2 = g^{a_2}</span>  and  <span class="math">y_3 = g^{a_3}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every voter V, choose random exponent s and PRF instance d. Compute the per-voter commitment  <span class="math">\\gamma = g^s</span>  and the set  <span class="math">\\mathcal{RC} = \\{(v, d(f(v)^s)) \\mid v \\in \\mathcal{O}\\}</span> . Send (codes,  <span class="math">\\mathcal{RC}</span> ) to V.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (keys,  <span class="math">y_1, a_2, y_3, \\{(V, s)\\}</span> ) to B, (keys,  <span class="math">y_1, y_2, a_3, \\{(V, \\gamma, d)\\}</span> ) to R, and (keys,  <span class="math">y_1</span> ) to A.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every computer P, send (keys,  <span class="math">y_1, f</span> ) to P.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Once (count) has been received by a qualified majority of the electoral board players:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (keys,  <span class="math">a_1</span> ) to D.</li>
    </ol>

    <p class="text-gray-300">Figure 7: Ideal functionality for key generation,  <span class="math">\\mathcal{F}_{key}</span>  (final).</p>

    <p class="text-gray-300">Remark 9. In practice, the per-voter exponent s will be pseudo-randomly generated. The receipt generator may use a single pseudo-random function to generate the receipt codes, but include a voter identifier to simulate a per-voter pseudo-random function.</p>

    <p class="text-gray-300">Remark 10. The key generation protocols have not yet been analyzed.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">4.2 The Protocol</h4>

    <p class="text-gray-300">The protocol has as its players the electoral board members, a set of voters, a larger set of computers, a ballot box, a receipt generator, a decryption service and an auditor. The programs run by the various players are described below.</p>

    <p class="text-gray-300"><em>Remark</em> 11. Error handling is mostly ignored in the protocol descriptions, but follows the usual principle that if something is wrong, the calling party is notified and processing stops.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">4.2.1 The Voter</h4>

    <p class="text-gray-300">Before the election, the voter receives a table of option–receipt code pairs. When the voter wants to submit a ballot, he gives the computer access to his electronic identity, submits the vote to the computer and waits for the computer's acceptance message and the receipt codes from the receipt generator. The receipt codes are verified against the option–receipt code pairs. If the voter receives receipt codes from the receipt generator when not processing a vote, he complains about a forgery.</p>

    <p class="text-gray-300">On (codes,  <span class="math">\\mathcal{RC}</span> ) from  <span class="math">\\mathcal{F}_{key}</span> :</p>

    <p class="text-gray-300">Figure 8: Program for the voter V (continues).</p>

    <pre><code class="language-text">1. Store RC.
On input (vote, P, v1, . . . , vk):
   1. Send (use, P) to Feid .
   2. Send (vote, v1, . . . , vk) to P.
   3. Wait for (accepted) or (fail) from P, and (receipt, rˇ1, . . . , rˇk
                                                                         0) from R.
   4. If (fail) was received from P, if k 6= k
                                                 0 or (vi
                                                        , rˇi) 6∈ RC for some i ∈ {1, . . . , k},
      output (fail). Otherwise erase ˇr1, . . . , rˇk and output (accepted).
On (receipt, . . .) from R:
   1. Output (forgery!).
On input (use, P):
   1. Send (use, P) to Feid .
</code></pre>

    <p class="text-gray-300">Figure 8: Program for the voter V (final).</p>

    <p class="text-gray-300">Remark 12. Given the receipt codes and the correspondence RC between options and receipt codes, it will usually be possible to reconstruct the corresponding ballot. Therefore, the voter should erase the receipt codes after verification (by deleting the SMS message with the codes).</p>

    <p class="text-gray-300">Remark 13. If the voter submits two or more ballots in parallel, the receipt codes from the receipt generator may arrive out of order and the voter will have no way to decide which receipt belongs to which ballot. There is no way for the voter to decide which ballot will be counted and which will not be counted. Honest voters should therefore not submit ballots in parallel.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">4.2.2 The Computer</h4>

    <p class="text-gray-300">The computer receives the ballot from the voter. It encrypts the ballot, generates a proof that it knows the contents of the encryption, signs the encrypted ballot on behalf of the voter, then submits the signed, encrypted ballot to the ballot box via Feid . Then it waits for the receipt generator's signature from the ballot box. Finally, the computer informs the voter that the ballot was accepted.</p>

    <pre><code class="language-text">On (keys, y1, f) from Fkey :
   1. Store y1 and f.
</code></pre>

    <p class="text-gray-300">Figure 9: Program for the computer P (continues).</p>

    <pre><code class="language-text">On (vote, v1, . . . , vk) from V :
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (establish, V, B) to Feid and wait for (established, sid).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set vk+1 = · · · = vkmax = 0.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i from 1 to kmax : Choose random t&lt;sup&gt;i&lt;/sup&gt; , compute (x&lt;sup&gt;i&lt;/sup&gt; , wi) = (g ti , y ti 1 f(vi)).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (prove, V, kmax ,(g, . . . , g),(x1, . . . , xkmax ),(t1, . . . , tkmax )) to Fpok and wait for (proof, . . . , π) from Fpok .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (sign, V,((x1, w1), . . . ,(xkmax , wkmax ), π)) to Feid , and wait for (signature, . . . , σ&lt;sup&gt;V&lt;/sup&gt; ) from Feid .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (send, sid,(vote, V,((x1, w1), . . . ,(xkmax , wkmax ), π), σ&lt;sup&gt;V&lt;/sup&gt; )) to Feid , and wait for (recv, sid,(receipt, σR)) from Feid .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute h&lt;sup&gt;b&lt;/sup&gt; ← Hash(V,(x1, w1), . . . ,(xkmax , wkmax ), π).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify, R, hb, σR) to Feid and wait for (verified, R, hb, σR).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (accepted) to V .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 9: Program for the computer P (final).</p>

    <p class="text-gray-300">Remark 14. Note that when sending the encrypted ballot to the ballot box, a fixed-length encoding should be used for the group elements. This is to prevent a compromised decryption service from correlating message length (which leaks out of the electronic identity functionality together with the identity) and encrypted ballots.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">4.2.3 The Ballot Box</h4>

    <p class="text-gray-300">The ballot box does nothing until it has received its keys. Afterwards, as computers connect to submit votes, it verifies signatures and proofs, then does the appropriate computations and generates appropriate proofs of correct computation. The result is passed to the receipt generator. The receipt generator replies with a signature, which the ballot box verifies and passes on to the computer.</p>

    <p class="text-gray-300">When the ballot box is told to close, it waits for ongoing submissions to complete, then selects the ballots to be counted and sends them to the decryption service. Finally, the entire contents of the ballot box is sent to the auditor.</p>

    <pre><code class="language-text">Do nothing until (keys, y1, a2, y3, {(V, s)}) has been received from Fkey , then do:
</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Record y1, a&lt;sup&gt;2&lt;/sup&gt; and y3, as well as the pairs (V, s).</li>
    </ol>

    <p class="text-gray-300">Figure 10: Program for the ballot box B (continues).</p>

    <p class="text-gray-300">On (established, sid, V, P) from Feid :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wait for (recv, sid, P,(((x1, w1), . . . ,(xkmax , wkmax ), π), σ&lt;sup&gt;V&lt;/sup&gt; )) from Feid .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify, V,((x1, w1), . . . ,(xkmax , wkmax ), π), σ&lt;sup&gt;V&lt;/sup&gt; ) to Feid and wait for (verified, . . . , σ&lt;sup&gt;V&lt;/sup&gt; ) from Feid .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify, V, kmax ,(g, . . . , g),(x1, . . . , xkmax ), π) to Fpok and wait for (verified, . . . , π) from Fpok .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Look up the stored pair (V, s) and place an exclusive lock on the pair (waiting for any other session to release its exclusive lock).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Select the next sequence number seq.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i from 1 to kmax :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Compute (ˇx&lt;sup&gt;i&lt;/sup&gt; , wˇ&lt;sup&gt;i&lt;/sup&gt; , πˇi) as specified below.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (ballot, seq, V,(x1, w1, xˇ1, wˇ1, πˇ1), . . . ,(xkmax , wkmax , xˇkmax , wˇkmax , πˇkmax ), π, σ&lt;sup&gt;V&lt;/sup&gt; ) to R, and wait for (receipt, seq, σR) from R.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute h&lt;sup&gt;b&lt;/sup&gt; ← Hash(V,(x1, w1), . . . ,(xkmax , wkmax ), π).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify, R, hb, σR) to Feid and wait for (verified, R, hb, σR) from Feid .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Store (seq, V,(x1, w1), . . . ,(xkmax , wkmax ), π, σ&lt;sup&gt;V&lt;/sup&gt; ) and release the lock on the record (V, s).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (receipt, σR) to P.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">On (count) from D:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Stop processing (established, . . .) messages from Feid .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Stop any voting sessions that have not yet reached Step 4 and wait for remaining sessions to terminate.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (count) to R.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let Sbb be the list of all recorded entries (seq, V,(x1, w1), . . . ,(xkmax , wkmax ), π, σ&lt;sup&gt;V&lt;/sup&gt; ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each voter V , find the recorded entry with the largest sequence number seq and extract the ballot ((x1, w1), . . . ,(xkmax , wkmax )). Compute</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$x = \\prod_{i=1}^{k_{max}} x_i \\qquad \\qquad w = \\prod_{i=1}^{k_{max}} w_i</span>$</p>

    <p class="text-gray-300">Figure 10: Program for the ballot box B (continues).</p>

    <p class="text-gray-300">and add (x, w) to the list L. (For elections where order is important, raise x&lt;sup&gt;i&lt;/sup&gt; and w&lt;sup&gt;i&lt;/sup&gt; to the ith power in the product.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sort L. Send (decrypt, L) to the decryption service D, and (content, Sbb) to A.</li>
    </ol>

    <p class="text-gray-300">Figure 10: Program for the ballot box B (final).</p>

    <p class="text-gray-300">The triples (ˇx&lt;sup&gt;i&lt;/sup&gt; , wˇ&lt;sup&gt;i&lt;/sup&gt; , πˇi) are computed as follows. The pair (ˇx&lt;sup&gt;i&lt;/sup&gt; , wˇi) are computed as in the simplified protocol. As for the correctness proof ˇπ&lt;sup&gt;i&lt;/sup&gt; , the idea is to prove correctness by proving equality of discrete logarithms, which is done by proving knowledge of the discrete logarithm in G × G or G × G × G. (We note that non-extractability of the non-interactive Schnorr proof is a non-issue here.)</p>

    <p class="text-gray-300">On input of (x, w), s and a2, do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute (¯x, w¯) ← (x s , w&lt;sup&gt;s&lt;/sup&gt; ) and ˆw ← x¯ a2 .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (prove, V, 1,(g, x, w),(g s , x, ¯ w¯), s) to Fpok and wait for (proof, . . . , π¯) from Fpok .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (prove, V, 1,(g, x¯),(y2, wˆ), a2) to Fpok and wait for (proof, . . . , πˆ) from Fpok .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The result is (ˇx, wˇ) = (¯x, w¯wˆ), the proof is ˇπ = ( ¯w, w, ˆ π, ¯ πˆ).</p>

    <p class="text-gray-300">To verify a proof ˇπ on input of (x, w), (ˇx, wˇ), y&lt;sup&gt;2&lt;/sup&gt; and γ, do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that ˇw = ¯wwˆ.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify, V, 1,(g, x, w),(γ, x, ¯ w¯), π¯) to Fpok and wait for (verified, . . .) from Fpok .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify, V, 1,(g, x),(y2, wˆ), πˆ) to Fpok and wait for (verified, . . .) from Fpok .</li>
    </ol></li>
    </ul>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">4.2.4 Receipt Generator</h4>

    <p class="text-gray-300">The receipt generator receives from the ballot box the sequence number, the entire encrypted ballot, the computer's proof, the voter's signature, the ciphertexts {(ˇx&lt;sup&gt;i&lt;/sup&gt; , wˇi)} and the proofs made by the ballot box. It verifies the proofs, the digital signature and the sequence number before decrypting (ˇx&lt;sup&gt;i&lt;/sup&gt; , wˇi). It then derives the receipt codes and sends them to the voter. It signs a hash of the encrypted ballot and sends this receipt to the ballot box. Also, it records the voter name, the sequence number and a hash of the encrypted ballot.</p>

    <pre><code class="language-text">On (keys, y1, y2, a3, {(V, γ, d)}) from Fkey :
   1. Record y1, y2, a3, as well as the tuples (V, γ, d).
</code></pre>

    <p class="text-gray-300">Figure 11: Program for the return code generator R (continues).</p>

    <p class="text-gray-300">On (ballot, seq, V,  <span class="math">(x_1, w_1, \\check{x}_1, \\check{w}_1, \\check{\\pi}_1), \\ldots, (x_{k_{max}}, w_{k_{max}}, \\check{x}_{k_{max}}, \\check{w}_{k_{max}}, \\check{\\pi}_{k_{max}}), \\pi, \\sigma_V)</span>  from B:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">h_b \\leftarrow Hash(V, (x_1, w_1), \\dots, (x_{k_{max}}, w_{k_{max}}), \\pi, \\sigma_V)</span>  and  <span class="math">h&#x27;_b \\leftarrow Hash(V, (x_1, w_1), \\dots, (x_{k_{max}}, w_{k_{max}}), \\pi)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Look up the recorded tuple  <span class="math">(V, \\gamma, d)</span>  and place an exclusive lock on the tuple (waiting for any other session to release its exclusive lock).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify that no record  <span class="math">(\\cdot, \\cdot, \\cdot, h&#x27;_h)</span>  or  <span class="math">(V, seq&#x27;, \\cdot, \\cdot)</span>  with  <span class="math">seq&#x27; \\geq seq</span>  exists.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify, V,  <span class="math">((x_1, w_1), \\ldots, (x_{k_{max}}, w_{k_{max}}), \\pi), \\sigma_V)</span>  to  <span class="math">\\mathcal{F}_{eid}</span>  and wait for (verified,  <span class="math">\\ldots, \\sigma_V</span> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (verify,  <span class="math">V, k_{max}, (g, \\ldots, g), (x_1, \\ldots, x_{k_{max}}), \\pi</span> ) to  <span class="math">\\mathcal{F}_{pok}</span>  and wait for (verified, ...).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i from 1 to  <span class="math">k_{max}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Verify the computation of  <span class="math">(\\check{x}_i, \\check{w}_i)</span>  using the proof  <span class="math">\\check{\\pi}_i</span>  as described after the ballot box program (Fig. 10).</li>
      <li>(b)  <span class="math">r_i \\leftarrow \\check{w}_i \\check{x}_i^{-a_3}</span> . If  <span class="math">r_i \\neq 1</span> , then  <span class="math">k \\leftarrow i</span> .</li>
      <li>(c)  <span class="math">\\check{r}_i \\leftarrow d(r_i)</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (sign,  <span class="math">R, h_b</span> ) to  <span class="math">\\mathcal{F}_{eid}</span>  and wait for (signature,  <span class="math">R, h_b, \\sigma_R</span> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Record  <span class="math">(V, seq, h_b, h&#x27;_b)</span> . Send (receipt,  <span class="math">seq, \\sigma_R</span> ) to B.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (receipt,  <span class="math">\\check{r}_1, \\ldots, \\check{r}_k</span> ) to V.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">On (count) from B:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify that all sessions have terminated.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (flush) to  <span class="math">\\mathcal{F}_{sc}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">S_R</span>  be the list of all recorded entries  <span class="math">(V, seq, h_b, h&#x27;_b)</span> . Send (hashes,  <span class="math">S_R</span> ) to A.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 11: Program for the return code generator R (final).</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.2.5 Decryption Service</h4>

    <p class="text-gray-300">The decryption service decrypts the encrypted ballots sent by the ballot box and shuffles the result before output. Before decryption, the auditor must approve the input. The decryption service also proves to the auditor that the encrypted ballots contain a permutation of the output ballots [12].</p>

    <p class="text-gray-300">The proof that the encrypted ballots contain a permutation of the output ballots is</p>

    <p class="text-gray-300">done by shuffling and rerandomizing the encrypted ballots, then decrypting the result. The correctness of the shuffle and the decryptions are proved to the auditor.</p>

    <p class="text-gray-300">The decryption service also decodes ballots. Let  <span class="math">2^{\\mathcal{O}}</span>  denote the set of all subsets of  <span class="math">\\mathcal{O}</span> , let G be a subgroup the non-zero elements of a finite prime field  <span class="math">\\mathbb{F}_p</span>  under multiplication, and let  <span class="math">\\ell_1, \\ldots, \\ell_{|\\mathcal{O}|}</span>  be the primes used to encode options.</p>

    <p class="text-gray-300">We define a decoding function  <span class="math">\\phi: G \\to 2^{\\mathcal{O}} \\cup \\{\\text{spoilt}\\}</span> . Considering  <span class="math">\\mu \\in G</span>  as an integer between 0 and p, we can try to factor that integer as a non-empty product of the small primes  <span class="math">\\ell_1, \\ldots, \\ell_{|\\mathcal{O}|}</span> . From such a product, we can easily deduce a subset S of  <span class="math">\\mathcal{O}</span>  such that  <span class="math">\\mu = \\prod_{v \\in S} f(v)</span> , and we let  <span class="math">\\phi(\\mu) = S</span> . If there is no such product, we let  <span class="math">\\phi(\\mu) = \\text{spoilt}</span> . (Note that for elections where order matter, the decoding function  <span class="math">\\phi</span>  must be changed in the obvious way.)</p>

    <p class="text-gray-300">On (keys,  <span class="math">a_1</span> ) from  <span class="math">\\mathcal{F}_{key}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (count) to B.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wait for  <span class="math">(\\text{decrypt}, (x_1, w_1), \\dots, (x_n, w_n))</span>  from B.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\chi \\leftarrow Hash((x_1, w_1), \\dots, (x_n, w_n))</span> , send  <span class="math">(\\mathsf{hash}, \\chi)</span>  to A, and wait for  <span class="math">(\\mathsf{proceed})</span>  from A.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose a permutation  <span class="math">\\Pi</span>  on  <span class="math">\\{1, \\ldots, n\\}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i from 1 to n: Choose a random number  <span class="math">t_i</span>  and compute:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$x_i&#x27; = x_{\\Pi(i)}g^{t_i} w_i&#x27; = w_{\\Pi(i)}y_1^{t_i}</span>$</p>

    <p class="text-gray-300">Compute  <span class="math">\\mu_i = w&#x27;_i(x&#x27;_i)^{-a_1}</span> , send (prove,  <span class="math">-, 1, (g, x&#x27;_i), (y_1, w&#x27;_i \\mu_i^{-1}), a_1</span> ) to  <span class="math">\\mathcal{F}_{pok}</span>  and wait for (proof, ...,  <span class="math">\\pi_i</span> ).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Create a proof  <span class="math">\\pi&#x27;</span>  that  <span class="math">(x_1&#x27;, w_1&#x27;), \\ldots, (x_n&#x27;, w_n&#x27;)</span>  is a shuffle of  <span class="math">(x_1, w_1), \\ldots, (x_n, w_n)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send (proofs,  <span class="math">(x&#x27;_1, w&#x27;_1, \\mu_1, \\pi_1), \\ldots, (x&#x27;_n, w&#x27;_n, \\mu_n, \\pi_n), \\pi&#x27;</span> ) to A, then output (ballots,  <span class="math">\\phi(\\mu_1), \\ldots, \\phi(\\mu_n)</span> ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 12: Program for the decryption service D.</p>

    <p class="text-gray-300">The proof of correctness  <span class="math">\\pi&#x27;</span>  for the ciphertext shuffle is a protocol run by a prover and a verifier. It works by the prover doing four intermediate shuffles and carefully revealing some information about each shuffle in parallel.</p>

    <p class="text-gray-300">Assume for the moment that the number of ciphertexts to be shuffled is a square, that is  <span class="math">n = \\nu^2</span> . Denote the <em>i</em>'th ciphertext  <span class="math">(x_i, w_i)</span>  by  <span class="math">c_i</span> .</p>

    <p class="text-gray-300">For the k'th shuffle, the prover chooses a permutation  <span class="math">\\Pi^{(k)}</span>  on  <span class="math">\\{1, 2, \\ldots, n\\}</span>  for the shuffle and lets  <span class="math">c_{\\Pi^{(k)}(i)}^{(k+1)}</span>  be a rerandomization of  <span class="math">c_i^{(k)}</span> . The challenger randomly divides the</p>

    <p class="text-gray-300">index set into ν groups {Γ (k) i }, each group containing ν indices. The prover must then reveal the images of the groups under Π(k) , that is, {Π(k) (Γ(k) i )}, and prove (using Fpok ) that</p>

    <p class="text-gray-300"><span class="math">$\\prod_{j \\in \\Gamma_i^{(k)}} c_j^{(k)} / \\prod_{j&#x27; \\in \\Pi(\\Gamma_i^{(k)})} c_{j&#x27;}^{(k+1)}</span>$</p>

    <p class="text-gray-300">is an encryption of the identity element. The intermediate shuffles are connected by requiring that for any i and j, the intersection of Π(k) (Γ(k) i ) and Γ(k+1) j should contain exactly one index.</p>

    <p class="text-gray-300">Note that for all i, c (1) i should be (x&lt;sup&gt;i&lt;/sup&gt; , wi) and c (5) i should be (x 0 i , w&lt;sup&gt;0&lt;/sup&gt; i ).</p>

    <p class="text-gray-300">The idea is that dividing the ciphertexts into groups prevents the prover from changing the content of ciphertexts. Limiting the information revealed about the permutations limits the information revealed to the verifier.</p>

    <p class="text-gray-300">The proof should be interactive, that is, the prover commits to every shuffle, then the verifier selects the groups.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">4.2.6 Auditor</h4>

    <p class="text-gray-300">The auditor verifies that every encrypted ballot in the ballot box was seen by the receipt generator. Also, it verifies the selection of ciphertexts sent for decryption. Finally, it verifies correctness of decryption.</p>

    <p class="text-gray-300">Remark 15. In the real protocol, the voter receives a receipt that he can verify after the election by contacting the auditor. For our corruption model, no security is gained and we have not modeled this process. In other corruption models, there might be some gain. We have not yet analysed these corruption models.</p>

    <p class="text-gray-300">On (keys, y1) from Fkey :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Store y1.</li>
    </ol>

    <p class="text-gray-300">On (content, Sbb) from B:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wait for (hashes, SR) from R.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify that every encrypted ballot in Sbb has a corresponding hash in SR, and vice versa.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the signatures on the encrypted ballots.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Select from Sbb the ciphertexts that should be decrypted, sort the list and compute a hash χ of the list.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wait for (hash, χ&lt;sup&gt;0&lt;/sup&gt; ) from D. Verify that χ = χ 0 , then send (proceed) to D.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 13: Program for the auditor A (continues).</p>

    <pre><code class="language-text">6. Wait for (proofs, (x&#x27;_1, w&#x27;_1, \\mu_1, \\pi_1), \\ldots, (x&#x27;_n, w&#x27;_n, \\mu_n, \\pi_n), \\pi&#x27;) from D.
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i from 1 to n, do: Send (verify, -, 1,  <span class="math">(g, x&#x27;_i)</span> ,  <span class="math">(y_1, w&#x27;_i \\mu_i^{-1})</span> ,  <span class="math">\\pi_i</span> ) to  <span class="math">\\mathcal{F}_{pok}</span>  and wait for (verified, . . . ) from  <span class="math">\\mathcal{F}_{pok}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the proof  <span class="math">\\pi&#x27;</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (accepted,  <span class="math">\\phi(\\mu_1), \\ldots, \\phi(\\mu_n)</span> ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 13: Program for the auditor A (final).</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.3 The Electoral Board Member</h3>

    <p class="text-gray-300">The electoral board member participates in the key generation. Since we have not analysed these protocols, but instead hide them in the key generation functionality, the electoral board member protocol is quite simple.</p>

    <pre><code class="language-text">On input (start):

1. Send (start) to \\mathcal{F}_{key}.

On input (count):

1. Send (count) to \\mathcal{F}_{key}.
</code></pre>

    <p class="text-gray-300">Figure 14: Program for the electoral board member  <span class="math">E_i</span> .</p>

    <p class="text-gray-300">Our goal should be to prove that the protocol realizes a functionality roughly similar to the one given in Fig. 15. Unfortunately, the protocol (given the subprotocols we have) is not secure. Hence, it does not realize the protocol in the most interesting corruption models. Fortunately, we are able to prove a number of interesting security properties for the protocol.</p>

    <p class="text-gray-300">Do nothing until (start) has been received from every election board player. Then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every voter, choose a random permutation  <span class="math">\\Pi_V</span>  on  <span class="math">\\mathcal{O}</span>  and an equivalence relation  <span class="math">\\sim_V</span>  on a set  <span class="math">\\mathcal{O}&#x27;</span>  containing  <span class="math">\\mathcal{O}</span>  (see Sect. 3 for the definition of  <span class="math">\\mathcal{O}&#x27;</span>  and Sect. 3.2 for a discussion on  <span class="math">\\sim_V</span> ).</li>
    </ol>

    <pre><code class="language-text">On input (vote, P, v_1, \\ldots, v_k) from V:
</code></pre>

    <p class="text-gray-300">Figure 15: Ideal functionality for electronic voting,  <span class="math">\\mathcal{F}_{vote}</span>  (continues).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If V is corrupt, choose the next sequence number seq, store (seq, V, v1, . . . , vk) and stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If P is corrupt, record (use, V, P).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If P is corrupt, set aux = (v1, . . . , vk). If R is corrupt, set aux = (Π&lt;sup&gt;V&lt;/sup&gt; (v1), . . . , Π&lt;sup&gt;V&lt;/sup&gt; (vk)). Otherwise, let aux be empty.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose unique sid and send (vote, sid, V, P, aux) to S and wait for (vote, sid, result, aux&lt;sup&gt;0&lt;/sup&gt; ) from S, where result ∈ {fail,store}.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If result = fail, output (fail) to V and stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose next sequence number seq. If P is corrupt, parse aux&lt;sup&gt;0&lt;/sup&gt; as (v 0 1 , . . . , v&lt;sup&gt;0&lt;/sup&gt; k &lt;sup&gt;0&lt;/sup&gt;) and store (seq, V, v&lt;sup&gt;0&lt;/sup&gt; 1 , . . . , v&lt;sup&gt;0&lt;/sup&gt; k &lt;sup&gt;0&lt;/sup&gt;). Otherwise store (seq, V, v1, . . . , vk).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wait for (vote, sid, result&lt;sup&gt;0&lt;/sup&gt; ), where result ∈ {fail, ok}. If result = fail, output (fail) to V and stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If P is corrupt and (v1, . . . , vk) 6∼&lt;sup&gt;V&lt;/sup&gt; (v 0 1 , . . . , v&lt;sup&gt;0&lt;/sup&gt; k &lt;sup&gt;0&lt;/sup&gt;), output (fail) to V and stop. Otherwise, output (accepted) to V .</li>
    </ol></li>
    </ul>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">On (use, P) from honest V :</h3>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If P is corrupt, record (use, V, P).</li>
    </ol>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">On (forge, V, P, v1, . . . , vk) from S:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If V is corrupt, P is honest or (use, V, P) is not recorded, stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose next sequence number seq and store (seq, V, v1, . . . , vk). Then send delayed message (forgery!) to V .</li>
    </ol></li>
    </ul>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">On (count) from an election board player:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Stop unless a qualified majority of the election board players have input (count).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If B or R are corrupt, send (count) to S and wait for (count, result). If result = fail, output (fail) to A and stop.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Stop processing new input from voters, and wait for processing of already received input from voters to terminate.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each voter V , select the stored record (seq, V, v1, . . . , vk) with maximal sequence number. Add the set {v1, . . . , vk} to a list L at a random position.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If D or A are corrupt, send (count, L) to S and wait for (count, result). If result = fail, output (fail) to A and stop. Otherwise, output (ballots, L) to D and (accepted, L) to A.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 15: Ideal functionality for electronic voting, Fvote (final).</p>

    <p class="text-gray-300">Our general strategy create a sequence of indistinguishable games, starting with the real world and ending with a game where it is easier to analyse security.</p>

    <p class="text-gray-300">We consider the following cases for corruption in order:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A subset of the voters and computers are corrupt, and possibly the ballot box.</li>
      <li>The receipt generator is corrupt.</li>
      <li>The decryption service is corrupt.</li>
      <li>The auditor is corrupt.</li>
    </ul>

    <h2 id="sec-17" class="text-2xl font-bold">5.1 Voters, computers and the ballot box</h2>

    <p class="text-gray-300">Our starting game is the real protocol interacting with a real adversary that has corrupted a number of voters and computers, and possibly the ballot box. We shall make a number of changes to this game and finally arrive in a game that is indistinguishable from the initial game, but where security analysis is easier. There we shall prove the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If the ballot box is not corrupt, the auditor will not fail the election.</li>
      <li>For any honest voter that uses only honest computers, any ballot accepted as cast and not superceded should be counted if the auditor accepts the election. The ballot remains confidential regardless.</li>
      <li>If an honest voter uses a corrupt computer (not neccessarily for voting), nothing can be guaranteed for voters that submit multiple ballots. However, for voters that submit exactly one ballot and accepts that ballot as cast, with high probability that ballot will be counted unless the voter observes an attack. If the ballot was submitted through an honest computer, the ballot remains confidential.</li>
    </ul>

    <p class="text-gray-300">Game 1 In the first game, one machine M plays the role of every honest player as well as the ideal functionalities. Note that in this game, the machine M knows every decryption key in the system, specifically the machine M knows a1, a&lt;sup&gt;2&lt;/sup&gt; and a3.</p>

    <p class="text-gray-300">This game is clearly indistinguishable from our starting point.</p>

    <p class="text-gray-300">Game 2 In this game, the machine M ignores mixing encrypted ballots and proving the correctness of decryptions. Instead, the encrypted ballots are simply decrypted and the ballots are shuffled.</p>

    <p class="text-gray-300">Since the adversary cannot observe the conversation between the decryption service and the auditor, this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300"><strong>Game 3</strong> In this game, the machine M aborts if it ever observes a collision in  <span class="math">Hash(\\cdot)</span> . Clearly, this game is indistinguishable from the previous game if  <span class="math">Hash(\\cdot)</span>  is collision resistant.</p>

    <p class="text-gray-300">From now on, we can treat Hash(.) as an injective function in analysis.</p>

    <p class="text-gray-300"><strong>Game 4</strong> The machine M samples the per-voter function  <span class="math">d: G \\to \\mathcal{C}</span>  from the set of all functions from G to  <span class="math">\\mathcal{C}</span> , not from F. Since F is a pseudo-random function family, this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300"><strong>Game 5</strong> We make two changes: First, the machine M computes the return codes sent to voters (see the key generation functionality, Fig. 7) as d(f(v)), not  <span class="math">d(f(v)^s)</span> . Second, the simulated return code generator (see Fig. 11) computes the return code as  <span class="math">d(w_i x_i^{-a_1})</span> , not as  <span class="math">d(\\check{w}_i \\check{x}_i^{-a_3})</span> . Note that the machine M knows  <span class="math">(x_i, w_i)</span>  because the ballot box also sends the original encrypted ballot.</p>

    <p class="text-gray-300">Since d is a random function and exponentiation is a permutation, the only way these changes can be observable is if  <span class="math">(w_i x_i^{-a_1})^s \\neq \\check{w}_i \\check{x}_i^{-a_3}</span> . Note that Schnorr proofs in the groups  <span class="math">G^2</span>  and  <span class="math">G^3</span>  are sound in the sense that it is hard to create a valid proof unless a witness exists. Therefore, as long as the ballot box proofs are valid,  <span class="math">(w_i x_i^{-a_1})^s = \\check{w}_i \\check{x}_i^{-a_3}</span>  holds except with negligible probablity.</p>

    <p class="text-gray-300">We conclude that this game is indistinguishable from the previous game. Observe also that we no longer use the return code generator decryption key  <span class="math">a_3</span> .</p>

    <p class="text-gray-300">Game 6 In this game, the machine M remembers the ballot corresponding to every honestly generated encrypted ballot (that is, signed by an honest user and created by an honest computer). When such ballots arrive at the simulated receipt generator, it does not decrypt the ciphertexts, but uses the stored ballot instead. When such encrypted ballots are submitted for final decryption, the stored ballot is used instead of decrypting the ciphertexts.</p>

    <p class="text-gray-300">Clearly, this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300">Game 7 When an adversarially generated encrypted ballot  <span class="math">((x_1, w_1), \\ldots, (x_{k_{max}}, w_{k_{max}}), \\pi)</span>  reaches the simulated receipt generator, it verifies the proof  <span class="math">\\pi</span>  before decryption. This forces the adversary to supply witnesses  <span class="math">(\\rho_1, \\ldots, \\rho_{k_{max}})</span>  to  <span class="math">\\mathcal{F}_{pok}</span>  that satisfy  <span class="math">x_i = g^{\\rho_i}</span> . The decryption of  <span class="math">(x_i, w_i)</span>  is  <span class="math">w_i y_1^{-\\rho_i}</span> . The simulated receipt generator uses this to decrypt instead of  <span class="math">w_i x_i^{-a_1}</span> .</p>

    <p class="text-gray-300">The machine M remembers the clear text ballot for adversarially encrypted ballots that arrive at the receipt generator. When these are submitted for final decryption, the stored ballot is used instead of decrypting the ciphertexts.</p>

    <p class="text-gray-300">By the properties of  <span class="math">\\mathcal{F}_{pok}</span> , the computed decryptions are always correct. Therefore, this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300">Claim. The decryption key a&lt;sup&gt;1&lt;/sup&gt; is not used in Game 7.</p>

    <p class="text-gray-300">Proof. The only encrypted ballots that need to be decrypted are those that the receipt generator have not seen. But if any such encrypted ballots reach the decryption service, the auditor will complain since the list of encrypted ballots received from the ballot box will either not match those submitted for decryption or not match those seen by the receipt generator. If the auditor complains, the machine M does not need to decrypt the ciphertexts, since there will be no election result.</p>

    <p class="text-gray-300">Remark 16. We note again that the Schnorr proof we use is not extractable, hence it does not realize the ideal functionality, hence the above argument does not strictly apply to our protocol. In our opinion, this is a technical problem, not a security problem. Therefore, the above argument is morally justified.</p>

    <p class="text-gray-300">Game 8 In this game, the simulated honest computers no longer provide the simulated Fpok with a witness for proofs. Since Fpok does not use the witness, this game is indistinguishable from the previous.</p>

    <p class="text-gray-300">Game 9 In this game, the simulated honest computers no longer encrypt encoded options, but rather random group elements. Since we do not use any of the decryption keys, a straight-forward DDH-reduction will show that this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300">Analysis Suppose the auditor accepts the election. The auditor verifies that the list of hashes retained by the receipt generator matches the list of encrypted ballots in the ballot box. Since Hash(·) is injective in the final game, every encrypted ballot in the ballot box must have been seen by the receipt generator. The receipt generator and the auditor verify the voter's signature, therefore the encrypted ballot must come from a computer used by the voter.</p>

    <p class="text-gray-300">If the computers used by the voter are all honest, the receipt generator sees and verifies the sequence numbers, then gives them to the auditor. Since the voter's computer verifies the receipt generator's signature, every honestly generated ballot must be in the ballot box. Since an honest voter submits votes sequentially, the ballot box sequence numbers must correspond to the submission order, which means that the correct ballot must be counted.</p>

    <p class="text-gray-300">If the voter has used a corrupt computer, we suppose that the voter submits exactly one ballot. Suppose first that this ballot is submitted through a corrupt computer. The voter will not accept the ballot as cast unless he receives correct receipt codes. If he receives correct receipt codes, then with high probability the ciphertexts seen by the receipt generator contain the correct ballot. If there are more encrypted ballots from the voter in the ballot box, these must have been seen by the receipt generator, which means that the voter must have received unexpected receipt codes, which means that the voter will have noticed (and complained about) an attack.</p>

    <p class="text-gray-300">If the voter's ballot is submitted through an honest computer, the ciphertexts seen by the ballot box contain no information about the ballot. Also, unless the voter receives unexpected receipt codes, the attacker cannot use the receipt generator as a decryption oracle. Therefore, the ballot will remain confidential.</p>

    <p class="text-gray-300">Discussion The above results are somewhat close to the security requirements, but there is a gap. We provide three example attacks to show that the gap is real, and not just a limitation of the security proof.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consider a corrupt computer used by the voter to submit two ballots, and suppose the ballots are known in advance to the attacker. The computer first submits the two ballots in reverse order, but delays the receipt code messages. When the voter asks the computer to submit the first ballot, the computer does nothing and the adversary delivers the second receipt code message. When the voter asks the computer to submit the second ballot, the computer does nothing and the adversary delivers the first receipt code message. The voter accepts both ballots as cast, but the wrong ballot is counted.</li>
    </ol>

    <p class="text-gray-300">In this attack, the ballot box is honest and the voter does not notice an attack.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consider a corrupt computer used by the voter to submit a ballot. The computer first submits (on behalf of the voter) the correct ballot, but delays the receipt code. He then submits a forged ballot and delivers this receipt code. In response to the unexpected receipt code, the voter fails to accept the ballot as cast. Next, suppose the voter resubmits his correct ballot through the same corrupt computer. The attacker discards the submission, but delivers the delayed receipt code. The voter now accepts his ballot as cast, but it will not be counted.</li>
    </ol>

    <p class="text-gray-300">In this attack, the ballot box is honest, but the voter notices an attack.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Since the receipt generator remembers ciphertexts and proofs of knowledge, the attacker cannot replay old ciphertexts. However, the attacker may substitute its own ciphertexts for honestly generated ciphertexts, observe the voter's subsequent behaviour and from that deduce something about the honestly generated ciphertexts.</li>
    </ol>

    <p class="text-gray-300">Consider a voter that has used a corrupt computer. Later, this voter uses an honest computer to vote. The adversary delays the receipt codes (but not the receipt for the honest computer). The adversary guesses the content of the honestly encrypted ballot and runs a second voting session from the corrupt computer submitting the guessed ballot. The adversary allows these receipt code message to arrive. From the voter's subsequent behaviour, the attacker may decide if his guess is correct or not.</p>

    <p class="text-gray-300">In this attack, the ballot box is honest, but the voter notices an attack.</p>

    <p class="text-gray-300">Remark 17. To some extent, these attacks are artefacts of our model, specifically the fact that the attacker schedules delivery of receipt code messages.</p>

    <p class="text-gray-300">However, the main problem is that the voter cannot connect receipt code messages to ballot submission sessions. Therefore, messages from two different protocols runs can be confused, which is the essential cause of the attacks.</p>

    <p class="text-gray-300">There may be solutions to this problem, but since these attacks are quite marginal, our opinion is that any mitigation attempt should not reduce usability. The best approach would be to use a stronger electronic identity scheme, where the voter is forced to approve the connection to the ballot box. This would allow a voter to connect receipt code messages to ballot submission sessions.</p>

    <p class="text-gray-300">Until some mitigation is in place, we believe the government's advice to voters should be to vote only once electronically. If something goes wrong or the voter is subject to coercion, the voter should submit a paper vote if possible, rather than vote again electronically.</p>

    <p class="text-gray-300">Remark 18. Note that the ballot box is honest in every attack. Indeed, in our model, corrupting the ballot box does not seem to help the attacker, because the ballot box must prove correctness of everything it does. Also, the receipt generator will detect replay attacks, so access to previously submitted electronic ballots does not help.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.2 The Receipt Generator</h3>

    <p class="text-gray-300">Again, our starting point is the real protocol interacting with a real adversary that has corrupted the receipt generator. For the final game, we shall prove the following:</p>

    <p class="text-gray-300">• The corrupt receipt generator learns nothing about the submitted ballots, except what the receipt codes tell him.</p>

    <p class="text-gray-300">Remark 19. A moderately complicated argument with a simulator based on the final game (with some minor modifications) should suffice to show that our protocol realizes the functionality Fvote in this corruption model. We have not completed that argument.</p>

    <p class="text-gray-300">Game 1 In this game, one machine M plays the role of every honest player as well as the ideal functionalities. Note that in this game, the machine M knows every decryption key in the system, specifically our machine M knows a1, a&lt;sup&gt;2&lt;/sup&gt; and a3.</p>

    <p class="text-gray-300">This game is clearly indistinguishable from our starting point.</p>

    <p class="text-gray-300">Game 2 Note that the machine M knows which cleartext ballot corresponds to which encrypted ballot. In this game, the decryption service uses the cleartext ballots instead of decrypting the encrypted ballots.</p>

    <p class="text-gray-300">This game is clearly indistinguishable from the previous game. Note also that the election decryption key a&lt;sup&gt;1&lt;/sup&gt; is no longer used.</p>

    <p class="text-gray-300"><strong>Game 3</strong> In this game, the machine M provides  <span class="math">\\mathcal{F}_{pok}</span>  with random witnesses. Since the witnesses are never used by  <span class="math">\\mathcal{F}_{pok}</span> , this game is clearly indistinguishable from the previous game.</p>

    <p class="text-gray-300"><strong>Game 4</strong> Now the machine M generates the message to the receipt generator when it generates the encrypted ballot (but does not send it until the appropriate message has arrived at the ballot box). Again, this game is clearly indistinguishable from the previous game.</p>

    <p class="text-gray-300"><strong>Game 5</strong> We change the machine M's computation of the values  <span class="math">x_i, w_i, \\bar{x}_i, \\bar{w}_i, \\hat{w}_i, \\dot{x}_i, \\dot{w}_i</span>  related to the option  <span class="math">v_i</span>  as follows:</p>

    <p class="text-gray-300">Here, s is the appropriate per-voter exponent and  <span class="math">s^{-1}</span>  is its multiplicative inverse modulo q.</p>

    <p class="text-gray-300">A straight-forward computation will show that the change in method of computation does not change the induced probability distributions. Therefore, this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300"><strong>Game 6</strong> In this game, the machine M samples a random  <span class="math">\\hat{w}_i</span>  instead of computing it as  <span class="math">\\tilde{x}_i^{a_2}</span> .</p>

    <p class="text-gray-300">Claim. A distinguisher for this game and the previous game will result in an adversary against Decision Diffie-Hellman.</p>

    <p class="text-gray-300"><em>Proof.</em> If this game is distinguishable from the previous game, we get an adversary against Decision Diffie-Hellman. On input of a tuple  <span class="math">(g, y_2, u_1, u_2)</span> , it works as follows. It runs the game as usual, except that during key generation,  <span class="math">y_2</span>  is taken as given,  <span class="math">a_2</span>  and  <span class="math">a_1</span>  are never generated, and  <span class="math">y_1 = y_3 y_2^{-1}</span> . Furthermore,  <span class="math">\\check{x}_i</span>  and  <span class="math">\\hat{w}_i</span>  are computed as:</p>

    <p class="text-gray-300"><span class="math">$\\dot{x}_i = g^{t_i} u_1^{t_i&#x27;} \\qquad \\qquad \\dot{w}_i = y_1^{t_i} u_2^{t_i&#x27;}</span>$</p>

    <p class="text-gray-300">If we get a DDH tuple, the execution proceeds as in the previous game. If we get a random tuple, the execution proceeds as in this game.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Game 7 In this game, we change the machine M's computation of x&lt;sup&gt;i&lt;/sup&gt; , w&lt;sup&gt;i&lt;/sup&gt; , x¯&lt;sup&gt;i&lt;/sup&gt; , w¯&lt;sup&gt;i&lt;/sup&gt; , wˆ&lt;sup&gt;i&lt;/sup&gt; , xˇ&lt;sup&gt;i&lt;/sup&gt; as follows:</p>

    <p class="text-gray-300">$$\\dot{x}_i = \\bar{x}_i
\\dot{w}_i = \\dot{w}_i \\bar{w}_i^{-1}
\\bar{x}_i = x_i^s
\\bar{w}_i = w_i^s
x_i = g^{t_i}
w_i = g^{t_i'}$$</p>

    <p class="text-gray-300">Here, s is the appropriate per-voter exponent.</p>

    <p class="text-gray-300">Again, a straight-forward computation shows that this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300">Game 8 In this game, we replace the per-voter functions v 7→ f(v) &lt;sup&gt;s&lt;/sup&gt; with random functions from O to G.</p>

    <p class="text-gray-300">Claim. A distinguisher for this game and the previous game will result in an adversary against the problem described in Sect. 3.3.</p>

    <p class="text-gray-300">Proof. Our adversary gets as its input (<code>1, . . . , </code>|O|) and (u1, . . . , u|O|). Define f : O → G to be f(i) = \`&lt;sup&gt;i&lt;/sup&gt; , i = 1, . . . , |O|. Let</p>

    <p class="text-gray-300"><span class="math">$g = \\prod_{j=1}^{|\\mathcal{O}|} \\ell_j^{s_j},</span>$</p>

    <p class="text-gray-300">where s&lt;sup&gt;j&lt;/sup&gt; are random numbers. For one specific voter, we use the receipt code function i 7→ u&lt;sup&gt;i&lt;/sup&gt; . We generate the per-voter commitment as</p>

    <p class="text-gray-300"><span class="math">$\\gamma = \\prod_{j=1}^{|\\mathcal{O}|} u_j^{s_j}.</span>$</p>

    <p class="text-gray-300">When generating encrypted ballots, we compute x&lt;sup&gt;i&lt;/sup&gt; , w&lt;sup&gt;i&lt;/sup&gt; , x¯&lt;sup&gt;i&lt;/sup&gt; , w¯&lt;sup&gt;i&lt;/sup&gt; as follows:</p>

    <p class="text-gray-300"><span class="math">$\\bar{x}_i = \\prod_{j=1}^{|\\mathcal{O}|} u_j^{t_{i,j}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\bar{w}_i = \\prod_{j=1}^{|\\mathcal{O}|} u_j^{t&#x27;_{i,j}}</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i = \\prod_{j=1}^{|\\mathcal{O}|} \\ell_j^{t_{i,j}}</span>$</p>

    <p class="text-gray-300"><span class="math">$w_i = \\prod_{j=1}^{|\\mathcal{O}|} \\ell_j^{t&#x27;_{i,j}}</span>$</p>

    <p class="text-gray-300">Note that the per-voter exponent s is no longer used for the specific voter.</p>

    <p class="text-gray-300">We divide the remaining voters into two groups. One group of voters uses f composed with exponentiation for the per-voter receipt code function and generates x&lt;sup&gt;i&lt;/sup&gt; , w&lt;sup&gt;i&lt;/sup&gt; , x¯&lt;sup&gt;i&lt;/sup&gt; , w¯&lt;sup&gt;i&lt;/sup&gt; as in the previous game. The other group uses random functions for the per-voter receipt code function and generates x&lt;sup&gt;i&lt;/sup&gt; , w&lt;sup&gt;i&lt;/sup&gt; , x¯&lt;sup&gt;i&lt;/sup&gt; , w¯&lt;sup&gt;i&lt;/sup&gt; as random group elements.</p>

    <p class="text-gray-300">It is now easy to observe that if there exists some exponent s such that u&lt;sup&gt;i&lt;/sup&gt; = \` s i , i = 1, . . . , |O|, then the computations for the specific voter induce the same probability distributions as for the first group. Otherwise, the induced distributions are as for the second group.</p>

    <p class="text-gray-300">The claim now follows by a straight-forward hybrid argument.</p>

    <p class="text-gray-300">Analysis Observe that in the final game, the encrypted ballots contain no information about the ballots except the (random) receipt codes. Given that the receipt generator must see the receipt codes, it learns no unavoidable information about the submitted ballots.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">5.3 The Decryption Service</h3>

    <p class="text-gray-300">We argue for the following claim for a compromised decryption service:</p>

    <p class="text-gray-300">• The submitted ballots remain confidential, and it is unlikely that the election result is incorrect.</p>

    <p class="text-gray-300">Analysis Suppose the decryption service is compromised. Since encrypted ballots are sent through secure channels (encoded using a fixed-length encoding) and the ballot box shuffles the order of the encrypted ballots before they are sent for decryption, the decryption service learns nothing about which encrypted ballot belongs to which voter, beyond what the list of decrypted ballots will tell it. This ensures confidentiality.</p>

    <p class="text-gray-300">Since correctness of decryption is proved using Fpok , we only need to consider the proof of correctness for the shuffle. We can ignore the shuffling. Again, since we use Fpok to prove that the rerandomization factors over groups are encryptions of the identity, the only relevant issue is the choice of groups. Furthermore, since the different choices of groups are dependent, we should only look at one round to produce an upper bound on the attackers success probability.</p>

    <p class="text-gray-300">The proof now reduces to the following: The decryption service generates n encryptions, the auditor partitions the ciphertexts into groups, and the decryption service proves that for each group, the product of all the ciphertexts is an encryption of the identity.</p>

    <p class="text-gray-300">The decryption service can cheat successfully by not generating encryptions of the identity and then hoping that the verifier chooses the groups such that for each group the product ciphertext is an encryption of the identity.</p>

    <p class="text-gray-300">This is essentially equivalent to the following game:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The attacker selects n = ν &lt;sup&gt;2&lt;/sup&gt; group elements z1, . . . , zn.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier selects a permutation Π on {1, . . . , n}.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The attacker wins if at least one z&lt;sup&gt;i&lt;/sup&gt; 6= 1, and</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i=\\nu j+1}^{\\nu(j+1)} z_{\\Pi(i)}</span>$</p>

    <p class="text-gray-300">holds for 1 ≤ j ≤ ν.</p>

    <p class="text-gray-300">To estimate the attacker's success probability, we need to estimate the number of permutations for which the attacker wins. Intuitively, it seems reasonable that to maximize the number of such permutations, the attacker wants many group elements to be the identity. This implies that the best choice is z&lt;sup&gt;1&lt;/sup&gt; = z −1 2 6= 1, while z&lt;sup&gt;3&lt;/sup&gt; = · · · = z&lt;sup&gt;n&lt;/sup&gt; = 1. The number of permutations that lead to success in this case is the number of permutations that keep z&lt;sup&gt;1&lt;/sup&gt; and z&lt;sup&gt;2&lt;/sup&gt; inside the same arbitrary group, but at arbitrary positions, and moves the other elements arbitrarily, that is</p>

    <p class="text-gray-300"><span class="math">$\\# = \\nu \\cdot \\nu(\\nu - 1) \\cdot (\\nu^2 - 2)!</span>$
.</p>

    <p class="text-gray-300">As a fraction of the total number of permutations, we get</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\nu \\cdot \\nu(\\nu - 1) \\cdot (\\nu^2 - 2)!}{\\nu^2!} = \\frac{\\nu \\cdot \\nu(\\nu - 1)}{\\nu^2(\\nu^2 - 1)} = \\frac{1}{(\\nu + 1)},</span>$</p>

    <p class="text-gray-300">which should be an upper bound on the probability of successful cheating. We note that for 10 000 votes, this gives an attacker a 1/100 chance of manipulating two votes.</p>

    <p class="text-gray-300">It is therefore plausible that minor tampering with ballots could pass undetected, however any significant tampering is quite unlikely. We also note that since the decryption service does not know who submitted which ballots, any tampering will essentially be random.</p>

    <p class="text-gray-300">Remark 20. Note that we cannot make the shuffle proof non-interactive in the usual manner, because of the high probability of manipulation.</p>

    <p class="text-gray-300">Remark 21. If the probability of manipulation is considered too large, one mitigation strategy is to have the decryption service produce a proof that the input ciphertexts contain a permutation of the output decryptions, e.g. like [18] or [12] (we do not need the full verifiable shuffle, just the proof of permutation of known plaintexts). Such a proof could be produced after the initial tally is published, but before the final result is certified.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.4 The Auditor</h3>

    <p class="text-gray-300">As usual, our starting point is the real protocol interacting with a real adversary that has corrupted the auditor. For the final game, we shall argue for the following:</p>

    <p class="text-gray-300">• The submitted ballots remain confidential.</p>

    <p class="text-gray-300">Remark 22. A moderately complicated argument with a simulator based on the final game should suffice to show that our protocol realizes the functionality Fvote in this corruption model. We have not completed that argument.</p>

    <p class="text-gray-300">Game 1 In the first game, one machine M plays the role of every honest player as well as the ideal functionalities. Note that in this game, the machine M knows every decryption key in the system, specifically the machine M knows a1, a&lt;sup&gt;2&lt;/sup&gt; and a3.</p>

    <p class="text-gray-300">This game is clearly indistinguishable from our starting point.</p>

    <p class="text-gray-300">Game 2 In this game, the machine M provides Fpok with random witnesses. Since the witnesses are never used by Fpok , this game is clearly indistinguishable from the previous game.</p>

    <p class="text-gray-300">Game 3 The machine M knows which cleartext ballot corresponds to which encrypted ballot. In this game, the decryption service uses the cleartext ballots instead of decrypting the ciphertexts. Likewise, the receipt generator never decrypts ciphertexts or generates receipt codes, and the voters never check the receipt codes.</p>

    <p class="text-gray-300">The adversary cannot observe these changes, therefore this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300">Note also that the content of the ciphertexts is no longer used.</p>

    <p class="text-gray-300">Game 4 Instead of using the cleartext ballots when generating the encrypted ballots, we encrypt random group elements.</p>

    <p class="text-gray-300">A straight-forward DDH reduction will show that this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300">Game 5 In the generation of the shuffle proof, the decryption service uses fresh random encryptions in each round instead of rerandomizations.</p>

    <p class="text-gray-300">Again, a straight-forward DDH reduction will show that this game is indistinguishable from the previous game.</p>

    <p class="text-gray-300">Note that at this point, the only information the auditor has about correlations between ciphertexts and decrypted ballots is through the groups in the shuffle proof.</p>

    <p class="text-gray-300">Analysis The ciphertexts seen by the auditor contain no information about the ballots. This means that the only way the auditor can deduce information about the voters' ballots is by correlating ciphertexts with decrypted ballots. As we have seen, the only information it has is through its selection of groups in the shuffle proof.</p>

    <p class="text-gray-300">We argue informally. Suppose that the auditor faces the simplest possible case, he wants to correlate two decrypted ballots (among many) with two ciphertexts. Suppose that groups are selected such the two ciphertexts are in distinct groups in the first round. In the second round every group contains exactly one ciphertext from each first round group. Therefore, the adversary cannot know in which group his ciphertexts are, he has lost track of them. If the adversary chooses groups such that the two ciphertexts are in the same group, they must be in distinct groups in the second round and the adversary will have lost track of them after the third round.</p>

    <p class="text-gray-300">It therefore seems reasonable that confidentiality is preserved, even if the auditor is corrupt.</p>

    <p class="text-gray-300">We have described the cryptographic protocol that will be used in the Norwegian goverment's e-voting experiment in 2011 and analysed its security.</p>

    <p class="text-gray-300">We can summarize our findings for our corruption model as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If a voter uses only honest computers, his final submitted ballot will remain confidential (up to information leaked through receipt codes) and will (with high probability) be counted correctly, or the auditor will complain.</li>
      <li>If the voter uses a compromised computer, but submits only one ballot, if he accepts the ballot as cast, the ballot will (with high probability) be counted correctly, or the auditor will complain.</li>
      <li>Any corrupt infrastructure player may prevent the election from completing. The decryption service and the auditor may do so after seeing the result.</li>
    </ul>

    <p class="text-gray-300">We believe these security properties, while not perfect, constitute a reasonable basis for an e-voting experiment. We stress that there are many other requirements for a secure election system that have not been examined, the most obvious being correct implementation and deployment. Moreover, we have not examined the usability of this system. While we believe many voters will be able to use this system correctly, we do not know how voters in general will interact with the system and consequently which security properties the deployed system will have. This will require further study.</p>

    <p class="text-gray-300">While confidentiality from the receipt generator depends on a new and untested cryptographic assumption, we believe this is justified for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The receipt generator will be quite well protected, and a compromise of this system is quite unlikely.</li>
      <li>A majority of voters submit ballots with exactly one option. For such ballots, the problem facing the corrupt receipt generator is essentially equivalent to Decision Diffie-Hellman with a fixed generator, a well-studied problem.</li>
      <li>While the efficiency gains for mixing and decryption are significant, it is possible to sacrifice these gains to get a less efficient system whose security is based entirely on Decision Diffie-Hellman.</li>
    </ul>

    <p class="text-gray-300">Another part of our security proof pretends that a certain non-interactive proof is extractable, which is not strictly true. We believe this is not a real deficiency, but rather a technical obstacle, and therefore justified.</p>

    <p class="text-gray-300"><strong>Future work</strong> The primary focus of future work should be to study the subprotocols not studied in this paper. Of particular interest are the key generation protocols and the electronic identity protocols.</p>

    <p class="text-gray-300">There are several other ways in which the protocol or its analysis can be extended. First of all, it should be easy to improve performance by more careful use of non-interactice zero knowledge proofs (for instance, the many proofs that  <span class="math">\\{(\\bar{x}_i, \\bar{w}_i)\\}</span>  have been correctly computed could be joined together).</p>

    <p class="text-gray-300">It might be possible to use a variant of ElGamal, where the public key consists of a number of group elements:  <span class="math">y_{1,1}, \\ldots, y_{1,k_{max}}</span> . To encrypt a ballot  <span class="math">v_1, \\ldots, v_{k_{max}}</span> , we choose one random number t and compute the ciphertext as  <span class="math">(g^t, y_{1,1}^t f(v_1), \\ldots, y_{1,k_{max}}^t f(v_{k_{max}})</span> . The proof of knowledge would now involve just one group element. The proofs of correctness could also be significantly improved. This would yield a significant performance improvement.</p>

    <p class="text-gray-300">One possible idea for extending the protocol is to have the voter's computer generate ciphertexts  <span class="math">(\\hat{x}_i, \\hat{w}_i)</span>  for the public key  <span class="math">y_3</span>  and prove that they have the same decryptions as the ciphertexts  <span class="math">(x_i, w_i)</span> . Then the ballot box computes  <span class="math">(\\check{x}, \\check{w})</span>  directly, obviating the need for the secret key  <span class="math">y_2</span>  and the relationship  <span class="math">a_1 + a_2 \\equiv a_3</span> . To prevent the receipt generator from simply decrypting  <span class="math">(\\hat{x}_i, \\hat{w}_i)</span> , the voter's computer must actually submit a commitment to  <span class="math">\\hat{w}_i</span>  as well as an opening that is only seen by the ballot box. Every proof must then work with the commitment, significantly increasing total computational load.</p>

    <p class="text-gray-300">If both the ballot box and the receipt generator are compromised and cooperate, election privacy will still be lost even if the election decryption key is not revealed. The reason is of course that the ballot box and the receipt generator together could decrypt  <span class="math">(\\hat{x}_i, \\hat{w}_i)</span> . However, if the system is only partially compromised (say, the keys and the content of the ballot box leak after the election), it is possible to preserve election privacy if  <span class="math">(\\hat{x}_i, \\hat{w}_i)</span>  and  <span class="math">(\\check{x}_i, \\check{w}_i)</span>  are discarded after use. It is unclear if the modest increase in robustness justifies the cost.</p>

    <p class="text-gray-300">If the public key infrastructure in use provides each voter with a public key encryption functionality, in addition to the identification and signature functionality, it might be possible to move the entire computation of  <span class="math">(\\check{x},\\check{w})</span>  to the voter's computer. This should be safe because the receipt generator applies a secret, pseudo-random function to the decryption to get the receipt codes. In such a scheme, the ballot box might not need any secret keys at all, a significant system simplification. Alternatively (as in Scytl's original proposal), the seed for the secret exponent could be printed on the electoral card and typed in by the voter.</p>

    <p class="text-gray-300">It might also be interesting to study additional corruption scenarios, e.g. allowing the adversary to corrupt both voters and computers in addition to the decryption service or</p>

    <p class="text-gray-300">the auditor. If we relax the security requirements, it might also be interesting to study simultaneous corruption of the ballot box, receipt generator and decryption service. Since voters sign encrypted ballots and the auditor verifies these signatures, it should be hard to insert forged ballots. Furthermore, since the receipt generator provides a signed receipt, it should be possible for voters together with the honest auditor to verify that their vote was counted.</p>

    <p class="text-gray-300">The author has had useful discussions about this analysis with Kjell Jørgen Hole, the people at Scytl, Helger Lipmaa in Trondheim, February 2010, Filip van Laenen, David Wagner, Mariana Raykova and Berry Schoenmakers, as well as many others.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] Dan Boneh and Philippe Golle. Almost entirely correct mixing with applications to voting. In Vijayalakshmi Atluri, editor, ACM Conference on Computer and Communications Security, pages 68–77. ACM, 2002.</p></li>
      <li><p class="text-gray-300">[2] e-voting security study. CESG, United Kingdom, July 2002. Issue 1.2.</p></li>
      <li><p class="text-gray-300">[3] David Chaum. Untraceable electronic mail, return addresses, and digital pseudonyms. Commun. ACM, 24(2):84–88, 1981.</p></li>
      <li><p class="text-gray-300">[4] David Chaum. Surevote. www.surevote.com, 2000.</p></li>
      <li><p class="text-gray-300">[5] David Chaum. Secret-ballot receipts: True voter-verifiable elections. IEEE Security &amp; Privacy, 2(1):38–47, 2004.</p></li>
      <li><p class="text-gray-300">[6] David Chaum, Peter Y. A. Ryan, and Steve A. Schneider. A practical voter-verifiable election scheme. In Sabrina De Capitani di Vimercati, Paul F. Syverson, and Dieter Gollmann, editors, ESORICS, volume 3679 of Lecture Notes in Computer Science, pages 118–139. Springer, 2005.</p></li>
      <li><p class="text-gray-300">[7] Josh D. Cohen and Michael J. Fischer. A robust and verifiable cryptographically secure election scheme (extended abstract). In Proceedings of 26th Symposium on Foundations of Computer Science, pages 372–382. IEEE, 1985.</p></li>
      <li><p class="text-gray-300">[8] Ronald Cramer, Matthew K. Franklin, Berry Schoenmakers, and Moti Yung. Multiautority secret-ballot elections with linear work. In Ueli M. Maurer, editor, EURO-CRYPT, volume 1070 of Lecture Notes in Computer Science, pages 72–83. Springer, 1996.</p></li>
      <li><p class="text-gray-300">[9] Ivan Damg˚ard, Kasper Dupont, and Michael Østergaard Pedersen. Unclonable group identification. In Serge Vaudenay, editor, EUROCRYPT, volume 4004 of Lecture Notes in Computer Science, pages 555–572. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[10] Marc Fischlin. Communication-efficient non-interactive proofs of knowledge with online extractors. In Victor Shoup, editor, CRYPTO, volume 3621 of Lecture Notes in Computer Science, pages 152–168. Springer, 2005.</p></li>
      <li><p class="text-gray-300">[11] Kristian Gjøsteen. A latency-free election scheme. In Tal Malkin, editor, CT-RSA, volume 4964 of Lecture Notes in Computer Science, pages 425–436. Springer, 2008.</p></li>
      <li><p class="text-gray-300">[12] Jens Groth. A verifiable secret shuffle of homomorphic encryptions. In Yvo Desmedt, editor, Public Key Cryptography, volume 2567 of Lecture Notes in Computer Science, pages 145–160. Springer, 2003.</p></li>
      <li><p class="text-gray-300">[13] Sven Heiberg, Helger Lipmaa, and Filip van Laenen. On achieving e-vote integrity in the presence of malicious trojans. Submission to the Norwegian e-Vote 2011 tender (see also http://eprint.iacr.org/2010/195), August 2009.</p></li>
      <li><p class="text-gray-300">[14] Markus Jakobsson, Ari Juels, and Ronald L. Rivest. Making mix nets robust for electronic voting by randomized partial checking. In Dan Boneh, editor, USENIX Security Symposium, pages 339–353. USENIX, 2002.</p></li>
      <li><p class="text-gray-300">[15] Antoine Joux, Reynald Lercier, David Naccache, and Emmanuel Thom´e. Oracleassisted Static Diffie-Hellman is easier than discrete logarithms. In Matthew G. Parker, editor, IMA Int. Conf., volume 5921 of Lecture Notes in Computer Science, pages 351– 367. Springer, 2009.</p></li>
      <li><p class="text-gray-300">[16] Ari Juels, Dario Catalano, and Markus Jakobsson. Coercion-resistant electronic elections. Cryptology ePrint Archive, Report 2002/165, 2002. http://eprint.iacr. org/.</p></li>
      <li><p class="text-gray-300">[17] Miroslaw Kutylowski and Filip Zag´orski. Verifiable internet voting solving secure platform problem. In Atsuko Miyaji, Hiroaki Kikuchi, and Kai Rannenberg, editors, IWSEC, volume 4752 of Lecture Notes in Computer Science, pages 199–213. Springer, 2007.</p></li>
      <li><p class="text-gray-300">[18] C. Andrew Neff. A verifiable secret shuffle and its application to e-voting. In ACM Conference on Computer and Communications Security, pages 116–125, 2001.</p></li>
      <li><p class="text-gray-300">[19] P. Y. A. Ryan and T. Peacock. Prˆet \`a voter: a systems perspective. Technical Report CS-TR No 929, School of Computing Science, Newcastle University, September 2005.</p></li>
      <li><p class="text-gray-300">[20] Kazue Sako and Joe Kilian. Receipt-free mix-type voting scheme a practical solution to the implementation of a voting booth. In Louis C. Guillou and Jean-Jacques</p></li>
    </ul>

    <p class="text-gray-300">Quisquater, editors, EUROCRYPT, volume 921 of Lecture Notes in Computer Science, pages 393–403. Springer, 1995.</p>

`;
---

<BaseLayout title="Analysis of an internet voting protocol (2010/380)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/380
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="analysis-of-an-internet-voting-protocol-2010" />
  </article>
</BaseLayout>
