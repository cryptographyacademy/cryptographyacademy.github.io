---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1530';
---

<BaseLayout title="Multivariate lookups based on logarithmic derivatives (2022/1530)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Multivariate lookups based on logarithmic derivatives
      </h1>
      <p class="text-gray-400 mb-2">
        Ulrich Hab&ouml;ck
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; Orbis Labs, Polygon Zero &middot;
        eprint 2022/1530
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                The Lagrange kernel of the boolean hypercube</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">The formal derivate</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                The logarithmic derivative</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                Lagrange interactive oracle proofs</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">
                The sumcheck protocol</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            Lookups based on the logarithmic derivative</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">The protocol</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">Soundness</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">
                Computational cost and optimal sum size</a>
            </li>
            <li>
              <a href="#sec-3.4"
                class="hover:text-white">
                Vector-valued lookups</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Multivariate Plookup</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Batch-column Plookup</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Computational cost and optimal product size</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Bounded multiplicity encoding</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Comparison</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#appendix-a"
            class="hover:text-white">
            Appendix A: The flookup proof of radical</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        Logarithmic derivatives translate products of linear factors
        into sums of their reciprocals, turning zeroes into simple
        poles of same multiplicity. Based on this simple fact, we
        construct an interactive oracle proof for lookups over the
        boolean hypercube, which makes use of a single multiplicity
        function instead of working with a rearranged union of table
        and witnesses, as Plookup [GW20] does. For single-column
        lookups the performance is comparable to Plookup, taken to the
        multivariate setting by Hyperplonk+ [CBBZ22]. However, the
        real power of our argument unfolds in the case of
        &ldquo;batch-column&rdquo; lookups, where multiple columns are
        subject to the same table lookup: While the number of field
        operations is comparable to the Plookup strategy, the oracles
        provided by our prover are significantly fewer. For example,
        given <span class="math">M = 20</span> columns of length
        between <span class="math">2^&#123;12&#125;</span> and
        <span class="math">2^&#123;18&#125;</span>, and assuming a
        commitment scheme over an elliptic curve with a 256 bit large
        base field, our paper-pencil operation counts indicate that
        the logarithmic derivative lookup is more than 3.9 times
        faster.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> lookup arguments, logarithmic
        derivatives, sumcheck protocol, multivariate polynomials,
        zero-knowledge proofs
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        Lookup arguments prove a sequence of values being member of
        an, often prediscribed, table. They are an essential tool for
        improving the efficiency of arguments for statements which are
        otherwise quite expensive to arithmetize. Main applications
        are (1) lookups for relations of high algebraic complexity,
        and (2) lookups for interval ranges, the latter of which are
        extensively used by zero-knowledge virtual machines. Although
        closely related to permutation (or shuffle) arguments [BG12],
        a first explicit occurence of lookups dates back to the Arya
        paper [BCG+18], to the best of our knowledge. While their
        argument handles multiplicities directly in a quite costly
        manner, Plookup [GW20] greatly improved over [BCG+18] using a
        rather geometric approach. Since then Plookup (and variants of
        it) is the general purpose lookup argument used in practical
        applications.
      </p>
      <p class="text-gray-300">
        In this paper we describe a lookup argument which is based on
        logarithmic derivatives. As in classical calculus, the formal
        logarithmic derivative turns products
        <span class="math">\prod_&#123;i=1&#125;^&#123;N&#125;
        (X - z_i)</span> into sums of their reciprocals,
      </p>
      <div class="math-block">
        \sum_&#123;i=1&#125;^&#123;N&#125;
        \frac&#123;1&#125;&#123;X - z_i&#125;,
      </div>
      <p class="text-gray-300">
        having poles with the same multiplicity as the zeros of the
        product. Working with poles instead of zeros is extremely
        useful for lookup arguments. While the treatment of
        multiplicities is quite indirect and therefore costly in the
        product approach [BCG+18, GW20], it turns straight-forward
        when using logarithmic derivatives: Given a sequence of field
        elements <span class="math">(a_i)_&#123;i=1&#125;^N</span>
        and another sequence
        <span class="math">(t_j)_&#123;j=1&#125;^M</span>, then
        <span class="math">\&#123;a_i: i=1,\ldots,N\&#125;
        \subseteq \&#123;t_j: j=1,\ldots,M\&#125;</span> as sets, if
        and only if there exists a sequence of field elements
        <span class="math">(m_j)_&#123;j=1&#125;^M</span> (the
        multiplicities) such that
      </p>
      <div class="math-block">
        \sum_&#123;i=1&#125;^&#123;N&#125;
        \frac&#123;1&#125;&#123;X - a_i&#125; =
        \sum_&#123;j=1&#125;^&#123;M&#125;
        \frac&#123;m_j&#125;&#123;X - t_j&#125;.
      </div>
      <p class="text-gray-300">
        (This holds under quite mild conditions on the field, see
        Lemma 5 for details.) Based on this fractional identity we
        construct a lookup argument which is more efficient than
        Plookup, which argues via a sorted union of witness and table
        sequence. This is particularly true in the case of
        <em>batch-column</em> lookups, where several sequences
        (&ldquo;columns&rdquo;) are subject to the same table lookup,
        a situation that often arises in zero-knowledge virtual
        machines, enforcing execution trace elements being valid
        machine words.
      </p>
      <p class="text-gray-300">
        The paper also notes that Bulletproof++ [Eag22] already uses
        logarithmic derivatives for range proofs, and concurrently,
        Flookup [GK22] describes an oracle proof for the radical of a
        witness sequence which is almost identical to the logarithmic
        derivative approach. Logarithmic derivatives are also directly
        used in large-table lookups, yielding the currently most
        efficient argument Cached Quotients [EFG22].
      </p>
      <p class="text-gray-300">
        The document focuses on batch-column lookups in the
        multivariate setting. Section 2 gathers the preliminaries:
        the Lagrange kernel over the boolean hypercube, the formal
        logarithmic derivative, and the multivariate sumcheck
        argument. Section 3 describes the lookup argument based on
        the logarithmic derivative. Section 4 outlines batch-column
        lookups using the Plookup strategy for comparison, and
        Section 5 provides the comparison.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>

      <!-- 2.1 -->
      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 The Lagrange kernel of the boolean hypercube
      </h3>
      <p class="text-gray-300">
        Let <span class="math">\mathbb&#123;F&#125;</span> denote a
        finite field, and
        <span class="math">\mathbb&#123;F&#125;^*</span> its
        multiplicative group. Throughout the document we regard the
        boolean hypercube
        <span class="math">H = \&#123;\pm 1\&#125;^n</span> as a
        multiplicative subgroup of
        <span class="math">(\mathbb&#123;F&#125;^*)^n</span>. The
        Lagrange kernel of
        <span class="math">H</span> is the multilinear polynomial
      </p>
      <div class="math-block">
        L_H(\vec&#123;X&#125;, \vec&#123;Y&#125;) =
        \frac&#123;1&#125;&#123;2^n&#125; \cdot
        \prod_&#123;j=1&#125;^n (1 + X_j \cdot Y_j).
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">p(\vec&#123;X&#125;)</span> be the
            unique multilinear extension of
            <span class="math">f: H \to \mathbb&#123;F&#125;</span>.
            Then for every
            <span class="math">\vec&#123;y&#125; \in
            \mathbb&#123;F&#125;^n</span>,
          </p>
          <div class="math-block">
            \langle f, L_H(\cdot, \vec&#123;y&#125;) \rangle_H =
            \sum_&#123;\vec&#123;x&#125; \in H&#125;
            f(\vec&#123;x&#125;) \cdot
            L_H(\vec&#123;x&#125;, \vec&#123;y&#125;) =
            p(\vec&#123;y&#125;).
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Since
        <span class="math">p(\vec&#123;y&#125;) =
        \sum_&#123;\vec&#123;z&#125; \in H&#125;
        f(\vec&#123;z&#125;) \cdot
        L_H(\vec&#123;X&#125;, \vec&#123;z&#125;)</span>, it suffices
        to show the claim for
        <span class="math">p(\vec&#123;X&#125;) =
        L_H(\vec&#123;X&#125;, \vec&#123;z&#125;)</span>, with
        <span class="math">\vec&#123;z&#125; \in H</span>. By the
        property of the Lagrange kernel we have
        <span class="math">\langle L_H(\cdot, \vec&#123;z&#125;),
        L_H(\cdot, \vec&#123;y&#125;) \rangle_H =
        L_H(\vec&#123;y&#125;, \vec&#123;z&#125;)</span>, which by
        symmetry equals
        <span class="math">L_H(\vec&#123;X&#125;,
        \vec&#123;y&#125;)</span> at
        <span class="math">\vec&#123;X&#125; =
        \vec&#123;z&#125;</span>.
      </p>

      <p class="text-gray-300">
        For any
        <span class="math">\vec&#123;y&#125; \in
        \mathbb&#123;F&#125;^n</span>, the domain evaluation of
        <span class="math">L_H(\vec&#123;X&#125;,
        \vec&#123;y&#125;)</span> over
        <span class="math">H</span> can be computed in
        <span class="math">\mathcal&#123;O&#125;(|H|)</span> field
        operations, by recursively computing partial products. Each
        recursion step costs
        <span class="math">|H_&#123;k-1&#125;|</span> field
        multiplications and the same number of additions, yielding
        overall cost bounded by
        <span class="math">|H| \cdot (\mathsf&#123;M&#125; +
        \mathsf&#123;A&#125;)</span>.
      </p>

      <!-- 2.2 -->
      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 The formal derivate
      </h3>
      <p class="text-gray-300">
        Given a univariate polynomial
        <span class="math">p(X) = \sum_&#123;k=0&#125;^&#123;d&#125;
        c_k \cdot X^k</span> over a general (possibly infinite) field
        <span class="math">\mathbb&#123;F&#125;</span>, its
        derivative is defined as
      </p>
      <div class="math-block">
        p'(X) := \sum_&#123;k=1&#125;^&#123;d&#125; k \cdot c_k
        \cdot X^&#123;k-1&#125;.
      </div>
      <p class="text-gray-300">
        As in calculus, the derivative is linear and satisfies the
        product rule. For a function
        <span class="math">\frac&#123;p(X)&#125;&#123;q(X)&#125;</span>
        from the rational function field
        <span class="math">\mathbb&#123;F&#125;(X)</span>, the
        derivative is the rational function
      </p>
      <div class="math-block">
        \left(\frac&#123;p(X)&#125;&#123;q(X)&#125;\right)' :=
        \frac&#123;p'(X) \cdot q(X) - p(X) \cdot
        q'(X)&#125;&#123;q(X)^2&#125;.
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 2</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">\mathbb&#123;F&#125;</span> be a
            field of characteristic
            <span class="math">p \neq 0</span>, and
            <span class="math">\frac&#123;p(X)&#125;&#123;q(X)&#125;</span>
            a rational function over
            <span class="math">\mathbb&#123;F&#125;</span> with both
            <span class="math">\deg p(X) &lt; p</span> and
            <span class="math">\deg q(X) &lt; p</span>. If the
            formal derivative
            <span class="math">\left(\frac&#123;p(X)&#125;&#123;q(X)&#125;\right)' = 0</span>,
            then
            <span class="math">\frac&#123;p(X)&#125;&#123;q(X)&#125; = c</span>
            for some constant
            <span class="math">c \in \mathbb&#123;F&#125;</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> If
        <span class="math">q(X)</span> is a constant, then the
        assertion follows from the corresponding statement for
        polynomials. Assuming
        <span class="math">\deg q(X) &gt; 0</span>, polynomial
        division gives
        <span class="math">\frac&#123;p(X)&#125;&#123;q(X)&#125; =
        m(X) + \frac&#123;r(X)&#125;&#123;q(X)&#125;</span>.
        By linearity we obtain
      </p>
      <div class="math-block">
        r'(X) \cdot q(X) - r(X) \cdot q'(X) = -m'(X) \cdot q(X)^2.
      </div>
      <p class="text-gray-300">
        Comparing degrees, we conclude
        <span class="math">m'(X) = 0</span>, and since
        <span class="math">\deg m(X) &lt; p</span> we have
        <span class="math">m(X) = c</span> for some constant. If
        <span class="math">r(X) \neq 0</span> the leading term of
        the left hand side would not vanish, so
        <span class="math">r(X) = 0</span>.
      </p>

      <!-- 2.3 -->
      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 The logarithmic derivative
      </h3>
      <p class="text-gray-300">
        The logarithmic derivative of a polynomial
        <span class="math">p(X)</span> over a (general) field
        <span class="math">\mathbb&#123;F&#125;</span> is the
        rational function
        <span class="math">\frac&#123;p'(X)&#125;&#123;p(X)&#125;</span>.
        The logarithmic derivative of a product
        <span class="math">p_1(X) \cdot p_2(X)</span> equals the sum
        of their logarithmic derivatives, since by the product rule
      </p>
      <div class="math-block">
        \frac&#123;(p_1(X) \cdot p_2(X))'&#125;&#123;p_1(X) \cdot
        p_2(X)&#125; =
        \frac&#123;p_1'(X)&#125;&#123;p_1(X)&#125; +
        \frac&#123;p_2'(X)&#125;&#123;p_2(X)&#125;.
      </div>
      <p class="text-gray-300">
        In particular the logarithmic derivative of a product
        <span class="math">p(X) = \prod_&#123;i=1&#125;^&#123;n&#125;
        (X + z_i)</span> is equal to the sum
      </p>
      <div class="math-block">
        \frac&#123;p'(X)&#125;&#123;p(X)&#125; =
        \sum_&#123;i=1&#125;^&#123;n&#125;
        \frac&#123;1&#125;&#123;X + z_i&#125;.
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 3</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">(a_i)_&#123;i=1&#125;^n</span> and
            <span class="math">(b_i)_&#123;i=1&#125;^n</span> be
            sequences over a field
            <span class="math">\mathbb&#123;F&#125;</span> with
            characteristic
            <span class="math">p &gt; n</span>. Then
            <span class="math">\prod_&#123;i=1&#125;^n (X + a_i) =
            \prod_&#123;i=1&#125;^n (X + b_i)</span> in
            <span class="math">\mathbb&#123;F&#125;[X]</span> if and
            only if
          </p>
          <div class="math-block">
            \sum_&#123;i=1&#125;^&#123;n&#125;
            \frac&#123;1&#125;&#123;X + a_i&#125; =
            \sum_&#123;i=1&#125;^&#123;n&#125;
            \frac&#123;1&#125;&#123;X + b_i&#125;
          </div>
          <p class="text-gray-300">
            in the rational function field
            <span class="math">\mathbb&#123;F&#125;(X)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> If
        <span class="math">p_a(X) = \prod_&#123;i=1&#125;^n
        (X + a_i)</span> and
        <span class="math">p_b(X) = \prod_&#123;i=1&#125;^n
        (X + b_i)</span> coincide, so do their logarithmic
        derivatives. For the converse, assume
        <span class="math">\frac&#123;p_a'(X)&#125;&#123;p_a(X)&#125;
        = \frac&#123;p_b'(X)&#125;&#123;p_b(X)&#125;</span>. Then
        <span class="math">\left(\frac&#123;p_a(X)&#125;&#123;p_b(X)&#125;\right)'
        = 0</span>. By Lemma 2,
        <span class="math">\frac&#123;p_a(X)&#125;&#123;p_b(X)&#125;
        = c</span> for some constant. Since both polynomials are
        monic, <span class="math">c = 1</span>.
      </p>

      <p class="text-gray-300">
        <strong>Remark 1.</strong> Lemma 3 also applies when
        <span class="math">\mathbb&#123;F&#125;</span> is the
        function field
        <span class="math">\mathbb&#123;F&#125;_p(Y_1, \ldots,
        Y_k)</span> over a finite field
        <span class="math">\mathbb&#123;F&#125;_p</span>. This
        observation is useful when generalizing the permutation
        argument to the case where
        <span class="math">a_i</span> and
        <span class="math">b_i</span> are multilinear polynomials.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 4</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">\mathbb&#123;F&#125;</span> be an
            arbitrary field and
            <span class="math">m_1, m_2 :
            \mathbb&#123;F&#125; \to \mathbb&#123;F&#125;</span> any
            functions. Then
            <span class="math">\sum_&#123;z \in
            \mathbb&#123;F&#125;&#125;
            \frac&#123;m_1(z)&#125;&#123;X - z&#125; =
            \sum_&#123;z \in \mathbb&#123;F&#125;&#125;
            \frac&#123;m_2(z)&#125;&#123;X - z&#125;</span> in the
            rational function field
            <span class="math">\mathbb&#123;F&#125;(X)</span>, if
            and only if
            <span class="math">m_1(z) = m_2(z)</span> for every
            <span class="math">z \in \mathbb&#123;F&#125;</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Suppose the fractional decompositions are
        equal. Then
        <span class="math">\sum_&#123;z \in
        \mathbb&#123;F&#125;&#125;
        \frac&#123;m_1(z) - m_2(z)&#125;&#123;X - z&#125; = 0</span>,
        and therefore
      </p>
      <div class="math-block">
        p(X) = \prod_&#123;w \in \mathbb&#123;F&#125;&#125;
        (X - w) \cdot \sum_&#123;z \in \mathbb&#123;F&#125;&#125;
        \frac&#123;m_1(z) - m_2(z)&#125;&#123;X - z&#125; = 0.
      </div>
      <p class="text-gray-300">
        In particular,
        <span class="math">p(z) = (m_1(z) - m_2(z)) \cdot
        \prod_&#123;w \in \mathbb&#123;F&#125; \setminus
        \&#123;z\&#125;&#125; (z - w) = 0</span> for every
        <span class="math">z \in \mathbb&#123;F&#125;</span>. Since
        <span class="math">\prod_&#123;w \in
        \mathbb&#123;F&#125; \setminus \&#123;z\&#125;&#125;
        (z - w) \neq 0</span>, we must have
        <span class="math">m_1(z) = m_2(z)</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 5 (Set inclusion)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">\mathbb&#123;F&#125;</span> be a
            field of characteristic
            <span class="math">p &gt; N</span>, and suppose that
            <span class="math">(a_i)_&#123;i=1&#125;^N</span>,
            <span class="math">(b_i)_&#123;i=1&#125;^N</span> are
            arbitrary sequences of field elements. Then
            <span class="math">\&#123;a_i\&#125; \subseteq
            \&#123;b_i\&#125;</span> as sets (with multiples of values
            removed), if and only if there exists a sequence
            <span class="math">(m_i)_&#123;i=1&#125;^N</span> of
            field elements from
            <span class="math">\mathbb&#123;F&#125;_q \subseteq
            \mathbb&#123;F&#125;</span> such that
          </p>
          <div class="math-block">
            \sum_&#123;i=1&#125;^&#123;N&#125;
            \frac&#123;1&#125;&#123;X + a_i&#125; =
            \sum_&#123;i=1&#125;^&#123;N&#125;
            \frac&#123;m_i&#125;&#123;X + b_i&#125;
          </div>
          <p class="text-gray-300">
            in the function field
            <span class="math">\mathbb&#123;F&#125;(X)</span>.
            Moreover, we have equality of the sets
            <span class="math">\&#123;a_i\&#125; =
            \&#123;b_i\&#125;</span>, if and only if
            <span class="math">m_i \neq 0</span> for every
            <span class="math">i = 1, \ldots, N</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Suppose
        <span class="math">\&#123;a_i\&#125; \subseteq
        \&#123;b_i\&#125;</span>. Set the
        <span class="math">(m_i)</span> as the normalized
        multiplicities
        <span class="math">m_i =
        \frac&#123;m_a(b_i)&#125;&#123;m_b(b_i)&#125;</span>. This
        choice obviously satisfies the identity. Conversely, if the
        identity holds, collecting fractions with the same denominator
        and applying Lemma 4 shows that each
        <span class="math">z \in \&#123;a_i\&#125;</span> must occur
        in <span class="math">\&#123;b_i\&#125;</span>.
      </p>

      <!-- 2.4 -->
      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 Lagrange interactive oracle proofs
      </h3>
      <p class="text-gray-300">
        A <em>Lagrange interactive oracle proof</em>
        (<em>Lagrange IOP</em>) over the boolean hypercube
        <span class="math">H = \&#123;\pm 1\&#125;^n</span> is an
        interactive protocol between a prover and a verifier. In each
        round, the verifier sends a message (typically a random
        challenge) and the prover computes one or several functions
        over the boolean hypercube, and gives the verifier oracle
        access to them. The verifier is allowed to query the oracles
        for their inner products with the Lagrange kernel
        <span class="math">L_H(\cdot, \vec&#123;y&#125;)</span>
        associated with an arbitrary vector
        <span class="math">\vec&#123;y&#125; \in
        \mathbb&#123;F&#125;^n</span>.
      </p>
      <p class="text-gray-300">
        Lagrange IOPs are turned into arguments by instantiating the
        Lagrange oracles by a <em>Lagrange commitment scheme</em>.
        This includes inner product arguments [BCC+16] and the
        multilinear variant [PST13] of the [KZG10] commitment scheme.
      </p>

      <!-- 2.5 -->
      <h3 id="sec-2.5" class="text-xl font-semibold mt-8 mb-3">
        2.5 The sumcheck protocol
      </h3>
      <p class="text-gray-300">
        Given a multivariate polynomial
        <span class="math">p(X_1, \ldots, X_n) \in
        \mathbb&#123;F&#125;[X_1, \ldots, X_n]</span>, a prover
        wants to convince a verifier that
      </p>
      <div class="math-block">
        s = \sum_&#123;(x_1, \ldots, x_n) \in
        \&#123;\pm 1\&#125;^n&#125; p(x_1, \ldots, x_n).
      </div>
      <p class="text-gray-300">
        This is done by a random folding procedure which stepwise
        reduces a claim on the sum over
        <span class="math">H^i = \&#123;\pm 1\&#125;^&#123;n-i&#125;</span>
        to one over a hypercube of half the size. Eventually, one ends
        up with a claim over a single-point sum, which is the value of
        <span class="math">p</span> at a random point
        <span class="math">(r_1, \ldots, r_n) \in
        \mathbb&#123;F&#125;^n</span>.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Protocol 1 (Sumcheck protocol)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">p(X_1, \ldots, X_n)</span> be a
            multivariate polynomial over a finite field
            <span class="math">\mathbb&#123;F&#125;</span>. The
            sumcheck protocol for the sum
            <span class="math">s = \sum_&#123;(x_1, \ldots, x_n)
            \in \&#123;\pm 1\&#125;^n&#125;
            p(x_1, \ldots, x_n)</span> is as follows:
          </p>
          <ul class="list-disc list-inside text-gray-300 mt-2
            space-y-2">
            <li>
              In each round
              <span class="math">i = 1, \ldots, n</span>, the prover
              sends the coefficients of the univariate polynomial
              <div class="math-block">
                s_i(X) = \sum_&#123;(x_&#123;i+1&#125;, \ldots,
                x_n) \in \&#123;\pm 1\&#125;^&#123;n-i&#125;&#125;
                p(r_1, \ldots, r_&#123;i-1&#125;, X,
                x_&#123;i+1&#125;, \ldots, x_n),
              </div>
              and the verifier checks whether
              <span class="math">s_&#123;i-1&#125;(r_&#123;i-1&#125;)
              = s_i(+1) + s_i(-1)</span>. If so, the verifier
              samples random challenge
              <span class="math">r_i \leftarrow_\$
              \mathbb&#123;F&#125;</span>.
            </li>
            <li>
              After these rounds the verifier checks that
              <span class="math">s_n(r_n) = p(r_1, \ldots,
              r_n)</span>.
            </li>
          </ul>
        </div>
      </div>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 2 (Sumcheck soundness)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The sumcheck protocol (Protocol 1) has soundness error
          </p>
          <div class="math-block">
            \varepsilon_&#123;\text&#123;sumcheck&#125;&#125; \le
            \frac&#123;1&#125;&#123;|\mathbb&#123;F&#125;|&#125;
            \cdot \sum_&#123;i=1&#125;^&#123;n&#125;
            \deg_&#123;X_i&#125; p(X_1, \ldots, X_n).
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        The sumcheck protocol is easily extended to a batch of
        polynomials
        <span class="math">p_i(X_1, \ldots, X_n)</span> by sampling
        a random linear combination. The soundness error increases
        only slightly.
      </p>

      <p class="text-gray-300">
        <strong>Computational cost.</strong> For the case that
        <span class="math">p(\vec&#123;X&#125;) =
        Q(w_1(\vec&#123;X&#125;), \ldots,
        w_\nu(\vec&#123;X&#125;))</span> with each
        <span class="math">w_i</span> multilinear and
        <span class="math">Q</span> having absolute degree
        <span class="math">d</span>, the overall prover cost is
        bounded by the simplified formula
      </p>
      <div class="math-block">
        |H| \cdot (d+1) \cdot ((\nu + |Q|_&#123;\mathsf&#123;M&#125;&#125;)
        \cdot \mathsf&#123;M&#125; + (\nu +
        |Q|_&#123;\mathsf&#123;A&#125;&#125;) \cdot
        \mathsf&#123;A&#125;).
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 3. LOOKUPS BASED ON THE LOGARITHMIC DERIVATIVE               -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Lookups based on the logarithmic derivative
      </h2>
      <p class="text-gray-300">
        Assume that <span class="math">\mathbb&#123;F&#125;</span> is
        a finite field, and that
        <span class="math">f_1, \ldots, f_M</span> and
        <span class="math">t: H \to \mathbb&#123;F&#125;</span> are
        functions over the Boolean hypercube
        <span class="math">H = \&#123;\pm 1\&#125;^n</span>. By
        Lemma 5, it holds that
        <span class="math">\bigcup_&#123;i=1&#125;^M
        \&#123;f_i(\vec&#123;x&#125;)\&#125;_&#123;\vec&#123;x&#125;
        \in H&#125; \subseteq
        \&#123;t(\vec&#123;x&#125;)\&#125;_&#123;\vec&#123;x&#125;
        \in H&#125;</span> as sets, if and only if there exists a
        function
        <span class="math">m: H \to \mathbb&#123;F&#125;</span> such
        that
      </p>
      <div class="math-block">
        \sum_&#123;\vec&#123;x&#125; \in H&#125;
        \sum_&#123;i=1&#125;^&#123;M&#125;
        \frac&#123;1&#125;&#123;X + f_i(\vec&#123;x&#125;)&#125; =
        \sum_&#123;\vec&#123;x&#125; \in H&#125;
        \frac&#123;m(\vec&#123;x&#125;)&#125;&#123;X +
        t(\vec&#123;x&#125;)&#125;,
      </div>
      <p class="text-gray-300">
        assuming the characteristic of
        <span class="math">\mathbb&#123;F&#125;</span> is larger than
        <span class="math">M</span> times the size of the hypercube.
        If <span class="math">t</span> is injective, then
        <span class="math">m</span> is the multiplicity function,
        counting the number of occurrences for each value. Otherwise,
        the normalized multiplicity function is defined as
      </p>
      <div class="math-block">
        m(\vec&#123;x&#125;) =
        \frac&#123;m_f(t(\vec&#123;x&#125;))&#125;&#123;m_t(t(\vec&#123;x&#125;))&#125;
        = \frac&#123;\sum_&#123;i=1&#125;^M
        |\&#123;\vec&#123;y&#125; \in H : f_i(\vec&#123;y&#125;) =
        t(\vec&#123;x&#125;)\&#125;|&#125;&#123;|\&#123;\vec&#123;y&#125;
        \in H : t(\vec&#123;y&#125;) =
        t(\vec&#123;x&#125;)\&#125;|&#125;.
      </div>

      <p class="text-gray-300">
        Given a random challenge
        <span class="math">x \leftarrow \mathbb&#123;F&#125;</span>
        from the verifier, the prover shows the rational identity
        holds at <span class="math">X = x</span>. To apply the
        sumcheck protocol, the fractional expression must be turned
        into a polynomial one. The prover splits the sum into partial
        sums of roughly the same number of terms
        <span class="math">\ell</span>, and provides multilinear
        helper functions for each sum, subject to domain identities of
        algebraic degree essentially equal to the number of reciprocal
        terms.
      </p>

      <!-- 3.1 -->
      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 The protocol
      </h3>
      <p class="text-gray-300">
        Let <span class="math">\ell</span> be the chosen sum size,
        <span class="math">[0, M] =
        \bigcup_&#123;k=1&#125;^&#123;K&#125; I_k</span> the
        decomposition into
        <span class="math">K = \lceil
        \frac&#123;M+1&#125;&#123;\ell&#125; \rceil</span>
        subintervals. Let
      </p>
      <div class="math-block">
        h_k(\vec&#123;x&#125;) = \sum_&#123;i \in I_k&#125;
        \frac&#123;m_i(\vec&#123;x&#125;)&#125;&#123;\varphi_i(\vec&#123;x&#125;)&#125;,
        \quad k = 1, \ldots, K,
      </div>
      <p class="text-gray-300">
        be the respective partial sums, where
        <span class="math">m_0(\vec&#123;x&#125;) =
        m(\vec&#123;x&#125;)</span>,
        <span class="math">\varphi_0(\vec&#123;x&#125;) = x +
        t(\vec&#123;x&#125;)</span>,
        <span class="math">m_i(\vec&#123;x&#125;) = -1</span>, and
        <span class="math">\varphi_i(\vec&#123;x&#125;) = x +
        f_i(\vec&#123;x&#125;)</span> for
        <span class="math">i = 1, \ldots, M</span>.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Protocol 2 (Batch-column lookup)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">M</span> be an integer, and
            <span class="math">\mathbb&#123;F&#125;</span> a finite
            field with characteristic
            <span class="math">p &gt; M \cdot 2^n</span>. Fix any
            integer <span class="math">\ell</span>,
            <span class="math">1 \le \ell \le M + 1</span>, and let
            <span class="math">K = \lceil
            \frac&#123;M+1&#125;&#123;\ell&#125; \rceil</span>.
            Given any functions
            <span class="math">f_1, \ldots, f_M, t : H \to
            \mathbb&#123;F&#125;</span>, the Lagrange IOP for
            <span class="math">\bigcup_&#123;i=1&#125;^M
            \&#123;f_i(\vec&#123;x&#125;) : \vec&#123;x&#125; \in
            H\&#125; \subseteq \&#123;t(\vec&#123;x&#125;) :
            \vec&#123;x&#125; \in H\&#125;</span> is as follows:
          </p>
          <ol class="list-decimal list-inside text-gray-300 mt-2
            space-y-2">
            <li>
              The prover determines the (normalized) multiplicity
              function
              <span class="math">m : H \to
              \mathbb&#123;F&#125;</span> and sends the oracle for
              <span class="math">m</span> to the verifier. The
              verifier answers with a random sample
              <span class="math">x \leftarrow_\$
              \mathbb&#123;F&#125; \setminus
              \&#123;-t(\vec&#123;x&#125;) : \vec&#123;x&#125; \in
              H\&#125;</span>.
            </li>
            <li>
              Given the challenge <span class="math">x</span>,
              the prover computes the values over
              <span class="math">H</span> for the partial sums
              <span class="math">h_1(\vec&#123;x&#125;), \ldots,
              h_K(\vec&#123;x&#125;)</span> and sends their oracles
              to the verifier.
            </li>
            <li>
              The verifier responds with a random vector
              <span class="math">\vec&#123;z&#125; \leftarrow_\$
              \mathbb&#123;F&#125;^n</span> and random batching
              scalars
              <span class="math">\lambda_1, \ldots, \lambda_K
              \leftarrow_\$ \mathbb&#123;F&#125;</span>. Both prover
              and verifier engage in the sumcheck protocol for
              <div class="math-block">
                \sum_&#123;\vec&#123;x&#125; \in H&#125;
                Q(L_H(\vec&#123;x&#125;, \vec&#123;z&#125;),
                m(\vec&#123;x&#125;),
                \varphi_0(\vec&#123;x&#125;), \ldots,
                \varphi_M(\vec&#123;x&#125;),
                h_1(\vec&#123;x&#125;), \ldots,
                h_K(\vec&#123;x&#125;)) = 0,
              </div>
              where
              <div class="math-block">
                Q(L, m, \varphi_0, \ldots, \varphi_M,
                h_1, \ldots, h_K) = \sum_&#123;k=1&#125;^K h_k +
                L \cdot \lambda_k \cdot \left( h_k \cdot
                \prod_&#123;i \in I_k&#125; \varphi_i -
                \sum_&#123;i \in I_k&#125; m_i \cdot
                \prod_&#123;j \in I_k \setminus
                \&#123;i\&#125;&#125; \varphi_j \right),
              </div>
              with <span class="math">m_0 = m</span> and all other
              <span class="math">m_i = -1</span>.
            </li>
            <li>
              The verifier queries
              <span class="math">[m], [t], [f_1], \ldots, [f_M],
              [h_1], \ldots, [h_K]</span> for their inner product
              with
              <span class="math">L_H(\cdot,
              \vec&#123;r&#125;)</span>, and checks the expected
              value.
            </li>
          </ol>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Remark 3.</strong> The condition
        <span class="math">x \notin
        \&#123;-t(\vec&#123;x&#125;)\&#125;</span> is imposed for
        completeness. Omitting it gives an overwhelmingly complete
        protocol with completeness error at most
        <span class="math">\frac&#123;|H|&#125;&#123;|\mathbb&#123;F&#125;|&#125;</span>.
        Alternatively, one may modify the domain identity to multiply
        by an extra <span class="math">\varphi_0</span> factor.
      </p>

      <!-- 3.2 -->
      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Soundness
      </h3>
      <p class="text-gray-300">
        The soundness analysis is a straight-forward application of
        the Schwartz-Zippel lemma and the Lagrange-query to
        point-query correspondence stated by Lemma 1. The rational
        identity is turned into a polynomial identity of degree at
        most
        <span class="math">|H| \cdot (M+1) - 1</span> by
        multiplying with the common denominator.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 4 (Soundness)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The interactive oracle proof described in Protocol 2 has
            soundness error
          </p>
          <div class="math-block">
            \varepsilon &lt;
            \frac&#123;(M+1) \cdot |H| - 1&#125;&#123;|\mathbb&#123;F&#125;| - |H|&#125;
            + \frac&#123;K+1&#125;&#123;|\mathbb&#123;F&#125;|&#125;
            + \varepsilon_&#123;\text&#123;sumcheck&#125;&#125;,
          </div>
          <p class="text-gray-300">
            where
            <span class="math">\varepsilon_&#123;\text&#123;sumcheck&#125;&#125;</span>
            is the soundness error of the sumcheck argument over
            <span class="math">H</span> for a multivariate polynomial
            in <span class="math">M+4</span> variables with maximum
            individual degree <span class="math">M+3</span>.
          </p>
        </div>
      </div>

      <!-- 3.3 -->
      <h3 id="sec-3.3" class="text-xl font-semibold mt-8 mb-3">
        3.3 Computational cost and optimal sum size
      </h3>
      <p class="text-gray-300">
        The polynomial <span class="math">Q</span> from Protocol 2
        has <span class="math">\nu = M + K + 3</span> variables and
        absolute degree
        <span class="math">d = \ell + 2</span>. The paper describes
        a domain evaluation strategy using batch inversion. Assuming
        inverses of <span class="math">\varphi_i</span> are given
        (except for one distinct element in each group), the domain
        identity terms in <span class="math">Q</span> can be
        evaluated via fractional representations, yielding evaluation
        costs of
        <span class="math">K \cdot (\ell + 2) \cdot
        \mathsf&#123;M&#125; + K \cdot (\ell + 1) \cdot
        \mathsf&#123;A&#125;</span>.
      </p>
      <p class="text-gray-300">
        The total costs of the oracle prover are:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2">
        <li>
          Arithmetic costs of
          <div class="math-block">
            |H| \cdot (K+5+(\ell+3) \cdot (4 \cdot M + 3 +
            \ell \cdot K)) \cdot \mathsf&#123;M&#125;,
          </div>
          neglecting field additions and subtractions.
        </li>
        <li>
          Oracle costs of
          <div class="math-block">
            K + 1 = \left\lceil
            \frac&#123;M+1&#125;&#123;\ell&#125; \right\rceil + 1
          </div>
          oracles of size <span class="math">|H|</span>.
        </li>
      </ul>

      <p class="text-gray-300">
        <strong>The optimal choice of
        <span class="math">\ell</span>.</strong> If
        <span class="math">\ell = 1</span>, each reciprocal gets a
        helper function, resulting in
        <span class="math">M+1</span> additional commitments but a
        very low degree
        <span class="math">d = 3</span>. Increasing
        <span class="math">\ell</span> reduces commitments but
        increases degree. The most extreme case
        <span class="math">\ell = M+1</span> gives a single
        additional commitment with degree
        <span class="math">d = M+3</span>. The optimal choice depends
        on the polynomial commitment scheme. The paper provides
        benchmark-based estimates using elliptic curve commitments in
        the Pallas curve.
      </p>

      <!-- 3.4 -->
      <h3 id="sec-3.4" class="text-xl font-semibold mt-8 mb-3">
        3.4 Vector-valued lookups
      </h3>
      <p class="text-gray-300">
        Protocol 2 generalizes to functions with multilinear values,
      </p>
      <div class="math-block">
        t(\vec&#123;x&#125;) =
        \sum_&#123;(j_1, \ldots, j_k) \in
        \&#123;0,1\&#125;^k&#125;
        t_&#123;j_1, \ldots, j_k&#125;(\vec&#123;x&#125;) \cdot
        Y_1^&#123;j_1&#125; \cdots Y_k^&#123;j_k&#125;,
      </div>
      <p class="text-gray-300">
        without changing the soundness error bound from Theorem 4.
        Since
        <span class="math">\mathbb&#123;F&#125;[X, Y_1, \ldots,
        Y_k]</span> is a unique factorization domain and the
        polynomials of the form
        <span class="math">X - \sum c_&#123;i_1, \ldots,
        i_k&#125; \cdot Y_1^&#123;i_1&#125; \cdots
        Y_k^&#123;i_k&#125;</span> are irreducible, Lemma 5 applies
        in the rational function field
        <span class="math">\mathbb&#123;F&#125;(X, Y_1, \ldots,
        Y_k)</span>. The only change is that the verifier now samples
        <span class="math">x</span> from
        <span class="math">\mathbb&#123;F&#125;</span> and
        <span class="math">\vec&#123;y&#125; = (y_1, \ldots,
        y_k)</span> from
        <span class="math">\mathbb&#123;F&#125;^k</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. MULTIVARIATE PLOOKUP                                      -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4. Multivariate Plookup</h2>
      <p class="text-gray-300">
        This section sketches batch-column lookups using the Plookup
        strategy and the multivariate time shift introduced by
        Hyperplonk [CBBZ22]. The time shift
        <span class="math">T: H \to H</span> on the boolean hypercube
        <span class="math">H = \&#123;\pm 1\&#125;^n</span> is
        derived from the multiplication by a primitive root in
        <span class="math">\text&#123;GF&#125;(2^n)</span>,
      </p>
      <div class="math-block">
        T(x_1, \ldots, x_n) =
        \frac&#123;1 + x_n&#125;&#123;2&#125; \cdot
        (1, x_1, \ldots, x_&#123;n-1&#125;) +
        \frac&#123;1 - x_n&#125;&#123;2&#125; \cdot
        (-1, (-1)^&#123;1 - c_1&#125; \cdot x_1, \ldots,
        (-1)^&#123;1 - c_&#123;n-1&#125;&#125; \cdot
        x_&#123;n-1&#125;),
      </div>
      <p class="text-gray-300">
        where the
        <span class="math">c_i \in \&#123;0, 1\&#125;</span> are
        coefficients of a primitive polynomial over
        <span class="math">\text&#123;GF&#125;(2)</span>. The time
        shift acts transitively on the punctuated hypercube
        <span class="math">H' = H \setminus
        \&#123;\vec&#123;1&#125;\&#125;</span>.
      </p>

      <!-- 4.1 -->
      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Batch-column Plookup
      </h3>
      <p class="text-gray-300">
        Let <span class="math">t: H' \to
        \mathbb&#123;F&#125;</span> be the lookup table, and
        <span class="math">f_i: H' \to
        \mathbb&#123;F&#125;</span>,
        <span class="math">i = 1, \ldots, M</span>, the functions
        subject to the lookup. The prover provides the ordered union
        via additional functions
        <span class="math">s_i: H' \to
        \mathbb&#123;F&#125;</span>,
        <span class="math">i = 1, \ldots, M+1</span>. The
        <em>Plookup identity</em> is
      </p>
      <div class="math-block">
        \prod_&#123;\vec&#123;x&#125; \in H'&#125;
        \prod_&#123;i=1&#125;^&#123;M&#125; (X +
        s_i(\vec&#123;x&#125;) + s_&#123;i+1&#125;(\vec&#123;x&#125;)
        \cdot Y) \cdot (X + s_&#123;M+1&#125;(\vec&#123;x&#125;) +
        s_1(T(\vec&#123;x&#125;)) \cdot Y)
      </div>
      <div class="math-block">
        = \prod_&#123;\vec&#123;x&#125; \in H'&#125;
        \prod_&#123;i=1&#125;^&#123;M&#125;
        (X + f_i(\vec&#123;x&#125;) + f_i(\vec&#123;x&#125;) \cdot Y)
        \cdot (X + t(\vec&#123;x&#125;) + t(T(\vec&#123;x&#125;))
        \cdot Y).
      </div>
      <p class="text-gray-300">
        The identity is reduced to a grand product over
        <span class="math">H'</span> by random samples
        <span class="math">\alpha, \beta \leftarrow
        \mathbb&#123;F&#125;</span>, yielding
      </p>
      <div class="math-block">
        \prod_&#123;\vec&#123;x&#125; \in H'&#125;
        h(\vec&#123;x&#125;) = 1,
      </div>
      <p class="text-gray-300">
        where
      </p>
      <div class="math-block">
        h(\vec&#123;x&#125;) =
        \frac&#123;\alpha + s_&#123;M+1&#125;(\vec&#123;x&#125;) +
        s_1(T(\vec&#123;x&#125;)) \cdot \beta&#125;&#123;\alpha +
        t(\vec&#123;x&#125;) + t(T(\vec&#123;x&#125;)) \cdot
        \beta&#125; \cdot
        \prod_&#123;i=1&#125;^&#123;M&#125;
        \frac&#123;\alpha + s_i(\vec&#123;x&#125;) +
        s_&#123;i+1&#125;(\vec&#123;x&#125;) \cdot
        \beta&#125;&#123;\alpha + f_i(\vec&#123;x&#125;) +
        f_i(\vec&#123;x&#125;) \cdot \beta&#125;.
      </div>
      <p class="text-gray-300">
        As in Protocol 2, the product is split into
        <span class="math">K = \lceil
        \frac&#123;M+1&#125;&#123;\ell&#125; \rceil</span> partial
        products. For each
        <span class="math">k = 1, \ldots, K</span>, the prover
        computes cumulative products
        <span class="math">\phi_k</span> along the orbit of the time
        shift <span class="math">T</span> on
        <span class="math">H'</span>. Correctness is proven by domain
        identities and point identities, all reduced to sumchecks.
        The resulting sumcheck polynomial <span class="math">Q</span>
        has absolute degree
        <span class="math">d = \ell + 2</span> (same as Protocol 2)
        but about double the variables:
        <span class="math">\nu = 2(M + 1 + K) + 3</span>.
      </p>

      <!-- 4.2 -->
      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Computational cost and optimal product size
      </h3>
      <p class="text-gray-300">
        The total costs of the oracle prover for the Plookup strategy
        are:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2">
        <li>
          Arithmetic costs of
          <div class="math-block">
            |H| \cdot \left( (2\ell^2 + 13\ell + 18) \left\lceil
            \frac&#123;M+1&#125;&#123;\ell&#125; \right\rceil +
            \ell \cdot (2M + 7) + 8(M+3) \right) \cdot
            \mathsf&#123;M&#125;,
          </div>
          neglecting field additions.
        </li>
        <li>
          Oracle costs of
          <div class="math-block">
            M + K + 1 = M + \left\lceil
            \frac&#123;M+1&#125;&#123;\ell&#125; \right\rceil + 1
          </div>
          functions of size <span class="math">|H|</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        The partial product size
        <span class="math">\ell</span> determines the trade-off
        between algebraic degree and the number of commitments. The
        paper provides benchmark-based estimates for the optimal
        choice using multi-scalar multiplication over the Pallas
        curve.
      </p>

      <!-- 4.3 -->
      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 Bounded multiplicity encoding
      </h3>
      <p class="text-gray-300">
        The Polygon MidenVM [Mid] uses an improvement of Plookup that
        reduces the number of commitments for the sorted union by
        arranging it as runs of at most
        <span class="math">B = 2^b</span> occurrences,
        <span class="math">b \ge 1</span>. The length
        <span class="math">m</span> of each run (reduced by one) is
        given bitwise,
      </p>
      <div class="math-block">
        m - 1 = m_0 + m_1 \cdot 2 + \ldots + m_&#123;b-1&#125;
        \cdot 2^&#123;b-1&#125;,
      </div>
      <p class="text-gray-300">
        and the power of the corresponding term
        <span class="math">Z</span> in the lookup product is selected
        by the expression
      </p>
      <div class="math-block">
        V(Z, m_0, \ldots, m_&#123;b-1&#125;) =
        \prod_&#123;j=0&#125;^&#123;b-1&#125;
        (m_j \cdot Z^&#123;2^j&#125; + (1 - m_j) \cdot 1) =
        Z^&#123;m_0 + m_1 \cdot 2 + \ldots + m_&#123;b-1&#125;
        \cdot 2^&#123;b-1&#125;&#125;.
      </div>
      <p class="text-gray-300">
        The commitment costs for
        <span class="math">s</span> are reduced by the factor
        <span class="math">\frac&#123;R \cdot (1 + \log_2
        B)&#125;&#123;M + 1&#125; \approx
        \frac&#123;1 + \log_2 B&#125;&#123;B&#125;</span>, whereas
        the absolute degree of the lookup identity increases only by
        the factor approximately
        <span class="math">1 + \frac&#123;\log_2
        B&#125;&#123;B&#125;</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. COMPARISON                                                -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Comparison</h2>
      <p class="text-gray-300">
        The significant advantage of the logarithmic derivative lookup
        over Plookup is the lower oracle costs. While the Plookup
        strategy demands <span class="math">M+1</span> oracles for
        the sorted union of the
        <span class="math">M</span> witness columns and the table,
        the logarithmic derivative approach demands only a single one
        for the multiplicities. The two strategies are compared by
        their computational cost per column when running with the
        optimal sum/product size
        <span class="math">\ell</span>.
      </p>
      <p class="text-gray-300">
        The paper provides a rough comparison with the bounded
        multiplicity improvement. For a quadratic overall domain
        identity (cubic sumcheck polynomial
        <span class="math">Q</span>):
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2">
        <li>
          The logarithmic derivative approach needs overall
          <span class="math">M+1</span> oracles: one for the
          multiplicity function and
          <span class="math">M</span> helper functions.
        </li>
        <li>
          Plookup demands overall
          <span class="math">2(M+1)</span> oracles:
          <span class="math">M+1</span> for the sorted union and
          <span class="math">M+1</span> for cumulative products.
        </li>
        <li>
          With multiplicity encoding using
          <span class="math">b</span> bits, Plookup improves down
          to
          <span class="math">M + 1 + \lceil
          \frac&#123;M&#125;&#123;2^b&#125; + 1 \rceil \cdot
          3b</span> oracles. In the extreme setting
          <span class="math">2^b = M</span>, this gives
          <span class="math">M + 1 + 6 \log_2(M)</span> oracles.
        </li>
      </ul>
      <p class="text-gray-300">
        Multiplicity encoding seems beneficial only for quite large
        batches of columns. Below
        <span class="math">M = 32</span> columns it performs even
        worse than Plookup. For
        <span class="math">M = 64</span> and
        <span class="math">M = 128</span>, it consumes 78% and 66%
        of Plookup&rsquo;s commitments respectively, which is still
        about 55% and 30% more than the logarithmic derivative
        approach.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        The author would like to thank Rayan Matovu and Morgan Thomas
        for giving me the space and time to dwell on batch-column
        lookups during my employment at Orbis Labs. Special thanks to
        Marcin Bugaj for helping out with the Pippenger benchmarks.
        Furthermore, I would like to thank Ariel Gabizon for his
        feedback and useful discussions.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A: The flookup proof of radical
      </h2>
      <p class="text-gray-300">
        Section 5 of [GK22] describes a polynomial IOP for lookups
        which is almost identical to the logarithmic derivative
        approach. Let
        <span class="math">\mathbb&#123;F&#125;</span> be an
        FFT-friendly finite field, having a multiplicative subgroup
        <span class="math">H = \&#123;x \in \mathbb&#123;F&#125; :
        x^n = 1\&#125;</span> of order
        <span class="math">n</span>, and let
        <span class="math">g</span> be a generator. For showing that
        the ranges of witness functions
        <span class="math">f_i : H \to
        \mathbb&#123;F&#125;</span>,
        <span class="math">i = 0, \ldots, M-1</span>, are contained
        in the range of a table
        <span class="math">t : H \to
        \mathbb&#123;F&#125;</span>, the logarithmic derivative
        identity is turned into the polynomial identity
      </p>
      <div class="math-block">
        \sum_&#123;x \in H&#125;
        \sum_&#123;i=0&#125;^&#123;M-1&#125;
        \frac&#123;v_T(X)&#125;&#123;X + f_i(x)&#125; =
        \sum_&#123;x \in H&#125; m(x) \cdot
        \frac&#123;v_T(X)&#125;&#123;X + t(x)&#125;,
      </div>
      <p class="text-gray-300">
        by multiplying with the precomputed table polynomial
        <span class="math">v_T(X) = \prod_&#123;x \in H&#125;
        (X + t(x))</span>. Instead of the multiplicity function
        <span class="math">m</span>, the prover explicitly provides
        the polynomial
      </p>
      <div class="math-block">
        R_T(X) = \sum_&#123;x \in H&#125; m(x) \cdot
        \frac&#123;v_T(X)&#125;&#123;X - t(x)&#125;,
      </div>
      <p class="text-gray-300">
        and engages in an IOP for showing
      </p>
      <div class="math-block">
        \sum_&#123;x \in H&#125;
        \sum_&#123;i=0&#125;^&#123;M-1&#125;
        \frac&#123;v_T(X)&#125;&#123;X + f_i(x)&#125; = R_T(X).
      </div>
      <p class="text-gray-300">
        The verifier queries
        <span class="math">v_T(X)</span> and
        <span class="math">R_T(X)</span> at a random challenge
        <span class="math">\alpha \leftarrow_\$
        \mathbb&#123;F&#125;</span>, and both parties run a sumcheck
        for
      </p>
      <div class="math-block">
        \sum_&#123;x \in H&#125;
        \sum_&#123;i=0&#125;^&#123;M-1&#125;
        \frac&#123;1&#125;&#123;\varphi_i(x)&#125; =
        \frac&#123;R_T(\alpha)&#125;&#123;v_T(\alpha)&#125;,
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\varphi_i(x) = \alpha +
        f_i(x)</span>. The prover provides the Lagrange
        representation of the sumcheck polynomial
        <span class="math">\phi(X)</span> subject to the domain
        identity
      </p>
      <div class="math-block">
        \left(\phi(g \cdot X) - \phi(X) +
        \frac&#123;R_T(\alpha)&#125;&#123;|H| \cdot
        v_T(\alpha)&#125;\right) \cdot
        \prod_&#123;i=0&#125;^&#123;M-1&#125; \varphi_i(X) =
        \prod_&#123;i=0&#125;^&#123;M-1&#125; \varphi_i(X) \cdot
        \sum_&#123;i=0&#125;^&#123;M-1&#125;
        \frac&#123;1&#125;&#123;\varphi_i(X)&#125;
        \mod v_H(X).
      </div>
      <p class="text-gray-300">
        The overall identity has the form
        <span class="math">Q(\varphi_0(X), \ldots,
        \varphi_&#123;M-1&#125;(X), \phi(X),
        \phi(g \cdot X)) = 0 \mod v_H(X)</span>, with
        <span class="math">Q</span> having
        <span class="math">\nu = M + 2</span> variables and
        absolute degree
        <span class="math">d = M + 1</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-decimal list-inside space-y-2 text-gray-400
        text-sm">
        <li>
          [BCC+16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos,
          Jens Groth, and Christophe Petit. &ldquo;Efficient
          zero-knowledge arguments for arithmetic circuits in the
          discrete log setting.&rdquo; In: <em>EUROCRYPT 2016</em>,
          Vol. 9666 of LNCS. Springer, 2016. Full paper:
          <a
            href="https://eprint.iacr.org/2016/263"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2016/263</a>.
        </li>
        <li>
          [BCG+18] Jonathan Bootle, Andrea Cerulli, Jens Groth,
          Sune Jakobsen, and Mary Maller. &ldquo;Arya: Nearly
          linear-time zero-knowledge proofs for correct program
          execution.&rdquo; In: <em>ASIACRYPT 2018</em>, Vol. 11272
          of LNCS, 2018. Full paper:
          <a
            href="https://eprint.iacr.org/2018/380"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2018/380</a>.
        </li>
        <li>
          [BFS20] Benedikt B&uuml;nz, Ben Fisch, and Alan
          Szepieniec. &ldquo;Transparent SNARKs from DARK
          compilers.&rdquo; In: <em>EUROCRYPT 2020</em>, 2020.
          Full paper:
          <a
            href="https://eprint.iacr.org/2019/1229"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2019/1229</a>.
        </li>
        <li>
          [BG12] Stephanie Bayer and Jens Groth. &ldquo;Efficient
          zero-knowledge argument for correctness of a
          shuffle.&rdquo; In: <em>EUROCRYPT 2012</em>, Vol. 7237
          of LNCS. Springer, 2012.
        </li>
        <li>
          [BSBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and
          Michael Riabzev. &ldquo;Scalable, transparent, and
          post-quantum secure computational integrity.&rdquo; In:
          <em>IACR ePrint Archive 2018/046</em>, 2018.
          <a
            href="https://eprint.iacr.org/2018/046"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2018/046</a>.
        </li>
        <li>
          [BSCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas
          Spooner. &ldquo;Interactive oracle proofs.&rdquo; In:
          <em>TCC 2016</em>, pages 31&ndash;60, 2016.
        </li>
        <li>
          [CBBZ22] Binyi Chen, Benedikt B&uuml;nz, Dan Boneh, and
          Zhenfei Zhang. &ldquo;Hyperplonk: PLONK with a
          linear-time prover and high-degree custom gates.&rdquo;
          In: <em>IACR ePrint Archive 2022/1355</em>, 2022.
          <a
            href="https://eprint.iacr.org/2022/1355"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/1355</a>.
        </li>
        <li>
          [Eag22] Liam Eagen. &ldquo;Bulletproofs++.&rdquo; In:
          <em>IACR ePrint Archive 2022/510</em>, 2022.
          <a
            href="https://eprint.iacr.org/2022/510"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/510</a>.
        </li>
        <li>
          [EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon.
          &ldquo;cq: Cached quotients for fast lookups.&rdquo; In:
          <em>IACR ePrint Archive 2022/1763</em>, 2022.
          <a
            href="https://eprint.iacr.org/2022/1763"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/1763</a>.
        </li>
        <li>
          [Gab22] Ariel Gabizon. &ldquo;Multiset checks in PLONK
          and Plookup.&rdquo; hackmd.io, 2022.
          <a
            href="https://hackmd.io/@arielg/ByFgSDA7D"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >hackmd.io/@arielg/ByFgSDA7D</a>.
        </li>
        <li>
          [GK22] Ariel Gabizon and Dmitry Khovratovich.
          &ldquo;flookup: Fractional decomposition-based lookups
          in quasi-linear time independent of the table
          size.&rdquo; In: <em>IACR ePrint Archive 2022/1447</em>,
          2022.
          <a
            href="https://eprint.iacr.org/2022/1447"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/1447</a>.
        </li>
        <li>
          [GW20] Ariel Gabizon and Zachary J. Williamson.
          &ldquo;Plookup: A simplified polynomial protocol for
          lookup tables.&rdquo; In: <em>IACR ePrint Archive
          2020/315</em>, 2020.
          <a
            href="https://eprint.iacr.org/2020/315"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2020/315</a>.
        </li>
        <li>
          [GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana
          Ciobotaru. &ldquo;PLONK: Permutations over
          Lagrange-bases for oecumenical non-interactive arguments
          of knowledge.&rdquo; In: <em>IACR ePrint Archive
          2019/953</em>, 2019.
          <a
            href="https://eprint.iacr.org/2019/953"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2019/953</a>.
        </li>
        <li>
          [KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian
          Goldberg. &ldquo;Constant-size commitments to polynomials
          and their applications.&rdquo; In: <em>ASIACRYPT
          2010</em>, Vol. 6477 of LNCS. Springer, 2010.
        </li>
        <li>
          [Lab] Avi Dessauer (Orbis Labs). tiny-ram-halo2.
          <a
            href="https://github.com/Orbis-Tertius/tiny-ram-halo2"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/Orbis-Tertius/tiny-ram-halo2</a>.
        </li>
        <li>
          [LFKN92] Carsten Lund, Lance Fortnow, Howard Karloff, and
          Noam Nisan. &ldquo;Algebraic methods for interactive proof
          systems.&rdquo; In: <em>Journal of the Association for
          Computing Machinery</em>, Vol. 39, pages 859&ndash;868,
          1992. Full paper:
          <a
            href="https://eprint.iacr.org/2017/1066"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2017/1066</a>.
        </li>
        <li>
          [Mid] Polygon Miden: A STARK-based virtual machine.
          <a
            href="https://github.com/maticnetwork/miden"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/maticnetwork/miden</a>.
        </li>
        <li>
          [PK22] Jim Posen and Assimakis A. Kattis.
          &ldquo;Caulk+: Table-independent lookup arguments.&rdquo;
          In: <em>IACR ePrint Archive 2022/957</em>, 2022.
          <a
            href="https://eprint.iacr.org/2022/957"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/957</a>.
        </li>
        <li>
          [Pol] Polygon Zero Team: plonky2.
          <a
            href="https://github.com/mir-protocol/plonky2"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/mir-protocol/plonky2</a>.
        </li>
        <li>
          [PST13] Charalampos Papamanthou, Elaine Shi, and Roberto
          Tamassia. &ldquo;Signatures of correct computation.&rdquo;
          In: <em>TCC 3</em>, Vol. 7785 of LNCS. Springer, 2013.
        </li>
        <li>
          [RDJH22] Gyumin Roh, Wei Dai, Maria Jabbour, and Andrew
          He. &ldquo;New lookup argument.&rdquo; zkResearch, 2022.
          <a
            href="https://zkresear.ch/t/new-lookup-argument/32"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >zkresear.ch/t/new-lookup-argument/32</a>.
        </li>
        <li>
          [Tha13] Justin Thaler. &ldquo;Time-optimal interactive
          proofs for circuit evaluation.&rdquo; In: <em>CRYPTO
          2013</em>, Vol. 8043 of LNCS, 2013. Full paper:
          <a
            href="https://eprint.iacr.org/2013/351"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2013/351</a>.
        </li>
        <li>
          [ZBK+22] Arantxa Zapico, Vitalik Buterin, Dmitry
          Khovratovich, Mary Maller, Anca Nitulescu, and Mark
          Simkin. &ldquo;Caulk: Lookup arguments in sublinear
          time.&rdquo; In: <em>IACR ePrint Archive 2022/621</em>,
          2022.
          <a
            href="https://eprint.iacr.org/2022/621"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/621</a>.
        </li>
      </ol>
    </section>

  </article>
</BaseLayout>
