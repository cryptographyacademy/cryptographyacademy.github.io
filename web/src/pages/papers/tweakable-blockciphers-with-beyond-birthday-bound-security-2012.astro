---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/450';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Tweakable Blockciphers with Beyond Birthday-Bound Security';
const AUTHORS_HTML = 'Will Landecker, Thomas Shrimpton, R.  Seth Terashima';

const CONTENT = `    <p class="text-gray-300">Will Landecker, Thomas Shrimpton, and R. Seth Terashima</p>

    <p class="text-gray-300">Dept. of Computer Science, Portland State University</p>

    <p class="text-gray-300">{landeckw,teshrim,seth}@cs.pdx.edu</p>

    <p class="text-gray-300">Abstract. Liskov, Rivest and Wagner formalized the tweakable blockcipher (TBC) primitive at CRYPTO'02. The typical recipe for instantiating a TBC is to start with a blockcipher, and then build up a construction that admits a tweak. Almost all such constructions enjoy provable security only to the birthday bound, and the one that does achieve security beyond the birthday bound (due to Minematsu) severely restricts the tweak size and requires per-invocation blockcipher rekeying.</p>

    <p class="text-gray-300">This paper gives the first TBC construction that simultaneously allows for arbitrarily "wide" tweaks, does not rekey, and delivers provable security beyond the birthday bound. Our construction is built from a blockcipher and an  <span class="math">\\epsilon</span> - <span class="math">\\mathrm{AXU}_2</span>  hash function.</p>

    <p class="text-gray-300">As an application of the TBC primitive, LRW suggest the TBC-MAC construction (similar to CBC-MAC but chaining through the tweak), but leave open the question of its security. We close this question, both for TBC-MAC as a PRF and a MAC. Along the way, we find a nonce-based variant of TBC-MAC that has a tight reduction to the security of the underlying TBC, and also displays graceful security degradation when nonces are misused. This result is interesting on its own, but it also serves as an application of our new TBC construction, ultimately giving a variable input-length PRF with beyond birthday-bound security.</p>

    <p class="text-gray-300">Keywords: tweakable blockcipher, beyond birthday bound, pseudorandom function, message authentication code, unforgeability.</p>

    <p class="text-gray-300">sectionIntroduction A blockcipher  <span class="math">E \\colon \\{0,1\\}^k \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  is typically viewed as a family of permutations  <span class="math">E_K</span>  over  <span class="math">\\{0,1\\}^n</span> , where the index into the family is the key  <span class="math">K \\in \\{0,1\\}^k</span> . A tweakable blockcipher (TBC) extends this viewpoint by adding a second "dimension" to the function family, called a tweak. In particular, a TBC  <span class="math">\\widetilde{E} \\colon \\{0,1\\}^k \\times \\mathcal{T} \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  is a family of permutations indexed by a pair  <span class="math">(K,T) \\in \\{0,1\\}^k \\times \\mathcal{T}</span> . There is, however, a semantic asymmetry between the key and the tweak: the key is secret and gives rise to security, while the tweak may be public and gives rise to variability.</p>

    <p class="text-gray-300">Liskov, Rivest and Wagner [21] formalized the TBC primitive. Their thesis was that primitives with inherent variability are a more natural starting point for building modes of operation, whereas classical constructions would use a blockcipher (deterministic once the key is fixed) and induce variability by using a per-message IV or nonce. Subsequent papers have delivered tweakable enciphering schemes (e.g. [14-16, 34, 8] and others), message authentication codes (e.g. [30]), and authenticated encryption (e.g. [29, 30, 20]) modes of operation. The Skein [32] hash function has a TBC at its core. TBC-based constructions have found widespread practical application for full-disk encryption.</p>

    <p class="text-gray-300">BUILDING TBCs. There are few dedicated TBC designs: the Hasty Pudding [31] and Mercy [10] ciphers natively admit tweaks. The more common approach is to start from a blockcipher and build up a TBC, incorporating support for a tweak without (one hopes) sacrificing whatever security the original blockcipher offered. The original LRW paper itself gave two constructions, which we call LRW1 and LRW2. The former construction is LRW1[E]K(T,X) = EK(T ⊕ EK(X)) and it is a secure tweakable-PRP if the underlying  <span class="math">n</span> -bit blockcipher  <span class="math">E</span>  is a secure PRP, although there is a birthday-type loss in the reduction. (That is, the security bound becomes vacuous around  <span class="math">2^{n/2}</span>  queries.) In addition to birthday-bound security, the tweakspace is limited to  <span class="math">\\mathcal{T} \\subseteq \\{0,1\\}^n</span> . The second LRW construction LRW2[H,E]h,K(T,X) = h(T) ⊕ EK(X ⊕ h(T)) avoids this length restriction by hashing the tweak. LRW prove that this is a tweakable strong-PRP when  <span class="math">E</span>  is a secure strong-PRP and  <span class="math">h</span>  is a random element of an  <span class="math">\\epsilon</span> -almost 2-xor-universal ( <span class="math">\\epsilon</span> -AXU <span class="math">_2</span> ) hash function family  <span class="math">H</span> . But here, too, one finds only birthday-bound</p>

    <p class="text-gray-300">security. Variations on the LRW constructions, for example Rogaway's XE and XEX constructions [30], similarly offer provable security only to the birthday bound.</p>

    <p class="text-gray-300">Tweakable blockciphers with beyond birthday-bound (BBB) security may be of particular interest for applications such as large-scale data-at-rest protection, where key management and negotiation issues seem likely to drive up the amount of data protected by a single key. Also, when legacy restrictions require the use of Triple-DES (where  <span class="math">n = 64</span> ), delivering BBB security has obvious benefits. We also note that OCB mode [30] would deliver BBB authenticated-encryption security if constructed over a BBB tweakable blockcipher; other TBC-based constructions with (tight) security reductions to the security of the underlying TBC would similarly benefit.</p>

    <p class="text-gray-300">Nonetheless, constructions of TBCs with BBB security are rare. One due to Minematsu [25] achieves BBB security, but only admits short tweaks (e.g.  <span class="math">\\mathcal{T} = \\{0,1\\}^{n - m}</span>  for  <span class="math">m\\geq n / 2</span> ). It requires two blockcipher calls per TBC invocation, and suffers an additional performance penalty by rescheduling one blockcipher key whenever the tweak changes. This last point also violates a TBC design goal, that changing a tweak should be more efficient than changing a key.</p>

    <p class="text-gray-300">A NEW CONSTRUCTION WITH BBB SECURITY: CLRW2. Our main technical result is the first TBC construction that has tweakable strong-PRP security beyond the birthday bound, admits essentially arbitrary tweaks, and does not require per-invocation rekeying of any of the underlying objects. We call this the Chained LRW2 (CLRW2) construction, since it can be written as LRW2[H, E]h2,K2(T, LRW2[H, E]h1,K1(T, X)); see Figure 1.</p>

    <p class="text-gray-300">The bulk of the paper is dedicated to showing that when  <span class="math">E</span>  is a secure strong-PRP and  <span class="math">H</span>  is an  <span class="math">\\epsilon</span> - <span class="math">\\mathrm{AXU}_2</span>  hash function family with  <span class="math">\\epsilon = 2^{-n}</span> , the CLRW2 TBC is a tweakable strong-PRP with security against adaptive attackers making  <span class="math">\\mathcal{O}(2^{2n/3})</span>  queries. Figure 2 gives a graphical comparison of our security bound and the birthday bound.</p>

    <p class="text-gray-300">We also consider some variations of CLRW2, for example omitting internal xors, or keying the two blockciphers with the same key.</p>

    <p class="text-gray-300">Note that there are many efficient constructions of  <span class="math">\\epsilon</span> - <span class="math">\\mathrm{AXU}_2</span>  families with  <span class="math">\\epsilon \\approx 2^{-n}</span>  and, except perhaps for very long tweaks, the running time of CLRW2 is likely to be dominated by the two blockcipher calls.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. The CLRW2 Construction.</p>

    <p class="text-gray-300">ANALYZING THE TBC-MAC CONSTRUCTION AND VARIANTS. In addition to formalizing the TBC primitive, LRW suggested TBC-based constructions for (authenticated) encryption, hashing and message authentication. The last of these has yet to receive formal analysis, so we consider it. The basic TBC-MAC construction operates as follows. Fix  <span class="math">k, n &amp;gt; 0</span>  and let  <span class="math">\\widetilde{E} \\colon \\{0,1\\}^k \\times \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  be a tweakable blockcipher. Fix  <span class="math">T_0 \\in \\{0,1\\}^n</span> . Then for any key  <span class="math">K \\in \\{0,1\\}^k</span>  and a plaintext  <span class="math">M = M_1, \\ldots, M_b</span>  consisting of  <span class="math">n</span> -bit blocks, define  <span class="math">\\mathrm{TBCMAC}[\\widetilde{E}]_K(M) = T_b</span>  where  <span class="math">T_i \\gets \\widetilde{E}_K(T_{i-1}, M_i)</span>  for all  <span class="math">i \\in [1..b]</span> . This is the TBC-MAC (over  <span class="math">\\widetilde{E}</span> ) of the input  <span class="math">M</span> .</p>

    <p class="text-gray-300">It is intuitive to think of TBC-MAC as analogous to CBC-MAC. Indeed, if  <span class="math">\\widetilde{E}_K(T,X) = E_K(T\\oplus X)</span>  then we have the CBC-MAC construction. But perhaps by abstracting away the details of  <span class="math">\\widetilde{E}</span>  one can achieve better security than that offered by CBC-MAC? This seems a reasonable expectation, since an attacker can directly influence the input to the blockcipher  <span class="math">E</span>  in CBC-MAC via the exclusive-or operation, but no such influence is guaranteed when</p>

    <p class="text-gray-300">the chaining value (the tweak) is separated from the plaintext input block. Moreover, it is easy to build TBCs with tweak inputs that are much larger than <span class="math">n</span> bits (LRW already gave one way), and exploiting this may allow for simple twists on the basic TBC-MAC that give better security.</p>

    <p class="text-gray-300">We first consider TBC-MAC as a variable-input-length pseudorandom function (VIL-PRF). We show that it is secure if the underlying TBC is a secure tweakable-PRP. Like CBC-MAC, however, TBC-MAC has only birthday-bound security. A small benefit is that this result is not restricted to prefix-free encoded inputs as it is for CBC-MAC. Actually, one can view TBC-MAC as an instance of the Merkle-Damgård iteration <em>[23, 11]</em> over a compression function with a dedicated key input. In this setting Bellare and Ristenpart <em>[3]</em> have already shown that various versions of Merkle-Damgård (plain, suffix-free encoded inputs, prefix-free encoded inputs) are PRF-preserving.</p>

    <p class="text-gray-300">A more interesting result is found if the underlying TBC allows “wide” tweaks, i.e. tweaks that are wider than the blocksize. In this case, a simple nonce-based version of TBC-MAC (TBCMAC2) achieves much better PRF security bounds. In fact, if nonces are properly respected, the mode of operation imparts <em>no</em> loss over the security of the underlying TBC. Thus, TBCMAC2 instantiated with a beyond-birthday secure TBC yields a variable-input-length PRF with beyond-birthday security. What’s more, the security bound degrades quadratically in the maximum number of times any nonce is repeated, providing more graceful behavior than most nonce-based constructions, which fail catastrophically when a nonce-repeat occurs. Such nonce misuse-resistance can be quite useful in practice.</p>

    <p class="text-gray-300">Lastly, we show that TBC-MAC is unforgeable assuming only that the underlying TBC is likewise unforgeable. This holds only for prefix-free encoded inputs. In fact, this follows from the work of Maurer and Sjödin <em>[22]</em>, who give general results for the Merkle-Damgård iteration. When the prefix-free encoding restriction is lifted, we exhibit a TBC <span class="math">\\widetilde{E}</span> that is unforgeable, yet TBC-MAC over <span class="math">\\widetilde{E}</span> is easily forged.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Unforgeability Preservation of TBC constructions.</h4>

    <p class="text-gray-300">A final, small contribution of this work is to address the question: What if one wants only to assume access to cryptographic primitives that are unforgeable (i.e. unpredictable), rather than pseudorandom? No previous work addresses the provable security of TBC constructions starting from blockciphers with this weaker security assumption. We begin this effort by considering the two TBC constructions from LRW. We show that LRW1 is <em>not</em> unforgeability preserving. That is, we build a blockcipher <span class="math">E</span> that is unforgeable but for which is it easy to forge LRW1[<span class="math">E</span>]. (In fact, we use LRW1 against itself in this result!) Likewise for LRW2, we show that there is an <span class="math">\\epsilon</span>-AXU_{2} hash function family and an unforgeable blockcipher <span class="math">E</span> such that LRW2[<span class="math">H,E</span>] is easily forged. (Again, we use LRW1 again to construct the <span class="math">E</span> we need.) For space reasons, these results appear in Appendix E. At this time, we do not know if CLRW2 remains unforgeable given only unforgeable underlying blockciphers.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Additional Related Work.</h4>

    <p class="text-gray-300">We have already mentioned the paper of Liskov et al. <em>[21]</em> as the starting point for our work. Goldenberg et al. <em>[17]</em> show how to build a TBC by directly tweaking the Luby-Rackoff construction. Using <span class="math">n</span>-bit random functions, the resulting <span class="math">2n</span>-bit TBC has tweakable strong-PRP security to roughly <span class="math">2^{n}</span> queries, and can accommodate a tweak of length <span class="math">\\ell n</span> using <span class="math">\\ell+6</span> rounds.</p>

    <p class="text-gray-300">Coron et al. <em>[9]</em> show that a three-round Feistel construction over an <span class="math">n</span>-bit TBC with a wide tweak yields a <span class="math">2n</span>-bit TBC that has beyond birthday-bound security if the underlying TBC does. Our CLRW2 construction meets this requirement.</p>

    <p class="text-gray-300">The PMAC1 construction by Rogaway <em>[30]</em> builds a (parallelizable) VIL-PRF from a TBC, achieving birthday-bound security. Recently, Yasuda <em>[36]</em> introduced the PMAC_plus construction, which has <span class="math">\\mathcal{O}(2^{2n/3})</span> security like TBCMAC2 but is more efficient and parallelizable. PMAC_plus could be viewed as a construction over a tweakable blockcipher (which might be called the “XXE” construction, following Rogaway’s naming convention), but neither the construction nor the proof is cast this way. Separately, Yasuda <em>[35]</em> proves that Algorithm 6 from ISO 9797-1 and SUM-ECBC both have security against <span class="math">\\mathcal{O}(2^{2n/3})</span> queries.</p>

    <p class="text-gray-300">The WMAC construction of Black and Cochran <em>[6]</em> is a stateful hash-then-MAC construction that, like our TBCMAC2 construction, allows for graceful (quadratic) security degradation when nonces are repeated. There are various methods for using randomness to build VIL-PRFs with beyond birthday-bound security; for example MACRX <em>[2]</em>, RMAC <em>[19]</em>, randomized WMAC and enhanced hash-then-MAC <em>[26]</em></p>

    <p class="text-gray-300">We note that real-world protocols such as TLS <em>[33]</em> employ nonce-based PRFs by using per-message sequence numbers. Nonce-based PRFs also have applications in secure memory; see Garay et al. <em>[18]</em> and references therein.</p>

    <p class="text-gray-300">Bellare and Ristenpart <em>[3]</em> study unforgeability preservation of iterated Merkle-Damgård constructions in the dedicated-key compression-function setting. They show that, in general, these iterations do not preserve unforge</p>

    <p class="text-gray-300">ability; however, their counterexample does not apply to TBC-MAC because the compression function they construct is not a TBC.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zhang et al. <em>[37]</em> study so-called rate-1 MACs constructed from variations of the PGV <em>[27, 7]</em> blockcipher-based compression functions. They show that certain of these compression functions, for example <span class="math">f(T,X)=E_{K\\,\\oplus\\,T}(X)</span>, iterate (through <span class="math">T</span>) to unforgeable MACs under the assumption that the underlying blockcipher is related-key unpredictable for specific related-key functions. In the case of our example, the related-key functions are $\\{K\\mapsto K\\oplus T\\mid T\\in\\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}<span class="math">. But in this example and others, assuming that the blockcipher is related-key unforgeable is equivalent to assuming that the compression function is an unforgeable TBC, and thus chaining through the tweak leads to TBC-MAC. Hence our results generalize some of those given by Zhang et al. <em>[37]</em>. We note that TBCs like </span>E_{K\\,\\oplus\\,T}(X)$ are inefficient choices for iteration through the tweak, since they require rescheduling the blockcipher key each round.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We mention in passing that the basic three-key enciphered CBC construction due to Dodis et al. <em>[12]</em> can, in large, part be viewed as an instance of TBC-MAC over the <span class="math">\\mathsf{LRW1}</span> TBC. (The <span class="math">IV</span> is no longer a fixed value, but depends on the first input block.)</p>

    <p class="text-gray-300">Note on error in previous version. This is a revised full version of a paper that appeared in CRYPTO ’12. Both the original full version (6 Aug. 2012) and the CRYPTO paper contain an error in the proof of Theorem 1.</p>

    <p class="text-gray-300">Briefly, the error occurs in the transition from Game 4 to Game 5 when we tacitly assume the former is more likely than an ideal tweakable blockcipher to return certain values (specifically, values in the set <span class="math">S_{1}</span>). We would like to thank Gordon Procter for bringing the error to our attention. Procter also provided a suggested patch to the problem <em>[28]</em>; while we believe the patch is sound, we opted for a solution that simplifies the proof by using a coupling argument to abstract away the details of certain game transitions.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. When <span class="math">\\mathcal{X}</span> is a set, we write <span class="math">x\\stackrel{{\\scriptstyle\\mathsf{s}}}{{\\leftarrow}}\\mathcal{X}</span> to mean that an element (named <span class="math">x</span>) is uniformly sampled from <span class="math">\\mathcal{X}</span>. We overload the notation for probabilistic algorithms, writing <span class="math">x\\stackrel{{\\scriptstyle\\mathsf{s}}}{{\\leftarrow}}M</span> to mean that algorithm <span class="math">M</span> runs and outputs a value named <span class="math">x</span>. When <span class="math">X</span> and <span class="math">Y</span> are strings, we write $X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y<span class="math"> for their concatenation. When </span>X\\in\\{0,1\\}^{*}<span class="math"> we write </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for its length and, if </span>1\\leq i<j\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> we write </span>X[i..j]<span class="math"> for the substring running from its </span>i^{\\mathrm{th}}<span class="math"> to </span>j^{\\mathrm{th}}<span class="math"> characters, or the empty string </span>\\varepsilon<span class="math"> otherwise. For a string </span>X<span class="math"> of even length </span>n<span class="math">, we define </span>X_{L}<span class="math"> and </span>X_{R}<span class="math"> to be </span>X[1..\\frac{n}{2}]<span class="math"> and </span>X[(\\frac{n}{2}+1)..n]<span class="math">, respectively. For a tuple of strings </span>(X_{1},X_{2},\\ldots,X_{r})<span class="math"> we define </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(X_{1},X_{2},\\ldots,X_{r})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{1}\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{2}\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\cdots\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,X_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The set </span>\\{0,1\\}^{n}<span class="math"> is the set of all </span>n<span class="math">-bit strings, </span>(\\{0,1\\}^{n})^{r}<span class="math"> is the set of all </span>nr<span class="math">-bit strings understood as </span>r<span class="math"> blocks of </span>n<span class="math">-bits each, and </span>(\\{0,1\\}^{n})^{+}<span class="math"> is the set of all strings that are a positive number of </span>n<span class="math">-bit blocks in length. When </span>X\\in(\\{0,1\\}^{n})^{+}<span class="math">, we write </span>X_{1},\\ldots,X_{b}\\stackrel{{\\scriptstyle\\mathsf{s}}}{{\\leftarrow}}X<span class="math"> to mean that </span>X<span class="math"> is parsed into </span>b<span class="math"> blocks of </span>n<span class="math">-bits each. For strings </span>X,Y\\in(\\{0,1\\}^{n})^{+}<span class="math"> we define the predicate </span>\\mathsf{CommonPF}_{i}(X,Y)<span class="math"> to be true if and only if </span>X<span class="math"> and </span>Y<span class="math"> agree on their first </span>i<span class="math"> blocks of </span>n<span class="math">-bits, i.e. </span>X_{j}=Y_{j}<span class="math"> for all </span>1\\leq j\\leq i<span class="math"> where </span>X_{j},Y_{j}\\in\\{0,1\\}^{n}<span class="math">. When </span>\\mathcal{X}\\subseteq(\\{0,1\\}^{n})^{+}<span class="math"> and </span>M\\in(\\{0,1\\}^{n})^{+}<span class="math">, we also define </span>\\mathsf{Prefix}_{\\mathcal{X}}(M)<span class="math"> to be the function that returns the blockwise longest common prefix that </span>M<span class="math"> shares with strings in </span>\\mathcal{X}<span class="math">. An <em>adversary</em> </span>A<span class="math"> is a probabilistic algorithm that takes zero or more oracles. We often use the notation </span>A\\Rightarrow x<span class="math"> to denote the event (defined over some specified probability space) that some algorithm </span>A<span class="math"> outputs value </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We make use of the code-based game-playing framework of Bellare and Rogaway <em>[5]</em>. When <span class="math">G</span> is a game and <span class="math">A</span> an adversary, we write <span class="math">\\Pr\\big{[}\\,G^{A}\\Rightarrow y\\,\\big{]}</span> for the probability that the Finalize procedure of game <span class="math">G</span> outputs <span class="math">y</span> when executed with adversary <span class="math">A</span>. The probability is over the coins of <span class="math">G</span> and <span class="math">A</span>. When the Finalize procedure is trivial, returning whatever <span class="math">A</span> does, we omit the procedure from the game and write <span class="math">\\Pr\\big{[}\\,A^{G}\\Rightarrow y\\,\\big{]}</span> for the probability that <span class="math">A</span> outputs <span class="math">y</span> when executed with game <span class="math">G</span>. In games, all boolean flags are initialized to false and all arrays are initially undefined at every point.</p>

    <p class="text-gray-300">Function Families and (Tweakable) Blockciphers. Let <span class="math">\\mathcal{K},\\mathcal{D}</span> and <span class="math">\\mathcal{R}</span> be sets, where at least <span class="math">\\mathcal{K}</span> is non-empty. A mapping <span class="math">F\\colon\\mathcal{K}\\times\\mathcal{D}\\to\\mathcal{R}</span> can be thought of as a function family <span class="math">F=\\{F_{K}\\}</span> where for each <span class="math">K\\in\\mathcal{K}</span> we assign <span class="math">F_{K}(\\cdot)=F(K,\\cdot)</span>. We will use both representations of the family, as a two-argument mapping and as a set indexed by the first argument, choosing whichever is most convenient. We write <span class="math">\\mathrm{Func}(\\mathcal{D},\\mathcal{R})</span> for the set of all mappings from <span class="math">\\mathcal{D}</span> to <span class="math">\\mathcal{R}</span>. We write <span class="math">\\mathrm{Perm}(n)</span> to denote the set of all permutations (bijections) over <span class="math">\\{0,1\\}^{n}</span>. We can view each of these as function families with some understood ordering.</p>

    <p class="text-gray-300">A blockcipher is a function family <span class="math">E\\colon\\mathcal{K}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> such that for all <span class="math">K\\in\\mathcal{K}</span> the mapping <span class="math">E_{K}(\\cdot)\\in\\mathrm{Perm}(n)</span>. We write <span class="math">\\mathrm{BC}(\\mathcal{K},n)</span> to mean the set of all such blockciphers, shortening to <span class="math">\\mathrm{BC}(k,n)</span> when <span class="math">\\mathcal{K}=\\{0,1\\}^{k}</span>. A tweakable blockcipher (TBC) is a function family <span class="math">\\widetilde{E}\\colon\\mathcal{K}\\times(\\mathcal{T}\\times\\{0,1\\}^{n})\\to\\{0,1\\}^{n}</span> such that for every <span class="math">K\\in\\mathcal{K}</span> and <span class="math">T\\in\\mathcal{T}\\subseteq\\{0,1\\}^{*}</span> the mapping <span class="math">\\widetilde{E}_{K}(T,\\cdot)</span> is a permutation over <span class="math">\\{0,1\\}^{n}</span>. The set <span class="math">\\mathcal{T}</span> is called the tweakspace of the TBC, and the element <span class="math">T\\in\\mathcal{T}</span> is the tweak.</p>

    <p class="text-gray-300">Security notions. Let <span class="math">F\\colon\\mathcal{K}\\times\\mathcal{D}\\to\\mathcal{R}</span> be a function family, and let <span class="math">A</span> be an adversary taking one oracle. Then we define</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{prf}}_{F}(A)=\\Pr\\Big{[}\\&gt;K\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}\\mathcal{K}\\&gt;:\\&gt;A^{F_{K}(\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}-\\Pr\\Big{[}\\&gt;\\rho\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}\\mathrm{Func}(\\mathcal{D},\\mathcal{R})\\&gt;:\\&gt;A^{\\rho(\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}</span></p>

    <p class="text-gray-300">to be the PRF advantage of <span class="math">A</span> attacking <span class="math">F</span>. Here, and throughout, the probability is over the random choices of the described experiment and those of the adversary. We define</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{uf}\\text{-}\\mathrm{cma}}_{F}(A)=\\Pr\\Big{[}\\&gt;K\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}\\mathcal{K}\\&gt;;\\&gt;(M,\\tau)\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}A^{F_{K}(\\cdot)}\\&gt;:\\&gt;F_{K}(M)=\\tau\\wedge\\mathrm{new}\\text{-}\\mathrm{msg}\\&gt;\\Big{]}</span></p>

    <p class="text-gray-300">to be the UF-CMA advantage (or “forging” advantage) of <span class="math">A</span>. Here the event <span class="math">\\mathrm{new}\\text{-}\\mathrm{msg}</span> holds iff the string <span class="math">M</span> was never asked by <span class="math">A</span> to its oracle.</p>

    <p class="text-gray-300">Let <span class="math">E\\colon\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> be a blockcipher, and let <span class="math">\\widetilde{E}:\\{0,1\\}^{k}\\times(\\mathcal{T}\\times\\{0,1\\}^{n})\\to\\{0,1\\}^{n}</span> be a tweakable blockcipher. Let <span class="math">K\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}\\{0,1\\}^{k}</span>, <span class="math">\\pi\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}\\mathrm{Perm}(n)</span>, and <span class="math">\\Pi\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}\\mathrm{BC}(\\mathcal{T},n)</span>. Then we define</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{prp}}_{E}(A)</span> <span class="math">=\\Pr\\Big{[}\\&gt;A^{E_{K}(\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}-\\Pr\\Big{[}\\&gt;A^{\\pi(\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}</span> <span class="math">\\mathbf{Adv}^{\\mathrm{aprp}}_{E}(A)</span> <span class="math">=\\Pr\\Big{[}\\&gt;A^{E_{K}(\\cdot),E_{K}^{-1}(\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}-\\Pr\\Big{[}\\&gt;A^{\\pi(\\cdot),\\pi^{-1}(\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}</span> <span class="math">\\mathbf{Adv}^{\\mathrm{prp}}_{\\widetilde{E}}(A)</span> <span class="math">=\\Pr\\Big{[}\\&gt;A^{\\widetilde{E}_{K}(\\cdot,\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}-\\Pr\\Big{[}\\&gt;A^{\\Pi(\\cdot,\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}</span> <span class="math">\\mathbf{Adv}^{\\mathrm{aprp}}_{\\widetilde{E}}(A)</span> <span class="math">=\\Pr\\Big{[}\\&gt;A^{\\widetilde{E}_{K}(\\cdot,\\cdot),\\widetilde{E}_{K}^{-1}(\\cdot,\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}-\\Pr\\Big{[}\\&gt;A^{\\Pi(\\cdot,\\cdot),\\Pi^{-1}(\\cdot,\\cdot)}\\Rightarrow 1\\&gt;\\Big{]}</span></p>

    <p class="text-gray-300">to be (respectively) the PRP, strong PRP, tweakable-PRP, and tweakable strong-PRP advantages of <span class="math">A</span>, an adversary taking the indicated number of oracles. These probabilities are over the random coins of <span class="math">A</span> and the random choices of <span class="math">K</span>, <span class="math">\\pi</span>, and <span class="math">\\Pi</span>, as appropriate.</p>

    <p class="text-gray-300">A function family <span class="math">F\\colon\\mathcal{K}\\times\\mathcal{D}\\to\\mathcal{R}</span> is <span class="math">\\epsilon</span>-almost 2-XOR-universal (<span class="math">\\epsilon</span>-AXU_{2}) if for all distinct <span class="math">X,X^{\\prime}\\in\\mathcal{D}</span> and <span class="math">Y\\in\\mathcal{R}</span>, <span class="math">\\Pr\\Big{[}\\&gt;K\\stackrel{{\\scriptstyle\\scriptscriptstyle\\rm s}}{{\\leftarrow}}\\mathcal{K}\\&gt;:\\&gt;F_{K}(X)\\oplus F_{K}(X^{\\prime})=Y\\&gt;\\Big{]}\\&gt;\\&gt;\\leq\\&gt;\\epsilon</span>.</p>

    <p class="text-gray-300">Resources and conventions. We consider the following adversarial resources: the running time <span class="math">t</span>, the number of oracle queries asked <span class="math">q</span>, and the total length of these queries <span class="math">\\mu</span>. For the PRP and strong PRP notions, we suppress <span class="math">\\mu</span> since it is implicitly computable from <span class="math">q</span> and the blocksize. In the UF-CMA advantage, <span class="math">\\mu</span> includes the length of the output forgery attempt <span class="math">(M,\\tau)</span>. It will often be the case that queries (and forgery attempts) are strings in <span class="math">(\\{0,1\\}^{n})^{+}</span> for some blocksize <span class="math">n&gt;0</span>, and here it will be convenient to speak of the total number of blocks <span class="math">\\sigma=\\mu/n</span>. The running time of an adversary is relative to some (implicit) fixed underlying model of computation. Running times will always be given with respect to some security experiment, and we define the running time to include the time to execute the entire experiment. We assume that adversaries do not make pointless queries: they do not repeat queries, nor do they ask queries that are outside of the domain of oracles they may access.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Tweakable SPRP-security of CLRW2</h2>

    <p class="text-gray-300">The centerpiece of this work is a TBC construction that provides BBB security, admits a large tweakspace, and does not require rekeying of any underlying object. Given a blockcipher <span class="math">E\\colon\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> is blockcipher, and a hash function family <span class="math">H\\colon\\mathcal{K}_{H}\\times\\mathcal{D}\\to\\{0,1\\}^{n}</span>, the CLRW2 construction <span class="math">\\widetilde{E}[H,E]\\colon(\\mathcal{K}_{H})^{2}\\times(\\{0,1\\}^{k})^{2}\\times\\mathcal{D}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> is given by</p>

    <p class="text-gray-300"><span class="math">\\widetilde{E}[H,E]_{h_{1},h_{2},K_{1},K_{2}}(T,X)=E_{K_{2}}(E_{K_{1}}(X\\oplus H_{h_{1}}(T))\\oplus H_{h_{1}}(T)\\oplus H_{h_{2}}(T))\\oplus H_{h_{2}}(T).</span></p>

    <p class="text-gray-300">The following theorem is our main technical result.</p>

    <p class="text-gray-300">Theorem 1. Fix  <span class="math">k, n &amp;gt; 0</span>  and let  <span class="math">E\\colon \\{0,1\\}^k\\times \\{0,1\\}^n\\to \\{0,1\\}^n</span>  be a blockcipher. Fix a non-empty set  <span class="math">\\mathcal{K}_H</span> , and let  <span class="math">\\mathcal{D}\\subseteq \\{0,1\\}^*</span> . Let  <span class="math">H\\colon \\mathcal{K}_H\\times \\mathcal{D}\\to \\{0,1\\}^n</span>  be an  <span class="math">\\epsilon</span> - <span class="math">AXU_2</span>  function family. Let  <span class="math">\\widetilde{E} = \\widetilde{E}[H,E]</span>  be the CLRW2 construction, defined above. Let  <span class="math">A</span>  be an adversary asking a total of  <span class="math">q</span>  queries to its oracles, running in time  <span class="math">t</span> . Let  <span class="math">\\hat{\\epsilon} = \\max \\{\\epsilon ,1 / (2^n -2q)\\}</span> . Then there exists an adversary  <span class="math">B</span>  using the same resources, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\widetilde {E}} ^ {\\mathrm {s p r p}} (A) \\leq 2 \\mathbf {A d v} _ {E} ^ {\\mathrm {s p r p}} (B) + \\frac {4 q ^ {3} \\hat {\\epsilon} ^ {2}}{1 - q ^ {3} \\hat {\\epsilon} ^ {2}}.</span></div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig.2. The maximum advantage of an adversary making  <span class="math">q</span>  queries against CLRW2 (solid line) and constructions limited by the birthday bound,  <span class="math">q^2 / 2^n</span>  (dashed line). Here,  <span class="math">n = 128</span> ,  <span class="math">\\epsilon = 2^{-n}</span> , and we have assumed the  <span class="math">\\mathbf{Adv}_E^{\\mathrm{sprp}}(B)</span>  term is negligible.</p>

    <p class="text-gray-300">This bound deserves some interpretation. Consider  <span class="math">\\epsilon = 2^{-n}</span>  (since there are efficient constructions meeting this), and assume  <span class="math">q \\leq 2^{n-2}</span> . Then  <span class="math">\\hat{\\epsilon} \\leq 1/2^{n-1} \\approx 2^{-n}</span>  for interesting values of  <span class="math">n</span> . Now the additive term in the bound is at most  <span class="math">p</span>  when  <span class="math">q \\leq (p/(p+6))^{1/3} \\hat{\\epsilon}^{-2/3}</span> , so for any small constant  <span class="math">p</span>  we have  <span class="math">q = \\mathcal{O}(2^{2n/3})</span> . Thus when  <span class="math">\\mathbf{Adv}_E^{\\mathrm{sprp}}(B)</span>  is sufficiently small, CLRW2 is secure as a tweakable-SPRP up to about  <span class="math">2^{2n/3}</span>  queries. Figure 2 gives a graphical comparison of our bound and the standard birthday bound.</p>

    <p class="text-gray-300">PROOF OVERVIEW. The proof of Theorem 1 is quite long and involved, so we'll start by giving a high-level overview of it. Proofs demonstrating birthday-bound security for TBC constructions typically "give up" if the adversary can cause a collision at a blockcipher input. In constructions like LRW1 and LRW2, the TBC output is no longer random, even when the blockcipher has been replaced by a random permutation. We overcome this problem by using two rounds of LRW2, and showing that it takes two independent collisions on the same query to force non-random CLRW2 outputs.</p>

    <p class="text-gray-300">The chief difficulty is ensuring that the second LRW2 round can withstand a collision so long as there was not also one on the first round. To this end, we argue that given a collision-free first round, the resulting distribution of CLRW2 output values — including those which require a second-round collision to obtain — is extremely close to that of an ideal TBC.</p>

    <p class="text-gray-300">The bulk of the proof is a sequence of games bounding the success probability of an adversary in the information-theoretic setting, where the blockciphers have been replaced by random permutations. The first three games address first-round collisions, and show that the distribution of CLRW2 outputs is consistent with that of an ideal cipher unless there is simultaneous a second-round collision. Our next three games address the case in which there is no first-round collision. By swapping the order in which dependent random variables are assigned values, we can choose the output early on in the game, and gain insight into the distribution by which it is governed. This distribution is shown to be very close to the ideal one. The final two games are used to derive an upper bound for the probability that the adversary can set a "bad flag", which would force the game to exhibit non-ideal behavior. In</p>

    <p class="text-gray-300">the end, we are able to assume that the adversary is non-adaptive by giving it explicit control over oracle return values. At that point, the <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> property can be applied.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For notational simplicity, we write <span class="math">h_{1}</span> for <span class="math">H_{h_{1}}</span>, and <span class="math">h_{2}</span> for <span class="math">H_{h_{2}}</span>; this should cause no confusion. The majority of the proof will consider the construction <span class="math">\\widetilde{E}</span> with <span class="math">E_{K_{1}}</span> and <span class="math">E_{K_{2}}</span> replaced with random permutations <span class="math">\\pi_{1}</span> and <span class="math">\\pi_{2}</span>, which we write as <span class="math">\\widetilde{E}_{h_{1},h_{2},\\pi_{i},\\pi_{2}}</span>. At the end we can make a standard move to lift to the fully complexity theoretic setting.</p>

    <p class="text-gray-300">Let <span class="math">A</span> be an adversary making <span class="math">q</span> queries. If the <span class="math">i^{\\text{th}}</span> query is to the left (encryption) oracle, we denote the query with <span class="math">(T_{i},X_{i})</span> and the response with <span class="math">Y_{i}</span>; if the query is to the right (decryption) oracle, the roles of <span class="math">X_{i}</span> and <span class="math">Y_{i}</span> are reversed. We denote by <span class="math">\\mathcal{Y}_{i}</span> the set of permissible (tweak-respecting) return values for an encryption oracle query, and similarly, <span class="math">\\mathcal{X}_{i}</span> is the set of permissible return values for a decryption oracle query. That is,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{Y}_{i}=</span> <span class="math">\\{0,1\\}^{n}\\setminus\\{Y_{j}\\ :\\ j&lt;i,T_{j}=T_{i}\\}</span> <span class="math">\\mathcal{X}_{i}=</span> <span class="math">\\{0,1\\}^{n}\\setminus\\{X_{j}\\ :\\ j&lt;i,T_{j}=T_{i}\\}\\,.</span></p>

    <p class="text-gray-300">Given a set <span class="math">S\\subseteq\\{0,1\\}^{n}</span> and a string <span class="math">x\\in\\{0,1\\}^{n}</span> we define <span class="math">S\\oplus x=\\{s\\oplus x:\\,s\\in S\\}</span>. The permutations <span class="math">\\pi_{1}</span> and <span class="math">\\pi_{2}</span> are constructed lazily, while <span class="math">h_{1}</span> and <span class="math">h_{2}</span> are already defined. Initially, boolean variables have the value false, integers are zero, and all other variable types are undefined (equal to <span class="math">\\bot</span>).</p>

    <p class="text-gray-300">Game <em>G1</em> (refer to Appendix A to see the games used in this proof) simulates <span class="math">\\widetilde{E}</span> exactly by lazily sampling values for <span class="math">\\pi_{1}</span> and <span class="math">\\pi_{2}</span>. Note that there is a certain symmetry between the encryption and decryption oracles. This symmetry arises from the fact that <span class="math">\\widetilde{E}</span> is the dual of <span class="math">\\widetilde{E}^{-1}</span>, in the sense that <span class="math">\\widetilde{E}_{h_{1},h_{2},\\pi_{1},\\pi_{2}}^{-1}(Y,T)=\\widetilde{E}_{h_{2},h_{1},\\pi_{2}^{-1},\\pi_{1}^{-1}}(Y,T)</span>.</p>

    <p class="text-gray-300">The bulk of this proof concerns showing that a sequence of games are identical, or are identical until a specified event occurs (a boolean variable is set to true). When arguing that transitions between games are correct in this sense, we will exploit the above symmetry by limiting our discussion to changes in the encryption oracle, and hence to queries made to that oracle; the arguments used to justify the corresponding changes in the decryption oracle are practically identical. Therefore fix some value <span class="math">i\\in[1..q]</span>, and assume the <span class="math">i^{\\text{th}}</span> query is to the encryption oracle.</p>

    <p class="text-gray-300">In Game <em>G2</em>, we change what happens when there is a collision at the first block cipher: we sample <span class="math">Y_{i}</span> from the ideal distribution, but raise a bad flag if we also encounter a collision at the input of second block cipher (<span class="math">\\mathsf{bad}_{1}</span>) or if <span class="math">Y_{i}</span> is already in the defined range (<span class="math">\\mathsf{bad}_{2}</span>). See Figure LABEL:fig:badflag. Game <em>G3</em> is identical to Game <em>G2</em>, except <span class="math">Y_{i}</span> is not reassigned after a bad flag is set. Hence <span class="math">\\Pr\\left[\\,A^{GI}\\Rightarrow 1\\,\\right]=\\Pr\\left[\\,A^{G2}\\Rightarrow 1\\,\\right]\\leq\\Pr\\left[\\,A^{G3}\\Rightarrow 1\\,\\right]+\\Pr\\left[\\,A^{G3}:\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right].</span></p>

    <p class="text-gray-300">Next we modify the section of code in Game <em>G3</em> that is executed when no collision occurs at <span class="math">\\pi_{1}</span>; i.e., when <span class="math">X_{i}\\oplus h_{1}(T_{i})\\neq X_{j}\\oplus h_{1}(T_{j})</span> for all <span class="math">j&lt;i</span>. Note that the random variables <span class="math">Z</span> and <span class="math">Y_{i}</span> are dependent. In Game <em>G3</em>, <span class="math">Z</span> is chosen before <span class="math">Y_{i}</span>, but as long as the joint distribution as preserved we may reverse this order. The resulting game will be equivalent to Game <em>G3</em>. As always, the decryption oracle will be modified in a similar manner.</p>

    <p class="text-gray-300">To describe the correct distribution for <span class="math">Y_{i}</span>, partition <span class="math">\\{0,1\\}^{n}</span> into four sets, <span class="math">S_{1}</span>, <span class="math">S_{2}</span>, <span class="math">S_{3}</span> and <span class="math">S_{4}</span>. These sets are defined with respect to an oracle query <span class="math">(T_{i},X_{i})</span> such that no collision occurs at <span class="math">\\pi_{1}</span>; that is, such that <span class="math">X_{i}\\oplus h_{1}(T_{i})\\not\\in Dom(\\pi_{1})</span>. (When referring to <span class="math">Dom(\\cdot)</span> outside of pseudocode, we refer to the set of points at which the function is defined at the instant the adversary makes its <span class="math">i^{\\text{th}}</span> oracle call [and similarly for <span class="math">Rng(\\cdot)</span>]; the game currently being used to define the oracle should be clear from context). For <span class="math">y\\in\\{0,1\\}^{n}</span>, we say <span class="math">y</span> is <em>permissible</em> when <span class="math">y\\in\\mathcal{Y}_{i}</span>, and <span class="math">y</span> is <em>possible</em> when <span class="math">\\Pr\\left[\\,Y_{i}=y\\,\\right]&gt;0</span>, given our assumption that <span class="math">X_{i}\\oplus h_{1}(T_{i})\\not\\in Dom(\\pi_{1})</span> and the oracles’ execution histories for the first <span class="math">i-1</span> queries.</p>

    <p class="text-gray-300">Let <span class="math">S_{4}</span> be the set of all non-permissible values. Note that if <span class="math">y</span> is not permissible (it has been returned on a query that used tweak <span class="math">T_{i}</span>), then <span class="math">y</span> is not possible (since <span class="math">\\widetilde{E}(T_{i},\\cdot)</span> is a permutation and queries are distinct); hence <span class="math">S_{4}</span> is a subset of the impossible values. Let <span class="math">S_{3}</span> be the set of impossible values that <em>are</em> permissible.</p>

    <p class="text-gray-300">We now subdivide the set of possible values based on the conditional branch on Line 317 in Game <em>G3</em>. Some values for <span class="math">Y_{i}</span> will only be returned if the choice of <span class="math">Z</span> causes a collision at <span class="math">\\pi_{2}</span>, while others can only be assigned in the absence of such a collision; the former will be <span class="math">S_{2}</span>, the latter <span class="math">S_{1}</span>. More formally, one can see that <span class="math">y</span> is not possible if and only if <span class="math">y\\oplus h_{2}(T_{i})\\in Rng(\\pi_{2})</span> and <span class="math">\\pi_{2}^{-1}(y\\oplus h_{2}(T_{i}))\\oplus h_{2}(T_{i})\\oplus h_{1}(T_{i})\\in Rng(\\pi_{1})</span> Therefore let <span class="math">S_{1}=\\{y\\ :\\ y\\oplus h_{2}(T_{i})\\not\\in Rng(\\pi_{2})\\}</span>, and let <span class="math">S_{2}</span> be the set of all other possible values.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">In summary,</p>

    <p class="text-gray-300"><span class="math">S_{1} = \\{y:y\\oplus h_{2}(T_{i})\\not\\in Rng(\\pi_{2})\\}</span></p>

    <p class="text-gray-300"><span class="math">S_{2} = \\left\\{y:y\\oplus h_{2}(T_{i})\\in Rng(\\pi_{2}),\\pi_{2}^{-1}(y\\oplus h_{2}(T_{i}))\\oplus h_{2}(T_{i})\\oplus h_{1}(T_{i})\\in \\overline{Rng(\\pi_{1})}\\right\\}</span></p>

    <p class="text-gray-300"><span class="math">S_{3} = \\mathcal{Y}_{i}\\setminus (S_{1}\\cup S_{2})</span></p>

    <p class="text-gray-300"><span class="math">= \\left\\{y:y\\oplus h_2(T_i)\\in Rng(\\pi_2),\\pi_2^{-1}(y\\oplus h_2(T_i))\\oplus h_2(T_i)\\oplus h_1(T_i)\\in Rng(\\pi_1)\\right\\} \\setminus \\overline{\\mathcal{Y}_i}</span></p>

    <p class="text-gray-300"><span class="math">S_{4} = \\overline{\\mathcal{Y}_{i}} = \\{Y_{j}:j &amp;lt;   i,T_{j} = T_{i}\\} .</span></p>

    <p class="text-gray-300">When these sets are used in pseudocode, it is understood that they are defined at the time the oracle call is made; although  <span class="math">Rng(\\pi_1)</span>  (for example) may change as code executes,  <span class="math">S_2</span>  does not change until the next query. When referred to by a decryption oracle, the definitions for these sets are the same up to the previously mentioned duality.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will now compute the probability that  <span class="math">Y_{i}</span>  will be in each of these sets (again, under the assumption that there is no collision at the first block cipher; i.e., that  <span class="math">L_{i} = X_{i} \\oplus h_{1}(T_{i}) \\notin \\text{Dom}(\\pi_{1})</span> ). Since  <span class="math">S_{3}</span>  and  <span class="math">S_{4}</span>  contain only impossible values,  <span class="math">\\operatorname*{Pr}\\left[Y_{i} \\in S_{3} \\cup S_{4} \\mid L_{i} \\notin \\text{Dom}(\\pi_{1})\\right] = 0</span> . Let  $N = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{Rng(\\pi_1)}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Given  </span>y \\in S_{2}<span class="math">  and  </span>L_{i} \\notin \\text{Dom}(\\pi_{1})<span class="math"> ,  </span>Y_{i} = y<span class="math">  if and only if  </span>Z = \\pi_2^{-1}(y \\oplus h_2(T_i)) \\oplus h_2(T_i) \\oplus h_2(T_i)<span class="math"> . This value is in  </span>\\overline{Rng(\\pi_1)}<span class="math">  by definition of  </span>S_{2}<span class="math"> , and so this event happens with probability  </span>1 / N$ . Hence,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname*{Pr}\\left[Y_i\\in S_2\\mid L_i\\notin Dom(\\pi_1)\\right] =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ N<span class="math">  and  </span>\\operatorname*{Pr}\\left[Y_i\\in S_1\\mid L_i\\oplus \\notin Dom(\\pi_1)\\right] = (N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) / N.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 3. When there is no collision at  <span class="math">\\pi_1</span> , the distribution governing  <span class="math">\\widetilde{E}</span> 's outputs is very close to the distribution an ideal cipher would provide. Horizontal scaling suggests plausible relative sizes of each  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> : likely  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2 \\cup S_4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . This graph is accurate for the oracles in Games 1-5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ideally,  <span class="math">Y_{i}</span>  would be distributed as  $p_{\\mathrm{TBC}}(y) \\coloneqq \\operatorname*{Pr}\\left[Y \\stackrel{4}{\\leftarrow} \\mathcal{Y}_{i}; Y = y\\right] = 1 / (2^{n} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  (for  </span>y \\notin S_4<span class="math"> ) and zero otherwise. However, we have shown that if there is no collision at  </span>\\pi_{1}<span class="math">  on the  </span>i^{\\text{th}}<span class="math">  query, then  </span>Y_{i}$  is distributed as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">See Figure 3.</p>

    <p class="text-gray-300">Although this distribution is not quite what we want, we will show that it is close enough (even against birthday-type attacks). In particular, the statistical distance</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}}):=\\frac{1}{2}\\sum_{y\\in\\{0,1\\}^{n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_{\\mathsf{lazy}}(y)-p_{\\mathsf{TBC}}(y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max_{S\\subseteq\\{0,1\\}^{n}}\\sum_{y\\in S}\\left(p_{\\mathsf{lazy}}(y)-p_{\\mathsf{TBC}}(y)\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">will be on the order of <span class="math">q^{2}/2^{2n}</span>. Geometrically, this quantity corresponds to half the shaded area in Figure 3. It can also be viewed as the area above <span class="math">p_{\\mathsf{TBC}}</span> but below <span class="math">p_{\\mathsf{lazy}}</span> (or the other way around).</p>

    <p class="text-gray-300">We integrate statistical distance into the game-playing proof by exploiting the existence of a optimal coupling distribution <span class="math">\\Gamma(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span> (see, e.g., Lemma 11.3 of <em>[24]</em>). This distribution samples points from <span class="math">\\{0,1\\}^{n}\\times\\{0,1\\}^{n}</span> and has the property that when <span class="math">(Y,Y^{\\prime})\\xleftarrow{\\mathsf{s}}\\Gamma(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">y\\in\\{0,1\\}^{n}</span>, <span class="math">\\Pr\\left[\\,Y=y\\,\\right]=p_{\\mathsf{lazy}}(y)</span> and <span class="math">\\Pr\\left[\\,Y^{\\prime}=y\\,\\right]=p_{\\mathsf{TBC}}(y)</span></li>

      <li>Except with probability <span class="math">\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span>, <span class="math">Y=Y^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">So in Game G4, we sample <span class="math">(Y,Y^{\\prime})\\xleftarrow{\\mathsf{s}}\\Gamma(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span> and return <span class="math">Y</span>. But we also need to lazily sample a point <span class="math">Z</span> for <span class="math">\\pi_{1}</span> that is consistent with our choice. If <span class="math">Y\\in S_{2}</span>, our decision is forced. On the other hand, if <span class="math">Y\\in S_{1}</span>, we can choose any value for <span class="math">Z\\in S^{\\prime}=\\overline{\\text{Reg}(\\pi_{1})}\\cap\\{z\\,:\\,z\\oplus h_{1}(T_{i})\\oplus h_{2}(T_{i})\\not\\in\\text{Dom}(\\pi_{2})\\}</span>. Sampling <span class="math">Z\\xleftarrow{\\mathsf{s}}S^{\\prime}</span> uniformly satisfies the need for the joint distribution on <span class="math">(Z,Y_{i})</span> to be identical in Games G3 and G4; e.g., in Game G4, for any fixed <span class="math">z\\in S^{\\prime}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\,Z=z\\,\\right]=\\Pr\\left[\\,Z=z\\mid Y_{i}\\in S_{1}\\,\\right]\\Pr\\left[\\,Y\\in S_{1}\\,\\right]=\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\left(\\frac{N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N}\\right)=\\frac{1}{N}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(By construction, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.) Hence:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\,A^{G3}\\,;\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right]=\\Pr\\left[\\,A^{G4}\\,;\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right],\\text{ and }\\Pr\\left[\\,A^{G3}\\Rightarrow 1\\,\\right]=\\Pr\\left[\\,A^{G4}\\Rightarrow 1\\,\\right].</span></p>

    <p class="text-gray-300">Then in Game G5, we return <span class="math">Y^{\\prime}</span> instead of <span class="math">Y</span> after sampling <span class="math">(Y,Y^{\\prime})\\xleftarrow{\\mathsf{s}}\\Gamma(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span>. Since <span class="math">Y\\neq Y^{\\prime}</span> only with probability <span class="math">\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span>, most of the time these two games will behave identically. We set <span class="math">\\mathsf{bad}_{3}</span> when they do not:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\,A^{G4}\\,;\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right]-\\Pr\\left[\\,A^{G5}\\,;\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right]\\leq\\Pr\\left[\\,A^{G5}\\,;\\,\\mathsf{bad}_{3}\\,\\right],</span> <span class="math">\\Pr\\left[\\,A^{G4}\\Rightarrow 1\\,\\right]-\\Pr\\left[\\,A^{G5}\\Rightarrow 1\\,\\right]\\leq\\Pr\\left[\\,A^{G5}\\,;\\,\\mathsf{bad}_{3}\\,\\right].</span></p>

    <p class="text-gray-300">Now that we return <span class="math">Y^{\\prime}</span> instead of <span class="math">Y</span>, the random variable <span class="math">Y</span> serves no direct function. So in Game G6, we forgo assigning <span class="math">Y</span>. Instead, we sample <span class="math">Y_{i}\\xleftarrow{\\mathsf{s}}\\mathcal{Y}_{i}</span>, and then set <span class="math">\\mathsf{bad}_{3}</span> with probability <span class="math">\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span>. Values for <span class="math">\\pi_{1}</span> and <span class="math">\\pi_{2}</span> are chosen as before. Thus, Games G5 and G6 are equivalent.</p>

    <p class="text-gray-300">At this point, <span class="math">Y_{i}</span> is always sampled from <span class="math">\\mathcal{Y}_{i}</span>, and once assigned, its value is never changed.</p>

    <p class="text-gray-300">In Game G7, we give the adversary control over what value is assigned to <span class="math">Y_{i}</span> (or <span class="math">X_{i}</span>, in the case of decryption queries), but insist that the value be in <span class="math">\\mathcal{Y}_{i}</span> or <span class="math">\\mathcal{X}_{i}</span>, as appropriate. Because the adversary can compute <span class="math">\\mathcal{Y}_{i}</span> and <span class="math">\\mathcal{X}_{i}</span>, he may simulate the oracles of Game G6 if desired; hence, he can set the <span class="math">\\mathsf{bad}</span> flags in Game G7 with probability at least as high as any adversary can set the corresponding flags in Game G6. The oracle’s outputs are now deterministic, and may be (trivially) computed by the adversary in advance. Hence, we may assume without loss of generality that the adversary is non-adaptive.</p>

    <p class="text-gray-300">For the rest of this proof, all probabilities will be with respect to the experiment <span class="math">A^{G7}</span> (unless the experiment is explicitly stated).</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{Q}</span> be the event that for there exist <span class="math">i</span>, <span class="math">j</span>, and <span class="math">k</span> (with <span class="math">j,k\\neq i</span>) such that <span class="math">X_{i}\\oplus h_{1}(T_{i})=X_{j}\\oplus h_{1}(T_{j})</span> and <span class="math">Y_{i}\\oplus h_{2}(T_{i})=Y_{k}\\oplus h_{2}(T_{k})</span>. That is, <span class="math">\\mathcal{Q}</span> indicates the <span class="math">i^{\\text{th}}</span> query is responsible for collisions at both <span class="math">\\pi_{1}</span> and <span class="math">\\pi_{2}</span>. Our strategy is to show that <span class="math">\\mathcal{Q}</span> is extremely unlikely, since it requires two independent collisions involving a single query. Barring such a query, we can show that the probability of a bad flag being set is very small.</p>

    <p class="text-gray-300">By definition of <span class="math">\\mathcal{Q}</span> and the <span class="math">\\epsilon</span>-<span class="math">\\text{AXU}_{2}</span> property of <span class="math">H</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\,\\mathcal{Q}\\,\\right]\\leq\\sum_{i=1}^{q}\\sum_{j,k\\neq i}\\Pr\\left[\\,h_{1}(T_{j})\\oplus h_{1}(T_{i})=X_{j}\\oplus X_{i}\\,\\right]\\Pr\\left[\\,h_{2}(T_{k})\\oplus h_{2}(T_{i})=Y_{k}\\oplus Y_{i}\\,\\right]&lt;q^{3}\\epsilon^{2}.</span></p>

    <p class="text-gray-300">Define <span class="math">\\beta_{j}=\\max_{\\widetilde{A}}\\left(\\Pr\\left[\\ \\widetilde{A}^{G7}\\,:\\,\\mathsf{bad}_{j}\\mid\\lnot\\mathcal{Q}\\,\\right]\\right)</span> and <span class="math">\\beta_{j}(i)=\\max_{\\widetilde{A}}\\left(\\Pr\\left[\\ \\widetilde{A}^{G7}\\,:\\,\\mathsf{bad}_{j}\\text{ on query }i\\mid\\lnot\\mathcal{Q}\\,\\right]\\right)</span>. We consider the event in the latter definition to “trigger” even if it has also triggered on an earlier query. (This definition assumes <span class="math">q</span> is not so large that <span class="math">\\Pr\\left[\\ \\lnot\\mathcal{Q}\\,\\right]=0</span>, but since our bound becomes vacuous before this threshold, this is not an issue.) When bounding <span class="math">\\beta_{j}(i)</span>, we will assume the <span class="math">i^{\\text{th}}</span> query is made to the encryption oracle; as before, the other case is symmetric.</p>

    <p class="text-gray-300">Because <span class="math">\\mathsf{bad}_{2}</span> can only be set if the conditions for <span class="math">\\mathcal{Q}</span> are met, we immediately have that <span class="math">\\beta_{2}\\leq\\Pr\\left[\\ \\mathcal{Q}\\,\\right]\\leq q^{3}\\epsilon^{2}</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{bad}_{1}</span> is set on query <span class="math">i</span> if and only if there exist <span class="math">j,k&lt;i</span> such that</p>

    <p class="text-gray-300"><span class="math">X_{i}\\oplus h_{1}(T_{i})=X_{j}\\oplus h_{1}(T_{j})\\quad\\text{and}\\quad\\pi_{1}(L_{i})\\oplus h_{1}(T_{i})\\oplus h_{2}(T_{i})=\\pi_{1}(L_{k})\\oplus h_{1}(T_{k})\\oplus h_{2}(T_{k}),</span></p>

    <p class="text-gray-300">where we remind the reader that <span class="math">L_{i}=X_{i}\\oplus h_{1}(T_{i})</span>. Our goal now is to bound</p>

    <p class="text-gray-300"><span class="math">\\beta_{1}(i)=\\Pr\\left[\\ \\exists k&lt;i\\ :\\ \\pi_{1}(L_{i})\\oplus\\pi_{1}(L_{k})=R(i,k)\\mid\\exists j&lt;i\\ :\\ L_{i}=L_{j}\\land\\lnot\\mathcal{Q}\\,\\right]\\cdot\\Pr\\left[\\ \\exists j&lt;i\\ :\\ L_{i}=L_{j}\\mid\\lnot\\mathcal{Q}\\,\\right],</span></p>

    <p class="text-gray-300">where for brevity we introduce <span class="math">R(i,k)=h_{1}(T_{i})\\oplus h_{2}(T_{i})\\oplus h_{1}(T_{k})\\oplus h_{2}(T_{k})</span>.</p>

    <p class="text-gray-300">Because queries are unique and <span class="math">\\widetilde{E}(T_{i},\\cdot)</span> is a permutation, <span class="math">L_{i}=L_{j}</span> is only possible if <span class="math">T_{i}\\neq T_{j}</span>, bringing the <span class="math">\\epsilon</span>-AXU_{2} property into scope. Hence</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ \\exists j&lt;i\\ :\\ L_{i}=L_{j}\\mid\\lnot\\mathcal{Q}\\,\\right]</span> <span class="math">=\\frac{\\Pr\\left[\\ \\exists j&lt;i\\ :\\ L_{i}=L_{j}\\land\\lnot\\mathcal{Q}\\,\\right]}{\\Pr\\left[\\ \\lnot\\mathcal{Q}\\,\\right]}</span> <span class="math">\\leq\\frac{\\Pr\\left[\\ \\exists j&lt;i\\ :\\ L_{i}=L_{j}\\,\\right]}{1-q^{3}\\epsilon^{2}}\\leq\\frac{q\\epsilon}{1-q^{3}\\epsilon^{2}}.</span></p>

    <p class="text-gray-300">We now wish to bound <span class="math">\\Pr\\left[\\ \\exists k&lt;i\\ :\\ \\pi_{1}(L_{i})\\oplus\\pi_{1}(L_{k})=R(i,k)\\mid\\exists j&lt;i\\ :\\ L_{i}=L_{j}\\land\\lnot\\mathcal{Q}\\,\\right]</span> (the other factor in our bound for <span class="math">\\beta_{1}(i)</span>), so assume that there is some <span class="math">j&lt;i</span> such that <span class="math">L_{i}=L_{j}</span> and that <span class="math">\\lnot\\mathcal{Q}</span>.</p>

    <p class="text-gray-300">Fix <span class="math">k\\in[1..i-1]</span>. Consider the case that <span class="math">L_{i}=L_{k}</span>. Then <span class="math">\\pi_{1}(L_{i})=R(i,k)</span> is equivalent to <span class="math">h_{1}(T_{i})\\oplus h_{1}(T_{k})=h_{2}(T_{i})\\oplus h_{2}(T_{k})</span>. Because queries must respect per-tweak permutivity, <span class="math">T_{i}\\neq T_{k}</span>; hence by the <span class="math">\\epsilon</span>-AXU_{2} property of <span class="math">H</span>, in this case <span class="math">\\beta_{1}(i)\\leq\\epsilon</span>.</p>

    <p class="text-gray-300">On the other hand, if <span class="math">L_{i}\\neq L_{k}</span>, we will trace the execution history of the game backwards to when the values eventually assigned to <span class="math">\\pi_{1}(L_{i})</span> and <span class="math">\\pi_{1}(L_{k})</span> become determined. Define root<span class="math">(x)=\\min\\left\\{m\\ :\\ L_{x}=L_{m}\\right\\}</span>. Let <span class="math">i^{\\prime}=\\text{root}(i)</span>, and let <span class="math">k^{\\prime}=\\text{root}(k)</span>. Since <span class="math">L_{i}=L_{j}</span> for some <span class="math">j&lt;i</span>, it follows that <span class="math">i^{\\prime}&lt;i</span>. Therefore, by our assumption that <span class="math">\\mathcal{Q}</span> does not occur, there is no <span class="math">\\ell\\neq i^{\\prime}</span> such that <span class="math">Y_{\\ell}\\oplus h_{2}(T_{\\ell})=Y_{i^{\\prime}}\\oplus h_{2}(T_{i^{\\prime}})</span>. Hence on query <span class="math">i^{\\prime}</span>, <span class="math">\\pi_{1}(L_{i})</span> is sampled from a set of size at least <span class="math">2^{n}-2q</span>; this sampling occurs indirectly through the random variable <span class="math">Z</span>, itself sampled either on Line 813 or 836, depending on which oracle receives query <span class="math">i^{\\prime}</span>.</p>

    <p class="text-gray-300">Now we compute when the value of <span class="math">\\pi_{1}(L_{k})=\\pi_{1}(L_{k^{\\prime}})</span> is determined. If there is no <span class="math">\\ell&lt;k^{\\prime}</span> such that <span class="math">Y_{\\ell}\\oplus h_{2}(T_{\\ell})=Y_{k^{\\prime}}\\oplus h_{2}(T_{k^{\\prime}})</span>, then <span class="math">\\pi_{1}(L_{k^{\\prime}})</span> is likewise sampled indirectly from a set of size at least <span class="math">2^{n}-2q</span>. However, if such an <span class="math">\\ell</span> exists, then <span class="math">\\pi_{1}(L_{k})=\\pi_{2}^{-1}(Y_{k^{\\prime}}\\oplus h_{2}(T_{k^{\\prime}}))\\oplus h_{2}(T_{k^{\\prime}})\\oplus h_{1}(T_{k^{\\prime}})</span>, and we are forced to backtrack further to when <span class="math">\\pi_{2}^{-1}(Y_{\\ell}\\oplus h_{2}(T_{\\ell}))=\\pi_{2}^{-1}(Y_{k^{\\prime}}\\oplus h_{2}(T_{k^{\\prime}}))</span> was defined. Fortunately, our assumption that the conditions for <span class="math">\\mathcal{Q}</span> are not met saves us from having to backtrack far. Let <span class="math">\\ell^{\\prime}=\\min\\left\\{m\\ :\\ Y_{\\ell}\\oplus h_{2}(T_{\\ell})=Y_{m}\\oplus h_{2}(T_{m})\\right\\}</span>. Then <span class="math">\\lnot\\mathcal{Q}</span> implies <span class="math">\\ell^{\\prime}=\\text{root}(\\ell^{\\prime})</span>. Hence on query <span class="math">\\ell^{\\prime}</span>, <span class="math">\\pi_{2}^{-1}(Y_{\\ell^{\\prime}}\\oplus h_{2}(T_{\\ell^{\\prime}}))=\\pi_{2}^{-1}(Y_{\\ell}\\oplus h_{2}(T_{\\ell}))</span> is sampled, through <span class="math">Z</span>, from a set of size at least <span class="math">2^{n}-2q</span>. In the first of these two cases, let <span class="math">r=k^{\\prime}</span>; in the second, let <span class="math">r=\\ell^{\\prime}</span>. After query <span class="math">r</span> completes, the value which will be assigned to <span class="math">\\pi_{1}(L_{k})</span> is deterministic.</p>

    <p class="text-gray-300">Suppose without loss of generality that <span class="math">i^{\\prime}&gt;r</span>. Then <span class="math">\\pi_{1}(L_{i})=\\pi_{1}(L_{k})\\oplus R(i,k)</span> only if on query <span class="math">i^{\\prime}</span>, <span class="math">\\pi_{1}(L_{i})=\\pi_{1}(L_{i^{\\prime}})</span> is assigned the unique value that makes the former equation true; this happens with probability at most <span class="math">1/(2^{n}-2q)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{\\epsilon}=\\max(\\epsilon,1/(2^{n}-2q))</span>. Then <span class="math">\\Pr\\left[\\ \\pi_{1}(L_{i})\\oplus\\pi_{1}(L_{k})=R(i,k)\\mid\\exists j&lt;i\\ :\\ L_{i}=L_{j}\\land\\lnot\\mathcal{Q}\\,\\right]\\leq\\hat{\\epsilon}</span>. We have</p>

    <p class="text-gray-300"><span class="math">\\beta_{1}\\leq\\sum_{i=1}^{q}\\beta_{1}(i)\\leq\\sum_{i=1}^{q}\\sum_{k=1}^{i-1}\\frac{q\\hat{\\epsilon}^{2}}{1-q^{3}\\hat{\\epsilon}}&lt;\\frac{q^{3}\\hat{\\epsilon}^{2}}{1-q^{3}\\hat{\\epsilon}^{2}}.</span></p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Our final task is to bound <span class="math">\\Pr\\left[\\mathsf{bad}_{3}\\right]=\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span>. For <span class="math">j=1,2,3</span>, define <span class="math">\\Delta_{j}=\\sum_{y\\in S_{j}}\\left(p_{\\mathsf{lazy}}(y)-p_{\\mathsf{TBC}}(y)\\right)</span>. Since for any <span class="math">y,y^{\\prime}\\in S_{j}</span>, <span class="math">p_{\\mathsf{lazy}}(y)=p_{\\mathsf{lazy}}(y^{\\prime})</span> (and <span class="math">p_{\\mathsf{TBC}}</span> is constant in these sets), we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\beta_{3}(i)=\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})=\\frac{1}{2}\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The law of total probability tells us that <span class="math">\\Delta_{1}+\\Delta_{2}+\\Delta_{3}=0</span>, and by construction of <span class="math">S_{3}</span>, <span class="math">\\Delta_{3}\\leq 0</span>. Further, since <span class="math">\\pi_{2}^{-1}(S_{4})\\oplus h_{2}(T_{i})\\oplus h_{1}(T_{i})\\subseteq R\\mathrm{ng}(\\pi_{1})</span>, we have that for <span class="math">y\\in S_{2}</span>: $p_{\\mathsf{lazy}}(y)-p_{\\mathsf{TBC}}(y)=1/N-1/(2^{n}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\geq 0<span class="math">. That is, </span>\\Delta_{2}\\geq 0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We therefore are left with two possibilities: either <span class="math">\\Delta_{1}\\leq 0</span> (in which case <span class="math">\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})=\\Delta_{2}</span>), or <span class="math">\\Delta_{1}&gt;0</span> (in which case <span class="math">\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})=-\\Delta_{3}</span>). Hence, <span class="math">\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})\\leq\\max(\\Delta_{2},-\\Delta_{3})</span>.</p>

    <p class="text-gray-300">The quantity <span class="math">\\Delta_{2}</span> can be bounded as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Delta_{2}</span> $=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\frac{1}{N}-\\frac{1}{2^{n}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\leq\\frac{q}{N(2^{n}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\left(2^{n}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-N\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq\\frac{q}{N(2^{n}-q)}\\left(2^{n}-N\\right)\\leq\\frac{q}{N(2^{n}-q)}\\left(2^{n}-(2^{n}-q)\\right)</span> <span class="math">=\\frac{q^{2}}{(2^{n}-q)^{2}}.</span></p>

    <p class="text-gray-300">It remains to bound <span class="math">-\\Delta_{3}=\\Pr\\left[Y\\stackrel{{\\scriptstyle\\mathsf{s}}}{{\\leftarrow}}\\mathcal{Y}_{i}\\,;\\,Y\\in S_{3}\\right]</span>. Note that <span class="math">Y\\in S_{3}</span> only if there exists <span class="math">j,k&lt;i</span> such that <span class="math">X_{j}\\oplus h_{1}(T_{j})=X_{i}\\oplus h_{1}(T_{i})</span> and <span class="math">Y_{k}\\oplus h_{2}(T_{k})=Y\\oplus h_{1}(T_{i})</span>. We appeal to the <span class="math">\\epsilon</span>-AXU_{2} property as before to argue that the probability of such <span class="math">j</span> and <span class="math">k</span> existing is at most <span class="math">(q\\epsilon)^{2}</span>.</p>

    <p class="text-gray-300">In both cases, then, <span class="math">\\beta_{3}(i)=\\delta(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})\\leq q^{2}\\hat{\\epsilon}^{2}</span>. (Recall that <span class="math">\\hat{\\epsilon}=\\max\\left\\{\\epsilon,1/(2^{n}-2q)\\right\\}</span>.) Therefore <span class="math">\\beta_{3}\\leq q^{3}\\hat{\\epsilon}^{2}</span>. By the fundamental lemma of game playing,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\,A^{\\widehat{E}_{h_{1},h_{2},\\pi_{1},\\pi_{2}(\\cdot,\\cdot),\\widehat{E}_{h_{1},h_{2},\\pi_{1},\\pi_{2}}^{-\\mathrm{1}}(\\cdot,\\cdot)}}\\Rightarrow 1\\,\\right]</span> <span class="math">=\\Pr\\left[\\,A^{G\\!I}\\Rightarrow 1\\,\\right]</span> <span class="math">\\leq\\Pr\\left[\\,A^{G\\!J}\\Rightarrow 1\\,\\right]+\\Pr\\left[\\,A^{G\\!J}\\,:\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right]</span> <span class="math">\\leq\\Pr\\left[\\,A^{G\\!6}\\Rightarrow 1\\,\\right]+\\Pr\\left[\\,A^{G\\!6}\\,:\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right]+2\\Pr\\left[\\,A^{G\\!6}\\,:\\,\\mathsf{bad}_{3}\\,\\right]</span> <span class="math">\\leq\\Pr\\left[\\,A^{G\\!6}\\Rightarrow 1\\,\\right]+\\Pr\\left[\\,A^{G\\!7}\\,:\\,\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}\\,\\right]+2\\Pr\\left[\\,A^{G\\!7}\\,:\\,\\mathsf{bad}_{3}\\,\\right]</span> <span class="math">\\leq\\Pr\\left[\\,A^{G\\!6}\\Rightarrow 1\\,\\right]+\\beta_{1}+\\Pr\\left[\\,{\\mathcal{Q}}\\,\\right]+2\\beta_{3}</span> <span class="math">\\leq\\Pr\\left[\\,A^{I\\!I(\\cdot,\\cdot),I\\!I^{-1}(\\cdot,\\cdot)}\\Rightarrow 1\\,\\right]+\\frac{4q^{3}\\hat{\\epsilon}^{2}}{1-q^{3}\\hat{\\epsilon}^{2}}.</span></p>

    <p class="text-gray-300">Thus by a standard argument, there exists a <span class="math">B</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{sprp}}_{E}(A)\\leq 2\\mathbf{Adv}^{\\mathrm{sprp}}_{E}(B)+\\frac{4q^{3}\\hat{\\epsilon}^{2}}{1-q^{3}\\hat{\\epsilon}^{2}}.</span></p>

    <p class="text-gray-300">This completes the proof. ∎</p>

    <p class="text-gray-300">A note on an error in a previous version. The original version of this paper attempted to, in effect, construct <span class="math">\\Gamma(p_{\\mathsf{lazy}},p_{\\mathsf{TBC}})</span> explicitly — but failed to do so correctly: we erroneously made a tacit assumption that <span class="math">\\Delta_{1}\\geq 0</span>. We thank Gordon Procter for bringing this mistake to our attention. Procter also helpfully provided a suggested patch <em>[28]</em>, which uses an if/else clause in the game-playing proof to address the two cases <span class="math">\\Delta_{1}\\geq 0</span> and <span class="math">\\Delta_{1}&lt;0</span> separately. We believe Procter’s solution succeeds in fixing the problem. Ultimately, however, we decided to use a coupling distribution to abstract the details of transitioning from <span class="math">p_{\\mathsf{lazy}}</span> to <span class="math">p_{\\mathsf{TBC}}</span>. This simplifies some of the arguments, but admittedly sacrifices some of the explicitness present in Procter’s proof.</p>

    <p class="text-gray-300">Attacks on simpler variants. Having seen our construction, one wonder if simpler variants work. For example, consider CLRW2 without the first <span class="math">H_{h_{2}}(T)</span> XOR operation, leaving</p>

    <p class="text-gray-300"><span class="math">\\widetilde{E}_{h_{1},h_{2},K_{1},K_{2}}(T,X)=H_{h_{2}}(T)\\oplus E_{K_{2}}(H_{h_{1}}(T)\\oplus E_{K_{1}}(H_{h_{1}}(T)\\oplus X)).</span></p>

    <p class="text-gray-300">This variation permits birthday-bound attack. Namely, an adversary could submit queries in pairs, <span class="math">(T_{i},X^{\\prime})</span> and <span class="math">(T_{i},X^{\\prime\\prime})</span>, where <span class="math">X^{\\prime}</span> and <span class="math">X^{\\prime\\prime}</span> are fixed, and a new random tweak is used for each pair. By remembering the values <span class="math">\\widetilde{E}(T_{i},X^{\\prime})\\oplus\\widetilde{E}(T_{i},X^{\\prime\\prime})</span>, which are independent of <span class="math">H_{h_{2}}</span>, it could detect collisions in <span class="math">H_{h_{1}}</span>, say by using a hash table. That is, if <span class="math">H_{h_{1}}(T_{i})=H_{h_{1}}(T_{j})</span>, then <span class="math">\\widetilde{E}(T_{i},X^{\\prime})\\oplus\\widetilde{E}(T_{i},X^{\\prime\\prime})=\\widetilde{E}(T_{j},X^{\\prime})\\oplus\\widetilde{E}(T_{j},X^{\\prime\\prime})</span>. The converse is false, but false positives could be weeded out by testing a small number of <span class="math">X</span>-values. Such an adversary would gain advantage close to one. Similar variations on <span class="math">\\widetilde{E}</span> permit analogous attacks, though we believe (but do not prove) that omitting the second <span class="math">H_{h_{1}}(T)</span> XOR operation yields a construction secure against adversaries constrained to chosen-plaintext attacks.</p>

    <p class="text-gray-300">One might also wish to try setting <span class="math">K_{2}=K_{1}</span>. While we know of no attacks here, modifying our proof to accomodate this change would be non-trivial. In particular, bounding <span class="math">\\beta_{1}</span> required us to trace back through a game’s execution history to determine when <span class="math">\\pi_{1}</span> became defined at particular points; this task would be messier and more difficult to verify if <span class="math">\\pi_{2}=\\pi_{1}</span>. Still, this may merit future investigation.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 PRF-security of TBC-MAC</h2>

    <p class="text-gray-300">The TBC-MAC function family. Fix <span class="math">k,n&gt;0</span> and let <span class="math">\\widetilde{E}\\colon\\{0,1\\}^{k}\\times\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{n}</span> be a tweakable blockcipher. We define the TBC-MAC function family <span class="math">\\mathsf{TBCMAC}[\\widetilde{E}]\\colon\\{0,1\\}^{k}\\times(\\{0,1\\}^{n})^{+}\\rightarrow\\{0,1\\}^{n}</span> as follows. On input <span class="math">K\\in\\{0,1\\}^{k}</span> and <span class="math">M\\in(\\{0,1\\}^{n})^{+}</span>, let <span class="math">\\mathsf{TBCMAC}[\\widetilde{E}]_{K}(T,M)=T_{b}</span> where <span class="math">T_{0}=0^{n}</span>; let <span class="math">M_{1},\\cdots,M_{b}\\stackrel{{\\scriptstyle\\sigma}}{{{\\leftarrow}}}M</span>, and <span class="math">T_{i}\\leftarrow\\widetilde{E}_{K}(T_{i-1},M_{i})</span> for <span class="math">i\\in\\{1,\\ldots,b\\}</span>. To extend the domain to <span class="math">\\{0,1\\}^{<em>}</span>, one could introduce an explicit, unambiguous padding rule mapping <span class="math">\\{0,1\\}^{</em>}\\rightarrow(\\{0,1\\}^{n})^{+}</span>, say mapping <span class="math">M\\mapsto M\\parallel 10^{r}</span> where <span class="math">r</span> is the smallest integer needed to reach a block boundary. But for simplicity we assume that all strings input to <span class="math">\\mathsf{TBCMAC}[\\widetilde{E}]</span> are block-aligned. We extend this assumption by writing <span class="math">\\mathsf{TBCMAC}^{\\mathsf{pf}}</span> for the TBC-MAC construction restricted to prefix-free encoded, block-aligned inputs.</p>

    <p class="text-gray-300">Building from a “narrow” tweaksize TBC. Our first result in this section is a natural one. We prove that TBC-MAC is a secure PRF if the underlying TBC <span class="math">\\widetilde{E}</span>, with <span class="math">n</span>-bit tweaks and blocksize, is secure as a tweakable-PRP. One might hope that the security bound for <span class="math">\\mathsf{TBCMAC}[\\widetilde{E}]</span> is better than for CBC-MAC over an <span class="math">n</span>-bit blockcipher, since the former is intuitively a “stronger” object than the latter. This is not the case. This is because the <span class="math">IV</span> is fixed; thus an adversary can ask a series of distinct one-block messages and wait for a collision. Considering the information-theoretic setting, the fixed <span class="math">IV</span> effectively reduces the ideal cipher to a random permutation in the first round, and so the standard PRP-PRF distinguishing attack forces us to accept birthday-bound security. The following theorem closely follows the code-based game-playing proof of CBC-MAC due to Bellare and Rogaway <em>[5]</em>. We note that a tighter bound could be achieved (with more work) following the techniques of Bellare et al. <em>[4]</em>. The proof appears in Appendix B .</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">(<span class="math">\\mathsf{TBCMAC}</span> is a PRF.) Fix <span class="math">n&gt;0</span>. Let <span class="math">\\widetilde{E}\\colon\\{0,1\\}^{n}\\times(\\{0,1\\}^{n}\\times\\{0,1\\}^{n})\\rightarrow\\{0,1\\}^{n}</span> be a tweakable blockcipher. Let <span class="math">A</span> be an adversary running in time <span class="math">t</span>, asking <span class="math">q</span> queries, each of length at most <span class="math">\\ell</span> blocks of <span class="math">n</span>-bits. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{prf}}_{\\mathsf{TBCMAC}[\\widetilde{E}]}(A)\\leq\\mathbf{Adv}^{\\mathrm{prp}}_{\\widetilde{E}}(B)+\\frac{(q\\ell)^{2}}{2^{n}}</span></p>

    <p class="text-gray-300">for an adversary <span class="math">B</span> that runs in time <span class="math">t^{\\prime}=t+\\mathcal{O}(\\ell q)</span> and asks at most <span class="math">q^{\\prime}=q\\ell</span> queries.</p>

    <p class="text-gray-300">Building from a “wide” tweaksize TBC. The LRW2 and CLRW2 constructions each give TBC that can handle tweaks that are potentially much larger than the blocksize. So we now consider the security of a nonce-based version of TBC-MAC based upon such a TBC. In particular, fix <span class="math">k,n,b&gt;0</span> and let <span class="math">\\widetilde{E}\\colon\\{0,1\\}^{k}\\times(\\{0,1\\}^{n+b+1}\\times\\{0,1\\}^{n})\\rightarrow\\{0,1\\}^{n}</span> be a tweakable blockcipher with tweaksize <span class="math">n+b+1</span> bits and blocksize <span class="math">n</span> bits. For an <span class="math">\\ell</span>-block message <span class="math">M_{1},\\ldots,M_{\\ell}</span> where <span class="math">\\ell&gt;1</span>, nonce <span class="math">N\\in\\{0,1\\}^{b}</span>, and a fixed <span class="math">T_{0}=IV</span>, define <span class="math">\\mathsf{TBCMAC2}[\\widetilde{E}]_{K}(N,M)</span> as <span class="math">T_{\\ell}=\\widetilde{E}_{K}(T_{\\ell-1}\\parallel 1\\parallel N,M_{\\ell})</span> where for <span class="math">i=1</span> to <span class="math">\\ell-1</span>, <span class="math">T_{i}=\\widetilde{E}_{K}(T_{i-1}\\parallel 0\\parallel 0^{b},M_{i})</span>. We say that a PRF-adversary <span class="math">A</span> is <em>nonce-respecting</em> (for <span class="math">\\mathsf{TBCMAC2}</span>) if it never repeats a nonce. The <em>multiplicity</em> <span class="math">\\alpha</span> of a nonce <span class="math">N</span> is the number of times it is used in an attack, e.g. <span class="math">\\alpha=1</span> for every nonce if the attack is nonce-respecting.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">(<span class="math">\\mathsf{TBCMAC2}</span> is a PRF.) Fix <span class="math">n&gt;0</span> and <span class="math">b\\geq 0</span>. Let <span class="math">\\widetilde{E}\\colon\\{0,1\\}^{n}\\times(\\{0,1\\}^{n+b+1}\\times\\{0,1\\}^{n})\\rightarrow\\{0,1\\}^{n}</span> be a tweakable blockcipher. Let <span class="math">\\mathsf{TBCMAC2}[\\widetilde{E}]</span> be as described above. Let <span class="math">A</span> be an adversary that runs in time <span class="math">t</span>,</p>

    <p class="text-gray-300"><span class="math">q</span> queries for the form <span class="math">(N,M)</span> where the length of <span class="math">M</span> is at most <span class="math">\\ell</span> blocks. Assume that there are <span class="math">r</span> distinct values of <span class="math">N</span> among these queries, and let <span class="math">\\alpha_{1},\\ldots,\\alpha_{r}</span> denote the multiplicities of these. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{prf}}_{\\mathsf{TBCMAC2}[\\widetilde{E}]}(A)\\leq\\mathbf{Adv}^{\\widetilde{\\mathrm{prp}}}_{\\widetilde{E}}(B)+\\frac{1}{2^{n+1}}\\left(\\sum_{i=1}^{r}\\alpha_{i}(\\alpha_{i}-1)\\right)+\\sum_{i=1}^{r}\\binom{\\alpha_{i}}{2}\\frac{(2\\ell+1)(2\\ell)}{2^{n}}</span></p>

    <p class="text-gray-300">where <span class="math">B</span> runs in time <span class="math">t^{\\prime}=t+\\mathcal{O}(q\\ell)</span> and asks at most <span class="math">q^{\\prime}=q\\ell</span> queries. Specifically, if <span class="math">A</span> is nonce-respecting, <span class="math">\\mathbf{Adv}^{\\mathrm{prf}}_{\\mathsf{TBCMAC2}[\\widetilde{E}]}(A)\\leq\\mathbf{Adv}^{\\widetilde{\\mathrm{prp}}}_{\\widetilde{E}}(B)</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The second claim follows immediately from the first, since <span class="math">\\alpha_{i}=1</span> for all <span class="math">i</span> if <span class="math">A</span> is nonce-respecting. So we prove the first claim.</p>

    <p class="text-gray-300">We omit proof of the standard switch from the complexity-theoretic to the information-theoretic setting, wherein adversary <span class="math">B</span> simulates the PRF experiment for <span class="math">\\mathsf{TBCMAC2}</span> over <span class="math">\\widetilde{E}_{K}</span> or <span class="math">\\Pi</span>, depending upon its own oracle. The remainder of the proof is the core technical piece, which proceeds by a sequence of code-based games.</p>

    <p class="text-gray-300">For ease of notation, we write <span class="math">\\mathsf{TBCMAC2}[\\Pi]</span> instead of <span class="math">\\mathsf{TBCMAC2}[\\mathrm{BC}(n+b+1,n)]_{\\Pi}</span> with the understanding that <span class="math">\\Pi</span> is a uniform element from <span class="math">\\mathrm{BC}(n+b+1,n)</span>. Also, in the psuedocode we use <span class="math">Dom(\\Pi(T,\\cdot))</span> to denote the set of domain points under the (lazily sampled) random permutation <span class="math">\\Pi(T,\\cdot)</span> that have been assigned a corresponding range value. Likewise, the set <span class="math">\\overline{\\mathit{Rng}}(\\Pi(T,\\cdot))</span> denotes the set of stings in <span class="math">\\{0,1\\}^{n}</span> that have not yet been associated to any domain point under <span class="math">\\Pi(T,\\cdot)</span>. Games are shown in Figure 4.</p>

    <p class="text-gray-300">Game <span class="math">G0</span> faithfully simulates <span class="math">\\mathsf{TBCMAC2}[\\Pi]</span>, using lazy sampling to establish the random <span class="math">\\Pi</span>. Game <span class="math">G1</span> does likewise, but always returns a uniform random string. Letting <span class="math">\\mathsf{bad}=\\mathsf{bad}_{1}\\vee\\mathsf{bad}_{2}</span>, we see that these games are identical-until-bad, so <span class="math">\\Pr\\left[\\,A^{G0}\\Rightarrow 1\\,\\right]-\\Pr\\left[\\,A^{G1}\\Rightarrow 1\\,\\right]\\leq\\Pr\\left[\\,A^{G1}\\,\\text{sets}\\,\\,\\mathsf{bad}\\,\\,\\right]</span>. Since <span class="math">G1</span> returns a random string no matter what the value of <span class="math">\\mathsf{bad}</span>, we drop unneccessary instructions and move to game <span class="math">G2</span> with <span class="math">\\Pr\\left[\\,A^{G1}\\,\\text{sets}\\,\\,\\mathsf{bad}\\,\\,\\right]=\\Pr\\left[\\,A^{G2}\\,\\text{sets}\\,\\,\\mathsf{bad}\\,\\,\\right]\\leq\\Pr\\left[\\,A^{G2}\\,\\text{sets}\\,\\,\\mathsf{bad}_{1}\\,\\,\\right]+\\Pr\\left[\\,A^{G2}\\,\\text{sets}\\,\\,\\mathsf{bad}_{2}\\,\\,\\right]</span>. It is easy to see that the first summand is at most <span class="math">(1/2^{n+1})\\sum_{i=1}^{r}(\\alpha_{i})(\\alpha_{i}-1)</span> by a union bound. Game <span class="math">G3</span> is the same as <span class="math">G2</span> with the setting of <span class="math">\\mathsf{bad}_{1}</span> removed. Thus we have <span class="math">\\Pr\\left[\\,A^{G1}\\,\\text{sets}\\,\\,\\mathsf{bad}\\,\\,\\right]\\leq(1/2^{n+1})(\\sum_{i=1}^{r}\\alpha_{i}(\\alpha_{i}-1))+\\Pr\\left[\\,A^{G3}\\,\\text{sets}\\,\\,\\mathsf{bad}_{2}\\,\\,\\right]</span>.</p>

    <p class="text-gray-300">The setting of <span class="math">\\mathsf{bad}_{2}</span> is more complicated to analyze, because the adversary controls <span class="math">M_{b}^{s}</span> and <span class="math">N^{s}</span>. We see that <span class="math">\\mathsf{bad}_{2}</span> is set only if for some <span class="math">1\\leq r&lt;s\\leq q</span> we have <span class="math">T_{b_{r}-1}^{r}=T_{b_{s}-1}^{s}</span> and <span class="math">N^{r}=N^{s}</span>. Notice that in terms of setting <span class="math">\\mathsf{bad}_{2}</span> the particular value assigned to <span class="math">\\Pi(T_{b_{s}-1}^{s}\\parallel N^{s},M_{b_{s}}^{s})</span> is irrelevant. It only matters that the domain point has been previously assigned a value. Moreover, these values are never used in the for-loop (because <span class="math">N^{s}=1\\parallel N</span>). So the adversary could itself have selected up front the values <span class="math">T_{b_{r}}^{s}</span> to be returned and, also up front, picked the <span class="math">q</span> pairs <span class="math">(\\mathtt{N},\\mathtt{M})</span> that optimize the chance of <span class="math">\\mathsf{bad}_{2}</span>. So in <span class="math">G4</span> we no longer sample <span class="math">T_{b_{s}}^{s}</span>, and no longer return any value; we simply mark domain points as defined. Thus <span class="math">\\Pr\\left[\\,A^{G3}\\,\\text{sets}\\,\\,\\mathsf{bad}_{2}\\,\\,\\right]\\leq\\Pr\\left[\\,A^{G4}\\,\\text{sets}\\,\\,\\mathsf{bad}_{2}\\,\\,\\right]</span>. Fix the optimal set of <span class="math">(\\mathtt{N},\\mathtt{M})</span> for setting <span class="math">\\mathsf{bad}_{2}</span> in <span class="math">G4</span>. Finally in game <span class="math">G5</span> we delay the setting of <span class="math">\\mathsf{bad}_{2}</span> until the end, exchange the procedure <span class="math">F</span> for a for-loop over the fixed nonce-message pairs, and sample the entire ideal cipher <span class="math">\\Pi</span> at the beginning instead of using lazy sampling. We note that <span class="math">G5</span> sets <span class="math">\\mathsf{bad}_{2}</span> at least as often as does <span class="math">G4</span>, since the latter only requires a tweak collision. Hence <span class="math">\\Pr\\left[\\,A^{G4}\\,\\text{sets}\\,\\,\\mathsf{bad}_{2}\\,\\,\\right]\\leq\\Pr\\left[\\,G5\\,\\text{sets}\\,\\,\\mathsf{bad}_{2}\\,\\,\\right].</span></p>

    <p class="text-gray-300">Once <span class="math">\\Pi</span> is fixed, the order in which the <span class="math">(\\mathtt{N}^{i},\\mathtt{M}^{i})</span>, <span class="math">i\\in[s]</span>, are put through the for-loop does not matter, so we assume that they are ordered lexicographically by their first component. Thus we can think of the messages as being processed in groups “named” by their common nonce value. By assumption, there are <span class="math">r</span> such groups with sizes <span class="math">\\alpha_{1},\\ldots,\\alpha_{r}</span>, respectively. Let <span class="math">\\mathsf{Coll}_{1},\\ldots,\\mathsf{Coll}_{r}</span> be the events that <span class="math">\\mathsf{bad}_{2}</span> is set by members of the corresponding groups. Then we have <span class="math">\\Pr\\left[\\,G5\\,\\text{sets}\\,\\,\\mathsf{bad}_{2}\\,\\,\\right]\\leq\\sum_{i=1}^{r}\\Pr\\left[\\,\\mathsf{Coll}_{i}\\,\\text{in }G5\\,\\,\\right]</span>. Collecting up results we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\,A^{G1}\\,\\text{sets}\\,\\,\\mathsf{bad}\\,\\,\\right]\\leq(2/2^{n})\\sum_{i=1}^{r}\\alpha_{i}(\\alpha_{i}-1)+\\sum_{i=1}^{r}\\Pr\\left[\\,\\mathsf{Coll}_{i}\\,\\text{in }G5\\,\\,\\right]\\;.</span></p>

    <p class="text-gray-300">At this point we notice that if <span class="math">\\alpha_{1}=\\cdots=\\alpha_{r}=1</span>, then all terms on the right side are zero. Thus if the attack is nonce-respecting, then our reduction is as tight as possible. In general, every <span class="math">i\\in[r]</span> for which <span class="math">\\alpha_{i}=1</span> contributes zero to the right side. Assume that <span class="math">\\alpha_{i}&gt;1</span> for some <span class="math">i\\in[r]</span>. The probability that <span class="math">\\mathsf{Coll}_{i}</span> is bounded as follows. Consider any two messages <span class="math">\\mathtt{M},\\mathtt{M}^{\\prime}</span> that are associated to the same nonce. By Lemma 2 we know the probability that these collide is at most <span class="math">(2\\ell)^{2}/2^{n}</span> since each message is at most <span class="math">\\ell</span> blocks long. By taking a union bound over all</p>

    <p class="text-gray-300">such pairs of messages we obtain</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Pr}\\left[A^{G1}\\text{ sets bad}\\right]\\leq (2 / 2^n)\\sum_{i = 1}^r\\alpha_i(\\alpha_i - 1) + \\sum_{i = 1}^r\\binom {\\alpha_i}{2}(2\\ell +1)(2\\ell) / 2^n</span></p>

    <p class="text-gray-300">and our proof is complete.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig.4. Games for Theorem 3. We write  <span class="math">\\mathbf{0}</span>  for  <span class="math">0\\parallel 0^{b}</span> , and  <span class="math">IV</span>  is some fixed string.</p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">TBC-MAC preserves the unforgeability of its underlying TBC when the TBC-MAC inputs are prefix-free. Since, qualitatively, this amounts to a new application of an existing result by Maurer and Sjödin [22], we defer our proof to Appendix D.</p>

    <p class="text-gray-300">Theorem 4. (TBCMAC<span class="math">^{pf}</span> preserves UF-CMA.) Fix <span class="math">k, n &amp;gt; 0</span>, and let <span class="math">\\widetilde{E} \\colon \\{0,1\\}^k \\times \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span> be a TBC. Let <span class="math">A</span> be an adversary for TBCMAC<span class="math">^{pf}[\\widetilde{E}]</span> that runs in time <span class="math">t</span>, asks <span class="math">q</span> queries, these totaling <span class="math">\\sigma</span> blocks of <span class="math">n</span>-bits in length. Then there exist adversaries <span class="math">B</span> and <span class="math">C</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {T B C M A C} ^ {\\mathrm {p f}} [ \\widetilde {E} ]} ^ {\\mathrm {U F - C M A}} (A) \\leq \\frac {\\sigma (\\sigma - 1)}{2} \\mathbf {A d v} _ {\\widetilde {E}} ^ {\\mathrm {U F - C M A}} (B) + \\mathbf {A d v} _ {\\widetilde {E}} ^ {\\mathrm {U F - C M A}} (C)</span></div>

    <p class="text-gray-300">where <span class="math">B</span> runs in time <span class="math">t_B \\leq t</span>, asks <span class="math">q_B \\leq \\sigma</span> queries totalling <span class="math">\\sigma_B \\leq 2\\sigma</span> blocks; and where <span class="math">C</span> runs in time <span class="math">t_C = t</span>, asks <span class="math">q_C = \\sigma</span> queries totalling <span class="math">\\sigma_C = 2\\sigma</span> blocks.</p>

    <p class="text-gray-300">However, if adversaries may mount an attack using non-prefix-free inputs, it is possible to forge TBC-MAC.³ The following lemma says that there exists a TBC <span class="math">\\widetilde{F}</span>, shown in Figure 12, that is unforgeable if some underlying TBC <span class="math">\\widetilde{E}</span> is. Liskov et al. [21] provide a TBC <span class="math">\\widetilde{E}</span> with the required signature.</p>

    <p class="text-gray-300">Lemma 1. Let <span class="math">\\widetilde{E}:\\{0,1\\}^k\\times \\{0,1\\}^{3n}\\times \\{0,1\\}^n\\to \\{0,1\\}^n</span> be a tweakable blockcipher. Let <span class="math">\\widetilde{F}:\\{0,1\\}^k\\times \\{0,1\\}^{2n}\\times \\{0,1\\}^{2n}\\to \\{0,1\\}^{2n}</span> be a tweakable blockcipher defined by</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde {F} _ {K} \\left(T _ {L} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {R}, X _ {L} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X _ {R}\\right) = X _ {L} \\oplus T _ {R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde {E} _ {K} \\left(X _ {L} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {L} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {R}, X _ {R}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Then <span class="math">\\mathbf{Adv}_{\\widetilde{F}}^{\\mathrm{uf - cma}}(A) \\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf - cma}}(B)</span> where the resources of adversaries <span class="math">A</span> and <span class="math">B</span> are the same.</p>

    <p class="text-gray-300">Proof. <span class="math">\\widetilde{F}</span> is a tweakable blockcipher because, given the tweak <span class="math">T</span> and key <span class="math">K</span>, one can invert <span class="math">\\widetilde{F}_K(T,X) = Y</span> by evaluating <span class="math">X = Y_L\\oplus T_R\\parallel \\widetilde{E}_K^{-1}(Y_L\\oplus T_R\\parallel T_L\\parallel T_R,Y_R)</span>. Therefore <span class="math">\\widetilde{F}_K(T,\\cdot)</span> is a permutation for every tweak <span class="math">T</span>.</p>

    <p class="text-gray-300">Now, let <span class="math">B</span> be a forging adversary for <span class="math">\\widetilde{E}</span> that runs as follows. Adversary <span class="math">B</span> runs <span class="math">A</span>, responding to <span class="math">A</span>'s queries by using its own oracle for <span class="math">\\widetilde{E}</span>. When <span class="math">A</span> outputs its forgery <span class="math">((T^{<em>},X^{</em>}),Y^{<em>})</span>, let <span class="math">B</span> output <span class="math">(X_{L}^{</em>}\\parallel T_{L}^{<em>}\\parallel T_{R}^{</em>},X_{R}^{<em>},Y_{R}^{</em>})</span> as its own forgery.</p>

    <p class="text-gray-300">If <span class="math">A</span>'s forgery is valid, it must be the case that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} Y ^ {<em>} = \\widetilde {F} _ {K} \\left(T ^ {</em>}, X ^ {<em>}\\right) \\\\ = X _ {L} ^ {</em>} \\oplus T _ {R} ^ {*} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde {E} _ {K} \\left(X _ {L} ^ {*} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {L} ^ {*} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {R} ^ {<em>}, X _ {R} ^ {</em>}\\right) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text {hence} Y _ {R} ^ {<em>} = \\widetilde {E} _ {K} \\left(X _ {L} ^ {</em>} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {L} ^ {*} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {R} ^ {<em>}, X _ {R} ^ {</em>}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It must also be the case that <span class="math">A</span>'s final query <span class="math">(T^{<em>},X^{</em>})</span> be a new query. This implies that $(X_{L}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{L}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{R}^{<em>},X_{R}^{</em>})<span class="math"> is a new query as well, as we have only rearranged the forgery&#x27;s </span>n<span class="math">-bit blocks. Clearly, then, </span>B<span class="math"> successfully forges whenever </span>A<span class="math"> does. Furthermore, </span>B<span class="math"> makes the same number of queries as </span>A<span class="math"> does. Therefore, if </span>A<span class="math"> runs in time </span>t<span class="math"> making </span>q<span class="math"> queries totalling </span>\\sigma<span class="math"> blocks, </span>\\mathbf{Adv}_{\\widetilde{F}}^{\\mathrm{uf - cma}}(A)\\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf - cma}}(B)<span class="math">, where the resources of </span>B<span class="math"> are </span>t^{\\prime} = t<span class="math">, </span>q^{\\prime} = q<span class="math"> queries, these totalling </span>\\sigma^{\\prime} = \\sigma<span class="math"> blocks. This is due to the fact that each of </span>A<span class="math">&#x27;s </span>q<span class="math"> queries contain a </span>2n<span class="math">-bit tweak and a </span>2n<span class="math">-bit message (a total of </span>4n<span class="math"> bits per query), and each of </span>B<span class="math">&#x27;s </span>q<span class="math"> queries contain a </span>3n<span class="math">-bit tweak and an </span>n<span class="math">-bit message (also totalling </span>4n$ bits per query).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now show that TBC-MAC instantiated with <span class="math">\\widetilde{F}</span> admits efficient forging attacks if arbitrary inputs are allowed.</p>

    <p class="text-gray-300">Theorem 5. (TBCMAC is not UF-CMA preserving.) Let <span class="math">\\widetilde{E}</span> be a tweakable blockcipher and let <span class="math">\\widetilde{F}</span> be as defined in Lemma 1. Then there exists an adversary <span class="math">A</span> that asks <span class="math">q = 2</span> queries totalling <span class="math">\\sigma = 12</span> blocks of <span class="math">n</span>-bits such that <span class="math">\\mathbf{Adv}_{\\mathsf{TBCMAC}[\\widetilde{F}]}^{\\mathrm{uf - cma}}(A) = 1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Consider the adversary <span class="math">A</span> that queries $Y^{1} \\gets \\mathsf{TBCMAC}[\\widetilde{F}]_{K}(0^{2n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{2n})<span class="math">, and then forges with </span>X^{<em>} = 0^{2n}<span class="math"> and </span>Y^{</em>} = 0^{n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{L}^{1}$. The forgery is valid; we leave the confirmation of this fact to the interested reader.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">³ We note that Bellare and Ristenpart [3] have already shown that the Merkle-Damgård iteration is not unforgeability preserving for arbitrary inputs. However, their counterexample does not suffice here, because the compression function they build is not a TBC.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] J. An and M. Bellare. Constructing VIL-MACs from FIL-MACs: Message authentication under weakened assumptions. Advances in Cryptology – CRYPTO 1999, LNCS vol. 1666, Springer, pp. 252–269, 1999.</li>

      <li>[2] M. Bellare, O. Goldreich and H. Krawczyk. Stateless evaluation of pseudorandom functions: Security beyond the birthday barrier. Advances in Cryptology – CRYPTO 1999, LNCS vol. 1666, Springer, pp. 270-287</li>

      <li>[3] M. Bellare and T. Ristenpart. Hash functions in the dedicated-key setting: Design choices and MPP transforms. International Colloquium on Automata, Languages, and Programming – ICALP 2007, LNCS vol. 4596, Springer, pp. 399–410, 2007.</li>

      <li>[4] M. Bellare, K. Pietrzak, P. Rogaway. Improved security analyses for CBC MACs. Advances in Cryptology – CRYPTO 2005, LNCS vol. 3621, Spring, pp. 527–541, 2005.</li>

      <li>[5] M. Bellare and P. Rogaway. The security of triple encryption and a framework for code-based game-playing proofs. Advances in Cryptology – EUROCRYPT 2006, LNCS vol. 4004, Springer, pp. 409–426, 2006.</li>

      <li>[6] J. Black and M. Cochran. MAC Reforgability. Fast Software Encryption – FSE 2009, LNCS vol. 5665, Springer, pp. 345–362, 2009.</li>

      <li>[7] J. Black, P. Rogaway, T. Shrimpton and M. Stam. An analysis of the blockcipher-based hash functions from PGV. Journal of Cryptology, vol. 23, no. 4, pp. 320–325, Springer, 2010.</li>

      <li>[8] D. Chakraborty and P. Sarkar. A new mode of encryption providing a tweakable strong pseudo-random permutation. Fast Software Encryption – FSE 2006, LNCS vol. 4047, Springer, pp. 293-309, 2006</li>

      <li>[9] J-S. Coron, Y. Dodis, A. Mandal and Y. Seurin. A Domain Extender for the Ideal Cipher. Theory of Cryptography – TCC 2010, LNCS vol. 5978, Springer, pp. 273-289, 2010.</li>

      <li>[10] P. Crowley. Mercy: A Fast Large Block Cipher for Disk Sector Encryption. Fast Software Encryption – FSE 2000, LNCS 19787, pp. 49-63, 2000.</li>

      <li>[11] I. Damgård. A design principle for hash functions. Advances in Cryptology – CRYPTO 1989, LNCS vol. 435, Springer, pp. 416–427, 1989.</li>

      <li>[12] Y. Dodis, K. Pietrzak and P. Puniya. A new mode of operation for block ciphers and length-preserving MACs. Advances in Cryptology – EUROCRYPT 2008, LNCS vol. 4965, Springer, pp. 198–219, 2008.</li>

      <li>[13] Y. Dodis and J. Steinberger. Message authentication codes from unpredictable block ciphers. Advances in Cryptology – CRYPTO 2009, LNCS vol. 5677, Springer, pp. 267–285, 2009.</li>

      <li>[14] S. Halevi and P. Rogaway. A tweakable cnciphering mode. Advances in Cryptology – CRYPTO 2003, LNCS vol. 2729, Springer, pp. 482–499, 2003.</li>

      <li>[15] S. Halevi and P. Rogaway. A parallelizable enciphering mode. Topics in Cryptology – CT-RSA 2004, LNCS vol. 2964, Springer, pp. 292–304, 2004.</li>

      <li>[16] S. Halevi. Invertible Universal Hashing and the TET Encryption Mode. Advances in Cryptology – CRYPTO 2007, LNCS vol. 4622, Springer, pp. 412-429, 2007.</li>

      <li>[17] D. Goldenberg, S. Hohenberger, M. Liskov, E.C. Schwartz and H. Seyalioglu. On Tweaking Luby-Rackoff Blockciphers. Advances in Cryptologoy – ASIACRYPT 2007, LNCS vol. 4833, Springer, pp. 342–356, 2007</li>

      <li>[18] J. Garay, V. Kolesnikov and R. McLellan. MAC precomputation with applications to secure memory. 12th Information Security Conference – ISC 2009, LNCS vol. 5735, Springer, pp. 427–442, 2009.</li>

      <li>[19] E. Jaulmes, A. Joux and F. Valette. On the security of randomized CBC-MAC beyond the birthday paradox limit: A new construction. Fast Software Encryption –FSE 2002, LNCS vol. 2365, Springer, pp. 237–251, 2002.</li>

      <li>[20] T. Krovetz and P. Rogaway. The Software Performance of Authenticated-Encryption Modes. Fast Software Encryption – FSE 2011, LNCS vol. 6733, Springer, pp. 306–327, 2011.</li>

      <li>[21] M. Liskov, R. Rivest and D. Wagner, Tweakable block ciphers. Advances in Cryptology – CRYPTO 2002, LNCS vol. 2442, Springer, pp. 31–46, 2002.</li>

      <li>[22] U. Maurer and J. Sjödin. Single-key AIL-MACs from any FIL-MAC. International Colloquium on Automata, Languages, and Programming – ICALP 2005, LNCS vol. 3580, Springer, pp. 472–484, 2005.</li>

      <li>[23] R. Merkle. One way hash functions and DES. Advances in Cryptology – CRYPTO ’89, LNCS vol. 435, Springer, pp. 428–446, 1989.</li>

      <li>[24] M. Mitzenmacher and E. Upfal. Probability and Computing: Randomized Algorithms and Probablistic Analysis. Cambridge University Press, 2005.</li>

      <li>[25] K. Minematsu. Beyond-birthday-bound security based on tweakable block cipher. Fast Software Encryption – FSE 2009, LNCS vol. 5665, Springer, pp. 308–326, 2009.</li>

      <li>[26] K. Minematsu. How to Thwart Birthday Attacks against MACs via Small Randomness. Fast Software Encryption – FSE 2010, LNCS vol. 6147, Springer, pp. 230–249, 2010.</li>

      <li>[27] B. Preneel, R. Govaerts and J. Vandewalle. Hash functions based on block ciphers: A synthetic approach. Advances in Cryptology – CRYPTO 1993, LNCS vol. 773, Springer, pp. 368–378, 1993.</li>

      <li>[28] G. Procter. A Note on the CLRW2 Tweakable Block Cipher Construction. Cryptology ePrint Archive, Report 2014/111. http://eprint.iacr.org/2014/111, Jan. 2014.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P. Rogaway, M. Bellare, J. Black and T. Krovetz. OCB: A Block-Cipher Mode of Operation for Efficient Authenticated Encryption. ACM Conference on Computer and Communication Security - CCS 2001, ACM Press, pp. 196-205, 2001.</li>

      <li>P. Rogaway. Efficient instantiations of tweakable blockciphers and refinements to modes OCB and PMAC Advances in Cryptology - ASIACRPT 2004, LNCS vol. 3329, Springer, pp. 13-31, 2004.</li>

      <li>R. Schroeppel. The hasty pudding cipher. NIST AES proposal, available at http://www.cs.arizona.edu/\\~rcs/hpc, 1998.</li>

      <li>M. Bellare, T. Kohno, S. Lucks, N. Ferguson, B. Schneier, D. Whiting, J. Callas and J. Walker. Provable Security Support for the Skein Hash Family. http://www.skein-hash.info/sites/default/files/skein-proofs.pdf</li>

      <li>T. Dierks and E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.1. Internet RFC 4346, 2006.</li>

      <li>P. Wang, D. Feng and W. Wu. HCTS: A variable-input-length enciphering mode. Information Security and Cryptology - CISC 2005, LNCS vol. 3822, Springer, pp. 175-188, 2005.</li>

      <li>K. Yasuda. The Sum of CBC MACs Is a Secure PRF Topics in Cryptology - CT-RSA 2010, LNCS vol. 5985, pp. 366-381, 2010.</li>

      <li>K. Yasuda. A New Variant of PMAC: Beyond the Birthday Bound Advances in Cryptology - CRYPTO 2011, LNCS vol. 6841, pp. 596-607, 2011.</li>

      <li>L. Zhang, W. Wu, P. Wang, L. Zhang, S. Wu and B. Liang. Constructing rate-1 MACs from related-key unpredictable block ciphers: PGV model revisited. Fast Software Encryption - FSE 2010, LNCS vol. 6147, Springer, pp. 250-269, 2010.</li>

    </ol>

    <p class="text-gray-300">This appendix contains the games used in the proof of Theorem 1.</p>

    <p class="text-gray-300">GAME  <span class="math">G1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">100</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E(T,X):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">119</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E-1(T,Y):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Xi←X; Ti←T</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Yi←Y; Ti←T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">Li←Xi ⊕ h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

            <td class="px-3 py-2 border-b border-gray-700">Ni←Yi ⊕ h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

            <td class="px-3 py-2 border-b border-gray-700">if Li ∈ Dom(π1) then</td>

            <td class="px-3 py-2 border-b border-gray-700">122</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ni ∈ Rng(π2) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">123</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni) ⊕ h2(Ti) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi ∈ Dom(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi ∈ Rng(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">106</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←π2(Mi) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←π1-1(Mi) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">126</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Rng(π2) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">127</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Dom(π1) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">109</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Mi)←Yi ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Mi)←Xi ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Rng(π1); π1(Li)←Z</td>

            <td class="px-3 py-2 border-b border-gray-700">130</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Dom(π2); π2-1(Ni)←Z</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni) ⊕ h2(Ti) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi ∈ Dom(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">132</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi ∈ Rng(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">114</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←π2(Mi) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←π1-1(Mi) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">115</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">116</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Rng(π2) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Dom(π1) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Mi)←Yi ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Mi)←Xi ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

            <td class="px-3 py-2 border-b border-gray-700">return Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">137</td>

            <td class="px-3 py-2 border-b border-gray-700">return Xi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 5. Game  <span class="math">G1</span>  simulates  <span class="math">\\widetilde{E}</span>  by using lazy sampling to define the random permutations.</p>

    <p class="text-gray-300">GAMES G2, G3</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">300</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E(T,X):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">323</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E-1(T,Y):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">301</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Xi←X; Ti←T</td>

            <td class="px-3 py-2 border-b border-gray-700">324</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Yi←Y; Ti←T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">302</td>

            <td class="px-3 py-2 border-b border-gray-700">Li←Xi⊕h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">325</td>

            <td class="px-3 py-2 border-b border-gray-700">Ni←Yi⊕h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">303</td>

            <td class="px-3 py-2 border-b border-gray-700">if Li∈Dom(π1) then</td>

            <td class="px-3 py-2 border-b border-gray-700">326</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ni∈Rng(π2) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">304</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li)⊕h1(Ti)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">327</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni)⊕h2(Ti)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">305</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">328</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Xi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">306</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Dom(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">329</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Rng(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">307</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

            <td class="px-3 py-2 border-b border-gray-700">330</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">308</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←π2(Mi)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">331</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←π1-1(Mi)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">309</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">332</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

            <td class="px-3 py-2 border-b border-gray-700">if Yi⊕h2(Ti)∈Rng(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">333</td>

            <td class="px-3 py-2 border-b border-gray-700">if Xi⊕h1(Ti)∈Dom(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">bad2←true</td>

            <td class="px-3 py-2 border-b border-gray-700">334</td>

            <td class="px-3 py-2 border-b border-gray-700">bad2←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">312</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Rng(π2)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">335</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Dom(π1)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">313</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Mi)←Yi⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">336</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Mi)←Xi⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">314</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">337</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">315</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Rng(π1); π1(Li)←Z</td>

            <td class="px-3 py-2 border-b border-gray-700">338</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Dom(π2); π2-1(Ni)←Z</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">316</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li)⊕h1(Ti)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">339</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni)⊕h2(Ti)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">317</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Dom(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">340</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Rng(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">318</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←π2(Mi)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">341</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←π1-1(Mi)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">319</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Rng(π2)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">343</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Dom(π1)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Mi)←Yi⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">344</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Mi)←Xi⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">322</td>

            <td class="px-3 py-2 border-b border-gray-700">return Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">345</td>

            <td class="px-3 py-2 border-b border-gray-700">return Xi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">GAMES G4, G5</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">500</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E(T,X):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">524</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E-1(T,Y):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">501</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Xi←X; Ti←T</td>

            <td class="px-3 py-2 border-b border-gray-700">525</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Yi←Y; Ti←T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">502</td>

            <td class="px-3 py-2 border-b border-gray-700">Li←Xi⊕h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">526</td>

            <td class="px-3 py-2 border-b border-gray-700">Ni←Yi⊕h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">503</td>

            <td class="px-3 py-2 border-b border-gray-700">if Li∈Dom(π1) then</td>

            <td class="px-3 py-2 border-b border-gray-700">527</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ni∈Rng(π2) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">504</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li)⊕h1(Ti)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">528</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni)⊕h2(Ti)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">505</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">529</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Xi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">506</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Dom(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">530</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Rng(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">507</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

            <td class="px-3 py-2 border-b border-gray-700">531</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">508</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">532</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">509</td>

            <td class="px-3 py-2 border-b border-gray-700">if Yi⊕h2(Ti)∈Rng(π2) then bad2←true</td>

            <td class="px-3 py-2 border-b border-gray-700">533</td>

            <td class="px-3 py-2 border-b border-gray-700">if Xi⊕h1(Ti)∈Dom(π1) then bad2←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Mi)←Yi⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">534</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Mi)←Xi⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">511</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">535</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">(Y,Y')←Γ(plazy,PTBC)</td>

            <td class="px-3 py-2 border-b border-gray-700">536</td>

            <td class="px-3 py-2 border-b border-gray-700">(X,X')←Γ(plazy,PTBC)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">513</td>

            <td class="px-3 py-2 border-b border-gray-700">if Y≠Y' then</td>

            <td class="px-3 py-2 border-b border-gray-700">537</td>

            <td class="px-3 py-2 border-b border-gray-700">if X≠X' then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">514</td>

            <td class="px-3 py-2 border-b border-gray-700">bad3←true</td>

            <td class="px-3 py-2 border-b border-gray-700">538</td>

            <td class="px-3 py-2 border-b border-gray-700">bad3←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">515</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Y'; Yi←Y</td>

            <td class="px-3 py-2 border-b border-gray-700">539</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←X'; Xi←X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">516</td>

            <td class="px-3 py-2 border-b border-gray-700">if Yi∈S2 then</td>

            <td class="px-3 py-2 border-b border-gray-700">540</td>

            <td class="px-3 py-2 border-b border-gray-700">if Xi∈S2 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">517</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←π2-1(Yi⊕h2(Ti))⊕h2(Ti)⊕h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">541</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←π1(Xi⊕h1(Ti))⊕h1(Ti)⊕h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">518</td>

            <td class="px-3 py-2 border-b border-gray-700">else if Yi∈S1</td>

            <td class="px-3 py-2 border-b border-gray-700">542</td>

            <td class="px-3 py-2 border-b border-gray-700">else if Xi∈S1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">519</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Rng(π1) \\ (Dom(π2)⊕h2(Ti)⊕h1(Ti))</td>

            <td class="px-3 py-2 border-b border-gray-700">543</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Dom(π2) \\ (Rng(π1)⊕h1(Ti)⊕h2(Ti))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">520</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Z⊕h1(Ti)⊕h2(Ti))←Yi⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">544</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Z⊕h2(Ti)⊕h1(Ti))←Xi⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">521</td>

            <td class="px-3 py-2 border-b border-gray-700">π1(Li)←Z</td>

            <td class="px-3 py-2 border-b border-gray-700">545</td>

            <td class="px-3 py-2 border-b border-gray-700">π2-1(Ni)←Z</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">522</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li)⊕h1(Ti)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">546</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni)⊕h2(Ti)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">523</td>

            <td class="px-3 py-2 border-b border-gray-700">return Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">547</td>

            <td class="px-3 py-2 border-b border-gray-700">return Xi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 6. In Game G4, we use a coupling  <span class="math">\\Gamma</span>  to sample random variables from the distribution of Game G3 ( <span class="math">p_{\\mathrm{lazy}}</span> ) and the distribution of an ideal TBC ( <span class="math">p_{\\mathrm{TBC}}</span> ). We return the former. In Game G5, we return the latter instead.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">600</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E(T,X):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">623</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E-1(T,Y):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">601</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Xi←X; Ti←T</td>

            <td class="px-3 py-2 border-b border-gray-700">624</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Yi←Y; Ti←T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">602</td>

            <td class="px-3 py-2 border-b border-gray-700">Li←Xi ⊕ h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">625</td>

            <td class="px-3 py-2 border-b border-gray-700">Ni←Yi ⊕ h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">603</td>

            <td class="px-3 py-2 border-b border-gray-700">if Li∈Dom(π1) then</td>

            <td class="px-3 py-2 border-b border-gray-700">626</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ni∈Rng(π2) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">604</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">627</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni) ⊕ h2(Ti) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">605</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">628</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Xi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">606</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Dom(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">629</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Rng(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">607</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

            <td class="px-3 py-2 border-b border-gray-700">630</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">608</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">631</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">609</td>

            <td class="px-3 py-2 border-b border-gray-700">if Yi ⊕ h2(Ti) ∈ Rng(π2) then bad2←true</td>

            <td class="px-3 py-2 border-b border-gray-700">632</td>

            <td class="px-3 py-2 border-b border-gray-700">if Xi ⊕ h1(Ti) ∈ Dom(π1) then bad2←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Mi) ← Yi ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">633</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Mi) ← Xi ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">611</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">634</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">612</td>

            <td class="px-3 py-2 border-b border-gray-700">Yi←Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">635</td>

            <td class="px-3 py-2 border-b border-gray-700">Xi←Xi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">613</td>

            <td class="px-3 py-2 border-b border-gray-700">V←{w ∈ R : 0 ≤ w ≤ 1}</td>

            <td class="px-3 py-2 border-b border-gray-700">636</td>

            <td class="px-3 py-2 border-b border-gray-700">V←{w ∈ R : 0 ≤ w ≤ 1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">614</td>

            <td class="px-3 py-2 border-b border-gray-700">if V < δ(plazy, pTBC) then bad3←true</td>

            <td class="px-3 py-2 border-b border-gray-700">637</td>

            <td class="px-3 py-2 border-b border-gray-700">if V < δ(plazy, pTBC) then bad3←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">615</td>

            <td class="px-3 py-2 border-b border-gray-700">if Yi ∈ S2 then</td>

            <td class="px-3 py-2 border-b border-gray-700">638</td>

            <td class="px-3 py-2 border-b border-gray-700">if Xi ∈ S2 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">616</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←π2-1(Yi ⊕ h2(Ti)) ⊕ h2(Ti) ⊕ h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">639</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←π1(Xi ⊕ h1(Ti)) ⊕ h1(Ti) ⊕ h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">617</td>

            <td class="px-3 py-2 border-b border-gray-700">else if Yi ∈ S1</td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

            <td class="px-3 py-2 border-b border-gray-700">else if Xi ∈ S1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">618</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Rng(π1) \\ (Dom(π2) ⊕ h2(Ti) ⊕ h1(Ti))</td>

            <td class="px-3 py-2 border-b border-gray-700">641</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Dom(π2) \\ (Rng(π1) ⊕ h1(Ti) ⊕ h2(Ti))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">619</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Z ⊕ h1(Ti) ⊕ h2(Ti)) ← Yi ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">642</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Z ⊕ h2(Ti) ⊕ h1(Ti)) ← Xi ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">620</td>

            <td class="px-3 py-2 border-b border-gray-700">π1(Li) ← Z</td>

            <td class="px-3 py-2 border-b border-gray-700">643</td>

            <td class="px-3 py-2 border-b border-gray-700">π2-1(Ni) ← Z</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">621</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">644</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni) ⊕ h2(Ti) ⊕ h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">622</td>

            <td class="px-3 py-2 border-b border-gray-700">return Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">645</td>

            <td class="px-3 py-2 border-b border-gray-700">return Xi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 7. Since the previous game discarded one of the coupled random variables, we no longer use the coupling distribution here. Instead, we sample directly from the ideal distribution but still set  <span class="math">\\mathsf{bad}_3</span>  with probability  <span class="math">\\delta(p_{\\mathrm{lazy}}, p_{\\mathrm{TBC}})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">700</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E(T,X,Y):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">721</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Procedure E-1(T,Y,X):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">701</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Xi←X; Ti←T</td>

            <td class="px-3 py-2 border-b border-gray-700">722</td>

            <td class="px-3 py-2 border-b border-gray-700">i←i+1; Yi←Y; Ti←T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">stYi←Y</td>

            <td class="px-3 py-2 border-b border-gray-700">stXi←X</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">702</td>

            <td class="px-3 py-2 border-b border-gray-700">Li←Xi⊕h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">723</td>

            <td class="px-3 py-2 border-b border-gray-700">Ni←Yi⊕h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">703</td>

            <td class="px-3 py-2 border-b border-gray-700">if Li∈Dom(π1) then</td>

            <td class="px-3 py-2 border-b border-gray-700">724</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ni∈Rng(π2) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">704</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li)⊕h1(Ti)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">725</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni)⊕h2(Ti)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">705</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Dom(π2) then</td>

            <td class="px-3 py-2 border-b border-gray-700">726</td>

            <td class="px-3 py-2 border-b border-gray-700">if Mi∈Rng(π1) then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">706</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

            <td class="px-3 py-2 border-b border-gray-700">727</td>

            <td class="px-3 py-2 border-b border-gray-700">bad1←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">707</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">728</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">708</td>

            <td class="px-3 py-2 border-b border-gray-700">if Yi⊕h2(Ti)∈Rng(π2) then bad2←true</td>

            <td class="px-3 py-2 border-b border-gray-700">729</td>

            <td class="px-3 py-2 border-b border-gray-700">if Xi⊕h1(Ti)∈Dom(π1) then bad2←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">709</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Mi)←Yi⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">730</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Mi)←Xi⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">710</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

            <td class="px-3 py-2 border-b border-gray-700">731</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">711</td>

            <td class="px-3 py-2 border-b border-gray-700">V←{w∈R:0≤w≤1}</td>

            <td class="px-3 py-2 border-b border-gray-700">732</td>

            <td class="px-3 py-2 border-b border-gray-700">V←{w∈R:0≤w≤1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">712</td>

            <td class="px-3 py-2 border-b border-gray-700">if V<δ(plazy,pTBC) then bad3←true</td>

            <td class="px-3 py-2 border-b border-gray-700">733</td>

            <td class="px-3 py-2 border-b border-gray-700">if V<δ(plazy,pTBC) then bad3←true</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">713</td>

            <td class="px-3 py-2 border-b border-gray-700">if Yi∈S2 then</td>

            <td class="px-3 py-2 border-b border-gray-700">734</td>

            <td class="px-3 py-2 border-b border-gray-700">if Xi∈S2 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">714</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←π2-1(Yi⊕h2(Ti))⊕h2(Ti)⊕h1(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">735</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←π1(Xi⊕h1(Ti))⊕h1(Ti)⊕h2(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">715</td>

            <td class="px-3 py-2 border-b border-gray-700">else if Yi∈S1</td>

            <td class="px-3 py-2 border-b border-gray-700">736</td>

            <td class="px-3 py-2 border-b border-gray-700">else if Xi∈S1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">716</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Rng(π1) \\ (Dom(π2)⊕h2(Ti)⊕h1(Ti))</td>

            <td class="px-3 py-2 border-b border-gray-700">737</td>

            <td class="px-3 py-2 border-b border-gray-700">Z←Dom(π2) \\ (Rng(π1)⊕h1(Ti)⊕h2(Ti))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">717</td>

            <td class="px-3 py-2 border-b border-gray-700">π2(Z⊕h1(Ti)⊕h2(Ti))←Yi⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">738</td>

            <td class="px-3 py-2 border-b border-gray-700">π1-1(Z⊕h2(Ti)⊕h1(Ti))←Xi⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">718</td>

            <td class="px-3 py-2 border-b border-gray-700">π1(Li)←Z</td>

            <td class="px-3 py-2 border-b border-gray-700">739</td>

            <td class="px-3 py-2 border-b border-gray-700">π2-1(Ni)←Z</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">719</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π1(Li)⊕h1(Ti)⊕h2(Ti)</td>

            <td class="px-3 py-2 border-b border-gray-700">740</td>

            <td class="px-3 py-2 border-b border-gray-700">Mi←π2-1(Ni)⊕h2(Ti)⊕h1(Ti)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">return Yi</td>

            <td class="px-3 py-2 border-b border-gray-700">741</td>

            <td class="px-3 py-2 border-b border-gray-700">return Xi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 8. Game  <span class="math">G7</span>  gives the adversary control over  <span class="math">Y_{i}</span>  values. Such an adversary can set bad flags at least as easily as adversaries for Game  <span class="math">G6</span>  can. Additionally, adversaries for Game  <span class="math">G7</span>  are, without loss of generality, non-adaptive.</p>

    <p class="text-gray-300">B Proof of Theorem 2</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Games G0, G1 procedure F(M): 100 s←s+1; M^s←M 101 M^s_1, ..., M^s_bs←M^s 102 P← Prefix_M(M^s); p←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">; T^s_p←T[P] 103 for i=p+1 to bs 104 T^i_s←{0,1}^n 103 if M^s_i ∈ Dom(Π(T^i_{i-1},·)) then 104 bad←true ;T^i_s←Π(T^i_{i-1},M^s_i) 105 if T^i_s ∈ Rng(Π(T^i_{i-1},·)) then 106 bad←true ;T^i_s←Rng(Π(T^i_{i-1},·)) 107 Π(T^i_{i-1},M^s_i)←T^i_s 108 T[M^s_1, ..., M^s_1]←T^i_s 109 M←M^s 110 Return T^s_b</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Game G3 procedure F(M): 200 s←s+1; M^s←M 301 M^s_1, ..., M^s_bs←M^s 302 P← Prefix_M(M^s); p←</td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">; T^s_p←T[P] 303 for i=p+1 to bs 305 if M^s_i ∈ Dom(Π(T^i_{i-1},·)) then bad←true 306 Π(T^i_{i-1},M^s_i)←defined 307 T[M^s_1, ..., M^s_1]←T^i_s←{0,1}^n 308 M←M^s 309 Return T^s_b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Game G5 for s=1 to q 500 M^s_1, ..., M^s_bs←M^s 501 P← Prefix_M(M^s); p←</td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">; T^s_p←T[P] 502 for i=p+1 to bs 503 if M^s_i ∈ Dom(Π(T^i_{i-1},·)) then bad←true 504 Π(T^i_{i-1},M^s_i)←defined 505 T[M^s_1, ..., M^s_1]←T^i_s←{0,1}^n 506 M←M^s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Game G2 procedure F(M): 200 s←s+1; M^s←M 201 M^s_1, ..., M^s_bs←M^s 202 P← Prefix_M(M^s); p←</td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">; T^s_p←T[P] 203 for i=p+1 to bs 204 T^i_s←{0,1}^n 205 if M^s_i ∈ Dom(Π(T^i_{i-1},·)) then bad←true 206 Π(T^i_{i-1},M^s_i)←T^i_s 207 T[M^s_1, ..., M^s_1]←T^i_s 208 M←M^s 209 Return T^s_b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Game G4 procedure F(M): 400 s←s+1; M^s←M 401 M^s_1, ..., M^s_bs←M^s 402 P← Prefix_M(M^s); p←</td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">; T^s_p←T[P] 403 for i=p+1 to bs 405 if M^s_i ∈ Dom(Π(T^i_{i-1},·)) then bad←true 406 Π(T^i_{i-1},M^s_i)←defined 407 T[M^1, ..., M^1]←T^i_s←{0,1}^n 408 M←M^s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Game G6 for all X ∈ {0,1}^n)+, T[X]←{0,1}^n for s=1 to q 600 M^s_1, ..., M^s_bs←M^s 601 P^s← Prefix_M(M^s); p^s←</td>

            <td class="px-3 py-2 border-b border-gray-700">P^s</td>

            <td class="px-3 py-2 border-b border-gray-700">602 if M^s_{p^s+1} ∈ Dom(Π(T[P^s],·)) then bad←true 603 Π(T[P^s],M^s_{p^s+1})←defined 604 for i=p^s+1 to bs-1 606 if M^s_{i+1} ∈ Dom(Π(T[M^s_1, ..., M^s],·)) then bad←true 607 Π(T[M^s_1, ..., M^s],M^s_{i+1})←defined 608 M←M^s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 9. Games for the proof of Theorem 2. We define  <span class="math">\\mathsf{T}[\\varepsilon] = 0^n</span> . The set  <span class="math">\\mathcal{M}</span>  is initially empty.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">We omit proof of the standard switch from the complexity-theoretic to the information-theoretic setting, wherein adversary <span class="math">B</span> simulates the PRF experiment for <span class="math">\\mathsf{TBCMAC}[\\widetilde{E}]</span> or <span class="math">\\mathsf{TBCMAC}[\\varPi]</span>, depending upon its own oracle. The remainder of the proof is the core technical piece, which proceeds by a sequence of code-based games.</p>

    <p class="text-gray-300">Game <span class="math">G0</span> faithfully implements <span class="math">\\mathsf{TBCMAC}[\\varPi]</span>. Here and throughout we use <span class="math">Dom(\\varPi(T,\\cdot))</span> to denote the set of domain points under the (lazily sampled) random permutation <span class="math">\\varPi(T,\\cdot)</span> that have been assigned a corresponding range value. Likewise, the set <span class="math">\\overline{Reg}(\\varPi(T,\\cdot))</span> denotes the set of stings in <span class="math">\\{0,1\\}^{n}</span> that have not yet been associated to any domain point under <span class="math">\\varPi(T,\\cdot)</span>. Game <span class="math">G1</span> omits the boxed statements, and hence implements a random function <span class="math">\\rho</span> with the same domain as <span class="math">\\mathsf{TBCMAC}</span> and <span class="math">n</span>-bit outputs. Thus <span class="math">\\Pr\\left[\\,A^{\\mathsf{TBCMAC}[\\varPi]}\\Rightarrow 1\\,\\right]=\\Pr\\left[\\,A^{G0}\\Rightarrow 1\\,\\right]</span> and <span class="math">\\Pr\\left[\\,A^{\\rho}\\Rightarrow 1\\,\\right]=\\Pr\\left[\\,A^{G1}\\Rightarrow 1\\,\\right]</span>, and these games are identical-until-bad <em>[5]</em>, so we have that <span class="math">\\mathbf{Adv}_{\\mathsf{TBCMAC}[\\varPi]}^{\\mathrm{prf}}(A)\\leq\\Pr\\left[\\,A^{G1}\\text{ sets bad}\\,\\right]</span>. The probability that <span class="math">\\mathsf{bad}\\leftarrow\\mathsf{true}</span> on line 106 of <span class="math">G1</span> is at most <span class="math">(0+1+\\cdots+(\\ell q-1))/2^{n}\\leq.5(\\ell q)^{2}/2^{n}</span>. So in <span class="math">G2</span> we simply remove the check for colliding range points under <span class="math">\\varPi</span> and have the bound <span class="math">\\Pr\\left[\\,A^{G1}\\text{ sets bad}\\,\\right]\\leq\\Pr\\left[\\,A^{G2}\\text{ sets bad}\\,\\right]+.5(\\ell q)^{2}/2^{n}</span>. Notice that in game <span class="math">G2</span> the actual values assigned to <span class="math">\\varPi</span> do not impact the setting of <span class="math">\\mathsf{bad}</span>. In moving to game <span class="math">G3</span> we simply associate a distinguished value defined to domain points that have been touched, and move the random sampling of <span class="math">T_{i}^{s}</span> to the first place that it is needed (line 307). Now, in <span class="math">G3</span> the adversary learns only the output of a random function on input <span class="math">M</span>, i.e. <span class="math">T_{b_{s}}^{s}</span> for query <span class="math">M^{s}</span>; inside the game these returned values are only written into <span class="math">\\mathtt{T}[M_{1}^{s}\\cdots M_{b_{s}}^{s}]</span>. But since queries are restricted to be prefix-free, these final values are never again used by the game, so we can simply return to the adversary a “dummy” uniform random point <span class="math">Z^{s}</span> that is never used elsewhere. We do this in game <span class="math">G4</span>. Thus <span class="math">\\Pr\\left[\\,A^{G3}\\text{sets bad}\\,\\right]\\leq\\Pr\\left[\\,A^{G4}\\text{sets bad}\\,\\right]</span>.</p>

    <p class="text-gray-300">At this point the adversary receives values that are independent of the setting of <span class="math">\\mathsf{bad}</span>, so we can assume that the adversary just picks <span class="math">q</span> random values itself and not bother to return the <span class="math">Z^{s}</span> at all. Moreover, at this point we can assume without loss that the adversary is deterministic and has hardcoded into it the string of coins that maximize the probability that it sets <span class="math">\\mathsf{bad}</span> by choice of the queries <span class="math">M^{1},\\ldots,M^{q}</span>. Let <span class="math">\\mathtt{M}^{1},\\ldots,\\mathtt{M}^{q}</span> be these queries. This moves us to game <span class="math">G5</span>, where the adversary is no longer present, so we replace the procedure <span class="math">F(M)</span> by a for-loop over these fixed messages. We have <span class="math">\\Pr\\left[\\,A^{G4}\\text{sets bad}\\,\\right]\\leq\\Pr\\left[\\,G5\\text{sets bad}\\,\\right]</span>.</p>

    <p class="text-gray-300">Finally we move to game <span class="math">G6</span>. Here we make a number of structural changes that do not impact the probability of setting <span class="math">\\mathsf{bad}</span>. First we unroll the first loop of the for-loop in <span class="math">G5</span> on line 502. We no longer sample values <span class="math">T_{i}^{s}</span> and assign these to <span class="math">\\mathtt{T}</span> inside the for-loop, instead we set <span class="math">\\mathtt{T}</span> to have uniform random values for every “message” <span class="math">X\\in(\\{0,1\\}^{n})^{+}</span>; thus in particular all of the random assignments that were made in <span class="math">G5</span> are made here. Wherever <span class="math">T_{i}^{s}</span> would have been used before, we use directly the corresponding values of <span class="math">\\mathtt{T}</span>. The prefixes <span class="math">P</span> are now indexed by <span class="math">s</span> (i.e. <span class="math">P^{s}</span>) as are the prefix (block)lengths <span class="math">p</span>. Finally, the inner for-loop from <span class="math">G5</span> is reindexed. It is straightforward to verify that <span class="math">\\Pr\\left[\\,G5\\text{ sets bad}\\,\\right]\\leq\\Pr\\left[\\,G6\\text{ sets bad}\\,\\right]</span>.</p>

    <p class="text-gray-300">What remains is an analysis of the ways in which <span class="math">\\mathsf{bad}</span> can be set in <span class="math">G6</span>. There are four cases to consider.</p>

    <p class="text-gray-300"><em>Case 1</em>: For some <span class="math">1\\leq r&lt;s\\leq q</span> we have <span class="math">(\\mathtt{T}[P^{r}],\\mathtt{M}_{p^{r}+1}^{r})=(\\mathtt{T}[P^{s}],\\mathtt{M}_{p^{s}+1}^{s})</span>. If <span class="math">P^{r}=P^{s}=\\varepsilon</span> then <span class="math">M^{r}</span> and <span class="math">M^{s}</span> differ in their first block, so <span class="math">\\Pr\\left[\\,(\\mathtt{T}[P^{r}],\\mathtt{M}_{p^{r}+1}^{r})=(\\mathtt{T}[P^{s}],\\mathtt{M}_{p^{s}+1}^{s})\\,\\right]=0</span> because <span class="math">\\mathtt{M}_{1}^{r}\\neq\\mathtt{M}_{1}^{s}</span>. If <span class="math">P^{r}=\\varepsilon</span> and <span class="math">\\mathrm{P}^{s}\\neq\\varepsilon</span> then <span class="math">\\Pr\\left[\\,(0^{n},\\mathtt{M}_{1}^{r})=(\\mathtt{T}[P^{s}],\\mathtt{M}_{p^{s}+1}^{s})\\,\\right]=2^{-n}</span> becauase <span class="math">\\mathtt{T}[P^{s}]</span> is uniformly random. If <span class="math">P^{r}\\neq\\varepsilon</span> and <span class="math">P^{s}=\\varepsilon</span> the same reasoning applies symmetrically. If <span class="math">P^{r}\\neq\\varepsilon</span> and <span class="math">P^{s}\\neq\\varepsilon</span> then <span class="math">\\Pr\\left[\\,(\\mathtt{T}[P^{r}],\\mathtt{M}_{p^{r}+1}^{r})=(\\mathtt{T}[P^{s}],\\mathtt{M}_{p^{s}+1}^{s})\\,\\right]=2^{-n}</span> unless <span class="math">P^{r}=P^{s}</span>, so assume this. But then <span class="math">\\mathtt{M}_{p^{r}+1}^{r}\\neq\\mathtt{M}_{p^{s}+1}^{s}</span>, since otherwise there would have been a longer common prefix.</p>

    <p class="text-gray-300"><em>Case 2</em>: For some <span class="math">1\\leq r&lt;s\\leq q</span> and <span class="math">p_{r}+1\\leq i\\leq b_{r}-1</span> we have <span class="math">(\\mathtt{T}[P^{s}],\\mathtt{M}_{p^{s}+1}^{s})=(\\mathtt{T}[\\mathtt{M}_{1}^{r}\\cdots\\mathtt{M}_{i}^{r}],\\mathtt{M}_{i+1}^{r})</span>. If <span class="math">P^{s}=\\varepsilon</span> then we have <span class="math">\\Pr\\left[\\,(0^{n},\\mathtt{M}_{p^{s}+1}^{s})=(\\mathtt{T}[\\mathtt{M}_{1}^{s}\\cdots\\mathtt{M}_{i}^{r}],\\mathtt{M}_{i+1}^{r})\\,\\right]=2^{-n}</span>. If <span class="math">P^{s}\\neq\\varepsilon</span> then <span class="math">\\Pr\\left<a href="\\mathtt{T}[P^{s}],\\mathtt{M}_{p^{s}+1}^{s}">\\,(\\,\\right</a>=(\\mathtt{T}[\\mathtt{M}_{1}^{r}\\cdots\\mathtt{M}_{i}^{r}],\\mathtt{M}_{i+1}^{r}))=2^{-n}</span> unless <span class="math">P^{s}=\\mathtt{M}_{1}^{r}\\cdots\\mathtt{M}_{i}^{r}</span>. But then <span class="math">\\mathtt{M}_{p^{s}+1}^{s}\\neq\\mathtt{M}_{i+1}^{r}</span>, since otherwise there would have been a longer common prefix.</p>

    <p class="text-gray-300"><em>Case 3</em>: For some <span class="math">1\\leq r&lt;s\\leq q</span> and <span class="math">p_{s}+1\\leq i\\leq b_{s}-1</span> we have <span class="math">(\\mathtt{T}[P^{r}],\\mathtt{M}_{p^{r}+1}^{s})=(\\mathtt{T}[\\mathtt{M}_{1}^{s}\\cdots\\mathtt{M}_{i}^{s}],\\mathtt{M}_{i+1}^{s})</span>. This is argued as in case 2, so <span class="math">\\Pr\\left[\\,(\\mathtt{T}[P^{r}],\\mathtt{M}_{p^{r}+1}^{s})=(\\mathtt{T}[\\mathtt{M}_{1}^{s}\\cdots\\mathtt{M}_{i}^{s}],\\mathtt{M}_{i+1}^{s})\\,\\right]\\leq 2^{-n}</span>.</p>

    <p class="text-gray-300"><em>Case 4</em>: For some <span class="math">1\\leq r&lt;s\\leq q</span>, some <span class="math">p_{r}+1\\leq i\\leq b_{r}-1</span>, and some <span class="math">p_{s}+1\\leq j\\leq b_{s}-1</span>, we have <span class="math">(\\mathtt{T}[\\mathtt{M}_{1}^{r}\\cdots\\mathtt{M}_{i}^{r}],\\mathtt{M}_{i+1}^{r})=(\\mathtt{T}[\\mathtt{M}_{1}^{s}\\cdots\\mathtt{M}_{j}^{s}],\\mathtt{M}_{j+1}^{s})</span>. The probability of this is at most <span class="math">2^{-n}</span> unless <span class="math">i=j</span> and <span class="math">\\mathtt{M}_{1}^{r}\\cdots\\mathtt{M}_{i}^{r}=\\mathtt{M}_{1}^{s}\\cdots\\mathtt{M}_{j}^{s}</span>. But this leads to contradictory values for <span class="math">p^{r}</span> and <span class="math">p^{s}</span>.</p>

    <p class="text-gray-300">Thus in every case the probability of <span class="math">\\mathsf{bad}\\leftarrow\\mathsf{true}</span> is at most <span class="math">2^{-n}</span>. Since there are at most <span class="math">.5(\\ell q)^{2}</span> opportunities for <span class="math">\\mathsf{bad}</span> to be set, we have <span class="math">\\Pr\\left[\\,G6\\text{ sets bad}\\,\\right]\\leq.5(\\ell q)^{2}/2^{n}</span>. Collecting up our results from each game step, we have our claimed bound. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">C Collision Resistance Lemma for TBC-MAC</p>

    <p class="text-gray-300">Here we give a simple result showing that TBC-MAC over an ideal cipher <span class="math">\\Pi</span> is collision resistant. We begin by observing that <span class="math">\\mathsf{TBCMAC}[\\mathrm{BC}(n,n)]</span> can be viewed as an iterated hash with compression function <span class="math">f^{\\Pi}(T,M)=\\Pi(T,M)</span>. Let <span class="math">H^{\\Pi}</span> be the TBC-MAC construction for a particular <span class="math">\\Pi\\in\\mathrm{BC}(n,n)</span>. Then we define the collision-finding advantage of <span class="math">A</span> attacking TBC-MAC as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{cr}}_{\\mathsf{TBCMAC}}(A)=\\Pr\\Big{[}\\;\\Pi\\&amp;lt;^{\\mathsf{s}}\\mathrm{BC}(n,n)\\,;\\,(M,M^{\\prime})\\&amp;lt;^{\\mathsf{s}}A^{\\Pi}\\,:\\,H^{\\Pi}(M)=H^{\\Pi}(M^{\\prime})\\,\\Big{]}</span></p>

    <p class="text-gray-300">and we make the convention that when <span class="math">A</span> outputs <span class="math">(M,M^{\\prime})</span> it has already made all queries necessary to evaluate <span class="math">H^{\\Pi}(M)</span> and <span class="math">H^{\\Pi}(M^{\\prime})</span>. We note that this differs from the usual ideal-cipher notion of collision-resistance because the adversary has access only to <span class="math">\\Pi</span>, and <em>not</em> its inverse. This notion will be sufficient for our needs.</p>

    <p class="text-gray-300">Similarly, let <span class="math">f^{\\Pi}(T,M)=\\Pi(T,M)</span> be the compression function of the TBC-MAC iteration for some particular <span class="math">\\Pi\\in\\mathrm{BC}(n,n)</span>. We define the collision-finding advantage of <span class="math">A</span> in attacking this compression function as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{comp}}_{f}(A)=\\Pr</span> <span class="math">\\Big{[}\\Pi\\&amp;lt;^{\\mathsf{s}}\\mathrm{BC}(n,n)\\,;\\,(T,M),(T^{\\prime}M^{\\prime})\\&amp;lt;^{\\mathsf{s}}A^{\\Pi}</span> <span class="math">:\\,((T,M)\\neq(T^{\\prime},M^{\\prime})\\wedge f^{\\Pi}(T,M)=f^{\\Pi}(T^{\\prime},M^{\\prime}))\\vee f^{\\Pi}(T,M)=0^{n}\\Big{]}</span></p>

    <p class="text-gray-300">where we note that the adversary wins by making a collision (again using only <span class="math">\\Pi</span>, not its inverse) or by finding a preimage of the IV. Now a standard argument about the Merkle-Damgård iteration gives us that for any collision-finding adversary <span class="math">A</span> asking <span class="math">q</span> messages of length at most <span class="math">\\ell</span> blocks, there exists an adversary <span class="math">B</span> such that <span class="math">\\mathbf{Adv}^{\\mathrm{cr}}_{\\mathsf{TBCMAC}}(A)\\leq\\mathbf{Adv}^{\\mathrm{comp}}_{f}(B)</span>, where <span class="math">B</span> asks at most <span class="math">q\\ell</span> queries. Moreover, a simple union bound argument shows that for any adversary <span class="math">B</span> making <span class="math">q\\ell</span> queries, we have <span class="math">\\mathbf{Adv}^{\\mathrm{comp}}_{f}(B)\\leq(q\\ell+1)(q\\ell)/2^{n}</span>. Thus we have the following lemma.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Fix <span class="math">n&amp;gt;0</span> and let <span class="math">A</span> be a collision-finding adversary for TBC-MAC that asks <span class="math">q</span> messages of length at most <span class="math">\\ell</span> blocks. Then <span class="math">\\mathbf{Adv}^{\\mathrm{cr}}_{\\mathsf{TBCMAC}}(A)\\leq(q\\ell+1)(q\\ell)/2^{n}</span>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">Appendix D Proof of Theorem 4</h2>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof essentially analyzes two cases: either the messages queried by <span class="math">A</span> to its oracle result in some output of <span class="math">\\widetilde{E}</span> repeating (possibly across queries), or all values output by <span class="math">\\widetilde{E}</span> are distinct. In the latter case, we will show there is an adversary <span class="math">C</span> that immediately turns <span class="math">A</span>’s forgery into a forgery for <span class="math">\\widetilde{E}</span> (in particular, the last call to <span class="math">\\widetilde{E}</span> in evaluating <span class="math">A</span>’s forgery). In the former case, we show that there exists an adversary that turns <span class="math">\\widetilde{E}</span>-collisions into <span class="math">\\widetilde{E}</span> forgeries.</p>

    <p class="text-gray-300">Consider Game <span class="math">G0</span> in Figure 10. As the boxed instructions are not executed in this game and various bookkeeping objects (e.g. <span class="math">\\mathcal{W}</span>, <span class="math">j</span>, <span class="math">\\mathsf{bad}</span>) are never surfaced, it is clear that the procedure <span class="math">\\mathsf{Mac}</span> correctly implements the <span class="math">\\mathsf{TBCMAC}^{\\mathsf{pt}}[\\widetilde{E}]</span> oracle expected by <span class="math">A</span> in the UF-CMA experiment. Likewise, the procedure Finalize returns 1 iff the “winning” event of the UF-CMA experiment occurs. Thus we have <span class="math">\\mathbf{Adv}^{\\mathrm{uf\\ast cma}}_{\\mathsf{TBCMAC}^{\\mathsf{pt}}\\widetilde{E}}(A)=\\Pr\\big{[}\\,G0^{A}\\Rightarrow 1\\,\\big{]}</span>. Now since Games <span class="math">G0</span> and <span class="math">G1</span> are <em>identical-until-bad</em> games, the fundamental lemma of game playing <em>[5]</em> gives us that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}\\,G0^{A}\\Rightarrow 1\\,\\big{]}-\\Pr\\big{[}\\,G1^{A}\\Rightarrow 1\\,\\big{]}\\leq\\Pr\\big{[}\\,G1^{A}\\text{ sets }\\mathsf{bad}\\,\\big{]}\\,.</span></p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{forges}</span> be the event that Finalize returns 1, i.e. the adversary manages to forge. We note that the event <span class="math">\\mathsf{forges}</span> does not occur in Game <span class="math">G1</span> if <span class="math">\\mathsf{bad}\\leftarrow\\mathsf{true}</span> because execution is halted in this case.</p>

    <p class="text-gray-300">Now, for <span class="math">\\ell\\in[1..\\sigma-1]</span> let <span class="math">\\mathsf{Coll}_{\\ell}</span> denote the event that <span class="math">\\mathsf{bad}\\leftarrow\\mathsf{true}</span> occurs in Game <span class="math">G1</span> on the <span class="math">\\ell</span>-th call to <span class="math">\\widetilde{E}</span>. Let <span class="math">\\mathsf{Coll}=\\mathsf{Coll}_{1}\\vee\\mathsf{Coll}_{2}\\vee\\cdots\\vee\\mathsf{Coll}_{(\\sigma-1)}</span>, and notice that if <span class="math">\\mathsf{Coll}</span> is true then exactly one of the <span class="math">\\mathsf{Coll}_{\\ell}</span> is true because Game <span class="math">G1</span> halts. Conditioning on <span class="math">\\mathsf{Coll}</span> and using the above, we have</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{uf\\ast cma}}_{\\mathsf{TBCMAC}^{\\mathsf{pt}}[\\widetilde{E}]}(A)</span> <span class="math">\\leq\\Pr_{1}\\big{[}\\,\\mathsf{forges}\\,\\big{]}+\\Pr_{1}\\big{[}\\,\\mathsf{Coll}\\,\\big{]}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\leq\\Pr_{1}\\big{[}\\,\\mathsf{forges}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\overline{\\mathsf{Coll}}\\,\\big{]}+\\Pr_{1}\\big{[}\\,\\mathsf{Coll}\\,\\big{]}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\Pr_{1}\\left[\\,\\cdot\\,\\right]</span> is the probability measured when <span class="math">A</span> is in Game <span class="math">G1</span>.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 10. Games for the proof of Theorem 4. Game  <span class="math">G0</span>  excludes the boxed text (lines 17 and 27). Game  <span class="math">G1</span>  includes the boxed text. Adversary  <span class="math">B_{\\ell}</span>  is for forging the TBC in the event that bad  <span class="math">\\leftarrow</span>  true on the  <span class="math">\\ell</span> -th message block in Game  <span class="math">G0</span> , where  <span class="math">\\ell \\in [\\sigma - 1]</span> . Recall our convention that all boolean flags are initially false.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">Consider the case that the event forges occurs in  <span class="math">G1</span> . Then necessarily  <span class="math">G1</span> -line 29 executes (the game did not halt), so in fact  <span class="math">\\operatorname{Pr}_1[\\text{forges}] = \\operatorname{Pr}_1[\\text{forges} \\mid \\overline{\\text{Coll}}]</span> . In this case there exists an obvious  <span class="math">\\widetilde{E}</span> -forging adversary  <span class="math">C</span>  (based on the code of game G1) that outputs  <span class="math">((T_{b_q - 1}, M_{b_q}^q), \\tau)</span>  as its forgery. We claim that if event (forges  <span class="math">\\mid \\overline{\\text{Coll}}</span> ) occurs in  <span class="math">G1</span> , then  <span class="math">C</span>  successfully forges  <span class="math">\\widetilde{E}</span> . To see this, it suffices to show that  <span class="math">C</span>  never asks  <span class="math">(T_{b_q - 1}, M_{b_q}^q)</span>  to its  <span class="math">\\widetilde{E}</span> -oracle during its execution. Assume not, and consider the message blocks  <span class="math">M_1^h, M_2^h, \\dots, M_w^h</span>  that immediately preceded the first query of  <span class="math">(T_{b_q - 1}, M_{b_q}^q)</span> . Either  <span class="math">M_1^h, \\dots, M_w^h = M_1^q, \\dots, M_{b_q - 1}^q</span>  or  <span class="math">M_1^h, \\dots, M_w^h \\neq M_1^q, \\dots, M_{b_q - 1}^q</span> . In the former case  <span class="math">M^q</span>  is a prefix of some previously queried message, which violates the prefix-free encoding of the messages. In the latter case,  <span class="math">\\operatorname{Coll}_{\\ell}</span>  must have occurred for some  <span class="math">\\ell</span> , which contradicts our assumption that  <span class="math">\\overline{\\text{Coll}}</span>  is true. Hence  <span class="math">\\operatorname{Pr}_1[\\text{forges} \\mid \\overline{\\text{Coll}}] \\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{id} * \\mathrm{cma}}(C)</span> . The adversary  <span class="math">C</span>  perfectly simulates an oracle  <span class="math">\\mathsf{TBCMAC}^{\\mathrm{pf}}[\\widetilde{E}]</span>  for  <span class="math">A</span> , making a single query for each block of a message queried by  <span class="math">A</span> . Thus  <span class="math">C</span> 's resources are defined by  <span class="math">t_C = t</span> ,  <span class="math">q_C = \\sigma</span> , and  <span class="math">\\sigma_C = 2\\sigma</span>  which comes from the fact that  <span class="math">C</span>  must query the tweak in addition to the message when simulating  <span class="math">\\mathsf{TBCMAC}^{\\mathrm{pf}}</span>  on each block of  <span class="math">A</span> 's queries.</p>

    <p class="text-gray-300">Thus it remains to bound  <span class="math">\\operatorname{Pr}_1[\\mathsf{Coll}]</span>  to finish our proof. For  <span class="math">\\ell \\in [1..\\sigma - 1]</span>  let  <span class="math">B_{\\ell}</span>  be the adversary described in Figure 10. Recall that if  <span class="math">\\mathsf{Coll}</span>  is true, then exactly one of  <span class="math">\\mathsf{Coll}_{\\ell}</span>  is true, and for this  <span class="math">\\ell</span>  there is some  <span class="math">0 \\leq p &amp;lt; \\ell</span>  such that  <span class="math">T_{\\ell} = T_{p}</span> . Let  <span class="math">(T_{\\ell - 1}, M_{\\ell})</span>  be the query to  <span class="math">\\widetilde{E}</span>  that gave rise to  <span class="math">T_{\\ell}</span> . In this case, there is a  <span class="math">1 / \\ell</span>  chance that  <span class="math">B_{\\ell}</span>  correctly guesses the index  <span class="math">p</span> . If it does and  <span class="math">(T_{\\ell - 1}, M_{\\ell})</span>  has not already been queried, then  <span class="math">((T_{\\ell - 1}, M_{\\ell}), T_{p})</span>  is a valid  <span class="math">\\widetilde{E}</span> -forgery. (Note that if  <span class="math">(T_{\\ell - 1}, M_{\\ell})</span>  had already been queried, then  <span class="math">\\mathsf{Coll}_{\\ell - 1}</span>  would have held, contradicting our assumption that  <span class="math">\\mathsf{Coll}_{\\ell}</span>  holds.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, <span class="math">\\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf}\\text{-cma}}(B_{\\ell}) = \\operatorname*{Pr}(B_{\\ell}\\text{ correctly guesses } T_{p}\\wedge \\mathsf{Coll}_{\\ell})</span>. The fact that <span class="math">B_{\\ell}</span> guesses <span class="math">T_{p}</span> uniformly from the set <span class="math">\\mathcal{W}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{W}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell$, gives us</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf}\\text{-cma}}(B_{\\ell}) \\geq \\operatorname*{Pr}(B_{\\ell} (\\text{ correctly guesses } T_{p}) \\wedge \\mathsf{Coll}_{\\ell}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\operatorname*{Pr}(B_{\\ell} (\\text{ correctly guesses } T_{p})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Coll}_{\\ell}) \\operatorname<em>{Pr}(\\mathsf{Coll}_{\\ell}) = \\frac{1}{\\ell} \\operatorname</em>{Pr}(\\mathsf{Coll}_{\\ell}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Thus,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr(\\mathsf{Coll}) \\leq \\sum_{\\ell=1}^{\\sigma-1} \\Pr(\\mathsf{Coll}_{\\ell}) \\leq \\left(\\sum_{\\ell=1}^{\\sigma-1} \\ell\\right) \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf}\\text{-cma}}(B) = \\frac{\\sigma(\\sigma-1)}{2} \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf}\\text{-cma}}(B)</span></div>

    <p class="text-gray-300">where <span class="math">B = B_{\\ell}</span> for the value of <span class="math">\\ell</span> that maximizes the advantage. This <span class="math">B</span> runs in time at most <span class="math">t_B = \\max_{\\ell}(t_{\\ell}) \\leq t</span>, asks at most <span class="math">q_B = \\max_{\\ell}(q_{\\ell}) \\leq \\sigma</span> queries, these totaling at most <span class="math">\\sigma_B = \\max_{\\ell}(\\sigma_{\\ell}) \\leq 2\\sigma</span> which comes from the fact that <span class="math">B_{\\ell}</span> must query the tweak in addition to the message when simulating <span class="math">\\mathsf{TBCMAC}^{\\mathsf{pf}}</span> on each block of <span class="math">A</span>'s queries. Pulling together results leads immediately to the theorem statement.</p>

    <h2 id="sec-19" class="text-2xl font-bold">E LRW1 and LRW2 Do Not Preserve Unforgeability</h2>

    <p class="text-gray-300">In this section we show that the two TBC constructions from Liskov et al. [21] do not preserve unforgeability. Specifically: given a PRP-secure blockcipher, we construct an unforgeable blockcipher (with a larger domain) that, when used in either of the constructions from Liskov et al. [21], yields a TBC that is easily forged. Curiously, we use one of the LRW constructions in the first step of the process, i.e. building an unforgeable blockcipher from a PRP.</p>

    <p class="text-gray-300"><strong>BREAKING LRW1.</strong> For what follows, we refer the reader to Figure 11 for a visual representation of the various constructions. First we construct a blockcipher from a TBC. Let <span class="math">\\widetilde{E}\\colon \\{0,1\\}^n\\times (\\{0,1\\}^n\\times \\{0,1\\}^n)\\to \\{0,1\\}^n</span> be a tweakable blockcipher. We define <span class="math">F^{\\widetilde{E}}\\colon \\{0,1\\}^n\\times \\{0,1\\}^{2n}\\to \\{0,1\\}^{2n}</span> by <span class="math">F_{K}^{\\widetilde{E}}(X_{L}\\parallel X_{R}) = X_{R}\\parallel \\widetilde{E}_{K}(X_{L},X_{R})</span>, where <span class="math">X_{L}</span> and <span class="math">X_{R}</span> are the leftmost and rightmost <span class="math">n</span> bits of <span class="math">X</span>, respectively. It is clear that the Feistel-like <span class="math">F^{\\widetilde{E}}</span> is invertible for any key <span class="math">K</span>, and therefore a permutation, since the preimage of <span class="math">Y_{L}\\parallel Y_{R}</span> is given by <span class="math">E_K^{-1}(Y_L,Y_R)\\parallel Y_L</span>. Thus <span class="math">F^{\\widetilde{E}}</span> is a blockcipher with an <span class="math">n</span>-bit key and <span class="math">2n</span>-bit blocksize.</p>

    <p class="text-gray-300">If the underlying TBC <span class="math">\\widetilde{E}</span> is unforgeable, then clearly so is the blockcipher <span class="math">F^{\\widetilde{E}}</span>, since forging the latter implies forging the former. Likewise, it is straightforward to prove that a secure tweakable-PRP is unforgeable. We state these simple results as lemmas; we omit the obvious reductions.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let <span class="math">\\widetilde{E}\\colon \\{0,1\\}^n\\times (\\{0,1\\}^n\\times \\{0,1\\}^n)\\to \\{0,1\\}^n</span> be a tweakable blockcipher, and let <span class="math">F^{\\widetilde{E}}</span> be defined as above. Then <span class="math">\\mathbf{Adv}_{F^{\\widetilde{E}}}^{\\mathrm{uf}\\text{-cma}}(A)\\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf}\\text{-cma}}(B)</span>, where the resources of <span class="math">A</span> and <span class="math">B</span> are identical.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> Fix <span class="math">n &amp;gt; 0</span>, and let <span class="math">\\widetilde{E}\\colon \\{0,1\\}^n\\times \\{0,1\\}^n\\times \\{0,1\\}^n\\to \\{0,1\\}^n</span> be a tweakable blockcipher. Let <span class="math">A</span> be an adversary running in time <span class="math">t</span>, asking <span class="math">q</span> queries totalling <span class="math">\\sigma</span> blocks. Then there exists adversary <span class="math">B</span> such that <span class="math">\\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{uf}\\text{-cma}}(A)\\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{prp}}(B) + \\frac{1}{2^n - q}</span>, where <span class="math">B</span> runs in time <span class="math">t</span>, asks <span class="math">q + 1</span> queries, these totalling <span class="math">\\sigma</span> blocks.</p>

    <p class="text-gray-300">Thus <span class="math">F^{\\widetilde{E}}</span> is unforgeable if <span class="math">\\widetilde{E}</span> is a secure tweakable-PRP. Now we leverage the results of Liskov et al. [21] to build a tweakable-PRP from a PRP. Specifically, let <span class="math">E\\colon \\{0,1\\}^n\\times \\{0,1\\}^n\\to \\{0,1\\}^n</span> be a blockcipher, and let LRW1[E]: <span class="math">\\{0,1\\}^n\\times (\\{0,1\\}^n\\times \\{0,1\\}^n)\\to \\{0,1\\}^n</span> be defined by LRW1[E]K(T,X) = EK(T ⊕ EK(X)). LRW show that <span class="math">\\mathbf{Adv}_{\\mathsf{LRW1}[E]}^{\\mathsf{prp}}(A)\\leq \\mathbf{Adv}_E^{\\mathsf{prp}}(B) + \\Theta (Q^2 /2^n)</span>, where <span class="math">A</span> makes <span class="math">Q</span> queries to its oracle, and the resources of <span class="math">B</span> are essentially those of <span class="math">A</span>. This result, combined with Lemmas 3 and 4 gives the following.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Fix <span class="math">n &amp;gt; 0</span>. Let <span class="math">E: \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span> be a blockcipher, and let LRW1[E]K(T,X) = <span class="math">E_K(T \\oplus E_K(X))</span> be defined as above. Let <span class="math">A</span> run in time <span class="math">t</span>, and ask <span class="math">q</span> queries of total length <span class="math">\\sigma</span> blocks. Then there exists a <span class="math">B</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{F^{\\mathrm{LRW1}}[E]}^{\\mathrm{uf}\\text{-cma}}(A) \\leq \\mathbf{Adv}_{E}^{\\mathrm{prp}}(B) + \\Theta((q+1)^2/2^n)</span></div>

    <p class="text-gray-300">where <span class="math">B</span> runs in time <span class="math">t</span>, asking <span class="math">q + 1</span> queries, these totalling <span class="math">\\sigma</span> blocks.</p>

    <p class="text-gray-300">Now we can proceed to the main point, that the TBC <span class="math">\\mathsf{LRW1}[F^{\\mathsf{LRW1}[E]}]</span> is easily forged.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">(<span class="math">\\mathsf{LRW1}</span> does not preserve unforgeability.) Fix <span class="math">n&gt;0</span>. Let <span class="math">E:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> be a blockcipher, and let <span class="math">\\mathsf{LRW1}[E]</span> be the tweakable blockcipher construction defined above. Let blockcipher <span class="math">F^{\\mathsf{LRW1}[E]}:\\{0,1\\}^{2n}\\times\\{0,1\\}^{2n}\\to\\{0,1\\}^{2n}</span> be defined (as above) by</p>

    <p class="text-gray-300"><span class="math">F^{\\mathsf{LRW1}[E]}_{K}(X_{L}\\parallel X_{R})=X_{R}\\parallel\\mathsf{LRW1}[E]_{K}(X_{L},X_{R})=X_{R}\\parallel E_{K}(X_{L}\\oplus E_{K}(X_{R}))).</span></p>

    <p class="text-gray-300">Then there exists an <span class="math">A</span> that achieves <span class="math">\\mathbf{Adv}^{\\mathrm{uf-cma}}_{\\mathsf{LRW1}[F^{\\mathsf{LRW1}[E]}]}(A)=1</span> by asking <span class="math">q=3</span> queries totalling <span class="math">\\sigma=12</span> blocks.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To avoid writing <span class="math">\\mathsf{LRW1}[F^{\\mathsf{LRW1}[E]}]_{K}</span> repeatedly, we let <span class="math">\\widetilde{E}_{K}</span> stand for this. Adversary <span class="math">A</span> asks queries <span class="math">Y^{1}\\leftarrow\\widetilde{E}_{K}(0^{2n},0^{2n})</span>, and <span class="math">Y^{2}\\leftarrow\\widetilde{E}_{K}(0^{2n},1^{2n})</span> and then outputs <span class="math">((T^{<em>},X^{</em>}),Y^{<em>})</span> where <span class="math">(T^{</em>},X^{<em>})=(1^{n}\\parallel Y^{1}_{L}\\oplus Y^{2}_{L},1^{2n})</span> and <span class="math">Y^{</em>}=Y^{1}</span> as its forgery. We note immediately that the forgery <span class="math">(T^{<em>},X^{</em>})</span> has never been queried, since <span class="math">T^{1}=T^{2}=0^{2n}\\neq T^{*}</span>.</p>

    <p class="text-gray-300">Now we show that <span class="math">A</span> indeed produces a valid forgery. First, we have that</p>

    <p class="text-gray-300"><span class="math">Y^{1}</span> <span class="math">=E_{K}(E_{K}(0^{n}))\\parallel E_{K}(E_{K}(E_{K}(E_{K}(0^{n})))),</span> <span class="math">Y^{2}</span> <span class="math">=E_{K}(1^{n}\\oplus E_{K}(1^{n}))\\parallel E_{K}(1^{n}\\oplus E_{K}(E_{K}(1^{n}\\oplus E_{K}(1^{n}))))</span></p>

    <p class="text-gray-300">and hence</p>

    <p class="text-gray-300"><span class="math">\\widetilde{E}_{K}(T^{<em>},X^{</em>})</span> <span class="math">=\\widetilde{E}_{K}(1^{n}\\parallel Y^{1}_{L}\\oplus Y^{2}_{L},1^{2n})</span> <span class="math">=\\widetilde{E}_{K}(1^{n}\\parallel E_{K}(E_{K}(0^{n}))\\oplus E_{K}(1^{n}\\oplus E_{K}(1^{n})),1^{2n})</span></p>

    <p class="text-gray-300">which we must show is exactly <span class="math">Y^{<em>}=Y^{1}</span>. Let <span class="math">U</span> denote the output of the first round of <span class="math">E_{K}</span> calculated in the <span class="math">\\mathsf{LRW1}</span> construction, and let <span class="math">V</span> denote the input to the second round of <span class="math">E_{K}</span>. Then we have both <span class="math">U^{</em>}=X^{<em>}_{R}\\parallel E_{K}(X^{</em>}_{L}\\oplus E_{K}(X^{*}_{R}))=1^{n}\\parallel E_{K}(1^{n}\\oplus E_{K}(1^{n}))</span> and</p>

    <p class="text-gray-300"><span class="math">V^{<em>}</span> <span class="math">=U^{</em>}_{L}\\oplus T^{<em>}_{L}\\parallel U^{</em>}_{R}\\oplus T^{*}_{R}</span> <span class="math">=1^{n}\\oplus 1^{n}\\parallel E_{K}(1^{n}\\oplus E_{K}(1^{n}))\\oplus E_{K}(E_{K}(0^{n}))\\oplus E_{K}(1^{n}\\oplus E_{K}(1^{n})</span> <span class="math">=0^{n}\\parallel E_{K}(E_{K}(0^{n}))</span></p>

    <p class="text-gray-300">finally giving</p>

    <p class="text-gray-300"><span class="math">Y^{<em>}=V^{</em>}_{R}\\parallel E_{K}(V^{<em>}_{L}\\oplus E_{K}(V^{</em>}_{R}))=E_{K}(E_{K}(0^{n}))\\parallel E_{K}(E_{K}(E_{K}(E_{K}(0^{n}))))=Y^{1}</span></p>

    <p class="text-gray-300">which completes the proof. ∎</p>

    <p class="text-gray-300">We note that if the two blockcipher calls in <span class="math">\\mathsf{LRW1}</span> were keyed with distinct keys, the proof is easily modified to cover this case, too. (We present the result with one key because this is the construction proposed by LRW.)</p>

    <p class="text-gray-300">Breaking LRW2. Liskov et al. <em>[21]</em> give a second construction that yields a tweakable-PRP from a blockcipher and an <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> hash function. The <span class="math">\\mathsf{LRW2}</span> construction is as follows. Given a blockcipher <span class="math">E:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> and an <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> hash function family <span class="math">H</span>, the construction <span class="math">\\mathsf{LRW2}[H,E]:(\\mathcal{K}\\times\\{0,1\\}^{n})\\times\\{0,1\\}^{t}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> is defined by <span class="math">\\mathsf{LRW2}[H,E]_{(h,K)}(T,X)=h(T)\\oplus E_{K}(X\\oplus h(T))</span>. We will show that there exists an <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> hash function family and an unforgeable blockcipher such that <span class="math">\\mathsf{LRW2}</span> admits an efficient forging attack that succeeds with high probablility. In particular, fix an <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> hash function family <span class="math">H</span> mapping from <span class="math">t</span> bits to <span class="math">n</span> bits. Let <span class="math">H^{\\prime}\\colon\\mathcal{K}\\times\\{0,1\\}^{t}\\to\\{0,1\\}^{2n}</span> be the family defined by <span class="math">h^{\\prime}(T)=0^{n}\\parallel h(T)</span> for each <span class="math">h\\in H</span>. We immediately have the following lemma, given without proof.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Fix <span class="math">t,n&gt;0</span> and let <span class="math">H\\colon\\mathcal{K}\\times\\{0,1\\}^{t}\\to\\{0,1\\}^{n}</span> be a family of <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> hash functions, and let <span class="math">H^{\\prime}</span> be defined as above. Then <span class="math">H^{\\prime}</span> is also <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span>.</p>

    <p class="text-gray-300">This will be our <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> hash function. For the blockcipher, we reuse the <span class="math">F^{\\mathsf{LRW1}[E]}</span> construction. We have already shown in Theorem 5 that this blockcipher is unforgeable if <span class="math">E</span> is a secure PRP. Our next result shows that <span class="math">\\mathsf{LRW2}[H^{\\prime},F^{\\mathsf{LRW1}[E]}]</span> does not preserve this unforgeability. See Figure 13 for a drawing of the construction.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">(<span class="math">\\mathsf{LRW2}</span> does not preserve unforgeability.) Fix <span class="math">t,n&gt;0</span>. Let <span class="math">E:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> be a blockcipher. Let <span class="math">F^{\\mathsf{LRW1}[E]}</span> be defined as in Theorem 6. Let <span class="math">H:\\mathcal{K}\\times\\{0,1\\}^{t}\\to\\{0,1\\}^{n}</span> be a family of <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span> hash functions, and let <span class="math">H^{\\prime}</span> be defined as above. Then there exists an adversary <span class="math">A</span> that asks <span class="math">q=3</span> queries, and achieves <span class="math">\\mathbf{Adv}^{\\mathrm{uf~{}~{}cma}}_{\\mathsf{LRW2}[H^{\\prime},F^{\\mathsf{LRW1}[E]}]}(A)&gt;1-\\epsilon</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To avoid writing <span class="math">\\mathsf{LRW2}[H^{\\prime},F^{\\mathsf{LRW1}[E]}]_{(h^{\\prime},K)}</span> repeatedly, we write <span class="math">\\overline{K}</span> for the pair <span class="math">(h^{\\prime},K)</span>, and write <span class="math">\\widetilde{E}_{\\overline{K}}</span> for <span class="math">\\mathsf{LRW2}[H^{\\prime},F^{\\mathsf{LRW1}[E]}]_{(h^{\\prime},K)}</span>.</p>

    <p class="text-gray-300">Adversary <span class="math">A</span> queries <span class="math">Y^{1}\\leftarrow\\widetilde{E}_{\\overline{K}}(0^{2n},0^{2n})</span> and <span class="math">Y^{2}\\leftarrow\\widetilde{E}_{\\overline{K}}(1^{2n},0^{2n})</span>. <span class="math">A</span> then forges with <span class="math">((T^{<em>},X^{</em>}),Y^{<em>})</span>, where <span class="math">Y^{</em>}=Y_{L}^{2}\\parallel Y_{L}^{1}\\oplus Y_{L}^{2}\\oplus Y_{R}^{2}</span>, and <span class="math">(T^{<em>},X^{</em>})=(0^{2n},0^{n}\\parallel Y_{1}^{L}\\oplus Y_{2}^{L})</span>.</p>

    <p class="text-gray-300">To aid in our analysis, we note that</p>

    <p class="text-gray-300"><span class="math">\\widetilde{E}_{\\overline{K}}(T,X)=X_{R}\\oplus h(T)\\parallel h(T)\\oplus E_{K}(X_{L}\\oplus E_{K}(X_{R}\\oplus h(T))</span></p>

    <p class="text-gray-300">and so <span class="math">Y^{1}=h(0^{2n})\\parallel h(0^{2n})\\oplus E_{K}(E_{K}(h(0^{2n})))</span>, and <span class="math">Y^{2}=h(1^{2n})\\parallel h(1^{2n})\\oplus E_{K}(E_{K}(h(1^{2n})))</span>.</p>

    <p class="text-gray-300">In order to prove the theorem statement, we must prove that <span class="math">((T^{<em>},X^{</em>}),Y^{<em>})</span> is a valid forgery with probability <span class="math">1-\\epsilon</span>. To this end, we first show that <span class="math">\\widetilde{E}_{\\overline{K}}(T^{</em>},X^{<em>})=Y^{</em>}</span>, and next that <span class="math">(T^{<em>},X^{</em>})</span> is a new query.</p>

    <p class="text-gray-300">To the first point, we note that</p>

    <p class="text-gray-300"><span class="math">\\widetilde{E}_{\\overline{K}}(T^{<em>},X^{</em>})</span> <span class="math">=\\widetilde{E}_{\\overline{K}}(0^{2n},0^{n}\\parallel Y_{1}^{L}\\oplus Y_{2}^{L})</span> <span class="math">=\\widetilde{E}_{\\overline{K}}(0^{2n},0^{n}\\parallel h(0^{2n})\\oplus h(1^{2n}))</span> <span class="math">=h(0^{2n})\\oplus h(1^{2n})\\oplus h(0^{2n})\\parallel h(0^{2n})\\oplus E_{K}(0^{n}\\oplus E_{K}(h(0^{2n})\\oplus h(1^{2n})\\oplus h(0^{2n})))</span> <span class="math">=h(1^{2n})\\parallel h(0^{2n})\\oplus E_{K}(E_{K}(h(1^{2n})))</span> <span class="math">=Y_{L}^{2}\\parallel Y_{L}^{1}\\oplus Y_{L}^{2}\\oplus Y_{R}^{2}</span></p>

    <p class="text-gray-300">Therefore the event <span class="math">\\widetilde{E}_{\\overline{K}}(T^{<em>},X^{</em>})=Y^{<em>}</span> is always true. To the second point, let <span class="math">\\mathrm{new\\text{-}msg}</span> denote the event that <span class="math">(T^{</em>},X^{*})</span> is a new query. We note that <span class="math">\\mathrm{new\\text{-}msg}</span> occurs if and only if <span class="math">Y_{1}^{L}\\oplus Y_{2}^{L}\\neq 0^{n}</span>. Thus we have</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}[\\mathrm{new\\text{-}msg}]=1-\\mathrm{Pr}[Y_{1}^{L}\\oplus Y_{2}^{L}=0^{n}]=1-\\mathrm{Pr}[h(0^{2n})\\oplus h(1^{2n})=0^{n}]&gt;1-\\epsilon.</span></p>

    <p class="text-gray-300">where the probability is taken over the random choice of function <span class="math">h\\in\\mathcal{H}</span>. Thus we have</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{uf~{}~{}cma}}_{E}(A)</span> <span class="math">=\\mathrm{Pr}\\left[\\left(\\widetilde{E}_{\\overline{K}}(T^{<em>},X^{</em>})=Y^{*}\\right)\\wedge\\mathrm{new\\text{-}msg}\\right]=\\mathrm{Pr}[\\mathrm{new\\text{-}msg}]</span> <span class="math">&gt;1-\\epsilon\\ \\ \\square</span></p>

    <p class="text-gray-300">We note that this counterexample is easily strengthened to the case that <span class="math">H</span> is a collision-resistant hash function, rather than merely <span class="math">\\epsilon</span>-<span class="math">\\mathrm{AXU}_{2}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 11. Figures for Theorem 6. Left: The LRW1[E] construction of an  <span class="math">n</span> -bit TBC from an  <span class="math">n</span> -bit BC. Center: Using LRW1[E] to build a  <span class="math">2n</span> -bit BC  <span class="math">F^{\\mathrm{LRW1}[E]}</span> . Right: The LRW1[F <span class="math">^{\\mathrm{LRW1}[E]}</span> ] TBC construction. The filled-in dot denotes the tweak input.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 12. The  <span class="math">\\widetilde{F}</span>  construction from Theorem 5</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Fig. 13. The LRW2 <span class="math">[H&#x27;, F^{\\mathrm{LRW1}[E]}]</span>  TBC construction, used in Theorem 7. Note that  <span class="math">h&#x27;(T) = 0^n \\parallel h(T)</span> , but for compactness we do not draw the  <span class="math">0^n</span>  block or the exclusive-or (with  <span class="math">0^n</span> ) operations.</p>`;
---

<BaseLayout title="Tweakable Blockciphers with Beyond Birthday-Bound Security (2012/450)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/450
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
