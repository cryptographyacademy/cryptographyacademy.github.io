---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1377';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fiat-Shamir Transformation of Multi-Round Interactive Proofs';
const AUTHORS_HTML = 'Thomas Attema, Serge Fehr, Michael Klooß';

const CONTENT = `    <p class="text-gray-300">Thomas Attema<span class="math">^{1,3,4,*}</span>, Serge Fehr<span class="math">^{1,3,<strong>}</span>, and Michael Klooß<span class="math">^{2,</strong>}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> CWI, Cryptology Group, Amsterdam, The Netherlands <span class="math">^{2}</span> KASTEL, Karlsruhe Institute of Technology, Karlsruhe, Germany <span class="math">^{3}</span> Leiden University, Mathematical Institute, Leiden, The Netherlands <span class="math">^{4}</span> TNO, Cyber Security and Robustness, The Hague, The Netherlands</p>

    <p class="text-gray-300">Version 2 - February 16, 2022<span class="math">^{1}</span></p>

    <p class="text-gray-300">Abstract. The celebrated Fiat-Shamir transformation turns any public-coin interactive proof into a non-interactive one, which inherits the main security properties (in the random oracle model) of the interactive version. While originally considered in the context of 3-move public-coin interactive proofs, i.e., so-called <span class="math">\\Sigma</span>-protocols, it is now applied to multi-round protocols as well. Unfortunately, the security loss for a <span class="math">(2\\mu + 1)</span>-move protocol is, in general, <span class="math">Q^{\\mu}</span>, where <span class="math">Q</span> is the number of oracle queries performed by the attacker. In general, this is the best one can hope for, as it is easy to see that this loss applies to the <span class="math">\\mu</span>-fold sequential repetition of <span class="math">\\Sigma</span>-protocols, but it raises the question whether certain (natural) classes of interactive proofs feature a milder security loss.</p>

    <p class="text-gray-300">In this work, we give positive and negative results on this question. On the positive side, we show that for <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound protocols (which cover a broad class of use cases), the knowledge error degrades linearly in <span class="math">Q</span>, instead of <span class="math">Q^{\\mu}</span>. On the negative side, we show that for <span class="math">t</span>-fold parallel repetitions of typical <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound protocols with <span class="math">t \\geq \\mu</span> (and assuming for simplicity that <span class="math">t</span> and <span class="math">Q</span> are integer multiples of <span class="math">\\mu</span>), there is an attack that results in a security loss of approximately <span class="math">\\frac{1}{2} Q^{\\mu} / \\mu^{\\mu + t}</span>.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1.1 Background</h2>

    <p class="text-gray-300">The celebrated and broadly used Fiat-Shamir transformation turns any public-coin interactive proof into a non-interactive proof, which inherits the main security properties (in the random oracle model) of the interactive version. The rough idea is to replace the random challenges, which are provided by the verifier in the interactive version, by the hash of the current message (concatenated with the messages from previous rounds). By a small adjustment, where also the to-be-signed message is included in the hashes, the transformation turns any public-coin interactive proof into a signature scheme. Indeed, the latter is a commonly used design principle for constructing very efficient signature schemes.</p>

    <p class="text-gray-300">While originally considered in the context of 3-move public-coin interactive proofs, i.e., so-called <span class="math">\\Sigma</span>-protocols, the Fiat-Shamir transformation also applies to multi-round protocols. However, a major drawback in the case of multi-round protocols is that, in general, the security loss obtained by applying the Fiat-Shamir transformation grows exponentially with the number of rounds. Concretely, for any <span class="math">(2\\mu + 1)</span>-move interactive proof <span class="math">\\varPi</span> (where we may assume that the prover speaks first and last, so that the number of communication rounds is indeed odd) that admits a cheating probability of at most <span class="math">\\epsilon</span>, captured by the knowledge or soundness error, the Fiat-Shamir-transformed protocol <span class="math">\\mathsf{FS}[\\varPi]</span> admits a cheating probability of at most <span class="math">(Q + 1)^{\\mu} \\cdot \\epsilon</span>, where <span class="math">Q</span> denotes the number of random-oracle queries admitted to the dishonest prover. Furthermore, there are (contrived) examples of multi-round protocols <span class="math">\\varPi</span> for which this <span class="math">(Q + 1)^{\\mu}</span> security loss is almost tight. For</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>thomas.attema@tno.nl</li>

    </ul>

    <p class="text-gray-300"><strong> serge.fehr@cwi.nl </strong>* michael.klooss@kit.edu</p>

    <p class="text-gray-300"><span class="math">^{1}</span> Change log w.r.t. Version 1 - October 11, 2021: Simpler proof of Lemma 2, more precise treatment of the attack in Section 7 (some details have been moved to appendix), considering adaptive security as well, and editorial changes throughout.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">instance, the <span class="math">\\mu</span>-fold sequential repetition <span class="math">\\Pi</span> of a special-sound <span class="math">\\Sigma</span>-protocol with challenge space <span class="math">\\mathcal{C}</span> is <span class="math">\\epsilon</span>-sound with $\\epsilon=\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu}}<span class="math">, while it is easy to see that, by attacking the sequential repetitions round by round, investing </span>Q/\\mu<span class="math"> queries per round to try to find a “good” challenge, and assuming </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to be much larger than </span>Q<span class="math">, its Fiat-Shamir transformation </span>\\mathsf{FS}[\\Pi]<span class="math"> can be broken with probability approximately </span>\\left(\\frac{Q}{\\mu}\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mu}=\\left(\\frac{Q}{\\mu}\\right)^{\\mu}\\cdot\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">\\mu</span> beyond 1 or 2, let alone for non-constant <span class="math">\\mu</span> (e.g., for Bulletproofs-like protocols <em>[BCC^{+}16, BBB^{+}18]</em>), this is a very unfortunate situation when it comes to choosing concrete security parameters. If one wants to rely on the proven security reduction, one needs to choose a large security parameter for <span class="math">\\Pi</span>, in order to compensate for the order <span class="math">Q^{\\mu}</span> security loss, effecting its efficiency; alternatively, one has to give up on proven security and simply <em>assume</em> that the security loss is much milder than what the general bound suggests — indeed, for the protocols one cares about, the <em>known</em> attacks do not feature such a large security loss. The latter of simply <em>assuming</em> the loss to be milder has become common practice.</p>

    <p class="text-gray-300">This situation gives rise to the following question: <em>Do there exist natural classes of multi-round public-coin interactive proofs for which the security loss behaves more benign than what the general reduction suggests?</em> Ideally, the general <span class="math">Q^{\\mu}</span> loss appears for contrived examples <em>only</em>. So far, the only positive result in that direction is <em>[x10]</em>, which shows an online/straight-line extractor for Bulletproofs and related protocols in the <em>algebraic group model</em>. They prove a security loss linear in <span class="math">Q</span> (and linear in <span class="math">n</span>, the statement size).</p>

    <p class="text-gray-300">In this work, we address this question (in the plain random-oracle model), and give both positive and negative answers, as explained in more detail below.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Our Results</h3>

    <p class="text-gray-300">On the positive side, we show that the Fiat-Shamir transformation of any <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound interactive proof has a security loss of at most <span class="math">Q+1</span>. More concretely, we consider the <em>knowledge error <span class="math">\\kappa</span></em> as the figure of merit, i.e., informally, the maximal probability of the verifier accepting the proof when the prover does not have a witness for the claimed statement, and we prove the following result. For any <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound <span class="math">(2\\mu+1)</span>-move interactive proof <span class="math">\\Pi</span> with knowledge error <span class="math">\\kappa</span> (which is a known function of <span class="math">(k_{1},\\ldots,k_{\\mu})</span>), the Fiat-Shamir transformed protocol <span class="math">\\mathsf{FS}[\\Pi]</span> has a knowledge error at most <span class="math">(Q+1)\\cdot\\kappa</span>.</p>

    <p class="text-gray-300">Since in the Fiat-Shamir transformation of any <span class="math">(2\\mu+1)</span>-move protocol <span class="math">\\Pi</span>, a dishonest prover can simulate any attack against <span class="math">\\Pi</span>, and can try <span class="math">Q/\\mu</span> times when allowed to do <span class="math">Q</span> queries in total, our new upper bound <span class="math">(Q+1)\\cdot\\kappa</span> is close to the trivial lower bound <span class="math">1-\\left(1-\\kappa\\right)^{Q/\\mu}\\approx Q\\kappa/\\mu</span>. Another, less explicit, security measure in the context of knowledge soundness is the run time of the knowledge extractor. Our bound on the knowledge error holds by means of a knowledge extractor that makes an expected number of <span class="math">K+Q\\cdot(K-1)</span> queries, where <span class="math">K=k_{1}\\cdots k_{\\mu}</span>. This is a natural bound: <span class="math">K</span> is the number of necessary distinct “good” transcripts (which form a certain tree-like structure). The loss of <span class="math">Q\\cdot(K-1)</span> captures the fact that a prover may finish different proofs, depending on the random oracle answers, and only one out of <span class="math">Q</span> proofs may be useful for extraction, as explained below.</p>

    <p class="text-gray-300">The construction of our knowledge extractor is motivated by the extractor from <em>[x2]</em> in the interactive case, but the analysis here in the context of a non-interactive proof is much more involved. We analyze the extractor in an inductive manner, and capture the induction step (and the base case) by means of an abstract experiment. The crucial idea for the analysis (and extractor) is how to deal with accepting transcripts which are not useful.</p>

    <p class="text-gray-300">To see the core problem, consider a <span class="math">\\Sigma</span>-protocol, i.e., a 3-move <span class="math">k</span>-special-sound interactive proof, and a semi-honest prover that knows a witness and behaves as follows. It prepares, independently, <span class="math">Q</span> first messages <span class="math">a^{1},\\ldots,a^{Q}</span> and asks for all hashes <span class="math">c^{i}=\\mathsf{RO}(a^{i})</span>, and then decides “randomly” (e.g., using a hash over all random oracle answers) which thread to complete, i.e., for which <span class="math">i^{<em>}</span> to compute the response <span class="math">z</span> and then output the valid proof <span class="math">(a^{i^{</em>}},z)</span>. When the extractor then reprograms the random oracle to try to obtain another valid response but now for a different challenge, this affects <span class="math">i^{<em>}</span>, and most likely the prover will then use a different thread <span class="math">j^{</em>}</span> and output the proof <span class="math">(a^{j^{<em>}},z^{\\prime})</span> with <span class="math">a^{j^{</em>}}\\neq a^{i^{<em>}}</span>. More precisely, <span class="math">\\Pr(a^{j^{</em>}}=a^{i^{*}})=1/Q</span>. Hence, an overhead of <span class="math">Q</span> appears in the run-time.</p>

    <p class="text-gray-300">Perhaps surprisingly, when moving to multi-round protocols, dealing with the knowledge error is relatively simple by recursively composing the extractor. However, controlling the run-time is intricate. If the extractor is recursively composed, i.e., it makes calls to a subextractor to obtain a subtree, then a naive construction and analysis gives a blow-up of <span class="math">Q^{\\mu}</span> in the run-time. Intuitively, because only <span class="math">1/Q</span> of the subextractor runs produce useful subtrees, i.e., subtrees which extend the current <span class="math">a^{i^{<em>}}</span>. The other trees belong to some <span class="math">a^{j}</span> with <span class="math">j\\neq i^{</em>}</span> and are thus useless. This overhead of <span class="math">Q</span> then accumulates per round (i.e., per subextractor).</p>

    <p class="text-gray-300">The crucial observation that we exploit in order to overcome the above issue is that the very first (accepting) transcript sampled by a subextractor already determines whether a subtree will be (potentially) useful, or not. Thus, if this very first transcript already shows that the subtree will not be useful, there is no need to run the full-fledged subtree extractor, saving precious time.</p>

    <p class="text-gray-300">To formally capture the technical aspects behind the extractor analysis, we consider and analyze an abstract sampling game. The sampling game considers a high-dimensional array, where each entry contains a bit <span class="math">v</span> and a pointer <span class="math">i</span> to one of the many dimensions. The goal is to find, by means of a prescribed strategy (which reflects how the extractor proceeds), <span class="math">k</span> entries with <span class="math">v=1</span> and with pointers <span class="math">i</span> to the same dimension, and, on top, the entries need to be appropriately located in the array, namely aligned along the dimension specified by the common pointer. The technical core of our proof then lies in analyzing certain figures of merit in this abstract experiment: the success probability and a cost function. Defining the cost function naively as the (expected) number of array entries that need to be visited is good enough for the analysis of the extractor of a <span class="math">\\Sigma</span>-protocol, but would lead to the old <span class="math">Q^{\\mu}</span> blow-up when analyzing the inductively defined extractor in that way. In order to capture the above idea of not running the full-fledged subtree extractor when it can be avoided, we introduce two weight functions and define the cost function by means of the total weight of the array entries visited by the extractor. The more general treatment, considering non-constant weight functions, significantly complicates the analysis of the abstract sampling game. Thus, the main technical core of our positive result lies in the analysis of this weighted cost function (Lemma 5).</p>

    <p class="text-gray-300">On the negative side, we show that the general exponential security loss of the Fiat-Shamir transformation, when applied to a multi-round protocol, is not an artefact of contrived examples, but there exist natural protocols that indeed have such an exponential loss. Concretely, we show that the <span class="math">t</span>-fold parallel repetition <span class="math">\\Pi^{t}</span> of a typical <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound <span class="math">(2\\mu+1)</span>-move interactive proof <span class="math">\\Pi</span> features this behavior when <span class="math">t\\geq\\mu</span>. For simplicity, let us assume that <span class="math">t</span> and <span class="math">Q</span> are multiples of <span class="math">\\mu</span>. Then, in more detail, we show that for any typical <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound protocol <span class="math">\\Pi</span> there exists a poly-time <span class="math">Q</span>-query prover <span class="math">\\mathcal{P}^{<em>}</span> against <span class="math">\\mathsf{FS}[\\Pi^{t}]</span> that succeeds in making the verifier accept with probability <span class="math">\\approx\\frac{1}{2}Q^{\\mu}\\kappa^{t}/\\mu^{\\mu+t}</span> for any statement <span class="math">x</span>, where <span class="math">\\kappa</span> is the knowledge error (as well as the soundness error) of <span class="math">\\Pi</span>. Thus, with the claimed probability, <span class="math">\\mathcal{P}^{</em>}</span> succeeds in making the verifier accept for statements <span class="math">x</span> that are not in the language and/or for which <span class="math">\\mathcal{P}^{<em>}</span> does not know a witness. Given that <span class="math">\\kappa^{t}</span> is the soundness error of <span class="math">\\Pi^{t}</span> (i.e., the soundness error of <span class="math">\\Pi^{t}</span> as an interactive proof), this shows that the soundness error of <span class="math">\\Pi^{t}</span> grows proportionally with <span class="math">Q^{\\mu}</span> when applying the Fiat-Shamir transformation. Recent work on the knowledge error of a parallel repetition </em>[x1]* shows that <span class="math">\\kappa^{t}</span> is also the knowledge error of <span class="math">\\Pi^{t}</span>, and so the above shows that the same exponential loss holds in the knowledge error of the Fiat-Shamir transformation of a parallel repetition.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Independent Concurrent Work.</h4>

    <p class="text-gray-300">In independent and to a large extent concurrent work, Wikström <em>[x22]</em> achieves a similar positive result on the Fiat-Shamir transformation, using a different approach and different techniques: <em>[x22]</em> reduces non-interactive extraction to a form of interactive extraction and then applies a generalized version of <em>[x23]</em>, while our construction adapts the interactive extractor from <em>[x2]</em> and offers a direct analysis. One small difference in the results, which is mainly of theoretical interest, is that our result holds and is meaningful for any <span class="math">Q&lt;N</span>, where <span class="math">N</span> is the size of the challenge set, whereas <em>[x22]</em> requires <span class="math">N</span> to be large.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">The Forking Lemma.</h5>

    <p class="text-gray-300">Security of the Fiat–Shamir transformation of <span class="math">k</span>-special-sound <span class="math">3</span>-move protocols is widely used for construction of signatures. There, unforgeability is typically proven via a forking lemma <em>[x20, x11]</em>, which extracts, with probability roughly <span class="math">\\epsilon^{k}/Q</span>, a witness from a signature-forging adversary with success probability <span class="math">\\epsilon</span>, where <span class="math">Q</span> is the number of queries to the random oracle. The loss <span class="math">\\epsilon^{k}</span> is due to <em>strict</em> polynomial time extraction (and can be decreased, but in general not down to <span class="math">\\epsilon</span>). Such a <span class="math">k</span>-th power loss in the success probability for a constant <span class="math">k</span> is fine in certain settings, e.g., for proving the security of signature schemes; however, not for proofs of knowledge (which, on the other hand, consider <em>expected</em> polynomial time extraction <em>[x3]</em>).</p>

    <p class="text-gray-300">A forking lemma for <em>interactive</em> multi-round proofs was presented in <em>[BCC^{+}16]</em> and its analysis was improved in a line of follow-up works <em>[x26, x13, x12, x14]</em>. This forking lemma shows that multi-round special-sound interactive proofs satisfy a notion of knowledge soundness called <em>witness extended emulation</em>. Eventually, it was shown that <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-soundness tightly implies knowledge soundness <em>[x2]</em>.</p>

    <p class="text-gray-300">We are not aware of forking lemmas being used in the context of the Fiat–Shamir transformation for multi-round interactive proofs, i.e., for <span class="math">(2\\mu+1)</span>-move protocols with <span class="math">\\mu&gt;1</span>. The aforementioned techniques for interactive proofs are not directly applicable to the Fiat-Shamir mode. First, incorporating the query complexity <span class="math">Q</span> of a dishonest prover <span class="math">\\mathcal{P}^{*}</span> attacking the non-interactive Fiat–Shamir transformation complicates the analysis. Second, a naive adaptation of the forking lemmas for interactive proofs gives a blow-up of <span class="math">Q^{\\mu}</span> in the run-time.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Interactive Proofs</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">R\\subseteq\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}</span> be a binary relation. Following standard conventions, we call <span class="math">(x;w)\\in R</span> a statement-witness pair, that is, <span class="math">x</span> is the <em>statement</em> and <span class="math">w</span> is a <em>witness</em> for <span class="math">x</span>. The set of valid witnesses for a statement <span class="math">x</span> is denoted by <span class="math">R(x)</span>, i.e., <span class="math">R(x)=\\{w:(x;w)\\in R\\}</span>. A statement that admits a witness is said to be a <em>true</em> or <em>valid</em> statement; the set of true statements is denoted by <span class="math">L_{R}</span>, i.e., <span class="math">L_{R}=\\{x:\\exists\\,w\\text{ s.t. }(x;w)\\in R\\}</span>. The relation <span class="math">R</span> is an NP relation if the validity of a witness <span class="math">w</span> can be verified in time polynomial in the size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of the statement </span>x$. From now on we assume all relations to be NP relations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In an interactive proof for a relation <span class="math">R</span>, a prover <span class="math">\\mathcal{P}</span> aims to convince a verifier <span class="math">\\mathcal{V}</span> that a statement <span class="math">x</span> admits a witness, or even that the prover <em>knows</em> a witness <span class="math">w\\in R(x)</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1 (Interactive Proof)</h6>

    <p class="text-gray-300">An <em>interactive proof</em> <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">R</span> is an interactive protocol between two probabilistic machines, a prover <span class="math">\\mathcal{P}</span> and a polynomial time verifier <span class="math">\\mathcal{V}</span>. Both <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> take as public input a statement <span class="math">x</span> and, additionally, <span class="math">\\mathcal{P}</span> takes as private input a witness <span class="math">w\\in R(x)</span>. The verifier <span class="math">\\mathcal{V}</span> either accepts or rejects and its output is denoted as <span class="math">(\\mathcal{P}(w),\\mathcal{V})(x)</span>. Accordingly, we say the corresponding transcript (i.e., the set of all messages exchanged in the protocol execution) is <em>accepting</em> or <em>rejecting</em>.</p>

    <p class="text-gray-300">Let us introduce some conventions and additional properties for interactive proof systems. We assume that the prover <span class="math">\\mathcal{P}</span> sends the first and the last message in any interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span>. Hence, the number of communication moves <span class="math">2\\mu+1</span> is always odd. We also say <span class="math">\\Pi</span> is a <span class="math">(2\\mu+1)</span>-move protocol. We will refer to <em>multi-round</em> protocols as a way of emphasizing that we are not restricting to <span class="math">3</span>-move protocols.</p>

    <p class="text-gray-300">Informally, an interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> is <em>complete</em> if for any statement-witness pair <span class="math">(x;w)\\in R</span> the honest execution results in the verifier accepting with high probability. It is <em>sound</em> if the verifier rejects false statements, i.e., <span class="math">x\\notin L_{R}</span>, with high probability. We do neither require (or formally define) completeness nor soundness, as our main focus is <em>knowledge soundness</em>. Intuitively, a protocol is knowledge sound if any (potentially malicious) prover <span class="math">\\mathcal{P}^{<em>}</span> which convinces the verifier must “know” a witness <span class="math">w</span> such that <span class="math">(x,w)\\in R</span>. Informally, this means that any prover <span class="math">\\mathcal{P}^{</em>}</span> with <span class="math">\\Pr((\\mathcal{P}^{*},\\mathcal{V})(x)=\\mathsf{accept})</span> large enough is able to efficiently compute a witness <span class="math">w\\in R(x)</span>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2 (Knowledge Soundness)</h6>

    <p class="text-gray-300">An interactive proof <span class="math">(\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">R</span> is <em>knowledge sound</em> with knowledge error <span class="math">\\kappa\\colon\\mathbb{N}\\to[0,1]</span> if there exists a positive polynomial <span class="math">q</span> and an algorithm <span class="math">\\mathcal{E}</span>, called a</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">knowledge extractor, with the following properties. Given input <span class="math">x</span> and black-box oracle access to a (potentially dishonest) prover <span class="math">\\mathcal{P}^{*}</span>, the extractor <span class="math">\\mathcal{E}</span> runs in an expected number of steps that is polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (counting queries to </span>\\mathcal{P}^{*}<span class="math"> as a single step) and outputs a witness </span>w\\in R(x)$ with probability</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\bigl{(}(x;\\mathcal{E}^{\\mathcal{P}^{<em>}}(x))\\in R\\bigr{)}\\geq\\frac{\\epsilon(\\mathcal{P}^{</em>},x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon(\\mathcal{P}^{<em>},x):=\\Pr((\\mathcal{P}^{</em>},\\mathcal{V})(x)=\\textsf{accept})</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">From the linearity of the expectation, it follows easily that it is sufficient to consider deterministic provers <span class="math">\\mathcal{P}^{*}</span> in Definition 2.</p>

    <p class="text-gray-300">An important class of protocols have particularly simple verifiers: effectively stateless verifiers which send uniformly random challenges to the prover, and run an efficient verification function on the final transcript.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3 (Public-Coin).</h6>

    <p class="text-gray-300">An interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> is <em>public-coin</em> if all of <span class="math">\\mathcal{V}</span>’s random choices are made public. The message <span class="math">c_{i}\\leftarrow_{R}\\mathcal{C}_{i}</span> of <span class="math">\\mathcal{V}</span> in the <span class="math">2i</span>-th move is called the <span class="math">i</span>-th <em>challenge</em>, and <span class="math">\\mathcal{C}_{i}</span> is the <em>challenge set</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.2 Special-Sound Multi-Round Protocols</h3>

    <p class="text-gray-300">The class of interactive proofs we are interested in are those where knowledge soundness follows from another property, namely <em>special-soundness</em>. Special-soundness is often simpler to verify, and many protocols satisfy this notion. Note that we require special-sound protocols to be public-coin.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 4 (<span class="math">k</span>-out-of-<span class="math">N</span> Special-Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">k,N\\in\\mathbb{N}</span>. A <span class="math">3</span>-move public-coin interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">R</span>, with challenge set of cardinality <span class="math">N\\geq k</span>, is <span class="math">k</span>-out-of-<span class="math">N</span> special-sound if there exists a polynomial time algorithm that, on input a statement <span class="math">x</span> and <span class="math">k</span> accepting transcripts <span class="math">(a,c_{1},z_{1}),\\ldots(a,c_{k},z_{k})</span> with common first message <span class="math">a</span> and pairwise distinct challenges <span class="math">c_{1},\\ldots,c_{k}</span>, outputs a witness <span class="math">w\\in R(x)</span>. We also say <span class="math">\\Pi</span> is <span class="math">k</span>-special-sound and, if <span class="math">k=2</span>, it is simply said to be special-sound.</p>

    <p class="text-gray-300">We refer to a <span class="math">3</span>-move public-coin interactive proof as a <span class="math">\\Sigma</span>-protocol. Note that often a <span class="math">\\Sigma</span>-protocol is required to be (perfectly) complete, special-sound and special honest-verifier zero-knowledge (SHVZK) by definition. We do not require a <span class="math">\\Sigma</span>-protocol to have these additional properties.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 5 (<span class="math">\\Sigma</span>-Protocol).</h6>

    <p class="text-gray-300">A <span class="math">\\Sigma</span>-protocol is a <span class="math">3</span>-move public-coin interactive proof.</p>

    <p class="text-gray-300">In order to generalize <span class="math">k</span>-special-soundness to multi-round protocols we introduce the notion of a tree of transcripts. We follow the definition of <em>[x1]</em>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 6 (Tree of Transcripts).</h6>

    <p class="text-gray-300">Let <span class="math">k_{1},\\ldots,k_{\\mu}\\in\\mathbb{N}</span>. A <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of transcripts for a <span class="math">(2\\mu+1)</span>-move public-coin interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> is a set of <span class="math">K=\\prod_{i=1}^{\\mu}k_{i}</span> transcripts arranged in the following tree structure. The nodes in this tree correspond to the prover’s messages and the edges to the verifier’s challenges. Every node at depth <span class="math">i</span> has precisely <span class="math">k_{i}</span> children corresponding to <span class="math">k_{i}</span> pairwise distinct challenges. Every transcript corresponds to exactly one path from the root node to a leaf node. See Figure 1 for a graphical illustration. We refer to the corresponding tree of challenges as a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of challenges.</p>

    <p class="text-gray-300">We will also write <span class="math">\\mathbf{k}=(k_{1},\\ldots,k_{\\mu})\\in\\mathbb{N}^{\\mu}</span> and refer to a <span class="math">\\mathbf{k}</span>-tree of transcripts or a <span class="math">\\mathbf{k}</span>-tree of challenges.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 7 (<span class="math">(k_{1},\\ldots,k_{\\mu})</span>-out-of-<span class="math">(N_{1},\\ldots,N_{\\mu})</span> Special-Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">k_{1},\\ldots,k_{\\mu},N_{1},\\ldots,N_{\\mu}\\in\\mathbb{N}</span>. A <span class="math">(2\\mu+1)</span>-move public-coin interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">R</span>, where <span class="math">\\mathcal{V}</span> samples the <span class="math">i</span>-th challenge from a set of cardinality <span class="math">N_{i}\\geq k_{i}</span> for <span class="math">1\\leq i\\leq\\mu</span>, is <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-out-of-<span class="math">(N_{1},\\ldots,N_{\\mu})</span> special-sound if there exists a polynomial time algorithm that, on input a statement <span class="math">x</span> and a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of accepting transcripts outputs a witness <span class="math">w\\in R(x)</span>. We also say <span class="math">\\Pi</span> is <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>-tree of transcripts of a <span class="math">(2\\mu +1)</span>-move interactive proof [ACK21].</p>

    <p class="text-gray-300">It is well known that, for 3-move protocols, <span class="math">k</span>-special-soundness implies knowledge soundness, but only recently it was shown that more generally, for public-coin <span class="math">(2\\mu + 1)</span>-move protocols, <span class="math">(k_{1}, \\ldots, k_{\\mu})</span>-out-of-<span class="math">(N_{1}, \\ldots, N_{\\mu})</span> special-soundness tightly implies knowledge soundness [ACK21], with knowledge error</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Er}(k_{1}, \\dots, k_{\\mu}; N_{1}, \\dots, N_{\\mu}) = 1 - \\prod_{i=1}^{\\mu} \\frac{N_{i} - k_{i} + 1}{N_{i}} = 1 - \\prod_{i=1}^{\\mu} \\left(1 - \\frac{k_{i} - 1}{N_{i}}\\right), \\tag{1}</span></div>

    <p class="text-gray-300">which matches the probability that at least one of the random challenges <span class="math">c_{i}</span> hits a certain set <span class="math">\\Gamma_{i}</span> of size <span class="math">k_{i} - 1</span>. Since typical protocols admit a trivial attack that succeeds if at least one of the random challenges <span class="math">c_{i}</span> hits a certain set <span class="math">\\Gamma_{i}</span> of size <span class="math">k_{i} - 1</span> (we capture this by the special-unsoundness property in Section 7), the soundness/knowledge error <span class="math">\\operatorname{Er}</span> is tight for general special-sound protocols.</p>

    <p class="text-gray-300">Note that <span class="math">\\operatorname{Er}(k; N) = (k - 1)/N</span> and, for all <span class="math">1 \\leq m \\leq \\mu</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Er}(k_{m}, \\dots, k_{\\mu}; N_{m}, \\dots, N_{\\mu}) = 1 - \\frac{N_{m} - k_{m} + 1}{N_{m}} \\left(1 - \\operatorname{Er}(k_{m+1}, \\dots, k_{\\mu}; N_{m+1}, \\dots, N_{\\mu})\\right), \\tag{2}</span></div>

    <p class="text-gray-300">where we define <span class="math">\\operatorname{Er}(\\emptyset; \\emptyset) = 1</span>. If <span class="math">N_1 = \\dots = N_\\mu = N</span>, i.e., if the verifier samples all <span class="math">\\mu</span> challenges from a set of size <span class="math">N</span>, we simply write <span class="math">\\operatorname{Er}(k_1, \\ldots, k_\\mu; N)</span>, or <span class="math">\\operatorname{Er}(\\mathbf{k}; N)</span> for <span class="math">\\mathbf{k} = (k_1, \\ldots, k_\\mu)</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">2.3 Non-Interactive Random Oracle Proofs (NIROP)</h2>

    <p class="text-gray-300">In practice, interactive proofs are not typically used. Instead, transformations are used which turn them into non-interactive proofs in the random oracle model (ROM). We define non-interactive random oracle proofs (NIROP) as in [BCS16]. Their definition is a straightforward adaption of (non-)interactive proof systems to the ROM. The same holds for their properties. Every algorithm is augmented by access to a random oracle.</p>

    <p class="text-gray-300">In the random oracle model, algorithms have black-box access to an oracle RO: <span class="math">\\{0,1\\}^<em> \\to \\mathcal{Y}</span>, called the random oracle, which is instantiated by a uniformly random function with domain <span class="math">\\{0,1\\}^</em></span> and codomain <span class="math">\\mathcal{Y}</span>. For convenience, we let the codomain <span class="math">\\mathcal{Y}</span> be an arbitrary finite set, while typically <span class="math">\\mathcal{Y} = \\{0,1\\}^\\eta</span> for some <span class="math">\\eta \\in \\mathbb{N}</span> related to the security parameter. Equivalently, RO is instantiated by lazy sampling, i.e., for every bit-string <span class="math">x \\in \\{0,1\\}^<em></span>, RO(x) is chosen uniformly at random in <span class="math">\\mathcal{Y}</span> (and then fixed). To avoid technical difficulties, we limit the domain from <span class="math">\\{0,1\\}^</em></span> to <span class="math">\\{0,1\\}^{\\leq u}</span>, the finite set of all bitstrings of length at most <span class="math">u</span>, for a sufficiently</p>

    <p class="text-gray-300">large <span class="math">u\\in\\mathbb{N}</span>. An algorithm <span class="math">\\mathcal{A}^{\\mathsf{RO}}</span> that is given black-box access to a random oracle is called a <em>random-oracle algorithm</em>. We call <span class="math">\\mathcal{A}</span> a <span class="math">Q</span>-query random-oracle algorithm, if it makes at most <span class="math">Q</span> queries to RO (independent of RO).</p>

    <p class="text-gray-300">A natural extension of the random oracle model is when <span class="math">\\mathcal{A}</span> is given access to <em>multiple independent</em> random oracles <span class="math">\\mathsf{RO}_{1},\\ldots,\\mathsf{RO}_{\\mu}</span>, possibly with different codomains. The definitions below apply to this extension in the obvious way.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 8 (Non-Interactive Random Oracle Proof (NIROP)).</h6>

    <p class="text-gray-300">A <em>non-interactive random oracle proof</em> for relation <span class="math">R</span> is a pair <span class="math">(\\mathcal{P},\\mathcal{V})</span> of (probabilistic) random-oracle algorithms, a prover <span class="math">\\mathcal{P}</span> and a polynomial-time verifier <span class="math">\\mathcal{V}</span>, such that: Given <span class="math">(x;w)\\in R</span> and access to a random oracle RO, the prover <span class="math">\\mathcal{P}^{\\mathsf{RO}}(x;w)</span> outputs a proof <span class="math">\\pi</span>. Given <span class="math">x\\in\\{0,1\\}^{*}</span>, a purported proof <span class="math">\\pi</span>, and access to a random oracle RO, the verifier <span class="math">\\mathcal{V}^{\\mathsf{RO}}(x,\\pi)</span> outputs <span class="math">0</span> to reject or <span class="math">1</span> to accept the proof.</p>

    <p class="text-gray-300">As for interactive definitions, a NIROP is complete if honestly generated proofs for <span class="math">(x;w)\\in R</span> are accepted by <span class="math">\\mathcal{V}</span> with high probability. It is sound if it is infeasible to produce an accepting proof for a false statement. In the non-interactive setting, the soundness error, i.e., the success probability of a cheating prover necessarily depends on the number of queries it is allowed to make to the random oracle. The same holds true for knowledge soundness of NIROPs.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 9 (Knowledge Soundness - NIROP).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A non-interactive random oracle proof <span class="math">(\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">R</span> is <em>knowledge sound</em> with <em>knowledge error</em> <span class="math">\\kappa\\colon\\mathbb{N}\\times\\mathbb{N}\\to[0,1]</span> if there exists a positive polynomial <span class="math">q</span> and an algorithm <span class="math">\\mathcal{E}</span>, called a <em>knowledge extractor</em>, with the following properties: The extractor, given input <span class="math">x</span> and oracle access to any (potentially dishonest) <span class="math">Q</span>-query random oracle prover <span class="math">\\mathcal{P}^{*}</span>, runs in an expected number of steps that is polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>Q<span class="math"> and outputs a witness </span>w\\in R(x)$, and satisfies</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\bigl{(}(x;w)\\in R:w\\leftarrow\\mathcal{E}^{\\mathcal{P}^{<em>}}(x)\\bigr{)}\\geq\\frac{\\epsilon(\\mathcal{P}^{</em>},x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,Q)}{q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for all <span class="math">x\\in\\{0,1\\}^{<em>}</span> where <span class="math">\\epsilon(\\mathcal{P}^{</em>},x)=\\Pr\\bigl{(}\\mathcal{V}^{\\mathsf{RO}}(x,\\mathcal{P}^{<em>,\\mathsf{RO}})=1\\bigr{)}</span>. Here, <span class="math">\\mathcal{E}</span> implements RO for <span class="math">\\mathcal{P}^{</em>}</span>, in particular, <span class="math">\\mathcal{E}</span> can arbitrarily program RO. Moreover, the randomness is over the randomness of <span class="math">\\mathcal{E}</span>, <span class="math">\\mathcal{V}</span>, <span class="math">\\mathcal{P}^{*}</span> and RO.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">As for the knowledge soundness of <em>interactive</em> proofs (see Remark 1), it is sufficient to consider <em>deterministic</em> provers <span class="math">\\mathcal{P}^{<em>}</span> in Definition 9. Consequently, we will assume all dishonest provers <span class="math">\\mathcal{P}^{</em>}</span> to be deterministic in order to simplify our analysis. Black-box access to <span class="math">\\mathcal{P}^{<em>}</span> then simply means black-box access to the next-message function of <span class="math">\\mathcal{P}^{</em>}</span>. This in particular means that <span class="math">\\mathcal{E}</span> can “rewind” <span class="math">\\mathcal{P}^{<em>}</span> to any state. We stress though that <span class="math">\\mathcal{E}</span> cannot depend on (or “know”) certain properties of <span class="math">\\mathcal{P}^{</em>}</span>, such as <span class="math">Q</span> or the success probability <span class="math">\\epsilon(\\mathcal{P}^{*},x)</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.4 Adaptive Security</h3>

    <p class="text-gray-300">Thus far, knowledge soundness has been defined with respect to <em>static</em> or <em>non-adaptive</em> provers <span class="math">\\mathcal{P}^{<em>}</span> attacking the considered (non-)interactive proof for a </em>fixed<em> statement <span class="math">x</span>. However, in many practical scenarios the dishonest provers are free to </em>choose<em> the statement <span class="math">x</span> adaptively. Hence, in these cases static security is not sufficient. For </em>interactive* proofs, it is well-known that static knowledge soundness implies adaptive knowledge soundness. However, this does not carry over to non-interactive proofs. For instance, it is easy to see that the static Fiat-Shamir transformation (see Definition 11) is in general not adaptively sound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For this reason, let us formalize adaptive knowledge soundness for non-interactive random oracle proofs. An adaptive prover <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> attacking the considered NIROP is given oracle access to a random oracle RO and outputs a statement <span class="math">x</span> of fixed length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math"> together with a proof </span>\\pi$. As in the static definition, adaptive knowledge soundness requires the existence of a knowledge extractor. However, formalizing the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">requirements of this extractor introduces some subtle issues. Namely, because <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> chooses the statement <span class="math">x</span> adaptively, it is not immediately clear for which statement the extractor should extract a witness. For instance, granting the extractor the same freedom of adaptively choosing the statement <span class="math">x</span>, for which it needs to extract a witness <span class="math">w</span>, renders knowledge extraction trivial; the extractor could simply output an arbitrary statement-witness pair <span class="math">(x;w)</span>. For this reason, we require the extractor to output statement-witness pairs <span class="math">(x;w)</span> corresponding to the valid pairs <span class="math">(x,\\pi)</span> outputted by the adaptive prover <span class="math">\\mathcal{P}^{\\mathsf{a}}</span>. To formalize these requirements, we also write <span class="math">(x,\\pi,v)</span>, with <span class="math">v\\in\\{0,1\\}</span> indicating whether <span class="math">\\pi</span> is a valid proof for statement <span class="math">x</span>. Given this notation, the extractor should output a triple <span class="math">(x,\\pi,v)</span> with the same distribution as the triples <span class="math">(x,\\pi,v)</span> produced by <span class="math">\\mathcal{P}^{\\mathsf{a}}</span>; furthermore, if <span class="math">\\pi</span> is a valid proof for statement <span class="math">x</span>, i.e., <span class="math">v=1</span>, then the extractor should additionally aim to output a witness <span class="math">w\\in R(x)</span>. As before, the success probability of the extractor is allowed to depend on the success probability of <span class="math">\\mathcal{P}^{\\mathsf{a}}</span>. Finally, to ensure that the knowledge extractor can be used in compositional settings, where the NIROP is deployed as a component of a larger protocol, the prover <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> is also allowed to additionally output arbitrary auxiliary information <span class="math">\\mathsf{aux}\\in\\{0,1\\}^{<em>}</span> and the extractor is then required to simulate the tuple <span class="math">(x,\\pi,\\mathsf{aux},v)</span>, rather than the triple <span class="math">(x,\\pi,v)</span>. The following definition formalizes adaptive knowledge soundness along these lines. For alternative definitions see, e.g., </em>[x24, x11]*.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 10 (Adaptive Knowledge Soundness - NIROP).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A non-interactive random oracle proof <span class="math">(\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">R</span> is <em>adaptively knowledge sound</em> with <em>knowledge error</em> <span class="math">\\kappa\\colon\\mathbb{N}\\times\\mathbb{N}\\to[0,1]</span> if there exists a positive polynomial <span class="math">q</span> and an algorithm <span class="math">\\mathcal{E}</span>, called a <em>knowledge extractor</em>, with the following properties: The extractor, given input <span class="math">n\\in\\mathbb{N}</span> and oracle access to any adaptive <span class="math">Q</span>-query random oracle prover <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> that outputs statements <span class="math">x</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">, runs in an expected number of steps that is polynomial in </span>n<span class="math"> and </span>Q<span class="math"> and outputs a tuple </span>(x,\\pi,\\mathsf{aux},v;w)<span class="math"> such that </span>\\{(x,\\pi,\\mathsf{aux},v):(x,\\pi,\\mathsf{aux})\\leftarrow\\mathcal{P}^{\\mathsf{a},\\mathsf{RO}}\\wedge v\\leftarrow\\mathcal{V}^{\\mathsf{RO}}(x,\\pi)\\}<span class="math"> and </span>\\{(x,\\pi,\\mathsf{aux},v):(x,\\pi,\\mathsf{aux},v;w)\\leftarrow\\mathcal{E}^{\\mathcal{P}^{\\mathsf{a}}}(n)\\}$ are identically distributed and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr\\big{(}v=\\mathsf{accept}\\wedge(x;w)\\in R:(x,\\pi,\\mathsf{aux},v;w)\\leftarrow\\mathcal{E}^{\\mathcal{P}^{\\mathsf{a}}}(n)\\big{)}\\geq\\frac{\\epsilon(\\mathcal{P}^{\\mathsf{a}})-\\kappa(n,Q)}{q(n)}\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon(\\mathcal{P}^{\\mathsf{a}})=\\Pr\\big{(}\\mathcal{V}^{\\mathsf{RO}}(x,\\pi)=1:(x,\\pi)\\leftarrow\\mathcal{P}^{\\mathsf{a},\\mathsf{RO}}\\big{)}</span>. Here, <span class="math">\\mathcal{E}</span> implements <span class="math">\\mathsf{RO}</span> for <span class="math">\\mathcal{P}^{\\mathsf{a}}</span>, in particular, <span class="math">\\mathcal{E}</span> can arbitrarily program <span class="math">\\mathsf{RO}</span>. Moreover, the randomness is over the randomness of <span class="math">\\mathcal{E}</span>, <span class="math">\\mathcal{V}</span>, <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> and <span class="math">\\mathsf{RO}</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">We note that, while the tuple <span class="math">(x,\\pi,\\mathsf{aux},v)</span> is required to have the same distribution for <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> and <span class="math">\\mathcal{E}(n)</span>, by default the respective executions of <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> and <span class="math">\\mathcal{E}(n)</span> give rise to two different probability spaces. Looking ahead though, we remark that the extractor that we eventually construct first does an honest run of <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> by faithfully simulating the answers to <span class="math">\\mathcal{P}^{\\mathsf{a}}</span>’s random oracle queries (this produces the tuple <span class="math">(x,\\pi,\\mathsf{aux},v)</span> that <span class="math">\\mathcal{E}(n)</span> eventually outputs and which so trivially has the right distribution), and then, if <span class="math">\\pi</span> is a valid proof, <span class="math">\\mathcal{E}(n)</span> starts rewinding <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> and reprogramming the random oracle to try to find enough valid proofs to compute a witness. Thus, in this sense, we can then say that <span class="math">\\mathcal{E}(n)</span> aims to find a witness <span class="math">w\\in R(x)</span> for <em>the statement <span class="math">x</span> outputted by <span class="math">\\mathcal{P}^{\\mathsf{a}}</span></em>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">2.5 Fiat–Shamir Transformations</h3>

    <p class="text-gray-300">The Fiat-Shamir transformation <em>[x10]</em> turns a public-coin interactive proof into a non-interactive random oracle proof (NIROP). The general idea is to compute the <span class="math">i</span>-th challenge <span class="math">c_{i}</span> as a hash of the <span class="math">i</span>-th prover message <span class="math">a_{i}</span> and (some part of) the previous communication transcript. For a <span class="math">\\Sigma</span>-protocol, the challenge <span class="math">c</span> is computed as <span class="math">c=H(a)</span> or as <span class="math">c=H(x,a)</span>, where the former is sufficient for <em>static</em> security, where the statement <span class="math">x</span> is given as input to the dishonest prover, and the latter is necessary for <em>adaptive</em> security, where the dishonest prover can choose the statement <span class="math">x</span> for which it wants to forge a proof.</p>

    <p class="text-gray-300">For multi-round public-coin interactive proofs, there is some degree of freedom in the computation of the <span class="math">i</span>-th challenge. For concreteness and simplicity, we consider a particular version where all previous prover messages are hashed along with the current message. As for <span class="math">\\Sigma</span>-protocols, we consider a static and an adaptive variant of this version of the Fiat-Shamir transformation. In contrast to the static variant, the adaptive Fiat-Shamir transformation includes the statement <span class="math">x</span> in all hash function evaluations. If it is not made explicit which variant is used, the considered result holds for both variants.</p>

    <p class="text-gray-300">Let <span class="math">\\Pi = (\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\mu +1)</span>-move public-coin interactive proof, where the challenge from the <span class="math">i</span>-th round is sampled from set <span class="math">\\mathcal{C}_i</span>. For simplicity, we consider <span class="math">\\mu</span> random oracles <span class="math">\\mathsf{RO}_i\\colon \\{0,1\\}^{\\leq u}\\to \\mathcal{C}_i</span> that map into the respective challenge spaces.</p>

    <p class="text-gray-300"><strong>Definition 11 (Fiat-Shamir Transformation).</strong> The static Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\varPi] = (\\mathcal{P}_{\\mathrm{fs}},\\mathcal{V}_{\\mathrm{fs}})</span> is the NIROP where <span class="math">\\mathcal{P}_{\\mathrm{fs}}^{\\mathsf{RO}_1,\\dots,\\mathsf{RO}_\\mu}(x;w)</span> runs <span class="math">\\mathcal{P}(x;w)</span> but instead of asking the verifier for the challenge <span class="math">c_{i}</span> on message <span class="math">a_{i}</span>, the challenges are computed as</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = \\mathsf {R O} _ {i} \\left(a _ {1}, \\dots , a _ {i - 1}, a _ {i}\\right); \\tag {3}</span></div>

    <p class="text-gray-300">the output is then the proof <span class="math">\\pi = (a_{1},\\ldots ,a_{\\mu +1})</span>. On input a statement <span class="math">x</span> and a proof <span class="math">\\pi = (a_{1},\\dots ,a_{\\mu +1})</span>, <span class="math">\\mathcal{V}_{\\mathrm{fs}}^{\\mathrm{RO}_1,\\dots,\\mathrm{RO}_\\mu}(x,\\pi)</span> accepts if, for <span class="math">c_{i}</span> as above <span class="math">\\mathcal{V}</span> accepts the transcript <span class="math">(a_{1},c_{1},\\dots ,a_{\\mu},c_{\\mu},a_{\\mu +1})</span> on input <span class="math">x</span>.</p>

    <p class="text-gray-300">If the challenges are computed as</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = \\mathsf {R O} _ {i} \\left(x, a _ {1}, \\dots , a _ {i - 1}, a _ {i}\\right); \\tag {4}</span></div>

    <p class="text-gray-300">the resulting NIROP is referred to as the adaptive Fiat-Shamir transformation.</p>

    <p class="text-gray-300">By means of reducing the security of other variants of the Fiat-Shamir transformation to Definition 11, appropriately adjusted versions of our results also apply to other variants of doing the "chaining" (Equations 3 and 4) in the Fiat-Shamir transformation, for instance when <span class="math">c_{i}</span> is computed as <span class="math">c_{i} = \\mathsf{RO}_{i}(i,c_{i - 1},a_{i})</span> or <span class="math">c_{i} = \\mathsf{RO}_{i}(x,i,c_{i - 1},a_{i})</span>, where <span class="math">c_{0}</span> is the empty string.</p>

    <h2 id="sec-27" class="text-2xl font-bold">2.6 Negative Hypergeometric Distribution</h2>

    <p class="text-gray-300">Consider a bucket containing <span class="math">\\ell</span> green balls and <span class="math">N - \\ell</span> red balls, i.e., a total of <span class="math">N</span> balls. In the negative hypergeometric experiment balls are drawn uniformly at random from this bucket, without replacement, until <span class="math">k</span> green balls have been found or until the bucket is empty. The number of red balls <span class="math">X</span> drawn in this experiment is said have a negative hypergeometric distribution with parameters <span class="math">N, \\ell, k</span>, which is denoted by <span class="math">X \\sim \\mathsf{NHG}(N, \\ell, k)</span>.</p>

    <p class="text-gray-300"><strong>Lemma 1 (Negative Hypergeometric Distribution).</strong> Let <span class="math">N, \\ell, k \\in \\mathbb{N}</span> with <span class="math">\\ell, k \\leq N</span>, and let <span class="math">X \\sim \\mathsf{NHG}(N, \\ell, k)</span>. Then <span class="math">\\mathbb{E}[X] \\leq k \\frac{N - \\ell}{\\ell + 1}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> If <span class="math">\\ell &amp;lt; k</span>, it clearly holds that <span class="math">\\operatorname*{Pr}(X = N - \\ell) = 1</span>. Hence, in this case, <span class="math">\\mathbb{E}[X] = N - \\ell \\leq k\\frac{N - \\ell}{\\ell + 1}</span>, which proves the claim.</p>

    <p class="text-gray-300">So let us now consider the case <span class="math">\\ell \\geq k</span>. Then, for all <span class="math">0 \\leq x \\leq N - \\ell</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} (X = x) = \\frac {\\binom {x + k - 1} {x} \\binom {N - x - k} {N - \\ell - x}}{\\binom {N} {N - \\ell}}.</span></div>

    <p class="text-gray-300">Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb {E} [ X ] = \\sum_ {x = 0} ^ {N - \\ell} \\Pr (X = x) \\cdot x = \\sum_ {x = 1} ^ {N - \\ell} x \\frac {\\binom {x + k - 1} {x} \\binom {N - x - k} {N - \\ell - x}}{\\binom {N} {N - \\ell}} \\\\ = k \\frac {N - \\ell}{\\ell + 1} \\sum_ {x = 1} ^ {N - \\ell} \\frac {\\frac {x}{k} \\binom {x + k - 1} {x} \\binom {N - x - k} {N - \\ell - x}}{\\frac {N - \\ell}{\\ell + 1} \\binom {N} {N - \\ell}} = k \\frac {N - \\ell}{\\ell + 1} \\sum_ {x = 1} ^ {N - \\ell} \\frac {\\binom {x + k - 1} {x - 1} \\binom {N - x - k} {N - \\ell - x}}{\\binom {N} {N - \\ell - 1}} \\\\ = k \\frac {N - \\ell}{\\ell + 1} \\sum_ {x = 1} ^ {N - \\ell} \\Pr (Y = x - 1) = k \\frac {N - \\ell}{\\ell + 1}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">Y \\sim \\mathsf{NHG}(N, \\ell + 1, k - 1)</span>. This completes the proof of the lemma.</p>

    <p class="text-gray-300">9</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">Typically, negative hypergeometric experiments are restricted to the non-trivial case <span class="math">\\ell\\geq k</span>. For reasons to become clear later, we also allow parameter choices with <span class="math">\\ell&lt;k</span> resulting in a trivial negative hypergeometric experiment in which all balls are always drawn.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Remark 5.</h6>

    <p class="text-gray-300">The above has a straightforward generalization to buckets with balls of more than 2 colors: say <span class="math">\\ell</span> green balls and <span class="math">m_{i}</span> balls of color <span class="math">i</span> for <span class="math">1\\leq i\\leq M</span>. The experiment proceeds as before, i.e., drawing until either <span class="math">k</span> green balls have been found or the bucket is empty. Let <span class="math">X_{i}</span> be the number of balls of color <span class="math">i</span> that are drawn in this experiment. Then <span class="math">X_{i}\\sim\\mathsf{NHG}(\\ell+m_{i},\\ell,k)</span> for all <span class="math">i</span>. To see this, simply run the generalized negative hypergeometric experiment without counting the balls that are neither green nor of color <span class="math">i</span>.</p>

    <h2 id="sec-30" class="text-2xl font-bold">3 An Abstract Sampling Game</h2>

    <p class="text-gray-300">Towards the goal of constructing and analyzing a knowledge extractor for the Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\varPi]</span> of special-sound interactive proofs <span class="math">\\varPi=(\\mathcal{P},\\mathcal{V})</span>, we define and analyze an abstract sampling game. Given access to a deterministic <span class="math">Q</span>-query prover <span class="math">\\mathcal{P}^{*}</span>, attacking the non-interactive random oracle proof <span class="math">\\mathsf{FS}[\\varPi]</span>, our extractor will essentially play this abstract game in the case <span class="math">\\varPi</span> is a <span class="math">\\Sigma</span>-protocol, and it will play this game recursively in the general case of a multi-round protocol. The abstraction allows us to focus on the crucial properties of the extraction algorithm, without unnecessarily complicating the notation.</p>

    <p class="text-gray-300">The game considers an arbitrary but fixed <span class="math">U</span>-dimensional array <span class="math">M</span>, where, for all <span class="math">1\\leq j_{1},\\ldots,j_{U}\\leq N</span>, the entry <span class="math">M(j_{1},\\ldots,j_{U})=(v,i)</span> contains a bit <span class="math">v\\in\\{0,1\\}</span> and an index <span class="math">i\\in\\{1,\\ldots,U\\}</span>. Think of the bit <span class="math">v</span> indicating whether this entry is “good” or “bad”, and the index <span class="math">i</span> points to one of the <span class="math">U</span> dimensions. The goal will be to find <span class="math">k</span> “good” entries with the same index <span class="math">i</span>, and with all of them lying in the 1-dimensional array <span class="math">M(j_{1},\\ldots,j_{i-1},\\,\\cdot\\,,j_{i+1},\\ldots,j_{U})</span> for some <span class="math">1\\leq j_{1},\\ldots,j_{i-1},j_{i+1},\\ldots,j_{U}\\leq N</span>.</p>

    <p class="text-gray-300">Looking ahead, considering the case of a <span class="math">\\Sigma</span>-protocol first, this game captures the task of our extractor to find <span class="math">k</span> proofs that are valid and feature the same first message but have different hash values assigned to the first message. Thus, in our application, the sequence <span class="math">j_{1},\\ldots,j_{U}</span> specifies the function table of the random oracle</p>

    <p class="text-gray-300"><span class="math">\\mathsf{RO}\\colon\\left\\{1,\\ldots,U\\right\\}\\to\\left\\{1,\\ldots,N\\right\\},i\\mapsto j_{i}</span></p>

    <p class="text-gray-300">while the entry <span class="math">M(j_{1},\\ldots,j_{U})</span> captures the relevant properties of the proof produced by the considered prover when interacting with that particular specification of the random oracle. Concretely, the bit <span class="math">v</span> indicates whether the proof is valid, and the index <span class="math">i</span> is the first message <span class="math">a</span> of the proof. Replacing <span class="math">j_{i}</span> by <span class="math">j^{\\prime}_{i}</span> then means to reprogram the random oracle at the point <span class="math">i=a</span>. Note that after the reprogramming, we want to obtain another valid proof with the same first message, i.e., with the same index <span class="math">i</span> (but now a different challenge, due to the reprogramming).</p>

    <p class="text-gray-300">The game is formally defined in Figure 2 and its core properties are summarized in Lemma 2 below. Looking ahead, we note that for efficiency reasons, the extractor will naturally not sample the entire sequence <span class="math">j_{1},\\ldots,j_{U}</span> (i.e., function table), but will sample its components on the fly using lazy sampling.</p>

    <p class="text-gray-300">To capture the main properties of the abstract sampling game, for all <span class="math">1\\leq i\\leq U</span>, we define the function</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$a_{i}\\colon\\left\\{1,\\ldots,N\\right\\}^{U}\\to\\mathbb{N}_{\\geq 0},(j_{1},\\ldots,j_{U})\\mapsto\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{j:\\;M(j_{1},\\ldots,j_{i-1},j,j_{i+1},\\ldots,j_{U})=(1,i)\\,\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,.$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The value <span class="math">a_{i}(j_{1},\\ldots,j_{U})</span> counts the number of entries that are “good” and have index <span class="math">i</span> in the 1-dimensional array <span class="math">M(j_{1},\\ldots,j_{i-1},\\,\\cdot\\,,j_{i+1},\\ldots,j_{U})</span>. Note that <span class="math">a_{i}</span> does not depend on the <span class="math">i</span>-th entry of the input vector <span class="math">(j_{1},\\ldots,j_{U})</span>, and so, by a slight abuse of notation, we sometimes also write <span class="math">a_{i}(j_{1},\\ldots,j_{i-1},j_{i+1},\\ldots,j_{U})</span> instead.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 2 (Abstract Sampling Game).</h6>

    <p class="text-gray-300">Consider the game in Figure 2. Let <span class="math">J=(J_{1},\\ldots,J_{U})</span> be uniformly distributed in <span class="math">\\{1,\\ldots,N\\}^{U}</span>, indicating the first entry sampled, and let <span class="math">(V,I)=M(J_{1},\\ldots,J_{U})</span>. Further, for all <span class="math">1\\leq i\\leq U</span>, let <span class="math">A_{i}=a_{i}(J)</span>. Moreover, let <span class="math">X</span> be the number of entries of the form <span class="math">(1,i)</span> with <span class="math">i=I</span> sampled (including the first one), and let <span class="math">\\Lambda</span> be the total number of entries sampled in this game. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[A]\\leq 1+(k-1)P\\quad\\text{and}</span> <span class="math">\\Pr(X=k)\\geq\\frac{N}{N-k+1}\\left(\\Pr(V=1)-P\\cdot\\frac{k-1}{N}\\right)\\,,</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">Fig. 2. Abstract Sampling Game.</p>

    <p class="text-gray-300">Parameters: <span class="math">k, N, U \\in \\mathbb{N}</span>, and <span class="math">M</span> a <span class="math">U</span>-dimensional array with entries in <span class="math">M(j_1, \\ldots, j_U) \\in \\{0, 1\\} \\times \\{1, \\ldots, U\\}</span> for all <span class="math">1 \\leq j_1, \\ldots, j_U \\leq N</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">(j_1, \\ldots, j_U) \\in \\{1, \\ldots, N\\}^U</span> uniformly at random and set <span class="math">(v, i) = M(j_1, \\ldots, j_U)</span>.</li>

      <li>If <span class="math">v = 0</span>, abort.</li>

      <li>Else, repeat</li>

      <li>sample <span class="math">j&#x27; \\in \\{1, \\ldots, N\\} \\setminus \\{j_i\\}</span> (without replacement),</li>

      <li>compute <span class="math">(v&#x27;, i&#x27;) = M(j_1, \\ldots, j_{i-1}, j&#x27;, j_{i+1}, \\ldots, j_U)</span>,</li>

      <li>until either <span class="math">k - 1</span> additional entries equal to <span class="math">(1, i)</span> have been found or until all indices <span class="math">j&#x27;</span> have been tried.</li>

    </ul>

    <p class="text-gray-300">where <span class="math">P = \\sum_{i=1}^{U} \\operatorname{Pr}(A_i &amp;gt; 0)</span>.</p>

    <p class="text-gray-300">Note the abstractly defined parameter <span class="math">P</span>. In our application, where <span class="math">M(j_{1},\\ldots ,j_{U})</span> is determined by the output of an algorithm making no more than <span class="math">Q</span> queries to the random oracle with function table <span class="math">j_{1},\\ldots ,j_{U}</span>, the parameter <span class="math">P</span> will be bounded by <span class="math">Q + 1</span>. We show this formally (yet again somewhat abstractly) in Lemma 3. Intuitively, the reason is that the events <span class="math">A_{i} &amp;gt; 0</span> are disjoint for the all but <span class="math">Q</span> indices <span class="math">i</span> that the considered algorithm does not query, and so their probabilities add up to at most 1. Indeed, if <span class="math">a_{i}(j_{1},\\dots ,j_{U}) &amp;gt; 0</span> for an index <span class="math">i</span> that the algorithm did not query then <span class="math">M(j_{1},\\dots ,j_{U}) = (1,i)</span>; namely, by choice of <span class="math">i</span>, the output of the algorithm is oblivious to the value of <span class="math">j_{i}</span>. Therefore, given <span class="math">j_{1},\\dots ,j_{U}</span>, such an index <span class="math">i</span> as above is unique.</p>

    <p class="text-gray-300">Proof (of Lemma 2). Expected Number of Samples. Let us first derive an upper bound on the expected value of <span class="math">\\Lambda</span>. To this end, let <span class="math">X&#x27;</span> denote the number of sampled entries of the form <span class="math">(1,i)</span> with <span class="math">i = I</span>, but, in contrast to <span class="math">X</span>, without counting the first one. Similarly, let <span class="math">Y&#x27;</span> denote the number of sampled entries of the form <span class="math">(v,i)</span> with <span class="math">v = 0</span> or <span class="math">i \\neq I</span>, again without counting the first one. Then <span class="math">\\Lambda = 1 + X&#x27; + Y&#x27;</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(X ^ {\\prime} = 0 \\mid V = 0\\right) = \\Pr \\left(Y ^ {\\prime} = 0 \\mid V = 0\\right) = 1.</span></div>

    <p class="text-gray-300">Hence, <span class="math">\\mathbb{E}[X&#x27; \\mid V = 0] = \\mathbb{E}[Y&#x27; \\mid V = 0] = 0</span>.</p>

    <p class="text-gray-300">Let us now consider the expected value <span class="math">\\mathbb{E}[Y&#x27; \\mid V = 1]</span>. To this end, we observe that, conditioned on the event <span class="math">V = 1 \\wedge I = i \\wedge A_i = a</span> with <span class="math">a &amp;gt; 0</span>, <span class="math">Y&#x27;</span> follows a negative hypergeometric distribution with parameters <span class="math">N - 1</span>, <span class="math">a - 1</span> and <span class="math">k - 1</span>. Hence, by Lemma 1,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ Y ^ {\\prime} \\mid V = 1 \\wedge I = i \\wedge A _ {i} = a \\right] \\leq (k - 1) \\frac {N - a}{a},</span></div>

    <p class="text-gray-300">and thus, using that <span class="math">\\operatorname*{Pr}(X&#x27; \\leq k - 1 \\mid V = 1) = 1</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} \\left[ X ^ {\\prime} + Y ^ {\\prime} \\mid V = 1 \\wedge I = i \\wedge A _ {i} = a \\right] \\leq (k - 1) + (k - 1) \\frac {N - a}{a} = (k - 1) \\frac {N}{a}.</span></div>

    <p class="text-gray-300">On the other hand</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr (V = 1 \\wedge I = i \\mid A _ {i} = a) = \\frac {a}{N}</span></div>

    <p class="text-gray-300">and thus</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr (V = 1 \\wedge I = i \\wedge A _ {i} = a) = \\Pr (A _ {i} = a) \\frac {a}{N}. \\tag {6}</span></div>

    <p class="text-gray-300">Therefore, and since <span class="math">\\operatorname{Pr}(V = 1 \\land I = i \\land A_i = 0) = 0</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname{Pr}(V = 1) \\cdot \\mathbb{E}[X&#x27; + Y&#x27; \\mid V = 1] &amp;amp;= \\sum_{i=1}^{U} \\sum_{a=1}^{N} \\operatorname{Pr}(V = 1 \\land I = i \\land A_i = a) \\cdot \\mathbb{E}[X&#x27; + Y&#x27; \\mid V = 1 \\land I = i \\land A_i = a] \\\\ &amp;amp;\\leq \\sum_{i=1}^{U} \\sum_{a=1}^{N} \\operatorname{Pr}(A_i = a)(k - 1) \\\\ &amp;amp;= (k - 1) \\sum_{i=1}^{U} \\operatorname{Pr}(A_i &amp;gt; 0) \\\\ &amp;amp;= (k - 1)P, \\end{aligned}</span></div>

    <p class="text-gray-300">where <span class="math">P = \\sum_{i=1}^{U} \\operatorname{Pr}(A_i &amp;gt; 0)</span>. Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbb{E}[\\Lambda] &amp;amp;= \\mathbb{E}[1 + X&#x27; + Y&#x27;] \\\\ &amp;amp;= 1 + \\operatorname{Pr}(V = 0) \\cdot \\mathbb{E}[X&#x27; + Y&#x27; \\mid V = 0] + \\operatorname{Pr}(V = 1) \\cdot \\mathbb{E}[X&#x27; + Y&#x27; \\mid V = 1] \\\\ &amp;amp;\\leq 1 + (k - 1)P, \\end{aligned}</span></div>

    <p class="text-gray-300">which proves the claimed upper bound on <span class="math">\\mathbb{E}[\\Lambda]</span>.</p>

    <p class="text-gray-300"><strong>Success Probability.</strong> Let us now find a lower bound for the "success probability" <span class="math">\\operatorname{Pr}(X = k)</span> of this game. Using (6) again, we can write</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}(X = k) = \\sum_{i=1}^{U} \\operatorname{Pr}(V = 1 \\land I = i \\land A_i \\geq k) = \\sum_{i=1}^{U} \\sum_{a=k}^{N} \\operatorname{Pr}(A_i = a) \\frac{a}{N}.</span></div>

    <p class="text-gray-300">Now, using <span class="math">a \\leq N</span>, note that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\frac{a}{N} &amp;amp;= 1 - \\left(1 - \\frac{a}{N}\\right) \\geq 1 - \\frac{N}{N - k + 1} \\left(1 - \\frac{a}{N}\\right) \\\\ &amp;amp;= \\frac{N}{N - k + 1} \\left(\\frac{N - k + 1}{N} - 1 + \\frac{a}{N}\\right) = \\frac{N}{N - k + 1} \\left(\\frac{a}{N} - \\frac{k - 1}{N}\\right). \\end{aligned}</span></div>

    <p class="text-gray-300">Therefore, combining the two, and using that the summand becomes negative for <span class="math">a &amp;lt; k</span> to argue the second inequality, and using (6) once more, we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname{Pr}(X = k) &amp;amp;\\geq \\sum_{i=1}^{U} \\sum_{a=k}^{N} \\operatorname{Pr}(A_i = a) \\frac{N}{N - k + 1} \\left(\\frac{a}{N} - \\frac{k - 1}{N}\\right) \\\\ &amp;amp;\\geq \\sum_{i=1}^{U} \\sum_{a=1}^{N} \\operatorname{Pr}(A_i = a) \\frac{N}{N - k + 1} \\left(\\frac{a}{N} - \\frac{k - 1}{N}\\right) \\\\ &amp;amp;= \\frac{N}{N - k + 1} \\sum_{i=1}^{U} \\sum_{a=1}^{N} \\left(\\operatorname{Pr}(V = 1 \\land I = i \\land A_i = a) - \\operatorname{Pr}(A_i = a) \\cdot \\frac{k - 1}{N}\\right) \\\\ &amp;amp;= \\frac{N}{N - k + 1} \\left(\\operatorname{Pr}(V = 1) - \\frac{k - 1}{N} \\sum_{i=1}^{U} \\operatorname{Pr}(A_i &amp;gt; 0)\\right) \\\\ &amp;amp;= \\frac{N}{N - k + 1} \\left(\\operatorname{Pr}(V = 1) - P \\cdot \\frac{k - 1}{N}\\right), \\end{aligned}</span></div>

    <p class="text-gray-300">where, as before, we have used that <span class="math">\\operatorname{Pr}(V = 1 \\land I = i \\land A_i = 0) = 0</span> for all <span class="math">1 \\leq i \\leq U</span> to conclude the second equality, and finally that <span class="math">P = \\sum_{i=1}^{U} \\operatorname{Pr}(A_i &amp;gt; 0)</span>. This completes the proof of the lemma.</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">Our knowledge extractor will instantiate the abstract sampling game via a deterministic <span class="math">Q</span>-query prover <span class="math">\\mathcal{P}^<em></span> attacking the Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\varPi]</span>. The index <span class="math">i</span> of <span class="math">M(v,i) = (j_1,\\ldots ,j_U)</span> is then determined by the output of <span class="math">\\mathcal{P}^</em></span>, with the random oracle being given by the function table <span class="math">j_{1},\\ldots ,j_{U}</span>. Since the index <span class="math">i</span> is thus determined by <span class="math">Q</span> queries to the random oracle, the following shows that the parameter <span class="math">P</span> will in this case be bounded by <span class="math">Q + 1</span>.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Consider the game in Figure 2. Let <span class="math">v</span> and <span class="math">idx</span> be functions such that <span class="math">M(j) = (v(j), idx(j))</span> for all <span class="math">j \\in \\{1, \\ldots, N\\}^U</span>. Furthermore, let <span class="math">J = (J_1, \\ldots, J_U)</span> be uniformly distributed in <span class="math">\\{1, \\ldots, N\\}^U</span>, and set <span class="math">A_i = a_i(J)</span> for all <span class="math">1 \\leq i \\leq U</span>. Let us additionally assume that for all <span class="math">j \\in \\{1, \\ldots, N\\}^U</span> there exists a subset <span class="math">S(j) \\subseteq \\{1, \\ldots, U\\}</span> of cardinality at most <span class="math">Q</span> such that <span class="math">idx(j) = idx(j&#x27;)</span> for all <span class="math">j&#x27;</span> with <span class="math">j_\\ell&#x27; = j_\\ell</span> for all <span class="math">\\ell \\in S(j)</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">P = \\sum_{i = 1}^{U} \\Pr (A_i &amp;gt; 0) \\leq Q + 1.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> By basic probability theory, it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} P &amp;amp;= \\sum_{i = 1}^{U} \\Pr (A_i &amp;gt; 0) \\\\ &amp;amp;= \\sum_{j \\in \\{1, \\dots, N\\}^U} \\Pr (J = j) \\sum_{i = 1}^{U} \\Pr (A_i &amp;gt; 0 \\mid J = j) \\\\ &amp;amp;= \\sum_j \\Pr (J = j) \\left( \\sum_{i \\in S(j)} \\Pr (A_i &amp;gt; 0 \\mid J = j) + \\sum_{i \\notin S(j)} \\Pr (A_i &amp;gt; 0 \\mid J = j) \\right) \\\\ &amp;amp;\\leq \\sum_j \\Pr (J = j) \\left( Q + \\sum_{i \\notin S(j)} \\Pr (A_i &amp;gt; 0 \\mid J = j) \\right) \\\\ &amp;amp;\\leq Q + \\sum_j \\Pr (J = j) \\sum_{i \\notin S(j)} \\Pr (A_i &amp;gt; 0 \\mid J = j), \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the inequality follows from the fact that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(j)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Q<span class="math"> for all </span>j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now note that, by definition of the sets <span class="math">S(j)</span>, for all <span class="math">j \\in \\{1, \\dots, N\\}^U</span>, <span class="math">i \\notin S(j)</span> and <span class="math">j_i \\in \\{1, \\dots, N\\}</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( idx(J_1, \\dots, J_{i-1}, j_i, J_{i+1}, \\dots, J_U) = idx(j) \\mid J = j \\right) = 1.</span></div>

    <p class="text-gray-300">Therefore, for all <span class="math">i \\notin S(j) \\cup \\{idx(j)\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr (A_i &amp;gt; 0 \\mid J = j) = 0.</span></div>

    <p class="text-gray-300">Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\notin S(j)} \\Pr (A_i &amp;gt; 0 \\mid J = j) \\leq \\Pr (A_{idx(j)} &amp;gt; 0 \\mid J = j) \\leq 1.</span></div>

    <p class="text-gray-300">Altogether, it follows that</p>

    <div class="my-4 text-center"><span class="math-block">P \\leq Q + \\sum_j \\Pr (J = j) = Q + 1,</span></div>

    <p class="text-gray-300">which completes the proof.</p>

    <p class="text-gray-300">5 The probabilities <span class="math">\\operatorname{Pr}(A_i &amp;gt; 0 \\mid J = j)</span> are all 0 or 1; however, it's still convenient to use probability notation here.</p>

    <p class="text-gray-300">Let us first consider the Fiat-Shamir transformation of a  <span class="math">k</span> -special-sound  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi</span> , i.e., a 3-move interactive proof, with challenge set  <span class="math">\\mathcal{C}</span> ; subsequently, in Section 6, we move to general multi-round interactive proofs.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{P}^<em></span>  be a deterministic dishonest  <span class="math">Q</span> -query random-oracle prover, attacking the Fiat-Shamir transformation  <span class="math">\\mathsf{FS}[\\varPi]</span>  of  <span class="math">\\varPi</span>  on input  <span class="math">x</span> . Given a statement  <span class="math">x</span>  as input, after making  <span class="math">Q</span>  queries to the random oracle  <span class="math">\\mathsf{RO}\\colon \\{0,1\\}^{\\leq u}\\to \\mathcal{C}</span> ,  <span class="math">\\mathcal{P}^</em></span>  outputs a proof  <span class="math">\\pi = (a,z)</span> . For reasons to become clear later, we re-format (and partly rename) the output and consider</p>

    <div class="my-4 text-center"><span class="math-block">I := a \\qquad \\text {a n d} \\qquad \\pi</span></div>

    <p class="text-gray-300">as  <span class="math">\\mathcal{P}^*</span> 's output. We refer to the output  <span class="math">I</span>  as the index.</p>

    <p class="text-gray-300">Furthermore, we extend  <span class="math">\\mathcal{P}^<em></span>  to an algorithm  <span class="math">\\mathcal{A}</span>  that additionally checks the correctness of the proof  <span class="math">\\pi</span> . Formally,  <span class="math">\\mathcal{A}</span>  runs  <span class="math">\\mathcal{P}^</em></span>  to obtain  <span class="math">I</span>  and  <span class="math">\\pi</span> , queries  <span class="math">\\mathsf{RO}</span>  to obtain  <span class="math">c := \\mathsf{RO}(I)</span> , and then outputs</p>

    <div class="my-4 text-center"><span class="math-block">I = a, \\quad y := (a, c, z) \\qquad \\text {a n d} \\qquad v := V (y),</span></div>

    <p class="text-gray-300">where  <span class="math">V(y) = 1</span>  if  <span class="math">y</span>  is an accepting transcript for the interactive proof  <span class="math">\\varPi</span>  on input  <span class="math">x</span>  and  <span class="math">V(y) = 0</span>  otherwise. We will also write  <span class="math">\\mathcal{A}^{\\mathsf{RO}}</span>  for the algorithm that executes  <span class="math">\\mathcal{A}</span>  given a fixed random oracle  <span class="math">\\mathsf{RO}</span> .</p>

    <p class="text-gray-300">Hence,  <span class="math">\\mathcal{A}</span>  is a random-oracle algorithm making at most  <span class="math">Q + 1</span>  queries; indeed, it relays the oracle queries done by  <span class="math">\\mathcal{P}^*</span>  and makes the one needed to do the verification. Moreover,  <span class="math">\\mathcal{A}</span>  has a naturally defined success probability</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon (\\mathcal {A}) := \\Pr \\left(v = 1: (I, y, v) \\leftarrow \\mathcal {A} ^ {\\mathsf {R O}}\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{RO}\\colon \\{0,1\\}^{\\leq u}\\to \\mathcal{C}</span>  is chosen uniformly at random. The probability  <span class="math">\\epsilon (\\mathcal{A})</span>  equals the success probability  <span class="math">\\epsilon (\\mathcal{P}^{<em>},x)</span>  of the random-oracle prover  <span class="math">\\mathcal{P}^</em></span>  on input  <span class="math">x</span> .</p>

    <p class="text-gray-300">Our goal is now to construct an extraction algorithm that, when given black-box access to  <span class="math">\\mathcal{A}</span> , aims to output  <span class="math">k</span>  accepting transcripts  <span class="math">y_{1},\\ldots ,y_{k}</span>  with common first message  <span class="math">a</span>  and distinct challenges. By the  <span class="math">k</span> -special-soundness property of  <span class="math">\\varPi</span> , a witness for statement  <span class="math">x</span>  can be computed efficiently from these transcripts.</p>

    <p class="text-gray-300">The extractor  <span class="math">\\mathcal{E}</span>  is defined in Figure 3. We remark that, by construction of  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathcal{A}</span>  does make a query to  <span class="math">I</span> ; thus,  <span class="math">c_{i}</span>  is well defined in Figure 3. Also, since  <span class="math">\\mathcal{P}^*</span>  and thus  <span class="math">\\mathcal{A}</span>  is deterministic, in each iteration of the repeat loop  <span class="math">\\mathcal{A}</span>  is ensured to make the query to  <span class="math">I</span>  again.</p>

    <p class="text-gray-300">Parameters:  <span class="math">k, Q \\in \\mathbb{N}</span></p>

    <p class="text-gray-300">Black-box access to:  <span class="math">\\mathcal{A}</span>  as above</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">\\mathcal{A}</span>  as follows to obtain  <span class="math">(I, y_1, v)</span> : answer all (distinct) oracle queries with uniformly random values in  <span class="math">\\mathcal{C}</span> . Set  <span class="math">i := I</span> , and let  <span class="math">c_i</span>  be the response to query  <span class="math">i</span> .</li>

      <li>If  <span class="math">v = 0</span> , abort.</li>

      <li>Else, repeat</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sample  <span class="math">c_i&#x27; \\in \\mathcal{C} \\setminus \\{c_i\\}</span>  (without replacement);</li>

      <li>run  <span class="math">\\mathcal{A}</span>  as follows to obtain  <span class="math">(I&#x27;, y&#x27;, v&#x27;)</span> : answer the query to  <span class="math">i</span>  with  <span class="math">c_i&#x27;</span> , while answering all other queries consistently if the query was performed by  <span class="math">\\mathcal{A}</span>  already on a previous run and with a fresh random value in  <span class="math">\\mathcal{C}</span>  otherwise;</li>

    </ul>

    <p class="text-gray-300">until either  <span class="math">k - 1</span>  additional challenges  <span class="math">c_i&#x27;</span>  with  <span class="math">v&#x27; = 1</span>  and  <span class="math">I&#x27; = I</span>  have been found or until all challenges  <span class="math">c_i&#x27; \\in \\mathcal{C}</span>  have been tried.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the former case, output the  <span class="math">k</span>  accepting transcripts  <span class="math">y_{1},\\ldots ,y_{k}</span></li>

    </ul>

    <p class="text-gray-300">A crucial observation is the following. Within a run of  <span class="math">\\mathcal{E}</span> , all the queries that are made by the different invocations of  <span class="math">\\mathcal{A}</span>  are answered consistently using lazy sampling, except for the queries to the index  <span class="math">i</span> , where</p>

    <p class="text-gray-300">different responses <span class="math">c_{i},c_{i}^{\\prime},\\ldots</span> are given. This is indistinguishable from having them answered by a full-fledged random oracle, i.e., by means of a pre-chosen function <span class="math">\\mathsf{RO}:\\{0,1\\}^{\\leq u}\\to\\mathcal{C}</span>, <span class="math">\\ell\\mapsto j_{\\ell}=\\mathsf{RO}(\\ell)</span>, but then replacing <span class="math">j_{i}</span> by fresh <span class="math">j^{\\prime}\\neq j_{i}</span> for the runs of <span class="math">\\mathcal{A}</span> in the repeat loop. Thus, the extractor is actually running the abstract game from Figure 2 and bounds on the success probability and the expected run time (in terms of queries to <span class="math">\\mathcal{A}</span>) follow from Lemma 2 and Lemma 3. Altogether we obtain the following result.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Lemma 4 (Extractor).</h6>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}</span> of Figure 3 makes an expected number of at most <span class="math">k+Q\\cdot(k-1)</span> queries to <span class="math">\\mathcal{A}</span> and succeeds in outputting <span class="math">k</span> transcripts <span class="math">y_{1},\\ldots,y_{k}</span> with common first message <span class="math">a</span> and distinct challenges with probability at least</p>

    <p class="text-gray-300"><span class="math">\\frac{N}{N-k+1}\\left(\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\frac{k-1}{N}\\right)\\,.</span></p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">U</span> be the cardinality of the domain <span class="math">\\{0,1\\}^{\\leq u}</span> of a random oracle <span class="math">\\mathsf{RO}\\colon\\{0,1\\}^{\\leq u}\\to\\mathcal{C}</span>. Considering an arbitrary but fixed ordering <span class="math">\\xi_{1},\\ldots,\\xi_{U}</span> of the bitstrings <span class="math">\\xi_{i}\\in\\{0,1\\}^{\\leq u}</span>, a vector <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span> then encodes the function table of the entire random oracle as <span class="math">\\mathsf{RO}(\\xi_{i})=c_{i}</span>. For this reason, we can also refer to <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span> as a (full-fledged) random oracle.</p>

    <p class="text-gray-300">Further, since <span class="math">\\mathcal{P}^{*}</span> is deterministic, the outputs <span class="math">I</span>, <span class="math">y</span> and <span class="math">v</span> of the algorithm <span class="math">\\mathcal{A}</span> can be viewed as functions taking as input a random oracle <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>.</p>

    <p class="text-gray-300">Let us now consider the following array <span class="math">M(\\mathbf{c})=\\big{(}I(\\mathbf{c}),v(\\mathbf{c})\\big{)}</span>, indexed by random oracles <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>. Then, a single run of the extractor is indistinguishable from playing the abstract sampling game of Figure 2 instantiated with array <span class="math">M</span>. The only difference is that, in this sampling game, we consider full-fledged random oracles encoded by vectors <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>, while the actual extractor implements these random oracles by lazy sampling.</p>

    <p class="text-gray-300">Thus, we can apply Lemma 2 to obtain bounds on the success probability and the expected run time. However, in order to control the parameter <span class="math">P</span>, which occurs in the bound of Lemma 2, we make the following observation, so that we can apply Lemma 3 and prove that <span class="math">P\\leq Q+1</span>.</p>

    <p class="text-gray-300">Namely, since <span class="math">\\mathcal{P}^{<em>}</span> is deterministic, its output can only change when the random oracle is reprogrammed at one of the indices <span class="math">i\\in\\{0,1\\}^{\\leq u}</span> queried by <span class="math">\\mathcal{P}^{</em>}</span>. In other words, for every random oracle <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>, there exists a subset <span class="math">S(\\mathbf{c})\\subset\\{0,1\\}^{\\leq u}</span> (indicating the queries made by <span class="math">\\mathcal{P}^{<em>}</span>) such that <span class="math">\\mathcal{P}^{</em>}</span>’s output stays the same when the random oracle is reprogrammed at an index <span class="math">i\\notin S(\\mathbf{c})</span>. In particular, <span class="math">I(\\mathbf{c})=I(\\mathbf{c}^{\\prime})</span> for all <span class="math">\\mathbf{c},\\mathbf{c}^{\\prime}</span> with <span class="math">c_{i}=c_{i}^{\\prime}</span> for all <span class="math">i\\in S(\\mathbf{c})</span>. Hence, the conditions of Lemma 3 are satisfied and <span class="math">P\\leq Q+1</span>. The bounds on the success probability and the expected run time now follow, completing the proof. ∎</p>

    <p class="text-gray-300">Given the existence of the above extractor, combined with the <span class="math">k</span>-special-soundness property, implies the following theorem.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 1 (Fiat-Shamir Transformation of a <span class="math">\\Sigma</span>-Protocol).</h6>

    <p class="text-gray-300">The Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\Pi]</span> of a <span class="math">k</span>-out-of-<span class="math">N</span> special-sound <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi</span> is knowledge sound with knowledge error</p>

    <p class="text-gray-300"><span class="math">\\kappa_{\\text{fs}}(Q)=(Q+1)\\cdot\\kappa\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa:=\\operatorname{Er}(k;N)=(k-1)/N</span> is the knowledge error of the (interactive) <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi</span>.</p>

    <h2 id="sec-37" class="text-2xl font-bold">5 Refined Analysis of the Abstract Sampling Game</h2>

    <p class="text-gray-300">Before we prove knowledge soundness of the Fiat-Shamir transformation of multi-round interactive protocols, we reconsider the abstract game of Section 3, and consider a refined analysis of the cost of playing the game. The multi-round knowledge extractor will essentially play a recursive composition of this game; however, the analysis of Section 3 is insufficient for our purposes (resulting in a super-polynomial bound on the run-time of the knowledge extractor). Fortunately, it turns out that a refinement allows us to prove the required (polynomial) upper bound.</p>

    <p class="text-gray-300">In Section 3, the considered cost measure is the number of entries visited during the game. For <span class="math">\\Sigma</span>-protocols, every entry corresponds to a single invocation of the dishonest prover <span class="math">\\mathcal{P}^{*}</span>. For multi-round protocols, every entry will correspond to a single invocation of a subtree extractor. The key observation is that some invocations of the subtree extractor are expensive while others are cheap. For this reason, we introduce a cost function <span class="math">\\Gamma</span> and a constant cost <span class="math">\\gamma</span> to our abstract game, allowing us to differentiate between these two cases. <span class="math">\\Gamma</span> and <span class="math">\\gamma</span> assign a cost to every entry of the array <span class="math">M</span>; <span class="math">\\Gamma</span> corresponds to the cost of an expensive invocation of the subtree extractor and <span class="math">\\gamma</span> corresponds to the cost of a cheap invocation. While this refinement presents a natural generalization of the abstract game of Section 3, its analysis becomes significantly more involved.</p>

    <p class="text-gray-300">The following lemma provides an upper bound for the total cost of playing the abstract game in terms of these two cost functions.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Lemma 5 (Abstract Sampling Game - Weighted Version).</h6>

    <p class="text-gray-300">Consider again the game of Figure 2, as well a cost function <span class="math">\\Gamma\\colon\\{1,\\ldots,N\\}^{U}\\to\\mathbb{R}_{\\geq 0}</span> and a constant cost <span class="math">\\gamma\\in\\mathbb{R}_{\\geq 0}</span>. Let <span class="math">J=(J_{1},\\ldots,J_{U})</span> be uniformly distributed in <span class="math">\\{1,\\ldots,N\\}^{U}</span>, indicating the first entry sampled, and let <span class="math">(V,I)=M(J_{1},\\ldots,J_{U})</span>. Further, for all <span class="math">1\\leq i\\leq U</span>, let <span class="math">A_{i}=a_{i}(J)</span>, where the function <span class="math">a_{i}</span> is as defined in Equation 5.</p>

    <p class="text-gray-300">We define the cost of sampling an entry <span class="math">M(j_{1},\\ldots,j_{U})=(v,i)</span> with index <span class="math">i=I</span> to be <span class="math">\\Gamma(j_{1},\\ldots,j_{U})</span> and the cost of sampling an entry <span class="math">M(j_{1},\\ldots,j_{U})=(v,i)</span> with index <span class="math">i\\neq I</span> to be <span class="math">\\gamma</span>. Let <span class="math">\\Delta</span> be the total cost of playing this game. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta]\\leq k\\cdot\\mathbb{E}[\\Gamma(J)]+(k-1)\\cdot T\\cdot\\gamma</span></p>

    <p class="text-gray-300">where <span class="math">T=\\sum_{i=1}^{U}\\Pr(I\\neq i\\wedge A_{i}&gt;0)\\leq P</span>.</p>

    <p class="text-gray-300">Note that the parameter <span class="math">T</span> in the statement here differs slightly from its counterpart <span class="math">P=\\sum_{i}\\Pr(A_{i}&gt;0)</span> in Lemma 2. Recalling the informal discussion of <span class="math">P</span> right after Lemma 2 in the context of our application, we immediately see that now the defining events <span class="math">I\\neq i\\wedge A_{i}&gt;0</span> are all empty for all but the <span class="math">Q</span> indices <span class="math">i</span> that the algorithm does not query, giving the bound <span class="math">T\\leq Q</span> here, compared to the bound <span class="math">P\\leq Q+1</span> on <span class="math">P</span>. The formal (and more abstract) statement and proof is given in Lemma 6.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let us split up <span class="math">\\Delta</span> into the cost measures <span class="math">\\Delta_{1}</span>, <span class="math">\\Delta_{2}</span> and <span class="math">\\Delta_{3}</span>, defined as follows. <span class="math">\\Delta_{1}</span> denotes the total costs of the elements <span class="math">M(j_{1},\\ldots,j_{U})=(1,i)</span> with <span class="math">i=I</span> sampled in the game, i.e., the elements with bit <span class="math">v=1</span> and index <span class="math">i=I</span>; correspondingly, <span class="math">X</span> denotes the number of entries of the form <span class="math">(1,i)</span> with <span class="math">i=I</span> sampled (including the first one if <span class="math">V=1</span>). Second, <span class="math">\\Delta_{2}</span> denotes the total costs of the elements <span class="math">M(j_{1},\\ldots,j_{U})=(0,i)</span> with <span class="math">i=I</span> sampled, i.e., the elements with bit <span class="math">v=0</span> and index <span class="math">i=I</span>; correspondingly, <span class="math">Y</span> denotes the number of entries of the form <span class="math">(0,i)</span> with <span class="math">i=I</span> sampled (including the first one if <span class="math">V=0</span>). Finally, <span class="math">\\Delta_{3}</span> denotes the total costs of the elements <span class="math">M(j_{1},\\ldots,j_{U})=(v,i)</span> with <span class="math">i\\neq I</span> sampled; correspondingly, <span class="math">Z</span> denotes the number of entries of this form sampled.</p>

    <p class="text-gray-300">Clearly <span class="math">\\Delta=\\Delta_{1}+\\Delta_{2}+\\Delta_{3}</span>. Moreover, since the cost <span class="math">\\gamma</span> is constant, it follows that <span class="math">\\mathbb{E}[\\Delta_{3}]=\\gamma\\cdot\\mathbb{E}[Z]</span>. In a similar manner, we now aim to relate <span class="math">\\mathbb{E}[\\Delta_{1}]</span> and <span class="math">\\mathbb{E}[\\Delta_{2}]</span> to <span class="math">\\mathbb{E}[Y]</span> and <span class="math">\\mathbb{E}[Z]</span>, respectively. However, since the cost function <span class="math">\\Gamma\\colon\\{1,\\ldots,N\\}^{U}\\to\\mathbb{R}_{\\geq 0}</span> is not necessarily constant, this is more involved.</p>

    <p class="text-gray-300">For <span class="math">1\\leq i\\leq U</span> let us write <span class="math">J_{i}^{<em>}=(J_{1},\\ldots,J_{i-1},J_{i+1},\\ldots,J_{U})</span>, which is uniformly random with support <span class="math">\\{1,\\ldots,N\\}^{U-1}</span>. Moreover, for all <span class="math">1\\leq i\\leq U</span> and <span class="math">j^{</em>}=(j_{1}^{<em>},\\ldots,j_{i-1}^{</em>},j_{i+1}^{<em>},\\cdots,j_{U})\\in\\{1,\\ldots,N\\}^{U-1}</span>, let <span class="math">\\Lambda(i,j^{</em>})</span> denote the event</p>

    <p class="text-gray-300"><span class="math">\\Lambda(i,j^{<em>})=[I=i\\,\\wedge\\,J_{i}^{</em>}=j^{*}]\\,.</span></p>

    <p class="text-gray-300">We note that conditioned on the event <span class="math">\\Lambda(i,j^{<em>})</span>, all samples are picked from the subarray <span class="math">M(j_{1}^{</em>},\\ldots,j_{i-1}^{<em>},\\cdot,j_{i+1}^{</em>},\\cdots,j_{U}^{*})</span>; the first one uniformly at random subject to the index <span class="math">I</span> being <span class="math">i</span>, and the remaining ones (if <span class="math">V=1</span>) uniformly at random (without replacement).</p>

    <p class="text-gray-300">We first analyze and bound <span class="math">\\mathbb{E}[\\Delta_{1}\\mid\\Lambda(i,j^{<em>})]</span>. We observe that, for all <span class="math">i</span> and <span class="math">j^{</em>}</span> with <span class="math">\\Pr\\bigl{(}\\Lambda(i,j^{*})\\bigr{)}&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{1}\\mid\\Lambda(i,j^{<em>})]=\\sum_{\\ell=0}^{N}\\Pr\\bigl{(}X=\\ell\\mid\\Lambda(i,j^{</em>})\\bigr{)}\\cdot\\mathbb{E}[\\Delta_{1}\\mid\\Lambda(i,j^{*})\\wedge X=\\ell]\\,.</span></p>

    <p class="text-gray-300">Since, conditioned on <span class="math">\\Lambda(i,j^{*})\\wedge X=\\ell</span> for <span class="math">\\ell\\in\\{0,\\ldots,N\\}</span>, any size-<span class="math">\\ell</span> subset of elements with <span class="math">v=1</span> and index <span class="math">i</span> is equally likely to be sampled, it follows that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{1}\\mid\\Lambda(i,j^{<em>})\\wedge X=\\ell]=\\mathbb{E}[\\Gamma(J)\\mid V=1\\wedge\\Lambda(i,j^{</em>})]\\cdot\\ell\\,.</span></p>

    <p class="text-gray-300">Hence,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{1}\\mid\\Lambda(i,j^{<em>})]</span> <span class="math">=\\mathbb{E}[\\Gamma(J)\\mid V=1\\wedge\\Lambda(i,j^{</em>})]\\cdot\\sum_{\\ell}\\Pr\\big{(}X=\\ell\\mid\\Lambda(i,j^{<em>})\\big{)}\\cdot\\ell</span> <span class="math">=\\mathbb{E}[\\Gamma(J)\\mid V=1\\wedge\\Lambda(i,j^{</em>})]\\cdot\\mathbb{E}[X\\mid\\Lambda(i,j^{*})]\\,.</span></p>

    <p class="text-gray-300">Similarly,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{2}\\mid\\Lambda(i,j^{<em>})]=\\mathbb{E}[\\Gamma(J)\\mid V=0\\wedge\\Lambda(i,j^{</em>})]\\cdot\\mathbb{E}[Y\\mid\\Lambda(i,j^{*})]\\,.</span></p>

    <p class="text-gray-300">Next, we bound the expected values of <span class="math">X</span> and <span class="math">Y</span> conditioned on <span class="math">\\Lambda(i,j^{<em>})</span>. The analysis is a more fine-grained version of the proof of Lemma 2. Bounding <span class="math">\\mathbb{E}[X\\mid\\Lambda(i,j^{</em>})]</span> is quite easy: since <span class="math">V=0</span> implies <span class="math">X=0</span> and <span class="math">V=1</span> implies <span class="math">X\\leq k</span>, it immediately follows that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[X\\mid\\Lambda(i,j^{<em>})]</span> <span class="math">=\\Pr(V=0\\mid\\Lambda(i,j^{</em>}))\\cdot\\mathbb{E}[X\\mid V=0\\wedge\\Lambda(i,j^{<em>})]</span> <span class="math">\\quad\\quad\\quad\\quad\\quad\\quad+\\Pr(V=1\\mid\\Lambda(i,j^{</em>}))\\cdot\\mathbb{E}[X\\mid V=1\\wedge\\Lambda(i,j^{<em>})]</span> <span class="math">\\leq\\Pr(V=1\\mid\\Lambda(i,j^{</em>}))\\cdot k\\,.</span></p>

    <p class="text-gray-300">Hence,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{1}\\mid\\Lambda(i,j^{<em>})]\\leq k\\cdot\\Pr(V=1\\mid\\Lambda(i,j^{</em>}))\\cdot\\mathbb{E}[\\Gamma(J)\\mid V=1\\wedge\\Lambda(i,j^{*})]\\,.</span> (7)</p>

    <p class="text-gray-300">Suitably bounding the expectation <span class="math">\\mathbb{E}[Y\\mid\\Lambda(i,j^{<em>})]</span>, and thus <span class="math">\\mathbb{E}[\\Delta_{2}\\mid\\Lambda(i,j^{</em>})]</span>, is more involved. For that purpose, we introduce the following parameters. For the considered fixed choice of the index <span class="math">1\\leq i\\leq U</span> and of <span class="math">j^{<em>}=(j_{1}^{</em>},\\ldots,j_{i-1}^{<em>},j_{i+1}^{</em>},\\cdots,j_{U}^{*})</span>, we let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$a:=a_{i}(j^{*})=\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\big{\\{}j:\\;(v_{j},i_{j})=M(j_{1}^{<em>},\\ldots,j_{i-1}^{</em>},j,j_{i+1}^{<em>},\\ldots,j_{U}^{</em>})=(1,i)\\,\\big{\\}}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\quad\\text{and}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let us first note that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{(}V=1\\mid\\Lambda(i,j^{<em>})\\big{)}=\\frac{a}{a+b}\\quad\\text{and}\\quad\\Pr\\big{(}V=0\\mid\\Lambda(i,j^{</em>})\\big{)}=\\frac{b}{a+b}</span></p>

    <p class="text-gray-300">for all <span class="math">i</span> and <span class="math">j^{<em>}</span> with <span class="math">\\Pr\\big{(}\\Lambda(i,j^{</em>})\\big{)}&gt;0</span>. Therefore, if we condition on the event <span class="math">V=1\\wedge\\Lambda(i,j^{<em>})</span> we implicitly assume that <span class="math">i</span> and <span class="math">j^{</em>}</span> are so that <span class="math">a</span> is positive. Now, towards bounding <span class="math">\\mathbb{E}[Y\\mid\\Lambda(i,j^{<em>})]</span>, we observe that conditioned on the event <span class="math">V=1\\wedge\\Lambda(i,j^{</em>})</span>, the random variable <span class="math">Y</span> follows a negative hypergeometric distribution with parameters <span class="math">a+b-1</span>, <span class="math">a-1</span> and <span class="math">k-1</span> (see also Remark 5). Hence, by Lemma 1,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[Y\\mid V=1\\wedge\\Lambda(i,j^{*})]\\leq(k-1)\\frac{b}{a}\\,,</span></p>

    <p class="text-gray-300">and thus</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[Y\\mid\\Lambda(i,j^{<em>})]</span> <span class="math">=\\Pr(V=0\\mid\\Lambda(i,j^{</em>}))\\cdot\\mathbb{E}[Y\\mid V=0\\wedge\\Lambda(i,j^{<em>})]</span> <span class="math">\\quad\\quad\\quad\\quad\\quad\\quad+\\Pr(V=1\\mid\\Lambda(i,j^{</em>}))\\cdot\\mathbb{E}[Y\\mid V=1\\wedge\\Lambda(i,j^{<em>})]</span> <span class="math">\\leq\\Pr\\big{(}V=0\\mid\\Lambda(i,j^{</em>})\\big{)}+\\Pr\\big{(}V=1\\mid\\Lambda(i,j^{<em>})\\big{)}\\cdot(k-1)\\frac{b}{a}</span> <span class="math">=\\frac{b}{a+b}+\\frac{a}{a+b}\\cdot(k-1)\\frac{b}{a}=k\\frac{b}{a+b}</span> <span class="math">=k\\cdot\\Pr(V=0\\mid\\Lambda(i,j^{</em>}))\\,,</span></p>

    <p class="text-gray-300">w</p>

    <p class="text-gray-300">where we use that <span class="math">\\mathbb{E}[Y\\mid V=0\\wedge\\Lambda(i,j^{*})]=1</span>. Hence,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{2}\\mid\\Lambda(i,j^{<em>})]\\leq k\\cdot\\Pr(V=0\\mid\\Lambda(i,j^{</em>}))\\cdot\\mathbb{E}[\\Gamma(J)\\mid V=0\\wedge\\Lambda(i,j^{*})]\\,,</span></p>

    <p class="text-gray-300">and thus, combined with Equation 7,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{1}+\\Delta_{2}\\mid\\Lambda(i,j^{<em>})]\\leq k\\cdot\\mathbb{E}[\\Gamma(J)\\mid\\Lambda(i,j^{</em>})]\\,.</span></p>

    <p class="text-gray-300">Since this inequality holds for all <span class="math">i</span> and <span class="math">j^{<em>}</span> with <span class="math">\\Pr\\big{(}\\Lambda(i,j^{</em>})\\big{)}&gt;0</span>, it follows that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta_{1}+\\Delta_{2}]\\leq k\\cdot\\mathbb{E}[\\Gamma(J)]\\,.</span></p>

    <p class="text-gray-300">What remains is to show that <span class="math">\\mathbb{E}[Z]\\leq(k-1)T</span>, and thus <span class="math">\\mathbb{E}[\\Delta_{3}]=\\gamma\\,\\mathbb{E}[Z]\\leq(k-1)T\\gamma</span>. The slightly weaker bound <span class="math">\\mathbb{E}[Z]\\leq(k-1)P</span> follows immediately from observing that <span class="math">Z\\leq Y^{\\prime}</span> for <span class="math">Y^{\\prime}</span> as in the proof of Lemma 2 (the number of entries counted by <span class="math">Z</span> is a subset of those counted by <span class="math">Y^{\\prime}</span>), and using that <span class="math">\\mathbb{E}[Y^{\\prime}]\\leq\\mathbb{E}[X^{\\prime}+Y^{\\prime}]\\leq(k-1)P</span> as derived in the proof of Lemma 2. In order to get the slightly better bound in terms of <span class="math">T</span>, we bound <span class="math">\\mathbb{E}[Z]</span> from scratch below. We use a similar approach as above for bounding the expectation of <span class="math">Y</span>. Thus, we consider a fixed choice of <span class="math">i</span> and <span class="math">j^{<em>}</span> and set <span class="math">a:=a_{i}(j^{</em>})</span> and <span class="math">b:=b_{i}(j^{<em>})</span>. Then, conditioned on <span class="math">V=1\\wedge\\Lambda(i,j^{</em>})</span>, also <span class="math">Z</span> follows a negative hypergeometric distribution, but now with parameters <span class="math">N-b-1</span>, <span class="math">a-1</span> and <span class="math">k-1</span>. Therefore, for all <span class="math">i</span> and <span class="math">j^{<em>}</span> with <span class="math">\\Pr\\big{(}V=1\\wedge\\Lambda(i,j^{</em>})\\big{)}&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[Z\\mid V=1\\wedge\\Lambda(i,j^{*})]\\leq(k-1)\\frac{N-a-b}{a}\\,.</span></p>

    <p class="text-gray-300">Using that <span class="math">\\mathbb{E}[Z\\mid V=0\\wedge\\Lambda(i,j^{<em>})]=0</span>, but also recalling that <span class="math">\\Pr\\big{(}V=1\\mid\\Lambda(i,j^{</em>})\\big{)}=a/(a+b)</span> and exploiting <span class="math">\\Pr(I=i\\mid J_{i}^{<em>}=j^{</em>})=(a+b)/N</span>, it follows that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[Z\\mid\\Lambda(i,j^{<em>})]</span> <span class="math">=\\Pr\\big{(}V=1\\mid\\Lambda(i,j^{</em>})\\big{)}\\cdot\\mathbb{E}[Z\\mid V=1\\wedge\\Lambda(i,j^{<em>})]</span> <span class="math">\\leq\\frac{a}{a+b}\\cdot(k-1)\\cdot\\frac{N-a-b}{a}=(k-1)\\cdot\\frac{N-a-b}{a+b}</span> <span class="math">=(k-1)\\cdot\\Big{(}\\frac{1}{\\Pr(I=i\\mid J_{i}^{</em>}=j^{<em>})}-1\\Big{)}</span> <span class="math">=(k-1)\\cdot\\frac{\\Pr(J_{i}^{</em>}=j^{<em>})-\\Pr(I=i\\wedge J_{i}^{</em>}=j^{<em>})}{\\Pr(\\Lambda(i,j^{</em>}))}</span> <span class="math">=(k-1)\\cdot\\frac{\\Pr(I\\neq i\\wedge J_{i}^{<em>}=j^{</em>})}{\\Pr(\\Lambda(i,j^{*}))}\\,.</span></p>

    <p class="text-gray-300">We recall that the above holds for all <span class="math">i</span> and <span class="math">j^{<em>}</span> for which <span class="math">a=a_{i}(j^{</em>})&gt;0</span>, so that <span class="math">\\Pr(V=1\\wedge\\Lambda(i,j^{<em>}))&gt;0</span>. For <span class="math">i</span> and <span class="math">j^{</em>}</span> with <span class="math">a=a_{i}(j^{<em>})=0</span>, it holds that <span class="math">\\Lambda(i,j^{</em>})</span> implies <span class="math">V=0</span>, and thus <span class="math">\\mathbb{E}[Z\\mid\\Lambda(i,j^{*})]=0</span>. Therefore</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[Z]</span> <span class="math">=\\sum_{i=1}^{U}\\sum_{\\genfrac{}{}{0.0pt}{}{j^{<em>}\\text{ s.t.}}{a_{i}(j^{</em>})&gt;0}}\\Pr[\\Lambda(i,j^{<em>})]\\cdot\\mathbb{E}[Z\\mid\\Lambda(i,j^{</em>})]</span> <span class="math">=(k-1)\\cdot\\sum_{i=1}^{U}\\sum_{\\genfrac{}{}{0.0pt}{}{j^{<em>}\\text{ s.t.}}{a_{i}(j^{</em>})&gt;0}}\\Pr(I\\neq i\\wedge J_{i}^{<em>}=j^{</em>})</span> <span class="math">\\leq(k-1)\\cdot\\sum_{i=1}^{U}\\Pr(I\\neq i\\wedge A_{i}&gt;0)=(k-1)\\cdot T\\,.</span></p>

    <p class="text-gray-300">Hence <span class="math">\\mathbb{E}[\\Delta_{3}]\\leq(k-1)\\cdot T\\cdot\\gamma</span>, as intended, and altogether it follows that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[\\Delta]=\\mathbb{E}[\\Delta_{1}+\\Delta_{2}+\\Delta_{3}]\\leq k\\cdot\\mathbb{E}[\\Gamma(J)]+(k-1)\\cdot T\\cdot\\gamma\\,,</span></p>

    <p class="text-gray-300">which completes the proof of the lemma. ∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Consider the game in Figure 2. Let <span class="math">v</span> and <span class="math">idx</span> be functions such that <span class="math">M(j)=\\big{(}v(j),idx(j)\\big{)}</span> for all <span class="math">j\\in\\{1,\\ldots,N\\}^{U}</span>. Furthermore, let <span class="math">J=(J_{1},\\ldots,J_{U})</span> be uniformly distributed in <span class="math">\\{1,\\ldots,N\\}^{U}</span> and set <span class="math">A_{i}=a_{i}(J)</span> for all <span class="math">1\\leq i\\leq U</span> as in Equation 5. Let us additionally assume that for all <span class="math">j\\in\\{1,\\ldots,N\\}^{U}</span> there exists a subset <span class="math">S(j)\\subseteq\\{1,\\ldots,U\\}</span> of cardinality at most <span class="math">Q</span> such that <span class="math">idx(j)=idx(j^{\\prime})</span> for all <span class="math">j,j^{\\prime}</span> with <span class="math">j_{\\ell}=j^{\\prime}_{\\ell}</span> for all <span class="math">\\ell\\in S(j)</span>. Then</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{i=1}^{U}\\Pr\\big{(}idx(J)\\neq i\\wedge A_{i}&gt;0\\big{)}\\leq Q\\,.</span></p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is analogous to the proof of Lemma 3. By basic probability theory, it follows that</p>

    <p class="text-gray-300"><span class="math">T</span> <span class="math">=\\sum_{i=1}^{U}\\Pr\\big{(}idx(J)\\neq i\\wedge A_{i}&gt;0\\big{)}</span> <span class="math">=\\sum_{j}\\Pr(J=j)\\bigg{(}\\sum_{i\\in S(j)}\\Pr\\big{(}idx(J)\\neq i\\wedge A_{i}&gt;0\\mid J=j\\big{)}+\\sum_{i\\notin S(j)}\\Pr\\big{(}idx(J)\\neq i\\wedge A_{i}&gt;0\\mid J=j\\big{)}\\bigg{)}</span> <span class="math">\\leq Q+\\sum_{j}\\Pr(J=j)\\sum_{i\\notin S(j)}\\Pr\\big{(}idx(J)\\neq i\\wedge A_{i}&gt;0\\mid J=j\\big{)}\\,,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the inequality follows from the fact that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(j)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Q<span class="math"> for all </span>j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now note that, by definition of the sets <span class="math">S(j)</span>, for all <span class="math">j\\in\\{1,\\ldots,N\\}^{U}</span>, <span class="math">i\\notin S(j)</span> and <span class="math">j_{i}\\in\\{1,\\ldots,N\\}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{(}idx(J_{1},\\ldots,J_{i-1},j_{i},J_{i+1},\\ldots,J_{U})=idx(j)\\mid J=j\\big{)}=1\\,.</span></p>

    <p class="text-gray-300">Therefore, for all <span class="math">i\\notin S(j)\\cup\\{idx(j)\\}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr(A_{i}&gt;0\\mid J=j)=0\\,.</span></p>

    <p class="text-gray-300">Hence,</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\notin S(j)}\\Pr\\big{(}idx(J)\\neq i\\wedge A_{i}&gt;0\\mid J=j\\big{)}\\leq\\Pr\\big{(}idx(J)\\neq idx(j)\\wedge A_{idx(j)}&gt;0\\mid J=j\\big{)}=0.</span></p>

    <p class="text-gray-300">Altogether, it follows that</p>

    <p class="text-gray-300"><span class="math">T\\leq Q+\\sum_{j}\\Pr(J=j)\\sum_{i\\notin S(j)}\\Pr\\big{(}idx(J)\\neq i\\wedge A_{i}&gt;0\\mid J=j\\big{)}=Q\\,,</span></p>

    <p class="text-gray-300">which completes the proof. ∎</p>

    <h2 id="sec-42" class="text-2xl font-bold">6 Fiat-Shamir Transformation of Multi-Round Protocols</h2>

    <p class="text-gray-300">Let us now move to multi-round interactive proofs. More precisely, we consider the Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\varPi]</span> of a <span class="math">\\mathbf{k}</span>-special-sound <span class="math">(2\\mu+1)</span>-move interactive proof <span class="math">\\varPi</span>, with <span class="math">\\mathbf{k}=(k_{1},\\ldots,k_{\\mu})</span>. While the multi-round extractor has a natural recursive construction, it requires a more fine-grained analysis to show that it indeed implies knowledge soundness.</p>

    <p class="text-gray-300">To avoid a cumbersome notation, in Section 6.1 we first handle <span class="math">(2\\mu+1)</span>-move interactive proofs in which the verifier samples all <span class="math">\\mu</span> challenges uniformly at random from the <em>same</em> set <span class="math">\\mathcal{C}</span>. Subsequently, in Section 6.2, we argue that our techniques have a straightforward generalization to interactive proofs where the verifier samples its challenges from different challenge sets. In Section 6.3, we show that our results extend to <em>adaptive</em> security in a straightforward way.</p>

    <p class="text-gray-300">6.1 Multi-Round Protocols with a Single Challenge Set</p>

    <p class="text-gray-300">Consider a deterministic dishonest <span class="math">Q</span>-query random-oracle prover <span class="math">\\mathcal{P}^{<em>}</span>, attacking the Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\varPi]</span> of a <span class="math">\\mathbf{k}</span>-special-sound interactive proof <span class="math">\\varPi</span> on input <span class="math">x</span>. We assume all challenges to be elements in the same set <span class="math">\\mathcal{C}</span>. After making at most <span class="math">Q</span> queries to the random oracle, <span class="math">\\mathcal{P}^{</em>}</span> outputs a proof <span class="math">\\pi=(a_{1},\\ldots,a_{\\mu+1})</span>. We re-format the output and consider</p>

    <p class="text-gray-300"><span class="math">I_{1}:=a_{1}\\,,\\&gt;I_{2}:=(a_{1},a_{2})\\,,\\ldots,\\&gt;I_{\\mu}:=(a_{1},\\ldots,a_{\\mu})\\quad\\text{and}\\quad\\pi</span></p>

    <p class="text-gray-300">as <span class="math">\\mathcal{P}^{<em>}</span>’s output. Sometimes it will be convenient to also consider <span class="math">I_{\\mu+1}:=(a_{1},\\ldots,a_{\\mu+1})</span>. Furthermore, we extend <span class="math">\\mathcal{P}^{</em>}</span> to a random-oracle algorithm <span class="math">\\mathcal{A}</span> that additionally checks the correctness of the proof <span class="math">\\pi</span>. Formally, relaying all the random oracle queries that <span class="math">\\mathcal{P}^{<em>}</span> is making, <span class="math">\\mathcal{A}</span> runs <span class="math">\\mathcal{P}^{</em>}</span> to obtain <span class="math">\\mathbf{I}=(I_{1},\\ldots,I_{\\mu})</span> and <span class="math">\\pi</span>, additionally queries the random oracle to obtain <span class="math">c_{1}:=\\mathsf{RO}(I_{1}),\\ldots,c_{\\mu}:=\\mathsf{RO}(I_{\\mu})</span>, and then outputs</p>

    <p class="text-gray-300"><span class="math">\\mathbf{I}\\,,\\quad y:=(a_{1},c_{1},\\ldots,a_{\\mu},c_{\\mu},a_{\\mu+1})\\qquad\\text{and}\\qquad v:=V(x,y)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">V(x,y)=1</span> if <span class="math">y</span> is an accepting transcript for the interactive proof <span class="math">\\varPi</span> on input <span class="math">x</span> and <span class="math">V(x,y)=0</span> otherwise. Hence, <span class="math">\\mathcal{A}</span> makes at most <span class="math">Q+\\mu</span> queries (the queries done by <span class="math">\\mathcal{P}^{*}</span>, and the queries to <span class="math">I_{1},\\ldots,I_{\\mu}</span>). Moreover, <span class="math">\\mathcal{A}</span> has a naturally defined success probability</p>

    <p class="text-gray-300"><span class="math">\\epsilon(\\mathcal{A}):=\\Pr\\bigl{(}v=1:(I,y,v)\\leftarrow\\mathcal{A}^{\\mathsf{RO}}\\bigr{)}\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{RO}\\colon\\{0,1\\}^{\\leq u}\\to\\mathcal{C}</span> is distributed uniformly. As before, <span class="math">\\epsilon(\\mathcal{A})=\\epsilon(\\mathcal{P}^{*},x)</span>.</p>

    <p class="text-gray-300">Our goal is now to construct an extraction algorithm that, when given black-box access to <span class="math">\\mathcal{A}</span>, and thus to <span class="math">\\mathcal{P}^{*}</span>, aims to output a <span class="math">\\mathbf{k}</span>-tree of accepting transcripts (Definition 6). By the <span class="math">\\mathbf{k}</span>-special-soundness property of <span class="math">\\varPi</span>, a witness for statement <span class="math">x</span> can then be computed efficiently from these transcripts.</p>

    <p class="text-gray-300">To this end, we recursively introduce a sequence of “subextractors” <span class="math">\\mathcal{E}_{1},\\ldots,\\mathcal{E}_{\\mu}</span>, where <span class="math">\\mathcal{E}_{m}</span> aims to find a <span class="math">(1,\\ldots,1,k_{m},\\ldots,k_{\\mu})</span>-tree of accepting transcripts. The main idea behind this recursion is that such a <span class="math">(1,\\ldots,1,k_{m},\\ldots,k_{\\mu})</span>-tree of accepting transcripts is the composition of <span class="math">k_{m}</span> appropriate <span class="math">(1,\\ldots,1,k_{m+1},\\ldots,k_{\\mu})</span>-trees.</p>

    <p class="text-gray-300">For technical reasons, we define the subextractors <span class="math">\\mathcal{E}_{m}</span> as <em>random-oracle</em> algorithms, each one making <span class="math">Q+\\mu</span> queries to a random oracle. As we will see, the recursive definition of <span class="math">\\mathcal{E}_{m}</span> is very much like the extractor from the 3-move case, but with <span class="math">\\mathcal{A}</span> replaced by the subextractor <span class="math">\\mathcal{E}_{m+1}</span>; however, for this to work we need the subextractor to be the same kind of object as <span class="math">\\mathcal{A}</span>, thus a random-oracle algorithm making the same number of queries. As base for the recursion, we consider the algorithm <span class="math">\\mathcal{A}</span> (which outputs a single transcript, i.e., a <span class="math">(1,\\ldots,1)</span>-tree); thus, the subextractor <span class="math">\\mathcal{E}_{\\mu}</span> (which outputs a <span class="math">(1,\\ldots,1,k_{\\mu})</span>-tree) is essentially the extractor of the 3-move case, but with <span class="math">\\mathcal{A}</span> now outputting an index <em>vector</em> <span class="math">\\mathbf{I}=(I_{1},\\ldots,I_{\\mu})</span>, and with <span class="math">\\mathcal{E}_{\\mu}</span> being a <em>random-oracle</em> algorithm, so that we can recursively replace the random-oracle algorithm <span class="math">\\mathcal{A}</span> by <span class="math">\\mathcal{E}_{\\mu}</span> to obtain <span class="math">\\mathcal{E}_{\\mu-1}</span>, etc.</p>

    <p class="text-gray-300">Formally, the recursive definition of <span class="math">\\mathcal{E}_{m}</span> from <span class="math">\\mathcal{E}_{m+1}</span> is given in Figure 4, where <span class="math">\\mathcal{E}_{\\mu+1}</span> (the base case) is set to <span class="math">\\mathcal{E}_{\\mu+1}:=\\mathcal{A}</span>, and where <span class="math">\\mathcal{E}_{m}</span> exploits the following <em>early abort</em> feature of <span class="math">\\mathcal{E}_{m+1}</span>: like <span class="math">\\mathcal{A}</span>, the subextractor <span class="math">\\mathcal{E}_{m+1}</span> computes the index vector it eventually outputs by running <span class="math">\\mathcal{P}^{<em>}</span> </em>as its first step<em> (see Lemma 7 below). This allows the executions of <span class="math">\\mathcal{E}_{m+1}</span> in the repeat loop in Fig. 4 to abort after a single run of <span class="math">\\mathcal{P}^{</em>}</span> if the requirement <span class="math">I_{m}^{\\prime}=I_{m}</span> on its index vector <span class="math">\\mathbf{I}</span> is not satisfied, without proceeding to produce the remaining parts <span class="math">y^{\\prime},v^{\\prime}</span> of the output (which would invoke more calls to <span class="math">\\mathcal{P}^{*}</span>).</p>

    <p class="text-gray-300">The actual extractor <span class="math">\\mathcal{E}</span> is then given by a run of <span class="math">\\mathcal{E}_{1}</span>, with the <span class="math">Q+\\mu</span> random-oracle queries made by <span class="math">\\mathcal{E}_{1}</span> being answered using lazy-sampling.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 6.</h6>

    <p class="text-gray-300">Let us emphasize that within <em>one</em> run of <span class="math">\\mathcal{E}_{m}</span>, except for the query to <span class="math">i</span> for which the response is “reprogrammed”, all the queries made by the multiple runs of the subextractor <span class="math">\\mathcal{E}_{m+1}</span> in the repeat loop are answered <em>consistently</em>, both with the run of <span class="math">\\mathcal{E}_{m+1}</span> in the first step and among the runs in the repeat loop. This means, a query to a value <span class="math">\\xi</span> that has been answered by <span class="math">\\eta</span> in a previous run on <span class="math">\\mathcal{E}_{m+1}</span> (within the considered run of <span class="math">\\mathcal{E}_{m}</span>) is again answered by <span class="math">\\eta</span>, and a query to a value <span class="math">\\xi^{\\prime}</span> that has not been queried yet in a</p>

    <p class="text-gray-300">Fig. 4. Subextractor  <span class="math">\\mathcal{E}_m</span> , as a  <span class="math">(Q + \\mu)</span> -query random-oracle algorithm.</p>

    <p class="text-gray-300">Parameters:  <span class="math">k_{m},Q\\in \\mathbb{N}</span></p>

    <p class="text-gray-300">Black-box access to:  <span class="math">\\mathcal{E}_{m + 1}</span></p>

    <p class="text-gray-300">Random oracle queries:  <span class="math">Q + \\mu</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">\\mathcal{E}_{m+1}</span>  as follows to obtain  <span class="math">(\\mathbf{I}, y_1, v)</span> : relay the  <span class="math">Q + \\mu</span>  queries to the random oracle and record all query-response pairs. Set  <span class="math">i := I_m</span> , and let  <span class="math">c_i</span>  be the response to query  <span class="math">i</span> .</li>

      <li>If  <span class="math">v = 0</span> , abort with output  <span class="math">v = 0</span> .</li>

      <li>Else, repeat</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sample  <span class="math">c_i&#x27; \\in \\mathcal{C} \\setminus \\{c_i\\}</span>  (without replacement);</li>

      <li>run  <span class="math">\\mathcal{E}_{m+1}</span>  as follows to obtain  <span class="math">(\\mathbf{I}&#x27;, y&#x27;, v&#x27;)</span> , aborting right after the initial run of  <span class="math">\\mathcal{P}^*</span>  if  <span class="math">I_m&#x27; \\neq I_m</span> : answer the query to  <span class="math">i</span>  with  <span class="math">c_i&#x27;</span> , while answering all other queries consistently if the query was performed by  <span class="math">\\mathcal{E}_{m+1}</span>  already on a previous run and with a fresh random value in  <span class="math">\\mathcal{C}</span>  otherwise;</li>

    </ul>

    <p class="text-gray-300">until either  <span class="math">k_{m} - 1</span>  additional challenges  <span class="math">c_{i}^{\\prime}</span>  with  <span class="math">v^{\\prime} = 1</span>  and  <span class="math">I_m^\\prime = I_m</span>  have been found or until all challenges  <span class="math">c_{i}^{\\prime}\\in \\mathcal{C}</span>  have been tried.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the former case, output  <span class="math">\\mathbf{I}</span> , the  <span class="math">k_{m}</span>  accepting  <span class="math">(1,\\dots ,1,k_{m + 1},\\dots ,k_{\\mu})</span> -trees  <span class="math">y_{1},\\ldots ,y_{k_{m}}</span> , and  <span class="math">v\\coloneqq 1</span> ; in the latter case, output  <span class="math">v\\coloneqq 0</span> .</li>

    </ul>

    <p class="text-gray-300">previous run on  <span class="math">\\mathcal{E}_{m + 1}</span>  (within the considered run of  <span class="math">\\mathcal{E}_m</span> ) is answered with a freshly chosen uniformly random  <span class="math">\\eta&#x27; \\in \\mathcal{C}</span> . In multiple runs of  <span class="math">\\mathcal{E}_m</span> , very naturally the random tape of  <span class="math">\\mathcal{E}_m</span>  will be refreshed, and thus there is no guaranteed consistency among the answers to the query calls of  <span class="math">\\mathcal{E}_{m + 1}</span>  across multiple runs of  <span class="math">\\mathcal{E}_m</span> .</p>

    <p class="text-gray-300">The following lemma captures some technical property of the subextractors  <span class="math">\\mathcal{E}_m</span> . Subsequently, Proposition 1 shows that  <span class="math">\\mathcal{E}_m</span> , if successful, indeed outputs a  <span class="math">(1,\\ldots ,1,k_m\\ldots ,k_\\mu)</span> -tree of accepting transcripts. Proposition 2 bounds the success probability and expected run time of  <span class="math">\\mathcal{E}_m</span> . All statements are understood to hold for any statement  <span class="math">x</span>  and any  <span class="math">m\\in \\{1,\\dots ,\\mu +1\\}</span> .</p>

    <p class="text-gray-300">Lemma 7 (Consistency of  <span class="math">\\mathcal{P}^<em></span>  and  <span class="math">\\mathcal{E}_m</span> ).  <span class="math">\\mathcal{E}_m</span>  obtains the index vector  <span class="math">\\mathbf{I}</span> , which it eventually outputs, by running  <span class="math">(\\mathbf{I},\\pi)\\gets \\mathcal{P}^</em></span>  as its first step. In particular, for any fixed choice of the random oracle  <span class="math">\\mathsf{RO}</span> , the index vector  <span class="math">\\mathbf{I}</span>  output by  <span class="math">\\mathcal{E}_m^{\\mathsf{RO}}</span>  matches the one output by  <span class="math">\\mathcal{P}^{*,\\mathsf{RO}}</span> .</p>

    <p class="text-gray-300">Proof. The first claim holds for  <span class="math">\\mathcal{E}_{\\mu +1} = \\mathcal{A}</span>  by definition of  <span class="math">\\mathcal{A}</span> , and it holds for  <span class="math">\\mathcal{E}_m</span>  with  <span class="math">m\\leq \\mu</span>  by induction, given that  <span class="math">\\mathcal{E}_m</span>  runs  <span class="math">\\mathcal{E}_{m + 1}</span>  as a first step. The claim on the matching index vectors then follows trivially.</p>

    <p class="text-gray-300">Proposition 1 (Correctness). For any fixed choice of the random oracle let  <span class="math">(\\mathbf{I},y_1,\\ldots ,y_{k_m},v)\\gets \\mathcal{E}_m^{\\mathrm{RO}}(x)</span> . If  <span class="math">v = 1</span>  then  <span class="math">(y_{1},\\dots ,y_{k_{m}})</span>  forms a  <span class="math">(1,\\dots ,1,k_{m},\\dots ,k_{\\mu})</span> -tree of accepting transcripts.</p>

    <p class="text-gray-300">Proof. All  <span class="math">k_{m+1} \\cdots k_{\\mu}</span>  transcripts in a  <span class="math">(1, \\ldots, 1, k_{m+1}, \\ldots, k_{\\mu})</span> -tree contain the same partial transcript  <span class="math">(a_1, c_1, \\ldots, c_m, a_{m+1})</span> , i.e., the first  <span class="math">2m-1</span>  messages in all these transcripts coincide. Hence, any  <span class="math">(1, \\ldots, 1, k_{m+1}, \\ldots, k_{\\mu})</span> -tree of transcripts has a well-defined trunk  <span class="math">(a_1, c_1, \\ldots, c_m, a_{m+1})</span> .</p>

    <p class="text-gray-300">By induction on  <span class="math">m</span> , we will prove that if  <span class="math">v = 1</span>  then  <span class="math">(y_{1},\\ldots ,y_{k_{m}})</span>  forms a  <span class="math">(1,\\dots ,1,k_{m},\\dots ,k_{\\mu})</span> -tree of accepting transcripts with trunk  <span class="math">(a_{1},\\mathsf{RO}(I_{1}),\\ldots ,\\mathsf{RO}(I_{m - 1}),a_{m})</span> , where  <span class="math">I_{m + 1} = (a_1,\\dots ,a_{m + 1})</span> . This obviously implies the correctness claim.</p>

    <p class="text-gray-300">For the base case  <span class="math">m = \\mu + 1</span> , recall that  <span class="math">\\mathcal{E}_{\\mu + 1} = \\mathcal{A}</span> , and that by definition of  <span class="math">\\mathcal{A}</span>  and its output  <span class="math">(\\mathbf{I}, y, v)</span> , if  <span class="math">v = 1</span>  then  <span class="math">y</span>  is an accepting transcript, and thus a  <span class="math">(1, \\ldots, 1)</span> -tree of accepting transcripts with  <span class="math">(a_1, \\mathsf{RO}(I_1), \\ldots, \\mathsf{RO}(I_\\mu), a_{\\mu + 1})</span>  as trunk where  <span class="math">I_{\\mu + 1} = (a_1, \\ldots, a_{\\mu + 1})</span> , by definition of  <span class="math">\\mathbf{I} = (I_1, \\ldots, I_\\mu)</span> .</p>

    <p class="text-gray-300">For the induction step, by the induction hypothesis on  <span class="math">\\mathcal{E}_{m+1}</span>  and its output  <span class="math">(\\mathbf{I}, y, v)</span> , if  <span class="math">v = 1</span>  then  <span class="math">y</span>  is a  <span class="math">(1, \\ldots, 1, k_{m+1}, \\ldots, k_{\\mu})</span> -tree of accepting transcripts with trunk  <span class="math">(a_1, \\mathsf{RO}(I_1), \\ldots, a_m, \\mathsf{RO}(I_m), a_{m+1})</span> , where  <span class="math">I_{m+1} = (a_1, \\ldots, a_{m+1})</span> . This holds for  <span class="math">(\\mathbf{I}, y_1, v)</span>  output by  <span class="math">\\mathcal{E}_{m+1}</span>  in the first step of  <span class="math">\\mathcal{E}_m</span> , but also for any invocation of  <span class="math">\\mathcal{E}_{m+1}</span>  in the repeat loop with output  <span class="math">(\\mathbf{I}&#x27;, y&#x27;, v&#x27;)</span> , here with trunk  <span class="math">(a_1&#x27;, \\mathsf{RO}&#x27;(I_1&#x27;), \\ldots, a_m&#x27;, \\mathsf{RO}&#x27;(I_m&#x27;), a_{m+1}&#x27;)</span> , where  <span class="math">I_{m+1}&#x27; = (a_1&#x27;, \\ldots, a_{m+1}&#x27;)</span>  and  <span class="math">\\mathsf{RO}&#x27;</span>  is such that  <span class="math">\\mathsf{RO}&#x27;(I_j) = \\mathsf{RO}(I_j)</span>  for all  <span class="math">j \\neq m</span> , while  <span class="math">\\mathsf{RO}(I_m) = c_i</span>  and  <span class="math">\\mathsf{RO}&#x27;(I_m) = c_i&#x27;</span> . By definition of the output of  <span class="math">\\mathcal{E}_m</span> , for  <span class="math">y_1</span>  and  <span class="math">y&#x27;</span>  occurring in the output of  <span class="math">\\mathcal{E}_m</span> , it is ensured that  <span class="math">I_m = I_m&#x27;</span> .</p>

    <p class="text-gray-300">Now note that, by Lemma 7, for the purpose of the argument, <span class="math">\\mathcal{E}_{m}</span> could have run <span class="math">\\mathcal{P}^{<em>}</span> instead of <span class="math">\\mathcal{E}_{m+1}</span> to obtain <span class="math">\\mathbf{I}</span> and <span class="math">\\mathbf{I}^{\\prime}</span>. Therefore, by definition of the index vectors outputted by <span class="math">\\mathcal{P}^{</em>}</span>, which is such that <span class="math">I_{j}</span> is a (fixed-size) prefix of <span class="math">I_{m}</span> for <span class="math">j&lt;m</span>, it follows that also <span class="math">I_{j}=I_{j}^{\\prime}</span> for all <span class="math">j&lt;m</span>.</p>

    <p class="text-gray-300">Therefore, the output <span class="math">y_{1},\\ldots,y_{k_{m}}</span> of <span class="math">\\mathcal{E}_{m}</span> forms a <span class="math">(1,\\ldots,1,k_{m},\\ldots,k_{\\mu})</span>-tree of accepting transcripts with trunk <span class="math">(a_{1},\\mathsf{RO}(I_{1}),\\ldots,a_{m-1},\\mathsf{RO}(I_{m-1}),a_{m})</span>, where <span class="math">I_{m}=(a_{1},\\ldots,a_{m})</span>. This completes the proof. ∎</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proposition 2 (Run Time and Success Probability).</h6>

    <p class="text-gray-300">Let <span class="math">K_{m}=k_{m}\\cdots k_{\\mu}</span>. The extractor <span class="math">\\mathcal{E}_{m}</span> makes an expected number of at most <span class="math">K_{m}+Q\\cdot(K_{m}-1)</span> queries to <span class="math">\\mathcal{A}</span> (and thus to <span class="math">\\mathcal{P}^{*}</span>) and successfully outputs <span class="math">v=1</span> with probability at least</p>

    <p class="text-gray-300"><span class="math">\\frac{\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\kappa_{m}}{1-\\kappa_{m}}</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa_{m}:=\\mathrm{Er}(k_{m},\\ldots,k_{\\mu};N)</span> is as defined in Equation 1.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof goes by induction on <span class="math">m</span>. The base case <span class="math">m=\\mu+1</span> holds trivially, understanding that <span class="math">K_{\\mu+1}=1</span> and <span class="math">\\mathrm{Er}(\\emptyset,N)=0</span>. Indeed, <span class="math">\\mathcal{E}_{\\mu+1}</span> makes <span class="math">1</span> call to <span class="math">\\mathcal{A}</span> and outputs <span class="math">v=1</span> with probability <span class="math">\\epsilon(\\mathcal{A})</span>. Alternatively, we can take <span class="math">m=\\mu</span> as base case, which follows immediately from Lemma 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the induction step, we assume now that the lemma is true for <span class="math">m^{\\prime}=m+1</span> and consider the extractor <span class="math">\\mathcal{E}_{m}</span>. As in the <span class="math">3</span>-move case, we observe that, within a run of <span class="math">\\mathcal{E}_{m}</span>, all the queries that are made by the different invocations of <span class="math">\\mathcal{E}_{m+1}</span> are answered consistently using lazy sampling, except for the queries to the index <span class="math">i</span>, which is answered with different responses <span class="math">c_{i}^{\\prime}</span>. This is indistinguishable from having them answered by a full-fledged random oracle <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>, where we recall that $U=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{0,1\\}^{\\leq u}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and therefore a full-fledged random oracle corresponds to a vector </span>\\mathbf{c}\\in\\mathcal{C}^{U}$ encoding its function table. Thus, the extractor is actually running the abstract sampling game from Figure 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, in contrast to the instantiation of Section 4, the entries of the array <span class="math">M</span> are now probabilistic. Namely, while <span class="math">\\mathcal{A}</span> is deterministic, the extractor <span class="math">\\mathcal{E}_{m+1}</span> is a probabilistic algorithm. Fortunately, this does not influence the key properties of the abstract sampling game. For the purpose of the analysis we may namely fix the randomness of the extractor <span class="math">\\mathcal{E}_{m+1}</span>. By linearity of the success probability and the expected run time, the bounds that hold for any fixed choice of randomness also hold when averaged over the randomness. Thus, we can apply Lemma 2 and Lemma 5 to bound the success probability and the expected run time.</p>

    <p class="text-gray-300">To control the parameters <span class="math">P</span> and <span class="math">T</span>, which occur in the bounds of these lemmas, we make the following observation. A similar observation was required in the proof of Lemma 4.</p>

    <p class="text-gray-300">First, by Lemma 7, the index vector <span class="math">\\mathbf{I}</span> outputted by <span class="math">\\mathcal{E}_{m+1}</span> matches the index vector outputted by <span class="math">\\mathcal{P}^{<em>}</span>, when given the same random oracle <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>. Second, since <span class="math">\\mathcal{P}^{</em>}</span> is deterministic, its output can only change when the random oracle is reprogrammed at one of the indices <span class="math">i\\in\\{0,1\\}^{\\leq u}</span> queried by <span class="math">\\mathcal{P}^{<em>}</span>. Therefore, for every random oracle <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>, there exists a subset <span class="math">S(\\mathbf{c})\\subset\\{0,1\\}^{\\leq u}</span> (indicating the queries made by <span class="math">\\mathcal{P}^{</em>}</span>) such that <span class="math">\\mathcal{P}^{*}</span>’s output stays the same when the random oracle is reprogrammed at an index <span class="math">i\\notin S(\\mathbf{c})</span>. In particular, <span class="math">I_{j}(\\mathbf{c})=I_{j}(\\mathbf{c}^{\\prime})</span> for all <span class="math">1\\leq j\\leq\\mu</span> and <span class="math">\\mathbf{c},\\mathbf{c}^{\\prime}\\in\\mathcal{C}^{U}</span> with <span class="math">c_{i}=c_{i}^{\\prime}</span> for all <span class="math">i\\in S(\\mathbf{c})</span>. Hence, the conditions of Lemma 3 and Lemma 6 are satisfied, and it follows that <span class="math">P\\leq Q+1</span> and <span class="math">T\\leq Q</span>. We are now ready to analyze the success probability and the expected number of <span class="math">\\mathcal{A}</span> queries of <span class="math">\\mathcal{E}_{m}</span>.</p>

    <p class="text-gray-300">Success Probability. By the induction hypothesis, the success probability <span class="math">p_{m+1}</span> of <span class="math">\\mathcal{E}_{m+1}</span> is bounded by</p>

    <p class="text-gray-300"><span class="math">p_{m+1}\\geq\\frac{\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\kappa_{m+1}}{1-\\kappa_{m+1}}\\,.</span></p>

    <p class="text-gray-300">Then, by Lemma 2 and Lemma 3, the success probability of <span class="math">\\mathcal{E}_{m}</span> is bounded by</p>

    <p class="text-gray-300"><span class="math">p_{m}\\geq\\frac{N}{N-k_{m}+1}\\left(p_{m+1}-(Q+1)\\frac{k_{m}-1}{N}\\right)\\geq\\frac{N}{N-k_{m}+1}\\left(\\frac{\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\kappa_{m+1}}{1-\\kappa_{m+1}}-(Q+1)\\frac{k_{m}-1}{N}\\right).</span></p>

    <p class="text-gray-300">By the recursive property (2) of <span class="math">\\kappa_{m}=\\mathrm{Er}(k_{m},\\ldots,k_{\\mu};N,\\ldots,N)</span>, it follows that</p>

    <p class="text-gray-300"><span class="math">\\frac{N-k_{m}+1}{N}(1-\\kappa_{m+1})=1-\\kappa_{m}\\,.</span></p>

    <p class="text-gray-300">Hence,</p>

    <p class="text-gray-300"><span class="math">p_{m}</span> <span class="math">\\geq\\frac{\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\kappa_{m+1}}{1-\\kappa_{m}}-(Q+1)\\frac{k_{m}-1}{N-k_{m}+1}</span> <span class="math">=\\frac{1}{1-\\kappa_{m}}\\bigg{(}\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\bigg{(}\\kappa_{m+1}+(1-\\kappa_{m})\\frac{k_{m}-1}{N-k_{m}+1}\\bigg{)}\\bigg{)}</span> <span class="math">=\\frac{1}{1-\\kappa_{m}}\\bigg{(}\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\bigg{(}1-(1-\\kappa_{m})\\cdot\\frac{N}{N-k_{m}+1}+(1-\\kappa_{m})\\frac{k_{m}-1}{N-k_{m}+1}\\bigg{)}\\bigg{)}</span> <span class="math">=\\frac{\\epsilon(\\mathcal{A})-(Q+1)\\cdot\\kappa_{m}}{1-\\kappa_{m}}\\,,</span></p>

    <p class="text-gray-300">which proves the claimed success probability.</p>

    <p class="text-gray-300">Expected Number of <span class="math">\\mathcal{A}</span>-Queries. Let the random variable <span class="math">T_{m}</span> denote the number of <span class="math">\\mathcal{A}</span>-queries made by extractor <span class="math">\\mathcal{E}_{m}</span>. By the induction hypothesis, it holds that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[T_{m+1}]\\leq K_{m+1}+Q\\cdot(K_{m+1}-1)\\,.</span></p>

    <p class="text-gray-300">We make one crucial observation, allowing us to achieve the claimed query complexity, linear in <span class="math">Q</span>. Namely, we can view the run of a (sub)extractor as a two-stage algorithm that allows an early abort. By Lemma 7, after only one <span class="math">\\mathcal{A}</span>-query <span class="math">\\mathcal{E}_{m+1}</span> already returns the index <span class="math">I_{m}</span>. At this stage, <span class="math">\\mathcal{E}_{m}</span> can decide whether to continue the execution of <span class="math">\\mathcal{E}_{m+1}</span> or to early abort this execution. If the index is incorrect, i.e., it does not match the one obtained in the first invocation of <span class="math">\\mathcal{E}_{m+1}</span>, then <span class="math">\\mathcal{E}_{m}</span> early aborts the execution of <span class="math">\\mathcal{E}_{m+1}</span>. Only if the index is correct, the <span class="math">\\mathcal{E}_{m+1}</span> execution has to be finished.</p>

    <p class="text-gray-300">For this reason, we define the function <span class="math">\\mathbf{c}\\mapsto\\Gamma(\\mathbf{c})</span>, where <span class="math">\\Gamma(\\mathbf{c})</span> is the (expected) costs of running <span class="math">\\mathcal{E}_{m+1}</span> (completely) with random oracle <span class="math">\\mathbf{c}\\in\\mathcal{C}^{U}</span>. Moreover, we set <span class="math">\\gamma=1</span> indicating the cost of an early abort invocation of <span class="math">\\mathcal{E}_{m+1}</span>. These cost functions measure the expected number of calls to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Hence, by Lemma 5 and Lemma 6, the expected cost of running <span class="math">\\mathcal{E}_{m}</span> is at most</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[T_{m}]</span> <span class="math">\\leq k_{m}\\cdot\\mathbb{E}[\\Gamma(C)]+\\gamma\\cdot Q\\cdot(k_{m}-1)=k_{m}\\cdot\\mathbb{E}[T_{m+1}]+Q\\cdot(k_{m}-1)</span> <span class="math">\\leq K_{m}+Q\\cdot(K_{m}-k_{m})+Q\\cdot(k_{m}-1)=K_{m}+Q\\cdot(K_{m}-1)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">C</span> is distributed uniformly at random in <span class="math">\\mathcal{C}^{U}</span>. This completes the proof. ∎</p>

    <p class="text-gray-300">The existence of extractor <span class="math">\\mathcal{E}_{1}</span>, combined with the <span class="math">\\mathbf{k}</span>-special-soundness property, implies the following. This theorem shows that the Fiat-Shamir security loss for <span class="math">\\mathbf{k}</span>-out-of-<span class="math">\\mathbf{N}</span> special-sound <span class="math">(2\\mu+1)</span>-round interactive proofs is <span class="math">Q+1</span>, i.e., the security loss is linear in the query complexity <span class="math">Q</span> of provers <span class="math">\\mathcal{P}^{*}</span> attacking the considered non-interactive random oracle proof <span class="math">\\mathsf{FS}[\\varPi]</span>. In particular, the Fiat-Shamir security loss is independent of the number of rounds <span class="math">(2\\mu+1)</span> of the interactive proof <span class="math">\\varPi</span>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Theorem 2 (FS Transformation of a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-Special-Sound Protocol).</h6>

    <p class="text-gray-300">The Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\varPi]</span> of a <span class="math">\\mathbf{k}=(k_{1},\\ldots,k_{\\mu})</span>-special-sound interactive proof <span class="math">\\varPi</span>, in which all challenges are sampled from a set <span class="math">\\mathcal{C}</span> of size <span class="math">N</span>, is knowledge sound with knowledge error</p>

    <p class="text-gray-300"><span class="math">\\kappa_{\\mathsf{fs}}(Q)=(Q+1)\\kappa\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa:=\\mathrm{Er}(\\mathbf{k};N)</span> is the knowledge error of the interactive proof <span class="math">\\varPi</span>.</p>

    <p class="text-gray-300">6.2 Multi-Round Protocols with Arbitrary Challenge Sets</p>

    <p class="text-gray-300">Thus far, we considered and analyzed multi-round interactive proofs in which all challenges are sampled uniformly at random from the same set <span class="math">\\mathcal{C}</span> of cardinality <span class="math">N</span>. However, it is straightforward to verify that our techniques also apply to multi-round interactive proofs with different challenge sets, i.e., where the <span class="math">i</span>-th challenge is sampled from a set <span class="math">\\mathcal{C}_{i}</span> of cardinality <span class="math">N_{i}</span>.</p>

    <p class="text-gray-300">A natural first step in this generalization is to consider <span class="math">\\mu</span> random oracles <span class="math">\\mathsf{RO}_{i}\\colon\\{0,1\\}^{\\leq u}\\to\\mathcal{C}_{i}</span> instead of one. Besides some additional bookkeeping, all the reasoning goes through unchanged. Indeed, everything works as is when the prover <span class="math">\\mathcal{P}^{*}</span> has the additional freedom to choose which random oracle it queries. Thus, we obtain the following generalization of Theorem 2.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 3 (FS Transformation of a k-out-of-N Special-Sound Interactive Proof).</h6>

    <p class="text-gray-300">The Fiat-Shamir transformation of a <span class="math">\\mathbf{k}</span>-out-of-<span class="math">\\mathbf{N}</span> special-sound interactive proof <span class="math">\\Pi</span> is knowledge sound with knowledge error</p>

    <p class="text-gray-300"><span class="math">\\kappa_{\\text{fs}}(Q)=(Q+1)\\kappa\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa:=\\operatorname{Er}(\\mathbf{k};\\mathbf{N})</span> is the knowledge error of the interactive proof <span class="math">\\Pi</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Remark 7.</h6>

    <p class="text-gray-300">Alternatively, one could fix <span class="math">\\mu</span> mappings <span class="math">f_{i}\\colon\\{0,1\\}^{<em>}\\to\\mathcal{C}_{i}</span> and define the random oracle to output sufficiently long bit-strings. As before, this allows the prover <span class="math">\\mathcal{P}^{</em>}</span> to take as input a single random oracle. Of course, this approach closely resembles practice, where the random oracles are replaced hash functions. However, one must be careful, since distinct bit-strings do not necessarily map to distinct challenges and uniformly random bit-strings do not necessary correspond to uniformly random challenges.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">6.3 Adaptive Security</h3>

    <p class="text-gray-300">Thus far, we restricted our extractor analysis to the static or non-adaptive knowledge soundness notion of Definition 9. More precisely, our knowledge extractor takes as input a fixed statement <span class="math">x</span>, is given oracle access to a static dishonest prover <span class="math">\\mathcal{P}^{*}</span> attacking the considered protocol on input <span class="math">x</span>, and aims to output a witness <span class="math">w</span> for <span class="math">x</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">However, our approach is easily modified towards proving adaptive knowledge soundness (Definition 10). To this end, let <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> be an adaptive <span class="math">Q</span>-query prover attacking the adaptive Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\Pi]</span> of a <span class="math">\\mathbf{k}</span>-out-of-<span class="math">\\mathbf{N}</span> special-sound interactive proof, i.e., <span class="math">\\mathcal{P}^{\\mathsf{a}}</span> takes no input and outputs a statement-proof pair <span class="math">(x,\\pi)</span>, with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math"> for some fixed </span>n<span class="math">, together with some auxiliary information </span>\\mathsf{aux}<span class="math">. The random oracle algorithm </span>\\mathcal{A}<span class="math"> is defined to run </span>(x,\\pi,\\mathsf{aux})\\leftarrow\\mathcal{P}^{\\mathsf{a}}<span class="math"> and verify that </span>\\pi<span class="math"> is a valid proof for statement </span>x$. The main difference with the static case is that the indices are now defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">I_{1}:=(x,a_{1})\\,,\\,I_{2}:=(x,a_{1},a_{2})\\,,\\ldots,\\,I_{\\mu}:=(x,a_{1},\\ldots,a_{\\mu})\\,,</span></p>

    <p class="text-gray-300">so as to match up with(4), i.e., with the adaptive Fiat-Shamir transformation.</p>

    <p class="text-gray-300">The statement <span class="math">x</span> can thus be considered as part of the first message <span class="math">(x,a_{1})</span>. Since all transcripts in a tree of transcripts have a common first message, it is easily seen that the extractor of Section 6, if successfully applied to this adaptive instantiation of <span class="math">\\mathcal{A}</span>, outputs a well-defined statement <span class="math">x</span> together with a tree of accepting transcripts for this statement <span class="math">x</span>. Moreover, <span class="math">x</span> is the statement outputted by the extractor’s first invocation of <span class="math">\\mathcal{P}^{\\mathsf{a}}</span>.</p>

    <p class="text-gray-300">For this reason, it immediately follows that our knowledge extractor, when applied to adaptive <span class="math">Q</span>-query provers <span class="math">\\mathcal{P}^{\\mathsf{a}}</span>, has the required properties. This proves the following theorem, showing that the adaptive Fiat-Shamir transformation of a special-sound interactive proof is adaptively knowledge sound.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 4 (FS Transformation - Adaptive Knowledge Soundness).</h6>

    <p class="text-gray-300">The adaptive Fiat-Shamir transformation of a <span class="math">\\mathbf{k}</span>-out-of-<span class="math">\\mathbf{N}</span> special-sound interactive proof <span class="math">\\Pi</span> is adaptively knowledge sound with knowledge error</p>

    <p class="text-gray-300"><span class="math">\\kappa_{\\text{fs}}(Q)=(Q+1)\\kappa\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa:=\\operatorname{Er}(\\mathbf{k};\\mathbf{N})</span> is the knowledge error of the interactive proof <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7 The Fiat-Shamir Transformation of Parallel Repetitions</p>

    <p class="text-gray-300">In the previous sections we have established a positive result; for a broad class of interactive proofs the Fiat-Shamir security loss is only linear in the query complexity <span class="math">Q</span> and independent of the number of rounds. One might therefore wonder whether the generic <span class="math">(Q+1)^{\\mu}</span> security loss, for <span class="math">(2\\mu+1)</span>-move protocols, is only tight for contrived examples. In this section, we show that this is not the case. We demonstrate a non-trivial attack on the Fiat–Shamir transformation of the parallel repetition of <span class="math">\\mathbf{k}</span>-special-sound protocols.</p>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\mu+1)</span>-move <span class="math">\\mathbf{k}</span>-special-sound interactive proof. We write <span class="math">\\Pi^{t}=(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> for its <span class="math">t</span>-fold parallel repetition. That is, the prover <span class="math">\\mathcal{P}^{t}(x;w)</span> runs <span class="math">t</span> instances of <span class="math">\\mathcal{P}(x;w)</span>, i.e., each message is a tuple <span class="math">(a^{1},\\ldots,a^{t})</span> of messages, one for each parallel thread of execution. Likewise, the verifier <span class="math">\\mathcal{V}^{t}(x)</span> runs <span class="math">t</span> instances of <span class="math">\\mathcal{V}(x)</span> in parallel, i.e., each challenge is a tuple <span class="math">(c^{1},\\ldots,c^{t})</span> of challenges, one for each parallel thread of the execution. Finally, the verifier accepts if all parallel instances are accepting.</p>

    <p class="text-gray-300">Assuming certain natural properties on <span class="math">\\Pi</span>, which are satisfied by typical examples, and assuming again for simplicity that the challenge spaces <span class="math">\\mathcal{C}_{i}</span> all have the same cardinality <span class="math">N</span>, we show that, when <span class="math">t\\geq\\mu</span>, there exists a malicious <span class="math">Q</span>-query prover <span class="math">\\mathcal{P}^{*}</span>, attacking <span class="math">\\mathsf{FS}[\\Pi^{t}]</span>, that, for any statement <span class="math">x</span>, succeeds in convincing the verifier with probability at least</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{2}\\frac{Q^{\\mu}}{\\mu^{t+\\mu}}\\operatorname{Er}(\\mathbf{k};N)^{t}\\,,</span></p>

    <p class="text-gray-300">assuming some mild conditions on the parameters. Given that <span class="math">\\operatorname{Er}(\\mathbf{k};N)^{t}</span> equals the soundness as well as the knowledge error of <span class="math">\\Pi^{t}</span>, our attack shows that the security loss of the Fiat-Shamir transformation, when applied to the <span class="math">t</span>-fold parallel repetition of <span class="math">\\Pi</span>, is at least <span class="math">\\frac{1}{2}Q^{\\mu}/\\mu^{t+\\mu}</span> (both, as a proof of language membership as well as a proof of knowledge). This stands in stark contrast to a single execution of a <span class="math">\\mathbf{k}</span>-special-sound protocol, where the loss is linear in <span class="math">Q</span> and independent of <span class="math">\\mu</span>.</p>

    <p class="text-gray-300">We go on to discuss the kind of <span class="math">\\mathbf{k}</span>-special-sound protocols <span class="math">\\Pi</span> for which our attack applies. For simplicity, we restrict our attention here to <span class="math">\\mathbf{k}=(k,\\ldots,k)</span> and assume <span class="math">t</span> and <span class="math">Q</span> to be multiples of <span class="math">\\mu</span>. In Appendix A.3, we consider the case of arbitrary <span class="math">\\mathbf{k}</span>, and the restrictions on <span class="math">t</span> and <span class="math">Q</span> can be easily avoided with some adjustments to the bound and the reasoning. Let <span class="math">\\boldsymbol{\\ell}=(\\ell,\\ldots,\\ell)</span> where <span class="math">\\ell\\leq k-1</span>. The attack on <span class="math">\\mathsf{FS}[\\Pi^{t}]</span> uses a property most <span class="math">\\mathbf{k}</span>-special-sound protocols <span class="math">\\Pi</span> satisfy, namely that there exists an efficient attack strategy <span class="math">\\mathcal{A}</span> against <span class="math">\\Pi</span> which tries to guess challenges up front so that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In any round, <span class="math">\\mathcal{A}</span> can prepare and send a message so that if he is lucky and the next challenge falls in a certain set <span class="math">\\Gamma</span> of cardinality <span class="math">\\ell</span>, <span class="math">\\mathcal{A}</span> will be able to complete the protocol and have the verifier accept (no matter what challenges <span class="math">\\mathcal{A}</span> encounters in the remaining rounds), and</li>

      <li>until <span class="math">\\mathcal{A}</span> is lucky in the above sense, in any round <span class="math">\\mathcal{A}</span> can actually prepare <span class="math">B</span> distinct messages as above, for a given parameter <span class="math">B</span>.</li>

    </ol>

    <p class="text-gray-300">We call protocols which admit such an attack strategy <span class="math">\\boldsymbol{\\ell}</span>-special-unsound with <span class="math">B</span> potential responses per round (see Appendix A.1 for a formal definition). The first point in particular implies an attack strategy for the interactive proof <span class="math">\\Pi</span> that succeeds with probability <span class="math">\\operatorname{Er}(\\boldsymbol{\\ell}+1,N)</span>. Since many <span class="math">\\mathbf{k}</span>-special-sound interactive proofs <span class="math">\\Pi</span> are <span class="math">\\boldsymbol{\\ell}</span>-special-unsound with <span class="math">\\boldsymbol{\\ell}=\\mathbf{k}-1</span>, this confirms the tightness of the knowledge error <span class="math">\\operatorname{Er}(\\mathbf{k},N)</span>, as already mentioned at the end of Section 2.2. The second point implies that in the context of the Fiat-Shamir transformation, an attacker can produce and try multiple message-challenge pairs in any round.</p>

    <p class="text-gray-300">These requirements are very common (for non-trivial <span class="math">\\boldsymbol{\\ell}</span> and large <span class="math">B</span>). For example, the folding technique of <em>[BCC^{+}16]</em>, when used to fold two parts into one, satisfies <span class="math">(3,\\ldots,3)</span>-special-soundness and <span class="math">(2,\\ldots,2)</span>-special-unsoundness with an exponential parameter <span class="math">B</span>; we discuss this in detail in Appendix A.2. Note that, while the honest prover in <em>[BCC^{+}16]</em> is deterministic, a dishonest prover can produce different messages (and hope to be lucky with one of the corresponding challenges).</p>

    <p class="text-gray-300">The following theorem gives a lower bound for the success probability of our attack on the Fiat-Shamir transformation <span class="math">\\mathsf{FS}[\\Pi^{t}]</span> of the <span class="math">t</span>-fold parallel repetition <span class="math">\\Pi^{t}</span> of an interactive proof <span class="math">\\Pi</span> with certain common soundness and unsoundness properties.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be a <span class="math">(2\\mu+1)</span>-move <span class="math">(k,\\ldots,k)</span>-out-of-<span class="math">(N,\\ldots,N)</span> special-sound interactive proof that is <span class="math">(\\ell,\\ldots,\\ell)</span>-special-unsound with <span class="math">B</span> responses per round for <span class="math">\\ell=k-1</span>. Furthermore, let <span class="math">t,Q\\in\\mathbb{N}</span> be integer multiples of <span class="math">\\mu</span> such that <span class="math">Q\\cdot\\left(\\frac{t}{N}\\right)^{t/\\mu}\\leq 1/4</span> and <span class="math">B\\geq Q</span>. Then there exists a <span class="math">Q</span>-query dishonest prover <span class="math">\\mathcal{P}^{<em>}</span> against <span class="math">(\\mathcal{P},\\mathcal{V})=\\mathsf{FS}[\\Pi^{t}]</span> such that, for any statement <span class="math">x\\in\\{0,1\\}^{</em>}</span>,</p>

    <p class="text-gray-300"><span class="math">\\epsilon(\\mathcal{P}^{<em>},x)=\\Pr\\bigl{(}\\mathcal{V}^{\\mathsf{RO}}(x,\\mathcal{P}^{</em>,\\mathsf{RO}})=1\\bigr{)}\\geq\\left(1-\\left(1-\\Bigl{(}\\frac{k-1}{N}\\Bigr{)}^{t/\\mu}\\right)^{Q/\\mu}\\right)^{\\mu}\\geq\\frac{1}{2}\\frac{Q^{\\mu}}{\\mu^{t+\\mu}}\\operatorname{Er}(\\mathbf{k};N)^{t}\\,.</span></p>

    <p class="text-gray-300">The run-time of <span class="math">\\mathcal{P}^{*}</span> is at most <span class="math">tQ</span> times the run-time of attack strategy <span class="math">\\mathcal{A}</span> against <span class="math">\\Pi</span>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The basic idea of the attack is that (groups of) parallel threads can be attacked individually and independently from each other over the different rounds of the protocol. Concretely, the attack is given by the adversary <span class="math">\\mathcal{P}^{<em>}</span> against <span class="math">\\mathsf{FS}[\\Pi^{t}]</span>, which makes up to <span class="math">Q=\\mu\\cdot Q^{\\prime}</span> queries, defined as follows: <span class="math">\\mathcal{P}^{</em>}</span> runs attack strategy <span class="math">\\mathcal{A}</span> in parallel against all <span class="math">t=\\mu\\cdot t^{\\prime}</span> threads. Let us call a thread green if strategy <span class="math">\\mathcal{A}</span> succeeds in guessing the challenge for that thread (and hence, <span class="math">\\mathcal{V}</span> will eventually accept for that thread). Otherwise, a thread is red. All threads start out red, and the goal of <span class="math">\\mathcal{P}^{<em>}</span> is to turn all threads green. To do so, in every round <span class="math">\\mathcal{P}^{</em>}</span> tries to turn at least <span class="math">t^{\\prime}=t/\\mu</span> red threads into green threads (or all red threads into green threads if fewer than <span class="math">t/\\mu</span> remain). For this, <span class="math">\\mathcal{P}^{<em>}</span> uses <span class="math">\\mathcal{A}</span> to get the messages which it feeds to the random oracle. If <span class="math">\\mathcal{P}^{</em>}</span> was lucky with the received challenges for at least <span class="math">t^{\\prime}=t/\\mu</span> threads, then enough red threads turn green. Else, <span class="math">\\mathcal{P}^{<em>}</span> tries the considered round again, exploiting that <span class="math">\\mathcal{A}</span> can produce up to <span class="math">B</span> distinct messages that give him a chance, each one giving a fresh challenge from the random oracle. The dishonest prover <span class="math">\\mathcal{P}^{</em>}</span> tries up to <span class="math">Q^{\\prime}=Q/\\mu</span> times per round until it gives up (and fails).</p>

    <p class="text-gray-300">The number of queries <span class="math">\\mathcal{P}^{<em>}</span> makes to the random oracle is at most <span class="math">Q</span>, hence <span class="math">\\mathcal{P}^{</em>}</span> is a <span class="math">Q</span>-query adversary. The probability that <span class="math">\\mathcal{P}^{<em>}</span> succeeds for any try in any round to turn at least <span class="math">t^{\\prime}=t/\\mu</span> red threads into green threads is at least <span class="math">(\\frac{\\ell}{N})^{t^{\\prime}}=\\lambda^{t^{\\prime}}</span>, where we introduce <span class="math">\\lambda=\\frac{\\ell}{N}</span> to simplify the upcoming expressions. Therefore, since <span class="math">\\mathcal{P}^{</em>}</span> makes at most <span class="math">Q^{\\prime}=Q/\\mu</span> queries in every round, the success probability for any fixed round is at least</p>

    <p class="text-gray-300"><span class="math">1-\\bigl{(}1-\\lambda^{t^{\\prime}}\\bigr{)}^{Q^{\\prime}}\\;\\geq\\;Q^{\\prime}\\lambda^{t^{\\prime}}-2\\,Q^{\\prime}{}^{2}\\lambda^{2t^{\\prime}}\\,=\\,Q^{\\prime}\\lambda^{t^{\\prime}}\\bigl{(}1-2\\,Q^{\\prime}\\lambda^{t^{\\prime}}\\bigr{)}\\,.</span> (8)</p>

    <p class="text-gray-300">where the inequality follows from the fact that <span class="math">1-(1-x)^{n}\\geq nx-2n^{2}x^{2}</span>, which can be shown to hold when <span class="math">nx\\leq 1/2</span> (see Appendix A), which is (more than) satisfied for <span class="math">x=\\lambda^{t^{\\prime}}</span> and <span class="math">n=Q^{\\prime}</span> by assumption. Hence, <span class="math">\\mathcal{P}^{*}</span> succeeds (in all <span class="math">\\mu</span> rounds) with probability at least</p>

    <p class="text-gray-300"><span class="math">Q^{\\prime}{}^{\\mu}\\lambda^{t}\\bigl{(}1-2\\,Q^{\\prime}\\lambda^{t^{\\prime}}\\bigr{)}^{\\mu}\\,\\geq\\,Q^{\\prime}{}^{\\mu}\\lambda^{t}\\bigl{(}1-2Q\\lambda^{t^{\\prime}}\\bigr{)}\\,\\geq\\,\\frac{1}{2}Q^{\\prime}{}^{\\mu}\\lambda^{t}\\,,</span></p>

    <p class="text-gray-300">where we use that <span class="math">(1-z)^{n}\\geq 1-nz</span> for <span class="math">n\\in\\mathbb{N}</span> and <span class="math">z\\in[0,1]</span> to argue the first inequality, and <span class="math">Q\\cdot\\left(\\frac{\\ell}{N}\\right)^{t^{\\prime}}\\leq 1/4</span> for the second. To complete the analysis of <span class="math">\\mathcal{P}^{*}</span>’s success probability, we observe that</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Er}(\\mathbf{k};N)=1-\\left(1-\\frac{k-1}{N}\\right)^{\\mu}\\leq\\mu\\cdot\\frac{k-1}{N}=\\mu\\cdot\\frac{\\ell}{N}=\\mu\\cdot\\lambda\\,.</span></p>

    <p class="text-gray-300">Hence, the success probability of <span class="math">\\mathcal{P}^{*}</span> is at least <span class="math">\\frac{1}{2}Q^{\\prime}{}^{\\mu}\\bigl{(}\\frac{\\operatorname{Er}(\\mathbf{k};N)}{\\mu}\\bigr{)}^{t}</span>, as claimed. ∎</p>

    <p class="text-gray-300">Recall that we assume <span class="math">t</span> and <span class="math">Q</span> to be divisible by <span class="math">\\mu</span>; this is mainly for simplicity. In general, i.e., when dropping this assumption, the success probability has lower bound <span class="math">1/2\\cdot\\lfloor Q/\\mu\\rfloor^{\\mu}\\cdot\\bigl{(}\\operatorname{Er}(\\mathbf{k};N)/\\mu\\bigr{)}^{\\lceil t/\\mu\\rceil\\mu}</span>.</p>

    <h2 id="sec-53" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">The first author was supported by EU H2020 project No. 780701 (PROMETHEUS) and the Vraaggestuurd Programma Cyber Security & Resilience, part of the Dutch Top Sector High Tech Systems and Materials program. The third author was supported by the topic Engineering Secure Systems (46.23.01) of the Helmholtz Association (HGF) and by KASTEL Security Research Labs.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AC20. Thomas Attema and Ronald Cramer. Compressed <span class="math">\\Sigma</span>-protocol theory and practical application to plug & play secure algorithmics. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 513–543. Springer, Heidelberg, August 2020.</li>

      <li>ACK21. Thomas Attema, Ronald Cramer, and Lisa Kohl. A compressed <span class="math">\\Sigma</span>-protocol theory for lattices. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part II, volume 12826 of LNCS, pages 549–579, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>AF21. Thomas Attema and Serge Fehr. Parallel repetition of <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound multi-round interactive proofs. Cryptology ePrint Archive, Report 2021/1259, 2021. https://eprint.iacr.org/2021/1259.</li>

      <li>AL21. Martin R. Albrecht and Russell W. F. Lai. Subtractive sets over cyclotomic rings - limits of Schnorr-like arguments over lattices. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part II, volume 12826 of LNCS, pages 519–548, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>BBB^{+}18. Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016.</li>

      <li>BCS16. Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016.</li>

      <li>BL02. Boaz Barak and Yehuda Lindell. Strict polynomial-time in simulation and extraction. In 34th ACM STOC, pages 484–493. ACM Press, May 2002.</li>

      <li>BN06. Mihir Bellare and Gregory Neven. Multi-signatures in the plain public-key model and a general forking lemma. In Ari Juels, Rebecca N. Wright, and Sabrina De Capitani di Vimercati, editors, ACM CCS 2006, pages 390–399. ACM Press, October / November 2006.</li>

      <li>DFMS19. Jelle Don, Serge Fehr, Christian Majenz, and Christian Schaffner. Security of the Fiat-Shamir transformation in the quantum random-oracle model. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part II, volume 11693 of LNCS, pages 356–383. Springer, Heidelberg, August 2019.</li>

      <li>dLS19. Rafa^{′}el del Pino, Vadim Lyubashevsky, and Gregor Seiler. Short discrete log proofs for FHE and ring-LWE ciphertexts. In Dongdai Lin and Kazue Sako, editors, PKC 2019, Part I, volume 11442 of LNCS, pages 344–373. Springer, Heidelberg, April 2019.</li>

      <li>FS87. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO 1986, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>GT21. Ashrujit Ghoshal and Stefano Tessaro. Tight state-restoration soundness in the algebraic group model. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part III, volume 12827 of LNCS, pages 64–93, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>HKR19. Max Hoffmann, Michael Klooß, and Andy Rupp. Efficient zero-knowledge arguments in the discrete log setting, revisited. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2093–2110. ACM Press, November 2019.</li>

      <li>JT20. Joseph Jaeger and Stefano Tessaro. Expected-time cryptography: Generic techniques and applications to concrete soundness. In Rafael Pass and Krzysztof Pietrzak, editors, TCC 2020, Part III, volume 12552 of LNCS, pages 414–443. Springer, Heidelberg, November 2020.</li>

      <li>PS96. David Pointcheval and Jacques Stern. Security proofs for signature schemes. In Ueli M. Maurer, editor, EUROCRYPT 1996, volume 1070 of LNCS, pages 387–398. Springer, Heidelberg, May 1996.</li>

      <li>Unr17. Dominique Unruh. Post-quantum security of Fiat-Shamir. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part I, volume 10624 of LNCS, pages 65–95. Springer, Heidelberg, December 2017.</li>

      <li>Wik18. Douglas Wikström. Special soundness revisited. Cryptology ePrint Archive, Report 2018/1157, 2018. https://eprint.iacr.org/2018/1157.</li>

      <li>Wik21. Douglas Wikström. Special soundness in the random oracle modeld. Cryptology ePrint Archive, Report 2021/1265, 2021. https://eprint.iacr.org/2021/1265.</li>

    </ul>

    <p class="text-gray-300">A Detailed Discussion of the Attack</p>

    <p class="text-gray-300">We discuss our attack in more detail, but also in more generality, here. Let <span class="math">\\Pi</span> be a <span class="math">(2\\mu+1)</span>-move public-coin interactive proof for relation <span class="math">R</span> with challenge sets <span class="math">\\mathcal{C}_{1},\\ldots,\\mathcal{C}_{\\mu}</span>.</p>

    <p class="text-gray-300">In Appendix A.1, we give a formal definition of the unsoundness property required for our attack to succeed. In Appendix A.2, we give an example of a multi-round protocol satisfying this unsoundness property, i.e., a protocol to which our attack applies. In Appendix A.3, we generalize the attack to a broader class of protocols and describe the properties of this generalization.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">A.1 Special-Unsoundness with Multiple Potential Responses</h3>

    <p class="text-gray-300">For simplicity, we assume perfect correctness. The attack applies when <span class="math">\\Pi</span> satisfies the following property.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 12 (<span class="math">\\ell</span>-special-unsoundness with <span class="math">B</span> potential responses per round).</h6>

    <p class="text-gray-300">We say that <span class="math">\\Pi</span> has <span class="math">\\boldsymbol{\\ell}</span>-<em>special-unsoundness</em> for <span class="math">\\boldsymbol{\\ell}=(\\ell_{1},\\ldots,\\ell_{\\mu})\\in\\mathbb{N}^{\\mu}</span> if there exists a dishonest prover <span class="math">\\mathcal{A}</span> of the following form, and so that in the execution with <span class="math">\\mathcal{V}</span> and input <span class="math">x</span> the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> starts off in <em>active mode</em>, which is so that in every round <span class="math">2i-1</span> when <span class="math">\\mathcal{A}</span> sends the response <span class="math">a_{i}</span> to <span class="math">\\mathcal{V}</span>, there exists a subset <span class="math">\\Gamma_{i}\\subseteq\\mathcal{C}_{i}</span> of cardinality <span class="math">\\ell_{i}</span> (defined as a function of the state of <span class="math">\\mathcal{A}</span> at that point) such that if the subsequent challenge <span class="math">c_{i}</span> is in <span class="math">\\Gamma_{i}</span> then <span class="math">\\mathcal{A}</span> switches into <em>passive mode</em>.</li>

      <li>If <span class="math">\\mathcal{A}</span> switches to <em>passive mode</em> then it remains in <em>passive mode</em>, and <span class="math">\\mathcal{V}</span> will accept at the end of the protocol execution.</li>

    </ul>

    <p class="text-gray-300">We say <span class="math">\\Pi</span> is <span class="math">\\boldsymbol{\\ell}</span>-special-unsound with <span class="math">B</span> <em>potential responses per round</em> if additionally the following holds: As long as <span class="math">\\mathcal{A}</span> is in active mode, the computation of <span class="math">a_{i}</span> involves a designated <em>seed</em> <span class="math">s_{i}</span>, which is chosen arbitrarily from some set <span class="math">\\mathcal{S}_{i}</span>. By redoing the computation with different seeds (but fixed randomness), <span class="math">\\mathcal{A}</span> can obtain at least <span class="math">B</span> <em>distinct</em> <span class="math">a_{i}</span>’s satisfying the properties specified above (i.e., existence of <span class="math">\\Gamma_{i}</span> such that <span class="math">\\mathcal{A}</span> switches to passive mode if <span class="math">c_{i}\\in\\Gamma_{i}</span>). Moreover, we require that distinct seeds produce distinct <span class="math">a_{i}</span>, that is, the mapping from seed <span class="math">s_{i}</span> to message <span class="math">a_{i}</span> is injective.</p>

    <p class="text-gray-300">The “<span class="math">B</span> potential responses per round”, which can be derived by changing the seed <span class="math">s</span>, are used so that <span class="math">\\mathcal{A}</span> can “retry” each round at least <span class="math">B</span> times. This will be used to obtain fresh challenges from the random oracles. The requirement that different seeds produce different <span class="math">a_{i}</span> will simplify statements and proofs, but it will be evident that it is stronger than necessary. One can relax the definition as long as <span class="math">\\mathcal{A}</span> can produce distinct <span class="math">a_{i}</span> efficiently, say by picking a few seeds at random; the (run-time) analysis must then take these additional tries into account.</p>

    <p class="text-gray-300">Protocols that are <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound are often <span class="math">(k_{1}-1,\\ldots,k_{\\mu}-1)</span>-special-unsound. For example, <span class="math">k</span>-special-sound <span class="math">\\Sigma</span>-protocols are typically <span class="math">(k-1)</span>-special-unsound in that a dishonest prover can first pick an arbitrary subset <span class="math">\\Gamma\\subset\\mathcal{C}</span> of cardinality <span class="math">k-1</span>, then choose an arbitrary response <span class="math">z</span>, and finally compute a first message <span class="math">a</span> (as a function of <span class="math">\\Gamma</span> and <span class="math">z</span>), so that <span class="math">(a,c,z)</span> is an accepting conversation whenever <span class="math">c\\in\\Gamma</span>. Furthermore, different choices (possibly of a certain form) of the pre-chosen response <span class="math">z</span> typically lead to different values of <span class="math">a</span>, thus satisfying the multiple responses per round property as well.</p>

    <p class="text-gray-300">For multi-round <span class="math">\\mathbf{k}</span>-special-sound protocols, this kind of attack often extends in such a way that once <span class="math">\\mathcal{A}</span> is successful in one round, it has all the information needed to continue as an honest prover, and the verifier will accept. In other words, the <em>passive mode</em> of <span class="math">\\mathcal{A}</span> usually corresponds to following the remainder of the protocol honestly. Below, we discuss in detail that in particular Bulletproofs-like protocols satisfy the Definition 12.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">A.2 An Example Protocol</h3>

    <p class="text-gray-300">Bulletproofs-like protocols are typically <span class="math">(2,\\ldots,2)</span>-special-unsound (or worse), as we explain here. At the core of these protocols is the folding technique of <em>[BCC^{+}16]</em>. Here, we describe the adaptation considered <em>[AC20]</em>,</p>

    <p class="text-gray-300">which, in the plain DL-setting, is the following 3-special-sound <span class="math">\\Sigma</span>-protocol for proving knowledge of <span class="math">\\mathbf{x} \\in \\mathbb{F}_q^n</span> with <span class="math">\\mathbf{g}^{\\mathbf{x}} = h</span>; we refer to this protocol as the folding protocol in the remainder. Here, <span class="math">\\mathbf{g} = (g_1, \\ldots, g_n) \\in \\mathbb{G}^n</span> and <span class="math">h \\in \\mathbb{G}</span> are publicly known, where <span class="math">\\mathbb{G}</span> is a group with prime order <span class="math">q</span>, and <span class="math">\\mathbf{g}^{\\mathbf{x}} := g^{x_1} \\cdots g_n^{x_n}</span>; furthermore, it is assumed (w.l.o.g.) that <span class="math">n</span> is a power of 2, and so in particular <span class="math">n</span> is even and we can write <span class="math">\\mathbf{g}_L = (g_1, \\ldots, g_{n/2})</span> and <span class="math">\\mathbf{g}_R = (g_{n/2+1}, \\ldots, g_{n/2})</span>, and similarly for <span class="math">\\mathbf{x}</span>, so that <span class="math">\\mathbf{g}^{\\mathbf{x}}</span> is the component-wise product <span class="math">\\mathbf{g}^{\\mathbf{x}} = \\mathbf{g}_L^{\\mathbf{x}_L} \\mathbf{g}_R^{\\mathbf{x}_R}</span> of <span class="math">\\mathbf{g}_L^{\\mathbf{x}_L}</span> and <span class="math">\\mathbf{g}_R^{\\mathbf{x}_R}</span>. Lastly, we may assume that <span class="math">\\mathbf{g} \\neq (1, \\ldots, 1)</span>, since in this case the relation <span class="math">\\mathbf{g}^{\\mathbf{x}} = h</span> is trivial and so there is nothing for the prover to prove.</p>

    <p class="text-gray-300">In the considered folding protocol, the honest prover first sends <span class="math">a := \\mathbf{g}_R^{\\mathbf{x}_L}</span> and <span class="math">b := \\mathbf{g}_L^{\\mathbf{x}_R}</span> to the verifier and then answers the challenge <span class="math">c \\gets_R \\mathbb{F}_q</span> with <span class="math">\\mathbf{z} := \\mathbf{x}_L + c \\mathbf{x}_R</span>, and the verifier accepts if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {g} _ {L} ^ {c} \\odot \\mathbf {g} _ {R}\\right) ^ {\\mathbf {z}} = a h ^ {c} b ^ {c ^ {2}}, \\tag {9}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{g}_L^c\\odot \\mathbf{g}_R</span> denotes the component-wise product of <span class="math">\\mathbf{g}_L^c</span> and <span class="math">\\mathbf{g}_R</span>. The communication complexity of this <span class="math">\\Sigma</span>-protocol can now be improved by not sending the answer <span class="math">\\mathbf{z}</span>, but instead proving knowledge of <span class="math">\\tilde{\\mathbf{x}}</span> with <span class="math">\\tilde{\\mathbf{g}}^{\\tilde{\\mathbf{x}}} = \\tilde{h} := ah^{c}b^{c^{2}}</span> for <span class="math">\\tilde{\\mathbf{g}} := \\mathbf{g}_L^c\\odot \\mathbf{g}_R</span>; the latter is done by means of running another instance of the protocol but now with the smaller witness <span class="math">\\tilde{\\mathbf{x}} = \\mathbf{z}</span>. But then, also in this instance, instead of sending the answer one can run yet another instance of the protocol to prove knowledge of the answer, etc. This results in a compressed multi-round interactive proof of knowledge with communication complexity logarithmically in <span class="math">n</span> (instead of linear).</p>

    <p class="text-gray-300">Towards arguing unsoundness, i.e., Definition 12, it follows directly from the construction design for the compression protocol that once a dishonest prover holds the correct answer, then he can honestly follow the remainder of the protocol and the verifier will accept. Thus, this defines the passive mode. For the active mode, we observe that the following holds for the folding protocol. For any two <span class="math">c_{1}, c_{2} \\in \\mathbb{F}_{q}</span> with <span class="math">c_{1}^{2} \\neq c_{2}^{2}</span> and with <span class="math">\\tilde{\\mathbf{g}}_{1} := \\mathbf{g}_{L}^{c_{1}} \\odot \\mathbf{g}_{R}</span> and <span class="math">\\tilde{\\mathbf{g}}_{2} := \\mathbf{g}_{L}^{c_{2}} \\odot \\mathbf{g}_{R}</span> both not being equal to <span class="math">(1, \\ldots, 1)</span>, <span class="math">\\mathcal{A}</span> can pick an arbitrary answer <span class="math">\\mathbf{z} \\in \\mathbb{F}_{q}^{n/2}</span> and solve the equation system</p>

    <div class="my-4 text-center"><span class="math-block">a b ^ {c _ {1} ^ {2}} = \\tilde {\\mathbf {g}} _ {1} ^ {\\mathbf {z}} h ^ {- c _ {1}}</span></div>

    <div class="my-4 text-center"><span class="math-block">a b ^ {c _ {2} ^ {2}} = \\tilde {\\mathbf {g}} _ {2} ^ {\\mathbf {z}} h ^ {- c _ {2}}</span></div>

    <p class="text-gray-300">for <span class="math">a</span> and <span class="math">b</span> by applying the inverse of the matrix <span class="math">\\left( \\begin{array}{cc}1 &amp;amp; c_1^2\\\\ 1 &amp;amp; c_2^2 \\end{array} \\right)</span> to both sides "in the exponent".</p>

    <p class="text-gray-300">Then, by construction, the pre-chosen answer <span class="math">\\mathbf{z}</span> satisfies (9) if the verifier's challenge <span class="math">c</span> happens to be in <span class="math">\\Gamma = \\{c_1, c_2\\}</span>, and thus by switching to the passive mode now if this happens to be the case and following the remainder of the protocol honestly, <span class="math">\\mathcal{A}</span> will make the verifier accept, as required by Definition 12. Also, if desired, <span class="math">\\mathcal{A}</span> can solve the above equation system with a different choice of <span class="math">\\mathbf{z}</span> to obtain a new pair <span class="math">(a, b)</span>. More precisely, let <span class="math">i \\in \\{1, \\dots, n/2\\}</span> be so that the <span class="math">i</span>-th coordinate of, say, <span class="math">\\tilde{\\mathbf{g}}_1</span> is not 1 (which exists by choice of <span class="math">c_1</span>), then the <span class="math">q</span> possible choices of the <span class="math">i</span>-th coordinate <span class="math">z_i \\in \\mathbb{F}_q</span> of <span class="math">\\mathbf{z}</span> lead to <span class="math">q</span> distinct right-hand-sides in the above equation system, and thus to <span class="math">q</span> distinct pairs <span class="math">(a, b)</span>, when keeping the remaining coordinates of <span class="math">\\mathbf{z}</span> fixed.</p>

    <h2 id="sec-57" class="text-2xl font-bold">A.3 Generalizing Theorem 5 to Arbitrary Special-Unsound Protocols</h2>

    <p class="text-gray-300">Theorem 6 removes the restriction <span class="math">\\ell_1 = \\dots = \\ell_\\mu</span> in Theorem 5. Indeed, it considers a <span class="math">(\\ell_1,\\ldots ,\\ell_\\mu)</span>-special-unsound protocol with arbitrary <span class="math">\\ell_i</span>'s.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 6.</strong> Let <span class="math">\\Pi</span> be a <span class="math">(2\\mu + 1)</span>-move public-coin interactive proof with challenge spaces <span class="math">\\mathcal{C}_1, \\ldots, \\mathcal{C}_\\mu</span>. Suppose <span class="math">\\Pi</span> has <span class="math">(\\ell_1, \\ldots, \\ell_\\mu)</span>-special-unsoundness with <span class="math">B</span> responses per round. Let <span class="math">\\Pi^t</span> be the <span class="math">t</span>-fold parallel repetition of <span class="math">\\Pi</span>. Let <span class="math">m_1, \\ldots, m_\\mu \\in \\mathbb{N}</span> such that <span class="math">\\sum_{i=1}^\\mu m_i = t</span>, and set $\\alpha_i = (\\frac{\\ell_i}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{m_i}<span class="math">. Let </span>Q = \\mu Q'<span class="math"> for </span>Q' \\in \\mathbb{N}<span class="math"> with </span>Q' \\sum_{i=1}^\\mu \\alpha_i &lt; 1/4<span class="math"> and </span>Q' \\leq B<span class="math">. Then there is a </span>Q<span class="math">-query dishonest prover </span>\\mathcal{P}^*<span class="math"> against </span>(\\mathcal{P}, \\mathcal{V}) = \\mathsf{FS}[\\Pi^t]<span class="math"> so that for every statement </span>x$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\epsilon (\\mathcal {P} ^ {*}, x) = \\operatorname * {P r} \\big (\\mathcal {V} ^ {\\mathsf {R O}} (x, \\mathcal {P} ^ {*}, \\mathsf {R O}) = 1 \\big) \\geq \\frac {1}{2} \\bigg (\\frac {Q}{\\mu} \\bigg) ^ {\\mu} \\cdot \\prod_ {i = 1} ^ {\\mu} \\alpha_ {i}.</span></div>

    <p class="text-gray-300">The run-time of <span class="math">\\mathcal{P}^{*}</span> is <span class="math">O(t\\cdot Q\\cdot T_{\\mathcal{A}})</span>, where <span class="math">T_{\\mathcal{A}}</span> is an upper-bound on the run-time of some <span class="math">\\ell</span>-special-unsoundness dishonest prover <span class="math">\\mathcal{A}</span> attacking the (interactive) proof system <span class="math">\\Pi</span> (i.e., when <span class="math">\\mathcal{A}</span> computes one message <span class="math">a_{i}</span> per round).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We recover the statement of Theorem 5 by considering <span class="math">\\Pi</span> that is <span class="math">(\\ell,\\dots,\\ell)</span>-special-unsound and has challenge spaces of fixed size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N<span class="math">, and by setting </span>m_{1}=\\dots=m_{\\mu}=t/\\mu<span class="math"> and thus </span>\\alpha_{1}=\\dots=\\alpha_{\\mu}=(\\frac{k-1}{N})^{t/\\mu}<span class="math"> then. In general, the freedom in choosing </span>m_{1},\\dots,m_{\\mu}<span class="math"> allows to adapt the number of threads that should be successfully attacked in each round, which is useful when the </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">’s and/or the </span>\\ell_{i}$’s vary over the different rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is analogous to the proof of Theorem 5, with the attack working in a thread by thread manner. Let <span class="math">\\mathcal{A}</span> be an <span class="math">(\\ell_{1},\\dots,\\ell_{\\mu})</span>-special-unsoundness malicious prover for <span class="math">\\Pi</span> with <span class="math">B</span> potential responses per round. Let <span class="math">\\mathcal{P}^{*}</span> be the adversary defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Start <span class="math">t</span> parallel instances <span class="math">\\mathcal{A}</span> with input <span class="math">x</span>, denoted as <span class="math">\\mathcal{A}_{1},\\dots,\\mathcal{A}_{t}</span>. We write <span class="math">a_{i}^{j}</span> for the <span class="math">(2i-1)</span>-th move message of the <span class="math">j</span>-th instance, and similarly for the corresponding unsoundness set <span class="math">\\Gamma_{i}^{j}</span>.</li>

      <li>From <span class="math">i=1</span>, repeat until <span class="math">i=\\mu</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Try up to <span class="math">Q/\\mu</span> times:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">\\mathcal{A}_{j}</span> which are in active mode, pick a seed <span class="math">s_{i}^{j}\\in\\mathcal{S}</span>, distinct from all seeds previously chosen for <span class="math">\\mathcal{A}_{j}</span> in this round.</li>

      <li>Run all <span class="math">\\mathcal{A}_{j}</span> to obtain the <span class="math">(2i-1)</span>-th move message <span class="math">a_{i}^{j}</span> for all <span class="math">i,j</span>. Moreover, compute the challenges <span class="math">c_{i}^{j}</span> for all threads <span class="math">j</span>.</li>

      <li>If, after receiving the challenges <span class="math">c_{i}^{j}</span>, at least <span class="math">\\sum_{k=1}^{i}m_{k}</span> of the <span class="math">\\mathcal{A}_{j}</span>’s would be in passive mode, send the challenges and increase <span class="math">i</span> (i.e., move on to attacking the next round). In particular, if at least <span class="math">m_{i}</span> <span class="math">\\mathcal{A}_{j}</span>’s switch from active to passive, <span class="math">i</span> will increase.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}^{*}</span> receives <span class="math">a_{\\mu+1}^{j}</span> from <span class="math">\\mathcal{A}_{j}</span> (for <span class="math">j=1,\\dots,t</span>) and completes the fake proof.</li>

    </ol>

    <p class="text-gray-300">First, let us analyze the efficiency of <span class="math">\\mathcal{P}^{<em>}</span>. Clearly, <span class="math">\\mathcal{P}^{</em>}</span> is a <span class="math">Q</span>-query random-oracle algorithm. Moreover, <span class="math">\\mathcal{P}^{*}</span> emulates at most <span class="math">t\\cdot Q</span> (partial) runs of the <span class="math">\\ell</span>-special-unsoundness malicious prover instances <span class="math">\\mathcal{A}_{j}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, let us analyze the success probability. For the <span class="math">i</span>-th challenge, <span class="math">\\mathcal{P}^{*}</span> will execute the inner loop body at most <span class="math">Q^{\\prime}\\in\\mathbb{N}</span> times, where <span class="math">Q=\\mu Q^{\\prime}</span> by definition. Moreover, for each retry, at least one message <span class="math">a_{i}^{j}</span> is different from its previous choices. (Because different seeds <span class="math">s_{i}^{j}</span> lead to different <span class="math">a_{i}^{j}</span> for any <span class="math">\\mathcal{A}_{j}</span> which is in active mode, and at least one <span class="math">\\mathcal{A}_{j}</span> is still in active mode, because otherwise the inner loop increases <span class="math">i</span>). Thus, the random oracle queries provide fresh random challenges. The probability that an inner iteration in move <span class="math">2i-1</span> succeeds for a uniformly random challenge choice is at least $\\alpha_{i}=(\\ell_{i}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{m_{i}}<span class="math">, since by construction at most </span>m_{i}<span class="math"> threads/instances </span>\\mathcal{A}_{j}<span class="math"> need to be lucky in this round. Consequently, the probability that </span>Q^{\\prime}<span class="math"> tries are sufficient to switch enough </span>\\mathcal{A}_{j}<span class="math"> from active to passive mode in the </span>i$-the iteration is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">1-(1-\\alpha_{i})^{Q^{\\prime}}\\geq Q^{\\prime}\\alpha_{i}-2(Q^{\\prime}\\alpha_{i})^{2}\\,.</span> (10)</p>

    <p class="text-gray-300">For the inequality we used that <span class="math">1-(1-x)^{n}\\geq nx-2n^{2}x^{2}</span> for any <span class="math">x\\geq 0</span> and <span class="math">n\\in\\mathbb{N}</span> with <span class="math">0\\leq nx\\leq 1/2</span>, where the latter follows from</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1-(1-x)^{n}-nx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sum_{i=2}^{n}\\binom{n}{i}x^{i}\\leq\\sum_{i=2}^{n}(nx)^{i}\\leq\\sum_{i=2}^{\\infty}(nx)^{i}=\\frac{n^{2}x^{2}}{1-nx}\\leq 2n^{2}x^{2}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Noting that <span class="math">Q^{\\prime}\\alpha_{i}\\leq Q^{\\prime}\\sum_{i}\\alpha_{i}\\leq 1/4\\leq 1/2</span> by assumption, we can thus indeed conclude (10).</p>

    <p class="text-gray-300">As every round must be successful for <span class="math">\\mathcal{P}^{<em>}</span> to succeed, the overall success probability of <span class="math">\\mathcal{P}^{</em>}</span> is thus at least</p>

    <p class="text-gray-300"><span class="math">\\prod_{i=1}^{\\mu}\\big{(}1-(1-\\alpha_{i})^{Q^{\\prime}}\\big{)}\\geq\\prod_{i=1}^{\\mu}\\big{(}Q^{\\prime}\\alpha_{i}-2(Q^{\\prime}\\alpha_{i})^{2}\\big{)}=Q^{\\prime\\mu}\\prod_{i=1}^{\\mu}\\alpha_{i}\\cdot\\prod_{i=1}^{\\mu}(1-2Q^{\\prime}\\alpha_{i})\\,.</span></p>

    <p class="text-gray-300">Using that <span class="math">\\prod_{i=1}^{\\mu}(1 - z_i) \\geq 1 - \\sum_{i=1}^{\\mu}z_i</span> for <span class="math">z_i \\geq 0</span>, we can further bound the right hand side as</p>

    <div class="my-4 text-center"><span class="math-block">Q ^ {\\prime \\mu} \\prod_ {i = 1} ^ {\\mu} \\alpha_ {i} \\cdot \\prod_ {i = 1} ^ {\\mu} (1 - 2 Q ^ {\\prime} \\alpha_ {i}) \\geq Q ^ {\\prime \\mu} \\prod_ {i = 1} ^ {\\mu} \\alpha_ {i} \\cdot \\left(1 - 2 \\sum_ {i = 1} ^ {\\mu} Q ^ {\\prime} \\alpha_ {i}\\right) \\geq \\frac {1}{2} \\cdot Q ^ {\\prime \\mu} \\prod_ {i = 1} ^ {\\mu} \\alpha_ {i},</span></div>

    <p class="text-gray-300">where we used again <span class="math">Q&#x27; \\sum_{i} \\alpha_{i} \\leq 1/4</span> for the final inequality. This proves the claim.</p>

    <p class="text-gray-300">31</p>`;
---

<BaseLayout title="Fiat-Shamir Transformation of Multi-Round Interactive Proofs (2021/1377)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1377
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
