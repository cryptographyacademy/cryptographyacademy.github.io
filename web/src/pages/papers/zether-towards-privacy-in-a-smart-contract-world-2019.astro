---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/191';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zether: Towards Privacy in a Smart Contract World';
const AUTHORS_HTML = 'Benedikt Bünz, Shashank Agrawal, Mahdi Zamani, Dan Boneh';

const CONTENT = `    <p class="text-gray-300">Zether: Towards Privacy in a Smart Contract World</p>

    <p class="text-gray-300">Benedikt Bünz^{1}, Shashank Agrawal^{2}, Mahdi Zamani^{3}, and Dan Boneh^{4}</p>

    <p class="text-gray-300">^{1}Stanford University, benedikt@cs.stanford.edu ^{2}Visa Research, shaagraw@visa.com ^{3}Visa Research, mzamani@visa.com ^{4}Stanford University, dabo@cs.stanford.edu</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Blockchain-based smart contract platforms like Ethereum have become quite popular as a way to remove trust and add transparency to distributed applications. While different types of important applications can be easily built on such platforms, there does not seem to be an easy way to add a meaningful level of privacy to them.</p>

    <p class="text-gray-300">In this paper, we propose <em>Zether</em>, a fully-decentralized, confidential payment mechanism that is compatible with Ethereum and other smart contract platforms. We take an account-based approach similar to Ethereum for efficiency and usability. We design a new smart contract that keeps the account balances encrypted and exposes methods to deposit, transfer and withdraw funds to/from accounts through cryptographic proofs.</p>

    <p class="text-gray-300">We describe techniques to protect Zether against replay attacks and front-running situations. We also develop a mechanism to enable interoperability with arbitrary smart contracts. This helps to make several popular applications like auctions, payment channels, voting, etc. confidential.</p>

    <p class="text-gray-300">As a part of our protocol, we propose <span class="math">\\Sigma</span>-Bullets, an improvement of the existing zero-knowledge proof system, Bulletproofs. <span class="math">\\Sigma</span>-Bullets make Bulletproofs more inter-operable with Sigma protocols, which is of general interest.</p>

    <p class="text-gray-300">We implement Zether as an Ethereum smart contract and show the practicality of our design by measuring the amount of <em>gas</em> used by the Zether contract. A Zether confidential transaction costs about 0.014 ETH or approximately $1.51 (as of early Feb, 2019). We discuss how small changes to Ethereum, which are already being discussed independently of Zether, would drastically reduce this cost.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Blockchain-based smart contract platforms have great promise to remove trust and add transparency to distributed applications. Ethereum is a prominent example of such a platform <em>[39]</em>. It provides high-level powerful programming languages like Solidity <em>[85]</em> to build decentralized applications (DApps) with ease. Unfortunately, there is no easy way to <em>add</em> some meaningful level of privacy to these applications. Take the case of auction contracts for instance, which can be built on Ethereum without much trouble <em>[86]</em>—but, could we build a <em>sealed-bid</em> auction mechanism just as easily?</p>

    <p class="text-gray-300">Sealed-bid auctions work roughly as follows: In a bidding phase, bidders submit <em>sealed</em> bids to an auctioneer so that no bidder knows how much others have bid. Afterwards, the bids are unsealed and a winner is chosen by comparing the bid values. If we try to build such an auction contract on Ethereum, how do bidders deposit their bids with the contract given that all transaction amounts in Ethereum are publicly visible?</p>

    <p class="text-gray-300">There are several ways people deal with this problem in practice. Ethereum Name Service suggests that users submit just a hash of their bids to register a name with the registrar, and deposit more ether (Ethereum’s native currency) than the true bid value <em>[36, 37]</em>. The official Solidity documentation has an example for blind auctions too, where users submit multiple bids which include some fake ones <em>[86]</em>. These mechanisms, however, do not hide the bid values completely and put additional burden</p>

    <p class="text-gray-300">on the users. Some powerful general-purpose cryptographic solutions have also been proposed to run arbitrary smart contracts in a privacy-preserving way <em>[53, 25]</em>, but they are not fully decentralized and/or too expensive for simple contracts.</p>

    <p class="text-gray-300">Indeed, the quest for confidentiality is not limited to auctions. Payment channels are widely seen as a central technology to increase the throughput of crypto-currencies. On a powerful platform like Ethereum, payment channels can be easily set up too <em>[44, 6]</em>—but, could we make such channels <em>confidential</em> just as easily?</p>

    <p class="text-gray-300">Confidential transfers. If there was a way to send ether confidentially on Ethereum, perhaps we could leverage it to <em>add</em> confidentiality to important applications like auctions and payment channels. Unfortunately, almost all known ways to transfer confidentially <em>[59, 67, 64, 30, 3]</em> are in the unspent-transaction-output (UTXO) model (popularized by Bitcoin), where the inputs to a new transaction are the unspent outputs of previous transactions. UTXOs are not well-suited for applications that need to maintain some state <em>[19]</em>, so smart-contract platforms like Ethereum operate in the account-based model.</p>

    <p class="text-gray-300">Another drawback of UTXO-based mechanisms is that though they have been proposed to fix privacy issues with Bitcoin, they actually require major changes to Bitcoin’s design and have spun off into separate crypto-currencies. An important benefit of powerful platforms like Ethereum is that the platform’s core capability itself can be enhanced by deploying new applications. Payment channels, for instance, can be deployed to improve throughput. So perhaps we can deploy a new payment application to improve confidentiality of not just payments but potentially other applications too.</p>

    <p class="text-gray-300">It is still conceivable that one of the UTXO-based mechanisms could be implemented over a contract. However, this approach suffers from multiple issues including storage cost, lower confidentiality, interoperability with other contracts, and adoption. We discuss the issues in depth in Appendix A.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Zether</h3>

    <p class="text-gray-300">In this paper, we propose an efficient, fully-decentralized confidential payment mechanism in the account-based model called <em>Zether</em>, which does not require any changes to the design of the underlying smart contract platform like Ethereum. We describe Zether as a smart contract that can be executed either individually or by other smart contracts to exchange confidential amounts of a token, denoted by ZTH. The techniques used in Zether can apply to other account-based crypto-currencies, completely independent of their consensus mechanisms.</p>

    <p class="text-gray-300">Our contributions can be summarized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Confidentiality</em> Transactions on Zether are confidential by design. Account balances are kept encrypted at all times and users provide cryptographic proofs to spend ZTH.</li>

      <li><em>Zero-knowledge proofs</em> Zether uses zero-knowledge (ZK) proofs as an important building block. To efficiently instantiate Zether, we propose a new ZK-proof mechanism, called <span class="math">\\Sigma</span>-Bullets, which enhances the interoperability of <span class="math">\\Sigma</span>-protocols <em>[29]</em> and Bulletproofs <em>[17]</em>. This allows us to efficiently combine Bulletproofs-based range proofs with ElGamal encryptions. (<span class="math">\\Sigma</span>-Bullets could be useful in other settings too.)</li>

      <li><em>Implementation</em> We implement Zether as an Ethereum smart contract and measure the gas amount required for executing it. We show that Zether is practical today and with already-planned enhancements to Ethereum will become even more efficient. As part of our implementation, we provide an efficient implementation of Bulletproofs <em>[17]</em> on Ethereum which is of independent interest.</li>

      <li><em>Interoperability</em> Zether provides a way to lock funds in an account to a smart contract, making it easy to <em>add</em> confidentiality to several important applications. We show how Zether can be used in a natural way to build four applications: sealed-bid auction, confidential payment channel, confidential stake-voting, and private proof-of-stake.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Anonymity</em> We describe an extension to Zether that can also hide the sender and receiver involved in a transaction among a group of users chosen by the sender. Though the overhead associated with anonymity scales linearly with the size of the group, no trusted set-up is needed and no changes to the underlying smart contract platform are required. Thus, Zether anonymity guarantee is more similar to Monero <em>[68]</em> than Zcash <em>[93]</em>, but in the account model.</li>

    </ul>

    <p class="text-gray-300">Organization. The rest of the paper is organized as follows. We provide some background on Ethereum in Section 2, with a focus on smart contract execution. Section 3 provides an overview of the Zether payment mechanism, its use in other applications, and the new ZK-proof system. Section 4 defines the cryptographic tools we need for Zether. It then formally defines the notion of a payment mechanism in a smart-contract world, and the security properties it should satisfy. Section 6 provides a detailed description of Zether. Section 7 describes our implementation in Solidity, its evaluation, various optimizations, etc. Section 8 shows how Zether can be used with smart contracts to get more privacy. Section 9 discusses the work related to Zether.</p>

    <p class="text-gray-300">We describe an anonymous version of Zether in detail in Appendix D. Appendix F has some discussion on important matters related to the use of Zether. Finally, Appendix G has a thorough discussion of <span class="math">\\Sigma</span>-Bullets.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Background on Ethereum</h2>

    <p class="text-gray-300">Accounts are Ethereum’s basic units. There are (a) <em>externally-owned accounts (EOAs)</em>, controlled by private keys and (b) <em>contract accounts</em>, controlled by their code. Both types of accounts have an ether balance, denominated in units of <em>wei</em>: 1 ether is 1e18 wei. The Ethereum blockchain tracks the state of every account <em>[39, 91]</em>. State changes are initiated through <em>transactions</em> coming from EOAs. A transaction consists of the destination account address, a signature <span class="math">\\sigma</span>, the transferred amount in wei, an optional data field representing inputs to a contract, a gasLimit value, and a gasPrice value. Every EOA is associated with a nonce, a counter that increments with every transaction. The signature <span class="math">\\sigma</span> signs the transaction and the sender’s nonce. During transaction processing, <span class="math">\\sigma</span> is verified against the nonce value. As a result, transactions cannot be “replayed” on the Ethereum network <em>[39]</em>.</p>

    <p class="text-gray-300">A transaction can transfer wei between accounts or trigger the execution of smart contract code. Contracts can send messages to other contracts, mimicking function calls. Every transaction and code execution is replicated on all nodes in the network. Every executed operation has a specified cost expressed in terms of <em>gas</em> units. For example, storing 256 bits of data costs 20,000 units of gas while changing it costs 5,000 and reading it costs 200 <em>[91]</em>. The sender pays for all contract operations that the transaction calls.</p>

    <p class="text-gray-300">The sender sets gasLimit field to the total amount of gas she is willing to spend for a transaction, and the gasPrice field to the amount of wei she is willing to pay per unit of gas. A miner, that is happy with the gas price, can include the transaction in a block and collect the fee. If the gas limit falls short of the gas needed to process the transaction, the miner will collect the fee but not change the blockchain’s state. Excess fees are refunded to the account that issued the transaction <em>[91]</em>.</p>

    <p class="text-gray-300">The total gas consumed by all transactions in a block is limited. This ensures that the time needed for processing and propagating a block remains sufficiently small, allowing for an adequately-decentralized network. Currently that limit is around 8 million gas units. Simple arithmetic operations cost 3 gas units and the average block time is 15s. The total Ethereum network can, therefore, perform less than 180k arithmetic operations per second. Some complex operations, e.g., the Keccak 256-bit hash function, however, do not need to be arithmetized but are provide as a standalone functionality at a reduced cost (36 gas for a 32 byte hash) <em>[91]</em>.</p>

    <p class="text-gray-300">Contracts are written in specific programming languages such as Solidity <em>[85]</em>. Once compiled to bytecode, the contract can be read and executed by the <em>Ethereum virtual machine (EVM)</em>, a sandboxed and isolated runtime environment. The EVM has access to a global persistent storage system and each contract account has separate storage available to it.</p>

    <p class="text-gray-300">In Ethereum, transactions are processed individually in an arbitrary order. Therefore, it is important to ensure that contract codes are written properly so that unexpected outcomes are avoided when a</p>

    <p class="text-gray-300">common part of the EVM state is changed by two or more transactions <em>[56]</em>. The low computational power, along with the asynchronous transactional nature of the Ethereum network make programming complicated smart contracts a delicate endeavor.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3 Overview of Zether</h2>

    <p class="text-gray-300">In this section, we provide an overview of the Zether payment mechanism, its use in other applications, and the new ZK-proof system.</p>

    <p class="text-gray-300">Commitment vs encryption. Several proposals for making transactions confidential use homomorphic commitments, such as Pedersen commitments <em>[69]</em>. Though they are simple and efficient, the opening of these commitments must be transferred to the receiver, say Bob, so that he can spend the money later. This randomness could be stored on-chain in some encrypted manner or sent directly to Bob through a separate channel. In the UTXO model, if Bob is unable to recover the randomness (an incorrect value was encrypted/sent, nothing sent at all, etc.), then it cannot spend the UTXO later. However, other UTXOs controlled by Bob are not affected at all and could still be spent. On the other hand, with an account-based model, since all the incoming transfers go into the same account, failure to recover the randomness for even a single transfer could render the whole account unusable.</p>

    <p class="text-gray-300">One could require senders to encrypt the randomness under receivers’ public key, and prove that the commitment indeed uses the randomness encrypted. We take a more direct and simpler approach here using ElGamal encryption with messages in the exponent <em>[27]</em>. The encryption scheme has linear encoding properties, i.e., it is homomorphic, which we utilize to create efficient ZK-proofs of correct encryption. We describe the encryption scheme in Section 4.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 Building Zether</h3>

    <p class="text-gray-300">Zether strives not just to make transfers confidential but also to prevent accidental loss of funds. We first discuss a simplistic version of Zether with the core functionality. We then describe some shortcomings and how to overcome them.</p>

    <p class="text-gray-300">A simplistic Zether. The Zether smart contract (ZSC) works with Zether tokens (ZTH). Zether accounts are identified with ElGamal public keys, which are stored in ZSC’s internal state. To fund an account with public key <span class="math">y</span> with <span class="math">b</span> ZTH, one can send <span class="math">b</span> ETH to the smart contract. ZSC generates an ElGamal encryption of <span class="math">b</span> with randomness <span class="math">0</span> (since <span class="math">b</span> is anyway part of the transaction) and <em>adds</em> it to the encrypted balance associated with <span class="math">y</span>. One can convert ZTH back to ETH by revealing the current balance <span class="math">b^{\\star}</span> and providing a ZK-proof that <span class="math">y</span>’s ciphertext (i.e., the ciphertext associated with <span class="math">y</span> on the smart contract) indeed encrypts <span class="math">b^{\\star}</span>.</p>

    <p class="text-gray-300">In order to transfer some <span class="math">b</span> amount of ZTH to a public key <span class="math">y^{\\prime}</span> without revealing <span class="math">b</span> itself, one can encrypt <span class="math">b</span> under <em>both</em> <span class="math">y</span> and <span class="math">y^{\\prime}</span>. A ZK-proof is provided to show that the two ciphertexts are well-formed, they encrypt the same positive value, and the remaining balance associated with <span class="math">y</span> is positive. In our implementation, we use a new ZK-proof system, called <span class="math">\\Sigma</span>-Bullets to efficiently prove the statements over the encrypted transfer balance and the new sender balance.</p>

    <p class="text-gray-300">Front-running. The very first problem with the simplistic version of Zether is that the ZK-proofs are generated w.r.t. a certain state of the contract. For example, the ZK-proof in a transfer transaction needs to show that the remaining balance is positive. A user Alice generates this proof w.r.t. to her current account balance, stored in an encrypted form on the contract. However, if another user Bob transfers some ZTH to Alice, and Bob’s transaction gets processed first, then Alice’s transaction will be rejected because the proof will not be valid anymore. Note that Bob may be a totally benign user yet Alice loses the fees she paid to process her transaction. We refer to this situation as the <em>front-running</em> problem. Burn transactions have a similar problem too: a proof that a ciphertext encrypts a certain value becomes invalid if the ciphertext changes.</p>

    <p class="text-gray-300">To solve this problem, one could introduce a new type of transaction that just locks an account to keep away incoming transfers. Alice could wait until this transaction gets into the blockchain before initiating an outgoing transfer (or doing a burn). While this seems to fix the problem (at the cost of making transfer, the primary transaction, a two-step process), it creates new problems for users like Bob who want to send ZTH to Alice. Alice’s account may not be locked when Bob publishes a transfer transaction tx, but it could get locked before tx gets in, resulting in tx being rejected.</p>

    <p class="text-gray-300">Any kind of locking approach becomes more untenable when we bring in anonymity. (We will discuss anonymity in more detail at the end of this section.) If Alice wants to hide herself among other users and make sure that her transaction gets through, she will have to lock <em>all</em> the accounts in the anonymity set. Clearly, this cannot be allowed: Alice must not be able to lock accounts of other users. Alternatively, Alice could only put locked accounts in her anonymity set. However, if someone unlocks their account before Alice’s transaction gets in, Alice’s degree of anonymity is reduced.</p>

    <p class="text-gray-300">Pending transfers. To address the front-running problem, we keep all the incoming transfers in a <em>pending</em> state. These transfers are rolled over into the accounts from time to time so that the incoming funds could be spent. This rollover cannot happen at arbitrary times, otherwise the proofs would get invalidated again.</p>

    <p class="text-gray-300">To handle this, we divide time into <em>epochs</em> where an epoch consists of <span class="math">k</span> consecutive blocks. The choice of <span class="math">k</span> depends on two factors: a) the gap between the latest state of blockchain and any user’s view, and b) the time it takes to get a transaction into the blockchain. At the end of every epoch, pending transfers are rolled over into the corresponding accounts. Users are expected to publish their transfer or burn transaction at the beginning of an epoch so that even if they do not see the latest state of the blockchain and it takes some time for their transaction to be included, they do not step into the next epoch. As long as <span class="math">k</span> is chosen wisely, transactions will be processed before the account changes state.</p>

    <p class="text-gray-300">Rolling over on a smart contract. Unfortunately, rolling over accounts is not as straightforward as it may appear because a smart contract does not do anything unless a transaction is sent to it. One cannot expect every user to send a rollover message for every epoch. Moreover, there is no way they will be able to get such a message in at the right time.</p>

    <p class="text-gray-300">A first idea is to rollover the pending transfers for <em>all</em> accounts on the receipt of the first message in an epoch. This, however, places an unreasonably large burden on the sender of that message: it will have to pay for the cost of rolling over the accounts that it does <em>not</em> own, which could be too many. Furthermore, users would have no way to know if their transaction would be the first in an epoch, so they cannot estimate the right amount of gas to supply.</p>

    <p class="text-gray-300">We rollover an account in an epoch when the first message from <em>this</em> account is received; so, one message rolls over only one account. To achieve this, we define a separate (internal) method for rolling over, and the first thing every other method does is to call this method. There could be accounts that do not get rolled over for several consecutive epochs because no transaction is initiated from them. This is not a problem because the account holder, say Alice, is not trying to use her money anyway. At some later point in time, when Alice wants to operate on her account, she will publish a transaction. All the money transferred into her account since the last rollover will be rolled over immediately and become available to be spent. Indeed, when Alice creates a ZK-proof, she will assume the state of her account to be what it would be when all the pending transfers are rolled over into it.</p>

    <p class="text-gray-300">Replay protection. Like any other payment mechanism, Zether needs to handle replay attacks. Ethereum provides replay protection of its own by associating nonces with every account, which need to be signed into every transaction. Unfortunately, this level of protection is not enough for Zether due to two reasons: (1) Zether accounts have their own public keys; they are not associated with Ethereum addresses. (2) Zether transactions contain <em>non-interactive</em> ZK-proofs. A malicious actor can steal these proofs and put them inside new transactions. If the state of the account has not changed, then the new transactions will also be processed successfully, leading to loss of funds. Later in this section, we will discuss another important feature of Zether: locking accounts to other smart contracts. Even if the request to lock a Zether account shows knowledge of the secret key, and the account is unlocked later, an adversarial entity could lock the account again by just replaying the request.</p>

    <p class="text-gray-300">To protect against such issues, we associate a nonce with every Zether account. The nonces are incremented as transactions are processed. A new transaction from an account must sign the latest value of the nonce associated with the account along with the transaction data, which includes any ZK-proof. This approach binds all components of a transaction together and ensures freshness. ZK-proofs cannot be imported into malicious transactions and valid transactions cannot be replayed.</p>

    <p class="text-gray-300">One way wonder if there is a way to use Ethereum addresses themselves as the identities of Zether accounts. The accounts would then be operated with the secret keys corresponding to the addresses, and we would get replay protection and signature verification for free. However, this would force users to operate a Zether account from a fixed Ethereum address. They would not be able to delegate the account to a different address, like when locking the account to a smart contract (which will be discussed in more detail later). Furthermore, Ethereum addresses are only a hash of public keys, not the full form. Proving statements about hashes in zero-knowledge is quite expensive. Lastly, having separate public keys for Zether accounts also helps make the design more modular and platform-independent.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Anonymity.</h5>

    <p class="text-gray-300">Zether can be extended to transfer anonymously. An anonymous version of Zether needs a more complex ZK-proof, a new replay and double-spend protection mechanism, and a different mechanism to lock accounts to smart contracts. We defer the discussion to Appendix D.1.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.2 Interoperability with Smart Contracts</h3>

    <p class="text-gray-300">A main design goal for Zether is to be interoperable with arbitrary smart contracts, which may contain bugs or even be maliciously designed. An important distinction between regular users and smart contracts is that contracts cannot generate ZK-proofs because they do not have any secret state. As a result, they cannot initiate a ZTH transfer.</p>

    <p class="text-gray-300">We make Zether interoperable with other smart contracts by exposing a lock/unlock functionality. To illustrate, suppose Alice owns an account acc. She can <em>lock</em> acc to any arbitrary smart contract, say <span class="math">SC</span>. In effect, this transfers the ownership of acc to <span class="math">SC</span>. Now, Zether will process only those transactions on acc that come from <span class="math">SC</span>. Any transactions sent by Alice, other users or other contracts will simply be declined. ZK-proofs, however, would still be generated by Alice if needed, and transferred to the Zether smart contract via <span class="math">SC</span>. <span class="math">SC</span> can finally <em>unlock</em> acc to return its control to Alice.</p>

    <p class="text-gray-300">Even this simple locking mechanism can help us realize several important applications in a confidential way. We provide a brief discussion here and defer details to Section 8</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Sealed-bid auctions.</h5>

    <p class="text-gray-300">Auctions are used to sell a wide variety of resources on Ethereum <em>[88]</em>. A primary example is the Ethereum Name Service (ENS) <em>[36]</em>. In the ENS bidding phase, a bidder submits a hash of her bid along with an amount of ether. ENS suggests that the amount should be higher than the bid value to disguise the true value of the bid. There are several drawbacks to this approach including that it reveals a good upper-bound to bid value. Using Zether, bidders can simply lock their accounts (or transfer the bid value to a new account and lock that) to the auction contract, thus getting full bid confidentiality. No other collateral needs to be put in place. After the bidding phase, bidders can open their bids by providing a ZK-proof on the encrypted bid value (a <em>burn</em> proof essentially). The auction smart contract can then simply unlock the accounts of the bidders who lost.</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">Confidential payment channels.</h5>

    <p class="text-gray-300">Payment channels are widely considered to be one of the most important solutions to the scalability problem of crypto-currencies. On Ethereum, they can be set up very easily through smart contracts. A certain amount of ether is locked into the contract, transfers are conducted off-the-chain between the parties, and then a final settlement is made on chain. This clearly reveals a lot of information, but Zether can be used to prevent it. A Zether account could be locked to the channel contract and ZK-proofs could be exchanged offline to show that the channel has enough liquidity. Thus, we have a simple way to make channels confidential.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Stake voting.</h5>

    <p class="text-gray-300">Several blockchain-based voting protocols have been proposed to deal with the transparency issues of traditional voting systems. An important example is the Open Vote Network of McCorry et al. <em>[61]</em>. Here, the vote values are binary: participants publish a special encryption of</p>

    <p class="text-gray-300">their votes and prove that they are 0 or 1. With Zether, we can allow the votes to carry weights, proportional to the assets a participant owns. Once again, this can be achieved by just locking account to the vote contract and proving in zero-knowledge that the vote value is equal to the amount locked.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof-of-stake.</h6>

    <p class="text-gray-300">Proof-of-stake is a popular alternative to the wasteful proof-of-work consensus mechanism. Users <em>stake</em> a number of coins and then a random beacon is used to select one of them as leader. This reveals the stake of users, making them susceptible to targeted attacks. Zether could be used to make proof-of-stake confidential. At a high level, users could encrypt an initial lottery ticket <span class="math">t</span> under their public key and stake an encrypted Zether balance <span class="math">b</span> under the same key. Then the random beacon value is used to derive a lottery drawing <span class="math">v</span>. If <span class="math">v</span> falls between <span class="math">t</span> and <span class="math">t+b</span> then the user wins the lottery, which it can prove without revealing <span class="math">t</span> or <span class="math">b</span>. See Section 8.4 for details.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.3 <span class="math">\\Sigma</span>-Bullets</h3>

    <p class="text-gray-300">Zether ensures that encrypted transactions are correct by using ZK-proofs that certify correctness without revealing any additional information. We design a custom proof system called <span class="math">\\Sigma</span>-Bullets that is well-suited for Zether. <span class="math">\\Sigma</span>-Bullets integrate Bulletproofs <em>[17]</em> with <span class="math">\\Sigma</span>-protocols to enable efficient proofs on algebraically-encoded values such as <span class="math">\\exists x:g^{x}=y\\wedge h^{x}=u\\in\\mathbb{G}</span>. Bulletproofs on the other hand is a circuit proof system that is well suited for range proofs and other more complicated arithmetic statements. Bulletproofs does enable proofs on Pedersen committed values if all values use the same commitment key. With <span class="math">\\Sigma</span>-Bullets we can prove complex statements on algebraically encoded data. For example, we can efficiently prove that a set of ElGamal encrypted values are in some range. Further, we combine one-out-of-many proofs<em>[49]</em>, also known as ring signatures, with range proofs to allow anonymous transfers. The one-out-of-many proof is a <span class="math">\\Sigma</span>-protocol that hides which account is being used. Bulletproof is then used to show that the account has sufficient funds for the transfer. The protocol is similar to the techniques used in QuisQuis<em>[43]</em>. QuisQuis first shows that a Pedersen commitment contains the same value as an ElGamal encryption and then executes the Bulletproof on the ElGamal encrypted values. <span class="math">\\Sigma</span>-Bullets more directly incorporates the <span class="math">\\Sigma</span>-protocol with the Bulletproof protocol.</p>

    <p class="text-gray-300"><span class="math">\\Sigma</span>-Bullets inherit from Bulletproofs the trapdoor-free setup and the short, logarithmic sized, proof lengths. The ability to prove statements on encrypted values further significantly reduces the prover and verifier time compared to a naive implementation using Bulletproofs. We describe <span class="math">\\Sigma</span>-Bullets in detail in Appendix G.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Notation and Tools</h2>

    <p class="text-gray-300">We use <span class="math">\\lambda</span> to denote the security parameter. Let GroupGen be a polynomial-time algorithm that on input <span class="math">1^{\\lambda}</span> outputs <span class="math">(p,g,\\mathbb{G})</span> where <span class="math">p=\\Theta(\\lambda)</span>, <span class="math">p</span> is prime, <span class="math">\\mathbb{G}</span> is a group of order <span class="math">p</span>, <span class="math">g</span> is a generator of <span class="math">\\mathbb{G}</span>, and the decisional Diffie-Hellman (DDH) assumption holds in <span class="math">\\mathbb{G}</span>. The DDH assumption states that a tuple <span class="math">(g,g^{a},g^{b},g^{a\\cdot b})</span> is computationally indistinguishable from <span class="math">(g,g^{a},g^{b},g^{c})</span> for random <span class="math">a,b,c</span>. It implies the discrete logarithm assumption.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{Z}_{p}</span> denote the integers modulo <span class="math">p</span>. <span class="math">\\mathbb{Z}_{p}^{\\star}</span> is the set of inverses in <span class="math">\\mathbb{Z}_{p}</span>. We use <span class="math">[a,b]</span> for <span class="math">a,b\\in\\mathbb{Z}</span> to denote the set of integers <span class="math">\\{a,a+1,\\ldots,b-1,b\\}</span>.</p>

    <p class="text-gray-300">We use <span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}S<span class="math"> to denote that </span>x<span class="math"> is sampled uniformly at random from a set </span>S<span class="math">. We use PPT as a shorthand for probabilistic polynomial time and </span>\\mathsf{negl}(\\lambda)$ to denote negligible functions.</p>

    <p class="text-gray-300">ElGamal encryption. ElGamal encryption is a public key encryption scheme secure under the DDH assumption. A random number from <span class="math">\\mathbb{Z}_{p}^{\\star}</span>, say <span class="math">x</span>, acts as a private key, and <span class="math">y=g^{x}</span> is the public key corresponding to that. To encrypt an integer <span class="math">b</span>, it is first mapped to one or more group elements. If <span class="math">b\\in\\mathbb{Z}_{p}</span>, then a simple mapping would be to just raise <span class="math">g</span> to <span class="math">b</span>. Now, a ciphertext for <span class="math">b</span> is given by <span class="math">(g^{b}y^{r},g^{r})</span> where <span class="math">r\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{Z}_{p}^{\\star}<span class="math">. With knowledge of </span>x<span class="math">, one can divide </span>g^{b}y^{r}<span class="math"> by </span>(g^{r})^{x}<span class="math"> to recover </span>g^{b}<span class="math">. However, </span>g^{b}<span class="math"> needs to be brute-forced to compute </span>b$.</p>

    <p class="text-gray-300">We argue that this is not an issue. First, as we will see, the Zether smart contract does not need to do this, only the users would do it. Second, users will have a good estimate of ZTH in their accounts</p>

    <p class="text-gray-300">because, typically, the transfer amount is known to the receiver. Thus, brute-force computation would occur only rarely. Third, one could represent a large range of values in terms of smaller ranges. For instance, if we want to allow amounts up to 64 bits, we could instead have 2 amounts of 32 bits each, and encrypt each one of them separately. In this paper, for simplicity, we will work with a single range, 1 to MAX, and set MAX to be <span class="math">2^{32}</span> in the implementation.</p>

    <p class="text-gray-300">The primary benefit of putting balances in exponent is that it makes ElGamal encryption additively homomorphic. If <span class="math">b</span> and <span class="math">b^{\\prime}</span> are encrypted under the same public key <span class="math">y</span> to get ciphertexts (<span class="math">C_{L}=g^{b}y^{r},C_{R}=g^{r}</span>) and (<span class="math">C_{L}^{\\prime}=g^{b^{\\prime}}y^{r^{\\prime}},C_{R}^{\\prime}=g^{r^{\\prime}}</span>) respectively, then (<span class="math">C_{L}C_{L}^{\\prime}=g^{b+b^{\\prime}}y^{r+r^{\\prime}},C_{R}C_{R}^{\\prime}=g^{r+r^{\\prime}}</span>) is an encryption of <span class="math">b+b^{\\prime}</span> under <span class="math">y</span>.</p>

    <p class="text-gray-300">Zero-knowledge proofs. A zero-knowledge (ZK) proof of a statement does not reveal any information beyond the validity of the statement. For example, one could prove that two ciphertexts encrypt the same message without revealing the message itself. Though any NP statement can be proved in zero-knowledge, the concrete costs depend on a number of factors.</p>

    <p class="text-gray-300"><span class="math">\\Sigma</span> protocols are honest-verifier public-coin zero-knowledge interactive proofs of a special form. Very efficient <span class="math">\\Sigma</span> protocols exist for proving a wide variety of algebraic statements like knowledge of <span class="math">b</span> and <span class="math">r</span> s.t. an ElGamal ciphertext encrypts <span class="math">b</span> with randomness <span class="math">r</span>. The Fiat-Shamir transform is a way of transforming any public-coin honest-verifier ZK-proof (like <span class="math">\\Sigma</span> protocols) into a <em>non-interactive</em> zero-knowledge <em>proof of knowledge</em> in the random oracle model.</p>

    <p class="text-gray-300">A ZK-proof for the statement</p>

    <p class="text-gray-300"><span class="math">\\mathsf{st}:\\{(a,b,c,\\ldots;x,y,z,\\ldots):f(a,b,c,\\ldots,x,y,z,\\ldots)\\}</span></p>

    <p class="text-gray-300">means that the prover shows knowledge of <span class="math">x,y,z,\\ldots</span> such that <span class="math">f(a,b,c,\\ldots,x,y,z,\\ldots)</span> is true, where <span class="math">a,b,c,\\ldots</span> are public variables. We use <span class="math">\\mathsf{st}[a,b,c,\\ldots]</span> to denote an instance of <span class="math">\\mathsf{st}</span> where the variables <span class="math">a,b,c,\\ldots</span> have some fixed values.</p>

    <p class="text-gray-300">We represent a non-interactive ZK (NIZK) proof system with algorithms (Setup_{nizk}, Prove, Verify_{nizk}), where Setup_{nizk} outputs some public parameters, Prove generates a proof for a statement given a witness, and Verify_{nizk} checks if the proof is valid w.r.t the statement. Zether uses NIZKs that are a) correct, an honest prover can produce a valid proof b) zero-knowledge, a verifier learns nothing from the proof but the validity of the statement, and c) sound, a computationally bounded prover cannot convince a verifier of a false statement. <span class="math">\\Sigma</span> protocols, with the Fiat-Shamir transform applied, have all these properties.</p>

    <p class="text-gray-300">Digital signatures. Signature schemes are used to authorize messages by <em>signing</em> them. A verifier can check a signature but will be unable to forge a signature on a previously unsigned message. Signatures can be built from Fiat-Shamir transformed NIZK proofs <em>[2]</em>.</p>

    <p class="text-gray-300">We represent a signature scheme with algorithms (Setup_{nizk}, Sign, Verify_{nizk}), where Setup_{nizk} outputs some public parameters, Sign generates a signature on an input message, and Verify_{nizk} checks if the signature is valid w.r.t. the message. Zether requires a signature scheme that is a) correct, it is possible to create valid signatures on arbitrary messages and b) existentially unforgeable, a computationally bounded adversary can’t create a valid signature on a <em>new</em> message, even after seeing signatures on other messages.</p>

    <p class="text-gray-300">We omit formal definitions for brevity and refer to <em>[11]</em> for a thorough treatment of the properties.</p>

    <h2 id="sec-15" class="text-2xl font-bold">5 Payment Mechanism</h2>

    <p class="text-gray-300">A payment mechanism for Ethereum consists of a setup routine, user algorithms, and a smart contract. The contract maintains a state <span class="math">\\mathsf{st}</span> which changes over time. The state at block height <span class="math">h</span> is denoted by <span class="math">\\mathsf{st}_{h}</span>. Users rely on the state of the smart contract to create transactions. A user account is identified by a public key <span class="math">\\mathsf{pk}</span>. Let MAX be the maximum amount of money that the mechanism can handle. Any amount below must be an integer between 0 and MAX.</p>

    <p class="text-gray-300">The payment mechanism also provides a way to lock funds of an account to an Ethereum address addr so that the address can control the movement of funds through the account, until the lock is released. In Section 8, we will use the locking/unlocking feature to bring privacy to several commonly used smart contracts.</p>

    <p class="text-gray-300">The term <em>transaction</em> is used in Ethereum to refer to a signed data package that stores a message to be sent from an externally owned account to another account on the blockchain. It can include binary data (its payload) and Ether. If the target account contains code, that code is executed and the payload is provided as input data. For a transaction tx, we use tx.ETH to denote the amount of ether being sent through tx.</p>

    <p class="text-gray-300">Contracts can call other contracts or send Ether to non-contract accounts by the means of <em>message calls</em>. The message call most relevant to us is msg.sender.transfer (in the syntax of Solidity) which transfers a certain amount of Ether from a contract to the sender who called it. For a transaction tx that calls a function <span class="math">f</span> on a contract, we use <span class="math">f(\\texttt{tx}).\\texttt{ETH}</span> to denote the amount of Ether successfully sent back to the caller when <span class="math">f</span> is executed with tx. (In Figure 5 and Figure 2, where we describe the details of our Zether instantiation, we use a programming oriented, Solidity inspired, syntax as defined in Table 1.)</p>

    <p class="text-gray-300">We are now ready to describe the various components of a payment mechanism.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Setup.</h4>

    <p class="text-gray-300">In the setup phase, some public parameters are generated. They could be distributed off-chain or put into the smart contract (described below). The smart contract is also deployed.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">User algorithms.</h4>

    <p class="text-gray-300">A user can run one of the following algorithms to interact with the smart contract. The output of these algorithms are <em>raw</em> transactions. We leave it implicit that they will be signed (using the public key of the Ethereum account from which they are sent) and destined to the Zether smart contract. Nonetheless, we use tx.addr to denote the Ethereum address addr from which tx was sent. All the algorithms get the security parameter as input but we show it explicitly only for the first one.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CreateAddress(<span class="math">1^{\\lambda}</span>) <span class="math">\\rightarrow</span> <span class="math">(\\texttt{sk},\\texttt{pk})</span>. CreateAddress provides a way for a user to uniquely identify itself to the smart contract. It takes (a unary representation of) the security parameter as input and outputs a secret key sk and a public key pk. We assume that pk is derived in a deterministic way from sk, and use pkOf(sk) to denote the public key that corresponds to sk.</li>

      <li>CreateFundTx(pk, amt) <span class="math">\\rightarrow</span> tx_{fund}. CreateFundTx is used to add funds to an account. It takes a public key pk and an amount amt as inputs. It outputs tx_{fund} = (pk, <span class="math">\\ldots</span>).</li>

      <li>CreateTransferTx(sk_{from}, pk_{to}, amt, st_{h}) <span class="math">\\rightarrow</span> tx_{trans}. CreateTransferTx is used to transfer money from one account to another. It takes a secret key sk_{from}, a destination public key pk_{to}, an amount amt, and the state of the smart contract st_{h} at a certain block height <span class="math">h</span> as inputs. It outputs tx_{trans}. (For anonymous transfers, this algorithm would also take a set AnonSet as input, which would contain both pkOf(sk_{from}) and pk_{to}. AnonSet would be a part of the output too.)</li>

      <li>CreateBurnTx(sk, st_{h}) <span class="math">\\rightarrow</span> tx_{burn}. CreateBurnTx is used to withdraw the entire balance from an account. It takes a secret key sk and a state st_{h} as inputs. It outputs tx_{burn} = (pkOf(sk), amt, <span class="math">\\ldots</span>).</li>

      <li>CreateLockTx(sk, addr, st_{h}) <span class="math">\\rightarrow</span> tx_{lock}. CreateLockTx is used to lock an account to an Ethereum address. It takes a secret key sk and an address addr as inputs. It outputs tx_{lock} = (pkOf(sk), addr, <span class="math">\\ldots</span>).</li>

      <li>CreateUnlockTx(pk) <span class="math">\\rightarrow</span> tx_{unlock}. CreateUnlockTx is used to unlock an account. It takes a public key pk as input. It outputs tx_{unlock} = (pk, <span class="math">\\ldots</span>).</li>

      <li>ReadBalance(sk, st_{h}) <span class="math">\\rightarrow</span> <span class="math">b</span>. ReadBalance is used to find the balance of an account. It takes a secret key sk and state st_{h} as inputs, and outputs an integer <span class="math">b</span></li>

    </ol>

    <p class="text-gray-300">Smart contract. The smart contract has five functions Fund, Transfer, Burn, Lock and Unlock. They take <span class="math">\\mathsf{tx}_{\\mathsf{fund}}</span>, <span class="math">\\mathsf{tx}_{\\mathsf{trans}}</span>, <span class="math">\\mathsf{tx}_{\\mathsf{burn}}</span>, <span class="math">\\mathsf{tx}_{\\mathsf{lock}}</span> and <span class="math">\\mathsf{tx}_{\\mathsf{unlock}}</span>, respectively. These functions output <span class="math">1</span> or <span class="math">0</span>, denoting success and failure respectively. If any of the inputs are not of the correct type the function automatically fails. Moreover the functions check certain properties of the input, such as verifying a proof or checking a nonce. If any of these checks fail, the function outputs <span class="math">0</span>. The five functions modify the state <span class="math">\\mathsf{st}</span> as needed. We use <span class="math">\\mathsf{SC}</span> as a shorthand for the smart contract.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SC}</span> has access to the current block height and the sender of every transaction. (In Solidity, the syntax for these are block.number and msg.sender, respectively.) It makes use of two constants: maximum amount value <span class="math">\\mathsf{MAX}</span> and epoch length <span class="math">\\mathsf{E}</span>, where <span class="math">\\mathsf{E}\\geq 1</span>. The epoch number of a block at height <span class="math">h</span> is defined to be <span class="math">\\lfloor h/\\mathsf{E}\\rfloor</span>. Thus, for example, the blocks at heights <span class="math">0,1,\\ldots,\\mathsf{E}-1</span> are in the first epoch, the ones at heights <span class="math">\\mathsf{E},\\mathsf{E}+1,\\ldots,2\\mathsf{E}-1</span> are in the second epoch, and so on.</p>

    <p class="text-gray-300">We now discuss informally the correctness and security requirements of a payment mechanism. See Appendix B and C for formal definitions. The definitions are for the more general case of anonymity, where not only the transfer amount but the sender/receiver are also hidden (among a chosen set of public keys).</p>

    <p class="text-gray-300">Correctness. Correctness captures the basic functionality a payment mechanism should provide if transactions are generated honestly but they could be sent from arbitrary Ethereum addresses and processed in an arbitrary order. We will assume, however, that if a transaction is generated in a certain epoch, then it gets processed in the same epoch. To illustrate, suppose Alice has <span class="math">X</span> <span class="math">\\mathsf{ZTH}</span> in her account. In an epoch <span class="math">e_{1}</span>, she publishes a transfer transaction to send <span class="math">Y\\leq X</span> <span class="math">\\mathsf{ZTH}</span> to someone else. There could be other users in the network who transfer to Alice at about the same time. Even if some of these transfers are processed before Alice’s, we don’t want her transfer to fail. Further, suppose Alice receives <span class="math">Z</span> <span class="math">\\mathsf{ZTH}</span> from others in <span class="math">e_{1}</span>. Then, in any epoch after <span class="math">e_{1}</span>, if she publishes a burn transaction with amount <span class="math">X-Y+Z</span>, then we would like her to get back that amount of <span class="math">\\mathsf{ETH}</span>.</p>

    <p class="text-gray-300">To specify correctness formally, we define the notion of an <em>ideal state</em> and describe how it evolves over time as honestly generated transactions are processed. The ideal state tracks the balance of every account and the Ethereum address (if any) to which it is locked. When a transaction is processed, the ideal state is updated depending on the type of transaction and the current state. Informally, we say that a payment mechanism is correct if whenever a burn transaction is processed for a certain account, the amount of Ether returned to the user is equal to the amount of Zether held in the <em>ideal state account</em>.</p>

    <p class="text-gray-300">Security requirements. We define two security requirements for a payment mechanism <span class="math">\\Pi</span>, overdraft-safety and privacy. Overdraft-safety ensures that users cannot misuse the smart contract to withdraw more money from their accounts that they rightfully own. Privacy of a payment-mechanism ensures that no additional information about the payments of honest parties beyond the intended is leaked to an adversary. In other words, only the sender and receiver of a payment should know the amount transferred in the payment. The formulation of overdraft-safety and privacy is inspired by Zerocash <em>[3]</em>.</p>

    <p class="text-gray-300">We define a game between a challenger <span class="math">\\mathsf{Chal}</span> and an adversary <span class="math">\\mathsf{Adv}</span> to capture the requirements, where <span class="math">\\mathsf{Chal}</span> represents the honest users in the network. Both <span class="math">\\mathsf{Chal}</span> and <span class="math">\\mathsf{Adv}</span> have access to an oracle <span class="math">\\mathcal{O}_{\\mathsf{SC}}</span> who maintains the smart contract <span class="math">\\mathsf{SC}</span>. <span class="math">\\mathsf{Adv}</span> has full view of the oracle: it can see all the transactions sent by <span class="math">\\mathsf{Chal}</span> to <span class="math">\\mathsf{SC}</span>, how the state of <span class="math">\\mathsf{SC}</span> changes, etc. We provide <span class="math">\\mathsf{Adv}</span> substantial control over <span class="math">\\mathsf{SC}</span>’s state. It can instruct any honest party at any time (via the challenger) to publish a transaction. It can create its own malformed transactions based on the transactions of honest parties, and then push the former into the blockchain ahead of the latter. In particular, it can arbitrarily delay the transactions of honest parties.</p>

    <p class="text-gray-300">For overdraft-safety, we associate some quantities with the game with respect to <span class="math">\\mathsf{Adv}</span>: <span class="math">\\mathsf{EtherDeposited}</span>, <span class="math">\\mathsf{ZetherReceived}</span> and <span class="math">\\mathsf{EtherBurnt}</span>, which have self-explanatory names. Informally, a payment mechanism is safe against overdrafts if</p>

    <p class="text-gray-300"><span class="math">\\mathsf{EtherDeposited}+\\mathsf{ZetherReceived}\\geq\\mathsf{EtherBurnt}.</span></p>

    <p class="text-gray-300">There are two important things to note here. First, it is not enough to just require that the <em>total</em> ether burnt (honest parties and adversary combined) should be no more than the <em>total</em> ether deposited</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Zether setup</p>

    <p class="text-gray-300">because it could still be possible that the adversary is able to burn more than its fair share. Second, we cannot take the more direct approach of computing the amount adversary can withdraw by just reading the balance of the accounts controlled by it from the smart contract because its secret keys are not available.</p>

    <p class="text-gray-300">We slightly modify the game discussed above to capture the privacy requirement. Instead of sending just one instruction to Chal every time (asking an honest party to create a transaction), Adv sends two consistent instructions at some point. Chal executes the  <span class="math">(b + 1)</span> -th instruction based on a bit  <span class="math">b</span>  hidden from Adv, which is chosen randomly in advance. Adv is supposed to guess  <span class="math">b</span>  at the end of the game. (This is the typical left-or-right setting used for indistinguishability-based definitions.) Consistency is defined carefully to rule out trivial wins for the adversary.</p>

    <p class="text-gray-300">We now present a secure payment mechanism called Zether. It consists of three components: a global setup algorithm that is run once to generate the global parameters for the protocol as well as to deploy the Zether smart contract. The second component is the Zether smart contract (ZSC) that handles transactions between users, interoperability with external smart contracts, and keeps the state of the system. The final component of the mechanism are the user algorithms which describe how users can interact with the smart contract and create valid transactions. A user is of course not bound to the behavior described in the user algorithms. Our security proof in Appendix E shows that even if an adversarial user does not comply with these algorithms, he can't break Zether's correctness, privacy and over-draft protections.</p>

    <p class="text-gray-300">Setup. The setup algorithm calls  <span class="math">\\text{Setup}_{\\text{nizk}}</span>  and  <span class="math">\\text{Setup}_{\\text{nizk}}</span>  as subroutines, which are the setup algorithms for the proof system and the signature scheme, respectively. The former setup could depend on the relations for which proofs are constructed. If these subroutines are trustless, then the whole setup is trustless, meaning that its correctness can be verified publicly. In the implementation (Section 7), we use Bulletproofs [17] and Schnorr signatures [82], both of which have a trustless setup. Zether significantly differs from Zcash [93] in this respect because Zcash has a trusted setup and its security is broken if the setup is subverted.</p>

    <p class="text-gray-300">Setup algorithm is formally described in Figure 1. Apart from setting up the proof system and signature scheme, it initializes account tables acc and pending transfers table pTransfers (recall that incoming transfers are put into a pending state first), a last roll over epoch table lastRollOver to keep track of the last epochs accounts were updated, a lock table lock to keep track of the addresses to which accounts are locked, a counter table ctr to prevent replay attacks, and a variable  <span class="math">b_{\\text{total}}</span>  that tracks the total amount of ZTH held by the contract. The setup also specifies an epoch length E and a maximum amount value MAX.</p>

    <p class="text-gray-300">Zero-knowledge relations. Each transfer and burn transaction in Zether contains a ZK-proof which ensures that the transfer is valid without revealing the reasons why it is valid.</p>

    <p class="text-gray-300">Burn transaction. Let us first consider a burn transaction where a user needs to verifiably decrypt his Zether balance. It can certainly do this by revealing its secret key to the smart contract. However, an adversary can use the secret key to decrypt all previous balances and transactions of the user, thus completely breaking its privacy. So, instead of decrypting in the clear, the user creates a ZK-proof for the following statement:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{st}_{\\mathsf{burn}}:\\left\\{(y,C_{L},C_{R},u,b,g,g_{\\mathsf{epoch}};\\mathsf{sk}):y=g^{\\mathsf{sk}}\\wedge C_{L}=g^{b}C_{R}^{\\mathsf{sk}}\\right\\}</span> (1)</p>

    <p class="text-gray-300">The statement shows that the user knows an <span class="math">\\mathsf{sk}</span> such that <span class="math">y</span> is indeed the public key corresponding to <span class="math">\\mathsf{sk}</span> and <span class="math">(C_{L},C_{R})</span> is a valid encryption of <span class="math">b</span> under <span class="math">y</span>. A simple <span class="math">\\Sigma</span> protocol can be used to prove the statement.</p>

    <p class="text-gray-300">Transfer transaction. Let us now consider a transfer transaction. Suppose a user wants to transfer an amount <span class="math">b^{\\star}</span> from a public key <span class="math">y</span> to a public key <span class="math">\\overline{y}</span>. Let <span class="math">(C_{L},C_{R})</span> be the encryption of balance associated with <span class="math">y</span>. The smart contract needs to deduct <span class="math">b^{\\star}</span> from <span class="math">y</span>’s balance and add the same amount to <span class="math">\\overline{y}</span>’s balance, which will be put into a pending state. Since we need to hide <span class="math">b^{\\star}</span> in this process, user will encrypt <span class="math">b^{\\star}</span> under both <span class="math">y</span> and <span class="math">\\overline{y}</span> to get <span class="math">(C,D)</span> and <span class="math">(\\overline{C},\\overline{D})</span>, respectively. Now, it must provide a proof to show that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>both ciphertexts are well formed and encrypt the same value <span class="math">b^{\\star}</span>;</li>

      <li><span class="math">b^{\\star}</span> is a positive value; and,</li>

      <li>the remaining balance of <span class="math">y</span>, say <span class="math">b^{\\prime}</span>, is positive too.</li>

    </ol>

    <p class="text-gray-300">More formally, a user proves the following statement:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{st}_{\\mathsf{ConfTransfer}}:\\left\\{(y,\\overline{y},C_{L},C_{R},C,D,\\overline{C},g;\\mathsf{sk},b^{\\star},b^{\\prime},r):\\right.</span> <span class="math">C=g^{b^{\\star}}y^{r}\\wedge\\overline{C}=g^{b^{\\star}}\\overline{y}^{r}\\wedge D=g^{r}\\wedge</span> <span class="math">\\left.C_{L}/C=g^{b^{\\prime}}\\left(C_{R}/D\\right)^{\\mathsf{sk}}\\wedge y=g^{\\mathsf{sk}}\\wedge\\right.</span> <span class="math">\\left.b^{\\star}\\in\\left[0,\\mathsf{MAX}\\right]\\wedge b^{\\prime}\\in\\left[0,\\mathsf{MAX}\\right]\\right\\}</span> (2)</p>

    <p class="text-gray-300">Kurosawa <em>[55]</em> first showed that in the ElGamal encryption scheme, randomness can be reused to encrypt to multiple recipients. We use the same idea here to make the zero-knowledge component more efficient: the same random number <span class="math">r</span> is used to encrypt <span class="math">b^{\\star}</span> under both <span class="math">y</span> and <span class="math">\\overline{y}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">block.number</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">current block number</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">msg sender</td>

            <td class="px-3 py-2 border-b border-gray-700">sender of the message (current call)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">msg.value</td>

            <td class="px-3 py-2 border-b border-gray-700">number of Wei sent with the message</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">address.transfer</td>

            <td class="px-3 py-2 border-b border-gray-700">send given amount of Wei to address</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">require</td>

            <td class="px-3 py-2 border-b border-gray-700">check conditions; current call reverts if condition fails</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Solidity syntax</p>

    <p class="text-gray-300">Zether contract. The Zether contract (ZSC) is defined in Figure 5. It consists of five public methods Fund, Burn, Transfer, Lock, Unlock and two additional internal helper methods RollOver, CheckLock. The helper methods are used to modularize the contract’s logic. We use Solidity syntax at some places in the description of ZSC, instead of introducing new notation; see Table 1 for the syntax we use and what it means. We now discuss ZSC’s methods in detail.</p>

    <p class="text-gray-300">Rolling over. Pending transfers for an account must be rolled over into the account every epoch, or at least in the epochs the account is used. However, no instruction on a smart contract can execute</p>

    <p class="text-gray-300">INPUTS: public key  <span class="math">y</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RollOver(y)</li>

      <li>Let  <span class="math">b = \\text{msg.value}</span></li>

      <li>require:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b + b_{\\text{total}} \\leq \\text{MAX}</span></li>

      <li>CheckLock(y, msg sender) = 1</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\operatorname{acc}[y] = \\bot</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">H =</span>  block.number,  <span class="math">e = \\lfloor H / \\mathsf{E} \\rfloor</span></li>

      <li>Set  <span class="math">\\operatorname{acc}[y] = (1, 1)</span></li>

      <li>Set pTransfers[y] = (gb, 1)</li>

      <li>Set lock[y] =  <span class="math">\\bot</span></li>

      <li>Set lastRollOver[y] = e</li>

      <li>Set  <span class="math">\\operatorname{ctr}[y] = 0</span></li>

    </ul>

    <p class="text-gray-300">Else:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set pTransfers[y] = pTransfers[y]  <span class="math">\\circ</span>  (gb, 1)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">b_{\\text{total}} = b_{\\text{total}} + b</span></li>

    </ol>

    <p class="text-gray-300">INPUTS:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sender public key  <span class="math">y</span></li>

      <li>recipient public key  <span class="math">\\overline{y}</span></li>

      <li>ciphertexts  <span class="math">(C, D)</span> ,  <span class="math">(\\overline{C}, D)</span></li>

      <li>proof  <span class="math">\\pi_{\\text{transfer}}</span></li>

      <li>signature  <span class="math">\\sigma_{\\text{transfer}}</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RollOver(y)</li>

      <li>RollOver  <span class="math">(\\overline{y})</span></li>

      <li>Let  <span class="math">(C_L, C_R) = \\operatorname{acc}[y]</span></li>

      <li>require:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CheckLock(y, msg sender) = 1</li>

      <li>Verify  <span class="math">_{n\\mathrm{izh}}(\\mathsf{st}_{\\mathrm{ConfTransfer}}[y,\\overline{y},C_L,C_R,C,\\overline{C},D],</span> <span class="math">\\pi_{\\mathrm{transfer}}) = 1</span></li>

      <li>Verify  <span class="math">_{n\\mathrm{izh}}(y,(\\overline{y},C,\\overline{C},D,\\pi_{\\mathrm{transfer}},\\mathrm{ctr}[y])</span> <span class="math">\\sigma_{\\mathrm{transfer}}) = 1</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\operatorname{acc}[y] = \\operatorname{acc}[y] \\circ (C^{-1}, D^{-1})</span></li>

      <li>Set pTransfers  <span class="math">[\\overline{y}] = \\mathsf{pTransfers}[\\overline{y}]\\circ (\\overline{C},D)</span></li>

      <li>Set  <span class="math">\\operatorname{ctr}[y] = \\operatorname{ctr}[y] + 1</span></li>

    </ol>

    <p class="text-gray-300">INPUTS:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>public key  <span class="math">y</span></li>

      <li>Ethereum address addr</li>

      <li>signature  <span class="math">\\sigma_{\\mathrm{lock}}</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RollOver(y)</li>

      <li>require:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CheckLock(y, msg sender) = 1</li>

      <li>Verify  <span class="math">_{n\\mathrm{izh}}(y,(\\mathrm{addr},\\mathrm{ctr}[y]),\\sigma_{\\mathrm{lock}}) = 1</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set lock[y] = addr</li>

      <li>Set  <span class="math">\\operatorname{ctr}[y] = \\operatorname{ctr}[y] + 1</span></li>

    </ol>

    <p class="text-gray-300">INPUTS:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>public key  <span class="math">y</span></li>

      <li>balance  <span class="math">b</span></li>

      <li>proof  <span class="math">\\pi_{\\mathrm{burn}}</span></li>

      <li>signature  <span class="math">\\sigma_{\\mathrm{burn}}</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RollOver(y)</li>

      <li>Let  <span class="math">(C_L, C_R) = \\operatorname{acc}[y]</span></li>

      <li>require:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CheckLock(y, msg sender) = 1</li>

      <li>Verify  <span class="math">_{n\\mathrm{izh}}(\\mathsf{st}_{\\mathrm{burn}}[y,C_L,C_R,b,g],\\pi_{\\mathrm{burn}}) = 1</span></li>

      <li>Verify  <span class="math">_{n\\mathrm{izh}}(y,(b,\\pi_{\\mathrm{burn}},\\mathrm{ctr}[y]),\\sigma_{\\mathrm{burn}}) = 1</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\operatorname{acc}[y] = \\operatorname{acc}[y] \\circ (C_L^{-1}, C_R^{-1})</span></li>

      <li>Set  <span class="math">\\operatorname{ctr}[y] = \\operatorname{ctr}[y] + 1</span></li>

      <li>Set  <span class="math">b_{\\text{total}} = b_{\\text{total}} - b</span></li>

      <li>Do msg sender transfer(b)</li>

    </ol>

    <p class="text-gray-300">INPUTS: public key  <span class="math">y</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RollOver(y)</li>

      <li>require:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CheckLock(y, msg sender) = 1</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\operatorname{lock}[y] = \\bot</span></li>

    </ol>

    <p class="text-gray-300">Internal Helper Methods</p>

    <p class="text-gray-300">INPUTS: public key  <span class="math">y</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">H =</span>  block.number,  <span class="math">e = \\lfloor H / \\mathsf{E}\\rfloor</span></li>

      <li>If lastRollOver[y] &lt; e:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\operatorname{acc}[y] = \\operatorname{acc}[y] \\circ p\\text{Transfers}[y]</span></li>

      <li>Set pTransfers[y] = (1, 1)</li>

      <li>Set lastRollOver[y] = e</li>

    </ul>

    <p class="text-gray-300">INPUTS:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>public key  <span class="math">y</span></li>

      <li>Ethereum address addr</li>

    </ul>

    <p class="text-gray-300">OUTPUT: 1 if account  <span class="math">y</span>  can be operated by addr; 0 otherwise</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\operatorname{lock}[y] = \\bot</span>  or  <span class="math">\\operatorname{lock}[y] = \\operatorname{addr}</span> :</li>

    </ol>

    <p class="text-gray-300">Output 1</p>

    <p class="text-gray-300">Else:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output 0</li>

    </ul>

    <p class="text-gray-300">Figure 2: ZSC: Zether smart contract</p>

    <p class="text-gray-300">unless triggered by a transaction. As a result, all public methods of ZSC first call RollOver on the input public key(s).</p>

    <p class="text-gray-300">Given a public key <span class="math">y</span>, RollOver checks if the last roll over was in an older epoch. If yes, then it rolls over the pending transfers pTransfers[<span class="math">y</span>] into acc[<span class="math">y</span>] and resets pending transfers as well as the last roll over epoch.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Check lock</h4>

    <p class="text-gray-300">Every transaction to operate on an account is associated with an Ethereum address (returned by msg.sender). If the account is unlocked, then it can be operated from any address. However, if it is locked to a certain address, then it can only be operated from that address. CheckLock is an internal methods to check these two conditions. All the methods call CheckLock before operating on an account.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Locking</h4>

    <p class="text-gray-300">Given a public key <span class="math">y</span>, an address addr and a signature <span class="math">\\sigma_{\\textsf{lock}}</span>, Lock checks if it is appropriate to operate on the account by calling CheckLock, which will be discussed in more detail shortly, and verifies that <span class="math">\\sigma_{\\textsf{lock}}</span> is a valid signature on addr and the current value of counter ctr[<span class="math">y</span>]. It sets lock[<span class="math">y</span>] to be addr and increments the counter, which ensures that this lock transaction cannot be replayed. Unlock method also calls CheckLock first, then sets the pending lock to be <span class="math">\\bot</span>.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Funding</h4>

    <p class="text-gray-300">Anybody can fund an account, even an account that he/she does not own, by simply specifying the public key <span class="math">y</span> and transferring some ETH. The only exception is for locked accounts; they can only be operated from the locking address. (One could have a different rule for funding locked accounts.) Fund converts ETH into ZTH. The ETH gets stored in the smart contract and the ZTH are homomorphically added to <span class="math">y</span>’s (pending) balance. If the account does not exist yet, a new one is created. Fund also ensures that the deposit does not exceed the total amount of funds, MAX, that Zether can handle.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Burn</h4>

    <p class="text-gray-300">Burn converts ZTH back to ETH. It verifies the proof <span class="math">\\pi_{\\textsf{burn}}</span> against st_{burn} (see (1)) to ensure that the sender knows the right private key and is claiming the right amount. It also checks a signature on the transaction data and the current value of counter, which prevents replay attacks. Note that a burn operation does not close an account.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Transfer</h4>

    <p class="text-gray-300">Transfer transfers some ZTH from an account to another. The proof <span class="math">\\pi_{\\textsf{transfer}}</span> makes sure that the ciphertext has the right form and the sender has enough money (see (2)). Similar to Burn, there is a signature here to prevent replay attacks.</p>

    <p class="text-gray-300">Note that the transferred amount is added to pTransfers of the recipient, not acc. (It will be rolled over into acc in a later epoch.) Thus, outgoing transfers of the recipient in this epoch will not be invalidated.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">User algorithms.</h4>

    <p class="text-gray-300">User algorithms specify how users can interact with ZSC. CreateTransferTx and CreateBurnTx first do a roll over of the input public keys to ensure that any pending transfers are rolled over. CreateBurnTx uses ReadBalance to recover the amount of ZTH in the account. Using the private key, ReadBalance finds the right <span class="math">b</span> s.t. <span class="math">C_{L}/C_{R}^{e}=g^{b}</span>. In typical cases, a user would <em>not</em> have to try all positive integers one by one to recover <span class="math">b</span>. She will already have a good estimate of <span class="math">b</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Anonymity.</h4>

    <p class="text-gray-300">Zether can be extended to transfer anonymously. We describe the extension in detail in Appendix D.2. We also discuss some important matters related to the use of Zether in Appendix F.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Proof of security.</h4>

    <p class="text-gray-300">We prove that Zether satisfies our security requirements in Appendix E. The proof is actually for the more general, anonymous version of Zether.</p>

    <h2 id="sec-34" class="text-2xl font-bold">7 Implementation & Evaluation</h2>

    <p class="text-gray-300">In order to properly evaluate the Zether protocol and show its feasibility we implemented basic Zether as an Ethereum smart contract. The implementation shows that Zether is feasible today and can be</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: User algorithms of Zether. CreateFundTx and CreateUnlockTx are straightforward, so not specified here.</p>

    <p class="text-gray-300">run on top of the Ethereum virtual machine. We also discuss several optimizations that we made in order to improve the performance of the contract. Further, we will analyze what small improvements to the EVM would significantly benefit Zether. Some of these improvements have been discussed independently and are already part of the Ethereum improvement proposal (EIP) track.</p>

    <p class="text-gray-300">We describe our Ethereum implementation of the basic Zether contract. The implementation was written in Solidity and makes use of several observations. Ethereum recently introduced precompiled contracts for elliptic-curve operations on the curve BN-128 [8]. These precompiled contracts reduce the cost of executing these operations compared to direct implementations. The reason is that miners can use specialized software, i.e., special cryptography libraries, to run these functions more efficiently. The operations were originally introduced to support pairing-based ZK-SNARKs.  <span class="math">\\Sigma</span> -Bullets do not require pairings and the curve BN-128 is not an optimal choice in terms of efficiency or security for Bulletproofs/ <span class="math">\\Sigma</span> -Bullets. Nevertheless, we chose to implement Zether using this curve because it is natively supported (precompiled contracts are far cheaper than a Solidity implementation of another curve such as secp256k1 [83].) As we explain in Section 7.3, this means that we have to rely on the DDH assumption in the  <span class="math">\\mathbb{G}_1</span>  group of BN-128. This assumption is called the external DDH or XDH assumption and is less general than the DDH assumption.</p>

    <p class="text-gray-300">Despite the precompiled contract, a majority of the gas cost lies in the cryptographic operations used, especially curve multiplication. We therefore aimed to reduce the number of exponentiations to an absolute minimum. We did this by implementing the optimizations presented in Section 6.2 of [17].</p>

    <p class="text-gray-300">We did not implement multi-exponentiation as this would not be beneficial. Multi-exponentiations reduce the number of curve operations but do this by splitting up the exponentiation. Multi-exponentiation algorithms assume that a  <span class="math">k</span> -bit exponentiation use  <span class="math">k</span>  curve operations. This is not the case for Solidity however. The gas cost for an exponentiation is independent of the exponents length and curve additions are relatively overpriced to curve multiplications. A curve multiplication is only 80 times more expensive than a curve addition even if the exponent has 256 bits. Therefore, multi-exponentiation would not lower but increase the gas cost.</p>

    <p class="text-gray-300">In a further optimization, we rolled out the inner product argument and combined all possible exponentiations into a single large statement. Furthermore, we slightly modified the recursive inner product argument such that it terminates at  <span class="math">n = 4</span>  instead of  <span class="math">n = 1</span> . By doing this, the prover has to send 6 more elements in  <span class="math">\\mathbb{Z}_p</span>  but on the other hand saves sending 4 Pedersen hashes which are elements in  <span class="math">\\mathbb{G}</span> . Since Solidity does not support point compression, i.e., points in  <span class="math">\\mathbb{G}</span>  are encoded using 64 bytes and scalars using 32 bytes, this small modification therefore saves 64 bytes in space and also reduces the number of curve exponentiations that need to be done. In total for the ConfTransfer transaction the elliptic curve operations for the account state manipulations, the  <span class="math">\\Sigma</span> -protocol and the 2 32-bit range proofs use 156 curve additions and 154 curve multiplications.</p>

    <p class="text-gray-300">A further optimization concerns the common reference string (CRS). Bulletproofs unlike SNARKs do not use a structured reference string which would require a trusted setup. Nevertheless, Bulletproofs still requires a long linear-sized reference string that the verifier needs to access. While the CRS could be generated on the fly, this would add over 3.9 million gas to the cost of the transaction. Storing the CRS in the blockchain storage also creates high additional cost as loading a 32-byte word costs 200 gas. On the other hand, loading a 32-byte code instruction costs only 3 gas which is why we choose to hard-code the generators into the smart contract. While this makes the contract-generation process more expensive, it is a one-time cost which is amortized over the lifetime of a contract.</p>

    <p class="text-gray-300">We now present several measurements for our implementation of basic Zether. We measure the total gas cost which includes the basic cost for sending a transaction, the storage cost as well as the proof/signature verification. We also present the gas cost in USD using a gas cost price of 2 Gwei per unit of gas [40] and exchange rate of 105 USD per ETH [57]. At the time of writing, a basic Zether transaction costs about 1.5 USD. We also show that a majority of the cost is produced by elliptic-curve operations by factoring out their gas cost. For a transfer transaction, the elliptic curve operations make up  <span class="math">90\\%</span>  of the total cost. For a fund transaction, the majority of the cost comes from initializing a new account. Adding funds to an existing account is significantly cheaper. Finally, we present the size of the transaction data. Note that this does not include the basic Ethereum transaction data which is roughly 110 bytes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gas Cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EC Cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">tx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Burn</td>

            <td class="px-3 py-2 border-b border-gray-700">384k</td>

            <td class="px-3 py-2 border-b border-gray-700">0.080</td>

            <td class="px-3 py-2 border-b border-gray-700">329k</td>

            <td class="px-3 py-2 border-b border-gray-700">160 bytes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fund</td>

            <td class="px-3 py-2 border-b border-gray-700">260k</td>

            <td class="px-3 py-2 border-b border-gray-700">0.035</td>

            <td class="px-3 py-2 border-b border-gray-700">41k</td>

            <td class="px-3 py-2 border-b border-gray-700">64 bytes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Transfer</td>

            <td class="px-3 py-2 border-b border-gray-700">7188k</td>

            <td class="px-3 py-2 border-b border-gray-700">1.51</td>

            <td class="px-3 py-2 border-b border-gray-700">6455k</td>

            <td class="px-3 py-2 border-b border-gray-700">1472 bytes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lock</td>

            <td class="px-3 py-2 border-b border-gray-700">223k</td>

            <td class="px-3 py-2 border-b border-gray-700">0.049</td>

            <td class="px-3 py-2 border-b border-gray-700">83k</td>

            <td class="px-3 py-2 border-b border-gray-700">128 bytes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Unlock</td>

            <td class="px-3 py-2 border-b border-gray-700">193k</td>

            <td class="px-3 py-2 border-b border-gray-700">0.041</td>

            <td class="px-3 py-2 border-b border-gray-700">83k</td>

            <td class="px-3 py-2 border-b border-gray-700">96 bytes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Gas costs for ZSC methods</p>

    <p class="text-gray-300">At the current gas costs, Zether is barely feasible. The cost of a single confidential-only transfer is just below a block's roughly 8 million gas limit [1], i.e., the maximum global gas consumed per block.</p>

    <p class="text-gray-300">Ethereum’s computation power currently is very limited. A simplified estimate is that at 3 gas units per arithmetic operation, Ethereum currently supports less than 180k operations per second for the whole network. There are several efforts to increase the scalability of Ethereum <em>[20, 92]</em>. Zether, as a fairly computation-heavy application, would benefit from this increase. There are also multiple more specific and smaller changes that would greatly benefit Zether. The majority of the cost of a transaction comes from the cryptographic operations. Despite heavily optimizing them, they make up for almost 90% of the cost. These operations seem overpriced when compared to operations like hashing. This discrepancy has been noted and discussed independently <em>[9]</em>. There currently exists an EIP to reduce the gas cost of elliptic curve multiplications by a factor of 6.66 and additions by a factor of 3.33 <em>[9]</em>. A further EIP reduces the cost of calling a precompiled contract <em>[74]</em> which would reduce the cost for each cryptographic operation by another 700 units of gas. If both of these were implemented, the cost of a Zether transfer would reduce to roughly 1.7 million gas (0.36 USD). At that point, optimizations on the non-cryptographic part of the contract could probably further reduce the cost.</p>

    <p class="text-gray-300">There are further changes that Ethereum could make that would benefit Zether. One of them would be supporting elliptic-curve operations for more efficient curves like secp256k1 <em>[83]</em> or Curve25519-ristretto <em>[28]</em>. Another would be supporting multi-exponentiation techniques that can reduce the number of cryptographic operations needed to verify the range proofs <em>[70]</em>.</p>

    <p class="text-gray-300">A simple but significant optimization that can be implemented without changing Ethereum applies to the proof verification: Bulletproofs can be batch verified. This means that verifying <span class="math">k</span> proofs is significantly faster than verifying a single proof. If transactions were collected by some service provider, combined to a single transaction and then sent to the Zether contract, it would significantly reduce the verification cost per proof. However, all transactions in a batch must be valid because a single invalid transaction will cause the whole verification to fail. Batch verification requires randomness but this randomness can either be sampled from the block header <em>[12]</em> or generated from a hash of the proofs.</p>

    <h2 id="sec-38" class="text-2xl font-bold">8 Applications using Zether</h2>

    <p class="text-gray-300">Zether’s capability to lock funds to other smart contracts can make several common applications more private. Before going into them, it is worth noting that the Zether contract will never transfer funds without first checking an appropriate burn or transfer proof, even if the request comes from another smart contract whose rules do not permit illegal transfers. This design decision ensures that the security of Zether only depends on itself and not on any outside smart contract. Even a maliciously written or insecure smart contract cannot cause Zether to misbehave.</p>

    <p class="text-gray-300">We discuss four applications for Zether below. Some applications such as confidential payment channels increase the privacy for the users. Others such as the sealed-bid auctions in fact increase the usability and security of the application.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">8.1 Sealed-bid Auctions</h3>

    <p class="text-gray-300">Auctions are used on Ethereum to sell tokens, resources, etc. <em>[88]</em>. Ethereum Name Service (ENS) <em>[36]</em>, for example, resolves human-readable names into machine-readable identifiers, such as Ethereum addresses and IPFS content hashes, and other identifiers. ENS allocates names through a Vickrey auction, a type of sealed-bid auction where the highest bidder wins but only pays the value of the second highest bid. A total of 782,521 of such auctions have been initiated as of early February 2019 <em>[41]</em>.</p>

    <p class="text-gray-300">ENS auctions consist of three stages. First, a user initiates an auction on a name by bidding on the name. Other people then get three days to place their own bids. Second, everyone reveals their bids over a period of two days. If a bid is not revealed, then the entire amount is forfeited. In the third stage, the highest bidder is awarded the name but only pays the value of the second highest bid.</p>

    <p class="text-gray-300">In the bidding phase, a bidder is supposed to make two API calls. The first call creates a sealed bid by hashing the bid value with a bidder generated secret. The second call submits the committed bid along with a certain amount of ether. ENS suggests that a bidder should deposit more ether than the bid value to disguise the true value of the latter.</p>

    <p class="text-gray-300">Drawbacks. One can easily see why this mechanism does not provide good bid privacy. First, the ether deposited reveals an upper bound on the bid value. Second, the bidder may not want to deposit a very large amount of ether (assuming she has it) because, in the best case, the amount remains locked till the end of the bidding phase, and, in the worst case, till the end of the whole bidding process.</p>

    <p class="text-gray-300">Using Zether. Zether provides a simple way to deal with these problems.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bidding phase: To bid <span class="math">b</span> ETH in the bidding phase, a bidder, say B, can transfer <span class="math">b</span> ZTH from her primary Zether account into a new account, and then lock the latter to the auction contract, call it AUC. Thus, the bid value is completely hidden without B having to deposit any extra money to obfuscate it.</li>

      <li>Reveal phase: B reveals her bid by sending <span class="math">b</span> and a burn proof to AUC. AUC can check the proof and verify that <span class="math">b</span> is in fact the right value. ZSC may also export the proof checking functionality as an API call. Now, there are three possibilities:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If a bid is not revealed in this phase or the revealed value is incorrect, then AUC does not do anything. Bidder’s account remains locked. Thus, bidders have a strong incentive to reveal their bid regardless of the outcome.</li>

      <li>If a new revealed bid is lower, then AUC can simply unlock the bidder’s account.</li>

      <li>If a new revealed bid is highest so far, then AUC unlocks the previous highest bid and stores only its amount.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Final phase: For the winning bid, AUC must only keep the next highest bid, say <span class="math">b^{\\star}</span>, and release the difference back to the bidder. This can be done through a Transfer transaction. However, since all amounts are public anyway, AUC can also simply burn the whole amount and retain one part (the winner’s payment) while refunding the rest to the winner. This prevents AUC from having to create an expensive Transfer transaction and it can utilize the burn proof which was submitted with the bid. For simplicity, ZSC can provide a functionality to split up the burn refund directly.</li>

    </ul>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">8.2 Payment Channels</h3>

    <p class="text-gray-300">Payment channels are a popular way to avoid the fee and delay associated with on-chain transactions. Two or more parties can set-up a payment channel amongst them by committing to some money up front. They can then send messages to each other offline to keep track of the money they owe each other.</p>

    <p class="text-gray-300">The first payment channels were proposed for Bitcoin <em>[87, 33, 72]</em>. Simpler constructions have been developed for Ethereum <em>[77, 6]</em>. We will consider a very simple construction here given by Di Ferrante <em>[44]</em> to illustrate some of the confidentiality issues surrounding payment channels and how Zether can help alleviate them. The ideas described below would extend easily to more complex channels.</p>

    <p class="text-gray-300">Suppose Bob wants to make small payments to Alice every time she <em>tweets</em> for him. Bob can open a payment channel with Alice with the help of a smart contract, say PC. Bob deposits a certain amount of ETH with PC and sets an expiration date. Whenever Alice tweets, Bob signs the <em>total</em> amount of money he owes to Alice so far, and sends the signature to Alice. At any time, Alice can cash out by sending the latest signature to the contract. PC will pay Alice accordingly and send the remaining balance to Bob. (We have omitted several details here because they are not important for the rest of the discussion; please refer to original write-up <em>[44]</em> for them.)</p>

    <p class="text-gray-300">Drawbacks. The amount of ETH Bob deposits with PC is visible to everyone. Indeed, even Alice does not need to know this amount as long as she is convinced that PC holds enough money to pay her off. Further, when Alice cashes out, everyone can see how much she charges per tweet (since the number of tweets is also public).</p>

    <p class="text-gray-300">Using Zether. Zether can easily be used to create a confidential payment channel. Instead of depositing ETH directly with PC, Bob will lock his Zether account to PC (or, as in the previous</p>

    <p class="text-gray-300">example, transfer some money to a new Zether account and lock that to PC). Whenever Alice tweets, Bob would send a Zether transfer transaction to Alice of the amount that she expects, say <span class="math">b</span>. Alice will check the validity of the transaction and that it indeed transfers <span class="math">b</span> to her.</p>

    <p class="text-gray-300">When Alice wants to cash out, she would send the latest transaction to PC, who will pass it on ZSC. ZSC will process the transfer because it is locked to PC. A transfer also unlocks Bob’s account. If Alice never cashes out, PC will just unlock Bob’s account after an expiration date. As a result, the payment channel between Alice and Bob remains confidential to others. Furthermore, Alice does not learn the total amount Bob locked into the payment channel.</p>

    <p class="text-gray-300">Using a simple signed counter the proposal can be trivially extended to bi-directional channels which in turn can be used to build payment channel networks <em>[72, 34]</em>. With a slightly more involved design we can also enable adding more funds to a channel. Suppose Bob wants to add more ZTH to his account. He prepares a transaction for PC and then lets Alice sign the transaction. He then forwards the transaction and the signature to PC which checks both and, if valid, submits the transaction to ZSC. Note that Alice needs to sign the transaction because it might invalidate a previous payment channel transfer. Alice will require that Bob give him a new valid Zether transaction with respect to Bob’s new balance.</p>

    <p class="text-gray-300">Green and Miers <em>[47]</em> show how to build anonymous payment channels. Their design is more involved but provides strong privacy against an intermediary payment channel hub. It requires an underlying private currency and as such is compatible with Zether.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">8.3 Stake Voting</h3>

    <p class="text-gray-300">Any voting process must be as open and transparent as possible. A blockchain based solution can provide such benefits but voter privacy becomes a concern. McCorry et al. <em>[61]</em> proposed a decentralized mechanism for boardroom voting, called the Open Vote Network (OVN), which provides voter privacy. They implement OVN as a Ethereum smart contract.</p>

    <p class="text-gray-300">The Election is carried out in several stages. In the voting stage, a participant publishes a special encryption of their vote <span class="math">v_{i}</span> and a ZK-proof that <span class="math">v_{i}</span> is binary. In the tally stage, the votes can be summed up to compute the final tally. The encryption scheme is designed such that that only the final tally can be computed—individual votes remain private.</p>

    <p class="text-gray-300">A natural question is whether votes can carry weights, instead of just being zero or one. For instance, can participants cast votes of size proportional to their assets, without revealing the value of those assets? Zether provides a simple way to achieve this. In the sign-up phase of the election, participants will lock their Zether account to the voting smart contract. Then, during the voting stage, when a participant casts a vote <span class="math">v_{i}</span> (in an encrypted form), he/she will provide a ZK-proof that <span class="math">v_{i}</span> is equal to the (encrypted) amount in his/her locked account.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">8.4 Privacy-preserving Proof-of-Stake</h3>

    <p class="text-gray-300">Proof-of-stake (PoS) is a consensus mechanism for blockchains, where a participant is elected as a leader with a probability that is proportional to the amount of coins that the participant <em>stakes</em> in the election. There are several PoS protocols <em>[52, 32, 24]</em> which all roughly follow the following simplified design: Users <em>stake</em> a number of coins and then a random beacon <em>[76, 12, 10]</em> is used to select one or a subset of them as leaders. Ethereum is planning to switch to a PoS-based consensus model in the future <em>[20]</em>. All current PoS proposals are for non-confidential currencies and require the user to reveal its stake.</p>

    <p class="text-gray-300">We propose a mechanism to make the PoS election process confidential using Zether, i.e., users do not have to reveal their stake in order to participate in the election. Similar ideas could be used to implement PoS for other confidential currencies such as ZCash <em>[3]</em> or Monero <em>[90]</em>. The general idea is that users encrypt an initial lottery ticket <span class="math">t</span> under their public key and stake an encrypted Zether balance <span class="math">b</span> under the same key. Then the random beacon value is used to derive a lottery drawing <span class="math">v</span>. If <span class="math">v</span> falls between <span class="math">t</span> and <span class="math">t+b</span> then the user wins the lottery, i.e. the PoS election. The user can use a range proof to prove that <span class="math">v</span> is in fact between <span class="math">t</span> and <span class="math">t+b</span> without revealing <span class="math">t</span> or <span class="math">b</span>. This range proof is similar to the one used in basic Zether’s Transfer.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">It is further possible to adjust the winning probability by scaling the range appropriately. Let <span class="math">p</span> denote the desired probability of winning for a single unit of stake. Let <span class="math">q</span> be the size of the ring in which the ElGamal encrypted values lie. For simplicity assume that <span class="math">p\\cdot q</span> is an integer. A user’s wins if <span class="math">v</span> falls in between <span class="math">t</span> and <span class="math">t+b\\cdot p\\cdot q</span>. This happens with probability <span class="math">b\\cdot p</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The hidden lottery approach does not guarantee that at least one user wins. In order to guarantee this, we can have a series of lottery drawings by utilizing a hash function <span class="math">\\mathcal{H}</span> that is modeled as a random oracle. For beacon <span class="math">v</span>, we define $v_{i}=\\mathcal{H}(v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i)<span class="math"> as a sequence of lottery drawings. The user who can demonstrate a winning ticket on the lowest drawing wins. We can also ensure that exactly 1 participant wins. First, we ensure that the lottery drawings are uncorrelated by appending the serialized public key </span>\\mathsf{pk}<span class="math"> when computing the lottery drawings, i.e. </span>v_{i,\\mathsf{pk}}=\\mathcal{H}(v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk})<span class="math">. Even a malicious user will not be able to correlate lottery tickets for distinct public keys, if </span>\\mathcal{H}$ is in fact a random function. Then we use run-off lottery elections between the previous winners until a single winner remains.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proposed scheme has the severe flaw that after multiple drawings an adversary will be estimate a user’s stake by simply observing the user’s probability of winning. This can be circumvented by having a user <em>prove</em> in zero-knowledge that she knows a winning ticket instead of revealing it. We can use a similar ZK-proof as the anonymous Zether transfer. The user proves that she <em>knows</em> a private key which won the lottery instead of revealing her stake. We can use a similar nonce protection as for the anonymous transfer to prevent that a user claims the same winning lottery ticket twice.</p>

    <p class="text-gray-300">The proposed scheme requires a formal analysis and further investigation which we leave for future work.</p>

    <h2 id="sec-43" class="text-2xl font-bold">9 Related Work</h2>

    <p class="text-gray-300">Confidential transactions for Bitcoin were first proposed by Maxwell <em>[59]</em>. He uses Pedersen commitments <em>[69]</em> and OR-proofs to build a payment mechanism where the transaction amounts are hidden, yet it can be verified that the sum of outputs of a transaction is no more than the sum of inputs. Monero goes a step further and uses a special type of signature scheme to hide the origins and destinations of transactions among a set of UTXOs chosen by the sender (anonymity set) <em>[67]</em>. The size of the signature, however, increases linearly with the size of the anonymity set. Thus, the anonymity properties of the extension to Zether is similar to that Monero. (The two are in different models though.)</p>

    <p class="text-gray-300">ZCash <em>[93]</em>, based on Zerocash <em>[3]</em>, provides anonymity at a sublinear cost using a more sophisticated ZK-proof system called zkSNARKs <em>[46]</em>. Senders and recipients are hidden among the group of people who use shielded addresses. Both Monero and ZCash utilize a set of nullifiers which grows linear in the number of transactions. The downside of using SNARKs is that a large common reference string (CRS) needs to be generated beforehand in a way that no one knows the trapdoor, which is a challenging task <em>[73]</em>. Spenders needs to download the CRS and generate proofs for a large circuit, which is very time consuming <em>[3, 94]</em>.</p>

    <p class="text-gray-300">There are several other approaches to make blockchain transactions anonymous. CoinJoin <em>[58]</em> provides a way for a set of users to jointly create a Bitcoin transaction. (MimbleWimble/Grin <em>[71, 48]</em> combines confidential transactions <em>[59]</em> and CoinJoin along with techniques to aggregate transactions non-interactively.) CoinShuffle <em>[81]</em> and Mixcoin <em>[13]</em> are mixing protocols for Bitcoin. TumbleBit <em>[50]</em> uses an untrusted intermediary, called a tumbler, to make transactions unlinkable. Möbius <em>[62]</em> replaces the tumbler with an Ethereum smart contract. Zether’s approach to anonymity is different from the above: it does not rely on <em>active</em> participation of other users. Zether users can choose their own anonymity set like Monero. On the other hand, if a mixing service is used actively, it may provide better anonymity.</p>

    <p class="text-gray-300">Hawk <em>[53]</em> is a framework for building arbitrary smart contracts in a privacy-preserving way. In particular, it can completely hide the bid values in an auction. This generality, however, comes at a significant cost. In Hawk, the private portion of a contract is converted into a circuit. A manager, who</p>

    <p class="text-gray-300">is entrusted with the private inputs of participants, generates a zkSNARK proof on the circuit <em>[5]</em> to show that it has been executed correctly. Apart from the fact that SNARKs rely on trusted setup, the reference string is also circuit-dependent, so a different string needs to be generated for every contract. Moreover, the circuit model puts a bound on the number of users who can participate.</p>

    <p class="text-gray-300">As a result, though Hawk is quite powerful and could provide better privacy, it is not fully decentralized and would be too expensive to use for simple contracts. Another general purpose framework, Ekiden <em>[25]</em>, addresses both the performance and confidentiality problems with smart contract platforms, but relies on trusted execution environments like Intel SGX, so are not fully decentralized either.</p>

    <p class="text-gray-300">RSCoin, Solidus, zkLedger, etc. <em>[31, 22, 66]</em> operate in a model that falls somewhere between a fully decentralized setting like that of Bitcoin/Ethereum and a centralized setting like that of modern financial systems. In this model, the banks regulate the monetary supply but use a blockchain to transact. There is some similarity between the techniques used here and zkLedger’s, where every bank has an account. A sending bank <span class="math">A</span> in zkLedger creates several commitments to send some money <span class="math">x</span> to a receiving bank <span class="math">B</span>. The commitment corresponding to <span class="math">A</span> is to <span class="math">-x</span>, to <span class="math">B</span> is to <span class="math">x</span>, and all other commitments are to zero. Then there are proofs to show that the commitments are well-formed and <span class="math">A</span> has more than <span class="math">x</span> amount of money. While we use similar ideas in our protocol, Zether needs to deal with many more issues like front-running, replay, compatibility, etc. that come with building a smart contract on an open platform.</p>

    <p class="text-gray-300">Concurrent work. Zexe <em>[16]</em> is a recent proposal for a private scripting language for Zerocash-style currencies <em>[3]</em>. It provides similar functionality to Bitcoin script while hiding the inputs to the script and the script itself. It, however, does not support stateful computations in the way a smart contract does.</p>

    <p class="text-gray-300">Quisquis <em>[43]</em> is a new anonymity system designed to address some problems with crypto-currencies like Monero and Zcash (e.g., the set of unspent outputs keep growing). Their model is an interesting hybrid of UTXO and account. While the basic unit is an account (consisting of a public key and a commitment), they are only of one-time use: old accounts are destroyed and new accounts created in a transaction.</p>

    <p class="text-gray-300">Though Quisquis provides a new approach to anonymity, it suffers from front-running attacks (public keys in an anonymity set may get updated just before the transaction is processed) and puts additional burden on clients (they have to go through the list of all updated keys to find out which one belongs to them). More importantly, Quisquis is a standalone crypto-currency while our goal is to build a system that can be deployed on any smart contract platform, and can be used by other smart contracts to achieve more privacy. As a result, Zether faces different technical issues and has a different design.</p>

    <h2 id="sec-44" class="text-2xl font-bold">10 Conclusion</h2>

    <p class="text-gray-300">Blockchain-based, smart contract platforms have great promise to remove trust and add transparency to distributed applications. Currently, this benefit often comes at the cost of greatly reduced privacy. With Zether, we begin to bridge the gap, showing that smart contracts can keep their accounts private while not losing functionality and with only a limited performance overhead. We do this by building a confidential and anonymous token on top of Ethereum. Zether uses account-based private payments which are of independent interest as many popular ledger systems currently use an account-based but non-private data structure. We show the versatility of our work by showing multiple applications that can be built using Zether. In order to efficiently instantiate Zether, we extend Bulletproofs to efficiently interact with <span class="math">\\Sigma</span> protocols.</p>

    <h2 id="sec-45" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Oleg Andreev for pointing out a bug in the <span class="math">\\Sigma</span>-Bullets description. This work was partially supported by NSF, ONR, the Simons Foundation.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Ethereum network status. https://ethstats.net/, 2018.</li>

      <li>[2] Michel Abdalla, Jee Hea An, Mihir Bellare, and Chanathip Namprempre. From identification to signatures via the Fiat-Shamir transform: Minimizing assumptions for security and forward-security. In Lars R. Knudsen, editor, EUROCRYPT 2002, volume 2332 of LNCS, pages 418–433. Springer, April / May 2002.</li>

      <li>[3] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474. IEEE Computer Society Press, May 2014.</li>

      <li>[4] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, October / November 2016.</li>

      <li>[5] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX Conference on Security Symposium, SEC’14, pages 781–796, Berkeley, CA, USA, 2014. USENIX Association.</li>

      <li>[6] Iddo Bentov, Ranjit Kumaresan, and Andrew Miller. Instantaneous decentralized poker. Cryptology ePrint Archive, Report 2017/875, 2017. http://eprint.iacr.org/2017/875.</li>

      <li>[7] Alex Biryukov, Dmitry Khovratovich, and Ivan Pustogarov. Deanonymisation of clients in bitcoin P2P network. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 14, pages 15–29. ACM Press, November 2014.</li>

      <li>[8] Precompiled contracts for addition and scalar multiplication on the elliptic curve alt bn128. https://eips.ethereum.org/EIPS/eip-196.</li>

      <li>[9] Reduce alt bn128 precompile gas costs. https://eips.ethereum.org/EIPS/eip-1108.</li>

      <li>[10] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. Verifiable delay functions. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part I, volume 10991 of LNCS, pages 757–788. Springer, August 2018.</li>

      <li>[11] Dan Boneh and Victor Shoup. A graduate course in applied cryptography. Cambridge, 2018.</li>

      <li>[12] Joseph Bonneau, Jeremy Clark, and Steven Goldfeder. On bitcoin as a public randomness source. Cryptology ePrint Archive, Report 2015/1015, 2015. http://eprint.iacr.org/2015/1015.</li>

      <li>[13] Joseph Bonneau, Arvind Narayanan, Andrew Miller, Jeremy Clark, Joshua A. Kroll, and Edward W. Felten. Mixcoin: Anonymity for bitcoin with accountable mixes. In Nicolas Christin and Reihaneh Safavi-Naini, editors, FC 2014, volume 8437 of LNCS, pages 486–504. Springer, March 2014.</li>

      <li>[14] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Essam Ghadafi, Jens Groth, and Christophe Petit. Short accountable ring signatures based on DDH. In Günther Pernul, Peter Y. A. Ryan, and Edgar R. Weippl, editors, ESORICS 2015, Part I, volume 9326 of LNCS, pages 243–265. Springer, September 2015.</li>

      <li>[15] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, May 2016.</li>

      <li>[16] Sean Bowe, Alessandro Chiesa, Matthew Green, Ian Miers, Pratyush Mishra, and Howard Wu. Zexe: Enabling decentralized private computation. Cryptology ePrint Archive, Report 2018/962, 2018. https://eprint.iacr.org/2018/962.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[17] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[18] Vitalik Buterin. On abstraction. https://blog.ethereum.org/2015/07/05/on-abstraction, 2015.</li>

      <li>[19] Vitalik Buterin. Thoughts on UTXOs. https://medium.com/@ConsenSys/thoughts-on-utxo-by-vitalik-buterin-2bb782c67e53, 2016.</li>

      <li>[20] Vitalik Buterin and Virgil Griffith. Casper the friendly finality gadget. CoRR, abs/1710.09437, 2017.</li>

      <li>[21] Jan Camenisch and Anna Lysyanskaya. Dynamic accumulators and application to efficient revocation of anonymous credentials. In Moti Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 61–76. Springer, August 2002.</li>

      <li>[22] Ethan Cecchetti, Fan Zhang, Yan Ji, Ahmed E. Kosba, Ari Juels, and Elaine Shi. Solidus: Confidential distributed ledger transactions via PVORM. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 17, pages 701–717. ACM Press, October / November 2017.</li>

      <li>[23] CHAINALYSIS. https://www.chainalysis.com.</li>

      <li>[24] Jing Chen, Sergey Gorbunov, Silvio Micali, and Georgios Vlachos. ALGORAND AGREEMENT: Super fast and partition resilient byzantine agreement. Cryptology ePrint Archive, Report 2018/377, 2018. https://eprint.iacr.org/2018/377.</li>

      <li>[25] Raymond Cheng, Fan Zhang, Jernej Kos, Warren He, Nicholas Hynes, Noah M. Johnson, Ari Juels, Andrew Miller, and Dawn Song. Ekiden: A platform for confidentiality-preserving, trustworthy, and performant smart contract execution. CoRR, abs/1804.05141, 2018.</li>

      <li>[26] Ronald Cramer and Ivan Damgård. Zero-knowledge proofs for finite field arithmetic; or: Can zero-knowledge be for free? In Hugo Krawczyk, editor, CRYPTO’98, volume 1462 of LNCS, pages 424–441. Springer, August 1998.</li>

      <li>[27] Ronald Cramer, Rosario Gennaro, and Berry Schoenmakers. A secure and optimally efficient multi-authority election scheme. In Walter Funy, editor, EUROCRYPT’97, volume 1233 of LNCS, pages 103–118. Springer, May 1997.</li>

      <li>[28] Curve25519-ristretto. https://ristretto.group/.</li>

      <li>[29] Ivan Dåmgard. On sigma protocols. https://www.cs.au.dk/~ivan/Sigma.pdf.</li>

      <li>[30] George Danezis, Cedric Fournet, Markulf Kohlweiss, and Bryan Parno. Pinocchio coin: Building zerocoin from a succinct pairing-based proof system. In Proceedings of the First ACM Workshop on Language Support for Privacy-enhancing Technologies, PETShop ’13, 2013.</li>

      <li>[31] George Danezis and Sarah Meiklejohn. Centrally banked cryptocurrencies. In NDSS 2016. The Internet Society, February 2016.</li>

      <li>[32] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 66–98. Springer, April / May 2018.</li>

      <li>[33] Christian Decker and Roger Wattenhofer. A fast and scalable payment network with bitcoin duplex micropayment channels. In Andrzej Pelc and Alexander A. Schwarzmann, editors, Stabilization, Safety, and Security of Distributed Systems, pages 3–18. Springer International Publishing, 2015.</li>

    </ul>

    <p class="text-gray-300">[34] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, and Daniel Malinowski. PERUN: Virtual payment channels over cryptographic currencies. Cryptology ePrint Archive, Report 2017/635, 2017. http://eprint.iacr.org/2017/635.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[35] ELLIPTIC. https://www.elliptic.co.</li>

      <li>[36] Ethereum Name Service. https://ens.domains.</li>

      <li>[37] ENS Docs – Register a name with the auction registrar. https://docs.ens.domains/en/latest/userguide.html#registering-a-name-with-the-auction-registrar.</li>

      <li>[38] EOS.io — Blockchain software architecture. https://www.eos.io.</li>

      <li>[39] Ethereum Project: Blockchain App Platform. https://www.ethereum.org/.</li>

      <li>[40] Ethereum Gasstation. https://ethgasstation.info/calculatorTxV.php.</li>

      <li>[41] Etherscan – Ether Name Sservice. https://etherscan.io/ens.</li>

      <li>[42] Ittay Eyal. The miner’s dilemma. In 2015 IEEE Symposium on Security and Privacy, pages 89–103. IEEE Computer Society Press, May 2015.</li>

      <li>[43] Prastudy Fauzi, Sarah Meiklejohn, Rebekah Mercer, and Claudio Orlandi. Quisquis: A new design for anonymous cryptocurrencies. Cryptology ePrint Archive, Report 2018/990, 2018. https://eprint.iacr.org/2018/990.</li>

      <li>[44] Matthew Di Ferrante. Ethereum Payment Channel in 50 Lines of Code, 2017. https://medium.com/@matthewdif/ethereum-payment-channel-in-50-lines-of-code-a94fad2704bc.</li>

      <li>[45] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, August 1987.</li>

      <li>[46] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, May 2013.</li>

      <li>[47] Matthew Green and Ian Miers. Bolt: Anonymous payment channels for decentralized currencies. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 17, pages 473–489. ACM Press, October / November 2017.</li>

      <li>[48] Grin. https://grin-tech.org/.</li>

      <li>[49] Jens Groth and Markulf Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 253–280. Springer, April 2015.</li>

      <li>[50] Ethan Heilman, Leen Alshenibr, Foteini Baldimtsi, Alessandra Scafuro, and Sharon Goldberg. TumbleBit: An untrusted bitcoin-compatible anonymous payment hub. In NDSS 2017. The Internet Society, February / March 2017.</li>

      <li>[51] George Kappos, Haaroon Yousaf, Mary Maller, and Sarah Meiklejohn. An Empirical Analysis of Anonymity in Zcash. In 27th USENIX Security Symposium, USENIX Security 2018, Baltimore, MD, USA, August 15-17, 2018., pages 463–477, 2018.</li>

      <li>[52] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS, pages 357–388. Springer, August 2017.</li>

    </ul>

    <p class="text-gray-300">[53] Ahmed E. Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In 2016 IEEE Symposium on Security and Privacy, pages 839–858. IEEE Computer Society Press, May 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[54] Amrit Kumar, Clément Fischer, Shruti Tople, and Prateek Saxena. A traceability analysis of monero’s blockchain. In Simon N. Foley, Dieter Gollmann, and Einar Snekkenes, editors, ESORICS 2017, Part II, volume 10493 of LNCS, pages 153–173. Springer, September 2017.</li>

      <li>[55] Kaoru Kurosawa. Multi-recipient public-key encryption with shortened ciphertext. In David Naccache and Pascal Paillier, editors, PKC 2002, volume 2274 of LNCS, pages 48–63. Springer, February 2002.</li>

      <li>[56] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor. Making smart contracts smarter. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS ’16, pages 254–269, New York, NY, USA, 2016. ACM.</li>

      <li>[57] Total Market Capitalization. https://coinmarketcap.com/charts.</li>

      <li>[58] Greg Maxwell. Coinjoin: Bitcoin privacy for the real world, 2013. https://bitcointalk.org/?topic=279249.</li>

      <li>[59] Greg Maxwell. Confidential transactions, 2015. https://people.xiph.org/~greg/confidential_values.txt.</li>

      <li>[60] David Mazieres. The stellar consensus protocol: A federated model for internet-level consensus. Stellar Development Foundation, 2015.</li>

      <li>[61] Patrick McCorry, Siamak F. Shahandashti, and Feng Hao. A smart contract for boardroom voting with maximum voter privacy. In Aggelos Kiayias, editor, FC 2017, volume 10322 of LNCS, pages 357–375. Springer, April 2017.</li>

      <li>[62] Sarah Meiklejohn and Rebekah Mercer. Möbius: Trustless tumbling for transaction privacy. PoPETs, 2018(2):105–121, 2018.</li>

      <li>[63] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoffrey M. Voelker, and Stefan Savage. A fistful of bitcoins: Characterizing payments among men with no names. In Proceedings of the 2013 Conference on Internet Measurement Conference, IMC ’13, pages 127–140, New York, NY, USA, 2013. ACM.</li>

      <li>[64] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed E-cash from Bitcoin. In 2013 IEEE Symposium on Security and Privacy, pages 397–411. IEEE Computer Society Press, May 2013.</li>

      <li>[65] Malte Möser, Kyle Soska, Ethan Heilman, Kevin Lee, Henry Heffan, Shashvat Srivastava, Kyle Hogan, Jason Hennessey, Andrew Miller, Arvind Narayanan, and Nicolas Christin. An empirical analysis of traceability in the monero blockchain. PoPETs, 2018(3):143–163, 2018.</li>

      <li>[66] Neha Narula, Willy Vasquez, and Madars Virza. zkledger: Privacy-preserving auditing for distributed ledgers. In 15th USENIX Symposium on Networked Systems Design and Implementation, NSDI 2018, Renton, WA, USA, April 9-11, 2018, pages 65–80, 2018.</li>

      <li>[67] Shen Noether. Ring signature confidential transactions for monero. Cryptology ePrint Archive, Report 2015/1098, 2015. http://eprint.iacr.org/2015/1098.</li>

      <li>[68] Shen Noether, Adam Mackenzie, and Monero Core Team. Ring confidential transactions. https://lab.getmonero.org/pubs/MRL-0005.pdf, 2016.</li>

      <li>[69] Torben P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In Proceedings of the 11th Annual International Cryptology Conference on Advances in Cryptology, CRYPTO ’91, pages 129–140, London, UK, UK, 1992. Springer-Verlag.</li>

    </ul>

    <p class="text-gray-300">[70] Nicholas Pippenger. On the evaluation of powers and monomials. SIAM Journal on Computing, 9(2):230–250, 1980.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[71] Andrew Poelstra. Mimblewimble, 2016. https://scalingbitcoin.org/papers/mimblewimble.pdf.</li>

      <li>[72] Joseph Poon and Thaddeus Dryja. The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments, 2016. https://lightning.network/lightning-network-paper.pdf.</li>

      <li>[73] Announcing the world’s largest multi-party computation ceremony. https://www.zfnd.org/blog/powers-of-tau/.</li>

      <li>[74] PRECOMPILED CALL opcode (Remove CALL costs for precompiled contracts). https://eips.ethereum.org/EIPS/eip-1109.</li>

      <li>[75] Jeffrey Quesnelle. On the linkability of Zcash transactions. CoRR, abs/1712.01210, 2017.</li>

      <li>[76] Michael O Rabin. Transaction protection by beacons. Journal of Computer and System Sciences, 27(2):256–267, 1983.</li>

      <li>[77] The Raiden Network. https://raiden.network.</li>

      <li>[78] Ripple - One Frictionless Experience To Send Money Globally. https://www.ripple.com.</li>

      <li>[79] Dorit Ron and Adi Shamir. Quantitative analysis of the full Bitcoin transaction graph. In Ahmad-Reza Sadeghi, editor, FC 2013, volume 7859 of LNCS, pages 6–24. Springer, April 2013.</li>

      <li>[80] Jeremy Rubin. The collapse of ETH is inevitable. https://techcrunch.com/2018/09/02/the-collapse-of-eth-is-inevitable, 2018.</li>

      <li>[81] Tim Ruffing, Pedro Moreno-Sanchez, and Aniket Kate. CoinShuffle: Practical decentralized coin mixing for bitcoin. In Miroslaw Kutylowski and Jaideep Vaidya, editors, ESORICS 2014, Part II, volume 8713 of LNCS, pages 345–364. Springer, September 2014.</li>

      <li>[82] Claus-Peter Schnorr. Efficient identification and signatures for smart cards (abstract) (rump session). In Jean-Jacques Quisquater and Joos Vandewalle, editors, EUROCRYPT’89, volume 434 of LNCS, pages 688–689. Springer, April 1990.</li>

      <li>[83] Secp256k1. https://en.bitcoin.it/wiki/Secp256k1.</li>

      <li>[84] Sequence. https://chain.com/sequence.</li>

      <li>[85] Solidity webpage. https://solidity.readthedocs.io.</li>

      <li>[86] Solidity by Example. https://solidity.readthedocs.io/en/v0.4.24/solidity-by-example.html.</li>

      <li>[87] Jeremy Spilman. Anti DoS for tx replacement, 2013. https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html.</li>

      <li>[88] Analyzing Token Sale Models. https://vitalik.ca/general/2017/06/09/sales.html.</li>

      <li>[89] Tor Project. https://www.torproject.org.</li>

      <li>[90] Nicolas van Saberhagen. CryptoNote v 2.0, 2013. https://cryptonote.org/whitepaper.pdf.</li>

      <li>[91] Gavin Wood. Ethereum: A Secure Decentralised Generalised Transaction Ledger. https://gavwood.com/paper.pdf.</li>

      <li>[92] Vlad Zamfir. Casper the friendly ghost: A correct by construction blockchain consensus protocol. https://github.com/ethereum/research/blob/master/papers/CasperTFG/CasperTFG.pdf, 2017.</li>

    </ul>

    <p class="text-gray-300">[93] Zcash: Privacy-protecting digital currency. https://z.cash/.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[94] zcash Documentation. https://media.readthedocs.org/pdf/zcash/english-docs/zcash.pdf.</li>

    </ul>

    <h2 id="sec-46" class="text-2xl font-bold">Appendix A UTXO on a Contract</h2>

    <p class="text-gray-300">One may wonder why one of the existing confidential payment mechanisms developed in the UTXO model cannot be implemented as an Ethereum smart contract. While such a strategy may help us save the effort involved in designing a new mechanism, there are several key advantages in building a confidential payment mechanism in the account-based model rather than the UTXO model:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Storage.</em> Storage on the Ethereum blockchain is quite expensive (for good reasons) and should be minimized as much as possible. For example, storing only 256 bits of information costs roughly 20,000 gas units (see Section 2 for the definition of gas), whereas sending it costs only 2,176 gas units <em>[91]</em>. If a UTXO-based model is implemented, then all unspent transactions need to be stored on a smart contract. Moreover, for all UTXO-based currencies that provide cryptographic anonymity <em>[3, 67]</em>, all <em>spent</em> transactions have to be stored as well. This makes the smart contract expensive to use.</li>

      <li><em>Confidentiality.</em> Accounts provide a natural <em>mixing</em> property. A new transaction in the account-based model draws from the total available balance, whereas the UTXOs used to create a new transaction in the Bitcoin model could reveal a lot of information about the new transaction, even if all the amounts are cryptographically hidden. For example, if a UTXO (even encrypted) coming from a user’s employer is used to create a new transaction, then the user is likely going to spend a significant amount of money. On the other hand, though UTXOs could potentially provide better anonymity, users can often be de-anonymized in practice <em>[63, 79, 23, 35]</em>.</li>

      <li><em>Interoperability with smart contracts.</em> An account-based privacy-preserving mechanism can easily inter-operate with smart contracts, which typically maintain accounts for their users and for the contract itself. For example, a private account can be used to fund an account on the smart contract, or be tied to a payment channel smart contract <em>[77, 6]</em>. Funds can be added to the channel by simply adding funds to the private account.</li>

      <li><em>Adoption.</em> Four out of the six most valuable cryptocurrencies (as of late 2018) use an account-based model (Ethereum, Ripple <em>[78]</em>, EOS <em>[38]</em>, Stellar <em>[60]</em>). An account-based privacy mechanism can be used to introduce private payments to these platforms.</li>

      <li><em>Simplicity for users.</em> If we provide privacy in the account-based model, then it encourages users to have a small number of accounts, making account management simpler. This also makes the system more efficient overall.</li>

    </ul>

    <h2 id="sec-47" class="text-2xl font-bold">Appendix B Correctness</h2>

    <p class="text-gray-300">To formally state the correctness property, we define what it means for a transaction to be generated honestly and the notion of an ideal state.</p>

    <p class="text-gray-300">Honestly-generated transactions. Let <span class="math">\\mathsf{TX}=(\\mathsf{TX}_{1},\\mathsf{TX}_{2},\\ldots,\\mathsf{TX}_{m})</span> be a group of transactions such that for every <span class="math">i\\in[m]</span>, <span class="math">\\mathsf{TX}_{i}=(\\mathsf{tx}_{i,1},\\mathsf{tx}_{i,2},\\ldots)</span> is a sequence of transactions which are processed in that order into the block at height <span class="math">h_{i}</span> (<span class="math">h_{1}&lt;h_{2}&lt;\\ldots&lt;h_{m}</span>). Define the <span class="math">k</span>-th transaction in <span class="math">\\mathsf{TX}</span> to be the <span class="math">k</span>-th transaction in the sequence <span class="math">(\\mathsf{tx}_{1,1},\\mathsf{tx}_{1,2},\\ldots,\\ \\mathsf{tx}_{2,1},\\mathsf{tx}_{2,2},\\ldots,\\ \\ldots,\\ \\mathsf{tx}_{m,1},\\mathsf{tx}_{m,2},\\ldots)</span>. We say that these transactions were generated honestly if all of the following are true:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All secret key, address pairs are generated through the CreateAddress algorithm.</li>

      <li>For all <span class="math">i,j</span>, <span class="math">\\mathsf{tx}_{i,j}</span> is generated by running one of the five user algorithms for generating transactions.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">\\mathsf{TX}_{i_1},\\mathsf{TX}_{i_2},\\ldots</span> s.t. <span class="math">h_{i_1},h_{i_2},\\ldots</span> are in the same epoch, and any <span class="math">\\mathsf{pk}</span>, <span class="math">\\mathsf{TX}_i</span> contains at most one transfer or burn transaction (not one of each) initiated from <span class="math">\\mathsf{pk}</span>. (This restriction is only for the anonymous version.)</li>

      <li>For any <span class="math">\\mathsf{tx}_{i,j}</span>, if <span class="math">h_i</span> is in epoch <span class="math">e</span> then a state after the last block of epoch <span class="math">e - 1</span> was used to generate <span class="math">\\mathsf{tx}_{i,j}</span> (if a state is needed at all).</li>

    </ul>

    <p class="text-gray-300">The last point above implies that even if there is some delay in processing the transaction, it is no more than the epoch length. In other words, all transactions generated for a certain epoch are assumed to be processed in the same epoch.</p>

    <p class="text-gray-300">For a block height <span class="math">h</span>, let <span class="math">\\text{last}(h)</span> denote the height of the last block in the previous epoch, i.e. <span class="math">\\text{last}(h) = \\lfloor h / \\mathsf{E} \\rfloor \\cdot \\mathsf{E} - 1</span>, and <span class="math">\\text{next}(h)</span> denote the height of the first block in the next epoch, i.e. <span class="math">\\text{next}(h) = \\lceil (h + 1) / \\mathsf{E} \\rceil \\cdot \\mathsf{E}</span>.</p>

    <p class="text-gray-300"><strong>Ideal state.</strong> The ideal state <span class="math">\\mathsf{IdSt}</span> consists of two tables <span class="math">\\mathsf{Bal}</span> and <span class="math">\\mathsf{Lk}</span> indexed by addresses. For a public key <span class="math">\\mathsf{pk}</span>, <span class="math">\\mathsf{Bal}[\\mathsf{pk}]</span> gives the balance in <span class="math">\\mathsf{pk}</span> and <span class="math">\\mathsf{Lk}[\\mathsf{pk}]</span> gives the locking Ethereum address (or <span class="math">\\bot</span> if <span class="math">\\mathsf{pk}</span> is not locked). Initially, <span class="math">\\mathsf{Bal}[\\mathsf{pk}]</span> and <span class="math">\\mathsf{Lk}[\\mathsf{pk}]</span> are set to 0 and <span class="math">\\bot</span>, respectively, for all <span class="math">\\mathsf{pk}</span>. These tables are updated as each new transaction is processed. We use <span class="math">\\mathsf{Bal}_h</span> and <span class="math">\\mathsf{Lk}_h</span> to denote the state of these tables when all the transactions included in blocks <span class="math">0,1,\\ldots,h</span> have been processed.</p>

    <p class="text-gray-300">Ideal state for a set of transactions <span class="math">\\mathsf{TX}</span> is defined recursively. Let <span class="math">\\mathsf{okToOperate}</span> be a function that given a public key <span class="math">\\mathsf{pk}</span> and an Ethereum address <span class="math">\\mathsf{addr}</span>, returns 1 iff <span class="math">\\mathsf{Lk}[\\mathsf{pk}]</span> is <span class="math">\\mathsf{addr}</span> or <span class="math">\\bot</span>. (In either case, <span class="math">\\mathsf{addr}</span> is allowed to operate on the account.) Let <span class="math">\\mathsf{IdSt}_k</span> denote the ideal state after the first <span class="math">k</span> transactions have been processed. <span class="math">\\mathsf{IdSt}_0</span>, ideal state at the beginning, is set to be the initial state of <span class="math">\\mathsf{Bal}</span> and <span class="math">\\mathsf{Lk}</span> tables. <span class="math">\\mathsf{IdSt}_k</span> is defined based on <span class="math">\\mathsf{IdSt}_{k-1}</span> and the <span class="math">k</span>th transaction as follows. If the <span class="math">k</span>th transaction <span class="math">\\mathsf{tx}_{i,j}</span> is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{tx}_{\\text{fund}} \\gets \\text{CreateFundTx}(\\mathsf{pk}, \\mathsf{amt})</span>: if the sum of all balances and <span class="math">\\mathsf{amt}</span> is at most MAX, and <span class="math">\\mathsf{okToOperate}(\\mathsf{pk}, \\mathsf{tx}_{\\text{fund}}.\\mathsf{addr}) = 1</span>, then <span class="math">\\mathsf{Bal}[\\mathsf{pk}]</span> is incremented by <span class="math">\\mathsf{amt}</span>.</li>

      <li><span class="math">\\mathsf{tx}_{\\text{trans}} \\gets \\text{CreateTransferTx}(\\mathsf{sk}_{\\text{from}}, \\mathsf{pk}_{\\mathsf{to}}, \\mathsf{AnonSet}, \\mathsf{amt}, \\mathsf{st}_{\\text{last}(h_i)})</span>: if</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">\\mathsf{pk} \\in \\mathsf{AnonSet}</span>, <span class="math">\\mathsf{okToOperate}(\\mathsf{pk}, \\mathsf{tx}_{\\text{trans}}.\\mathsf{addr}) = 1</span>, and</li>

      <li><span class="math">\\mathsf{Bal}_{\\mathsf{last}(h_i)}[\\mathsf{pkOf}(\\mathsf{sk}_{\\mathsf{from}})] \\geq \\mathsf{amt}</span>,</li>

    </ul>

    <p class="text-gray-300">then <span class="math">\\mathsf{Bal}[\\mathsf{pkOf}(\\mathsf{sk}_{\\mathsf{from}})]</span> is decremented by <span class="math">\\mathsf{amt}</span> and <span class="math">\\mathsf{Bal}[\\mathsf{pk}_{\\mathsf{to}}]</span> is incremented by <span class="math">\\mathsf{amt}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{tx}_{\\text{lock}} \\gets \\text{CreateLockTx}(\\mathsf{sk}, \\mathsf{addr})</span>: if <span class="math">\\mathsf{okToOperate}(\\mathsf{pk}, \\mathsf{tx}_{\\text{lock}}.\\mathsf{addr}) = 1</span> then <span class="math">\\mathsf{Lk}_{\\mathsf{next}(h)}[\\mathsf{pk}] = \\mathsf{addr}</span>.</li>

      <li><span class="math">\\mathsf{tx}_{\\text{unlock}} \\gets \\text{CreateUnlockTx}(\\mathsf{pk})</span>: if <span class="math">\\mathsf{okToOperate}(\\mathsf{pk}, \\mathsf{tx}_{\\text{unlock}}.\\mathsf{addr}) = 1</span> then <span class="math">\\mathsf{Lk}_{\\mathsf{next}(h)}[\\mathsf{pk}] = \\bot</span>.</li>

      <li><span class="math">\\mathsf{tx}_{\\text{burn}} \\gets \\text{CreateBurnTx}(\\mathsf{sk}, \\mathsf{amt}, \\mathsf{st}_{\\mathsf{last}(h_i)})</span>: if <span class="math">\\mathsf{okToOperate}(\\mathsf{pk}, \\mathsf{tx}_{\\text{burn}}.\\mathsf{addr}) = 1</span> and <span class="math">\\mathsf{Bal}_{\\mathsf{last}(h_i)}[\\mathsf{pk}] \\geq \\mathsf{amt}</span>, then decrement <span class="math">\\mathsf{Bal}[\\mathsf{pk}]</span> by <span class="math">\\mathsf{amt}</span>.</li>

    </ul>

    <p class="text-gray-300">(If in any of the above cases, <span class="math">\\mathsf{pk}</span> is not defined, then it must be taken to mean <span class="math">\\mathsf{pkOf}(\\mathsf{sk})</span>.)</p>

    <p class="text-gray-300"><strong>Correctness.</strong> A payment mechanism is <strong>correct</strong> if for every group of transactions <span class="math">\\mathsf{TX}</span>, whenever <span class="math">\\mathsf{tx}_{i,j}</span> is a burn transaction <span class="math">\\mathsf{tx}_{\\mathsf{burn}} = (\\mathsf{pk}, \\mathsf{amt}, \\ldots)</span>, <span class="math">\\mathsf{Burn}(\\mathsf{tx}_{\\mathsf{burn}}).\\mathsf{ETH}</span> is same as <span class="math">\\mathsf{Bal}_{\\mathsf{last}(h_i)}[\\mathsf{pk}]</span>. (Recall that <span class="math">\\mathsf{Burn}(\\mathsf{tx}_{\\mathsf{burn}}).\\mathsf{ETH}</span> is the amount of Ether sent back to the user who called <span class="math">\\mathsf{Burn}</span> with <span class="math">\\mathsf{tx}_{\\mathsf{burn}}</span>.) Furthermore, for every <span class="math">\\mathsf{sk}</span> and <span class="math">h</span>, we require that <span class="math">\\mathsf{ReadBalance}(\\mathsf{sk}, \\mathsf{st}_h)</span> returns <span class="math">\\mathsf{Bal}_{\\mathsf{last}(h)}[\\mathsf{pkOf}(\\mathsf{sk})]</span></p>

    <p class="text-gray-300">C Security Requirements</p>

    <p class="text-gray-300">We define here the common elements of the two security games; we refer to this basic version as just Security-Game. All the entities (Chal, Adv and <span class="math">\\mathcal{O}_{\\text{SC}}</span>) in the game receive the security parameter <span class="math">\\lambda</span> as input. When <span class="math">\\mathcal{O}_{\\text{SC}}</span> receives a transaction from Chal or Adv, it adds the transaction to the queue of pending transactions. At any time, Chal can get the latest state of SC (or any older state) through <span class="math">\\mathcal{O}_{\\text{SC}}</span>. Adv has full view of the oracle: it can see all the transactions sent by Chal to SC, how the state of SC changes, etc.</p>

    <p class="text-gray-300">Adversary’s influence on the contract. We allow Adv to control the state of SC in one of the following ways:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It can instruct Chal to run one of the user algorithms with certain inputs and send the resulting transaction (if any) to <span class="math">\\mathcal{O}_{\\text{SC}}</span> from an Ethereum address of its choice . Example instructions are (addr, CreateAddress), and (addr, CreateFundTx, pk, amt). Note that:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a CreateAddress instruction, Chal sends the address output by this algorithm—but not the secret key—directly to Adv.</li>

      <li>For transactions that require a secret key under the possession of Chal as an input, Adv specifies the corresponding public key instead.</li>

      <li>When Chal receives an instruction, it uses the state of SC in the last block of the previous epoch (if needed) to execute the instruction.</li>

      <li>If Chal has generated a transfer or a burn transaction in an epoch with a certain public key, then instructions to generate any one of these two transactions again from the same public key in the same epoch will be rejected. Chal will also reject transfer instructions that require it to use accounts locked to different addresses in the anonymity set. (This point and the one before are important because Chal models honest parties in the system.)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It can directly send an arbitrary transaction to <span class="math">\\mathcal{O}_{\\text{SC}}</span>.</li>

      <li>It can ask <span class="math">\\mathcal{O}_{\\text{SC}}</span> to process an arbitrary (non-empty) subset of the pending transactions and update the state of SC. This captures the addition of a new block to the blockchain.</li>

    </ol>

    <p class="text-gray-300">The game stops when Adv so desires. Let <span class="math">h^{\\star}</span> be the height of the last block. Let PK denote the set of public keys generated by Chal (at the behest of Adv). Adv does not have the secret keys for them.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">C.1 Overdraft-safety</h3>

    <p class="text-gray-300">We capture overdraft-safety by means of a game called Overdraft-Safety-Game between a challenger Chal, an adversary Adv and the oracle <span class="math">\\mathcal{O}_{\\text{SC}}</span>, who interact in the exact same way as Security-Game. Let us associate some quantities with the game with respect to Adv:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>EtherDeposited. Denotes the sum of all <span class="math">\\textsf{tx}_{\\textsf{fund}}</span>.ETH for which <span class="math">\\textsf{tx}_{\\textsf{fund}}=(\\textsf{pk},\\ldots)</span> is such that <span class="math">\\textsf{pk}\\notin\\textsf{PK}</span>.</li>

      <li>ZetherReceived. Let in be the sum of all <span class="math">\\textsf{tx}_{\\textsf{fund}}</span>.ETH for which <span class="math">\\textsf{tx}_{\\textsf{fund}}=(\\textsf{pk},\\ldots)</span> is such that <span class="math">\\textsf{pk}\\in\\textsf{PK}</span>. Let <span class="math">\\textsf{honBal}=\\sum_{\\textsf{pkOf}(\\textsf{sk})\\in\\textsf{PK}}\\textsf{ReadBalance}(\\textsf{sk},\\textsf{st}_{h^{\\star}})</span> be the total balance of honest parties. (Recall that <span class="math">h^{\\star}</span> is the height of the last added block before the game ends.) Finally, let out be the sum of all <span class="math">\\textsf{burn}(\\textsf{tx}_{\\textsf{burn}})</span>.ETH for which <span class="math">\\textsf{tx}_{\\textsf{burn}}=(\\textsf{pk},\\ldots)</span> is such that <span class="math">\\textsf{pk}\\in\\textsf{PK}</span>. Then ZetherReceived denotes <span class="math">\\textsf{in}-\\textsf{out}-\\textsf{honBal}</span>, which may be negative.</li>

      <li>EtherBurnt. Denotes the sum of all <span class="math">\\textsf{burn}(\\textsf{tx}_{\\textsf{burn}})</span>.ETH for which <span class="math">\\textsf{tx}_{\\textsf{burn}}=(\\textsf{pk},\\ldots)</span> is such that <span class="math">\\textsf{pk}\\notin\\textsf{PK}</span>.</li>

    </ul>

    <p class="text-gray-300">A payment mechanism is <em>safe against overdrafts</em> if for all PPT adversaries Adv, the probability that <span class="math">\\textsf{EtherDeposited}+\\textsf{ZetherReceived}&lt;\\textsf{EtherBurnt}</span> in Overdraft-Safety-Game is <span class="math">\\textsf{negl}(\\lambda)</span>, where the probability is taken over the coin tosses of Adv and the challenger.</p>

    <p class="text-gray-300">C.2 Privacy</p>

    <p class="text-gray-300">In order to capture the privacy requirement formally, we define a game called Privacy-Game between a challenger Chal, an adversary Adv and the oracle <span class="math">\\mathcal{O}_{\\mathsf{SC}}</span>, who interact in the same way as Security-Game but with one crucial difference. Instead of sending just one instruction to Chal every time, Adv sends two <em>consistent</em> instructions at some point and only one instruction rest of the time (consistency will be defined below). Chal executes the <span class="math">(b+1)</span>-th instruction based on a bit <span class="math">b</span> hidden from Adv, which is chosen randomly in advance. Adv outputs a bit <span class="math">b^{\\prime}</span> at the end of the game as a guess for <span class="math">b</span>. (This is the typical left-or-right setting used for indistinguishability-based definitions.)</p>

    <p class="text-gray-300">Two instructions are <em>consistent</em> if they refer to the same user algorithm and need to be sent from the same Ethereum address. Additionally, if the instructions are for</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>creating a fund transaction, then they are associated with the same public key and amount.</li>

      <li>creating a transfer transaction, then</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>they are associated with the same anonymity set;</li>

      <li>the amounts should be at most the value returned by ReadBalance with the respective sender’s public key and the state of the last block in the previous epoch;</li>

      <li>if any of the receivers is a corrupt party, both instructions have the same receiver and the same amount.</li>

      <li>creating a lock transaction, then they are associated with the same public key and Ethereum address.</li>

      <li>creating an unlock transaction, then they are associated with the same public key.</li>

      <li>creating a burn transaction, then they are associated with the same public key, and ReadBalance with that public key and the state of the last block in the previous epoch returns the same value.</li>

      <li>executing ReadBalance, then they must return the same value.</li>

    </ul>

    <p class="text-gray-300">A payment mechanism is <em>private</em> if for all PPT adversaries Adv, the probability that <span class="math">b^{\\prime}=b</span> in Privacy-Game is <span class="math">1/2+\\mathsf{negl}(\\lambda)</span>, where the probability is over the coin tosses of Adv and challenger.</p>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix D Anonymous Zether</h2>

    <p class="text-gray-300">In this section, we discuss an anonymous version of Zether in detail. While this version hides both sender and receiver apart from hiding the transfer amount, it also incurs some additional costs. First, the size of ZK-proof for a transfer increases linearly with the size of the anonymity set. Second, as we will see, users would be able to do only one transfer or burn transaction per epoch (not one of each).</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">D.1 Overview</h3>

    <p class="text-gray-300">More complex ZK-proof. An anonymous transfer transaction enables a user Alice with public key <span class="math">y_{A}</span> interested in sending <span class="math">b</span> ZTH to another user Bob with public key <span class="math">y_{B}</span> to hide both herself and Bob among a larger group of users <span class="math">\\mathbb{U}</span> with public keys <span class="math">\\{y_{1},\\ldots,y_{n}\\}</span>, along with hiding <span class="math">b</span>. (<span class="math">\\mathbb{U}</span> of course contains Alice and Bob.) As a result, Alice provides a more complex ZK-proof <span class="math">\\pi</span>. Specifically, Alice generates <span class="math">n</span> ciphertexts <span class="math">C_{1},\\ldots,C_{n}</span> under keys <span class="math">y_{1},\\ldots,y_{n}</span> respectively. <span class="math">\\pi</span> shows that all the ciphertexts are well-formed; only two of the underlying amounts are non-zero and their values only differ in sign; and, the remaining balance of the account with positive amount is non-negative.</p>

    <p class="text-gray-300">We use several optimizations to reduce the size of <span class="math">\\pi</span> and verification cost. The prover sends <span class="math">n</span> ciphertexts, and all of them expect two encrypt <span class="math">0</span>. We leverage this in our proof construction such that the proof statement only contains two range proofs, as sub-statements. Concretely we use one-out-of-many proofs <em>[49]</em>. These proofs can be used to give a secondary encryption to one out of</p>

    <p class="text-gray-300"><span class="math">n</span> ciphertexts without revealing which original ciphertext was re-encrypted. One-out-of-many proofs can be used to build ring-signatures. Alice uses this proof to create secondary encryptions of <span class="math">b</span> and <span class="math">-b</span> under <span class="math">y_{A}</span> and <span class="math">y_{B}</span> respectively along with a secondary encryption of Alice’s balance <span class="math">b^{<em>}</span>. Alice then simply shows the relationship between <span class="math">b</span> and <span class="math">-b</span> and that <span class="math">b</span> and <span class="math">b^{</em>}-b</span> are non-negative using a range proof.</p>

    <p class="text-gray-300">Replay and double-spend protection. There is a subtle issue with using the same replay protection mechanism we proposed earlier for confidential transfers. An anonymous transaction published by Alice involves multiple accounts only one of which Alice may own. To preserve anonymity, we cannot treat Alice’s account in any special way. Indeed, all the accounts involved in the transaction must be treated in the same way. Thus, the nonces associated with <em>each</em> one of them should be incremented. Unfortunately, this immediately leads to a serious problem. Other account holders involved in Alice’s transaction may have generated a transaction with the previous value of nonce. If their transactions get in later, then they will be rejected. If even one of them gets in before, then Alice’s transaction will be rejected.</p>

    <p class="text-gray-300">We take a different approach to replay protection, which has some similarities with that of Monero. Every epoch will be associated with a base <span class="math">g_{\\textnormal{epoch}}</span> derived from hashing some fixed string like ‘Zether’ and the current epoch number. To initiate a transfer or burn transaction from an account with public key <span class="math">y=g^{\\textnormal{zk}}</span>, <span class="math">g^{\\textnormal{zk}}_{\\textnormal{epoch}}</span> must be included in the transaction. More precisely, the proof <span class="math">\\pi</span> described above for a transfer transaction will also show knowledge of <span class="math">\\textnormal{sk}</span> such that <span class="math">\\overline{g}=g^{\\textnormal{zk}}_{\\textnormal{epoch}}</span> for <span class="math">\\overline{g}</span> included in the transaction. (Burn transactions’ proofs will also include this.) Importantly, <span class="math">\\overline{g}</span> is computationally unlinkable to <span class="math">y</span> under the DDH assumption. We refer to <span class="math">\\overline{g}</span> as a nonce in the sequel.</p>

    <p class="text-gray-300">While in the case of confidential transfers, we subtract the transfer amount from the sender’s balance immediately but keep it pending for the receiver, one cannot take the same approach for anonymous transfers. All the transfer amounts, whether positive (for the receiver), negative (for the sender) or zero (for others), have to be kept pending. Thus, an anonymous transfer transaction would not immediately affect the balance of any of the users involved. This opens up the system to double-spending attacks. A user could generate two transfer transactions in an epoch, sending her total balance to two different users. The attached ZK-proofs would both be valid because they will be verified against the same state. Fortunately, the nonce, in addition to preventing replay attacks, also prevents such double-spending attacks.</p>

    <p class="text-gray-300">During every epoch, ZSC will accumulate nonces as they come, rejecting any transaction that reuses a nonce. An important difference from Monero is that the set of nonces does not grow indefinitely; it is reset to null at the beginning of every epoch. Thus, providing anonymity does not lead to a continuous growth in the size of the state of ZSC.</p>

    <p class="text-gray-300">A drawback of this approach to replay protection and double-spending is that even honest users can only initiate at most one transfer or burn transaction in a given epoch.</p>

    <p class="text-gray-300">Global updates. With the new replay protection mechanism in place, a few global updates need to be made in every epoch: set the base for the epoch and empty the nonce set. We will have to make the updates at the receipt of the very first message in an epoch, be it from any account. Thus, users will have to provide a little more gas to cover the possibility that their message could be the very first one in an epoch. In most cases, this extra gas will be reimbursed.</p>

    <p class="text-gray-300">Locking to smart contracts. It is not hard to see that if some accounts involved in an anonymous transfer are locked to a smart contract then all of the locked accounts must be locked to the same contract. Furthermore, the transfer is processed only if it comes from that contract.</p>

    <p class="text-gray-300">A more difficult thing to observe is that locking must not come into effect immediately. Suppose Alice publishes a transaction in a certain epoch to lock her account to a smart contract. Another user Bob may have published a transfer transaction (at about the same time as Alice) with Alice in his anonymity set while her account was still unlocked. If Alice’s transaction gets in first, locking her account, then Bob’s transaction will be rejected. The same holds for unlocking as well. Therefore, when ZSC is invoked to lock/unlock an account, it just records the request but does not act on it</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 4: Anonymous Zether setup</p>

    <p class="text-gray-300">immediately. When the account is rolled over in some later epoch, the request will be executed. (Recall that every method on ZSC first checks if there is a need for roll over.)</p>

    <p class="text-gray-300">Lock transactions also need replay protection. In fact, using the account secret key, the sender must sign both the nonce and an address (to which the account will be locked) in the case of confidential transfers, and both the epoch base and address in the case of anonymous transfers. As a result, for the latter case, lock transactions must be published at the beginning of an epoch just like transfer and burn transactions.</p>

    <p class="text-gray-300">We now formally describe the three components of anonymous Zether (setup, smart contract and user algorithms) with respect to the basic version (see Section 6).</p>

    <p class="text-gray-300">Setup. Four new variables are initialized in setup: a pending lock table pLock to temporarily hold lock requests, a nonce set  <span class="math">\\mathcal{U}</span>  to prevent replay attacks, a global last update variable  <span class="math">t</span>  to record the last epoch in which any account was updated, and an epoch base  <span class="math">g_{\\mathrm{epoch}}</span> . Also, the counter table goes away. See Figure 4 for a complete description.</p>

    <p class="text-gray-300">Anonymous transfer ZK-proof. Anonymous transfers not only hide the transfer amount but also the sender and receiver in a transfer. Suppose a user wants to transfer an amount  <span class="math">b^{\\star}</span>  from a public key  <span class="math">y</span>  to  <span class="math">\\overline{y}</span> , and it would like to hide the two keys among a larger set of public keys, say  <span class="math">\\mathbf{y} = \\{y_1, \\ldots, y_n\\}</span> . Let  <span class="math">(C_{L,i}, C_{R,i})</span>  be the encryption of the balance associated with key  <span class="math">y_i</span> , for  <span class="math">i \\in [n]</span> . The user now needs to create  <span class="math">n</span>  ciphertexts  <span class="math">(C_1, D_1), \\ldots, (C_n, D_n)</span>  and prove that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>they are well-formed;</li>

      <li>one of them (say  <span class="math">j</span> th) encrypts  <span class="math">b^{\\star}</span> , one of them (say  <span class="math">\\ell</span> th) encrypts  <span class="math">-b^{\\star}</span> , rest encrypt 0;</li>

      <li><span class="math">b^{\\star}</span>  is positive;</li>

      <li>remaining balance in  <span class="math">y_{j}</span>  (say  <span class="math">b&#x27;</span> ) is also positive; and,</li>

      <li>the correct nonce is declared.</li>

    </ul>

    <p class="text-gray-300">We can again reuse randomness and set  <span class="math">D_{1} = \\dots = D_{n} = D</span> .</p>

    <p class="text-gray-300">To handle such a complex statement efficiently without revealing  <span class="math">j</span> ,  <span class="math">\\ell</span> ,  <span class="math">b^{\\star}</span>  and  <span class="math">b&#x27;</span> , we introduce new binary variables  <span class="math">s_1, \\ldots, s_n</span>  and  <span class="math">t_1, \\ldots, t_n</span> . Value 1 for an  <span class="math">s_i</span>  denotes that money is being transferred</p>

    <p class="text-gray-300">from <span class="math">y_{i}</span> and value 1 for a <span class="math">t_j</span> denotes that money is being transferred to <span class="math">y_j</span>. The user would keep these variables secret and prove various statements using them. Only one of <span class="math">s_1, \\ldots, s_n</span> and one of <span class="math">t_1, \\ldots, t_n</span> should be 1. This could be shown by proving that each of these variables is either 0 or 1, <span class="math">\\sum_{i} s_i = 1</span> and <span class="math">\\sum_{i} t_i = 1</span>.</p>

    <p class="text-gray-300">In addition, the user proves:</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} C_i^{s_i} = g^{b^{\\star}} \\prod_{i=1}^{n} y_i^{r \\cdot s_i} \\tag{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} C_i^{s_i + t_i} = \\prod_{i=1}^{n} y_i^{r \\cdot (s_i + t_i)} \\tag{4}</span></div>

    <div class="my-4 text-center"><span class="math-block">C_i^{(1 - s_i) \\cdot (1 - t_i)} = y_i^{(1 - s_i) \\cdot (1 - t_i) \\cdot r} \\text{ for } i \\in [n] \\tag{5}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} \\left(\\frac{C_{L,i}}{C_i}\\right)^{s_i} = g^{b&#x27;} \\left(\\frac{\\prod_{i=1}^{n} C_{R,i}^{s_i}}{D}\\right)^{\\mathbf{sk}} \\tag{6}</span></div>

    <div class="my-4 text-center"><span class="math-block">g_{\\text{epoch}}^{\\mathbf{sk}} = u \\tag{7}</span></div>

    <p class="text-gray-300">Given that exactly one of <span class="math">s_1, \\ldots, s_n</span> is 1 and rest are 0, Eq (3) shows that the ciphertext for non-zero <span class="math">s_i</span> is a valid encryption of <span class="math">b^{\\star}</span>. When Eq (3) is subtracted from Eq (4), we get <span class="math">\\prod_{i=1}^{n} C_i^{t_i} = g^{-b^{\\star}} \\prod_{i=1}^{n} y_i^{r \\cdot t_i}</span>, which shows that the ciphertext for non-zero <span class="math">t_i</span> is a valid encryption of <span class="math">-b^{\\star}</span>. Thus, Eq (3) and (4) together show that the ciphertexts that encode non-zero quantities are valid.</p>

    <p class="text-gray-300">These statements can be proved more efficiently using techniques from one-out-of-many proofs [49] and in particular the extension to ElGamal encryptions [14]. These proofs are <span class="math">\\Sigma</span> protocols that can be used to show that a decryption of one out of <span class="math">n</span> ciphertexts has certain properties, e.g. they are 0. The proof size is only logarithmic in <span class="math">n</span>. This is achieved by writing <span class="math">i</span> in its binary representations and constructing <span class="math">n</span> products such that only the <span class="math">i</span>th is 1 and all other are 0.</p>

    <p class="text-gray-300">In Eq (5), the expression <span class="math">(1 - s_i)(1 - t_i)</span> is non-zero only when both <span class="math">s_i</span> and <span class="math">t_i</span> are zero. For such <span class="math">i</span>, <span class="math">C_i</span> should be an encryption of 0, which is what the equation shows. (When <span class="math">s_i</span> or <span class="math">t_i</span> is non-zero, both sides are of the equation are just 0.) Eq (6) shows that <span class="math">b&#x27;</span> balance is left in the account for which <span class="math">s_i</span> is 1. Lastly, Eq (7) shows that <span class="math">u</span> is the correct nonce for the current epoch.</p>

    <p class="text-gray-300">Further, the user also needs to show that <span class="math">g^{\\mathbf{sk}} = \\Pi y_i^{s_i}</span>, <span class="math">b^{\\star} \\in [0, \\mathsf{MAX}]</span> and <span class="math">b&#x27; \\in [0, \\mathsf{MAX}]</span>, where the first equation ties the secret key to the spending public key (without revealing the latter), and the rest two show that the amount being transferred and the remaining amount are in the right range. Summing it up, the user proves the following statement:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{st_{AnonTransfer}} :</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\left( (y_i, C_{L,i}, C_{R,i}, C_i)_{i=1}^n, D, u, g, g_{\\text{epoch}}; \\mathbf{sk}, b^{\\star}, b&#x27;, r, (s_i, t_i)_{i=1}^n \\right) : \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} C_i^{s_i} = g^{b^{\\star}} \\prod_{i=1}^{n} y_i^{r \\cdot s_i} \\wedge \\prod_{i=1}^{n} C_i^{s_i + t_i} = \\prod_{i=1}^{n} y_i^{r \\cdot (s_i + t_i)} \\wedge</span></div>

    <div class="my-4 text-center"><span class="math-block">D = g^r \\wedge \\left( C^{(1 - s_i) \\cdot (1 - t_i)} = y_i^{(1 - s_i) \\cdot (1 - t_i) \\cdot r} \\right)_{i=1}^n \\wedge</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i=1}^{n} \\left(\\frac{C_{L,i}}{C_i}\\right)^{s_i} = g^{b&#x27;} \\left( \\frac{\\prod_{i=1}^{n} C_{R,i}^{s_i}}{D} \\right)^{\\mathbf{sk}} \\wedge g^{\\mathbf{sk}} = \\prod_{i=1}^{n} y_i^{s_i} \\wedge</span></div>

    <div class="my-4 text-center"><span class="math-block">g_{\\text{epoch}}^{\\mathbf{sk}} = u \\wedge (s_i \\in \\{0,1\\} \\wedge t_i \\in \\{0,1\\})_{i=1}^n \\wedge</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left. \\sum_{i=1}^{n} s_i = 1 \\wedge \\sum_{i=1}^{n} t_i = 1 \\wedge b^{\\star} \\in [0, \\mathsf{MAX}] \\wedge b&#x27; \\in [0, \\mathsf{MAX}] \\right\\} \\tag{8}</span></div>

    <p class="text-gray-300">The statement is complex, but in fact highly structured. The resulting proof size can be logarithmic in the range and in the anonymity set. This is done by combining one-out-of-many proofs for showing that two encryptions are non-zero with Bulletproofs for range proofs and for showing that all other encryptions encrypt 0. The proofs can be efficiently combined using our extension of Bulletproofs</p>

    <p class="text-gray-300">called <span class="math">\\Sigma</span>-Bullets (Section G). Even with this efficient proof the transaction size will still be linear in the anonymity set. This is because the sender needs to send an encryption for each account in the anonymity set. This seems inherent as every account needs to be treated equally in an anonymous transfer. This limitation is not present in UTXO-based currencies where constant sized fully anonymous payment systems have been proposed and implemented <em>[64, 3]</em>. Theoretically, the requirement could be removed using fully homomorphic encryption but it remains an open problem whether a more practical solution is available.</p>

    <p class="text-gray-300">Contract. The contract for anonymous version of Zether is described in Figure 5. We discuss below how it differs from ZSC.</p>

    <p class="text-gray-300">Locking. In the anonymous version, (un)locking must not take effect immediately, i.e. in the same epoch as the transaction is published; it must be deferred to the next epoch (see Appendix D.1). Therefore, both Lock and Unlock change entries in the table pLock rather than changing lock directly. Also, the signature given to Lock is on the epoch base instead of the counter.</p>

    <p class="text-gray-300">Rolling over. RollOver also rolls over any changes to the locking address of the input public key (pLock is assigned to lock) now. Some global changes are also made in an epoch. For this, RollOver checks if the last global update <span class="math">t</span> was in a older epoch. If so, then it sets <span class="math">g_{\\text{epoch}}</span> for the current epoch, empties the nonce set <span class="math">\\mathcal{U}</span> and resets <span class="math">t</span>.</p>

    <p class="text-gray-300">Account counters vs nonce set. Anonymous Zether has a different replay protection mechanism, so all the logic related to account counters (initializing them in Fund, incrementing them in Transfer, Burn, Lock) goes away. Instead, nonces <span class="math">u</span> that come with Transfer and Burn are added to the set <span class="math">\\mathcal{U}</span>. This set is reset to null in every epoch.</p>

    <p class="text-gray-300">Burn. A slightly different statement is proved now, denoted by <span class="math">\\mathsf{st}^{\\prime}_{\\text{burn}}</span>. The new statement is same as <span class="math">\\mathsf{st}_{\\text{burn}}</span> but with one additional condition, <span class="math">u=g_{\\text{epoch}}^{\\text{sk}}</span>. On the positive side, there is no need to verify a signature.</p>

    <p class="text-gray-300">Transfer. As we have seen before, the statement <span class="math">\\mathsf{st}_{\\text{AnonTransfer}}</span> is a lot more complex than <span class="math">\\mathsf{st}_{\\text{ConfTransfer}}</span>. Transfer takes a set of <span class="math">n</span> public keys and ciphertexts (instead of just two before), rolls over and checks the locks on each one of them, and then verifies a more complex proof <span class="math">\\pi_{\\text{transfer}}</span>. For all the accounts, the pending transfers table is updated. (Just like Burn, there is no signature verification now.)</p>

    <p class="text-gray-300">User Algorithms. CreateAddress, CreateFundTx, CreateUnlockTx and ReadBalance do not change. CreateBurnTx and CreateTransferTx produce proofs for different statements now. They roll over the input public key(s) not just to make sure that any pending transfers are rolled over, but also to make sure that any pending lock requests take affect. CreateLockTx signs the epoch base instead of the counter.</p>

    <h2 id="sec-52" class="text-2xl font-bold">Appendix E Security Proof</h2>

    <p class="text-gray-300">In this section we provide a proof sketch to show that the anonymous version of Zether satisfies the correctness and security requirements from Appendix B and C. (Security proof of basic Zether is roughly a special case of this.)</p>

    <p class="text-gray-300">Correctness. We first prove that Zether satisfies the correctness definition. Consider a slightly modified version of Zether where RollOver is called on all accounts at the end of each epoch. This only differs from Zether from an efficiency viewpoint as Zether implements lazy roll overs (i.e., every ZSC method rolls over all the accounts it touches in the very beginning of the call). Using this we show that every honestly generated transaction will in fact be processed successfully by ZSC.</p>

    <p class="text-gray-300">Algorithms CreateTransferTx and CreateBurnTx roll over all the input public keys based on the state of the smart contract. Thus, any pending transfers associated with these keys are absorbed into</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fund</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Burn</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">·INPUTS: public key y</td>

            <td class="px-3 py-2 border-b border-gray-700">·INPUTS: - public key y</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. RollOver(y)</td>

            <td class="px-3 py-2 border-b border-gray-700">- balance b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. Let b = msg.value</td>

            <td class="px-3 py-2 border-b border-gray-700">- nonce u</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. require: - b + b_total ≤ MAX - CheckLock(y, msg sender) = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">- proof πburn</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. If acc[y] = ⊥: - Let H = block.number, e = [H/E]</td>

            <td class="px-3 py-2 border-b border-gray-700">1. RollOver(y)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Set acc[y] = (1,1)</td>

            <td class="px-3 py-2 border-b border-gray-700">2. Let (CL, CR) = acc[y]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Set pTransfers[y] = (gb, 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">3. require: - u∉U</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Set lock[y] = pLock[y] = ⊥</td>

            <td class="px-3 py-2 border-b border-gray-700">- CheckLock(y, msg sender) = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Set lastRollOver[y] = e</td>

            <td class="px-3 py-2 border-b border-gray-700">- Verify_nizk(st_burn[y, CL, CR, u, b, g, gepoch], πburn) = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Else: - Set pTransfers[y] = pTransfers[y] ∘ (gb, 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">4. Set U = U ∪ {u}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5. Set b_total = b_total + b</td>

            <td class="px-3 py-2 border-b border-gray-700">5. Set acc[y] = acc[y] ∘ (CL-1, CR-1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Transfer</td>

            <td class="px-3 py-2 border-b border-gray-700">6. Set b_total = b_total - b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">·INPUTS: - set of public keys y = {y1, ..., yn} - ciphertexts (C1, D), (C2, D), ..., (Cn, D) - nonce u - proof πtransfer</td>

            <td class="px-3 py-2 border-b border-gray-700">7. Do msg sender.transfer(b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. For each i ∈ [1, n]: a. RollOver(yi) b. Let (CL,i, CR,i) = acc[yi]</td>

            <td class="px-3 py-2 border-b border-gray-700">Unlock ·INPUTS: public key y</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. Let C = {C1, ..., Cn}</td>

            <td class="px-3 py-2 border-b border-gray-700">1. RollOver(y)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. require: - u∉U</td>

            <td class="px-3 py-2 border-b border-gray-700">2. require: - CheckLock(y, msg sender) = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- CheckLock(yi, msg sender) = 1 for i ∈ [1, n]</td>

            <td class="px-3 py-2 border-b border-gray-700">3. Set pLock[y] = ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Verify_nizk(stAnonTransfer[y, C, D, (CL,i, CR,i)]i=1, u, g, gepoch], πtransfer) = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Internal Helper Methods</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. Set U = U ∪ {u}</td>

            <td class="px-3 py-2 border-b border-gray-700">RollOver ·INPUTS: public key y</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5. For each i ∈ [1, n], set pTransfers[yi] = pTransfers[yi] ∘ (Ci, D)</td>

            <td class="px-3 py-2 border-b border-gray-700">1. Let H = block.number, e = [H/E]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lock</td>

            <td class="px-3 py-2 border-b border-gray-700">2. If lastRollOver[y] < e: - Set acc[y] = acc[y] ∘ pTransfers[y] - Set pTransfers[y] = (1,1) - Set lock[y] = pLock[y] - Set lastRollOver[y] = e</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">·INPUTS: - public key y</td>

            <td class="px-3 py-2 border-b border-gray-700">3. If t < e: - Set gepoch = H(Zether</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">e) - Set U = ∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Ethereum address addr</td>

            <td class="px-3 py-2 border-b border-gray-700">- Set t = e</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  - signature σlock |   |</p>

    <p class="text-gray-300">|  1. RollOver(y) |   |</p>

    <p class="text-gray-300">|  2. require: - CheckLock(y, msg sender) = 1 |   |</p>

    <p class="text-gray-300">|  - Verify_nizk(y, (addr, gepoch), σlock) = 1 |   |</p>

    <p class="text-gray-300">|  3. Set pLock[y] = addr |   |</p>

    <p class="text-gray-300">Figure 5: Smart contract for anonymous version of Zether. CheckLock is same as in Figure 2.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 6: User algorithms for anonymous version of Zether. CreateAddress and ReadBalance are same as in Figure 3.</p>

    <p class="text-gray-300">the respective accounts and any pending lock requests take effect. Transfer and burn transactions are then generated with respect to this new state of the accounts, which will match with the state ZSC will use to process them (as long as the delay is less than the length of an epoch).</p>

    <p class="text-gray-300">Honest users put only those accounts in their anonymity set that are locked to the same address (if any of them is locked at all). Even if one of the account holders changes the lock on his/her account by calling Lock or Unlock, these methods treat the new locking address (which could be  <span class="math">\\bot</span> ) as a pending lock. The lock request will take effect in a subsequent epoch, so transactions generated in this epoch will not be affected.</p>

    <p class="text-gray-300">The rest of the correctness follows from the homomorphic properties of ElGamal encryption as well as the correctness properties of the proof system. Though the encrypted values are in  <span class="math">\\mathbb{Z}_p</span>  and the ideal state handles positive integers, this is not a problem because ZSC takes deposits only up to an amount MAX, a constant much smaller than  <span class="math">p</span> . The homomorphic operations, therefore, would not cause an overflow.</p>

    <p class="text-gray-300">Finally, note that a user is able to create a nonce and as such a transaction or burn per epoch unless  <span class="math">g_{\\mathrm{epoch}} = g_{\\mathrm{epoch}&#x27;}</span>  for epoch  <span class="math">\\neq</span>  epoch'. This however happens with at most negligible probability if the hash function  <span class="math">\\mathcal{H}</span>  is collision resistant.</p>

    <p class="text-gray-300">Overdraft-safety. We show that ZSC methods move the right amount of funds to/from accounts by proving that they satisfy certain properties. An inductive argument would then show that Zether is safe against overdrafts as per Appendix C.1.</p>

    <p class="text-gray-300">Let us consider the method Fund first. Let  <span class="math">(C_L, C_R)</span>  be the (rolled over) state of an account  <span class="math">y</span> . If, hypothetically, Burn is invoked on this state, suppose it returns  <span class="math">b</span>  ETH. Now Fund is called with  <span class="math">b&#x27;</span>  ETH. We show that if Burn is invoked again (hypothetically), it will return no more than  <span class="math">b + b&#x27;</span>  ETH. Since Burn returns  <span class="math">b</span>  on the first invocation, it must be that  <span class="math">C_L = g^b C_R^{\\mathrm{sh}}</span>  due to the soundness property of ZK-proofs. When  <span class="math">b&#x27;</span>  is deposited, pTransfers is set to  <span class="math">(g^{b&#x27;}, 1)</span> . Now when Burn is invoked again, the</p>

    <p class="text-gray-300">state of <span class="math">y</span> will either be <span class="math">(C_L, C_R)</span> or <span class="math">(C_L, C_R) \\circ (g^{b&#x27;}, 1)</span> depending on whether there is a roll over or not. In the first case, only <span class="math">b</span> will satisfy the required relation between <span class="math">C_L</span> and <span class="math">C_R</span>, and, in the second case, only <span class="math">b + b&#x27;</span> will. So, again due to the soundness property, at most <span class="math">b + b&#x27;</span> can be obtained by burning.</p>

    <p class="text-gray-300">Next we consider the method Transfer. Let <span class="math">(y_1, \\ldots, y_n)</span> be the anonymity set, <span class="math">(C_1, D)</span>, ..., <span class="math">(C_n, D)</span> be the ciphertexts, and <span class="math">\\pi_{\\text{transfer}}</span> be the proof for a transfer transaction tx. Let <span class="math">(C_{L,i}, C_{R,i})</span> be the (rolled over) state of the concerned accounts. If Burn is invoked (hypothetically) on these accounts, suppose it returns <span class="math">b_1, \\ldots, b_n</span> ETH, respectively. Now if tx is processed successfully by Transfer, then it must be that there exists a <span class="math">j</span>, <span class="math">k</span> and <span class="math">b^<em></span> s.t. <span class="math">(C_j, D)</span> encrypts <span class="math">-b^</em></span> under <span class="math">y_j</span>, <span class="math">(C_k, D)</span> encrypts <span class="math">b^<em></span> under <span class="math">y_k</span>, and rest of the ciphertexts encrypt 0 (due to the soundness property). Transfer sets pTransfers <span class="math">[y_i]</span> to be <span class="math">(C_i, D)</span> for all <span class="math">i</span>. Thus, when Burn is invoked again on <span class="math">y_i</span>, its state will either be <span class="math">(C_{L,i}, C_{R,i})</span> or <span class="math">(C_{L,i}, C_{R,i}) \\circ (C_i, D)</span> depending on whether there is a roll over or not. For the accounts other than <span class="math">y_j</span> and <span class="math">y_k</span>, the same amount as before will be returned. For <span class="math">y_k</span>, at most <span class="math">b_k + b^</em></span> will be returned. Finally, for <span class="math">y_j</span>, note that no burning can take place in this epoch because transfer has already declared the nonce. When a burn is processed in the next epoch, there will be a roll over changing the account state to <span class="math">(C_{L,i}, C_{R,i}) \\circ (C_i, D)</span>. So Burn will return <span class="math">b_j - b^*</span>. Therefore, we can see that transfer transactions cannot be used to increase the overall Zether balance of the accounts involved. Further note that the nonce along with the soundness of the proof system, enforce that an adversary will at most be able to do a single transfer per account per epoch.</p>

    <p class="text-gray-300">One can similarly analyze the method Burn. We skip the details.</p>

    <p class="text-gray-300">Now we can use a simple inductive argument to show that an adversary which wins Security-Game will break the soundness of the proof system. This happens with at most negligible probability.</p>

    <p class="text-gray-300"><strong>Privacy: Confidentiality &amp; Anonymity.</strong> In Privacy-Game, Adv sends one instruction to Chal every time except once, when it sends two consistent instructions. The consistency requirements prevent Adv from trivially winning the game. If the instructions are for funding, locking or unlocking, then it is easy to see that the adversary has no advantage. Two consistent burn instructions will also not reveal any additional information to Adv due to the zero-knowledge property of the proof system.</p>

    <p class="text-gray-300">We are only left with the case of two consistent transfer instructions. A transfer transaction consists of an anonymity set <span class="math">\\mathbf{y}</span>, a list of commitments <span class="math">\\mathbf{C}</span>, a blinding value <span class="math">D</span>, a nonce <span class="math">u</span>, and <span class="math">\\pi_{\\text{transfer}}</span>. Two consistent transactions could have two different senders, so the nonce values could be different. However, <span class="math">g_{\\text{epoch}}^x</span> (for any <span class="math">x</span>) is indistinguishable from random under the DDH assumption since both <span class="math">y</span> and <span class="math">g_{\\text{epoch}}</span> are random (when <span class="math">\\mathcal{H}</span> is modeled as a random oracle). Further, ciphertexts <span class="math">(C_i, D)</span> for honest <span class="math">i</span> are indistinguishable from the encryption of random messages. Now, let the receivers for the two instructions be <span class="math">j</span> and <span class="math">k</span>. If neither of them are under the control of Adv, then all the ciphertexts Adv can decrypt are just encryptions of 0. Otherwise, both <span class="math">j</span> and <span class="math">k</span> must be corrupt. In this case, Adv can decrypt <span class="math">(C_j, D)</span> and <span class="math">(C_k, D)</span> too, but then they must decrypt to the same amount.</p>

    <h2 id="sec-53" class="text-2xl font-bold">F Discussion and Extensions</h2>

    <p class="text-gray-300">We discuss here certain important things related to the use of Zether.</p>

    <p class="text-gray-300"><strong>Paying gas in ZTH through economic abstraction.</strong> One of the main limitations of the anonymity of Zether comes from the fact that every transaction needs to pay fees in ETH pegged gas. This is not only cumbersome as a ZTH holder needs to maintain both a Zether and an Ethereum account, it can also have consequences for the anonymity of a transaction. Every transaction is initiated by an EOA (see Section 2) and that EOA pays for the gas. Unfortunately, no matter what privacy guarantees Zether has, transactions that are issued by the same EOA are inevitably linked. Even if a user controls multiple EOAs she has to make sure that they remain unlinkable in order to send anonymous transactions on Zether. (The confidentiality of a transaction is not affected by this.)</p>

    <p class="text-gray-300">Ideally, miners could receive transaction fees in ZTH instead of ETH which are by design exchangeable and have as such identical value. In order to do this, a transaction will be sent with a 0 gas price. This</p>

    <p class="text-gray-300">5Anonymity is a hard to achieve goal in general. There are several ways to attack Monero [54, 65] and Zcash [75, 51] for example. Even if an anonymous network like Tor [89] is used, cryptocurrencies can be attacked [7].</p>

    <p class="text-gray-300">means that a newly created unlinked EOA can issue the transaction. Every transaction will specify the fee amount publicly. In the ZK-proof the sender now proves that his new balance is his old balance minus the transacted amount minus the fees. The fees is then sent to a fee pool within the Zether contract that can be spent from without further permission or secrets. A miner can simply insert a raking transaction at the end of the block that pays all of the fees to his account. The fee pool could also be used to fund contract-wide transactions such as RollOver.</p>

    <p class="text-gray-300">The idea of paying fees in a non-native currency is called economic abstraction and has been discussed intensively <em>[18, 80]</em>. The concept is particularly interesting with respect to Zether as it is would make Zether a) more usable and b) more private. The major obstacle to this approach is that miners would need to mine these special 0 gas price transactions and properly rake the fee pool. A similar approach that circumvents the miner adoption problem is to have special delegator nodes that issue the transactions to the network. Users would send their transactions to delegators who will forward them to the miners and will pay the Ethereum gas fees. These delegator nodes could be rewarded in Zether by adding their Zether address to the transaction. The fee amount would not go to the fee pool but to that address.</p>

    <p class="text-gray-300">A general problem for any anonymous blockchain transaction is that transactions need to be relayed to either the miners or the delegators without revealing the original sender’s identity. This problem can be alleviated through anonymous communication networks like Tor <em>[89]</em>.</p>

    <h5 id="sec-54" class="text-base font-semibold mt-4">Zether as a native token.</h5>

    <p class="text-gray-300">Zether can be viewed as a mechanism to do private transactions in an account-based currency. If a currency like Ethereum <em>[39]</em>, Ripple <em>[78]</em>, EOS <em>[38]</em> or Stellar <em>[60]</em> or even a private blockchain like Sequence <em>[84]</em> wanted to introduce private transactions then they can use a Zether style system. While we have presented Zether as a smart contract token that can be run on a smart contract platform, it is also possible to envision Zether becoming the native token of such a platform. Using Zether as a native token has several advantages. As discussed in the previous paragraph, it is important for Zether’s anonymity that miners receive fees in ZTH. This is automatically ensured if ZTH is the native token in which fees are denominated. An additional benefit of Zether as a native token is that denial-of-service protection becomes simpler. Miners can process transactions in an arbitrary order. For example the proofs can be verified <em>before</em> the account balances are transferred. We can potentially remove the requirement of having separate stable and temporary accounts as the ordered processing allows a user to spend ZTH even if they receive funds in the same block. Depending on the block-time, it may still be useful to maintain a temporary and a stable account to allow slightly outdated transactions to be processed correctly.</p>

    <p class="text-gray-300">In Section 7.3, we discuss multiple optimizations that would benefit Zether. If Zether were a native token then these optimizations can be used to make transactions more efficient and scalable. For example, miners can run optimized proof validation software using efficient elliptic curves instead of using Ethereum’s general purpose state machine. Further, Bulletproofs used in our instantiation of Zether can be verified more efficiently when processed in batches <em>[17]</em>. This is beneficial as a fully verifying node can now more efficiently process a proposed block. This property is important in order to protect against the miners’ dilemma <em>[42]</em>, where miners are disincentivized to verify blocks if verification becomes too expensive.</p>

    <h5 id="sec-55" class="text-base font-semibold mt-4">Multiple recipients</h5>

    <p class="text-gray-300">Zether transfer transactions have one recipient only, but quite often Alice may want to send ZTH to several other users at the same time. While Alice can do a separate transfer for every recipient, we can define a new transfer method that accomplishes the same task much more efficiently. Let us consider the simpler case of confidential transactions and recall the statement <span class="math">\\mathsf{st_{ConfTransfer}}</span> (2) from Section 6. Suppose Alice has a balance <span class="math">b</span> and she wants to transfer <span class="math">b_{1}^{\\star},\\ldots,b_{n}^{\\star}</span> to <span class="math">n</span> users.</p>

    <p class="text-gray-300">We know that range proofs are the most expensive components of ZK-proofs in Zether both in terms of communication and computation. If separate transactions are generated, then Alice needs to show a total of <span class="math">2n</span> values to be positive: <span class="math">b_{1}^{\\star}</span>, <span class="math">b-b_{1}^{\\star}</span>, <span class="math">b_{2}^{\\star}</span>, <span class="math">(b-b_{1}^{\\star})-b_{2}^{\\star}</span>, <span class="math">\\ldots</span>, <span class="math">b_{n}^{\\star}</span>, <span class="math">(b-b_{1}^{\\star}-\\ldots-b_{n-1}^{\\star})-b_{n}^{\\star}</span>. Instead, we could generate a single transaction that consists of an encryption of <span class="math">\\hat{b}=b_{1}^{\\star}+\\ldots+b_{n}^{\\star}</span> under Alice’s public key, encryptions of <span class="math">b_{i}^{\\star}</span> under <span class="math">i</span>th user’s public key, range proofs for <span class="math">b_{i}^{\\star}</span>, and a range proof</p>

    <p class="text-gray-300">for the remaining balance <span class="math">b-\\hat{b}</span>. Thus, there will be a total of <span class="math">n+1</span> range proofs as opposed to <span class="math">2n</span>, a saving of about <span class="math">50\\%</span>.</p>

    <p class="text-gray-300">Locking mechanism. When a Zether account is locked to a smart contract, it will only be affected by transactions coming from that contract. Specifically, no one else can deposit or withdraw money from the account. There could be other more flexible ways of locking accounts though. For instance, one could allow locked accounts to be funded from <em>any</em> address.</p>

    <h2 id="sec-56" class="text-2xl font-bold">Appendix G Proofs and <span class="math">\\Sigma</span>-Bullets</h2>

    <p class="text-gray-300">Transfer and AnonTransfer are medium-sized relations that involve proofs on encrypted data. We, therefore, want to use a proving system which a) is efficient, i.e. has short proofs and efficient verification and b) allows proofs on cryptographically encoded data. Bulletproofs <em>[17]</em> is a generic zero-knowledge proof system that produces short (logarithmic sized) proofs without relying on a trusted setup. Bulletproofs was specifically designed to work well with Confidential Transactions <em>[59]</em> as it directly proofs of statements which include values that are committed to in a Pedersen commitment. Its short proofs and trustless setup make Bulletproofs an intriguing choice for Zether’s underlying proof system. However, unlike UTXO-based Confidential Transactions Zether relies on ElGamal encryptions instead of Pedersen commitments. We, therefore, aim to use a proving system similar to Bulletproofs but where we can prove statements on ElGamal encrypted values. Simply replacing Pedersen commitments with ElGamal encryptions is insufficient as ElGamal encryptions cannot be ’opened’ like a commitment and are also not additively homomorphic if encryptions are under different keys, as is the case in Zether. Further for AnonTransfer we need to combine a one-out-of-many proof with range proofs. The one-out of many proof is used to select the receiver and sender transfer encryption and the range proof ensures that no overdraft is created. Bulletproofs enables efficient range proofs and there are logarithmic sized efficient <span class="math">\\Sigma</span> protocols <em>[26]</em> for doing one-out-of-many proofs <em>[49, 14]</em>.</p>

    <p class="text-gray-300">To efficiently prove these statements and instantiate Zether we design <span class="math">\\Sigma</span>-Bullets. <span class="math">\\Sigma</span>-Bullets is an extension of Bulletproofs. It enables the combination of <span class="math">\\Sigma</span>-protocols and Bulletproofs. Concretely given an arithmetic circuit, a <span class="math">\\Sigma</span>-Bullets proof ensures that a public linear combination of the circuit’s wires is equal to some witness of a <span class="math">\\Sigma</span> protocol. This enhancement in turn enables proofs on many different encodings such as ElGamal encryptions, ElGamal commitments or Pedersen commitments in different groups or using different generators. Further it allows the combination of different specialized <span class="math">\\Sigma</span>-protocols such as one-out-of-many proofs or accumulator proofs <em>[21]</em> with the generic circuit-base proof system Bulletproofs. This will benefit other systems that want to prove statements on additively encoded witnesses.</p>

    <p class="text-gray-300"><span class="math">\\Sigma</span>-Bullets. Bulletproofs <em>[17]</em> enable proofs on Pedersen committed values by computing a linear combination of commitments and opening that combination. This uses the homomorphic property of Pedersen commitments that use the same commitment key. The core idea of <span class="math">\\Sigma</span>-Bullets is to replace this linear combination with a <span class="math">\\Sigma</span> protocol. The <span class="math">\\Sigma</span> protocol ensures that the linear combination of the encoded values is equal to some public value. The efficient composability of <span class="math">\\Sigma</span> protocols allows us to combine the opening with other proofs.</p>

    <p class="text-gray-300">We first present a high-level overview of the Bulletproofs protocol and then discuss how we modify it to construct <span class="math">\\Sigma</span>-Bullets. The prover first commits to the circuit’s wires in <span class="math">A</span> and to a vector of blinding values in <span class="math">S</span>. The commitments are Pedersen vector commitments <em>[15]</em>. The prover then receives challenges <span class="math">y,z</span> and commits to polynomial <span class="math">t(X)</span> using a polynomial commitment that can be verifiably opened to an evaluation of <span class="math">t(X)</span>. The prover does not commit to one of the coefficients of the polynomial, e.g. the <span class="math">0</span> coefficient. If the prover is honest then the verifier can compute said coefficient from just the challenges and the commitments to wire values <span class="math">v_{i}</span>s which are committed to in <span class="math">V_{i}</span>. Finally the prover convinces the verifier that <span class="math">t(X)</span> is equal to the inner product of two polynomials with vector</p>

    <p class="text-gray-300">coefficients. The two polynomials can be homomorphically constructed from <span class="math">A</span>, <span class="math">S</span> and the challenges. This final step uses an inner product argument which requires only <span class="math">O(\\log(n))</span> communication where <span class="math">n</span> is the size of the circuit. The protocol can be made non-interactive using the Fiat-Shamir heuristic. Concretely assume that given an arithmetic circuit <span class="math">\\mathsf{Circuit}:\\mathbb{Z}_p^n\\times \\mathbb{Z}_p^m\\to \\{0,1\\}</span> the prover wants to prove the following that she knows <span class="math">\\vec{a}\\in \\mathbb{Z}_p^n,\\vec{v}\\in \\mathbb{Z}_p^m</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">V _ {i} = \\operatorname {E n c o d e} (v _ {i}) \\forall i \\in [ 1, m ], \\operatorname {C i r c u i t} (\\vec {a}, \\vec {v}) = 1</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Commit to wires values <span class="math">\\vec{a}</span> in <span class="math">A</span> |   |</p>

    <p class="text-gray-300">|  Commit to randomness in <span class="math">S</span> |   |</p>

    <p class="text-gray-300">|   | A,S  |</p>

    <p class="text-gray-300">|   | y,z←$Zq  |</p>

    <p class="text-gray-300">|   | y,z  |</p>

    <p class="text-gray-300">|  Use <span class="math">y</span> to combine constraints |   |</p>

    <p class="text-gray-300">|  Such that they can be written as: |   |</p>

    <p class="text-gray-300">|  <span class="math">t(X) + \\sum_{i=1}^{n} z^i v_i = \\langle l(X), r(X) \\rangle \\in \\mathbb{Z}_q</span> |   |</p>

    <p class="text-gray-300">|  <span class="math">\\land t(0) = \\delta(y, z)</span> |   |</p>

    <p class="text-gray-300">|  <span class="math">l(X), r(X) \\in \\mathbb{Z}_q^n \\land \\deg(l, r) \\leq 3</span> |   |</p>

    <p class="text-gray-300">|  <span class="math">T = \\text{Commit}(t(X))</span> |   |</p>

    <p class="text-gray-300">|   | T  |</p>

    <p class="text-gray-300">|   | x←$Zq  |</p>

    <p class="text-gray-300">|   | x  |</p>

    <p class="text-gray-300">|  <span class="math">\\hat{t} = t(x), \\vec{l} = l(x), \\vec{r} = r(x)</span> |   |</p>

    <p class="text-gray-300">|   | <span class="math">\\hat{t}, \\vec{l}, \\vec{r}</span>  |</p>

    <p class="text-gray-300">Now the verifier creates commitment <span class="math">P</span> to <span class="math">l(X), r(X)</span> from <span class="math">A, S, y, z</span> and checks the following condition:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T(0) = t_0</span></li>

      <li><span class="math">Open(T \\cdot \\prod_{i=1}^{m} V_i^{z^i}) + \\delta(y, z) = \\hat{t}</span></li>

      <li><span class="math">Open(P) = \\vec{l}, \\vec{r}</span></li>

      <li><span class="math">\\langle \\vec{l}, \\vec{r} \\rangle = \\hat{t}</span></li>

    </ol>

    <p class="text-gray-300">Note that the second condition requires that <span class="math">T</span> and the <span class="math">V_{i}</span>'s are additively homomorphic. We can therefore not simply replace <span class="math">T</span> and <span class="math">V_{i}</span> with ElGamal encryptions as they are not homomorphic if done under different keys. We generalize the protocol by simply requiring that the prover proves that</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {t} = \\sum_ {i = 1} ^ {m} v _ {i} \\cdot z ^ {i} + \\delta (y, z) + O p e n (T). \\tag {9}</span></div>

    <p class="text-gray-300">Instead of giving the opening of the polynomial commitment to <span class="math">t(X)</span> the verifier instead proofs knowledge of the opening. Concretely this equates to opening the Pedersen commitment <span class="math">T = g^{t}h^{\\tau}</span> by proving knowledge of the blinding value <span class="math">\\tau</span>. This can be achieved through a simple <span class="math">\\Sigma</span> protocol. We show concretely how this can be achieved for <span class="math">m = 2</span> and <span class="math">V_{1}, V_{2}</span> being ElGamal encryptions in the burn proof. We further provide a security proof for that protocol. The security proof for the overall protocol is</p>

    <p class="text-gray-300">40</p>

    <p class="text-gray-300">straightforward if the  <span class="math">\\Sigma</span>  protocol proves a statement that implies (9) while having special-soundness and zero-knowledge properties. The Bulletproof extractor simply extracts the openings of the  <span class="math">V</span> 's from the  <span class="math">\\Sigma</span>  protocol and otherwise proceeds as described in [17]. The simulator uses the  <span class="math">\\Sigma</span>  protocol's simulator to generate a valid looking  <span class="math">\\Sigma</span>  protocol as a sub-routine.</p>

    <p class="text-gray-300">We now proceed by presenting two  <span class="math">\\Sigma</span>  protocols that are vital for Zether.</p>

    <p class="text-gray-300">Burn proof.  <span class="math">\\Sigma</span>  protocol for proving Statement  <span class="math">\\mathsf{st}_{\\mathsf{Burn}}</span></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">Proof sketch. We will show that the sigma protocol is perfectly complete, honest-verifier zero-knowledge and has special-soundness. Completeness is immediate. For zero-knowledge we build a simulator  <span class="math">S</span>  that constructs valid and indistinguishable transcripts given a valid statement  <span class="math">(y, C_L, C_R, u, b, g, g_{\\mathrm{epoch}})</span>  and access to the verifier's state. The simulator will first samples a random challenge  <span class="math">c</span>  a random  <span class="math">s_{\\mathrm{sk}}</span>  and computes  <span class="math">A_y = g^{s_{\\mathrm{sk}}} y^{-c}</span> ,  <span class="math">A_{C_R} = C_R^{s_{\\mathrm{sk}}} \\left( \\frac{C_L}{g^b} \\right)^{-c}</span>  and  <span class="math">A_u = g_{\\mathrm{epoch}}^{s_{\\mathrm{sk}}} u^{-c}</span> . If the verifier is honest, i.e. generates random challenges then  <span class="math">c, s_{\\mathrm{sk}}</span>  are uniformly distributed and  <span class="math">A_y, A_{C_R}, A_u</span>  form DDH tuples. The simulated transcripts are identically distributed. To prove special-soundness we build an extractor that can compute the witness from two accepting transcripts with the same first round message  <span class="math">A_y, A_{C_R}, A_u</span> . The transcripts also contain  <span class="math">(c, s_{\\mathrm{sk}})</span>  and  <span class="math">(c&#x27;, s_{\\mathrm{sk}}&#x27;)</span>  respectively. If both transcripts are accepting then the extractor can output  <span class="math">\\hat{\\mathbf{sk}} = \\frac{s_{\\mathrm{sk}} - s_{\\mathrm{sk}}&#x27;}{c - c&#x27;}</span>  as a valid witness. We can directly deduce from the verification equations that  <span class="math">g^{\\hat{\\mathbf{sk}}} = y \\wedge C_R^{\\hat{\\mathbf{sk}}} = \\frac{C_L}{g^b} \\wedge g_{\\mathrm{epoch}}^{\\hat{\\mathbf{sk}}} = u</span></p>

    <p class="text-gray-300"><span class="math">\\Sigma</span> -Bullets ConfTransfer proof. We will now describe how exactly we use the  <span class="math">\\Sigma</span>  Bullets construction to create an efficient proof for  <span class="math">\\mathsf{st}_{\\mathsf{Transfer}}</span>  the statement which proofs that a ConfTransfer transaction is valid. We will use Bulletproofs to perform the range proofs and use a sigma protocol to proof that the balances are properly encrypted. The conjunction of these two is  <span class="math">\\mathsf{st}_{\\mathsf{ConfTransfer}}</span> .</p>

    <p class="text-gray-300">The  <span class="math">\\Sigma</span>  protocol takes as input the senders public key  <span class="math">y</span>  the receiver's public key  <span class="math">\\hat{y}</span>  and an encryption of the senders balance after the transfer  <span class="math">C_{L,n} = \\frac{C_L}{C}, C_{R,n} = \\frac{C_R}{D}</span> . Further it takes the encryption of the in and outgoing amounts as input, i.e.  <span class="math">C, D, \\overline{C}</span> . Then the bulletproof protocol is run as described above. The  <span class="math">\\Sigma</span>  then also takes in  <span class="math">T</span>  the commitment to  <span class="math">t(X)</span>  as well as an opening of it at the challenge  <span class="math">x</span> :  <span class="math">(\\hat{t})</span> . Note that it is important that the  <span class="math">\\Sigma</span>  protocol is run after the Bulletproofs protocol. In the non-interactive variant this means that the whole Bulletproofs transcript is also hashed in order to generate the  <span class="math">\\Sigma</span>  protocol challenge.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{(y, \\overline {{y}}, C _ {L, n}, C _ {R, n}, C, D, \\overline {{C}}, z, \\dot {t}, \\delta (y, z); \\mathsf {s k}, b ^ {\\star}, b ^ {\\prime}, r, \\tau): \\right. \\\\ C = g ^ {b ^ {\\star}} y ^ {r} \\wedge \\overline {{C}} = g ^ {b ^ {\\star}} \\bar {y} ^ {r} \\wedge D = g ^ {r} \\wedge \\\\ C _ {L, n} = g ^ {b ^ {\\prime}} C _ {R, n} ^ {\\mathrm {s k}} \\wedge g ^ {\\mathrm {s k}} = y \\wedge \\\\ \\left. t = \\dot {t} - \\delta (y, z) \\wedge g ^ {t - b ^ {\\star} \\cdot z ^ {2} - b ^ {\\prime} \\cdot z ^ {3}} h ^ {\\tau} = T _ {1, 2} \\right\\} \\tag {10} \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover(sk,r,b*,b')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ksk,kr,kb,kτ←sZq |   |</p>

    <p class="text-gray-300">|  Ay=gsk |   |</p>

    <p class="text-gray-300">|  AD=Dkr |   |</p>

    <p class="text-gray-300">|  Ab=gkbD-kskz2CR,n-kskz3 |   |</p>

    <p class="text-gray-300">|  Aŷ=(y/ŷ)kr |   |</p>

    <p class="text-gray-300">|  At=g-kbhkr |   |</p>

    <p class="text-gray-300">|   | Ay,AD  |</p>

    <p class="text-gray-300">|   | Ab,Aŷ,At  |</p>

    <p class="text-gray-300">|   | c c←sZq  |</p>

    <p class="text-gray-300">|  sk=ksk+cs |   |</p>

    <p class="text-gray-300">|  sr=kr+cr |   |</p>

    <p class="text-gray-300">|  sb=kb+c(b*z2+b'z3) |   |</p>

    <p class="text-gray-300">|  sτ=kτ+c·τ |   |</p>

    <p class="text-gray-300">|   | sk,sr,sb,sτ  |</p>

    <p class="text-gray-300">|   | Check the following:  |</p>

    <p class="text-gray-300">|   | gsk=Ay  |</p>

    <p class="text-gray-300">|   | gsr=AD  |</p>

    <p class="text-gray-300">|   | gsb(Dz2Cz3R,n)sk=Ab(Cz2Cz3L,n)c  |</p>

    <p class="text-gray-300">|   | (y/ŷ)sr=Ay(C/C)c  |</p>

    <p class="text-gray-300">|   | gt-c-sbhtr=AtT1,2  |</p>

    <p class="text-gray-300">Proof Sketch. We now provide a sketch of our Zether- <span class="math">\\Sigma</span>  protocol is secure and is a proof of knowledge for Relation (10). The protocol is honest verifier zero knowledge because there exists a simulator that can simulate verifying transcripts without access to the witness. The simulator generates a random challenge  <span class="math">c</span>  and random  <span class="math">s_{\\mathbf{sk}}, s_r, s_b, s_\\tau</span> . He then computes  <span class="math">A_y, A_D, A_b, A_{\\hat{y}}</span>  and  <span class="math">A_t</span>  according to the verification equations. If  <span class="math">g, D, \\frac{y}{\\hat{y}}</span>  and  <span class="math">h</span>  are group generators, i.e. not equal to 1, then each  <span class="math">A</span>  value is a random group element in the honest protocol and in the simulated transcript.  <span class="math">A_D</span>  and  <span class="math">A_{\\hat{y}}</span>  form a DDH tuple with basis  <span class="math">g</span>  and  <span class="math">\\frac{y}{\\hat{y}}</span>  which means that they are computationally indistinguishable from the independently sampled  <span class="math">A_D</span>  and  <span class="math">A_{\\hat{y}}</span> .</p>

    <p class="text-gray-300">We prove that the protocol is a proof of knowledge by showing that we can build an extractor. The extractor rewrites the sigma protocol once to receive two accepting transcripts with different challenges and the same first message. Let  <span class="math">c_{2}, s_{\\mathbf{sk},2}, s_{r,2}, s_{b,2}, s_{\\tau,2}</span>  be the second transcript. From them he computes  <span class="math">\\mathbf{sk} = \\frac{s_{\\mathbf{sk}} - s_{\\mathbf{sk},2}}{c - c_{2}}, r = \\frac{s_{r} - s_{r,2}}{c - c_{2}}, b = \\frac{s_{b} - s_{b,2}}{c - c_{2}}, \\tau = \\frac{s_{\\tau} - s_{\\tau,2}}{c - c_{2}}</span> . From the verification equations we can deduce that  <span class="math">y = g^{\\mathbf{sk}}, D^{r}, g^{b} = \\left(\\frac{C}{D^{a}}\\right)^{z^{2}}\\left(\\frac{C_{L,n}}{C_{R,n}^{a}}\\right)^{z^{3}}</span> . Further we also have that  <span class="math">g^{\\hat{t}}h^{\\tau} = g^{b + \\delta (y,z)}T_{1,2}</span> . In order to extract  <span class="math">b^{\\star}</span>  and  <span class="math">b&#x27;</span>  we need to rewind the whole  <span class="math">\\Sigma</span> -Bullets protocol twice to get three executions with different  <span class="math">zs</span> :  <span class="math">(z_{1}, z_{2}, z_{3})</span> . Using the same extraction procedure for the  <span class="math">\\Sigma</span>  protocol we get the extracted witnesses  <span class="math">(\\mathbf{sk}_{i}, r_{i}, b_{i}, \\tau_{i}), i \\in \\{1, 2\\}</span> . First note that  <span class="math">\\mathbf{sk}_{1} = \\mathbf{sk}_{2}</span>  since  <span class="math">g^{\\mathbf{sk}_{1}} = g^{\\mathbf{sk}_{2}} = y</span> . We can now form</p>

    <p class="text-gray-300">the equations:</p>

    <p class="text-gray-300"><span class="math">g^{b_{1}}=(\\frac{C}{D^{\\mathsf{sk}}})^{z_{1}^{2}}(\\frac{C_{L,n}}{C^{\\mathsf{sk}}_{R,n}})^{z_{1}^{3}}</span> <span class="math">g^{b_{2}}=(\\frac{C}{D^{\\mathsf{sk}}})^{z_{2}^{2}}(\\frac{C_{L,n}}{C^{\\mathsf{sk}}_{R,n}})^{z_{2}^{3}}</span></p>

    <p class="text-gray-300">One can now easily find a linear combination of these equations to compute <span class="math">b^{\\star}</span> such that <span class="math">g^{b^{\\star}}=\\frac{C}{D^{\\mathsf{sk}}}</span> and <span class="math">b^{\\prime}</span> such that <span class="math">g^{b^{\\prime}}=\\frac{C_{L,n}}{C^{\\mathsf{sk}}_{R,n}}</span>. This shows that we can successfully extract a witness <span class="math">(\\mathsf{sk},b^{\\star},b^{\\prime},r)</span> such that the statement <span class="math">(y,\\overline{y},C_{L,n},C_{R,n},C,D,\\overline{C},z,\\hat{t},\\delta(y,z);\\mathsf{sk},b^{\\star},b^{\\prime},r,\\tau)</span> is in Relation (10).</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">G.1 Signatures</h3>

    <p class="text-gray-300">Zether not only uses zero-knowledge proofs but also heavily relies on signatures. Instead of instantiating a separate signature scheme we can leverage our zero-knowledge proofs to also provide signature functionality. All of the ZK-proofs in our instantiation of Zether are derived from interactive proofs and then transformed to non-interactive proofs using the Fiat-Shamir heuristic <em>[45, 4]</em>. The Fiat-Shamir heuristic and its extension to multi-round protocol transform an interactive public-coin proof into a non-interactive proof by generating the verifiers’ messages from the hash of the transcript. There exists a simple transformation that creates a signature scheme from such a proof system <em>[2]</em>. Concretely, if the prover shows knowledge of a private key and then appends the message to the transcript before generating the challenge, then the proof also acts as a signature. This leads to signatures that can be generated and verified at almost no additional cost.</p>`;
---

<BaseLayout title="Zether: Towards Privacy in a Smart Contract World (2019/191)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/191
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
