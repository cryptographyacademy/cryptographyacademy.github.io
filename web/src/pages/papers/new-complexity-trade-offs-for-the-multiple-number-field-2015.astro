---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/944';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'New Complexity Trade-Offs for the (Multiple) Number Field Sieve Algorithm in Non-Prime Fields';
const AUTHORS_HTML = 'Palash Sarkar, Shashank Singh';

const CONTENT = `    <p class="text-gray-300">Palash Sarkar and Shashank Singh</p>

    <p class="text-gray-300">Applied Statistics Unit Indian Statistical Institute palash@isical.ac.in, sha2nk.singh@gmail.com</p>

    <p class="text-gray-300">Abstract. The selection of polynomials to represent number fields crucially determines the efficiency of the Number Field Sieve (NFS) algorithm for solving the discrete logarithm in a finite field. An important recent work due to Barbulescu et al. builds upon existing works to propose two new methods for polynomial selection when the target field is a non-prime field. These methods are called the generalised Joux-Lercier (GJL) and the Conjugation methods. In this work, we propose a new method (which we denote as <span class="math">\\mathcal{A}</span>) for polynomial selection for the NFS algorithm in fields <span class="math">\\mathbb{F}_Q</span>, with <span class="math">Q = p^n</span> and <span class="math">n &amp;gt; 1</span>. The new method both subsumes and generalises the GJL and the Conjugation methods and provides new trade-offs for both <span class="math">n</span> composite and <span class="math">n</span> prime. Let us denote the variant of the (multiple) NFS algorithm using the polynomial selection method "X" by (M)NFS-X. Asymptotic analysis is performed for both the NFS-<span class="math">\\mathcal{A}</span> and the MNFS-<span class="math">\\mathcal{A}</span> algorithms. In particular, when <span class="math">p = L_Q(2/3, c_p)</span>, for <span class="math">c_p \\in [3.39, 20.91]</span>, the complexity of NFS-<span class="math">\\mathcal{A}</span> is better than the complexities of all previous algorithms whether classical or MNFS. The MNFS-<span class="math">\\mathcal{A}</span> algorithm provides lower complexity compared to NFS-<span class="math">\\mathcal{A}</span> algorithm; for <span class="math">c_p \\in (0, 1.12] \\cup [1.45, 3.15]</span>, the complexity of MNFS-<span class="math">\\mathcal{A}</span> is the same as that of the MNFS-Conjugation and for <span class="math">c_p \\notin (0, 1.12] \\cup [1.45, 3.15]</span>, the complexity of MNFS-<span class="math">\\mathcal{A}</span> is lower than that of all previous methods.</p>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{G} = \\langle \\mathfrak{g} \\rangle</span> be a finite cyclic group. The discrete log problem (DLP) in <span class="math">\\mathfrak{G}</span> is the following. Given <span class="math">(\\mathfrak{g}, \\mathfrak{h})</span>, compute the minimum non-negative integer <span class="math">\\mathfrak{e}</span> such that <span class="math">\\mathfrak{h} = \\mathfrak{g}^{\\mathfrak{e}}</span>. For appropriately chosen groups <span class="math">\\mathfrak{G}</span>, the DLP in <span class="math">\\mathfrak{G}</span> is believed to be computationally hard. This forms the basis of security of many important cryptographic protocols.</p>

    <p class="text-gray-300">Studying the hardness of the DLP on subgroups of the multiplicative group of a finite field is an important problem. There are two general algorithms for tackling the DLP on such groups. These are the function field sieve (FFS) [1,2, 16, 18] algorithm and the number field sieve (NFS) [11, 17, 19] algorithm. Both these algorithms follow the framework of index calculus algorithms which is currently the standard approach for attacking the DLP in various groups.</p>

    <p class="text-gray-300">For small characteristic fields, the FFS algorithm leads to a quasi-polynomial running time <em>[6]</em>. Using the FFS algorithm outlined in <em>[15, 6]</em>, Granger et al. <em>[12]</em> reported a record computation of discrete log in the binary extension field <span class="math">\\mathbb{F}_{2^{n_{234}}}</span>. FFS also applies to the medium characteristic fields. Some relevant works along this line are reported in <em>[18, 14, 25]</em>.</p>

    <p class="text-gray-300">For medium to large characteristic finite fields, the NFS algorithm is the state-of-the-art. In the context of the DLP, the NFS was first proposed by Gordon <em>[11]</em> for prime order fields. The algorithm proceeded via number fields and one of the main difficulties in applying the NFS was in the handling of units in the corresponding ring of algebraic integers. Schirokauer <em>[26, 28]</em> proposed a method to bypass the problems caused by units. Further, Schirokauer <em>[27]</em> showed the application of the NFS algorithm to composite order fields. Joux and Lercier <em>[17]</em> presented important improvements to the NFS algorithm as applicable to prime order fields.</p>

    <p class="text-gray-300">Joux, Lercier, Smart and Vercauteren <em>[19]</em> later showed that the NFS algorithm is applicable to all finite fields. Since then, several works <em>[20, 5, 13, 24]</em> have gradually improved the NFS in the context of medium to large characteristic finite fields.</p>

    <p class="text-gray-300">The efficiency of the NFS algorithm is crucially dependent on the properties of the polynomials used to construct the number fields. Consequently, polynomial selection is an important step in the NFS algorithm and is an active area of research. The recent work <em>[5]</em> by Barbulescu et al. extends a previous method <em>[17]</em> for polynomial selection and also presents a new method. The extension of <em>[17]</em> is called the generalised Joux-Lercier (GJL) method while the new method proposed in <em>[5]</em> is called the Conjugation method. The paper also provides a comprehensive comparison of the trade-offs in the complexity of the NFS algorithm offered by the various polynomial selection methods.</p>

    <p class="text-gray-300">The NFS based algorithm has been extended to multiple number field sieve algorithm (MNFS). The work <em>[8]</em> showed the application of the MNFS to medium to high characteristic finite fields. Pierrot <em>[24]</em> proposed MNFS variants of the GJL and the Conjugation methods. For more recent works on NFS we refer to <em>[7, 22, 4]</em>.</p>

    <p class="text-gray-300">Our contributions: In this work, we build on the works of <em>[17, 5]</em> to propose a new method of polynomial selection for NFS over <span class="math">\\mathbb{F}_{p^{n}}</span>. The new method both subsumes and generalises the GJL and the Conjugation methods. There are two parameters to the method, namely a divisor <span class="math">d</span> of the extension degree <span class="math">n</span> and a parameter <span class="math">r\\geq k</span> where <span class="math">k=n/d</span>.</p>

    <p class="text-gray-300">For <span class="math">d=1</span>, the new method becomes the same as the GJL method. For <span class="math">d=n</span> and <span class="math">r=k=1</span>, the new method becomes the same as the Conjugation method. For <span class="math">d=n</span> and <span class="math">r&gt;1</span>; or, for <span class="math">1&lt;d&lt;n</span>, the new method provides polynomials which leads to different trade-offs than what was previously known. Note that the case <span class="math">1&lt;d&lt;n</span> can arise only when <span class="math">n</span> is composite, though the case <span class="math">d=n</span> and <span class="math">r&gt;1</span> arises even when <span class="math">n</span> is prime. So, the new method provides new trade-offs for both <span class="math">n</span> composite and <span class="math">n</span> prime.</p>

    <p class="text-gray-300">Following the works of <em>[5, 24]</em> we carry out an asymptotic analysis of new method for the classical NFS as well as for MNFS. For the medium and the large characteristic cases, the results for the new method are exactly the same as those obtained for existing methods in <em>[5, 24]</em>. For the boundary case, however, we obtain some interesting asymptotic results. Letting <span class="math">Q=p^{n}</span>, the subexponential expression <span class="math">L_{Q}(a,c)</span> is defined to be the following:</p>

    <p class="text-gray-300"><span class="math">L_{Q}(a,c)=\\exp\\left((c+o(1))(\\ln Q)^{a}(\\ln\\ln Q)^{1-a}\\right).</span> (1)</p>

    <p class="text-gray-300">Write <span class="math">p=L_{Q}(2/3,c_{p})</span> and let <span class="math">\\theta_{0}</span> and <span class="math">\\theta_{1}</span> be such that the complexity of the MNFS-Conjugation method is <span class="math">L_{Q}(1/3,\\theta_{0})</span> and the complexity of the MNFS-GJL method is <span class="math">L_{Q}(1/3,\\theta_{1})</span>. As shown in <em>[24]</em>, <span class="math">L_{Q}(1/3,\\theta_{0})</span> is the minimum complexity of MNFS while for <span class="math">c_{p}&gt;4.1</span>, complexity of new method (MNFS-<span class="math">\\mathcal{A}</span>) is lower than the complexity <span class="math">L_{Q}(1/3,\\theta_{1})</span> of MNFS-GJL method.</p>

    <p class="text-gray-300">The classical variant of the new method, (i.e., NFS-<span class="math">\\mathcal{A}</span>) itself is powerful enough to provide better complexity than all previously known methods, whether classical or MNFS, for <span class="math">c_{p}\\in[3.39,20.91]</span>. The MNFS variant of the new method provides lower complexity compared to the classical variant of the new method for all <span class="math">c_{p}</span>.</p>

    <p class="text-gray-300">The complexity of MNFS-<span class="math">\\mathcal{A}</span> with <span class="math">k=1</span> and using linear sieving polynomials can be written as <span class="math">L_{Q}(1/3,\\mathbf{C}(c_{p},r))</span>, where <span class="math">\\mathbf{C}(c_{p},r)</span> is a function of <span class="math">c_{p}</span> and a parameter <span class="math">r</span>. For every integer <span class="math">r\\geq 1</span>, there is an interval <span class="math">[\\epsilon_{0}(r),\\epsilon_{1}(r)]</span> such that for <span class="math">c_{p}\\in[\\epsilon_{0}(r),\\epsilon_{1}(r)]</span>, <span class="math">\\mathbf{C}(c_{p},r)&lt;\\mathbf{C}(c_{p},r^{\\prime})</span> for <span class="math">r\\neq r^{\\prime}</span>. Further, for a fixed <span class="math">r</span>, let <span class="math">C(r)</span> be the minimum value of <span class="math">\\mathbf{C}(c_{p},r)</span> over all <span class="math">c_{p}</span>. We show that <span class="math">C(r)</span> is monotone increasing for <span class="math">r\\geq 1</span>; <span class="math">C(1)=\\theta_{0}</span>; and that <span class="math">C(r)</span> is bounded above by <span class="math">\\theta_{1}</span> which is its limit as <span class="math">r</span> goes to infinity. So, for the new method the minimum</p>

    <p class="text-gray-300">complexity is the same as MNFS-Conjugation method. On the other hand, as <span class="math">r</span> increases, the complexity of MNFS-<span class="math">\\mathcal{A}</span> remains lower than the complexities of all the prior known methods. In particular, the complexity of MNFS-<span class="math">\\mathcal{A}</span> interpolates nicely between the complexity of the MNFS-GJL and the minimum possible complexity of the MNFS-Conjugation method. This is depicted in Figure 1. In Figure 4 of Section 8.1, we provide a more detailed plot of the complexity of MNFS-<span class="math">\\mathcal{A}</span> in the boundary case.</p>

    <p class="text-gray-300">The complete statement regarding the complexity of MNFS-<span class="math">\\mathcal{A}</span> in the boundary case is the following. For <span class="math">c_{p}\\in(0,1.12]\\cup[1.45,3.15]</span>, the complexity of MNFS-<span class="math">\\mathcal{A}</span> is the same as that of MNFS-Conjugation; for <span class="math">c_{p}\\notin(0,1.12]\\cup[1.45,3.15]</span>, the complexity of MNFS-<span class="math">\\mathcal{A}</span> is lower than that of all previous methods. In particular, the improvements for <span class="math">c_{p}</span> in the range <span class="math">(1.12,1.45)</span> is obtained using <span class="math">k=2</span> and <span class="math">3</span>; while the improvements for <span class="math">c_{p}&gt;3.15</span> is obtained using <span class="math">k=1</span> and <span class="math">r&gt;1</span>. In all cases, the minimum complexity is obtained using linear sieving polynomials.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Background on NFS for Non-Prime Fields</h2>

    <p class="text-gray-300">We provide a brief sketch of the background on the variant of the NFS algorithm that is applicable to the extension fields <span class="math">\\mathbb{F}_{Q}</span>, where <span class="math">Q=p^{n}</span>, <span class="math">p</span> is a prime and <span class="math">n&gt;1</span>. More detailed discussions can be found in <em>[17, 5]</em>.</p>

    <p class="text-gray-300">Following the structure of index calculus algorithms, NFS has three main phases, namely, relation collection (sieving), linear algebra and descent. Prior to these, is the set-up phase. In the set-up phase, two number fields are constructed and the sieving parameters are determined. The two number fields are set up by choosing two irreducible polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> over the integers such that their reductions modulo <span class="math">p</span> have a common irreducible factor <span class="math">\\varphi(x)</span> of degree <span class="math">n</span> over <span class="math">\\mathbb{F}_{p}</span>. The field <span class="math">\\mathbb{F}_{p^{n}}</span> will be considered to be represented by <span class="math">\\varphi(x)</span>. Let <span class="math">\\mathfrak{g}</span> be a generator of <span class="math">\\mathfrak{G}=\\mathbb{F}_{k^{n}}^{*}</span> and let <span class="math">q</span> be the largest prime dividing the order of <span class="math">\\mathfrak{G}</span>. We are interested in the discrete log of elements of <span class="math">\\mathfrak{G}</span> to the base <span class="math">\\mathfrak{g}</span> modulo this largest prime <span class="math">q</span>.</p>

    <p class="text-gray-300">The choices of the two polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> are crucial to the algorithm. These greatly affect the overall run time of the algorithm. Let <span class="math">\\alpha,\\beta\\in\\mathbb{C}</span> and <span class="math">m\\in\\mathbb{F}_{p^{n}}</span> be the roots of the polynomials <span class="math">f(x),\\ g(x)</span> and <span class="math">\\varphi(x)</span> respectively. We further let <span class="math">l(f)</span> and <span class="math">l(g)</span> denote the leading coefficient of the polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> respectively. The two number fields and the finite field are given as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathbb{K}_{1}=\\mathbb{Q}(\\alpha)=\\frac{\\mathbb{Q}[x]}{\\langle f(x)\\rangle},\\,\\mathbb{K}_{2}=\\mathbb{Q}(\\beta)=\\frac{Q[x]}{\\langle g(x)\\rangle}\\text{ and }\\mathbb{F}_{p^{n}}=\\mathbb{F}_{p}(m)=\\frac{\\mathbb{F}_{p}[x]}{\\langle\\varphi(x)\\rangle}.</span></p>

    <p class="text-gray-300">Thus, we have the following commutative diagram shown in Figure 2, where we represent the image of <span class="math">\\xi\\in\\mathbb{Z}(\\alpha)</span> or <span class="math">\\xi\\in\\mathbb{Z}(\\beta)</span> in the finite field <span class="math">\\mathbb{F}_{p^{n}}</span> by <span class="math">\\overline{\\xi}</span>. Actual computations are carried out over these number fields and are then transformed to the finite field via these homomorphisms. In fact, instead of doing the computations over the whole number field <span class="math">\\mathbb{K}_{i}</span>, one works over its ring</p>

    <p class="text-gray-300">of algebraic integers <span class="math">\\mathcal{O}_i</span>. These integer rings provide a nice way of constructing a factor basis and moreover, unique factorisation of ideals holds over these rings.</p>

    <p class="text-gray-300">The factor basis <span class="math">\\mathcal{F} = \\mathcal{F}_1 \\cup \\mathcal{F}_2</span> is chosen as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {F} _ {1} = \\left\\{ \\begin{array}{c} \\text {prime ideals } \\mathfrak {q} _ {1, j} \\text { in } \\mathcal {O} _ {1}, \\text { either having norm less than } B \\\\ \\text {or lying above the prime factors of } l (f) \\end{array} \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {F} _ {2} = \\left\\{ \\begin{array}{c} \\text {prime ideals } \\mathfrak {q} _ {2, j} \\text { in } \\mathcal {O} _ {2}, \\text { either having norm less than } B \\\\ \\text {or lying above the prime factors of } l (g) \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">where <span class="math">B</span> is the smoothness bound and is to be chosen appropriately. An algebraic integer is said to be <span class="math">B</span>-smooth if the principal ideal generated by it factors into the prime ideals of norms less than <span class="math">B</span>. As mentioned in the paper [5], independently of choice of <span class="math">f</span> and <span class="math">g</span>, the size of the factor basis is <span class="math">B^{1 + o(1)}</span>. For asymptotic computations, this is simply taken to be <span class="math">B</span>. The work flow of NFS can be understood by the diagram in Figure 2.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 2. A work-flow of NFS.</p>

    <p class="text-gray-300">A polynomial <span class="math">\\phi(x) \\in \\mathbb{Z}[x]</span> of degree at most <span class="math">t - 1</span> (i.e. having <span class="math">t</span> coefficients) is chosen and the principal ideals generated by its images in the two number fields are checked for smoothness. If both of them are smooth, then</p>

    <div class="my-4 text-center"><span class="math-block">\\phi (\\alpha) \\mathcal {O} _ {1} = \\prod_ {j} \\mathfrak {q} _ {1, j} ^ {e _ {j}} \\text { and } \\phi (\\beta) \\mathcal {O} _ {2} = \\prod_ {j} \\mathfrak {q} _ {2, j} ^ {e _ {j} ^ {\\prime}} \\tag {2}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathfrak{q}_{1,j}</span> and <span class="math">\\mathfrak{q}_{2,j}</span> are prime ideals in <span class="math">\\mathcal{F}_1</span> and <span class="math">\\mathcal{F}_2</span> respectively. For <span class="math">i = 1,2</span>, let <span class="math">h_i</span> denote the class number of <span class="math">\\mathcal{O}_i</span> and <span class="math">r_i</span> denote the torsion-free rank of <span class="math">\\mathcal{O}_i^\\star</span>. Then, for some <span class="math">\\varepsilon_{i,j} \\in \\mathfrak{q}_{i,j}</span> and units <span class="math">u_{i,j} \\in \\mathcal{O}_i^\\star</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\log_ {g} \\overline {{\\phi (\\alpha)}} \\equiv \\sum_ {j = 1} ^ {r _ {1}} \\lambda_ {1, j} (\\phi (\\alpha)) \\Lambda_ {1, j} + \\sum_ {j} e _ {j} X _ {1, j} \\quad (\\mathrm {mod} q), \\tag {3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\log_ {g} \\overline {{\\phi (\\beta)}} \\equiv \\sum_ {j = 1} ^ {r _ {2}} \\lambda_ {2, j} (\\phi (\\beta)) \\Lambda_ {2, j} + \\sum_ {j} e _ {j} ^ {\\prime} X _ {2, j} \\quad (\\mathrm {mod} q), \\tag {4}</span></div>

    <p class="text-gray-300">where for <span class="math">i = 1,2</span> and <span class="math">j = 1\\ldots r_i</span>, <span class="math">\\Lambda_{i,j} = \\log_q\\overline{u_{i,j}}</span> is an unknown virtual logarithm of the unit <span class="math">u_{i,j}</span>, <span class="math">X_{i,j} = h_i^{-1}\\log_q\\overline{\\varepsilon_{i,j}}</span> is an unknown virtual logarithm</p>

    <p class="text-gray-300">of prime ideal <span class="math">\\mathfrak{q}_{i,j}</span> and <span class="math">\\lambda_{i,j}:\\mathcal{O}_{i}\\mapsto\\mathbb{Z}/q\\mathbb{Z}</span> is Schirokauer map <em>[26, 28, 19]</em>. We skip the details of virtual logarithms and Schirokauer maps, as these details will not affect the polynomial selection problem considered in this work.</p>

    <p class="text-gray-300">Since <span class="math">\\overline{\\phi\\left(\\alpha\\right)}=\\overline{\\phi\\left(\\beta\\right)}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\textstyle\\sum_{j=1}^{r_{1}}\\lambda_{1,j}\\left(\\,\\phi\\left(\\alpha\\right)\\right)\\Lambda_{1,j}+\\sum_{j}e_{j}X_{1,j}\\equiv\\sum_{j=1}^{r_{2}}\\lambda_{2,j}\\left(\\,\\phi\\left(\\beta\\right)\\right)\\Lambda_{2,j}+\\sum_{j}e^{\\prime}_{j}X_{2,j}(\\mathrm{mod}\\ q)</span> (5)</p>

    <p class="text-gray-300">The relation given by (5) is a linear equation modulo <span class="math">q</span> in the unknown virtual logs. More than (<span class="math">\\#\\mathcal{F}_{1}+\\#\\mathcal{F}_{2}+r_{1}+r_{2}</span>) such relations are collected by sieving over suitable <span class="math">\\phi(x)</span>. The linear algebra step solves the resulting system of linear equations using either the Lanczos or the block Wiedemann algorithms to obtain the virtual logs of factor basis elements.</p>

    <p class="text-gray-300">After the linear algebra phase is over, the descent phase is used to compute the discrete logs of the given elements of the field <span class="math">\\mathbb{F}_{p^{n}}</span>. For a given element <span class="math">\\mathfrak{y}</span> of <span class="math">\\mathbb{F}_{p^{n}}</span>, one looks for an element of the form <span class="math">\\mathfrak{y}^{i}\\mathfrak{g}^{j}</span>, for some <span class="math">i,j\\in\\mathbb{N}</span>, such that the principal ideal generated by preimage of <span class="math">\\left(\\mathfrak{y}^{i}\\mathfrak{g}^{j}\\right)</span> in <span class="math">\\mathcal{O}_{1}</span>, factors into prime ideals of norms bounded by some bound <span class="math">B_{1}</span> and of degree at most <span class="math">t-1</span>. Then the special-<span class="math">\\mathfrak{q}</span> descent technique <em>[19]</em> is used to write the ideal generated by the preimage as a product of prime ideals in <span class="math">\\mathcal{F}_{1}</span>, which is then converted into a linear equation involving virtual logs. Putting the value of virtual logs, obtained after linear algebra phase, the value of <span class="math">\\log_{\\mathfrak{g}}(\\mathfrak{y})</span> is obtained. For more details and recent work on the descent phase, we refer to <em>[19, 13]</em>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Polynomial Selection and Sizes of Norms</h2>

    <p class="text-gray-300">It is evident from the description of NFS that the relation collection phase requires polynomials <span class="math">\\phi(x)\\in\\mathbb{Z}[x]</span> whose images in the two number fields are simultaneously smooth. For ensuring the smoothness of <span class="math">\\phi(\\alpha)</span> and <span class="math">\\phi(\\beta)</span>, it is enough to ensure that their norms viz, <span class="math">\\mathrm{Res}(f,\\phi)</span> and <span class="math">\\mathrm{Res}(g,\\phi)</span> are <span class="math">B</span>-smooth. We refer to <em>[5]</em> for further explanations.</p>

    <p class="text-gray-300">Using the Corollary 2 of Kalkbrenerâ€™s work <em>[21]</em>, we have the following upper bound for the absolute value of the norm.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Res}(f,\\phi)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\kappa\\left(\\deg f,\\deg\\phi\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg\\phi}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg f}$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\kappa(a,b)=\\binom{a+b}{a}\\binom{a+b-1}{a}</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> is maximum of the absolute values of the coefficients of </span>f$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Following <em>[5]</em>, let <span class="math">E</span> be such that the coefficients of <span class="math">\\phi</span> are in <span class="math">\\left[-\\frac{1}{2}E^{2/t},\\frac{1}{2}E^{2/t}\\right]</span>. So, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx E^{2/t}<span class="math"> and the number of polynomials </span>\\phi(x)<span class="math"> that is considered for the sieving is </span>E^{2}<span class="math">. Whenever </span>p=L_{Q}(a,c_{p})<span class="math"> with </span>a>\\frac{1}{3}<span class="math">, we have the following bound on the </span>\\mathrm{Res}(f,\\phi)\\times\\mathrm{Res}(g,\\phi)$ (for details we refer to <em>[5]</em>).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Res}(f,\\phi)\\times\\mathrm{Res}(g,\\phi)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx\\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)^{t-1}E^{(\\deg f+\\deg g)2/t}.$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For small values of <span class="math">n</span>, the sieving polynomial <span class="math">\\phi(x)</span> is taken to be linear, i.e., <span class="math">t=2</span> and then the norm bound becomes approximately $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}E^{(\\deg f+\\deg g)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The methods for choosing  <span class="math">f</span>  and  <span class="math">g</span>  result in the coefficients of one or both of these polynomials to depend on  <span class="math">Q</span> . So, the right hand side of (7) is determined by  <span class="math">Q</span>  and  <span class="math">E</span> . All polynomial selection algorithms try to minimize the RHS of (7). From the bound in (7), it is evident that during polynomial selection, the goal should be to try and keep the degrees and the coefficients of both  <span class="math">f</span>  and  <span class="math">g</span>  to be small. Ensuring both degrees and coefficients to be small is a nontrivial task and leads to a trade-off. Previous methods for polynomial selections provide different trade-offs between the degrees and the coefficients. Estimates of  <span class="math">Q - E</span>  trade-off values have been provided in [5] and is based on the CADO factoring software [3]. Table 1 reproduces these values where  <span class="math">Q(dd)</span>  represents the number of decimal digits in  <span class="math">Q</span> .</p>

    <p class="text-gray-300">Table 1. Estimate of  <span class="math">Q - E</span>  values [5].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(dd)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">100</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">120</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">140</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">160</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">180</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">200</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">240</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">280</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">300</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q(bits)</td>

            <td class="px-3 py-2 border-b border-gray-700">333</td>

            <td class="px-3 py-2 border-b border-gray-700">399</td>

            <td class="px-3 py-2 border-b border-gray-700">466</td>

            <td class="px-3 py-2 border-b border-gray-700">532</td>

            <td class="px-3 py-2 border-b border-gray-700">598</td>

            <td class="px-3 py-2 border-b border-gray-700">665</td>

            <td class="px-3 py-2 border-b border-gray-700">731</td>

            <td class="px-3 py-2 border-b border-gray-700">798</td>

            <td class="px-3 py-2 border-b border-gray-700">864</td>

            <td class="px-3 py-2 border-b border-gray-700">931</td>

            <td class="px-3 py-2 border-b border-gray-700">997</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E(bits)</td>

            <td class="px-3 py-2 border-b border-gray-700">20.9</td>

            <td class="px-3 py-2 border-b border-gray-700">22.7</td>

            <td class="px-3 py-2 border-b border-gray-700">24.3</td>

            <td class="px-3 py-2 border-b border-gray-700">25.8</td>

            <td class="px-3 py-2 border-b border-gray-700">27.2</td>

            <td class="px-3 py-2 border-b border-gray-700">28.5</td>

            <td class="px-3 py-2 border-b border-gray-700">29.7</td>

            <td class="px-3 py-2 border-b border-gray-700">30.9</td>

            <td class="px-3 py-2 border-b border-gray-700">31.9</td>

            <td class="px-3 py-2 border-b border-gray-700">33.0</td>

            <td class="px-3 py-2 border-b border-gray-700">34.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As mentioned in [5, 13], presently the following three polynomial selection methods provide competitive trade-offs.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>JLSV1: Joux, Lercier, Smart, Vercauteren method [19].</li>

      <li>GJL: Generalised Joux Lercier method [23, 5].</li>

      <li>Conjugation method [5].</li>

    </ol>

    <p class="text-gray-300">Brief descriptions of these methods are given below.</p>

    <p class="text-gray-300">JLSV1. Repeat the following steps until  <span class="math">f</span>  and  <span class="math">g</span>  are obtained to be irreducible over  <span class="math">\\mathbb{Z}</span>  and  <span class="math">\\varphi</span>  is irreducible over  <span class="math">\\mathbb{F}_p</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomly choose polynomials  <span class="math">f_0(x)</span>  and  <span class="math">f_1(x)</span>  having small coefficients with  <span class="math">\\deg(f_1) &amp;lt; \\deg(f_0) = n</span> .</li>

      <li>Randomly choose an integer  <span class="math">\\ell</span>  to be slightly greater than  <span class="math">\\lceil \\sqrt{p} \\rceil</span> .</li>

      <li>Let  <span class="math">(u,v)</span>  be the rational reconstruction of  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{F}_p</span> , i.e.,  <span class="math">\\ell \\equiv u / v \\bmod p</span> .</li>

      <li>Define  <span class="math">f(x) = f_0(x) + \\ell f_1(x)</span>  and  <span class="math">g(x) = vf_0(x) + uf_1(x)</span>  and  <span class="math">\\varphi(x) = f(x) \\mod p</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  <span class="math">\\deg(f) = \\deg(g) = n</span>  and both  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  are  </span>O\\left(p^{1/2}\\right) = O\\left(Q^{1/(2n)}\\right)<span class="math">  and so (7) becomes  </span>E^{4n/t}Q^{(t-1)/n}<span class="math">  which is  </span>E^{2n}Q^{1/n}<span class="math">  for  </span>t = 2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">GJL. The basic Joux-Lercier method [17] works for prime fields. The generalised Joux-Lercier method extends the basic Joux-Lercier method to work over composite fields  <span class="math">\\mathbb{F}_{p^n}</span> .</p>

    <p class="text-gray-300">The heart of the GJL method is the following idea. Let <span class="math">\\varphi(x)</span> be a monic polynomial <span class="math">\\varphi(x) = x^n + \\varphi_{n-1}x^{n-1} + \\cdots + \\varphi_1x + \\varphi_0</span> and <span class="math">r \\geq \\deg(\\varphi)</span> be an integer. Let <span class="math">n = \\deg(\\varphi)</span>. Given <span class="math">\\varphi(x)</span> and <span class="math">r</span>, define an <span class="math">(r+1) \\times (r+1)</span> matrix <span class="math">M_{\\varphi,r}</span> in the following manner.</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\varphi , r} = \\left[ \\begin{array}{c c c c c c} p &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; p &amp;amp; &amp;amp; \\\\ \\varphi_ {0} &amp;amp; \\varphi_ {1} &amp;amp; \\dots &amp;amp; \\varphi_ {n - 1} &amp;amp; 1 &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; \\varphi_ {0} &amp;amp; \\varphi_ {1} &amp;amp; \\dots &amp;amp; \\varphi_ {n - 1} 1 \\end{array} \\right] \\tag {8}</span></div>

    <p class="text-gray-300">The first <span class="math">n \\times n</span> principal sub-matrix of <span class="math">M_{\\varphi, r}</span> is <span class="math">\\mathrm{diag}[p, p, \\ldots, p]</span> corresponding to the polynomials <span class="math">p, px, \\ldots, px^{n-1}</span>. The last <span class="math">r - n + 1</span> rows correspond to the polynomials <span class="math">\\varphi(x), x\\varphi(x), \\ldots, x^{r-n}\\varphi(x)</span>.</p>

    <p class="text-gray-300">Apply the LLL algorithm to <span class="math">M_{\\varphi, r}</span> and let the first row of the resulting LLL-reduced matrix be <span class="math">[g_0, g_1, \\ldots, g_{r-1}, g_r]</span>. Define</p>

    <div class="my-4 text-center"><span class="math-block">g (x) = g _ {0} + g _ {1} x + \\dots + g _ {r - 1} x ^ {r - 1} + g _ {r} x ^ {r}. \\tag {9}</span></div>

    <p class="text-gray-300">The notation</p>

    <div class="my-4 text-center"><span class="math-block">g = \\operatorname {L L L} \\left(M _ {\\varphi , r}\\right) \\tag {10}</span></div>

    <p class="text-gray-300">will be used to denote the polynomial <span class="math">g(x)</span> given by (9). By construction, <span class="math">\\varphi(x)</span> is a factor of <span class="math">g(x)</span> modulo <span class="math">p</span>.</p>

    <p class="text-gray-300">The GJL procedure for polynomial selection is the following. Choose an <span class="math">r \\geq n</span> and repeat the following steps until <span class="math">f</span> and <span class="math">g</span> are irreducible over <span class="math">\\mathbb{Z}</span> and <span class="math">\\varphi</span> is irreducible over <span class="math">\\mathbb{F}_p</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomly choose a degree <span class="math">(r + 1)</span>-polynomial <span class="math">f(x)</span> which is irreducible over <span class="math">\\mathbb{Z}</span> and having coefficients of size <span class="math">O(\\ln(p))</span> such that <span class="math">f(x)</span> has a factor <span class="math">\\varphi(x)</span> of degree <span class="math">n</span> modulo <span class="math">p</span> which is both monic and irreducible.</li>

      <li>Let <span class="math">\\varphi(x) = x^n + \\varphi_{n-1}x^{n-1} + \\cdots + \\varphi_1x + \\varphi_0</span> and <span class="math">M_{\\varphi,r}</span> be the <span class="math">(r+1) \\times (r+1)</span> matrix given by (8).</li>

      <li>Let <span class="math">g(x) = \\mathrm{LLL}(M_{\\varphi,r})</span>.</li>

    </ol>

    <p class="text-gray-300">The polynomial <span class="math">f(x)</span> has degree <span class="math">r + 1</span> and <span class="math">g(x)</span> has degree <span class="math">r</span>. The procedure is parameterised by the integer <span class="math">r</span>.</p>

    <p class="text-gray-300">The determinant of <span class="math">M</span> is <span class="math">p^n</span> and so from the properties of the LLL-reduced basis, the coefficients of <span class="math">g(x)</span> are of the order <span class="math">O\\left(p^{n / (r + 1)}\\right) = O\\left(Q^{1 / (r + 1)}\\right)</span>. The coefficients of <span class="math">f(x)</span> are <span class="math">O(\\ln p)</span>.</p>

    <p class="text-gray-300">The bound on the norm given by (7) in this case is <span class="math">E^{2(2r + 1) / t}Q^{(t - 1) / (r + 1)}</span> which becomes <span class="math">E^{2r + 1}Q^{1 / (r + 1)}</span> for <span class="math">t = 2</span>. Increasing <span class="math">r</span> reduces the size of the coefficients of <span class="math">g(x)</span> at the cost of increasing the degrees of <span class="math">f</span> and <span class="math">g</span>. In the concrete example considered in [5] and also in [24], <span class="math">r</span> has been taken to be <span class="math">n</span> and so <span class="math">M</span> is an <span class="math">(n + 1)\\times (n + 1)</span> matrix.</p>

    <p class="text-gray-300">Conjugation. Repeat the following steps until <span class="math">f</span> and <span class="math">g</span> are irreducible over <span class="math">\\mathbb{Z}</span> and <span class="math">\\varphi</span> is irreducible over <span class="math">\\mathbb{F}_p</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose a quadratic monic polynomial <span class="math">\\mu(x)</span>, having coefficients of size <span class="math">O(\\ln p)</span>, which is irreducible over <span class="math">\\mathbb{Z}</span> and has a root <span class="math">\\mathfrak{t}</span> in <span class="math">\\mathbb{F}_p</span>.</li>

      <li>Choose two polynomials <span class="math">g_0(x)</span> and <span class="math">g_1(x)</span> with small coefficients such that <span class="math">\\deg g_1 &amp;lt; \\deg g_0 = n</span>.</li>

      <li>Let <span class="math">(u, v)</span> be a rational reconstruction of <span class="math">\\mathfrak{t}</span> modulo <span class="math">p</span>, i.e., <span class="math">\\mathfrak{t} \\equiv u / v \\bmod p</span>.</li>

      <li>Define <span class="math">g(x) = vg_0(x) + ug_1(x)</span> and <span class="math">f(x) = \\operatorname{Res}_y(\\mu(y), g_0(x) + y g_1(x))</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">\\deg(f) = 2n</span>, <span class="math">\\deg(g) = n</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(\\ln p)<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(p^{1/2}) = O(Q^{1/(2n)})<span class="math">. In this case, the bound on the norm given by (7) is </span>E^{6n/t}Q^{(t-1)/(2n)}<span class="math"> which becomes </span>E^{3n}Q^{1/(2n)}<span class="math"> for </span>t = 2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-5" class="text-2xl font-bold">4 A Simple Observation</h2>

    <p class="text-gray-300">For the GJL method, while constructing the matrix <span class="math">M</span>, the coefficients of the polynomial <span class="math">\\varphi(x)</span> are used. If, however, some of these coefficients are zero, then these may be ignored. The idea is given by the following result.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> Let <span class="math">n</span> be an integer, <span class="math">d</span> a divisor of <span class="math">n</span> and <span class="math">k = n / d</span>. Suppose <span class="math">A(x)</span> is a monic polynomial of degree <span class="math">k</span>. Let <span class="math">r \\geq k</span> be an integer and set <span class="math">\\psi(x) = \\mathrm{LLL}(M_{A,r})</span>. Define <span class="math">g(x) = \\psi(x^d)</span> and <span class="math">\\varphi(x) = A(x^d)</span>. Then</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg(\\varphi) = n</span> and <span class="math">\\deg(g) = rd</span>;</li>

      <li><span class="math">\\varphi(x)</span> is a factor of <span class="math">g(x)</span> modulo <span class="math">p</span>;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = p^{n/(d(r+1))}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> The first point is straightforward. Note that by construction <span class="math">A(x)</span> is a factor of <span class="math">\\psi(x)</span> modulo <span class="math">p</span>. So, <span class="math">A(x^d)</span> is a factor of <span class="math">\\psi(x^d) = g(x)</span> modulo <span class="math">p</span>. This shows the second point. The coefficients of <span class="math">g(x)</span> are the coefficients of <span class="math">\\psi(x)</span>. Following the GJL method, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = p^{k/(r+1)} = p^{n/(d(r+1))}<span class="math"> and so the same holds for </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$. This shows the third point.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that if we had defined <span class="math">g(x) = \\mathrm{LLL}(M_{\\varphi,rd})</span>, then $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> would have been </span>p^{n/(rd+1)}<span class="math">. For </span>d &gt; 1<span class="math">, the value of </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$ given by Proposition 1 is smaller.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>A variant.</strong> The above idea shows how to avoid the zero coefficients of <span class="math">\\varphi(x)</span>. A similar idea can be used to avoid the coefficients of <span class="math">\\varphi(x)</span> which are small. Suppose that the polynomial <span class="math">\\varphi(x)</span> can be written in the following form.</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi(x) = \\varphi_{i_1} x^{i_1} + \\cdots + \\varphi_{i_k} x^{i_k} + x^n + \\sum_{j \\notin \\{i_1, \\dots, i_k\\}} \\varphi_j x^j \\tag{11}</span></div>

    <p class="text-gray-300">where <span class="math">i_1, \\ldots, i_k</span> are from the set <span class="math">\\{0, \\ldots, n-1\\}</span> and for <span class="math">j \\in \\{0, \\ldots, n-1\\} \\setminus \\{i_1, \\ldots, i_k\\}</span>, the coefficients <span class="math">\\varphi_j</span> are all <span class="math">O(1)</span>. Some or even all of these <span class="math">\\varphi_j</span>'s could</p>

    <p class="text-gray-300">be zero. A <span class="math">(k + 1) \\times (k + 1)</span> matrix <span class="math">M</span> is constructed in the following manner.</p>

    <div class="my-4 text-center"><span class="math-block">M = \\left[ \\begin{array}{c c c c} p &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; p \\\\ \\varphi_{i_1} \\varphi_{i_2} \\dots \\varphi_{i_k} 1 \\end{array} \\right] \\tag{12}</span></div>

    <p class="text-gray-300">The matrix <span class="math">M</span> has only one row obtained from <span class="math">\\varphi(x)</span> and it is difficult to use more than one row. Apply the LLL algorithm to <span class="math">M</span> and write the first row of the resulting LLL-reduced matrix as <span class="math">[g_{i_1},\\ldots ,g_{i_k},g_n]</span>. Define</p>

    <div class="my-4 text-center"><span class="math-block">g(x) = \\left(g_{i_1} x^{i_1} + \\dots + g_{i_k} x^{i_k} + g_n x^n\\right) + \\sum_{j \\notin \\{i_1, \\dots, i_k, n\\}} \\varphi_j x^j. \\tag{13}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The degree of <span class="math">g(x)</span> is <span class="math">n</span> and the bound on the coefficients of <span class="math">g(x)</span> is determined as follows. The determinant of <span class="math">M</span> is <span class="math">p^k</span> and by the LLL-reduced property, each of the coefficients <span class="math">g_{i_1},\\ldots ,g_{i_k},g_n</span> is <span class="math">O(p^{k / (k + 1)}) = O(Q^{k / (n(k + 1))})</span>. Since <span class="math">\\varphi_j</span> for <span class="math">j\\notin \\{i_1,\\dots ,i_k\\}</span> are all <span class="math">O(1)</span>, it follows from (13) that all the coefficients of <span class="math">g(x)</span> are <span class="math">O(Q^{k / (n(k + 1))})</span> and so $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(Q^{k / (n(k + 1))})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the simple observation made in the earlier section, the non-zero terms of the polynomial <span class="math">g(x)</span> are powers of <span class="math">x^d</span>. This creates a restriction and does not turn out to be necessary to apply the main idea of the previous section. Once the polynomial <span class="math">\\psi(x)</span> is obtained using the LLL method, it is possible to substitute any degree <span class="math">d</span> polynomial with small coefficients for <span class="math">x</span> and still the norm bound will hold. In fact, the idea can be expressed more generally in terms of resultants. Algorithm <span class="math">\\mathcal{A}</span> describes the new general method for polynomial selection.</p>

    <p class="text-gray-300">The following result states the basic properties of Algorithm <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> The outputs <span class="math">f(x)</span>, <span class="math">g(x)</span> and <span class="math">\\varphi(x)</span> of Algorithm A satisfy the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg(f) = d(r + 1)</span>; <span class="math">\\deg(g) = rd</span> and <span class="math">\\deg(\\varphi) = n</span>;</li>

      <li>both <span class="math">f(x)</span> and <span class="math">g(x)</span> have <span class="math">\\varphi(x)</span> as a factor modulo <span class="math">p</span>;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(\\ln (p))<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(Q^{1 / (d(r + 1))})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}(f, \\phi) \\times \\operatorname{Res}(g, \\phi) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx \\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)^{t - 1} \\times E^{2(\\deg f + \\deg g)/t} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= O \\left(E^{2d(2r + 1)/t} \\times Q^{(t - 1)/(d(r + 1))}\\right). \\tag{14} \\end{array} $$</p>

    <p class="text-gray-300">|  Algorithm: A: A new method of polynomial selection.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: p, n, d (a factor of n) and r â‰¥ n/d.  |   |</p>

    <p class="text-gray-300">|  Output: f(x), g(x) and Ï†(x).  |   |</p>

    <p class="text-gray-300">|  Let k = n/d;  |   |</p>

    <p class="text-gray-300">|  repeat  |   |</p>

    <p class="text-gray-300">|  Randomly choose a monic irreducible polynomial A1(x) having the following properties: deg A1(x) = r + 1; A1(x) is irreducible over the integers; A1(x) has coefficients of size O(ln(p)); modulo p, A1(x) has an irreducible factor A2(x) of degree k.  |   |</p>

    <p class="text-gray-300">|  Randomly choose monic polynomials C0(x) and C1(x) with small coefficients such that deg C0(x) = d and deg C1(x) < d.  |   |</p>

    <p class="text-gray-300">|  Define  |   |</p>

    <p class="text-gray-300">|  f(x) = Resy(A1(y), C0(x) + yC1(x));  |   |</p>

    <p class="text-gray-300">|  Ï†(x) = Resy(A2(y), C0(x) + yC1(x)) mod p;  |   |</p>

    <p class="text-gray-300">|  Ïˆ(x) = LLL(MA2,r);  |   |</p>

    <p class="text-gray-300">|  g(x) = Resy(Ïˆ(y), C0(x) + yC1(x)).  |   |</p>

    <p class="text-gray-300">|  until f(x) and g(x) are irreducible over Z and Ï†(x) is irreducible over Fp.  |   |</p>

    <p class="text-gray-300">|  return f(x), g(x) and Ï†(x).  |   |</p>

    <p class="text-gray-300">Proof. By definition  <span class="math">f(x) = \\operatorname{Res}_y(A_1(y), C_0(x) + yC_1(x))</span>  where  <span class="math">A_1(x)</span>  has degree  <span class="math">r + 1</span> ,  <span class="math">C_0(x)</span>  has degree  <span class="math">d</span>  and  <span class="math">C_1(x)</span>  has degree  <span class="math">d - 1</span> , so the degree of  <span class="math">f(x)</span>  is  <span class="math">d(r + 1)</span> . Similarly, one obtains the degree of  <span class="math">\\varphi(x)</span>  to be  <span class="math">n</span> . Since  <span class="math">\\psi(x)</span>  is obtained from  <span class="math">A_2(x)</span>  as  <span class="math">\\mathrm{LLL}(M_{A_2,r})</span>  it follows that the degree of  <span class="math">\\psi(x)</span>  is  <span class="math">r</span>  and so the degree of  <span class="math">g(x)</span>  is  <span class="math">rd</span> .</p>

    <p class="text-gray-300">Since  <span class="math">A_{2}(x)</span>  divides  <span class="math">A_{1}(x)</span>  modulo  <span class="math">p</span> , it follows from the definition of  <span class="math">f(x)</span>  and  <span class="math">\\varphi(x)</span>  that modulo  <span class="math">p</span> ,  <span class="math">\\varphi(x)</span>  divides  <span class="math">f(x)</span> . Since  <span class="math">\\psi(x)</span>  is a linear combination of the rows of  <span class="math">M_{A_{2},r}</span> , it follows that modulo  <span class="math">p</span> ,  <span class="math">\\psi(x)</span>  is a multiple of  <span class="math">A_{2}(x)</span> . So,  <span class="math">g(x) = \\operatorname{Res}_{y}(\\psi(y), C_{0}(x) + yC_{1}(x))</span>  is a multiple of  <span class="math">\\varphi(x) = \\operatorname{Res}_{y}(A_{2}(y), C_{0}(x) + yC_{1}(x))</span>  modulo  <span class="math">p</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the coefficients of  <span class="math">C_0(x)</span>  and  <span class="math">C_1(x)</span>  are  <span class="math">O(1)</span>  and the coefficients of  <span class="math">A_1(x)</span>  are  <span class="math">O(\\ln p)</span> , it follows that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(\\ln p)<span class="math"> . The coefficients of  </span>g(x)<span class="math">  are  </span>O(1)<span class="math">  multiples of the coefficients of  </span>\\psi(x)<span class="math"> . By third point of Proposition 1, the coefficients of  </span>\\psi(x)<span class="math">  are  </span>O(p^{n/(d(r+1))}) = Q^{1/(d(r+1))}<span class="math">  which shows that  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(Q^{1/(d(r+1))})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proposition 2 provides the relevant bound on the product of the norms of a sieving polynomial  <span class="math">\\phi(x)</span>  in the two number fields defined by  <span class="math">f(x)</span>  and  <span class="math">g(x)</span> . We note the following points.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">d = 1</span> , then the norm bound is  <span class="math">E^{2(2r + 1) / t}Q^{(t - 1) / (r + 1)}</span>  which is the same as that obtained using the GJL method.</li>

      <li>If  <span class="math">d = n</span> , then the norm bound is  <span class="math">E^{2n(2r + 1) / t}Q^{(t - 1) / (n(r + 1))}</span> . Further, if  <span class="math">r = k = 1</span> , then the norm bound is the same as that obtained using the</li>

    </ol>

    <p class="text-gray-300">Conjugation method. So, for <span class="math">d=n</span>, Algorithm <span class="math">\\mathcal{A}</span> is a generalisation of the Conjugation method. Later, we show that choosing <span class="math">r&gt;1</span> provides asymptotic improvements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">n</span> is a prime, then the only values of <span class="math">d</span> are either <span class="math">1</span> or <span class="math">n</span>. The norm bounds in these two cases are covered by the above two points.</li>

      <li>If <span class="math">n</span> is composite, then there are non-trivial values for <span class="math">d</span> and it is possible to obtain new trade-offs in the norm bound. For concrete situations, this can be of interest. Further, for composite <span class="math">n</span>, as value of <span class="math">d</span> increases from <span class="math">d=1</span> to <span class="math">d=n</span>, the norm bound nicely interpolates between the norm bounds of the GJL method and the Conjugation method.</li>

    </ol>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Existence of <span class="math">\\mathbb{Q}</span>-automorphisms:</h4>

    <p class="text-gray-300">The existence of <span class="math">\\mathbb{Q}</span>-automorphism in the number fields speeds up the NFS algorithm in the non-asymptotic sense <em>[19]</em>. Similar to the existence of <span class="math">\\mathbb{Q}</span>-automorphism in GJL method, as discussed in <em>[5]</em>, the first polynomial generated by the new method, can have a <span class="math">\\mathbb{Q}</span>-automorphism. In general, it is difficult to get an automorphism for the second polynomial as it is generated by the LLL algorithm. On the other hand, we can have a <span class="math">\\mathbb{Q}</span>-automorphism for the second polynomial also in the specific cases. Some of the examples are reported in <em>[10]</em>.</p>

    <h2 id="sec-8" class="text-2xl font-bold">6 Non-asymptotic Comparisons and Examples</h2>

    <p class="text-gray-300">We compare the norm bounds for <span class="math">t=2</span>, i.e., when the sieving polynomial is linear. In this case, Table 2 lists the degrees and norm bounds of polynomials for various methods. Table 3 compares the new method with the JLSV1 and the GJL method for concrete values of <span class="math">n</span>, <span class="math">r</span> and <span class="math">d</span>. This shows that the new method provides different trade-offs which were not known earlier.</p>

    <p class="text-gray-300">As an example, we can see from Table 3 that the new method compares well with GJL and JLSV1 methods for <span class="math">n=4</span> and <span class="math">Q</span> of 300 dd (refer to Table 1). As mentioned in <em>[5]</em>, when the differences between the methods are small, it is not possible to decide by looking only at the size of the norm product. Keeping this in view, we see that the new method is competitive for <span class="math">n=6</span> as well. These observations are clearly visible in the plots given in the Figure 3. From the <span class="math">Q</span>-<span class="math">E</span> pairs given in Table 1, it is clear that the increase of <span class="math">E</span> is slower than that of <span class="math">Q</span>. This suggests that the new method will become competitive when <span class="math">Q</span> is sufficiently large.</p>

    <p class="text-gray-300">Next we provide some concrete examples of polynomials <span class="math">f(x),g(x)</span> and <span class="math">\\varphi(x)</span> obtained using the new method. The examples are for <span class="math">n=6</span> and <span class="math">n=4</span>. For <span class="math">n=6</span>, we have taken <span class="math">d=1,2,3</span> and <span class="math">6</span> and in each case <span class="math">r</span> was chosen to be <span class="math">r=k=n/d</span>. For <span class="math">n=4</span>, we consider <span class="math">d=2</span> with <span class="math">r=k=n/d</span> and <span class="math">r=k+1</span>; and <span class="math">d=4</span> with <span class="math">r=k</span>. These examples are to illustrate that the method works as predicted and returns the desired polynomials very fast. We have used Sage <em>[29]</em> and MAGMA computer algebra system <em>[9]</em> for all the computations done in this work.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (a) Polynomials for  <span class="math">\\mathbb{F}_{p^4}</span></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (b) Polynomials for  <span class="math">\\mathbb{F}_{p^6}</span> Fig. 3. Product of norms for various polynomial selection methods</p>

    <p class="text-gray-300">Table 2. Parameterised efficiency estimates for NFS obtained from the different polynomial selection methods.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Methods</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆž</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆž</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆž</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆžE(deg f+deg g)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">Q2/n</td>

            <td class="px-3 py-2 border-b border-gray-700">Q2/n</td>

            <td class="px-3 py-2 border-b border-gray-700">E2nQ1/n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GJL (râ‰¥n)</td>

            <td class="px-3 py-2 border-b border-gray-700">r+1</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Qr+1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">E2r+1Qr+1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjugation</td>

            <td class="px-3 py-2 border-b border-gray-700">2n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q2/n</td>

            <td class="px-3 py-2 border-b border-gray-700">E3nQ3/n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A (d</td>

            <td class="px-3 py-2 border-b border-gray-700">n, râ‰¥n/d)</td>

            <td class="px-3 py-2 border-b border-gray-700">d(r+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">dr</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q2(r+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ed(2r+1)Q1/(d(r+1))</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Comparison of efficiency estimates for composite  <span class="math">n</span>  with  <span class="math">d = 2</span>  and  <span class="math">r = n/2</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FQ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(deg f, deg g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆž</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆž</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆž</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">âˆžE(deg f+deg g)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp4</td>

            <td class="px-3 py-2 border-b border-gray-700">GJL</td>

            <td class="px-3 py-2 border-b border-gray-700">(5,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/5</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q1/5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">(4,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">E8Q1/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">(6,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/6</td>

            <td class="px-3 py-2 border-b border-gray-700">E10Q1/6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp6</td>

            <td class="px-3 py-2 border-b border-gray-700">GJL</td>

            <td class="px-3 py-2 border-b border-gray-700">(7,6)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/7</td>

            <td class="px-3 py-2 border-b border-gray-700">E13Q1/7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">(6,6)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/12</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/12</td>

            <td class="px-3 py-2 border-b border-gray-700">E12Q1/6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">(8,6)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">E14Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp8</td>

            <td class="px-3 py-2 border-b border-gray-700">GJL</td>

            <td class="px-3 py-2 border-b border-gray-700">(9,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/9</td>

            <td class="px-3 py-2 border-b border-gray-700">E17Q1/9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">(8,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/16</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/16</td>

            <td class="px-3 py-2 border-b border-gray-700">E16Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">(10,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/10</td>

            <td class="px-3 py-2 border-b border-gray-700">E18Q1/10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp9</td>

            <td class="px-3 py-2 border-b border-gray-700">GJL</td>

            <td class="px-3 py-2 border-b border-gray-700">(10,9)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/10</td>

            <td class="px-3 py-2 border-b border-gray-700">E19Q1/10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">(9,9)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/18</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/18</td>

            <td class="px-3 py-2 border-b border-gray-700">E18Q1/9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">(12,9)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ln p)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/12</td>

            <td class="px-3 py-2 border-b border-gray-700">E21Q1/12</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Example 1. Let  <span class="math">n = 6</span> , and  <span class="math">p</span>  is a 201-bit prime given below.</p>

    <p class="text-gray-300">p = 1606938044258990275541962092341162602522202993782792835361211</p>

    <p class="text-gray-300">Taking <span class="math">d = 1</span> and <span class="math">r = n / d</span>, we get</p>

    <div class="my-4 text-center"><span class="math-block">f(x) = x^7 + 18x^6 + 99x^5 - 107x^4 - 3470x^3 - 15630x^2 - 30664x - 23239</span></div>

    <div class="my-4 text-center"><span class="math-block">g(x) = 712965136783466122384156554261504665235609243446869x^6 + 16048203858903</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l} 260691766216702652575435281807544247712x^5 + 14867720774814154920358989 \\\\ 0852868028274077107624860184x^4 + 7240853845391439257955648357229262561 \\\\ 71920852986660372x^3 + 194693204195493982969795038496468458378024972218 \\\\ 5345772x^2 + 2718971797270235171234259793142851416923331519178675874x \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1517248296800681060244076172658712224507653769252953211</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi(x) = x^6 + 671560075936012275401828950369729286806144005939695349290760x^5 + 774705834624554066737199160555511502088270323481268337340514x^4 + 1100</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 646447552671580437963861085020431145126151057937318479717x^3 + 27131646 \\\\ 3864123658232870095113273120009266491174096472632727x^2 + 4101717389506 \\\\ 73951225351009256251353058695601874372080573092x + 1326632804961027767 \\\\ 272334662693578855845363854398231524390607 \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{180}<span class="math">. Taking </span>d = 2<span class="math"> and </span>r = n / d$, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">f(x) = x^8 - x^7 - 5x^6 - 50x^5 - 181x^4 - 442x^3 - 801x^2 - 633x - 787</span></div>

    <div class="my-4 text-center"><span class="math-block">g(x) = 833480932500516492505935839185008193696457787x^6 + 2092593616641287655</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 065740032896986343580698615x^5 + 1298540899568952261791537743468335194 \\\\ 3188533320x^4 + 21869741590966357897620167461539967141532970622x^3 + 6 \\\\ 4403097224634262677273803471992671747860968564x^2 + 558647116952815842 \\\\ 83909455665521092749502793807x + 921778354059077827252784356704871327 \\\\ 10722661831 \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\varphi(x) = x^6 + 225577566898041285405539226183221508226286589225546142714057x^5 + 726156673723889082895351451739733545328394720523246272955173x^4 + 10214</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 78132054694721578888994001730764934454660630543688348056x^3 + 674978102 \\\\ 55620874288201802771995130845407860934811815878391x^2 + 632426210761786 \\\\ 622105494194314937817927439372918029042718843x + 104093530686601670252 \\\\ 6455143725415379604742339065421793844038 \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{156}<span class="math">. Taking </span>d = 3<span class="math"> and </span>r = n / d$, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">f(x) = x^9 - 4x^8 - 54x^7 - 174x^6 - 252x^5 - 174x^4 - 76x^3 - 86x^2 - 96x - 42</span></div>

    <p class="text-gray-300"><span class="math">g(x)=2889742364508381557593312392497801006712\\,x^{6}+83633695370646306085610</span></p>

    <p class="text-gray-300"><span class="math">87765146274738509\\,x^{5}+10828078806524085705506412783408772941877\\,x^{4}+</span></p>

    <p class="text-gray-300"><span class="math">41812824889730400169000397417267197701179\\,x^{3}+1497421347777532476213</span></p>

    <p class="text-gray-300"><span class="math">31508897969482387354\\,x^{2}+240946716989443210293442965552611305592194\\,x</span></p>

    <p class="text-gray-300"><span class="math">+151696455655104744403073743333940426598833</span></p>

    <p class="text-gray-300"><span class="math">\\varphi(x)=x^{6}+265074577705978624915342871970538348132010154368109244143774\\,x^{5}</span></p>

    <p class="text-gray-300"><span class="math">+21159801273629654486978970226092134077566675973129512551886\\,x^{4}+10</span></p>

    <p class="text-gray-300"><span class="math">63445611445684266941289540827947199397416276334188055837892\\,x^{3}+1459</span></p>

    <p class="text-gray-300"><span class="math">587283058054365639950761731919998074021438242745336103973\\,x^{2}+145654</span></p>

    <p class="text-gray-300"><span class="math">3437800571643325638648207188371117923539168263210522995\\,x+378129170</span></p>

    <p class="text-gray-300"><span class="math">960510211491600303623674471468414144797178846977007</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{137}<span class="math">. Taking </span>d=6<span class="math"> and </span>r=n/d$, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f(x)=x^{12}+3\\,x^{10}+10\\,x^{9}+53\\,x^{8}+112\\,x^{7}+163\\,x^{6}</span></p>

    <p class="text-gray-300"><span class="math">+184\\,x^{5}+177\\,x^{4}+166\\,x^{3}+103\\,x^{2}+72\\,x+48</span></p>

    <p class="text-gray-300"><span class="math">g(x)=-666878138402353195498832669848\\,x^{6}-1867253271074924746011849188889\\,x^{5}</span></p>

    <p class="text-gray-300"><span class="math">-5601759813224774238035547566667\\,x^{4}-6668753801765210948063915265053\\,x^{3}</span></p>

    <p class="text-gray-300"><span class="math">-4268003536420067847037882226971\\,x^{2}-6935516090029480629033212906363\\,x</span></p>

    <p class="text-gray-300"><span class="math">-7469013084299698984047396755556</span></p>

    <p class="text-gray-300"><span class="math">\\varphi(x)=x^{6}+356485336847074091920944597187811284411849047991334266185684\\,x^{5}+</span></p>

    <p class="text-gray-300"><span class="math">1069456010541222275762833791563433853235547143974002798557052\\,x^{4}+175</span></p>

    <p class="text-gray-300"><span class="math">488639976380184062760893597893819537042246173878495567205\\,x^{3}+1069456</span></p>

    <p class="text-gray-300"><span class="math">010541222275762833791563433853235547143974002798557050\\,x^{2}+1069456010</span></p>

    <p class="text-gray-300"><span class="math">541222275762833791563433853235547143974002798557054\\,x+14259413473882</span></p>

    <p class="text-gray-300"><span class="math">96367683778388751245137647396191965337064742736</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case we get $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{102}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-9" class="text-base font-medium mt-4">Example 2.</h6>

    <p class="text-gray-300">Let <span class="math">n=4</span>, and <span class="math">p</span> is a <span class="math">301</span>-bit prime given below.</p>

    <p class="text-gray-300"><span class="math">p=203703597633448608626844568840937816105146839366593625063614044935438</span></p>

    <p class="text-gray-300"><span class="math">1299763336706183493607</span></p>

    <p class="text-gray-300">Taking <span class="math">d=2</span> and <span class="math">r=n/d</span>, we get</p>

    <p class="text-gray-300"><span class="math">f(x)=x^{6}+2\\,x^{5}+10\\,x^{4}+11\\,x^{3}+8\\,x^{2}+3\\,x+5</span></p>

    <p class="text-gray-300"><span class="math">g(x)=1108486244023576208689360410176300373132220654590976786482134\\,x^{4}+20</span></p>

    <p class="text-gray-300"><span class="math">50762938144982289360096083705563965935573667103554994528044\\,x^{3}+5523</span></p>

    <p class="text-gray-300"><span class="math">467580377021934753091786207648479867036209679151793015319\\,x^{2}+456222</span></p>

    <p class="text-gray-300"><span class="math">7246514756745388645848004531501269616133890841445574058\\,x+441498133</span></p>

    <p class="text-gray-300"><span class="math">6353445726063731376031348106734815555088175006533185</span></p>

    <p class="text-gray-300"><span class="math">\\varphi(x)=x^{4}+1305623360698284685175599277707343457576279146188242586245210199</span></p>

    <p class="text-gray-300"><span class="math">344777856138293049165536292\\,x^{3}+1630663764713242722426772175575945319</span></p>

    <p class="text-gray-300"><span class="math">640665655794962932653634545690570677252853972689997048\\,x^{2}+1955704168</span></p>

    <p class="text-gray-300"><span class="math">7282007596779450734445471817050521654016832790620588920363634983674148</span></p>

    <p class="text-gray-300"><span class="math">96214457800\\,x+163066376471324272242677217557594531964066565579496293</span></p>

    <p class="text-gray-300"><span class="math">2653634545690570677252853972689997047</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{201}<span class="math">. If we take </span>r=n/d+1$, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f(x)=x^{8}+16\\,x^{7}+108\\,x^{6}+398\\,x^{5}+865\\,x^{4}+1106\\,x^{3}+820\\,x^{2}+328\\,x+55</span></p>

    <p class="text-gray-300"><span class="math">g(x)=348482147842083865380881347784399925335728557\\,x^{6}+5536103979982210590</span></p>

    <p class="text-gray-300"><span class="math">186016445459289773029045618\\,x^{5}+3381254505070666477453052572333514580</span></p>

    <p class="text-gray-300"><span class="math">1290667783\\,x^{4}+96062171957261124763428590648958745188735445330\\,x^{3}+1</span></p>

    <p class="text-gray-300"><span class="math">24085795781307363759935898131887563792535489069\\,x^{2}+73090839973729169</span></p>

    <p class="text-gray-300"><span class="math">966964061428402316131911130808\\,x+16093810783274309055350481972028841</span></p>

    <p class="text-gray-300"><span class="math">649178007790</span></p>

    <p class="text-gray-300"><span class="math">\\varphi(x)=x^{4}+5128690964597943246501962358998676237033930846168967447990334244</span></p>

    <p class="text-gray-300"><span class="math">55696319185673262765599428\\,x^{3}+1802408796932749487444974790576022081</span></p>

    <p class="text-gray-300"><span class="math">708344659229207911271845827650035713383268427662416444\\,x^{2}+1553341208</span></p>

    <p class="text-gray-300"><span class="math">0263216762891646375525736686031169799908288433475579574772861500238438</span></p>

    <p class="text-gray-300"><span class="math">04262435184\\,x+263801507553366513494386082876419210598165405378517676</span></p>

    <p class="text-gray-300"><span class="math">874745554282946755826248639365618168</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{156}<span class="math">. If we take </span>d=4<span class="math"> and </span>r=d/n$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f(x)=x^{8}-3\\,x^{7}-33\\,x^{6}-97\\,x^{5}-101\\,x^{4}+3\\,x^{3}+73\\,x^{2}-35\\,x-8</span></p>

    <p class="text-gray-300"><span class="math">g(x)=684862886024125973911391867198415841436877278\\,x^{4}+1925808392957060519</span></p>

    <p class="text-gray-300"><span class="math">248933705295588974774910731\\,x^{3}+1668247862726425714278449912696271875</span></p>

    <p class="text-gray-300"><span class="math">703468525\\,x^{2}+40961560447538961485182385700123093758271763\\,x+124094</span></p>

    <p class="text-gray-300"><span class="math">5506932934545337541838097173133338033453</span></p>

    <p class="text-gray-300"><span class="math">\\varphi(x)=x^{4}+3001292991290566658187708046113162326822746963576576248059013380</span> <span class="math">7217067092452460559896554\\,x^{3}+900387897387169997456312413833948698046</span> <span class="math">82408907297287441770401421651201277357381679689656\\,x^{2}+15006464956452</span> <span class="math">8332909385402305658116341137348178828812402950669036085335462262302799</span> <span class="math">482756\\,x+30012929912905666581877080461131623268227469635765762480590</span> <span class="math">133807217067092452460559896553</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case also we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{150}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-10" class="text-2xl font-bold">7 Asymptotic Complexity Analysis</h2>

    <p class="text-gray-300">The goal of the asymptotic complexity analysis is to express the runtime of the NFS algorithm using the L-notation and at the same time obtain bounds on <span class="math">p</span> for which the analysis is valid. Our description of the analysis is based on prior works predominantly those in <em>[17, 19, 5, 24]</em>.</p>

    <p class="text-gray-300">For <span class="math">0&lt;a&lt;1</span>, write</p>

    <p class="text-gray-300"><span class="math">p=L_{Q}(a,c_{p}),\\text{ where }c_{p}=\\frac{1}{n}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1-a}\\text{ and so }n=\\frac{1}{c_{p}}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1-a}.</span> (15)</p>

    <p class="text-gray-300">The value of <span class="math">a</span> will be determined later. Also, for each <span class="math">c_{p}</span>, the runtime of the NFS algorithm is the same for the family of finite fields <span class="math">\\mathbb{F}_{p^{n}}</span> where <span class="math">p</span> is given by (15).</p>

    <p class="text-gray-300">From Section 3, we recall the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The number of polynomials to be considered for sieving is <span class="math">E^{2}</span>.</li>

      <li>The factor base is of size <span class="math">B</span>.</li>

    </ol>

    <p class="text-gray-300">Sparse linear algebra using the Lanczos or the block Wiedemann algorithm takes time <span class="math">O(B^{2})</span>. For some <span class="math">0&lt;b&lt;1</span>, let</p>

    <p class="text-gray-300"><span class="math">B=L_{Q}(b,c_{b}).</span> (16)</p>

    <p class="text-gray-300">The value of <span class="math">b</span> will be determined later. Set</p>

    <p class="text-gray-300"><span class="math">E=B</span> (17)</p>

    <p class="text-gray-300">so that asymptotically, the number of sieving polynomials is equal to the time for the linear algebra step.</p>

    <p class="text-gray-300">Let <span class="math">\\pi=\\Psi(\\Gamma,B)</span> be the probability that a random positive integer which is at most <span class="math">\\Gamma</span> is <span class="math">B</span>-smooth. Let <span class="math">\\Gamma=L_{Q}(z,\\zeta)</span> and <span class="math">B=L_{Q}(b,c_{b})</span>. Using the L-notation version of the Canfield-ErdÃ¶s-Pomerance theorem,</p>

    <p class="text-gray-300"><span class="math">\\left(\\Psi(\\Gamma,B)\\right)^{-1}=L_{Q}\\left(z-b,(z-b)\\frac{\\zeta}{c_{b}}\\right).</span> (18)</p>

    <p class="text-gray-300">The bound on the product of the norms given by Proposition 2 is</p>

    <p class="text-gray-300"><span class="math">\\Gamma=E^{\\frac{2}{t}d(2r+1)}\\times Q^{\\frac{t-1}{d(r+1)}}.</span> (19)</p>

    <p class="text-gray-300">Note that in (19), <span class="math">t-1</span> is the degree of the sieving polynomial. Following the usual convention, we assume that the same smoothness probability <span class="math">\\pi</span> holds for the event that a random sieving polynomial <span class="math">\\phi(x)</span> is smooth over the factor base.</p>

    <p class="text-gray-300">The expected number of polynomials to consider for obtaining one relation is <span class="math">\\pi^{-1}</span>. Since <span class="math">B</span> relations are required, obtaining this number of relations requires trying <span class="math">B\\pi^{-1}</span> trials. Balancing the cost of sieving and the linear algebra steps requires <span class="math">B\\pi^{-1}=B^{2}</span> and so</p>

    <p class="text-gray-300"><span class="math">\\pi^{-1}=B.</span> (20)</p>

    <p class="text-gray-300">Obtaining <span class="math">\\pi^{-1}</span> from (18) and setting it to be equal to <span class="math">B</span> allows solving for <span class="math">c_{b}</span>. Balancing the costs of the sieving and the linear algebra phases leads to the runtime of the NFS algorithm to be <span class="math">B^{2}=L_{Q}(b,2c_{b})</span>. So, to determine the runtime, we need to determine <span class="math">b</span> and <span class="math">c_{b}</span>. The value of <span class="math">b</span> will turn out to be <span class="math">1/3</span> and the only real issue is the value of <span class="math">c_{b}</span>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">n=kd</span> for positive integers <span class="math">k</span> and <span class="math">d</span>. Using the expressions for <span class="math">p</span> and <span class="math">E(=B)</span> given by (15) and (16), we obtain the following.</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{c}E^{\\frac{2}{t}d(2r+1)}=L_{Q}\\left(1-a+b,\\frac{2c_{b}(2r+1)}{c_{p}kt}\\right);\\\\ Q^{\\frac{t-1}{d(r+1)}}=L_{Q}\\left(a,\\frac{kc_{p}(t-1)}{(r+1)}\\right).\\end{array} \\] (21)</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The second expression follows directly from <span class="math">Q=p^{n}</span>, <span class="math">p=L_{Q}(a,c_{p})</span> and <span class="math">n=kd</span>. The computation for obtaining the first expression is the following.</p>

    <p class="text-gray-300"><span class="math">E^{\\frac{2}{t}d(2r+1)}</span> <span class="math">=L_{Q}\\left(b,c_{b}\\frac{2}{t}d(2r+1)\\right)</span> <span class="math">=\\exp\\left(c_{b}\\frac{2}{t}(2r+1)\\frac{n}{k}(\\ln Q)^{b}(\\ln\\ln Q)^{1-b}\\right)</span> <span class="math">=\\exp\\left(c_{b}\\frac{2}{c_{p}kt}(2r+1)\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1-a}(\\ln Q)^{b}(\\ln\\ln Q)^{1-b}\\right)</span> <span class="math">=L_{Q}\\left(1-a+b,\\frac{2c_{b}(2r+1)}{c_{p}kt}\\right).</span></p>

    <p class="text-gray-300">âˆŽ</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 1 (Boundary Case).</h6>

    <p class="text-gray-300">Let <span class="math">k</span> divide <span class="math">n</span>, <span class="math">r\\geq k</span>, <span class="math">t\\geq 2</span> and <span class="math">p=L_{Q}(2/3,c_{p})</span> for some <span class="math">0&lt;c_{p}&lt;1</span>. It is possible to ensure that the runtime of the NFS algorithm with polynomials chosen by Algorithm <span class="math">\\mathcal{A}</span> is <span class="math">L_{Q}(1/3,2c_{b})</span> where</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2r+1}{3c_{p}kt}+\\sqrt{\\left(\\frac{2r+1}{3c_{p}kt}\\right)^{2}+\\frac{kc_{p}(t-1)}{3(r+1)}}.</span> (22)</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Setting <span class="math">2a=1+b</span>, the two <span class="math">L</span>-expressions given by (21) have the same first component and so the product of the norms is</p>

    <p class="text-gray-300"><span class="math">\\Gamma=L_{Q}\\left(a,\\frac{2c_{b}(2r+1)}{c_{p}kt}+\\frac{kc_{p}(t-1)}{(r+1)}\\right).</span></p>

    <p class="text-gray-300">Then <span class="math">\\pi^{-1}</span> given by (18) is</p>

    <p class="text-gray-300"><span class="math">L_{Q}\\left(a-b,(a-b)\\left(\\frac{2(2r+1)}{c_{p}kt}+\\frac{kc_{p}(t-1)}{c_{b}(r+1)}\\right)\\right).</span></p>

    <p class="text-gray-300">From the condition <span class="math">\\pi^{-1}=B</span>, we get <span class="math">b=a-b</span> and</p>

    <p class="text-gray-300"><span class="math">c_{b}=(a-b)\\left(\\frac{2(2r+1)}{c_{p}kt}+\\frac{kc_{p}(t-1)}{c_{b}(r+1)}\\right).</span></p>

    <p class="text-gray-300">The conditions <span class="math">a-b=b</span> and <span class="math">2a=1+b</span> show that <span class="math">b=1/3</span> and <span class="math">a=2/3</span>. The second equation then becomes</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{1}{3}\\left(\\frac{2(2r+1)}{c_{p}kt}+\\frac{kc_{p}(t-1)}{c_{b}(r+1)}\\right).</span> (23)</p>

    <p class="text-gray-300">Solving the quadratic for <span class="math">c_{b}</span> and choosing the positive root gives</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2r+1}{3c_{p}kt}+\\sqrt{\\left(\\frac{2r+1}{3c_{p}kt}\\right)^{2}+\\frac{kc_{p}(t-1)}{3(r+1)}}.</span></p>

    <p class="text-gray-300">âˆŽ</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Corollary 1 (Boundary Case of the Conjugation Method <em>[5]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">r=k=1</span>. Then for <span class="math">p=L_{Q}(2/3,c_{p})</span>, the runtime of the NFS algorithm is <span class="math">L_{Q}(1/3,2c_{b})</span> with</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{1}{c_{p}t}+\\sqrt{\\left(\\frac{1}{c_{p}t}\\right)^{2}+\\frac{c_{p}(t-1)}{6}}.</span></p>

    <p class="text-gray-300">Allowing <span class="math">r</span> to be greater than <span class="math">k</span> leads to improved asymptotic complexity. We do not perform this analysis. Instead, we perform the analysis in the similar situation which arises for the multiple number field sieve algorithm.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 2 (Medium Characteristic Case).</h6>

    <p class="text-gray-300">Let <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">a&gt;1/3</span>. It is possible to ensure that the runtime of the NFS algorithm with the polynomials produced by Algorithm <span class="math">\\mathcal{A}</span> is <span class="math">L_{Q}(1/3,(32/3)^{1/3})</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since <span class="math">a&gt;1/3</span>, the bound <span class="math">\\Gamma</span> on the product of the norms can be taken to be the expression given by (7). The parameter <span class="math">t</span> is chosen as follows <em>[5]</em>. For <span class="math">0&lt;c&lt;1</span>, let <span class="math">t=c_{t}n((\\ln Q)/(\\ln\\ln Q))^{-c}</span>. For the asymptotic analysis, <span class="math">t-1</span> is also assumed to be given by the same expression for <span class="math">t</span>. Then the expressions given by (21) become the following.</p>

    <p class="text-gray-300"><span class="math">E^{\\frac{2}{t}d(2r+1)}=L_{Q}\\left(b+c,\\frac{2c_{b}(2r+1)}{kc_{t}}\\right);\\ Q^{\\frac{t-1}{d(r+1)}}=L_{Q}\\left(1-c,\\frac{kc_{t}}{r+1}\\right).</span> (24)</p>

    <p class="text-gray-300">This can be seen by substituting the expression for <span class="math">t</span> in (21) and further by using the expression for <span class="math">n</span> given in (15).</p>

    <p class="text-gray-300">Setting <span class="math">2c = 1 - b</span>, the first components of the two expressions in (24) become equal and so</p>

    <div class="my-4 text-center"><span class="math-block">\\Gamma = L _ {Q} \\left(b + c, \\frac {2 c _ {b} (2 r + 1)}{k c _ {t}} + \\frac {k c _ {t}}{r + 1}\\right).</span></div>

    <p class="text-gray-300">Using this <span class="math">\\Gamma</span>, the expression for <span class="math">\\pi^{-1}</span> is</p>

    <div class="my-4 text-center"><span class="math-block">\\pi^ {- 1} = L _ {Q} \\left(c, c \\left(\\frac {2 (2 r + 1)}{k c _ {t}} + \\frac {k c _ {t}}{c _ {b} (r + 1)}\\right)\\right).</span></div>

    <p class="text-gray-300">We wish to choose <span class="math">c_{t}</span> so as to maximise the probability <span class="math">\\pi</span> and hence to minimise <span class="math">\\pi^{-1}</span>. This is done by setting <span class="math">2(2r + 1) / (kc_{t}) = (kc_{t}) / (c_{b}(r + 1))</span> whence <span class="math">kc_{t} = \\sqrt{2c_{b}(r + 1)(2r + 1)}</span>. With this value of <span class="math">kc_{t}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\pi^ {- 1} = L _ {Q} \\left(c, \\frac {2 c \\sqrt {2 c _ {b} (r + 1) (2 r + 1)}}{c _ {b} (r + 1)}\\right).</span></div>

    <p class="text-gray-300">Setting <span class="math">\\pi^{-1}</span> to be equal to <span class="math">B = L_{Q}(b, c_{b})</span> yields <span class="math">b = c</span> and</p>

    <div class="my-4 text-center"><span class="math-block">c _ {b} = \\left(\\frac {2 c \\sqrt {2 c _ {b} (r + 1) (2 r + 1)}}{c _ {b} (r + 1)}\\right).</span></div>

    <p class="text-gray-300">From <span class="math">b = c</span> and <span class="math">2c = 1 - b</span> we obtain <span class="math">c = b = 1/3</span>. Using this value of <span class="math">c</span> in the equation for <span class="math">c_b</span>, we obtain <span class="math">c_b = (2/3)^{2/3} \\times ((2(2r + 1)) / (r + 1))^{1/3}</span>. The value of <span class="math">c_b</span> is the minimum for <span class="math">r = 1</span> and this value is <span class="math">c_b = (4/3)^{1/3}</span>.</p>

    <p class="text-gray-300">Note that the parameter <span class="math">a</span> which determines the size of <span class="math">p</span> is not involved in any of the computation. The assumption <span class="math">a &amp;gt; 1/3</span> is required to ensure that the bound on the product of the norms can be taken to be the expression given by (7).</p>

    <p class="text-gray-300"><strong>Theorem 3 (Large Characteristic).</strong> It is possible to ensure that the runtime of the NFS algorithm with the polynomials produced by Algorithm <span class="math">\\mathcal{A}</span> is <span class="math">L_{Q}(1/3, (64/9)^{1/3})</span> for <span class="math">p \\geq L_{Q}(2/3, (8/3)^{1/3})</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Following [5], for <span class="math">0 &amp;lt; e &amp;lt; 1</span>, let <span class="math">r = c_r / 2((\\ln Q) / (\\ln \\ln Q))^e</span>. For the asymptotic analysis, the expression for <span class="math">2r + 1</span> is taken to be two times this expression. Substituting this expression for <span class="math">r</span> in (21), we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\left. \\begin{array}{l} E ^ {\\frac {2}{7} d (2 r + 1)} = L _ {Q} \\left(1 - a + b + e, \\frac {2 c _ {b} c _ {r}}{c _ {p} k t}\\right); \\\\ Q ^ {\\frac {t - 1}{d (r + 1)}} = L _ {Q} \\left(a - e, \\frac {2 k c _ {p} (t - 1)}{c _ {r}}\\right). \\end{array} \\right\\} \\tag {25}</span></div>

    <p class="text-gray-300">Setting <span class="math">1 + b = 2(a - e)</span>, we obtain <span class="math">\\Gamma = L_{Q}\\left(\\frac{1 + b}{2},\\frac{2c_{b}c_{r}}{c_{p}kt} +\\frac{2kc_{p}(t - 1)}{c_{r}}\\right)</span> and so the probability <span class="math">\\pi^{-1}</span> is given by</p>

    <div class="my-4 text-center"><span class="math-block">L _ {Q} \\left(\\frac {1 - b}{2}, \\frac {1 - b}{2} \\times \\left(\\frac {2 c _ {r}}{c _ {p} k t} + \\frac {2 k c _ {p} (t - 1)}{c _ {r} c _ {b}}\\right)\\right).</span></div>

    <p class="text-gray-300"><span class="math">c_{r}</span> for which the probability <span class="math">\\pi</span> is maximised (and hence <span class="math">\\pi^{-1}</span> is minimised) is obtained by setting <span class="math">c_{r}/(c_{p}k)=\\sqrt{(t(t-1))/c_{b}}</span> and the minimum value of <span class="math">\\pi^{-1}</span> is</p>

    <p class="text-gray-300"><span class="math">L_{Q}\\left(\\frac{1-b}{2},\\frac{1-b}{2}\\times\\left(4\\sqrt{\\frac{t-1}{tc_{b}}}\\right)\\right).</span></p>

    <p class="text-gray-300">Setting this value of <span class="math">\\pi^{-1}</span> to be equal to <span class="math">B</span>, we obtain</p>

    <p class="text-gray-300"><span class="math">b=(1-b)/2;\\ c_{b}=\\frac{1-b}{2}\\times\\left(4\\sqrt{\\frac{t-1}{tc_{b}}}\\right).</span></p>

    <p class="text-gray-300">The first equation shows <span class="math">b=1/3</span> and using this in the second equation, we obtain <span class="math">c_{b}=(4/3)^{2/3}((t-1)/t)^{1/3}</span>. This value of <span class="math">c_{b}</span> is minimised for the minimum value of <span class="math">t</span> which is <span class="math">t=2</span>. This gives <span class="math">c_{b}=(8/9)^{1/3}</span>.</p>

    <p class="text-gray-300">Using <span class="math">2(a-e)=1+b</span> and <span class="math">b=1/3</span> we get <span class="math">a-e=2/3</span>. Note that <span class="math">r\\geq k</span> and so <span class="math">p\\geq p^{k/r}=L_{Q}(a,(c_{p}k)/r)=L_{Q}(a-e,(2c_{p}k)/c_{r})</span>. With <span class="math">t=2</span>, the value of <span class="math">(c_{p}k)/c_{r}</span> is equal to <span class="math">(1/3)^{1/3}</span> and so <span class="math">p\\geq L_{Q}(2/3,(8/3)^{1/3})</span>. âˆŽ</p>

    <p class="text-gray-300">Theorems 2 and 3 show that the generality introduced by <span class="math">k</span> and <span class="math">r</span> do not affect the overall asymptotic complexity for the medium and large prime case and the attained complexities in these cases are the same as those obtained for previous methods in <em>[5]</em>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">8 Multiple Number Field Sieve Variant</h2>

    <p class="text-gray-300">As the name indicates, the multiple number field sieve variant uses several number fields. The discussion and the analysis will follow the works <em>[8, 24]</em>.</p>

    <p class="text-gray-300">There are two variants of multiple number field sieve algorithm. In the first variant, the image of <span class="math">\\phi(x)</span> needs to be smooth in at least any two of the number fields. In the second variant, the image of <span class="math">\\phi(x)</span> needs to be smooth in the first number field and at least one of the other number fields.</p>

    <p class="text-gray-300">We have analysed both the variants of multiple number field sieve algorithm and found that the second variant turns out to be better than the first one. So we discuss the second variant of MNFS only. In contrast to the number field sieve algorithm, the right number field is replaced by a collection of <span class="math">V</span> number fields in the second variant of MNFS. The sieving polynomial <span class="math">\\phi(x)</span> has to satisfy the smoothness condition on the left number field as before. On the right side, it is sufficient for <span class="math">\\phi(x)</span> to satisfy a smoothness condition on at least one of the <span class="math">V</span> number fields.</p>

    <p class="text-gray-300">Recall that Algorithm <span class="math">\\mathcal{A}</span> produces two polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> of degrees <span class="math">d(r+1)</span> and <span class="math">dr</span> respectively. The polynomial <span class="math">g(x)</span> is defined as <span class="math">\\text{Res}_{y}(\\psi(y),C_{0}(x)+yC_{1}(x))</span> where <span class="math">\\psi(x)=\\text{LLL}(M_{A_{2},r})</span>, i.e., <span class="math">\\psi(x)</span> is defined from the first row of the matrix obtained after applying the LLL-algorithm to <span class="math">M_{A_{2},r}</span>.</p>

    <p class="text-gray-300">Methods for obtaining the collection of number fields on the right have been mentioned in <em>[24]</em>. We adapt one of these methods to our setting. Consider Algorithm <span class="math">\\mathcal{A}</span>. Let <span class="math">\\psi_{1}(x)</span> be <span class="math">\\psi(x)</span> as above and let <span class="math">\\psi_{2}(x)</span> be the polynomial defined</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">from the second row of the matrix <span class="math">M_{A_{2},r}</span>. Define <span class="math">g_{1}(x)=\\mathrm{Res}_{y}(\\psi_{1}(y),C_{0}(x)+yC_{1}(x))</span> and <span class="math">g_{2}(x)=\\mathrm{Res}_{y}(\\psi_{2}(y),C_{0}(x)+yC_{1}(x))</span>. Then choose <span class="math">V-2</span> linear combinations <span class="math">g_{i}(x)=s_{i}g_{1}(x)+t_{i}g_{2}(x)</span>, for <span class="math">i=3,\\ldots,V</span>. Note that the coefficients <span class="math">s_{i}</span> and <span class="math">t_{i}</span> are of the size of <span class="math">\\sqrt{V}</span>. All the <span class="math">g_{i}</span>â€™s have degree <span class="math">dr</span>. Asymptotically, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=Q^{1/(d(r+1))}<span class="math">. Since we take </span>V=L_{Q}(1/3)<span class="math">, all the </span>g_{i}<span class="math">â€™s have their infinity norms to be the same as that of </span>g(x)$ given by Proposition 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the left number field, as before, let <span class="math">B</span> be the bound on the norms of the ideals which are in the factor basis defined by <span class="math">f</span>. For each of the right number fields, let <span class="math">B^{\\prime}</span> be the bound on the norms of the ideals which are in the factor basis defined by each of the <span class="math">g_{i}</span>â€™s. So, the size of the entire factor basis is <span class="math">B+VB^{\\prime}</span>. The following condition balances the left portion and the right portion of the factor basis.</p>

    <p class="text-gray-300"><span class="math">B=VB^{\\prime}.</span> (26)</p>

    <p class="text-gray-300">With this condition, the size of the factor basis is <span class="math">B^{1+o(1)}</span> as in the classical NFS and so asymptotically, the linear algebra step takes time <span class="math">B^{2}</span>. As before, the number of sieving polynomials is <span class="math">E^{2}=B^{2}</span> and the coefficients of <span class="math">\\phi(x)</span> can take <span class="math">E^{2/t}</span> distinct values.</p>

    <p class="text-gray-300">Let <span class="math">\\pi</span> be the probability that a random sieving polynomial <span class="math">\\phi(x)</span> gives rise to a relation. Let <span class="math">\\pi_{1}</span> be the probability that <span class="math">\\phi(x)</span> is smooth over the left factor basis and <span class="math">\\pi_{2}</span> be the probability that <span class="math">\\phi(x)</span> is smooth over at least one of the right factor bases. Further, let <span class="math">\\Gamma_{1}=\\mathrm{Res}_{x}(f(x),\\phi(x))</span> be the bound on the norm corresponding to the left number field and <span class="math">\\Gamma_{2}=\\mathrm{Res}_{x}(g_{i}(x),\\phi(x))</span> be the bound on the norm for any of the right number fields. Note that <span class="math">\\Gamma_{2}</span> is determined only by the degree and the <span class="math">L_{\\infty}</span>-norm of <span class="math">g_{i}(x)</span> and hence is the same for all <span class="math">g_{i}(x)</span>â€™s. Heuristically, we have</p>

    <p class="text-gray-300"><span class="math">\\pi_{1}</span> <span class="math">=\\Psi(\\Gamma_{1},B);</span> (27) <span class="math">\\pi_{2}</span> <span class="math">=V\\Psi(\\Gamma_{2},B^{\\prime});</span> <span class="math">\\pi</span> <span class="math">=\\pi_{1}\\times\\pi_{2}.</span></p>

    <p class="text-gray-300">As before, one relation is obtained in about <span class="math">\\pi^{-1}</span> trials and so <span class="math">B</span> relations are obtained in about <span class="math">B\\pi^{-1}</span> trials. Balancing the cost of linear algebra and sieving, we have as before <span class="math">B=\\pi^{-1}</span>.</p>

    <p class="text-gray-300">The following choices of <span class="math">B</span> and <span class="math">V</span> are made.</p>

    <p class="text-gray-300"><span class="math">E</span> <span class="math">=B=L_{Q}\\left(\\tfrac{1}{3},c_{b}\\right);</span> (28) <span class="math">V</span> <span class="math">=L_{Q}\\left(\\tfrac{1}{3},c_{v}\\right);\\text{ and so}</span> <span class="math">B^{\\prime}</span> <span class="math">=B/V=L_{Q}\\left(\\tfrac{1}{3},c_{b}-c_{v}\\right).</span></p>

    <p class="text-gray-300">With these choices of <span class="math">B</span> and <span class="math">V</span>, it is possible to analyse the MNFS variant for Algorithm <span class="math">\\mathcal{A}</span> for three cases, namely, the medium prime case, the boundary case and the large characteristic case. Below we present the details of the boundary case. This presents a new asymptotic result.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 4 (MNFS-Boundary Case)</h6>

    <p class="text-gray-300">Let <span class="math">k</span> divide <span class="math">n</span>, <span class="math">r\\geq k</span>, <span class="math">t\\geq 2</span> and</p>

    <p class="text-gray-300"><span class="math">p=L_{Q}\\left(\\frac{2}{3},c_{p}\\right)\\text{ where }c_{p}=\\frac{1}{n}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1/3}.</span></p>

    <p class="text-gray-300">It is possible to ensure that the runtime of the MNFS algorithm is <span class="math">L_{Q}(1/3, 2c_{b})</span> where</p>

    <div class="my-4 text-center"><span class="math-block">c _ {b} = \\frac {4 r + 2}{6 k t c _ {p}} + \\sqrt {\\frac {r (3 r + 2)}{(3 k t c _ {p}) ^ {2}} + \\frac {c _ {p} k (t - 1)}{3 (r + 1)}}. \\tag {29}</span></div>

    <p class="text-gray-300">Proof. Note the following computations.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Gamma_ {1} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg (f)} = E ^ {2 \\deg (f) / t} = E ^ {(2 d (r + 1)) / t} = E ^ {(2 n (r + 1)) / (k t)} \\\\ = L _ {Q} \\left(\\frac {2}{3}, \\frac {2 (r + 1) c _ {b}}{k t c _ {p}}\\right); \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\pi_ {1} ^ {- 1} = L _ {Q} \\left(\\frac {1}{3}, \\frac {2 (r + 1)}{3 k t c _ {p}}\\right); \\\\ \\Gamma_ {2} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg (g)} \\times \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg (\\phi)} = E ^ {2 \\deg (g) / t} \\times Q ^ {(t - 1) / (d (r + 1))} \\\\ = E ^ {(2 r d) / t} \\times Q ^ {(t - 1) / (d (r + 1))} = E ^ {(2 r n) / (k t)} \\times Q ^ {k (t - 1) / (n (r + 1))} \\\\ = L _ {Q} \\left(\\frac {2}{3}, \\frac {2 r c _ {b}}{c _ {p} k t} + \\frac {k c _ {p} (t - 1)}{r + 1}\\right); \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\pi_ {2} ^ {- 1} = L _ {Q} \\left(\\frac {1}{3}, - c _ {v} + \\frac {1}{3 (c _ {b} - c _ {v})} \\left(\\frac {2 r c _ {b}}{c _ {p} k t} + \\frac {k c _ {p} (t - 1)}{r + 1}\\right)\\right); \\\\ \\pi^ {- 1} = L _ {Q} \\left(\\frac {1}{3}, \\frac {2 (r + 1)}{3 k t c _ {p}} - c _ {v} + \\frac {1}{3 (c _ {b} - c _ {v})} \\left(\\frac {2 r c _ {b}}{c _ {p} k t} + \\frac {k c _ {p} (t - 1)}{r + 1}\\right)\\right); \\\\ \\end{array}</span></div>

    <p class="text-gray-300">From the condition <span class="math">\\pi^{-1} = B</span>, we obtain the following equation.</p>

    <div class="my-4 text-center"><span class="math-block">c _ {b} = \\frac {2 (r + 1)}{3 k t c _ {p}} - c _ {v} + \\frac {1}{3 \\left(c _ {b} - c _ {v}\\right)} \\left(\\frac {2 r c _ {b}}{c _ {p} k t} + \\frac {k c _ {p} (t - 1)}{r + 1}\\right). \\tag {30}</span></div>

    <p class="text-gray-300">We wish to find <span class="math">c_v</span> such that <span class="math">c_b</span> is minimised subject to the constraint (30). Using the method of Lagrange multipliers, the partial derivative of (30) with respect to <span class="math">c_v</span> gives</p>

    <div class="my-4 text-center"><span class="math-block">c _ {v} = \\frac {r + 1}{3 k t c _ {p}}.</span></div>

    <p class="text-gray-300">Using this value of <span class="math">c_v</span> in (30) provides the following quadratic in <span class="math">c_b</span>.</p>

    <div class="my-4 text-center"><span class="math-block">(3 k t c _ {p}) c _ {b} ^ {2} - (4 r + 2) c _ {b} + \\frac {(r + 1) ^ {2}}{3 k t c _ {p}} - \\frac {(c _ {p} k) ^ {2} t (t - 1)}{r + 1} = 0.</span></div>

    <p class="text-gray-300">Solving this and taking the positive square root, we obtain</p>

    <div class="my-4 text-center"><span class="math-block">c _ {b} = \\frac {4 r + 2}{6 k t c _ {p}} + \\sqrt {\\frac {r (3 r + 2)}{(3 k t c _ {p}) ^ {2}} + \\frac {c _ {p} k (t - 1)}{3 (r + 1)}}. \\tag {31}</span></div>

    <p class="text-gray-300">Hence the overall complexity of MNFS for the boundary case is <span class="math">L_{Q}\\left(\\frac{1}{3},2c_{b}\\right)</span>.</p>

    <p class="text-gray-300">â–¡</p>

    <p class="text-gray-300">Theorem 4 expresses  <span class="math">2c_{b}</span>  as a function of  <span class="math">c_{p}, t, k</span>  and  <span class="math">r</span> . Let us write this as  <span class="math">2c_{b} = \\mathbf{C}(c_{p}, t, k, r)</span> . It turns out that fixing the values of  <span class="math">(t, k, r)</span>  gives a set  <span class="math">S(t, k, r)</span>  such that for  <span class="math">c_{p} \\in S(t, k, r)</span> ,  <span class="math">\\mathbf{C}(c_{p}, t, k, r) \\leq \\mathbf{C}(c_{p}, t&#x27;, k&#x27;, r&#x27;)</span>  for any  <span class="math">(t&#x27;, k&#x27;, r&#x27;) \\neq (t, k, r)</span> . In other words, for a choice of  <span class="math">(t, k, r)</span> , there is a set of values for  <span class="math">c_{p}</span>  where the minimum complexity of MNFS- <span class="math">\\mathcal{A}</span>  is attained. The set  <span class="math">S(t, k, r)</span>  could be empty implying that the particular choice of  <span class="math">(t, k, r)</span>  is suboptimal.</p>

    <p class="text-gray-300">For  <span class="math">1.12 \\leq c_p \\leq 4.5</span> , the appropriate intervals are given in Table 4. Further, the interval  <span class="math">(0,1.12]</span>  is the union of  <span class="math">S(t,1,1)</span>  for  <span class="math">t \\geq 3</span> . Note that the choice  <span class="math">(t,k,r) = (t,1,1)</span>  specialises MNFS- <span class="math">\\mathcal{A}</span>  to MNFS-Conjugation. So, for  <span class="math">c_p \\in (0,1.12] \\cup [1.45,3.15]</span>  the complexity of MNFS- <span class="math">\\mathcal{A}</span>  is the same as that of MNFS-Conjugation.</p>

    <p class="text-gray-300">Table 4. Choices of  <span class="math">(t,k,r)</span>  and the corresponding  <span class="math">S(t,k,r)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(t,k,r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(t,k,r)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(t,1,1), tâ‰¥3</td>

            <td class="px-3 py-2 border-b border-gray-700">âˆªtâ‰¥3S(t,1,1)â‰ˆ(0,1.12]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,3,3)</td>

            <td class="px-3 py-2 border-b border-gray-700">[(1/3)(4âˆš21+20)1/3, (âˆš78/9+29/36)1/3]â‰ˆ[1.12,1.21]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,2,2)</td>

            <td class="px-3 py-2 border-b border-gray-700">[(âˆš78/9+29/36)1/3, (1/2)(4âˆš11+11)1/3]â‰ˆ[1.21,1.45]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,1,1)</td>

            <td class="px-3 py-2 border-b border-gray-700">[(1/2)(4âˆš11+11)1/3, (2âˆš62+31/2)1/3]â‰ˆ[1.45,3.15]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,1,2)</td>

            <td class="px-3 py-2 border-b border-gray-700">[(2âˆš62+31/2)1/3, (8âˆš33+45)1/3]â‰ˆ[3.15,4.5]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Figure 4, we have plotted  <span class="math">2c_{b}</span>  given by Theorem 4 against  <span class="math">c_{p}</span>  for some values of  <span class="math">t</span> ,  <span class="math">k</span>  and  <span class="math">r</span>  where the minimum complexity of MNFS- <span class="math">\\mathcal{A}</span>  is attained. The plot is labelled MNFS- <span class="math">\\mathcal{A}</span> . The sets  <span class="math">S(t,k,r)</span>  are clearly identifiable from the plot. The figure also shows a similar plot for NFS- <span class="math">\\mathcal{A}</span>  which shows the complexity in the boundary case given by Theorem 1. For comparison, we have plotted the complexities of the GJL and the Conjugation methods from [5] and the MNFS-GJL and the MNFS-Conjugation methods from [24].</p>

    <p class="text-gray-300">Based on the plots given in Figure 4, we have the following observations.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Complexities of NFS- <span class="math">\\mathcal{A}</span>  are never worse than the complexities of NFS-GJL and NFS-Conjugation. Similarly, complexities of MNFS- <span class="math">\\mathcal{A}</span>  are never worse than the complexities of MNFS-GJL and MNFS-Conjugation.</li>

      <li>For both the NFS- <span class="math">\\mathcal{A}</span>  and the MNFS- <span class="math">\\mathcal{A}</span>  methods, increasing the value of  <span class="math">r</span>  provides new complexity trade-offs.</li>

      <li>There is a value of  <span class="math">c_p</span>  for which the minimum complexity is achieved. This corresponds to the MNFS-Conjugation. Let  <span class="math">L_{Q}(1/3, \\theta_0)</span>  be this complexity. The value of  <span class="math">\\theta_0</span>  is determined later.</li>

      <li>Let the complexity of the MNFS-GJL be  <span class="math">L_{Q}(1/3, \\theta_{1})</span> . The value of  <span class="math">\\theta_{1}</span>  was determined in [24]. The plot for MNFS- <span class="math">\\mathcal{A}</span>  approaches the plot for MNFS-GJL from below.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For smaller values of <span class="math">c_p</span>, it is advantageous to choose <span class="math">t &amp;gt; 2</span> or <span class="math">k &amp;gt; 1</span>. On the other hand, for larger values of <span class="math">c_p</span>, the minimum complexity is attained for <span class="math">t = 2</span> and <span class="math">k = 1</span>.</li>

    </ol>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. Complexity plot for boundary case</p>

    <p class="text-gray-300">From the plot, it can be seen that for larger values of <span class="math">c_p</span>, the minimum value of <span class="math">c_b</span> is attained for <span class="math">t = 2</span> and <span class="math">k = 1</span>. So, we decided to perform further analysis using these values of <span class="math">t</span> and <span class="math">k</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">8.2 Analysis for <span class="math">t = 2</span> and <span class="math">k = 1</span></h2>

    <p class="text-gray-300">Fix <span class="math">t = 2</span> and <span class="math">k = 1</span> and let us denote <span class="math">\\mathbf{C}(c_p, 2, 1, r)</span> as simply <span class="math">\\mathbf{C}(c_p, r)</span>. Then from Theorem 4 the complexity of MNFS-<span class="math">\\mathcal{A}</span> for <span class="math">p = L_Q(2/3, c_p)</span> is <span class="math">L_Q(1/3, \\mathbf{C}(c_p, r))</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {C} \\left(c _ {p}, r\\right) = 2 c _ {b} = 2 \\sqrt {\\frac {c _ {p}}{3 (r + 1)} + \\frac {(3 r + 2) r}{3 6 c _ {p} ^ {2}}} + \\frac {2 r + 1}{3 c _ {p}}. \\tag {32}</span></div>

    <p class="text-gray-300">Figure 4 shows that for each <span class="math">r \\geq 1</span>, there is an interval <span class="math">[\\epsilon_0(r), \\epsilon_1(r)]</span> such that for <span class="math">c_p \\in [\\epsilon_0(r), \\epsilon_1(r)]</span>, <span class="math">\\mathbf{C}(c_p, r) &amp;lt; \\mathbf{C}(c_p, r&#x27;)</span> for <span class="math">r \\neq r&#x27;</span>. For <span class="math">r = 1</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon_ {0} (1) = \\frac {1}{2} \\left(4 \\sqrt {1 1} + 1 1\\right) ^ {\\frac {1}{3}} \\approx 1. 4 5; \\epsilon_ {1} (1) = \\left(2 \\sqrt {6 2} + \\frac {3 1}{2}\\right) ^ {\\frac {1}{3}} \\approx 3. 1 5.</span></div>

    <p class="text-gray-300">For <span class="math">p = L_{Q}(2/3, c_{p})</span>, the complexity of MNFS-<span class="math">\\mathcal{A}</span> is same as the complexity of MNFS-Conj. for <span class="math">c_{p}</span> in [1.45, 3.15]; for <span class="math">c_{p} &amp;gt; 3.15</span>, the complexity of MNFS-<span class="math">\\mathcal{A}</span> is</p>

    <p class="text-gray-300">lower than the complexity of all prior methods. The following result shows that the minimum complexity attainable by MNFS-<span class="math">\\mathcal{A}</span> approaches the complexity of MNFS-GJL from below.</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> For <span class="math">r \\geq 1</span>, let <span class="math">C(r) = \\min_{c_p &amp;gt; 0} \\mathbf{C}(c_p, r)</span>. Then</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C(1) = \\theta_0 = \\left(\\frac{146}{261}\\sqrt{22} +\\frac{208}{87}\\right)^{1 / 3}</span>.</li>

      <li>For <span class="math">r \\geq 1</span>, <span class="math">C(r)</span> is monotone increasing and bounded above.</li>

      <li>The limiting upper bound of <span class="math">C(r)</span> is <span class="math">\\theta_{1} = \\left(\\frac{2\\times(13\\sqrt{13} + 46)}{27}\\right)^{1 / 3}</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Proof.</strong> Differentiating <span class="math">\\mathbf{C}(c_p, r)</span> with respect to <span class="math">c_p</span> and equating to 0 gives</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\frac {6}{r + 1} - \\frac {(3 r + 2) r}{c _ {p} ^ {3}}}{1 8 \\sqrt {\\frac {c _ {p}}{3 (r + 1)} + \\frac {(3 r + 2) r}{3 6 c _ {p} ^ {2}}}} - \\frac {2 r + 1}{3 c _ {p} ^ {2}} = 0 \\tag {33}</span></div>

    <p class="text-gray-300">On simplifying we get,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {6 c _ {p} ^ {3} - (3 r + 2) r (r + 1)}{\\sqrt {\\left(1 2 c _ {p} ^ {3} + (r + 1) (3 r + 2) r\\right) (r + 1)}} - \\frac {2 r + 1}{1} = 0 \\tag {34}</span></div>

    <p class="text-gray-300">Equation (34) is quadratic in <span class="math">c_p^3</span>. On solving we get the following value of <span class="math">c_p</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c _ {p} = \\left(\\frac {7}{6} r ^ {3} + \\frac {1 3}{6} r ^ {2} + \\frac {1}{6} \\sqrt {1 3 r ^ {2} + 1 0 r + 1} \\left(2 r ^ {2} + 3 r + 1\\right) + \\frac {7}{6} r + \\frac {1}{6}\\right) ^ {1 / 3}; \\\\ = \\rho (r) (\\text {say}). \\tag {35} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Putting the value of <span class="math">c_p</span> back in (32), we get the minimum value of <span class="math">C</span> (in terms of <span class="math">r</span>) as</p>

    <div class="my-4 text-center"><span class="math-block">C (r) = 2 \\sqrt {\\frac {\\rho (r)}{3 (r + 1)} + \\frac {(3 r + 2) r}{3 6 \\rho (r) ^ {2}}} + \\frac {2 r + 1}{3 \\rho (r)}. \\tag {36}</span></div>

    <p class="text-gray-300">All the three sequences in the expression for <span class="math">C(r)</span>, viz, <span class="math">\\frac{\\rho(r)}{3(r + 1)}</span>, <span class="math">\\frac{(3r + 2)r}{36\\rho(r)^2}</span> and <span class="math">\\frac{2r + 1}{3\\rho(r)}</span> are monotonic increasing. This can be verified through computation (with a symbolic algebra package) as follows. Let <span class="math">s_r</span> be any one of these sequences. Then computing <span class="math">s_{r + 1} / s_r</span> gives a ratio of polynomial expressions from which it is possible to directly argue that <span class="math">s_{r + 1} / s_r</span> is greater than one. We have done these computations but, do not present the details since they are uninteresting and quite messy. Since all the three sequences <span class="math">\\frac{\\rho(r)}{3(r + 1)}</span>, <span class="math">\\frac{(3r + 2)r}{36\\rho(r)^2}</span> and <span class="math">\\frac{2r + 1}{3\\rho(r)}</span> are monotonic increasing so is <span class="math">C(r)</span>.</p>

    <p class="text-gray-300">\\ddagger This equation is incorrect in the proceedings version.</p>

    <p class="text-gray-300">Note that for <span class="math">r\\geq 1</span>, <span class="math">\\rho(r)&gt;(7/6)^{1/3}r&gt;1.05r</span>. So, for <span class="math">r&gt;1</span>,</p>

    <p class="text-gray-300"><span class="math">\\frac{(3r+2)r}{\\rho(r)^{2}}</span> <span class="math">=3\\left(\\frac{r}{\\rho(r)}\\right)^{2}+2\\frac{r}{\\rho(r)^{2}}&lt;3\\times\\left(\\frac{1}{1.05}\\right)^{2}+2\\times\\frac{1}{1.05}.</span> <span class="math">\\frac{(2r+1)}{\\rho(r)}</span> <span class="math">=2\\frac{r}{\\rho(r)}+\\frac{1}{\\rho(r)}&lt;2\\times\\frac{1}{1.05}+\\frac{1}{1.05}.</span></p>

    <p class="text-gray-300">This shows that the sequences <span class="math">\\frac{(3r+2)r}{\\rho(r)^{2}}</span> and <span class="math">\\frac{(2r+1)}{\\rho(r)}</span> are bounded above. For <span class="math">r&gt;8</span>, we have <span class="math">(3r+1)&lt;(8r+1)&lt;r^{2}</span> and <span class="math">(2r^{2}+r+1/6)&lt;r^{3}/3</span> which implies that for <span class="math">r&gt;8</span>, <span class="math">\\rho(r)&lt;(7/6+1/6\\times\\sqrt{14}\\times 3+1/3)^{1/3}r&lt;1.5\\,r</span>. Using <span class="math">\\rho(r)&lt;1.5r</span> for <span class="math">r&gt;8</span>, it can be shown that the sequence <span class="math">\\left(\\frac{\\rho(r)}{r+1}\\right)_{r&gt;8}</span> is bounded above by <span class="math">1.5</span>. Since the three constituent sequences <span class="math">\\frac{\\rho(r)}{(r+1)}</span>, <span class="math">\\frac{(3\\,r+2)r}{\\rho(r)^{2}}</span> and <span class="math">\\frac{2\\,r+1}{\\rho(r)}</span> are bounded above, it follows that <span class="math">C(r)</span> is also bounded above. Being monotone increasing and bounded above <span class="math">C(r)</span> is convergent. We claim that</p>

    <p class="text-gray-300"><span class="math">\\lim_{r\\to\\infty}C(r)=\\left(\\frac{2\\times(13\\sqrt{13}+46)}{27}\\right)^{1/3}.</span></p>

    <p class="text-gray-300">The proof of the claim is the following. Using the expression for <span class="math">\\rho(r)</span> from (35) we have <span class="math">\\lim_{r\\to\\infty}\\frac{\\rho(r)}{r}=\\left(\\frac{2}{6}\\,\\sqrt{13}+\\frac{7}{6}\\right)^{\\frac{1}{3}}</span>. Now,</p>

    <p class="text-gray-300"><span class="math">C(r)=2\\,\\sqrt{\\frac{\\rho(r)/r}{3\\,(1+1/r)}+\\frac{(3+2/r)}{36\\,\\rho(r)^{2}/r^{2}}}+\\frac{2+1/r}{3\\,\\rho(r)/r}.</span> (37)</p>

    <p class="text-gray-300">Hence,</p>

    <p class="text-gray-300"><span class="math">\\lim_{r\\to\\infty}C(r)=2\\,\\sqrt{\\frac{(2\\sqrt{13}+7)^{1/3}}{3\\times 6^{1/3}}+\\frac{3\\times 6^{2/3}}{36\\,(2\\sqrt{13}+7)^{2/3}}}+\\frac{2\\times 6^{1/3}}{3\\,(2\\sqrt{13}+7)^{1/3}}</span></p>

    <p class="text-gray-300">After further simplification, we get</p>

    <p class="text-gray-300"><span class="math">\\lim_{r\\to\\infty}C(r)=\\left(\\frac{2\\times(13\\sqrt{13}+46)}{27}\\right)^{1/3}.</span></p>

    <p class="text-gray-300">The limit of <span class="math">C(r)</span> as <span class="math">r</span> goes to infinity is the value of <span class="math">\\theta_{1}</span> where <span class="math">L_{Q}(1/3,\\theta_{1})</span> is the complexity of MNFS-GJL as determined in <em>[24]</em>. This shows that as <span class="math">r</span> goes to infinity, the complexity of MNFS-<span class="math">\\mathcal{A}</span> approaches the complexity of MNFS-GJL from below.</p>

    <p class="text-gray-300">We have already seen that <span class="math">C(r)</span> is monotone increasing for <span class="math">r\\geq 1</span>. So, the minimum value of <span class="math">C(r)</span> is obtained for <span class="math">r=1</span>. After simplifying <span class="math">C(1)</span>, we get the minimum complexity of MNFS-<span class="math">\\mathcal{A}</span> to be</p>

    <p class="text-gray-300"><span class="math">L_{Q}\\left(1/3,\\frac{3+\\sqrt{3(11+4\\sqrt{6})}}{\\left(18\\left(7+3\\sqrt{6}\\right)\\right)^{1/3}}\\right)=L\\left(1/3,1.7114\\right).</span></p>

    <p class="text-gray-300">This minimum complexity is obtained at  <span class="math">c_{p} = \\rho(1) = \\left(2\\sqrt{6} + \\frac{14}{3}\\right)^{\\frac{1}{3}} = 2.123</span> .</p>

    <p class="text-gray-300">Note 1. As mentioned earlier, for  <span class="math">r = k = 1</span> , the new method of polynomial selection becomes the Conjugation method. So, the minimum complexity of MNFS- <span class="math">\\mathcal{A}</span>  is the same as the minimum complexity for MNFS-Conjugation. Here we note that the value of the minimum complexity given by (38), is not same as the one reported by Pierrot in [24]. This is due to an error in the calculation in [24].</p>

    <p class="text-gray-300">Complexity of NFS- <span class="math">\\mathcal{A}</span> : From Figure 4, it can be seen that there is an interval for  <span class="math">c_p</span>  for which the complexity of NFS- <span class="math">\\mathcal{A}</span>  is better than both MNFS-Conjugation and MNFS-GJL. An analysis along the lines as done above can be carried out to formally show this. We skip the details since these are very similar to (actually a bit simpler than) the analysis done for MNFS- <span class="math">\\mathcal{A}</span> . Here we simply mention the following two results:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">c_p \\geq (2\\sqrt{89} + 20)^{\\frac{1}{3}} \\approx 3.39</span> , the complexity of NFS- <span class="math">\\mathcal{A}</span>  is better than that of MNFS-Conjugation.</li>

      <li>For  <span class="math">c_p \\leq \\frac{1}{8} \\sqrt{390} \\sqrt{(5 \\sqrt{13} - 18) \\left( \\frac{26}{27} \\sqrt{13} + \\frac{92}{27} \\right)^{\\frac{1}{3}}} + \\frac{45}{8} \\left( \\frac{26}{27} \\sqrt{13} + \\frac{92}{27} \\right)^{\\frac{2}{3}} \\approx 20.91</span> , the complexity of NFS- <span class="math">\\mathcal{A}</span>  is better than that of MNFS-GJL.</li>

      <li>So, for  <span class="math">c_p \\in [3.39, 20.91]</span> , the complexity of NFS- <span class="math">\\mathcal{A}</span>  is better than the complexity of all previous methods including the MNFS variants.</li>

    </ol>

    <p class="text-gray-300">Current state-of-the-art: The complexity of MNFS- <span class="math">\\mathcal{A}</span>  is lower than that of NFS- <span class="math">\\mathcal{A}</span> . As mentioned earlier (before Table 4) the interval  <span class="math">(0,1.12]</span>  is the union of  <span class="math">\\cup_{t\\geq 3}S(t,1,1)</span> . This fact combined with Theorem 5 and Table 4 show the following. For  <span class="math">p = L_Q(2/3,c_p)</span> , when  <span class="math">c_p\\in (0,1.12]\\cup [1.45,3.15]</span> , the complexity of MNFS- <span class="math">\\mathcal{A}</span>  is the same as that of MNFS-Conjugation; for  <span class="math">c_p\\notin (0,1.12]\\cup [1.45,3.15]</span>  and  <span class="math">c_p &amp;gt; 0</span> , the complexity of MNFS- <span class="math">\\mathcal{A}</span>  is smaller than all previous methods. Hence, MNFS- <span class="math">\\mathcal{A}</span>  should be considered to provide the current state-of-the-art asymptotic complexity in the boundary case.</p>

    <p class="text-gray-300">In a manner similar to that used to prove Theorem 4, it is possible to work out the complexities for the medium and large characteristic cases of the MNFS corresponding to the new polynomial selection method. To tackle the medium prime case, the value of  <span class="math">t</span>  is taken to be  <span class="math">t = c_{t}n\\left((\\ln Q)(\\ln \\ln Q)\\right)^{-1 / 3}</span>  and to tackle the large prime case, the value of  <span class="math">r</span>  is taken to be  <span class="math">r = c_{r} / 2\\left((\\ln Q)(\\ln \\ln Q)\\right)^{1 / 3}</span> .</p>

    <p class="text-gray-300">This will provide a relation between <span class="math">c_{b},c_{v}</span> and <span class="math">r</span> (for the medium prime case) or <span class="math">t</span> (for the large prime case). The method of Lagrange multipliers is then used to find the minimum value of <span class="math">c_{b}</span>. We have carried out these computations and the complexities turn out to be the same as those obtained in <em>[24]</em> for the MNFS-GJL (for large characteristic) and the MNFS-Conjugation (for medium characteristic) methods. Hence, we do not present these details.</p>

    <h2 id="sec-23" class="text-2xl font-bold">9 Conclusion</h2>

    <p class="text-gray-300">In this work, we have proposed a new method for polynomial selection for the NFS algorithm for fields <span class="math">\\mathbb{F}_{p^{n}}</span> with <span class="math">n&gt;1</span>. Asymptotic analysis of the complexity has been carried out both for the classical NFS and the MNFS algorithms for polynomials obtained using the new method. For the boundary case with <span class="math">p=L_{Q}(2/3,c_{p})</span> for <span class="math">c_{p}</span> outside a small set, the new method provides complexity which is lower than all previously known methods.</p>

    <h2 id="sec-24" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Leonard M. Adleman. The function field sieve. In Leonard M. Adleman and Ming-Deh A. Huang, editors, ANTS, volume 877 of Lecture Notes in Computer Science, pages 108â€“121. Springer, 1994.</li>

      <li>[2] Leonard M. Adleman and Ming-Deh A. Huang. Function field sieve method for discrete logarithms over finite fields. Inf. Comput., 151(1-2):5â€“16, 1999.</li>

      <li>[3] Shi Bai, Cyril Bouvier, Alain Filbois, Pierrick Gaudry, Laurent Imbert, Alexander Kruppa, FranÃ§ois Morain, Emmanuel ThomÃ©, and Paul Zimmermann. CADO-NFS, an implementation of the number field sieve algorithm. CADO-NFS, Release 2.1.1, 2014. http://cado-nfs.gforge.inria.fr/.</li>

      <li>[4] Razvan Barbulescu. An appendix for a recent paper of Kim. IACR Cryptology ePrint Archive, 2015:1076, 2015.</li>

      <li>[5] Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and FranÃ§ois Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology â€“ EUROCRYPT 2015, volume 9056 of Lecture Notes in Computer Science, pages 129â€“155. Springer Berlin Heidelberg, 2015.</li>

      <li>[6] Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel ThomÃ©. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Phong Q. Nguyen and Elisabeth Oswald, editors, Advances in Cryptology â€“ EUROCRYPT 2014, volume 8441 of Lecture Notes in Computer Science, pages 1â€“16. Springer Berlin Heidelberg, 2014.</li>

      <li>[7] Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung. The tower number field sieve. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology â€“ ASIACRYPT 2015, volume 9453 of Lecture Notes in Computer Science, pages 31â€“55. Springer, 2015.</li>

      <li>[8] Razvan Barbulescu and CÃ©cile Pierrot. The multiple number field sieve for medium and high characteristic finite fields. LMS Journal of Computation and Mathematics, 17:230â€“246, 2014.</li>

      <li>[</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] Wieb Bosma, John Cannon, and Catherine Playoust. The Magma algebra system. I. The user language. J. Symbolic Comput., 24(3-4):235â€“265, 1997. Computational algebra and number theory (London, 1993).</li>

      <li>[10] Pierrick Gaudry, Laurent Grmy, and Marion Videau. Collecting relations for the number field sieve in GF(<span class="math">p^{6}</span>). Cryptology ePrint Archive, Report 2016/124, 2016. http://eprint.iacr.org/.</li>

      <li>[11] Daniel M. Gordon. Discrete logarithms in GF(<span class="math">p</span>) using the number field sieve. SIAM J. Discrete Math, 6:124â€“138, 1993.</li>

      <li>[12] Robert Granger, Thorsten Kleinjung, and Jens ZumbrÃ¤gel. Discrete logarithms in GF(<span class="math">2^{9234}</span>). NMBRTHRY list, January 2014.</li>

      <li>[13] Aurore Guillevic. Computing individual discrete logarithms faster in GF(<span class="math">p^{n}</span>). Cryptology ePrint Archive, Report 2015/513, 2015. http://eprint.iacr.org/.</li>

      <li>[14] Antoine Joux. Faster index calculus for the medium prime case: Application to 1175-bit and 1425-bit finite fields. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT, volume 7881 of Lecture Notes in Computer Science, pages 177â€“193. Springer, 2013.</li>

      <li>[15] Antoine Joux. A new index calculus algorithm with complexity <span class="math">L(1/4+o(1))</span> in small characteristic. In Tanja Lange, Kristin E. Lauter, and Petr Lisonek, editors, Selected Areas in Cryptography â€“ SAC 2013, volume 8282 of Lecture Notes in Computer Science, pages 355â€“379. Springer, 2013.</li>

      <li>[16] Antoine Joux and Reynald Lercier. The function field sieve is quite special. In Claus Fieker and David R. Kohel, editors, ANTS, volume 2369 of Lecture Notes in Computer Science, pages 431â€“445. Springer, 2002.</li>

      <li>[17] Antoine Joux and Reynald Lercier. Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the gaussian integer method. Math. Comput., 72(242):953â€“967, 2003.</li>

      <li>[18] Antoine Joux and Reynald Lercier. The function field sieve in the medium prime case. In Serge Vaudenay, editor, EUROCRYPT, volume 4004 of Lecture Notes in Computer Science, pages 254â€“270. Springer, 2006.</li>

      <li>[19] Antoine Joux, Reynald Lercier, Nigel P. Smart, and Frederik Vercauteren. The number field sieve in the medium prime case. In Cynthia Dwork, editor, Advances in Cryptology â€“ CRYPTO, volume 4117 of Lecture Notes in Computer Science, pages 326â€“344. Springer, 2006.</li>

      <li>[20] Antoine Joux and CÃ©cile Pierrot. The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> - Application to pairing-friendly constructions. In Zhenfu Cao and Fangguo Zhang, editors, Pairing-Based Cryptography â€“ Pairing 2013, volume 8365 of Lecture Notes in Computer Science, pages 45â€“61. Springer, 2013.</li>

      <li>[21] M. Kalkbrener. An upper bound on the number of monomials in determinants of sparse matrices with symbolic entries. Mathematica Pannonica, 8(1):73â€“82, 1997.</li>

      <li>[22] Taechan Kim. Extended tower number field sieve: A new complexity for medium prime case. IACR Cryptology ePrint Archive, 2015:1027, 2015.</li>

      <li>[23] D. Matyukhin. Effective version of the number field sieve for discrete logarithm in a field GF(<span class="math">p^{k}</span>). Trudy po Discretnoi Matematike 9, 121151 (2006) (in Russian), 2006. http://m.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=tdm&paperid=144&option_lang=eng.</li>

      <li>[24] CÃ©cile Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology â€“ EUROCRYPT 2015, volume 9056 of Lecture Notes in Computer Science, pages 156â€“170, 2015.</li>

      <li>[25] P. Sarkar and S. Singh. Fine tuning the function field sieve algorithm for the medium prime case. Information Theory, IEEE Transactions on, PP(99):1â€“1, 2016.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[26] Oliver Schirokauer. Discrete logarithms and local units. Philosophical Transactions: Physical Sciences and Engineering, 1993.</li>

      <li>[27] Oliver Schirokauer. Using number fields to compute logarithms in finite fields. Math. Comp., 69(231):1267â€“1283, 2000.</li>

      <li>[28] Oliver Schirokauer. Virtual logarithms. J. Algorithms, 57(2):140â€“147, Nov 2005.</li>

      <li>[29] W. A. Stein et al. Sage Mathematics Software. The Sage Development Team, 2013. http://www.sagemath.org.</li>

    </ul>`;
---

<BaseLayout title="New Complexity Trade-Offs for the (Multiple) Number Field Si... (2015/944)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/944
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
