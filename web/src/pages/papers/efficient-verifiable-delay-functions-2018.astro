---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/623';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient verifiable delay functions';
const AUTHORS_HTML = 'Benjamin Wesolowski';

const CONTENT = `    <p class="text-gray-300">Benjamin Wesolowski</p>

    <p class="text-gray-300">École Polytechnique Fédérale de Lausanne EPFL IC LACAL, Station 14, CH-1015 Lausanne, Switzerland</p>

    <p class="text-gray-300">Abstract. We construct a verifiable delay function (VDF). A VDF is a function whose evaluation requires running a given number of sequential steps, yet the result can be efficiently verified. They have applications in decentralised systems, such as the generation of trustworthy public randomness in a trustless environment, or resource-efficient blockchains. To construct our VDF, we actually build a trapdoor VDF. A trapdoor VDF is essentially a VDF which can be evaluated efficiently by parties who know a secret (the trapdoor). By setting up this scheme in a way that the trapdoor is unknown (not even by the party running the setup, so that there is no need for a trusted setup environment), we obtain a simple VDF. Our construction is based on groups of unknown order such as an RSA group, or the class group of an imaginary quadratic field. The output of our construction is very short (the result and the proof of correctness are each a single element of the group), and the verification of correctness is very efficient.</p>

    <p class="text-gray-300">We describe a function that is slow to compute and easy to verify: a verifiable delay function (henceforth, VDF) in the sense of [4]. These functions should be computable in a prescribed amount of time <span class="math">\\Delta</span>, but not faster (the time measures an amount of sequential work, that is work that cannot be performed faster by running on a large number of parallel cores), and the result should be easy to verify (i.e., for a cost polylog(<span class="math">\\Delta</span>)). These special functions are used in [15] (under the name of slow-timed hash functions) to construct a trustworthy randomness beacon: a service producing publicly verifiable random numbers, which are guaranteed to be unbiased and unpredictable. These randomness beacons, introduced by Rabin in [17], are a valuable tool in a public, decentralised setting, as it is not trivial for someone to flip a coin and convince their peers that the outcome was not rigged. A number of interesting applications of VDFs have recently emerged — see [4] for an overview. Most notably, they can be used to design resource-efficient blockchains, eliminating the need for massively power-consuming mining farms. VDFs play a key role in the Chia blockchain design (chia.net), and the Ethereum Foundation (ethereum.org) and Protocol Labs (protocol.ai) are</p>

    <p class="text-gray-300">1 The paper [4] was developed independently of the present work, yet we adopt their terminology for verifiable delay functions, for the sake of uniformity.</p>

    <p class="text-gray-300">teaming up to investigate the technology of VDFs which promise to play a key role in their respective platforms.</p>

    <p class="text-gray-300">There is thereby a well-motivated need for an efficient construction. This problem was left open in <em>[4]</em>, and we address it here with a new, simple, and efficient VDF.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Contribution</h3>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">An efficient construction.</h4>

    <p class="text-gray-300">The starting point of our construction is the time-lock puzzle of Rivest, Shamir and Wagner <em>[18]</em>: given as input an RSA group <span class="math">(\\mathbf{Z}/N\\mathbf{Z})^{\\times}</span>, where <span class="math">N</span> is a product of two large, secret primes, a random element <span class="math">x\\in(\\mathbf{Z}/N\\mathbf{Z})^{\\times}</span>, and a timing parameter <span class="math">t</span>, compute <span class="math">x^{2^{t}}</span>. Without the factorisation of <span class="math">N</span>, this task requires <span class="math">t</span> sequential squarings in the group. More generally, one could work with any group <span class="math">G</span> of unknown order. This construction is only a time-lock puzzle and not a VDF, because given an output <span class="math">y</span>, there is no efficient way to verify that <span class="math">y=x^{2^{t}}</span>.</p>

    <p class="text-gray-300">The new VDF construction consists in solving an instance of the time-lock puzzle of <em>[18]</em>, and computing a proof of correctness, which allows anyone to efficiently verify the result. Fix a timing parameter <span class="math">\\Delta</span>, a security level <span class="math">k</span> (say, <span class="math">128,192</span>, or <span class="math">256</span>), and a group <span class="math">G</span>. Our construction has the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is <span class="math">\\Delta</span>-sequential (meaning that it requires <span class="math">\\Delta</span> sequential steps to evaluate) assuming the classic time-lock assumption of <em>[18]</em> in the group <span class="math">G</span>.</li>

      <li>It is sound (meaning that one cannot produce a valid proof for an incorrect output) under some group theoretic assumptions on <span class="math">G</span>, believed to be true for RSA groups and class groups of quadratic imaginary number fields.</li>

      <li>The output and the proof of correctness are each a single element of the group <span class="math">G</span> (also, the output can be recovered from the proof and a <span class="math">2k</span>-bit integer; so it is possible to transmit a single group element and a small integer instead of 2 group elements).</li>

      <li>The verification of correctness requires essentially two exponentiations in the group <span class="math">G</span>, with exponents of bit-length <span class="math">2k</span>.</li>

      <li>The proof can be produced in <span class="math">O(\\Delta/\\log(\\Delta))</span> group operations.</li>

    </ol>

    <p class="text-gray-300">For applications where a lot of these proofs need to be stored, widely distributed, and repeatedly verified, having very short and efficiently verifiable proofs is invaluable.</p>

    <p class="text-gray-300">Following discussions about the present work at the August 2018 workshop at Stanford hosted by the Ethereum Foundation and the Stanford Center for Blockchain Research, we note that our construction features two other useful properties: the proofs can be <em>aggregated</em> and <em>watermarked</em>. Aggregating consists in producing a single short proof that simultaneously proves the correctness of several VDF evaluations. Watermarking consists in tying a proof to the evaluator’s identity; in a blockchain setting, this allows to give credit (and a reward) to the party who spent time and resources evaluating the VDF. These properties</p>

    <p class="text-gray-300">are discussed in Section 7.</p>

    <p class="text-gray-300">Note that the method we describe to compute the proof requires an amount <span class="math">O(\\Delta/\\log(\\Delta))</span> group operations. Hence, there is an interval between the guaranteed sequential work <span class="math">\\Delta</span> and the total work <span class="math">(1+\\varepsilon)\\Delta</span>, where <span class="math">\\varepsilon=O(1/\\log(\\Delta))</span>. For practical parameters, this <span class="math">\\varepsilon</span> is in the order of <span class="math">0.05</span>, and this small part of the computation is easily parallelizable, so that the total evaluation time with <span class="math">s</span> cores is around <span class="math">(1+1/(20s))\\Delta</span>. This gap should be of no importance since anyways, computational models do not capture well small constant factors with respect to real-world running time. Precise timing is unlikely to be achievable without resorting to trusted hardware, thus applications of VDFs are designed not to be too sensitive to these small factors.</p>

    <p class="text-gray-300">If despite these facts it is still problematic in some application to know the output of the VDF slightly before having the proof, it is possible to eliminate this gap by artificially considering the proof as part of the output (the output is now a pair of group elements, and the proof is empty). The resulting protocol is still <span class="math">\\Delta</span>-sequential (trivially), and as noted in Remark 5, it is also sound. We also propose a second method in Section 4.3 which allows to exponentially reduce the overhead of the proof computation at the cost of lengthening the resulting proof by a few group elements.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Trapdoor verifiable delay function.</h4>

    <p class="text-gray-300">The construction proposed is actually a <em>trapdoor</em> VDF, from which we can derive an actual VDF. A party, Alice, holds a secret key <span class="math">\\mathsf{sk}</span> (the trapdoor), and an associated public key <span class="math">\\mathsf{pk}</span>. Given a piece of data <span class="math">x</span>, a trapdoor VDF allows to compute an output <span class="math">y</span> from <span class="math">x</span> such that anyone can easily verify that either <span class="math">y</span> has been computed by Alice (i.e., she used her secret trapdoor), or the computation of <span class="math">y</span> required an amount of time at least <span class="math">\\Delta</span> (where, again, time is measured as an amount of sequential work). The verification that <span class="math">y</span> is the correct output of the VDF for input <span class="math">x</span> should be efficient, with a cost <span class="math">\\text{polylog}(\\Delta)</span>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Deriving a verifiable delay function.</h4>

    <p class="text-gray-300">Suppose that a public key <span class="math">\\mathsf{pk}</span> for a trapdoor VDF is given without any known associated secret key. This results in a simple VDF, where the evaluation requires a prescribed amount of time <span class="math">\\Delta</span> for everyone (because there is no known trapdoor).</p>

    <p class="text-gray-300">Now, how to publicly generate a public key without any known associated private key? In the construction we propose, this amounts to the public generation of a group of unknown order. A standard choice for such groups are RSA groups, but it is hard to generate an RSA number (a product of two large primes) with a strong guarantee that nobody knows the factorisation. It is possible to generate a random number large enough that with high probability it is divisible by two large primes (as done in <em>[19]</em>), but this approach severely damages the efficiency of the construction, and leaves more room for parallel optimisation of the arithmetic modulo a large integer, or for specialised hardware acceleration. It is also possible to generate a modulus by a secure multiparty execution of the RSA key</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">generation procedure among independent parties, each contributing some secret random seeds (as done in <em>[6]</em>). However, in this scenario, a third party would have to assume that the parties involved in this computation did not collude to retrieve the secret. We propose to use the class group of an imaginary quadratic order. One can easily generate an imaginary quadratic order by choosing a random discriminant, and when the discriminant is large enough, the order of the class group cannot be computed. These class groups were introduced in cryptography by Buchmann and Williams in <em>[9]</em>, exploiting the difficulty of computing their orders (and the fact that this order problem is closely related to the discrete logarithm and the root problems in this group). To this day, the best known algorithms for computing the order of the class group of an imaginary quadratic field of discriminant <span class="math">d</span> are still of complexity $L_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(1/2)<span class="math"> under the generalised Riemann hypothesis, for the usual function </span>L_{t}(s)=\\exp\\left(O\\left(\\log(t)^{s}\\log\\log(t)^{1-s}\\right)\\right)$, as shown in <em>[14]</em> and <em>[20]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Circumventing classic impossibility results.</h4>

    <p class="text-gray-300">Finally, we further motivate the notion of <em>trapdoor</em> VDF by showing that it constitutes an original tool to circumvent classic impossibility results. We illustrate this in Section 8 with a simple and efficient identification protocol with surprising zero-knowledge and deniability properties.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.2 Time-sensitive cryptography and related work</h3>

    <p class="text-gray-300">Rivest, Shamir and Wagner <em>[18]</em> introduced in 1996 the use of <em>time-locks</em> for encrypting data that can be decrypted only in a predetermined time in the future. This was the first time-sensitive cryptographic primitive taking into account the parallel power of possible attackers. Other timed primitives appeared in different contexts: Bellare and Goldwasser <em>[1, 2]</em> suggested <em>time capsules</em> for key escrowing in order to counter the problem of early recovery. Boneh and Naor <em>[7]</em> introduced <em>timed commitments</em>: a hiding and binding commitment scheme, which can be <em>forced open</em> by a procedure of determined running time. More recently, and as already mentioned, the notion of slow-timed hash function was introduced in <em>[15]</em> as a tool to provide trust to the generation of public random numbers.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Verifiable delay functions.</h4>

    <p class="text-gray-300">These slow-timed hash functions were recently revisited and formalised by Boneh <em>et al.</em> in <em>[4]</em> under the name of verifiable delay functions. The function proposed in <em>[15]</em>, <em>sloth</em>, is not asymptotically efficiently verifiable: the verification procedure (given <span class="math">x</span> and <span class="math">y</span>, verify that <span class="math">\\mathsf{sloth}(x)=y</span>) is faster than the evaluation procedure (given <span class="math">x</span>, compute the value <span class="math">\\mathsf{sloth}(x)</span>) only by a constant factor. The authors of <em>[4]</em> proposed practical constructions that achieve an exponential gap between evaluation and verification, but do not strictly achieve the requirements of a VDF. For one of them, the evaluation requires an amount <span class="math">\\mathrm{polylog}(\\Delta)</span> of parallelism to run in parallel time <span class="math">\\Delta</span>. The other one is insecure against an adversary that can run a large (but feasible) pre-computation, so the setup must be regularly updated. The new construction we propose does not suffer these disadvantages.</p>

    <p class="text-gray-300">Pietrzak’s verifiable delay function. Independently from the present work, another efficient VDF was proposed in <em>[16]</em>. The author describes an elegant construction, provably secure under the classic time-lock assumption of <em>[18]</em> when implemented over an RSA group <span class="math">(\\mathbf{Z}/N\\mathbf{Z})^{\\times}</span> where <span class="math">N</span> is a product of two safe primes. The philosophy of <em>[16]</em> is close to our construction: it consists in solving the puzzle of <em>[18]</em> (for a timing parameter <span class="math">\\Delta</span>), and computing a proof of correctness. Their proofs can be computed with <span class="math">O(\\sqrt{\\Delta}\\log(\\Delta))</span> group multiplications. However, the proofs obtained are much longer (they consist of <span class="math">O(\\log(\\Delta))</span> group elements, versus a single group element in our construction), and the verification procedure is less efficient (it requires <span class="math">O(\\log(\\Delta))</span> group exponentiations, versus essentially two group exponentiations in our construction — for exponents of bit-length the security level <span class="math">k</span> in both cases).</p>

    <p class="text-gray-300">In the example given in <em>[18]</em>, the group <span class="math">G</span> is an RSA group for a 2048 bit modulus, and the time <span class="math">\\Delta</span> is set to <span class="math">2^{40}</span> sequential squarings in the group, so the proofs are <span class="math">10KB</span> long. In comparison, in the same setting, our proofs are <span class="math">0.25KB</span> long.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.3 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout this paper, the integer <span class="math">k</span> denotes a security level (typically <span class="math">128,192</span>, or <span class="math">256</span>), and the map <span class="math">H:\\{0,1\\}^{<em>}\\to\\{0,1\\}^{2k}</span> denotes a secure cryptographic hash function. For simplicity of exposition, the function <span class="math">H</span> is regarded as a map from <span class="math">\\mathcal{A}^{</em>}</span> to <span class="math">\\{0,1\\}^{2k}</span>, where <span class="math">\\mathcal{A}^{<em>}</span> is the set of strings over some alphabet <span class="math">\\mathcal{A}</span> such that <span class="math">\\{0,1\\}\\subset\\mathcal{A}</span>. The alphabet <span class="math">\\mathcal{A}</span> contains at least all nine digits and twenty-six letters, and a special character <span class="math">\\star</span>. Given two strings <span class="math">s_{1},s_{2}\\in\\mathcal{A}^{</em>}</span>, denote by $s_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{2}<span class="math"> their concatenation, and by </span>s_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{2}<span class="math"> their concatenation separated by </span>\\star<span class="math">. The function </span>\\texttt{int}:\\{0,1\\}^{<em>}\\to\\mathbf{Z}_{\\geq 0}<span class="math"> maps </span>x\\in\\{0,1\\}^{</em>}<span class="math"> in the canonical manner to the non-negative integer with binary representation </span>x<span class="math">. The function </span>\\texttt{bin}:\\mathbf{Z}_{\\geq 0}\\to\\{0,1\\}^{*}<span class="math"> maps any non-zero integer to its binary representation with no leading </span>0<span class="math">-characters, and </span>\\texttt{bin}(0)=0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-11" class="text-2xl font-bold">2 Trapdoor verifiable delay functions</h2>

    <p class="text-gray-300">Let <span class="math">\\Delta:\\mathbf{Z}_{&gt;0}\\to\\mathbf{R}_{&gt;0}</span> be a function of the (implicit) security parameter <span class="math">k</span>. This <span class="math">\\Delta</span> is meant to represent a time duration, and what is precisely meant by <em>time</em> is explained in Section 3 (essentially, it measures an amount of sequential work). A party, Alice, has a public key <span class="math">\\mathsf{pk}</span> and a secret key <span class="math">\\mathsf{sk}</span>. Let <span class="math">x</span> be a piece of data. Alice, thanks to her secret key <span class="math">\\mathsf{sk}</span>, is able to quickly evaluate a function <span class="math">\\mathsf{trapdoor}_{\\mathsf{sk}}</span> on <span class="math">x</span>. On the other hand, other parties knowing only <span class="math">\\mathsf{pk}</span> can compute <span class="math">\\mathsf{eval}_{\\mathsf{pk}}(x)</span> in time <span class="math">\\Delta</span>, but not faster (and important parallel computing power does not give a substantial advantage in going faster; remember that <span class="math">\\Delta</span> measures the sequential work), such that the resulting value <span class="math">\\mathsf{eval}_{\\mathsf{pk}}(x)</span> is the same as <span class="math">\\mathsf{trapdoor}_{\\mathsf{sk}}(x)</span>.</p>

    <p class="text-gray-300">More formally, a trapdoor VDF consists of the following components (very close to the classic VDF defined in <em>[4]</em>)</p>

    <p class="text-gray-300">keygen <span class="math">\\rightarrow</span> (pk, sk) is a key generation procedure, which outputs Alice’s public key pk and secret key sk. As usual, the public key should be publicly available, and the secret key is meant to be kept secret. trapdoor_{sk} <span class="math">(x,\\Delta)\\rightarrow(y,\\pi)</span> takes as input the data <span class="math">x\\in\\mathcal{X}</span> (for some input space <span class="math">\\mathcal{X}</span>), and uses the secret key sk to produce the output <span class="math">y</span> from <span class="math">x</span>, and a (possibly empty) proof <span class="math">\\pi</span>. The parameter <span class="math">\\Delta</span> is the amount of sequential work required to compute the same output <span class="math">y</span> without knowledge of the secret key. eval_{pk} <span class="math">(x,\\Delta)\\rightarrow(y,\\pi)</span> is a procedure to evaluate the function on <span class="math">x</span> using only the public key pk, for a targeted amount of sequential work <span class="math">\\Delta</span>. It produces the output <span class="math">y</span> from <span class="math">x</span>, and a (possibly empty) proof <span class="math">\\pi</span>. This procedure is meant to be infeasible in time less than <span class="math">\\Delta</span> (this will be expressed precisely in the security requirements). verify_{pk} <span class="math">(x,y,\\pi,\\Delta)\\rightarrow</span> true or false is a procedure to check if <span class="math">y</span> is indeed the correct output for <span class="math">x</span>, associated to the public key pk and the evaluation time <span class="math">\\Delta</span>, possibly with the help of the proof <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">Note that the security parameter <span class="math">k</span> is implicitly an input to each of these procedures. Given any key pair (pk, sk) generated by the keygen procedure, the functionality of the scheme is the following. Given any input <span class="math">x</span> and time parameter <span class="math">\\Delta</span>, let <span class="math">(y,\\pi)\\leftarrow</span> eval_{pk} <span class="math">(x,\\Delta)</span> and <span class="math">(y^{\\prime},\\pi^{\\prime})\\leftarrow</span> trapdoor_{sk} <span class="math">(x,\\Delta)</span>. Then, <span class="math">y=y^{\\prime}</span> and the procedures verify_{pk} <span class="math">(x,y,\\pi,\\Delta)</span> and verify_{pk} <span class="math">(x,y^{\\prime},\\pi^{\\prime},\\Delta)</span> both output true.</p>

    <p class="text-gray-300">We also require the protocol to be <em>sound</em>, as in <em>[4]</em>. Intuitively, we want that if <span class="math">y^{\\prime}</span> is not the correct output of eval_{pk} <span class="math">(x,\\Delta)</span> then verify_{pk} <span class="math">(x,y^{\\prime},\\Delta)</span> outputs false. We however allow the holder of the trapdoor to generate misleading values <span class="math">y^{\\prime}</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1 (Soundness)</h6>

    <p class="text-gray-300">A trapdoor VDF is <em>sound</em> if any polynomially bounded algorithm solves the following <em>soundness-breaking</em> game with negligible probability (in <span class="math">k</span>): given as input the public key pk, output a message <span class="math">x</span>, a value <span class="math">y^{\\prime}</span> and a proof <span class="math">\\pi^{\\prime}</span> such that <span class="math">y^{\\prime}\\neq</span> eval_{pk} <span class="math">(x,\\Delta)</span>, and verify_{pk} <span class="math">(x,y^{\\prime},\\pi^{\\prime},\\Delta)</span> = true.</p>

    <p class="text-gray-300">The second security property is that the correct output cannot be produced in time less than <span class="math">\\Delta</span> without knowledge of the secret key sk. This is formalised in the next section via the <span class="math">\\Delta</span>-evaluation race game. A trapdoor VDF is <span class="math">\\Delta</span>-sequential if any polynomially bounded adversary wins the <span class="math">\\Delta</span>-evaluation race game with negligible probability.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 Wall-clock time and computational assumptions</h2>

    <p class="text-gray-300">Primitives such as verifiable delay functions or time-lock puzzles wish to deal with the delicate notion of real-world time. This section discusses how to formally handle this concept, and how it translates in practice.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.1 Theoretical model</h3>

    <p class="text-gray-300">A precise notion of wall-clock time is difficult to capture formally. However, we can get a first approximation by choosing a model of computation, and defining</p>

    <p class="text-gray-300">time* as an amount of sequential work in this model. A model of computation is a set of allowable operations, together with their respective costs. For instance, working with circuits with gates <span class="math">\\vee</span>, <span class="math">\\wedge</span> and <span class="math">\\neg</span> which each have cost <span class="math">1</span>, the notion of time complexity of a circuit <span class="math">\\mathcal{C}</span> can be captured by its depth <span class="math">d(\\mathcal{C})</span>, i.e., the length of the longest path in <span class="math">\\mathcal{C}</span>. The time-complexity of a boolean function <span class="math">f</span> is then the minimal depth of a circuit implementing <span class="math">f</span>, but this does not reflect the time it might take to actually compute <span class="math">f</span> in the real world where one is not bound to using circuits. A random access machine might perform better, or maybe a quantum circuit.</p>

    <p class="text-gray-300">A good model of computation for analysing the actual time it takes to solve a problem should contain all the operations that one could use in practice (in particular the adversary). From now on, we suppose the adversary works in a model of computation <span class="math">\\mathcal{M}</span>. We do not define exactly <span class="math">\\mathcal{M}</span>, but only assume that it allows all operations a potential adversary could perform, and that it comes with a cost function <span class="math">c</span> and a time-cost function <span class="math">t</span>. For any algorithm <span class="math">\\mathcal{A}</span> and input <span class="math">x</span>, the cost <span class="math">C(\\mathcal{A},x)</span> measures the overall cost of computing <span class="math">\\mathcal{A}(x)</span> (i.e., the sum of the costs of all the elementary operations that are executed), while the time-cost <span class="math">T(\\mathcal{A},x)</span> abstracts the notion of time it takes to run <span class="math">\\mathcal{A}(x)</span> in the model <span class="math">\\mathcal{M}</span>. For the model of circuits, one could define the cost as the size of the circuit and the time-cost as its depth. For concreteness, one can think of the model <span class="math">\\mathcal{M}</span> as the model of parallel random-access machines.</p>

    <p class="text-gray-300">All forthcoming security claims are (implicitly) made with respect to the model <span class="math">\\mathcal{M}</span>. The time-lock assumption of Rivest, Shamir and Wagner <em>[18]</em> can be expressed as Assumption 1 below.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2</h6>

    <p class="text-gray-300"><span class="math">((\\delta,t)</span>-time-lock game). Let <span class="math">k\\in\\mathbf{Z}_{&gt;0}</span> be a difficulty parameter, and <span class="math">\\mathcal{A}</span> be an algorithm playing the game. The parameter <span class="math">t</span> is a positive integer, and <span class="math">\\delta:\\mathbf{Z}_{&gt;0}\\rightarrow\\mathbf{R}_{&gt;0}</span> is a function. The <span class="math">(\\delta,t)</span>-time-lock game goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An RSA modulus <span class="math">N</span> is generated at random by an RSA key-generation procedure, for the security parameter <span class="math">k</span>;</li>

      <li><span class="math">\\mathcal{A}(N)</span> outputs an algorithm <span class="math">\\mathcal{B}</span>;</li>

      <li>An element <span class="math">g\\in\\mathbf{Z}/N\\mathbf{Z}</span> is generated uniformly at random;</li>

      <li><span class="math">\\mathcal{B}(g)</span> outputs <span class="math">h\\in\\mathbf{Z}/N\\mathbf{Z}</span>.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">\\mathcal{A}</span> wins the game if <span class="math">h=g^{2^{t}}\\mod N</span> and <span class="math">T(\\mathcal{B},g)&lt;t\\delta(k)</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Assumption 1 (Time-lock assumption)</h6>

    <p class="text-gray-300">There is a cost function <span class="math">\\delta:\\mathbf{Z}_{&gt;0}\\rightarrow\\mathbf{R}_{&gt;0}</span> such that the following two statements hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There is an algorithm <span class="math">\\mathcal{S}</span> such that for any modulus <span class="math">N</span> generated by an RSA key-generation procedure with security parameter <span class="math">k</span>, and any element <span class="math">g\\in\\mathbf{Z}/N\\mathbf{Z}</span>, the output of <span class="math">\\mathcal{S}(N,g)</span> is the square of <span class="math">g</span>, and <span class="math">T(\\mathcal{S},(N,g))&lt;\\delta(k)</span>;</li>

      <li>For any <span class="math">t\\in\\mathbf{Z}_{&gt;0}</span>, no algorithm <span class="math">\\mathcal{A}</span> of polynomial cost wins the <span class="math">(\\delta,t)</span>-time-lock game with non-negligible probability (with respect to the difficulty parameter <span class="math">k</span>).</li>

    </ol>

    <p class="text-gray-300">2 i.e., C(\\mathcal{A},g) = O(f(\\mathrm{len}(g))) for a polynomial f , with \\mathrm{len}(g) the binary length of g .</p>

    <p class="text-gray-300">The function <span class="math">\\delta</span> encodes the time-cost of computing a single modular squaring, and Assumption 1 expresses that without knowledge of the factorisation of <span class="math">N</span>, there is no faster way to compute <span class="math">g^{2^{t}}\\mod N</span> than performing <span class="math">t</span> sequential squarings.</p>

    <p class="text-gray-300">With this formalism, we can finally express the security notion of a trapdoor VDF.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 3</h6>

    <p class="text-gray-300">(<span class="math">\\Delta</span>-evaluation race game). Let <span class="math">\\mathcal{A}</span> be a party playing the game. The parameter <span class="math">\\Delta:\\mathbf{Z}_{&gt;0}\\rightarrow\\mathbf{R}_{&gt;0}</span> is a function of the (implicit) security parameter <span class="math">k</span>. The <span class="math">\\Delta</span>-evaluation race game goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The random procedure keygen is run and it outputs a public key pk;</li>

      <li><span class="math">\\mathcal{A}(\\textsf{pk})</span> outputs an algorithm <span class="math">\\mathcal{B}</span>;</li>

      <li>Some data <span class="math">x\\in\\mathcal{X}</span> is generated according to some random distribution of min-entropy at least <span class="math">k</span>;</li>

      <li><span class="math">\\mathcal{B}^{\\mathcal{O}}(x)</span> outputs a value <span class="math">y</span>, where <span class="math">\\mathcal{O}</span> is an oracle that outputs the evaluation <span class="math">\\textsf{trapdoor}_{\\textsf{sk}}(x^{\\prime},\\Delta)</span> on any input <span class="math">x^{\\prime}\\neq x</span>.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">\\mathcal{A}</span> wins the game if <span class="math">T(\\mathcal{B},x)&lt;\\Delta</span> and <span class="math">\\textsf{eval}_{\\textsf{pk}}(x,\\Delta)</span> outputs <span class="math">y</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 4</h6>

    <p class="text-gray-300">(<span class="math">\\Delta</span>-sequential). A trapdoor VDF is <span class="math">\\Delta</span>-sequential if any polynomially bounded player (with respect to the implicit security parameter) wins the above <span class="math">\\Delta</span>-evaluation race game with negligible probability.</p>

    <p class="text-gray-300">Observe that it is useless to allow <span class="math">\\mathcal{A}</span> to adaptively ask for oracle evaluations of the VDF during the execution of <span class="math">\\mathcal{A}(\\textsf{pk})</span>: for any data <span class="math">x^{\\prime}</span>, the procedure <span class="math">\\textsf{eval}_{\\textsf{pk}}(x^{\\prime},\\Delta)</span> produces the same output as <span class="math">\\textsf{trapdoor}_{\\textsf{sk}}(x^{\\prime},\\Delta)</span>, so any such request can be computed by the adversary in time <span class="math">O(\\Delta)</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">Suppose that the input <span class="math">x</span> is hashed as <span class="math">H(x)</span> (by a secure cryptographic hash function) before being evaluated (as is the case in the construction we present in the next section), i.e.</p>

    <p class="text-gray-300"><span class="math">\\textsf{trapdoor}_{\\textsf{sk}}(x,\\Delta)=t_{\\textsf{sk}}(H(x),\\Delta),</span></p>

    <p class="text-gray-300">for some procedure <span class="math">t</span>, and similarly for eval and verify. Then, it becomes unnecessary to give to <span class="math">\\mathcal{B}</span> access to the oracle <span class="math">\\mathcal{O}</span>. We give a proof in Appendix A when <span class="math">H</span> is modeled as a random oracle.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Remark 2</h6>

    <p class="text-gray-300">At the third step of the game, the bound on the min-entropy is fixed to <span class="math">k</span>. The exact value of this bound is arbitrary, but forbidding low entropy is important: if <span class="math">x</span> has a good chance of falling in a small subset of <span class="math">\\mathcal{X}</span>, the adversary can simply precompute the VDF for all the elements of this subset.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.2 Timing assumptions in the real world</h3>

    <p class="text-gray-300">Given an algorithm, or even an implementation of this algorithm, its actual running time will depend on the hardware on which it is run. If the algorithm is</p>

    <p class="text-gray-300">executed independently on several single-core general purpose CPUs, the variations in running time between them will be reasonably small as overclocking records on clock-speeds barely achieve 9GHz (cf. <em>[10]</em>), only a small factor higher than a common personal computer. Assuming the computation is not parallelisable, using multiple CPUs would not allow to go faster. However, specialized hardware could be built to perform a certain computation much more efficiently than on any general purpose hardware.</p>

    <p class="text-gray-300">For these reasons, the theoretical model developed in Section 3.1 has a limited accuracy. To resolve this issue, and evaluate precisely the security of a timing assumption like Assumption 1, one must estimate the speed at which the current state of technology allows to perform a certain task, given a possibly astronomical budget. To this end, the Ethereum Foundation and Protocol Labs <em>[13]</em> are currently investigating extremely fast hardware implementations of RSA multiplication, and hope to construct a piece of hardware close enough to today’s technological limits, with the goal of using the present construction in their future platforms. Similarly, the Chia Network has opened a competition in the near future for very fast multiplication in the class group of a quadratic imaginary field.</p>

    <h2 id="sec-22" class="text-2xl font-bold">4 Construction of the verifiable delay function</h2>

    <p class="text-gray-300">Let <span class="math">x\\in\\mathcal{A}^{<em>}</span> be the input at which the VDF is to be evaluated. Alice’s secret key <span class="math">\\mathtt{sk}</span> is the order of a finite group <span class="math">G</span>, and her public key is a description of <span class="math">G</span> allowing to compute the group multiplication efficiently. We also assume that any element <span class="math">g</span> of <span class="math">G</span> can efficiently be represented in a canonical way as binary strings <span class="math">\\mathtt{bin}(g)</span>. Also part of Alice’s public key is a hash function <span class="math">H_{G}:\\mathcal{A}^{</em>}\\rightarrow G</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Example 1 (RSA setup)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A natural choice of setup is the following: the group <span class="math">G</span> is <span class="math">(\\mathbf{Z}/N\\mathbf{Z})^{\\times}</span> where <span class="math">N=pq</span> for a pair of distinct prime numbers <span class="math">p</span> and <span class="math">q</span>, where the secret key is <span class="math">(p-1)(q-1)</span> and the public key is <span class="math">N</span>, and the hash function $H_{G}(x)=\\mathtt{int}(H(\\text{\`\`residue''}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x))\\mod N<span class="math"> (where </span>H<span class="math"> is a secure cryptographic hash function). For a technical reason explained later in Remark 4, we actually need to work in </span>(\\mathbf{Z}/N\\mathbf{Z})^{\\times}/\\{\\pm 1\\}$, and we call this the RSA setup.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-24" class="text-base font-medium mt-4">Example 2 (Class group setup)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a public setup where we do not want the private key to be known by anyone, one could choose <span class="math">G</span> to be the class group of an imaginary quadratic field. The construction is simple. Choose a random, negative, square-free integer <span class="math">d</span>, of large absolute value, and such that <span class="math">d\\equiv 1\\mod 4</span>. Then, let <span class="math">G=\\mathrm{Cl}(d)</span> be the class group of the imaginary quadratic field <span class="math">\\mathbf{Q}(\\sqrt{d})</span>. Just as we wish, there is no known algorithm to efficiently compute the order of this group. The multiplication can be performed efficiently, and each class can be represented canonically by its reduced ideal. Note that the even part of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Cl}(d)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> can be computed if the factorisation of </span>d<span class="math"> is known. Therefore one should choose </span>d<span class="math"> to be a negative prime, which ensures that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Cl}(d)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is odd. See <em>[8]</em> for a review of the arithmetic in class groups of imaginary quadratic orders, and a discussion on the choice of cryptographic parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consider a targeted evaluation time given by <span class="math">\\Delta=t\\delta</span> for a timing parameter <span class="math">t</span>, where <span class="math">\\delta</span> is the time-cost (i.e., the amount of sequential work) of computing a single squaring in the group <span class="math">G</span> (as done in Assumption 1 for the RSA setup).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To evaluate the VDF on input <span class="math">x</span>, first let <span class="math">g=H_{G}(x)</span>. The basic idea (which finds its origins in <em>[18]</em>) is that for any <span class="math">t\\in\\mathbf{Z}_{&gt;0}</span>, Alice can efficiently compute <span class="math">g^{2^{t}}</span> with two exponentiations, by first computing $e=2^{t}\\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, followed by </span>g^{e}<span class="math">. The running time is logarithmic in </span>t<span class="math">. Any other party who does not know </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> can also compute </span>g^{2^{t}}<span class="math"> by performing </span>t<span class="math"> sequential squarings, with a running time </span>t\\delta<span class="math">. Therefore anyone can compute </span>y=g^{2^{t}}<span class="math"> but only Alice can do it fast, and any other party has to spend a time linear in </span>t<span class="math">. However, verifying that the published value </span>y<span class="math"> is indeed </span>g^{2^{t}}<span class="math"> is long: there is no shortcut to the obvious strategy consisting in recomputing </span>g^{2^{t}}<span class="math"> and checking if it matches. To solve this issue, we propose the following public-coin succinct argument, for proving that </span>y=g^{2^{t}}<span class="math">. The input of the interaction is </span>(G,g,y,t)<span class="math">. Let </span>\\mathrm{Primes}(2k)<span class="math"> denote the set containing the </span>2^{2k}$ first prime numbers.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples a prime <span class="math">\\ell</span> uniformly at random from <span class="math">\\mathrm{Primes}(2k)</span>.</li>

      <li>The prover computes <span class="math">\\pi=g^{\\lfloor 2^{t}/\\ell\\rfloor}</span> and sends it to the verifier.</li>

      <li>The verifier computes <span class="math">r=2^{t}\\mod\\ell</span>, (the least positive residue of <span class="math">2^{t}</span> modulo <span class="math">\\ell</span>), and accepts if <span class="math">g,y,\\pi\\in G</span> and <span class="math">\\pi^{\\ell}g^{r}=y</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, it might not be clear how Alice or a third party should compute <span class="math">\\pi=g^{\\lfloor 2^{t}/\\ell\\rfloor}</span>. For Alice, it is simple: she can compute <span class="math">r=2^{t}\\mod\\ell</span>. Then we have <span class="math">\\lfloor 2^{t}/\\ell\\rfloor=(2^{t}-r)/\\ell</span>, and since she knows the order of the group, she can compute $q=(2^{t}-r)/\\ell\\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\pi=g^{q}<span class="math">. We explain in Section 4.1 how anyone else can compute </span>\\pi<span class="math"> without knowing </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, with a total of </span>O(t/\\log(t))$ group multiplications.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This protocol is made non-interactive using the Fiat-Shamir transformation, by letting $\\ell=H_{\\mathtt{prime}}(\\mathtt{bin}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{bin}(y))<span class="math">, where </span>H_{\\mathtt{prime}}<span class="math"> is a hash function which sends any string </span>s<span class="math"> to an element of </span>\\mathrm{Primes}(2k)$. We assume in the security analysis below that this function is a uniformly distributed random oracle. The procedures trapdoor, verify and eval are fully described in Algorithms 1, 2 and 3 respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 3</h6>

    <p class="text-gray-300">Instead of hashing the input <span class="math">x</span> into the group <span class="math">G</span> as <span class="math">g=H_{G}(x)</span>, one could simply consider <span class="math">x\\in G</span>. However, the function <span class="math">x\\mapsto x^{2^{t}}</span> being a group homomorphism, bypassing the hashing step has undesirable consequences. For instance, given <span class="math">x^{2^{t}}</span>, one can compute <span class="math">(x^{\\alpha})^{2^{t}}</span> for any integer <span class="math">\\alpha</span> at the cost of only an exponentiation by <span class="math">\\alpha</span>.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Verification</h5>

    <p class="text-gray-300">It is straightforward to check that the verification condition <span class="math">\\pi^{\\ell}g^{r}=y</span> holds if the evaluator is honest. Now, what can a dishonest evaluator do? That question is answered formally in Section 6, but the intuitive idea is easy to understand. We will show that given <span class="math">x</span>, finding a pair <span class="math">(y,\\pi)</span> different from the honest one amounts to solve a root-finding problem in the underlying group <span class="math">G</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data: a public key <span class="math">\\mathsf{pk}=(G,H_{G})</span> and a secret key $\\mathsf{sk}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, some input </span>x\\in\\mathcal{A}^{*}<span class="math">, a targeted evaluation time </span>\\Delta=t\\delta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Result: the output <span class="math">y</span>, and the proof <span class="math">\\pi</span>.</p>

    <p class="text-gray-300"><span class="math">g\\leftarrow H_{G}(x)\\in G</span>;</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$e\\leftarrow 2^{t}\\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">y\\leftarrow g^{e}</span>;</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\ell\\leftarrow H_{\\mathsf{prime}}(\\mathsf{bin}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bin}(y))$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">r\\leftarrow</span> least residue of <span class="math">2^{t}</span> modulo <span class="math">\\ell</span>;</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$q\\leftarrow(2^{t}-r)\\ell^{-1}\\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\pi\\leftarrow g^{q}</span>;</p>

    <p class="text-gray-300">return <span class="math">(y,\\pi)</span>;</p>

    <p class="text-gray-300">Algorithm 1 <span class="math">\\mathsf{trapdoor}_{\\mathsf{sk}}(x,t)\\to(y,\\pi)</span></p>

    <p class="text-gray-300">(supposedly hard for anyone who does not know the secret order of the group). As a result, only Alice can produce misleading proofs.</p>

    <p class="text-gray-300">Consider the above interactive succinct argument, and suppose that the verifier accepts, i.e., <span class="math">\\pi^{\\ell}g^{r}=y</span>, where <span class="math">r</span> is the least residue of <span class="math">2^{t}</span> modulo <span class="math">\\ell</span>. Since <span class="math">r=2^{t}-\\ell\\lfloor 2^{t}/\\ell\\rfloor</span>, the verification condition is equivalent to</p>

    <p class="text-gray-300"><span class="math">yg^{-2^{t}}=\\left(\\pi g^{-\\lfloor 2^{t}/\\ell\\rfloor}\\right)^{\\ell}.</span></p>

    <p class="text-gray-300">Before the generation of <span class="math">\\ell</span>, the left-hand side <span class="math">\\alpha=yg^{-2^{t}}</span> is already determined. Once <span class="math">\\ell</span> is revealed, the evaluator is able to compute <span class="math">\\beta=\\pi g^{-\\lfloor 2^{t}/\\ell\\rfloor}</span>, which is an <span class="math">\\ell</span>-th root of <span class="math">\\alpha</span>. For a prover to succeed with good probability, he must be able to extract <span class="math">\\ell</span>-th roots of <span class="math">\\alpha</span> for arbitrary values of <span class="math">\\ell</span>. This is hard in our groups of interest, unless <span class="math">\\alpha=\\beta=1_{G}</span>, in which case <span class="math">(y,\\pi)</span> is the honest output.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">Observe that in the RSA setup, this task is easy if <span class="math">\\alpha=\\pm 1</span>, i.e. <span class="math">y=\\pm g^{2^{t}}</span>. It is however a difficult problem, given an RSA modulus <span class="math">N</span>, to find an element <span class="math">\\alpha\\mod N</span> other than <span class="math">\\pm 1</span> from which <span class="math">\\ell</span>-th roots can be extracted for any <span class="math">\\ell</span>. This explains why we need to work in the group <span class="math">G=(\\mathbf{Z}/N\\mathbf{Z})^{\\times}/\\{\\pm 1\\}</span> instead of <span class="math">(\\mathbf{Z}/N\\mathbf{Z})^{\\times}</span> in the RSA setup. This problem is formalized (and generalised to other groups) in Definition 6.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">4.1 Computing the proof <span class="math">\\pi</span> in <span class="math">O(t/\\log(t))</span> group operations</h3>

    <p class="text-gray-300">In this section, we describe how to compute the proof <span class="math">\\pi=g^{\\lfloor 2^{t}/\\ell\\rfloor}</span> with a total of <span class="math">O(t/\\log(t))</span> group multiplications. First, we mention a very simple algorithm to compute <span class="math">\\pi</span>, which simply computes the long division <span class="math">\\lfloor 2^{t}/\\ell\\rfloor</span> on the fly, as pointed out by Boneh, Bünz and Fisch <em>[5]</em>, but requires between <span class="math">t</span> and <span class="math">2t</span> group operations. It is given in Algorithm 4.</p>

    <p class="text-gray-300">We now describe how to perform the same computation with only <span class="math">O(t/\\log(t))</span> group operations. Fix a parameter <span class="math">\\kappa</span>. The idea is to express <span class="math">\\lfloor 2^{t}/\\ell\\rfloor</span> in base <span class="math">2^{\\kappa}</span> as</p>

    <p class="text-gray-300"><span class="math">\\lfloor 2^{t}/\\ell\\rfloor=\\sum_{i}b_{i}2^{\\kappa i}=\\sum_{b=0}^{2^{\\kappa}-1}b\\left(\\sum_{i\\ \\text{such that}\\ b_{i}=b}2^{\\kappa i}\\right).</span></p>

    <p class="text-gray-300">Data: a public key <span class="math">\\mathsf{pk}=(G,H_{G})</span>, some input <span class="math">x\\in\\mathcal{A}^{*}</span>, a targeted evaluation time <span class="math">\\Delta=t\\delta</span>, a VDF output <span class="math">y</span> and a proof <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">Result: true if <span class="math">y</span> is the correct evaluation of the VDF at <span class="math">x</span>, false otherwise.</p>

    <p class="text-gray-300"><span class="math">g\\leftarrow H_{G}(x)</span>;</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\ell\\leftarrow H_{\\mathsf{prime}}(\\mathsf{bin}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bin}(y))$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">r\\leftarrow</span> least residue of <span class="math">2^{t}</span> modulo <span class="math">\\ell</span>;</p>

    <p class="text-gray-300">if <span class="math">\\pi^{\\ell}g^{r}=y</span> then</p>

    <p class="text-gray-300">return true;</p>

    <p class="text-gray-300">else</p>

    <p class="text-gray-300">return false;</p>

    <p class="text-gray-300">end for</p>

    <p class="text-gray-300">Algorithm 2 verify<span class="math">{}_{\\mathsf{pk}}(x,y,\\pi,t)\\rightarrow\\text{true or false}</span></p>

    <p class="text-gray-300">Data: a public key <span class="math">\\mathsf{pk}=(G,H_{G})</span>, some input <span class="math">x\\in\\mathcal{A}^{*}</span>, a targeted evaluation time <span class="math">\\Delta=t\\delta</span>.</p>

    <p class="text-gray-300">Result: the output value <span class="math">y</span> and a proof <span class="math">\\pi</span>.</p>

    <p class="text-gray-300"><span class="math">g\\leftarrow H_{G}(x)\\in G</span>;</p>

    <p class="text-gray-300"><span class="math">y\\leftarrow g^{2^{t}}</span>; // via <span class="math">t</span> sequential squarings</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\ell\\leftarrow H_{\\mathsf{prime}}(\\mathsf{bin}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bin}(y))$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\pi\\leftarrow g^{\\lfloor 2^{t}/\\ell\\rfloor}</span>; // following the simple Algorithm 4, or the faster Algorithm 5</p>

    <p class="text-gray-300">return <span class="math">(y,\\pi)</span>;</p>

    <p class="text-gray-300">Algorithm 3 eval<span class="math">{}_{\\mathsf{pk}}(x,t)\\rightarrow(y,\\pi)</span></p>

    <p class="text-gray-300">Similarly to Algorithm 4, each coefficient <span class="math">b_{i}</span> can be computed as</p>

    <p class="text-gray-300"><span class="math">b_{i}=\\left\\lfloor\\frac{2^{\\kappa}(2^{t-\\kappa(i+1)}\\mod\\ell)}{\\ell}\\right\\rfloor,</span></p>

    <p class="text-gray-300">where <span class="math">2^{t-\\kappa(i+1)}</span> mod <span class="math">\\ell</span> denotes the least residue of <span class="math">2^{t-\\kappa(i+1)}</span> modulo <span class="math">\\ell</span>. For each <span class="math">\\kappa</span>-bits integer <span class="math">b\\in\\{0,\\ldots,2^{\\kappa}-1\\}</span>, let <span class="math">I_{b}=\\{i\\mid b_{i}=b\\}</span>. We get</p>

    <p class="text-gray-300"><span class="math">g^{\\lfloor 2^{t}/\\ell\\rfloor}=\\prod_{b=0}^{2^{\\kappa}-1}\\left(\\prod_{i\\in I_{b}}g^{2^{\\kappa i}}\\right)^{b}.</span> (1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose first that all the values <span class="math">g^{2^{\\kappa i}}</span> have been memorised (from the sequential computation of the value <span class="math">y=g^{2^{t}}</span>). Then, each product <span class="math">\\prod_{i\\in I_{b}}g^{2^{\\kappa i}}</span> can be computed in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> group multiplications (for a total of </span>\\sum_{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=t/\\kappa<span class="math"> multiplications), and the full product (1) can be deduced with about </span>\\kappa 2^{\\kappa}<span class="math"> additional group operations. In total, this strategy requires about </span>t/\\kappa+\\kappa 2^{\\kappa}<span class="math"> group operations. Choosing, for instance, </span>\\kappa=\\log(t)/2<span class="math">, we get about </span>t\\cdot 2/\\log(t)<span class="math"> group operations. Of course, this would require the storage of </span>t/\\kappa$ group elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now show that the memory requirement can easily be reduced to, for instance, <span class="math">O(\\sqrt{t})</span> group elements, for essentially the same speedup. Instead of memorising each <span class="math">\\kappa</span> element of the sequence <span class="math">g^{2^{t}}</span>, only memorise every <span class="math">\\kappa\\gamma</span> element</p>

    <p class="text-gray-300">Data: an element <span class="math">g</span> in a group <span class="math">G</span> (with identity <span class="math">1_G</span>), a prime number <span class="math">\\ell</span> and a positive integer <span class="math">t</span>.</p>

    <p class="text-gray-300">Result: <span class="math">g^{\\lfloor 2^t / \\ell \\rfloor}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} x \\leftarrow 1 _ {G} \\in G; \\\\ r \\leftarrow 1 \\in \\mathbf {Z}; \\\\ \\text{for } i \\leftarrow 0 \\text{ to } T - 1 \\text{ do} \\\\ \\quad b \\leftarrow \\lfloor 2 r / \\ell \\rfloor \\in \\{0, 1 \\} \\in \\mathbf {Z}; \\\\ \\quad r \\leftarrow \\text{least residue of } 2 r \\text{ modulo } \\ell; \\\\ \\quad x \\leftarrow x ^ {2} g ^ {b}; \\\\ \\text{end} \\\\ \\text{return } x; \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Algorithm 4: Simple algorithm to compute <span class="math">g^{\\lfloor 2^t / \\ell \\rfloor}</span>, with an on-the-fly long division [5].</p>

    <p class="text-gray-300">(i.e., the elements <span class="math">g^{2^0}, g^{2^{\\kappa \\gamma}}, g^{2^{2\\kappa \\gamma}}, \\ldots</span>), for some parameter <span class="math">\\gamma</span> (we will show that <span class="math">\\gamma = O(\\sqrt{t})</span> is sufficient). For each integer <span class="math">j</span>, let <span class="math">I_{b,j} = \\{i \\in I_b \\mid i \\equiv j \\mod \\gamma\\}</span>. Now,</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {\\lfloor 2 ^ {t} / \\ell \\rfloor} = \\prod_ {b = 0} ^ {2 ^ {\\kappa} - 1} \\left(\\prod_ {j = 0} ^ {\\gamma - 1} \\prod_ {i \\in I _ {b, j}} g ^ {2 ^ {\\kappa i}}\\right) ^ {b} = \\prod_ {j = 0} ^ {\\gamma - 1} \\left(\\prod_ {b = 0} ^ {2 ^ {\\kappa} - 1} \\left(\\prod_ {i \\in I _ {b, j}} g ^ {2 ^ {\\kappa (i - j)}}\\right) ^ {b}\\right) ^ {2 ^ {\\kappa j}}.</span></div>

    <p class="text-gray-300">In each factor of the final product, <span class="math">i - j</span> is divisible by <span class="math">\\gamma</span>, so <span class="math">g^{2^{\\kappa(i - j)}}</span> is one of the memorised values. A straightforward approach allows to compute this product with a total amount of group operations about <span class="math">t / \\kappa + \\gamma \\kappa 2^{\\kappa}</span>, yet one can still do better. Write <span class="math">y_{b,j} = \\prod_{i \\in I_{b,j}} g^{2^{\\kappa(i - j)}}</span>, and split <span class="math">\\kappa</span> into two halves, as <span class="math">\\kappa_1 = \\lfloor \\kappa / 2 \\rfloor</span> and <span class="math">\\kappa_0 = \\kappa - \\kappa_1</span>. Now, observe that for each index <span class="math">j</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {b = 0} ^ {2 ^ {\\kappa} - 1} y _ {b, j} ^ {b} = \\prod_ {b _ {1} = 0} ^ {2 ^ {\\kappa_ {1}} - 1} \\left(\\prod_ {b _ {0} = 0} ^ {2 ^ {\\kappa_ {0}} - 1} y _ {b _ {1} 2 ^ {\\kappa_ {0}} + b _ {0}, j}\\right) ^ {b _ {1} 2 ^ {\\kappa_ {0}}} \\cdot \\prod_ {b _ {0} = 0} ^ {2 ^ {\\kappa_ {0}} - 1} \\left(\\prod_ {b _ {1} = 0} ^ {2 ^ {\\kappa_ {1}} - 1} y _ {b _ {1} 2 ^ {\\kappa_ {0}} + b _ {0}, j}\\right) ^ {b _ {0}}</span></div>

    <p class="text-gray-300">The right-hand side provides a way to compute the product with a total of about <span class="math">2(2^{\\kappa} + \\kappa 2^{\\kappa /2})</span> (instead of <span class="math">\\kappa 2^{\\kappa}</span> as in the more obvious strategy). The full method is summarised in Algorithm 5 (on page 29), and requires about <span class="math">t / \\kappa +\\gamma 2^{\\kappa +1}</span> group multiplications.</p>

    <p class="text-gray-300">The algorithm requires the storage of about <span class="math">t / (\\kappa \\gamma) + 2^{\\kappa}</span> group elements. Choosing, for instance, <span class="math">\\kappa = \\log (t) / 3</span> and <span class="math">\\gamma = \\sqrt{t}</span>, we get about <span class="math">t\\cdot 3 / \\log (t)</span> group operations, with the storage of about <span class="math">\\sqrt{t}</span> group elements. This algorithm can also be parallelised.</p>

    <h2 id="sec-29" class="text-2xl font-bold">4.2 A practical bandwidth and storage improvement</h2>

    <p class="text-gray-300">Typically, an evaluator would compute the output <span class="math">y</span> and the proof <span class="math">\\pi</span>, and send the pair <span class="math">(y,\\pi)</span> to the verifiers. Each verifier would compute the Fiat-Shamir</p>

    <p class="text-gray-300">challenge</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\ell\\leftarrow H_{\\tt prime}(\\tt bin(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tt bin(y)),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then check <span class="math">y=\\pi^{\\ell}g^{2^{t}\\mod\\ell}</span>. Instead, it is possible for the evaluator to transmit <span class="math">(\\ell,\\pi)</span>, which has almost half the size (typically, <span class="math">\\ell</span> is in the order of hundreds of bits while group elements are in the order of thousands of bits). The verifiers would recover</p>

    <p class="text-gray-300"><span class="math">y\\leftarrow\\pi^{\\ell}g^{2^{t}\\mod\\ell},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and then verify that $\\ell=H_{\\tt prime}(\\tt bin(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tt bin(y))$. The two strategies are equivalent, but the second divides almost by 2 the bandwidth and storage footprint.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">4.3 A trade-off between proof shortness and prover efficiency</h3>

    <p class="text-gray-300">The evaluation of the VDF, i.e., the computation of <span class="math">y=g^{2^{t}}</span>, takes time <span class="math">T=\\delta t</span>, where <span class="math">\\delta</span> is the time of one squaring in the underlying group. As demonstrated in Section 4.1, the proof <span class="math">\\pi</span> can be computed in <span class="math">O(t/\\log(t))</span> group operations. Say that the total time of computing the proof is a fraction <span class="math">T/\\omega</span>; considering Algorithm 5, one can think of <span class="math">\\omega=20</span>, a reasonable value for practical parameters. One potential issue with the proposed VDF is that the computation of <span class="math">\\pi</span> can only start after the evaluation of the VDF output <span class="math">g^{2^{t}}</span> is completed. So after the completion of the VDF evaluation, there still remains a total amount <span class="math">T/\\omega</span> of work to compute the proof. We call <em>overhead</em> these computations that must be done after the evaluation of <span class="math">y=g^{2^{t}}</span>. Even though this part of the computation can be parallelised, it might be advantageous for some applications to reduce the overhead to a negligible amount of work.</p>

    <p class="text-gray-300">We show in the following that using only two parallel threads, the overhead can be reduces to a total cost of about <span class="math">T/\\omega^{n}</span>, at the cost of lengthening the proofs to <span class="math">n</span> group elements (instead of a single one), and <span class="math">n-1</span> small prime numbers. Note that the value of <span class="math">\\omega</span> varies with <span class="math">T</span>, yet for simplicity of exposition, we assume that it is constant in the following analysis (a reasonable approximation for practical purposes).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The idea is to start proving some intermediate results before the full evaluation is over. For instance, consider <span class="math">t_{1}=t\\frac{\\omega}{\\omega+1}</span>. Run the evaluator, and when the intermediate value <span class="math">g_{1}=g^{2^{t_{1}}}</span> is reached, store it (but keep the evaluator running in parallel), and compute the proof <span class="math">\\pi_{1}</span> for the statement <span class="math">g_{1}=g^{2^{t_{1}}}</span>. The computation of this proof takes time about <span class="math">\\delta t_{1}/\\omega=T/(\\omega+1)</span>, which is the time it takes to finish the full evaluation (i.e., going from <span class="math">g_{1}</span> to <span class="math">y=g^{2^{t}}=g_{1}^{2^{t/(\\omega+1)}}</span>). Therefore, the evaluation of <span class="math">y</span> and the first proof <span class="math">\\pi_{1}</span> finish at the same time. It only remains to produce a proof <span class="math">\\pi_{2}</span> for the statement <span class="math">y=g_{1}^{2^{t/(\\omega+1)}}</span>, which can be done in total time <span class="math">\\frac{\\delta t}{\\omega(\\omega+1)}\\leq T/\\omega^{2}</span>. Therefore the overhead is at most <span class="math">T/\\omega^{2}</span>. At first glance, it seems the verification requires the triple <span class="math">(g_{1},\\pi_{1},\\pi_{2})</span>, but in fact, the value <span class="math">g_{1}</span> can be recovered from <span class="math">\\pi_{1}</span> and the prime number $\\ell_{1}=H_{\\tt prime}(\\tt bin(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tt bin(g_{1}))<span class="math"> via </span>g_{1}=\\pi_{1}^{\\ell}g^{t_{1}\\mod\\ell}<span class="math">, as done is Section 4.2. Therefore, the proof can be compressed to </span>(\\ell_{1},\\pi_{1},\\pi_{2})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">More generally, one could split the computation into <span class="math">n</span> segments of length <span class="math">t_{i}=t\\omega^{n-i}\\frac{\\omega-1}{\\omega^{n}-1}</span>, for <span class="math">i=1,\\ldots,n</span>. We have that <span class="math">t=\\sum_{i=1}^{n}t_{i}</span>, and <span class="math">t_{i}=t_{i-1}/\\omega</span>, so during the evaluation of each segment (apart from the first), one can compute the proof corresponding to the previous segment. The overhead is only the proof of the last segment, which takes time <span class="math">T\\frac{\\omega-1}{\\omega(\\omega^{n}-1)}\\leq T/\\omega^{n}</span>. The proof consists of the <span class="math">n</span> intermediate proofs and the <span class="math">n-1</span> intermediate prime challenges.</p>

    <h2 id="sec-31" class="text-2xl font-bold">5 Analysis of the sequentiality</h2>

    <p class="text-gray-300">In this section, the proposed construction is proven to be <span class="math">(t\\delta)</span>-sequential, meaning that no polynomially bounded player can win the associated <span class="math">(t\\delta)</span>-evaluation race game with non-negligible probability (in other words, the VDF cannot be evaluated in time less than <span class="math">t\\delta</span>). For the RSA setup, it is proved under the classic time-lock assumption of Rivest, Shamir and Wagner <em>[18]</em> (formalised in Assumption 1), and more generally, it is secure for groups where a generalisation of this assumption holds (Assumption 2).</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">5.1 Generalised time-lock assumptions</h3>

    <p class="text-gray-300">The following game generalises the classic time-lock assumption to arbitrary families of groups of unknown orders.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 5 (Generalised <span class="math">(\\delta,t)</span>-time-lock game).</h6>

    <p class="text-gray-300">Consider a sequence <span class="math">(\\mathcal{G}_{k})_{k\\in\\mathbf{Z}_{&gt;0}}</span>, where each <span class="math">\\mathcal{G}_{k}</span> is a set of finite groups (supposedly of unknown orders), associated to a “difficulty parameter” <span class="math">k</span>. Let keygen be a procedure to generate a random group from <span class="math">\\mathcal{G}_{k}</span>, according to the difficulty <span class="math">k</span>.</p>

    <p class="text-gray-300">Fix the difficulty parameter <span class="math">k\\in\\mathbf{Z}_{&gt;0}</span>, and let <span class="math">\\mathcal{A}</span> be an algorithm playing the game. The parameter <span class="math">t</span> is a positive integer, and <span class="math">\\delta:\\mathbf{Z}_{&gt;0}\\to\\mathbf{R}_{&gt;0}</span> is a function. The <span class="math">(\\delta,t)</span>-time-lock game goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A group <span class="math">G</span> is generated by keygen;</li>

      <li><span class="math">\\mathcal{A}(G)</span> outputs an algorithm <span class="math">\\mathcal{B}</span>;</li>

      <li>An element <span class="math">g\\in G</span> is generated uniformly at random;</li>

      <li><span class="math">\\mathcal{B}(g)</span> outputs <span class="math">h\\in G</span>.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">\\mathcal{A}</span> wins the game if <span class="math">h=g^{2^{t}}</span> and <span class="math">T(\\mathcal{B},g)&lt;t\\delta(k)</span>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Assumption 2 (Generalised time-lock assumption)</h6>

    <p class="text-gray-300">The generalised time-lock assumption for a given family of groups <span class="math">(\\mathcal{G}_{k})_{k\\in\\mathbf{Z}_{&gt;0}}</span> is the following. There is a cost function <span class="math">\\delta:\\mathbf{Z}_{&gt;0}\\to\\mathbf{R}_{&gt;0}</span> such that the following two statements hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There is an algorithm <span class="math">\\mathcal{S}</span> such that for any group <span class="math">G\\in\\mathcal{G}_{k}</span> (for the difficulty parameter <span class="math">k</span>), and any element <span class="math">g\\in G</span>, the output of <span class="math">\\mathcal{S}(G,g)</span> is the square of <span class="math">g</span>, and <span class="math">T(\\mathcal{S},(G,g))&lt;\\delta(k)</span>;</li>

      <li>For any <span class="math">t\\in\\mathbf{Z}_{&gt;0}</span>, no algorithm <span class="math">\\mathcal{A}</span> of polynomial cost wins the <span class="math">(\\delta,t)</span>-time-lock game with non-negligible probability (with respect to the difficulty parameter <span class="math">k</span></li>

    </ol>

    <p class="text-gray-300">The function <span class="math">\\delta</span> encodes the time-cost of computing a single squaring in a group of <span class="math">\\mathcal{G}_k</span>, and Assumption 2 expresses that without more specific knowledge about these groups (such as their orders), there is no faster way to compute <span class="math">g^{2^t}</span> than performing <span class="math">t</span> sequential squarings.</p>

    <h2 id="sec-35" class="text-2xl font-bold">5.2 Sequentiality in the random oracle model</h2>

    <p class="text-gray-300"><strong>Proposition 1</strong> (tδ-sequentiality of the trapdoor VDF in the random oracle model). Let <span class="math">\\mathcal{A}</span> be a player winning with probability <span class="math">p_{\\mathrm{win}}</span> the (tδ)-evaluation race game associated to the proposed construction, assuming <span class="math">H_G</span> and <span class="math">H_{\\mathrm{prime}}</span> are random oracles and <span class="math">\\mathcal{A}</span> is limited to <span class="math">q</span> oracle queries³. Then, there is a player <span class="math">\\mathcal{C}</span> for the (generalised) <span class="math">(\\delta, t)</span>-time-lock game, with winning probability <span class="math">p \\geq (1 - q/2^k)p_{\\mathrm{win}}</span>, and with same running time as <span class="math">\\mathcal{A}</span> (up to a constant factor⁴).</p>

    <p class="text-gray-300"><strong>Proof.</strong> Build <span class="math">\\mathcal{C}</span> as follows. Upon receiving the group <span class="math">G</span>, <span class="math">\\mathcal{C}</span> starts running <span class="math">\\mathcal{A}</span> on input <span class="math">G</span>. The random oracles <span class="math">H_G</span> and <span class="math">H_{\\mathrm{prime}}</span> are simulated in a straightforward manner, maintaining a table of values, and generating a random outcome for any new request (with distribution uniform in <span class="math">G</span> and in <span class="math">\\mathrm{Primes}(2k)</span> respectively). When <span class="math">\\mathcal{A}(G)</span> outputs an algorithm <span class="math">\\mathcal{B}</span>, <span class="math">\\mathcal{C}</span> generates a random <span class="math">x \\in \\mathcal{X}</span> (according to the same distribution as the <span class="math">(t\\delta)</span>-evaluation race game). If <span class="math">x</span> has been queried by the oracle already, <span class="math">\\mathcal{C}</span> aborts; this happens with probability at most <span class="math">q/2^k</span>, since the min-entropy of the distribution of messages in the <span class="math">(t\\delta)</span>-evaluation race game is at least <span class="math">k</span>. Otherwise, <span class="math">\\mathcal{C}</span> outputs the following algorithm <span class="math">\\mathcal{B}&#x27;</span>. When receiving as input the challenge <span class="math">g</span>, <span class="math">\\mathcal{B}&#x27;</span> adds <span class="math">g</span> to the table of oracle <span class="math">H_G</span>, for the input <span class="math">x</span> (i.e., <span class="math">H_G(x) = g</span>). As discussed in Remark 1, we can assume that the algorithm <span class="math">\\mathcal{B}</span> does not call the oracle <span class="math">\\mathrm{trapdoor}_{\\mathrm{sk}}(-, y, \\Delta)</span>. Then <span class="math">\\mathcal{B}&#x27;</span> can invoke <span class="math">\\mathcal{B}</span> on input <span class="math">x</span> while simulating the oracles <span class="math">H_G</span> and <span class="math">H_{\\mathrm{prime}}</span>. Whenever <span class="math">\\mathcal{B}</span> outputs <span class="math">y</span>, <span class="math">\\mathcal{B}&#x27;</span> outputs <span class="math">y</span>, which equals <span class="math">g^{2^t}</span> whenever <span class="math">y</span> is the correct evaluation of the VDF at <span class="math">x</span>. We assume that simulating the oracle has a negligible cost, so <span class="math">\\mathcal{B}&#x27;(g)</span> has essentially the same time-cost as <span class="math">\\mathcal{B}(x)</span>. Then, <span class="math">\\mathcal{C}</span> wins the <span class="math">(\\delta, t)</span>-time-lock game with probability <span class="math">p \\geq p_{\\mathrm{win}}(1 - q/2^k)</span>.</p>

    <h2 id="sec-36" class="text-2xl font-bold">6 Analysis of the soundness</h2>

    <p class="text-gray-300">In this section, the proposed construction is proven to be sound, meaning that no polynomially bounded player can produce a misleading proof for an invalid output of the VDF. For the RSA setup, it is proved under a new number theoretic assumption expressing that it is hard to find an integer <span class="math">u \\neq 0, \\pm 1</span> for which <span class="math">\\ell</span>-th</p>

    <p class="text-gray-300">³ In this game, the output of <span class="math">\\mathcal{A}</span> is another algorithm <span class="math">\\mathcal{B}</span>. When we say that <span class="math">\\mathcal{A}</span> is limited to <span class="math">q</span> queries, we limit the total number of queries by <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{B}</span> combined. In other words, if <span class="math">\\mathcal{A}</span> did <span class="math">x \\leq q</span> queries, then its output <span class="math">\\mathcal{B}</span> is limited to <span class="math">q - x</span> queries.</p>

    <p class="text-gray-300">⁴ Note that this constant factor does not affect the chances of <span class="math">\\mathcal{C}</span> to win the <span class="math">(\\delta, t)</span>-time-lock game, since it concerns only the running time of <span class="math">\\mathcal{C}</span> itself and not of the algorithm output by <span class="math">\\mathcal{C}(G)</span></p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">roots modulo an RSA modulus <span class="math">N</span> can be extracted for arbitrary <span class="math">\\ell</span>-values sampled uniformly at random from <span class="math">\\mathrm{Primes}(2k)</span>, when the factorisation of <span class="math">N</span> is unknown. More generally, the construction is sound if a generalisation of this assumptions holds in the group of interest.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">6.1 The root finding problem</h3>

    <p class="text-gray-300">The following game formalises the root finding problem.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 6 (The root finding game <span class="math">\\mathcal{G}^{\\mathsf{root}}</span>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be a party playing the game. The <em>root finding game</em> <span class="math">\\mathcal{G}^{\\mathsf{root}}(\\mathcal{A})</span> goes as follows: first, the <em>keygen</em> procedure is run, resulting in a group <span class="math">G</span> which is given to <span class="math">\\mathcal{A}</span> (<span class="math">G</span> is supposedly of unknown order). The player <span class="math">\\mathcal{A}</span> then outputs an element <span class="math">u</span> of <span class="math">G</span>. An integer <span class="math">\\ell</span> is sampled uniformly from <span class="math">\\mathrm{Primes}(2k)</span> and given to <span class="math">\\mathcal{A}</span>. The player <span class="math">\\mathcal{A}</span> outputs an integer <span class="math">v</span> and wins the game if <span class="math">v^{\\ell}=u\\neq 1_{G}</span>.</p>

    <p class="text-gray-300">In the RSA setup, the group <span class="math">G</span> is the quotient <span class="math">(\\mathbf{Z}/N\\mathbf{Z})^{\\times}/\\{\\pm 1\\}</span>, where <span class="math">N</span> is a product of two random large prime numbers. It is not known if this problem can easily be reduced to a standard assumption such as the difficulty of factoring <span class="math">N</span> or the RSA problem, for which the best known algorithms have complexity <span class="math">L_{N}(1/3)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, in the class group setting, this problem is not known to reduce to a standard assumption, but it is closely related to the order problem and the root problem (which are tightly related to each other, see <em>[3, Theorem 3]</em>), for which the best known algorithms have complexity $L_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(1/2)<span class="math"> where </span>d$ is the discriminant.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now prove that to win this game <span class="math">\\mathcal{G}^{\\mathsf{root}}</span>, it is sufficient to win the following game <span class="math">\\mathcal{G}^{\\mathsf{root}}_{X}</span>, which is more convenient for our analysis.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 7 (The oracle root finding game <span class="math">\\mathcal{G}^{\\mathsf{root}}_{X}</span>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be a party playing the game. Let <span class="math">X</span> be a function that takes as input a group <span class="math">G</span> and a string <span class="math">s</span> in <span class="math">\\mathcal{A}^{<em>}</span>, and outputs an element <span class="math">X(G,s)\\in G</span>. Let <span class="math">\\mathcal{O}:\\mathcal{A}^{</em>}\\to\\mathrm{Primes}(2k)</span> be a random oracle with the uniform distribution. The player has access to the random oracle <span class="math">\\mathcal{O}</span>. The <em>oracle root finding game</em> <span class="math">\\mathcal{G}^{\\mathsf{root}}_{X}(\\mathcal{A},\\mathcal{O})</span> goes as follows: first, the <em>keygen</em> procedure is run and the resulting group <span class="math">G</span> is given to <span class="math">\\mathcal{A}</span>. The player <span class="math">\\mathcal{A}</span> then outputs a string <span class="math">s\\in\\mathcal{A}^{*}</span>, and an element <span class="math">v</span> of <span class="math">G</span>. The game is won if <span class="math">v^{\\mathcal{O}(s)}=X(G,s)\\neq 1_{G}</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">If there is a function <span class="math">X</span> and an algorithm <span class="math">\\mathcal{A}</span> limited to <span class="math">q</span> queries to the oracle <span class="math">\\mathcal{O}</span> winning the game <span class="math">\\mathcal{G}^{\\mathsf{root}}_{X}(\\mathcal{A},\\mathcal{O})</span> with probability <span class="math">p_{\\mathsf{win}}</span>, there is an algorithm <span class="math">\\mathcal{B}</span> winning the game <span class="math">\\mathcal{G}^{\\mathsf{root}}(\\mathcal{B})</span> with probability at least <span class="math">p_{\\mathsf{win}}/(q+1)</span>, and same running time, up to a small constant factor.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an algorithm limited to <span class="math">q</span> oracle queries, and winning the game with probability <span class="math">p_{\\mathsf{win}}</span>. Build an algorithm <span class="math">\\mathcal{A}^{\\prime}</span> which does exactly the same thing as <span class="math">\\mathcal{A}</span>, but with possibly additional oracle queries at the end to make sure the output string <span class="math">s^{\\prime}</span> is always queried to the oracle, and the algorithm always does exactly <span class="math">q+1</span> (distinct) oracle queries.</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">Build an algorithm <span class="math">\\mathcal{B}</span> playing the game <span class="math">\\mathcal{G}^{\\mathrm{root}}</span>, using <span class="math">\\mathcal{A}&#x27;</span> as follows. Upon receiving <span class="math">\\mathsf{pk} = G</span>, <span class="math">\\mathcal{B}</span> starts running <span class="math">\\mathcal{A}&#x27;</span> on input <span class="math">\\mathsf{pk}</span>. The oracle <span class="math">\\mathcal{O}</span> is simulated as follows. First, an integer <span class="math">i \\in \\{1, 2, \\dots, q + 1\\}</span> is chosen uniformly at random. For the first <span class="math">i - 1</span> (distinct) queries from <span class="math">\\mathcal{A}&#x27;</span> to <span class="math">\\mathcal{O}</span>, the oracle value is chosen uniformly at random from <span class="math">\\mathrm{Primes}(2k)</span>. When the <span class="math">i</span>th string <span class="math">s \\in \\mathcal{A}^<em></span> is queried to the oracle, the algorithm <span class="math">\\mathcal{B}</span> outputs <span class="math">u = X(G, s)</span>, concluding the first round of the game <span class="math">\\mathcal{G}^{\\mathrm{root}}</span>. The game continues as the integer <span class="math">\\ell</span> is received (uniform in <span class="math">\\mathrm{Primes}(2k)</span>). This <span class="math">\\ell</span> is then used as the value for the <span class="math">i</span>th oracle query <span class="math">\\mathcal{O}(s)</span>, and the algorithm <span class="math">\\mathcal{A}&#x27;</span> can continue running. The subsequent oracle queries are handled like the first <span class="math">i - 1</span> queries, by picking random primes in <span class="math">\\mathrm{Primes}(2k)</span>. Finally, <span class="math">\\mathcal{A}&#x27;</span> outputs a string <span class="math">s&#x27; \\in \\mathcal{A}^</em></span> and an element <span class="math">v</span> of <span class="math">G</span>. To conclude the game <span class="math">\\mathcal{G}^{\\mathrm{root}}(\\mathcal{B})</span>, <span class="math">\\mathcal{B}</span> returns <span class="math">v</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{O}</span> simulates a random oracle with uniform outputs in <span class="math">\\mathrm{Primes}(2k)</span>, <span class="math">\\mathcal{A}&#x27;</span> outputs with probability <span class="math">p_{\\mathrm{win}}</span> a pair <span class="math">(s&#x27;, v)</span> such that <span class="math">v^{\\mathcal{O}(s&#x27;)} = X(G, s&#x27;) \\neq 1_G</span>; denote this event <span class="math">\\mathsf{win}_{\\mathcal{A}&#x27;}</span>. If <span class="math">s = s&#x27;</span>, this condition is exactly <span class="math">v^\\ell = u \\neq 1_G</span>, where <span class="math">u = X(G, s)</span> is the output for the first round of <span class="math">\\mathcal{G}^{\\mathrm{root}}</span>, and <span class="math">\\mathcal{O}(s) = \\ell</span> is the input for the second round. If these conditions are met, the game <span class="math">\\mathcal{G}^{\\mathrm{root}}(\\mathcal{B})</span> is won. Therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {B} \\text{ wins } \\mathcal {G} ^ {\\text {root}} \\right] \\geq p _ {\\text {win}} \\cdot \\Pr \\left[ s = s ^ {\\prime} \\mid \\operatorname {win} _ {\\mathcal {A} ^ {\\prime}} \\right].</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathcal{Q} = \\{s_1, s_2, \\dots, s_{q+1}\\}</span> be the <span class="math">q+1</span> (distinct) strings queried to <span class="math">\\mathcal{O}</span> by <span class="math">\\mathcal{A}&#x27;</span>, indexed in chronological order. By construction, we have <span class="math">s = s_i</span>. Let <span class="math">j</span> be such that <span class="math">s&#x27; = s_j</span> (recall that <span class="math">\\mathcal{A}&#x27;</span> makes sure that <span class="math">s&#x27; \\in \\mathcal{Q}</span>). Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ s = s ^ {\\prime} \\mid \\operatorname {win} _ {\\mathcal {A} ^ {\\prime}} \\right] = \\Pr \\left[ i = j \\mid \\operatorname {win} _ {\\mathcal {A} ^ {\\prime}} \\right]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The integer <span class="math">i</span> is chosen uniformly at random in <span class="math">\\{1,2,\\dots,q + 1\\}</span>, and the values given to <span class="math">\\mathcal{A}&#x27;</span> are independent from <span class="math">i</span> (the oracle values are all independent random variables). So $\\operatorname*{Pr}\\left[i = j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{win}_{\\mathcal{A}'}\\right] = 1 / (q + 1)<span class="math">. Therefore </span>\\operatorname*{Pr}[\\mathcal{B}<span class="math"> wins </span>\\mathcal{G}^{\\mathrm{root}}] \\geq p_{\\mathrm{win}} / (q + 1)<span class="math">. Since </span>\\mathcal{B}<span class="math"> mostly consists in running </span>\\mathcal{A}$ and simulating the random oracle, it is clear that both have the same running time, up to a small constant factor.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-42" class="text-2xl font-bold">6.2 Soundness in the random oracle model</h2>

    <p class="text-gray-300"><strong>Proposition 2 (Soundness of the trapdoor VDF in the random oracle model).</strong> Let <span class="math">\\mathcal{A}</span> be a player winning with probability <span class="math">p_{\\mathrm{win}}</span> the soundness-breaking game associated to the proposed scheme, assuming <span class="math">H_{G}</span> and <span class="math">H_{\\mathrm{prime}}</span> are random oracles and <span class="math">\\mathcal{A}</span> is limited to <span class="math">q</span> oracle queries. Then, there is a player <span class="math">\\mathcal{D}</span> for the root finding game <span class="math">\\mathcal{G}^{\\mathrm{root}}</span> with winning probability <span class="math">p \\geq p_{\\mathrm{win}} / (q + 1)</span>, and with same running time as <span class="math">\\mathcal{A}</span> (up to a constant factor).</p>

    <p class="text-gray-300"><strong>Proof.</strong> Instead of directly building <span class="math">\\mathcal{D}</span>, we build an algorithm <span class="math">\\mathcal{D}&#x27;</span> playing the game <span class="math">\\mathcal{G}_X^{\\mathrm{root}}(\\mathcal{D}&#x27;,\\mathcal{O})</span>, and invoke Lemma 1. Define the function <span class="math">X</span> as follows. Recall that</p>

    <p class="text-gray-300">for any group <span class="math">G</span> that we consider in the construction, each element <span class="math">g \\in G</span> admits a canonical binary representation <span class="math">\\mathsf{bin}(g)</span>. For any such group <span class="math">G</span>, any elements <span class="math">g, h \\in G</span>, let</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X(G, \\mathsf{bin}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bin}(h)) = h / g^{2^t},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and let <span class="math">X(G, s) = 1_G</span> for any other string <span class="math">s</span>. When receiving <span class="math">\\mathsf{pk}</span>, <span class="math">\\mathcal{D}&#x27;</span> starts running <span class="math">\\mathcal{A}</span> with input <span class="math">\\mathsf{pk}</span>. The oracle <span class="math">H_G</span> is simulated by generating random values in the straightforward way, and <span class="math">H_{\\text{prime}}</span> is set to be exactly the oracle <span class="math">\\mathcal{O}</span>. The algorithm <span class="math">\\mathcal{A}</span> outputs a message <span class="math">x</span>, and pair <span class="math">(y, \\pi) \\in G \\times G</span> (if it is not of this form, abort). Output $s = \\mathsf{bin}(H_G(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bin}(y)<span class="math"> and </span>v = \\pi / H_G(x)^{\\lfloor 2^t / \\mathcal{O}(s) \\rfloor}<span class="math">. If </span>\\mathcal{A}<span class="math"> won the simulated soundness-breaking game, the procedure did not abort, and </span>v^{\\mathcal{O}(s)} = X(G, s) \\neq 1_G<span class="math">, so </span>\\mathcal{D}'<span class="math"> wins the game. Hence </span>\\mathcal{D}'<span class="math"> has winning probability </span>p_{\\text{win}}<span class="math">. Since </span>\\mathcal{A}<span class="math"> was limited to </span>q<span class="math"> oracle queries, </span>\\mathcal{D}'<span class="math"> also does not do more than </span>q<span class="math"> queries. Applying Lemma 1, there is an algorithm </span>\\mathcal{D}<span class="math"> winning the game </span>\\mathcal{G}^{\\text{root}}(\\mathcal{B})<span class="math"> with probability </span>p \\geq p_{\\text{win}}(1 - \\varepsilon) / (q + 1)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 5. The construction remains sound if instead of considering the output <span class="math">y</span> and the proof <span class="math">\\pi</span>, we consider the output to be the pair <span class="math">(y, \\pi)</span>, with an empty proof. The winning probability of <span class="math">\\mathcal{D}</span> in Proposition 2 becomes <span class="math">p \\geq p_{\\mathrm{win}}(1 - \\varepsilon) / (q + 1)</span>, where $\\varepsilon = \\mathrm{negl}\\left(\\frac{k}{\\log\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\log(q)}\\right)<span class="math">, by accounting for the unlikely event that the large random prime </span>\\mathcal{O}(s)<span class="math"> is a divisor of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-43" class="text-2xl font-bold">7 Aggregating and watermarking proofs</h2>

    <p class="text-gray-300">In this section, we present two useful properties of the VDF: the proofs can be aggregated, and watermarked. The methods of this section follow from discussions at the August 2018 workshop at Stanford hosted by the Ethereum Foundation and the Stanford Center for Blockchain Research. The author wishes to thank the participants for their contribution.</p>

    <h2 id="sec-44" class="text-2xl font-bold">7.1 Aggregation</h2>

    <p class="text-gray-300">If the VDF is evaluated at multiple inputs, it is possible to produce a single proof <span class="math">\\widetilde{\\pi} \\in G</span> that simultaneously proves the validity of all the outputs. Suppose that <span class="math">n</span> inputs are given, <span class="math">x_1, \\ldots, x_n</span>. For each index <span class="math">i</span>, let <span class="math">g_i = H_G(x_i)</span>. The following public-coin interactive succinct argument allows to prove that a given list <span class="math">(y_i)_{i=1}^n</span> satisfies <span class="math">y_i = g_i^{2^t}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples a prime <span class="math">\\ell</span> uniformly at random from <span class="math">\\operatorname{Primes}(2k)</span>, and <span class="math">n</span> uniformly random integers <span class="math">(\\alpha_i)_{i=1}^n</span> of <span class="math">k</span> bits.</li>

      <li>The prover computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\pi} = \\left(\\prod_{i=1}^{n} g_i^{\\alpha_i}\\right)^{\\lfloor 2^t / \\ell \\rfloor}</span></div>

    <p class="text-gray-300">and sends it to the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier computes <span class="math">r = 2^t \\mod \\ell</span>, (the least positive residue of <span class="math">2^t</span> modulo <span class="math">\\ell</span>), and accepts if</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\pi}^{\\ell} \\left(\\prod_{i=1}^{n} g_i^{\\alpha_i}\\right)^r = \\prod_{i=1}^{n} y_i^{\\alpha_i}.</span></div>

    <p class="text-gray-300">The single group element <span class="math">\\widetilde{\\pi}</span> serves as proof for the whole list of <span class="math">n</span> statements <span class="math">y_i = g_i^{2^t}</span>: it is an aggregated proof. The protocol can be made non-interactive by a Fiat-Shamir transformation: let</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s = \\operatorname{bin}(g_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{bin}(g_2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{bin}(g_n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{bin}(y_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{bin}(y_2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{bin}(y_n),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and let <span class="math">\\ell = H_{\\mathrm{prime}}(s)</span>, and for each index <span class="math">i</span>, let $\\alpha_i = \\mathrm{int}(H(\\mathrm{bin}(i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s))<span class="math"> (where </span>H$ is a secure cryptographic hash function). For simplicity, we prove the soundness in the interactive setup (the non-interactive soundness then follows from the Fiat-Shamir heuristic).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 6.</strong> One could harmlessly fix <span class="math">\\alpha_1 = 1</span>, leaving only <span class="math">\\alpha_i</span> to be chosen at random for <span class="math">i &amp;gt; 1</span>. We present the protocol as above for simplicity, to avoid dealing with <span class="math">i = 1</span> as a special case in the proof below.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> If there is a malicious prover <span class="math">\\mathcal{P}</span> breaking the soundness of the above interactive succinct argument with probability <span class="math">p</span>, then there is a player <span class="math">\\mathcal{B}</span> winning the root finding game <span class="math">\\mathcal{G}^{\\mathrm{root}}</span> with probability at least <span class="math">(p^2 - 2^{-k}) / 3</span>, with essentially the same running time as <span class="math">\\mathcal{P}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathcal{I} = \\{0,1,\\ldots,2^k - 1\\}</span>, and let <span class="math">\\mathcal{Z} = \\mathcal{I}^{n-1} \\times \\mathrm{Primes}(2k)</span>. Let <span class="math">Z = (\\alpha_2, \\ldots, \\alpha_n, \\ell)</span> be a uniformly distributed random variable in <span class="math">\\mathcal{Z}</span>, and let <span class="math">\\alpha_1</span> and <span class="math">\\alpha_1&#x27;</span> be two independent, uniformly distributed random variables in <span class="math">\\mathcal{I}</span>. Let <span class="math">\\mathsf{win}</span> and <span class="math">\\mathsf{win}&#x27;</span> be the events that <span class="math">\\mathcal{P}</span> breaks soundness when given <span class="math">(\\alpha_1, \\alpha_2, \\ldots, \\alpha_n, \\ell)</span> and <span class="math">(\\alpha_1&#x27;, \\alpha_2, \\ldots, \\alpha_n, \\ell)</span> respectively. We wish to estimate the probability of the event double_win = win ∧ win' ∧ (α1 ≠ α1'). Observe that conditioning over <span class="math">Z = z</span> for an arbitrary, fixed <span class="math">z \\in \\mathcal{Z}</span>, the events win and win' are independent and have same probability, so</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\text{win} \\wedge \\text{win}'] = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{z \\in \\mathcal{Z}} \\Pr[\\text{win} \\wedge \\text{win}' \\mid Z = z] = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{z \\in \\mathcal{Z}} \\Pr[\\text{win} \\mid Z = z]^2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">From the Cauchy-Schwarz inequality, we get</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{z \\in \\mathcal{Z}} \\Pr[\\text{win} \\mid Z = z]^2 \\geq \\left( \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{z \\in \\mathcal{Z}} \\Pr[\\text{win} \\mid Z = z] \\right)^2 = \\Pr[\\text{win}]^2 = p^2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We conclude that <span class="math">\\operatorname<em>{Pr}[\\text{win} \\wedge \\text{win}&#x27;] \\geq p^2</span>, and therefore, <span class="math">\\operatorname</em>{Pr}[\\text{double\\_win}] \\geq p^2 - 2^{-k}</span>.</p>

    <p class="text-gray-300">With these probabilities at hand, we can now construct the player <span class="math">\\mathcal{B}</span> for the root finding game <span class="math">\\mathcal{G}^{\\mathrm{root}}</span>. Run <span class="math">\\mathcal{P}</span>, which outputs values <span class="math">g_i</span> and <span class="math">y_i</span>. If <span class="math">y_i = g_i^{2^t}</span></p>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">for all <span class="math">i</span>, abort. Up to some reindexing, we can now assume <span class="math">y_{1}\\neq g_{1}^{2^{t}}</span>. Draw <span class="math">\\alpha_{1},\\alpha_{1}^{\\prime},\\alpha_{2},\\ldots,\\alpha_{n}</span> uniformly at random from <span class="math">\\mathcal{I}</span>. Define</p>

    <p class="text-gray-300"><span class="math">x_{0}=y_{1}/g_{1}^{2^{t}},\\ x_{1}=\\prod_{i=1}^{n}(y_{i}^{\\alpha_{i}}/g_{i}^{2^{i}})^{\\alpha_{i}},\\ x_{2}=(y_{1}/g_{1}^{2^{t}})^{\\alpha_{1}^{\\prime}}\\prod_{i=2}^{n}(y_{i}^{\\alpha_{i}}/g_{i}^{2^{t}})^{\\alpha_{i}}.</span></p>

    <p class="text-gray-300">Let <span class="math">b</span> be a uniformly random element of <span class="math">\\{0,1,2\\}</span>. The algorithm <span class="math">\\mathcal{B}</span> outputs <span class="math">x_{b}</span>. We get back a challenge <span class="math">\\ell</span>. Run the prover <span class="math">\\mathcal{P}</span> twice, independently, for the challenges <span class="math">(\\alpha_{1},\\alpha_{2},\\ldots,\\alpha_{n},\\ell)</span> and <span class="math">(\\alpha_{1}^{\\prime},\\alpha_{2},\\ldots,\\alpha_{n},\\ell)</span>, and suppose that both responses break soundness, and <span class="math">\\alpha_{1}\\neq\\alpha_{1}^{\\prime}</span> (i.e., the event double_win occurs). If <span class="math">x_{1}\\neq 1_{G}</span> or <span class="math">x_{2}\\neq 1_{G}</span>, the winning responses from <span class="math">\\mathcal{P}</span> allow to extract an <span class="math">\\ell</span>-th root of either <span class="math">x_{1}</span> or <span class="math">x_{2}</span> respectively. Otherwise, we have <span class="math">x_{1}=x_{2}</span>, which implies that <span class="math">x_{0}^{\\alpha_{1}-\\alpha_{1}^{\\prime}}=1_{G}</span>, so <span class="math">x_{0}</span> is an element of order dividing <span class="math">\\alpha_{1}-\\alpha_{1}^{\\prime}</span>, and one can easily extract any <span class="math">\\ell</span>-th root of <span class="math">x_{0}</span>. In conclusion, under the event double_win, one can always extract an <span class="math">\\ell</span>-th root of either <span class="math">x_{0}</span>, <span class="math">x_{1}</span> or <span class="math">x_{2}</span>, so the total winning probability of algorithm <span class="math">\\mathcal{B}</span> is at least <span class="math">(p^{2}-2^{-k})/3</span>. ∎</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">7.2 Watermarking</h3>

    <p class="text-gray-300">When using a VDF to build a decentralised randomness beacon (e.g., as a backbone for an energy-efficient blockchain design), people who spent time and energy evaluating the VDF should be rewarded for their effort. Since the output of the VDF is supposed to be unique, it is hard to reliably identify the person who computed it. A naive attempt of the evaluator to sign the output would not prevent theft: since the output is public, a dishonest party could as easily sign it and claim it their own.</p>

    <p class="text-gray-300">Let the evaluator’s identity be given as a string id. One proposed method (see <em>[12]</em>) essentially consists in computing the VDF twice: once on the actual input, and once on a combination of the input with the evaluator’s identity id. Implemented carefully, this method could allow to reliably reward the evaluators for their work, but it also doubles the required effort. In the following, we sketch two cost-effective solutions to this problem.</p>

    <p class="text-gray-300">The first cost-effective approach consists in having the evaluator prove that he knows some hard-to-recover intermediate value of the computation of the VDF. Since the evaluation of our proposed construction requires computing in sequence the elements <span class="math">g_{i}=g^{2^{i}}</span> for <span class="math">i=1,\\ldots,t</span>, and only the final value <span class="math">y=g_{t}</span> of the sequence is supposed to be revealed, one can prove that they performed the computation by proving that they know <span class="math">g_{t-1}</span> (it is a square root of <span class="math">y</span>, hence the fastest way for someone else to recover it would be to recompute the full sequence). A simple way to do so would be for the evaluator to reveal the value <span class="math">c_{\\textsf{id}}=g_{t-1}^{p_{\\textsf{id}}}</span> (a <em>certificate</em>), where <span class="math">p_{\\textsf{id}}=H_{\\texttt{prime}}(\\texttt{id})</span>. The validity of the certificate can be checked via the equation <span class="math">y^{p_{\\textsf{id}}}=c_{\\textsf{id}}^{2}</span>. The security claim is the following: given the input <span class="math">x</span>, the output <span class="math">y</span>, the proof <span class="math">\\pi</span>, and the certificate <span class="math">c_{\\textsf{id}}</span>, the cost for an adversary with identifier <span class="math">\\texttt{id}^{\\prime}</span> (distinct from <span class="math">\\texttt{id}</span>) to produce a valid certif</p>

    <p class="text-gray-300"><span class="math">c_{\\mathsf{id}^{\\prime}}</span> is as large as actually recomputing the output of the VDF by themself.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above method is cost-effective as it does not require the evaluator to perform much more work than evaluating the VDF. However, it makes the output longer by adding an extra group element: the certificate. Another approach consists in producing a single group element that plays simultaneously the role of the proof and the certificate. This element is a <em>watermarked proof</em>, tied to the evaluator’s identity. This can be done easily with our construction. In the evaluation procedure (Algorithm 3), replace the definition of the prime <span class="math">\\ell</span> by $H_{\\mathsf{prime}}(\\mathsf{id}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bin}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bin}(y))<span class="math"> (and the corresponding change must be made in the verification procedure). The resulting proof </span>\\pi_{\\mathsf{id}}<span class="math"> is now inextricably tied to </span>\\mathsf{id}<span class="math">. Informally, the security claim is the following: given the input </span>x<span class="math">, the output </span>y<span class="math">, and the watermarked proof </span>\\pi_{\\mathsf{id}}<span class="math">, the cost for an adversary with identifier </span>\\mathsf{id}^{\\prime}<span class="math"> (distinct from </span>\\mathsf{id}<span class="math">) to produce a valid proof </span>\\pi_{\\mathsf{id}^{\\prime}}<span class="math"> is about as large as reevaluating the VDF altogether. Indeed, a honest prover, after having computed the output </span>y<span class="math">, can compute </span>\\pi_{\\mathsf{id}}<span class="math"> at a reduced cost thanks to some precomputed intermediate values. But an adversary does not have these intermediate values, so they would have to compute </span>\\pi_{\\mathsf{id}^{\\prime}}<span class="math"> from scratch. This is an exponentiation in </span>G<span class="math">, with exponent of bit-length close to </span>t<span class="math">; without any intermediate values, it requires in the order of </span>t$ sequential group operations, which is the cost of evaluating the VDF.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-46" class="text-2xl font-bold">8 Circumventing impossibility results with timing assumptions</h2>

    <p class="text-gray-300">In addition to the applications mentioned in the introduction, we conclude this paper by showing that a <em>trapdoor</em> VDF also constitutes a new tool for circumventing classic impossibility results. We illustrate this through a simple identification protocol constructed from a trapdoor VDF, where a party, Alice, wishes to identify herself to Bob by proving that she knows the trapdoor. Thanks to the VDF timing properties, this protocol features surprising zero-knowledge and deniability properties challenging known impossibility results.</p>

    <p class="text-gray-300">As this discussion slightly deviates from the crux of the article (the construction of a trapdoor VDF), most of the details are deferred to Appendices B and C, and this section only introduces the main ideas. As in the rest of the paper, the parameter <span class="math">k</span> is the security level. The identification protocol goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bob chooses a challenge <span class="math">c\\in\\{0,1\\}^{k}</span> uniformly at random. He sends it to Alice, along with a time limit <span class="math">\\Delta</span>, and starts a timer.</li>

      <li>Alice responds by sending the evaluation of the VDF on input <span class="math">c</span> (with time parameter <span class="math">\\Delta</span>), together with the proof. She can respond fast using her trapdoor.</li>

      <li>Upon receiving the response, Bob stops the timer. He accepts if the verification of the VDF succeeds and the elapsed time is smaller than <span class="math">\\Delta</span>.</li>

    </ol>

    <h6 id="sec-47" class="text-base font-medium mt-4">Remark 7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We present here only an identification protocol, but it is easy to turn it into an authentication protocol for a message <span class="math">m</span> by having Alice use the concatenation $c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m$ as input to the VDF.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since only Alice can respond immediately thanks to her secret, Bob is convinced of her identity. Since anyone else can compute the response to the challenge in time <span class="math">\\Delta</span>, the exchange is perfectly simulatable, hence perfectly zero-knowledge. It is well-known (and in fact clear from the definition) that a classic interactive zero-knowledge proof cannot have only one round (this would be a challenge-response exchange, and the simulator would allow to respond to the challenge in polynomial time, violating soundness). The above protocol avoids this impossibility thanks to a modified notion of soundness, ensuring that only Alice can respond <em>fast enough</em>. This is made formal in Appendix B, via the notion of zero-knowledge timed challenge-response protocol.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Remark 8.</h6>

    <p class="text-gray-300">Note that this very simple protocol is also efficient: the “time-lock” evaluation of the VDF does not impact any of the honest participants, it is only meant to be used by the simulator. Only the trapdoor evaluation and the verification are actually executed.</p>

    <p class="text-gray-300">Finally, this protocol has strong deniability properties. Indeed, since anyone can produce in time <span class="math">\\Delta</span> a response to any challenge, any transcript of a conversation that is older than time <span class="math">\\Delta</span> could have been generated by anyone. In fact the protocol is <em>on-line deniable</em> against any judge that suffers a communication delay larger than <span class="math">\\Delta/2</span>. Choosing <span class="math">\\Delta</span> to be as short as possible (while retaining soundness) yields a strongly deniable protocol. Full on-line deniability is known to be impossible in a PKI (see <em>[11]</em>), and this delay assumption provides a new way to circumvent this impossibility. This is discussed in more detail in Appendix C.</p>

    <h2 id="sec-49" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The author wishes to thank a number of people with whom interesting discussions helped improve the present work, in alphabetical order, Dan Boneh, Justin Drake, Alexandre Gélin, Novak Kaluđerović, Arjen K. Lenstra and Serge Vaudenay. Finalisation of this work has been partially funded by the ERC Advanced Grant 740972 (ALGSTRONGCRYPTO).</p>

    <h2 id="sec-50" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Bellare and S. Goldwasser. Encapsulated key escrow. Technical report, 1996.</li>

      <li>[2] M. Bellare and S. Goldwasser. Verifiable partial key escrow. In Proceedings of the 4th ACM Conference on Computer and Communications Security, CCS ’97, pages 78–91, New York, NY, USA, 1997. ACM.</li>

      <li>[3] I. Biehl, J. Buchmann, S. Hamdy, and A. Meyer. A signature scheme based on the intractability of computing roots. Designs, Codes and Cryptography, 25(3):223–236, 2002.</li>

      <li>[4] D. Boneh, J. Bonneau, B. Bünz, and B. Fisch. Verifiable delay functions. In E. F. Brickell, editor, Advances in Cryptology – CRYPTO 2018, pages 757–788. Springer, 2018.</li>

      <li>[5] D. Boneh, B. Bünz, and B. Fisch. A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.iacr.org/2018/712.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>D. Boneh and M. Franklin. Efficient generation of shared rsa keys. In Annual International Cryptology Conference, pages 425–439. Springer, 1997.</li>

      <li>D. Boneh and M. Naor. Timed commitments. In M. Bellare, editor, Advances in Cryptology – CRYPTO 2000, volume 1880 of Lecture Notes in Computer Science, pages 236–254. Springer Berlin Heidelberg, 2000.</li>

      <li>J. Buchmann and S. Hamdy. A survey on iq cryptography. In In Proceedings of Public Key Cryptography and Computational Number Theory, pages 1–15, 2001.</li>

      <li>J. Buchmann and H. C. Williams. A key-exchange system based on imaginary quadratic fields. Journal of Cryptology, 1(2):107–118, 1988.</li>

      <li>CPU-Z OC world records. http://valid.canardpc.com/records.php, 2018.</li>

      <li>Y. Dodis, J. Katz, A. Smith, and S. Walfish. Composability and On-Line Deniability of Authentication, pages 146–162. Springer Berlin Heidelberg, Berlin, Heidelberg, 2009.</li>

      <li>J. Drake. Ethereum 2.0 randomness. August 2018 workshop at Stanford hosted by the Ethereum Foundation and the Stanford Center for Blockchain Research, 2018. https://docs.google.com/presentation/d/13OAGL42yzOvQUKvJJ0EBsAAne25yA7sv9RC8FfPhtyo.</li>

      <li>J. Drake. Minimal VDF randomness beacon. Ethereum Research post, 2018. https://ethresear.ch/t/minimal-vdf-randomness-beacon/3566.</li>

      <li>J. L. Hafner and K. S. McCurley. A rigorous subexponential algorithm for computation of class groups. Journal of the American mathematical society, 2(4):837–850, 1989.</li>

      <li>A. K. Lenstra and B. Wesolowski. Trustworthy public randomness with sloth, unicorn and trx. International Journal of Applied Cryptology, 2016.</li>

      <li>K. Pietrzak. Simple verifiable delay functions. Cryptology ePrint Archive, Report 2018/627, Version 20180626:145529, 2018. https://eprint.iacr.org/2018/627.</li>

      <li>M. O. Rabin. Transaction protection by beacons. Journal of Computer and System Sciences, 27(2):256 – 267, 1983.</li>

      <li>R. L. Rivest, A. Shamir, and D. A. Wagner. Time-lock puzzles and timed-release crypto. 1996.</li>

      <li>T. Sander. Efficient accumulators without trapdoor extended abstract. In International Conference on Information and Communications Security, pages 252–262. Springer, 1999.</li>

      <li>U. Vollmer. Asymptotically fast discrete logarithms in quadratic number fields. In International Algorithmic Number Theory Symposium (ANTS), pages 581–594. Springer, 2000.</li>

    </ol>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix A Proof of Remark 1</h2>

    <p class="text-gray-300">Model <span class="math">H</span> as a random oracle. Suppose that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{trapdoor}^{H}_{\\mathsf{sk}}(x,\\Delta)</span> <span class="math">=t_{\\mathsf{sk}}(H(x),\\Delta),</span> <span class="math">\\mathsf{eval}^{H}_{\\mathsf{pk}}(x,\\Delta)</span> <span class="math">=e_{\\mathsf{pk}}(H(x),\\Delta),and</span> <span class="math">\\mathsf{verify}_{\\mathsf{pk}}(x,y,\\Delta)</span> <span class="math">=v_{\\mathsf{pk}}(H(x),y,\\Delta),</span></p>

    <p class="text-gray-300">for procedures <span class="math">t,e</span> and <span class="math">v</span> that do not have access to <span class="math">H</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be a player of the <span class="math">\\Delta</span>-evaluation race game. Assume that the output <span class="math">\\mathcal{B}</span> of <span class="math">\\mathcal{A}</span> is limited to a number <span class="math">q</span> of queries to <span class="math">\\mathcal{O}</span> and <span class="math">H</span>. We are going to build</p>

    <p class="text-gray-300">an algorithm <span class="math">\\mathcal{A}&#x27;</span> that wins with same probability as <span class="math">\\mathcal{A}</span> when its output <span class="math">\\mathcal{B}&#x27;</span> is not given access to <span class="math">\\mathcal{O}</span>.</p>

    <p class="text-gray-300">Let <span class="math">(Y_{i})_{i=1}^{q}</span> be a sequence of random hash values (i.e., uniformly distributed random values in <span class="math">\\{0,1\\}^{2k}</span>). First observe that <span class="math">\\mathcal{A}</span> wins the <span class="math">\\Delta</span>-evaluation race game with the same probability if the last step runs the algorithm <span class="math">\\mathcal{B}^{\\mathcal{O}&#x27;,H&#x27;}</span> instead of <span class="math">\\mathcal{B}^{\\mathcal{O},H}</span>, where</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H&#x27;</span> is the following procedure: for any new requested input <span class="math">x</span>, if <span class="math">x</span> has previously been requested by <span class="math">\\mathcal{A}</span> to <span class="math">H</span> then output <span class="math">H&#x27;(x) = H(x)</span>; otherwise set <span class="math">H&#x27;(x)</span> to be the next unassigned value in the sequence <span class="math">(Y_i)</span>;</li>

      <li><span class="math">\\mathcal{O}&#x27;</span> is an oracle that on input <span class="math">x</span> outputs <span class="math">t_{\\mathsf{sk}}(H&#x27;(x), \\Delta)</span>.</li>

    </ol>

    <p class="text-gray-300">With this observation in mind, we build <span class="math">\\mathcal{A}&#x27;</span> as follows. On input <span class="math">\\mathsf{pk}</span>, <span class="math">\\mathcal{A}&#x27;</span> first runs <span class="math">\\mathcal{A}^H</span> which outputs <span class="math">\\mathcal{A}^H(\\mathsf{pk}) = \\mathcal{B}</span>. Let <span class="math">X</span> be the set of inputs of the requests that <span class="math">\\mathcal{A}</span> made to <span class="math">H</span>. For any <span class="math">x \\in X</span>, <span class="math">\\mathcal{A}&#x27;</span> computes and stores the pair <span class="math">(H(x), \\mathsf{eval}_{\\mathsf{pk}}(x, \\Delta))</span> in a list <span class="math">L</span>. In addition, it computes and stores <span class="math">(Y_i, e_{\\mathsf{pk}}(Y_i, \\Delta))</span> for each <span class="math">i = 1, \\ldots, q</span>, and adds them to <span class="math">L</span>.</p>

    <p class="text-gray-300">Consider the following procedure <span class="math">\\mathcal{O}&#x27;</span>: on input <span class="math">x</span>, look for the pair of the form <span class="math">(H&#x27;(x), \\sigma)</span> in the list <span class="math">L</span>, and output <span class="math">\\sigma</span>. The output of <span class="math">\\mathcal{A}&#x27;</span> is the algorithm <span class="math">\\mathcal{B}&#x27; = \\mathcal{B}^{\\mathcal{O}&#x27;, H&#x27;}</span>. It does not require access to the oracle <span class="math">\\mathcal{O}</span> anymore: all the potential requests are available in the list of precomputed values. Each call to <span class="math">\\mathcal{O}</span> is replaced by a lookup in the list <span class="math">L</span>, so <span class="math">\\mathcal{B}&#x27;</span> has essentially the same running time as <span class="math">\\mathcal{B}</span>. Therefore <span class="math">\\mathcal{A}&#x27;</span> wins the <span class="math">\\Delta</span>-evaluation race game with same probability as <span class="math">\\mathcal{A}</span> even when its output <span class="math">\\mathcal{B}&#x27;</span> is not given access to a evaluation oracle.</p>

    <h2 id="sec-52" class="text-2xl font-bold">B Timed challenge-response identification protocols</h2>

    <p class="text-gray-300">A timed challenge-response identification protocol has four procedures:</p>

    <p class="text-gray-300">keygen → (pk, sk) is a key generation procedure, which outputs a prover's public key pk and secret key sk.</p>

    <p class="text-gray-300">challenge → c which outputs a random challenge.</p>

    <p class="text-gray-300">respondsk(c, Δ) → r is a procedure that uses the prover's secret key to respond to the challenge c, for the time parameter Δ.</p>

    <p class="text-gray-300">verifypk(c, r, Δ) → true or false is a procedure to check if r is a valid response to c, for the public key pk and the time parameter Δ.</p>

    <p class="text-gray-300">The security level <span class="math">k</span> is implicitly an input to each of these procedures. The keygen procedure is used to generate Alice's public and secret keys, then the identification protocol is as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bob generates a random <span class="math">c</span> with the procedure challenge. He sends it to Alice, along with a time limit <span class="math">\\Delta</span>, and starts a timer.</li>

      <li>Alice responds <span class="math">r = \\text{respond}_{\\text{sk}}(c, \\Delta)</span>.</li>

      <li>Bob stops the timer. He accepts if verifypk(c, r, Δ) = true and the elapsed time is smaller than Δ.</li>

    </ol>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">Given a time parameter <span class="math">\\Delta</span>, a <span class="math">\\Delta</span>-response race game and an associated notion of <span class="math">\\Delta</span>-soundness can be defined in a straightforward manner as follows.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 8 (<span class="math">\\Delta</span>-response race game).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be a party playing the game. The parameter <span class="math">\\Delta:\\mathbf{Z}_{&gt;0}\\rightarrow\\mathbf{R}_{&gt;0}</span> is a function of the (implicit) security parameter <span class="math">k</span>. The <span class="math">\\Delta</span>-response race game goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The random procedure keygen is run and it outputs a public key pk;</li>

      <li><span class="math">\\mathcal{A}(\\mathsf{pk})</span> outputs an algorithm <span class="math">\\mathcal{B}</span>;</li>

      <li>A random challenge <span class="math">c</span> is generated according to the procedure challenge;</li>

      <li><span class="math">\\mathcal{B}^{\\mathcal{O}}(c)</span> outputs a value <span class="math">r</span>, where <span class="math">\\mathcal{O}</span> is an oracle that outputs the evaluation <span class="math">\\mathsf{respond}_{\\mathsf{sk}}(c^{\\prime},\\Delta)</span> on any input <span class="math">c^{\\prime}\\neq c</span>.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">\\mathcal{A}</span> wins the game if <span class="math">T(\\mathcal{B},c)&lt;\\Delta</span> and <span class="math">\\mathsf{verify}_{\\mathsf{pk}}(c,r,\\Delta)=\\mathsf{true}</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 9 (<span class="math">\\Delta</span>-soundness).</h6>

    <p class="text-gray-300">A timed challenge-response identification protocol is <span class="math">\\Delta</span>-sound if any polynomially bounded player (with respect to the implicit security parameter) wins the above <span class="math">\\Delta</span>-response race game with negligible probability.</p>

    <p class="text-gray-300">It is as immediate to verify that a sound and <span class="math">\\Delta</span>-sequential VDF gives rise to a <span class="math">\\Delta</span>-sound identification protocol (via the construction of Section 8). Similarly, the completeness of the identification protocol (that a honest run of the protocol terminates with a successful verification) is straightforward to derive from the fact that the verification of a valid VDF output always outputs true. There simply is one additional requirement: if the procedure <span class="math">\\mathsf{respond}_{\\mathsf{sk}}(c,\\Delta)</span> requires computation time at least <span class="math">\\epsilon_{1}</span>, and the channel of communication has a transmission delay at least <span class="math">\\epsilon_{2}</span>, we must have <span class="math">\\epsilon_{1}+2\\epsilon_{2}&lt;\\Delta</span>. Finally the zero-knowledge property is defined as follows.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 10 (Zero-knowledge).</h6>

    <p class="text-gray-300">A timed challenge-response identification protocol is (perfectly, computationally, or statistically) zero-knowledge if there is an algorithm <span class="math">\\mathcal{S}</span> that on input <span class="math">k</span>, <span class="math">\\Delta</span>, pk and a random <span class="math">\\mathsf{challenge}(k,\\Delta)</span> produces an output (perfectly, computationally, or statistically) indistinguishable from <span class="math">\\mathsf{respond}_{\\mathsf{sk}}(c,k,\\Delta)</span>, and the running time of <span class="math">\\mathcal{S}</span> is polynomial in <span class="math">k</span>.</p>

    <p class="text-gray-300">In a classical cryptographic line of though, this zero-knowledge property is too strong to provide any soundness, since an adversary can respond to the challenge with a running time polynomial in the security parameter of Alice’s secret key. This notion starts making sense when the complexity of the algorithm <span class="math">\\mathcal{S}</span> is governed by another parameter, here <span class="math">\\Delta</span>, independent from Alice’s secret.</p>

    <p class="text-gray-300">For the protocol derived from a VDF, the zero-knowledge property is ensured by the fact that anyone can compute Alice’s response to the challenge in time polynomial in <span class="math">k</span>, with the procedure eval.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">C Local identification</p>

    <p class="text-gray-300">The challenge-response identification protocol derived from a VDF in Section 8 is totally deniable against a judge, Judy, observing the communication from a long distance. The precise definition of on-line deniability is discussed in <em>[11]</em>. We refer the reader there for the details, but the high level idea is as follows. Alice is presumably trying to authenticate her identity to Bob. Judy will rule whether or not the identification was attempted. Judy interacts with an informant who is witnessing the identification and who wants to convince Judy that it happened. This informant could also be a misinformant, who is not witnessing any identification, but tries to deceive Judy into believing it happened. The protocol is on-line deniable if no efficient judge can distinguish whether she is talking to an informant or a misinformant. The (mis)informant is allowed to corrupt Alice or Bob, at which point he learns their secret keys and controls their future actions. When some party is corrupted, Judy learns about it.</p>

    <p class="text-gray-300">It is shown in <em>[11]</em> that this strong deniability property is impossible to achieve in a PKI. To mitigate this issue, they propose a secure protocol in a relaxed setting, allowing incriminating aborts. We propose an alternative relaxation of the setting, where Judy is assumed to be far away from Alice and Bob (more precisely: the travel time of a message between Alice and Bob is shorter than between Alice (or Bob) and Judy). For example, consider a building whose access is restricted to authorised card holders. Suppose the card holders do not want anyone other than the card reader to get convincing evidence that they are accessing the building (even if the card reader is corrupted, it cannot convince anyone else). Furthermore, Alice herself cannot convince anyone that the card reader ever acknowledged her identification attempt. In this context, the card and the card reader benefit from very efficient communications, while a judge farther away would communicate with an additional delay. An identification protocol can exploit this delay to become deniable, and this is achieved by the timed challenge-response identification protocol derived from a VDF.</p>

    <p class="text-gray-300">The idea is the following. Suppose that the distance between Alice and Judy is long enough to ensure that the travel time of a message from Alice to Judy is larger than <span class="math">\\Delta/2</span>. Then, Judy cannot distinguish a legitimate response of Alice that took some time to reach her from a response forged by a misinformant that is physically close to Judy.</p>

    <p class="text-gray-300">More precisely, considering an informant <span class="math">I</span> who established a strategy with Judy, we can show that there is a misinformant <span class="math">M</span> that Judy cannot distinguish from <span class="math">I</span>. First of all, Bob cannot be incriminated since he is not using a secret key. It all boils down to tracking the messages that depend on Alice’s secret key.</p>

    <p class="text-gray-300">Consider a run of the protocol with the informant <span class="math">I</span>. Let <span class="math">t_{0}</span> be the point in time where Alice computed <span class="math">s=\\mathsf{trapdoor}_{\\mathsf{sk}}(c,\\Delta)</span>. The delay implies two things:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenge <span class="math">c</span> is independent of anything Judy sent after point in time <span class="math">t_{0}-\\Delta/2</span>.</li>

      <li>The first message Judy receives that can depend on <span class="math">s</span> (and therefore the first message that depends on Alice’s secret) arrives after <span class="math">t_{0}+\\Delta/2</span>.</li>

    </ol>

    <p class="text-gray-300">From Point 1, at time <span class="math">t_{0}-\\Delta/2</span>, the misinformant (who is close to Judy) can already generate <span class="math">c</span> (following whichever procedure <span class="math">I</span> and Judy agreed on), and start evaluating <span class="math">\\mathsf{eval}_{\\mathsf{pk}}(c,\\Delta)</span>. The output is ready at time <span class="math">t_{0}+\\Delta/2</span>, so from Point 2, the misinformant is on time to send to Judy messages that should depend on the signature <span class="math">s</span>.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">In practice.</h4>

    <p class="text-gray-300">The protocol is deniable against a judge at a certain distance away from Alice and Bob, and the minimal value of this distance depends on <span class="math">\\Delta</span>. An accurate estimation of this distance would require in the first place an equally accurate estimation of the real time <span class="math">\\Delta</span> (in seconds) a near-optimal adversary would need to forge the response. This non-trivial task relates to the discussion of Section 3.2.</p>

    <p class="text-gray-300">Assuming reasonable bounds for <span class="math">\\Delta</span> have been established, one can relate the distance and the communication delay in a very conservative way through the speed of light. We want Judy to stand at a sufficient distance to ensure that any message takes at least <span class="math">\\Delta/2</span> s to travel between them, so Judy should be at least <span class="math">c\\Delta/2</span> m away, where <span class="math">c\\approx 3.00\\times 10^{8}</span> m/s is the speed of light. For security against a judge standing 100 m away, one would require <span class="math">\\Delta\\approx 0.66</span> <span class="math">\\mu</span>s. Alice should be able to respond to Bob’s challenge in less time than that. At this point, it seems unreasonable to assume that such levels of precision can be achieved (although in principle, distance bounding protocols do deal with such constraints), yet it remains interesting that such a simple and efficient protocol provides full deniability against a judge that suffers more serious communication delays.</p>

    <p class="text-gray-300">Data: an element  <span class="math">g</span>  in a group  <span class="math">G</span>  (with identity  <span class="math">1_G</span> ), a prime number  <span class="math">\\ell</span> , a positive integer  <span class="math">t</span> , two parameters  <span class="math">\\kappa, \\gamma &amp;gt; 0</span> , and a table of precomputed values  <span class="math">C_i = g^{2^{i\\kappa \\gamma}}</span> , for  <span class="math">i = 0, \\dots, \\lceil t / (\\kappa \\gamma) \\rceil</span> .</p>

    <p class="text-gray-300">Result:  <span class="math">g^{\\lfloor 2^t /\\ell \\rfloor}</span></p>

    <p class="text-gray-300">// define a function get_block such that  <span class="math">\\lfloor 2^t /\\ell \\rfloor = \\sum_i</span>  get_block(i)  <span class="math">2^{\\kappa i}</span></p>

    <p class="text-gray-300">get_block  <span class="math">\\leftarrow</span>  the function that on input  <span class="math">i</span>  returns  <span class="math">\\lfloor 2^{\\kappa}(2^{t - \\kappa (i + 1)}\\mod \\ell) / \\ell \\rfloor</span></p>

    <p class="text-gray-300">// split  <span class="math">\\kappa</span>  into to halves</p>

    <p class="text-gray-300"><span class="math">\\kappa_{1}\\gets \\lfloor \\kappa /2\\rfloor</span></p>

    <p class="text-gray-300"><span class="math">\\kappa_0\\gets \\kappa -\\kappa_1</span></p>

    <p class="text-gray-300"><span class="math">x\\gets 1_G\\in G</span></p>

    <p class="text-gray-300">for  <span class="math">j\\gets \\gamma -1</span>  to 0 (descending order) do</p>

    <pre><code class="language-latex">$\\begin{array}{rl} &amp;amp; x\\gets x^{2^{\\kappa}}\\\\ &amp;amp; \\mathrm{for~}b\\in \\{0,\\ldots ,2^{\\kappa} - 1\\} \\mathrm{do}\\\\ &amp;amp; \\qquad |y_{b}\\gets 1_{G}\\in G;\\\\ &amp;amp; \\mathrm{end}\\\\ &amp;amp; \\mathrm{for~}i\\gets 0,\\ldots ,\\lceil t / (\\kappa \\gamma)\\rceil -1\\mathrm{do}\\\\ &amp;amp; \\qquad b\\leftarrow \\mathrm{get\\_block}(i\\gamma +j);\\qquad //\\mathrm{this~could~easily~be~optimised~by}\\\\ &amp;amp; \\qquad \\mathrm{computing~the~blocks~iteratively~as~in~Algorithm~4~(but}\\\\ &amp;amp; \\qquad \\mathrm{computing~blocks~of~}\\kappa \\mathrm{~bits~and~taking~steps~of~}\\kappa \\gamma \\mathrm{~bits}),\\\\ &amp;amp; \\qquad \\mathrm{instead~of~computing~them~one~by~one}.\\\\ &amp;amp; \\qquad y_{b}\\gets y_{b}\\cdot C_{i};\\\\ &amp;amp; \\mathrm{end}\\\\ &amp;amp; \\mathrm{for~}b_{1}\\in \\{0,\\ldots ,2^{\\kappa_{1}} - 1\\} \\mathrm{do}\\\\ &amp;amp; \\qquad z\\gets 1_{G}\\in G;\\\\ &amp;amp; \\mathrm{for~}b_{0}\\in \\{0,\\ldots ,2^{\\kappa_{0}} - 1\\} \\mathrm{do}\\\\ &amp;amp; \\qquad |z\\gets z\\cdot y_{b_{1}2^{\\kappa_{0}} + b_{0}};\\\\ &amp;amp; \\mathrm{end}\\\\ &amp;amp; x\\gets x\\cdot z^{b_{1}2^{\\kappa_{0}}};\\\\ &amp;amp; \\mathrm{end}\\\\ &amp;amp; \\mathrm{for~}b_{0}\\in \\{0,\\ldots ,2^{\\kappa_{0}} - 1\\} \\mathrm{do}\\\\ &amp;amp; \\qquad z\\gets 1_{G}\\in G;\\\\ &amp;amp; \\mathrm{for~}b_{1}\\in \\{0,\\ldots ,2^{\\kappa_{1}} - 1\\} \\mathrm{do}\\\\ &amp;amp; \\qquad |z\\gets z\\cdot y_{b_{1}2^{\\kappa_{0}} + b_{0}};\\\\ &amp;amp; \\mathrm{end}\\\\ &amp;amp; x\\gets x\\cdot z^{b_{0}};\\\\ &amp;amp; \\mathrm{end} \\end{array}$
end
end
return  $x$</code></pre>

    <p class="text-gray-300">Algorithm 5: Faster algorithm to compute  <span class="math">g^{\\lfloor 2^t / \\ell \\rfloor}</span> , given some precomputa- tions.</p>`;
---

<BaseLayout title="Efficient verifiable delay functions (2018/623)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/623
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
