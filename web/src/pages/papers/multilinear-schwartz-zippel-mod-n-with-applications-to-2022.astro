---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/458';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Multilinear Schwartz-Zippel mod N with Applications to Succinct Arguments';
const AUTHORS_HTML = 'Benedikt Bünz, Ben Fisch';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz [ [ben.fisch@yale.edu ] New York University ] Ben Fisch [ fale University ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We show that for <span class="math">\\mathbf{x}\\stackrel{{\\scriptstyle\\rm S}}{{\\leftarrow}}[0,2^{{\\lambda}})^{\\mu}</span> and any integer <span class="math">N</span> the probability that <span class="math">f(\\mathbf{x})\\equiv 0\\bmod N</span> for any non-zero multilinear polynomial <span class="math">f\\in\\mathbb{Z}[X_{1},\\ldots,X_{\\mu}]</span>, co-prime to <span class="math">N</span> is inversely proportional to <span class="math">N</span>. As a corollary we show that if <span class="math">\\log_{2}N\\geq\\log_{2}(2\\mu)\\lambda+8\\mu^{2}</span> then the probability is bounded by <span class="math">\\frac{\\mu+1}{2^{N}}</span>. We also give tighter numerically derived bounds, showing that if <span class="math">\\log_{2}N\\geq 418</span>, and <span class="math">\\mu\\leq 20</span> the probability is bounded by <span class="math">\\frac{\\mu}{2^{N}}+2^{-120}</span>.</p>

    <p class="text-gray-300">We then apply this Multilinear Composite Schwartz-Zippel Lemma (LCSZ) to resolve an open problem in the literature on succinct arguments: that the <em>Bulletproofs</em> protocol for linear relations over classical Pedersen commitments in prime-order groups remains knowledge sound when generalized to commitment schemes that are binding only over short integer vectors. In particular, this means that the Bulletproofs protocol can be instantiated with plausibly post-quantum commitments from lattice hardness assumptions (SIS/R-SIS/M-SIS). It can also be instantiated with commitments based on groups of unknown order (GUOs), in which case the verification time becomes logarithmic instead of linear time.</p>

    <p class="text-gray-300">Prior work on lattice-based Bulletproofs <em>(Crypto, 2020)</em> and its extensions required modifying the protocol to sample challenges from special sets of polynomial size. This results in a non-negligible knowledge error, necessitating parallel repetition to amplify soundness, which impacts efficiency and poses issues for the Fiat-Shamir transform. Our analysis shows knowledge soundness for the original Bulletproofs protocol with the exponential-size integer challenge set <span class="math">[0,2^{{\\lambda}}]</span> and thus achieves a negligible soundness error without repetition, circumventing a previous impossibility result <em>(Crypto, 2021)</em>. Our analysis also closes a critical gap in the original security proof of DARK, a GUO-based polynomial commitment scheme <em>(Eurocrypt, 2020)</em>. Along the way to achieving our result we also define <em>Almost Special Soundness</em> (AMSS), a generalization of Special-Soundness. Our main result is divided into two parts: (1) that the Bulletproofs protocol over generalized commitments is AMSS, and (2) that AMSS implies knowledge soundness. This framework serves to simplify the application of our analytical techniques to protocols beyond Bulletproofs in the future.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The famous DeMillo-Lipton-Schwartz-Zippel (DLSZ) lemma <em>[x11, x32, x36]</em> states that for any field <span class="math">\\mathbb{F}</span>, non-empty finite subset <span class="math">S\\subseteq\\mathbb{F}</span>, and non-zero <span class="math">\\mu</span>-variate polynomial <span class="math">f</span> over <span class="math">\\mathbb{F}</span> of total degree <span class="math">d</span>, the number of zeros of <span class="math">f</span> contained in <span class="math">S^{\\mu}</span> is bounded by $d\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu-1}<span class="math"> (or equivalently, the probability that </span>f(\\mathbf{x})=0<span class="math"> for </span>\\mathbf{x}<span class="math"> sampled uniformly from </span>S^{\\mu}<span class="math"> is bounded by </span>\\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">). For </span>\\mu=1<span class="math"> this simply follows from the Fundamental Theorem of Algebra, but for multivariate polynomials, the number of zeros over the whole field could be unbounded. The computational significance of this lemma is that sampling an element from </span>S<span class="math"> only takes </span>n\\cdot\\log_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> random bits but the probability of randomly sampling a zero of </span>f<span class="math"> from </span>S^{\\mu}<span class="math"> is inversely proportional to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, which is exponential in the number of random bits. One of its original motivations was an efficient randomized algorithm for polynomial identity testing, but it has since found widespread application in computer science <em>[x23]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The classical lemma applies more broadly to integral domains, but not to more general commutative rings such as the ring <span class="math">\\mathbb{Z}_{N}</span>. As a simple counterexample, over the ring of integers modulo <span class="math">N=2p</span> the polynomial <span class="math">f(X)=pX\\bmod N</span> vanishes on half of the points in <span class="math">[0,N)</span>.</p>

    <p class="text-gray-300">This counterexample exploits the fact that <span class="math">f</span> is of the form <span class="math">f(X)=u\\cdot g(X)</span> where <span class="math">u</span> is a zero-divisor. There are also simple counterexamples for <span class="math">f</span> co-prime to <span class="math">N</span>: setting <span class="math">N=2^{\\lambda}</span> the polynomial <span class="math">f(X)=X^{\\lambda}\\bmod N</span> vanishes on half of the points in <span class="math">[0,N)</span>. However, there are no such counterexamples when <span class="math">f</span> is both multilinear and co-prime to <span class="math">N</span>. In fact, we will show in this work the probability a random vector from <span class="math">S^{\\mu}=[0,m)^{\\mu}</span> is a zero of a <span class="math">\\mu</span>-linear polynomial (multilinear with <span class="math">\\mu</span> variables) co-prime to <span class="math">N</span> is negligible in the minimum of <span class="math">\\log m</span> and <span class="math">\\log N</span>. As we will show in our main result, this special case of <span class="math">f</span> and <span class="math">N</span> still has a surprisingly powerful application to cryptography that resolves multiple recent open questions in the area of succinct arguments.</p>

    <p class="text-gray-300">The DLSZ lemma has previously been extended to commutative rings by restricting the set <span class="math">S</span> to special subsets in which the difference of any two elements is not a zero divisor <em>[x1]</em>. For example, in the case of <span class="math">\\mathbb{Z}_{N}</span> this would require the difference of any two elements in <span class="math">S</span> to be co-prime to <span class="math">N</span>. All examples of such sets have <span class="math">O(\\log N)</span> size. Our present work explores the setting where <span class="math">S</span> is the contiguous interval <span class="math">[0,m)</span> and thus does not have this restriction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a warmup, it is easy to see that any univariate linear polynomial <span class="math">f(X)=c\\cdot X+b</span> co-prime to <span class="math">N</span> has at most one root modulo <span class="math">N</span>. If there were two such roots <span class="math">x_{1}\\not\\equiv x_{2}\\bmod N</span> then <span class="math">c(x_{1}-x_{2})\\equiv 0\\mod N</span> implies <span class="math">c</span> is a zero divisor (i.e., <span class="math">\\gcd(c,N)\\neq 1</span>). Furthermore, <span class="math">c\\cdot x_{1}\\equiv-b\\bmod N</span> implies <span class="math">-b=c\\cdot x_{1}+q\\cdot N</span> for some <span class="math">q\\in\\mathbb{Z}</span>, and thus, <span class="math">\\gcd(c,N)</span> also divides <span class="math">b</span>. This would contradict the co-primality of <span class="math">f</span> and <span class="math">N</span>. So for <span class="math">x</span> uniformly distributed in <span class="math">S=[0,m)</span> the probability of <span class="math">f(x)\\equiv 0\\bmod N</span> in this case is indeed at most $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Unfortunately, this does not generalize nicely to polynomials of arbitrary degree as illustrated by the counterexample above. On the other hand, we are able to generalize the lemma in a meaningful way to multivariate <em>linear</em> polynomials (i.e, at most degree </span>1<span class="math"> in each variable). We bound the probability of sampling a zero from </span>S^{\\mu}=[0,m)^{\\mu}<span class="math"> of a </span>\\mu<span class="math">-linear polynomial co-prime to </span>N<span class="math"> by </span>\\epsilon+\\frac{\\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, where </span>\\epsilon$ is tightly bounded by a product of regularized beta functions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also formulate an inverse lemma showing that for all sufficiently large <span class="math">N</span>, <span class="math">\\epsilon</span> is negligibly small. In particular, for <span class="math">\\log N\\geq 8\\mu^{2}+(1+\\log\\mu)\\lambda</span>, <span class="math">\\epsilon</span> is at most <span class="math">2^{-\\lambda}</span>, showing that the probability decays exponentially. Our technique for deriving this threshold lower bound <span class="math">t(\\lambda,\\mu)</span> on <span class="math">N</span> for a target <span class="math">\\lambda</span> formulates <span class="math">t(\\lambda,\\mu)</span> as the objective function of a knapsack problem. We derive an analytical solution by deriving bounds on the regularized beta function. We also apply a knapsack approximation algorithm to find tighter values of <span class="math">t(\\lambda,\\mu)</span> for specific values of <span class="math">\\mu</span> and <span class="math">\\lambda</span>. We call our new lemma the <em>multilinear composite Schwartz-Zippel</em> (LCSZ) lemma.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Bulletproofs for short pre-images</h3>

    <p class="text-gray-300">Using the multi-linear composite Schwartz-Zippel lemma (LCSZ), we can prove that a generalization of the Bulletproofs Polynomial Commitment <em>[x2, x3]</em> is secure even with large challenge sets. The generalization allows for commitments to “short” (i.e., bounded norm) integer vectors. This includes groups of unknown order, such as the RSA group or class groups, as well as lattice-based commitments (i.e. Ajtai commitments based on the Integer SIS or Ring-SIS assumptions). The instantiation using commitments based on groups of unknown order is essentially a variation of DARK <em>[x4]</em>, and our analysis closes a vital gap in the security proof that was first discovered by <em>[x5]</em>. Unlike the fix proposed by <em>[x4]</em>, our analysis covers the original DARK protocol and enables the use of a large challenge space instead of relying on binary challenges. Our analysis is also the first to show that lattice-based Bulletproofs <em>[x6]</em> (i.e., Bulletproofs instantiated with Ajtai commitments) with a challenge space of exponential size (e.g., <span class="math">[0,2^{\\lambda})</span>) has a negligible knowledge error (without parallel repetition). All previous attempts <em>[x7, x10]</em> had analyzed small, specially constructed challenge sets, which result in a knowledge error <span class="math">o(\\frac{1}{\\mathfrak{poly}(X)})</span>, and thus these protocols used parallel repetition to amplify soundness. In fact, <em>[x1]</em> give an impossibility result, showing that the approach of specially constructing such sets is limited and unlikely to result in a negligible soundness error. Furthermore, parallel-repetition is not always compatible with the Fiat-Shamir transform <em>[x1, x27]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a bit more detail, lattice-based Bulletproofs use commitments to an integer vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}^{n}</span> of the form <span class="math">C=\\mathbf{A}\\mathbf{x}\\bmod q</span> where <span class="math">\\mathbf{A}</span> is a matrix over a <span class="math">\\mathbb{Z}</span>-module <span class="math">\\mathcal{R}</span> and <span class="math">q</span> is a prime number. When <span class="math">\\mathcal{R}=\\mathbb{Z}</span>, the commitment is binding to integer vectors of bounded L2 norm <span class="math">B</span> under the <em>short-integer solution</em> (SIS) assumption for a matrix of appropriate dimensions and <span class="math">q</span> sufficiently larger than <span class="math">B</span>. A more general assumption called <em>module SIS</em> (M-SIS) allows for <span class="math">\\mathcal{R}</span> to be an <span class="math">m</span>-th cyclotomic ring <span class="math">\\mathcal{R}=\\mathbb{Z}[X]/\\Phi_{m}(X)</span>. The goal of the protocol is to argue, for a public input <span class="math">\\mathbf{z}\\in\\mathbb{Z}^{n}</span> and prime <span class="math">p</span>, that <span class="math">\\langle\\mathbf{z},\\mathbf{x}\\rangle=y\\bmod p</span>. The protocol is knowledge sound if there is a knowledge extractor that can obtain an integer vector <span class="math">\\tilde{\\mathbf{x}}\\in\\mathbb{Z}^{n}</span> of sufficiently small norm and a sufficiently small positive integer <span class="math">s</span> such that <span class="math">\\mathbf{A}\\tilde{\\mathbf{x}}=s\\cdot C</span> and <span class="math">\\langle\\mathbf{z},\\tilde{\\mathbf{x}}\\rangle=s\\cdot y\\bmod p</span>. The protocol has knowledge error <span class="math">\\delta</span> if for any adversary succeeding with probability <span class="math">\\epsilon</span> the extractor runs in time <span class="math">\\mathfrak{poly}(n)/\\epsilon</span> and succeeds with probability at least <span class="math">1-\\delta/\\epsilon</span>. The pair <span class="math">(\\tilde{\\mathbf{x}},s)</span> is also known as a “relaxed” opening of the commitment <span class="math">C</span>, which can be interpreted as an opening to the rational <span class="math">\\tilde{\\mathbf{x}}/s</span>. This is binding under M-SIS if $s\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbf{x}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq B<span class="math">. The recent work by Albrecht and Lai <em>[x1]</em> called </span>s<span class="math"> the <em>slack</em> and the norm increase factor </span>t=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbf{x}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> the <em>stretch</em>. It is important to keep </span>s\\cdot t\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq B<span class="math"> for the protocol to be meaningfully sound as otherwise the commitment is no longer binding. While the size of </span>q<span class="math"> could always be increased to accommodate a larger </span>B$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">this increases the communication complexity of the protocol. Thus, for the protocol to remain succinct it is important that <span class="math">s\\cdot t\\in 2^{O(\\text{polylog}(n))}</span>. The impossibility result of <em>[x1]</em> suggested that prior approaches to analyzing lattice-based Bulletproofs would not be able to demonstrate knowledge soundness with small slack using challenge sets of size greater than <span class="math">\\text{\\sf poly}(\\lambda)</span>, and thus would have knowledge soundness error <span class="math">o(1/\\text{\\sf poly}(\\lambda))</span> without parallel repetition. Our work gets around this barrier with new analysis techniques, achieving exponentially small knowledge error <span class="math">2^{-\\lambda}</span> with <span class="math">s\\cdot t\\in 2^{O(\\text{polylog}(n))}</span>.</p>

    <p class="text-gray-300">Prior analysis of DARK and lattice Bulletproofs considered the special-soundness of the protocol. Informally, a public-coin interactive argument for a given relation is special-sound if an extractor can obtain a witness from <em>any</em> tree of accepting transcripts with distinct challenges at any branch. By the “forking lemma”, which shows how to generate such trees, special-soundness implies knowledge soundness. DARK and lattice Bulletproofs both have a similar structure, the main difference being the instantiation of the vector commitment, although in both cases the vector commitment is only binding to short vectors in <span class="math">\\mathbb{Z}^{n}</span> of norm at most <span class="math">B\\in 2^{O(\\text{polylog}(n))}</span>. This restriction on the size of <span class="math">B</span> is for succinctness in the case of lattice Bulletproofs and for quasilinear prover complexity in the case of DARK (the time complexity of creating a DARK commitment is <span class="math">\\Omega(n\\log B)</span> group operations). Special-soundness of these protocol thus requires that the extractor can obtain from any such transcript tree a relaxed opening to the integer vector commitment with slack <span class="math">s</span> and stretch <span class="math">t</span> such that <span class="math">s\\cdot t\\in 2^{O(\\text{polylog}(n))}</span>. In a special-soundness analysis, the differences of challenges in a transcript tree are arbitrary. The strech and slack of the extracted opening grow multiplicatively with those differences, which makes it difficult to bind them tightly. In fact, with challenges chosen from the set <span class="math">[0,2^{\\lambda})</span>, the extractor might obtain an opening with slack <span class="math">2^{o(\\lambda n)}</span>, which is far too large for either DARK or lattice Bulletproofs. However, using the LCSZ, we are able to show that Bulletproofs with vector commitments binding to short vectors (which generalize both DARK and lattice Bulletproofs) satisfies a less stringent requirement we call <em>almost-special soundness</em> (AMSS), which we show also implies knowledge soundness.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Almost Special Soundness</h4>

    <p class="text-gray-300">We introduce almost-special soundness (AMSS) as a generalization of special-soundness. AMSS protocols are multi-round protocols where every round is associated with a commitment that is binding over openings to messages in a set <span class="math">\\mathcal{W}</span>. This does not have to be an explicit message sent to the verifier but roughly represents the prover’s state at a round of the protocol. At a very high level, protocols are AMSS if there exists an algorithm that extracts from any forking transcript tree an opening to these commitments, and if the opening is not inside a subset <span class="math">\\mathcal{W}^{\\prime}\\subset\\mathcal{W}</span> then re-running (or completing) the protocol starting from this extracted state on fresh challenges would fail (with overwhelmingly high probability) to result in a transcript accepted by the verifier. One additional key requirement, stated informally here, is that re-running the protocol on the <em>same</em> challenges would either result in the same transcript or a break of the commitment scheme. We leverage these combined properties to show that AMSS protocols are knowledge-sound. We then show that Bulletproofs with commitments to short pre-images are almost-special sound, which relies on the inverse LCSZ.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a brief overview, we begin by viewing the relaxed openings of the commitment scheme as <em>rational openings</em>. For any commitment <span class="math">C</span> the opening <span class="math">(\\mathbf{f},N)</span> such that <span class="math">\\text{\\sf com}(\\mathbf{f})=N\\cdot C</span> is interpreted as an opening of <span class="math">C</span> to the rational vector <span class="math">\\mathbf{f}/N</span>. In the terminology of <em>[x1]</em>, the slack is thus the size of the absolute value of the denominator $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the stretch is the L2 norm of the numerator </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math">. The Bulletproofs verifier accepts the protocol transcript only if the final message is a “small” integer (of bounded absolute value). This suggests that if the prover were to run the honest protocol starting with </span>\\mathbf{f}/N<span class="math"> as its private state, then its success would imply </span>f(\\mathbf{r})\\equiv 0<span class="math"> mod </span>N<span class="math"> where </span>f<span class="math"> is a multilinear polynomial with the coefficients defined by </span>\\mathbf{f}<span class="math"> and </span>\\mathbf{r}<span class="math"> are the verifier challenges. We can use the inverse LCSZ to show that if </span>N<span class="math"> is too “large” and </span>\\mathbf{r}$ is sampled randomly then this probability is negligible. Making this analysis formal is non-trivial, and we present a summary of the ideas in the technical overview below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Along the way to showing that AMSS implies knowledge soundness we also introduce a variant of the standard forking lemma, which we call the <em>path predicate forking lemma</em>. This lemma shows the existence of a PPT algorithm to generate a transcript tree satisfying additional properties for AMSS protocols that enable the efficient extraction of a witness.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Fiat-Shamir transform</h4>

    <p class="text-gray-300">The Fiat-Shamir transform is a method for transforming an interactive protocol with a public coin verifier into a non-interactive publicly verifiable protocol by replacing the verifier public-coin challenges with hashes of the prover’s messages. Recent work <em>[x2, x21]</em> has shown that the Fiat-Shamir transform is secure for multi-round special-sound protocols. However, the security proof does not translate immediately to almost special-sound (AMSS) protocols. We prove security of the Fiat-Shamir transform for AMSS protocols with <em>computationally unique commitments</em>, where it is infeasible to open two distinct commitments to the same message. The deterministic variants of DARK and Ajtai commitments have this property.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.2 Related work</h3>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Lattice-based Bulletproofs</h4>

    <p class="text-gray-300">Most practical lattice-based succinct proof systems have focused on single-round protocols. These protocols <em>[x11, x2, x10, x11]</em> have <span class="math">o(\\sqrt{(}m))</span> communication complexity.Bulletproofs <em>[x3, x4]</em> is a multiround argument of</p>

    <p class="text-gray-300">knowledge for the opening of Pedersen vector commitments, which are binding based on the discrete-logarithm assumption. The Bulletproofs protocol has a recursive structure involving <span class="math">logn</span> rounds for commitments to vectors of length <span class="math">n</span>, and is public-coin, where the verifier’s challenges are integers uniformly sampled from <span class="math">[0,2^{\\lambda})</span>. The overall communication is only <span class="math">2\\log_{2}(n)</span> <span class="math">\\lambda</span>-bit sized messages. Bootle et al. <em>[x1]</em> adapted the protocol to the lattice setting by replacing the Pedersen commitments with vector commitments based on Ring SIS or Module SIS over a cyclotomic ring <span class="math">\\mathcal{R}</span>. They also replace the challenge set <span class="math">[0,2^{\\lambda})</span> with a smaller subset of <span class="math">\\mathcal{R}</span>. The challenges are monomials with binary coefficients such that the differences of any two challenges divide <span class="math">2</span> in the ring. This allows them to demonstrate special-soundness, i.e. an extractor that can obtain an opening to the lattice-based vector commitment from any ternary tree of valid transcripts with distinct challenges on each edge. However, the smaller challenge set results in a larger soundness error and thus necessitates parallel repetition. This combined with the slack of the extractor leads to total communication <span class="math">O(\\lambda^{2}\\log^{2}(n))</span>, compared with the <span class="math">O(\\lambda\\log(n))</span> complexity of the original Bulletproofs protocol for Pedersen commitments.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">Bulletproofs with subtractive sets</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>[x1]</em> generalize the techniques of <em>[x1]</em> to allow for commitments based on Module SIS (M-SIS) and also more general challenge sets: special sets where differences in challenges are invertible. <em>[x2]</em> further generalize the protocol, allowing for more general challenge sets they call <span class="math">(k,3)</span>-subtractive over <span class="math">\\mathcal{R}</span>. A set <span class="math">S</span> is <span class="math">(k,3)</span>-subtractive if for any triple of challenges <span class="math">\\{c_{1},c_{2},c_{3}\\}\\subseteq S</span> and <span class="math">i\\in\\{1,2,3\\}</span> the product <span class="math">\\prod_{j\\neq i}(c_{i}-c_{j})</span> divides <span class="math">s</span>. They show that the Bulletproofs protocol using M-SIS commitments and <span class="math">(k,3)</span>-subtractive challenge sets achieves slack <span class="math">k^{\\log n}</span> and knowledge error $\\log n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. They construct a </span>(2,3)<span class="math">-subtractive set of size </span>O(m)<span class="math"> for an order </span>m<span class="math"> power-of-two or cyclotomic ring </span>\\mathcal{R}<span class="math"> and show that it is nearly optimal: there is no </span>(2,3)<span class="math">-subtractive set in such a ring of size greater than </span>m+1<span class="math">. This means that the size of the challenge set is at most linear in the bit-length of the commitments (i.e., polynomial rather than exponential in the security parameter </span>\\lambda<span class="math">), necessitating </span>O(\\lambda/\\log m)$ parallel repetitions of the protocol to amplify soundness. Beyond increasing the communication complexity this also poses difficulties for the security of the Fiat-Shamir transform <em>[x1, x21]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Their upper bounds on the size of <span class="math">(k,r)</span>-subtractive sets relative to <span class="math">k</span> extends to prime-power cyclotomic rings and even larger values of <span class="math">k</span>, suggesting that using small challenge sets (and boosting soundness through parallel repetition) was fundamentally required for achieving a sufficiently small extraction slack, at least based on the prior analysis techniques. <em>[x2]</em> state that “unless fundamentally new techniques are discovered” their impossibility result “represents a barrier to practically efficient lattice-based succinct arguments in the Bulletproof framework”.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">Comparison to our work</h3>

    <p class="text-gray-300">Our work overcomes this barrier, showing that lattice-based Bulletproofs can indeed be instantiated with the exponential-sized challenge set <span class="math">[0,2^{\\lambda})</span> and still achieve sufficiently small slack and stretch. The analysis is based on our variant of the DLSZ lemma for multilinear polynomials mod composite <span class="math">N</span> (i.e., our LCSZ lemma). This also demonstrates compatibility of lattice-based Bulletproofs with the Fiat-Shamir transform. Specifically, our analysis is able to achieve both slack and stretch of <span class="math">2^{O(\\lambda\\log n)}</span> and knowledge error <span class="math">\\lambda n\\cdot 2^{-\\Omega(\\lambda)}</span>. Prior analysis of lattice-Bulletproofs <em>[x1, x1]</em> instantiated with smaller challenges sets required <span class="math">O(\\lambda/\\log(m))</span> parallel repetitions where <span class="math">m</span> is the degree of the cyclotomic polynomial of the ring used for M-SIS commitments. On the other hand, they achieved a smaller slack of <span class="math">2^{O(\\log m\\log n)}</span>, thus allowing for a smaller modulus <span class="math">q</span> than what our analysis of lattice-based Bulletproofs over the challenge set <span class="math">[0,2^{\\lambda})</span> requires. Specifically, with vectors of length <span class="math">n</span> over <span class="math">\\mathbb{Z}_{p}</span>, the modulus <span class="math">q</span> is <span class="math">O(\\log m\\log n+\\log p)</span> bits in their case and <span class="math">O(\\lambda\\log n+\\log p)</span> bits in ours. Overall, for a commitment matrix in <span class="math">\\mathcal{R}^{s\\times n}</span>, according to prior analysis the prover needs to send <span class="math">O(\\kappa m(\\lambda\\log^{2}n+\\log p\\log n\\cdot\\lambda/\\log m))</span> bits whereas according to our analysis the prover needs to send <span class="math">O(\\kappa m(\\lambda\\log^{2}n+\\log p\\log n)</span> bits. The reduction in overall complexity is most significant when <span class="math">\\log p\\gg\\log m\\log n</span>. In other words, this is practically relevant for succinct-arguments applied to statements with a large field size relative to arithmetic complexity (e.g., <span class="math">\\log p=256</span>, <span class="math">\\log m=10</span>, and <span class="math">\\log n=15</span>). An interesting direction for future work is to look at ways to pack the coefficients of vectors over a smaller modulus <span class="math">p^{\\prime}\\ll p</span> into vectors over the larger modulus and still make use of the linear form opening. Another direction is to use an exponential-size challenge set of smaller norm elements (i.e., over the polynomial ring rather than integers), but this would require further generalizations of the LCSZ lemma.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">Comparison of our work to LaBRADOR <em>[x10]</em> <em>[x11]</em> <em>Recently, LaBRADOR, [x10]</em> presented a new argument system for dot product constraints that circumvented the prior limitations of slack and knowledge error in lattice-based arguments that have a recursive structure like Bulletproofs. In contrast to our work, which provides a tighter analysis of the original simple Bulletproofs protocol in the lattice setting without modification, LaBRADOR changes the way the protocol works, allowing the verifier to request additional random linear projections of the committed vectors at each level of recursion, which are folded into prover’s original claim. The projection is a map <span class="math">\\Pi:\\mathbb{Z}^{n}\\to\\mathbb{Z}^{256}</span> with entries sampled randomly and independently from a distribution over <span class="math">\\{-1,0,1\\}</span> with probability <span class="math">1/4</span>, <span class="math">1/2</span>, and <span class="math">1/4</span> respectively. If the prover is committed to <span class="math">\\mathbf{x}</span> then the verifier learns <span class="math">y=\\Pi\\mathbf{x}\\bmod q</span> and checks that its L2 norm is appropriately bounded. Since <span class="math">\\Pi</span> is independent of the challenges used for extraction, the knowledge extractor is able to obtain <span class="math">\\tilde{\\mathbf{x}}</span>, independent of <span class="math">\\Pi</span>, such that <span class="math">\\Pi\\tilde{\\mathbf{x}}\\bmod q</span> has bounded norm. Based on the</h3>

    <p class="text-gray-300">modular Johnson-Lindenstrauss Lemma <em>[x10]</em>, for sufficiently large <span class="math">q</span> this implies on bound on the L2 norm of the extracted vector. This allows for tightly bounding the slack at each level of extraction even when using challenges sampled from an exponential size set over <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300">This is closely related to how we are able to a tighter slack/stretch of the original Bulletproofs protocol without modification, leveraging the fact that final message sent in the protocol is a certain random linear projection of the original vector <span class="math">\\mathbf{x}</span>: it is an evaluation of a multilinear polynomial <span class="math">f_{\\mathbf{x}}</span> with <span class="math">\\log n</span> variables and coefficients <span class="math">\\mathbf{x}</span> on the random challenges <span class="math">c_{1},...,c_{\\log n}</span> sampled by the verifier from <span class="math">[0,2^{\\lambda})</span> in each round. Unlike the analysis of LaBRADOR, our extractor does not operate modulo <span class="math">q</span>. Instead, we allow for slack in the opening of a commitment <span class="math">C</span>, extracting <span class="math">\\bar{\\mathbf{x}}\\in\\mathcal{R}^{n}</span> and <span class="math">s\\in\\mathbb{Z}</span> such that <span class="math">\\mathbf{A}\\bar{\\mathbf{x}}=s\\cdot C\\bmod q</span> and the multilinear polynomial <span class="math">h</span> with rational coefficient vector <span class="math">\\frac{1}{s}\\cdot\\bar{\\mathbf{x}}</span> satisfies <span class="math">h(c_{1},...,c_{\\log n})\\in\\mathbb{Z}</span>. Our analysis applies our new composite Schwartz-Zippel lemma in a similar way to how the modular Johnson-Lindenstrauss lemma functions in the analysis of LaBRADOR. It implies for large <span class="math">s</span> and <span class="math">\\vec{c}=(c_{1},...,c_{\\log n})</span> uniformly distributed independent of <span class="math">h</span> that <span class="math">h(\\vec{c})\\not\\in\\mathbb{Z}</span> with overwhelming probability, thus bounding the size of the slack <span class="math">s</span> for the extracted opening. However, unlike LaBRADOR, the coefficients of <span class="math">g</span> are derived by the extractor using the verifier’s challenges and are thus not independent. This complicates the analysis. We get around this by using 4-ary transcript trees, where <span class="math">h</span> can be extracted from a 3-ary subtree and the challenges <span class="math">c_{1},...,c_{\\log n}</span> come from an independent path. We provide a more detailed overview in the next section.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">DARK and Groups of Unknown Order</h4>

    <p class="text-gray-300">The DARK Polynomial Commitment <em>[x5]</em> is a polynomial commitment with succinct verification using groups of unknown order. If instantiated with class groups (see <em>[x11]</em>) the protocol does not require a trusted setup. The scheme is particularly interesting because of the short proof sizes. Unfortunately, the original scheme had a gap in the security proof that was first discovered by <em>[x3]</em>. This paper provides a fix to this security proof and shows that a slight modification to the original protocol is secure. Our protocol is a generalization that applies to general linear-homomorphisms of which polynomial evaluations are a special case. It also uses a Bulletproofs-style folding which makes it easier to generalize. Concretely, however, the group-of-unknown order instantiation of our protocol has the same concrete efficiencies as the original DARK protocol when used as a polynomial commitment. We also applied the techniques (The CSZ and AMSS) developed in this paper to the original DARK protocol and added that to the appendix of the eprint<em>[x12]</em>. <em>[x3]</em> had originally provided a fix to DARK using binary challenges. This blows up the communication complexity. Concretely each round requires sending <span class="math">\\lambda</span> commitments, whereas we prove that a slight modification of the original DARK protocol is correct, which only requires sending 2 commitments per round. Both <em>[x3]</em> and our scheme are secure under the hidden order assumption (Assumption 1). However, interestingly, when applying the Fiat-Shamir heuristic to AMSS protocols (see full version), we require that the commitment be <em>computationally unique</em>. For the DARK-style commitment in groups of unknown order, this requires the stronger subgroup hidden-order assumption.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Technical overview</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The regular DeMillo-Lipton-Schwartz-Zippel lemma is relatively simple to prove. Consider the special case of a multilinear polynomial over a field. As a base case, a univariate linear polynomial has at most one root over the field. For the induction step, express <span class="math">f(X_{1},...,X_{\\mu+1})=g(X_{1},...,X_{\\mu})+X_{\\mu+1}h(X_{1},...,X_{\\mu})</span> for random variables <span class="math">X_{1},...,X_{\\mu+1}</span>. The probability that <span class="math">h(x_{1},...,x_{n})=0</span> over random <span class="math">x_{i}</span> sampled from <span class="math">S</span> is at most $\\mu/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by the inductive hypothesis, and if </span>h(x_{1},...,x_{\\mu})=w\\neq 0<span class="math"> and </span>g(x_{1},...,x_{\\mu})=u<span class="math">, then </span>u+X_{\\mu+1}w<span class="math"> has at most one root (base case). By the union bound, the overall probability is at most </span>\\mu/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=({\\mu+1})/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. This simple proof does not work for multilinear polynomials modulo a composite integer. The base case is the same for </span>f<span class="math"> coprime to N, which has at most one root. However, in the induction step, it isn’t enough that </span>h(x_{1},...,x_{\\mu})\\neq 0<span class="math"> as it still may be a zero divisor, in which case the polynomial </span>u+X_{\\mu+1}w<span class="math"> is not necessarily coprime to </span>N<span class="math"> and the base case no longer applies. The number of roots depends on </span>\\gcd(u+X_{\\mu+1}w,N)<span class="math"> and our new analysis takes into account its distribution. For each prime divisor </span>p_{i}<span class="math"> of </span>N<span class="math">, the highest power of </span>p_{i}<span class="math"> that divides </span>u+X_{\\mu+1}w<span class="math"> follows a geometric distribution. Using a modified inductive argument, we are able to show that the probability </span>f(x_{1},...,x_{\\mu})\\equiv 0\\bmod p^{r}<span class="math"> is bounded by the probability that </span>\\sum_{i=1}^{n}Z_{i}\\geq r<span class="math"> for </span>i.i.d.<span class="math"> geometric variables with success parameter </span>1-\\frac{1}{p}<span class="math">. This probability is equal to a </span>I_{\\frac{1}{2}}(r,\\mu)<span class="math"> where </span>I<span class="math"> is the regularized beta function. Furthermore, by CRT this probability is independent for each prime factor of </span>N$, and thus, the overall probability can be bounded by a product of regularized beta functions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">“Inverse” multilinear composite Schwartz-Zippel (LCSZ) lemma</h4>

    <p class="text-gray-300">While our main theorem gives a tight bound on the probability for particular values of <span class="math">N,\\mu</span>, and <span class="math">m</span>, cryptographic applications require finding concrete parameters such that the probability is exponentially small in a security parameter <span class="math">\\lambda</span>. Concretely, we want to find a value <span class="math">N^{<em>}</span> such that for all <span class="math">N\\geq N^{</em>}</span> the probability that <span class="math">f(X_{1},...,X_{\\mu})\\equiv 0\\bmod N</span> is bounded by <span class="math">2^{-\\lambda}</span>. To do this, we first derive simple and useful bounds for the regularized beta function:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">I_{\\frac{1}{p}}(r,\\mu)\\leq\\left(\\frac{n}{p}\\right)^{r}</span> for <span class="math">p\\geq 2\\mu</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">I_{\\frac{1}{2}}(r,\\mu)\\leq\\frac{r^{\\alpha}}{p^{r}}</span> for <span class="math">r\\geq 2\\mu</span></li>

      <li><span class="math">\\log(I_{1/p}(r-1,\\mu))-\\log(I_{1/p}(r,\\mu))</span> is non-increasing in <span class="math">r</span> for any <span class="math">p&gt;\\mu</span> and for <span class="math">r=1</span> in <span class="math">p</span>.</li>

    </ul>

    <p class="text-gray-300">We then formulate finding <span class="math">N^{<em>}</span> as an optimization problem. <span class="math">N^{</em>}</span> is the maximum value of <span class="math">N</span> such that the probability of <span class="math">f(\\mathbf{x})\\equiv 0\\bmod N</span> is greater than <span class="math">2^{-\\lambda}</span>. For any <span class="math">N</span> let <span class="math">S(N)</span> denote the set of pairs <span class="math">(p,r)</span> where <span class="math">p</span> is a prime divisor of <span class="math">N</span> with multiplicity <span class="math">r</span>. Taking the logarithm of both the objective and the constraint yields a knapsack-like constraint maximization problem where the objective is <span class="math">\\log(N^{<em>})=\\sum_{(p_{i},r_{i})\\in S(N^{</em>})}r_{i}\\cdot\\log(p_{i})</span> and the constraint is <span class="math">\\sum_{(p_{i},r_{i})\\in S(N^{<em>})}-\\log(I_{\\frac{1}{r_{i}}}(r,\\mu))\\leq\\lambda</span>. Using the bounds on <span class="math">I_{\\frac{1}{r_{i}}}</span> and several transformations of the problem we show that any optimal solution to this problem must be bounded by <span class="math">t=8\\mu^{2}+\\log_{2}(2\\mu)\\lambda</span>, which in turn implies that <span class="math">N^{</em>}\\leq 2^{t}</span>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Tighter computational solution</h4>

    <p class="text-gray-300">We further show that a simple greedy knapsack algorithm computes an upper bound to the knapsack problem. The algorithm uses the fact that <span class="math">\\frac{\\log(p)}{\\log(I_{1/p}(r-1,\\mu))-\\log(I_{1/p}(r,\\mu))}</span> the so-called marginal density of each item is non increasing over certain regions. Adding the densest items to the knapsack computes an upper bound to the objective. We run the algorithm on a large number of values for <span class="math">\\mu</span> and <span class="math">\\lambda</span> and report the result.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.1 Bulletproofs for Short Pre-Images and Almost Special Soundness</h3>

    <p class="text-gray-300">In the Bulletproofs Inner Product Argument a prover convinces a verifier that it knows the opening <span class="math">\\mathbf{f}\\in\\mathbb{F}_{p}^{n}</span> to a homomorphic commitment <span class="math">C=\\mathsf{com}(\\mathbf{f})\\in\\mathbb{G}</span> where <span class="math">\\mathbb{G}</span> is a prime-order group. At a very high level, it does this by iteratively computing <span class="math">\\vec{f}^{t}=\\mathbf{f}_{L}+x\\cdot\\mathbf{f}_{R}\\in\\mathbb{F}^{n/2}</span>, where <span class="math">\\mathbf{f}_{L},\\mathbf{f}_{R}</span> are the left and right half of <span class="math">\\mathbf{f}</span> respectively and <span class="math">x\\in\\mathbb{F}</span> is a verifier generated challenge, and sending a commitment to the new <span class="math">\\mathbf{f}^{t}</span> to the verifier. After <span class="math">\\log_{2}(n)</span> rounds, the prover sends a single field element as the final message. This naturally generalizes to homomorphic commitments that map vectors in <span class="math">\\mathbb{Z}^{n}</span> to a group <span class="math">\\mathbb{G}</span>. The Bulletproofs protocol operates in exactly the same way over integer vectors but using more general instantiations of the commitment scheme. In particular, we consider schemes that may only be binding to <em>short</em> vectors in <span class="math">\\mathbb{Z}^{n}</span>, such as the DARK commitment using groups of unknown order or lattice-based (Ajtai) commitments. Additionally, the verifier checks that the final message is a “small” integer. Furthermore, we consider commitments that are binding under what we call <em>short rational openings</em> that open <span class="math">C</span> to <span class="math">\\mathbf{h}=\\mathbf{f}/s</span> by showing <span class="math">s\\cdot C=\\mathsf{com}(\\mathbf{f})</span>, where the numerator and denominator of <span class="math">\\mathbf{h}</span> have bounded norms in reduced form. We consider such rational openings due to “slack” in the knowledge extractor for Bulletproofs over rings like <span class="math">\\mathbb{Z}</span> instead of fields, where the extractor obtains <span class="math">\\mathbf{f}</span> and <span class="math">s</span> satisfying <span class="math">s\\cdot C=\\mathsf{com}(\\mathbf{f})</span>, but cannot invert <span class="math">s</span> to obtain a direct pre-image of <span class="math">C</span>. In the soundness analysis, we leverage the fact that the final integer is small in order to bound the numerator/denominator (i.e., stretch and slack) of the extracted opening. This is where we invoke the new LCSZ lemma for multilinear polynomials. To gain some intuition in how we apply LCSZ, if the prover’s private state at the start of protocol were a rational vector <span class="math">\\mathbf{f}/s</span> such that <span class="math">\\mathsf{com}(\\mathbf{f})=s\\cdot C</span>, then running protocol would result in an integer <span class="math">y</span> that is the evaluation of a multilinear polynomial <span class="math">h</span> with rational coefficients <span class="math">\\vec{f}/s</span> at the <span class="math">\\log_{2}(n)</span> challenges <span class="math">\\vec{c}=(c_{1},...,c_{\\log n})</span> sampled by the verifier, i.e. <span class="math">y=h(\\vec{c})</span>. Equivalently, <span class="math">f(\\vec{c})\\equiv 0\\bmod s</span>. If <span class="math">\\vec{c}</span> were sampled uniformly and independent from <span class="math">f</span>, then the LCSZ lemma states that as <span class="math">s</span> grows too large this probability becomes vanishingly small.</p>

    <p class="text-gray-300">For commitments binding over <span class="math">\\mathbb{Z}_{p}</span>, Bulletproofs satisfies special-soundness: there exists an efficient extractor that can extract a witness (i.e., an opening to the input commitment) from <em>any</em> forking tree of transcripts. Special-soundness implies knowledge-soundness by the classic <em>forking lemma</em>, which shows how to generate a transcript tree in polynomial time. Unfortunately, Bulletproofs with commitments that are only binding over small norm (rational) openings fails to satisfy special-soundness because the opening extracted from a forking tree of transcripts may have a very large norm (i.e., large slack or stretch). On the other hand, it turns out that we can leverage the intuition above in order to bound the size (slack and stretch) of extracted openings. Along the way, we introduce a new notion called almost-special soundness.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Almost Special Soundness</h4>

    <p class="text-gray-300">A <span class="math">k</span>-ary transcript tree for a <span class="math">\\mu</span>-round public-coin interactive proof labels each node of a <span class="math">k</span>-ary <span class="math">\\mu</span>-depth tree with a prover message and each edge with a verifier public-coin challenge so that the labels along any root-to-leaf path in the tree form a valid transcript between the prover and verifier that would cause the verifier to accept. An interactive proof for a relation <span class="math">\\mathcal{R}</span> is <span class="math">k^{(\\mu)}</span>-special-sound if there exists an extractor that can efficiently extract a witness <span class="math">\\mathsf{w}</span> from any <span class="math">k</span>-ary tree of protocol transcripts for input <span class="math">\\mathsf{x}</span> so that <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>. Bulletproofs for standard Pedersen vector commitments has this property for 3-ary trees, but not for vector commitments with bounded-norm openings because the extractor may obtain an opening that has a too large norm. On the other hand, if a prover running the protocol honestly were to start in its head with an opening of the commitment that has a too large norm there is a negligible probability over the random challenges that it would result in a valid transcript, whose last message is an integer of bounded norm. This applies to rational openings as well with a large norm numerator or denominator. This probability analysis relies on LCSZ, as explained in the paragraph above. We will say that rational openings have “large. norm” if they have either a large numerator (stretch), large denominator (slack), or both.</p>

    <p class="text-gray-300">This observation suggests the following strawman extraction analysis: show that one of the valid transcripts in the tree corresponds to running the honest prover on the extracted opening, and conclude that if the extracted rational opening had large norm then it would have a negligible probability of resulting in a valid transcript. A fallacy in this argument is that the extracted witness is computed from the transcripts, and is thus dependent on the challenges appearing in the transcripts, whereas running the prover on a large norm opening only results in an invalid transcript with high probability over challenges sampled independently from this opening. To address this we could attempt the following: generate a 4-ary tree <span class="math">T</span> via rejection sampling from polynomially many random simulations, extract an opening <span class="math">\\mathbf{w}^{<em>}</span> from its 3-ary left subtree <span class="math">T_{L}</span>, show that some transcript <span class="math">\\mathbf{tr}</span> in <span class="math">T\\setminus T_{L}</span> is the result of running the prover on <span class="math">\\mathbf{w}^{</em>}</span>. The extracted witness is now independent of the challenges appearing in <span class="math">\\mathbf{tr}</span> and was well-defined during the generation of <span class="math">T</span>, after <span class="math">T_{L}</span> was created and before <span class="math">\\mathbf{tr}</span> was added. Given that <span class="math">T</span> was generated via polynomially many random simulations we can argue this event had a negligible probability of occurring.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The remaining challenge, however, is to show that some transcript <span class="math">\\mathbf{tr}</span> in <span class="math">T\\setminus T_{L}</span> is consistent with running the honest prover on the extracted opening <span class="math">\\mathbf{w}^{*}</span>. It turns out that for protocols like Bulletproofs this is only true when the extracted opening of the input commitment is within the space over which the scheme is binding, which seems to bring us back to square one. For example, the transcript for a single round (Bulletproofs protocol over an input commitment <span class="math">C</span> to a vector in <span class="math">\\mathbb{Z}^{2}</span> and commitment basis <span class="math">\\mathbf{g}=(g_{L},g_{R})\\in\\mathbb{G}^{2}</span> consists of <span class="math">(C,C_{L},C_{R},r,f^{\\prime})\\in\\mathbb{G}^{3}\\times\\mathbb{Z}</span> such that <span class="math">f^{\\prime}\\cdot(g_{R}+rg_{L})=C_{R}+r^{2}C_{L}+rC</span>. Given an opening <span class="math">\\mathbf{f}=(f_{L},f_{R})</span> such that <span class="math">\\mathsf{com}(\\mathbf{f})=(\\mathbf{f},\\mathbf{g})=C</span> and $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0,f_{L}),\\mathbf{g})=C_{L}<span class="math"> and </span>\\langle(f_{R},0),\\mathbf{g}\\rangle=C_{R}<span class="math"> then “re-running” the protocol on the openings with challenge </span>r<span class="math"> gives </span>f^{<em>}=f_{L}+r\\cdot f_{R}<span class="math"> such that </span>f^{</em>}\\cdot(g_{R}+rg_{L})=C_{R}+r^{2}C_{L}+rC=C^{<em>}<span class="math">. If </span>f^{</em>}<span class="math"> is sufficiently small then this implies </span>f^{<em>}=f^{\\prime}<span class="math">, otherwise it is a break of the commitment scheme as it provides conflicting openings to </span>C^{</em>}<span class="math">. However, </span>f^{*}<span class="math"> is only guaranteed to be small if the extracted opening </span>\\mathbf{f}$ has low norm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To get around this issue, we can increase the parameters of the commitment scheme so that it is binding over slightly larger openings, and we will argue level by level that the extracted openings remain small (using the independent path and the fact that re-generation of transcripts either returns the same commitments/messages or a break of the commitment scheme). In other words, while we want to show that every extracted value remains below some norm bound <span class="math">A</span>, each extraction step produces a value that might be as large as some bound <span class="math">B&gt;A</span>, but for which the scheme is still binding, and thus re-running the protocol on this value will conflict with some path in the transcript tree with overwhelmingly high probability if too much larger than <span class="math">A</span>. This is precisely where we apply our new LCSZ lemma. If the extracted opening with numerator <span class="math">\\mathbf{f}</span> and denominator <span class="math">s</span> has too large norm then re-running the protocol with this opening as the prover’s private state and using the challenges <span class="math">c_{1},...,c_{\\mu}</span> from the independent path would conflict with the transcript along the independent path (the final message will not be a small integer) except with negligible probability over the random challenges. The final message is equal to the evaluation <span class="math">h(c_{1},...,c_{\\mu})</span> where <span class="math">h</span> is a multilinear polynomial with coefficient vector <span class="math">\\mathbf{f}/s</span>. This allows us to bound the norm growth at each level by some sufficiently small value <span class="math">C\\in(A,B)</span>. Crucially, while the growth from <span class="math">A</span> to <span class="math">B</span> is at least quadratic in <span class="math">A</span>, the growth from <span class="math">A</span> to <span class="math">C</span> will be constant.</p>

    <p class="text-gray-300">We generalize this to the notion of Almost Special Sound(AMSS) protocols and replace the bounds A and B with arbitrary predicates <span class="math">\\phi_{a}</span> and <span class="math">\\phi_{b}</span>. We prove that all protocols with this structure are knowledge sound, just like special-sound protocols, where the knowledge error is dependent on the probability that a random completion of a transcript starting from a message that fails predicate <span class="math">\\phi_{a}</span> results in a valid transcript. Intuitively, this captures the fact that once the adversary has a private state that fails the desired extraction predicate, it will fail with overwhelming probability over fresh challenges to complete the proof transcript successfully.</p>

    <p class="text-gray-300">Our proof that AMSS implies knowledge-soundness relies on a lemma that we call the path predicate forking lemma. The usual forking lemma shows how to generate forking transcript tree, which in special-sound protocols can be passed directly to the extractor. In our case, we need to generate transcript tree that satisfies additional predicates on each node. In the standard forking lemma <em>[x10]</em>, the predicate would simply be that challenges on each child of a node in the transcript tree are distinct from previous challenges. Our new lemma considers more general predicates, which may depend on partial transcripts that have already been generated in the course of the transcript generation algorithm. The analysis is similar and uses a union bound over all polynomial steps of the transcript tree generation process.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Fiat-Shamir transform</h4>

    <p class="text-gray-300">The analysis showing that AMSS protocols are knowledge-sound critically relies on the fact that in the transcript tree generation process for an interactive protocol, the challenges on any given branch are sampled uniformly and independently. This is used to show that the transcript tree generated satisfies a certain property with overwhelming probability. The Fiat-Shamir transform converts an interactive public-coin protocol into a non-interactive protocol by replacing the verifier’s messages with a transcript hash. The problem with applying the Fiat-Shamir transform to an AMSS protocol is that the adversary can now grind the challenges in each round when generating a transcript, breaking uniformity and independence of challenges. Using a union bound, we could still bound the probability that the transcript tree does not have the desired property, but this would result in a factor <span class="math">Q^{\\mu}</span> loss where <span class="math">Q</span> is the number of queries an adversary performs, and <span class="math">\\mu</span> is the number of rounds in the protocol. However, we can instead focus on protocols where grinding challenges is impossible for the</p>

    <p class="text-gray-300">adversary. To do this, we introduce the notion of <em>computationally unique</em> commitments. In a computationally unique commitment scheme, it is infeasible to open two distinct commitments to the same message. We prove that this property is held by a large class of deterministic homomorphic commitment schemes, which include those from groups of unknown order and lattice assumptions. We prove security of the Fiat-Shamir transform for AMSS protocols in the random oracle model with computationally unique commitments. This analysis is in the full version.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3 Main theorem statement (LCSZ)</h2>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 1 (Multilinear Composite Schwartz-Zippel (LCSZ)).</h6>

    <p class="text-gray-300">Let <span class="math">N=\\prod_{i=1}^{\\ell}p_{i}^{r_{i}}</span> for distinct primes <span class="math">p_{1},...,p_{\\ell}</span>. Let <span class="math">f</span> be any <span class="math">\\mu</span>-linear integer polynomial co-prime to <span class="math">N</span>. For any integer <span class="math">m&gt;1</span> and <span class="math">\\mathbf{x}</span> sampled uniformly from <span class="math">[0,m)^{\\mu}</span>, then</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}_{\\mathbf{x}\\leftarrow[0,m)^{\\mu}}[f(\\mathbf{x})\\equiv 0\\bmod N]\\leq\\frac{\\mu}{m}+\\prod_{i=1}^{\\ell}I_{\\frac{1}{r_{i}}}(r_{i},\\mu),</span></p>

    <p class="text-gray-300">where <span class="math">I_{\\frac{1}{r}}(r,\\mu)=(1-\\frac{1}{\\mu})^{\\mu}\\sum_{j=r}^{\\infty}\\binom{\\mu+r-1}{r}\\left(\\frac{1}{\\mu}\\right)^{j}</span> is the regularized beta function.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">The regularized beta function characterizes the tail distribution of the sum of independent geometric random variables. If <span class="math">Y=\\sum_{i=1}^{\\mu}Z_{i}</span> where each <span class="math">Z_{i}</span> is an independent geometric random variable with parameter <span class="math">\\epsilon</span> then <span class="math">P[Y\\geq r]=I_{1-\\epsilon}(r,\\mu)</span>. <span class="math">Y</span> is a negative binomial variable with parameters <span class="math">\\epsilon,\\mu</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A close reading of the proof reveals that if <span class="math">m=N</span>, then the theorem statement simplifies to <span class="math">\\mathbb{P}_{\\mathbf{x}\\leftarrow[0,N)^{\\mu}}[f(\\mathbf{x})\\equiv 0\\bmod N]\\leq\\prod_{i=1}^{\\ell}I_{\\frac{1}{r_{i}}}(r_{i},\\mu)</span>. This is because <span class="math">\\mathbf{x}</span> is uniform mod <span class="math">\\mathbb{N}</span> and thus uniform mod any $N^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-23" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">The theorem is nearly tight for all <span class="math">N</span>. Setting <span class="math">f(\\mathbf{x})=\\prod_{i=1}^{\\mu}x_{i}</span> and <span class="math">m=N</span> gives <span class="math">P_{\\mathbf{x}\\leftarrow[0,m)^{\\mu}}[f(\\mathbf{x})\\equiv 0\\bmod N]=\\mathbb{P}_{\\mathbf{x}\\leftarrow[0,N)^{\\mu}}[f(\\mathbf{x})\\equiv 0\\bmod N]=\\prod_{i=1}^{\\ell}I_{\\frac{1}{r_{i}}}(r_{i},\\mu)</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">1-e^{-\\mu/p_{i}}\\leq I_{\\frac{1}{r_{i}}}(1,\\mu)=1-(1-\\frac{1}{p_{i}})^{\\mu}\\leq\\frac{\\mu}{p_{i}}</span>. Hence, for square-free <span class="math">N</span> the probability in Theorem 1 is upper bounded by <span class="math">\\frac{\\mu}{m}+\\frac{\\mu^{\\ell}}{N}</span>, but for <span class="math">\\ell&gt;1</span> this is a loose upper bound unless <span class="math">\\mu\\ll p_{i}</span> for all $p_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N<span class="math">. For </span>\\ell=1<span class="math"> (i.e., prime </span>N$), Theorem 1 coincides with the Schwartz-Zippel lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 5.</h6>

    <p class="text-gray-300"><span class="math">I_{\\frac{1}{r_{i}}}(r_{i},1)=\\left(\\frac{1}{p_{i}}\\right)^{r_{i}}.</span> Hence, for <span class="math">\\mu=1</span>, the bound in Theorem 1 is <span class="math">\\frac{1}{N}+\\frac{1}{m}</span>.</p>

    <p class="text-gray-300">We defer the proof of Theorem 1 to Appendix A.1.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 Inverse LCSZ</h2>

    <p class="text-gray-300">Theorem 1 (LCSZ) bounds the probability <span class="math">\\mathbb{P}_{\\mathbf{x}\\leftarrow[0,m)^{\\mu}}[f(\\mathbf{x}\\equiv 0\\bmod N]</span> for given values of <span class="math">\\mu,N</span>, and <span class="math">m</span>, which has the form <span class="math">\\frac{\\mu}{m}+\\delta_{N,\\mu}</span>. In the case that <span class="math">N</span> is prime, <span class="math">\\delta_{N,\\mu}=\\frac{\\mu}{N}</span>, which agrees with the standard Schwartz-Zippel lemma applied to <span class="math">\\mu</span>-linear polynomials. The term <span class="math">\\delta_{N,\\mu}</span> for composite <span class="math">N</span>, which is dependent on both <span class="math">\\mu</span> and the factorization of <span class="math">N</span>, has a complicated closed form expression in terms of a product of regularized beta functions.</p>

    <p class="text-gray-300">This section analyzes the inverse: for a given <span class="math">\\mu,\\lambda\\in\\mathbb{N}</span> what size threshold <span class="math">t(\\lambda,\\mu)\\in\\mathbb{N}</span> is sufficient such that <span class="math">\\delta_{N,\\mu}\\leq 2^{-\\lambda}</span> for all <span class="math">N\\geq t(\\lambda,\\mu)</span>? In other words:</p>

    <p class="text-gray-300"><span class="math">t(\\lambda,\\mu):=\\sup\\{N\\in\\mathbb{N}:\\prod_{(p,r)\\in S(N)}I_{\\frac{1}{p}}(r,\\mu)\\geq 2^{-\\lambda}\\}.</span> (<span class="math">t(\\lambda,\\mu)</span> def)</p>

    <p class="text-gray-300">For <span class="math">\\mu=1</span>, since <span class="math">I_{1/p}(r,1)=\\frac{1}{p^{r}}</span> and <span class="math">\\prod_{(p,r)\\in S(N)}I_{\\frac{1}{p}}(r,\\mu)=\\frac{1}{N}</span>, it is easy to see that <span class="math">t(\\lambda,\\mu)=2^{\\lambda}</span>. For <span class="math">\\mu\\geq 2</span>, the value of <span class="math">t(\\lambda,\\mu)</span> (or even an upper bound) is not nearly as easy to derive. For the rest of this section we will focus on this <span class="math">\\mu\\geq 2</span> case. We will analytically derive an upper bound to <span class="math">t(\\lambda,\\mu)</span>, showing that <span class="math">\\log t(\\lambda,\\mu)\\in O(\\mu^{2+\\epsilon}+\\frac{\\lambda}{\\epsilon})</span> for any <span class="math">\\epsilon\\geq\\log_{\\mu}(2)</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 2 (Inverse LCSZ).</h6>

    <p class="text-gray-300">For all <span class="math">\\mu\\geq 2</span>, <span class="math">\\epsilon\\geq\\log_{\\mu}(2)</span>, and all <span class="math">N</span> such that</p>

    <p class="text-gray-300"><span class="math">\\log N\\geq 4\\mu^{2+\\epsilon}+(1+\\frac{1}{\\epsilon})\\cdot\\lambda.</span></p>

    <p class="text-gray-300">we have that for any <span class="math">\\mu</span>-linear polynomial <span class="math">f</span> that is coprime with <span class="math">N</span></p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}_{x\\leftarrow[0,m)^{\\mu}}[f(x)\\equiv 0\\bmod N]\\leq 2^{-\\lambda}+\\frac{\\mu}{m}.</span></p>

    <p class="text-gray-300">By setting <span class="math">\\epsilon=\\log_{\\mu}(2)</span> we get:</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">For all <span class="math">N</span> such that</p>

    <p class="text-gray-300"><span class="math">\\log N\\geq 8\\mu^{2}+\\log_{2}(2\\mu)\\cdot\\lambda.</span></p>

    <p class="text-gray-300">we have that for any <span class="math">n</span>-linear polynomial <span class="math">f</span> that is coprime with <span class="math">N</span></p>

    <p class="text-gray-300"><span class="math">P_{x\\leftarrow[0,m)^{\\mu}}[f(x)\\equiv 0\\bmod N]\\leq 2^{-\\lambda}+\\frac{\\mu}{m}.</span></p>

    <p class="text-gray-300">We defer the proof of Theorem 2 to Appendix A.3</p>

    <p class="text-gray-300">Theorem 2 provides an analytical upper bound on  <span class="math">t(\\lambda, \\mu)</span>  for any  <span class="math">\\mu, \\lambda \\in \\mathbb{N}</span> . However, the analytical bound does not appear to be tight for  <span class="math">\\mu \\geq 2</span>  (for  <span class="math">\\mu = 1</span>  it is tight). This next section provides an algorithm to derive an upper bound on  <span class="math">t(\\lambda, \\mu)</span>  for any specific values of  <span class="math">\\lambda, \\mu</span> . The algorithm gives tighter bounds than Theorem 2 for a table of tested values (Table 1). This is useful in practice, e.g. for deriving concrete cryptographic security parameters in cryptographic protocols that rely on LCSZ.</p>

    <p class="text-gray-300">Algorithm 1 Greedy algorithm that returns an upper bound to Eq. (Constrained Max 2) Input  <span class="math">\\mu \\in \\mathbb{N},\\lambda \\in \\mathbb{N}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize a max heap  <span class="math">H</span>  that stores tuples  <span class="math">(p,r,d)\\in \\mathbb{P}\\times \\mathbb{Z}\\times \\mathbb{R}</span>  and sorts them by the third value.</li>

      <li>Initialize  <span class="math">w\\gets 0</span>  and  <span class="math">v\\gets 0</span></li>

      <li>Push (density(2,1),2,1) onto the heap and set pmax  <span class="math">= 2</span></li>

      <li>While  <span class="math">w &amp;lt;   \\lambda</span></li>

      <li>(a) Pop  <span class="math">(p,r,d)</span>  from  <span class="math">H</span></li>

    </ol>

    <p class="text-gray-300">(b) Push  <span class="math">(p,r + 1</span>  ,(density  <span class="math">(p,r + 1))</span>  onto  <span class="math">H</span> (c) Set  <span class="math">v\\gets v + \\mathrm{val}(p,r)</span> (d) Set  <span class="math">w\\gets w + \\mathrm{weight}(p,r)</span> (e) If  <span class="math">p = \\mathrm{pmax}</span>  then set pmax  <span class="math">\\leftarrow</span>  next_prime(p) and push (density(pmax,1),pmax,1) onto  <span class="math">H</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">v</span></li>

    </ol>

    <p class="text-gray-300">Theorem 3 (Computational bound). Let  <span class="math">k</span>  be the output of algorithm Algorithm 1 on input  <span class="math">\\lambda, \\mu</span> . Then for all  <span class="math">m \\in \\mathbb{N}</span> , all  <span class="math">N \\geq 2^k</span>  and all  <span class="math">\\mu</span> -linear polynomials  <span class="math">f</span> , coprime with  <span class="math">N</span> ,  <span class="math">\\log_2 N \\geq t(\\lambda, \\mu)</span>  and</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P _ {\\mathbf {x} \\leftarrow</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0, m) ^ {\\mu}} [ f (\\mathbf {x}) \\equiv 0 \\bmod N ] \\leq 2 ^ {- \\lambda} + \\frac {\\mu}{m}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The proof of the Theorem is in Appendix A.4.</p>

    <p class="text-gray-300">Using Algorithm 1 we computed analytical bounds for all  <span class="math">\\mu \\in (1,50)</span>  for different values of  <span class="math">\\lambda</span> . The precise bound for  <span class="math">\\mu = 20</span>  and  <span class="math">\\lambda = 120</span>  is:</p>

    <p class="text-gray-300"><span class="math">2^{c}\\geq 2^{36}\\cdot 3^{20}\\cdot 5^{11}\\cdot 7^{8}\\cdot 11^{5}\\cdot 13^{5}\\cdot 17^{4}\\cdot 19^{3}\\cdot 23^{3}\\cdot 29^{2}\\cdot 31^{2}\\cdot 37^{2}\\cdot 41^{2}\\cdot 43^{2}\\cdot 47^{2}\\cdot 53^{2}\\cdot 59\\cdot 61\\cdot 67</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>71 - 73 - 79 - 83 - 89 - 97 - 101 - 103 - 107 - 109 - 113 - 127 - 131 - 137 - 139 - 149 - 151 - 157 - 163</li>

    </ul>

    <p class="text-gray-300">Other results are presented in their logarithmic form in Table 1. The results are significantly tighter than the analytical Theorem 2. For  <span class="math">n = 20</span>  and  <span class="math">\\lambda = 120</span>  the analytical theorem gives a value for  <span class="math">\\log_2(N)</span>  of 3839 vs the computational which is 416. We also provide the open-source Python implementation of the algorithm <span class="math">^3</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">μ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 40</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 120</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 240</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">μ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 40</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 120</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 240</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">241</td>

            <td class="px-3 py-2 border-b border-gray-700">472</td>

            <td class="px-3 py-2 border-b border-gray-700">758</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">289</td>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">248</td>

            <td class="px-3 py-2 border-b border-gray-700">481</td>

            <td class="px-3 py-2 border-b border-gray-700">772</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">207</td>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">679</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">492</td>

            <td class="px-3 py-2 border-b border-gray-700">792</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">429</td>

            <td class="px-3 py-2 border-b border-gray-700">695</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">506</td>

            <td class="px-3 py-2 border-b border-gray-700">806</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">222</td>

            <td class="px-3 py-2 border-b border-gray-700">437</td>

            <td class="px-3 py-2 border-b border-gray-700">718</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">275</td>

            <td class="px-3 py-2 border-b border-gray-700">516</td>

            <td class="px-3 py-2 border-b border-gray-700">820</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

            <td class="px-3 py-2 border-b border-gray-700">732</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">278</td>

            <td class="px-3 py-2 border-b border-gray-700">527</td>

            <td class="px-3 py-2 border-b border-gray-700">831</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">233</td>

            <td class="px-3 py-2 border-b border-gray-700">464</td>

            <td class="px-3 py-2 border-b border-gray-700">749</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">419</td>

            <td class="px-3 py-2 border-b border-gray-700">736</td>

            <td class="px-3 py-2 border-b border-gray-700">1105</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1: Computationally determined values of  <span class="math">t(\\lambda, \\mu)</span>  such that for all  <span class="math">N \\geq t(\\lambda, \\mu)</span> ,  $\\mathbb{P}_{\\mathbf{x} \\leftarrow</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0, m\\rangle^{\\mu}}[f(\\mathbf{x}) \\equiv 0 \\bmod N] \\leq 2^{-\\lambda} + \\frac{\\mu}{m}<span class="math">  for different  </span>\\mu<span class="math">  and different  </span>\\lambda$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  <span class="math">f</span>  is a multivariate polynomial, then  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  denotes the maximum over the absolute values of all coefficients of  </span>f$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-33" class="text-base font-medium mt-4">Lemma 1 (Evaluation Bound).</h6>

    <p class="text-gray-300">For any <span class="math">\\mu</span>-linear integer polynomial <span class="math">f</span> and <span class="math">m\\geq 2</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{P}_{\\mathbf{x}\\leftarrow[0,m]^{\\mu}}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\mathbf{x})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{1}{m^{\\mu}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}]\\leq\\frac{3\\mu}{m}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">f^{(0)}:=f</span>. Given a vector <span class="math">\\mathbf{x}=(x_{1},..,x_{\\mu})</span>, for each <span class="math">j\\in[1,\\mu]</span> define <span class="math">f_{\\mathbf{x}}^{(j)}</span> to be the <span class="math">\\mu-j</span>-variate partial evaluation <span class="math">f_{\\mathbf{x}}^{(j)}:=f(x_{1},...,x_{j},X_{j+1},...,X_{\\mu})</span>. Then we can rewrite the lemma statement as:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P_{\\mathbf{x}\\leftarrow[0,m]^{\\mu}}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(\\mu)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\frac{1}{m^{\\mu}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}]\\leq\\frac{3\\mu}{m}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will bound the probability for random <span class="math">\\mathbf{x}</span> that there exists any <span class="math">j</span> for which $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If no such </span>j<span class="math"> exists, then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f^{(\\mu)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1}{m^{\\mu}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">j</span>, we can write <span class="math">f_{\\mathbf{x}}^{(j)}=g(X_{j+1},...,X_{\\mu})+x_{j}\\cdot h(X_{j+1},...,X_{\\mu})</span> where <span class="math">g,h</span> are <span class="math">\\mu-j</span> variate multilinear integer polynomials and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> because the coefficients of </span>g<span class="math"> and </span>h<span class="math"> are a partition of the coefficients of </span>f_{\\mathbf{x}}^{(j-1)}<span class="math">. Suppose now that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, i.e. that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ and consider two cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 1: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. For any integer </span>\\Delta\\neq 0$, using the triangle inequality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+(x_{j}+\\Delta)h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}h+\\Delta h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>{(1-\\frac{1}{m})\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The last part of the inequality holds because <span class="math">1-\\frac{1}{m}\\geq\\frac{1}{m}</span> for any <span class="math">m\\geq 2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case2: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Using the triangle inequality,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{1}{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This implies, for <span class="math">m\\geq 2</span>, that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ because:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>{(1-\\frac{1}{m})\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\implies</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{m-1}{x_{j}\\cdot m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1}{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The last step uses that <span class="math">x_{j}\\in[1,m)</span>. For <span class="math">x_{j}=0</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Finally, for any integer </span>\\Delta$, by the triangle inequality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+(x_{j}+\\Delta)\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2<span class="math"> this implies that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+(x_{j}+\\Delta)\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In both cases, we conclude that for any choice of <span class="math">(x_{1},...,x_{j-1})</span> for the first <span class="math">j-1</span> components of the random <span class="math">\\mathbf{x}</span>, which define <span class="math">g</span> and <span class="math">h</span>, there are at most three choices of <span class="math">x_{j}</span> such that the event $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> holds true (i.e., if true for </span>x_{j}<span class="math">, then it is also true for at most </span>x_{j}+1<span class="math"> and </span>x_{j}-1<span class="math">). Thus this event occurs with probability at most </span>\\frac{3}{m}<span class="math">. Finally, by a union bound over </span>j<span class="math">, the probability this event occurs for some index </span>j<span class="math"> is at most </span>\\frac{3\\mu}{m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Fact 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">q\\in\\mathbb{Z}</span> be any positive integer. For any integer <span class="math">E\\in\\mathbb{Z}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{q^{d+2}-q}{2(q-1)}<span class="math"> there exists a unique degree </span>d<span class="math"> integer polynomial </span>f\\in\\mathbb{Z}[X]<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq q/2<span class="math"> such that </span>f(q)=E$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 2 (Rational Encoding of multi-linear polynomials).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">q\\in\\mathbb{Z}</span> be any positive integer. Let $\\vec{q}=[q^{2^{l-1}}]_{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1}^{\\mu}\\in\\mathbb{Z}^{\\mu}<span class="math">. Consider any </span>\\beta_{d},\\beta_{n}\\in\\mathbb{N}<span class="math"> such that </span>\\beta_{d}\\cdot\\beta_{n}\\leq\\frac{q}{2}<span class="math">. Let </span>Z=\\{z\\in\\mathbb{Z}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta_{d}\\}<span class="math">, let </span>\\mathcal{F}=\\{f\\in\\mathbb{Z}[X_{1},\\ldots,X_{\\mu}]:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta_{n}\\}<span class="math"> be a </span>\\mu<span class="math">-linear polynomial, and let </span>\\mathcal{H}=\\{f/z\\in\\mathbb{Q}[X_{1},\\ldots X_{\\mu}]:f\\in\\mathcal{F}\\wedge z\\in Z\\}<span class="math">. Then for any </span>h_{1},h_{2}\\in\\mathcal{H}<span class="math">, if </span>h_{1}(\\vec{q})=h_{2}(\\vec{q})<span class="math"> then </span>h_{1}=h_{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">h_{1}=\\frac{f_{1}}{z_{1}}</span> and <span class="math">h_{2}=\\frac{f_{2}}{z_{2}}</span>. If <span class="math">h_{1}(\\vec{q})=h_{2}(\\vec{q})</span> then <span class="math">z_{1}f_{2}(\\vec{q})=z_{2}f_{1}(\\vec{q})</span>. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{2}\\cdot f_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta_{d}\\cdot\\beta_{n}\\leq\\frac{q}{2}<span class="math"> and likewise </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{1}\\cdot f_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\frac{q}{2}<span class="math">. Note that there exist a unique univariate degree </span>2^{\\mu}-1<span class="math"> polynomial </span>\\hat{f}_{1}<span class="math"> that has the same coefficients as </span>f_{1}<span class="math"> such that for all </span>q<span class="math"> </span>f_{1}(\\vec{q})=\\hat{f}_{1}(q)<span class="math">. Let </span>f_{2}<span class="math"> be the univariate degree </span>2^{\\mu}-1<span class="math"> polynomial with the same coefficients as </span>\\hat{f}_{2}<span class="math">. It then follows from Fact 1 that if </span>z_{1}f_{2}(\\vec{q})=z_{1}\\hat{f}_{2}(q)=z_{2}\\hat{f}_{1}(q)=z_{2}f_{1}(\\vec{q})<span class="math"> then </span>z_{1}f_{2}=z_{2}f_{1}<span class="math">, or equivalently, </span>h_{1}=h_{2}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">5.2 Groups of Unknown Order</p>

    <p class="text-gray-300">A group of unknown order is a group where the order is computationally hard to compute. It is defined by an algorithm GGen that on input security parameter, samples a group <span class="math">\\mathbb{G}</span>, along with size bounds on the group that depend on the security parameter (we omit the size bounds for simplicity). We define three assumptions in these groups. The hidden order assumption which is the most basic, minimal assumption, saying that it is hard to compute the order of random group elements. The stronger sub-group hidden order assumption states that it is hard to compute any information about the order of a sampled subgroup, e.g., a subgroup generated by a commitment key. And finally, the famous RSA assumption which states that it is hard to compute roots of random elements in the group and implies the hidden order assumption.</p>

    <p class="text-gray-300">Assumption 1 (Hidden Order Assumption). The hidden order assumption holds for a group sampling algorithm GGen if for any probabilistic polynomial time adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} &amp;amp; \\mathbb{G} \\leftarrow GGen(1^{\\lambda}) \\\\ a \\cdot \\mathsf{G} = 0: &amp;amp; \\mathsf{G} \\stackrel{\\$}{\\leftarrow} \\mathbb{G} \\\\ &amp;amp; a \\in \\mathbb{Z} \\leftarrow \\mathcal{A}(\\mathbb{G}, \\mathsf{G}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) .</span></div>

    <p class="text-gray-300">Assumption 2 (Subgroup Hidden Order Assumption). The subgroup hidden order assumption is a generalization of the hidden order assumption. It says that it is difficult to compute a multiple of the order of any element in a subgroup sampled according to some distribution. It holds for a group sampling algorithm <span class="math">GGen</span> and subgroup sampling algorithm <span class="math">SGGen</span> if for any probabilistic polynomial time adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr} \\left[ \\operatorname{gcd}(a,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\neq 1: \\begin{array}{l} \\mathbb{G} \\leftarrow GGen(1^{\\lambda}) \\\\ \\mathbb{H} \\leftarrow SGGen(\\mathbb{G}) \\\\ a \\in \\mathbb{Z} \\leftarrow \\mathcal{A}(\\mathbb{G}, \\mathbb{H}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Assumption 3 (RSA assumption, [RSA78; CPP17]). The RSA assumption holds for <span class="math">GGen</span> if for any probabilistic polynomial time adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} &amp;amp; \\mathbb{G}, N \\leftarrow GGen(1^{\\lambda}) \\\\ \\ell \\cdot \\mathsf{U} = \\mathsf{G}: &amp;amp; \\mathsf{G} \\stackrel{\\$}{\\leftarrow} \\mathbb{G}, \\ell \\stackrel{\\$}{\\leftarrow} [N] \\\\ &amp;amp; \\mathsf{U} \\in \\mathbb{G} \\leftarrow \\mathcal{A}(\\mathbb{G}, \\mathsf{G}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) .</span></div>

    <p class="text-gray-300">The RSA Assumption implies Assumption 1[BFS19].</p>

    <p class="text-gray-300">5.3 IP Transcript Trees</p>

    <p class="text-gray-300">Let <span class="math">(P,V)</span> be a <span class="math">\\mu</span>-round public coin interactive protocol. A <span class="math">\\mu</span>-round public-coin protocol <span class="math">(P,V)</span> consists of <span class="math">\\mu</span>-rounds of messages between the prover and verifier, where in each round the prover sends a message to the verifier and the verifier responds with <span class="math">x \\leftarrow \\mathcal{X}</span> sampled uniformly from the challenge space <span class="math">\\mathcal{X}</span>. At the end of the protocol, the verifier outputs either accept or reject. By convention, the protocol starts with the prover's first message and ends with the prover's last message. A transcript thus contains <span class="math">\\mu + 1</span> prover messages and <span class="math">\\mu</span> challenges. We will denote transcripts by a <span class="math">\\mu \\times 2</span> matrix <span class="math">A</span> such that <span class="math">A(0,0)</span> is the protocol input <span class="math">\\mathbf{x}</span>, <span class="math">A(0,1)</span> is the prover's first message, and for all <span class="math">i \\geq 1</span>, <span class="math">A(i,0)</span> is the verifier's <span class="math">i</span>th round challenge and <span class="math">A(i,1)</span> is the prover's <span class="math">i</span>th round response. We restrict our attention to protocols in which the verifier's decision is a deterministic function <span class="math">D_V</span> of the transcript, but is also without loss of generality. An accepting transcript is an array <span class="math">A</span> such that <span class="math">D_V(A) = \\text{accept}</span>.</p>

    <p class="text-gray-300">A <span class="math">k</span>-ary transcript tree for <span class="math">(P,V)</span> is a labeling of a <span class="math">\\mu</span>-depth <span class="math">k</span>-ary tree such that the labels on every root-to-leaf path forms an accepting <span class="math">(P,V)</span> transcript. It will be convenient to order the nodes of the tree according to a depth-first reverse topological sort (aka post-order tree traversal). This is a topological sorting of the tree with directed edges flowing from leaves to root which places left subtrees before right subtrees. This ordering associates each node with an index in <span class="math">[1,N]</span> where <span class="math">N = \\text{size}(\\mu, k) = \\frac{k^{\\mu + 1} - 1}{k - 1}</span>. A post-order labeling of the tree is a function <span class="math">L: [1,N] \\to \\{0,1\\}^*</span>. We may refer to the level of a node in the tree. The root of a tree is always at level <span class="math">\\theta</span> and the leaves of a depth <span class="math">\\mu</span> tree are at level <span class="math">\\mu</span>. The height of node at level <span class="math">\\ell</span> within a <span class="math">\\mu</span>-depth tree is <span class="math">\\mu - \\ell</span>. For each <span class="math">v \\in [1,N]</span> let <span class="math">S_v \\subseteq [1,N]</span> denote the indices of all nodes in the subtree rooted</p>

    <p class="text-gray-300">4The subgroup sampling algorithm takes <span class="math">\\mathbb{G}</span> as input, which is interpreted as a succinct description of <span class="math">\\mathbb{G}</span>, such as a list of generators, not necessarily the list of all elements in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: IP transcript tree for  <span class="math">\\mu = k = 3</span> . Nodes and edges are labeled using post-order labeling. We also indicate  <span class="math">v^{*}</span>  for every node.</p>

    <p class="text-gray-300">at node  <span class="math">v</span> . For each  <span class="math">v \\in [1, N]</span>  let  <span class="math">v^<em></span>  denote the largest index  <span class="math">v^</em> &amp;lt; v</span>  such that the node at index  <span class="math">v^<em></span>  does not belong to the subtree  <span class="math">S_v</span> . Note that for nodes on the leftmost path of the tree  <span class="math">v^</em></span>  does not exist so we denote it by  <span class="math">\\bot</span> . For any subset  <span class="math">S \\subseteq [1, N]</span>  et  <span class="math">\\operatorname{pred}(S)</span>  denote a superset of  <span class="math">S</span>  which include the indices of all predecessors of nodes  <span class="math">S</span> . Finally, for each  <span class="math">v \\in [1, N]</span>  let  <span class="math">L_v : [1, v] \\to \\{0, 1\\}^<em></span>  denote the restriction of  <span class="math">L</span>  to the subset  <span class="math">\\operatorname{pred}([1, v])</span> . More generally, for any  <span class="math">S \\subseteq [1, N]</span>  let  <span class="math">L_S : S \\to \\{0, 1\\}^</em></span>  denote the restriction of the labeling  <span class="math">L</span>  to the subset of node indices  <span class="math">S</span> .  <span class="math">L_{S_v}</span>  thus denotes the labeling of the subtree  <span class="math">S_v</span> . Note that  <span class="math">L_v</span>  is not the same as  <span class="math">L_{S_v}</span> .</p>

    <p class="text-gray-300">A transcript tree is thus a special post-order labeling of the tree  <span class="math">L:[1,N]\\to \\mathcal{X}\\times \\mathcal{M}</span>  where  <span class="math">\\mathcal{X}</span>  is the verifier's challenge set and  <span class="math">\\mathcal{M}</span>  is the space of prover messages. We can think of the first component (i.e., the verifier challenge) as a label on the node's incoming edge and the second component (i.e., prover's response) as a label on the node itself. The root has no incoming edge, but the root label's first component is the protocol input. For any root-to-leaf path of nodes with indices  <span class="math">\\{v_0,\\dots,v_\\mu\\}</span>  the labeling  <span class="math">L</span>  defines the matrix  <span class="math">A</span>  such that  <span class="math">L(v_{i}) = (A(i,0),A(i,1))</span>  and  <span class="math">A</span>  is an accepting transcript. Given a label  <span class="math">L(v)</span>  for  <span class="math">v &amp;lt; N</span>  (non-roots) we will use the notation  <span class="math">L(v)_0</span>  to denote the first component of the label containing the verifier's challenge and  <span class="math">L(v)_1</span>  the second component containing the prover's response. We define a  <span class="math">k</span> -ary forking transcript tree to be a  <span class="math">k</span> -ary transcript tree in which the challenge labels on all edges sharing a common parent are distinct.</p>

    <p class="text-gray-300">Finally, we define a transcript tree labeling as a function of transcript trees that returns a derived labeling of the tree, i.e. a function  <span class="math">f: (\\mathcal{X} \\times \\mathcal{M})^N \\to \\mathcal{C}^N</span>  that given the labeling  <span class="math">L</span>  corresponding to a  <span class="math">k</span> -ary transcript tree induces the labeling  <span class="math">f(L): [1, N] \\to \\mathcal{C}</span> . For any  <span class="math">\\nu \\in [1, N]</span>  let  <span class="math">\\operatorname{pred}(\\nu)</span>  denote the indices of the path starting at the root and ending at node  <span class="math">\\nu</span>  so that  <span class="math">L_{\\operatorname{pred}(\\nu)}</span>  denotes the labels assigned to the nodes along this path by  <span class="math">L</span> , i.e. in a transcript tree this is the prefix of all transcripts that pass through  <span class="math">\\nu</span> . A localized transcript tree labeling further restricts  <span class="math">f</span>  so that the label  <span class="math">c_\\nu \\in \\mathcal{C}</span>  that  <span class="math">f(L)</span>  assigned to node  <span class="math">\\nu</span>  is a function of  <span class="math">L_{\\operatorname{pred}(\\nu)}</span> .</p>

    <p class="text-gray-300">The standard forking lemma for  <span class="math">\\mu</span> -round public coin interactive protocols characterizes the efficiency of generating a  <span class="math">k</span> -ary  <span class="math">\\mu</span> -depth transcript tree for which the challenges labeling the children within the tree fork, i.e. are distinct. More precisely, the forking lemma says that given any adversarial prover  <span class="math">\\mathcal{A}</span>  that may deviate from the honest protocol but causes the verifier to accept with probability  <span class="math">\\epsilon</span> , there is a tree generation algorithm that has only black-box access to  <span class="math">\\mathcal{A}</span> , runs in time  <span class="math">t \\in O\\left(\\frac{\\lambda}{\\epsilon} \\cdot k^{\\mu} \\cdot (\\mu + t_{V})\\right)</span> , where  <span class="math">t_{V}</span>  is the running time of the verifier's decision algorithm, and succeeds with probability  <span class="math">1 - t \\cdot \\mathrm{negl}(\\lambda)</span>  in producing a transcript tree with the forking property.</p>

    <p class="text-gray-300">Our path predicate forking lemma generalizes the property of the transcript tree that can be generated by considering arbitrary predicates on partial labelings of the tree.</p>

    <p class="text-gray-300">In the standard forking lemma, the predicate would simply be that new challenges are distinct from previous challenges. The lemma considers more general predicates for each node <span class="math">v\\in[1,N]</span>, which may depend on <span class="math">L_{v}</span>. Recall that for each <span class="math">v\\in[1,N]</span>, the node <span class="math">v^{<em>}</span> is the largest index <span class="math">v^{</em>}&lt;v</span> such that the node at this index is not contained in the subtree <span class="math">S_{v}</span> rooted at <span class="math">v</span> and <span class="math">\\mathsf{pred}([1,v^{<em>}])</span> is the superset of <span class="math">[1,v^{</em>}]</span> that includes the indices of all predecessors of nodes <span class="math">[1,v^{<em>}]</span>, which by definition also do not intersect with <span class="math">S_{v}</span>. Our lemma considers predicates at level <span class="math">\\ell_{v}</span> of the form <span class="math">\\pi_{v}:(\\mathcal{X}\\times\\mathcal{M})^{\\mathsf{pred}([1,v^{</em>}])}\\times\\mathcal{X}^{\\mu-\\ell_{v}}\\to\\{0,1\\}</span>, i.e. each predicate <span class="math">\\pi_{v}</span> takes as input a labeling function <span class="math">L_{v^{*}}</span> and a vector of challenges <span class="math">\\mathbf{x}\\in\\mathcal{X}^{\\mu-\\ell_{v}}</span>.</p>

    <p class="text-gray-300">The vector of challenges will represent <em>the leftmost</em> path down the tree starting from <span class="math">v</span>, which by definition is independent of the partial labeling <span class="math">L_{v^{<em>}}</span>. We denote the indices of the leftmost path from <span class="math">v</span> to the leaves as <span class="math">\\mathsf{Ipath}_{v}</span> and the challenge labels along this path assigned by <span class="math">L</span> as <span class="math">L(\\mathsf{Ipath}_{v})_{0}</span>. For example in Figure 1 the predicate <span class="math">\\pi_{8}</span> for node 8 would take as input the labels on the subtree spanned by node 4, the root label, and the challenge <span class="math">L(5)_{0}</span>. The lemma says that if <span class="math">\\pi_{v}(L_{v^{</em>}},\\mathbf{x})=1</span> with overwhelming probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> for any post-order labeling <span class="math">L:[1,N]\\to\\mathcal{X}\\times\\mathcal{M}</span> of the <span class="math">k</span>-ary <span class="math">\\mu</span>-depth tree, any node <span class="math">v</span> in the tree, and <span class="math">\\mathbf{x}</span> sampled randomly, then the transcript generation algorithm produces a transcript tree represented by some post-order labeling <span class="math">L</span> for which <span class="math">\\pi_{v}(L_{v^{<em>}},L(\\mathsf{Ipath}_{v})_{0})=1</span> for all <span class="math">v</span> in the tree. In fact, the lemma is even more general as it has a weaker requirement that <span class="math">\\pi_{v}(L_{v},\\mathbf{x})=1</span> with overwhelming probability conditioned on <span class="math">\\pi_{u}(L_{u},L(\\mathsf{Ipath}_{u})_{0})=1</span> for all <span class="math">u\\leq v^{</em>}</span>. The standard forking lemma is a special case where <span class="math">\\pi_{v}</span> checks that the challenge label on <span class="math">v</span> is distinct from the challenge labels on any of its left siblings. The challenge label <span class="math">L(v)_{0}</span> on <span class="math">v</span> is the first component of <span class="math">L(\\mathsf{Ipath}_{v})_{0}</span>. Assuming <span class="math">v</span> is not a first child, the labels on the left sibling(s) of <span class="math">v</span> as well as its parent are included in <span class="math">L_{v^{*}}</span>.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Proof Overview</h4>

    <p class="text-gray-300">We will begin with a high level overview of the proof. The algorithm is exactly the same as the recursive tree generation algorithm for the standard forking lemma. The difference is only in the analysis. The standard forking lemma considers predicates <span class="math">\\pi_{v}(L_{v^{<em>}},x)</span> that are functions only of the challenges assigned by <span class="math">L_{v^{</em>}}</span> to left sibling nodes of <span class="math">v</span> and a single (fresh) <span class="math">x\\in\\mathcal{X}</span> rather than a vector, and are independently true with overwhelming probability.</p>

    <p class="text-gray-300">Just as in the standard forking lemma, the analysis is a simple union bound. First, the tree generation algorithm is transformed to a Monte Carlo algorithm that runs for <span class="math">t\\in\\mathsf{poly}(\\lambda)</span> steps and succeeds with overwhelming probability. The standard forking lemma is based on the observation that a <span class="math">t</span>-step algorithm makes at most <span class="math">t</span> samples from <span class="math">\\mathcal{X}</span> and thus the predicates hold true for all sampled challenges with probability at least <span class="math">1-t\\cdot\\mathsf{negl}(\\lambda)</span>. In our case, the analysis is very similar. Let <span class="math">L</span> denote the labeling returned by the Monte Carlo tree generation algorithm. We begin with the observation that this tree generation algorithm constructs the labeling in depth-first post-order. In particular, when the transcript tree generation algorithm visits a node <span class="math">v</span> at heigh <span class="math">h_{v}</span> it has already derived a partial labeling <span class="math">L_{v^{<em>}}</span>. It samples a random vector <span class="math">\\mathbf{x}\\in\\mathcal{X}^{h_{v}}</span> and attempts to derive a valid transcript for <span class="math">\\mathsf{Ipath}_{v}</span> using this challenge vector <span class="math">\\mathbf{x}</span>. If it succeeds then it sets <span class="math">L(\\mathsf{Ipath}_{v})_{0}=\\mathbf{x}</span>, otherwise the entire vector <span class="math">\\mathbf{x}</span> is discarded and it tries again starting from <span class="math">v</span>. Suppose there exists some <span class="math">v</span> such that <span class="math">\\pi_{v}(L_{v^{</em>}},L(\\mathsf{Ipath}_{v})_{0})=0</span> and let <span class="math">v</span> be the lowest index node with this property. This would imply that there occurred an event where the algorithm had already constructed <span class="math">L_{v^{<em>}}</span> satisfying <span class="math">\\pi_{u}(L_{u^{</em>}},L(\\mathsf{Ipath}_{u})_{0})=1</span> for all <span class="math">u\\leq v^{<em>}</span> and then sampled <span class="math">\\mathbf{x}\\leftarrow\\mathcal{X}^{h_{v}}</span>, setting <span class="math">L(\\mathsf{Ipath}_{v})_{0}=\\mathbf{x}</span>, such that <span class="math">\\pi_{v}(L_{v^{</em>}},\\mathbf{x})=0</span>. However, by hypothesis this event occurs with probability <span class="math">\\mathsf{negl}(\\lambda)</span> over random <span class="math">\\mathbf{x}</span>. Since the algorithm runs for only <span class="math">t\\in\\mathsf{poly}(\\lambda)</span> steps, an event of this kind occurs with probability at most <span class="math">t\\cdot\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Thus, we obtain a Monte Carlo algorithm that returns a transcript tree where all the predicates are satisfied with overwhelming probability.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma 3 (Path Predicate Forking Lemma).</h6>

    <p class="text-gray-300">Let <span class="math">(P,V)</span> be a <span class="math">\\mu</span>-round public-coin protocol with prover message space <span class="math">\\mathcal{M}</span> and verifier challenge space <span class="math">\\mathcal{X}</span>. For each node <span class="math">v\\in[1,N]</span> of a <span class="math">\\mu</span>-depth <span class="math">k</span>-ary balanced tree on <span class="math">N=\\mathsf{size}(\\mu,k)</span> nodes, let <span class="math">h_{v}</span> denote the height of <span class="math">v</span>. Let <span class="math">\\{\\pi_{v}:v\\in[1,N]\\}</span> denote a set of predicates, where <span class="math">\\pi_{v}(L_{v^{<em>}},\\mathbf{x})</span> is a function of the partial labeling <span class="math">L_{v^{</em>}}</span> and challenge vector <span class="math">\\mathbf{x}\\in\\mathcal{X}^{h_{v}}</span>, with the property that for any post-order labeling function <span class="math">L:[1,N]\\to\\mathcal{X}\\times\\mathcal{M}</span> and any <span class="math">v\\in[1,N]</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Pr_{\\mathbf{x}\\leftarrow\\mathcal{X}^{h_{v}}}[\\pi_{v}(L_{v^{*}},\\mathbf{x})=1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\forall_{u\\leq v^{<em>}}\\pi_{u}(L_{u^{</em>}},L(\\mathsf{Ipath}_{u})_{0})=1]\\geq 1-\\delta$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">t_{V}</span> denote the worst-case running time of the verifier’s decision algorithm <span class="math">D_{V}</span>. There is an algorithm <span class="math">\\mathsf{Tree}^{A}(\\mathbf{z})</span> that, given a security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and oracle access</p>

    <p class="text-gray-300">to an adversarial prover <span class="math">\\mathcal{A}</span> that causes <span class="math">V</span> to accept with probability <span class="math">\\epsilon</span> on public input <span class="math">\\mathbf{z}</span>, runs in time at most <span class="math">t=2\\lambda\\cdot\\frac{b^{\\nu}}{\\epsilon}\\cdot(\\mu+t_{V})</span> and with probability at least <span class="math">1-t\\cdot\\delta-2^{-\\lambda}</span> outputs a <span class="math">k</span>-ary transcript tree with post-order labeling <span class="math">L:[1,N]\\to\\mathcal{X}\\times\\mathcal{M}</span> such that <span class="math">\\pi_{v}(L_{v^{\\epsilon}},L(\\mathsf{Ipath}_{v})_{0})=1</span> for all <span class="math">v\\in[1,N]</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We will first describe a Las Vegas tree-finding algorithm that runs in expected polynomial time as we can then transform it to a Monte Carlo algorithm with a finite runtime and overwhelming success probability.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Tree finding algorithm</h4>

    <p class="text-gray-300">The tree-finding algorithm <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> begins by sampling a random tape <span class="math">\\sigma</span> for the adversary. Let <span class="math">A(\\sigma)</span> denote the <em>deterministic</em> adversary with fixed random tape <span class="math">\\sigma</span>. For all <span class="math">i\\in[0,\\mu]</span> define <span class="math">T_{i}(\\sigma,k,\\mathbf{z},x_{1},...,x_{i})</span> as follows:</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Algorithm 1.</h6>

    <p class="text-gray-300"><span class="math">T_{i}(\\sigma,k,\\mathbf{z},x_{1},...,x_{i})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i=\\mu</span>: Simulate the protocol with <span class="math">\\mathcal{A}(\\sigma)</span> as the prover and fixing the verifier’s challenges <span class="math">\\mu</span> ordered challenges to the values <span class="math">x_{1},...,x_{\\mu}</span>. If the verifier outputs <span class="math">1</span> during this simulation then return the protocol transcript <span class="math">tr</span>, and otherwise return <span class="math">\\mathsf{fail}</span>.</li>

      <li>Else if <span class="math">0\\leq i&lt;\\mu</span>: Sample <span class="math">x_{i+1}\\leftarrow\\mathcal{X}</span> and run <span class="math">T_{i}(\\sigma,k,y,x_{1},...,x_{i+1})</span>. This either returns <span class="math">\\mathsf{fail}</span> or a transcript tree denoted <span class="math">\\mathsf{tree}</span>. If it returns <span class="math">\\mathsf{fail}</span>, then output <span class="math">\\mathsf{fail}</span>. Otherwise, save the pair <span class="math">(x_{i+1},\\mathsf{tree})</span>. If <span class="math">i&lt;\\mu-1</span> then <span class="math">\\mathsf{tree}</span> is a tree of accepting transcripts that share a common prefix for the first <span class="math">i+1</span> rounds, which includes the challenges <span class="math">x_{1},...,x_{i+1}</span>. If <span class="math">i+1=\\mu</span> then <span class="math">\\mathsf{tree}</span> is a single accepting transcript. Repeat this process as many times as needed, each time sampling a fresh <span class="math">x_{i+1}^{\\prime}</span>, running <span class="math">T_{i}(\\sigma,y,x_{1},...,x_{i+1}^{\\prime})</span>, ignoring the runs that <span class="math">\\mathsf{fail}</span>, saving the succesful challenge/tree pairs until <span class="math">k</span> pairs have been recorded. Together the transcripts in all <span class="math">k</span> recorded trees form one larger tree of accepting transcripts that share a commmon prefix <span class="math">\\mathsf{tr}_{\\mathsf{pre}}</span> for the first <span class="math">i</span> rounds of messages with fixed challenges <span class="math">x_{1},...,x_{i}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> repeatedly samples <span class="math">\\sigma</span> and runs <span class="math">T_{0}(\\sigma,k,\\mathbf{z})</span> until it outputs a tree of accepting transcripts.</p>

    <p class="text-gray-300">We now analyze the expected runtime of <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> and success probability of returning an <span class="math">k</span>-ary tree of accepting transcripts given that <span class="math">\\mathcal{A}</span> succeeds with probability <span class="math">\\epsilon</span>. <span class="math">T_{0}(\\sigma,k,\\mathbf{z})</span> returns <span class="math">\\mathsf{fail}</span> iff the first iteration of each subroutine <span class="math">T_{i}</span> returns <span class="math">\\mathsf{fail}</span> for <span class="math">i=1</span> to <span class="math">\\mu</span>. The probability this happens is equal to the probability that <span class="math">T_{\\mu}(\\sigma,y,x_{1},...,x_{\\mu})</span> outputs <span class="math">\\mathsf{fail}</span> for a uniformly distributed challenge tuple <span class="math">(x_{1},...,x_{\\mu})</span>. This is equal to the failure probability of <span class="math">\\mathcal{A}(\\sigma)</span>, i.e. <span class="math">1-\\epsilon</span>. Thus, <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> calls <span class="math">T_{0}</span> in expectation <span class="math">1/\\epsilon</span> times. Letting <span class="math">t_{0}</span> be a random variable for the runtime of <span class="math">T_{0}(\\sigma,\\mathbf{z})</span> over random <span class="math">\\sigma</span>, the expected runtime of <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> is <span class="math">t_{0}/\\epsilon</span>.</p>

    <p class="text-gray-300">It remains to analyze the expected runtime <span class="math">\\mathbb{E}[t_{0}]</span> of <span class="math">T_{0}(\\sigma,\\mathbf{z})</span>. Each call to <span class="math">T_{i}(\\sigma,k,\\mathbf{z},x_{1},...,x_{i})</span> for <span class="math">i\\in[1,\\mu]</span> that occurs in the execution trace of <span class="math">T_{0}(\\sigma,k,\\mathbf{z})</span> is on i.i.d. uniformly distributed challenges <span class="math">x_{1},...,x_{i}</span>. Let <span class="math">t_{i}</span> be a random variable denoting the runtime of <span class="math">T_{i}(\\sigma,k,\\mathbf{z},x_{1},...,x_{i})</span> over a uniformly distributed <span class="math">\\sigma</span>. We omit the time to sample a random challenge from the runtime analysis as this will only affect the runtime up to a constant factor. Since <span class="math">T_{\\mu}(\\sigma,k,\\mathbf{z},\\mathbf{x}_{\\mu})</span> makes <span class="math">\\mu</span> calls to the oracle <span class="math">\\mathcal{A}</span> and one call to the verifier’s decision algorithm <span class="math">D_{V}</span> its runtime is at most <span class="math">\\mu+t_{V}</span>, where <span class="math">t_{V}</span> is the worst case running time of <span class="math">D_{V}</span>.</p>

    <p class="text-gray-300">For <span class="math">i&lt;\\mu</span>, <span class="math">T_{i}(\\sigma,k,y,\\mathbf{x}_{i})</span> outputs <span class="math">\\mathsf{fail}</span> iff the first call to each <span class="math">T_{j}</span> subroutine for <span class="math">j\\in[i+1,\\mu]</span> returns <span class="math">\\mathsf{fail}</span>, in which case the runtime is <span class="math">t_{\\mathcal{A}}</span>. The probability <span class="math">T_{i}(\\sigma,k,\\mathbf{z},\\mathbf{x}_{i})</span> outputs <span class="math">\\mathsf{fail}</span> for random <span class="math">\\sigma</span> and <span class="math">\\mathbf{x}_{i}</span> is again equal to the failure probability of <span class="math">\\mathcal{A}(\\sigma)</span>, i.e. <span class="math">1-\\epsilon</span>. If it does not output <span class="math">\\mathsf{fail}</span>, then in expectation it runs an additional <span class="math">(k-1)/\\epsilon</span> iterations of <span class="math">T_{i+1}(\\sigma,k,\\mathbf{z},\\mathbf{x}_{i},x_{i+1})</span> sampling a fresh <span class="math">x_{i+1}</span> for each iteration. Thus, the expected runtime <span class="math">\\mathbb{E}(t_{i})</span> is:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[(1-\\epsilon)\\cdot t_{\\mathcal{A}}+(k-1)\\cdot t_{i+1}]\\leq\\mathbb{E}[t_{i+1}\\cdot k]</span></p>

    <p class="text-gray-300">This recurrence relation shows:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[t_{0}]\\leq\\mathbb{E}[t_{\\mu}\\cdot k^{\\mu}]</span></p>

    <p class="text-gray-300">Thus, we have shown that the expected runtime of <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> is <span class="math">\\mathbb{E}[t]\\leq\\frac{k^{\\mu}}{\\epsilon}\\cdot(\\mu+t_{V})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">By standard techniques, the Las Vegas algorithm <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> may be transformed to a Monte Carlo algorithm that runs for <span class="math">2\\lambda \\cdot \\mathbb{E}[t]</span> steps and succeeds except with probability <span class="math">1 - 2^{-\\lambda}</span>.</p>

    <p class="text-gray-300"><strong>Transcript tree property analysis</strong> The transcript tree labels returned by <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> are computed in depth-first post-order by the Monte Carlo tree generation algorithm. Let <span class="math">L</span> denote this post-order labeling. Consider any node <span class="math">v</span> that is labeled with challenge <span class="math">L(v)_0 = x</span> in the tree. Let <span class="math">i</span> denote the level of <span class="math">v</span> within the tree and let <span class="math">\\mathbf{x} = (x_1,..,x_{i-1},x,x_{i+1},...,x_\\mu)</span> denote the vector of challenge labels assigned to the path starting from the root to <span class="math">v</span> and following the left-most path down the tree from <span class="math">v</span>. During the execution of <span class="math">\\mathsf{Tree}(k,\\mathbf{z})</span> the following event occurred: immediately after <span class="math">x</span> was sampled as a candidate label for <span class="math">v</span>, the challenges <span class="math">x_{i+1},...,x_\\mu</span> were sampled uniformly and independently such that <span class="math">\\mathcal{A}(\\sigma, k, \\mathbf{z}, \\mathbf{x})</span> succeeded (i.e., produced a valid transcript). If this event had not occurred (i.e., <span class="math">\\mathcal{A}(\\sigma, k, \\mathbf{z}, \\mathbf{x})</span> failed) then <span class="math">x</span> would have been discarded and the process would have been repeated.</p>

    <p class="text-gray-300">In other words, when the transcript tree generation algorithm visits a node <span class="math">v</span> it has already derived a partial labeling <span class="math">L_{v^<em>}</span> for the nodes at indices <span class="math">\\text{pred}([1, v^</em>))</span>, which are not in any subtree rooted at <span class="math">v</span>. It samples a random vector <span class="math">\\mathbf{x} \\in \\mathcal{X}^{h_v}</span> and attempts to derive a valid transcript for <span class="math">\\text{Ipath}_v</span> using this challenge vector <span class="math">\\mathbf{x}</span>. If it succeeds, then it sets <span class="math">L(\\text{Ipath}_v)_0 = \\mathbf{x}</span>, otherwise the entire vector <span class="math">\\mathbf{x}</span> is discarded, and it tries again starting from <span class="math">v</span>. Suppose there exists some <span class="math">v</span> such that <span class="math">\\pi_v(L_{v^<em>}, L(\\text{Ipath}_v)_0) = 0</span> and let <span class="math">v</span> be the lowest index node with this property. This would imply that there occurred an event where the algorithm had already partially constructed <span class="math">L</span> such that <span class="math">\\pi_u(L_{v^</em>}, L(\\text{Ipath}_u)_0) = 1</span> for all <span class="math">u \\leq v^<em></span> and then subsequently sampled <span class="math">\\mathbf{x} \\gets \\mathcal{X}^{h_v}</span>, setting <span class="math">L(\\text{Ipath}_u)_0 = \\mathbf{x}</span>, such that <span class="math">\\pi_v(L_{v^</em>}, \\mathbf{x}) = 0</span>. However, by hypothesis this event occurs with probability <span class="math">\\delta</span> over random <span class="math">\\mathbf{x}</span>. The algorithm runs for at most <span class="math">t = \\frac{2\\lambda}{v} k^\\mu \\cdot (\\mu + t_V)</span> steps in total, hence by a union bound the probability that an event of this kind occurs at all is at most <span class="math">t \\cdot \\delta</span>.</p>

    <p class="text-gray-300">Thus, we obtain a Monte Carlo extraction algorithm that returns a transcript tree where all the predicates are satisfied with overwhelming probability (for appropriate setting of the parameters). More precisely, for any security parameter <span class="math">\\lambda \\in \\mathbb{N}</span> and for <span class="math">t = \\frac{2\\lambda}{v} \\cdot k^{\\mu} \\cdot (\\mu + t_V)</span> the extraction algorithm runs in time at most <span class="math">t</span> and (by a union bound) succeeds in returning a transcript tree labeling <span class="math">L</span> where, for all <span class="math">v</span>, <span class="math">\\pi_v(L_{v^*}, L(\\text{Ipath}_v)_0) = 1</span> with probability at least <span class="math">1 - t \\cdot \\delta - 2^{-\\lambda}</span>.</p>

    <p class="text-gray-300">□</p>

    <h2 id="sec-44" class="text-2xl font-bold">5.5 Knowledge Soundness</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An NP relation <span class="math">\\mathcal{R}</span> is a subset of strings <span class="math">x, w \\in \\{0, 1\\}^*</span> such that there is a decision algorithm to decide <span class="math">(x, w) \\in \\mathcal{R}</span> that runs in time polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The language of </span>\\mathcal{R}<span class="math">, denoted </span>\\mathcal{L}_R<span class="math">, is the set </span>\\{x \\in \\{0, 1\\}^<em> : \\exists w \\in \\{0, 1\\}^</em> \\text{ s.t. } (x, w) \\in \\mathcal{R}\\}<span class="math">. The string </span>w<span class="math"> is called the witness and </span>x<span class="math"> the instance. An interactive proof of knowledge for an NP relation </span>\\mathcal{R}<span class="math"> is a special kind of two-party interactive protocol between a prover denoted </span>\\mathcal{P}<span class="math"> and a verifier denoted </span>\\mathcal{V}<span class="math">, where </span>\\mathcal{P}<span class="math"> has a private input </span>w<span class="math"> and both parties have a common public input </span>x<span class="math"> such that </span>(x, w) \\in \\mathcal{R}<span class="math">. Informally, the protocol is complete if </span>\\mathcal{P}(x, w)<span class="math"> always causes </span>\\mathcal{V}(x)<span class="math"> to output 1 for any </span>(x, w) \\in \\mathcal{R}<span class="math">. The protocol is knowledge sound if there exists an extraction algorithm </span>\\mathcal{E}<span class="math"> called the extractor such that for every </span>x<span class="math"> and adversarial prover </span>\\mathcal{A}<span class="math"> that causes </span>\\mathcal{V}(x)<span class="math"> to output 1 with non-negligible probability, </span>\\mathcal{E}<span class="math"> outputs </span>w<span class="math"> such that </span>(x, w) \\in \\mathcal{R}<span class="math"> with overwhelming probability given access to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 1 (Interactive Proof of Knowledge).</strong> An interactive protocol <span class="math">\\Pi = (\\mathcal{P},\\mathcal{V})</span> between a prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> is a proof of knowledge for a relation <span class="math">\\mathcal{R}</span> with knowledge error <span class="math">\\delta :\\mathbb{N}\\to [0,1]</span> if the following properties hold, where on common input <span class="math">x</span> and prover witness <span class="math">w</span> the output of the verifier is denoted by the random variable <span class="math">\\langle \\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: for all <span class="math">(x, w) \\in \\mathcal{R}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\langle \\mathcal {P} (x, w), \\mathcal {V} (x) \\rangle = 1 \\right] = 1</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span>-Knowledge Soundness: There exists a polynomial <span class="math">\\mathsf{poly}(\\cdot)</span> and a probabilistic oracle machine <span class="math">\\mathcal{E}</span> called the extractor such that given oracle access to any adversarial</li>

    </ul>

    <p class="text-gray-300">6Run <span class="math">\\lambda</span> independent instances in parallel for 2 <span class="math">\\cdot</span> <span class="math">\\mathbb{E}[t]</span> steps. By Markov, each instance terminates (i.e., succeeds) with probability at least 1/2. The probability none succeed is at most <span class="math">2^{-\\lambda}</span></p>

    <p class="text-gray-300">7The extractor can run <span class="math">\\mathcal{A}</span> for any specified number of steps, inspect the internal state of <span class="math">\\mathcal{A}</span>, and even rewind <span class="math">\\mathcal{A}</span> to a previous state.</p>

    <p class="text-gray-300">interactive prover algorithm <span class="math">\\mathcal{A}</span> and any input <span class="math">x\\in\\mathcal{L}_{R}</span> the following holds: if</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}\\left[\\left\\langle\\mathcal{A}(x),\\mathcal{V}(x)\\right\\rangle=1\\right]=\\epsilon(x)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then <span class="math">\\mathcal{E}^{\\mathcal{A}}(x)</span> with oracle access to <span class="math">\\mathcal{A}</span> runs in time $\\frac{\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}<span class="math"> and outputs </span>w<span class="math"> such that </span>(x,w)\\in R<span class="math"> with probability at least </span>1-\\frac{\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An interactive proof is “knowledge sound”, or simply a “proof of knowledge”, if has negligible knowledge error <span class="math">\\delta</span>.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Remark 6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 1 places no restriction on the runtime of the adversary, however, it does not guarantee extraction from an adversary that succeeds with sufficiently small <span class="math">\\epsilon(x)</span> such that $\\epsilon(x)\\leq\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. For </span>\\mathcal{R}<span class="math"> in NP, this definition of knowledge soundness implies the alternative formulation of Bellare and Goldreich <em>[x1]</em>, which says that the protocol has knowledge error </span>\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> if there exists an extractor that succeeds in expected time </span>\\frac{\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math">. An extractor which succeeds with probability </span>p=1-\\frac{\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}<span class="math"> in </span>t=\\frac{\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}<span class="math"> steps can run repeatedly (for </span>t<span class="math"> steps per iteration) on fresh randomness until it obtains a witness for the relation, which it can verify efficiently. It will succeed in an expected </span>\\frac{t}{p}=\\frac{\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> steps. Finally, this has been shown to imply another equivalent formulation which requires the extractor to run in expected time </span>O(\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> and succeed with probability </span>\\frac{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> for some polynomial </span>q<span class="math">. It is easy to see this implies the former because such an extractor can be repeated, succeeding in expected time </span>\\frac{q\\cdot\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-46" class="text-base font-semibold mt-4">Interactive arguments</h5>

    <p class="text-gray-300">Knowledge soundness holds against unbounded provers. The DARK protocol does not satisfy knowledge soundness because it relies on the computational binding property of cryptographic commitments. Interactive proofs that are only secure against computationally bounded adversaries are called <em>interactive arguments</em>. Adapting Definition 1 for arguments is more subtle than simply restricting the runtime of the adversary. The issue comes from the fact that the knowledge soundness definition quantifies the success of the extractor over all inputs <span class="math">x</span>. For example, there could exist an input <span class="math">x</span> that encodes the factorization of an RSA modulus which allows the adversarial prover to break the binding property of commitments that are based on the difficulty of factoring. For this input, the adversarial prover could succeed while the extractor would fail. This particular problem is fixed by requiring the adversary to generate the input <span class="math">x</span>. If the trapdoor is exponentially hard to compute the polynomial time adversary will not be able to embed the trapdoor in <span class="math">x</span> with non-negligible probability. (See Damgård and Fujisaki <em>[x10]</em> for a broader discussion of these issues).</p>

    <h5 id="sec-47" class="text-base font-semibold mt-4">Witness-extended emulation</h5>

    <p class="text-gray-300">A property called witness-extended emulation <em>[x14]</em> strengthens the knowledge-soundness definition so that the extractor outputs not only a witness but also a simulated transcript of the messages between the prover and verifier. This property is helpful for composability. In particular, if the interactive proof is used as a subprotocol within a larger protocol, it may be necessary in the security analysis to construct a simulator that needs to both obtain the adversary’s witness as well as simulate its view in the subprotocol. Fortunately, Lindell <em>[x13]</em> proved that every knowledge sound protocol also satisfies witness-extended emulation. Groth and Ishai <em>[x16]</em> further adapt the definition of witness-extended emulation for interactive arguments with setup (i.e., SRS model). This is the definition we will use in the present work.</p>

    <p class="text-gray-300">Before presenting the definition we will introduce some useful notations. In the SRS model, there is an additional setup algorithm Setup that generates public parameters <span class="math">\\mathsf{pp}</span> that are common inputs to the prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. The setup, which may or may not require a trusted party to sample trapdoor secrets, typically generates these parameters based on a security parameter <span class="math">\\lambda</span> necessary for computational security. Without loss of generality, the length of <span class="math">\\mathsf{pp}\\leftarrow\\textsf{Setup}(\\lambda)</span> is at least <span class="math">\\lambda</span> bits. The relation <span class="math">\\mathcal{R}</span> being proved may also depend on the setup parameters, denote <span class="math">\\mathcal{R}_{\\mathsf{pp}}</span>. For any prover algorithm <span class="math">\\mathcal{P}^{<em>}</span> interacting with a verifier algorithm <span class="math">\\mathcal{V}</span>, which may deviate arbitrarily from the honest prover algorithm <span class="math">\\mathcal{P}</span>, let <span class="math">\\mathsf{Record}(\\mathcal{P}^{</em>},\\mathsf{pp},x,\\mathsf{st})</span> denote the message transcript between <span class="math">\\mathcal{P}^{<em>}</span> and <span class="math">\\mathcal{V}</span> on shared inputs <span class="math">x</span> and <span class="math">\\mathsf{pp}</span> and initial prover state <span class="math">\\mathsf{st}</span>. For <span class="math">\\mathsf{tr}\\leftarrow\\mathsf{Record}(\\mathcal{P}^{</em>},\\mathsf{pp},x,\\mathsf{st})</span> let <span class="math">\\mathcal{V}_{\\mathsf{chack}}(\\mathsf{tr})</span> denote the verifier’s decision algorithm to accept or reject the transcript. Furthermore, let <span class="math">\\mathcal{E}^{\\mathsf{Record}(\\mathcal{P}^{*},\\mathsf{pp},x,\\mathsf{st})}</span> denote a machine <span class="math">\\mathcal{E}</span> with a transcript oracle for this interaction that can be rewound to any round and run again on fresh verifier randomness.</p>

    <p class="text-gray-300">Definition 2 (Witness-extended emulation [GI08; Lin01]). An interactive proof in the SRS model  <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span>  satisfies witness-extended emulation for relation  <span class="math">\\mathcal{R}</span>  if for every deterministic polynomial time  <span class="math">\\mathcal{P}^*</span>  there exists an expected polynomial time emulator  <span class="math">\\mathcal{E}</span>  such that for any non-uniform <span class="math">^8</span>  adversary  <span class="math">\\mathcal{A}</span>  and distinguisher  <span class="math">\\mathcal{D}</span>  that runs in time  <span class="math">\\mathsf{poly}(\\lambda)</span>  the following condition holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {D} (\\operatorname {t r}) = 1: \\begin{array}{c} \\operatorname {p p} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}) \\\\ (x, \\operatorname {s t}) \\leftarrow \\mathcal {A} (\\operatorname {p p}) \\\\ \\operatorname {t r} \\leftarrow \\operatorname {R e c o r d} (\\mathcal {P} ^ {*}, \\operatorname {p p}, x, \\operatorname {s t}) \\end{array} \\right] \\approx_ {\\lambda}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathcal {D} (\\operatorname {t r}) = 1 \\text {a n d} &amp;amp; \\operatorname {p p} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}) \\\\ V _ {\\text {c h e c k}} (\\operatorname {t r}) = 1 \\Rightarrow (x, w) \\in \\mathcal {R} _ {\\mathrm {p p}} &amp;amp; (x, \\operatorname {s t}) \\leftarrow \\mathcal {A} (\\operatorname {p p}) \\\\ &amp;amp; (\\operatorname {t r}, w) \\leftarrow \\mathcal {E} ^ {\\text {R e c o r d} (\\mathcal {P} ^ {*}, \\operatorname {p p}, x, \\operatorname {s t})} (\\operatorname {p p}, x) \\end{array} \\right]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">X\\approx_{\\lambda}Y</span>  denotes that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X - Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 4 (Lindell [Lin01]). Any proof of knowledge for relation  <span class="math">\\mathcal{R}</span>  also satisfies witness-extended emulation for  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Lemma 5. Let  <span class="math">\\mathcal{R}</span>  denote any NP relation. Given a commitment scheme  <span class="math">\\mathsf{com} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> , for any  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda)</span>  let  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span>  denote the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} ^ {\\prime} (\\mathsf {p p}) = \\left\\{ \\begin{array}{c} (x, w): \\mathcal {R} (x, w) = 1 \\\\ \\vee \\\\ [ w = (C, \\sigma_ {1}, \\sigma_ {2}) \\wedge \\sigma_ {1} \\neq \\sigma_ {2} \\wedge \\mathsf {O p e n} (\\mathsf {p p}, C, \\sigma_ {1}) = \\mathsf {O p e n} (\\mathsf {p p}, C, \\sigma_ {2}) = 1 ] \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">Let  <span class="math">\\Pi(\\mathsf{pp})</span>  denote the interactive protocol between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  parameterized by the setup parameter  <span class="math">\\mathsf{pp}</span> . If for all  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda)</span>  the protocol  <span class="math">\\Pi(\\mathsf{pp})</span>  is a proof of knowledge (Definition 1) for  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span>  then the tuple  <span class="math">(\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span>  as an interactive proof with setup satisfies witness-extended emulation (Definition 2) for  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Proof. By Lemma 4 a knowledge sound interactive proof for  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span>  also satisfies witness-extended emulation for  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span> . It remains to show that this implies witness-extended emulation for  <span class="math">\\mathcal{R}</span> . It suffices to show that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathcal {D} (\\operatorname {t r}) = 1 \\text {a n d} &amp;amp; \\operatorname {p p} \\leftarrow \\operatorname {S e t u p} (\\lambda) \\\\ V _ {\\text {c h e c k}} (\\operatorname {t r}) = 1 \\Rightarrow (x, w) \\in \\mathcal {R}: &amp;amp; (x, \\operatorname {s t}) \\leftarrow \\mathcal {A} (\\operatorname {p p}) \\\\ &amp;amp; (\\operatorname {t r}, w) \\leftarrow \\mathcal {E} ^ {\\text {R e c o r d} (\\mathcal {P} ^ {*}, \\operatorname {p p}, x, \\operatorname {s t})} (\\operatorname {p p}, x) \\end{array} \\right] \\approx_ {\\lambda}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathcal {D} (\\operatorname {t r}) = 1 \\text {a n d} &amp;amp; \\operatorname {p p} \\leftarrow \\operatorname {S e t u p} (\\lambda) \\\\ V _ {\\text {c h e c k}} (\\operatorname {t r}) \\Rightarrow (x, w) \\in \\mathcal {R} ^ {\\prime} (\\operatorname {p p}) &amp;amp; (x, \\operatorname {s t}) \\leftarrow \\mathcal {A} (\\operatorname {p p}) \\\\ &amp;amp; (\\operatorname {t r}, w) \\leftarrow \\mathcal {E} ^ {\\text {R e c o r d} (\\mathcal {P} ^ {*}, \\operatorname {p p}, x, \\operatorname {s t})} (\\operatorname {p p}, x) \\end{array} \\right]</span></div>

    <p class="text-gray-300">The difference between these two probabilities is bounded by the probability, over the distribution on the right side of the equation, that  <span class="math">(\\mathbf{x},\\mathbf{w})\\in \\mathcal{R}&#x27;(\\mathsf{pp})</span>  but  <span class="math">(\\mathbf{x},\\mathbf{w})\\notin \\mathcal{R}</span> . This event implies that  <span class="math">\\mathbf{w}</span>  encodes a break to the commitment scheme with parameters  <span class="math">\\mathsf{pp}</span> . Since  <span class="math">\\mathcal{A}</span> ,  <span class="math">P^{<em>}</span> , Setup and  <span class="math">\\mathcal{E}</span>  all run in time  <span class="math">\\mathsf{poly}(\\lambda)</span>  this occurs with probability at most  <span class="math">\\mathsf{negl}(\\lambda)</span>  over randomly sampled  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(\\lambda)</span>  by the computational binding property of the commitment scheme. More precisely, supposing that the difference between these two probabilities is  <span class="math">\\epsilon (\\lambda)</span> , then we can use  <span class="math">\\mathcal{A}</span> ,  <span class="math">P^{</em>}</span> , and  <span class="math">\\mathcal{E}</span>  to construct an algorithm  <span class="math">\\mathcal{A}&#x27;</span>  which on input  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(\\lambda)</span>  simulates  <span class="math">(x,\\mathsf{st})\\gets \\mathcal{A}(\\mathsf{pp})</span>  and  <span class="math">(\\mathsf{tr},w)\\gets \\mathcal{E}^{\\mathrm{Record}(\\mathcal{P}^{*},\\mathsf{pp},x,\\mathsf{st})}(\\mathsf{pp},x)</span>  returning  <span class="math">w</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} w = (C, \\sigma_ {1}, \\sigma_ {2}) &amp;amp; \\\\ \\wedge &amp;amp; \\\\ \\sigma_ {1} \\neq \\sigma_ {2} &amp;amp; : \\quad \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ \\wedge &amp;amp; w \\leftarrow \\mathcal {A} ^ {\\prime} (\\mathsf {p p}) \\\\ \\mathsf {V f} _ {\\mathsf {p p}} (C, \\sigma_ {1}) = \\mathsf {V f} _ {\\mathsf {p p}} (C, \\sigma_ {2}) = 1 &amp;amp; \\end{array} \\right] = \\epsilon (\\lambda)</span></div>

    <p class="text-gray-300">If  <span class="math">\\epsilon (\\lambda)</span>  is non-negligible this contradicts the binding property of the commitment scheme.</p>

    <p class="text-gray-300">Zero knowledge We recall the definition of honest verifier zero-knowledge (HVZK) for interactive proofs. HVZK only considers simulating the view of a verifier that follows the protocol honestly. The Fiat-Shamir transform compiles public-coin proofs that have HVZK into non-interactive proofs that have statistical zero-knowledge (for malicious verifiers).</p>

    <p class="text-gray-300">Definition 3 (HVZK for interactive arguments). Let  <span class="math">\\mathsf{View}_{\\langle \\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle}</span>  denote the view of the verifier in an interactive protocol on common input  <span class="math">x</span>  and prover witness input  <span class="math">w</span> . The interactive protocol has  <span class="math">\\delta</span> -statistical honest verifier zero-knowledge if there exists a probabilistic polynomial time algorithm  <span class="math">\\mathcal{S}</span>  such that for every  <span class="math">(x,w)\\in \\mathcal{R}</span> , the distribution  <span class="math">\\mathcal{S}(x)</span>  is  <span class="math">\\delta</span> -close to  <span class="math">\\mathsf{View}_{\\langle \\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle}</span>  (as distributions over the randomness of  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> ).</p>

    <p class="text-gray-300">We first define deterministic (non-hiding) commitment scheme over a message space  <span class="math">\\mathcal{M}</span>  and opening space  <span class="math">\\mathcal{W} \\supseteq \\mathcal{M}</span> . When  <span class="math">\\mathcal{M} = \\mathcal{W}</span>  it is identical to collision-resistant hash functions. More generally, the commitment function is a collision-resistant hash function  <span class="math">H: \\mathcal{M} \\to \\{0,1\\}^{\\lambda}</span> , but the algorithm that verifies an opening of  <span class="math">C</span>  to  <span class="math">m</span>  is not restricted to checking  <span class="math">H(m) = C</span>  (e.g., this may not be possible when  <span class="math">m \\notin \\mathcal{M}</span> ).</p>

    <p class="text-gray-300">These schemes do not provide a way to commit to  <span class="math">\\mathbf{x} \\in \\mathcal{W} \\setminus \\mathcal{M}</span> , but is nonetheless useful to define in the context of arguments of knowledge. Suppose a party commits to a message  <span class="math">m \\in \\mathcal{M}</span>  as  <span class="math">C = H(m)</span>  and is asked to prove knowledge of an opening of  <span class="math">C</span>  using an argument system for which the knowledge extractor is only guaranteed to extract an opening to a message in the superset  <span class="math">\\mathcal{W}</span> . There are applications where it doesn't matter whether the prover knows an actual input  <span class="math">m \\in \\mathcal{M}</span>  to  <span class="math">H</span>  such that  <span class="math">H(m) = C</span>  as long as it is committed in a binding way to some message in  <span class="math">\\mathcal{W}</span>  that it knows. In fact, commitment schemes where  <span class="math">\\mathcal{M} = \\mathbb{Z}^n</span>  and  <span class="math">\\mathcal{W} \\subseteq \\mathbb{Q}^n</span>  together with arguments of knowledge that extract openings to  <span class="math">\\mathcal{W}</span>  suffice to construct linear-map vector commitments over prime fields  <span class="math">\\mathbb{F}_p</span> , with polynomial commitment schemes as a special case. These have very powerful applications including the construction of generic succinct non-interactive argument (SNARK) systems for all of  <span class="math">NP</span> .</p>

    <p class="text-gray-300">Definition 4 (Deterministic Commitment Scheme). A deterministic commitment scheme  <span class="math">\\Gamma</span>  is a tuple  <span class="math">\\Gamma = (\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit},\\mathsf{Open})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(1^{\\lambda}) \\to \\mathfrak{pp}</span>  is a PPT algorithm that generates public parameters  <span class="math">\\mathfrak{pp}</span> , which define a finite set of indices  <span class="math">\\mathcal{I}</span> , a message space  <span class="math">\\mathcal{M}</span> , and an opening space  <span class="math">\\mathcal{W} \\supseteq \\mathcal{M}</span> ;</li>

      <li><span class="math">\\mathcal{G}(\\mathsf{pp},\\iota)\\to \\mathsf{pp}^*</span>  is a PPT algorithm that generates parameters for the index  <span class="math">\\iota \\in \\mathcal{I}</span> ;</li>

      <li>Commit  <span class="math">(\\mathsf{pp}^*, m) \\to C</span>  is a polynomial time computable function that takes a secret message  <span class="math">m</span>  and returns a public commitment  <span class="math">C</span> .</li>

      <li><span class="math">\\mathsf{Open}(\\mathsf{pp}^<em>, C, w, \\sigma) \\to b \\in \\{0,1\\}</span>  is a PPT algorithm that verifies the opening of commitment  <span class="math">C</span>  to the message  <span class="math">w \\in \\mathcal{W}</span>  provided with an opening hint  <span class="math">\\sigma \\in \\{0,1\\}^</em></span> .</li>

    </ul>

    <p class="text-gray-300">A commitment scheme  <span class="math">\\Gamma</span>  is binding if for all PPT adversaries  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ &amp;amp; (\\iota , C, m _ {0}, m _ {1}, \\sigma_ {0}, \\sigma_ {1}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ b _ {0} = b _ {1} = 1 \\wedge m _ {0} \\neq m _ {1}: &amp;amp; \\mathsf {p p} ^ {*} \\leftarrow \\mathcal {G} (\\mathsf {p p}, \\iota) \\\\ &amp;amp; b _ {0} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p} ^ {*}, C, m _ {0}, \\sigma_ {0}) \\\\ &amp;amp; b _ {1} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p} ^ {*}, C, m _ {1}, \\sigma_ {1}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">We say that a tuple  <span class="math">(C, (m_0, \\sigma_0), (m_1, \\sigma_1))</span>  is a break of the commitment scheme, if  <span class="math">\\mathsf{Open}(\\mathsf{pp}^<em>, C, x_1, \\sigma_1) = \\mathsf{Open}(\\mathsf{pp}^</em>, C, m_1, \\sigma_1) = 1</span>  and  <span class="math">m_0 \\neq m_1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark on  <span class="math">\\mathcal{I}</span> : The standard definition of commitment schemes does not have an indexing set  <span class="math">\\mathcal{I}</span> , or equivalently has  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> . The more general definition we presented is important for our applications, and it is important for the scheme to be binding even for an adversarially sampled index. As a simple example, Setup might determine a prime-order group  </span>\\mathcal{G}<span class="math">  in which the discrete logarithm is hard and  </span>\\mathcal{I} \\subset \\mathcal{G}<span class="math">  is the set of  </span>p - 1<span class="math">  generators. The commitment function at index  </span>g \\in \\mathcal{I}<span class="math">  computes  </span>x \\mapsto g^x<span class="math">  for  </span>x \\in \\mathbb{F}_p$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 5 (Almost-Special-Soundness (new)). Let  <span class="math">\\chi</span>  denote any set of size  <span class="math">2^{\\lambda}</span> . Let  <span class="math">\\Gamma = (\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit},\\mathsf{Open})</span>  denote a deterministic commitment scheme with message space  <span class="math">\\mathcal{M}</span> , opening space  <span class="math">\\mathcal{W}</span> , and indexing set  <span class="math">\\mathcal{I}</span> . Let  <span class="math">\\Pi</span>  be  <span class="math">\\mu</span> -round public-coin interactive proof with challenge space  <span class="math">\\chi</span>  for a relation  <span class="math">\\mathcal{R}_{\\mathsf{pp}}</span> , such that the commitment parameters  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>  are generated as part of the setup of  <span class="math">\\Pi</span>  and where the relation is possibly dependent on  <span class="math">\\mathsf{pp}</span> .  <span class="math">\\Pi</span>  is  <span class="math">(k^{(p)},\\delta(\\cdot),\\Gamma,\\phi)</span> -almost-special-sound if there exists</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A pair of predicates  <span class="math">\\phi = (\\phi_{a},\\phi_{b})</span>  where  <span class="math">\\phi_{a},\\phi_{b}:[\\mu ]\\times \\mathcal{M}\\to \\{0,1\\}</span>  and  <span class="math">\\phi_{a}(i,m_{i}) = 1\\Rightarrow \\phi_{b}(i,m_{i}) = 1.</span></li>

      <li>A negligible function  <span class="math">\\delta :\\mathbb{N}\\to \\mathbb{R}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There is a localized transcript tree labeling <span class="math">F</span> (Section 5.3) that assigns to each node <span class="math">\\nu</span> of a valid transcript tree for <span class="math">\\Pi</span> a commitment label <span class="math">C^{(\\nu)}</span> for the scheme <span class="math">\\Gamma</span> at an index <span class="math">\\iota_{\\nu} \\in \\mathcal{I}</span>. Additionally, any leaf node <span class="math">\\nu</span> of the transcript tree is labelled with <span class="math">C^{(\\nu)}</span> for some index <span class="math">\\iota_{\\nu} \\in \\mathcal{I}</span> together with an opening <span class="math">(m_{\\nu}, o_{\\nu})</span> such that <span class="math">\\mathrm{Open}(\\mathsf{pp}_{i_{\\nu}}, C^{(\\nu)}, m_{\\nu}, o_{\\nu}) = 1</span> and <span class="math">\\phi_{a}(\\mu, m_{\\mu}) = 1</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Extract Witness:</strong> ExtractWitness <span class="math">(x, F, \\text{tree}, \\text{treeOpenings}) \\to w</span> takes as input an instance <span class="math">x</span>, the tree labeling function <span class="math">F</span>, a <span class="math">k</span>-ary transcript tree tree and purported openings treeOpenings = <span class="math">[(m_1, \\sigma_1), \\ldots, (m_N, \\sigma_N)]</span>, to the commitments of each node in the tree, that are defined by <span class="math">F</span>. If tree, treeOpenings, satisfy the following properties then <span class="math">(x, w) \\in \\mathbb{R}_{\\mathsf{pp}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenge labels for the children of each node are distinct.</li>

      <li>For each <span class="math">\\nu \\in \\text{tree}</span>, <span class="math">\\text{Open}(\\mathsf{pp}_{\\nu}, C^{\\nu}, m_{\\nu}, \\sigma_{\\nu}) = 1</span></li>

      <li>For each <span class="math">\\nu \\in \\text{tree}</span>, <span class="math">\\phi_{a}(\\sigma_{\\nu}) = 1</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Extract Internal:</strong> ExtractInternal <span class="math">(F, \\nu, \\text{subtree} = [(\\iota_1, m_1, \\sigma_1), \\ldots, (\\iota_t, m_t, \\sigma_t)]) \\to (m, \\sigma)</span> takes as input a node <span class="math">\\nu</span> such that <span class="math">C^\\nu = F(\\nu)</span> is the commitment assigned to <span class="math">\\nu</span> by <span class="math">F</span>, as well as the transcript subtree of size <span class="math">t</span>, spanned at <span class="math">\\nu</span>, defined by the indices <span class="math">\\iota</span> of the subtree along with purported openings to each commitment <span class="math">F(\\iota) = C^\\iota</span> in the subtree.</p>

    <p class="text-gray-300">Given that each node's children in the subtree have distinct challenge labels, the algorithm either outputs a break of <span class="math">\\Gamma</span> (Definition 4) or satisfies the following property:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [t] \\phi_{a}(\\text{level}(\\iota_{i}), m_{i}) = 1 \\wedge \\text{Open}(\\mathsf{pp}_{\\iota_{i}}, C^{(\\iota_{i})}, m_{i}, \\sigma_{i}) = 1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Downarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{Open}(\\mathsf{pp}_{\\nu}, C^{\\nu}, m, \\sigma) = 1 \\wedge \\phi_{b}(\\text{level}(\\nu), m) = 1</span></div>

    <p class="text-gray-300">Here <span class="math">\\text{level} : [k^{\\mu}] \\to [\\mu]</span> maps from a node to its level in the tree.</p>

    <p class="text-gray-300"><strong>Extend algorithm</strong> <span class="math">\\operatorname{Extend}(\\iota, \\operatorname{tr}) \\to ((m_{\\ell_{\\iota} = \\text{level}(\\iota) + 1}^{\\prime}, \\sigma_{\\ell_{\\iota}}^{\\prime}), \\ldots, (m_{\\mu}^{\\prime}, \\sigma_{\\mu}))</span>, such that <span class="math">\\operatorname{tr} = [C_{\\iota}, (C_{1}, \\alpha_{1}), \\ldots, (C_{\\mu}, \\alpha_{\\mu})]</span> is an accepting transcript that includes the node <span class="math">\\iota</span>, i.e. <span class="math">C_{\\ell_{\\iota}} = C^{(\\iota)}</span>. For any openings to <span class="math">C_{i}, \\ldots, C_{\\mu}</span>, <span class="math">(m_{i}, \\sigma_{i}), \\ldots, (m_{\\mu}, \\sigma_{\\mu})</span>, one of the following cases holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\exists j \\in [i, \\mu]</span> such that <span class="math">(C_j, (m_j, \\sigma_j), (m_j&#x27;, \\sigma_j&#x27;))</span> is a break of <span class="math">\\Gamma</span></li>

    </ol>

    <p class="text-gray-300">2.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{\\alpha_{i}, \\ldots, \\alpha_{\\mu} \\leftarrow \\chi} \\left[ \\phi_{a}(\\text{level}(\\iota), m) = 0 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} m_{i} = m_{i}^{\\prime} \\forall i \\in [\\ell_{i} + 1, \\mu] \\\\ \\phi_{a}(m_{i}^{\\prime}) = 1 \\forall i \\in [\\ell_{i} + 1, \\mu] \\\\ \\phi_{b}(m_{\\ell_{\\iota}}) = 1 \\end{array} \\right. \\right] \\leq \\delta(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Short-hand notation:</strong> An interactive proof is <span class="math">(k^{(\\mu)},\\delta)</span>-almost-special-sound if it is <span class="math">(k^{(\\mu)},\\delta, \\com, \\phi)</span>-almost-special-sound for some commitment scheme <span class="math">\\com</span> and some predicate pair <span class="math">\\phi</span>. We may omit <span class="math">\\delta</span> and simply write <span class="math">k^{(\\mu)}</span>-almost-special-soundness if this holds for some negligible function <span class="math">\\delta : \\mathbb{N} \\to \\mathbb{R}</span>.</p>

    <p class="text-gray-300"><strong>Remark 7.</strong> Any special sound protocol satisfies almost-special-soundness as 3) essentially captures the special soundness definition. More precisely, a <span class="math">k^{(\\mu)}</span>-special sound satisfies <span class="math">k^{(\\mu)}</span>-almost-special-soundness by setting the commitment scheme to be trivial (i.e., identity function) and the <span class="math">i</span>th round commitment <span class="math">C^{(i)}</span> to the prover's <span class="math">i</span>th round message and setting the predicates <span class="math">\\phi_{a} = 1, \\phi_{b} = 0</span> to be trivial as well (i.e., always return 1 and 0 respectively). The algorithm <span class="math">\\text{Extend}</span> can output an arbitrary set of messages because the condition on the algorithm is vacuously true as <span class="math">\\phi_{a}(i, m) \\neq 0</span> for any <span class="math">(i, m)</span>. The algorithm <span class="math">\\text{Extract}(\\nu, C^{(\\nu)}, *)</span> is trivial because <span class="math">C^{(\\nu)}</span> is the message itself. The algorithm <span class="math">\\text{Break}</span> is also trivial as <span class="math">\\phi_{b}</span> is always 0. The algorithm <span class="math">\\text{Extract}(x, \\text{openTree}) \\to w</span> exists by the definition of <span class="math">k^{(\\mu)}</span>-special soundness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 4 (AMSS implies Knowledge Soundness).</strong> If a <span class="math">\\mu</span>-round interactive proof for a relation <span class="math">\\mathcal{R}</span> with <span class="math">\\lambda</span>-bit challenges, $\\mu \\in O(\\log (\\lambda +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, and verifier decision algorithm runtime </span>t_V \\in \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\lambda)<span class="math"> on input </span>\\mathbf{x} \\in \\mathcal{L}_{\\mathcal{R}}<span class="math"> and parameters </span>\\mathsf{pp} \\gets \\Gamma \\cdot \\mathrm{Setup}(1^{\\lambda})$ is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">9 Crucially, the definition does not require the i th position of all transcripts to use the same commitment index. The commitment index \\mu_{i} used in a particular transcript for the i th commitment C^{(i)} might be a function of the transcript prefix preceding C^{(i)} .</p>

    <p class="text-gray-300"><span class="math">(k^{(\\mu)},\\delta,\\Gamma,\\phi)</span>-almost-special-sound then for <span class="math">\\delta^{\\prime}(\\lambda)=2\\lambda(k+1)^{\\mu}(\\mu+t_{V})\\cdot\\max(\\delta(\\lambda),k\\cdot 2^{-\\lambda})+2^{-\\lambda}</span> it is <span class="math">\\delta^{\\prime}</span>-knowledge sound for the modified relation:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}^{\\prime}(\\mathsf{pp})=\\{(x,w):\\mathcal{R}(x,w)=1\\ \\ \\vee w\\in\\mathcal{L}_{\\mathsf{break}}(\\mathsf{pp})\\}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathsf{break}}(\\mathsf{pp})=\\{(\\mathcal{C},\\sigma_{1},\\sigma_{2},\\iota):\\iota\\in\\mathcal{I}\\ \\wedge\\ \\sigma_{1}\\neq\\sigma_{2}\\ \\wedge\\ \\mathsf{Open}(\\mathsf{pp},\\mathcal{C},\\sigma_{1})=\\mathsf{Open}(\\mathsf{pp},\\mathcal{C},\\sigma_{2})=1\\}</span></p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Remark 8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\delta^{\\prime}(\\lambda)</span> is a negligible function if <span class="math">\\delta(\\lambda)</span> is negligible, assuming <span class="math">k\\in O(1)</span>, $\\mu\\in O(\\log(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, </span>t_{V}\\in\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\lambda)<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathsf{poly}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of Theorem 4 is in Appendix B. By Lemma 5, this theorem has the following corollary:</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Corollary 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An interactive proof with <span class="math">\\lambda</span>-bit challenges that is <span class="math">k^{(\\mu)}</span>-almost-special-sound for a relation <span class="math">\\mathcal{R}</span> and has at most $\\mu\\in O(\\log(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> rounds on any instance </span>x\\in\\mathcal{L}_{\\mathcal{R}}<span class="math"> has witness-extended emulation for </span>\\mathcal{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-51" class="text-2xl font-bold">7 Argument of knowledge of “short” rational opening</h2>

    <p class="text-gray-300">For any deterministic homomorphic commitment to vectors in <span class="math">\\mathbb{Z}_{p}^{n}</span>, where the commitment function is a homomorphism <span class="math">\\mathsf{com}:\\mathbb{Z}_{p}^{n}\\to\\mathbb{G}</span>, there is a generic succinct argument of knowledge of a commitment opening (i.e., a homomorphism preimage) with <span class="math">O(\\log n)</span> communication complexity <em>[x1, x2, x3]</em>. This same protocol can also be used to argue knowledge of any linear form of the committed vector. This is also known as a linear-map vector commitment (LMVC) <em>[x10, x5]</em>, and captures polynomial commitments as a special case.</p>

    <p class="text-gray-300">We generalize this result to work with deterministic homomorphic integer vector commitments that are only binding over <em>short</em> vectors in <span class="math">\\mathbb{Z}^{n}</span>, which includes vector commitment schemes based on lattices and groups of unknown order. Furthermore, the protocol can still be used to argue knowledge of any linear form <span class="math">h:\\mathbb{Z}^{n}\\to\\mathbb{G}</span> of the committed vector, where <span class="math">\\mathbb{G}</span> is a prime order group. The protocol is essentially the same as the succinct homomorphism preimage protocol <em>[x1, x2]</em>, but where the verifier additionally checks a bound on the prover’s final message. This can also be viewed as a special case of the sumcheck argument with a bound check, as described in <em>[x3]</em>, but we provide a much tighter soundness analysis.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A bit more precisely, the protocol is not an argument of knowledge of a short integer vector pre-image per se, but rather a <em>short rational</em> opening of the commitment <span class="math">C=\\mathsf{com}(x)</span>, which is some <span class="math">x^{\\prime}\\in\\mathbb{Z}^{n}</span> and <span class="math">z\\in\\mathbb{Z}</span> such that <span class="math">\\mathsf{com}(x^{\\prime})=z\\cdot C</span> and <span class="math">x^{\\prime}/z\\in\\mathcal{M}\\subseteq\\mathbb{Q}^{n}</span> where $\\mathcal{M}=\\{x/2\\in\\mathbb{Q}^{n}:z\\in\\mathbb{Z},gcd(x,z)=1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta_{n},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta_{d}\\}<span class="math"> is a subset of rational vectors with bounded norm denominators and numerators in reduced form. We call this an opening of the commitment </span>C<span class="math"> to the rational vector </span>x^{\\prime}/z\\in\\mathcal{M}<span class="math">. If the commitment scheme is binding over such rational openings to vectors in </span>\\mathcal{M}<span class="math"> and </span>[0,p)^{n}\\subseteq\\mathcal{M}<span class="math">, then it also functions as a binding commitment scheme for vectors in </span>\\mathbb{Z}_{p}^{n}<span class="math"> where an opening to </span>m\\in\\mathcal{M}<span class="math"> is also an opening to </span>m\\bmod p\\in\\mathbb{Z}_{p}^{n}<span class="math"> and the protocol is thus an argument of knowledge of an opening to a unique vector in </span>\\mathbb{Z}_{p}^{n}<span class="math">. Finally, for any linear form </span>h:\\mathbb{Z}_{p}^{n}\\to\\mathbb{G}<span class="math"> the modified commitment </span>\\mathsf{com}^{<em>}(x)=(\\mathsf{com}(x),h(x))<span class="math"> preserves binding over </span>\\mathcal{M}<span class="math"> and running the same protocol for </span>\\mathsf{com}^{</em>}<span class="math"> becomes an argument of knowledge for an opening of the commitment </span>(C,y)<span class="math"> to a unique </span>x^{<em>}\\in\\mathbb{Z}_{p}^{n}<span class="math"> such that </span>h(x^{</em>})=y$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-52" class="text-base font-semibold mt-4">Remark on zero-knowledge</h5>

    <p class="text-gray-300">Deterministic commitment schemes are non-hiding and our construction is focussed on producing a succinct argument of knowledge without concern for zero-knowledge. To obtain a zero-knowledge argument, the succinct argument can be composed with (i.e., applied as the pivot to) a sigma protocol for pre-images of <span class="math">\\phi</span>. See <em>[x1]</em> for further details.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 6 (<span class="math">\\mathbb{Z}</span>-linear commitment scheme).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\Gamma=(\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit},\\mathsf{Open})</span> be a deterministic commitment scheme such that for any <span class="math">\\mathsf{pp}=(\\mathcal{I},\\mathcal{M},\\mathcal{W})\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span> where <span class="math">\\mathcal{M}\\subseteq\\mathcal{W}\\subseteq\\mathbb{Z}^{n}</span> and <span class="math">\\iota\\in\\mathcal{I}</span> the commitment function <span class="math">\\mathsf{Commit}(\\mathsf{pp},\\cdot):\\mathcal{M}\\to\\mathbb{G}</span> is the restriction $h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{M}}<span class="math"> of a group homomorphism </span>h:\\mathbb{Z}^{n}\\to\\mathbb{G}<span class="math">. We say that </span>\\Gamma<span class="math"> is a </span>\\mathbb{Z}$-linear deterministic commitment scheme.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 7 (Rational openings).</h6>

    <p class="text-gray-300">Let <span class="math">\\Gamma=(\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit},\\mathsf{Open})</span> be <span class="math">\\mathbb{Z}</span>-linear deterministic commitment scheme where commitments are contained within a finite group <span class="math">\\mathbb{G}</span>. Let <span class="math">\\mathcal{W}^{<em>}\\subseteq\\mathbb{Q}^{n}</span> and let <span class="math">\\mathsf{Setup}^{</em>}(1^{\\lambda})</span> denote a new setup algorithm that runs <span class="math">\\mathsf{Setup}(1^{\\lambda})</span> but</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">replaces <span class="math">\\mathcal{W}</span> with <span class="math">\\mathcal{W}^<em></span>. Let <span class="math">\\mathrm{Open}^</em>(\\mathsf{pp}, C, \\mathbf{x}/z, (z, \\mathbf{x}, \\sigma))</span> denote a new opening verification algorithm which on inputs <span class="math">z \\in \\mathbb{Z}</span>, <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span> such that <span class="math">\\mathbf{x}/z \\in \\mathcal{W}^*</span> and <span class="math">C \\in \\mathbb{G}</span> returns 1 if and only if $z \\neq 0 \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\mathrm{Open}(\\mathsf{pp}, z \\cdot C, \\mathbf{x}, \\sigma) = 1<span class="math">. We call the opening hint </span>(z, \\mathbf{x}, \\sigma)<span class="math"> a rational opening of </span>C<span class="math"> to </span>\\mathbf{x}/z \\in \\mathcal{W}^<em><span class="math">. We say </span>\\Gamma<span class="math"> is binding over rational openings to </span>\\mathcal{W}^</em> \\subseteq \\mathbb{Q}^n<span class="math"> if </span>\\Gamma^<em> = (\\mathrm{Setup}^</em>, \\mathcal{G}, \\mathrm{Commit}, \\mathrm{Open}^*)$ satisfies the usual definition of commitment binding (See Definition 4).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 6 (trivial).</strong> If <span class="math">(\\mathsf{Setup}, \\mathcal{G}, \\mathsf{Commit}, \\mathsf{Open})</span> is a <span class="math">\\mathbb{Z}</span>-linear deterministic commitment scheme binding over <span class="math">\\mathcal{W} \\subseteq \\mathbb{Q}^n</span> where <span class="math">\\mathsf{Commit}(\\mathsf{pp}_i, \\cdot): \\mathbb{Z}^n \\to \\mathbb{G}_{\\mathsf{com}}</span> and <span class="math">h: \\mathbb{Z}^n \\to \\mathbb{G}</span> is any homomorphism, then the modified scheme <span class="math">(\\mathsf{Setup}, \\mathcal{G}, \\mathsf{Commit}, \\mathsf{Open}^*)</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(1^{\\lambda}) \\to \\mathsf{pp}</span> and <span class="math">\\mathcal{G}(\\iota, \\mathsf{pp}) \\to \\mathsf{pp}_{\\iota}</span></li>

      <li><span class="math">\\operatorname{Commit}^*(\\mathsf{pp}_i, \\mathbf{x} \\in \\mathbb{Z}^n) \\to (\\operatorname{Commit}(\\mathsf{pp}_i, \\mathbf{x}), h(\\mathbf{x})) \\in \\mathbb{G}_{\\mathsf{com}} \\times \\mathbb{G}</span></li>

      <li><span class="math">\\operatorname{Open}^*(\\mathsf{pp}_i, (C, y) \\in \\mathbb{G}_{\\mathsf{com}} \\times \\mathbb{G}, \\mathbf{x} \\in \\mathbb{Z}^n, s) \\to \\operatorname{Open}(\\mathsf{pp}_i, \\mathbf{x}, s, C)</span></li>

    </ul>

    <p class="text-gray-300">is also a <span class="math">\\mathbb{Z}</span>-linear deterministic commitment scheme binding over <span class="math">\\mathcal{W}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Any break of the modified scheme includes a break of the original scheme, i.e. tuples <span class="math">(\\mathbf{x}, \\iota, s, (C, y))</span> and <span class="math">(\\mathbf{x}&#x27;, \\iota, s&#x27;, (C, y))</span> such that <span class="math">\\mathbf{x} \\neq \\mathbf{x}&#x27; \\in \\mathcal{W}</span> and <span class="math">\\mathrm{Open}(\\mathsf{pp}_i, C, \\mathbf{x}, s) = 1</span> and <span class="math">\\mathrm{Open}(\\mathsf{pp}_i, C, \\mathbf{x}&#x27;, s&#x27;) = 1</span>. <span class="math">\\square</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Commitment schemes binding over bounded rationals</strong> Let <span class="math">\\beta = \\beta_{\\mathfrak{n}} \\cdot \\beta_{\\mathfrak{d}}</span> for some <span class="math">\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}} &amp;gt; 0</span>. Let $\\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}}) := \\{\\mathbf{x} / z \\in \\mathbb{Q}^n : z \\in \\mathbb{Z},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}\\}<span class="math">. The following lemmas establish several families of integer vector commitment schemes that are binding over </span>\\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let <span class="math">\\Gamma = (\\mathsf{Setup}, \\mathcal{G}, \\mathsf{Commit}, \\mathsf{Open})</span> denote any <span class="math">\\mathbb{Z}</span>-linear deterministic commitment scheme that maps <span class="math">\\mathbb{Z}^n \\to \\mathbb{G}^k</span> where for any <span class="math">\\iota \\in \\mathcal{I}</span> and <span class="math">\\mathsf{pp}_{\\iota} = \\mathcal{G}(\\mathsf{pp}, \\iota)</span> the algorithm <span class="math">\\mathsf{Open}(\\mathsf{pp}_{\\iota}, C, \\mathbf{x})</span> receives no hint and simply checks <span class="math">C = \\mathsf{Commit}(\\mathsf{pp}_{\\iota}, \\mathbf{x}) = \\langle \\mathbf{x}, \\mathbf{g}_{\\mathsf{pp}_{\\iota}} \\rangle</span> where <span class="math">\\mathbf{g}_{\\mathsf{pp}_{\\iota}} \\in \\mathbb{G}^{n \\times k}</span> is a basis for the homomorphism. Let <span class="math">\\mathcal{A}(\\mathsf{pp})</span> denote a polynomial time algorithm that on input <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span> returns <span class="math">\\iota \\in \\mathcal{I}</span>, <span class="math">(z, \\mathbf{x})</span>, <span class="math">(z&#x27;, \\mathbf{x}&#x27;) \\in \\mathbb{Z} \\times \\mathbb{Z}^n</span> and <span class="math">Y \\in \\mathbb{G}</span> such that with probability non-negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300">(a) <span class="math">z^{\\prime}\\mathbf{x}\\neq z\\mathbf{x}^{\\prime}</span> (b) <span class="math">\\frac{\\mathbf{x}}{z}, \\frac{\\mathbf{x}&#x27;}{z&#x27;} \\in \\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})</span> (c) <span class="math">z\\cdot Y = \\mathsf{Commit}(\\mathsf{pp}_{\\iota},\\mathbf{x})</span> and <span class="math">z^{\\prime}\\cdot Y = \\mathsf{Commit}(\\mathsf{pp}_{\\iota},\\mathbf{x}^{\\prime})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(d) $z, z' \\neq 0 \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and either </span>\\frac{\\mathbf{x}}{z} \\neq 0 \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> or </span>\\frac{\\mathbf{x}'}{z'} \\neq 0 \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is prime then </span>\\mathcal{A}<span class="math"> breaks the binding of </span>\\Gamma<span class="math"> over </span>\\mathcal{W}_{\\beta} = \\{\\mathbf{x} \\in \\mathbb{Z}^n :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta\\}<span class="math">. Otherwise, </span>\\mathcal{A}<span class="math"> either breaks the binding property over </span>\\mathcal{W}_{\\beta}<span class="math"> or outputs an element </span>u<span class="math"> in the span of </span>\\mathbf{g}_{\\mathrm{pp}_i}$ and an integer multiple of its order.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Let <span class="math">\\mathsf{com} := \\mathsf{Commit}(\\mathsf{pp}_i, \\cdot)</span>. Condition (c) implies <span class="math">\\mathsf{com}(z&#x27; \\cdot \\mathbf{x}) = \\mathsf{com}(z \\cdot \\mathbf{x}&#x27;)</span>. Condition (b) implies <span class="math">\\frac{\\mathbf{x}}{z} = \\frac{\\mathbf{x}_1}{z_1}</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}<span class="math"> where </span>gcd(\\mathbf{x}_1, z_1) = 1<span class="math">, and likewise </span>\\frac{\\mathbf{x}'}{z'} = \\frac{\\mathbf{x}_2}{z_2}<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}<span class="math"> where </span>gcd(\\mathbf{x}_2, z_2) = 1<span class="math">. Let </span>\\Delta_1 = z / z_1 \\in \\mathbb{Z}<span class="math"> and </span>\\Delta_2 = z' / z_2 \\in \\mathbb{Z}<span class="math"> and let </span>\\Delta = \\Delta_1 \\cdot \\Delta_2<span class="math">. These relations imply that </span>\\Delta \\cdot \\mathsf{com}(z_2 \\cdot \\mathbf{x}_1) = \\Delta \\cdot \\mathsf{com}(z_1 \\cdot \\mathbf{x}_2)<span class="math"> where, condition (b) implies that, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_1 \\cdot \\mathbf{x}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_2 \\cdot \\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math">. Finally, </span>\\Delta \\neq 0 \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by condition (d) and </span>z_2 \\cdot \\mathbf{x}_1 \\neq z_1 \\cdot \\mathbf{x}_2<span class="math"> by condition (a). Let </span>\\mathbf{x}^<em> = z_2 \\cdot \\mathbf{x}_1 - z_1 \\cdot \\mathbf{x}_2<span class="math"> and </span>u = \\mathsf{com}(\\mathbf{x}^</em>)<span class="math">. We have established that </span>\\mathbf{x}^* \\neq 0<span class="math"> and </span>\\Delta \\cdot u = 0<span class="math"> and </span>\\Delta \\neq 0 \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q<span class="math"> is prime, then the space of commitments is a </span>\\mathbb{Z}_q<span class="math">-module and this implies </span>\\mathsf{com}(z_2 \\cdot \\mathbf{x}_1) = \\mathsf{com}(z_1 \\cdot \\mathbf{x}_2)<span class="math">, which breaks the binding of </span>\\Pi_{\\mathsf{cm}}<span class="math"> over </span>\\mathcal{W}_{\\beta}<span class="math">. If </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is not prime, then either </span>u<span class="math"> is the zero vector, which breaks binding over </span>\\mathcal{W}_{\\beta}<span class="math">, or otherwise </span>\\Delta<span class="math"> must be a multiple of the order of </span>u \\in \\mathbb{G}^k<span class="math">, which is in the span of </span>\\mathbf{g}_{\\mathsf{pp}_i}<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Corollary 3 (Homomorphic prime-order commitments).</strong> Let <span class="math">\\Gamma = (\\mathsf{Setup}, \\mathcal{G}, \\mathsf{Commit}, \\mathsf{Open})</span> denote any <span class="math">\\mathbb{Z}</span>-linear deterministic commitment scheme where the commitments are contained within a <span class="math">k</span>-dimensional <span class="math">\\mathbb{Z}</span>-module <span class="math">\\mathbb{G}^k</span> and <span class="math">\\mathbb{G}</span> is a group of prime-order <span class="math">q</span>. Suppose that for non-zero <span class="math">C</span> the algorithm <span class="math">\\mathsf{Open}(\\mathsf{pp}_i, C, \\mathbf{x})</span> checks <span class="math">\\mathsf{Commit}(\\mathsf{pp}_i, \\mathbf{x}) = C</span> and the element <span class="math">\\mathbf{0}_{\\mathbb{G}} \\in \\mathbb{G}^k</span> is the unique valid commitment to <span class="math">\\mathbf{0} \\in \\mathbb{Z}^n</span>. If <span class="math">\\Gamma</span> is binding over $\\mathcal{W}_{\\beta} = \\{\\mathbf{x} \\in \\mathbb{Z}^n :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta\\}<span class="math"> then </span>\\Gamma<span class="math"> is also binding over rational openings to </span>\\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">21</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Suppose there exists a polynomial time algorithm  <span class="math">\\mathcal{A}(\\mathsf{pp})</span>  that on input  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>  returns  <span class="math">\\iota \\in \\mathcal{I}</span>  and  <span class="math">C \\in \\mathbb{G}^k</span>  and conflicting valid openings  <span class="math">(z, \\mathbf{x}), (z&#x27;, \\mathbf{x}&#x27;) \\in \\mathbb{Z} \\times \\mathbb{Z}^n</span>  of  <span class="math">C</span>  to  <span class="math">\\mathbf{x}/z \\neq \\mathbf{x}&#x27;/z&#x27; \\in \\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})</span>  with probability non-negligible in  <span class="math">\\lambda</span> . By validity of the openings  <span class="math">z, z&#x27; \\neq 0 \\bmod q</span> . If  <span class="math">\\mathbf{x} = \\mathbf{0} \\bmod q</span>  then  <span class="math">z \\cdot C = \\mathsf{Commit}(\\mathsf{pp}_{\\iota}, \\mathbf{x}) = \\mathbf{0}_{\\mathbb{G}}</span> , which implies  <span class="math">C = \\mathbf{0}_{\\mathbb{G}}</span>  because  <span class="math">z \\neq 0 \\bmod q</span>  and  <span class="math">q</span>  is prime. If  <span class="math">C = \\mathbf{0}_{\\mathbb{G}}</span>  then only  <span class="math">\\mathbf{x} = \\mathbf{x}&#x27; = 0</span>  would be accepted as valid openings of  <span class="math">z \\cdot C</span>  and  <span class="math">z&#x27; \\cdot C</span>  respectively, contradicting  <span class="math">\\mathbf{x}/z \\neq \\mathbf{x}&#x27;/z&#x27;</span> . This shows that  <span class="math">\\mathbf{x} \\neq \\mathbf{0} \\bmod q</span>  and the same argument shows that  <span class="math">\\mathbf{x}&#x27; \\neq \\mathbf{0} \\bmod q</span> . Therefore, by Lemma 7,  <span class="math">\\mathcal{A}(\\mathsf{pp})</span>  breaks the binding of  <span class="math">\\Pi</span>  over  $\\mathcal{W}_{\\beta} = \\{\\mathbf{x} \\in \\mathbb{Z}^n :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta\\}$ , a contradiction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Homomorphic prime-order examples. Examples of commitments to integer vectors that satisfy the conditions in Corollary 3 trivially include Pedersen commitments but also Ajtai commitments based on Integer-SIS/Ring-SIS/Module-SIS. Let  <span class="math">q</span>  be a prime, let  <span class="math">n, \\kappa \\in \\mathbb{N}</span>  denote security parameters, Let  <span class="math">\\Phi_m(x)</span>  be the  <span class="math">m</span> -th cyclotomic polynomial <span class="math">^{11}</span>  (i.e., its roots are the primitive  <span class="math">m</span> -th roots of unity). Let  <span class="math">\\mathcal{R} = \\mathbb{Z}[x] / \\Phi_m</span>  and  <span class="math">\\mathcal{R}_q = \\mathbb{Z}_q[x] / \\Phi_m</span> , and let  <span class="math">n = n(m)</span>  and  <span class="math">B = B(m)</span>  be functions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Integer-SIS. The problem  <span class="math">\\mathrm{SIS}_{n,q,m,B}</span>  is: given  <span class="math">\\mathbf{A} \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_q^{n \\times n}</span> , find  <span class="math">\\mathbf{z} \\in \\mathbb{Z}^n</span>  such that  <span class="math">\\mathbf{A} \\cdot \\mathbf{z} = 0^m \\mod q</span>  and  $0 &lt; \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B$ .</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Module-SIS. For some  <span class="math">\\kappa &amp;gt; 0</span> , the problem  <span class="math">\\mathrm{M - SIS}_{\\kappa, n, q, m, B}</span>  is: given  <span class="math">\\mathbf{A} \\stackrel{\\S}{\\leftarrow} \\mathcal{R}_q^{\\kappa \\times n}</span> , find  <span class="math">\\mathbf{z} \\in \\mathcal{R}^n</span>  such that  <span class="math">\\mathbf{A} \\cdot \\mathbf{z} = 0^\\kappa \\bmod q</span>  and  $0 &lt; \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbf{z} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\leq B$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that SIS and R-SIS are both special cases of M-SIS, with appropriate setting of the parameters. For example, Ring-SIS is the same as Module-SIS when  <span class="math">\\kappa = 1</span> . All three problems are related to certain worst case lattice problems, and are believed to be hard for appropriate settings of the parameters  <span class="math">n, q, m, B</span> , and  <span class="math">\\kappa</span> . In particular, these problems are believed to be post-quantum secure when the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Integer-SIS [MP13; GPV08]  <span class="math">m</span>  sufficiently large and  <span class="math">n, \\log(q) \\leq poly(m)</span>  and  <span class="math">q \\geq B\\sqrt{m} \\cdot \\omega(\\sqrt{\\log m})</span> .</li>

      <li>Module-SIS [LS15, Th. 3.6]:  <span class="math">m\\kappa</span>  sufficiently large and  <span class="math">q &amp;gt; B \\cdot (m\\kappa)^{1/2}\\omega(\\sqrt{\\log m\\kappa})</span> , and both  <span class="math">n</span>  and  <span class="math">\\log q</span>  are less than  <span class="math">\\mathrm{poly}(m\\kappa)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 4 (Homomorphic GUO commitments). Let  <span class="math">\\Gamma = (\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit},\\mathsf{Open})</span>  denote any  <span class="math">\\mathbb{Z}</span> -linear deterministic commitment scheme where for any  <span class="math">\\mathsf{pp}</span> ,  <span class="math">\\iota</span> , and  <span class="math">\\mathsf{pp}_{\\iota} = \\mathcal{G}(\\mathsf{pp},\\iota)</span>  the function  <span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\iota}):\\mathbb{Z}^n\\to \\mathbb{G}</span>  is a homomorphism with basis  <span class="math">\\mathbf{g}_{\\mathsf{pp}_{\\iota}}</span> . Suppose that the subgroup hidden order assumption for  <span class="math">\\mathbb{G}</span>  holds with respect to the distribution over subgroups  <span class="math">\\langle \\mathbf{g}_{\\mathsf{pp}_{\\iota}}\\rangle \\subseteq \\mathbb{G}</span>  induced by sampling  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(1^{\\lambda})</span>  and any adversarially sampled  <span class="math">\\iota \\in \\mathcal{I}</span> . If  <span class="math">\\Gamma</span>  is binding over  $\\mathcal{W}_{\\beta} = \\{\\mathbf{x}\\in \\mathbb{Z}^{n}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\}<span class="math">  then  </span>\\Gamma<span class="math">  is also binding over rational openings to  </span>\\mathcal{W}(\\beta_{\\mathfrak{n}},\\beta_{\\mathfrak{d}})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Corollary 5 (DARK commitments). The integer vector commitment scheme known as DARK [BFS20] uses a group of unknown order  <span class="math">\\mathbb{G}</span>  and for  <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span>  computes the homomorphism  <span class="math">\\mathbf{x} \\mapsto g^{f_{\\mathbf{x}}(q)}</span> , where  <span class="math">f_{\\mathbf{x}}(q) = \\sum_{i=1}^{n} \\mathbf{x}_i q^{i-1}</span> , given setup parameters  <span class="math">q \\in \\mathbb{N}</span>  and  <span class="math">g \\in \\mathbb{G}</span>  sampled uniformly at random. Setting  <span class="math">q = \\lceil 2\\sqrt{n}\\beta \\rceil</span> , DARK is binding over rational openings to  <span class="math">\\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})</span>  based on the hidden order assumption in  <span class="math">\\mathbb{G}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. For  <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span>  let  <span class="math">f_{\\mathbf{x}}</span>  denote the univariate polynomial with coefficient vector  <span class="math">\\mathbf{x}</span> . By Fact 1,  <span class="math">f_{\\mathbf{x}}(q) \\neq f_{\\mathbf{x}&#x27;}(q)</span>  for all  <span class="math">\\mathbf{x} \\neq \\mathbf{x}&#x27;</span>  of  <span class="math">L_{\\infty}</span>  norm at most  <span class="math">q/2</span>  which is guaranteed if the  <span class="math">L_2</span>  norm is at most  <span class="math">q/(2\\sqrt{n})</span> . By the hidden order assumption (Assumption 1) no polynomial-time adversary can compute integers  <span class="math">x \\neq y</span>  such that  <span class="math">g^x = g^y</span>  for  <span class="math">g \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> . DARK is therefore binding over  $\\mathcal{W}_{\\beta} = \\{\\mathbf{x} \\in \\mathbb{Z}^n :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta\\}<span class="math">  for  </span>q \\geq 2\\sqrt{n}\\beta<span class="math">  by the hidden order assumption, and as a corollary to Lemma 7 it is also binding over  </span>\\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})$  under the hidden order assumption.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 8. We define a integer matrix norm family <span class="math">\\mathcal{F}</span> as an infinite collection <span class="math">\\mathcal{F} = \\{\\mathcal{N}_{m,n}\\}</span> of matrix norms <span class="math">\\mathcal{N}_{m,n}:\\mathbb{Z}^{m\\times n}\\to \\mathbb{R}</span>. We say that the <span class="math">\\mathcal{F}</span> is <span class="math">\\alpha (m,n,k)</span>-submultiplicative if for all <span class="math">m,n,k\\in \\mathbb{N}</span>, <span class="math">M\\in \\mathbb{Z}^{m\\times n}</span>, and <span class="math">X\\in \\mathbb{Z}^{n\\times k}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {N} _ {m, k} (M \\cdot X) \\leq \\alpha (m, n, k) \\cdot \\mathcal {N} _ {m, n} (M) \\cdot \\mathcal {N} _ {n, k} (X)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 8. Let <span class="math">(\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit},\\mathsf{Open})</span> be any <span class="math">\\mathbb{Z}</span>-linear deterministic commitment scheme that is binding over $\\mathcal{W}_{\\beta} = \\{\\mathbf{x}\\in \\mathbb{Z}^n:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\}<span class="math">, where the norm </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> belongs to an </span>\\alpha<span class="math">-submultiplicative norm family. Let </span>U:\\mathbb{Z}^{m}\\to \\mathbb{Z}^{n}<span class="math"> denote any injective linear map, i.e. </span>U\\in \\mathbb{Z}^{m\\times n}<span class="math"> is a full row rank matrix. Then the modified scheme </span>(\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit}^{<em>},\\mathsf{Open}^{</em>})<span class="math"> over </span>\\mathbb{Z}^m$ where:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commit <span class="math">^{*}</span> (pp, x ∈ Z <span class="math">^m</span> ) → Commit(pp, x · U)</li>

      <li>Open <span class="math">^{*}</span> (pp, C, x ∈ Z <span class="math">^m</span>, s) → Open(pp, C, x · U, s)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is binding over $\\mathcal{W}^* = \\{\\mathbf{x}\\in \\mathbb{Z}^m:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{\\beta}{\\alpha\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Suppose <span class="math">(C, \\mathbf{x} \\in \\mathbb{Z}^m, s)</span> and <span class="math">(C, \\mathbf{x}&#x27; \\in \\mathbb{Z}^m, s&#x27;)</span> are both accepted by <span class="math">\\mathsf{Open}^<em></span> for distinct <span class="math">\\mathbf{x}, \\mathbf{x}&#x27; \\in \\mathcal{W}^</em></span>, then both <span class="math">(C, \\mathbf{x} \\cdot U, s)</span> and <span class="math">(\\mathbf{x}&#x27; \\cdot U, s&#x27;, C)</span> are accepted by <span class="math">\\mathsf{Open}</span>. Since <span class="math">U</span> is injective, <span class="math">\\mathbf{x} \\cdot U \\neq \\mathbf{x}&#x27; \\cdot U</span>. Furthermore, since the norm is <span class="math">\\alpha</span>-submultiplicative, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x} \\cdot U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\alpha \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math">. Similarly, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}' \\cdot U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math">. This contradicts the binding of </span>(\\mathsf{Setup}, \\mathcal{G}, \\mathsf{Commit}, \\mathsf{Open})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 9. Let (Setup, G, Commit, Open) be any Z-linear deterministic commitment scheme that is binding over rational openings to <span class="math">\\mathcal{W}(\\beta_{\\mathfrak{n}},\\beta_{\\mathfrak{d}})</span>, where the norm $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> belongs to an </span>\\alpha<span class="math">-submultiplicative norm family. Let </span>U:\\mathbb{Z}^m\\to \\mathbb{Z}^n<span class="math"> denote any injective linear map, i.e. </span>U\\in \\mathbb{Z}^{m\\times n}<span class="math"> is a full row rank matrix. Then the modified scheme (Setup, G, Commit<em>, Open</em>) over </span>\\mathbb{Z}^m$ where:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commit <span class="math">^{*}</span> (pp, x ∈ Z <span class="math">^m</span> ) → Commit(pp, x · U)</li>

      <li>Open <span class="math">^{*}</span> (pp, C, x ∈ Z <span class="math">^m</span>, s) → Open(pp, C, x · U, s)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is binding over $\\mathcal{W}(\\frac{\\beta_{\\mathfrak{n}}}{\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\beta_{\\mathfrak{d}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let $\\beta_{\\mathfrak{n}}^{*} = \\frac{\\beta_{\\mathfrak{n}}}{\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Suppose </span>(C, \\mathbf{x} \\in \\mathbb{Z}^m, z \\in \\mathbb{Z}, s)<span class="math"> and </span>(C, \\mathbf{x}' \\in \\mathbb{Z}^m, z' \\in \\mathbb{Z}, s')<span class="math"> are both accepted by </span>\\mathsf{Open}^<em><span class="math"> for distinct </span>\\mathbf{x}/z, \\mathbf{x}'/z \\in \\mathcal{W}(\\beta_{\\mathfrak{n}}^</em>, \\beta_{\\mathfrak{d}})<span class="math">, then both </span>(C, \\mathbf{x} \\cdot U, z, s)<span class="math"> and </span>(\\mathbf{x}' \\cdot U, z', s', C)<span class="math"> are accepted by </span>\\mathsf{Open}<span class="math">. Let </span>\\mathbf{x}/z = \\mathbf{x}_1/z_1<span class="math"> in reduced form so that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}^*<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}<span class="math">. Similarly, let </span>\\mathbf{x}'/z' = \\mathbf{x}_1'/z_1'<span class="math"> in reduced form so that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_1'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}^*<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_1'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}<span class="math">. Since the norm is </span>\\alpha<span class="math">-submultiplicative, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_1 \\cdot U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\alpha \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}<span class="math">. Similarly, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_1' \\cdot U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}<span class="math">. This shows that </span>\\mathbf{x} \\cdot U/z \\in \\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})<span class="math"> and </span>\\mathbf{x}' \\cdot U/z' \\in \\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})<span class="math">. Furthermore, since </span>z' \\mathbf{x} \\neq z \\mathbf{x}'<span class="math"> and </span>U<span class="math"> is injective, </span>z' \\mathbf{x} \\cdot U \\neq z \\mathbf{x}' \\cdot U$. This contradicts the binding of (Setup, G, Commit, Open).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-55" class="text-2xl font-bold">7.1 Interactive protocol for short rational openings</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The public input of the protocol is a homomorphism <span class="math">\\mathsf{com}:\\mathbb{Z}^n\\to \\mathbb{G}</span>, a target value <span class="math">C\\in \\mathbb{G}</span>, and a bound <span class="math">\\beta \\in \\mathbb{R}</span>. The honest prover has a witness <span class="math">\\mathbf{x}</span> of L2 norm at most <span class="math">\\beta</span> such that <span class="math">\\mathsf{com}(\\mathbf{x}) = C</span>. The prover's claim is that it knows some witness <span class="math">(z,\\mathbf{x})</span> such that <span class="math">\\mathsf{com}(\\mathbf{x}) = z\\cdot C</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\lambda \\log n}\\sqrt{\\xi}\\cdot \\beta<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sqrt{\\xi} /2^{\\lambda \\log n}<span class="math"> for a soundness slack parameter </span>\\xi<span class="math">. In other words, setting </span>\\beta_{\\mathfrak{n}} = 2^{\\lambda \\log n}\\sqrt{\\xi}\\cdot \\beta<span class="math"> and </span>\\beta_{\\mathfrak{d}} = \\sqrt{\\xi} /2^{\\lambda \\log n}<span class="math"> so that </span>\\beta_{\\mathfrak{n}}\\cdot \\beta_{\\mathfrak{d}} = \\xi \\cdot \\beta<span class="math">, the knowledge extractor for this protocol opens a valid rational opening for </span>C<span class="math"> as long as the commitment scheme is binding over </span>\\mathcal{W}(\\beta_{\\mathfrak{n}},\\beta_{\\mathfrak{d}}):= \\{\\mathbf{x} / z\\in \\mathbb{Q}^n:z\\in \\mathbb{Z},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\beta_{\\mathfrak{n}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}\\}<span class="math">. We prove that it suffices to set </span>\\xi = 2^{(16 + 2\\mu)\\lambda +6\\mathsf{CSZ}_{\\mu ,z} + 2\\mu +6}<span class="math">, where </span>\\mathsf{CSZ}_{\\log n,\\lambda}\\in O(\\log^2 n + \\lambda \\log \\log n)<span class="math"> is derived from the Multilinear Composite Schwartz Zippel (Theorem 2). Hence </span>\\xi \\in 2^{O(\\lambda \\log n + \\log^2 n)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{g} = (\\mathbf{g}_1, \\dots, \\mathbf{g}_n)</span> denote a basis of <span class="math">\\mathsf{com}</span> such that <span class="math">\\mathsf{com}(\\mathbf{x}) = \\langle \\mathbf{x}, \\mathbf{g} \\rangle</span>. The interactive protocol is essentially the succinct argument for homomorphism preimages from [BDFG21; AC20], but where the verifier additionally checks a bound on the prover's final message. This is also a special case of a sumcheck argument with a bound check, as described in [BCS21]. The prover's final message is an integer <span class="math">x^* \\in \\mathbb{Z}</span> and the verifier immediately rejects the proof unless $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^* \\leq \\beta \\cdot 2^{\\lambda \\log n}$. We include the full protocol in the figure below for completeness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An important observation, as first noted in [BBBPWM18] and leveraged in Halo [BGH19], is that the verifier does not use its input <span class="math">\\mathbf{g}</span> unless <span class="math">n = 1</span>. Thus, the verifier does not need to compute <span class="math">\\mathbf{g} \\in \\mathbb{G}^{2^r}</span> at each round of recursion. Instead, it only needs to compute the final <span class="math">g&#x27; \\in \\mathbb{G}</span> at the final round, which can be computed as <span class="math">g&#x27; = \\sum_{i=1}^{n} u_i \\mathbf{g}_i</span> where <span class="math">u_i</span> is the <span class="math">i</span>th coefficient of the polynomial <span class="math">u(X) = \\prod_{j=1}^{\\log n} (r_j + X^{2^{j-1}})</span> where <span class="math">r_j</span> is the verifier's challenge at the <span class="math">j</span>th round.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: A succinct interactive protocol for short rational openings. The honest prover's input must have norm at most  <span class="math">\\beta</span> . For simplicity  <span class="math">n</span>  is a power of 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Application: polynomial commitment scheme Given any prime  <span class="math">p</span>  of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\beta<span class="math">  and any deterministic homomorphic commitment scheme (Setup, com, Vf) that is binding over  </span>D = \\{\\mathbf{x} \\in \\mathbb{Z}^n :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\xi \\cdot \\beta\\}<span class="math"> , where  </span>\\mathsf{com} : \\mathbb{Z}^n \\to \\mathbb{G}_{\\mathsf{com}}<span class="math">  is a homomorphism and  </span>\\xi<span class="math">  is the slack parameter of the homomorphism-preimage (HPI) protocol, we can commit to the coefficient vector  </span>\\mathbf{x} \\in [0,p)^n<span class="math">  of a degree- </span>n<span class="math">  polynomial  </span>f_{\\mathbf{x}}(Z) = \\sum_{i} \\mathbf{x}_{i} Z^{i}<span class="math">  as  </span>C = \\mathsf{com}(\\mathbf{x})<span class="math">  and open evaluations of the committed polynomial at any point  </span>z \\in \\mathbb{Z}_p<span class="math">  to  </span>t = f_{\\mathbf{x}}(z)<span class="math">  by running the HPI protocol for the homomorphism  </span>\\mathbf{x} \\mapsto (\\mathsf{com}(\\mathbf{x}), f_{\\mathbf{x}}(z))<span class="math"> . Setting  </span>\\beta_1 = 2^{\\lambda \\log n} \\sqrt{\\xi} \\cdot \\beta<span class="math">  and  </span>\\beta_2 = \\sqrt{\\xi} / 2^{\\lambda \\log n}<span class="math"> , this protocol proves knowledge of a pair  </span>(a, \\mathbf{x}^<em>)<span class="math">  such that  </span>\\mathsf{com}(\\mathbf{x}^</em>) = a \\cdot C<span class="math">  and  </span>f_{\\mathbf{x}^*}(z) = a \\cdot t \\mod p<span class="math">  where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_1<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_2<span class="math"> . This is a valid rational opening of  </span>C<span class="math">  to  </span>\\mathbf{x}^<em> / a<span class="math"> , and by Corollary 3 the commitment is binding for rational openings in  </span>\\mathcal{W}(\\beta_1, \\beta_2)<span class="math"> . This proves for the polynomial  </span>f(X) = \\sum_{i} f_{\\mathbf{x}^</em>, i} / aX^i \\in \\mathbb{Z}_p<span class="math"> ,  </span>f(z) = t<span class="math"> . The protocol has logarithmic communication complexity but requires a linear verifier to compute the final  </span>g'$  value.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Special case: DARK rational openings with log verifier In the special case that  <span class="math">\\mathbb{G}</span>  is a group of unknown order and  <span class="math">\\operatorname{com}(\\mathbf{x}) = g^{f_{\\mathbf{x}}(q)}</span>  for  <span class="math">q \\in \\mathbb{N}</span>  and  <span class="math">g</span>  a random element in  <span class="math">\\mathbb{G}</span> , where  <span class="math">f_{\\mathbf{x}}(q) = \\sum_{i=1}^{n} \\mathbf{x}_{i} q^{i-1}</span> , the verifier complexity can be made logarithmic by adding a proof-of-exponentiation (PoE)[Wes19] step. By Corollary 5, for  <span class="math">q = \\lceil \\sqrt{n} 2\\xi \\beta \\rceil</span>  this commitment scheme is binding over vectors in  $\\{\\mathbf{x} \\in \\mathbb{Z}^n :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\xi \\beta\\}<span class="math">  and for any  </span>\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}} &gt; 0<span class="math">  such that  </span>\\beta_{\\mathfrak{n}} \\cdot \\beta_{\\mathfrak{d}} = \\xi \\beta<span class="math"> , is binding under rational openings to  </span>\\mathcal{W}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}}) := \\{\\mathbf{x}/z \\in \\mathbb{Q}^n : z \\in \\mathbb{Z},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\beta_{\\mathfrak{n}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When using this as a linear-map vector commitment scheme over  <span class="math">\\mathbb{F}_p</span> , where the honest prover may commit to any  <span class="math">\\mathbf{x} \\in [0, p)^n</span>  which has L2 norm at most  <span class="math">\\beta = \\sqrt{n} \\cdot p</span> , we would set  <span class="math">q = \\lceil n2\\xi p \\rceil</span> . The resulting interactive argument in this case is a slight variation of the DARK evaluation protocol.</p>

    <p class="text-gray-300">The verifier complexity is made logarithmic using a PoE as follows. Recall that the verifier only needs to compute the final round  <span class="math">g&#x27; = \\prod_{\\mathbf{x}} g_n^{n_i}</span>  where  <span class="math">u_i</span>  are the coefficients of  <span class="math">u(X) = \\prod_{j=1}^{\\log n} (r_j + X^{2^{j-1}})</span> . In this case,  <span class="math">\\mathbf{g}_{\\ell} = g^{(q&#x27;)}</span> , and thus  <span class="math">g&#x27; = g^{(\\sum_i u_i q&#x27;)} = g^{u(q)}</span> . The Wesolowski PoE[Wes19] enables a Prover to convince a Verifier that  <span class="math">Y = X^a \\in \\mathbb{G}</span>  for  <span class="math">X, Y \\in \\mathbb{G}</span>  and  <span class="math">a \\in \\mathbb{Z}</span> . In the protocol, the verifier sends a random 2λ-bit prime  <span class="math">\\ell</span> , and the prover computes  <span class="math">Q \\gets g^{(\\lfloor \\frac{a}{L} \\rfloor)}</span>  and sends it to the verifier. The verifier then computes  <span class="math">r \\gets a \\mod \\ell</span>  and checks that  <span class="math">Y = X^r + Q^\\ell</span> . The protocol is secure under the adaptive root assumption in  <span class="math">\\mathbb{G}</span> . Note that the verifier just has to compute  <span class="math">a \\mod \\ell</span>  and do two  <span class="math">O(\\lambda)</span> -bit scalar multiplications. The prover runs the PoE protocol on input  <span class="math">(g, g&#x27;, u(q))</span>  in order to show that  <span class="math">g&#x27;</span>  was constructed correctly. Note that the verifier can evaluate  <span class="math">u(q) \\mod \\ell</span>  in  <span class="math">O(\\log(n))</span>  field multiplications in  <span class="math">\\mathbb{F}_{\\ell}</span> . To do this the prover computes  <span class="math">q^{(2^j)} \\mod \\ell</span>  for  <span class="math">j \\in [0, \\log_2(n) - 1]</span>  using  <span class="math">\\log_2(n)</span>  multiplications. And then evaluates  <span class="math">u(q) \\mod \\ell = \\prod_{j=1}^{\\log n} (r_j + X^{2^{j-1}}) \\mod \\ell</span>  using another  <span class="math">\\log_2(n)</span>  multiplications. Alternatively, one can use Pietrzak's proof of exponentiation[Pie19]. The protocol only</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">works for powers of 2. The prover would send the <span class="math">g_i \\gets g^{q^{2^i}}</span> for all <span class="math">i \\in [0, \\log_2(n))</span>. The verifier can efficiently compute <span class="math">g^{u(q)}</span> given the <span class="math">g_i</span> values. The proof size would be <span class="math">O(\\log_2(n))</span>, but importantly, it can be instantiated without any assumptions in all groups [HHKKP22]. Using preprocessing of <span class="math">q</span>, it also has prover <span class="math">O(\\sqrt{n})</span>, independent of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-56" class="text-2xl font-bold">7.2 Almost special soundness analysis</h2>

    <p class="text-gray-300">Theorem 5 (Bulletproofs for short openings is AMSS). Let <span class="math">n = 2^{\\mu}</span> for <span class="math">\\mu \\geq 1</span>. Let <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda} = 8\\mu^{2} + \\log_{2}(2\\mu)\\lambda</span>. Let <span class="math">\\Gamma = \\langle \\mathsf{Setup}, \\mathcal{G}, \\mathsf{Commit}, \\mathsf{Open} \\rangle</span> denote any <span class="math">\\mathbb{Z}</span>-linear deterministic commitment scheme satisfying the following conditions:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For <span class="math">\\beta_{\\mathfrak{n}} = 2^{\\lambda \\mu}\\sqrt{\\xi}\\cdot \\beta</span> and <span class="math">\\beta_{\\mathfrak{d}} = \\sqrt{\\xi} /2^{\\lambda \\mu}</span> where <span class="math">\\log \\xi = (14 + 2\\mu)\\lambda +6\\mathsf{CSZ}_{\\mu ,\\lambda} + 2(\\mu +4)</span> it is binding to $\\mathcal{W}(\\beta_{\\mathfrak{n}},\\beta_{\\mathfrak{d}}):= \\{\\mathbf{x} / z\\in \\mathbb{Q}^n:z\\in \\mathbb{Z},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\beta_{\\mathfrak{n}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}\\}$ under rational openings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Open}(\\mathsf{pp}_{\\iota},C,\\mathbf{x})</span> receives no hint, i.e. checks <span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\iota},\\mathbf{x}) = C</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The group <span class="math">\\mathbb{G}</span> defined for any <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span> is a GUO (i.e., the hidden order assumption holds in <span class="math">\\mathbb{G}</span>) or a <span class="math">\\mathbb{Z}_q</span>-module for prime <span class="math">q</span> (i.e., <span class="math">\\mathbb{G} = \\mathbb{G}_1^k</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> denote the interactive protocol which runs the protocol in Figure 2 for parameters <span class="math">\\beta</span> and <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> defined by <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^\\lambda)</span>, an index <span class="math">\\iota \\in \\mathcal{I}</span>, <span class="math">\\mathsf{pp}_{\\iota} = \\mathcal{G}(\\mathsf{pp}, \\iota)</span>, and <span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\iota}, \\mathbf{x}) = \\langle \\mathbf{x}, \\mathbf{g} \\rangle</span> for <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span>. There exists a predicate pair <span class="math">\\phi = (\\phi_a, \\phi_b)</span> and commitment scheme <span class="math">\\Gamma^<em></span> such that <span class="math">\\Pi</span> is an <span class="math">(4^{(\\mu)}, \\frac{3\\mu}{2^\\lambda}, \\Gamma^</em>, \\phi)</span>-almost-special-sound interactive argument for the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {S R O} _ {\\beta , \\mathsf {p p} _ {\\iota}} = \\left\\{\\left(C, \\mathsf {w} = (z, \\mathbf {x})\\right): \\langle \\mathbf {x}, \\mathbf {g} \\rangle = z \\cdot C \\text { and } \\mathbf {x} / z \\in \\mathcal {W} (\\beta_ {\\mathfrak {n}}, \\beta_ {\\mathfrak {d}}) \\right\\}</span></div>

    <p class="text-gray-300">Remark 9. Note that <span class="math">\\xi \\in 2^{O(\\lambda \\log n + \\log^2 n)}</span>. <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda}</span> is derived from the Multilinear Composite Schwartz Zippel Theorem (Theorem 2). We can also substitute any value for <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda}</span> using the table of concrete bounds in Theorem 3 for fixed 120-bit security in place of the analytical bound from Theorem 2).</p>

    <p class="text-gray-300">Proof. The commitment scheme <span class="math">\\Gamma^{<em>} = (\\mathsf{Setup}^{</em>},\\mathcal{G}^{<em>},\\mathsf{Commit}^{</em>},\\mathsf{Open}^{*})</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}^<em> (1^\\lambda)</span> first runs <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>, which determines <span class="math">\\mathbb{G}</span> and <span class="math">\\mathcal{I}</span> among other parameters. The new indexing set is defined as <span class="math">\\mathcal{I}^{</em>} = \\mathcal{I} \\cup \\bigcup_{i=1}^{\\mu} \\mathcal{I} \\times \\chi^{i}</span>.</li>

      <li><span class="math">\\mathcal{G}^{*}(\\mathsf{pp}, \\iota \\in \\mathcal{I}, \\mathbf{r} \\in \\chi^{i})</span> for <span class="math">i \\in [0, \\mu]</span> first computes <span class="math">\\mathsf{pp}_{\\iota} = \\mathcal{G}(\\mathsf{pp}, \\iota)</span> to determine the basis <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> such that <span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\iota}, \\mathbf{x}) = \\langle \\mathbf{x}, \\mathbf{g} \\rangle</span> for all <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span>, and then computes <span class="math">\\mathbf{g}^{(i)} = U_{i} \\cdot \\mathbf{g}</span> where <span class="math">U_{i} \\in \\mathbb{Z}^{2^{\\mu - i} \\times n}</span> is defined recursively as: <span class="math">U_{0} = I_{2^{\\mu}}</span> and <span class="math">U_{i} = (r_{i} \\cdot I_{2^{\\mu - i}} \\cdot I_{2^{\\mu - i}}) \\cdot U_{i - 1}</span> for <span class="math">i \\geq 1</span>. The notation <span class="math">I_{k}</span> for <span class="math">k \\in \\mathbb{N}</span> denotes the <span class="math">k \\times k</span> identity matrix. Let <span class="math">\\beta_{\\mathfrak{n}}^{(i)} = \\beta_{\\mathfrak{n}} \\cdot 2^{-(i\\lambda + \\frac{\\mu}{2})}</span> for <span class="math">i \\geq 1</span> and <span class="math">\\beta_{\\mathfrak{n}}^{(0)} = \\beta_{\\mathfrak{n}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The output <span class="math">\\mathsf{pp}_{\\iota, \\mathbf{r}}</span> determines the message space $\\mathcal{M}_i = \\{\\mathbf{x} \\in \\mathbb{Z}^{2^{\\mu - i}} :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}^{(i)}\\}<span class="math"> and opening space </span>\\mathcal{W}_i(\\beta_{\\mathfrak{n}}^{(i)}, \\beta_{\\mathfrak{d}}) = \\{\\mathbf{x} / z \\in \\mathbb{Q}^{2^{\\mu - i}} : z \\in \\mathbb{Z},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\beta_{\\mathfrak{n}}^{(i)},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}\\}<span class="math"> and includes </span>\\mathbf{g}^{(i)} \\in \\mathbb{G}^{2^{\\mu - i}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Commit}^* (\\mathsf{pp}_{\\iota ,\\mathbf{r}},\\mathbf{x}\\in \\mathbb{Z}^{2^{\\mu -i}})</span> returns <span class="math">C = \\langle \\mathbf{x},\\mathbf{g}^{(i)}\\rangle</span> as well as <span class="math">C_L = \\langle \\mathbf{x}_L,\\mathbf{g}_R^{(i)}\\rangle</span> and <span class="math">\\langle \\mathbf{x}_R,\\mathbf{g}_L^{(i)}\\rangle</span> for <span class="math">i\\in [1,\\mu ]</span>. Here <span class="math">\\mathbf{x}_L,\\mathbf{g}_L</span> denote the left half of <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{g}</span> respectively and <span class="math">\\mathbf{x}_R,\\mathbf{g}_R</span> the right. For <span class="math">i = 0</span>, it just returns <span class="math">C = \\langle \\mathbf{x},\\mathbf{g}\\rangle</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{Open}^<em> (\\mathsf{pp}_{\\iota ,\\mathbf{r}^</em>}(C,C_L,C_R),\\mathbf{x}\\in \\mathbb{Z}^{2^{\\mu -i}},z\\in \\mathbb{Z})</span> returns 1 iff <span class="math">\\mathbf{x} / z\\in \\mathcal{W}_i(\\beta_{\\mathfrak{n}}^{(i)},\\beta_{\\mathfrak{d}})</span> and <span class="math">\\langle \\mathbf{x},\\mathbf{g}^{(i)}\\rangle = z\\cdot C</span>, <span class="math">\\langle \\mathbf{x}_L,\\mathbf{g}_R^{(i)}\\rangle = z\\cdot C_L</span>, <span class="math">\\langle \\mathbf{x}_R,\\mathbf{g}_L^{(i)}\\rangle = z\\cdot C_R</span> and $z\\neq 0\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for </span>i\\in [1,\\mu -1]<span class="math">. For </span>i = 0<span class="math">, the </span>C_L<span class="math"> and </span>C_R<span class="math"> checks are omitted. (If </span>\\mathbb{G}<span class="math"> is a GUO, </span>z\\neq 0<span class="math"> suffices). For </span>i = \\mu<span class="math"> it returns 1 iff </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{n}}^{(\\mu)}<span class="math"> and </span>\\mathbf{x}\\cdot \\mathbf{g}^{(\\mu)} = C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The setup of the proof system determines the bound <span class="math">\\beta \\in \\mathbb{R}</span>, <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>, and an index <span class="math">\\iota</span> and <span class="math">\\mathsf{pp}_{\\iota} = \\mathcal{G}(\\mathsf{pp}, \\iota)</span> so that the protocol in Figure 2 is run on shared inputs <span class="math">\\beta</span>, <span class="math">C \\in \\mathbb{G}</span>, and <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> to the prover/verifier, where <span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\iota}, \\mathbf{x}) = \\langle \\mathbf{x}, \\mathbf{g} \\rangle</span> for <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span>. The parameters <span class="math">\\beta, \\mathsf{pp}_{\\iota}</span> thus determine the relation <span class="math">\\mathsf{SRO}_{\\beta, \\mathsf{pp}_{\\iota}}</span>. This setup can also be viewed as running <span class="math">\\mathsf{Setup}^<em>(1^{\\lambda})</span> as an extension of <span class="math">\\mathsf{Setup}(1^{\\lambda})</span>, which determines the same parameters. The public input <span class="math">C</span> to the relation <span class="math">\\mathsf{SRO}_{\\beta, \\mathsf{pp}_{\\iota}}</span> is thus a commitment for <span class="math">\\Gamma^</em></span> at index <span class="math">\\iota \\in \\mathcal{I}</span>. By construction, the <span class="math">i</span>th round prover message of the protocol for <span class="math">i \\in [1, \\mu]</span> is a commitment for <span class="math">\\Gamma^*</span> at index <span class="math">(\\iota, \\mathbf{r}_i) \\in \\mathcal{I} \\times \\chi^i</span> where <span class="math">\\mathbf{r}_i = (r_1, \\dots, r_i)</span> are the first <span class="math">i</span> round challenges in the protocol transcript.</p>

    <p class="text-gray-300">Let <span class="math">E_{i} = (r_{i}\\cdot I_{2^{\\mu -i}}\\quad I_{2^{\\mu -i}})</span> so that <span class="math">U_{i} = E_{i}\\cdot U_{i - 1}</span> for all <span class="math">i\\geq 1</span>. Right-multiplication by <span class="math">U_{0}</span> is injective. For <span class="math">i\\geq 1</span>, right-multiplication by <span class="math">E_{i}</span> is an injective map from</p>

    <p class="text-gray-300">13The CSZμ,λ value can be replaced with values from the table in Theorem 3</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{Z}^{2^{\\mu -i}}\\to \\mathbb{Z}^{2^{\\mu -i + 1}}</span>. Thus, by induction, right-multiplication by <span class="math">U_{i}</span> is an injective map from <span class="math">\\mathbb{Z}^{2^{\\mu -i}}\\to \\mathbb{Z}^{2^{\\mu}}</span>. The number of non-zero entries in <span class="math">U_{1}</span> is exactly <span class="math">2^{\\mu}</span>, and for each <span class="math">i &amp;gt; 1</span> the number of non-zero entries in <span class="math">U_{i}</span> is no greater than the number of non-zero entries in <span class="math">U_{i - 1}</span>. The entries of <span class="math">U_{i}</span> are subset products of <span class="math">\\{r_1,\\dots,r_i\\}</span> and thus each have absolute value at most <span class="math">2^{i\\lambda}</span>. Therefore, we can bound the Frobenius norm $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i\\lambda +\\frac{\\mu}{2}}<span class="math">. Let </span>\\beta_{n}^{(i)} = \\beta_{n}\\cdot 2^{-(i\\lambda +\\frac{\\mu}{2})}<span class="math">. Since the Frobenius norm is 1-submultiplicative, by Lemma 9, the commitment scheme </span>\\Gamma^{*}<span class="math"> at index </span>(\\iota ,\\mathbf{r}_i)<span class="math"> is binding over rational openings of </span>C_L,C_R<span class="math"> to </span>\\mathcal{W}_i(\\beta_n^{(i)} / ,\\beta_d)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each round of the protocol, let <span class="math">r_i</span> denote the <span class="math">i</span>th round challenge and <span class="math">(C_L^{(i)}, C_R^{(i)})</span> denote the <span class="math">i</span>th round prover messages for <span class="math">i \\in [0, \\mu - 1]</span>. Let <span class="math">x_\\mu \\in \\mathbb{Z}</span> denote the prover's <span class="math">\\mu</span>th round message. We define <span class="math">C_0 = C</span> (the input) and "virtual" messages <span class="math">C_{i+1} = C_L^{(i)} + r_{i+1}^2 C_R^{(i)} + r_{i+1} C^{(i)}</span> for each <span class="math">i \\in [0, \\mu - 1]</span>. In transcript trees we will denote by <span class="math">C^{(\\nu)}</span> the virtual commitment corresponding to a node index <span class="math">\\nu \\in [0, N]</span> (i.e., the virtual commitment defined by the partial transcript ending at node <span class="math">\\nu</span>). These virtual commitments will be included in the localized transcript tree labeling <span class="math">F</span>.</p>

    <p class="text-gray-300">Transcript tree labeling <span class="math">F</span> In any transcript the <span class="math">i</span>th round prover message is a triple of commitments in <span class="math">\\mathbb{G}^3</span>. Given a transcript tree defined by <span class="math">L:[1,N]\\to \\chi \\times \\mathbb{G}^3</span>, the function <span class="math">F(L)(\\nu) = (C^{(\\nu)},C_R^{(\\nu)},C_L^{(\\nu)})</span> assigns a <span class="math">\\Gamma^{*}</span> commitment label to node <span class="math">\\nu \\in [1,N]</span>, computed as follows. The root of a transcript tree, which is at index <span class="math">N</span> in a post-order labelling and level 0, is assigned the commitment label <span class="math">F(L)(N) = C^{(N)} = C</span>, where <span class="math">C</span> is the input commitment to the protocol. Each internal node of a transcript tree with index <span class="math">\\nu</span> is assigned <span class="math">(C^{(\\nu)} = C_L^{(\\nu)} + r_\\nu^2 C_R^{(\\nu)} + r_\\nu C_\\nu, C_L^{(\\nu)}, C_R^{(\\nu)})</span>. <span class="math">F</span> is localized because <span class="math">C^{(\\nu)}</span> is computed from the partial transcript that <span class="math">L</span> assigns to the predecessor nodes of <span class="math">\\nu</span>.</p>

    <p class="text-gray-300">Finally, we show that <span class="math">C^{(\\nu)}</span> is a correct <span class="math">\\Gamma^{<em>}</span> commitment for the index <span class="math">\\iota_{\\nu}</span>. Define <span class="math">\\mathbf{g}_N = \\mathbf{g} = \\mathcal{G}^</em>(\\mathsf{pp},\\iota)</span> for the root, and <span class="math">\\mathbf{g}_{\\nu} = \\mathcal{G}^{*}(\\mathsf{pp},\\iota ,\\mathbf{r}^{(\\nu)})</span> for a node on level <span class="math">i\\geq 1</span> whose transcript prefix has the challenge sequence <span class="math">\\mathbf{r}^{(\\nu)} = (r_1^{(\\nu)},\\dots,r_i^{(\\nu)})</span>. Note that on the <span class="math">i</span>th level <span class="math">\\mathbf{g}_{\\nu}\\in \\mathbb{G}^{2^{\\mu -i}}</span>. In a correct transcript tree, for any node <span class="math">\\nu</span> at the <span class="math">\\ell_{\\nu}</span>th level, <span class="math">C^{(\\nu)} = \\langle \\mathbf{x}&#x27;,\\mathbf{g}_{\\nu}\\rangle</span> for some <span class="math">\\mathbf{x}&#x27;\\in \\mathbb{Z}^{2^{\\mu -\\ell_{\\nu}}}</span>. Additionally, <span class="math">C_L^{(\\nu)} = \\langle (\\mathbf{0},\\mathbf{x}_L&#x27;),\\mathbf{g}_{\\nu}\\rangle</span> and <span class="math">C_R^{(\\nu)} = \\langle (\\mathbf{x}_R&#x27;,\\mathbf{0}),\\mathbf{g}_{\\nu}\\rangle</span> where <span class="math">\\mathbf{x}_L&#x27;</span> and <span class="math">\\mathbf{x}_R&#x27;</span> are the left and right half of <span class="math">\\mathbf{x}&#x27;</span>, respectively.</p>

    <p class="text-gray-300">The predicates <span class="math">\\phi_{a}</span> and <span class="math">\\phi_{b}</span> We define the numerator bounds <span class="math">B_0 \\geq \\dots \\geq B_\\mu</span> such that <span class="math">\\log B_\\mu = \\mu \\lambda + \\log \\beta</span> (corresponding to the numerator verification bound on the prover's final round message) and <span class="math">\\log B_i = \\mathsf{CSZ}_{\\mu - i, \\lambda} + (2\\mu - i)\\lambda + \\frac{\\mu}{2} + \\log \\beta</span> for <span class="math">i \\geq 1</span>. We define denominator bounds <span class="math">D_0 \\geq \\dots \\geq D_\\mu</span> such that <span class="math">D_\\mu = 1</span> (corresponding to the denominator verification bound on the prover's final round message, i.e. that it is an integer) and <span class="math">\\log D_i = \\mathsf{CSZ}_{\\mu - i, \\lambda}</span> for <span class="math">i \\geq 1</span>.</p>

    <p class="text-gray-300">For any <span class="math">i \\in [0, \\mu]</span> and <span class="math">\\mathbf{m} = \\mathbf{x} / z \\in \\mathbb{Q}^{2^{\\mu - i}}</span> we define:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi_{a}(i,\\mathbf{m}) = 1</span> iff <span class="math">\\mathbf{m} \\in \\mathcal{W}_i(B_i, D_i)</span></li>

      <li><span class="math">\\phi_{b}(i,\\mathbf{m}) = 1</span> iff <span class="math">\\mathbf{m} \\in \\mathcal{W}_i(\\beta_n^{(i)} / 2^{2\\lambda + 1}, \\beta_d)</span></li>

    </ul>

    <p class="text-gray-300">Note that <span class="math">\\log \\beta_{n}^{(i)} = (2\\mu - i)\\lambda + \\log \\beta + 2(\\lambda + 1 + \\mathsf{CSZ}_{\\mu, \\lambda}) + \\frac{1}{2} \\geq \\log B_{i}</span> and <span class="math">\\beta_{d} \\geq D_{i}</span> for all <span class="math">i \\in [0, \\mu]</span>, thus <span class="math">\\mathcal{W}_i(B_i, D_i) \\subseteq \\mathcal{W}_i(\\beta_n^{(i)}, \\beta_d)</span>. This shows that <span class="math">i</span>th round commitments (i.e., commitment labels assigned by <span class="math">F</span> to nodes on the <span class="math">i</span>th level) are binding under rational openings to <span class="math">\\mathcal{W}_i(B_i, D_i)</span> as a subset of <span class="math">\\mathcal{W}_i(\\beta_n^{(i)}, \\beta_d)</span> and also that <span class="math">\\phi_{a}(i, \\mathbf{m}) = 1</span> implies <span class="math">\\phi_{b}(i, \\mathbf{m}) = 1</span>.</p>

    <p class="text-gray-300">The following facts will be needed later on in the proof:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta_{d} = \\sqrt{\\xi} / 2^{\\mu \\lambda} \\geq 2^{3\\lambda} \\cdot D_{0}^{3}</span> for <span class="math">\\frac{1}{2} \\log \\xi \\geq (\\mu + 3)\\lambda + 3\\mathsf{CSZ}_{\\mu, \\lambda}</span></li>

      <li><span class="math">\\beta_{n}^{(i)} / 2^{2\\lambda +1} = 2^{(\\mu -i - 2)\\lambda -\\frac{\\mu}{2} -1}\\sqrt{\\xi}\\cdot \\beta \\geq 2^{6\\lambda +2}B_{i + 1}D_{i + 1}^{2}</span> for <span class="math">\\frac{1}{2}\\log \\xi \\geq (\\mu +8)\\lambda +</span> <span class="math">3\\mathsf{CSZ}_{\\mu ,\\lambda} + \\mu +3</span></li>

    </ul>

    <p class="text-gray-300">Both conditions are satisfied by the theorem hypothesis.</p>

    <p class="text-gray-300">The ExtractInternal <span class="math">(F, i, \\nu, \\text{openSubtree})</span> algorithm operates as follows to extract an opening of <span class="math">(C^{(\\nu)}, C_R^{(\\nu)}, C_L^{(\\nu)})</span> for a node <span class="math">\\nu</span> on the <span class="math">i</span>th tree level. The input openSubtree contains openings <span class="math">(\\mathbf{x}_{u_j}, t_{u_j})</span> for all three children nodes <span class="math">u_1, u_2</span>, and <span class="math">u_3</span> of node <span class="math">\\nu</span>. Let <span class="math">C_j = F(L)(u_j)</span> and let <span class="math">r_j</span> denote the challenge labels that <span class="math">L</span> assigns to <span class="math">u_j</span> where <span class="math">r_1 \\neq r_2 \\neq r_3 \\neq r_4 \\neq 0</span>. By construction, <span class="math">C_j = C_L^{(\\nu)} + r_j^2 C_R^{(\\nu)} + r_j C^{(\\nu)}</span> for <span class="math">j \\in \\{1, 2, 3, 4\\}</span>. Define <span class="math">\\mathbf{R} \\in \\mathbb{Z}^{3 \\times 3}</span> to be the matrix with rows <span class="math">(r_j, r_j^2, 1)</span> for <span class="math">j \\in \\{1, 2, 3\\}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{T}</span>  the diagonal matrix with diagonal entries  <span class="math">t_{u_1}, t_{u_2}, t_{u_3} \\neq 0</span>  (also non-zero mod prime  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ), and let  </span>E_j = \\left(r_j \\cdot I_{2^{\\mu - i - 1}} \\quad I_{2^{\\mu - i - 1}}\\right)$ . We can summarize the relations as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {R} \\cdot \\left[ \\begin{array}{c} C ^ {(\\nu)} \\\\ C _ {R} ^ {(\\nu)} \\\\ C _ {L} ^ {(\\nu)} \\end{array} \\right] = \\left[ \\begin{array}{c} C ^ {(u _ {1})} \\\\ C ^ {(u _ {2})} \\\\ C ^ {(u _ {3})} \\end{array} \\right] \\qquad \\mathbf {T} \\cdot \\left[ \\begin{array}{c} C ^ {(u _ {1})} \\\\ C ^ {(u _ {2})} \\\\ C ^ {(u _ {3})} \\end{array} \\right] = \\left[ \\begin{array}{c} \\langle \\mathbf {x} _ {u _ {1}}, \\mathbf {g} _ {u _ {1}} \\rangle \\\\ \\langle \\mathbf {x} _ {u _ {2}}, \\mathbf {g} _ {u _ {2}} \\rangle \\\\ \\langle \\mathbf {x} _ {u _ {3}}, \\mathbf {g} _ {u _ {3}} \\rangle \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {x} _ {u _ {1}} \\cdot E _ {1} \\\\ \\mathbf {x} _ {u _ {2}} \\cdot E _ {2} \\\\ \\mathbf {x} _ {u _ {3}} \\cdot E _ {3} \\end{array} \\right] \\cdot \\mathbf {g} _ {\\nu}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {T} \\cdot \\mathbf {R} \\cdot \\left[ \\begin{array}{c} C ^ {(\\nu)} \\\\ C _ {R} ^ {(\\nu)} \\\\ C _ {L} ^ {(\\nu)} \\end{array} \\right] = \\mathbf {T} \\cdot \\left[ \\begin{array}{c} C ^ {(u _ {1})} \\\\ C ^ {(u _ {2})} \\\\ C ^ {(u _ {3})} \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {x} _ {u _ {1}} \\cdot E _ {1} \\\\ \\mathbf {x} _ {u _ {2}} \\cdot E _ {2} \\\\ \\mathbf {x} _ {u _ {3}} \\cdot E _ {3} \\end{array} \\right] \\cdot \\mathbf {g} _ {\\nu} = \\mathbf {X} \\cdot \\mathbf {g} _ {\\nu}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\mathbf{P} = adj(\\mathbf{T}\\cdot \\mathbf{R})\\in \\mathbb{Z}^{3\\times 3}</span> , the adjugate matrix so that  <span class="math">\\mathbf{P}\\cdot \\mathbf{T}\\cdot \\mathbf{R} = \\operatorname<em>{det}(\\mathbf{T})\\cdot \\operatorname</em>{det}(\\mathbf{R})\\cdot \\mathbf{I}_3</span> . Let  <span class="math">t_\\nu = \\operatorname<em>{det}(\\mathbf{T})\\cdot \\operatorname</em>{det}(\\mathbf{R}) = t_{u_1}\\cdot t_{u_2}\\cdot t_{u_3}\\cdot \\operatorname*{det}(\\mathbf{R})</span> . Since  <span class="math">\\mathbf{R}</span>  is Vandermonde it has a non-zero integer determinant, which is also non-zero mod prime  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Therefore  </span>t_\\nu \\neq 0<span class="math">  and also  </span>t_\\nu \\neq 0<span class="math">  mod  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in the case that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is prime.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P} \\cdot \\mathbf {T} \\cdot \\mathbf {R} \\cdot \\left[ \\begin{array}{c} C ^ {(\\nu)} \\\\ C _ {R} ^ {(\\nu)} \\\\ C _ {L} ^ {(\\nu)} \\end{array} \\right] = t _ {\\nu} \\cdot \\left[ \\begin{array}{c} C ^ {(\\nu)} \\\\ C _ {R} ^ {(\\nu)} \\\\ C _ {L} ^ {(\\nu)} \\end{array} \\right] = \\mathbf {P} \\cdot \\mathbf {X} \\cdot \\mathbf {g} _ {\\nu}.</span></div>

    <p class="text-gray-300">Letting  <span class="math">\\mathbf{P}_1</span>  denote the first row of  <span class="math">\\mathbf{P}</span>  we obtain  <span class="math">t_\\nu \\cdot C_\\nu = \\langle \\mathbf{P}_1, \\mathbf{X} \\cdot \\mathbf{g}_\\nu \\rangle</span> . The extractor sets  <span class="math">\\mathbf{x}^{(\\nu)} := \\langle \\mathbf{P}_1, \\mathbf{X} \\rangle</span> , which now satisfies  <span class="math">\\langle \\mathbf{x}^{(\\nu)}, \\mathbf{g}_\\nu \\rangle = t_\\nu \\cdot C_\\nu</span> . Similarly, it sets  <span class="math">\\mathbf{x}_R^{(\\nu)} = \\langle \\mathbf{P}_2, \\mathbf{X} \\rangle</span>  and  <span class="math">\\mathbf{x}_L^{(\\nu)} = \\langle \\mathbf{P}_3, \\mathbf{X} \\rangle</span> , which satisfy  <span class="math">\\langle \\mathbf{x}_R^{(\\nu)}, g_\\nu \\rangle = t_\\nu \\cdot C_R^{(\\nu)}</span>  and  <span class="math">\\langle \\mathbf{x}_L^{(\\nu)}, g_\\nu \\rangle = t_\\nu \\cdot C_L^{(\\nu)}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If all entries of  <span class="math">\\mathbf{T}</span>  have absolute value bounded by  <span class="math">D_{i + 1}</span>  then  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_\\nu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{3\\lambda}D_{i + 1}^3<span class="math">  . We will next bound the norm of  </span>\\mathbf{x}_{\\nu}<span class="math">  assuming that all  </span>\\mathbf{x}_{u_i}<span class="math">  have norm bounded by  </span>B_{i + 1}<span class="math">  , first note that all entries of the adjugate matrix are determinants of  </span>2\\times 2<span class="math">  submatrices, thus  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">adj(\\mathbf{T})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq D_{i + 1}^2\\sqrt{3}<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">adj(\\mathbf{R})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{3\\lambda}\\sqrt{3}<span class="math">  . Since  </span>\\mathbf{P} = adj(\\mathbf{T}\\cdot \\mathbf{R}) = adj(\\mathbf{R})\\cdot adj(\\mathbf{T})<span class="math">  and since the Frobenius norm is 1-submultiplicative,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3\\cdot 2^{3\\lambda}D_{i + 1}^2<span class="math">  . For each  </span>j<span class="math"> </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_{u_j}\\cdot E_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 = (r_j^2 +1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_{u_j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2<span class="math">  , thus  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 = \\sum_{j = 1}^3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_{u_j}\\cdot E_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2\\leq 3\\cdot (2^{2\\lambda} + 1)\\cdot B_{i + 1}^2<span class="math">  . Finally, for any  </span>j\\in \\{1,2,3\\}<span class="math"> </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\mathbf{P}_j,\\mathbf{X}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{P}\\cdot \\mathbf{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{3\\lambda}D_{i + 1}^2\\cdot \\sqrt{3} (2^{\\lambda} + 1)B_{i + 1}\\leq 2^{4\\lambda +1}B_{i + 1}D_{i + 1}^2<span class="math">  As shown above, this implies  </span>\\mathbf{x}^{(\\nu)} / t_{\\nu},\\mathbf{x}_{R}^{(\\nu)} / t_{\\nu},\\mathbf{x}_{L}^{(\\nu)} / t_{\\nu}\\in \\mathcal{W}_i(\\beta_n^{(t)},\\beta_d)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that for all  <span class="math">i\\in \\{1,2,3,4\\}</span>  we have that:</p>

    <div class="my-4 text-center"><span class="math-block">t _ {u _ {i}} \\cdot \\langle (r _ {i}, r _ {i} ^ {2}, 1), (C ^ {(\\nu)}, C _ {R} ^ {(\\nu)}, C _ {L} ^ {(\\nu)}) \\rangle = \\langle (r _ {i} \\mathbf {x} _ {u _ {i}}, \\mathbf {x} _ {u _ {i}}), \\mathbf {g} _ {\\nu} \\rangle</span></div>

    <p class="text-gray-300">Multiplying both sides by  <span class="math">t_\\nu</span>  we get:</p>

    <div class="my-4 text-center"><span class="math-block">t _ {u _ {i}} t _ {\\nu} \\cdot \\langle (r _ {i}, r _ {i} ^ {2}, 1), (C ^ {(\\nu)}, C _ {R} ^ {(\\nu)}, C _ {L} ^ {(\\nu)}) \\rangle = t _ {\\nu} \\langle (r _ {i} \\mathbf {x} _ {u _ {i}}, \\mathbf {x} _ {u _ {i}}), \\mathbf {g} _ {\\nu} \\rangle</span></div>

    <p class="text-gray-300">We can now replace  <span class="math">(C^{(\\nu)}, C_R^{(\\nu)}, C_L^{(\\nu)})</span>  with the extracted openings:</p>

    <div class="my-4 text-center"><span class="math-block">t _ {u _ {i}} \\cdot \\langle r _ {i} \\mathbf {x} ^ {(\\nu)} + r _ {i} ^ {2} \\mathbf {x} _ {R} ^ {(\\nu)} + \\mathbf {x} _ {L} ^ {(\\nu)}, \\mathbf {g} _ {\\nu} \\rangle = t _ {\\nu} \\langle (r _ {i} \\mathbf {x} _ {u _ {i}}, \\mathbf {x} _ {u _ {i}}), \\mathbf {g} _ {\\nu} \\rangle</span></div>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{x}^{\\nu} = (\\mathbf{a},\\mathbf{b})</span> <span class="math">\\mathbf{x}_L^\\nu = (\\mathbf{a}_L,\\mathbf{b}_L)</span>  and  <span class="math">\\mathbf{x}_R^\\nu = (\\mathbf{a}_R,\\mathbf{b}_R)</span>  denote the subdivision of each vector into two equal length halves. Two cases ensue. Either</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_{u_i} \\cdot (r_i \\cdot \\mathbf{a} + r_i^2 \\mathbf{a}_R + \\mathbf{a}_L) = t_\\nu r_i \\mathbf{x}_{u_i}</span>  and  <span class="math">t_{u_i} \\cdot (r_i \\cdot \\mathbf{b} + r_i^2 \\mathbf{b}_R + \\mathbf{b}_L) = t_\\nu \\mathbf{x}_{u_i}</span> ; or</li>

    </ul>

    <p class="text-gray-300">they are distinct openings of the commitment  <span class="math">C^{(u_i)} = \\langle (r_i,r_i^2,1),(C^{(\\nu)},C_R^{(\\nu)},C_L^{(\\nu)})\\rangle</span>  to the rationals  <span class="math">\\mathbf{h}_1 = \\frac{(r_i\\mathbf{x}_{u_i},\\mathbf{x}_{u_i})}{t_\\nu}</span>  and  <span class="math">\\mathbf{h}_2 = \\frac{r_i\\mathbf{x}^{(\\nu)} + r_i^2\\mathbf{x}_R^{(\\nu)} + \\mathbf{x}_L^{(\\nu)}}{t_{u_i}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}^{(\\nu)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_L^\\nu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}^{(\\nu)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  are all bounded by  </span>B' = 2^{4\\lambda +1}B_{i + 1}D_{i + 1}^2<span class="math">  we have that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(r_i\\mathbf{x}^{(\\nu)} + r_i^2\\mathbf{x}_R^{(\\nu)} + \\mathbf{x}_L^{(\\nu)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is bounded by  </span>3\\cdot 2^{2\\lambda}B'\\leq 2^{6\\lambda +3}B_{i + 1}D_{i + 1}^2<span class="math">  and thus  </span>\\mathbf{h}_1,\\mathbf{h}_2\\in \\mathcal{W}_i(\\beta_n^{(t)},\\beta_d)<span class="math"> . Additionally,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf{x}_{u_i},\\mathbf{x}_{u_i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\lambda +1}\\cdot B_{i + 1}\\leq B'<span class="math">  and thus  </span>\\mathbf{h}_1,\\mathbf{h}_2\\in \\mathcal{W}_i(\\beta_n^{(t)},\\beta_d)<span class="math"> . In this case, the algorithm returns these openings as a break of the commitment scheme  </span>\\Gamma^{*}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Otherwise:</p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} \\cdot \\mathbf {a} + r _ {i} ^ {2} \\mathbf {a} _ {R} + r _ {i} \\mathbf {a} _ {L} = r _ {i} ^ {2} \\cdot \\mathbf {b} + r _ {i} ^ {3} \\mathbf {b} _ {R} + r _ {i} \\mathbf {b} _ {L} \\forall i \\in \\{1, 2, 3, 4 \\}</span></div>

    <p class="text-gray-300">Since the  <span class="math">4 \\times 4</span>  Vandermonde matrix with rows  <span class="math">(1, r_i, r_i^2, r_i^3)</span>  has a trivial kernel, this equation implies:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {a} = \\mathbf {b} _ {L} \\quad \\mathbf {b} = \\mathbf {a} _ {R} \\\\ \\mathbf {b} _ {R} = 0 \\quad \\mathbf {a} _ {L} = 0 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore,  <span class="math">(\\mathbf{x}^{(\\nu)},t_{\\nu})</span>  is a valid opening to the commitment  <span class="math">(C^{(\\nu)},C_R^{(\\nu)},C_L^{(\\nu)})</span></p>

    <p class="text-gray-300">At the root, ExtractWitness  <span class="math">(C,</span>  openTree) runs ExtractInternal  <span class="math">(0,N,C,</span>  openTree) to either obtain a witness  <span class="math">(\\mathbf{x},t)</span>  such that  <span class="math">\\langle \\mathbf{x},\\mathbf{g}\\rangle = t\\cdot C</span>  where  <span class="math">\\mathbf{x} / t\\in \\mathcal{W}(\\beta_n,\\beta_d)</span>  or a break of the commitment scheme  <span class="math">\\Gamma^{*}</span> .</p>

    <p class="text-gray-300">The Extend algorithm For <span class="math">\\mathbf{h} \\in \\mathbb{Q}^{2^{\\mu - i}}</span> and an accepting transcript <span class="math">\\operatorname{tr} = [C, (C_1, r_1), \\ldots, (C_\\mu, \\bot)]</span> with challenges in <span class="math">\\chi</span>, the algorithm <span class="math">\\operatorname{Extend}(i, \\mathbf{h}, \\operatorname{tr})</span> sets <span class="math">\\mathbf{h}_i := \\mathbf{h}</span> and runs the following iterative algorithm: for <span class="math">j = i</span> to <span class="math">\\mu - 1</span> set <span class="math">\\mathbf{h}_{j + 1} := \\mathbf{h}_{j,L} + r_{j + 1} \\cdot \\mathbf{h}_{j,R}</span> where <span class="math">\\mathbf{h}_{j,L}</span> and <span class="math">\\mathbf{h}_{j,R}</span> are the left/right coefficient split of <span class="math">\\mathbf{h}_j</span>. It returns <span class="math">\\mathbf{h}_i, \\ldots, \\mathbf{h}_\\mu</span>.</p>

    <p class="text-gray-300">Note that if <span class="math">\\mathbf{h}_i</span> is the honest prover's committed state in the <span class="math">i</span>th round of the protocol <span class="math">\\Pi</span> and <span class="math">r_{i+1}, \\ldots, r_\\mu</span> are the last <span class="math">\\mu - i</span> round challenges then the value <span class="math">\\mathbf{h}_\\mu \\in \\mathbb{Z}</span> returned by <span class="math">\\operatorname{Extend}(i, \\mathbf{h}_i, r_{i+1}, \\ldots, r_\\mu)</span> returns is also the honest prover's last message to the verifier.</p>

    <p class="text-gray-300">If <span class="math">\\forall_{j\\geq i}\\mathbf{h}_j^{\\prime} = \\mathbf{x}_j / z_j</span> then Extend outputs <span class="math">\\mathbf{h}_i, \\dots, \\mathbf{h}_\\mu</span>. Otherwise, let <span class="math">j \\in [i, \\mu)</span> be the first index where <span class="math">\\mathbf{h}_{j+1}&#x27; \\neq \\mathbf{x}_{j+1} / z_{j+1}</span> and output <span class="math">(\\mathbf{x}_{j,L} + r_{j+1} \\cdot \\mathbf{x}_{j,R}, z_j)</span>, where <span class="math">\\mathbf{x}_{j,L}</span> and <span class="math">\\mathbf{x}_{j,R}</span> are the left/right halves of <span class="math">\\mathbf{x}_j</span>, as the attempted opening for <span class="math">C^{(j+1)}</span>.</p>

    <p class="text-gray-300">Subclaim 1 (Application of New Schwartz-Zippel Lemma). For any <span class="math">i \\in [\\mu]</span> and <span class="math">\\mathbf{h} \\in \\mathbb{Q}^{2^{\\mu - i}}</span>, if <span class="math">\\phi_{\\mathrm{a}}(i, \\mathbf{h}) = 0</span> then the probability over uniform i.i.d. <span class="math">r_{i+1}, \\ldots, r_\\mu</span> that <span class="math">\\mathbf{h}_\\mu</span> returned by <span class="math">\\operatorname{Extend}(i, \\mathbf{h}, r_{i+1}, \\ldots, r_\\mu)</span> satisfies <span class="math">\\phi_{\\mathrm{a}}(\\mu, \\mathbf{h}_\\mu) = 1</span> is at most <span class="math">\\frac{3(\\mu - i)}{2^{\\lambda}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{x} / N = \\mathbf{h}</span> for <span class="math">\\gcd(\\mathbf{x}, N) = 1</span> denote the reduced form of <span class="math">\\mathbf{h} \\in \\mathbb{Q}^{2^{\\mu - i}}</span>. If <span class="math">\\phi_{\\mathrm{a}}(i, \\mathbf{h}) = 0</span> then either <span class="math">z &amp;gt; D_i</span> or $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; B_i<span class="math"> while </span>\\phi_{\\mathrm{a}}(\\mu, \\mathbf{h}_\\mu) = 1<span class="math"> implies </span>\\mathbf{h}_\\mu \\in \\mathbb{Z}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{h}_\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B_\\mu<span class="math">. Let </span>\\mu' = \\mu - i<span class="math">. Observe that </span>\\mathbf{h}_\\mu = \\frac{1}{z} \\cdot f(r_\\mu, \\dots, r_{i+1})<span class="math"> where </span>f<span class="math"> is a </span>\\mu'<span class="math">-linear polynomial with coefficient vector </span>\\mathbf{x}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 1 <span class="math">N &amp;gt; D_{i}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; D_{i}<span class="math"> then since </span>\\log D_{i} = \\mathsf{CSZ}_{\\mu - i}<span class="math">, the probability that </span>\\mathbf{h}_{\\mu} \\in \\mathbb{Z}$ is:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {(r _ {i + 1}, \\dots , r _ {\\mu}) \\leftarrow [ 0, 2 ^ {\\lambda}) ^ {\\mu - i}} [ f (r _ {\\mu}, \\dots , r _ {i + 1}) \\equiv 0 \\bmod N ] \\leq \\frac {\\mu - i + 1}{2 ^ {\\lambda}}.</span></div>

    <p class="text-gray-300">by the Multilinear Composite Schwartz-Zippel Lemma (Theorem 2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 2 $N \\leq D_i \\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; B_i$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case, if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{h}_{\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B_{\\mu}<span class="math"> then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(r_{\\mu}, \\dots, r_{i+1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N \\cdot B_{\\mu} \\leq 2^{\\mathsf{CSZ}_{\\mu - i, \\lambda}} \\cdot B_{\\mu}<span class="math">. Furthermore, the fact that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; B_i<span class="math"> and </span>\\log B_i = \\mathsf{CSZ}_{\\mu - i, \\lambda} + (\\mu - i)\\lambda + \\frac{\\mu}{2} + \\log B_{\\mu}$ imply:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log \\left(\\mathrm {C S Z} _ {\\mu - i, \\lambda} \\cdot B _ {\\mu}\\right) \\leq \\log B _ {i} - (\\mu - i) \\lambda - \\frac {\\mu}{2} &lt;   \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (\\mu - i) \\lambda - \\frac {\\mu}{2}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\mu /2} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$, the Evaluation Bound Lemma (Lemma 1) implies:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathbb {P} [ \\mathbf {h} _ {\\mu} \\leq B _ {\\mu} ] \\leq \\mathbb {P} [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f (r _ {\\mu}, \\dots , r _ {i + 1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq D _ {i} \\cdot B _ {\\mu} ] \\leq \\mathbb {P} [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f (r _ {\\mu}, \\dots , r _ {i + 1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\leq \\frac {1}{2 ^ {(\\mu - i) \\lambda}} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ] \\leq \\frac {3 (\\mu - i)}{2 ^ {\\lambda}}. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Together these imply that if <span class="math">\\phi_{\\mathrm{a}}(i,\\mathbf{x} / N) = 0</span> then the probability over the random challenges that the final element <span class="math">\\mathbf{h}_{\\mu}</span> of the list returned by Extend satisfies <span class="math">\\phi_{\\mathrm{a}}(\\mu ,\\mathbf{h}_{\\mu}) = 1</span> is negligible.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Subclaim 2. For any <span class="math">i \\in [\\mu - 1]</span>, given a valid transcript together with the "virtual" commitments <span class="math">(C^{(0)}, \\dots, C^{(\\mu)})</span>, round challenges <span class="math">(r_1, \\dots, r_\\mu)</span>, and openings <span class="math">(o_i, \\dots, o_\\mu)</span> of the <span class="math">\\mu - i + 1</span> last <span class="math">\\Gamma^*</span>-commitment triples <span class="math">\\mathcal{C}_i, \\dots, \\mathcal{C}_\\mu</span> where for <span class="math">j \\in [i, \\mu]</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}_j = (C^{(j)}, C_L^{(j)}, C_R^{(j)})</span></li>

      <li><span class="math">o_j</span> contains an opening of <span class="math">C^{(j)}</span> to a rational vector <span class="math">\\mathbf{h}_j</span>, such that <span class="math">\\phi_b(j, \\mathbf{h}_j) = 1</span></li>

      <li><span class="math">\\phi_{\\mathrm{a}}(j,\\mathbf{h}_j) = 1</span> if <span class="math">j \\geq i + 1</span></li>

    </ul>

    <p class="text-gray-300">then either <span class="math">\\operatorname{Extend}(i, \\mathbf{h}_i, r_{i+1}, \\dots, r_\\mu)</span> returns <span class="math">\\mathbf{h}_{i+1}, \\dots, \\mathbf{h}_\\mu</span> or <span class="math">\\operatorname{Break}(i, \\mathbf{h}_i, (o_i, \\dots, o_\\mu))</span> returns for some <span class="math">j \\geq i</span> a valid opening of <span class="math">\\mathcal{C}^{(j)}</span> to <span class="math">\\mathbf{h}_j&#x27; \\neq \\mathbf{h}_j</span>.</p>

    <p class="text-gray-300">Proof. Let <span class="math">(\\mathbf{h}_{i + 1}^{\\prime},\\dots,\\mathbf{h}_{\\mu}^{\\prime})</span> denote the output of <span class="math">\\operatorname{Extend}(i,\\mathbf{h}_i,r_{i + 1},\\dots,r_\\mu)</span> and suppose it is not equal to <span class="math">(\\mathbf{h}_{i + 1},\\dots,\\mathbf{h}_{\\mu})</span>. Let <span class="math">j\\in [i,\\mu)</span> denote the first index for which <span class="math">\\mathbf{h}_{j + 1}\\neq \\mathbf{h}_{j + 1}^{\\prime}</span>. This means that <span class="math">\\mathbf{h}_j = \\mathbf{h}_j^\\prime</span> and thus <span class="math">\\mathbf{h}_{j + 1}^{\\prime} = \\mathbf{h}_{j,L} + r_{j + 1}\\cdot \\mathbf{h}_{j,R}</span> where <span class="math">\\mathbf{h}_{j,L}</span> and <span class="math">\\mathbf{h}_{j,R}</span> are the left/right halves of <span class="math">\\mathbf{h}_j</span>. Let <span class="math">\\mathbf{g}^{(j)} = \\mathcal{G}^{*}(\\mathsf{pp},\\iota ,\\mathbf{r}^{(j)})</span> denote the commitment basis determined by <span class="math">r_1,\\ldots ,r_j</span>, let <span class="math">\\mathbf{g}^{(j)} = (\\mathbf{g}_L^{(j)},\\mathbf{g}_R^{(j)})</span>, and let <span class="math">\\mathbf{g}^{(j + 1)} = r_{j + 1}\\cdot \\mathbf{g}_L^{(j)} + \\mathbf{g}_R^{(j)}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{h}_j = \\mathbf{x}_j / z_j</span> so that <span class="math">\\langle \\mathbf{x}_j,\\mathbf{g}_j\\rangle = z_j\\cdot C^{(j)}</span> by validity of the opening of <span class="math">\\mathcal{C}_j</span>. Let <span class="math">\\mathbf{x}_j = (\\mathbf{x}_{j,L},\\mathbf{x}_{j,R})</span> so that <span class="math">\\mathbf{x}_{j + 1}^{\\prime} = \\mathbf{x}_{j,L} + r_{j + 1}\\mathbf{x}_{j,R}</span> and <span class="math">\\mathbf{h}_{j + 1}^{\\prime} = \\mathbf{x}_{j + 1}^{\\prime} / z_{j}</span>. Validity of the opening of <span class="math">\\mathcal{C}_j</span> additionally implies <span class="math">z_{j}\\cdot C_{L}^{(j)} = \\langle \\mathbf{x}_{j,L},\\mathbf{g}_{R}^{(j)}\\rangle</span> and <span class="math">z_{j}\\cdot C_{R}^{(j)} = \\langle \\mathbf{x}_{j,R},\\mathbf{g}_{L}^{(j)}\\rangle</span>. Furthermore, <span class="math">\\phi_b(j,\\mathbf{h}_j) = 1</span> implies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_{j + 1}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\lambda +1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_8^{(j)} / 2^{\\lambda} = \\beta_8^{(j + 1)}<span class="math"> and thus </span>\\mathbf{h}_{j + 1}^{\\prime}\\in \\mathcal{W}(\\beta_8^{(i)},\\beta_d)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In a correct transcript:</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{x}_{j,L},\\mathbf{g}_{R}^{(j)}\\rangle+r_{j+1}^{2}\\langle\\mathbf{x}_{j,L},\\mathbf{g}_{R}^{(j)}\\rangle+r_{j+1}\\langle x_{j},\\mathbf{g}^{(j)}\\rangle=z_{j}\\cdot C^{(j+1)}</span></p>

    <p class="text-gray-300">Thus <span class="math">\\langle\\mathbf{x}_{j,L}+r_{j+1}\\cdot\\mathbf{x}_{j,R},\\mathbf{g}_{R}^{(j)}+r_{j+1}\\mathbf{g}_{L}^{(j)}\\rangle=\\langle\\mathbf{x}_{j+1}^{\\prime},\\mathbf{g}^{(j+1)}\\rangle=z_{j}\\cdot C^{(j+1)}</span>. This shows that <span class="math">\\mathbf{h}_{j+1}^{\\prime}\\neq\\mathbf{h}_{j+1}</span> is a conflicting valid opening to <span class="math">C^{(j+1)}</span>. ∎</p>

    <h2 id="sec-57" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AC20] Thomas Attema and Ronald Cramer. “Compressed <span class="math">\\Sigma</span>-Protocol Theory and Practical Application to Plug & Play Secure Algorithmics”. In: CRYPTO 2020, Part III. Ed. by Daniele Micciancio and Thomas Ristenpart. Vol. 12172. LNCS. Springer, Heidelberg, Aug. 2020, pp. 513–543. doi: 10.1007/978-3-030-56877-1_18.</li>

      <li>[ACK21a] Thomas Attema, Ronald Cramer, and Lisa Kohl. A Compressed <span class="math">\\Sigma</span>-Protocol Theory for Lattices. Cryptology ePrint Archive, Report 2021/307. https://eprint.iacr.org/2021/307. 2021.</li>

      <li>[ACK21b] Thomas Attema, Ronald Cramer, and Lisa Kohl. “A Compressed <span class="math">\\Sigma</span>-Protocol Theory for Lattices”. In: CRYPTO 2021, Part II. Ed. by Tal Malkin and Chris Peikert. Vol. 12826. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 549–579. doi: 10.1007/978-3-030-84245-1_19.</li>

      <li>[AFK21] Thomas Attema, Serge Fehr, and Michael Klooß. Fiat-Shamir Transformation of Multi-Round Interactive Proofs. Cryptology ePrint Archive, Report 2021/1377. https://eprint.iacr.org/2021/1377. 2021.</li>

      <li>[AL21] Martin R. Albrecht and Russell W. F. Lai. “Subtractive Sets over Cyclotomic Rings - Limits of Schnorr-Like Arguments over Lattices”. In: CRYPTO 2021, Part II. Ed. by Tal Malkin and Chris Peikert. Vol. 12826. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 519–548. doi: 10.1007/978-3-030-84245-1_18.</li>

      <li>[ALS20] Thomas Attema, Vadim Lyubashevsky, and Gregor Seiler. “Practical Product Proofs for Lattice Commitments”. In: CRYPTO 2020, Part II. Ed. by Daniele Micciancio and Thomas Ristenpart. Vol. 12171. LNCS. Springer, Heidelberg, Aug. 2020, pp. 470–499. doi: 10.1007/978-3-030-56880-1_17.</li>

      <li>[BBBPWM18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: 2018 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2018, pp. 315–334. doi: 10.1109/SP.2018.00020.</li>

      <li>[BCCGP16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: EUROCRYPT 2016, Part II. Ed. by Marc Fischlin and Jean-Sébastien Coron. Vol. 9666. LNCS. Springer, Heidelberg, May 2016, pp. 327–357. doi: 10.1007/978-3-662-49896-5_12.</li>

      <li>[BCPS15] Anurag Bishnoi, Pete L. Clark, Aditya Potukuchi, and John R. Schmitt. On zeros of a polynomial in a finite grid. 2015. doi: 10.48550/ARXIV.1508.06020. URL: https://arxiv.org/abs/1508.06020.</li>

      <li>[BCS21] Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. “Sumcheck Arguments and Their Applications”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 742–773. doi: 10.1007/978-3-030-84242-0_26.</li>

      <li>[BDFG21] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. “Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 649–680. doi: 10.1007/978-3-030-84242-0_23.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BF22] Benedikt Bünz and Ben Fisch. Schwartz-Zippel for multilinear polynomials mod N. Cryptology ePrint Archive, Report 2022/458. https://eprint.iacr.org/2022/458. 2022.</li>

      <li>[BFS19] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK Compilers. Cryptology ePrint Archive, Report 2019/1229. https://eprint.iacr.org/2019/1229. 2019.</li>

      <li>[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. “Transparent SNARKs from DARK Compilers”. In: EUROCRYPT 2020, Part I. Ed. by Anne Canteaut and Yuval Ishai. Vol. 12105. LNCS. Springer, Heidelberg, May 2020, pp. 677–706. doi: 10.1007/978-3-030-45721-1_24.</li>

      <li>[BG93] Mihir Bellare and Oded Goldreich. “On Defining Proofs of Knowledge”. In: CRYPTO’92. Ed. by Ernest F. Brickell. Vol. 740. LNCS. Springer, Heidelberg, Aug. 1993, pp. 390–420. doi: 10.1007/3-540-48071-4_28.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. https://eprint.iacr.org/2019/1021. 2019.</li>

      <li>[BH01] Johannes Buchmann and Safuat Hamdy. “A survey on IQ cryptography”. In: Public-Key Cryptography and Computational Number Theory. 2001, pp. 1–15.</li>

      <li>[BHRRS21] Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. “Time- and Space-Efficient Arguments from Groups of Unknown Order”. In: CRYPTO 2021, Part IV. Ed. by Tal Malkin and Chris Peikert. Vol. 12828. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 123–152. doi: 10.1007/978-3-030-84259-8_5.</li>

      <li>[BLNS20] Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. “A Non-PCP Approach to Succinct Quantum-Safe Zero-Knowledge”. In: CRYPTO 2020, Part II. Ed. by Daniele Micciancio and Thomas Ristenpart. Vol. 12171. LNCS. Springer, Heidelberg, Aug. 2020, pp. 441–469. doi: 10.1007/978-3-030-56880-1_16.</li>

      <li>[BS22] Ward Beullens and Gregor Seiler. LaBRADOR: Compact Proofs for R1CS from Module-SIS. Cryptology ePrint Archive, Report 2022/1341. https://eprint.iacr.org/2022/1341. 2022.</li>

      <li>[CNRZZ22] Matteo Campanelli, Anca Nitulescu, Carla Ràfols, Alexandros Zacharakis, and Arantxa Zapico. Linear-map Vector Commitments and their Practical Applications. Cryptology ePrint Archive, Report 2022/705. https://eprint.iacr.org/2022/705. 2022.</li>

      <li>[CPP17] Geoffroy Couteau, Thomas Peters, and David Pointcheval. “Removing the Strong RSA Assumption from Arguments over the Integers”. In: EUROCRYPT 2017, Part II. Ed. by Jean-Sébastien Coron and Jesper Buus Nielsen. Vol. 10211. LNCS. Springer, Heidelberg, 2017, pp. 321–350. doi: 10.1007/978-3-319-56614-6_11.</li>

      <li>[DF02] Ivan Damgård and Eiichiro Fujisaki. “A Statistically-Hiding Integer Commitment Scheme Based on Groups with Hidden Order”. In: ASIACRYPT 2002. Ed. by Yuliang Zheng. Vol. 2501. LNCS. Springer, Heidelberg, Dec. 2002, pp. 125–142. doi: 10.1007/3-540-36178-2_8.</li>

      <li>[DL77] Richard A DeMillo and Richard J Lipton. A Probabilistic Remark on Algebraic Program Testing. Tech. rep. GEORGIA INST OF TECH ATLANTA SCHOOL OF INFORMATION and COMPUTER SCIENCE, 1977.</li>

      <li>[ENS20] Muhammed F. Esgin, Ngoc Khanh Nguyen, and Gregor Seiler. “Practical Exact Proofs from Lattices: New Techniques to Exploit Fully-Splitting Rings”. In: ASIACRYPT 2020, Part II. Ed. by Shiho Moriai and Huaxiong Wang. Vol. 12492. LNCS. Springer, Heidelberg, Dec. 2020, pp. 259–288. doi: 10.1007/978-3-030-64834-3_9.</li>

      <li>[GHL22] Craig Gentry, Shai Halevi, and Vadim Lyubashevsky. “Practical Noninteractive Publicly Verifiable Secret Sharing with Thousands of Parties”. In: EUROCRYPT 2022, Part I. Ed. by Orr Dunkelman and Stefan Dziembowski. Vol. 13275. LNCS. Springer, Heidelberg, 2022, pp. 458–487. doi: 10.1007/978-3-031-06944-4_16.</li>

    </ul>

    <p class="text-gray-300">[GI08] Jens Groth and Yuval Ishai. “Sub-linear Zero-Knowledge Argument for Correctness of a Shuffle”. In: EUROCRYPT 2008. Ed. by Nigel P. Smart. Vol. 4965. LNCS. Springer, Heidelberg, Apr. 2008, pp. 379–396. DOI: 10.1007/978-3-540-78967-3_22.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GPV08] Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan. “Trapdoors for hard lattices and new cryptographic constructions”. In: 40th ACM STOC. Ed. by Richard E. Ladner and Cynthia Dwork. ACM Press, May 2008, pp. 197–206. DOI: 10.1145/1374376.1374407.</li>

      <li>[HHKKP22] Charlotte Hoffmann, Pavel Hubácek, Chethan Kamath, Karen Klein, and Krzysztof Pietrzak. “Practical Statistically-Sound Proofs of Exponentiation in Any Group”. In: CRYPTO 2022, Part II. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13508. LNCS. Springer, Heidelberg, Aug. 2022, pp. 370–399. DOI: 10.1007/978-3-031-15979-4_13.</li>

      <li>[Kar15] Dmitrii Karp. Normalized incomplete beta function: log-concavity in parameters and other properties. 2015. DOI: 10.48550/ARXIV.1509.05120. URL: https://arxiv.org/abs/1509.05120.</li>

      <li>[KI04] Valentine Kabanets and Russell Impagliazzo. “Derandomizing Polynomial Identity Tests Means Proving Circuit Lower Bounds”. In: Comput. Complex. 13.1-2 (2004), pp. 1–46. DOI: 10.1007/s00037-004-0182-6. URL: https://doi.org/10.1007/s00037-004-0182-6.</li>

      <li>[Lin01] Yehuda Lindell. “Parallel Coin-Tossing and Constant-Round Secure Two-Party Computation”. In: CRYPTO 2001. Ed. by Joe Kilian. Vol. 2139. LNCS. Springer, Heidelberg, Aug. 2001, pp. 171–189. DOI: 10.1007/3-540-44647-8_10.</li>

      <li>[LM19] Russell W. F. Lai and Giulio Malavolta. “Subvector Commitments with Application to Succinct Arguments”. In: CRYPTO 2019, Part I. Ed. by Alexandra Boldyreva and Daniele Micciancio. Vol. 11692. LNCS. Springer, Heidelberg, Aug. 2019, pp. 530–560. DOI: 10.1007/978-3-030-26948-7_19.</li>

      <li>[LNS21] Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. “Shorter Lattice-Based Zero-Knowledge Proofs via One-Time Commitments”. In: PKC 2021, Part I. Ed. by Juan Garay. Vol. 12710. LNCS. Springer, Heidelberg, May 2021, pp. 215–241. DOI: 10.1007/978-3-030-75245-3_9.</li>

      <li>[LS15] Adeline Langlois and Damien Stehlé. “Worst-case to average-case reductions for module lattices”. In: Des. Codes Cryptogr. 75.3 (2015), pp. 565–599.</li>

      <li>[MP13] Daniele Micciancio and Chris Peikert. “Hardness of SIS and LWE with Small Parameters”. In: CRYPTO 2013, Part I. Ed. by Ran Canetti and Juan A. Garay. Vol. 8042. LNCS. Springer, Heidelberg, Aug. 2013, pp. 21–39. DOI: 10.1007/978-3-642-40041-4_2.</li>

      <li>[NS22] Ngoc Khanh Nguyen and Gregor Seiler. “Practical Sublinear Proofs for R1CS from Lattices”. In: CRYPTO 2022, Part II. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13508. LNCS. Springer, Heidelberg, Aug. 2022, pp. 133–162. DOI: 10.1007/978-3-031-15979-4_5.</li>

      <li>[Pie19] Krzysztof Pietrzak. “Proofs of Catalytic Space”. In: ITCS 2019. Ed. by Avrim Blum. Vol. 124. LIPIcs, Jan. 2019, 59:1–59:25. DOI: 10.4230/LIPIcs.ITCS.2019.59.</li>

      <li>[RS62] J Barkley Rosser and Lowell Schoenfeld. “Approximate formulas for some functions of prime numbers”. In: Illinois Journal of Mathematics 6.1 (1962), pp. 64–94.</li>

      <li>[RSA78] Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. “A Method for Obtaining Digital Signatures and Public-Key Cryptosystems”. In: Communications of the Association for Computing Machinery 21.2 (Feb. 1978), pp. 120–126. DOI: 10.1145/359340.359342.</li>

      <li>[Sch80] Jacob T Schwartz. “Fast probabilistic algorithms for verification of polynomial identities”. In: Journal of the ACM (JACM) 27.4 (1980), pp. 701–717.</li>

    </ul>

    <p class="text-gray-300">[Wes19] Benjamin Wesolowski. "Efficient Verifiable Delay Functions". In: EUROCRYPT 2019, Part III. Ed. by Yuval Ishai and Vincent Rijmen. Vol. 11478. LNCS. Springer, Heidelberg, May 2019, pp. 379-407. DOI: 10.1007/978-3-030-17659-4_13. [Wik21] Douglas Wikström. <em>Special Soundness in the Random Oracle Model</em>. Cryptology ePrint Archive, Report 2021/1265. https://eprint.iacr.org/2021/1265.2021. [WTsTW18] Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. “Doubly-Efficient zkSNARKs Without Trusted Setup”. In: 2018 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2018, pp. 926–943. DOI: 10.1109/SP.2018.00060. [Zip79] Richard Zippel. "Probabilistic algorithms for sparse polynomials". In: International symposium on symbolic and algebraic manipulation. Springer. 1979, pp. 216-226.</p>

    <h2 id="sec-59" class="text-2xl font-bold">A.1 Proof of main LCSZ theorem (Theorem 1)</h2>

    <p class="text-gray-300">Theorem 1 (Multilinear Composite Schwartz-Zippel (LCSZ)). Let <span class="math">N = \\prod_{i=1}^{\\ell} p_i^{r_i}</span> for distinct primes <span class="math">p_1, \\ldots, p_\\ell</span>. Let <span class="math">f</span> be any <span class="math">\\mu</span>-linear integer polynomial co-prime to <span class="math">N</span>. For any integer <span class="math">m &amp;gt; 1</span> and <span class="math">\\mathbf{x}</span> sampled uniformly from <span class="math">[0, m)^\\mu</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {\\mathbf {x} \\leftarrow [ 0, m) ^ {\\mu}} [ f (\\mathbf {x}) \\equiv 0 \\bmod N ] \\leq \\frac {\\mu}{m} + \\prod_ {i = 1} ^ {\\ell} I _ {\\frac {1}{p _ {i}}} (r _ {i}, \\mu),</span></div>

    <p class="text-gray-300">where <span class="math">I_{\\frac{1}{\\mu}}(r,\\mu) = (1 - \\frac{1}{p})^{\\mu}\\sum_{j = r}^{\\infty}\\binom{\\mu + r - 1}{r}\\left(\\frac{1}{p}\\right)^{j}</span> is the regularized beta function.</p>

    <p class="text-gray-300">Proof. We begin by introducing some notations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a polynomial <span class="math">f \\in \\mathbb{Z}[X_1, \\ldots, X_\\mu]</span> let <span class="math">\\vec{f}</span> denote the coefficients of <span class="math">f</span> and let <span class="math">\\operatorname{cont}(f)</span> denote the greatest integer divisor of <span class="math">f</span>, i.e. the content.</li>

      <li><span class="math">\\vec{\\beta} = (\\beta_{1},\\dots,\\beta_{\\mu})\\in [0,m)^{\\mu}</span> is a random variable distributed uniformly over <span class="math">[0,m)^{\\mu}</span>. For any <span class="math">i\\geq 1</span>, let <span class="math">\\vec{\\beta}_i = (\\beta_1,\\dots,\\beta_i)</span>, let <span class="math">f_0 = f</span>, and let <span class="math">f_{i}(\\vec{\\beta}_{i})\\coloneqq f(\\beta_{1},\\ldots ,\\beta_{i},X_{i + 1},\\ldots ,X_{\\mu})</span>.</li>

      <li>Given the random variable <span class="math">\\vec{\\beta}</span> distributed uniformly over <span class="math">[0, m)^{\\mu}</span>, define for each <span class="math">j \\in [1, \\ell]</span> and <span class="math">i \\in [1, \\mu]</span> the random variable <span class="math">Y_{j,i}</span> (as a function of <span class="math">\\vec{\\beta}</span>) representing the multiplicity of <span class="math">p_j</span> in <span class="math">\\operatorname{cont}(f_i(\\vec{\\beta}_i))</span>). Naturally, we set <span class="math">Y_{j,0} = 0</span> for all <span class="math">j</span> because <span class="math">\\forall_j f_0 \\neq 0 \\bmod p_j</span>. (Note: <span class="math">Y_{j,i}</span> are not independent). For any <span class="math">i \\in [\\mu]</span> the event that <span class="math">\\forall_j Y_{j,i} \\geq r_j</span> is equivalent to the event that <span class="math">f_i(\\vec{\\beta}_i) = 0 \\bmod N</span> and the event that <span class="math">\\forall_j Y_{j,i} = r_i</span> is equivalent to <span class="math">\\operatorname{cont}(f_i(\\vec{\\beta}_i)) = N</span>. The event <span class="math">\\forall_j Y_{j,\\mu} \\geq r_j</span> is thus equivalent to <span class="math">f(\\vec{\\beta}) = 0 \\bmod N</span>.</li>

      <li>Let <span class="math">\\{Z_{j,i}\\}</span> for <span class="math">i \\in [\\mu]</span> and <span class="math">j \\in [\\ell]</span> be a set of independent random variables, where <span class="math">Z_{j,i}</span> is geometric with parameter <span class="math">1 - \\frac{1}{p_i}</span>.</li>

    </ul>

    <p class="text-gray-300">From the CCDF (complementary CDF) of geometric random variables we have that <span class="math">P[Z_{j,i} \\geq k] = \\left(\\frac{1}{p_i}\\right)^k</span>. Setting <span class="math">Z_j \\coloneqq \\sum_{i=1}^{\\mu} Z_{j,i}</span>, from the CCDF of the negative binomial distribution (i.e., tail distribution of the sum of independent geometric random variables) it follows that <span class="math">\\forall_j P[Z_j \\geq r] = I_{\\frac{1}{p_i}}(r, \\mu)</span>.</p>

    <p class="text-gray-300">Next, we establish an important subclaim:</p>

    <p class="text-gray-300">Claim 1. For any <span class="math">i \\geq 2</span> and <span class="math">\\vec{k}, \\vec{k}&#x27; \\in \\mathbb{N}^{\\ell}</span> where <span class="math">\\forall_j k_j \\geq 0</span>:</p>

    <div class="my-4 text-center"><span class="math-block">P [ \\forall_ {j} Y _ {j, i} \\geq k _ {j} + k _ {j} ^ {\\prime} ] \\forall_ {j} Y _ {j, i - 1} = k _ {j} ^ {\\prime} ] \\leq \\frac {1}{m} + P [ \\forall_ {j} Z _ {j, i} \\geq k _ {j} ].</span></div>

    <p class="text-gray-300">Furthermore, for all <span class="math">i\\geq 1</span>, <span class="math">P[\\forall_jY_{j,i}\\geq Y_{j,i - 1} + k_j]\\leq \\frac{1}{m} +P[\\forall_jZ_{j,i}\\geq k_j]</span>.</p>

    <p class="text-gray-300">Proof. Since the order of the variables does not matter, w.l.o.g. assume that <span class="math">\\forall_{j\\in [1,\\ell &#x27;]}k_j\\geq 1</span> and <span class="math">\\forall_{j &amp;gt; \\ell &#x27;}k_j = 0</span>. Let <span class="math">N^{*} = \\prod_{j = 1}^{\\ell &#x27;}p_{j}^{k_{j}}</span> and <span class="math">N^{\\prime} = \\prod_{j = 1}^{\\ell^{\\prime}}p_{j}^{\\prime}</span> . For any <span class="math">i\\geq 2</span> and any <span class="math">\\mathbf{x}\\in [0,m)^{i - 1}</span>, in the event that <span class="math">\\vec{\\beta}_{i - 1} = \\mathbf{x}</span> and <span class="math">\\forall jY_{j,i - 1} = k_j^\\prime</span>, then by definition <span class="math">f_{i - 1}(\\mathbf{x})\\equiv 0\\bmod N^{\\prime}</span> and <span class="math">\\forall_jf_{i - 1}(\\mathbf{x}) / N^{\\prime}\\not\\equiv 0\\bmod p_j</span>. In case <span class="math">i = 1</span>, we have that <span class="math">\\forall_jY_{j,0} = 0</span>, <span class="math">N^{\\prime} = 1</span></p>

    <p class="text-gray-300">and <span class="math">\\forall_j f_0 = f \\neq 0 \\mod p_j</span>. Thus, for all <span class="math">i \\geq 1</span>, conditioned on the events that <span class="math">\\vec{\\beta}_{i-1} = \\mathbf{x}</span> and <span class="math">\\forall_j Y_{j,i-1} = k_j&#x27;</span>, there exist multilinear <span class="math">\\mu - i</span> variate polynomials <span class="math">h_i, g_i</span> such that <span class="math">f_{i-1}(\\mathbf{x}) / N&#x27; = h_i(X_{i+1}, \\ldots, X_\\mu) + X_i \\cdot g_i(X_{i+1}, \\ldots, X_\\mu)</span> where for all <span class="math">j</span> at least one of <span class="math">h_i</span> or <span class="math">g_i</span> is nonzero modulo <span class="math">p_j</span>.</p>

    <p class="text-gray-300">Furthermore, for any <span class="math">i \\geq 1</span>, conditioned on the events <span class="math">\\forall j Y_{j,i-1} = k_j&#x27;</span> and <span class="math">\\vec{\\beta}_{i-1} = \\mathbf{x}</span>, the event that <span class="math">\\forall_j Y_{j,i} \\geq k_j + k_j&#x27;</span> is equivalent to the event that <span class="math">h_i + \\beta_i g_i \\equiv 0 \\bmod N^*</span>.</p>

    <p class="text-gray-300">For each index <span class="math">t \\in [1, 2^{\\mu - i}]</span> let <span class="math">h_i[t]</span> and <span class="math">g_i[t]</span> denote the <span class="math">t</span>th coefficients of <span class="math">h_i</span> and <span class="math">g_i</span> respectively (i.e., the coefficients on the <span class="math">t</span>th monomial in a canonical ordering of the <span class="math">2^{\\mu - i}</span> monomials over the <span class="math">\\mu - i</span> variables <span class="math">X_{i+1}, \\ldots, X_\\mu</span>). Given that for every <span class="math">j \\in [\\ell&#x27;]</span> the polynomial <span class="math">h_i + X_i \\cdot g_i</span> is non-zero modulo <span class="math">p_j</span>, for each <span class="math">j \\in [\\ell&#x27;]</span> there exists at least one index <span class="math">t_j</span> for which the univariate linear polynomial <span class="math">h_i[t_j] + X_i g_i[t_j]</span> is non-zero modulo <span class="math">p_j</span>. We now have that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P \\left[ \\forall_{j} Y_{j,i} \\geq k_{j} + k_{j}&#x27; \\mid \\vec{\\beta}_{i-1} = \\mathbf{x} \\wedge \\forall_{j} Y_{j,i-1} = k_{j}&#x27; \\right] \\quad (1) \\\\ = P \\left[ \\forall_{j} h_{i} + \\beta_{i} \\cdot g_{i} \\equiv 0 \\bmod p_{j}^{k_{j}} \\right] \\quad (2) \\\\ \\leq P \\left[ \\forall_{j} h_{i}[t_{j}] + \\beta_{i} \\cdot g_{i}[t_{j}] \\equiv 0 \\bmod p_{j}^{k_{j}} \\right]. \\quad (3) \\end{array}</span></div>

    <p class="text-gray-300">For each <span class="math">t_j</span> there is at most one solution to the equation <span class="math">h_i[t_j] + X_i \\cdot g_i[t_j] \\equiv 0 \\bmod p_j</span>. Consequently, by CRT, there is at most one integer solution <span class="math">x^<em> \\in [0, N^</em>)</span> to the system of equations <span class="math">\\forall_j h_i[t_j] + X_i \\cdot g_i[t_j] \\equiv 0 \\bmod p_j^{14}</span>. If <span class="math">x^<em></span> was uniform mod <span class="math">N^</em></span> then the probability would be <span class="math">\\frac{1}{N^<em>}</span>. However, we must also consider the case that <span class="math">x^</em></span> is not uniform mod <span class="math">N^*</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">E</span> denote the event that the system of equations <span class="math">\\forall_j h_i[t_j] + \\beta_i \\cdot g_i[t_j] \\equiv 0 \\bmod p_j^{k_j}</span> from equation (3) is satisfied. There is at most one integer equivalence class modulo <span class="math">N^<em></span> satisfying this system of equations and the random variable <span class="math">\\beta_i</span> is uniformly distributed over <span class="math">[0, m)</span>. Let <span class="math">U</span> denote the event that <span class="math">\\beta_i \\in [0, m - m \\bmod N^</em>)</span> and let <span class="math">\\bar{U}</span> denote the event that <span class="math">\\beta_i \\in [m - m \\bmod N^<em>, m)</span>. Conditioned on <span class="math">U</span>, <span class="math">\\beta_i</span> is uniformly distributed modulo <span class="math">N^</em></span>, and thus $P[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U] \\leq 1 / N^<em><span class="math">. Conditioned on </span>\\bar{U}<span class="math">, </span>\\beta_i<span class="math"> is uniformly distributed over the set </span>[m - m \\bmod N^</em>, m)<span class="math">. As this set is a contiguous interval of less than </span>N^*<span class="math"> integers it contains at most one solution to the systems of equations, and thus, </span>P[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{U}] \\leq 1 / (m \\bmod N^<em>)<span class="math">. The probability of </span>\\bar{U}<span class="math"> is exactly </span>\\frac{m \\bmod N^</em>}{m}$. Therefore:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P[E] = P[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U] \\cdot P[U] + P[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{U}] \\cdot P[\\bar{U}] \\quad (4) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq \\frac{1}{N^<em>} \\cdot \\left(1 - \\frac{m \\bmod N^</em>}{m}\\right) + \\frac{1}{m \\bmod N^<em>} \\cdot \\frac{m \\bmod N^</em>}{m} \\quad (5) \\\\ \\leq \\frac{1}{N^*} + \\frac{1}{m}. \\quad (6) \\end{array} $$</p>

    <p class="text-gray-300">We also have that:</p>

    <div class="my-4 text-center"><span class="math-block">P[\\forall_{j \\in [\\ell]} Z_{j,i} \\geq k_{j}] = \\prod_{j=1}^{\\ell&#x27;} P[Z_{j,i} \\geq k_{j}] = \\prod_{j=1}^{\\ell&#x27;} \\left(\\frac{1}{p_{j}}\\right)^{k_{j}} = \\frac{1}{N^{*}}.</span></div>

    <p class="text-gray-300">Thus, putting it all together, for any <span class="math">i \\geq 1</span> and any <span class="math">\\mathbf{x} \\in [0, m)^{i-1}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">P[\\forall_{j} Y_{j,i} \\geq k_{j} + k_{j}&#x27; \\mid \\vec{\\beta}_{i-1} = \\mathbf{x} \\wedge \\forall_{j} Y_{j,i-1} = k_{j}&#x27;] \\leq \\frac{1}{m} + \\frac{1}{N^{*}} = \\frac{1}{m} + P[\\forall_{j} Z_{j,i} \\geq k_{j}].</span></div>

    <p class="text-gray-300">Since the probability bound is independent of <span class="math">\\mathbf{x}</span>, this implies:</p>

    <div class="my-4 text-center"><span class="math-block">P[\\forall_{j} Y_{j,i} \\geq k_{j} + k_{j}&#x27; \\mid \\forall_{j} Y_{j,i-1} = k_{j}&#x27;] \\leq \\frac{1}{m} + P[\\forall_{j} Z_{j,i} \\geq k_{j}].</span></div>

    <p class="text-gray-300">Consequently, for any <span class="math">i \\geq 2</span> and <span class="math">\\vec{k} \\in \\mathbb{N}^{\\ell}</span> where <span class="math">\\forall_j k_j &amp;gt; 0</span>:</p>

    <div class="my-4 text-center"><span class="math-block">P[\\forall_{j} Y_{j,i} \\geq Y_{j,i-1} + k_{j}] \\leq \\max_{\\vec{k}^i} P[\\forall_{j} Y_{j,i} \\geq k_{j} + k_{j}&#x27; \\mid \\forall_{j} Y_{j,i-1} = k_{j}&#x27;] \\leq \\frac{1}{m} + P[\\forall_{j} Z_{j,i} \\geq k_{j}].</span></div>

    <p class="text-gray-300">Similarly, for <span class="math">i = 1</span> and <span class="math">\\vec{k} \\in \\mathbb{N}^{\\ell}</span> where <span class="math">\\forall_j k_j &amp;gt; 0</span>:</p>

    <div class="my-4 text-center"><span class="math-block">P[\\forall_{j} Y_{j,i} \\geq k_{j}] \\leq \\frac{1}{m} + P[\\forall_{j} Z_{j,i} \\geq k_{j}].</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">33</p>

    <p class="text-gray-300">We now prove the full theorem by induction over <span class="math">i \\in [1, \\mu]</span>. Specifically, we will prove the following inductive hypothesis for <span class="math">i \\in [1, \\mu]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">P[f_i(\\vec{\\beta}_i) = 0 \\bmod N] = P[\\forall_j Y_{j,i} \\geq r_j] \\leq \\frac{i}{m} + \\prod_{j=1}^{\\ell} P[\\sum_{k=1}^{i} Z_{j,k} \\geq r_j].</span></div>

    <p class="text-gray-300">Setting <span class="math">i = \\mu</span> this is equivalent to the theorem statement.</p>

    <p class="text-gray-300"><strong>Base Case:</strong> The base case follows directly from the subclaim for the case <span class="math">i = 1</span>.</p>

    <div class="my-4 text-center"><span class="math-block">P[\\forall_j Y_{j,1} \\geq r_j] \\leq \\frac{1}{m} + P[\\forall_j Z_{j,1} \\geq r_j] = \\frac{1}{m} + \\prod_{j=1}^{\\ell} P[Z_{j,1} \\geq r_j].</span></div>

    <p class="text-gray-300"><strong>Induction Step:</strong> Assume the inductive hypothesis holds for some <span class="math">1 \\leq i &amp;lt; \\mu</span>, i.e.:</p>

    <div class="my-4 text-center"><span class="math-block">P[\\forall_j Y_{j,i} \\geq r_j] \\leq \\frac{i}{m} + \\prod_{j=1}^{\\ell} P[\\sum_{k=1}^{i} Z_{j,k} \\geq r_j].</span></div>

    <p class="text-gray-300">We will show this implies the hypothesis holds for <span class="math">i + 1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} P[\\forall_j Y_{j,i+1} \\geq r_j] &amp;amp;= \\sum_{\\vec{k} \\in \\mathbb{N}^{\\ell}} P[\\forall_j Y_{j,i+1} - Y_{j,i} \\geq r_j - k_j] \\cdot [\\forall_j Y_{j,i} = k_j] \\cdot P[\\forall_j Y_{j,i} = k_j] \\\\ &amp;amp;\\leq \\sum_{\\vec{k}} (P[\\forall_j Z_{j,i+1} \\geq r_j - k_j] + \\frac{1}{m}) \\cdot P[\\forall_j Y_{j,i} = k_j] \\quad (\\text{by subclaim}) \\\\ &amp;amp;= \\frac{1}{m} + \\sum_{\\vec{k}} P[\\forall_j Z_{j,i+1} \\geq r_j - k_j] \\cdot P[\\forall_j Y_{j,i} = k_j] \\\\ &amp;amp;= \\frac{1}{m} + \\sum_{\\vec{\\Delta} \\in \\mathbb{Z}^2, \\forall j \\Delta_j \\leq r_j} P[\\forall_j Z_{j,i+1} \\geq \\Delta_j] \\cdot P[\\forall_j Y_{j,i} = r_j - \\Delta_j] \\quad (\\text{change of variables}) \\\\ &amp;amp;= \\frac{1}{m} + \\sum_{\\vec{\\Delta} \\in \\mathbb{Z}^2, \\forall j \\Delta_j \\leq r_j} \\sum_{\\vec{k} \\in \\mathbb{N}^2} P[\\forall_j Z_{j,i+1} = \\Delta_j + k_j] \\cdot P[\\forall_j Y_{j,i} = r_j - \\Delta_j] \\\\ &amp;amp;= \\frac{1}{m} + \\sum_{\\vec{\\Delta}&#x27; \\in \\mathbb{N}^2} P[\\forall_j Z_{j,i+1} = \\Delta&#x27;_j] \\cdot \\sum_{\\vec{k} \\in \\mathbb{N}^2} P[\\forall_j Y_{j,i} = r_j - (\\Delta&#x27;_j - k_j)] \\quad (\\text{c.o.v.}) \\\\ &amp;amp;= \\frac{1}{m} + \\sum_{\\vec{\\Delta}&#x27; \\in \\mathbb{N}^2} P[\\forall_j Z_{j,i+1} = \\Delta&#x27;_j] \\cdot P[\\forall_j Y_{j,i} \\geq r_j - \\Delta&#x27;_j] \\\\ &amp;amp;\\leq \\frac{1}{m} + \\sum_{\\vec{\\Delta}&#x27;} P[\\forall_j Z_{j,i+1} = \\Delta&#x27;_j] \\cdot (P[\\forall_j \\sum_{i&#x27;=1}^{i} Z_{j,i&#x27;} \\geq r_j - \\Delta&#x27;_j] + \\frac{i}{m}) \\quad (\\text{inductive hyp.}) \\\\ &amp;amp;= \\frac{i+1}{m} + \\sum_{\\vec{\\Delta}&#x27;} P[\\forall_j Z_{j,i+1} = \\Delta&#x27;_j] \\cdot P[\\forall_j \\sum_{k=1}^{i} Z_{j,k} \\geq r_j - \\Delta&#x27;_j] \\\\ &amp;amp;= \\frac{i+1}{m} + P[\\forall_j \\sum_{k=1}^{i} Z_{j,k} \\geq r_j - Z_{j,i+1}] \\quad (\\text{independence of variables}) \\\\ &amp;amp;= \\frac{i+1}{m} + \\prod_{j=1}^{\\ell} P[\\sum_{k=1}^{i+1} Z_{j,k} \\geq k_j]. \\quad (\\text{independence of variables}) \\end{aligned}</span></div>

    <p class="text-gray-300">□</p>

    <h2 id="sec-60" class="text-2xl font-bold">A.2 Bounds on the regularized beta function</h2>

    <p class="text-gray-300">We provide useful bounds of the regularized beta function that are necessary for the proofs of Theorems 2 and 3.</p>

    <p class="text-gray-300">The regularized incomplete beta function is defined for <span class="math">k, \\mu \\in \\mathbb{N}</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">I_\\epsilon(k, \\mu) = (1 - \\epsilon)^\\mu \\sum_{j=k}^{\\infty} \\binom{\\mu + j - 1}{j} \\epsilon^j.</span></div>

    <p class="text-gray-300">Special values are <span class="math">I_\\epsilon(k,1) = \\epsilon^k</span>, which matches the tail distribution of a geometric variable with parameter <span class="math">1 - \\epsilon</span>, and <span class="math">I_\\epsilon(1,\\mu) = 1 - (1 - \\epsilon)^\\mu</span>, which is the probability that at least one of <span class="math">\\mu</span> geometric variables of parameter <span class="math">1 - \\epsilon</span> is positive.</p>

    <p class="text-gray-300"><strong>Lemma 10.</strong> <span class="math">I_\\epsilon(k, \\mu) \\leq (\\epsilon \\mu)^k</span> for all <span class="math">\\mu, k \\in \\mathbb{N}</span> and <span class="math">\\epsilon \\in (0,1)</span> where <span class="math">\\epsilon \\mu \\leq 1/2</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> For <span class="math">k = 0</span> the statement holds because <span class="math">I_\\epsilon(0, \\mu) = 1</span>. For <span class="math">\\mu = 1</span> we have <span class="math">I_\\epsilon(k, 1) = \\epsilon^k</span>. It remains to prove the inequality for <span class="math">\\mu \\geq 2</span> and <span class="math">k \\geq 1</span>. We will use the following ordinary generating function identity for binomial coefficients: <span class="math">\\sum_{j=0}^{\\infty} \\binom{a+j}{a} x^j = \\frac{1}{(1-x)^{a+1}}</span>.</p>

    <p class="text-gray-300">This allows us to write <span class="math">I_\\epsilon(k, \\mu)</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">I_{\\epsilon}(k,\\mu) = (1 - \\epsilon)^{\\mu} \\cdot \\left(\\sum_{j=0}^{\\infty} \\binom{\\mu + j - 1}{j} \\epsilon^{j} - \\sum_{j=0}^{k-1} \\binom{\\mu + j - 1}{j} \\epsilon^{j}\\right) = (1 - \\epsilon)^{\\mu} \\cdot \\left(\\frac{1}{(1 - \\epsilon)^{\\mu}} - \\sum_{j=0}^{k-1} \\binom{\\mu + j - 1}{j} \\epsilon^{j}\\right) = 1 - (1 - \\epsilon)^{\\mu} \\sum_{j=0}^{k-1} \\binom{\\mu + j - 1}{j} \\epsilon^{j}</span></div>

    <p class="text-gray-300">Using the geometric series identity <span class="math">(\\epsilon \\mu)^k = 1 - (1 - \\epsilon \\mu) \\cdot \\sum_{j=0}^{k-1} (\\epsilon \\mu)^j</span>, we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} (\\epsilon \\mu)^{k} - I_{\\epsilon}(k, \\mu) &amp;amp;= \\sum_{j=0}^{k-1} (1 - \\epsilon)^{\\mu} \\cdot \\binom{\\mu + j - 1}{j} \\epsilon^{j} - (1 - \\epsilon \\mu)(\\epsilon \\mu)^{j} \\\\ &amp;amp;= \\sum_{j=0}^{k-1} \\left((1 - \\epsilon)^{\\mu} \\cdot \\binom{\\mu + j - 1}{j} - (1 - \\epsilon \\mu) \\mu^{j}\\right) \\epsilon^{j}. \\end{aligned}</span></div>

    <p class="text-gray-300">Let <span class="math">\\Phi_{\\epsilon, \\mu}(k) = (\\epsilon \\mu)^k - I_{\\epsilon}(k, \\mu)</span> so that the goal is to show <span class="math">\\Phi_{\\epsilon, \\mu}(k) \\geq 0</span> for <span class="math">k, \\mu \\in \\mathbb{N}</span> where <span class="math">\\mu \\geq 2</span> and <span class="math">\\epsilon \\mu \\leq 1/2</span>. Observe that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi_{\\epsilon, \\mu}(1) = \\epsilon \\mu - 1 + (1 - \\epsilon)^{\\mu} = (1 - \\epsilon)^{\\mu} - (1 - \\epsilon \\mu) \\geq 0.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\lim_{k \\to \\infty} \\Phi_{\\epsilon, \\mu}(k) = 0.</span></div>

    <p class="text-gray-300">Thus, it suffices to show that <span class="math">\\Phi_{\\epsilon, \\mu}(k)</span> is non-increasing on the interval <span class="math">k \\in [2, \\infty)</span> when <span class="math">\\epsilon \\mu \\leq 1/2</span> as this implies that <span class="math">\\Phi_{\\epsilon, \\mu}(k) \\geq 0</span> for all <span class="math">k \\geq 1</span>, <span class="math">\\mu \\geq 2</span>, and <span class="math">\\epsilon \\mu \\leq 1/2</span>. Moreover, we can easily show this by showing that for all <span class="math">\\mu, j \\geq 2</span> and <span class="math">\\epsilon \\mu \\leq 1/2</span>:</p>

    <div class="my-4 text-center"><span class="math-block">(1 - \\epsilon)^{\\mu} \\cdot \\binom{\\mu + j - 1}{j} \\leq (1 - \\epsilon \\mu) \\cdot \\mu^{j}.</span></div>

    <p class="text-gray-300">Letting <span class="math">R(\\mu, j) = \\frac{\\binom{\\mu + j - 1}{j}}{\\mu^{j}}</span>, observe that:</p>

    <div class="my-4 text-center"><span class="math-block">R(\\mu, j) = \\frac{\\binom{\\mu + j - 1}{j}}{\\mu^{j}} = \\frac{\\prod_{i=0}^{j-1} (\\mu + i)}{j! \\, \\mu^{j}} = \\prod_{i=0}^{j-1} \\frac{\\mu + i}{\\mu \\cdot (i + 1)}.</span></div>

    <p class="text-gray-300">Since <span class="math">\\mu + i \\leq \\mu \\cdot (i + 1)</span> for all <span class="math">\\mu \\geq 2</span> and <span class="math">i \\geq 0</span>, it follows that <span class="math">R(\\mu, j) \\leq R(\\mu, 2) = \\frac{1}{2} \\cdot \\left(1 + \\frac{1}{\\mu}\\right)</span> for <span class="math">j \\geq 2</span>. Furthermore, for <span class="math">\\epsilon \\in (0, 1/\\mu)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{d}{d\\epsilon} \\frac{(1 - \\epsilon)^{\\mu}}{1 - \\epsilon \\mu} = \\frac{(\\mu - 1)\\epsilon \\mu (1 - \\epsilon)^{\\mu - 1}}{(1 - \\epsilon \\mu)^{2}} \\geq 0.</span></div>

    <p class="text-gray-300">Thus, for <span class="math">\\epsilon \\in (0, \\frac{1}{2\\mu}]</span> and <span class="math">\\mu \\geq 2</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{(1 - \\epsilon)^{\\mu}}{(1 - \\epsilon \\mu)} \\cdot R(\\mu, j) \\leq \\frac{(1 - \\frac{1}{2\\mu})^{\\mu}}{1/2} \\cdot R(\\mu, 2) \\leq \\frac{(1 + \\frac{1}{\\mu})}{\\sqrt{e}} \\leq e^{\\frac{1}{\\mu} - 1/2} \\leq 1.</span></div>

    <p class="text-gray-300">This completes the proof.</p>

    <p class="text-gray-300"><strong>Lemma 11.</strong> <span class="math">I_{\\epsilon}(k,\\mu) \\leq \\epsilon^{k} \\cdot k^{\\mu}</span> for <span class="math">k \\geq 2\\mu</span> and <span class="math">\\epsilon \\leq 1/2</span>.</p>

    <p class="text-gray-300">This is tighter than Bound 1 for larger <span class="math">k</span>, i.e. when <span class="math">k^{\\mu} &amp;lt; \\mu^{k}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Similar to the analysis in Bound 1, define <span class="math">\\Psi_{\\epsilon, \\mu}(k) = \\epsilon^{k} k^{\\mu} - I_{\\epsilon}(k, \\mu)</span> so that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Psi_{\\epsilon, \\mu}(k) = \\epsilon^{k} k^{\\mu} - 1 + (1 - \\epsilon)^{\\mu} \\sum_{j=0}^{k-1} \\binom{\\mu + j - 1}{j} \\epsilon^{j}.</span></div>

    <p class="text-gray-300">Bound 2 holds iff <span class="math">\\Psi_{\\epsilon, \\mu}(k) \\geq 0</span> for all <span class="math">k \\geq 2\\mu</span> and <span class="math">\\epsilon \\leq 1/2</span>. For <span class="math">\\mu = 1</span> we have <span class="math">I_{\\epsilon}(k, 1) = \\epsilon^{k}</span> so</p>

    <div class="my-4 text-center"><span class="math-block">\\Psi_{\\epsilon, 1}(k) = \\epsilon^{k} \\cdot k - \\epsilon^{k} \\geq 0.</span></div>

    <p class="text-gray-300">Furthermore, <span class="math">\\lim_{k \\to \\infty} \\Psi_{\\epsilon, \\mu}(k) = 0</span>. Thus, it suffices to show that <span class="math">\\Psi_{\\epsilon, \\mu}</span> is non-increasing on the interval <span class="math">[2\\mu, \\infty)</span> for <span class="math">\\mu \\geq 2</span> and <span class="math">\\epsilon \\leq 1/2</span>.</p>

    <p class="text-gray-300">Observe that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Psi_{\\epsilon, \\mu}(k + 1) - \\Psi_{\\epsilon, \\mu}(k) = \\epsilon^{k + 1}(k + 1)^{\\mu} - \\epsilon^{k}k^{\\mu} + (1 - \\epsilon)^{\\mu} \\binom{\\mu + k - 1}{k} \\epsilon^{k} = \\epsilon^{k} \\left[ \\epsilon(k + 1)^{\\mu} - k^{\\mu} + (1 - \\epsilon)^{\\mu} \\binom{\\mu + k - 1}{k} \\right].</span></div>

    <p class="text-gray-300">Defining:</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_{\\epsilon}(k, \\mu) := (1 - \\epsilon)^{\\mu} \\frac{\\binom{\\mu + k - 1}{k}}{k^{\\mu}} + \\epsilon (1 + \\frac{1}{k})^{\\mu}.</span></div>

    <p class="text-gray-300"><span class="math">\\Psi_{\\epsilon, \\mu}(k)</span> is non-increasing on <span class="math">k \\in [2\\mu, \\infty]</span> iff <span class="math">\\Delta_{\\epsilon}(k, \\mu) \\leq 1</span> for all <span class="math">k \\geq 2\\mu</span>. We will prove this for <span class="math">\\mu \\geq 2</span> and <span class="math">\\epsilon \\leq 1/2</span>. Using the inequality <span class="math">(1 + \\frac{1}{k})^{\\mu} \\leq \\sqrt{e}</span> for <span class="math">k \\geq 2\\mu</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_{\\epsilon}(2\\mu, \\mu) \\leq (1 - \\epsilon)^{\\mu} \\frac{\\binom{3n - 1}{2\\mu}}{(2\\mu)^{\\mu}} + \\epsilon \\sqrt{e}.</span></div>

    <p class="text-gray-300">The right hand side is decreasing as <span class="math">\\mu \\to \\infty</span> and thus for <span class="math">\\mu \\geq 2</span> and <span class="math">\\epsilon \\leq 1/2</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_{\\epsilon}(2\\mu, \\mu) \\leq (1 - \\epsilon)^{2} \\cdot \\frac{\\binom{5}{4}}{4^{2}} + \\epsilon \\sqrt{e} = (1 - \\epsilon)^{2} \\cdot \\frac{5}{16} + \\epsilon \\sqrt{e} &amp;lt; 1.</span></div>

    <p class="text-gray-300">To see why this is less than 1 for <span class="math">\\epsilon \\leq 1/2</span>, note that <span class="math">\\frac{d}{dc} (1 - \\epsilon)^2 \\cdot c_1 + \\epsilon \\cdot c_2 = 2c_1\\epsilon + c_2 - 2c_1</span> is positive when <span class="math">\\epsilon \\geq 0</span> and <span class="math">c_2 \\geq 2c_1</span>, and <span class="math">\\sqrt{e} &amp;gt; \\frac{5}{8}</span>. Thus, on the interval <span class="math">\\epsilon \\in [0, \\frac{1}{2}]</span>, <span class="math">(1 - \\epsilon)^2 \\frac{5}{16} + \\epsilon \\sqrt{e} \\leq \\frac{1}{4} \\cdot \\frac{5}{16} + \\frac{1}{2}\\sqrt{e} = 0.902\\ldots</span></p>

    <p class="text-gray-300">Finally, since <span class="math">\\Delta_{\\epsilon}(k,\\mu)</span> is decreasing as <span class="math">k\\to \\infty</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall_{k \\geq 2\\mu, \\mu \\geq 2, \\epsilon \\leq 1/2} \\Delta_{\\epsilon}(k, \\mu) \\leq \\Delta_{\\epsilon}(2\\mu, \\mu) &amp;lt; 1.</span></div>

    <p class="text-gray-300">Corollary 6. For any prime <span class="math">p</span> and any positive integer <span class="math">\\mu</span></p>

    <div class="my-4 text-center"><span class="math-block">P[\\sum_{i = 1}^{\\mu} X_i \\geq r] = I_{\\frac{1}{p}}(r, \\mu) \\leq \\begin{cases} \\frac{r^p}{p^r} \\text{ if } r \\geq 2\\mu \\\\ \\left(\\frac{\\mu}{r}\\right)^{r} \\text{ if } p \\geq 2\\mu \\\\ 1 \\text{ otherwise} \\end{cases},</span></div>

    <p class="text-gray-300">where <span class="math">X_i</span> are independent geometric variables with parameter <span class="math">\\left(\\frac{1}{p}\\right)</span> and <span class="math">P[X_i \\geq r] = \\left(\\frac{1}{p}\\right)^r</span>.</p>

    <h2 id="sec-61" class="text-2xl font-bold">A.3 Proof of Inverse LCSZ (Theorem 2)</h2>

    <p class="text-gray-300">Theorem 2 (Inverse LCSZ). For all <span class="math">\\mu \\geq 2</span>, <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span>, and all <span class="math">N</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\log N \\geq 4\\mu^{2 + \\epsilon} + \\left(1 + \\frac{1}{\\epsilon}\\right) \\cdot \\lambda.</span></div>

    <p class="text-gray-300">we have that for any <span class="math">\\mu</span>-linear polynomial <span class="math">f</span> that is coprime with <span class="math">N</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P}_{x \\leftarrow [0, m)^{\\mu}}[f(x) \\equiv 0 \\bmod N] \\leq 2^{-\\lambda} + \\frac{\\mu}{m}.</span></div>

    <p class="text-gray-300">By Theorem 1 (CSZ) we have that for <span class="math">N = \\prod_{i} p_i^{r_i}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P}_{\\mathbf{x} \\leftarrow [0, m)^{\\mu}}[f(\\mathbf{x}) \\equiv 0 \\bmod N] \\leq \\prod_{i} I_{\\frac{1}{p_i}}(r_i, \\mu) + \\frac{\\mu}{m}.</span></div>

    <p class="text-gray-300">For <span class="math">\\mu = 1</span> and <span class="math">\\log_2(N) \\geq \\lambda</span>, Theorem 1 shows that <span class="math">\\mathbb{P}_{x \\leftarrow [0, m)}[f(x) \\equiv 0 \\bmod N] \\leq 2^{-\\lambda} + \\frac{1}{m}</span>. This is derived by substituting <span class="math">I_{1/p}(r, 1) = \\frac{1}{p^r}</span>, which gives <span class="math">\\mathbb{P}_{x \\leftarrow [0, m)}[f(x) \\equiv 0 \\bmod N] \\leq \\frac{1}{N} + \\frac{1}{m}</span>. The case <span class="math">\\mu \\geq 2</span> is more complicated. This is the focus of the rest of the proof.</p>

    <p class="text-gray-300">For a given <span class="math">N \\in \\mathbb{N}</span>, let <span class="math">S(N)</span> denote the set of pairs <span class="math">(p, r)</span> where <span class="math">p</span> is a prime divisor of <span class="math">N</span> and <span class="math">r</span> is its multiplicity, i.e. <span class="math">N = \\prod_{(p, r) \\in S} p^r</span>.</p>

    <p class="text-gray-300">It follows from Theorem 1 (CSZ) that if <span class="math">N \\geq t(\\lambda, \\mu) = \\sup_{N \\in \\mathbb{N}} \\left\\{ \\prod_{(p,r) \\in S(N)} I_{\\frac{1}{p}}(r, \\mu) \\geq 2^{-\\lambda} \\right\\}</span> then</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P}_{\\mathbf{x} \\leftarrow [0, m)^{\\mu}}[f(\\mathbf{x}) \\equiv 0 \\bmod N] \\leq 2^{-\\lambda} + \\frac{\\mu}{m}.</span></div>

    <p class="text-gray-300">Assuming <span class="math">t(\\lambda, \\mu) &amp;lt; \\infty</span>, we obtain the following constrained maximization problem:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\log_ {2} t (\\lambda , \\mu) := \\max  _ {N \\in \\mathbb {N}} \\log_ {2} N \\\\ \\text {subject to} \\sum_ {(p, r) \\in S (N)} - \\log_ {2} I _ {\\frac {1}{p}} (r, \\mu) \\leq \\lambda . \\end{array} \\tag {Constrained \\ Max 1}</span></div>

    <p class="text-gray-300">In order to derive an upper bound on <span class="math">\\log_2 t(\\lambda, \\mu)</span>, we construct a sequence of modified maximization problems, each of which is an upper bound to the prior. The last in this sequence is a knapsack problem for which we analytically derive an upper bound.</p>

    <p class="text-gray-300"><strong>Definition 9.</strong> Let <span class="math">\\mathsf{val}(p,r) \\coloneqq r\\log_2p</span> and let <span class="math">\\mathsf{weight}_\\mu (p,r) = -\\log_2I_{\\frac{1}{p}}(r,\\mu)</span>. Additionally, for all <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span>, let:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {w e i g h t} _ {\\mu , \\epsilon} (p, r) := \\left\\{ \\begin{array}{l} r \\cdot (\\log_ {2} (p) - \\log_ {2} (\\mu)) \\text { if } p \\geq \\mu^ {1 + \\epsilon} \\\\ r \\cdot \\log_ {2} (p) - \\mu \\cdot \\log_ {2} (r) \\text { if } p &amp;lt;   \\mu^ {1 + \\epsilon} \\wedge r &amp;gt; 2 (1 + \\epsilon) \\frac {\\mu \\ln \\mu}{\\ln p} \\\\ 0 \\text { otherwise} \\end{array} \\right..</span></div>

    <p class="text-gray-300"><strong>Claim 2.</strong> For any prime <span class="math">p</span> and <span class="math">r \\in \\mathbb{N}</span>, if <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span> then <span class="math">\\mathsf{weight}_{\\mu}(p,r) \\leq \\mathsf{weight}_{\\mu,\\epsilon}(p,r)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> If <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span> then <span class="math">\\mu^{1 + \\epsilon} \\geq 2\\mu</span> and the claim follows from Corollary 6 (to Lemma 10 and Lemma 11).</p>

    <p class="text-gray-300"><strong>Claim 3.</strong> For any prime <span class="math">p</span>, <span class="math">\\mathsf{weight}_{\\mu, \\epsilon}(p, r)</span> is non-decreasing over <span class="math">r \\geq 1</span> and increasing for <span class="math">r &amp;gt; 2(1 + \\epsilon)\\frac{\\mu\\log\\mu}{\\log p}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We first show that the function <span class="math">\\mathsf{weight}_{\\mu, \\epsilon}(p, r)</span> is non-decreasing in <span class="math">r</span> in each of the three cases, which comprise three subdivisions of the plane <span class="math">\\mathsf{Primes} \\times \\mathbb{N}</span>, which we denote <span class="math">S_A</span>, <span class="math">S_B</span>, and <span class="math">S_C</span> respectively. <span class="math">S_A</span> contains all <span class="math">(p, r)</span> where <span class="math">p \\geq \\mu^{1 + \\epsilon}</span>, in which case <span class="math">\\frac{d}{dc} \\mathsf{weight}_{\\mu, \\epsilon}(p, r) = \\log_2(p) - \\log_2(\\mu) &amp;gt; 0</span>. <span class="math">S_B</span> contains all <span class="math">(p, r)</span> where <span class="math">r &amp;gt; 2(1 + \\epsilon)\\frac{\\mu\\ln\\mu}{\\ln p}</span> and <span class="math">p &amp;lt; \\mu^{1 + \\epsilon}</span>, in which case <span class="math">\\frac{d}{dc} \\mathsf{weight}_{\\mu, \\epsilon}(p, r) = \\log_2(p) - \\frac{\\mu}{r\\ln 2}</span>, and <span class="math">\\log_2(p) - \\frac{\\mu}{r\\ln 2} \\geq \\log_2 p - \\frac{1}{2\\ln 2} &amp;gt; 0</span>. The weight function is constant at 0 for all remaining pairs, which comprise set <span class="math">S_C</span>.</p>

    <p class="text-gray-300">It remains to show that <span class="math">\\mathsf{weight}_{\\mu, \\epsilon}(p, r)</span> increases in <span class="math">r</span> across the boundary between <span class="math">S_B</span> and <span class="math">S_C</span>, for which it suffices to show that the weight is positive for all <span class="math">(p, r) \\in S_B</span>. Suppose, towards contradiction, that <span class="math">r \\log_2 p \\leq \\mu \\log_2 r</span> and <span class="math">r &amp;gt; 2(1 + \\epsilon) \\frac{\\mu \\log_2 \\mu}{\\log_2 p}</span>. This would imply that both <span class="math">\\frac{r}{\\log_2 r} \\leq \\frac{\\mu}{\\log_2 p}</span> and <span class="math">\\frac{r}{2(1 + \\epsilon) \\log \\mu} &amp;gt; \\frac{\\mu}{\\log_2 p}</span>, which implies that <span class="math">\\log_2 r &amp;gt; 2(1 + \\epsilon) \\log \\mu</span>. Since <span class="math">\\frac{r}{\\log_2 r}</span> is monotonic increasing in <span class="math">r</span>, this in turn implies that <span class="math">\\frac{r}{\\log_2 r} &amp;gt; \\frac{\\mu^2}{4 \\log_2 \\mu} \\geq \\mu</span> for all <span class="math">\\mu \\geq 1</span>. Finally, the implication that <span class="math">\\frac{r}{\\log_2 r} &amp;gt; \\mu</span> contradicts the assumption that <span class="math">r \\log_2 p \\leq \\mu \\log_2 r</span>.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">The first modified maximization problem is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\max  _ {N \\in \\mathbb {N}} \\sum_ {(p, r) \\in S (N)} \\operatorname {v a l} (p, r) \\\\ \\text {subject to} \\sum_ {(p, r) \\in S (N)} \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, r) \\leq \\lambda . \\end{array} \\tag {Constrained \\ Max 2}</span></div>

    <p class="text-gray-300"><strong>Claim 4.</strong> Eq. (Constrained Max 2) is an upper bound to Eq. (Constrained Max 1) for any <span class="math">\\mu</span> and <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span>:</p>

    <p class="text-gray-300"><strong>Proof.</strong> For any <span class="math">N \\in \\mathbb{N}</span>, by definition <span class="math">\\sum_{(p,r) \\in S(N)} \\mathsf{val}(p,r) = \\log_2 N</span>. Thus the only difference between the two maximization problems are the constraints. Furthermore, if <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span> then, by Claim 2, Eq. (Constrained Max 2) is simply a relaxation of the constraints in Eq. (Constrained Max 1).</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Primes}</span> denote the infinite set of prime numbers.</p>

    <p class="text-gray-300"><strong>Definition 10 (Marginal Value/Weight).</strong> Using <span class="math">\\mathsf{val}(p,r)</span> and <span class="math">\\mathsf{weight}(p,r)</span> as defined in Definition 9, <span class="math">r\\geq 1</span> and <span class="math">p\\in \\mathsf{Primes}</span>, let <span class="math">\\Delta \\mathsf{val}(p,r)\\coloneqq \\mathsf{val}(p,r) - \\mathsf{val}(p,r - 1) = \\log_2p</span> and <span class="math">\\Delta \\mathsf{val}(p,0)\\coloneqq \\mathsf{val}(p,0) = 0</span>. Similarly, for <span class="math">r\\geq 1</span> let <span class="math">\\Delta \\mathsf{weight}_{\\mu ,\\epsilon}(p,r)\\coloneqq \\mathsf{weight}_{\\mu ,\\epsilon}(p,r) - \\mathsf{weight}_{\\mu ,\\epsilon}(p,r - 1)</span> and <span class="math">\\Delta \\mathsf{weight}_{\\mu ,\\epsilon}(p,0)\\coloneqq \\mathsf{weight}_{\\mu ,\\epsilon}(p,0) = 1</span>.</p>

    <p class="text-gray-300">By Claim 3, <span class="math">\\Delta \\mathrm{weight}_{\\mu ,\\epsilon}(p,r)</span> is non-negative for all prime <span class="math">p</span> and <span class="math">r\\in \\mathbb{N}</span>, and positive for <span class="math">r &amp;gt; 2(1 + \\epsilon)\\frac{\\mu\\log\\mu}{\\log p}</span>. The following knapsack problem gives an upper bound to Eq. (Constrained Max 2):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\max  _ {S \\subseteq \\text {Primes} \\times \\mathbb {N}} \\sum_ {(p, r) \\in S} \\Delta \\operatorname {v a l} (p, r) \\\\ \\text {subject to} \\sum_ {(p, r) \\in S} \\Delta \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, r) \\leq \\lambda . \\end{array} \\tag {Knapsack Problem}</span></div>

    <p class="text-gray-300">Claim 5. Eq. (Knapsack Problem) is an upper bound to Eq. (Constrained Max 2).</p>

    <p class="text-gray-300">Proof. Le <span class="math">S^<em></span> denote argmax of Eq. (Knapsack Problem) with <span class="math">v^</em> = \\sum_{(p,r) \\in S^*} \\Delta \\mathrm{val}(p,r)</span> and suppose (towards contradiction) that there exists <span class="math">N \\in \\mathbb{N}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in S (N)} \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, r) \\leq \\lambda</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in S (N)} \\operatorname {v a l} (p, r) &amp;gt; v ^ {*}.</span></div>

    <p class="text-gray-300">Consider the set <span class="math">S&#x27;</span>, which includes <span class="math">S(N)</span> and adds for each <span class="math">(p, r) \\in S(N)</span> the pairs <span class="math">(p, j)</span> for each <span class="math">j \\leq r</span>, i.e:</p>

    <div class="my-4 text-center"><span class="math-block">S ^ {\\prime} = \\bigcup_ {(p, r) \\in S (N)} \\bigcup_ {j = 0} ^ {r} \\{(p, j) \\}.</span></div>

    <p class="text-gray-300">Observe that:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in S ^ {\\prime}} \\Delta \\operatorname {v a l} (p, r) = \\sum_ {(p, r) \\in S (N)} \\sum_ {j = 0} ^ {r} \\Delta \\operatorname {v a l} (p, j) = \\sum_ {(p, r) \\in S (N)} \\operatorname {v a l} (p, r) &amp;gt; v ^ {*}.</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in S ^ {\\prime}} \\Delta \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, r) = \\sum_ {(p, r) \\in S (N)} \\sum_ {j = 0} ^ {r} \\Delta \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, j) = \\sum_ {(p, r) \\in S (N)} \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, r) \\leq \\lambda .</span></div>

    <p class="text-gray-300">This is a contradiction to the assumption that <span class="math">v^{*}</span> is the solution to Eq. (Knapsack Problem).</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Finally, we prove a series of claims that will enable us to derive an upper bound on Eq. (Knapsack Problem). First, we define:</p>

    <p class="text-gray-300">Definition 11 (Density). <span class="math">\\mathsf{density}_{\\mu ,\\epsilon}(p,r) = \\frac{\\Delta\\mathrm{val}(p,r)}{\\Delta\\mathrm{weight}_{p,\\epsilon}(p,r)}</span> where <span class="math">\\Delta \\mathrm{val}(p,r)</span> and <span class="math">\\Delta \\mathrm{weight}(p,r)</span> are defined in Definition 10.</p>

    <p class="text-gray-300">Claim 6. For all <span class="math">S \\subseteq \\operatorname{Primes} \\times \\mathbb{N}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in S} \\Delta \\operatorname {v a l} (p, r) \\leq \\sum_ {(p, r) \\in S} \\Delta \\operatorname {w e i g h t} (p, r) \\cdot \\max  _ {(p, r) \\in S} \\left\\{\\operatorname {d e n s i t y} _ {\\mu , \\epsilon} (p, r) \\right\\}.</span></div>

    <p class="text-gray-300">Proof.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {(p, r) \\in S} \\Delta \\operatorname {w e i g h t} (p, r) \\cdot \\max  _ {(p, r) \\in S} \\left\\{\\operatorname {d e n s i t y} _ {\\mu , \\epsilon} (p, r) \\right\\} \\\\ \\geq \\sum_ {(p, r) \\in S} \\operatorname {w e i g h t} _ {\\mu} (p, r) \\cdot \\operatorname {d e n s i t y} _ {\\mu , \\epsilon} (p, r) \\\\ = \\sum_ {(p, r) \\in S} \\operatorname {v a l} (p, r). \\end{array}</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Claim 7. If <span class="math">\\mu \\geq 2</span>, <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span>, <span class="math">r \\geq 1</span>, and <span class="math">p \\geq \\mu^{1 + \\epsilon}</span> then <span class="math">\\mathrm{density}_{\\mu, \\epsilon}(p, r) \\leq 1 + \\frac{1}{\\epsilon}</span>.</p>

    <p class="text-gray-300">Proof. If <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span> and <span class="math">p \\geq \\mu^{1 + \\epsilon}</span> then <span class="math">p \\geq 2\\mu</span>, and thus:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {d e n s i t y} _ {\\mu , \\epsilon} (p, r) = \\frac {\\Delta \\operatorname {v a l} (p , r)}{\\Delta \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p , r)} = \\frac {\\log p}{\\log_ {2} (p) - \\log_ {2} (\\mu)}.</span></div>

    <p class="text-gray-300">Furthermore, <span class="math">p \\geq \\mu^{1 + \\epsilon}</span> implies that:</p>

    <div class="my-4 text-center"><span class="math-block">\\log_ {2} (p) - \\log_ {2} (\\mu) \\geq \\log_ {2} (p) - \\frac {1}{1 + \\epsilon} \\log_ {2} (p) = \\log_ {2} (p) \\cdot \\frac {\\epsilon}{1 + \\epsilon}.</span></div>

    <p class="text-gray-300">Thus <span class="math">\\mathrm{density}_{\\mu ,\\epsilon}(p,r)\\leq \\frac{\\log_2(p)}{\\log_2(p)\\cdot\\frac{r}{1 + \\epsilon}} = 1 + \\frac{1}{\\epsilon}.</span></p>

    <p class="text-gray-300">Claim 8. If <span class="math">\\mu \\geq 2</span>, <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span>, <span class="math">r &amp;gt; 2(1 + \\epsilon) \\cdot \\frac{\\mu \\ln \\mu}{\\ln p}</span>, and <span class="math">p &amp;lt; \\mu^{1 + \\epsilon}</span> then <span class="math">\\mathrm{density}_{\\mu, \\epsilon}(p, r) \\leq 1 + \\frac{1}{\\epsilon}</span>.</p>

    <p class="text-gray-300">Proof. Since <span class="math">p &amp;lt; \\mu^{1 + \\epsilon}</span>, the conditions on <span class="math">r</span> imply <span class="math">r &amp;gt; 2(1 + \\epsilon)\\frac{\\mu\\ln\\mu}{\\ln p} &amp;gt; 2\\mu</span> and thus:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {d e n s i t y} _ {\\mu , \\epsilon} (p, r) = \\frac {\\Delta \\operatorname {v a l} (p , r)}{\\Delta \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p , r)} = \\frac {\\ln p}{\\ln p + \\mu \\ln \\frac {r - 1}{r}} = \\frac {1}{1 - \\frac {\\mu}{\\ln p} \\ln \\frac {r}{r - 1}}.</span></div>

    <p class="text-gray-300"><span class="math">\\mathrm{density}_{\\mu,\\epsilon}(p,r)</span> is non-negative because <span class="math">\\Delta \\mathrm{val}(p,r)</span> is non-negative and <span class="math">\\Delta \\mathrm{weight}(p,r)</span> is positive over <span class="math">r &amp;gt; 2(1 + \\epsilon)\\frac{\\mu\\log\\mu}{\\log p}</span>. Thus, for <span class="math">p</span> and <span class="math">r</span> satisfying these conditions, it must be the case that <span class="math">0 \\leq \\frac{\\mu}{\\ln p}\\ln \\frac{r}{r-1} &amp;lt; 1</span>. Furthermore, this term is decreasing (approaching zero) as <span class="math">r</span> increases, which shows that for <span class="math">r</span> and <span class="math">p</span> subject to these conditions <span class="math">\\mathrm{density}_{\\mu,\\epsilon}(p,r)</span> is also decreasing in <span class="math">r</span>. Combining this with the fact that <span class="math">\\ln \\frac{r}{r-1} = \\ln(1 + \\frac{1}{r-1}) \\leq \\frac{1}{r-1}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {d e n s i t y} _ {\\mu , \\epsilon} (p, r) \\leq \\operatorname {d e n s i t y} _ {\\mu , \\epsilon} (p, 2 (1 + \\epsilon) \\frac {\\mu \\ln \\mu}{\\ln p} + 1) \\leq \\frac {1}{1 - \\frac {\\mu}{\\ln p} \\frac {\\ln p}{2 (1 + \\epsilon) \\mu \\ln p}} = \\frac {1}{1 - \\frac {1}{2 (1 + \\epsilon) \\ln \\mu}} \\leq 1 + \\frac {1}{\\epsilon}.</span></div>

    <p class="text-gray-300">Claim 9. For <span class="math">\\alpha \\in \\mathbb{R}</span> let <span class="math">\\mathrm{Primes}(\\alpha)</span> denote the set of prime numbers strictly less than <span class="math">\\alpha</span>. For <span class="math">\\mu \\in \\mathbb{N}</span> and <span class="math">\\epsilon \\in (0,1)</span> define:</p>

    <div class="my-4 text-center"><span class="math-block">B _ {\\mu , \\epsilon} := \\{(p, r): p \\in \\operatorname {P r i m e s} (\\mu^ {1 + \\epsilon}), r \\leq 2 (1 + \\epsilon) \\frac {\\mu \\ln \\mu}{\\ln p} \\}.</span></div>

    <p class="text-gray-300">Then :</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in B _ {\\mu , \\epsilon}} \\Delta \\operatorname {v a l} (p, r) \\leq 4 \\mu^ {2 + \\epsilon}.</span></div>

    <p class="text-gray-300">Proof. Let <span class="math">\\pi(X)</span> denote the prime counting function. We use the fact that <span class="math">\\pi(x) \\leq 1.3 \\cdot \\frac{x}{\\ln(x)}</span> for all <span class="math">x &amp;gt; 1</span> [RS62].</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {(p, r) \\in B _ {\\mu , \\epsilon}} \\Delta \\operatorname {v a l} (p, r) = \\sum_ {p \\in \\operatorname {P r i m e s} (\\mu^ {1 + \\epsilon})} \\sum_ {r = 0} ^ {\\lfloor 2 (1 + \\epsilon) \\frac {\\mu \\ln \\mu}{\\ln p} \\rfloor} \\log p = \\sum_ {\\operatorname {P r i m e s} (\\mu^ {1 + \\epsilon})} 2 (1 + \\epsilon) \\mu \\log_ {2} \\mu \\\\ \\leq 1. 3 \\cdot \\frac {\\mu^ {1 + \\epsilon}}{\\ln (\\mu^ {1 + \\epsilon})} \\cdot \\frac {2 \\cdot (1 + \\epsilon) \\mu \\ln (\\mu)}{\\ln (2)} \\leq 4 \\mu^ {2 + \\epsilon}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Putting together these claims, we obtain the bound:</p>

    <p class="text-gray-300">Claim 10. For all <span class="math">\\mu \\geq 2</span>, <span class="math">\\epsilon \\geq \\log_{\\mu}(2)</span> and <span class="math">S \\subseteq \\mathrm{Primes} \\times \\mathbb{N}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in S} \\Delta \\operatorname {v a l} (p, r) \\leq 4 n ^ {2 + \\epsilon} + \\sum_ {(p, r) \\in S} \\Delta \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, r) \\cdot \\left(1 + \\frac {1}{\\epsilon}\\right).</span></div>

    <p class="text-gray-300">Proof. Partition <span class="math">S</span> into disjoint sets <span class="math">S_{1}</span> and <span class="math">S_{2}</span> such that <span class="math">S_{2}</span> contains all the pairs <span class="math">(p, r) \\in S</span> for which either <span class="math">p \\geq \\mu^{1 + \\epsilon}</span> or <span class="math">r &amp;gt; 2(1 + \\epsilon)\\frac{\\mu\\ln\\mu}{\\ln p}</span>, and <span class="math">S_{1}</span> contains the remaining pairs. <span class="math">S_{1} \\subseteq B_{\\mu, \\epsilon}</span> from Claim 9 and thus <span class="math">\\sum_{(p, r) \\in S_{1}} \\Delta \\mathrm{val}(p, r) \\leq 4\\mu^{2 + \\epsilon}</span>. Furthermore, by Claim 7, if <span class="math">(p, r) \\in S_{2}</span> then <span class="math">\\mathrm{density}_{\\mu, \\epsilon}(p, r) \\leq 1 + \\frac{1}{\\epsilon}</span> and by Claim 6:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {(p, r) \\in S _ {2}} \\Delta \\operatorname {v a l} (p, r) \\leq \\sum_ {(p, r) \\in S _ {2}} \\Delta \\operatorname {w e i g h t} _ {\\mu , \\epsilon} (p, r) \\cdot \\left(1 + \\frac {1}{\\epsilon}\\right).</span></div>

    <p class="text-gray-300">Putting everything together:</p>

    <p class="text-gray-300"><span class="math">\\sum_{(p,r)\\in S}\\Delta\\mathsf{val}(p,r)</span> <span class="math">=\\sum_{(p,r)\\in S_{1}}\\Delta\\mathsf{val}(p,r)+\\sum_{(p,r)\\in S_{2}}\\Delta\\mathsf{val}(p,r)</span> <span class="math">\\leq 4n^{2+\\epsilon}+\\sum_{(p,r)\\in S}\\Delta\\mathsf{weight}_{\\mu,\\epsilon}(p,r)\\cdot(1+\\frac{1}{\\epsilon}).</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Finally, we can conclude from Claim 10 that for any <span class="math">S\\in\\mathsf{Primes}\\times\\mathbb{N}</span>, <span class="math">\\mu\\geq 2</span>, and <span class="math">\\epsilon\\geq\\log_{\\mu}(2)</span>, if <span class="math">\\sum_{(p,r)\\in S}\\Delta\\mathsf{weight}_{\\mu,\\epsilon}(p,r)\\leq\\lambda</span>, i.e., if <span class="math">S</span> satisfies the constraints of Eq. (Knapsack Problem) then:</p>

    <p class="text-gray-300"><span class="math">\\sum_{(p,r)\\in S}\\Delta\\mathsf{weight}_{\\mu,\\epsilon}(p,r)\\leq 4n^{2+\\epsilon}+\\lambda\\cdot(1+\\frac{1}{\\epsilon}).</span></p>

    <p class="text-gray-300">The right hand side of the equation is therefore an upper bound for the solution to Eq. (Knapsack Problem), and consequently (by Claim 4 and Claim 5), an upper bound for the solution <span class="math">t(\\lambda,\\mu)</span> to Eq. (Constrained Max 1) when <span class="math">\\mu\\geq 2</span>. In conclusion, for any <span class="math">N\\in\\mathbb{N}</span>, <span class="math">\\mu\\geq 2</span>, and <span class="math">\\epsilon\\geq\\log_{\\mu}(2)</span>, if <span class="math">\\log_{2}N\\geq 4n^{2+\\epsilon}+\\lambda\\cdot(1+\\frac{1}{\\epsilon})</span> then <span class="math">\\log_{2}N\\geq t(\\lambda,\\mu)</span> and:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}_{\\mathbf{x}\\leftarrow[0,m)^{\\mu}}[f(\\mathbf{x})\\equiv 0\\bmod N]\\leq 2^{-\\lambda}+\\frac{\\mu}{m}</span></p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">A.4 Proof of Computational Inverse LCSZ (Theorem 3)</h3>

    <h6 id="sec-63" class="text-base font-medium mt-4">Theorem 3 (Computational bound).</h6>

    <p class="text-gray-300">Let <span class="math">k</span> be the output of algorithm Algorithm 1 on input <span class="math">\\lambda,\\mu</span>. Then for all <span class="math">m\\in\\mathbb{N}</span>, all <span class="math">N\\geq 2^{k}</span> and all <span class="math">\\mu</span>-linear polynomials <span class="math">f</span>, coprime with <span class="math">N</span>, <span class="math">\\log_{2}N\\geq t(\\lambda,\\mu)</span> and</p>

    <p class="text-gray-300"><span class="math">P_{\\mathbf{x}\\leftarrow[0,m)^{\\mu}}[f(\\mathbf{x})\\equiv 0\\bmod N]\\leq 2^{-\\lambda}+\\frac{\\mu}{m}.</span></p>

    <p class="text-gray-300">As shown in the prior section, <span class="math">t(\\lambda,\\mu)</span> is upper bounded by a solution to a knapsack problem, Eq. (Knapsack Problem), over the infinite set of items <span class="math">\\mathsf{Primes}\\times\\mathbb{N}</span>. There is a simple well-known greedy algorithm that returns an upper bound to the optimal value for the knapsack problem over a <em>finite</em> set of items. This algorithm greedily adds items to the knapsack in order of decreasing density until the knapsack overflows the weight bound, and returns the total value of the added items at this point. Over an infinite set of items, it is not generally possible to sort by decreasing density. However, by leveraging monotonicity properties of the density function in our case, we are able to adapt the greedy approximation algorithm to work for Eq. (Knapsack Problem). In particular, we are able to enumerate over pairs in <span class="math">\\mathsf{Primes}\\times\\mathbb{N}</span> in an order of non-increasing density.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Claim 11.</h6>

    <p class="text-gray-300">Let <span class="math">A</span> and <span class="math">B</span> be any pair of discrete strictly ordered sets which contain minimum elements <span class="math">a_{0}\\in A</span> and <span class="math">b_{0}\\in B</span>. Let <span class="math">a+</span> denote the next element of <span class="math">A</span> after <span class="math">a</span> and likewise <span class="math">b+</span> the next element of <span class="math">B</span> after <span class="math">b</span>. If <span class="math">f:A\\times B\\to\\mathbb{R}^{+}</span> is monotonically non-increasing over pairs <span class="math">(a,b_{0})</span> as <span class="math">a\\in A</span> increases, and for any fixed <span class="math">a</span>, monotonically non-increasing over pairs <span class="math">(a,b)</span> as <span class="math">b\\in B</span> increases, then the following algorithm enumerates the pairs <span class="math">(a,b)\\in A\\times B</span> in order of decreasing <span class="math">f(a,b)</span>. The algorithm initializes the set <span class="math">C=\\{(a_{0},b_{0})\\}</span> and also a variable <span class="math">\\mathsf{max}_{A}</span> to keep track of the highest order element in <span class="math">A</span> seen so far. At each iteration, it removes a pair <span class="math">(a,b)\\in C</span> of lowest <span class="math">f(a,b)</span> value and appends <span class="math">(a,b)</span> to the output enumeration list. Before proceeding to the next iteration, it adds <span class="math">(a,b+)</span> to <span class="math">C</span>, and if <span class="math">a=\\mathsf{max}_{A}</span> then it also adds <span class="math">(a+,b_{0})</span> to <span class="math">C</span> and updates <span class="math">\\mathsf{max}_{A}:=a+</span>.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose, towards contradiction, that the algorithm appends <span class="math">(a,b)</span> to the output list, and there exists at least one pair <span class="math">(a^{\\prime},b^{\\prime})</span> not yet in the list at this iteration such that <span class="math">f(a^{\\prime},b^{\\prime})&gt;f(a,b)</span>. If <span class="math">b^{\\prime}\\neq b_{0}</span> and <span class="math">(a^{\\prime},b_{0})</span> appeared in the output list already, then each <span class="math">(a^{\\prime},b^{<em>})</span> for <span class="math">b^{</em>}\\in[b_{0},b^{\\prime}]</span> would also have been added to <span class="math">C</span> and removed before <span class="math">(a,b)</span> because <span class="math">f(a^{\\prime},b^{*})\\geq f(a^{\\prime},b^{\\prime})&gt;f(a,b)</span>. This would be a contradiction, so it remains to consider the case that <span class="math">b^{\\prime}=b_{0}</span>, i..e. that <span class="math">(a^{\\prime},b_{0})</span> did not appear in the list and <span class="math">f(a^{\\prime},b_{0})&gt;f(a,b)</span>.</p>

    <p class="text-gray-300">First, this implies that <span class="math">a^{\\prime}&gt;a</span>. Otherwise, If <span class="math">a^{\\prime}\\leq a</span>, then <span class="math">(a^{\\prime},b_{0})</span> would have been added to <span class="math">C</span> before <span class="math">(a,b)</span> and thus removed before <span class="math">(a,b)</span>. Second, <span class="math">b\\neq b_{0}</span> and</p>

    <p class="text-gray-300"><span class="math">f(a,b)&lt;f(a,b_{0})</span>, as otherwise this would imply that <span class="math">f(a^{\\prime},b_{0})&gt;f(a,b)\\geq f(a,b_{0})</span>, contradicting the monotonicity property. Thus <span class="math">(a,b_{0})</span> must already appear in the output list because it is added to <span class="math">C</span> before <span class="math">(a,b)</span> and removed before <span class="math">(a,b)</span>. Furthermore, for all <span class="math">a^{<em>}\\in[a,a^{\\prime}]</span>, <span class="math">f(a^{</em>},b_{0})\\geq f(a^{\\prime},b_{0})&gt;f(a,b)</span>, thus each such pair <span class="math">(a^{*},b_{0})</span> would have been added and removed before <span class="math">(a,b)</span>. This is a contradiction. ∎</p>

    <p class="text-gray-300">We use the enumeration algorithm of Claim 11 to implement the greedy algorithm that obtains an upper bound to a generic knapsack problem over the infinite set of items <span class="math">\\mathsf{Primes}\\times\\mathbb{N}</span>:</p>

    <p class="text-gray-300"><span class="math">\\max_{S\\subseteq\\mathsf{Primes}\\times\\mathbb{N}}\\sum_{(p,r)\\in S}\\mathsf{val}(p,r)</span> (Generic Knapsack Problem) subject to <span class="math">\\sum_{(p,r)\\in S}\\mathsf{weight}(p,r)\\leq\\lambda.</span></p>

    <p class="text-gray-300">for any <span class="math">\\mathsf{val},\\mathsf{weight}:\\mathsf{Primes}\\times\\mathbb{N}\\to\\mathbb{R}^{+}</span> where <span class="math">\\mathsf{density}(p,r)=\\frac{\\mathsf{val}(p,r)}{\\mathsf{weight}(p,r)}</span> is monotonic non-increasing over <span class="math">r</span> for any fixed <span class="math">p</span>, and also over <span class="math">p</span> for fixed <span class="math">r=1</span>. This is presented below as Algorithm 1.</p>

    <p class="text-gray-300">Moreover, we will show that the density function defined in terms of <span class="math">\\mathsf{val}(p,r)=\\log p</span>, <span class="math">\\mathsf{weight}(p,1)=-\\log I_{1/p}(1,\\mu)</span>, and <span class="math">\\mathsf{weight}(p,r)=\\log I_{1/p}(r-1,)-\\log I_{1/p}(r,\\mu)</span> for <span class="math">r&gt;1</span> satisfies this monotonicity property. The density function in Eq. (Knapsack Problem) also has this monotonicity property, but we are able to obtain a tighter bound on Eq. (Constrained Max 1) by defining regularized beta function directly instead of the simpler form upper bounds on the regularized beta function that were more useful for deriving the analytical result in Theorem 2.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Claim 12.</h6>

    <p class="text-gray-300">Eq. (Generic Knapsack Problem) with <span class="math">\\mathsf{density}(p,r)=\\frac{\\mathsf{val}(p,r)}{\\mathsf{weight}(p,r)}</span>, <span class="math">\\mathsf{val}(p,r)=\\log p</span>, and <span class="math">\\mathsf{weight}(p,r)=\\log I_{1/p}(r-1,\\mu)-\\log I_{1/p}(r,\\mu)</span> is an upper bound to Eq. (Constrained Max 1).</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The analysis is the same as in Claim 5, replacing <span class="math">\\Delta\\mathsf{weight}_{\\mu,\\epsilon}</span> with the weights defined here. ∎</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Claim 13.</h6>

    <p class="text-gray-300">For <span class="math">p\\in\\mathbb{P},r\\in\\mathbb{N}</span> and <span class="math">\\mu\\geq 2\\in\\mathbb{N}</span> let <span class="math">\\mathsf{density}(p,r)=\\frac{\\mathsf{val}(p,r)}{\\mathsf{weight}(p,r)}</span> where <span class="math">\\mathsf{val}(p,r)=\\log p</span>, and <span class="math">\\mathsf{weight}(p,r)=\\log I_{1/p}(r-1,\\mu)-\\log I_{1/p}(r,\\mu)</span> for <span class="math">r\\geq 1</span>. Then <span class="math">\\mathsf{density}(p,r)</span> is decreasing in <span class="math">r</span> and <span class="math">\\mathsf{density}(p,1)</span> is non-increasing in <span class="math">p</span>.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Part 1: <span class="math">\\mathsf{density}(p,r)</span> is decreasing in <span class="math">r</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{density}(p,r)=\\frac{\\log p}{\\mathsf{weight}(p,r)}</span> is decreasing in <span class="math">r</span> iff <span class="math">\\mathsf{weight}(p,r)</span> is increasing in <span class="math">r</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{weight}(p,r)=-\\log I_{1/p}(r,\\mu)+\\log I_{1/p}(r-1,\\mu)=\\log\\frac{I_{1/p}(r-1,\\mu)}{I_{1/p}(r,\\mu)}.</span></p>

    <p class="text-gray-300">is decreasing in <span class="math">r</span> if <span class="math">\\frac{I_{1/p}(r-1,\\mu)}{I_{1/p}(r,\\mu)}</span> is decreasing in <span class="math">r</span>. This is the case if for all <span class="math">r</span></p>

    <p class="text-gray-300"><span class="math">\\frac{I_{1/p}(r,\\mu)}{I_{1/p}(r+1,\\mu)}-\\frac{I_{1/p}(r-1,\\mu)}{I_{1/p}(r,\\mu)}&gt;0.</span></p>

    <p class="text-gray-300">Which is equivalent to showing that</p>

    <p class="text-gray-300"><span class="math">I_{1/p}(r,\\mu)\\cdot I_{1/p}(r,\\mu)-I_{1/p}(r-1,\\mu)\\cdot I_{1/p}(r-1,\\mu)&gt;0.</span> (7)</p>

    <p class="text-gray-300">The regularized beta function <span class="math">I_{x}(a,b)</span> is log convave for all <span class="math">b&gt;1</span> as shown in <em>[x11]</em>. This implies that for <span class="math">b&gt;1</span> and all <span class="math">\\alpha,\\beta&gt;0</span> <span class="math">I_{x}(a+\\alpha,b)\\cdot I_{x}(a+\\beta,b)-I_{x}(a,b)\\cdot I_{x}(a+\\alpha+\\beta,b)&gt;0</span>. Setting <span class="math">a=r-1,b=\\mu,\\alpha=1,\\beta=1</span> this shows that Eq. (7) holds and <span class="math">\\mathsf{weight}</span> is increasing in <span class="math">r</span>, and <span class="math">\\mathsf{density}</span> is decreasing in <span class="math">r</span> for all <span class="math">\\mu&gt;1</span>.</p>

    <p class="text-gray-300">Part 2: <span class="math">\\mathsf{density}(p,1)</span> is non-increasing in <span class="math">p</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{density}(p,1)=\\frac{\\log p}{\\mathsf{weight}(p,1)}=\\frac{\\ln p}{-\\ln(1-(1-p^{-1})^{\\mu})}.</span></p>

    <p class="text-gray-300">The derivative <span class="math">\\frac{d}{dp}\\mathsf{density}(p,1)</span> is non-negative iff:</p>

    <p class="text-gray-300"><span class="math">-p^{-1}\\cdot\\ln(1-(1-p^{-1})^{\\mu})-\\frac{\\ln p\\cdot\\mu(1-p^{-1})^{\\mu-1}\\cdot p^{-2}}{1-(1-p^{-1})^{\\mu}}\\geq 0.</span></p>

    <p class="text-gray-300">Equivalently:</p>

    <p class="text-gray-300"><span class="math">-\\ln(1-(1-p^{-1})^{\\mu})-\\frac{\\ln p\\cdot\\mu(1-p^{-1})^{\\mu-1}p^{-1}}{1-(1-p^{-1})^{\\mu}}\\geq 0.</span></p>

    <p class="text-gray-300">Set <span class="math">x=1-\\frac{1}{p}</span>, which increases over the range <span class="math">(1/2,1)</span> as <span class="math">p</span> increases in the range <span class="math">[2,\\infty)</span>. The requisite inequality for <span class="math">x\\in(1/2,1)</span> becomes:</p>

    <p class="text-gray-300"><span class="math">-\\ln(1-x^{\\mu})+\\frac{\\ln(1-x)\\cdot\\mu\\cdot x^{\\mu-1}(1-x)}{1-x^{\\mu}}\\geq 0.</span></p>

    <p class="text-gray-300">which, rearranging terms, holds true iff for <span class="math">x\\in(1/2,1)</span>:</p>

    <p class="text-gray-300"><span class="math">\\frac{\\ln(1-x^{\\mu})(1-x^{\\mu})}{\\ln(1-x)(1-x)x^{\\mu-1}}\\leq\\mu.</span></p>

    <p class="text-gray-300">In fact we can show this inequality holds true over all <span class="math">x\\in(0,1)</span>. Using the inequalities <span class="math">\\ln(1-x^{\\mu})\\leq-x^{\\mu}</span> and <span class="math">-\\ln(1-x)\\geq x</span> we obtain:</p>

    <p class="text-gray-300"><span class="math">\\frac{\\ln(1-x^{\\mu})(1-x^{\\mu})}{\\ln(1-x)(1-x)x^{\\mu-1}}\\leq\\frac{x^{\\mu}(1-x^{\\mu})}{x(1-x)x^{\\mu-1}}=\\frac{1-x^{\\mu}}{1-x}\\leq\\mu.</span></p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">Proof of Theorem 3</h3>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Algorithm 1 is a greedy enumeration algorithm over pairs <span class="math">(p,r)</span> following the enumeration strategy in Claim 11. By Claim 13, density satisfies the monotonicity conditions required for Claim 11 and thus the enumeration algorithm enumerates pairs in order of non-increasing density. Thus, the algorithm outputs an upper bound to (Generic Knapsack Problem) with density <span class="math">\\mathsf{density}(p,r)=\\frac{\\mathsf{val}(p,r)}{\\mathsf{weight}(p,r)}</span>, <span class="math">\\mathsf{val}(p,r)=\\log p</span>, and <span class="math">\\mathsf{weight}(p,r)=\\log I_{1/p}(r-1,\\mu)-\\log I_{1/p}(r,\\mu)</span>. By Claim 12 this is an upper bound to Eq. (Constrained Max 1) which in turn by Theorem 1 gives a bound on <span class="math">\\log_{2}t(\\lambda,\\mu)</span>. ∎</p>

    <h2 id="sec-72" class="text-2xl font-bold">Appendix B Proof of Almost Special Soundness Theorems</h2>

    <h6 id="sec-73" class="text-base font-medium mt-4">Theorem 4 (AMSS implies Knowledge Soundness).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If a <span class="math">\\mu</span>-round interactive proof for a relation <span class="math">\\mathcal{R}</span> with <span class="math">\\lambda</span>-bit challenges, $\\mu\\in O(\\log(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, and verifier decision algorithm runtime </span>t_{V}\\in\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\lambda)<span class="math"> on input </span>\\mathsf{x}\\in\\mathcal{L}_{\\mathcal{R}}<span class="math"> and parameters </span>\\mathsf{pp}\\leftarrow\\Gamma.\\mathsf{Setup}(1^{\\lambda})<span class="math"> is </span>(k^{\\langle\\mu\\rangle},\\delta,\\Gamma,\\phi)<span class="math">-almost-special-sound then for </span>\\delta^{\\prime}(\\lambda)=2\\lambda(k+1)^{\\mu}(\\mu+t_{V})\\cdot\\max(\\delta(\\lambda),k\\cdot 2^{-\\lambda})+2^{-\\lambda}<span class="math"> it is </span>\\delta^{\\prime}$-knowledge sound for the modified relation:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{R}^{\\prime}(\\mathsf{pp})=\\{(\\mathsf{x},\\mathsf{w}):\\mathcal{R}(\\mathsf{x},\\mathsf{w})=1\\ \\ \\vee\\ \\mathsf{w}\\in\\mathcal{L}_{\\mathsf{break}}(\\mathsf{pp})\\}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathsf{break}}(\\mathsf{pp})=\\{(\\mathcal{C},\\sigma_{1},\\sigma_{2},\\iota):\\iota\\in\\mathcal{I}\\ \\wedge\\ \\sigma_{1}\\neq\\sigma_{2}\\ \\wedge\\ \\mathsf{Open}(\\mathsf{pp}_{\\iota},\\mathcal{C},\\sigma_{1})=\\mathsf{Open}(\\mathsf{pp}_{\\iota},\\mathcal{C},\\sigma_{2})=1\\}</span></p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose we have a protocol that is <span class="math">(k^{\\langle\\mu\\rangle},\\delta)</span>-almost-special-sound with challenge space <span class="math">\\mathcal{X}</span> of size <span class="math">2^{\\lambda}</span> for some negligible function <span class="math">\\delta:\\mathbb{N}\\to\\mathbb{R}</span>. We will make use of algorithms ExtractWitness, ExtractInternal, and Extend and their properties that are guaranteed to exist by the definition of almost-special-soundness (Definition 5).</p>

    <p class="text-gray-300">For any node <span class="math">\\nu</span> of a <span class="math">(k+1)</span>-ary transcript tree let <span class="math">S_{\\nu}^{<em>}</span> denote the </em>left* <span class="math">k</span>-ary subtree rooted at <span class="math">\\nu</span> defined by a breadth-first search from <span class="math">\\nu</span> that visits only the first <span class="math">k</span> children of each node reached (i.e., prunes the rightmost branch from each node of the complete <span class="math">(k+1)</span>-ary subtree <span class="math">S_{\\nu}</span>).</p>

    <p class="text-gray-300">In Definition 12, we define an algorithm <span class="math">\\mathsf{TreeExtract}(\\ell_{\\nu},\\nu,L_{S_{\\nu}},F(L)_{S_{\\nu}})</span> that operates on a labeled subtree of a <span class="math">(k+1)</span>-ary transcript tree that has depth <span class="math">\\mu</span>, where <span class="math">\\ell_{\\nu}</span> is the level of <span class="math">\\nu</span>, <span class="math">L</span> defines a <span class="math">(k+1)</span>-ary transcript tree and <span class="math">F(L)</span> is a localized transcript tree labeling, while <span class="math">L_{S_{\\nu}}</span> and <span class="math">F(L)_{S_{\\nu}}</span> are their respective restrictions to the subtree <span class="math">S_{\\nu}</span> rooted at <span class="math">\\nu</span>. This algorithm uses the algorithm Extract as a subroutine. There are three potential outcomes of running <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\nu},\\nu,L_{S_{\\nu}},F(L)_{S_{\\nu}})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If any of the calls to ExtractInternal return break, i.e. a break of a commitment scheme, the algorithm immediately outputs that break as a valid witness.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It returns openSubtree, which contains valid openings of all the commitment labels <span class="math">F(L)</span> assigned to nodes in <span class="math">S_{\\nu}</span> valid for their corresponding commitment scheme indices, including the label <span class="math">\\mathcal{C}_{\\nu}</span> on node <span class="math">\\nu</span> with respect to index <span class="math">\\iota_{\\nu}</span>. In this case we say it “succeeds”.</li>

      <li>It returns <span class="math">\\bot</span>.</li>

    </ol>

    <p class="text-gray-300">The TreeExtract algorithm is not guaranteed to succeed. In particular, the calls to ExtractInternal are only guaranteed to either succeed or break the commitment scheme when the openings of subtrees satisfy predicate <span class="math">\\phi_{a}</span> and the challenge labels are distinct within the pruned subtrees <span class="math">S_{\\nu}^{<em>}</span>. Definition 12 also defines TreeExtract<span class="math">{}^{</em>}(k,\\ell_{\\nu},\\nu,L_{S_{\\nu}^{<em>}}),F(L)_{S_{\\nu}^{</em>}})</span>, an algorithm that only extracts openings of the commitments in <span class="math">F(L)_{S_{\\nu}^{<em>}}</span> and returns an opening of <span class="math">C_{\\nu}</span> as a commitment for index <span class="math">\\iota_{\\nu}</span>. This runs similarly to TreeExtract, but it is only a function of nodes present in the left <span class="math">k</span>-ary subtree <span class="math">S_{\\nu}^{</em>}</span>. While it is possible that TreeExtract fails and TreeExtract^{∗} succeeds, they will always output the same opening of <span class="math">C_{\\nu}</span> in the event that both succeed.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{size}(k,\\mu)=\\frac{k\\nu^{+i}-1}{k-1}</span>, which is the number of nodes is a <span class="math">k</span>-ary depth <span class="math">\\mu</span> tree. Given any <span class="math">\\mu</span>-round protocol that satisfies <span class="math">(k^{(\\mu)},\\delta)</span>-almost-special-soundness, setting <span class="math">N=\\mathsf{size}(k+1,\\mu)</span> we will define a collection of predicates <span class="math">\\{\\pi_{\\nu}:\\nu\\in[1,N]\\}</span> for the nodes of a <span class="math">k</span>-ary transcript tree with post-order labeling <span class="math">L</span>, such that each <span class="math">\\pi_{\\nu}</span> is a function of the partial labeling <span class="math">L_{\\nu^{<em>}}</span> and a <span class="math">\\mu-\\ell_{\\nu}</span>-length challenge vector <span class="math">\\mathbf{r}\\in\\mathcal{X}^{\\mu-\\ell_{\\nu}}</span>, where <span class="math">\\ell_{\\nu}</span> is the level of node <span class="math">\\nu</span> in the tree. Recall that <span class="math">\\nu^{</em>}&amp;lt;\\nu</span> is the node of highest index smaller than <span class="math">\\nu</span> that is not a member of the subtree of <span class="math">\\nu</span>, and <span class="math">L_{\\nu^{<em>}}</span> are the labels <span class="math">L</span> assigned to <span class="math">\\mathsf{pred}([1,\\nu^{</em>}])</span>, the superset of <span class="math">[1,\\nu^{<em>}]</span> that includes all its predecessors. Let <span class="math">\\omega</span> denote the parent node of <span class="math">\\nu</span>. Note that if <span class="math">\\nu</span> is not a first child then <span class="math">\\omega\\in\\mathsf{pred}([1,\\nu^{</em>}])</span>. Similarly, if <span class="math">\\nu^{\\prime}</span> is a left-sibling of <span class="math">\\nu</span> then <span class="math">\\nu^{\\prime}\\in[1,\\nu^{<em>}]</span>. So the labels on both <span class="math">\\nu^{\\prime}</span> and <span class="math">\\omega</span> would be included in <span class="math">L_{\\nu^{</em>}}</span>. Finally, for any localized transcript tree labeling <span class="math">F</span>, the induced labeling <span class="math">F(L)_{S_{\\nu}^{<em>}}</span> is a function of <span class="math">L_{\\nu^{</em>}}</span>. This is because the labels that <span class="math">F(L)</span> assigns to <span class="math">S_{\\nu}^{<em>}</span> are computed from the labels that <span class="math">L</span> assigns to <span class="math">S_{\\nu}^{</em>}</span> and its predecessors <span class="math">\\mathsf{pred}(S_{\\nu}^{<em>})\\subseteq\\mathsf{pred}([1,\\nu^{</em>}])</span>.</p>

    <p class="text-gray-300">The predicate <span class="math">\\pi_{\\nu}(L_{\\nu^{*}},\\mathbf{r})</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\nu</span> has no left-sibling, then <span class="math">\\pi_{\\nu}</span> always returns 1.</li>

      <li>If <span class="math">\\nu</span> has <span class="math">0&amp;lt;i&amp;lt;k</span> left-siblings (i.e., it is neither the first nor last child) then <span class="math">\\pi_{\\nu}(L_{\\nu^{*}},\\mathbf{r})=1</span> iff the challenge label <span class="math">L(\\nu)_{0}</span> assigned to <span class="math">\\nu</span> is distinct from the challenge labels assigned to its <span class="math">i</span> left-siblings.</li>

      <li>If <span class="math">\\nu</span> has no right-sibling (i.e., is rightmost child) then let <span class="math">(m_{\\omega},\\alpha_{\\omega})</span> denote the output returned by TreeExtract<span class="math">{}^{<em>}(k,\\ell_{\\omega},C_{\\omega},L_{S_{\\omega}^{</em>}},F(L)_{S_{\\omega}^{*}})</span> if successful in returning a valid opening of the commitment <span class="math">\\mathcal{C}_{\\omega}</span> with respect to its index <span class="math">\\iota_{\\omega}</span>. We say it “fails” otherwise, including potentially returning a break of the commitment scheme. Let <span class="math">m^{\\prime}</span> denote the last message in the output list of <span class="math">\\mathsf{Extend}(\\ell_{\\omega},m_{\\omega},\\mathbf{r})</span> and finally:</li>

    </ul>

    <p class="text-gray-300">\\[ \\pi_{\\nu}(L_{\\nu^{<em>}},\\mathbf{r})=\\begin{cases}1&\\quad\\text{if <span class="math">\\mathsf{TreeExtract}^{</em>}(k,\\ell_{\\omega},\\omega,L_{S_{\\omega}^{<em>}},F(L)_{S_{\\omega}^{</em>}})</span> fails}\\\\ 1&\\quad\\text{if <span class="math">\\phi_{a}(\\ell_{\\omega},m_{\\omega})=1</span>}\\\\ 1&\\quad\\text{if <span class="math">\\phi_{a}(\\ell_{\\omega},m_{\\omega})=0</span>}\\land\\phi_{a}(\\mu,m^{\\prime})=0\\\\ 0&\\text{otherwise}\\end{cases} \\]</p>

    <p class="text-gray-300">As remarked above, while TreeExtract operates on the entire <span class="math">(k+1)</span>-ary subtree of labels rooted at <span class="math">\\omega</span>, the algorithm TreeExtract^{∗} takes as input only the labelings of the left <span class="math">k</span>-ary subtree <span class="math">S_{\\omega}^{<em>}</span>, i.e. <span class="math">L_{S_{\\omega}^{</em>}}\\subseteq L_{\\nu^{<em>}}</span>, and <span class="math">F(L)_{S_{\\omega}^{</em>}}</span>, which can all be derived from <span class="math">L_{\\nu^{<em>}}</span>. By the definition of <span class="math">(k^{(\\mu)},\\delta)</span>-almost-special-soundness (Definition 5, pt. 5), for any <span class="math">\\nu\\in[0,N)</span> that has no right-sibling and any <span class="math">L_{\\nu^{</em>}}</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}_{\\mathbf{r}\\leftarrow\\mathcal{X}^{\\mu-\\ell_{\\nu}}}\\left[\\pi_{v}(L_{\\nu^{*}},\\mathbf{r})=1\\right]\\geq 1-\\delta(\\lambda)</span></p>

    <p class="text-gray-300">If <span class="math">\\nu</span> has <span class="math">0&amp;lt;i&amp;lt;k</span> left-siblings then by a union bound:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}_{\\mathbf{r}\\leftarrow\\mathcal{X}^{\\mu-\\ell_{\\nu}}}\\left[\\pi_{v}(L_{\\nu^{*}},\\mathbf{r})=1\\right]\\geq 1-\\frac{i}{2^{\\lambda}}</span></p>

    <p class="text-gray-300">For any <span class="math">\\nu\\in[0,N]</span> let <span class="math">\\mathsf{lpath}(\\nu)_{0}</span> denote the challenge labels <span class="math">L(\\cdot)_{0}</span> along the leftmost branch from <span class="math">\\nu</span> to a leaf starting with the label <span class="math">L(\\nu)_{0}</span> on <span class="math">\\nu</span>. By Lemma 3 (Path Predicate Forking Lemma) there is an algorithm <span class="math">\\mathsf{Tree}^{\\mathcal{A}}(\\mathbf{z})</span> that, given a security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, an input <span class="math">\\mathsf{x}\\in\\mathcal{L}_{\\mathcal{R}}</span>, and oracle access to an adversarial prover <span class="math">\\mathcal{A}</span> that causes <span class="math">\\mathcal{V}</span> to accept on input <span class="math">\\mathsf{x}</span> with probability <span class="math">\\epsilon</span>, runs in time at most <span class="math">t=2\\lambda\\cdot\\frac{(k+1)^{\\nu}}{\\epsilon}\\cdot(\\mu+t_{V})</span>, where <span class="math">t_{V}</span> is the worst-case running time of verifier’s decision algorithm, and returns with probability at least <span class="math">1-t\\cdot\\max(\\delta(\\lambda),\\frac{k}{2^{\\lambda}})-2^{-\\lambda}</span> a <span class="math">(k+1)</span>-ary transcript tree with post-order labeling <span class="math">L:[1,N]\\to\\mathcal{X}\\times\\mathcal{M}</span> such that <span class="math">\\pi_{v}(L_{\\nu^{*}},\\mathsf{lpath}(\\nu)_{0})=1</span> for all <span class="math">v\\in[1,N]</span>.</p>

    <p class="text-gray-300">In particular, <span class="math">L</span> defines a <span class="math">(k+1)</span>-ary transcript tree with the properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenge labels on the first <span class="math">k</span> children of any node are distinct, i.e., if <span class="math">\\omega</span> has children <span class="math">\\nu_{1},...,\\nu_{k+1}</span> ordered from left-to-right, then for any <span class="math">i,j\\in[1,k]</span> if <span class="math">i\\neq j</span> then <span class="math">L_{0}(\\nu_{i})\\neq L_{0}(\\nu_{j})</span>.</li>

      <li>If <span class="math">\\nu</span> is the <span class="math">(k+1)</span>th child of <span class="math">\\omega</span> and running <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\omega},\\omega,L_{S^{\\star}_{\\nu}},F(L)_{S^{\\star}_{\\nu}})</span> at level <span class="math">\\ell_{\\omega}</span> returns an opening of the commitment label <span class="math">\\mathcal{C}_{\\omega}=F(L)(\\omega)</span> to <span class="math">m_{\\omega}</span> with respect to index <span class="math">\\iota_{\\omega}</span> such that <span class="math">\\phi_{a}(\\ell_{\\omega},m_{\\omega})\\neq 1</span>, then the final output of <span class="math">\\mathsf{Extend}(\\ell_{\\omega},m_{\\omega},\\mathsf{lpath}(\\nu)_{0})</span> is a message <span class="math">m^{\\prime}</span> such that <span class="math">\\phi_{a}(\\mu,m^{\\prime})\\neq 1</span>.</li>

    </ol>

    <p class="text-gray-300">By Lemma 12 there is a deterministic extraction algorithm that takes any <span class="math">L</span> with the above properties and computes a witness <span class="math">\\mathsf{w}</span> such that <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}^{\\prime}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In conclusion, for any adversarial prover that succeeds on input <span class="math">x</span> with probability <span class="math">\\epsilon(x)</span>, there is a probabilistic extractor that runs in time at most <span class="math">t=2\\lambda\\frac{(k+1)^{\\mu}}{\\epsilon(x)}(\\mu+t_{V})</span> and with probability at least <span class="math">1-t\\cdot\\max(\\delta(\\lambda),\\frac{k}{2^{k}})-2^{-\\lambda}</span> returns a witness for <span class="math">\\mathcal{R}^{\\prime}</span>. Since $t\\in\\underbrace{\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\lambda)}_{\\epsilon(x)}<span class="math"> assuming </span>\\mu\\in O(\\log(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> and </span>t_{V}\\in\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\lambda)<span class="math">, this satisfies the definition of </span>\\delta^{\\prime}<span class="math">-knowledge soundness with </span>\\delta^{\\prime}(\\lambda)=2\\lambda(k+1)^{\\mu}(\\mu+t_{V})\\cdot\\max(\\delta(\\lambda),k\\cdot 2^{-\\lambda})+2^{-\\lambda}<span class="math">, which is a negligible function of </span>\\lambda<span class="math"> as long as </span>\\delta(\\lambda)$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Definition 12 (Tree Extractor).</h6>

    <p class="text-gray-300">We define an algorithm <span class="math">\\mathsf{TreeExtract}(k,\\ell,\\nu,C_{\\nu},L_{S_{\\nu}},F(L)_{S_{\\nu}})</span> where <span class="math">\\ell_{\\nu}</span> is the level of <span class="math">\\nu</span> in a <span class="math">(k+1)</span>-ary transcript tree with depth <span class="math">\\mu</span>, <span class="math">L</span> is a labeling that defines a valid transcript tree and <span class="math">F(L)</span> is a localized induced labeling, <span class="math">\\mathcal{C}_{\\nu}=F(L)(\\nu)</span> is the commitment label on <span class="math">\\nu</span> for commitment index <span class="math">\\iota_{\\nu}</span>, and and <span class="math">L_{S_{\\nu}}</span> and <span class="math">F(L)_{S_{\\nu}}</span> are their restrictions to the <span class="math">(k+1)</span>-ary subtree <span class="math">S_{\\nu}</span> rooted at <span class="math">\\nu</span>. <span class="math">L_{S_{\\nu}}</span> also contains the commitment indices in <span class="math">\\mathcal{I}</span> for each node of the subtree <span class="math">S_{\\nu}</span>. If <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\nu},\\nu,L_{S_{\\nu}},F(L)_{S_{\\nu}})</span> fails it returns <span class="math">\\bot</span>. Otherwise, it succeeds and returns <span class="math">\\mathsf{openSubtree}</span>, which contains openings of all the commitment labels <span class="math">F(L)</span> assigned to nodes in <span class="math">S_{\\nu}</span> with respect to their corresponding commitment indices in <span class="math">\\mathcal{I}</span>, and also an opening <span class="math">(m,o)</span> for the root. The algorithms runs as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all leaf nodes <span class="math">u</span>, if the opening of <span class="math">(m_{u},o_{u})</span> of <span class="math">\\mathcal{C}_{u}=F(L)(u)</span> with respect to index <span class="math">\\iota_{u}</span> does not satisfy <span class="math">\\phi_{a}(\\mu,m_{u})=1</span> then abort and output <span class="math">\\bot</span>, otherwise output <span class="math">(m_{u},o_{u})</span> and continue.</li>

      <li>For each node <span class="math">\\omega\\in S_{\\nu}</span> on the second to last level with commitment label <span class="math">\\mathcal{C}_{\\omega}=F(L)(\\omega)</span> with respect to index <span class="math">\\iota_{\\omega}</span>, set <span class="math">\\mathsf{openLeaves}</span> to include the first <span class="math">k</span> leaves of <span class="math">\\omega</span> along with their openings and commitment indices. If the challenge labels on these <span class="math">k</span> leaves given by <span class="math">L</span> are not all distinct then abort and return <span class="math">\\bot</span>. Otherwise run <span class="math">\\mathsf{Extract}(\\mu-1,\\omega,C_{\\omega},\\mathsf{openLeaves})</span> to get an opening <span class="math">(m_{\\omega},o_{\\omega})</span> of <span class="math">\\mathcal{C}_{\\omega}</span> with respect to <span class="math">\\iota_{\\omega}</span>. If <span class="math">\\phi(\\mu-1,m_{\\omega})\\neq 1</span> then abort and return <span class="math">\\bot</span>.</li>

      <li>Continue iteratively: once openings for all commitment labels of all subtrees rooted at the <span class="math">i</span>th level have been computed, for each node <span class="math">\\omega</span> on level <span class="math">i-1</span> with label <span class="math">\\mathcal{C}_{\\omega}=F(L)(\\omega)</span> with respect to <span class="math">\\iota_{\\omega}</span>, if its first <span class="math">k</span> children do not have distinct challenge labels in <span class="math">L</span> abort and return <span class="math">\\bot</span>, otherwise run <span class="math">\\mathsf{ExtractInternal}(F,i,\\mathsf{subtree}^{\\star}_{\\omega})</span> on the commitment label openings <span class="math">\\mathsf{subtree}^{\\star}_{\\omega}</span> of the left <span class="math">k</span>-ary subtree <span class="math">S^{\\star}_{\\omega}</span> (excluding node <span class="math">\\omega</span>), which were computed in prior iterations, to get <span class="math">(m_{\\omega},o_{\\omega})</span>. If <span class="math">\\phi_{a}(i,m_{\\omega})\\neq 1</span> abort and return <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">Finally, <span class="math">\\mathsf{TreeExtract}^{*}(k,\\ell_{\\nu},\\nu,C_{\\nu},L_{S^{\\star}_{\\nu}})</span> denotes the algorithm that only extracts openings of the commitments in <span class="math">L_{S^{\\star}_{\\nu}}</span> and returns an opening of <span class="math">\\mathcal{C}_{\\nu}</span>. This runs exactly like <span class="math">\\mathsf{TreeExtract}</span> except that it only iterates over nodes that are present in the left <span class="math">k</span>-ary subtree <span class="math">S^{\\star}_{\\nu}</span>.</p>

    <p class="text-gray-300">The <span class="math">\\mathsf{TreeExtract}</span> algorithm is not guaranteed to succeed. In particular, the internal calls to <span class="math">\\mathsf{Extract}</span> are only guaranteed to succeed when the openings of subtrees satisfy predicate <span class="math">\\phi_{a}</span> and the challenge labels are distinct within the pruned subtrees <span class="math">S^{\\star}_{\\nu}</span>. If any internal step fails then <span class="math">\\mathsf{TreeExtract}</span> outputs <span class="math">\\bot</span>. While it is possible that <span class="math">\\mathsf{TreeExtract}</span> fails and <span class="math">\\mathsf{TreeExtract}^{*}</span> succeeds, it is easy to see that they output the same opening of the commitment label <span class="math">C_{\\nu}</span> on node <span class="math">\\nu</span> assuming both succeed. Furthermore, while <span class="math">\\mathsf{TreeExtract}</span> operates on a labeling of a <span class="math">(k+1)</span>-ary transcript tree, the calls to <span class="math">\\mathsf{ExtractInternal}</span> run on labelings of <span class="math">k</span>-ary transcript trees because it is defined for a protocol that is <span class="math">(k^{(p)},\\delta)</span>-almost-special-sound. The reason we always pass the labeling/opening of the left <span class="math">k</span>-ary subtree (as opposed to an arbitrary <span class="math">k</span>-ary subtree) to <span class="math">\\mathsf{ExtractInternal}</span> is to ensure that the opening of <span class="math">\\mathcal{C}_{\\nu}</span> included in the output of <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\nu},\\nu,L_{S_{\\nu}},F(L)_{S_{\\nu}})</span> is a function of only the labels on the left <span class="math">k</span>-ary subtree <span class="math">S^{\\star}_{\\nu}</span> and its predecessors, and in particular is computed independently from any of the labels assigned to the (rightmost) subtree rooted at the <span class="math">(k+1)</span>th (rightmost) child of <span class="math">\\nu</span>. This fact is used in the proof of Theorem 4.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Definition 13 (Predicate Special Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\rho</span> denote any binary predicate that takes as input any <span class="math">k</span>-ary <span class="math">\\mu</span>-depth transcript tree. A <span class="math">\\mu</span>-round public coin interactive proof for a relation <span class="math">\\mathcal{R}</span> with <span class="math">\\lambda</span>-bit challenges is <span class="math">(k^{(\\mu)},\\rho)</span>-special sound if there exists a deterministic extraction algorithm <span class="math">\\mathcal{E}</span> that takes as input an instance <span class="math">\\mathsf{x}\\in\\mathcal{L}_{\\mathcal{R}}</span>, any <span class="math">k</span>-ary forking transcript tree rooted at <span class="math">\\mathsf{x}</span> with labeling <span class="math">L</span> such that <span class="math">\\rho(L)=1</span>, and returns a witness <span class="math">\\mathsf{w}</span> such that <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span> in time <span class="math">\\mathsf{poly}(\\lambda,k^{\\mu})</span>.</p>

    <p class="text-gray-300">Setting <span class="math">\\rho=1</span>, i.e. the trivial predicate that is always true, recovers the standard definition of <span class="math">k^{(\\mu)}</span>-special soundness. Recall that we defined a <em>forking</em> transcript tree (Section 5.3) as a transcript tree in which the challenge labels on edges that share the same parent node are distinct.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Lemma 12.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi(\\mathsf{pp})</span> denote a <span class="math">(k^{(\\mu)},\\delta,\\Gamma,\\phi)</span>-almost-special-sound protocol for a relation <span class="math">\\mathcal{R}</span> and any <span class="math">\\delta\\in[0,1]</span>, parametrized by <span class="math">\\mathsf{pp}\\leftarrow\\Gamma.\\mathsf{Setup}(1^{\\lambda})</span>. Define the binary predicate <span class="math">\\rho</span> as a function of a <span class="math">(k+1)</span>-ary <span class="math">\\mu</span>-depth forking transcript tree given by labeling <span class="math">L</span>, which uses the algorithm TreeExtract from Definition 12, the algorithm Extend and localized transcript tree labelling <span class="math">F</span> from Definition 5 and returns <span class="math">1</span> iff the following condition holds:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>For any node <span class="math">\\omega</span> with <span class="math">(k+1)</span>th child <span class="math">\\nu</span>, if <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\omega},\\omega,L_{S_{\\omega}^{<em>}},F(L)_{S_{\\omega}^{</em>}})</span> returns an opening <span class="math">(m_{\\omega},o_{\\omega})</span> of the label <span class="math">\\mathcal{C}_{\\omega}=F(L)(\\omega)</span> on node <span class="math">\\omega</span> (at level <span class="math">\\ell_{\\omega}</span>) with respect to commitment index <span class="math">\\iota_{\\omega}\\in\\mathcal{I}</span> such that <span class="math">\\phi_{a}(\\ell_{\\omega},m_{\\omega})\\neq 1</span>, then the final output of <span class="math">\\mathsf{Extend}(\\ell_{\\omega},m_{\\omega},\\mathsf{Ipath}(\\nu)_{0})</span> is a message <span class="math">m^{\\prime}</span> such that <span class="math">\\phi_{a}(\\mu,m^{\\prime})\\neq 1</span>.</p>
    </blockquote>

    <p class="text-gray-300"><span class="math">\\Pi(\\mathsf{pp})</span> is <span class="math">((k+1)^{(\\mu)},\\rho)</span>-special sound for the relation <span class="math">\\mathcal{R}^{\\prime}(\\mathsf{pp})</span> defined in Theorem 4.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Remark 10.</h6>

    <p class="text-gray-300">The value of <span class="math">\\delta</span> does not affect <span class="math">((k+1)^{\\mu},\\rho)</span>-special soundness. The value of <span class="math">\\delta</span> affects the runtime of the extraction algorithm that is able to generate a transcript tree satisfying the predicate <span class="math">\\rho</span> (in Theorem 4).</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We will argue that, assuming the <span class="math">(k+1)</span>-ary forking transcript tree has property <span class="math">\\rho</span>, for any <span class="math">\\omega\\in[1,N]</span>, either <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\omega},\\omega,L_{S_{\\omega}},F(L)_{S_{\\omega}})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>returns a break of the commitment scheme</li>

      <li>returns a subtree openSubtree of openings of the commitment labels in <span class="math">F(L)_{S_{\\omega}}</span> satisfying <span class="math">\\phi_{a}</span> (i.e., each opening of a label <span class="math">C_{\\omega}</span> to <span class="math">m_{\\omega}</span> for a node <span class="math">\\omega</span> on level <span class="math">\\ell_{\\omega}</span> satisfies <span class="math">\\phi_{a}(\\ell_{\\omega},m_{\\omega})=1</span>)</li>

      <li>or it returns openSubtree and there is an efficient algorithm that uses openSubtree and <span class="math">L</span> to break the commitment scheme.</li>

    </ol>

    <h4 id="sec-80" class="text-lg font-semibold mt-6">Step 1:</h4>

    <p class="text-gray-300">Suppose that <span class="math">\\omega</span> is a node of highest level <span class="math">\\ell_{\\omega}</span> for which TreeExtract fails . In other words, for any node of higher level than <span class="math">\\ell_{\\omega}</span>, the output of TreeExtract is a subtree opening that satisfies <span class="math">\\phi_{a}</span>. This means that all the openings of internal (non-root) nodes of the subtree labeling <span class="math">F(L)_{S_{\\omega}}</span> computed while running TreeExtract on <span class="math">\\omega</span> satisfy <span class="math">\\phi_{a}</span>. Furthermore, <span class="math">L</span> has the property that all challenge labels on the first <span class="math">k</span> siblings are distinct.</p>

    <h4 id="sec-81" class="text-lg font-semibold mt-6">Step 2:</h4>

    <p class="text-gray-300">By the definition of almost-special-soundness and the hypothesis in Step 1, the algorithm <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\omega},\\omega,L_{S_{\\omega}},F(L)_{S_{\\omega}})</span> either returns a break of the commitment scheme or succeeds in returning openSubtree consisting of the openings of <span class="math">F(L)_{S_{\\omega}}</span> such that the openings of all internal (non-root) nodes satisfy <span class="math">\\phi_{a}</span>, and the opening <span class="math">(m_{\\omega},o_{\\omega})</span> of the subtree root <span class="math">\\omega</span> satisfies <span class="math">\\phi_{b}(\\ell_{\\omega},m_{\\omega})=1</span>. The opening <span class="math">(m_{\\omega},o_{\\omega})</span> is also identical to the output of <span class="math">\\mathsf{TreeExtract}^{<em>}(k,\\ell_{\\omega},\\omega,L_{S_{\\omega}^{</em>}},F(L)_{S_{\\omega}^{*}})</span>.</p>

    <h4 id="sec-82" class="text-lg font-semibold mt-6">Step 3:</h4>

    <p class="text-gray-300">Suppose that <span class="math">\\mathsf{TreeExtract}(k,\\ell_{\\omega},\\omega,L_{S_{\\omega}},F(L)_{S_{\\omega}})</span> does not return a break of the commitment scheme (i.e., returns a subtree opening as described in Step 2). Let <span class="math">\\nu</span> denote the rightmost child of <span class="math">\\omega</span>. By hypothesis, if <span class="math">\\phi_{a}(\\ell_{\\omega},m_{\\omega})=0</span> then the final output of <span class="math">\\mathsf{Extend}(\\ell_{\\omega},\\mathsf{Ipath}(\\nu))</span> is a message <span class="math">m^{\\prime}</span> such that <span class="math">\\phi_{a}(\\mu,m^{\\prime})=0</span> (or a break of <span class="math">\\Gamma</span> in which case we return immediately). However, this implies that <span class="math">m^{\\prime}</span> must be distinct from the label <span class="math">F(L)</span> assigned to the leaf node of the rightmost branch extending from <span class="math">\\nu</span>. Let <span class="math">\\mathsf{Ipath}(\\nu)=(v_{1},...,v_{\\mu})</span> denote the transcript along the root-to-leaf path passing</p>

    <p class="text-gray-300">through node <span class="math">\\omega</span> and ending with its leftmost branch. For each <span class="math">i\\in[1,\\mu]</span> let <span class="math">\\hat{C}_{i}=L(v_{i})_{1}</span> and <span class="math">\\hat{\\mathbf{C}}=(\\hat{C}_{1},...,\\hat{C}_{\\mu})</span> with corresponding commitment indices <span class="math">\\vec{\\iota}=(\\iota_{1},...,\\iota_{\\mu})</span>. Finally, since <span class="math">\\phi_{b}(\\ell_{\\omega},m_{\\omega})=1</span> and openSubtree contains openings <span class="math">(m_{\\ell_{\\nu}},\\alpha_{\\ell_{\\nu}}),...(m_{\\mu},\\alpha_{\\mu})</span> of the commitments <span class="math">\\hat{C}_{\\ell_{\\nu}},...\\hat{C}_{\\mu}</span> with respect to their corresponding indices <span class="math">\\vec{\\iota}</span> that all satisfy predicate <span class="math">\\phi_{a}(i,m_{i})=1</span>, if <span class="math">m^{\\prime}\\neq m_{\\mu}</span> then by the definition of almost-special-soundness this implies that Extend outputs a conflicting opening of some commitment label in <span class="math">\\hat{\\mathbf{C}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}=F(L)(N)</span> denote the transcript tree root commitment label. The extractor uses TreeExtract to either obtain a break of the commitment scheme or openTree, which includes an opening for <span class="math">\\mathcal{C}</span>. If every opening in openTree satisfies predicate <span class="math">\\phi_{a}</span> then it runs ExtractWitness(x,openTree) to obtain witness w satisfying <span class="math">R(\\mathbf{x},\\mathbf{w})=1</span>. Otherwise, it uses the Break algorithm (as described in the previous step) to output an index <span class="math">\\iota\\in\\mathcal{I}</span> and conflicting openings of a commitment with respect to <span class="math">\\iota</span>, which is a witness for <span class="math">R^{\\prime}(\\mathsf{pp})</span>.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-83" class="text-2xl font-bold">Appendix C Fiat-Shamir Transform of Almost-Special-Sound Protocols</h2>

    <p class="text-gray-300">Recently, <em>[x21, x1]</em> showed that for <span class="math">\\mu</span>-round special sound protocols the non-interactive Fiat-Shamir transform of these protocols only suffers a security loss that is linear in the number of queries the adversary makes to the random oracle. These proofs do not directly apply to almost-special-sound protocols. In particular, in a non-interactive protocol, we cannot guarantee that the challenges on <span class="math">\\mathsf{bpath}(\\nu)</span> are mutually independent. With the FS transform each challenge is a deterministic function of the partial transcript of prover messages preceding the challenge. If the adversary has some degree of freedom in choosing each prover message without altering prior round messages, then it may be able to sample each challenge conditional on previous challenges, called <em>grinding</em>. In the case of analyzing DARK, we were able to bound the probability that <span class="math">f(x_{1},\\ldots,x_{\\mu})\\equiv 0\\bmod N</span> for <em>independently</em> sampled <span class="math">x_{1},\\ldots,x_{\\mu}</span>. If the adversary can grind challenges then it can for each challenge <span class="math">x_{i}</span> ensure that <span class="math">f(x_{1},\\ldots,x_{i},X_{i+1},\\ldots,X_{\\mu})\\equiv 0\\bmod N_{i}</span> where <span class="math">N_{i}</span> is a factor of <span class="math">N</span> of size roughly <span class="math">N^{\\frac{1}{\\nu}}</span>. The proof of Theorem 5 relies on the fact that <span class="math">\\mathbb{P}_{(\\alpha_{i+1},...,\\alpha_{\\mu})\\leftarrow[0,2^{\\lambda}]^{\\mu-1}}[g(\\alpha_{i+1},...,\\alpha_{\\mu})\\equiv 0\\bmod N]=\\delta</span> is negligible for sufficiently large <span class="math">N</span>. Analyzing a grinding adversary of the non-interactive protocol that makes at most <span class="math">T</span> queries to the random oracle corresponds to analyzing the probability that for any set of <span class="math">T</span> values</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}_{S=\\{\\alpha_{i,j}\\}_{i\\in[\\mu],j\\in[T]})\\leftarrow[0,2^{\\lambda}]^{\\mu\\cdot T}}\\exists(j_{1},\\ldots,j_{\\mu})\\text{ s.t. }[g(\\alpha_{1,j_{1}},...,\\alpha_{\\mu,j_{\\mu}})\\equiv 0\\bmod N]</span></p>

    <p class="text-gray-300">which by a union bound is less than <span class="math">T^{\\mu}\\cdot\\delta</span>.</p>

    <p class="text-gray-300">However, what conditions might be sufficient to prevent an adversary from grinding challenges? If for every partial transcript, there is a unique next prover message that leads to an accepting transcript then the adversary would not have the opportunity to grind. In fact, it suffices for this to be computationally hard. We will show that this is the case for any protocol satisfying the definition of almost-special soundness with respect to a <em>computationally unique</em> commitment scheme, which we define. This implies that the messages in each round are commitments from a scheme where it is computationally difficult to come up with two distinct commitments to the same message (note this implies the scheme cannot be hiding). The DARK protocol has precisely this property. Finally, we prove that the Fiat-Shamir transform of these almost-special-sound protocols is secure.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Definition 14 (Random Oracle).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our version of the random oracle model, all random oracle algorithms have black-box access to a shared random function <span class="math">\\mathcal{H}:\\mathcal{M}^{\\leq u}\\to\\mathcal{X}</span> where <span class="math">\\mathcal{M}^{\\leq u}</span> consists of all vectors <span class="math">(m_{1},...,m_{i})\\in\\mathcal{M}^{i}</span> for each <span class="math">i\\leq u</span>. <span class="math">\\mathcal{H}</span> assigns to each of the $\\frac{\\langle\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{u+1}-1}{\\langle\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> unique elements of </span>\\mathcal{M}^{\\leq u}<span class="math"> an output independently and uniformly distributed in </span>\\mathcal{X}<span class="math">. Random oracles may be assigned indices from a set </span>\\mathcal{I}<span class="math">, where for any distinct </span>i,j\\in\\mathcal{I}<span class="math"> the oracles </span>\\mathcal{H}_{i}<span class="math"> and </span>\\mathcal{H}_{j}<span class="math"> are independently distributed random functions. For any </span>k<u<span class="math"> and fixed </span>\\mathbf{m}=(m_{1},...,m_{k})<span class="math"> we will use the notation </span>\\mathcal{H}_{\\mathbf{m}}:\\mathcal{M}^{\\leq u-k}\\to\\mathcal{X}<span class="math"> where </span>\\mathcal{H}_{\\mathbf{m}}(m_{1}^{\\prime},...,m_{i}^{\\prime})=\\mathcal{H}(\\mathbf{m},m_{1}^{\\prime},...,m_{i}^{\\prime})<span class="math"> for any </span>i\\leq u-k<span class="math">. This is equivalent to a random oracle family indexed by </span>\\mathcal{M}^{k}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A <em><span class="math">Q</span>-query random oracle algorithm</em> is an algorithm that makes at most <span class="math">Q</span> queries to the random oracle.</p>

    <p class="text-gray-300">Definition 15 (Non-interactive Proof of Knowledge in RO). An non-interactive protocol  <span class="math">\\Pi = (\\mathcal{P},\\mathcal{V})</span>  between a prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  in the random oracle model (i.e., with shared oracle access to the random function  <span class="math">\\mathcal{H}</span> ) is a proof of knowledge for a relation  <span class="math">\\mathcal{R}</span>  with knowledge error  <span class="math">\\delta :\\mathbb{N}^2\\to [0,1]</span>  if the following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: for all  <span class="math">(x, w) \\in \\mathcal{R}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} \\left[ \\mathcal {V} ^ {\\mathcal {H}} (x, \\pi) = 1: \\pi \\leftarrow \\mathcal {P} ^ {\\mathcal {H}} (x, w) \\right] = 1</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span> -Knowledge Soundness: There exists a polynomial  <span class="math">\\mathsf{poly}(\\cdot)</span>  and a probabilistic oracle machine  <span class="math">\\mathcal{E}</span>  called the extractor such that given oracle access to any  <span class="math">Q</span> -query random oracle algorithm  <span class="math">\\mathcal{A}</span>  and any input  <span class="math">x \\in \\mathcal{L}_R</span>  the following holds: if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} \\left[ \\mathcal {V} ^ {\\mathcal {H}} (x, \\pi) = 1: \\pi \\leftarrow \\mathcal {A} ^ {\\mathcal {H}} (x) \\right] = \\epsilon (x)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then  <span class="math">\\mathcal{E}^{\\mathcal{A}}(x)</span>  outputs  <span class="math">w</span>  such that  <span class="math">(x,w)\\in \\mathcal{R}</span>  in an expected  $\\frac{\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{e(x) - \\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,Q)}<span class="math">  number of steps. In the course of running with black-box access to  </span>\\mathcal{A}<span class="math"> ,  </span>\\mathcal{E}^{\\mathcal{A}}(x)<span class="math">  implements the random oracle for  </span>\\mathcal{A}<span class="math"> , i.e. it intercepts all queries that  </span>\\mathcal{A}<span class="math">  makes to  </span>\\mathcal{H}$  and simulates the response.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pi</span>  is called "knowledge sound" or a "proof of knowledge" for  <span class="math">\\mathcal{R}</span>  if for all  <span class="math">Q</span>  polynomial in  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  the knowledge error  </span>\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, Q)<span class="math">  is a negligible function of  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 16 (Non-interactive argument of knowledge in SRS/RO). A non-interactive proof system  <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P}^{\\mathcal{H}},\\mathcal{V}^{\\mathcal{H}})</span>  with setup procedure  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(\\lambda)</span>  in the random oracle model, where  <span class="math">\\mathcal{P}^{\\mathcal{H}}</span>  and  <span class="math">\\mathcal{V}^{\\mathcal{H}}</span>  are given shared access to both the random oracle  <span class="math">\\mathcal{H}</span>  and the parameters  <span class="math">\\mathsf{pp}</span>  (where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\lambda<span class="math"> ), is an argument of knowledge for relation  </span>\\mathcal{R}<span class="math">  with knowledge error  </span>\\mathsf{err}:\\mathbb{N}^2\\to [0,1]<span class="math">  if there exists a polynomial time extractor  </span>\\mathcal{E}<span class="math">  such that for any non-uniform polynomial time adversary  </span>\\mathcal{A}<span class="math">  and deterministic  </span>Q<span class="math"> -query polynomial time prover  </span>P^{*}$  the following holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} \\left[ \\begin{array}{c c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ (x, w) \\in \\mathcal {R} a n d &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\mathcal {V} ^ {\\mathcal {H}} (\\mathsf {p p}, x, \\pi) = 1 &amp;amp; \\pi \\leftarrow P ^ {*} (\\mathsf {s t}) \\\\ &amp;amp; w \\leftarrow \\mathcal {E} ^ {P ^ {*} (\\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right] \\geq \\mathbb {P} \\left[ \\begin{array}{c c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ \\mathcal {V} ^ {\\mathcal {H}} (\\mathsf {p p}, x, \\pi) = 1 &amp;amp; : &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; &amp;amp; \\pi \\leftarrow P ^ {*} (\\mathsf {s t}) \\end{array} \\right] - \\mathsf {e r r} (\\lambda , Q)</span></div>

    <p class="text-gray-300">Definition 17 (FS Transform). For any  <span class="math">\\mu</span> -round public-coin interactive proof  <span class="math">\\Pi</span>  the FS transform  <span class="math">\\Pi_{FS}^{\\mathcal{H}}</span>  of  <span class="math">\\Pi</span>  with respect to the random oracle  <span class="math">\\mathcal{H}</span>  is a non-interactive proof in the random oracle model which on public input  <span class="math">\\mathbf{x}</span>  simulates the interactive protocol  <span class="math">\\Pi</span>  by replacing each  <span class="math">i</span> th round public-coin challenge, for  <span class="math">i \\in [1, \\mu]</span> , with  <span class="math">\\mathcal{H}(\\mathbf{x}, m_1, \\dots, m_i)</span> , where  <span class="math">m_1, \\dots, m_i</span>  denote the first  <span class="math">i</span>  prover messages.</p>

    <p class="text-gray-300">Lemma 13 (FS for special-sound multiround protocols [AFK21; Wik21]). For any  <span class="math">\\mu</span> -round interactive proof  <span class="math">\\Pi = (\\mathcal{P}, \\mathcal{V})</span>  for relation  <span class="math">\\mathcal{R}</span>  and its FS transform  <span class="math">\\Pi_{FS} = (\\mathcal{P}^{\\mathcal{H}}, \\mathcal{V}^{\\mathcal{H}})</span>  with random oracle  <span class="math">\\mathcal{H}</span> , there exists a random oracle algorithm Tree which given black-box access to any  <span class="math">Q</span> -query deterministic prover algorithm  <span class="math">\\mathcal{P}^<em></span> , input  <span class="math">x \\in \\mathcal{L}_R</span> , and  <span class="math">k \\in \\mathbb{N}</span>  makes at most  <span class="math">Q + \\mu</span>  queries to  <span class="math">\\mathcal{H}</span>  and returns a  <span class="math">k</span> -ary forking transcript tree for  <span class="math">\\Pi</span>  in expected time  <span class="math">k^\\mu + Q \\cdot (k^\\mu - 1)</span>  and succeeds with probability  <span class="math">\\frac{\\epsilon(x) - (Q + 1) \\cdot \\kappa}{(1 - \\kappa)}</span>  where  <span class="math">\\kappa = 1 - (1 - \\frac{k - 1}{2^\\lambda})^\\mu</span>  and  <span class="math">\\epsilon(x)</span>  is the probability (over  <span class="math">\\mathcal{H}</span> ) that  <span class="math">\\mathcal{P}^</em></span>  outputs a non-interactive proof for  <span class="math">x</span>  that  <span class="math">\\mathcal{V}^{\\mathcal{H}}</span>  accepts. Moreover, the transcript tree satisfies additional properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Every root-to-leaf labelled path (i.e., transcript included in the tree) matches the output of  <span class="math">\\mathcal{P}^{*\\mathcal{H}&#x27;}(x)</span>  with a partially fresh random oracle  <span class="math">\\mathcal{H}&#x27;</span> , and thus has the format of a valid  <span class="math">\\Pi_{FS}</span>  proof with respect to  <span class="math">\\mathcal{H}&#x27;</span> .</li>

      <li>For any node  <span class="math">\\nu</span> , the labels  <span class="math">L_{S_{\\nu}}</span>  on the subtree  <span class="math">S_{\\nu}</span>  are generated by a  <span class="math">(Q + \\mu)</span> -query random oracle algorithm independently from all labels  <span class="math">L_{\\nu^{*}}</span> , i.e. labels computed on lower indexed nodes that do not belong to  <span class="math">S_{\\nu}</span> . In particular, if  <span class="math">\\nu</span>  is the  <span class="math">k</span> th child of  <span class="math">\\omega</span>  then  <span class="math">L_{S_{\\nu}}</span>  is independent of the labels on the  <span class="math">(k - 1)</span> -ary left subtree of  <span class="math">\\omega</span> .</li>

    </ul>

    <p class="text-gray-300">Lemma 13 immediately implies that the FS transform of any  <span class="math">k^{(\\mu)}</span> -special sound protocol for  <span class="math">\\mathcal{R}</span>  is knowledge sound in the RO model. However, we need to work a bit harder to apply this lemma to almost-special-sound protocols. We will only be able to show computational knowledge soundness for protocols that are almost-special-sound with respect to a computationally-unique commitment scheme. The DARK proof system has this property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 18 (RO relation hardness). Let  <span class="math">\\mathcal{R}^{\\mathcal{H}}(\\mathsf{pp})</span>  denote a family of relations parametrized by a random oracle  <span class="math">\\mathcal{H}</span>  and setup  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda)</span>  with security parameter  <span class="math">\\lambda</span>  where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\lambda<span class="math"> .  </span>\\mathcal{R}^{\\mathcal{H}}(\\mathsf{pp})<span class="math">  is  </span>(Q, \\epsilon(\\lambda))<span class="math"> -hard in the RO model if for any pair of polynomial time random oracle algorithms  </span>\\mathcal{A}_1, \\mathcal{A}_2<span class="math">  where  </span>\\mathcal{A}_1<span class="math">  makes at most  </span>Q<span class="math">  queries to a random oracle  </span>\\mathcal{H}'<span class="math">  (possibly distinct from  </span>\\mathcal{H}<span class="math"> ) and  </span>\\mathcal{A}_2<span class="math">  makes at most  </span>Q<span class="math">  queries to random oracle  </span>\\mathcal{H}$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} \\left[ (\\mathsf {x}, \\mathsf {w}) \\in \\mathcal {R} ^ {\\mathcal {H}} (\\mathsf {p p}): \\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ \\mathsf {x} \\leftarrow \\mathcal {A} _ {1} ^ {\\mathcal {H} ^ {\\prime}} (\\mathsf {p p}) \\\\ \\mathsf {w} \\leftarrow \\mathcal {A} _ {2} ^ {\\mathcal {H}} (\\mathsf {p p}, \\mathsf {x}) \\end{array} \\right] \\leq \\epsilon (\\lambda)</span></div>

    <p class="text-gray-300">Definition 19 (Computationally Unique Commitments). A deterministic commitment scheme  <span class="math">\\Gamma = (\\mathsf{Setup},\\mathcal{G},\\mathsf{Commit},\\mathsf{Open})</span>  is computationally-unique if for any polynomial-time adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ b _ {0} = b _ {1} = 1 \\wedge C _ {0} \\neq C _ {1}: &amp;amp; \\mathsf {c p} _ {\\mathsf {i}} = \\mathcal {G} (\\mathsf {p p}, \\iota) \\\\ &amp;amp; b _ {0} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p} _ {\\mathsf {i}}, C _ {0}, x, r _ {0}) \\\\ &amp;amp; b _ {1} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p} _ {\\mathsf {i}}, C _ {1}, x, r _ {1}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Lemma 14. Any deterministic homomorphic commitment scheme  <span class="math">\\Gamma</span>  that is binding under rational openings to  <span class="math">\\mathcal{W} \\subseteq \\mathbb{Q}^n</span>  is computationally unique if the commitment group  <span class="math">\\mathbb{G}</span>  is either prime or is a group of unknown order in which the subgroup hidden order assumption holds for all of  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Proof. Suppose  <span class="math">C&#x27; \\neq C \\in \\mathbb{G}</span>  and  <span class="math">\\mathbf{x} / z \\in \\mathcal{W}</span>  and  <span class="math">\\operatorname{com}(\\mathbf{x}) = z \\cdot C</span>  and  <span class="math">\\operatorname{com}(\\mathbf{x} \\cdot \\Delta) = z \\cdot \\Delta \\cdot C</span> . This implies that  <span class="math">z\\Delta \\cdot (C&#x27; - C) = 0</span> . In a prime-order group this is impossible because  <span class="math">C&#x27; - C \\neq 0</span> . In a group of unknown order,  <span class="math">z\\Delta</span>  is a multiple of the order of  <span class="math">C&#x27; - C</span> , which violates the subgroup hidden order assumption for  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Lemma 15. For any  <span class="math">\\mu, Q = \\mathsf{poly}(\\lambda)</span> , and computationally-unique commitment scheme  <span class="math">\\Gamma = (\\mathsf{Setup}, \\mathcal{G}, \\mathsf{Commit}, \\mathsf{Open})</span> , predicate  <span class="math">\\rho: \\mathcal{M}^2 \\times \\mathcal{X}^\\mu \\to \\{0,1\\}</span> , and  <span class="math">\\mathsf{ext}: \\mathcal{M} \\times \\mathcal{X}^{\\leq \\mu} \\to \\mathcal{M}</span>  where  <span class="math">\\forall i, m \\in \\mathcal{M}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {\\alpha_ {1}, \\dots , \\alpha_ {\\mu}} [ \\rho_ {i} (m, m _ {\\mu}, \\alpha_ {1}, \\dots , \\alpha_ {\\mu}) = 1: \\operatorname {e x t} (m, \\alpha_ {1}, \\dots , \\alpha_ {\\mu}) = m _ {\\mu} ] \\leq \\delta</span></div>

    <p class="text-gray-300">the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {e x t}} ^ {\\mathcal {H}} (\\mathsf {p p}, \\mu , \\rho) = \\left\\{(x = (C, m, o), \\mathsf {w} = (\\mathsf {t r}, M)): \\begin{array}{c} \\mathsf {t r} = (C _ {1}, \\ldots , C _ {\\mu}) \\\\ \\forall_ {i \\in [ \\mu ]} \\alpha_ {i} = \\mathcal {H} (C, C _ {1}, \\ldots , C _ {i - 1}) \\\\ M = ((m _ {1}, o _ {1}), \\ldots , (m _ {\\mu}, o _ {\\mu})) \\\\ \\mathsf {O p e n} (\\mathsf {p p}, C, m, o) = 1 \\\\ \\mathsf {p p} _ {\\mathrm {i}} = \\mathcal {G} (\\mathsf {p p}, \\alpha_ {1}, \\ldots , \\alpha_ {i}) \\\\ \\forall_ {i \\in [ \\mu ]} \\mathsf {O p e n} (\\mathsf {p p} _ {\\mathrm {i}}, C _ {i}, m _ {i}, o _ {i}) = 1 \\\\ \\forall_ {i \\in [ \\mu ]} \\mathsf {e x t} (m, \\alpha_ {1}, \\ldots , \\alpha_ {i}) = m _ {i} \\\\ \\rho (m, m _ {\\mu}, \\alpha_ {1}, \\ldots , \\alpha_ {\\mu}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">is  <span class="math">(Q,\\delta +\\mathsf{negl}(\\lambda))</span>  -hard in the RO model.</p>

    <p class="text-gray-300">Proof. Consider any pair of polynomial time random oracle algorithms  <span class="math">\\mathbf{x} \\gets \\mathcal{A}_1^{\\mathcal{H}&#x27;}(\\mathsf{pp})</span>  and  <span class="math">\\mathsf{w} \\gets \\mathcal{A}_2^{\\mathcal{H}}(\\mathsf{pp},\\mathsf{x})</span>  that for setup parameter  <span class="math">\\lambda</span>  make at most  <span class="math">Q = \\mathsf{poly}(\\lambda)</span>  queries to their respective oracles  <span class="math">\\mathcal{H}&#x27;</span>  and  <span class="math">\\mathcal{H}</span> . For fixed  <span class="math">\\mathbf{x}</span>  let  <span class="math">T_{\\mathcal{H}}(\\mathbf{x}) = (T_1, \\dots, T_\\mu)</span>  denote a random variable representing the output  <span class="math">\\mathsf{tr}</span>  included in  <span class="math">\\mathsf{w}</span>  conditioned on the event that  <span class="math">w</span>  satisfies at least all validity criteria other than possibly the last, i.e.  <span class="math">\\rho(m, m_\\mu, \\alpha_1, \\dots, \\alpha_\\mu) = 1</span> . Note that  <span class="math">T_{\\mathcal{H}}(\\mathbf{x})</span>  is also dependent on the randomness of the oracle  <span class="math">\\mathcal{H}</span> . Presuming this event occurs with probability at least  <span class="math">\\epsilon(\\mathbf{x})</span> , we can repeat  <span class="math">\\mathcal{A}_2^{\\mathcal{H}}(\\mathsf{pp},\\mathbf{x})</span>  on fresh internal randomness (not changing  <span class="math">\\mathcal{H}</span> ) in expectation  <span class="math">1 / \\epsilon(\\mathbf{x})</span>  times until it outputs  <span class="math">\\mathsf{w}</span>  satisfying this event with a particular assignment  <span class="math">\\mathsf{tr} = (C_1, \\dots, C_\\mu)</span>  to the random variable  <span class="math">T_{\\mathcal{H}}(\\mathbf{x})</span> . Suppose that for any  <span class="math">i \\in [\\mu]</span>  we then reprogrammed  <span class="math">\\mathcal{H}</span>  to an oracle  <span class="math">\\mathcal{H}^*</span>  by sampling new answers to any subset of the queries  <span class="math">\\{q_j = (C, C_1, \\dots, C_j)\\}_{i \\leq j &amp;lt; \\mu}</span>  but keeping all</p>

    <p class="text-gray-300">other queries consistent with <span class="math">\\mathcal{H}</span>. For <span class="math">i=\\mu</span> we do not change the oracle and <span class="math">\\mathcal{H}^{<em>}=\\mathcal{H}</span>. Define the random variable <span class="math">T_{\\mathcal{H}^{\\prime}}(\\mathsf{x})</span> in the same way for the new oracle <span class="math">\\mathcal{H}^{</em>}</span>. Suppose further that repeating the same experiment with <span class="math">\\mathcal{A}_{2}^{\\mathcal{H}^{\\prime}}(\\mathsf{pp},\\mathsf{x})</span> were to return with probability greater than <span class="math">\\delta^{\\prime}(\\mathsf{x})</span> a vector <span class="math">\\mathsf{tr}^{\\prime}=(C_{1}^{\\prime},...,C_{\\mu}^{\\prime})\\neq\\mathsf{tr}</span> where the first distinct index between <span class="math">\\mathsf{tr}^{\\prime}</span> and <span class="math">\\mathsf{tr}</span> is some <span class="math">k\\leq i</span>. For <span class="math">i=\\mu</span> we just repeat the same experiment with <span class="math">\\mathcal{H}</span>. For all <span class="math">i\\in[\\mu]</span> let <span class="math">\\alpha_{i}=\\mathcal{H}(C,C_{1},...,C_{i-1})</span>, let <span class="math">m_{i}=\\mathsf{ext}(m,\\alpha_{1},...,\\alpha_{i})</span>, let <span class="math">\\alpha_{i}^{\\prime}=\\mathcal{H}^{*}(C,C_{1}^{\\prime},...,C_{i-1}^{\\prime})</span>, and let <span class="math">m_{i}^{\\prime}=\\mathsf{ext}(m,\\alpha_{1}^{\\prime},...,\\alpha_{i}^{\\prime})</span>. Since the oracle answers to queries <span class="math">C</span> and <span class="math">\\{q_{j}=(C,C_{1},...,C_{\\ell})\\}_{1\\leq\\ell&lt;k}</span> have not changed and <span class="math">(C_{1},...,C_{k-1})=(C_{1}^{\\prime},...,C_{k-1}^{\\prime})</span> it follows that <span class="math">(\\alpha_{1},...,\\alpha_{k})=(\\alpha_{1}^{\\prime},...,\\alpha_{k}^{\\prime})</span> and <span class="math">(m_{1},...,m_{k})=(m_{1}^{\\prime},...,m_{k}^{\\prime})</span>. The result of these two experiments would thus include openings of the distinct commitments <span class="math">C_{k}\\neq C_{k}^{\\prime}</span> to the same message <span class="math">m_{k}=m_{k}^{\\prime}</span>. By computational uniqueness of the commitment scheme, for <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda)</span> and <span class="math">\\mathsf{x}\\leftarrow\\mathcal{A}_{1}^{\\mathcal{H}^{\\prime}}(\\mathsf{pp})</span> either <span class="math">\\delta^{\\prime}(\\mathsf{x})</span> or <span class="math">\\epsilon(\\mathsf{x})</span> is negligible in <span class="math">\\lambda</span>, as we have shown that it is possible to construct and adversary using <span class="math">\\mathcal{A}_{1}</span> and <span class="math">\\mathcal{A}_{2}</span> that on input <span class="math">\\mathsf{pp}</span> breaks the uniqueness of the commitment scheme (Definition 19) in expected time <span class="math">(\\frac{1}{\\epsilon(\\mathsf{x})}+\\frac{1}{\\delta^{\\prime}(\\mathsf{x})})\\cdot\\mathsf{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300">We draw two conclusions from this. For <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda)</span> and <span class="math">\\mathsf{x}\\leftarrow\\mathcal{A}_{1}^{\\mathcal{H}^{\\prime}}(\\mathsf{pp})</span>, if <span class="math">\\mathcal{A}_{2}^{\\mathcal{H}}(\\mathsf{pp},\\mathsf{x})</span> succeeds in returning <span class="math">w</span> satisfying the aforementioned event (i.e., all criteria except the last predicate) with non-negligible probability then there is a unique vector <span class="math">(C_{1},...,C_{\\mu})</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{P}[T_{\\mathcal{H}}(\\mathsf{x})=(C_{1},...,C_{\\mu})]\\geq 1-\\mathsf{negl}(\\lambda)</span></li>

      <li>While this unique vector of high support may depend on <span class="math">\\mathcal{H}</span>, for all <span class="math">i\\in[\\mu]</span> the first <span class="math">i</span> components <span class="math">(C_{1},...,C_{i})</span> are independent of the answers to the values <span class="math">\\mathcal{H}(q)</span> for <span class="math">q\\in\\{(C,C_{1},...,C_{j})\\}_{i\\leq j&lt;\\mu}</span>.</li>

    </ol>

    <p class="text-gray-300">If (a) were false then running the experiment above for case <span class="math">i=\\mu</span> would succeed with non-negligible probability <span class="math">\\delta^{\\prime}</span> in returning a distinct assignment to <span class="math">\\mathcal{T}_{\\mathcal{H}}(\\mathsf{x})</span>, which contradicts the computational uniqueness of the commitment scheme as shown above. If (b) were false, then for some <span class="math">i&lt;\\mu</span> the experiment would succeed with non-negligible probability <span class="math">\\delta^{\\prime}</span> in returning a distinct assignment to <span class="math">\\mathcal{T}_{\\mathcal{H}}(\\mathsf{x})</span> where the first index of distinction is <span class="math">k\\leq i</span>, again contradicting the computational uniqueness of the commitment scheme as shown above.</p>

    <p class="text-gray-300">Finally, (b) implies that <span class="math">(\\alpha_{1},...,\\alpha_{\\mu})</span> where <span class="math">\\alpha_{i}=\\mathcal{H}(C,C_{1},...,C_{i})</span> is uniformly distributed and hence <span class="math">\\mathbb{P}[\\rho(m,m_{\\mu},\\alpha_{1},...,\\alpha_{\\mu})=1]\\leq\\delta</span> as stated in the hypothesis. Thus, conditioned on the event that <span class="math">w</span> satisfies at least all validity criteria except the predicate, then its first component is <span class="math">\\mathsf{tr}=(C_{1},...,C_{\\mu})</span> with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>, in which case it fails the last criteria (i.e., the predicate) with probability <span class="math">1-\\delta</span>. In conclusion, by a union bound it satisfies all criteria with probability at most <span class="math">\\delta+\\mathsf{negl}(\\lambda)</span>. ∎</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Theorem 6 (Fiat Shamir for AMSS protocols with unique commitments).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi</span> is a <span class="math">(k^{(\\mu)},\\delta,\\mathsf{com},\\phi)</span>-almost-special-sound protocol for a relation <span class="math">\\mathcal{R}</span> and a computationally-unique commitment scheme <span class="math">\\mathsf{com}</span> (Definition 19) whose setup runs <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{com}\\text{.}\\mathsf{Setup}(\\lambda)</span> then its FS transform <span class="math">\\Pi_{FS}</span> is an argument of knowledge for <span class="math">\\mathcal{R}</span> in the RO model (Definition 16) with knowledge error:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{err}(\\lambda,Q)=\\frac{(Q+1)\\kappa}{1-\\kappa}+2\\lambda(k^{\\mu}+Q\\cdot(k^{\\mu}-1))\\cdot\\delta+\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa=1-(1-\\frac{k}{\\delta^{1}})^{\\mu}</span>.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{V}^{\\mathcal{H}}</span> denote the resulting verifier for <span class="math">\\Pi_{FS}</span>. We will construct an extractor <span class="math">\\mathcal{E}</span> which is given black-box access to any deterministic <span class="math">Q</span>-query prover algorithm <span class="math">\\mathcal{P}^{<em>}</span>, where <span class="math">Q</span> is assumed to be polynomial in <span class="math">\\lambda</span>. <span class="math">\\mathcal{E}</span> has the power to intercept and respond to the queries <span class="math">\\mathcal{P}^{</em>}</span> makes to the random oracle, simulating (i.e., reprogramming) the oracle responses. On input <span class="math">x</span> and parameters <span class="math">\\mathsf{pp}</span>, <span class="math">\\mathcal{E}</span> first tests that <span class="math">\\mathcal{P}^{<em>}</span> outputs a proof <span class="math">\\pi</span> such that <span class="math">\\mathcal{V}^{\\mathcal{H}}(\\mathsf{pp},x,\\pi)=1</span> and otherwise aborts. If this first step succeeds, then <span class="math">\\mathcal{E}</span> continues by running the tree generation algorithm from Lemma 13 to generate a <span class="math">(k+1)</span>-ary forking transcript tree. Given black-box access to a deterministic <span class="math">Q</span>-query prover algorithm, this tree generation algorithm runs in expected polynomial time <span class="math">k^{\\mu}+Q\\cdot(k^{\\mu}-1)</span> succeeding with probability <span class="math">\\frac{\\epsilon(x)-(Q+1)\\cdot\\kappa}{(1-\\kappa)}</span> where <span class="math">\\kappa=1-(1-\\frac{k}{\\delta^{1}})^{\\mu}</span> and <span class="math">\\epsilon(x)</span> is the probability over the randomness of <span class="math">\\mathcal{H}</span> that <span class="math">\\mathcal{P}^{</em>}</span> outputs a non-interactive proof that <span class="math">\\mathcal{V}^{\\mathcal{H}}</span> accepts. <span class="math">\\mathcal{E}</span> will repeat <span class="math">\\lambda</span> iterations of running this tree generation algorithm for <span class="math">2(k^{\\mu}+Q\\cdot(k^{\\mu}-1))</span> steps each time, and returns the first trial that succeeds. By Markov, this results in a new tree generation algorithm that runs in strict polynomial time <span class="math">2\\lambda(k^{\\mu}+Q\\cdot(k^{\\mu}-1))</span> with negligible loss <span class="math">2^{-\\lambda}</span> in its probability of success.</p>

    <p class="text-gray-300">For any <span class="math">(k + 1)</span>-ary transcript tree, there is a polynomial time procedure (Definition 12) which as shown in Lemma 12 either:</p>

    <p class="text-gray-300">(a) Extracts a witness <span class="math">w</span> such that <span class="math">(x, w) \\in \\mathcal{R}</span> (b) Extracts a break to the binding of the commitment scheme, i.e. an element of <span class="math">\\mathcal{L}_{\\mathrm{break}}(\\mathsf{pp})</span> defined in Theorem 4. (c) Extracts an opening <span class="math">(m_{\\omega}, \\alpha_{\\omega})</span> for the commitment label on some node <span class="math">\\omega</span> at some level <span class="math">i</span> with rightmost child <span class="math">\\nu</span> at level <span class="math">i + 1</span> such that <span class="math">\\phi_{b}(i, m_{\\omega}) = 1</span>, <span class="math">\\phi_{a}(i, m_{\\omega}) = 0</span>, openings of all commitment labels on the leftmost path <span class="math">\\mathsf{path}(\\nu)</span> extending down from <span class="math">\\nu</span> to messages equal to <span class="math">\\mathsf{Extend}(i, m, \\alpha_{i}, \\dots, \\alpha_{\\mu}) = (m_{i}, \\dots, m_{\\mu})</span> where <span class="math">(\\alpha_{i}, \\dots, \\alpha_{\\mu})</span> are the verifier challenges along this path such that <span class="math">\\forall_{j \\geq i} \\phi_{a}(j, m_{j}) = 1</span>.</p>

    <p class="text-gray-300">The third extraction event was ruled out (with overwhelming probability) from any transcript tree generated via the Path Predicate Forking Lemma, see Theorem 4 and Lemma 3. In particular, the transcript tree generated there was shown to satisfy a predicate (with overwhelming probability) that eliminates the possibility that <span class="math">\\phi_{a}(i,m_{\\omega}) = 0</span> yet <span class="math">\\phi_{a}(\\mu ,m_{\\mu}) = 1</span>. The analysis leveraged the way that transcripts are sampled by that tree generation algorithm. However, we will need to use a slightly different analysis this time.</p>

    <p class="text-gray-300">First, we define the relation for all <span class="math">i \\in [\\mu]</span>, commitment scheme parameters <span class="math">\\mathsf{pp}</span>, and random oracle <span class="math">\\mathcal{H}^*</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {e x t}} ^ {\\mathcal {H} ^ {*}} (\\mathsf {p p}, \\mu - i) = \\left\\{ \\begin{array}{c} \\mathsf {t r} = (\\mathsf {x}, C _ {1}, \\dots , C _ {\\mu - i}) \\\\ \\forall_ {j \\in [ \\mu - i ]} \\alpha_ {j} = \\mathcal {H} ^ {*} (C, C _ {1}, \\dots , C _ {j - 1}) \\\\ M = ((m _ {1}, o _ {1}), \\dots , (m _ {\\mu - i}, o _ {\\mu - i})) \\\\ \\forall_ {j \\in [ \\mu - i ]} \\mathsf {c o m . O p e n} (\\mathsf {p p}, C _ {j}, m _ {j}, o _ {j}) = 1 \\\\ \\mathsf {E x t e n d} (i, m, \\alpha_ {1}, \\dots , \\alpha_ {\\mu - i}) = (m _ {1}, \\dots , m _ {\\mu - i}) \\\\ \\phi_ {b} (i, m) = 1, \\phi_ {a} (i, m) = 0, \\phi_ {a} (\\mu , m _ {\\mu - i}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">We note that by Lemma 13, in case (c) occurs, there is a <span class="math">(Q + \\mu)</span>-query polynomial time algorithm <span class="math">\\mathcal{A}_1</span> that generates <span class="math">(C,m,o)</span> and transcript prefix <span class="math">\\mathbf{y}</span>, and an independent <span class="math">(Q + \\mu)</span>-query adversary <span class="math">\\mathcal{A}_2^{\\mathcal{H}^<em>}</span> which generates the witness <span class="math">(\\mathbf{tr},M)</span> such that <span class="math">((C,m,o),(\\mathbf{tr},M))\\in \\mathcal{R}_{\\mathrm{ext}}^{\\mathcal{H}_2^</em>}(\\mathsf{pp},\\mu -i)</span> for some <span class="math">i</span>. <span class="math">\\mathcal{A}_1</span> represents the algorithm that ran the partial tree generation that created all labels on the left <span class="math">k</span>-ary subtree of <span class="math">\\omega</span> and also the prefix <span class="math">\\mathbf{y}</span> labeling the trunk (i.e., from root to <span class="math">\\omega</span>) of subtree <span class="math">S_{\\nu}</span>, and then also ran the tree extraction algorithm (Definition 12) on this left <span class="math">k</span>-ary subtree of <span class="math">\\omega</span>. Note that conditioned on event (c), <span class="math">\\omega</span> is the first node and index <span class="math">i</span> for which this tree extraction succeeds in producing an opening <span class="math">(m_{\\omega},o_{\\omega})</span> such that <span class="math">\\phi_b(i,m_\\omega) = 1</span> but <span class="math">\\phi_a(i,m_\\omega) = 0</span>. By Lemma 13 the root-to-leaf path that includes the prefix <span class="math">\\mathbf{y}</span> and <span class="math">\\mathsf{path}(\\nu)</span> matches the output of some <span class="math">\\mathcal{A}_2^{\\mathcal{H}^<em>}(x)</span> with partially fresh random oracle <span class="math">\\mathcal{H}^</em></span>, and there is also a subtree generation algorithm that is a <span class="math">(Q + \\mu)</span>-query algorithm which generated the labels on subtree <span class="math">S_{\\nu}</span>. <span class="math">\\mathcal{A}_2^{\\mathcal{H}^*}</span> represents the combination of these two algorithms and also the subtree extractor that opens the commitments on these labels. Conditioned on <span class="math">(c)</span>, the openings of the commitment labels within this subtree all satisfy predicate <span class="math">\\phi_a</span> and the opened messages of the commitment labels <span class="math">\\mathsf{path}(\\nu)_0</span> along the leftmost path from <span class="math">\\nu</span> match the output of <span class="math">\\mathsf{Extend}(i,m,\\mathsf{path}(\\nu)_1)</span> where <span class="math">\\mathsf{path}(\\nu)_1</span> are the challenge labels along this path.</p>

    <p class="text-gray-300">Let <span class="math">\\rho_{i}</span> denote the predicate such that <span class="math">\\rho_{i}(m,m^{\\prime},\\alpha_{1},\\dots,\\alpha_{\\mu -i}) = 1</span> iff <span class="math">\\phi_b(i,m) = 1</span>, <span class="math">\\phi_a(i,m) = 0</span>, and <span class="math">\\phi_a(\\mu ,m&#x27;) = 1</span>. By the definition of <span class="math">(k^{(\\mu)},\\delta ,\\mathsf{com},\\phi)</span>-almost-special-soundness, for uniform random <span class="math">\\beta_{1},\\ldots ,\\beta_{\\mu -i}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {\\beta_ {1}, \\dots , \\beta_ {\\mu - i}} [ \\rho (m, m _ {\\mu - i}, \\beta_ {1}, \\dots , \\beta_ {\\mu - i}) = 1: \\operatorname {E x t e n d} (i, m, \\beta_ {1}, \\dots , \\beta_ {\\mu - i}) = (m _ {1}, \\dots , m _ {\\mu - i}) ] \\leq \\delta</span></div>

    <p class="text-gray-300">Thus, since <span class="math">Q + \\mu</span> is polynomial in <span class="math">\\lambda</span>, by Lemma 15 the relation <span class="math">\\mathcal{R}_{\\mathrm{ext}}^{\\mathcal{H}^*}(\\mathsf{pp},\\mu -i)</span> is <span class="math">(Q + \\mu ,\\delta +\\mathsf{negl}(\\lambda))</span>-hard in the RO model for <span class="math">Q = \\mathsf{poly}(\\lambda)</span>. This shows that for any particular index in the transcript tree, the event of type (c) occurs with probability at most <span class="math">\\delta +\\mathsf{negl}(\\lambda)</span> when running the extractor with polynomial time provers making a polynomial number of queries to the RO. This experiment may effectively occur times over the course of the tree generation algorithm, but we can loosely union bound the probability that event (c) ever occurs by the runtime of the tree generation algorithm. Similarly, we can eliminate event (b) as occurring with <span class="math">\\mathsf{negl}(\\lambda)</span> by the computational binding property of the commitment scheme, which does not require an additional union bound.</p>

    <p class="text-gray-300">Finally, letting <span class="math">\\epsilon(x, \\mathsf{st})</span> denote the probability over the parameters and random oracle that the verifier accepts the proof <span class="math">\\pi</span> output by <span class="math">P^{*}(\\mathsf{st})</span> for public input <span class="math">x</span>, we conclude that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} \\left[ \\begin{array}{c c} (x, w) \\in \\mathcal {R} a n d &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ \\mathcal {V} ^ {N} (\\mathsf {p p}, x, \\pi) = 1: &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; \\pi \\leftarrow P ^ {*} (\\mathsf {s t}) \\\\ &amp;amp; w \\leftarrow \\mathcal {E} ^ {P ^ {*} (\\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right] = \\mathbb {P} \\left[ \\begin{array}{c c} (x, w) \\in \\mathcal {R}: &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; \\pi \\leftarrow P ^ {*} (\\mathsf {s t}) \\\\ &amp;amp; w \\leftarrow \\mathcal {E} ^ {P ^ {*} (\\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\sum_ {x, \\mathfrak {s t}} \\left(\\frac {\\epsilon (x , \\mathfrak {s t}) - (Q + 1) \\kappa}{1 - \\kappa} - 2 \\lambda (k ^ {\\rho} + Q \\cdot (k ^ {\\rho} - 1)) \\cdot \\delta - \\mathsf {n e g l} (\\lambda)\\right) \\cdot \\mathbb {P} [ \\mathcal {A} (\\mathsf {p p}) = (x, \\mathfrak {s t}): \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) ]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\mathbb {P} \\left[ \\begin{array}{c c} \\mathcal {V} ^ {N} (\\mathsf {p p}, x, \\pi) = 1: &amp;amp; \\underset {\\pi \\leftarrow P ^ {*} (\\mathsf {s t})} {\\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda)} - \\frac {(Q + 1) \\kappa}{1 - \\kappa} - 2 \\lambda (k ^ {\\rho} + Q \\cdot (k ^ {\\rho} - 1)) \\cdot \\delta - \\mathsf {n e g l} (\\lambda) \\end{array} \\right]</span></div>

    <p class="text-gray-300">The first equality holds because  <span class="math">\\mathcal{E}^{\\mathcal{P}^<em>(\\mathsf{st})}(\\mathsf{pp}, x)</span>  aborts in its first step if the deterministic  <span class="math">\\mathcal{P}^</em>(\\mathsf{st})</span>  outputs  <span class="math">\\pi</span>  such that  <span class="math">\\mathcal{V}^N(\\mathsf{pp}, x, \\pi) \\neq 1</span> .</p>`;
---

<BaseLayout title="Multilinear Schwartz-Zippel mod N with Applications to Succi... (2022/458)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/458
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
