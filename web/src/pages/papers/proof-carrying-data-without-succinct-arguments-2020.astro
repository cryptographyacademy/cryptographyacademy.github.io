---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1618';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proof-Carrying Data without Succinct Arguments';
const AUTHORS_HTML = 'Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, Nicholas Spooner';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz benedikt@cs.stanford.edu Stanford University Alessandro Chiesa alexch@berkeley.edu UC Berkeley William Lin will.lin@berkeley.edu UC Berkeley Pratyush Mishra pratyush@berkeley.edu UC Berkeley Nicholas Spooner nspooner@bu.edu Boston University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Proof-carrying data (PCD) is a powerful cryptographic primitive that enables mutually distrustful parties to perform distributed computations that run indefinitely. Known approaches to construct PCD are based on succinct non-interactive arguments of knowledge (SNARKs) that have a succinct verifier or a succinct accumulation scheme.</p>

    <p class="text-gray-300">In this paper we show how to obtain PCD without relying on SNARKs. We construct a PCD scheme given any non-interactive argument of knowledge (e.g., with linear-size arguments) that has a <em>split accumulation scheme</em>, which is a weak form of accumulation that we introduce.</p>

    <p class="text-gray-300">Moreover, we construct a transparent non-interactive argument of knowledge for R1CS whose split accumulation is verifiable via a (small) <em>constant number of group and field operations</em>. Our construction is proved secure in the random oracle model based on the hardness of discrete logarithms, and it leads, via the random oracle heuristic and our result above, to concrete efficiency improvements for PCD.</p>

    <p class="text-gray-300">Along the way, we construct a split accumulation scheme for Hadamard products under Pedersen commitments and for a simple polynomial commitment scheme based on Pedersen commitments.</p>

    <p class="text-gray-300">Our results are supported by a modular and efficient implementation.</p>

    <p class="text-gray-300">Keywords: proof-carrying data; accumulation schemes; recursive proof composition</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Contributions  3</p>

    <p class="text-gray-300">2  Techniques  8 2.1 Accumulation: atomic vs split  8 2.2 PCD from split accumulation  10 2.3 NARK with split accumulation based on DL  12 2.4 On proving knowledge soundness  15 2.5 Split accumulation for Hadamard products  17 2.6 Split accumulation for Pedersen polynomial commitments  19 2.7 Implementation and evaluation  22</p>

    <p class="text-gray-300">3  Preliminaries  25 3.1 Non-interactive arguments in the ROM  25 3.2 Proof-carrying data  26 3.3 Instantiating the random oracle  27 3.4 Post-quantum security  27 3.5 Commitment schemes  28</p>

    <p class="text-gray-300">4  Split accumulation schemes for relations  29 4.1 Special case: accumulators and predicate inputs are identical  30 4.2 A relaxation of knowledge soundness  31</p>

    <p class="text-gray-300">5  PCD from arguments of knowledge with split accumulation  33 5.1 Construction  34 5.2 Completeness  35 5.3 Knowledge soundness  35 5.4 Zero knowledge  38 5.5 Efficiency  38 5.6 Post-quantum security  39</p>

    <p class="text-gray-300">6  An expected-time forking lemma  40 6.1 Notation for oracle algorithms  40 6.2 An expected-time forking lemma  40</p>

    <p class="text-gray-300">7  Split accumulation for Hadamard products  43 7.1 Construction  43 7.2 Proof of Theorem 7.2  45</p>

    <p class="text-gray-300">8  Split accumulation for R1CS  50 8.1 zkNARK for R1CS  50 8.2 Split accumulation for the zkNARK verifier  51 8.3 Security proofs  53</p>

    <p class="text-gray-300">9  Implementation  60</p>

    <p class="text-gray-300">10 Evaluation  62 10.1 Split accumulation for R1CS  62 10.2 Accumulation for polynomial commitments based on DL  63</p>

    <p class="text-gray-300">A  Split accumulation for Pedersen polynomial commitments  65 A.1 Construction  65 A.2 Zero-finding games  66 A.3 Proof of Theorem A.2  67</p>

    <p class="text-gray-300">Acknowledgements  70</p>

    <p class="text-gray-300">References  70</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300"><em>Proof-carrying data</em> (PCD) <em>[x10]</em> is a powerful cryptographic primitive that enables mutually distrustful parties to perform distributed computations that run indefinitely, while ensuring that the correctness of every intermediate state of the computation can be verified efficiently. A special case of PCD is <em>incrementally-verifiable computation</em> (IVC) <em>[x23]</em>. PCD has found applications in enforcing language semantics <em>[x11]</em>, verifiable MapReduce computations <em>[x12]</em>, image authentication <em>[x20]</em>, blockchains <em>[x18, x5, x4]</em>, and others. Given the theoretical and practical relevance of PCD, it is an important research question to build efficient PCD schemes from minimal cryptographic assumptions.</p>

    <p class="text-gray-300">PCD from succinct verification. The canonical construction of PCD is via <em>recursive composition</em> of succinct non-interactive arguments (SNARGs) <em>[x3, x2, x7]</em>. Informally, a proof that the computation was executed correctly for <span class="math">t</span> steps consists of a proof of the claim “the <span class="math">t</span>-th step of the computation was executed correctly, and there exists a proof that the computation was executed correctly for <span class="math">t-1</span> steps”. The latter part of the claim is expressed using the SNARG verifier itself. This construction yields secure PCD (with IVC as a special case) provided the SNARG satisfies an adaptive knowledge soundness property (i.e., is a SNARK). Efficiency requires the SNARK to have sublinear-time verification, achievable via SNARKs for machine computations <em>[x3]</em> or preprocessing SNARKs for circuit computations <em>[x2, x7]</em>.</p>

    <p class="text-gray-300">Requiring sublinear-time verification, however, significantly restricts the choice of SNARK, which limits what is achievable for PCD. These restrictions have practical implications: the concrete efficiency of recursion is limited by the use of expensive curves for pairing-based SNARKs <em>[x2]</em> or heavy use of cryptographic hash functions for hash-based SNARKs <em>[x7]</em>.</p>

    <p class="text-gray-300">PCD from accumulation. Recently, <em>[x4]</em> gave an alternative construction of PCD using SNARKs that have succinct <em>accumulation schemes</em>; this developed and formalized a novel approach for recursion sketched in <em>[x6]</em>. Informally, rather than being required to have sublinear-time verification, the SNARK is required to be accompanied by a cryptographic primitive that enables “postponing” the verification of SNARK proofs by way of an accumulator that is updated at each recursion step. The main efficiency requirement on the accumulation scheme is that the accumulation procedure must be succinctly verifiable, and in particular the accumulator itself must be succinct.</p>

    <p class="text-gray-300">Requiring a SNARK to have a succinct accumulation scheme is a weaker condition than requiring it to have sublinear-time verification. This has enabled constructing PCD from SNARKs that do <em>not</em> have sublinear-time verification <em>[x4]</em>, which in turn led to PCD constructions from assumptions and with efficiency properties that were not previously achieved. Practitioners have exploited this freedom to design implementations of recursive composition with improved practical efficiency <em>[x13, x16]</em>.</p>

    <p class="text-gray-300">Our motivation. The motivation of this paper is twofold. First, can PCD be built from a weaker primitive than SNARKs with succinct accumulation schemes? If so, can we leverage this to obtain PCD constructions with improved <em>concrete</em> efficiency?</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Contributions</h3>

    <p class="text-gray-300">We make theory and systems contributions that advance the state of the art for PCD: (1) We introduce <em>split accumulation schemes for relations</em>, a cryptographic primitive that relaxes prior notions of accumulation. (2) We obtain PCD from any non-interactive argument of knowledge that satisfies this weaker notion of accumulation; surprisingly, this allows for arguments with no succinctness whatsoever. (3) We construct a non-interactive argument of knowledge based on discrete logarithms (and random oracles) whose accumulation verifier has constant size (improving over the logarithmic-size verifier of prior accumulation schemes in this</p>

    <p class="text-gray-300">setting). (4) We implement and evaluate constructions from this paper and from <em>[x1]</em>.</p>

    <p class="text-gray-300">We elaborate on each of these contributions next.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">(1) Split accumulation for relations.</h4>

    <p class="text-gray-300">Recall from <em>[x1]</em> that an accumulation scheme for a predicate <span class="math">\\Phi\\colon X\\to\\{0,1\\}</span> enables proving/verifying that each input in an infinite stream <span class="math">\\mathsf{q}_{1},\\mathsf{q}_{2},\\ldots</span> satisfies the predicate <span class="math">\\Phi</span>, by augmenting the stream with <em>accumulators</em>. Informally, for each <span class="math">i</span>, the prover produces a new accumulator <span class="math">\\mathsf{acc}_{i+1}</span> from the input <span class="math">\\mathsf{q}_{i}</span> and the old accumulator <span class="math">\\mathsf{acc}_{i}</span>; the verifier can check that the triple <span class="math">(\\mathsf{q}_{i},\\mathsf{acc}_{i},\\mathsf{acc}_{i+1})</span> is a valid accumulation step, much more efficiently than running <span class="math">\\Phi</span> on <span class="math">\\mathsf{q}_{i}</span>. At any time, the decider can validate <span class="math">\\mathsf{acc}_{i+1}</span>, which establishes that for all <span class="math">j\\leq i</span> it was the case that <span class="math">\\Phi(\\mathsf{q}_{j})=1</span>. The accumulator size (and hence the running time of the three algorithms) cannot grow in the number of accumulation steps.</p>

    <p class="text-gray-300">We extend this notion in two orthogonal ways. First we consider relations <span class="math">\\Phi\\colon X\\times W\\to\\{0,1\\}</span> and now for a stream of instances <span class="math">\\mathsf{qx}_{1},\\mathsf{qx}_{2},\\ldots</span> the goal is to establish that there exist witnesses <span class="math">\\mathsf{qw}_{1},\\mathsf{qw}_{2},\\ldots</span> such that <span class="math">\\Phi(\\mathsf{qx}_{i},\\mathsf{qw}_{i})=1</span> for each <span class="math">i</span>. Second, we consider accumulators <span class="math">\\mathsf{acc}_{i}</span> that are split into an instance part <span class="math">\\mathsf{acc}_{i}.\\mathtt{x}</span> and a witness part <span class="math">\\mathsf{acc}_{i}.\\mathtt{w}</span> with the restriction that the accumulation verifier only gets to see the instance part (and possibly an auxiliary accumulation proof <span class="math">\\mathsf{pf}</span>). We refer to this notion as <em>split accumulation for relations</em>, and refer to (for contrast) the notion from <em>[x1]</em> as <em>atomic accumulation for languages</em>.</p>

    <p class="text-gray-300">The purpose of these extensions is to enable us to consider accumulation schemes in which predicate witnesses and accumulator witnesses are large while still requiring the accumulation verifier to be succinct (it receives short predicate instances and accumulator instances but not large witnesses). We will see that such accumulation schemes are both simpler and cheaper, while still being useful for primitives such as PCD.</p>

    <p class="text-gray-300">See Section 2.1 for more on atomic vs. split accumulation, and Section 4 for formal definitions.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">(2) PCD via split accumulation.</h4>

    <p class="text-gray-300">A non-interactive argument has a split accumulation scheme if the relation corresponding to its verifier has a split accumulation scheme (we make this precise later). We show that any non-interactive argument of knowledge (NARK) having a split accumulation scheme where the <em>accumulation verifier</em> is sublinear can be used to build a proof-carrying data (PCD) scheme, <em>even if the NARK does not have sublinear argument size</em>. This significantly broadens the class of non-interactive arguments from which PCD can be built, and is the first result to obtain PCD from non-interactive arguments that need not be succinct. Similarly to <em>[x1]</em>, if the NARK and accumulation scheme are post-quantum secure, so is the PCD scheme. (It remains an open question whether there are non-trivial post-quantum instantiations of these.)</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">There is an efficient transformation that compiles any NARK with a split accumulation scheme into a PCD scheme. If the NARK and its split accumulation scheme are zero knowledge, then the PCD scheme is also zero knowledge. Additionally, if the NARK and its accumulation scheme are post-quantum secure then the PCD scheme is also post-quantum secure.</p>

    <p class="text-gray-300">Similarly to all PCD results known to date, the above theorem holds in a model where all parties have access to a common reference string, <em>but no oracles</em>. (The construction makes non-black-box use of the accumulation scheme verifier, and the theorem does not carry over to the random oracle model.)</p>

    <p class="text-gray-300">A corollary of Theorem 1 is that any NARK with a split accumulation scheme can be “bootstrapped” into a SNARK for machine computations. (PCD implies IVC and, further assuming collision-resistant hashing, also efficient SNARKs for machine computations <em>[x2]</em>.) This is surprising: an argument with decidedly weak efficiency properties implies an argument with succinct proofs and succinct verification!</p>

    <p class="text-gray-300">See Section 2.2 for a summary of the ideas behind Theorem 1, and Section 5 for technical details.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">(3) NARK with split accumulation based on DL.</h4>

    <p class="text-gray-300">Theorem 1 motivates the question of whether we can leverage the weaker condition on the argument system to improve the efficiency of PCD. Our focus is on minimizing the cost of the accumulation verifier for the argument system, because it is the only component</p>

    <p class="text-gray-300">that is not used as a black box, and thus typically determines concrete efficiency. Towards this end, we present a (zero knowledge) NARK with (zero knowledge) split accumulation based on discrete logarithms, with a constant-size accumulation verifier; the NARK has a transparent (public-coin) setup.</p>

    <p class="text-gray-300">Theorem 2 (informal). In the random oracle model and assuming the hardness of the discrete logarithm problem, there exists a transparent (zero knowledge) NARK for R1CS and a corresponding (zero knowledge) split accumulation scheme with the following efficiency:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NARK prover time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">varifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">argument size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">split accumulation scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">decider time</td>

            <td class="px-3 py-2 border-b border-gray-700">accumulator size</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">acc.x</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(1) G + O(1) F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F</td>

            <td class="px-3 py-2 border-b border-gray-700">acc.w</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(M) F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Above, M denotes the number of constraints in the R1CS instance,  <span class="math">\\mathbb{G}</span>  denotes group scalar multiplications or group elements, and  <span class="math">\\mathbb{F}</span>  denotes field operations or field elements.</p>

    <p class="text-gray-300">The NARK construction from Theorem 2 is particularly simple: it is obtained by applying the Fiat-Shamir transformation to a sigma protocol for R1CS based on Pedersen commitments (and linear argument size). The only "special" feature about the construction is that, as we prove, it has a very efficient split accumulation scheme for the relation corresponding to its verifier. By heuristically instantiating the random oracle, we can apply Theorem 1 (and [BCCT13]) to obtain a SNARK for machines from this modest starting point.</p>

    <p class="text-gray-300">We find it informative to compare Theorem 2 and SNARKs with atomic accumulation based on discrete logarithms [BCMS20]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the SNARK's argument size is  <span class="math">O(\\log \\mathsf{M})</span>  group elements, much less than the NARK's  <span class="math">O(\\mathsf{M})</span>  field elements;</li>

      <li>the SNARK's accumulator verifier uses  <span class="math">O(\\log \\mathsf{M})</span>  group scalar multiplications and field operations, much more than the NARK's  <span class="math">O(1)</span>  group scalar multiplications and field operations.</li>

    </ul>

    <p class="text-gray-300">Therefore Theorem 2 offers a tradeoff that minimizes the cost of the accumulator at the expense of argument size. (As we shall see later, this tradeoff has concrete efficiency advantages.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our focus on argument systems based on discrete logarithms is motivated by the fact that they can be instantiated based on efficient curves suitable for recursion: the Tweedle [BGH19] or Pasta [Hop20] curve cycles, which follow the curve cycle technique for efficient recursion [BCTV14]. (In fact, as our construction does not rely on any number-theoretic properties of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , we could even use the (secp256k1, secq256k1) cycle, where secp256k1 is the curve used in Bitcoin.) This focus on discrete logarithms is a choice made for this paper, and we believe that our ideas can lead to efficiency improvements to recursion in other settings (e.g., pairing-based and hash-based arguments) and leave these to future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See Section 2.3 for a summary of the ideas behind Theorem 1, and Section 8 for technical details.</p>

    <p class="text-gray-300">(4) Split accumulation for common predicates. We obtain split accumulation schemes with constant-size accumulation verifiers for common predicates: (i) Hadamard products (and more generally any bilinear function) under Pedersen commitments (see Section 2.5 for a summary and Section 7 for details); (ii) polynomial evaluations under Pedersen commitments (see Section 2.6 for a summary and Appendix A for technical details). Split accumulation for Hadamard products is a building block that we use to prove Theorem 1. (5) Implementation and evaluation. We contribute a set of Rust libraries that realize PCD via accumulation via modular combinations of interchangeable components: (a) generic interfaces for atomic and split accumulation; (b) generic construction of PCD from arguments with atomic and split accumulation; (c) split accumulation for our zkNARK for R1CS; (d) split accumulation for Hadamard products under Pedersen commitments; (e) split accumulation for polynomial evaluations under Pedersen commitments; (f) atomic accumulation for polynomial commitments based on inner product arguments and pairings from [BCMS20];</p>

    <p class="text-gray-300">(g) constraints for all the foregoing accumulation verifiers. Practitioners interested in PCD will find these libraries useful for prototyping and comparing different types of recursion (and, e.g., may help decide if current systems based on atomic recursion <em>[x11, Pickles20]</em> are better off via split recursion or not).</p>

    <p class="text-gray-300">We additionally conduct experiments to evaluate our implementation. Our experiments focus on determining the <em>recursion threshold</em>, which informally is the number of constraints that need to be proved at each step of the recursion. Our evaluation demonstrates that, over curves from the popular “Pasta” cycle <em>[x12]</em>, the recursion threshold for split accumulation of our NARK for R1CS is as low as <span class="math">52{,}000</span> constraints, which is at least <span class="math">8.5\\times</span> cheaper than the cost of IVC constructed from atomic accumulation for discrete-logarithm-based protocols <em>[x3]</em>. In fact, the recursion threshold is even lower than that for IVC constructed from prior state-of-the-art pairing-friendly SNARKs <em>[x16]</em>. While this comes at the expense of much larger proof sizes, this overhead is attractive for notable applications (e.g., incrementally-verifiable ledgers).</p>

    <p class="text-gray-300">See Section 9 and Section 10 for more details on our implementation and evaluation, respectively.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Remark 1.1 (concurrent work).</h6>

    <p class="text-gray-300">A concurrent work <em>[x2]</em> studies similar questions as this paper. Below we summarize the similarities and the differences between the two papers.</p>

    <p class="text-gray-300"><em>Similarities.</em> Both papers are study by the goal of reducing the cost of recursive arguments. The main object of study in <em>[x2]</em> is additive polynomial commitment schemes (PC schemes), for which <em>[x2]</em> considers different types of <em>aggregation schemes</em>: (1) <em>public</em> aggregation in <em>[x2]</em> is closely related to atomic accumulation specialized to PC schemes from a prior work <em>[x3]</em>; and (2) <em>private</em> aggregation in <em>[x2]</em> is closely related to split accumulation specialized to PC schemes from this paper. Moreover, the private aggregation scheme for additive PC schemes in <em>[x2]</em> is similar to our split accumulation scheme for Pedersen PC schemes (overviewed in Section 2.6 and detailed in Appendix A). The protocols differ in how efficiency depends on the <span class="math">n</span> claims to aggregate/accumulate: the verifier in <em>[x2]</em> uses <span class="math">n+1</span> group scalar multiplications while ours uses <span class="math">2n</span>. (Informally, <em>[x2]</em> first randomly combines claims and then evaluates at a random point, while we first evaluate at a random point and then randomly combine claims.)</p>

    <p class="text-gray-300"><em>Differences.</em> The two papers develop distinct, and complementary, directions.</p>

    <p class="text-gray-300">The focus of <em>[x2]</em> is to design protocols for any additive PC scheme (and, even more generally, any PC scheme with a linear combination scheme), including the aforementioned private aggregation protocol and a compiler that endows a given PC scheme with zero knowledge.</p>

    <p class="text-gray-300">In contrast, our focus is to formulate a definition of split accumulation for general relation predicates that (a) we demonstrate suffices to construct PCD, and (b) in the random oracle model, we can also demonstrably achieve via a split accumulation scheme based on Pedersen commitments. We emphasize that our definitions are materially different from the case of atomic accumulation in <em>[x3]</em>, and necessitate careful consideration of technicalities such as the flavor of adaptive knowledge soundness, which algorithms can be allowed to query oracles, and so on. Hence, we cannot simply rely on the existing foundations for atomic accumulation of <em>[x3]</em> in order to infer the correct definitions and security reductions for split accumulation. Overall, our theoretical work enables us to achieve the first construction of PCD without succinct arguments, and also to obtain a novel NARK for R1CS with a constant-size accumulation verifier.</p>

    <p class="text-gray-300">We stress that the treatment of accumulation at a higher level of abstraction than for PC schemes is essential to prove theorems about PCD. In particular, contrary to what is claimed as a theorem in <em>[x2]</em>, it is <em>not</em> known how to build PCD from a PC scheme with an aggregation/accumulation scheme in any model without making additional heuristic assumptions. This is because obtaining a NARK from a PC scheme using known techniques requires the use of a random oracle, which we do not know how to accumulate. In contrast, we construct PCD in the standard model starting directly from an aggregation/accumulation scheme <em>for a NARK</em>, and <em>no additional assumptions</em>. Separately, the security of our accumulation scheme for a NARK in the standard model <em>is</em> an assumption, which is conjectured based on a security proof in the ROM.</p>

    <p class="text-gray-300">Another major difference is that we additionally contribute a comprehensive and modular implementation of protocols from <em>[x1]</em> and this paper, and conduct an evaluation for the discrete logarithm setting. This supports the asymptotic improvements with measured improvements in concrete efficiency.</p>

    <p class="text-gray-300">We summarize the main ideas behind our results. In Section 2.1 we discuss our new notion of split accumulation for relation predicates, and compare it with the notion of atomic accumulation for language predicates from [BCMS20]. In Section 2.2 we discuss the proof of Theorem 1. In Section 2.3 we discuss the proof of Theorem 2; for this we rely on a new result about split accumulation for Hadamard products, which we discuss in Section 2.5. Then, in Section 2.6, we discuss our split accumulation for a Pedersen-based polynomial commitment, which can act as a drop-in replacement for polynomial commitments used in prior SNARKs, such as those of [BGH19]. Finally, in Section 2.7 we elaborate on our implementation and evaluation. Figure 1 illustrates the relation between our results. The rest of the paper contains technical details, and we provide pointers to relevant sections along the way.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Diagram showing the relation between our results. Gray boxes within a result are notable subroutines.</p>

    <p class="text-gray-300">We review the notion of accumulation from [BCMS20], which we refer to as atomic accumulation, and then describe the weaker notion that we introduce, which we call split accumulation.</p>

    <p class="text-gray-300">Atomic accumulation for languages. An accumulation scheme for a language predicate  <span class="math">\\Phi \\colon X \\to \\{0,1\\}</span>  is a tuple of algorithms  <span class="math">(\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> , known as the prover, verifier, and decider, that enable proving/verifying statements of the form  <span class="math">\\Phi (\\mathfrak{q}_1)\\wedge \\Phi (\\mathfrak{q}_2)\\wedge \\dots</span>  more efficiently than running the predicate  <span class="math">\\Phi</span>  on each input.</p>

    <p class="text-gray-300">This is done as follows. Starting from an initial ("empty") accumulator  <span class="math">\\mathsf{acc}_1</span> , the prover is used to accumulate the first input  <span class="math">\\mathfrak{q}_1</span>  to produce a new accumulator  <span class="math">\\mathsf{acc}_2 \\gets \\mathrm{P}(\\mathfrak{q}_1, \\mathsf{acc}_1)</span> ; then the prover is used again to accumulate the second input  <span class="math">\\mathfrak{q}_2</span>  to produce a new accumulator  <span class="math">\\mathsf{acc}_3 \\gets \\mathrm{P}(\\mathfrak{q}_2, \\mathsf{acc}_2)</span> ; and so on.</p>

    <p class="text-gray-300">Each accumulator produced so far enables efficient verification of the predicate on all inputs that went into the accumulator. For example, to establish that  <span class="math">\\Phi (\\mathfrak{q}_1)\\wedge \\dots \\wedge \\Phi (\\mathfrak{q}_T) = 1</span>  it suffices to check that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the verifier accepts each accumulation step:  <span class="math">\\mathrm{V}(\\mathfrak{q}_1, \\mathrm{acc}_1, \\mathrm{acc}_2) = 1</span> ,  <span class="math">\\mathrm{V}(\\mathfrak{q}_2, \\mathrm{acc}_2, \\mathrm{acc}_3) = 1</span> , and so on; and</li>

      <li>the decider accepts the final accumulator:  <span class="math">\\mathrm{D}(\\mathrm{acc}_T) = 1</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Qualitatively, this replaces the naive cost  $T \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  with the new cost  </span>T \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . This is beneficial when the verifier is much cheaper than checking the predicate directly and the decider is not much costlier than checking the predicate directly. Crucially, the verifier and decider costs (and, in particular, the accumulator size) should not grow with the number  </span>T$  of accumulation steps (which need not be known in advance).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The properties of an accumulation scheme are summarized in the following informal definition, which additionally includes an accumulation proof used to check an accumulation step (but is not passed on).</p>

    <p class="text-gray-300">Definition 2.1 (informal). An accumulation scheme for a predicate  <span class="math">\\Phi \\colon X \\to \\{0,1\\}</span>  consists of a triple of algorithms  <span class="math">(\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> , known as the prover, verifier, and decider, that satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For every accumulator <span class="math">\\mathsf{acc}</span> and predicate input <span class="math">\\mathsf{q} \\in X</span>, if <span class="math">\\mathrm{D}(\\mathsf{acc}) = 1</span> and <span class="math">\\Phi(\\mathsf{q}) = 1</span>, then for <span class="math">(\\mathsf{acc}^{\\star}, \\mathsf{pf}^{\\star}) \\gets \\mathrm{P}(\\mathsf{acc}, \\mathsf{q})</span> it holds that <span class="math">\\mathrm{V}(\\mathsf{q}, \\mathsf{acc}, \\mathsf{acc}^{\\star}, \\mathsf{pf}^{\\star}) = 1</span> and <span class="math">\\mathrm{D}(\\mathsf{acc}^{\\star}) = 1</span>.</li>

      <li>Soundness: For every efficiently-generated old accumulator <span class="math">\\mathsf{acc}</span>, predicate input <span class="math">\\mathsf{q} \\in X</span>, new accumulator <span class="math">\\mathsf{acc}^{\\star}</span>, and accumulation proof <span class="math">\\mathsf{pf}^{\\star}</span>, if <span class="math">\\mathrm{D}(\\mathsf{acc}^{\\star}) = 1</span> and <span class="math">\\mathrm{V}(\\mathsf{q}, \\mathsf{acc}, \\mathsf{acc}^{\\star}, \\mathsf{pf}^{\\star}) = 1</span> then, with all but negligible probability, <span class="math">\\Phi(\\mathsf{q}) = 1</span> and <span class="math">\\mathrm{D}(\\mathsf{acc}) = 1</span>.</li>

    </ul>

    <p class="text-gray-300">The above definition omits many details, such as the ability to accumulate multiple accumulators <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> and multiple predicate inputs <span class="math">[\\mathfrak{q}_i]_{i=1}^n</span> in one step, the optional property of zero knowledge (enabled by the accumulation proof <span class="math">\\mathsf{pf}^{\\star}</span>), the fact that <span class="math">\\mathrm{P}, \\mathrm{V}, \\mathrm{D}</span> should receive keys <span class="math">\\mathsf{apk}, \\mathsf{avk}, \\mathsf{dk}</span> generated by an indexer algorithm that receives the specification of <span class="math">\\Phi</span>, and others. We refer the reader to [BCMS20] for more details.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The aspect that we wish to highlight here is the following: in order for the verifier to be much cheaper than the predicate $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> it must be that the accumulator itself is much smaller than the predicate </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{acc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> because the verifier receives the accumulator as input. (And if the accumulator is accompanied by a validity proof </span>\\mathsf{pf}$ then this proof must also be small.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We refer to this setting as atomic accumulation because the entirety of the accumulator is treated as one short monolithic string. In contrast, in this paper we consider a relaxation where this is not the case, and will enable us to obtain new instantiations that lead to new theoretical and practical results.</p>

    <p class="text-gray-300"><strong>Split accumulation for relations.</strong> We propose a relaxed notion of accumulation: a split accumulation scheme for a relation predicate <span class="math">\\Phi \\colon X \\times W \\to \\{0,1\\}</span> is again a tuple of algorithms <span class="math">(\\mathrm{P}, \\mathrm{V}, \\mathrm{D})</span> as before. Split accumulation differs from atomic accumulation in that: (a) an input to <span class="math">\\Phi</span> consists of a short instance part <span class="math">\\mathsf{qx}</span> and a (possibly) long witness part <span class="math">\\mathsf{qw}</span>; (b) an accumulator <span class="math">\\mathsf{acc}</span> is split into a short instance part <span class="math">\\mathsf{acc}.\\mathbf{x}</span> and a (possibly) long witness part <span class="math">\\mathsf{acc}.\\mathbf{w}</span>; (c) the verifier only needs the short parts of inputs and accumulators to verify an accumulation step, along with a short validity proof instead of the long witness parts.</p>

    <p class="text-gray-300">As before, the prover is used to accumulate a predicate input <span class="math">\\mathfrak{q}_i = (\\mathfrak{q}\\mathbf{x}_i,\\mathfrak{q}\\mathbf{w}_i)</span> into a prior accumulator <span class="math">\\mathsf{acc}_i</span> to obtain a new accumulator and validity proof <span class="math">(\\mathsf{acc}_{i + 1},\\mathsf{pf}_{i + 1})\\gets \\mathrm{P}(\\mathfrak{q}_i,\\mathsf{acc}_i)</span>. Different from before, however, we wish to establish that given instances <span class="math">\\mathfrak{q}\\mathbf{x}_1,\\ldots ,\\mathfrak{q}\\mathbf{x}_T</span> there exist (more precisely, a party knows) witnesses <span class="math">\\mathfrak{q}\\mathbf{w}_1,\\dots ,\\mathfrak{q}\\mathbf{w}_T</span> such that <span class="math">\\Phi (\\mathfrak{q}\\mathbf{x}_1,\\mathfrak{q}\\mathbf{w}_1)\\wedge \\dots \\wedge \\Phi (\\mathfrak{q}\\mathbf{x}_T,\\mathfrak{q}\\mathbf{w}_T) = 1</span>. For this it suffices to check that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the verifier accepts each accumulation step given only the short instance parts: <span class="math">\\mathrm{V}(\\mathfrak{q}\\mathbf{x}_1, \\mathsf{acc}_1.\\mathbf{x}, \\mathsf{acc}_2.\\mathbf{x}, \\mathsf{pf}_2) = 1, \\mathrm{V}(\\mathfrak{q}\\mathbf{x}_2, \\mathsf{acc}_2.\\mathbf{x}, \\mathsf{acc}_3.\\mathbf{x}, \\mathsf{pf}_3) = 1</span>, and so on; and</li>

      <li>the decider accepts the final accumulator (made of both the instance and witness part): <span class="math">\\mathrm{D}(\\mathrm{acc}_T) = 1</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Again the naive cost $T \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is replaced with the new cost </span>T \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, but now it could be that an accumulator is, e.g., as large as </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$; we only need the instance part of the accumulator (and predicate inputs) to be short.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The security property of a split accumulation scheme involves an extractor that outputs a long witness part from a short instance part and proof, and is reminiscent of the knowledge soundness of a succinct non-interactive argument. Turning this high level description into a working definition requires some care, however, and we view this as a contribution of this paper.¹ Informally the security definition could be summarized as follows.</p>

    <p class="text-gray-300"><strong>Definition 2.2 (informal).</strong> A split accumulation scheme for a predicate <span class="math">\\Phi \\colon X \\times W \\to \\{0,1\\}</span> consists of a triple of algorithms <span class="math">(\\mathrm{P}, \\mathrm{V}, \\mathrm{D})</span> that satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For every accumulator <span class="math">\\mathsf{acc}</span> and predicate input <span class="math">\\mathfrak{q} = (\\mathfrak{q}\\mathbf{x},\\mathfrak{q}\\mathbf{w}) \\in X \\times W</span>, if <span class="math">\\mathrm{D}(\\mathsf{acc}) = 1</span> and <span class="math">\\Phi(\\mathfrak{q}) = 1</span>, then for <span class="math">(\\mathsf{acc}^{\\star},\\mathsf{pf}^{\\star}) \\gets \\mathrm{P}(\\mathfrak{q},\\mathsf{acc})</span> it holds that <span class="math">\\mathrm{V}(\\mathfrak{q}\\mathbf{x},\\mathsf{acc}.\\mathbf{x},\\mathsf{acc}^{\\star}.\\mathbf{x},\\mathsf{pf}^{\\star}) = 1</span> and <span class="math">\\mathrm{D}(\\mathsf{acc}^{\\star}) = 1</span>.</li>

    </ul>

    <p class="text-gray-300">¹By “working definition” we mean a definition that we can provably fulfill under concrete hardness assumptions in the random oracle model, and, separately, that provably suffices for recursive composition in the plain model without random oracles.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge: For every efficiently-generated old accumulator instance acc.x, old input instance qx, accumulation proof pf<em>, and new accumulator acc</em>, if <span class="math">\\mathrm{D}(\\mathrm{acc}^{<em>})=1</span> and <span class="math">\\mathrm{V}(\\mathrm{qx},\\mathrm{acc.x},\\mathrm{acc}^{</em>}.\\mathrm{x},\\mathrm{pf}^{*})=1</span> then, with all but negligible probability, an efficient extractor can find an old accumulator witness acc.w and predicate witness qw such that <span class="math">\\Phi(\\mathrm{qx},\\mathrm{qw})=1</span> and <span class="math">\\mathrm{D}((\\mathrm{acc.x},\\mathrm{acc.w}))=1</span>.</li>

    </ul>

    <p class="text-gray-300">One can verify that split accumulation is indeed a relaxation of atomic accumulation: any atomic accumulation scheme is (trivially) a split accumulation scheme with empty witnesses. Crucially, however, a split accumulation scheme alleviates a major restriction of atomic accumulation, namely, that accumulators and predicate inputs have to be short.</p>

    <p class="text-gray-300">See Section 4 for formal definitions for split accumulation.</p>

    <p class="text-gray-300">Next, in Section 2.2 we show that split accumulation suffices for recursive composition (which has surprising theoretical consequences) and then in Section 2.3 we present a NARK with split accumulation scheme based on discrete logarithms.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.2 PCD from split accumulation</h3>

    <p class="text-gray-300">We summarize the main ideas behind Theorem 1, which obtains proof-carrying data (PCD) from any NARK that has a split accumulation scheme. To ease exposition, in this summary we focus on IVC, which can be viewed as the special case where a circuit <span class="math">F</span> is repeatedly applied. That is, we wish to incrementally prove a claim of the form “<span class="math">F^{T}(z_{0})=z_{T}</span>” where <span class="math">F^{T}</span> denotes <span class="math">F</span> composed with itself <span class="math">T</span> times.</p>

    <p class="text-gray-300">Prior work: recursion via atomic accumulation. Our starting point is a theorem from <em>[x1]</em> that obtains PCD from any SNARK that has an atomic accumulation scheme. The IVC construction implied by that theorem is roughly follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The IVC prover receives a previous instance <span class="math">z_{i}</span>, proof <span class="math">\\pi_{i}</span>, and accumulator <span class="math">\\mathrm{acc}_{i}</span>; accumulates <span class="math">(z_{i},\\pi_{i})</span> with <span class="math">\\mathrm{acc}_{i}</span> to obtain a new accumulator <span class="math">\\mathrm{acc}_{i+1}</span> and accumulation proof <span class="math">\\mathsf{pf}_{i+1}</span>; and generates a SNARK proof <span class="math">\\pi_{i+1}</span> of the following claim expressed as a circuit <span class="math">R</span> (see Fig. 2, middle box): “<span class="math">z_{i+1}=F(z_{i})</span>, and there exist a SNARK proof <span class="math">\\pi_{i}</span>, accumulator <span class="math">\\mathrm{acc}_{i}</span>, and accumulation proof <span class="math">\\mathsf{pf}_{i+1}</span> such that the accumulation verifier accepts <span class="math">((z_{i},\\pi_{i}),\\mathrm{acc}_{i},\\mathrm{acc}_{i+1},\\mathsf{pf}_{i+1})</span>”. The IVC proof for <span class="math">z_{i+1}</span> is <span class="math">(\\pi_{i+1},\\mathrm{acc}_{i+1})</span>.</li>

      <li>The IVC verifier validates an IVC proof <span class="math">(\\pi_{i},\\mathrm{acc}_{i})</span> for <span class="math">z_{i}</span> by running the SNARK verifier on the instance <span class="math">(z_{i},\\mathrm{acc}_{i})</span> and proof <span class="math">\\pi_{i}</span>, and running the accumulation scheme decider on the accumulator <span class="math">\\mathrm{acc}_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">In each iteration we maintain the invariant that if <span class="math">\\mathrm{acc}_{i}</span> is a valid accumulator (according to the decider) and <span class="math">\\pi_{i}</span> is a valid SNARK proof, then the computation is correct up to the <span class="math">i</span>-th step.</p>

    <p class="text-gray-300">Note that while it would suffice to prove that “<span class="math">z_{i+1}=F(z_{i})</span>, <span class="math">\\pi_{i}</span> is a valid SNARK proof, and <span class="math">\\mathrm{acc}_{i}</span> is a valid accumulator”, we cannot afford to do so. Indeed: (i) proving that <span class="math">\\pi_{i}</span> is a valid proof requires proving a statement about the argument verifier, which may not be sublinear; and (ii) proving that <span class="math">\\mathrm{acc}_{i}</span> is a valid accumulator requires proving a statement about the decider, which may not be sublinear. Instead of proving this claim directly, we “defer” it by having the prover accumulate <span class="math">(z_{i},\\pi_{i})</span> into <span class="math">\\mathrm{acc}_{i}</span> to obtain a new accumulator <span class="math">\\mathrm{acc}_{i+1}</span>. The soundness property of the accumulation scheme ensures that if <span class="math">\\mathrm{acc}_{i+1}</span> is valid and the accumulation verifier accepts <span class="math">((z_{i},\\pi_{i}),\\mathrm{acc}_{i},\\mathrm{acc}_{i+1},\\mathsf{pf}_{i+1})</span>, then <span class="math">\\pi_{i}</span> is a valid SNARK proof and <span class="math">\\mathrm{acc}_{i}</span> is a valid accumulator. Thus all that remains to maintain the invariant is for the prover to prove that the accumulation verifier accepts; this is possible provided that the accumulation verifier is sublinear.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Our construction: recursion via split accumulation.</h4>

    <p class="text-gray-300">Our construction naturally extends the above idea to the setting of NARKs with split accumulation schemes. Indeed, the only difference to the above construction is that the proof <span class="math">\\pi_{i+1}</span> generated by the IVC prover is for the statement “<span class="math">z_{i+1}=F(z_{i})</span>, and there exist a NARK proof <em>instance</em> <span class="math">\\pi_{i}.\\mathbbm{x}</span>, an accumulator <em>instance</em> <span class="math">\\mathsf{acc}_{i}.\\mathbbm{x}</span>, and an accumulation proof <span class="math">\\mathsf{pf}_{i+1}</span> such that the accumulation verifier accepts <span class="math">((z_{i},\\pi_{i}.\\mathbbm{x}),\\mathsf{acc}_{i}.\\mathbbm{x},\\mathsf{acc}_{i+1}.\\mathbbm{x},\\mathsf{pf}_{i+1})</span>”, and accordingly the IVC verifier runs the NARK verifier on <span class="math">((z_{i},\\mathsf{acc}_{i}.\\mathbbm{x}),\\pi_{i})</span> (in addition to running the accumulation scheme decider on the accumulator <span class="math">\\mathsf{acc}_{i}</span>). This is illustrated in Fig. 2 (lower box). Note that the circuit <span class="math">R</span> itself is unchanged from the atomic case; the difference is in whether we pass the <em>entire</em> proof and accumulators or just the <span class="math">\\mathbbm{x}</span> part.</p>

    <p class="text-gray-300">Proving that this relaxation yields a secure construction is more complex. Similar to prior work, the proof of security proceeds via a recursive extraction argument, as we explain next.</p>

    <p class="text-gray-300">For an atomic accumulation scheme (<em>[x1]</em>), one maintains the following extraction invariant: the <span class="math">i</span>-th extractor outputs <span class="math">(z_{i},\\pi_{i},\\mathsf{acc}_{i})</span> such that <span class="math">\\pi_{i}</span> is valid according to the SNARK, <span class="math">\\mathsf{acc}_{i}</span> is valid according to the decider, and <span class="math">F^{T-i}(z_{i})=z_{T}</span>. The <span class="math">T</span>-th “extractor” is simply the malicious prover, and we can obtain the <span class="math">i</span>-th extractor by applying the knowledge guarantee of the SNARK to the <span class="math">(i+1)</span>-th extractor. That the invariant is maintained is implied by the soundness guarantee of the atomic accumulation scheme.</p>

    <p class="text-gray-300">For a split accumulation scheme, we want to maintain the same extraction invariant; however, the extractor for the NARK will only yield <span class="math">(z_{i},\\pi_{i}.\\mathbbm{x},\\mathsf{acc}_{i}.\\mathbbm{x})</span>, and not the corresponding witnesses. This is where we make use of the extraction property of the split accumulation scheme itself. Specifically, we interleave the knowledge guarantees of the NARK and accumulation scheme as follows: the <span class="math">i</span>-th NARK extractor is obtained from the <span class="math">(i+1)</span>-th accumulation extractor using the knowledge guarantee of the NARK, and the <span class="math">i</span>-th accumulation extractor is obtained from the <span class="math">i</span>-th NARK extractor using the knowledge guarantee of the accumulation scheme. We take the malicious prover to be the <span class="math">T</span>-th accumulation extractor.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">From sketch to proof.</h4>

    <p class="text-gray-300">In Section 5, we give the formal details of our construction and a proof of correctness. In particular, we show how to construct PCD, a more general primitive than IVC. In the PCD setting, rather than each computation step having a single input <span class="math">z_{i}</span>, it receives <span class="math">m</span> inputs from different nodes. Proving correctness hence requires proving that <em>all</em> of these inputs were computed correctly. For our construction, this entails checking <span class="math">m</span> proofs and <span class="math">m</span> accumulators. To do this, we extend the definition of an accumulation scheme to allow accumulating multiple instance-proof pairs and multiple “old” accumulators.</p>

    <p class="text-gray-300">We also note that the application to PCD leads to other definitional considerations, which are similar to those that have appeared in previous works <em>[x11, x1]</em>. In particular, the knowledge soundness guarantee for both the NARK <em>and</em> the accumulation scheme should be of the stronger “multi-instance witness-extended emulation with auxiliary input and output” type used in previous work. Additionally, the underlying construction of split accumulation achieves only expected polynomial-time extraction (in the ROM), and so the recursive extraction technique requires that we are able to extract from expected-time adversaries.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Remark 2.3 (knowledge soundness for PCD vs. IVC).</h6>

    <p class="text-gray-300">The proof of security for PCD extracts a transcript <em>one full layer at a time</em>. Since a layer consists of many nodes, each with an <em>independently-generated</em> proof and accumulator, a standard “single-instance” extraction guarantee is insufficient in general. However, in the special case of IVC, every layer consists of exactly one node, and so single-instance extraction does suffice.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 2.4 (flavors of PCD).</h6>

    <p class="text-gray-300">The recent advances in PCD from accumulation achieve weaker efficiency guarantees than PCD from succinct verification, and formally these results are incomparable. (Starting from weaker assumptions they obtain weaker conclusions.) The essential feature that all these works achieve is that the efficiency of PCD algorithms is independent of the number of nodes in the PCD computation, which is how PCD is defined (see Section 3.2). That said, prior work on PCD from succinct verification <em>[x2, x3, x11]</em> additionally guarantees that verifying a PCD proof is sublinear in a node’s computation;</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Comparison of circuits used to realize recursion with different techniques.</p>

    <p class="text-gray-300">and prior work on PCD from atomic accumulation [BCMS20] merely ensures that a PCD proof has size (but not necessarily verification time) that is sublinear in a node's computation. The PCD scheme obtained in this paper does not have these additional features: a PCD proof has size that is linear in a node's computation.</p>

    <p class="text-gray-300">We summarize the main ideas behind Theorem 2, which provides, in the discrete logarithm setting with random oracles, a (zero knowledge) NARK for R1CS that has a (zero knowledge) split accumulation scheme whose accumulation verifier has constant size (more precisely, performs a constant number of group scalar multiplications, field operations, and random oracle calls).</p>

    <p class="text-gray-300">Recall that R1CS is a standard generalization of arithmetic circuit satisfiability where the "circuit description" is given by coefficient matrices, as specified below. (" <span class="math">\\circ</span> " denotes the entry-wise product.)</p>

    <p class="text-gray-300">Definition 2.5 (R1CS problem). Given a finite field  <span class="math">\\mathbb{F}</span> , coefficient matrices  <span class="math">A, B, C \\in \\mathbb{F}^{\\mathsf{M} \\times \\mathsf{N}}</span> , and an instance vector  <span class="math">x \\in \\mathbb{F}^{\\mathfrak{n}}</span> , is there a witness vector  <span class="math">w \\in \\mathbb{F}^{\\mathsf{N} \\neg \\mathfrak{n}}</span>  such that  <span class="math">Az \\circ Bz = Cz</span>  for  <span class="math">z := (x, w) \\in \\mathbb{F}^{\\mathsf{N}}</span> ?</p>

    <p class="text-gray-300">We explain our construction incrementally. In Section 2.3.1 we begin by describing a NARK for R1CS that is not zero knowledge, and a "basic" split accumulation scheme for it that is also not zero knowledge. In Section 2.3.2 we show how to extend the NARK and its split accumulation scheme to both be zero knowledge. In Section 2.3.3 we explain why the accumulation scheme described so far is limited to the special case of 1 old accumulator and 1 predicate input (which suffices for IVC), and sketch how to obtain accumulation for  <span class="math">m</span>  old accumulators and  <span class="math">n</span>  predicate inputs (which is required for PCD); this motivates the problem of accumulating Hadamard products, which we subsequently address in Section 2.5.</p>

    <p class="text-gray-300">We highlight here that both the NARK and the accumulation scheme are particularly simple compared to other protocols in the SNARK literature (especially with regard to constructions that enable recursion!), and view this as a significant advantage for potential deployments of these ideas in the real world.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{ck} = (G_1, \\ldots, G_{\\mathsf{M}}) \\in \\mathbb{G}^{\\mathsf{M}}</span>  be a commitment key for the Pedersen commitment scheme with message space  <span class="math">\\mathbb{F}^{\\mathsf{M}}</span> , and let  <span class="math">\\mathsf{Commit}(\\mathsf{ck}, a) := \\sum_{i \\in [\\mathsf{M}]} a_i \\cdot G_i</span>  denote its commitment function. Consider the following non-interactive argument for R1CS:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(ck, (A, B, C), x, w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(ck, (A, B, C), x)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z := (x, w) ∈ F^N</td>

            <td class="px-3 py-2 border-b border-gray-700">z := (x, w)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z_A := Az ∈ F^M C_A := Commit(ck, z_A) ∈ G</td>

            <td class="px-3 py-2 border-b border-gray-700">z_A := Az C_A := Commit(ck, z_A)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z_B := Bz ∈ F^M C_B := Commit(ck, z_B) ∈ G</td>

            <td class="px-3 py-2 border-b border-gray-700">z_B := Bz C_B := Commit(ck, z_B)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z_C := Cz ∈ F^M C_C := Commit(ck, z_C) ∈ G</td>

            <td class="px-3 py-2 border-b border-gray-700">z_C := Cz C_C := Commit(ck, z_C)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | C_C := Commit(ck, z_A ∘ z_B)  |</p>

    <p class="text-gray-300">The NARK's security follows from the binding property of Pedersen commitments. (At this point we are not using any homomorphic properties, but we will in the accumulation scheme.) Moreover, denoting by  <span class="math">\\mathsf{K} = \\Omega (\\mathsf{M})</span>  the number of non-zero entries in the coefficient matrices, the NARK's efficiency is as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NARK prover time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NARK verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NARK argument size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(K) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The NARK may superficially appear useless because it has linear argument size and is not zero knowledge. Nevertheless, we can obtain an efficient split accumulation scheme for it, as we describe next. <span class="math">^3</span></p>

    <p class="text-gray-300">The predicate to be accumulated is the NARK verifier with a suitable split between predicate instance and predicate witness:  <span class="math">\\Phi</span>  takes as input a predicate instance  <span class="math">\\mathsf{qx} = (x, C_A, C_B, C_C)</span>  and a predicate witness  <span class="math">\\mathsf{qw} = w</span> , and then runs the NARK verifier with R1CS instance  <span class="math">x</span>  and proof  <span class="math">\\pi = (C_A, C_B, C_C, w)</span> .</p>

    <p class="text-gray-300">An accumulator acc is split into an accumulator instance  <span class="math">\\mathsf{acc}.\\mathbf{x} = (x, C_A, C_B, C_C, C_\\circ) \\in \\mathbb{F}^n \\times \\mathbb{G}^4</span>  and an accumulator witness  <span class="math">\\mathsf{acc}.\\mathbf{w} = w \\in \\mathbb{F}^{\\mathsf{N} - \\mathsf{n}}</span> . The accumulation decider D validates a split accumulator  <span class="math">\\mathsf{acc} = (\\mathsf{acc}.\\mathbf{x}, \\mathsf{acc}.\\mathbf{w})</span>  as follows: set  <span class="math">z := (x, w) \\in \\mathbb{F}^{\\mathsf{N}}</span> ; compute the vectors  <span class="math">z_A := Az</span> ,  <span class="math">z_B := Bz</span> , and  <span class="math">z_C := Cz</span> ; and check that the following conditions hold:</p>

    <p class="text-gray-300"><span class="math">C_A \\stackrel{?}{=} \\operatorname{Commit}(\\mathsf{ck}, z_A)</span> ,  <span class="math">C_B \\stackrel{?}{=} \\operatorname{Commit}(\\mathsf{ck}, z_B)</span> ,  <span class="math">C_C \\stackrel{?}{=} \\operatorname{Commit}(\\mathsf{ck}, z_C)</span> ,  <span class="math">C_\\circ \\stackrel{?}{=} \\operatorname{Commit}(\\mathsf{ck}, z_A \\circ z_B)</span> .</p>

    <p class="text-gray-300">Note that the accumulation decider D is similar, but not equal, to the NARK verifier.</p>

    <p class="text-gray-300">We are left to describe the accumulation prover and accumulation verifier. Both have access to a random oracle  <span class="math">\\rho</span> . For adaptive security, queries to the random oracle should include a hash  <span class="math">\\tau</span>  of the coefficient matrices  <span class="math">A, B, C</span>  and instance size  <span class="math">n</span> , which can be precomputed in an offline phase. (Formally, this is done via the indexer algorithm of the accumulation scheme, which receives the coefficient matrices and instance size, performs all one-time computations such as deriving  <span class="math">\\tau</span> , and produces an accumulator proving key apk, an accumulator verification key avk, and a decision key dk for P, V, and D respectively.)</p>

    <p class="text-gray-300">The intuition for accumulation is to set the new accumulator to be a random linear combination of the old accumulator and predicate input, and use the accumulation proof to collect cross terms that arise from the Hadamard product (a bilinear, not linear, operation). This naturally leads to the following simple construction.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{P}^{\\rho_{\\mathrm{AS}}}(\\mathrm{acc},(\\mathrm{qx},\\mathrm{qw}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{A}\\coloneqq A\\cdot (\\mathsf{qx}.x,\\mathsf{qw}.w),z_{B}\\coloneqq B\\cdot (\\mathsf{qx}.x,\\mathsf{qw}.w).</span></li>

      <li><span class="math">z_A^\\prime \\coloneqq A\\cdot (\\mathrm{acc.s.x},\\mathrm{acc.w.w}),z_B^\\prime \\coloneqq B\\cdot (\\mathrm{acc.s.x},\\mathrm{acc.w.w}).</span></li>

      <li><span class="math">\\mathsf{pf} \\coloneqq \\mathsf{Commit}(\\mathsf{ck}, z_A \\circ z_B&#x27; + z_A&#x27; \\circ z_B)</span> .</li>

      <li><span class="math">\\beta \\coloneqq \\rho_{\\mathrm{AS}}(\\tau, \\mathrm{acc.s}, \\mathrm{qx}, \\mathrm{pf})</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x} \\cdot x \\coloneqq \\mathrm{acc} \\cdot \\mathrm{x} \\cdot x + \\beta \\cdot \\mathrm{qx} \\cdot x</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_A := \\mathrm{acc} \\cdot \\mathrm{x}. C_A + \\beta \\cdot \\mathrm{qx}. C_A</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_B := \\mathrm{acc} \\cdot \\mathrm{x}. C_B + \\beta \\cdot \\mathrm{qx}. C_B</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_C := \\mathrm{acc} \\cdot \\mathrm{x}. C_C + \\beta \\cdot \\mathrm{qx}. C_C</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_{\\circ} := \\mathrm{acc} \\cdot \\mathrm{x}. C_{\\circ} + \\beta \\cdot \\mathrm{pf} + \\beta^{2} \\cdot \\mathrm{qx}. C_{C}</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{w} \\cdot w := \\mathrm{acc} \\cdot \\mathrm{w} \\cdot w + \\beta \\cdot \\mathrm{qw} \\cdot w</span> .</li>

      <li>Output  <span class="math">(\\mathrm{acc}^*, \\mathrm{pf})</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{V}^{\\rho_{\\mathrm{AS}}}(\\mathrm{acc.s}, \\mathrm{qx}, \\mathrm{acc}^*. \\mathrm{x}, \\mathrm{pf})</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta \\coloneqq \\rho_{\\mathrm{AS}}(\\tau, \\mathrm{acc.s}, \\mathrm{qx}, \\mathrm{pf})</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x} \\cdot x \\stackrel{\\circ}{=} \\mathrm{acc} \\cdot \\mathrm{x} \\cdot x + \\beta \\cdot \\mathrm{qx} \\cdot x</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_A \\stackrel{\\circ}{=} \\mathrm{acc} \\cdot \\mathrm{x}. C_A + \\beta \\cdot \\mathrm{qx}. C_A</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_B \\stackrel{\\circ}{=} \\mathrm{acc} \\cdot \\mathrm{x}. C_B + \\beta \\cdot \\mathrm{qx}. C_B</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_C \\stackrel{\\circ}{=} \\mathrm{acc} \\cdot \\mathrm{x}. C_C + \\beta \\cdot \\mathrm{qx}. C_C</span> .</li>

      <li><span class="math">\\mathrm{acc}^* \\cdot \\mathrm{x}. C_{\\circ} \\stackrel{\\circ}{=} \\mathrm{acc} \\cdot \\mathrm{x}. C_{\\circ} + \\beta \\cdot \\mathrm{pf} + \\beta^{2} \\cdot \\mathrm{qx}. C_{C}</span> .</li>

    </ol>

    <p class="text-gray-300">The efficiency of the split accumulation scheme can be summarized by the following table:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulation prover time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulation verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">decider time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulator size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">4 G 5</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) G</td>

            <td class="px-3 py-2 border-b border-gray-700">acc.x</td>

            <td class="px-3 py-2 border-b border-gray-700">= 4 G + n F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(K) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K) F</td>

            <td class="px-3 py-2 border-b border-gray-700">acc.w</td>

            <td class="px-3 py-2 border-b border-gray-700">= (N - n) F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1 RO</td>

            <td class="px-3 py-2 border-b border-gray-700">1 RO</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The key efficiency feature is that the accumulation verifier only performs 1 call to the random oracle, a constant number of group scalar multiplications, and field operations. (More precisely, the verifier makes n field operations, but this does not grow with circuit size and, more fundamentally, is inevitable because the accumulation verifier must receive the R1CS instance  <span class="math">x \\in \\mathbb{F}^n</span>  as input.)</p>

    <p class="text-gray-300">We explain how to add zero knowledge to the approach described in the previous section.</p>

    <p class="text-gray-300">First, we extend the NARK to additionally achieve zero knowledge. For this we construct a sigma protocol for R1CS based on Pedersen commitments, which is summarized in Figure 3; then we apply the Fiat-Shamir transformation to it to obtain a corresponding zkNARK for R1CS. Here the commitment key for the Pedersen commitment is  <span class="math">\\mathsf{ck} := (G_1, \\ldots, G_{\\mathsf{M}}, H) \\in \\mathbb{G}^{\\mathsf{M} + 1}</span> , as we need a spare group element for the commitment randomness. The blue text in the figure represents the "diff" compared to the non-zero-knowledge version, and indeed if all such text were removed the protocol would collapse to the previous one.</p>

    <p class="text-gray-300">Second, we extend the split accumulation scheme to accumulate the modified protocol for R1CS. Again the predicate being accumulated is the NARK verifier but now since the NARK verifier has changed so does the predicate. A zkNARK proof  <span class="math">\\pi</span>  now can be viewed as a pair  <span class="math">(\\pi_1,\\pi_2)</span>  denoting the prover's commitment and response in the sigma protocol. Then the predicate  <span class="math">\\Phi</span>  takes as input a predicate instance  <span class="math">\\mathbf{qx} = (x,\\pi_1)\\in \\mathbb{F}^n\\times \\mathbb{G}^8</span>  and a predicate witness  <span class="math">\\mathrm{qw} = \\pi_{2}\\in \\mathbb{F}^{\\mathsf{N} - \\mathsf{n} + 4}</span> , and then runs the NARK verifier with R1CS instance  <span class="math">x</span>  and proof  <span class="math">\\pi = (\\pi_1,\\pi_2)</span> .</p>

    <p class="text-gray-300">An accumulator acc is split into an accumulator instance  <span class="math">\\mathsf{acc.sx} = (x, C_A, C_B, C_C, C_\\circ) \\in \\mathbb{F}^n \\times \\mathbb{G}^4</span>  (the same as before) and an accumulator witness  <span class="math">\\mathsf{acc.w} = (w, \\sigma_A, \\sigma_B, \\sigma_C, \\sigma_\\circ) \\in \\mathbb{F}^{N-n+4}</span> . The decider is essentially the same as in Section 2.3.1, except that now the four commitments are computed using the corresponding randomness in  <span class="math">\\mathsf{acc.w}</span> .</p>

    <p class="text-gray-300">The accumulation prover and accumulation verifier can be extended, in a straightforward way, to support the new zkSNARK protocol; we provide these in Figure 4, with text in blue to denote the "diff" to accumulate</p>

    <p class="text-gray-300">the zero knowledge features of the NARK and with text in red to denote the features to make accumulation itself zero knowledge. There we use <span class="math">\\rho_{\\texttt{NARK}}</span> to denote the oracle used for the zkNARK for R1CS, which is obtained via the Fiat–Shamir transformation applied to a sigma protocol (as mentioned above); for adaptive security, the Fiat–Shamir query includes, in addition to <span class="math">\\pi_{1}</span>, a hash <span class="math">\\tau:=\\rho_{\\texttt{NARK}}(A,B,C,\\texttt{n})</span> of the coefficient matrices and the R1CS input <span class="math">x\\in\\mathbb{F}^{\\texttt{n}}</span> (this means that the Fiat–Shamir query equals <span class="math">(\\tau,\\texttt{qx})=(\\tau,x,\\pi_{1})</span>).</p>

    <p class="text-gray-300">Note that now the accumulation prover and accumulation verifier are each making <span class="math">2</span> calls to the random oracle, rather than <span class="math">1</span> as before, because they have to additionally compute the sigma protocol’s challenge.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">2.3.3 Towards general accumulation</h4>

    <p class="text-gray-300">The accumulation schemes described in Sections 2.3.1 and 2.3.2 are limited to a special case, which we could call the “IVC setting”, where accumulation involves <span class="math">1</span> old accumulator and <span class="math">1</span> predicate input. However, the definition of accumulation requires supporting <span class="math">m</span> old accumulators <span class="math">[\\texttt{acc}_{j}]_{j=1}^{m}=[(\\texttt{acc}_{j}.\\texttt{x},\\texttt{acc}_{j}.\\texttt{w})]_{j=1}^{m}</span> and <span class="math">n</span> predicate inputs <span class="math">[(\\texttt{qx}_{i},\\texttt{qw}_{i})]_{i=1}^{n}</span>, for any <span class="math">m</span> and <span class="math">n</span>. (E.g., to construct PCD we set both <span class="math">m</span> and <span class="math">n</span> equal to the “arity” of the compliance predicate.) How can we extend the ideas described so far to this more general case?</p>

    <p class="text-gray-300">The zkNARK verifier performs two types of computations: linear checks and a Hadamard product check. We describe how to accumulate each of these in the general case.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Linear checks. A split accumulator <span class="math">\\texttt{acc}=(\\texttt{acc}.\\texttt{x},\\texttt{acc}.\\texttt{w})</span> in Section 2.3.2 included sub-accumulators for different linear checks: <span class="math">x,C_{A},C_{B},C_{C}</span> in <span class="math">\\texttt{acc}.\\texttt{x}</span> and <span class="math">w,\\sigma_{A},\\sigma_{B},\\sigma_{C}</span> in <span class="math">\\texttt{acc}.\\texttt{w}</span>. We can keep these components and simply use more random coefficients or, as we do, further powers of the element <span class="math">\\beta</span>. For example, in the accumulation prover <span class="math">\\mathrm{P}</span> a computation such as <span class="math">\\texttt{acc}^{\\star}.\\texttt{x}.x:=\\texttt{acc}.\\texttt{x}.x+\\beta\\cdot\\texttt{qx}.x</span> is replaced by a computation such as <span class="math">\\texttt{acc}^{\\star}.\\texttt{x}.x:=\\sum_{j=1}^{m}\\beta^{j-1}\\cdot\\texttt{acc}_{j}.\\texttt{x}.x+\\sum_{i=1}^{n}\\beta^{m+j-1}\\cdot\\texttt{qx}_{i}.x</span>.</li>

      <li>Hadamard product check. A split accumulator <span class="math">\\texttt{acc}=(\\texttt{acc}.\\texttt{x},\\texttt{acc}.\\texttt{w})</span> in Section 2.3.2 also included a sub-accumulator for the Hadamard product check: <span class="math">C_{\\circ}</span> in <span class="math">\\texttt{acc}.\\texttt{x}</span> and <span class="math">\\sigma_{\\circ}</span> in <span class="math">\\texttt{acc}.\\texttt{w}</span>. Because a Hadamard product is a <em>b</em>ilinear operation, combining two Hadamard products via a random coefficient led to a quadratic polynomial whose coefficients include the two original Hadamard products and a cross term. This is indeed why we stored the cross term in the accumulation proof <span class="math">\\mathsf{pf}</span>. However, if we consider the cross terms that arise from combining more than two Hadamard products (i.e., when <span class="math">m+n&gt;2</span>) then the corresponding polynomials do not lend themselves to accumulation because the original Hadamard products appear together with other cross terms. To handle this issue, we introduce in Section 2.5 a new subroutine that accumulates Hadamard products via an additional round of interaction.</li>

    </ul>

    <p class="text-gray-300">We work out, and prove secure, the above ideas in full generality in Section 8.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.4 On proving knowledge soundness</h3>

    <p class="text-gray-300">In order to construct accumulation schemes that fulfill the type of knowledge soundness that we ultimately need for PCD (see Section 2.2), we formulate a new <em>expected-time</em> <em>forking lemma in the random oracle model</em>, which is informally stated below. In our setting, <span class="math">(\\texttt{q},\\texttt{b},\\texttt{o})\\in L</span> if <span class="math">\\texttt{o}=([\\texttt{qx}_{i}]_{i=1}^{n},\\texttt{acc},\\texttt{pf})</span> is such that <span class="math">\\mathrm{D}(\\texttt{acc})=1</span> and, given that <span class="math">\\rho(\\texttt{q})=\\texttt{b}</span>, the accumulation verifier accepts: <span class="math">\\mathrm{V}^{\\rho}([\\texttt{qx}_{i}]_{i=1}^{n},\\texttt{acc}.\\texttt{x},\\texttt{pf})=1</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Lemma 1 (informal).</h6>

    <p class="text-gray-300">Let <span class="math">L</span> be an efficiently recognizable set. There exists an algorithm <span class="math">\\mathsf{Fork}</span> such that for every expected polynomial time algorithm <span class="math">A</span> and integer <span class="math">N\\in\\mathbb{N}</span> the following holds. With all but negligible probability over the choice of random oracle <span class="math">\\rho</span>, randomness <span class="math">r</span> of <span class="math">A</span>, and randomness of <span class="math">\\mathsf{Fork}</span>, if <span class="math">A^{\\rho}(r)</span> outputs a tuple <span class="math">(\\texttt{q},\\texttt{b},\\texttt{o})\\in L</span> with <span class="math">\\rho(\\texttt{q})=\\texttt{b}</span>, then <span class="math">\\mathsf{Fork}^{A,\\rho}(1^{N},\\texttt{q},\\texttt{b},\\texttt{o},r)</span> outputs <span class="math">[(\\texttt{b}_{j},\\texttt{o}_{j})]_{j=1}^{N}</span> such that <span class="math">\\texttt{b}_{1},\\ldots,\\texttt{b}_{N}</span> are pairwise distinct and for each <span class="math">j\\in[N]</span> it holds that <span class="math">(\\texttt{q},\\texttt{b}_{j},\\texttt{o}_{j})\\in L</span>.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: The sigma protocol for R1CS that underlies the zkNARK for R1CS. Figure 4: Accumulation prover and accumulation verifier for the zkNARK for R1CS.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{P}^{\\rho_{\\mathrm{AS}}}</span>  (qx, qw), acc):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{A}\\coloneqq A\\cdot (\\mathrm{qx}.x,\\mathrm{qw}.s),z_{B}\\coloneqq B\\cdot (\\mathrm{qx}.x,\\mathrm{qw}.s).</span></li>

      <li><span class="math">z_A^\\prime \\coloneqq A\\cdot (\\mathrm{acc}.x.x,\\mathrm{acc}.w.s),z_B^\\prime \\coloneqq B\\cdot (\\mathrm{acc}.x.x,\\mathrm{acc}.w.s).</span></li>

      <li>Sample  <span class="math">x^{<em>}\\gets \\mathbb{F}^{n}</span>  and  <span class="math">s^</em>\\gets \\mathbb{F}^{N - n}</span>  and  <span class="math">\\omega_{2}^{*}\\gets \\mathbb{F}</span></li>

      <li><span class="math">s_A^<em> \\coloneqq A \\cdot (x^</em>, s^<em>)</span> ,  <span class="math">s_B^</em> \\coloneqq B \\cdot (x^<em>, s^</em>)</span> ,  <span class="math">s_C^<em> \\coloneqq C \\cdot (x^</em>, s^*)</span> .</li>

      <li><span class="math">C_A^<em> \\coloneqq \\operatorname{Commit}(\\operatorname{ck}, s_A^</em>; \\omega_A^<em>)</span>  for  <span class="math">\\omega_A^</em> \\gets \\mathbb{F}</span> .</li>

      <li><span class="math">C_B^<em> \\coloneqq \\operatorname{Commit}(\\operatorname{ck}, s_B^</em>; \\omega_B^<em>)</span>  for  <span class="math">\\omega_B^</em> \\gets \\mathbb{F}</span> .</li>

      <li><span class="math">C_C^<em> \\coloneqq \\operatorname{Commit}(\\operatorname{ck}, s_C^</em>; \\omega_C^<em>)</span>  for  <span class="math">\\omega_C^</em> \\gets \\mathbb{F}</span> .</li>

      <li><span class="math">\\mathrm{pf}_1\\coloneqq \\mathrm{Commit}(\\mathrm{ck},z_A\\circ s_B^<em> +s_A^</em>\\circ z_B;0)</span></li>

      <li><span class="math">\\mathsf{pf}_3\\coloneqq \\mathsf{Commit}(\\mathsf{ck},\\mathsf{s}_A^<em>\\circ \\mathsf{s}_B^</em> +\\mathsf{z}_A\\circ \\mathsf{z}_B&#x27; + \\mathsf{z}_A&#x27;\\circ \\mathsf{z}_B;\\omega_2^*)</span></li>

      <li><span class="math">\\mathsf{pf}_3\\coloneqq \\mathsf{Commit}(\\mathsf{ck},\\mathsf{s}_A^<em>\\circ \\mathsf{z}_B&#x27; + \\mathsf{z}_A&#x27;\\circ \\mathsf{s}_B^</em>;0)</span></li>

      <li><span class="math">\\mathsf{pf} \\coloneqq (x^{<em>}, C_{A}^{</em>}, C_{B}^{<em>}, C_{C}^{</em>}, \\mathsf{pf}_{1}, \\mathsf{pf}_{2}, \\mathsf{pf}_{3})</span> .</li>

      <li><span class="math">\\beta \\coloneqq \\rho_{\\mathrm{AS}}(\\tau, \\mathrm{acc}.x, \\mathrm{qx}, \\mathrm{pf})</span> .</li>

      <li>Compute  <span class="math">\\gamma \\coloneqq \\rho_{\\mathrm{NARK}}(\\tau, \\mathrm{qx})</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x} \\cdot \\mathsf{x} \\coloneqq \\mathsf{acc} \\cdot \\mathsf{x} \\cdot \\mathsf{x} + \\beta \\cdot \\mathsf{x}^</em> + \\beta^2 \\cdot \\mathsf{qx} \\cdot \\mathsf{x}</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x}.C_A := \\mathsf{acc} \\cdot \\mathsf{x}.C_A + \\beta \\cdot C_A^</em> + \\beta^2 \\cdot (\\mathsf{qx}.C_A + \\gamma \\cdot \\mathsf{qx}.C_A&#x27;)</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x}.C_B := \\mathsf{acc} \\cdot \\mathsf{x}.C_B + \\beta \\cdot C_B^</em> + \\beta^2 \\cdot (\\mathsf{qx}.C_B + \\gamma \\cdot \\mathsf{qx}.C_B&#x27;)</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x}.C_C := \\mathsf{acc} \\cdot \\mathsf{x}.C_C + \\beta \\cdot C_C^</em> + \\beta^2 \\cdot (\\mathsf{qx}.C_C + \\gamma \\cdot \\mathsf{qx}.C_C&#x27;)</span> .</li>

      <li><span class="math">\\mathsf{acc}^* \\cdot \\mathsf{x}.C_{\\circ} := \\mathsf{acc} \\cdot \\mathsf{x}.C_{\\circ} + \\beta \\cdot \\mathsf{pf}_{1} + \\beta^{2} \\cdot \\mathsf{pf}_{2} + \\beta^{3} \\cdot \\mathsf{pf}_{3} + \\beta^{4} \\cdot (\\mathsf{qx}.C_{\\circ} + \\gamma \\cdot C_{1} + \\gamma^{2} \\cdot C_{2})</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{w}.s := \\mathsf{acc} \\cdot \\mathsf{w}.s + \\beta \\cdot s^</em> + \\beta^2 \\cdot \\mathsf{qw}.s</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{w}. \\sigma_A := \\mathsf{acc} \\cdot \\mathsf{w}. \\sigma_A + \\beta \\cdot \\omega_A^</em> + \\beta^2 \\cdot \\mathsf{qw}. \\sigma_A</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{w}. \\sigma_B := \\mathsf{acc} \\cdot \\mathsf{w}. \\sigma_B + \\beta \\cdot \\omega_B^</em> + \\beta^2 \\cdot \\mathsf{qw}. \\sigma_B</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{w}. \\sigma_C := \\mathsf{acc} \\cdot \\mathsf{w}. \\sigma_C + \\beta \\cdot \\omega_C^</em> + \\beta^2 \\cdot \\mathsf{qw}. \\sigma_C</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{w}. \\sigma_{\\circ} := \\mathsf{acc} \\cdot \\mathsf{w}. \\sigma_{\\circ} + \\beta^{2} \\cdot \\omega_{2}^{</em>} + \\beta^{4} \\cdot \\mathsf{qw}. \\sigma_{\\circ}</span> .</li>

      <li>Output  <span class="math">(\\mathrm{acc}^*,\\mathrm{pf})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{V}^{\\rho_{\\mathrm{AS}}}(\\mathrm{qx}, \\mathrm{acc}.x, \\mathrm{acc}^*.x, \\mathrm{pf})</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta \\coloneqq \\rho_{\\mathrm{AS}}(\\tau, \\mathrm{acc}.x, \\mathrm{qx}, \\mathrm{pf})</span> .</li>

      <li><span class="math">\\gamma \\coloneqq \\rho_{\\mathrm{NARK}}(\\tau, \\mathrm{qx})</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x}.x \\stackrel{?}{=} \\mathsf{acc} \\cdot \\mathsf{x}.x + \\beta \\cdot x^</em> + \\beta^2 \\cdot \\mathsf{qx}.x.</span></li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x}.C_A \\stackrel{?}{=} \\mathsf{acc} \\cdot \\mathsf{x}.C_A + \\beta \\cdot C_A^</em> + \\beta^2 \\cdot (\\mathsf{qx}.C_A + \\gamma \\cdot \\mathsf{qx}.C_A&#x27;)</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x}.C_B \\stackrel{?}{=} \\mathsf{acc} \\cdot \\mathsf{x}.C_B + \\beta \\cdot C_B^</em> + \\beta^2 \\cdot (\\mathsf{qx}.C_B + \\gamma \\cdot \\mathsf{qx}.C_B&#x27;)</span> .</li>

      <li><span class="math">\\mathsf{acc}^<em> \\cdot \\mathsf{x}.C_C \\stackrel{?}{=} \\mathsf{acc} \\cdot \\mathsf{x}.C_C + \\beta \\cdot C_C^</em> + \\beta^2 \\cdot (\\mathsf{qx}.C_C + \\gamma \\cdot \\mathsf{qx}.C_C&#x27;)</span> .</li>

      <li><span class="math">\\mathsf{acc}^* \\cdot \\mathsf{x}.C_{\\circ} \\stackrel{?}{=} \\mathsf{acc} \\cdot \\mathsf{x}.C_{\\circ} + \\beta \\cdot \\mathsf{pf}_1 + \\beta^2 \\cdot \\mathsf{pf}_2 + \\beta^3 \\cdot \\mathsf{pf}_3 + \\beta^4 \\cdot (\\mathsf{qx}.C_C + \\gamma \\cdot C_1 + \\gamma^2 \\cdot C_2)</span> .</li>

    </ol>

    <p class="text-gray-300">This forking lemma differs from prior forking lemmas in three significant ways. First, it is in the random oracle model rather than the interactive setting (unlike <em>[x1]</em>). Second, we can obtain any polynomial number of accepting transcripts in expected polynomial time with only negligible loss in success probability (unlike forking lemmas for signature schemes, which typically extract two transcripts in strict polynomial time <em>[x3]</em>). Finally, it holds even if the adversary itself runs in expected (as opposed to strict) polynomial time. This is important for our application to PCD where the extractor in one recursive step becomes the adversary in the next. This last feature requires some care, since the running time of the adversary, and in particular the length of its random tape, may not be bounded. For more details, see Section 6.2.</p>

    <p class="text-gray-300">Moreover, in our security proofs we at times additionally rely on an expected-time variant of the <em>zero-finding game lemma</em> from <em>[x2]</em> to show that if a particular polynomial equation holds at a point obtained from the random oracle via a “commitment” to the equation, then it must with overwhelming probability be a polynomial identity. For more details, see Appendix A.2.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.5 Split accumulation for Hadamard products</h3>

    <p class="text-gray-300">We construct a split accumulation scheme for a predicate <span class="math">\\Phi_{\\text{\\tiny HP}}</span> that considers the Hadamard product of committed vectors. For a commitment key <span class="math">\\mathsf{ck}</span> for messages in <span class="math">\\mathbb{F}^{\\ell}</span>, the predicate <span class="math">\\Phi_{\\text{\\tiny HP}}</span> takes as input a predicate instance <span class="math">\\mathsf{qx}=(C_{1},C_{2},C_{3})\\in\\mathbb{G}^{3}</span> consisting of three Pedersen commitments, a predicate witness <span class="math">\\mathsf{qw}=(a,b,\\omega_{1},\\omega_{2},\\omega_{3})</span> consisting of two vectors <span class="math">a,b\\in\\mathbb{F}^{\\ell}</span> and three opening randomness elements <span class="math">\\omega_{1},\\omega_{2},\\omega_{3}\\in\\mathbb{F}</span>, and checks that <span class="math">C_{1}=\\mathsf{CM.Commit}(\\mathsf{ck},a;\\omega_{1})</span>, <span class="math">C_{2}=\\mathsf{CM.Commit}(\\mathsf{ck},b;\\omega_{2})</span>, and <span class="math">C_{3}=\\mathsf{CM.Commit}(\\mathsf{ck},a\\circ b;\\omega_{3})</span>. In other words, <span class="math">C_{3}</span> is a commitment to the Hadamard product of the vectors committed in <span class="math">C_{1}</span> and <span class="math">C_{2}</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 3 (informal).</h6>

    <p class="text-gray-300">The Hadamard product predicate <span class="math">\\Phi_{\\text{\\tiny HP}}</span> has a split accumulation scheme <span class="math">\\mathsf{AS}_{\\text{\\tiny HP}}</span> that is secure in the random oracle model (and assuming the hardness of the discrete logarithm problem) where verifying accumulation requires <span class="math">5</span> group scalar multiplications and <span class="math">O(1)</span> field operations per claim, and results in an accumulator whose instance part is <span class="math">3</span> group elements and witness part is <span class="math">O(\\ell)</span> field elements. Moreover, the accumulation scheme can be made zero knowledge at a sub-constant overhead per claim.</p>

    <p class="text-gray-300">We formalize and prove this theorem in Section 7. Below we summarize the ideas behind this result. Our construction directly extends to accumulate any bilinear function (see Remark 2.6).</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">A bivariate identity.</h4>

    <p class="text-gray-300">The accumulation scheme is based on a bivariate polynomial identity, and is the result of turning a public-coin two-round reduction into a non-interactive scheme by using the random oracle. Given <span class="math">n</span> pairs of vectors <span class="math">[(a_{i},b_{i})]_{i=1}^{n}</span>, consider the following two polynomials with coefficients in <span class="math">\\mathbb{F}^{\\ell}</span>:</p>

    <p class="text-gray-300"><span class="math">a(X,Y):=\\textstyle\\sum_{i=1}^{n}X^{i-1}Y^{i-1}a_{i}\\quad\\text{and}\\quad b(X):=\\textstyle\\sum_{i=1}^{n}X^{n-i}b_{i}\\enspace.</span></p>

    <p class="text-gray-300">The Hadamard product of the two polynomials can be written as</p>

    <p class="text-gray-300"><span class="math">a(X,Y)\\circ b(X)=\\textstyle\\sum_{i=1}^{2n-1}X^{i-1}t_{i}(Y)\\quad\\text{where}\\quad t_{n}(Y)=\\textstyle\\sum_{i=1}^{n}Y^{i-1}a_{i}\\circ b_{i}\\enspace.</span></p>

    <p class="text-gray-300">The expression of the coefficient polynomials <span class="math">\\{t_{i}(Y)\\}_{i\\neq n}</span> is not important; instead, the important aspect here is that a coefficient polynomial, namely <span class="math">t_{n}(Y)</span>, includes the Hadamard products of all <span class="math">n</span> pairs of vectors as different coefficients. This identity is the starting point of the accumulation scheme, which informally evaluates this expression at random points to reduce the <span class="math">n</span> Hadamard products to <span class="math">1</span> Hadamard product. Similar ideas are used to reduce several Hadamard products to a single inner product in <em>[x1, x4]</em>.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Batching Hadamard products.</h4>

    <p class="text-gray-300">We describe a public-coin two-round reduction from <span class="math">n</span> Hadamard product claims to <span class="math">1</span> Hadamard product claim. The verifier receives <span class="math">n</span> predicate instances <span class="math">[\\mathsf{qx}_{i}]_{i=1}^{n}=[(C_{1,i},C_{2,i},C_{3,i})]_{i=1}^{n}</span> each consisting of three Pedersen commitments, and the prover receives corresponding predicate witnesses <span class="math">[\\mathsf{qw}_{i}]_{i=1}^{n}=[(a_{i},b_{i},\\omega_{1,i},\\omega_{2,i},\\omega_{3,i})]_{i=1}^{n}</span> containing the corresponding openings.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier sends a first challenge <span class="math">\\mu\\in\\mathbb{F}</span>.</li>

      <li>The prover computes the product polynomial <span class="math">a(X,\\mu)\\circ b(X)=\\sum_{i=1}^{2n-1}X^{i-1}t_{i}(\\mu)\\in\\mathbb{F}^{\\ell}[X]</span>; for each <span class="math">i\\in[2n-1]\\setminus\\{n\\}</span>, computes the commitment <span class="math">C_{t,i}:=\\mathsf{CM.Commit}(\\mathsf{ck},t_{i};0)\\in\\mathbb{G}</span>; and sends to the verifier an accumulation proof <span class="math">\\mathsf{pf}:=[C_{t,i},C_{t,n+i}]_{i=1}^{n-1}</span>.</li>

      <li>The verifier sends a second challenge <span class="math">\\nu\\in\\mathbb{F}</span>.</li>

      <li>The verifier computes and outputs a new predicate instance <span class="math">\\mathsf{qx}=(C_{1},C_{2},C_{3})</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">C_{1}</span> <span class="math">=\\sum_{i=1}^{n}\\nu^{i-1}\\mu^{i-1}C_{1,i}\\enspace,</span> <span class="math">C_{2}</span> <span class="math">=\\sum_{i=1}^{n}\\nu^{n-i}C_{2,i}\\enspace,</span> <span class="math">C_{3}</span> <span class="math">=\\sum_{i=1}^{n-1}\\nu^{i-1}C_{t,i}+\\nu^{n-1}\\sum_{i=1}^{n}\\mu^{i-1}C_{3,i}+\\sum_{i=1}^{n-1}\\nu^{n+i-1}C_{t,n+i}\\enspace.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes and outputs a corresponding predicate witness <span class="math">\\mathsf{qw}=(a,b,\\omega_{1},\\omega_{2},\\omega_{3})</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">a</span> <span class="math">:=\\sum_{i=1}^{n}\\nu^{i-1}\\mu^{i-1}a_{i}</span> <span class="math">\\omega_{1}</span> <span class="math">:=\\sum_{i=1}^{n}\\nu^{i-1}\\mu^{i-1}\\omega_{1,i}\\enspace,</span> <span class="math">b</span> <span class="math">:=\\sum_{i=1}^{n}\\nu^{n-i}b_{i}</span> <span class="math">\\omega_{2}</span> <span class="math">:=\\sum_{i=1}^{n}\\nu^{n-i}\\omega_{2,i}\\enspace,</span> <span class="math">\\omega_{3}</span> <span class="math">:=\\nu^{n-1}\\sum_{i=1}^{n}\\mu^{i-1}\\omega_{3,i}\\enspace.</span></p>

    <p class="text-gray-300">Observe that the new predicate instance <span class="math">\\mathsf{qx}=(C_{1},C_{2},C_{3})</span> consists of commitments to <span class="math">a(\\nu,\\mu),b(\\nu),a(\\nu,\\mu)\\circ b(\\nu)</span> respectively, and the predicate witness <span class="math">\\mathsf{qw}=(a,b,\\omega_{1},\\omega_{2},\\omega_{3})</span> consists of corresponding opening information. The properties of low-degree polynomials imply that if any of the <span class="math">n</span> claims is incorrect (there is <span class="math">i\\in[n]</span> such that <span class="math">\\Phi_{\\text{\\tiny HP}}(\\mathsf{qx}_{i},\\mathsf{qw}_{i})=0</span>) then, with high probability, so is the output claim (<span class="math">\\Phi_{\\text{\\tiny HP}}(\\mathsf{qx},\\mathsf{qw})=0</span>).</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Split accumulation.</h5>

    <p class="text-gray-300">The batching protocol described above yields a split accumulation scheme for <span class="math">\\Phi_{\\text{\\tiny HP}}</span> in the random oracle model. An accumulator <span class="math">\\mathsf{acc}</span> has the same form as a predicate input <span class="math">(\\mathsf{qx},\\mathsf{qw})</span>: <span class="math">\\mathsf{acc.x}</span> has the same form as a predicate instance <span class="math">\\mathsf{qx}</span>, and <span class="math">\\mathsf{acc.w}</span> has the same form as a predicate witness <span class="math">\\mathsf{qw}</span>. The accumulation decider <span class="math">\\mathrm{D}</span> simply equals <span class="math">\\Phi_{\\text{\\tiny HP}}</span> (this is well-defined due to the prior sentence). The accumulation prover and accumulation verifier are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation prover <span class="math">\\mathrm{P}</span> runs the interactive reduction by relying on the random oracle to generate the random verifier messages (i.e., it applies the Fiat–Shamir transformation to the reduction), in order to produce an accumulation proof <span class="math">\\mathsf{pf}</span> as well as an accumulator <span class="math">\\mathsf{acc}=(\\mathsf{qx},\\mathsf{qw})</span> whose instance part is computed like the verifier of the reduction and witness part is computed like the prover of the reduction.</li>

      <li>The accumulation verifier <span class="math">\\mathrm{V}</span> re-derives the challenges using the random oracle, and checks that <span class="math">\\mathsf{qx}</span> was correctly derived from <span class="math">[\\mathsf{qx}_{i}]_{i=1}^{n}</span> (also via the help of the accumulation proof <span class="math">\\mathsf{pf}</span>).</li>

    </ul>

    <p class="text-gray-300">The construction described above is not zero knowledge. One way to achieve zero knowledge is for the accumulation prover to sample a random predicate input that satisfies the predicate, accumulate it, and include it as part of the accumulation proof <span class="math">\\mathsf{pf}</span>. In our construction (detailed in Section 7), we opt for a more efficient solution, leveraging the fact that we are not actually interested in accumulating the random predicate input.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Efficiency.</h5>

    <p class="text-gray-300">The efficiency claimed in Theorem 3 is evident from the construction. The (short) instance part of an accumulator consists of <span class="math">3</span> group elements, while the (long) witness part of an accumulator consists of <span class="math">O(\\ell)</span> field elements. The accumulator verifier <span class="math">\\mathrm{V}</span> performs <span class="math">2</span> random oracle calls, <span class="math">5</span> group scalar multiplication, and <span class="math">O(1)</span> field operations per accumulated claim.</p>

    <h5 id="sec-29" class="text-base font-semibold mt-4">Security.</h5>

    <p class="text-gray-300">Given an adversary that produces Hadamard product claims <span class="math">[\\mathsf{qx}_{i}]_{i=1}^{n}=[(C_{1,i},C_{2,i},C_{3,i})]_{i=1}^{n}</span>, a single Hadamard product claim <span class="math">\\mathsf{qx}=(C_{1},C_{2},C_{3})</span> and corresponding witness <span class="math">\\mathsf{qw}=(a,b,\\omega_{1},\\omega_{2},\\omega_{3})</span>, and an accumulation proof <span class="math">\\mathsf{pf}</span> that makes the accumulation verifier accept, we need to extract witnesses</p>

    <p class="text-gray-300"><span class="math">[\\mathsf{qw}_i]_{i=1}^n = [(a_i, b_i, \\omega_{1,i}, \\omega_{2,i}, \\omega_{3,i})]_{i=1}^n</span> for the instances <span class="math">[\\mathsf{qx}_i]_{i=1}^n</span>. Our security proof (in Section 7.2) works in the random oracle model, assuming hardness of the discrete logarithm problem.</p>

    <p class="text-gray-300">In the proof we apply our expected-time forking lemma twice (see Section 2.4 for a discussion of this lemma and Section 6.2 for details including a corollary that summarizes its double invocation). This lets us construct a two-level tree of transcripts with branching factor <span class="math">n</span> on the first challenge <span class="math">\\mu</span> and branching factor <span class="math">2n - 1</span> on the second challenge <span class="math">\\nu</span>. Given such a transcript tree, the extractor works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Using the transcripts corresponding to challenges <span class="math">\\{(\\mu_1, \\nu_{1,k})\\}_{k \\in [n]}</span> we extract <span class="math">\\ell</span>-element vectors <span class="math">[a_i]_{i=1}^n</span>, <span class="math">[b_i]_{i=1}^n</span> and field elements <span class="math">[\\omega_{1,i}]_{i=1}^n</span>, <span class="math">[\\omega_{2,i}]_{i=1}^n</span> such that <span class="math">[a_i]_{i=1}^n</span> and <span class="math">[b_i]_{i=1}^n</span> are committed in <span class="math">[C_{1,i}]_{i=1}^n</span> and <span class="math">[C_{2,i}]_{i=1}^n</span> under randomness <span class="math">[\\omega_{1,i}]_{i=1}^n</span> and <span class="math">[\\omega_{2,i}]_{i=1}^n</span>, respectively.</li>

      <li>Define <span class="math">a(X,Y) \\coloneqq \\sum_{i=1}^{n} X^{i-1} Y^{i-1} a_i \\in \\mathbb{F}^\\ell[X,Y]</span> and <span class="math">b(X) \\coloneqq \\sum_{i=1}^{n} X^{n-i} b_i \\in \\mathbb{F}^\\ell[X]</span>, using the vectors extracted above; then let <span class="math">t_i(Y)</span> be the coefficient of <span class="math">X^{i-1}</span> in <span class="math">a(X,Y) \\circ b(X)</span>. For each <span class="math">j \\in [n]</span>, using the transcripts corresponding to challenges <span class="math">\\{(\\mu_j, \\nu_{j,k})\\}_{k \\in [2n-1]}</span>, we extract field elements <span class="math">[\\tau_i^{(j)}]_{i=1}^{2n-1}</span> such that <span class="math">t_n(\\mu_j)</span> is committed in <span class="math">\\sum_{i=1}^{n-1} \\mu_j^{i-1} C_{3,i}</span> under randomness <span class="math">\\tau_n^{(j)}</span> and <span class="math">[t_i(\\mu_j), t_{n+i}(\\mu_j)]_{i=1}^{n-1}</span> are committed in <span class="math">\\mathsf{pf}^{(j)} \\coloneqq [C_{t,i}^{(j)}, C_{t,n+i}^{(j)}]_{i=1}^{n-1}</span> under randomness <span class="math">[\\tau_i^{(j)}, \\tau_{n+i}^{(j)}]_{i=1}^{n-1}</span> respectively.</li>

      <li>Compute the solution <span class="math">[\\omega_{3,i}]_{i=1}^n</span> to the linear system <span class="math">\\{\\tau_n^{(j)} = \\sum_{i=1}^{n-1} \\mu_j^{i-1} \\omega_{3,i}\\}_{j \\in [n]}</span>. Together with the relation <span class="math">\\{t_n(\\mu_j) = \\sum_{i=1}^{n-1} \\mu_j^{i-1} a_i \\circ b_i\\}_{j \\in [n]}</span>, we deduce that <span class="math">C_{3,i}</span> is a commitment to <span class="math">a_i \\circ b_i</span> under randomness <span class="math">\\omega_{3,i}</span> for all <span class="math">i \\in [n]</span>.</li>

      <li>For each <span class="math">i \\in [n]</span>, output <span class="math">\\mathsf{qw}_i := (a_i, b_i, \\omega_{1,i}, \\omega_{2,i}, \\omega_{3,i})</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Remark 2.6 (extension to any bilinear operation).</strong> The ideas described above extend, in a straightforward way, to accumulating any bilinear operation of committed vectors. Let <span class="math">f\\colon \\mathbb{F}^\\ell \\times \\mathbb{F}^\\ell \\to \\mathbb{F}^m</span> be a bilinear operation, i.e., such that: (a) <span class="math">f(a + a&#x27;, b) = f(a, b) + f(a&#x27;, b)</span>; (b) <span class="math">f(a, b + b&#x27;) = f(a, b) + f(a, b&#x27;)</span>; (c) <span class="math">\\alpha \\cdot f(a, b) = f(\\alpha a, b) = f(a, \\alpha b)</span>. Let <span class="math">\\Phi_f</span> be the predicate that takes as input a predicate instance <span class="math">\\mathsf{qx} = (C_1, C_2, C_3) \\in \\mathbb{G}^3</span> consisting of three Pedersen commitments, a predicate witness <span class="math">\\mathsf{qw} = (a, b, \\omega_1, \\omega_2, \\omega_3)</span> consisting of two vectors <span class="math">a, b \\in \\mathbb{F}^\\ell</span> and three opening randomness elements <span class="math">\\omega_1, \\omega_2, \\omega_3 \\in \\mathbb{F}</span>, and checks that <span class="math">C_1 = \\mathsf{CM. Commit}(\\mathsf{ck}_\\ell, a; \\omega_1)</span>, <span class="math">C_2 = \\mathsf{CM. Commit}(\\mathsf{ck}_\\ell, b; \\omega_2)</span>, and <span class="math">C_3 = \\mathsf{CM. Commit}(\\mathsf{ck}_m, f(a, b); \\omega_3)</span>. The Hadamard product <span class="math">\\circ\\colon \\mathbb{F}^\\ell \\times \\mathbb{F}^\\ell \\to \\mathbb{F}^\\ell</span> is a bilinear operation, as is the scalar product <span class="math">\\langle \\cdot, \\cdot \\rangle\\colon \\mathbb{F}^\\ell \\times \\mathbb{F}^\\ell \\to \\mathbb{F}</span>. Our accumulation scheme for Hadamard products works the same way, mutatis mutandis, for a general bilinear map <span class="math">f</span>.</p>

    <h2 id="sec-30" class="text-2xl font-bold">2.6 Split accumulation for Pedersen polynomial commitments</h2>

    <p class="text-gray-300">We construct an efficient split accumulation scheme <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span> for a predicate <span class="math">\\Phi_{\\mathsf{PC}}</span> that checks a polynomial evaluation claim for a "trivial" polynomial commitment scheme <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span> based on Pedersen commitments (see Fig. 5). In more detail, for a Pedersen commitment key ck for messages in <span class="math">\\mathbb{F}^{d+1}</span>, the predicate <span class="math">\\Phi_{\\mathsf{PC}}</span> takes as input a predicate instance <span class="math">\\mathsf{qx} = (C, z, v) \\in \\mathbb{G} \\times \\mathbb{F} \\times \\mathbb{F}</span> and a predicate witness <span class="math">\\mathsf{qw} = p \\in \\mathbb{F}^{\\leq d}[X]</span>, and checks that <span class="math">C = \\mathsf{CM. Commit}(\\mathsf{ck}, p)</span>, <span class="math">p(z) = v</span>, and <span class="math">\\deg(p) \\leq d</span>. In other words, the predicate <span class="math">\\Phi_{\\mathsf{PC}}</span> checks that the polynomial <span class="math">p</span> of degree at most <span class="math">d</span> committed in <span class="math">C</span> evaluates to <span class="math">v</span> at <span class="math">z</span>.</p>

    <p class="text-gray-300"><strong>Theorem 4 (informal).</strong> The (Pedersen) polynomial commitment predicate <span class="math">\\Phi_{\\mathsf{PC}}</span> has a split accumulation scheme <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span> that is secure in the random oracle model (and assuming the hardness of the discrete logarithm problem). Verifying accumulation requires 2 group scalar multiplications and <span class="math">O(1)</span> field additions/multiplications per claim, and results in an accumulator whose instance part is 1 group element and 2 field elements and whose witness part is <span class="math">d</span> field elements. (See Table 1.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: On input  <span class="math">\\lambda, D \\in \\mathbb{N}</span> , output  <span class="math">\\mathsf{pp}_{\\mathsf{CM}} \\gets \\mathsf{CM}. \\mathsf{Setup}(1^{\\lambda}, D + 1)</span> .</li>

      <li>Trim: On input  <span class="math">\\mathsf{pp}_{\\mathsf{CM}}</span>  and  <span class="math">d \\in \\mathbb{N}</span> , check that  <span class="math">d \\leq D</span> , set  <span class="math">\\mathsf{ck} := \\mathsf{CM}.\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{CM}}, d + 1)</span> , and output  <span class="math">(\\mathsf{ck}, \\mathsf{rk} := \\mathsf{ck})</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Commit: On input ck and  <span class="math">p \\in \\mathbb{F}[X]</span>  of degree at most  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{ck}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> , output  </span>C \\gets \\mathsf{CM}.\\mathsf{Commit}(\\mathrm{ck},p)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Open: On input  <span class="math">(\\mathsf{ck},p,C,z)</span> , output  <span class="math">\\pi \\coloneqq p</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Check: On input  <span class="math">(\\mathsf{rk}, (C, z, v), \\pi = p)</span> , check that  <span class="math">C = \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{rk}, p)</span> ,  <span class="math">p(z) = v</span> , and  $\\deg(p) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{rk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Completeness of  </span>\\mathsf{PC}_{\\mathsf{Pad}}$  follows from that of CM, while extractability follows from the binding property of CM.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5:  <span class="math">\\mathsf{PC}_{\\mathsf{Pad}}</span>  is a trivial polynomial commitment scheme based on the Pedersen commitment scheme CM.</p>

    <p class="text-gray-300">One can use  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  to obtain a split accumulation scheme for a different NARK; see Remark 2.7 for details.</p>

    <p class="text-gray-300">In Table 1 we compare the efficiency of our split accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  for the predicate  <span class="math">\\Phi_{\\mathsf{PC}}</span>  with the efficiency of the atomic accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  [BCMS20] for the equivalent predicate defined by the check algorithm of the (succinct) PC scheme  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span>  based on the inner-product argument on cyclic groups [BCCGP16; BBBPWM18; WTSTW18]. The takeaway is that the accumulation verifier for  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  is significantly cheaper than the accumulation verifier for  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span> .</p>

    <p class="text-gray-300">Technical details are in Appendix A; in the rest of this section we sketch the ideas behind Theorem 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulation scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulation prover (per claim)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulation verifier (per claim)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulation decider</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulator size instance</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">witness</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ASIPA [BCMS20]</td>

            <td class="px-3 py-2 border-b border-gray-700">atomic</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG + RO †</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log d) G O(d) F [+O(d) G per accumulation]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log d) G O(log d) F O(log d) RO</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d) G O(d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G O(log d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ASPC [this work]</td>

            <td class="px-3 py-2 border-b border-gray-700">split</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG + RO</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d) G O(d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G O(1) F 2 RO</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d) G O(d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G 2 F</td>

            <td class="px-3 py-2 border-b border-gray-700">d F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Efficiency comparison between the atomic accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  for  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span>  in [BCMS20] and the split accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  for  <span class="math">\\mathsf{PC}_{\\mathsf{Pad}}</span>  in this work. Above  <span class="math">\\mathbb{G}</span>  denotes group scalar multiplications or group elements, and  <span class="math">\\mathbb{F}</span>  denotes field operations or field elements. ( <span class="math">\\dagger</span> :  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  relies on knowledge soundness of  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span> , which results from applying the Fiat-Shamir transformation to a logarithmic-round protocol. The security of this protocol has only been proven via a superpolynomial-time extractor [BMMTV19] or in the algebraic group model [GT20].)</p>

    <p class="text-gray-300">First we describe a simple public-coin interactive reduction for combining two or more evaluation claims into a single evaluation claim, and then explain how this interactive reduction gives rise to the split accumulation scheme. We prove security in the random oracle model, using an expected-time extractor.</p>

    <p class="text-gray-300">Batching evaluation claims. First consider two evaluation claims  <span class="math">(C_1, z, v_1)</span>  and  <span class="math">(C_2, z, v_2)</span>  for the same evaluation point  <span class="math">z</span>  (and degree  <span class="math">d</span> ). We can use a random challenge  <span class="math">\\alpha \\in \\mathbb{F}</span>  to combine these claims into one claim  <span class="math">(C&#x27;, z, v&#x27;)</span>  where  <span class="math">C&#x27; := C_1 + \\alpha C_2</span>  and  <span class="math">v&#x27; := v_1 + \\alpha v_2</span> . If either of the original claims does not hold then, with high probability over the choice of  <span class="math">\\alpha</span> , neither does the new claim. This idea extends to any number of claims for the same evaluation point, by taking  <span class="math">C&#x27; := \\sum_i \\alpha^i C_i</span>  and  <span class="math">v&#x27; := \\sum_i \\alpha^i v_i</span> .</p>

    <p class="text-gray-300">Next consider two evaluation claims  <span class="math">(C_1, z_1, v_1)</span>  and  <span class="math">(C_2, z_2, v_2)</span>  at (possibly) different evaluation points  <span class="math">z_1</span>  and  <span class="math">z_2</span> . We explain how these can be combined into four claims all at the same point. Below we use the fact that  <span class="math">p(z) = v</span>  if and only if there exists a polynomial  <span class="math">w(X)</span>  such that  <span class="math">p(X) = w(X) \\cdot (X - z) + v</span> .</p>

    <p class="text-gray-300">Let  <span class="math">p_1(X)</span>  and  <span class="math">p_2(X)</span>  be the polynomials "inside"  <span class="math">C_1</span>  and  <span class="math">C_2</span> , respectively, that are known to the prover.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes the witness polynomials  <span class="math">w_{1} \\coloneqq \\frac{p_{1}(X) - v_{1}}{X - z_{1}}</span>  and  <span class="math">w_{2} \\coloneqq \\frac{p_{2}(X) - v_{2}}{X - z_{2}}</span>  and sends the commitments  <span class="math">W_{1} \\coloneqq \\operatorname{Commit}(w_{1})</span>  and  <span class="math">W_{2} \\coloneqq \\operatorname{Commit}(w_{2})</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier sends a random evaluation point <span class="math">z^{*}\\in\\mathbb{F}</span>.</li>

      <li>The prover computes and sends the evaluations <span class="math">y_{1}:=p_{1}(z^{<em>}),y_{2}:=p_{2}(z^{</em>}),y_{1}^{\\prime}:=w_{1}(z^{<em>}),y_{2}^{\\prime}:=w_{2}(z^{</em>})</span>.</li>

      <li>The verifier checks the relation between each witness polynomial and the original polynomial at the random evaluation point <span class="math">z^{*}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">y_{1}=y_{1}^{\\prime}\\cdot(z^{<em>}-z_{1})+y_{1}^{\\prime}\\quad\\text{and}\\quad y_{2}=y_{2}^{\\prime}\\cdot(z^{</em>}-z_{2})+y_{2}^{\\prime}\\enspace.</span></p>

    <p class="text-gray-300">Next, the verifier outputs four evaluation claims for <span class="math">p_{1}(z^{<em>})=y_{1},p_{2}(z^{</em>})=y_{2},w_{1}(z^{<em>})=y_{1}^{\\prime},w_{2}(z^{</em>})=y_{2}^{\\prime}</span>:</p>

    <p class="text-gray-300"><span class="math">(C_{1},z^{<em>},y_{1})\\ ,\\ (C_{2},z^{</em>},y_{2})\\ ,\\ (W_{1},z^{<em>},y_{1}^{\\prime})\\ ,\\ (W_{2},z^{</em>},y_{2}^{\\prime})\\ .</span></p>

    <p class="text-gray-300">More generally, we can reduce <span class="math">m</span> evaluation claims at <span class="math">m</span> points to <span class="math">2m</span> evaluation claims all at the same point.</p>

    <p class="text-gray-300">By combining the two techniques, one obtains a public-coin interactive reduction from any number of evaluation claims (regardless of evaluation points) to a single evaluation claim.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Split accumulation.</h5>

    <p class="text-gray-300">The batching protocol described above yields a split accumulation scheme for <span class="math">\\Phi_{\\textsc{pc}}</span> in the random oracle model. An accumulator acc has the same form as a predicate input: the instance part is an evaluation claim and the witness part is a polynomial. Next we describe the algorithms of the accumulation scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation prover <span class="math">\\mathrm{P}</span> runs the interactive reduction by relying on the random oracle to generate the random verifier messages (i.e., it applies the Fiat–Shamir transformation to the reduction), in order to combine the instance parts of old accumulators and inputs to obtain the instance part of a new accumulator. Then <span class="math">\\mathrm{P}</span> also combines the committed polynomials using the same linear combinations in order to derive the new committed polynomial, which is the witness part of the new accumulator. The accumulation proof <span class="math">\\mathsf{pf}</span> consists of the messages to the verifier in the reduction, which includes the commitments to the witness polynomials <span class="math">W_{i}</span> and the evaluations <span class="math">y_{i},y_{i}^{\\prime}</span> at <span class="math">z^{*}</span> of <span class="math">p_{i},w_{i}</span> (that is, <span class="math">\\mathsf{pf}:=[(W_{i},y_{i},y_{i}^{\\prime})]_{i=1}^{n}</span>).</li>

      <li>The accumulation verifier <span class="math">\\mathrm{V}</span> checks that the challenges were correctly computed from the random oracle, and performs the checks of the reduction (the claims were correctly combined and that the proper relation between each <span class="math">y_{i},y_{i}^{\\prime},z_{i},z^{*}</span> holds).</li>

      <li>The accumulation decider <span class="math">\\mathrm{D}</span> reads the accumulator in its entirety and checks that the polynomial (the witness part) satisfies the evaluation claim (the instance part). (Here the random oracle is not used.)</li>

    </ul>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Efficiency.</h5>

    <p class="text-gray-300">The efficiency claimed in Theorem 4 (and Table 1) is evident from the construction. The accumulation prover <span class="math">\\mathrm{P}</span> computes <span class="math">n+m</span> commitments to polynomials when combining <span class="math">n</span> old accumulators and <span class="math">m</span> predicate inputs (all polynomials are for degree at most <span class="math">d</span>). The (short) instance part of an accumulator consists of <span class="math">1</span> group element and <span class="math">2</span> field elements, while the (long) witness part of an accumulator consists of <span class="math">O(d)</span> field elements. The accumulator decider <span class="math">\\mathrm{D}</span> computes <span class="math">1</span> commitment (and <span class="math">1</span> polynomial evaluation at <span class="math">1</span> point) in order to validate an accumulator. Finally, the cost of running the accumulator verifier <span class="math">\\mathrm{V}</span> is dominated by <span class="math">2(n+m)</span> scalar multiplication of the linear commitments.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Security.</h5>

    <p class="text-gray-300">Given an adversary that produces evaluation claims <span class="math">[\\mathsf{qx}_{i}]_{i=1}^{n}=[(C_{i},z_{i},v_{i})]_{i=1}^{n}</span>, a single claim <span class="math">\\mathsf{qx}=(C,z,v)</span> and polynomial <span class="math">\\mathsf{qw}=s(X)</span> with <span class="math">s(z^{*})=v</span> to which <span class="math">C</span> is a commitment, and accumulation proof <span class="math">\\mathsf{pf}</span> that makes the accumulation verifier accept, we need to extract polynomials <span class="math">[\\mathsf{qw}_{i}]_{i=1}^{n}=[p_{i}(X)]_{i=1}^{n}</span> with <span class="math">p_{i}(z_{i})=v_{i}</span> to which <span class="math">C_{i}</span> is a commitment. Our security proof (in Appendix A.3.1) works in the random oracle model, assuming hardness of the discrete logarithm problem.</p>

    <p class="text-gray-300">In the proof, we apply our expected-time forking lemma (see Sections 2.4 and 6.2) to obtain <span class="math">2n</span> polynomials <span class="math">[s^{(j)}]^{2n}_{j=1}</span> for the same evaluation point <span class="math">z^{<em>}</span> but distinct challenges <span class="math">\\alpha_{j}</span>, where <span class="math">n</span> is the number of evaluation claims. The checks in the reduction procedure imply that <span class="math">s^{(j)}(X)=\\sum_{i=1}^{n}\\alpha_{j}^{i}p_{i}(X)+\\sum_{i=1}^{n}\\alpha_{j}^{n+i}w_{i}(X)</span>, where <span class="math">w_{i}(X)</span> is the witness corresponding to <span class="math">p_{i}(X)</span>; hence we can recover the <span class="math">p_{i}(X),w_{i}(X)</span> by solving a linear system (given by the Vandermonde matrix in the challenges <span class="math">[\\alpha_{j}]^{2n}_{j=1}</span>). We then use an expected-time variant of the zero-finding game lemma from </em>[x1]<em> (see Appendix A.2) to show that if a particular polynomial equation on <span class="math">p_{i}(X),w_{i}(X)</span> holds at the point <span class="math">z^{</em>}</span> obtained from the random oracle, it must with overwhelming probability be an identity. Applying this to the equation induced by the reduction shows that, with high probability, each extracted polynomial <span class="math">p_{i}</span> satisfies the corresponding evaluation claim <span class="math">(C_{i},z_{i},v_{i})</span>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Remark 2.7 (from <span class="math">\\mathsf{PC_{Ped}}</span> to an accumulatable NARK).</h6>

    <p class="text-gray-300">If one replaced the (succinct) polynomial commitment scheme that underlies the preprocessing zkSNARK in <em>[x10]</em> with the aforementioned (non-succinct) trivial Pedersen polynomial commitment scheme then (after some adjustments and using our Theorem 4) one would obtain a zkNARK for R1CS with a split accumulation scheme whose accumulation verifier <em>is</em> of constant size but other asymptotics would be worse compared to Theorem 2.</p>

    <p class="text-gray-300">First, the cryptographic costs and the quasilinear costs of the NARK and accumulation scheme would also grow in the number <span class="math">\\mathsf{K}</span> of non-zero entries in the coefficient matrices, which can be much larger than <span class="math">\\mathsf{M}</span> and <span class="math">\\mathsf{N}</span> (asymptotically and concretely). Second, the NARK prover would additionally use a quasilinear number of field operations due to FFTs. Finally, in addition to poorer asymptotics, this approach would lead to a concretely more expensive accumulation verifier and overall a more complex protocol.</p>

    <p class="text-gray-300">Nevertheless, one <em>can</em> design a concretely efficient zkNARK for R1CS based on the Pedersen PC scheme and our accumulation scheme for it. This naturally leads to an alternative construction to the one in Section 2.3 (which is instead based on accumulation of Hadamard products), and would lead to a slightly more expensive prover (which now would use FFTs) and a slightly cheaper accumulation verifier (a smaller number of group scalar multiplications). We leave this as an exercise for the interested reader.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">2.7 Implementation and evaluation</h3>

    <p class="text-gray-300">We elaborate on our implementation and evaluation of accumulation schemes and their application to PCD.</p>

    <h5 id="sec-36" class="text-base font-semibold mt-4">The case for a PCD framework.</h5>

    <p class="text-gray-300">Different PCD constructions offer different trade-offs. The tradeoffs are both about asymptotics (see Remark 2.4) and about practical concerns, as we review below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>PCD from sublinear verification <em>[x7, x8, x11]</em> is typically instantiated via preprocessing SNARKs based on pairings. This route offers excellent verifier time (a few milliseconds regardless of the computation at a PCD node), but requires a private-coin setup (which complicates deployment) and cycles of pairing-friendly elliptic curves (which are costly in terms of group arithmetic and size).</li>

      <li>PCD from atomic accumulation <em>[x11]</em> can, e.g., be instantiated via SNARKs based on cyclic groups <em>[x12]</em>. This route offers a transparent setup (easy to deploy) and logarithmic-size arguments (a few kilobytes even for large computations), using cycles of standard elliptic curves (more efficient than their pairing-friendly counterparts). On the other hand, this route yields linear verification times (expensive for large computations) and logarithmic costs for accumulation (increasing the cost of recursion).</li>

      <li>PCD from split accumulation (this work) can, e.g., be instantiated via NARKs based on cyclic groups. This route still offers a transparent setup and allows using cycles of standard elliptic curves. Moreover, it offers constant costs for accumulation, but at the expense of argument size, which is now linear.</li>

    </ul>

    <p class="text-gray-300">It would be desirable to have a single framework that supports different PCD constructions via a modular composition of simpler building blocks. Such a framework would enable a number of desirable features: (a) ease of replacing older building blocks with new ones; (b) ease of prototyping different PCD constructions for different applications (which may have different needs), thereby enabling practitioners to make informed choices about which PCD construction is best for them; (c) simpler and more efficient auditing of complex cryptographic systems with many intermixed layers. (Realizing even a single PCD construction is a substantial implementation task.); and (d) separation of “application” logic from the underlying recursion via a common PCD interface. Together, these features would enable further industrial deployment of PCD, as well as making future research and comparisons simpler.</p>

    <p class="text-gray-300">Implementation (Section 9). The above considerations motivated our implementation efforts for PCD. Our code base has two main parts, one for realizing accumulation schemes and another for realizing PCD from accumulation (the latter is integrated with PCD from succinct verification under a unified PCD interface).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Framework for accumulation. We designed a modular framework for (atomic and split) accumulation schemes, and use it to implement, under a common interface, several accumulation schemes: (a) the atomic accumulation scheme <span class="math">\\mathsf{AS}_{\\text{AGM}}</span> in <em>[x1]</em> for the PC scheme <span class="math">\\mathsf{PC}_{\\text{AGM}}</span>; (b) the atomic accumulation scheme <span class="math">\\mathsf{AS}_{\\text{IPA}}</span> in <em>[x1]</em> for the PC scheme <span class="math">\\mathsf{PC}_{\\text{IPA}}</span>; (c) the split accumulation scheme <span class="math">\\mathsf{AS}_{\\text{PC}}</span> in this paper for the PC scheme <span class="math">\\mathsf{PC}_{\\text{Pad}}</span>; (d) the split accumulation scheme <span class="math">\\mathsf{AS}_{\\text{HP}}</span> in this paper for the Hadamard product predicate <span class="math">\\Phi_{\\text{HP}}</span>; (e) the split accumulation scheme for our NARK for R1CS. Our framework also provides a generic method for defining R1CS constraints for the verifiers of these accumulation schemes; we leverage this to implement R1CS constraints for all of these accumulation schemes.</li>

      <li>PCD from accumulation. We use the foregoing framework to implement a generic construction of PCD from accumulation. We support the PCD construction of <em>[x1]</em> (which uses atomic accumulation) and the PCD construction in this paper (which uses split accumulation). Our code builds on, and extends, an existing PCD library. Our implementation is modular: it takes as ingredients an implementation of any NARK, an implementation of any accumulation scheme for that NARK, and constraints for the accumulation verifier, and produces a concrete PCD construction. This allows us, for example, to obtain a PCD instantiation based on our NARK for R1CS and its split accumulation scheme.</li>

    </ul>

    <p class="text-gray-300">Evaluation for DL setting (Section 10). When realizing PCD in practice the main goal is to “minimize the cost of recursion”, that is, to minimize the number of constraints that need to be recursively proved in each PCD step (excluding the constraints for the application) without hurting other parameters too much (prover time, argument size, and so on). We evaluate our implementation with respect to this goal, with a focus on understanding the trade-offs between atomic and split accumulation in the discrete logarithm setting.</p>

    <p class="text-gray-300">The DL setting is of particular interest to practitioners, as it leads to systems with a transparent (public-coin) setup that can be based on efficient cycles of (standard) elliptic curves <em>[x2, x14]</em>; indeed, some projects are developing real-world systems that use PCD in the DL setting <em>[x11, Pickles20]</em>. The main drawback of the DL setting is that verification time (and sometimes argument size) is linear in a PCD node’s computation. This inefficiency is, however, tolerable if a PCD node’s computation is not too large, as is the case in the aforementioned projects. (Especially so when taking into account the disadvantages of PCD based on pairings, which involves relying on a private-coin setup and more expensive curve cycles.)</p>

    <p class="text-gray-300">We evaluate our implementation to answer two questions: (a) how efficient is recursion with split accumulation for our simple zkNARK for R1CS? (b) what is the constraint cost of split accumulation for</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PC}_{\\textsf{Red}}</span> compared to atomic accumulation for <span class="math">\\mathsf{PC}_{\\textsf{IPA}}</span>? All our experiments are performed over the 255-bit Pallas curve in the Pasta cycle of curves <em>[x11]</em>, which is used by real-world deployments.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Split accumulation for R1CS. Our evaluation demonstrates that the cost of recursion for IVC with our split accumulation scheme for the simple NARK for R1CS is low, both with zero knowledge (<span class="math">\\sim 99\\times 10^{3}</span> constraints) and without (<span class="math">\\sim 52\\times 10^{3}</span> constraints). In fact, this cost is even lower than the cost of IVC based on highly efficient pairing-based circuit-specific SNARKs. Furthermore, like in the pairing-based case, this cost does not grow with the size of computation being checked. This is much better than prior constructions of IVC based on atomic accumulation for <span class="math">\\mathsf{PC}_{\\textsf{IPA}}</span> in the DL setting, as we will see next.</li>

      <li>Comparison of accumulation for PC schemes. Several (S)NARKs are built from PC schemes, and the primary cost of recursion for these is determined by the cost of accumulation for the PC scheme. In light of this we compare the costs of two accumulation schemes:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the atomic accumulation scheme for the PC scheme <span class="math">\\mathsf{PC}_{\\textsf{IPA}}</span> <em>[x5]</em>;</li>

      <li>the split accumulation scheme for <span class="math">\\mathsf{PC}_{\\textsf{Red}}</span> (Appendix A).</li>

    </ul>

    <p class="text-gray-300">Our evaluation demonstrates that the constraint cost of the <span class="math">\\mathsf{AS}_{\\textsf{PC}}</span> accumulation verifier is <span class="math">8</span> to <span class="math">20</span> times cheaper than that of the <span class="math">\\mathsf{AS}_{\\textsf{IPA}}</span> accumulation verifier.</p>

    <p class="text-gray-300">We note that the cost of all the aforementioned accumulation schemes is dominated by the cost of many common subcomponents, and so improvements in these subcomponents will preserve the relative cost. For example, applying existing techniques <em>[x12, Pickles20]</em> for optimizing the constraint cost of elliptic curve scalar multiplications should benefit all our schemes in a similar way.</p>

    <p class="text-gray-300">Indexed relations. An indexed relation  <span class="math">\\mathcal{R}</span>  is a set of triples  <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span>  where  <span class="math">\\dot{\\mathfrak{s}}</span>  is the index,  <span class="math">\\mathfrak{x}</span>  is the instance, and  <span class="math">\\mathfrak{w}</span>  is the witness; the corresponding indexed language  <span class="math">\\mathcal{L}(\\mathcal{R})</span>  is the set of pairs  <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x})</span>  for which there exists a witness  <span class="math">\\mathfrak{w}</span>  such that  <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})\\in \\mathcal{R}</span> . For example, the indexed relation of satisfiable boolean circuits consists of triples where  <span class="math">\\dot{\\mathfrak{s}}</span>  is the description of a boolean circuit,  <span class="math">\\mathfrak{x}</span>  is a partial assignment to its input wires, and  <span class="math">\\mathfrak{w}</span>  is an assignment to the remaining wires that makes the boolean circuit output 0.</p>

    <p class="text-gray-300">Security parameters. For simplicity of notation, we assume that all public parameters have length at least  <span class="math">\\lambda</span> , so that algorithms which receive such parameters can run in time  <span class="math">\\mathrm{poly}(\\lambda)</span> .</p>

    <p class="text-gray-300">Random oracles. We denote by  <span class="math">\\mathcal{U}(\\lambda)</span>  the set of all functions that map  <span class="math">\\{0,1\\}^<em></span>  to  <span class="math">\\{0,1\\}^\\lambda</span> . We denote by  <span class="math">\\mathcal{U}(</em>)</span>  the set  <span class="math">\\bigcup_{\\lambda \\in \\mathbb{N}} \\mathcal{U}(\\lambda)</span> . A random oracle with security parameter  <span class="math">\\lambda</span>  is a function  <span class="math">\\rho: \\{0,1\\}^* \\to \\{0,1\\}^\\lambda</span>  sampled uniformly at random from  <span class="math">\\mathcal{U}(\\lambda)</span> .</p>

    <p class="text-gray-300">Adversaries. All of the definitions in this paper should be taken to refer to non-uniform adversaries. An adversary (or extractor) running in expected polynomial time is then a Turing machine provided with a polynomial-size non-uniform advice string and access to an infinite random tape, whose expected running time for all choices of advice is polynomial. We sometimes write  <span class="math">(\\mathsf{o};r)\\gets A(x)</span>  when  <span class="math">A</span>  is an expected polynomial-time algorithm, where  <span class="math">\\mathsf{o}</span>  is  <span class="math">A</span> 's output and  <span class="math">r</span>  is the randomness used by  <span class="math">A</span>  (i.e., up to the rightmost position of the head on the randomness tape). We also write  <span class="math">(\\mathsf{o},r^{\\prime})\\gets A(x;r)</span> , where  <span class="math">r</span>  is a string of finite length: this denotes executing  <span class="math">A</span>  with an infinite random tape with prefix  <span class="math">r</span>  and  <span class="math">r^\\prime</span>  is the randomness used by  <span class="math">A</span>  (and in particular its prefix is consistent with  <span class="math">r</span> ). Finally, we write  <span class="math">\\mathsf{o}\\gets A(x;\\sigma)</span>  where  <span class="math">\\sigma \\in \\{0,1\\}^{*}</span>  is an infinite string representing the entire random tape.</p>

    <p class="text-gray-300">A tuple of algorithms  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  is a (preprocessing) non-interactive argument in the random oracle model (ROM) for an indexed relation family  <span class="math">\\{\\mathcal{R}_{\\mathsf{pp}}\\}_{\\mathsf{pp}}</span>  if the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every adversary  <span class="math">\\mathcal{A}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\dot {\\mathfrak {s}}, \\mathfrak {x}, \\mathfrak {w}) \\notin \\mathcal {R} _ {\\mathsf {p p}} \\\\ \\vee \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathfrak {x}, \\pi) = 1 \\end{array} \\right] \\begin{array}{c} \\mathfrak {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ (\\dot {\\mathfrak {s}}, \\mathfrak {x}, \\mathfrak {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\dot {\\mathfrak {s}}) \\\\ \\pi \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathrm {i p k}, \\mathfrak {x}, \\mathfrak {w}) \\end{array} \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For every polynomial-size adversary  <span class="math">\\tilde{\\mathcal{P}}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\dot {\\mathfrak {s}}, \\mathfrak {x}) \\notin \\mathcal {L} (\\mathcal {R} _ {\\mathsf {p p}}) &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathfrak {x}, \\pi) = 1 &amp;amp; (\\dot {\\mathfrak {s}}, \\mathfrak {x}, \\pi) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\dot {\\mathfrak {s}}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">Completeness allows  <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span>  to depend adversarially on the random oracle  <span class="math">\\rho</span>  and public parameters pp; and soundness allows  <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x})</span>  to depend adversarially on the random oracle  <span class="math">\\rho</span>  and public parameters pp.</p>

    <p class="text-gray-300">Our PCD construction makes use of the stronger property of knowledge soundness, and optionally also the property of (statistical) zero knowledge. We define both of these properties below.</p>

    <p class="text-gray-300">We refer to an argument with knowledge soundness as a NARK (non-interactive argument of knowledge) whereas an argument that just satisfies soundness is a NARG.</p>

    <p class="text-gray-300">Knowledge soundness.  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has knowledge soundness (with respect to auxiliary input distribution  <span class="math">\\mathcal{D}</span> ) if for every expected polynomial time adversary  <span class="math">\\tilde{\\mathcal{P}}</span>  there exists an expected polynomial time extractor  <span class="math">\\mathcal{E}</span>  such that for every set  <span class="math">Z</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathsf {p p}, \\mathsf {a i}, \\vec {\\mathrm {i}}, \\vec {\\mathrm {x}}, \\mathsf {a o}) \\in Z &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\wedge \\forall j \\in [ \\ell ], (\\dot {\\mathrm {i}} _ {j}, \\mathrm {x} _ {j}, \\mathrm {w} _ {j}) \\in \\mathcal {R} _ {\\mathsf {p p}} &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (\\mathsf {p p}) \\\\ &amp;amp; (\\vec {\\mathrm {i}}, \\vec {\\mathrm {x}}, \\vec {\\mathrm {w}}, \\mathsf {a o}) \\leftarrow \\mathcal {E} _ {\\tilde {\\mathcal {P}}} (\\mathsf {p p}, \\mathsf {a i}) \\end{array} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathsf {p p}, \\mathsf {a i}, \\vec {\\mathrm {i}}, \\vec {\\mathrm {x}}, \\mathsf {a o}) \\in Z &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\wedge \\forall j \\in [ \\ell ], \\mathcal {V} ^ {\\rho} (\\mathrm {i v k} _ {j}, \\mathrm {x} _ {j}, \\pi_ {j}) = 1 &amp;amp; \\mathrm {a i} \\leftarrow \\mathcal {D} (\\mathsf {p p}) \\\\ &amp;amp; (\\vec {\\mathrm {i}}, \\vec {\\mathrm {x}}, \\vec {\\pi}, \\mathsf {a o}) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {a i}) \\\\ &amp;amp; \\forall j \\in [ \\ell ], (\\mathrm {i p k} _ {j}, \\mathrm {i v k} _ {j}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\dot {\\mathrm {i}} _ {j}) \\end{array} \\right] - \\operatorname {n e g l} (\\lambda) . \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Remark 3.1. The definition of knowledge soundness that we use is stronger than usual, to prove post-quantum security in Theorem 5.3. This stronger definition is similar to witness-extended emulation [Lin03].</p>

    <p class="text-gray-300">Zero knowledge.  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator  <span class="math">S</span>  such that for every honest adversary  <span class="math">\\mathcal{A}</span>  (on input pp it only outputs triples in the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{pp}}</span> ) the distributions below are statistically close:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{( \\rho , \\mathsf {p p}, \\dot {\\mathfrak {i}}, \\mathfrak {x}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathsf {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathfrak {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\dot {\\mathfrak {i}}) \\\\ \\pi \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathrm {i p k}, \\mathfrak {x}, \\mathfrak {w}) \\end{array} \\right. \\right\\} \\quad \\text {a n d} \\quad \\left\\{ \\begin{array}{c} \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathsf {p p}, \\tau) \\leftarrow \\mathcal {S} ^ {\\rho} (1 ^ {\\lambda}) \\\\ (\\dot {\\mathfrak {i}}, \\mathfrak {x}, \\mathfrak {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ (\\pi , \\mu) \\leftarrow \\mathcal {S} ^ {\\rho} (\\tau , \\dot {\\mathfrak {i}}, \\mathfrak {x}) \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Above,  <span class="math">\\rho[\\mu]</span>  is the function that, on input  <span class="math">x</span> , equals  <span class="math">\\mu(x)</span>  if  <span class="math">\\mu</span>  is defined on  <span class="math">x</span> , or  <span class="math">\\rho(x)</span>  otherwise. This definition uses explicitly-programmable random oracles [BR93]. (Non-interactive zero knowledge with non-programmable random oracles is impossible for non-trivial languages [Pas03; BCS16].)</p>

    <p class="text-gray-300">A triple of algorithms  <span class="math">\\mathsf{PCD} = (\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V})</span>  is a (preprocessing) proof-carrying data scheme (PCD scheme) for a class of compliance predicates  <span class="math">\\mathsf{F}</span>  if the properties below hold.</p>

    <p class="text-gray-300">Definition 3.2. A transcript  <span class="math">\\mathsf{T}</span>  is a directed acyclic graph where each vertex  <span class="math">u\\in V(\\mathsf{T})</span>  is labeled by local data  <span class="math">z_{\\mathrm{loc}}^{(u)}</span>  and each edge  <span class="math">e\\in E(\\mathsf{T})</span>  is labeled by a message  <span class="math">z^{(e)}\\neq \\bot</span> . The output of a transcript  <span class="math">\\mathsf{T}</span> , denoted  <span class="math">\\mathsf{o}(\\mathsf{T})</span> , is  <span class="math">z^{(e)}</span>  where  <span class="math">e = (u,v)</span>  is the lexicographically-first edge such that  <span class="math">v</span>  is a sink.</p>

    <p class="text-gray-300">Definition 3.3. A vertex  <span class="math">u \\in V(\\mathsf{T})</span>  is  <span class="math">\\varphi</span> -compliant for  <span class="math">\\varphi \\in \\mathsf{F}</span>  if for all outgoing edges  <span class="math">e = (u, v) \\in E(\\mathsf{T})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(base case) if  <span class="math">u</span>  has no incoming edges,  <span class="math">\\varphi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, \\bot, \\ldots, \\bot)</span>  accepts;</li>

      <li>(recursive case) if  <span class="math">u</span>  has incoming edges  <span class="math">e_1, \\ldots, e_m</span> ,  <span class="math">\\varphi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, z^{(e_1)}, \\ldots, z^{(e_m)})</span>  accepts.</li>

    </ul>

    <p class="text-gray-300">We say that  <span class="math">\\mathsf{T}</span>  is  <span class="math">\\varphi</span> -compliant if all of its vertices are  <span class="math">\\varphi</span> -compliant.</p>

    <p class="text-gray-300">Completeness. PCD has perfect completeness if for every adversary  <span class="math">\\mathcal{A}</span>  the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\varphi \\in \\mathsf {F} &amp;amp; \\mathfrak {p} \\mathfrak {p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ \\wedge \\varphi (z, z _ {\\mathrm {l o c}}, z _ {1}, \\ldots , z _ {m}) = 1 &amp;amp; (\\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathfrak {p p}) \\\\ \\wedge (\\forall i, z _ {i} = \\bot \\lor \\forall i, \\mathbb {V} (\\mathsf {i v k}, z _ {i}, \\pi_ {i}) = 1) &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathbb {I} (\\mathfrak {p p}, \\varphi) \\\\ \\Downarrow &amp;amp; \\pi \\leftarrow \\mathbb {P} (\\mathsf {i p k}, z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Knowledge soundness. PCD has knowledge soundness (with respect to auxiliary input distribution  <span class="math">\\mathcal{D}</span> ) if for every expected polynomial-time adversary  <span class="math">\\tilde{\\mathbb{P}}</span>  there exists an expected polynomial-time extractor  <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span>  such that for every set  <span class="math">Z</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} \\varphi \\in \\mathsf {F} &amp;amp; \\mathfrak {p} \\mathfrak {p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ \\wedge (\\mathfrak {p} \\mathfrak {p}, \\mathsf {a i}, \\varphi , \\mathsf {o} (\\mathsf {T}), \\mathsf {a o}) \\in Z &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (\\mathfrak {p} \\mathfrak {p}) \\\\ \\wedge \\mathsf {T} \\text {i s} \\varphi \\text {- c o m p l i a n t} &amp;amp; (\\varphi , \\mathsf {T}, \\mathsf {a o}) \\leftarrow \\mathbb {E} _ {\\tilde {\\mathbb {P}}} (\\mathfrak {p} \\mathfrak {p}, \\mathsf {a i}) \\end{array} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c c} \\varphi \\in \\mathsf {F} &amp;amp; \\mathfrak {p} \\mathfrak {p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ \\wedge (\\mathfrak {p} \\mathfrak {p}, \\mathsf {a i}, \\varphi , \\mathsf {o}, \\mathsf {a o}) \\in Z &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (\\mathfrak {p} \\mathfrak {p}) \\\\ \\wedge \\mathcal {V} (\\mathsf {i v k}, \\mathsf {o}, \\pi) = 1 &amp;amp; (\\varphi , \\mathsf {o}, \\pi , \\mathsf {a o}) \\leftarrow \\tilde {\\mathbb {P}} (\\mathfrak {p} \\mathfrak {p}, \\mathsf {a i}) \\\\ &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathbb {I} (\\mathfrak {p} \\mathfrak {p}, \\varphi) \\end{array} \\right] - \\operatorname {n e g l} (\\lambda) . \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Zero knowledge. PCD has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator  <span class="math">\\mathbb{S}</span>  such that for every honest adversary  <span class="math">\\mathcal{A}</span>  the distributions below are statistically close:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{c} \\mathfrak {p p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ (\\mathfrak {p p}, \\varphi , z, \\pi) \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathfrak {p p}) \\\\ (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathbb {I} (\\mathfrak {p p}, \\varphi) \\\\ \\pi \\leftarrow \\mathbb {P} (\\mathsf {i p k}, z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\end{array} \\right\\} \\text {a n d} \\left\\{ \\begin{array}{c} (\\mathfrak {p p}, \\varphi , z, \\pi) \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathfrak {p p}, \\tau) \\leftarrow \\mathbb {S} (1 ^ {\\lambda}) \\\\ (\\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathfrak {p p}) \\\\ \\pi \\leftarrow \\mathbb {S} (\\tau , \\varphi , z) \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">An adversary is honest if its output satisfies the implicant of the completeness condition with probability 1, namely:  <span class="math">\\varphi \\in \\mathsf{F}</span> ,  <span class="math">\\varphi(z, z_{\\mathrm{loc}}, z_1, \\ldots, z_m) = 1</span> , and either  <span class="math">\\forall i</span> ,  <span class="math">z_i = \\bot</span>  or  <span class="math">\\forall i</span> ,  <span class="math">\\mathbb{V}(\\mathsf{ivk}, z_i, \\pi_i) = 1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The generator  <span class="math">\\mathbb{G}</span> , prover  <span class="math">\\mathbb{P}</span> , indexer  <span class="math">\\mathbb{I}</span> , and verifier  <span class="math">\\mathbb{V}</span>  run in polynomial time. A proof  <span class="math">\\pi</span>  has size  $\\mathrm{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> ; in particular, it is not permitted to grow with each application of  </span>\\mathbb{P}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Almost all results in this paper are proved in the random oracle model, and so we give definitions which include random oracles. The single exception is our construction of proof-carrying data, in Section 5.1. We do not know how to build PCD schemes which are secure in the random oracle model from any standard assumption. Instead, we show that assuming the existence of a non-interactive argument with security in the standard (CRS) model, we obtain a PCD scheme that is also secure in the standard (CRS) model.</p>

    <p class="text-gray-300">For this reason, the definition of PCD above is stated in the standard model (without oracles). We do not explicitly define non-interactive arguments in the standard model; the definition is easily obtained by removing the random oracle from the definitions in Section 3.1.</p>

    <p class="text-gray-300">The definitions of both non-interactive arguments (in the standard model) and proof-carrying data can be strengthened, in a straightforward way, to express post-quantum security. In particular, we replace</p>

    <p class="text-gray-300">polynomial-size circuit" and "polynomial-time algorithm" with their quantum analogues. Since we do not prove post-quantum security of any construction in the random oracle model, we do not discuss the quantum random oracle model.</p>

    <p class="text-gray-300">We define commitment schemes and specify the Pedersen commitment scheme (used throughout this work).</p>

    <p class="text-gray-300">Definition 3.4. A commitment scheme is a tuple  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit})</span>  with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CM.Setup, on input a message format  <span class="math">L</span> , outputs public parameters pp, which in particular specify a message universe  <span class="math">\\mathcal{M}_{\\mathrm{pp}}</span>  and a commitment universe  <span class="math">\\mathcal{C}_{\\mathrm{pp}}</span> .</li>

      <li>CM.Trim, on input public parameters pp and a trim specification  <span class="math">\\ell</span> , outputs a commitment key ck containing a description of a message space  <span class="math">\\mathcal{M}_{\\mathrm{ck}} \\subseteq \\mathcal{M}_{\\mathrm{pp}}</span>  corresponding to  <span class="math">\\ell</span> .</li>

      <li>CM.Commit, on input a commitment key ck, a message  <span class="math">m \\in \\mathcal{M}_{\\mathrm{ck}}</span> , and randomness  <span class="math">\\omega</span> , outputs a commitment  <span class="math">C \\in \\mathcal{C}_{\\mathrm{pp}}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The commitment scheme CM is binding if, for every message format  <span class="math">L</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda)<span class="math">  and every expected polynomial-time adversary  </span>\\mathcal{A}$ , the following holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}\\left[\\begin{array}{c c}\\underset {\\sim}{m_{1}\\in\\mathcal{M}_{\\mathrm{ck}_{1}}},m_{2}\\in\\mathcal{M}_{\\mathrm{ck}_{2}}\\\\ \\wedge m_{1}\\neq m_{2}\\\\ \\wedge \\mathrm{CM.}\\mathrm{Commit}(\\mathrm{ck}_{1},m_{1};\\omega_{1}) = \\mathrm{CM.}\\mathrm{Commit}(\\mathrm{ck}_{2},m_{2};\\omega_{2}) \\end{array}\\right]\\left\\lvert\\begin{array}{c}\\mathsf{pp}\\leftarrow \\mathsf{CM.Setup}^{p}(1^{\\lambda},L)\\\\\\left(\\ell_{1},m_{1},\\omega_{1}\\right)\\leftarrow \\mathcal{A}^{p}(\\mathsf{pp})\\\\ \\mathsf{ck}_{1}\\leftarrow \\mathsf{CM.Trim}^{p}(\\mathsf{pp},\\ell_{1})\\\\ \\mathsf{ck}_{2}\\leftarrow \\mathsf{CM.Trim}^{p}(\\mathsf{pp},\\ell_{2})\\end{array}\\right.\\right. = \\mathrm{negl}(\\lambda)\\ .</span></p>

    <p class="text-gray-300">Note that  <span class="math">m_{1} \\neq m_{2}</span>  is well-defined since  <span class="math">\\mathcal{M}_{\\mathrm{ck}_1}, \\mathcal{M}_{\\mathrm{ck}_2} \\subseteq \\mathcal{M}_{\\mathrm{pp}}</span> .</p>

    <p class="text-gray-300">Remark 3.5. The binding property is stated for expected polynomial time adversaries, since this is how it will be used in this work. This is equivalent to the standard definition of binding (i.e., for polynomial size adversaries) via a non-uniform reduction.</p>

    <p class="text-gray-300">The Pedersen commitment scheme  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit})</span>  operates as follows, for some algorithm SampleGrp that outputs  <span class="math">(\\mathbb{G},q,G)</span>  where  <span class="math">\\mathbb{G}</span>  is a group of prime order  <span class="math">q</span>  generated by  <span class="math">G</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The message format  <span class="math">L</span>  and trim specification  <span class="math">\\ell</span>  are nonnegative integers with  <span class="math">\\ell \\leq L</span> .</li>

      <li>CM.Setup  <span class="math">(1^{\\lambda}, L)</span>  runs  <span class="math">(\\mathbb{G}, q, G) \\gets \\text{SampleGrp}(1^{\\lambda})</span> , samples  <span class="math">\\vec{G} = (G_1, \\ldots, G_L, H) \\in \\mathbb{G}^{L+1}</span>  uniformly at random, and outputs  <span class="math">\\mathsf{pp} := ((\\mathbb{G}, q, G), \\vec{G})</span> ;  <span class="math">\\mathcal{M}_{\\mathsf{pp}} := \\mathbb{F}^L</span>  where  <span class="math">\\mathbb{F}</span>  is the prime field of size  <span class="math">q</span> , and  <span class="math">\\mathcal{C}_{\\mathsf{pp}} := \\mathbb{G}</span> .</li>

      <li>CM.Trim(pp,  <span class="math">\\ell</span> ) outputs  <span class="math">\\mathsf{ck} = ((\\mathbb{G}, q, G), (G_1, \\ldots, G_\\ell, H))</span> ; this key determines  <span class="math">\\mathcal{M}_{\\mathsf{ck}} := \\mathbb{F}^\\ell</span> .</li>

      <li>CM.Commit(ck,  <span class="math">m;\\omega</span>  ) outputs  <span class="math">\\sum_{i = 1}^{\\ell}m_{i}\\cdot G_{i} + \\omega \\cdot H</span>  , where  <span class="math">\\omega \\in \\mathbb{F}</span></li>

    </ul>

    <p class="text-gray-300">CM is binding when the discrete logarithm problem is hard in  <span class="math">\\mathbb{G}</span>  as sampled by SampleGrp. CM is perfectly hiding: for any message  <span class="math">m</span> , CM.Commit(ck,  <span class="math">m; \\omega</span> ) is uniformly random in  <span class="math">\\mathbb{G}</span>  when  <span class="math">\\omega</span>  is uniformly random in  <span class="math">\\mathbb{F}</span> . CM satisfies the following homomorphic property: for all keys  <span class="math">\\mathsf{ck}, \\alpha, \\beta \\in \\mathbb{F}, m_1, m_2 \\in \\mathbb{F}^\\ell, \\omega_1, \\omega_2 \\in \\mathbb{F}</span> ,</p>

    <p class="text-gray-300"><span class="math">\\alpha \\cdot \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, m_1; \\omega_1) + \\beta \\cdot \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, m_2; \\omega_2) = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, \\alpha m_1 + \\beta m_2; \\alpha \\omega_1 + \\beta \\omega_2)</span></p>

    <p class="text-gray-300">where  <span class="math">\\cdot</span>  above represents scalar multiplication in  <span class="math">\\mathbb{G}</span>  (the natural action of  <span class="math">\\mathbb{F}</span>  on  <span class="math">\\mathbb{G}</span> ).</p>

    <p class="text-gray-300">Let  <span class="math">\\Phi \\colon \\{0,1\\}^* \\to \\{0,1\\}</span>  be a (relation) predicate and  <span class="math">\\mathcal{H}</span>  a randomized oracle algorithm that outputs predicate parameters  <span class="math">\\mathsf{pp}_{\\Phi}</span>  (see below). A split accumulation scheme for  <span class="math">(\\Phi, \\mathcal{H})</span>  is a tuple of algorithms  <span class="math">\\mathsf{AS} = (\\mathrm{G}, \\mathrm{I}, \\mathrm{P}, \\mathrm{V}, \\mathrm{D})</span>  of which  <span class="math">\\mathrm{P}, \\mathrm{V}</span>  have access to the same random oracle  <span class="math">\\rho</span> . The algorithms have the following syntax and properties.</p>

    <p class="text-gray-300">Syntax. The algorithms comprising AS have the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: On input a security parameter  <span class="math">\\lambda</span>  (in unary), G samples and outputs public parameters pp.</li>

      <li>Indexer: On input public parameters  <span class="math">\\mathsf{pp}</span> , predicate parameters  <span class="math">\\mathsf{pp}_{\\Phi}</span>  (generated by  <span class="math">\\mathcal{H}</span> ), and a predicate index  <span class="math">\\mathsf{i}_{\\Phi}</span> , I deterministically computes and outputs a triple  <span class="math">(\\mathsf{apk}, \\mathsf{avk}, \\mathsf{dk})</span>  consisting of an accumulator proving key  <span class="math">\\mathsf{apk}</span> , an accumulator verification key  <span class="math">\\mathsf{avk}</span> , and a decision key  <span class="math">\\mathsf{dk}</span> .</li>

      <li>Accumulation prover: On input the accumulator proving key  <span class="math">\\mathsf{apk}</span> , predicate inputs  <span class="math">[(qx_i, qw_i)]_{i=1}^n</span> , and old accumulators  <span class="math">[acc_j]_{j=1}^m = [(acc_j.x, acc_j.w)]_{j=1}^m</span> , P outputs a new accumulator  <span class="math">acc = (acc.x, acc.w)</span>  and a proof  <span class="math">pf</span>  for the accumulation verifier.</li>

      <li>Accumulation verifier: On input the accumulator verification key  <span class="math">\\mathsf{avk}</span> , predicate input instances  <span class="math">[qx_i]_{i=1}^n</span> , accumulator instances  <span class="math">[acc_j.x]_{j=1}^m</span> , a new accumulator instance  <span class="math">\\mathsf{acc.x}</span> , and a proof  <span class="math">\\mathsf{pf}</span> , V outputs a bit indicating whether  <span class="math">\\mathsf{acc.x}</span>  correctly accumulates  <span class="math">[(qx_i, qw_i)]_{i=1}^n</span>  and  <span class="math">[acc_j.x]_{j=1}^m</span> .</li>

      <li>Decider: On input the decision key  <span class="math">\\mathsf{dk}</span> , and an accumulator  <span class="math">\\mathsf{acc} = (\\mathsf{acc.x}, \\mathsf{acc.w})</span> , D outputs a bit indicating whether  <span class="math">\\mathsf{acc}</span>  is a valid accumulator.</li>

    </ul>

    <p class="text-gray-300">These algorithms must satisfy two properties, completeness and knowledge soundness, defined below. We additionally define a notion of zero knowledge that we use to achieve zero knowledge PCD (see Section 5).</p>

    <p class="text-gray-300">Completeness. For every (unbounded) adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\forall j \\in [ m ],   \\mathrm {D} (\\mathrm {d k}, \\mathrm {a c c} _ {j}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\forall i \\in [ n ],   \\Phi (\\mathrm {p p} _ {\\Phi}, \\mathrm {i} _ {\\Phi}, \\mathrm {q x} _ {i}, \\mathrm {q w} _ {i}) = 1 &amp;amp; \\mathrm {p p} \\leftarrow \\mathrm {G} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\mathrm {p p} _ {\\Phi} \\leftarrow \\mathcal {H} (1 ^ {\\lambda}) \\\\ \\mathrm {V} ^ {\\rho} (\\mathrm {a v k}, [ \\mathrm {q x} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {a c c} _ {j}. \\mathrm {x} ] _ {j = 1} ^ {m}, \\mathrm {a c c}. \\mathrm {x}, \\mathrm {p f}) = 1 &amp;amp; (\\mathrm {i} _ {\\Phi}, [ (\\mathrm {q x} _ {i}, \\mathrm {q w} _ {i}) ] _ {i = 1} ^ {n}, [ \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathrm {p p}, \\mathrm {p p} _ {\\Phi}) \\\\ \\mathrm {D} (\\mathrm {d k}, \\mathrm {a c c}) = 1 &amp;amp; (\\mathrm {a p k}, \\mathrm {a v k}, \\mathrm {d k}) \\leftarrow \\mathrm {I} (\\mathrm {p p}, \\mathrm {p p} _ {\\Phi}, \\mathrm {i} _ {\\Phi}) \\\\ &amp;amp; (\\mathrm {a c c}, \\mathrm {p f}) \\leftarrow \\mathrm {P} ^ {\\rho} (\\mathrm {a p k}, [ (\\mathrm {q x} _ {i}, \\mathrm {q w} _ {i}) ] _ {i = 1} ^ {n}, [ \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Note that for  <span class="math">m = n = 0</span>  the precondition on the left-hand side holds vacuously and this is required for the completeness condition to be non-trivial.</p>

    <p class="text-gray-300">Knowledge soundness. There exists an extractor  <span class="math">\\mathbf{E}</span>  running in expected polynomial time such that for every adversary  <span class="math">\\tilde{\\mathbf{P}}</span>  running in expected (non-uniform) polynomial time and auxiliary input distribution  <span class="math">\\mathcal{D}</span> , the following probability is negligibly close to 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathrm {V} ^ {\\rho} (\\mathsf {a v k}, [ \\mathsf {q x} _ {i} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j}. \\mathsf {x} ] _ {j = 1} ^ {m}, \\mathsf {a c c}. \\mathsf {x}, \\mathsf {p f}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathrm {D} (\\mathsf {d k}, \\mathsf {a c c}) = 1 &amp;amp; \\mathsf {p p} _ {\\Phi} \\leftarrow \\mathcal {H} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (1 ^ {\\lambda}) \\\\ \\forall i \\in [ n ],   \\Phi (\\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}, \\mathsf {q x} _ {i}, \\mathsf {q w} _ {i}) = 1 &amp;amp; (\\mathsf {i} _ {\\Phi}, [ \\mathsf {q x} _ {i} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j}. \\mathsf {x} ] _ {j = 1} ^ {m}, \\mathsf {a c c}, \\mathsf {p f}; r) \\leftarrow \\tilde {\\mathrm {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}) \\\\ \\forall j \\in [ m ],   \\mathrm {D} \\big (\\mathsf {d k}, (\\mathsf {a c c} _ {j}. \\mathsf {x}, \\mathsf {a c c} _ {j}. \\mathsf {w}) \\big) = 1 &amp;amp; ([ \\mathsf {q w} _ {i} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j}. \\mathsf {w} ] _ {j = 1} ^ {m}) \\leftarrow \\mathrm {E} ^ {\\tilde {\\mathrm {P}}, \\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}, r) \\\\ &amp;amp; (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">Zero knowledge. There exists a polynomial-time simulator S such that for every polynomial-size "honest" adversary  <span class="math">\\mathcal{A}</span>  (see below) the following distributions are (statistically/computationally) indistinguishable:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{ (ρ, pp, ppΦ, iΦ, acc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  pp← G(1λ)  |</p>

    <p class="text-gray-300">|   |  ppΦ← H(1λ)  |</p>

    <p class="text-gray-300">|   |  (iΦ, [(qx_i, qw_i)]n_i=1, [acc_j]n_j=1)← A^ρ(pp, ppΦ)  |</p>

    <p class="text-gray-300">|   |  (apk, avk, dk)← I(pp, ppΦ, iΦ)  |</p>

    <p class="text-gray-300">|   | (acc, pf)← P^ρ(apk, [(qx_i, qw_i)]n_i=1, [acc_j]n_j=1)  |</p>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{ (ρ[μ], pp, ppΦ, iΦ, acc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  (pp,τ)← S^ρ(1^λ)  |</p>

    <p class="text-gray-300">|   |  ppΦ← H(1^λ)  |</p>

    <p class="text-gray-300">|   |  (iΦ, [(qx_i, qw_i)]n_i=1, [acc_j]n_j=1)← A^ρ(pp, ppΦ)  |</p>

    <p class="text-gray-300">|   |  (acc,μ)← S^ρ(τ, ppΦ, iΦ)  |</p>

    <p class="text-gray-300">Here  <span class="math">\\mathcal{A}</span>  is honest if it outputs, with probability 1, a tuple  <span class="math">(\\mathrm{i}_{\\Phi},[(\\mathrm{qx}_i,\\mathrm{qw}_i)]_{i = 1}^n,[acc_j]_{j = 1}^m)</span>  such that  <span class="math">\\Phi (\\mathsf{pp}_{\\Phi},\\mathrm{i}_{\\Phi},\\mathsf{qx}_i,\\mathsf{qw}_i) = 1</span>  and  <span class="math">\\mathrm{D(dk,acc_j)} = 1</span>  for all  <span class="math">i\\in [n]</span>  and  <span class="math">j\\in [m]</span> . Note that the simulator S is not required to simulate the accumulation verifier proof pf.</p>

    <p class="text-gray-300">Remark 4.1 (predicates with oracles). In Section 8 we accumulate predicates  <span class="math">\\Phi</span>  that themselves have access to oracles, as do their associated parameter generation algorithms  <span class="math">\\mathcal{H}</span> . These oracles are disjoint from the random oracle  <span class="math">\\rho</span>  used by the accumulation scheme. The definitions above can be adapted to this setting by providing all algorithms ((G, I, P, V, D) of the accumulation scheme, adversaries  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\tilde{\\mathrm{P}}</span> , the extractor E, and the simulator S) with access to these oracles.</p>

    <p class="text-gray-300">Some accumulation schemes have the property that the decider is equal to the predicate itself:  <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc})\\equiv</span> <span class="math">\\Phi (\\mathsf{pp}_{\\Phi},\\mathsf{i}_{\\Phi},\\mathsf{acc}.\\mathbf{x},\\mathsf{acc}.\\mathbf{w})</span>  . This implies that predicate inputs and accumulators have the same form, and are split in the same way. In this case, the definitions can be simplified. Below we state these simplified definitions because we use them in Section 7 and Appendix A.</p>

    <p class="text-gray-300">Completeness. For every (unbounded) adversary  <span class="math">\\mathcal{A}</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∀i∈[n], Φ(ppΦ, iΦ, qx_i, qw_i) = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ←U(λ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">↓</td>

            <td class="px-3 py-2 border-b border-gray-700">pp←G(1^λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V^ρ(avk, [qx_i]n_i=1, acc.x, pf) = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">ppΦ←H(1^λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">D(dk, acc) = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">(iΦ, [(qx_i, qw_i)]n_i=1)←A(pp, ppΦ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   | (apk, avk, dk)←I(pp, ppΦ, iΦ)  |</p>

    <p class="text-gray-300">|   |  | (acc, pf)←P^ρ(apk, [(qx_i, qw_i)]n_i=1)  |</p>

    <p class="text-gray-300">Knowledge soundness. There exists an extractor E running in expected polynomial time such that for every</p>

    <p class="text-gray-300">adversary  <span class="math">\\tilde{\\mathrm{P}}</span>  running in expected (non-uniform) polynomial time and auxiliary input distribution  <span class="math">\\mathcal{D}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\operatorname {V} ^ {\\rho} (\\mathsf {a v k}, [ \\mathsf {q x} _ {i} ] _ {i = 1} ^ {n}, \\mathsf {a c c .} \\mathbb {x}, \\mathsf {p f}) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {G} (1 ^ {\\lambda}) \\\\ \\operatorname {D} (\\mathsf {d k}, \\mathsf {a c c}) = 1 &amp;amp; \\mathsf {p p} _ {\\Phi} \\leftarrow \\mathsf {H} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (1 ^ {\\lambda}) \\\\ \\forall i \\in [ n ],   \\Phi (\\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}, \\mathsf {q x} _ {i}, \\mathsf {q w} _ {i}) = 1 &amp;amp; (\\mathsf {i} _ {\\Phi}, [ \\mathsf {q x} _ {i} ] _ {i = 1} ^ {n}, \\mathsf {a c c}, \\mathsf {p f}; r) \\leftarrow \\tilde {\\mathrm {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}) \\\\ &amp;amp; [ \\mathsf {q w} _ {i} ] _ {i = 1} ^ {n} \\leftarrow \\mathrm {E} ^ {\\tilde {\\mathrm {P}}, \\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}, r) \\\\ &amp;amp; (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}) \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda) .</span></div>

    <p class="text-gray-300">The definitions of knowledge soundness that we presented so far are convenient for proving schemes secure in the random oracle model, but are stronger than what we need. To prove security for PCD in Section 5 a weaker notion of "multi-instance" extraction will suffice. This is motivated by analyses in the quantum random oracle model, where the no-cloning principle necessitates that the extractor simulate the oracle itself in order to extract. In contrast, in the classical setting the extractor may simply "observe" the adversary's queries to the real oracle, which justifies the prior definition. Below we state the property we use, and then explain how it is implied (in the classical setting) by the prior definitions of knowledge soundness.</p>

    <p class="text-gray-300">Knowledge soundness (with respect to auxiliary input distribution  <span class="math">\\mathcal{D}</span> ). For every (non-uniform) adversary  <span class="math">\\tilde{\\mathrm{P}}</span>  running in expected polynomial time there exists an extractor  <span class="math">\\mathrm{E}</span>  running in expected polynomial time such that for every set  <span class="math">Z</span>  the following probabilities are within  <span class="math">\\mathrm{negl}(\\lambda)</span>  of each other:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c} \\left(\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}, \\left[ \\begin{array}{c}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\Phi} ^ {(k)} \\\\ \\mathsf {a c c} ^ {(k)} \\\\ [ \\mathsf {q x} _ {i} ^ {(k)} ] _ {i = 1} ^ {n} \\\\ [ \\mathsf {a c c} _ {j}. \\mathsf {x} ^ {(k)} ] _ {j = 1} ^ {m} \\end{array} \\right] _ {k = 1} ^ {\\ell}, \\mathsf {a o}\\right) \\in Z \\\\ \\left\\{\\forall j \\in [ m ], \\mathrm {D} (\\mathsf {d k} ^ {(k)}, \\mathsf {a c c} _ {j} ^ {(k)}) = 1 \\\\ \\forall i \\in [ n ], \\Phi (\\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi} ^ {(k)}, \\mathsf {q x} _ {i} ^ {(k)}, \\mathsf {q w} _ {i} ^ {(k)}) = 1 \\right\\} _ {k = 1} ^ {\\ell} \\\\ \\end{array} \\right] \\left(\\left[ \\begin{array}{c}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\Phi} ^ {(k)} \\\\ \\mathsf {a c c} ^ {(k)} \\\\ [ (\\mathsf {q x} _ {i} ^ {(k)}, \\mathsf {q w} _ {i} ^ {(k)}) ] _ {i = 1} ^ {n} \\\\ [ \\mathsf {a c c} _ {j} ^ {(k)} ] _ {j = 1} ^ {m} \\end{array} \\right] _ {k = 1} ^ {\\ell}, \\mathsf {a o}\\right) \\leftarrow \\mathrm {E} _ {\\tilde {\\mathrm {P}}} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}) \\\\ \\forall k, (\\mathsf {a p k} ^ {(k)}, \\mathsf {a v k} ^ {(k)}, \\mathsf {d k} ^ {(k)}) \\leftarrow \\mathrm {I} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi} ^ {(k)}) \\end{array} \\right] \\text {a n d}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ &amp; \\left[ \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}, \\left[ \\begin{array}{c}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\Phi} ^ {(k)} \\\\ \\mathsf {a c c} ^ {(k)} \\\\ [ \\mathsf {q x} _ {i} ^ {(k)} ] _ {i = 1} ^ {n} \\\\ [ \\mathsf {a c c} _ {j}. \\mathsf {x} ^ {(k)} ] _ {j = 1} ^ {m} \\end{array} \\right] _ {k = 1} ^ {\\ell}, \\mathsf {a o}\\right) \\in Z \\\\ &amp; \\left\\{\\mathrm {V} ^ {\\rho} (\\mathsf {a v k} ^ {(k)}, [ \\mathsf {q x} _ {i} ^ {(k)} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j}. \\mathsf {x} ^ {(k)} ] _ {j = 1} ^ {m}, \\mathsf {a c c}. \\mathsf {x} ^ {(k)}, \\mathsf {p f} ^ {(k)}) = 1 \\right\\} _ {k = 1} ^ {\\ell} \\\\ &amp; \\mathrm {D} (\\mathsf {d k} ^ {(k)}, \\mathsf {a c c} ^ {(k)}) = 1 \\end{array} \\right] \\left(\\left[ \\begin{array}{c}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\Phi} ^ {(k)} \\\\ \\mathsf {a c c} ^ {(k)} \\\\ [ \\mathsf {q x} _ {i} ^ {(k)} ] _ {i = 1} ^ {n} \\\\ [ \\mathsf {a c c} _ {j}. \\mathsf {x} ^ {(k)} ] _ {j = 1} ^ {m} \\end{array} \\right] _ {k = 1} ^ {\\ell}, \\mathsf {a o}\\right) \\leftarrow \\tilde {\\mathrm {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {a i}) \\\\ &amp; \\forall k, (\\mathsf {a p k} ^ {(k)}, \\mathsf {a v k} ^ {(k)}, \\mathsf {d k} ^ {(k)}) \\leftarrow \\mathrm {I} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi} ^ {(k)}) \\end{array} \\right]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The above definition is implied. In the classical setting, the above definition is implied by the definition of knowledge soundness given earlier in this section. The multi-instance extractor  <span class="math">\\mathrm{E}_{\\tilde{\\mathrm{P}}}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{E}_{\\tilde{\\mathrm{P}}}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp}_{\\Phi},\\mathsf{ai})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize the table tr:  <span class="math">\\{0,1\\}^{*}\\rightharpoonup \\{0,1\\}^{\\lambda}</span>  to be empty.</li>

      <li>Run  <span class="math">\\left([i_{\\Phi}^{(k)}, \\mathsf{acc}^{(k)}, [\\mathsf{qx}_i^{(k)}]_{i=1}^n, [\\mathsf{acc}_j \\cdot \\mathfrak{x}^{(k)}]_{j=1}^m, \\mathsf{pf}^{(k)}]_{k=1}^\\ell, \\mathsf{ao}; r\\right) \\gets \\tilde{\\mathrm{P}}^{(\\cdot)}(\\mathsf{pp}, \\mathsf{pp}_{\\Phi}, \\mathsf{ai})</span> , simulating its access to the random oracle using tr.</li>

      <li>For each  <span class="math">k \\in [\\ell]</span> , let  <span class="math">\\tilde{\\mathrm{P}}^{(k)}</span>  equal  <span class="math">\\tilde{\\mathrm{P}}</span>  with its output is restricted to the index  <span class="math">k</span> . Run</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left[ \\mathrm {q w} _ {i} ^ {(k)} \\right] _ {i = 1} ^ {n}, \\left[ \\mathrm {a c c} _ {j}. \\mathrm {w} ^ {(k)} \\right] _ {j = 1} ^ {m}\\right) \\leftarrow \\mathrm {E} ^ {\\tilde {\\mathrm {P}} ^ {(k)}, (\\cdot)} (\\mathrm {p p}, \\mathrm {p p} _ {\\Phi}, \\mathrm {a i}, r)</span></div>

    <p class="text-gray-300">simulating its access to the random oracle using tr.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\left([i_{\\Phi}^{(k)}, \\mathsf{acc}^{(k)}, [(\\mathsf{qx}_i^{(k)}, \\mathsf{qw}_i^{(k)})]_{i=1}^n, [(\\mathsf{acc}_j \\cdot \\mathfrak{x}^{(k)}, \\mathsf{acc}_j \\cdot \\mathfrak{w}^{(k)})]_{j=1}^m\\right)_{k=1}^\\ell, \\mathsf{ao}\\right)</span> .</li>

    </ol>

    <p class="text-gray-300">5 PCD from arguments of knowledge with split accumulation</p>

    <p class="text-gray-300">We formally restate and then prove Theorem 1, which provides a construction of proof-carrying data (PCD) from any NARK that has a split accumulation scheme with certain efficiency properties.</p>

    <p class="text-gray-300">First, we provide definitions and notation for these properties.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 5.1 (accumulation for <span class="math">\\mathsf{ARG}</span>).</h6>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> is a split accumulation scheme for the non-interactive argument system <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> if <span class="math">\\mathsf{AS}</span> is a split accumulation scheme for the pair <span class="math">(\\Phi_{\\mathcal{V}},\\mathcal{H}_{\\text{\\tiny{ARG}}}\\coloneqq\\mathcal{G})</span> where <span class="math">\\Phi_{\\mathcal{V}}</span> is defined below:</p>

    <p class="text-gray-300"><span class="math">\\Phi_{\\mathcal{V}}(\\mathsf{pp}_{\\Phi}=\\mathsf{pp},\\mathsf{i}_{\\Phi}=\\mathsf{i},\\mathsf{qx}=(\\mathbbmss x,\\pi.\\mathbbmss x),\\mathsf{qw}=\\pi.\\mathbbmss w)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\leftarrow\\mathcal{I}(\\mathsf{pp},\\mathsf{i})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\mathcal{V}(\\mathrm{ivk},\\mathbbmss x,(\\pi.\\mathbbmss x,\\pi.\\mathbbmss w))</span>.</li>

    </ol>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 5.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> be an accumulation scheme for a non-interactive argument (see Definition 5.1). We denote by <span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}</span> the circuit corresponding to the computation of the accumulation verifier <span class="math">\\mathrm{V}</span>, for security parameter <span class="math">\\lambda</span>, when checking the accumulation of <span class="math">m</span> instance-proof pairs and accumulators, on an index of size at most <span class="math">N</span>, where each instance is of size at most <span class="math">k</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by <span class="math">\\mathsf{v}(\\lambda,m,N,k)</span> the size of the circuit <span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}</span>, by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{avk}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the size of the accumulator verification key </span>\\mathsf{avk}<span class="math">, and by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{acc}.\\mathbbmss x(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ the size of an accumulator instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that here we have specified that the size of <span class="math">\\mathsf{acc}.\\mathbbmss x</span> is bounded by a function of <span class="math">\\lambda,m,N</span>; in particular, it <em>may not</em> depend on the number of instances accumulated, or on the input size bound <span class="math">k</span>.</p>

    <p class="text-gray-300">When we invoke the accumulation verifier in our construction of PCD, an instance will consist of an accumulator verification key, an accumulator <em>instance</em>, and some additional data of size <span class="math">\\ell</span>. Thus the size of the accumulation verifier circuit used in the scheme is given by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{v}^{*}(\\lambda,m,N,\\ell)\\coloneqq\\mathsf{v}(\\lambda,m,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{avk}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{acc}.\\mathbbmss x(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The notion of “sublinear verification” which is important here is that <span class="math">\\mathsf{v}^{*}</span> is sublinear in <span class="math">N</span>. The following theorem shows that when this is the case, this accumulation scheme can be used to construct PCD.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 5.3.</h6>

    <p class="text-gray-300">There exists a polynomial-time transformation <span class="math">\\mathrm{T}</span> such that if <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> is a NARK for circuit satisfiability and <span class="math">\\mathsf{AS}</span> is a split accumulation scheme for <span class="math">\\mathsf{ARG}</span> then <span class="math">\\mathsf{PCD}=(\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V})\\coloneqq\\mathrm{T}(\\mathsf{ARG},\\mathsf{AS})</span> is a PCD scheme for constant-depth compliance predicates, provided</p>

    <p class="text-gray-300"><span class="math">\\exists\\,\\epsilon\\in(0,1)\\text{ and a polynomial }\\alpha\\text{ s.t. }\\mathsf{v}^{*}(\\lambda,m,N,\\ell)=O(N^{1-\\epsilon}\\cdot\\alpha(\\lambda,m,\\ell))\\enspace.</span></p>

    <p class="text-gray-300">Moreover:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{ARG}</span> and <span class="math">\\mathsf{AS}</span> are secure against quantum adversaries, then <span class="math">\\mathsf{PCD}</span> is secure against quantum adversaries.</li>

      <li>If <span class="math">\\mathsf{ARG}</span> and <span class="math">\\mathsf{AS}</span> are (post-quantum) zero knowledge, then <span class="math">\\mathsf{PCD}</span> is (post-quantum) zero knowledge.</li>

      <li>If the size of the predicate <span class="math">\\varphi\\colon\\mathbb{F}^{(m+2)\\ell}\\to\\mathbb{F}</span> is <span class="math">f=\\omega(\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})</span> then:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the cost of running <span class="math">\\mathbb{I}</span> is equal to the cost of running both <span class="math">\\mathcal{I}</span> and <span class="math">\\mathrm{I}</span> on an index of size <span class="math">f+o(f)</span>;</li>

      <li>the cost of running <span class="math">\\mathbb{P}</span> is equal to the cost of accumulating <span class="math">m</span> instance-proof pairs using <span class="math">\\mathrm{P}</span>, and running <span class="math">\\mathcal{P}</span>, on an index of size <span class="math">f+o(f)</span> and instance of size <span class="math">o(f)</span>;</li>

      <li>the cost of running <span class="math">\\mathbb{V}</span> is equal to the cost of running both <span class="math">\\mathcal{V}</span> and <span class="math">\\mathrm{D}</span> on an index of size <span class="math">f+o(f)</span> and an instance of size <span class="math">o(f)</span>.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">This last point gives the conditions for a <em>sublinear additive</em> recursive overhead; i.e., when the <em>additional</em> cost of proving that <span class="math">\\varphi</span> is satisfied recursively is asymptotically smaller than the cost of proving that <span class="math">\\varphi</span> is satisfied locally. Note that the smaller the compliance predicate <span class="math">\\varphi</span>, the more efficient the accumulation scheme has to be in order to achieve this.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Remark 5.4 (accumulator instance size).</h6>

    <p class="text-gray-300">Theorem 5.3 requires that the size of an accumulator instance <span class="math">\\mathsf{acc}.\\mathtt{x}</span> be <em>independent</em> of the instance size <span class="math">k</span>. This is achieved by our split accumulation scheme in Section 8.2. It is also straightforward to convert any split accumulation scheme into one that satisfies this condition, using a collision resistant hash function <span class="math">h</span>. Specifically, the accumulator instance of the new scheme will be <span class="math">h(\\mathsf{acc}.\\mathtt{x})</span>, and <span class="math">\\mathsf{acc}.\\mathtt{x}</span> is appended to the accumulator witness and accumulation proof. The accumulation verifier and decider then simply verify the hash in addition to performing their original computation.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">5.1 Construction</h3>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> be a non-interactive argument for circuit satisfiability and <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> an accumulation scheme for <span class="math">\\mathsf{ARG}</span> (see Definition 5.1). Below we construct a PCD scheme <span class="math">\\mathsf{PCD}=(\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V})</span>.</p>

    <p class="text-gray-300">Given a compliance predicate <span class="math">\\varphi\\colon\\mathbb{F}^{(m+2)\\ell}\\to\\mathbb{F}</span>, the circuit that realizes the recursion is as follows.</p>

    <p class="text-gray-300"><span class="math">R^{(\\lambda,N,k)}_{\\mathrm{V},\\varphi}\\big{(}(\\mathsf{avk},z,\\mathsf{acc}.\\mathtt{x}),(z_{\\mathsf{loc}},[z_{i},\\pi_{i}.\\mathtt{x},\\mathsf{acc}_{i}.\\mathtt{x}]_{i=1}^{m},\\mathsf{pf})\\big{)}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the compliance predicate <span class="math">\\varphi(z,z_{\\mathsf{loc}},z_{1},\\ldots,z_{m})</span> accepts.</li>

      <li>If there exists <span class="math">i\\in[m]</span> such that <span class="math">z_{i}\\neq\\bot</span>, check that the NARK accumulation verifier accepts:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}.\\mathtt{x}]_{i=1}^{m},\\mathsf{acc}.\\mathtt{x},\\mathsf{pf})=1\\quad\\text{where}\\quad\\mathsf{qx}_{i}\\coloneqq\\big{(}(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}.\\mathtt{x}),\\pi_{i}.\\mathtt{x}\\big{)}\\enspace.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the above checks hold, output <span class="math">1</span>; otherwise, output <span class="math">0</span>.</li>

    </ol>

    <p class="text-gray-300">Above, <span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}</span> refers to the circuit representation of <span class="math">\\mathrm{V}</span> with input size appropriate for security parameter <span class="math">\\lambda</span>, number of instance-proof pairs and accumulators <span class="math">m</span>, circuit size <span class="math">N</span>, and circuit input size <span class="math">k</span>.</p>

    <p class="text-gray-300">Next we describe the generator <span class="math">\\mathbb{G}</span>, indexer <span class="math">\\mathbb{I}</span>, prover <span class="math">\\mathbb{P}</span>, and verifier <span class="math">\\mathbb{V}</span> of the PCD scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{G}(1^{\\lambda})</span>: Sample <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})</span> and <span class="math">\\mathsf{pp}_{\\mathsf{AS}}\\leftarrow\\mathrm{G}(1^{\\lambda})</span>, and output <span class="math">\\mathbb{pp}\\coloneqq(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}})</span>.</li>

      <li><span class="math">\\mathbb{I}(\\mathbb{pp},\\varphi)</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute the integer $N\\coloneqq N(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,\\ell)<span class="math">, where </span>N$ is defined in Lemma 5.5 below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the index key pair <span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\coloneqq\\mathcal{I}(\\mathsf{pp},R)</span> for the circuit <span class="math">R</span> for the NARK.</li>

      <li>Compute the index key triple <span class="math">(\\mathsf{apk},\\mathsf{dk},\\mathsf{avk})\\coloneqq\\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp}_{\\Phi}=\\mathsf{pp},\\mathrm{i}_{\\Phi}=R)</span> for the accumulator.</li>

      <li>Output the proving key <span class="math">\\mathrm{ipk}\\coloneqq(\\mathrm{ipk},\\mathsf{apk})</span> and verification key <span class="math">\\mathrm{ivk}\\coloneqq(\\mathrm{ivk},\\mathsf{dk},\\mathsf{avk})</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{P}(\\mathsf{ipk},z,z_{\\mathsf{loc}},[z_{i},(\\pi_{i},\\mathsf{acc}_{i})]_{i=1}^{m})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">z_{i}=\\bot</span> for all <span class="math">i\\in[m]</span> then sample <span class="math">(\\mathsf{acc},\\mathsf{pf})\\leftarrow\\mathrm{P}(\\mathsf{apk},\\bot)</span>.</li>

      <li>If <span class="math">z_{i}\\neq\\bot</span> for some <span class="math">i\\in[m]</span> then:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>set predicate input instance <span class="math">\\mathsf{qx}_{i}\\coloneqq((\\mathsf{avk},z_{i},\\mathsf{acc}_{i}.\\mathtt{x}),\\pi_{i}.\\mathtt{x})</span>;</li>

      <li>set predicate input witness <span class="math">\\mathsf{qw}_{i}\\coloneqq(\\mathsf{acc}_{i}.\\mathtt{w},\\pi_{i}.\\mathtt{w})</span>;</li>

      <li>sample <span class="math">(\\mathsf{acc},\\mathsf{pf})\\leftarrow\\mathrm{P}(\\mathsf{apk},[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{m},[\\mathsf{acc}_{i}]_{i=1}^{m})</span>.</li>

      <li>Sample <span class="math">\\pi\\leftarrow\\mathcal{P}\\big{(}\\mathrm{ipk},(\\mathsf{avk},z,\\mathsf{acc}.\\mathtt{x}),(z_{\\mathsf{loc}},[z_{i},\\pi_{i}.\\mathtt{x},\\mathsf{acc}_{i}.\\mathtt{x}]_{i=1}^{m},\\mathsf{pf})\\big{)}</span>.</li>

      <li>Output <span class="math">(\\pi,\\mathsf{acc})</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{V}(\\mathsf{ivk},z,(\\pi,\\mathsf{acc}))</span>: Accept if both <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z,\\mathsf{acc}.\\mathtt{x}),\\pi)</span> and <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})</span> accept.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5.2 Completeness</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be any adversary that causes the completeness condition of PCD to be satisfied with probability <span class="math">p</span>. We construct an adversary <span class="math">\\mathcal{B}</span>, as follows, that causes the completeness condition of AS to be satisfied with probability at most <span class="math">p</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\mathbb{pp}:=(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}})</span> and compute <span class="math">(\\varphi,z,z_{\\mathsf{loc}},[z_{i},\\pi_{i},\\mathsf{acc}_{i}]_{i=1}^{m})\\leftarrow\\mathcal{A}(\\mathbb{pp})</span>.</li>

      <li>Set <span class="math">(\\mathsf{apk},\\mathsf{dk},\\mathsf{avk}):=\\mathsf{I}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp},R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)})</span>.</li>

      <li>Construct <span class="math">[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{m}</span> as in the PCD prover <span class="math">\\mathbb{P}</span>.</li>

      <li>Output <span class="math">(R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)},[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{m},[\\mathsf{acc}_{i}]_{i=1}^{m})</span>.</li>

    </ol>

    <p class="text-gray-300">Suppose that <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\varphi,z,z_{\\mathsf{loc}},[z_{i},\\pi_{i},\\mathsf{acc}_{i}]_{i=1}^{m})</span> such that the completeness precondition is satisfied, but <span class="math">\\mathbb{V}(\\mathsf{ivk},z,(\\pi,\\mathsf{acc}))=0</span>. Then, by construction of <span class="math">\\mathbb{V}</span>, it holds that either <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z,\\mathsf{acc}.\\mathbb{x}),\\pi)=0</span> or <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})=0</span>. If <span class="math">z_{i}=\\perp</span> for all <span class="math">i</span>, then by perfect completeness of ARG both of these algorithms output <span class="math">1</span>; hence there exists <span class="math">i</span> such that <span class="math">z_{i}\\neq\\perp</span>. Hence it holds that for all <span class="math">i</span>, <span class="math">\\mathbb{V}(\\mathsf{ivk},z_{i},(\\pi_{i},\\mathsf{acc}_{i}))=1</span>, whence for all <span class="math">i</span>, <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}.\\mathbb{x}),\\pi_{i})=\\Phi_{\\mathcal{V}}(\\mathsf{pp},R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)},(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}.\\mathbb{x}),\\pi_{i})=1</span> and <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc}_{i})=1</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z,\\mathsf{acc}.\\mathbb{x}),\\pi)=0</span>, then, by perfect completeness of ARG, we know that <span class="math">R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}</span> rejects <span class="math">\\big{(}(\\mathsf{avk},z,\\mathsf{acc}),(z_{\\mathsf{loc}},[z_{i},\\pi_{i}.\\mathbb{x},\\mathsf{acc}_{i}.\\mathbb{x}]_{i=1}^{m}),\\mathsf{pf}\\big{)}</span>, and so <span class="math">\\mathrm{V}(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}.\\mathbb{x}]_{i=1}^{m},\\mathsf{acc}.\\mathbb{x})=0</span>. Otherwise, <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})=0</span>.</p>

    <p class="text-gray-300">Now consider the completeness experiment for AS with adversary <span class="math">\\mathcal{B}</span>. Since <span class="math">\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}}</span> are drawn identically to the PCD experiment, the distribution of the output of <span class="math">\\mathcal{A}</span> is identical. Hence in particular it holds that for all <span class="math">i</span>, <span class="math">\\Phi_{\\mathcal{V}}(\\mathsf{pp},R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)},(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i})=1</span> and <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc}_{i})=1</span>. By the above, it holds that either <span class="math">\\mathrm{V}(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}.\\mathbb{x}]_{i=1}^{m},\\mathsf{acc})=0</span> or <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})=0</span>, and so <span class="math">\\mathcal{B}:=(\\mathcal{B}_{1},\\mathcal{B}_{2})</span> causes the completeness condition for AS to be satisfied with probability at most <span class="math">p</span>.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">5.3 Knowledge soundness</h3>

    <p class="text-gray-300">The extracted transcript <span class="math">\\mathsf{T}</span> will be a tree, so for convenience we associate the label <span class="math">z^{(u,v)}</span> of the unique outgoing edge of a node <span class="math">u</span> with the node <span class="math">u</span> itself, so that the node <span class="math">u</span> is labelled with <span class="math">(z^{(u)},z_{\\mathsf{loc}}^{(u)})</span>. In this proof we also associate with each node <span class="math">u</span> a NARK proof <span class="math">\\pi^{(u)}</span> and an accumulator <span class="math">\\mathsf{acc}^{(u)}</span>, so the full label for a node is <span class="math">(z^{(u)},z_{\\mathsf{loc}}^{(u)},\\pi^{(u)},\\mathsf{acc}^{(u)})</span>. One can transform such a transcript into one that satisfies Definition 3.2.</p>

    <p class="text-gray-300">Given a malicious prover <span class="math">\\tilde{\\mathbb{P}}</span>, we will construct an extractor <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> that satisfies knowledge soundness.</p>

    <p class="text-gray-300">We do so via an iterative process that constructs a sequence of extractors <span class="math">\\mathbb{E}_{1},\\ldots,\\mathbb{E}_{d}</span> where <span class="math">d</span> is the depth of <span class="math">\\varphi</span> and <span class="math">\\mathbb{E}_{j}</span> outputs a tree of depth <span class="math">j+1</span>. The extractor <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> is then equal to <span class="math">\\mathbb{E}_{d}</span>.</p>

    <p class="text-gray-300">In the base case, we define <span class="math">\\mathbb{E}_{0}(\\mathbb{pp},\\mathsf{ai})</span> to compute <span class="math">(\\varphi,\\mathsf{o},\\pi,\\mathsf{acc})\\leftarrow\\tilde{\\mathbb{P}}(\\mathbb{pp},\\mathsf{ai})</span> and output <span class="math">(\\varphi,\\mathsf{T}_{0})</span>, where <span class="math">\\mathsf{T}_{0}</span> is a single node labeled with <span class="math">(\\mathsf{o},\\pi,\\mathsf{acc})</span>.</p>

    <p class="text-gray-300">Next, we construct the extractor <span class="math">\\mathbb{E}_{j}</span> inductively for each recursion depth <span class="math">j\\in[d]</span>, given that we have already constructed <span class="math">\\mathbb{E}_{j-1}</span>. We use the notation <span class="math">l_{\\mathsf{T}}(j)</span> to denote the vertices of <span class="math">\\mathsf{T}</span> at depth <span class="math">j</span> (so that <span class="math">l_{\\mathsf{T}}(0):=\\varnothing</span> and <span class="math">l_{\\mathsf{T}}(1)</span> is the singleton containing the root). We proceed in several steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, we construct a NARK prover <span class="math">\\tilde{\\mathcal{P}}_{j}</span> as follows:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathcal{P}}_j(\\mathsf{pp},(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{ai}))</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\varphi, \\mathsf{T}_{j-1}, \\mathsf{ao}) \\gets \\mathbb{E}_{j-1}((\\mathsf{pp}, \\mathsf{pp}_{\\mathsf{AS}}), \\mathsf{ai})</span>.</li>

      <li>For each vertex <span class="math">v \\in l_{\\mathsf{T}_{j-1}}(j)</span>, denote its label by <span class="math">(z^{(v)}, \\pi^{(v)}, \\mathsf{acc}^{(v)})</span>.</li>

      <li>Run the argument indexer <span class="math">(\\mathrm{ipk}, \\mathrm{ivk}) := \\mathcal{I}(\\mathsf{pp}, R_{\\mathrm{V},\\varphi}^{(\\lambda, N, k)})</span>.</li>

      <li>Run the accumulator indexer (apk, dk, avk) := <span class="math">\\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}}, \\mathsf{pp}, R_{\\mathrm{V}, \\varphi}^{(\\lambda, N, k)})</span>.</li>

      <li>Output</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\vec {\\mathbb {i}}, \\vec {\\pi}, \\vec {\\pi}, \\mathsf {a o} ^ {\\prime}) := \\left(\\vec {R}, (\\mathsf {a v k}, z ^ {(v)}, \\mathsf {a c c} ^ {(v)}. \\mathbb {x}) _ {v \\in l _ {\\mathsf {T} _ {j - 1}} (j)}, (\\pi^ {(v)}) _ {v \\in l _ {\\mathsf {T} _ {j - 1}} (j)}, (\\varphi , \\mathsf {T} _ {j - 1}, \\mathsf {a o})\\right)</span></div>

    <p class="text-gray-300">where <span class="math">\\vec{R}</span> is the vector <span class="math">(R_{\\mathrm{V},\\varphi}^{(\\lambda ,N,k)},\\ldots ,R_{\\mathrm{V},\\varphi}^{(\\lambda ,N,k)})</span> of the appropriate length.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Second, we let <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}_j}</span> be the extractor that corresponds to <span class="math">\\tilde{\\mathcal{P}}_j</span>, via the knowledge soundness of the non-interactive argument ARG.</li>

      <li>Third, we construct an accumulation scheme prover <span class="math">\\tilde{\\mathrm{P}}_j</span> as follows:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathrm{P}}_j(\\mathsf{pp}_{\\mathsf{AS}},(\\mathsf{pp},\\mathsf{ai}))</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the extractor <span class="math">(\\vec{\\mathbb{i}},\\vec{\\pi},\\vec{\\mathbf{w}},\\mathsf{ao}^{\\prime})\\gets \\mathcal{E}_{\\tilde{\\mathcal{P}}_j}(\\mathsf{pp},(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{ai}))</span></li>

      <li>Parse the auxiliary output <span class="math">\\mathsf{ao}&#x27;</span> as <span class="math">(\\varphi, \\mathsf{T}&#x27;, \\mathsf{ao})</span>. If <span class="math">\\mathsf{T}&#x27;</span> is not a transcript of depth <span class="math">j</span>, abort.</li>

      <li>For each vertex <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>,</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>obtain <span class="math">\\mathsf{acc}^{(v)}</span> from <span class="math">\\mathsf{T}&#x27;</span>;</li>

      <li>obtain the local data <span class="math">z_{\\mathrm{loc}}^{(v)}</span>, input messages <span class="math">\\left(z_i^{(v)}, \\pi_i^{(v)}. \\mathbb{x}, \\mathsf{acc}_i^{(v)}. \\mathbb{x}\\right)_{i \\in [m]}</span> and accumulation proof <span class="math">\\mathsf{pf}^{(v)}</span> from <span class="math">\\mathbf{w}^{(v)}</span>;</li>

      <li>append <span class="math">z_{\\mathrm{loc}}^{(v)}</span> to the label of <span class="math">v</span> in <span class="math">\\mathsf{T}&#x27;</span>;</li>

      <li>let <span class="math">S_{j} \\coloneqq \\{v \\in l_{\\mathsf{T}&#x27;}(j) : \\exists i, z_{i}^{(v)} \\neq \\bot\\}</span>;</li>

      <li>attach <span class="math">m</span> children to each <span class="math">v \\in S_j</span>, where the <span class="math">i</span>-th child is labeled with <span class="math">z_i^{(v)}</span>;</li>

      <li>define <span class="math">\\mathsf{qx}_i^{(v)} \\coloneqq \\big((\\mathsf{avk}, z_i^{(v)}, \\mathsf{acc}_i^{(v)}. \\mathbb{x}), \\pi_i^{(v)}. \\mathbb{x}\\big)</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\left(\\left(\\mathbb{i}^{(v)},\\mathsf{acc}^{(v)},\\mathsf{pf}^{(v)},[\\mathsf{qx}_i^{(v)}]_i^m,[\\mathsf{acc}_i^{(v)}.\\mathbb{x}]_{i = 1}^m\\right)_{v\\in S_j},(\\varphi ,\\mathsf{T}&#x27;,\\mathsf{ao})\\right)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fourth, we let <span class="math">\\mathrm{E}_{\\tilde{\\mathrm{P}}_j}</span> be the extractor corresponding to <span class="math">\\tilde{\\mathrm{P}}_j</span>, by the knowledge soundness of the split accumulation scheme AS.</li>

      <li>Finally, we define the extractor <span class="math">\\mathbb{E}_j</span> as follows:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbb{E}_j(\\mathbb{pp} = (\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}}),\\mathsf{ai})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the extractor <span class="math">\\left(\\left(\\mathbb{i}^{(v)},\\mathsf{acc}^{(v)},[\\mathsf{qx}_i^{(v)},\\mathsf{qw}_i^{(v)}]_i^m,[\\mathsf{acc}_i^{(v)}]_i^m\\right)_{v\\in S_j},\\mathsf{ao}&#x27;\\right)\\gets \\mathrm{E}_{\\tilde{\\mathrm{P}}_j}(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{ai}).</span></li>

      <li>Parse the auxiliary output <span class="math">\\mathsf{ao}&#x27;</span> as <span class="math">(\\varphi, \\mathsf{T}&#x27;, \\mathsf{ao})</span>. If <span class="math">\\mathsf{T}&#x27;</span> is not a transcript of depth <span class="math">j</span>, abort.</li>

      <li>Let <span class="math">S_{j} \\coloneqq \\{v \\in l_{\\mathsf{T}&#x27;}(j) : \\exists i, z_{i}^{(v)} \\neq \\bot\\}</span>.</li>

      <li>Parse each <span class="math">\\mathsf{qx}_i^{(v)}</span> as <span class="math">((\\mathsf{avk}^{(v)},z_i^{(v)},\\mathsf{acc}_i^{(v)}.\\mathbb{x}),\\pi_i^{(v)}.\\mathbb{x})</span> and <span class="math">\\mathsf{qw}_i^{(v)}</span> as <span class="math">\\pi_i^{(v)}.\\mathbb{w}</span>; combine each pair <span class="math">(\\pi_i^{(v)}.\\mathbb{x},\\pi_i^{(v)}.\\mathbb{w})</span> into a proof <span class="math">\\pi_i^{(v)}</span>.</li>

      <li>Output <span class="math">(\\varphi, \\mathsf{T}_j, \\mathsf{ao})</span> where <span class="math">\\mathsf{T}_j</span> is the transcript constructed from <span class="math">\\mathsf{T}&#x27;</span> by adding, for each vertex <span class="math">v \\in S_j</span>, <span class="math">(\\pi_i^{(v)}, \\mathsf{acc}_i^{(v)})</span> to the label of its <span class="math">i</span>-th child.</li>

    </ol>

    <p class="text-gray-300">We now show that <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> runs in expected polynomial time and that it outputs a transcript that is <span class="math">\\varphi</span>-compliant.</p>

    <p class="text-gray-300"><strong>Running time of the extractor.</strong> It follows from the extraction guarantees of ARG and AS that <span class="math">\\mathbb{E}_j</span> runs in expected time polynomial in the expected running time of <span class="math">\\mathbb{E}_{j-1}</span>. Hence if <span class="math">d(\\varphi)</span> is a constant, <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}} = \\mathbb{E}_{d(\\varphi)}</span> runs in expected polynomial time.</p>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300">Correctness of the extractor. Fix a set <span class="math">Z</span>, and suppose that <span class="math">\\tilde{\\mathbb{P}}</span>'s output falls in <span class="math">Z</span> and causes <span class="math">\\mathbb{V}</span> to accept, with probability <span class="math">\\mu</span>. We show by induction that, for all <span class="math">j \\in \\{0, \\dots, d\\}</span>, the transcript <span class="math">\\mathsf{T}_j</span> output by <span class="math">\\mathbb{E}_j</span> is <span class="math">\\varphi</span>-compliant up to depth <span class="math">j</span>, and that for all <span class="math">v \\in \\mathsf{T}_j</span>, both <span class="math">\\mathcal{V}(\\mathrm{ivk}, (\\mathsf{avk}, z^{(v)}, \\mathsf{acc}^{(v)}.\\mathbf{x}), \\pi^{(v)})</span> and <span class="math">\\mathrm{D}(\\mathsf{dk}, \\mathsf{acc}^{(v)})</span> accept, and that <span class="math">(\\mathbb{pp}, \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}_j), \\mathsf{ao}) \\in Z</span> and <span class="math">\\varphi \\in \\mathsf{F}</span>, with probability <span class="math">\\mu - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">For <span class="math">j = 0</span> the statement holds by assumption.</p>

    <p class="text-gray-300">Now suppose that <span class="math">(\\varphi, \\mathsf{T}_{j-1}) \\gets \\mathbb{E}_{j-1}(\\mathbb{pp}, \\mathsf{ai})</span> is such that <span class="math">\\mathsf{T}_{j-1}</span> is <span class="math">\\varphi</span>-compliant up to depth <span class="math">j-1</span>, and that both <span class="math">\\mathcal{V}(\\mathrm{ivk}, (\\mathsf{avk}, z^{(v)}, \\mathsf{acc}^{(v)}.\\mathbf{x}), \\pi^{(v)})</span> and <span class="math">\\mathrm{D}(\\mathsf{dk}, \\mathsf{acc}^{(v)})</span> accept for all <span class="math">v \\in \\mathsf{T}_{j-1}</span> with probability <span class="math">\\mu - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Let <span class="math">(\\vec{\\mathfrak{s}}, (\\mathsf{avk}_v, z^{(v)}, \\mathsf{acc}^{(v)}.\\mathbf{x})_v, (\\pi^{(v)})_v, (\\varphi, \\mathsf{T}&#x27;), \\vec{\\mathfrak{w}})</span> be the output of <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}_j}(\\mathsf{pp}, (\\mathsf{pp}_{\\mathsf{AS}}, \\mathsf{ai}))</span>.</p>

    <p class="text-gray-300">We let <span class="math">(\\mathsf{pp}, (\\mathsf{pp}_{\\mathsf{AS}}, \\mathsf{ai}), \\vec{\\mathfrak{s}}, (\\mathsf{avk}_v, z^{(v)}, \\mathsf{acc}^{(v)}.\\mathbf{x})_v, (\\varphi, \\mathsf{T}&#x27;, \\mathsf{ao})) \\in Z&#x27;</span> if and only if, for <span class="math">(\\mathsf{apk}, \\mathsf{dk}, \\mathsf{avk}) \\gets \\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}}, \\mathsf{pp}, R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)})</span> it holds that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">((\\mathsf{pp}, \\mathsf{pp}_{\\mathsf{AS}}), \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}&#x27;), \\mathsf{ao}) \\in Z</span> and <span class="math">\\varphi \\in \\mathsf{F}</span>;</li>

      <li><span class="math">\\dot{\\mathfrak{s}}^{(v)} = R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}</span> and <span class="math">\\mathsf{avk}_v = \\mathsf{avk}</span> for all <span class="math">v</span>;</li>

      <li><span class="math">\\mathsf{T}&#x27;</span> is <span class="math">\\varphi</span>-compliant up to depth <span class="math">j - 1</span>;</li>

      <li><span class="math">\\mathrm{D}(\\mathrm{dk}, \\mathrm{acc}^{(v)})</span> accepts for all <span class="math">v \\in \\mathsf{T}&#x27;</span>; and</li>

      <li>for <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>, <span class="math">v</span> is labeled in <span class="math">\\mathsf{T}&#x27;</span> with <span class="math">(z^{(v)}, \\pi^{(v)}, \\mathsf{acc}^{(v)})</span>.</li>

    </ul>

    <p class="text-gray-300">By knowledge soundness, with probability <span class="math">\\mu -\\mathrm{negl}(\\lambda)</span>, <span class="math">(\\mathsf{pp},(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{ai}),\\vec{\\mathfrak{s}},(\\mathrm{ivk}_v,z^{(v)})_v,(\\varphi ,\\mathsf{T}&#x27;))\\in Z&#x27;</span> and for every vertex <span class="math">v\\in l_{\\mathsf{T}&#x27;}(j)</span>, <span class="math">(R_{\\mathrm{V},\\varphi}^{(\\lambda ,N,k)},(\\mathsf{avk}_v,z^{(v)},\\mathsf{acc}^{(v)}),\\mathsf{w}^{(v)})\\in \\mathcal{R}_{\\mathrm{R1CS}}</span>. Here we use <span class="math">Z^{\\prime}</span> and the auxiliary output in the knowledge soundness definition of ARG to ensure consistency between the values <span class="math">z^{(v)}</span> and <span class="math">\\mathsf{T}&#x27;</span>, and to ensure that <span class="math">\\mathsf{T}&#x27;</span> is <span class="math">\\varphi</span>-compliant and that the decider accepts.</p>

    <p class="text-gray-300">Consider some <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>. Since <span class="math">(R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}, (\\mathsf{avk}^{(v)}, z^{(v)}, \\mathsf{acc}^{(v)}.\\mathbf{x}), \\mathsf{w}^{(v)}) \\in \\mathcal{R}_{\\mathrm{R1CS}}</span>, we obtain from <span class="math">\\mathsf{w}^{(v)}</span> either:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>local data <span class="math">z_{\\mathrm{loc}}^{(v)}</span>, input messages <span class="math">\\left(z_i^{(v)}, \\pi_i^{(v)}.\\mathbf{x}, \\mathsf{acc}_i^{(v)}.\\mathbf{x}\\right)_{i \\in [m]}</span> and proof <span class="math">\\mathsf{pf}</span> such that <span class="math">\\varphi(z^{(v)}, z_{\\mathrm{loc}}, z_1, \\ldots, z_m)</span> accepts and the accumulation verifier <span class="math">V^{(\\lambda, N, k)}(\\mathsf{avk}^{(v)}, [\\mathsf{qx}_i^{(v)}]_i = 1, [\\mathsf{acc}_i^{(v)}.\\mathbf{x}]_{i=1}^m, \\mathsf{acc}^{(v)}, \\mathsf{pf}^{(v)})</span> accepts, where <span class="math">\\mathsf{qx}_i^{(v)} := ((\\mathsf{avk}^{(v)}, z_i^{(v)}, \\mathsf{acc}_i^{(v)}.\\mathbf{x}), \\pi_i^{(v)}.\\mathbf{x})</span>; or</li>

      <li>local data <span class="math">z_{\\mathrm{loc}}^{(v)}</span> such that <span class="math">\\varphi(z^{(v)}, z_{\\mathrm{loc}}^{(v)}, \\bot, \\dots, \\bot)</span> accepts.</li>

    </ul>

    <p class="text-gray-300">In both cases we append <span class="math">z_{\\mathrm{loc}}^{(v)}</span> to the label of <span class="math">v</span>. In the latter case, <span class="math">v</span> has no children and so is <span class="math">\\varphi</span>-compliant by the base case condition. In the former case we label the children of <span class="math">v</span> with <span class="math">(z_i, \\pi_i, \\mathsf{acc}_i)</span>, and so <span class="math">v</span> is <span class="math">\\varphi</span>-compliant.</p>

    <p class="text-gray-300">We define <span class="math">(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp},\\mathsf{ai},(\\dot{\\mathfrak{s}}^{(v)},\\mathsf{acc}^{(v)},[\\mathsf{qx}_i^{(v)}]_i = 1,[\\mathsf{acc}_i^{(v)}.\\mathbf{x}]_{i = 1}^m)_v,(\\varphi ,\\mathsf{T}&#x27;,\\mathsf{ao}))\\in Z&#x27;&#x27;</span> if and only if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">((\\mathsf{pp}, \\mathsf{pp}_{\\mathsf{AS}}), \\mathsf{ai}, \\varphi, \\mathsf{o}(\\mathsf{T}&#x27;), \\mathsf{ao}) \\in Z</span> and <span class="math">\\varphi \\in \\mathsf{F}</span>,</li>

      <li><span class="math">\\dot{\\mathfrak{s}}^{(v)} = R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}</span> for all <span class="math">v</span>,</li>

      <li><span class="math">\\mathsf{T}&#x27;</span> is <span class="math">\\varphi</span>-compliant up to depth <span class="math">j</span>,</li>

      <li>for all <span class="math">v, \\mathbf{qx}_i^{(v)} = ((\\mathsf{avk}, z_i^{(v)}, \\mathsf{acc}_i^{(v)}.\\mathbf{x}), \\pi_i^{(v)})</span> where <span class="math">(\\mathsf{apk}, \\mathsf{avk}, \\mathsf{dk}) \\gets \\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}}, \\mathsf{pp}_{\\Phi}, \\mathrm{i}_{\\Phi})</span>, and</li>

      <li>for <span class="math">u \\in l_{\\mathsf{T}&#x27;}(j + 1)</span>, where <span class="math">u</span> is the <span class="math">i</span>-th child of <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>, <span class="math">u</span> is labeled in <span class="math">\\mathsf{T}&#x27;</span> with <span class="math">z_i^{(v)}</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\left(\\left(\\dot{\\mathfrak{s}}^{(v)},\\mathsf{acc}^{(v)},[\\mathsf{qx}_i^{(v)},\\mathsf{qw}_i^{(v)}]_i = 1,[\\mathsf{acc}_i^{(v)}]_i = 1\\right)_{v\\in S_j},\\mathsf{ao}&#x27;\\right)\\gets \\mathrm{E}_{\\tilde{\\mathcal{P}}_j}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp},\\mathsf{ai}).</span> By the knowledge soundness guarantee of the accumulation scheme, <span class="math">(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai},(\\dot{\\mathfrak{s}}^{(v)},\\mathsf{acc}^{(v)},[\\mathsf{qx}_i^{(v)}]_i = 1,\\mathsf{acc}_i^{(v)}.\\mathbf{x}]_{i = 1}^m)_v,\\mathsf{ao}&#x27;)\\in Z&#x27;&#x27;</span> and it holds that for all descendants <span class="math">u</span> of <span class="math">v</span> in <span class="math">\\mathsf{T}_j</span>, <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc}^{(u)})</span> accepts and <span class="math">\\Phi_{\\mathcal{V}}(\\mathsf{pp},R_{\\mathrm{V},\\varphi}^{(\\lambda ,N,k)},(\\mathsf{avk},z^{(u)},\\mathsf{acc}^{(u)}.\\mathbf{x}),\\pi_{\\mathrm{in}}^{(u)}) = \\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z^{(u)},\\mathsf{acc}^{(u)}.\\mathbf{x}),\\pi_{\\mathrm{in}}^{(u)})</span> accepts, with probability <span class="math">\\mu -\\mathrm{negl}(\\lambda)</span>; this completes the inductive step.</p>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">Hence by induction, <span class="math">(\\varphi,\\mathsf{T},\\mathsf{ao})\\leftarrow\\mathbb{E}(\\mathfrak{pp},\\mathsf{ai})</span> has <span class="math">\\varphi</span>-compliant <span class="math">\\mathsf{T}</span>, <span class="math">(\\mathfrak{pp},\\mathsf{ai},\\varphi,\\mathsf{o}(\\mathsf{T}),\\mathsf{ao})\\in Z</span>, and <span class="math">\\varphi\\in\\mathsf{F}</span>, with probability <span class="math">\\mu-\\mathrm{negl}(\\lambda)</span>.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">5.4 Zero knowledge</h3>

    <p class="text-gray-300">The simulator <span class="math">\\mathbb{S}</span> operates as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathbb{S}(1^{\\lambda})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample simulated parameters for the non-interactive argument: <span class="math">(\\mathsf{pp},\\tau)\\leftarrow\\mathcal{S}(1^{\\lambda})</span>.</li>

      <li>Sample simulated parameters for the accumulation scheme: <span class="math">(\\mathsf{pp}_{\\mathsf{AS}},\\tau_{\\mathsf{AS}})\\leftarrow\\mathrm{S}(1^{\\lambda})</span>.</li>

      <li>Output <span class="math">(\\mathfrak{pp}:=(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}}),(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}},\\tau,\\tau_{\\mathsf{AS}}))</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbb{S}((\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}},\\tau,\\tau_{\\mathsf{AS}}),\\varphi,z)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute accumulator keys: <span class="math">(\\mathsf{apk},\\mathsf{dk},\\mathsf{avk}):=\\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp}_{\\Phi}=\\mathsf{pp},\\mathsf{i}_{\\Phi}=R^{(\\lambda,N,k)}_{\\mathrm{V},\\varphi})</span>.</li>

      <li>Sample simulated accumulator: <span class="math">\\mathsf{acc}\\leftarrow\\mathrm{S}(\\tau_{\\mathsf{AS}},\\mathsf{pp}_{\\Phi}=\\mathsf{pp},\\mathsf{i}_{\\Phi}=R^{(\\lambda,N,k)}_{\\mathrm{V},\\varphi})</span>.</li>

      <li>Sample simulated argument: <span class="math">\\pi\\leftarrow\\mathcal{S}(\\tau,R^{(\\lambda,N,k)}_{\\mathrm{V},\\varphi},(\\mathsf{avk},z,\\mathsf{acc}.\\mathtt{x}))</span>.</li>

      <li>Output <span class="math">(\\pi,\\mathsf{acc})</span>.</li>

    </ol>

    <p class="text-gray-300">We consider the following sequence of hybrids.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{H}_{0}</span>: The original experiment.</li>

      <li><span class="math">\\mathbf{H}_{1}</span>: As <span class="math">\\mathbf{H}_{0}</span>, but the public parameters <span class="math">\\mathsf{pp}</span> and proof <span class="math">\\pi</span> are generated by the simulator <span class="math">\\mathcal{S}</span> for <span class="math">\\mathsf{ARG}</span>.</li>

      <li><span class="math">\\mathbf{H}_{2}</span>: As <span class="math">\\mathbf{H}_{1}</span>, but the public parameters <span class="math">\\mathsf{pp}_{\\mathsf{AS}}</span> and accumulator <span class="math">\\mathsf{acc}</span> is generated by the simulator <span class="math">\\mathrm{S}</span> for <span class="math">\\mathsf{AS}</span>.</li>

    </ul>

    <p class="text-gray-300">We need to argue that <span class="math">\\mathbf{H}_{0}</span> and <span class="math">\\mathbf{H}_{2}</span> are indistinguishable.</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{A}</span> is honest (for <span class="math">\\mathsf{PCD}</span>), by completeness of <span class="math">\\mathsf{AS}</span> it induces an honest adversary for <span class="math">\\mathsf{ARG}</span>, whence <span class="math">\\mathbf{H}_{0}</span> and <span class="math">\\mathbf{H}_{1}</span> are indistinguishable by the zero knowledge property of <span class="math">\\mathsf{ARG}</span>. Note that since they are part of the witness, the input and accumulator lists <span class="math">[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m}</span> and verifier proof <span class="math">\\mathsf{pf}</span> are not used in <span class="math">\\mathbf{H}_{1}</span>. Hence, since <span class="math">\\mathcal{A}</span> induces an honest adversary for <span class="math">\\mathsf{AS}</span> and the simulated <span class="math">\\mathsf{pp}</span> is indistinguishable from the real <span class="math">\\mathsf{pp}</span> (sampled by <span class="math">\\mathcal{G}(1^{\\lambda})</span>), <span class="math">\\mathbf{H}_{1}</span> and <span class="math">\\mathbf{H}_{2}</span> are indistinguishable by the zero knowledge property of <span class="math">\\mathsf{AS}</span>.</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">5.5 Efficiency</h3>

    <p class="text-gray-300">The efficiency argument follows from Lemma 5.5 and is essentially identical to that of <em>[x1]</em>, and so we will not repeat it. We note only that the quantity <span class="math">\\mathsf{v}^{*}</span> (i) describes the size of the accumulation verifier, which in particular need not read the entire NARK proof, which may be large, and (ii) is a function of the size of the accumulator instance alone; the accumulator witness may be large.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Lemma 5.5.</h6>

    <p class="text-gray-300">Suppose that for every security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, arity <span class="math">m</span>, and message size <span class="math">\\ell\\in\\mathbb{N}</span> the ratio of accumulation verifier circuit size to index size <span class="math">\\mathsf{v}^{*}(\\lambda,m,N,\\ell)/N</span> is monotone decreasing in <span class="math">N</span>. Then there exists a size function <span class="math">N(\\lambda,f,m,\\ell)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\forall\\,\\lambda,f,m,\\ell\\in\\mathbb{N}\\quad S(\\lambda,f,m,\\ell,N(\\lambda,f,m,\\ell))\\leq N(\\lambda,f,m,\\ell)\\enspace.</span></p>

    <p class="text-gray-300">Moreover if for some <span class="math">\\epsilon&gt;0</span> and some increasing function <span class="math">\\alpha</span> it holds that, for all <span class="math">N,\\lambda,m,\\ell</span> sufficiently large,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{v}^{*}(\\lambda,m,N,\\ell)\\leq N^{1-\\epsilon}\\alpha(\\lambda,m,\\ell)</span></p>

    <p class="text-gray-300">then, for all <span class="math">\\lambda,m,\\ell</span> sufficiently large, <span class="math">N(\\lambda,f,m,\\ell)\\leq O(f+\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">5.6 Post-quantum security</p>

    <p class="text-gray-300">We consider post-quantum knowledge soundness and zero knowledge.</p>

    <h5 id="sec-55" class="text-base font-semibold mt-4">Knowledge soundness.</h5>

    <p class="text-gray-300">In the quantum setting, <span class="math">\\tilde{\\mathbb{P}}</span> is taken to be a polynomial-size <em>quantum</em> circuit; hence also <span class="math">\\tilde{\\mathcal{P}}_{j},\\mathcal{E}_{\\tilde{\\mathcal{P}}_{j}},\\tilde{\\mathrm{P}}_{j},\\mathrm{E}_{\\tilde{\\mathrm{P}}_{j}},\\mathbb{E}_{j}</span> are quantum circuits for all <span class="math">j</span>, as is the final extractor <span class="math">\\mathbb{E}</span>. Our definition of knowledge soundness is such that our proof then generalizes immediately to show security against quantum adversaries. In particular, the only difficulty arising from quantum adversaries is that they can generate their own randomness, whereas in the classical case we can force an adversary to behave deterministically by fixing its randomness. This difference is resolved by our strong adaptive knowledge extraction property, which we use to enforce that the extractor’s output is consistent with the transcript obtained so far.</p>

    <h5 id="sec-56" class="text-base font-semibold mt-4">Zero knowledge.</h5>

    <p class="text-gray-300">From the argument in the preceding section it is clear that, by modifying the definitions of zero knowledge as appropriate for the quantum setting, if ARG and AS both achieve post-quantum zero knowledge, then so does PCD.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">6 An expected-time forking lemma</p>

    <p class="text-gray-300">We establish useful notation for algorithms with access to oracles (Section 6.1), and then provide an expected-time forking lemma with negligible loss (Section 6.2). We use this technical lemma to prove the security of split accumulation schemes in later sections.</p>

    <p class="text-gray-300">6.1 Notation for oracle algorithms</p>

    <p class="text-gray-300">Let <span class="math">A</span> be a <span class="math">t</span>-query oracle algorithm with access to an oracle <span class="math">\\rho\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}</span>. For <span class="math">\\vec{\\mathfrak{a}}=({\\mathfrak{a}}_{1},\\ldots,{\\mathfrak{a}}_{t})\\in(\\{0,1\\}^{\\lambda})^{t}</span>, we denote by <span class="math">({\\mathfrak{q}},{\\mathfrak{o}};{\\mathfrak{tr}},r)\\leftarrow A^{\\vec{\\mathfrak{a}}}(x)</span> the following procedure: run <span class="math">A</span> on input <span class="math">x</span>, and answer the <span class="math">i</span>-th query <span class="math">{\\mathfrak{q}}_{i}</span> of <span class="math">A</span> to its oracle with <span class="math">{\\mathfrak{a}}_{i}</span> for each <span class="math">i</span>; output <span class="math">({\\mathfrak{q}},{\\mathfrak{o}};{\\mathfrak{tr}},r)</span>, where <span class="math">r</span> is the randomness used by <span class="math">A</span>. We write <span class="math">({\\mathfrak{q}},{\\mathfrak{o}};{\\mathfrak{tr}},r)\\leftarrow A^{\\rho}(x)</span> to denote the same procedure when each <span class="math">{\\mathfrak{a}}_{i}</span> is adaptively set to <span class="math">\\rho({\\mathfrak{q}}_{i})</span>.</p>

    <p class="text-gray-300">We assume without loss of generality that <span class="math">A</span> makes no duplicate queries; in particular, we can interpret <span class="math">\\mathfrak{tr}</span> as partial function <span class="math">\\mathfrak{tr}\\colon\\{0,1\\}^{*}\\rightharpoonup\\{0,1\\}^{\\lambda}</span>. For a query transcript <span class="math">\\mathfrak{tr}=[({\\mathfrak{q}}_{i},{\\mathfrak{a}}_{i})]_{i=1}^{t}</span> and query <span class="math">{\\mathfrak{q}}</span>, if <span class="math">{\\mathfrak{q}}={\\mathfrak{q}}_{j}</span> for some <span class="math">j\\in[t]</span> then let <span class="math">j</span> be the smallest such index, and define <span class="math">\\mathfrak{tr}_{\\mathfrak{q}}:=[({\\mathfrak{q}}_{i},{\\mathfrak{a}}_{i})]_{i=1}^{j-1}</span>. That is, <span class="math">\\mathfrak{tr}</span> is truncated to the query before the first query to <span class="math">{\\mathfrak{q}}</span>. If <span class="math">{\\mathfrak{q}}</span> does not appear in <span class="math">\\mathfrak{tr}</span>, define <span class="math">\\mathfrak{tr}_{\\mathfrak{q}}:=\\bot</span>.</p>

    <p class="text-gray-300">6.2 An expected-time forking lemma</p>

    <p class="text-gray-300">We give an expected-time forking lemma that is suitable for our setting. In particular, it handles adversaries with an expected running time guarantee, which is a requirement of our knowledge soundness definition.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 6.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{p}</span> be a predicate computable in time <span class="math">t_{\\mathfrak{p}}</span>. There exists an algorithm <span class="math">\\mathsf{Fork}</span> such that for every public parameter string <span class="math">\\mathfrak{pp}\\in\\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span> and oracle algorithm <span class="math">A</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{ccl}\\mathfrak{tr}_{\\mathfrak{q}}\\neq\\bot\\wedge\\mathfrak{p}(\\mathfrak{pp},({\\mathfrak{q}},\\rho({\\mathfrak{q}})),{\\mathfrak{o}},\\mathfrak{tr}_{\\mathfrak{q}})=1\\\\ \\Downarrow&\\\\ \\forall j\\in[N],\\mathfrak{p}(\\mathfrak{pp},({\\mathfrak{q}},{\\mathfrak{b}}_{j}),{\\mathfrak{o}}_{j},\\mathfrak{tr}_{\\mathfrak{q}})=1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\wedge{\\mathfrak{b}}_{1},\\ldots,{\\mathfrak{b}}_{N}\\text{ are pairwise distinct}\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\rho\\leftarrow\\mathcal{U}(\\lambda)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">({\\mathfrak{q}},{\\mathfrak{o}};{\\mathfrak{tr}},r)\\leftarrow A^{\\rho}(\\mathfrak{pp})\\\\ [\\mathfrak{b}_{j},{\\mathfrak{o}}_{j}]_{j=1}^{N}\\leftarrow\\mathsf{Fork}^{A}(\\mathfrak{pp},1^{N},({\\mathfrak{q}},\\rho({\\mathfrak{q}})),{\\mathfrak{o}},\\mathfrak{tr}_{\\mathfrak{q}},r)\\end{array}\\right]\\geq 1-\\frac{2N\\sqrt{t}}{2^{\\lambda/2}}\\ . \\]</p>

    <p class="text-gray-300">In the above experiment, <span class="math">\\mathsf{Fork}</span> runs in expected time <span class="math">O(tN\\cdot(t_{A}+t_{\\mathfrak{p}}))</span>, where <span class="math">t</span> is a strict bound on the number of oracle queries made by <span class="math">A</span> and <span class="math">t_{A}</span> is its expected running time.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The algorithm <span class="math">\\mathsf{Fork}</span> on input <span class="math">({\\mathfrak{pp}},1^{N},({\\mathfrak{q}},{\\mathfrak{a}}),{\\mathfrak{o}},{\\mathfrak{tr}},r)</span> operates as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathfrak{tr}=\\bot</span> or <span class="math">\\mathfrak{p}(\\mathfrak{pp},({\\mathfrak{q}},{\\mathfrak{a}}),{\\mathfrak{o}},{\\mathfrak{tr}})=0</span>, output <span class="math">\\bot</span>.</li>

      <li>Parse <span class="math">\\mathfrak{tr}</span> as <span class="math">[({\\mathfrak{q}}_{1},{\\mathfrak{a}}_{1}),\\ldots,({\\mathfrak{q}}_{i-1},{\\mathfrak{a}}_{i-1})]</span>.</li>

      <li>Set <span class="math">{\\mathfrak{b}}_{1}:={\\mathfrak{a}}</span> and <span class="math">{\\mathfrak{o}}_{1}:={\\mathfrak{o}}</span>.</li>

      <li>Set <span class="math">J:=1</span> and repeat the following until <span class="math">J=N</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Draw <span class="math">{\\mathfrak{a}}_{i}^{\\prime},\\ldots,{\\mathfrak{a}}_{t}^{\\prime}\\leftarrow\\{0,1\\}^{\\lambda}</span>.</li>

      <li>Run <span class="math">A^{{\\mathfrak{a}}_{1},\\ldots,{\\mathfrak{a}}_{i-1},{\\mathfrak{a}}_{i}^{\\prime},\\ldots,{\\mathfrak{a}}_{t}^{\\prime}}({\\mathfrak{pp}};r)</span> until it halts and outputs <span class="math">({\\mathfrak{q}}^{\\prime},{\\mathfrak{o}}^{\\prime};{\\mathfrak{tr}}^{\\prime},r^{\\prime})</span>. If <span class="math">r^{\\prime}</span> is longer than <span class="math">r</span>, set <span class="math">r:=r^{\\prime}</span>.</li>

      <li>If <span class="math">{\\mathfrak{q}}^{\\prime}={\\mathfrak{q}}</span> (in particular, <span class="math">\\mathfrak{tr}_{\\mathfrak{q}}^{\\prime}=\\mathfrak{tr}_{\\mathfrak{q}}</span>) and <span class="math">\\mathfrak{p}(\\mathfrak{pp},({\\mathfrak{q}},{\\mathfrak{a}}_{i}^{\\prime}),{\\mathfrak{o}}^{\\prime},{\\mathfrak{tr}})=1</span>, set <span class="math">J:=J+1</span>, <span class="math">{\\mathfrak{b}}_{J}:={\\mathfrak{a}}_{i}^{\\prime}</span>, and <span class="math">{\\mathfrak{o}}_{J}:={\\mathfrak{o}}^{\\prime}</span>.</li>

      <li>Output <span class="math">({\\mathfrak{b}}_{1},{\\mathfrak{o}}_{1},\\ldots,{\\mathfrak{b}}_{N},{\\mathfrak{o}}_{N})</span>.</li>

    </ol>

    <p class="text-gray-300">For the purposes of analysis, we consider an experiment where both <span class="math">A</span> and <span class="math">\\mathsf{Fork}</span> obtain their randomness from a shared infinite tape <span class="math">\\sigma\\in\\{0,1\\}^{*}</span>. This is indistinguishable from the real experiment since we can view the (common) randomness generated by all runs of <span class="math">A</span> as being the prefix of <span class="math">\\sigma</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $S_{i} := \\{(\\vec{a}, \\sigma) : (\\mathsf{q}, \\mathsf{o}; \\mathsf{tr}) \\leftarrow A^{\\vec{a}}(\\mathsf{pp}; \\sigma) \\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{tr}_{\\mathsf{q}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= i \\wedge \\mathsf{p}(\\mathsf{pp}, (\\mathsf{q}, \\mathsf{a}_{i}), \\mathsf{o}, \\mathsf{tr}_{\\mathsf{q}}) = 1\\}$. Define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {i} (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) := \\operatorname * {P r} _ {\\mathfrak {a} _ {i} ^ {\\prime}, \\dots , \\mathfrak {a} _ {t} ^ {\\prime} \\in \\{0, 1 \\} ^ {\\lambda}} [ (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}, \\mathfrak {a} _ {i} ^ {\\prime}, \\dots , \\mathfrak {a} _ {t} ^ {\\prime}, \\sigma) \\in S _ {i} ].</span></div>

    <p class="text-gray-300">Observe that if <span class="math">(\\vec{a},\\sigma)\\in S_i</span> then the probability that one iteration of Step 4 increments <span class="math">J</span> is <span class="math">\\delta_{i}(\\mathfrak{a}_{1},\\ldots ,\\mathfrak{a}_{i - 1};\\sigma)</span>. If the precondition on the left of the probability statement holds then Fork does not terminate in Step 1. In this case <span class="math">\\delta_{i}(\\mathfrak{a}_{1},\\dots ,\\mathfrak{a}_{i - 1};\\sigma) &amp;gt; 0</span>, and Fork's output (if it halts) satisfies “<span class="math">\\forall j\\in [N],\\mathsf{p}(\\mathsf{pp},(\\mathsf{q},\\mathsf{b}_j),\\mathsf{o}_j,\\mathsf{tr}_{\\mathsf{q}}) = 1</span>”.</p>

    <p class="text-gray-300">We now bound the expected running time of Fork. Let <span class="math">T_{A}, T_{\\text{Fork}}</span> be random variables denoting the running time of <span class="math">A</span>, Fork respectively, and let <span class="math">t(\\mathfrak{a}_1, \\ldots, \\mathfrak{a}_{i-1}; \\sigma)</span> denote the expected running time of a single iteration of Step 4. The number of iterations between <span class="math">J = j</span> and <span class="math">J = j + 1</span>, which we denote <span class="math">X^{(j)}</span>, is geometrically distributed with parameter <span class="math">\\delta_i(\\mathfrak{a}_1, \\ldots, \\mathfrak{a}_{i-1}; \\sigma) &amp;gt; 0</span> when <span class="math">(\\vec{a}, \\sigma) \\in S_i</span>. We denote the time between these increments of <span class="math">J</span> by <span class="math">T^{(j)}</span> and note that, when <span class="math">(\\vec{a}; \\sigma) \\in S_i</span>, <span class="math">\\mathbb{E}[T^{(j)} \\mid X^{(j)} = m] = m \\cdot t(\\mathfrak{a}_1, \\ldots, \\mathfrak{a}_{i-1}; \\sigma)</span> by linearity. Let</p>

    <div class="my-4 text-center"><span class="math-block">f (\\mathfrak {a} _ {1}, \\ldots , \\mathfrak {a} _ {i - 1}; \\sigma) := \\left\\{ \\begin{array}{l l} \\frac {t (\\mathfrak {a} _ {1} , \\ldots , \\mathfrak {a} _ {i - 1} ; \\sigma)}{\\delta_ {i} (\\mathfrak {a} _ {1} , \\ldots , \\mathfrak {a} _ {i - 1} ; \\sigma)} &amp;amp; \\text {if} \\delta_ {i} (\\mathfrak {a} _ {1}, \\ldots , \\mathfrak {a} _ {i - 1}; \\sigma) \\neq 0 \\\\ 0 &amp;amp; \\text {otherwise} \\end{array} \\right..</span></div>

    <p class="text-gray-300">By the law of total expectation:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbb {E} \\left[ T _ {\\text {F o r k}} \\right] = \\mathbb {E} _ {\\vec {a}, \\sigma} \\left[ \\mathbb {E} \\left[ T _ {\\text {F o r k}} \\mid (\\vec {a}, \\sigma) \\right] \\right] \\\\ = \\mathbb {E} _ {\\vec {a}, \\sigma} \\left[ \\sum_ {j = 1} ^ {N} \\sum_ {m = 1} ^ {\\infty} \\Pr [ X ^ {(j)} = m \\mid (\\vec {a}, \\sigma) ] \\cdot \\mathbb {E} [ T ^ {(j)} \\mid X ^ {(j)} = m, (\\vec {a}, \\sigma) ] \\right] \\\\ = \\frac {N}{2 ^ {t \\lambda}} \\cdot \\sum_ {i = 1} ^ {t} \\mathbb {E} _ {\\sigma} \\left[ \\sum_ {\\vec {a} \\text {s . t .} (\\vec {a}, \\sigma) \\in S _ {i}} \\sum_ {m = 1} ^ {\\infty} \\left(1 - \\delta_ {i} (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma)\\right) ^ {m - 1} \\cdot \\delta_ {i} (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) \\cdot m \\cdot t (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) \\right] \\\\ = \\frac {N}{2 ^ {t \\lambda}} \\cdot \\sum_ {i = 1} ^ {t} \\mathbb {E} _ {\\sigma} \\left[ \\sum_ {\\vec {a} \\text {s . t .} (\\vec {a}, \\sigma) \\in S _ {i}} \\frac {t \\left(\\mathfrak {a} _ {1} , \\dots , \\mathfrak {a} _ {i - 1} ; \\sigma\\right)}{\\delta_ {i} \\left(\\mathfrak {a} _ {1} , \\dots , \\mathfrak {a} _ {i - 1} ; \\sigma\\right)} \\right] \\\\ = \\frac {N}{2 ^ {t \\lambda}} \\cdot \\sum_ {i = 1} ^ {t} \\mathbb {E} _ {\\sigma} \\left[ \\sum_ {\\vec {a} \\text {s . t .} (\\vec {a}, \\sigma) \\in S _ {i}} f (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) \\right] \\\\ \\leq N \\cdot \\sum_ {i = 1} ^ {t} \\mathbb {E} _ {\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}, \\sigma} [ t (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) ] \\\\ = N \\cdot t \\cdot \\left(\\mathbb {E} \\left[ T _ {A} \\right] + t _ {\\mathrm {p}} + O (t)\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Above the inequality follows because for all functions <span class="math">f(\\mathfrak{a}_1, \\ldots, \\mathfrak{a}_{i-1}; \\sigma)</span> into <span class="math">\\mathbb{R}</span> and <span class="math">\\sigma \\in \\{0, 1\\}^*</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {\\vec {a} \\text {s . t .} (\\vec {a}, \\sigma) \\in S _ {i}} f (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) = \\sum_ {\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}} f (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) \\sum_ {\\mathfrak {a} _ {i}, \\dots , \\mathfrak {a} _ {t}} 1 _ {S _ {i}} (\\vec {a}, \\sigma) \\\\ = 2 ^ {(t - i + 1) \\lambda} \\sum_ {\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}} f (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma) \\cdot \\delta_ {i} (\\mathfrak {a} _ {1}, \\dots , \\mathfrak {a} _ {i - 1}; \\sigma). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">It remains to show that the <span class="math">\\mathfrak{b}_1, \\ldots, \\mathfrak{b}_N</span> are pairwise distinct. Similarly to the above, it can be shown that the expected number of iterations is at most <span class="math">Nt</span>, and so the probability that Fork performs more than</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300"><span class="math">\\sqrt{t} \\cdot 2^{\\lambda/2}</span>  iterations is at most  <span class="math">\\frac{Nt}{\\sqrt{t} \\cdot 2^{\\lambda/2}} = \\frac{N\\sqrt{t}}{2^{\\lambda/2}}</span> . Conditioned on this, the probability that in any iteration we draw  <span class="math">\\mathfrak{a}_i&#x27;</span>  such that  <span class="math">\\mathfrak{a}_i&#x27; = \\mathfrak{b}_j</span>  for any  <span class="math">j &amp;lt; J</span>  is at most  <span class="math">\\frac{N\\sqrt{t}2^{\\lambda/2}}{2^{\\lambda}} = \\frac{N\\sqrt{t}}{2^{\\lambda/2}}</span> . By a union bound we obtain that the probability that there exist two elements among  <span class="math">\\mathfrak{b}_1, \\ldots, \\mathfrak{b}_N</span>  that are equal is at most  <span class="math">2 \\cdot \\frac{N\\sqrt{t}}{2^{\\lambda/2}}</span> .</p>

    <p class="text-gray-300">The following corollary enables extraction from protocols with two sequential oracle queries; e.g., those arising from the Fiat-Shamir transformation applied to a five-message protocol. It is shown by "recursively" applying the above forking lemma to an adversary constructed using the Fork algorithm itself.</p>

    <p class="text-gray-300">Corollary 6.2. Let  <span class="math">\\mathfrak{p}</span>  be a predicate computable in time  <span class="math">t_{\\mathfrak{p}}</span> . There exists an algorithm  <span class="math">\\mathrm{Fork}_2</span>  such that for all  <span class="math">\\mathfrak{pp} \\in \\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span>  and oracle algorithms  <span class="math">A</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {t r} _ {\\mathfrak {q}} \\neq \\bot \\wedge &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathfrak {p} (\\mathfrak {p p}, (\\mathfrak {q}, \\rho (\\mathfrak {q})), \\mathfrak {o}, \\rho (\\rho (\\mathfrak {q}), \\mathfrak {o}), \\mathfrak {o} ^ {\\prime}, \\operatorname {t r} _ {\\mathfrak {q}}) = 1 &amp;amp; (\\mathfrak {q}, \\mathfrak {o}, \\mathfrak {o} ^ {\\prime}; \\operatorname {t r}, r) \\leftarrow A ^ {\\rho} (\\mathfrak {p p}) \\\\ \\downarrow &amp;amp; [ \\mathfrak {b} _ {j}, \\mathfrak {o} _ {j}, [ \\mathfrak {b} _ {j, k} ^ {\\prime}, \\mathfrak {o} _ {j, k} ^ {\\prime} ] _ {k = 1} ^ {N ^ {\\prime}} ] _ {j = 1} ^ {N} \\\\ \\mathfrak {b} _ {1}, \\ldots , \\mathfrak {b} _ {N} \\text {a r e p a i r w i s e d i s t i n c t} &amp;amp; \\leftarrow \\operatorname {F o r k} _ {2} ^ {A} (\\mathfrak {p p}, 1 ^ {N}, 1 ^ {N ^ {\\prime}}, (\\mathfrak {q}, \\rho (\\mathfrak {q})), \\mathfrak {o}, \\\\ \\wedge \\forall j \\in [ N ], &amp;amp; \\rho (\\mathfrak {p p}, (\\mathfrak {q}, \\mathfrak {b} _ {j}), \\mathfrak {o} _ {j}, \\mathfrak {b} _ {j, k} ^ {\\prime}, \\mathfrak {o} _ {j, k} ^ {\\prime}, \\operatorname {t r} _ {\\mathfrak {q}}) = 1 &amp;amp; \\rho (\\rho (\\mathfrak {q}), \\mathfrak {o}), \\mathfrak {o} ^ {\\prime}, \\operatorname {t r}, r) \\\\ \\rho (\\mathfrak {p p}, (\\mathfrak {q}, \\mathfrak {b} _ {j}), \\mathfrak {o} _ {j}, \\mathfrak {b} _ {j, k} ^ {\\prime}, \\mathfrak {o} _ {j, k} ^ {\\prime}, \\operatorname {t r} _ {\\mathfrak {q}}) = 1 \\\\ \\wedge \\mathfrak {b} _ {j, 1} ^ {\\prime}, \\ldots , \\mathfrak {b} _ {j, N ^ {\\prime}} ^ {\\prime} \\text {a r e p a i r w i s e d i s t i n c t} &amp;amp; \\rho (\\rho (\\mathfrak {q}), \\mathfrak {o}), \\mathfrak {o} ^ {\\prime}, \\operatorname {t r}, r) \\end{array} \\right] \\geq 1 - \\frac {3 N N ^ {\\prime} \\sqrt {t}}{2 ^ {\\lambda / 2}}.</span></div>

    <p class="text-gray-300">In the above experiment,  <span class="math">\\mathsf{Fork}_2</span>  runs in expected time  <span class="math">O(t^{2}NN^{\\prime}\\cdot (t_{A} + t_{\\mathfrak{p}}))</span> , where  <span class="math">t</span>  is a strict bound on the number of oracle queries made by  <span class="math">A</span>  and  <span class="math">t_A</span>  is its expected running time.</p>

    <p class="text-gray-300">7 Split accumulation for Hadamard products</p>

    <p class="text-gray-300">We construct a split accumulation scheme for the Hadamard products. We define the predicate to accumulate and then state our theorem. The remainder of the section is dedicated to proving the theorem.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Definition 7.1.</h6>

    <p class="text-gray-300">The Hadamard product predicate <span class="math">\\Phi_{\\textsc{hp}}</span> takes as input: (i) public parameters <span class="math">\\mathsf{pp}_{\\Phi}=\\mathsf{pp}_{\\mathsf{CM}}</span> for the Pedersen commitment scheme (for messages of some maximum length <span class="math">L</span>); (ii) an index <span class="math">\\mathsf{i}_{\\Phi}=\\ell</span> specifying a message length (at most <span class="math">L</span>); (iii) an instance <span class="math">\\mathsf{qx}=(C_{1},C_{2},C_{3})\\in\\mathbb{G}^{3}</span> consisting of three Pedersen commitments; (iv) a witness <span class="math">\\mathsf{qw}=(a,b,\\omega_{1},\\omega_{2},\\omega_{3})</span> consisting of two vectors <span class="math">a,b\\in\\mathbb{F}^{\\ell}</span> and three opening randomness elements <span class="math">\\omega_{1},\\omega_{2},\\omega_{3}\\in\\mathbb{F}</span>. The predicate <span class="math">\\Phi_{\\textsc{hp}}</span> computes the commitment key <span class="math">\\mathsf{ck}:=\\mathsf{CM}.\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{CM}},\\ell)</span> for messages of length <span class="math">\\ell</span> and checks that</p>

    <p class="text-gray-300"><span class="math">C_{1}=\\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck},a;\\omega_{1})\\ \\land\\ C_{2}=\\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck},b;\\omega_{2})\\ \\land\\ C_{3}=\\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck},a\\circ b;\\omega_{3})\\ \\ .</span> (1)</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Theorem 7.2.</h6>

    <p class="text-gray-300">The scheme <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> constructed in Section 7.1 is a zero-knowledge split accumulation scheme in the random oracle model for the Hadamard product predicate in Definition 7.1. <span class="math">\\mathsf{AS}</span> achieves the efficiency stated below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: <span class="math">\\mathrm{G}(1^{\\lambda})</span> runs in time <span class="math">O(\\lambda)</span>.</li>

      <li>Indexer: The time of <span class="math">\\mathrm{I}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{i}_{\\Phi}=\\ell)</span> is dominated by the time to run <span class="math">\\mathsf{CM}.\\mathsf{Trim}</span> with message length <span class="math">\\ell</span>.</li>

      <li>Accumulation prover: The time of <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m})</span> is dominated by <span class="math">O(n+m)\\cdot\\ell</span> group scalar multiplications and <span class="math">\\tilde{O}(n+m)\\cdot\\ell</span> field additions/multiplications.</li>

      <li>Accumulation verifier: <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{n},[\\mathsf{acc}_{j}.\\mathtt{x}]_{j=1}^{m},\\mathsf{acc}.\\mathtt{x},\\mathsf{pf})</span> requires making <span class="math">2</span> calls to the random oracle, <span class="math">O(n+m)</span> field additions/multiplications, and <span class="math">O(n+m)</span> group scalar multiplications.</li>

      <li>Decider: The time of <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})</span> equals the time to run the predicate <span class="math">\\Phi_{\\textsc{hp}}</span>.</li>

      <li>Sizes: An accumulator <span class="math">\\mathsf{acc}</span> is split into an accumulator instance <span class="math">\\mathsf{acc}.\\mathtt{x}</span> of <span class="math">3</span> group elements, and an accumulator witness <span class="math">\\mathsf{acc}.\\mathtt{w}</span> of <span class="math">O(\\ell)</span> field elements. An accumulation proof <span class="math">\\mathsf{pf}</span> consists of <span class="math">O(n+m)</span> group elements.</li>

    </ul>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">7.1 Construction</h3>

    <p class="text-gray-300">We describe the accumulation scheme <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> for the Hadamard product predicate <span class="math">\\Phi_{\\textsc{hp}}</span>. An accumulator <span class="math">\\mathsf{acc}</span> is split in two parts that are analogous to instance-witness pairs given to <span class="math">\\Phi_{\\textsc{hp}}</span> (see Definition 7.1). Jumping ahead, the decider <span class="math">\\mathrm{D}</span> is equal to the predicate <span class="math">\\Phi_{\\textsc{hp}}</span>; hence, there is no distinction between inputs and prior accumulators, and so it suffices to accumulate inputs only.</p>

    <p class="text-gray-300">Generator. The generator <span class="math">\\mathrm{G}</span> receives as input <span class="math">\\mathsf{pp}:=1^{\\lambda}</span> and outputs <span class="math">1^{\\lambda}</span>. (In other words, <span class="math">\\mathrm{G}</span> does not have to create additional public parameters beyond those used by <span class="math">\\Phi_{\\textsc{hp}}</span>.)</p>

    <p class="text-gray-300">Indexer. On input the accumulator parameters <span class="math">\\mathsf{pp}</span>, predicate parameters <span class="math">\\mathsf{pp}_{\\Phi}=\\mathsf{pp}_{\\mathsf{CM}}</span>, and a predicate index <span class="math">\\mathsf{i}_{\\Phi}=\\ell</span>, the indexer <span class="math">\\mathrm{I}</span> computes the commitment key <span class="math">\\mathsf{ck}:=\\mathsf{CM}.\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{CM}},\\ell)</span>, and then outputs the accumulator proving key <span class="math">\\mathsf{apk}:=(\\mathsf{ck},\\ell)</span>, the accumulator verification key <span class="math">\\mathsf{avk}:=\\ell</span>, and the decision key <span class="math">\\mathsf{dk}:=\\mathsf{ck}</span>.</p>

    <p class="text-gray-300">Accumulation prover. On input the accumulation proving key <span class="math">\\mathsf{apk}</span> and predicate instance-witness pairs <span class="math">[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{n}</span> (of the same form as split accumulators <span class="math">[\\mathsf{acc}_{j}]_{j=1}^{m}=[(\\mathsf{acc}_{j}.\\mathtt{x},\\mathsf{acc}_{j}.\\mathtt{w})]_{j=1}^{m}</span>), <span class="math">\\mathrm{P}</span> works as below.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300"><span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk} = (\\mathsf{ck},\\ell),[(\\mathsf{qx}_i,\\mathsf{qw}_i)]_{i = 1}^n)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i\\in [n]</span>  , parse the predicate instance  <span class="math">\\mathbf{q}\\mathbf{x}_i</span>  as  <span class="math">(C_{1,i},C_{2,i},C_{3,i})</span></li>

      <li>For each  <span class="math">i\\in [n]</span>  , parse the predicate witness  <span class="math">\\mathsf{qw}_i</span>  as  <span class="math">(a_{i},b_{i},\\omega_{1,i},\\omega_{2,i},\\omega_{3,i})</span></li>

      <li>Sample  <span class="math">a^{\\star}, b^{\\star} \\in \\mathbb{F}^{\\ell}</span>  and  <span class="math">\\omega_1^{\\star}, \\omega_2^{\\star}, \\omega_3^{\\star} \\in \\mathbb{F}</span>  and compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_1^\\star \\coloneqq \\mathsf{CM. Commit}(\\mathsf{ck},a^\\star ;\\omega_1^\\star)</span></p>

    <p class="text-gray-300"><span class="math">C_2^\\star \\coloneqq \\mathsf{CM. Commit}(\\mathsf{ck},b^\\star ;\\omega_2^\\star)</span></p>

    <p class="text-gray-300"><span class="math">C_3^\\star \\coloneqq \\mathsf{CM. Commit}(\\mathsf{ck},a^{\\star}\\circ b_{1} + a_{n}\\circ b^{\\star};\\omega_{3}^{\\star})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the random oracle to compute the challenge  <span class="math">\\mu \\coloneqq \\rho (\\ell ,[\\mathbf{q}\\mathbf{x}_i]_i^n,C_1^\\star ,C_2^\\star ,C_3^\\star)\\in \\mathbb{F}</span></li>

      <li>Compute  <span class="math">a(X,\\mu)\\coloneqq \\sum_{i = 1}^{n}X^{i - 1}\\mu^{i - 1}a_i + \\mu^n a^\\star \\in \\mathbb{F}^\\ell [X]</span></li>

      <li>Compute  <span class="math">b(X,\\mu)\\coloneqq \\sum_{i = 1}^{n}X^{n - i}b_{i} + \\mu b^{\\star}\\in \\mathbb{F}^{\\ell}[X]</span></li>

      <li>Compute the product polynomial  <span class="math">a(X,\\mu)\\circ b(X,\\mu)</span>  , which is of the form  <span class="math">\\sum_{i = 1}^{2n - 1}X^{i - 1}t_i\\in \\mathbb{F}^\\ell [X]</span></li>

      <li>For each  <span class="math">i\\in [2n - 1]\\setminus \\{n\\}</span>  , compute the commitment  <span class="math">C_{t,i}\\coloneqq \\mathsf{CM. Commit}(\\mathsf{ck},t_i;0)\\in \\mathbb{G}</span></li>

      <li>Use the random oracle to compute the challenge  <span class="math">\\nu \\coloneqq \\rho (\\mu ,[C_{t,i},C_{t,n + i}]_{i = 1}^{n - 1})\\in \\mathbb{F}</span></li>

      <li>Compute the commitment to  <span class="math">a(\\nu, \\mu)</span> :  <span class="math">C_1 := \\sum_{i=1}^{n} \\nu^{i-1} \\mu^{i-1} C_{1,i} + \\mu^n C_1^* \\in \\mathbb{G}</span> .</li>

      <li>Compute the commitment to  <span class="math">b(\\nu, \\mu)</span> :  <span class="math">C_2 := \\sum_{i=1}^{n} \\nu^{n-i} C_{2,i} + \\mu C_2^* \\in \\mathbb{G}</span> .</li>

      <li>Compute the commitment to  <span class="math">a(\\nu, \\mu) \\circ b(\\nu, \\mu)</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_3\\coloneqq \\sum_{i = 1}^{n - 1}\\nu^{i - 1}C_{t,i} + \\nu^{n - 1}(\\mu^n C_3^* +\\sum_{i = 1}^n\\mu^{i - 1}C_{3,i}) + \\sum_{i = 1}^{n - 1}\\nu^{n + i - 1}C_{t,n + 1}\\in \\mathbb{G}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute opening value and opening randomness for  <span class="math">C_1</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">a\\coloneqq \\sum_{i = 1}^{n}\\nu^{i - 1}\\mu^{i - 1}a_{i} + \\mu^{n}a^{\\star}\\in \\mathbb{F}^{\\ell}\\quad \\mathrm{and}\\quad \\omega_{1}\\coloneqq \\sum_{i = 1}^{n}\\nu^{i - 1}\\mu^{i - 1}\\omega_{1,i} + \\mu^{n}\\omega_{1}^{\\star}\\in \\mathbb{F}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute opening value and opening randomness for  <span class="math">C_2</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">b\\coloneqq \\sum_{i = 1}^{n}\\nu^{n - i}b_{i} + \\mu b^{\\star}\\in \\mathbb{F}^{\\ell}\\quad \\mathrm{and}\\quad \\omega_{2}\\coloneqq \\sum_{i = 1}^{n}\\nu^{n - i}\\omega_{2,i} + \\mu \\omega_{2}^{\\star}\\in \\mathbb{F}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute opening randomness for  <span class="math">C_3</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\omega_{3}\\coloneqq \\nu^{n - 1}(\\mu^{n}\\omega_{3}^{\\star} + \\sum_{i = 1}^{n}\\mu^{i - 1}\\omega_{3,i})\\in \\mathbb{F}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set the accumulator acc := (acc.x, acc.w) where acc.x :=  <span class="math">(C_1, C_2, C_3)</span>  and acc.w :=  <span class="math">(a, b, \\omega_1, \\omega_2, \\omega_3)</span> .</li>

      <li>Set the accumulation proof  <span class="math">\\mathsf{pf} \\coloneqq (C_1^\\star, C_2^\\star, C_3^\\star, [C_{t,i}, C_{t,n+i}]_{i=1}^{n-1})</span> .</li>

      <li>Output (acc, pf).</li>

    </ol>

    <p class="text-gray-300">Accumulation verifier. On input the accumulator verification key avk, predicate instances  <span class="math">[\\mathbf{q}\\mathbf{x}_i]_i = 1</span>  (of the same form as accumulator instances  <span class="math">[\\mathrm{acc}_j.\\mathbf{x}]_j = 1</span> ), a new accumulator instance acc.x, and an accumulation proof pf, V works as below.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk} = \\ell ,[\\mathsf{qx}_i]_i = 1,\\mathsf{acc.x},\\mathsf{pf})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\mu \\coloneqq \\rho (\\ell ,[\\mathbf{q}\\mathbf{x}_i]_i = 1,C_1^\\star ,C_2^\\star ,C_3^\\star)</span>  and  <span class="math">\\nu \\coloneqq \\rho (\\mu ,[C_{t,i},C_{t,n + i}]_{i = 1}^{n - 1})</span></li>

      <li>Check that  <span class="math">\\mathsf{acc.x}.C_1 = \\sum_{i=1}^{n} \\nu^{i-1} \\mu^{i-1} \\mathsf{qx}_i.C_1 + \\mu^n C_1^*</span> .</li>

      <li>Check that  <span class="math">\\mathsf{acc.x}.C_2 = \\sum_{i=1}^{n} \\nu^{n-i} \\mathbf{qx}_i.C_2 + \\mu C_2^*</span> .</li>

      <li>Check that  <span class="math">\\mathsf{acc.x}.C_3 = \\sum_{i=1}^{n-1} \\nu^{i-1} C_{t,i} + \\nu^{n-1} (\\mu^n C_3^* + \\sum_{i=1}^{n} \\mu^{i-1} \\mathbf{qx}_i.C_3) + \\sum_{i=1}^{n-1} \\nu^{n+i-1} C_{t,n+i}</span> .</li>

    </ol>

    <p class="text-gray-300">Decider. On input the decision key  <span class="math">\\mathsf{dk} = \\mathsf{ck}</span>  and an accumulator  <span class="math">\\mathsf{acc} = (\\mathsf{acc.x},\\mathsf{acc.w})</span> , D performs the checks from the Hadamard product predicate  <span class="math">\\Phi_{\\mathsf{HP}}</span>  on  <span class="math">\\mathsf{acc}</span>  (see Equation (1)). That is, D checks that  <span class="math">\\mathsf{acc.x}.C_1 = \\mathsf{CM. Commit}(\\mathsf{ck},\\mathsf{acc.w}.a;\\mathsf{acc.w.}\\omega_1)</span> ,  <span class="math">\\mathsf{acc.x}.C_2 = \\mathsf{CM. Commit}(\\mathsf{ck},\\mathsf{acc.w}.b;\\mathsf{acc.w.}\\omega_2)</span> , and  <span class="math">\\mathsf{acc.x}.C_3 = \\mathsf{CM. Commit}(\\mathsf{ck},\\mathsf{acc.w}.a\\circ \\mathsf{acc.w}.b;\\mathsf{acc.w.}\\omega_3)</span> .</p>

    <p class="text-gray-300">7.2 Proof of Theorem 7.2</p>

    <p class="text-gray-300">We prove that the accumulation scheme constructed in the previous section satisfies the claimed efficiency properties, achieves completeness, and achieves zero knowledge. Then in Section 7.2.1 we prove that it achieves knowledge soundness.</p>

    <p class="text-gray-300">Efficiency. We now analyze the efficiency of our accumulation scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: <span class="math">\\mathrm{G}(1^{\\lambda})</span> outputs <span class="math">1^{\\lambda}</span>, and hence runs in time <span class="math">O(\\lambda)</span>.</li>

      <li>Indexer: <span class="math">\\mathrm{I}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathrm{i}_{\\Phi})</span> runs CM.Trim with message length <span class="math">\\ell</span>.</li>

      <li>Accumulation prover: <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{n})</span> performs <span class="math">O(n)\\cdot\\ell</span> group scalar multiplications and <span class="math">\\tilde{O}(n)\\cdot\\ell</span> field additions/multiplications. (The quasilinear cost in <span class="math">n</span> is due to multiplication of polynomials of degree <span class="math">n</span>.)</li>

      <li>Accumulation verifier: <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{n},\\mathsf{acc}.\\mathtt{x},\\mathsf{pf})</span> makes <span class="math">2</span> calls to the random oracle, <span class="math">O(n)</span> field operations, and <span class="math">5n-5</span> group scalar multiplications.</li>

      <li>Decider: <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})</span> invokes the Hadamard product predicate <span class="math">\\Phi_{\\mathsf{HP}}</span> and performs <span class="math">3\\ell</span> scalar multiplications.</li>

      <li>Sizes: The accumulator instance <span class="math">\\mathsf{acc}.\\mathtt{x}</span> consists of <span class="math">3</span> group elements. The accumulator witness <span class="math">\\mathsf{acc}.\\mathtt{w}</span> consists of <span class="math">2\\ell+3</span> field elements. The accumulation proof <span class="math">\\mathsf{pf}</span> consists of <span class="math">2n-2</span> group elements.</li>

    </ul>

    <p class="text-gray-300">Completeness. Since we need only accumulate predicate inputs (as accumulators are split like predicate inputs and the decider equals the predicate being accumulated), it suffices to demonstrate that the simplified completeness property from Section 4.1 holds. Fix an (unbounded) adversary <span class="math">\\mathcal{A}</span>. For each <span class="math">i\\in[n]</span>, since</p>

    <p class="text-gray-300"><span class="math">\\Phi_{\\mathsf{HP}}\\big{(}\\mathsf{pp}_{\\Phi},\\mathrm{i}_{\\Phi}=\\ell,\\mathsf{qx}_{i}=(C_{1,i},C_{2,i},C_{3,i}),\\mathsf{qw}_{i}=(a_{i},b_{i},\\omega_{1,i},\\omega_{2,i},\\omega_{3,i})\\big{)}=1\\enspace,</span></p>

    <p class="text-gray-300">we know that <span class="math">C_{1,i}=\\mathsf{CM.Commit}(\\mathsf{ck},a_{i};\\omega_{1,i})</span>, <span class="math">C_{2,i}=\\mathsf{CM.Commit}(\\mathsf{ck},b_{i};\\omega_{2,i})</span>, and <span class="math">C_{3,i}=\\mathsf{CM.Commit}(\\mathsf{ck},a_{i}\\circ b_{i};\\omega_{3,i})</span>. This implies for <span class="math">a:=\\sum_{i=1}^{n}\\nu^{i-1}\\mu^{i-1}a_{i}+\\mu^{n}a^{\\star}</span> and <span class="math">b:=\\sum_{i=1}^{n}\\mu^{n-i}b_{i}+\\mu b^{\\star}</span> that <span class="math">a\\circ b=\\sum_{i=1}^{2n-1}\\nu^{i-1}t_{i}</span> and that <span class="math">t_{n}=\\mu^{n}(a^{\\star}\\circ b_{1}+a_{n}\\circ b^{\\star})+\\sum_{i=1}^{n}\\mu^{i-1}a_{i}\\circ b_{i}</span>. Further we have that <span class="math">\\omega_{1}=\\sum_{i=1}^{n}\\nu^{i-1}\\mu^{i-1}\\omega_{1,i}+\\mu^{n}\\omega_{1}^{\\star}</span>, <span class="math">\\omega_{2}=\\sum_{i=1}^{n}\\mu^{n-i}\\omega_{2,i}+\\mu\\omega_{2}^{\\star}</span>, and <span class="math">\\omega_{3}=\\nu^{n-1}(\\mu^{n}\\omega_{3}^{\\star}+\\sum_{i=1}^{n}\\mu^{i-1}\\omega_{3,i})</span>. This implies that <span class="math">C_{1}=\\mathsf{CM.Commit}(\\mathsf{ck},a;\\omega_{1})</span>, <span class="math">C_{2}=\\mathsf{CM.Commit}(\\mathsf{ck},b;\\omega_{2})</span>, and <span class="math">C_{3}=\\mathsf{CM.Commit}(\\mathsf{ck},a\\circ b;\\omega_{3})</span>; that is, the new accumulator is accepted by the decider. That the accumulation verifier accepts the corresponding instance parts also follows form the above equations, and the homomorphic properties of the Pedersen commitment.</p>

    <p class="text-gray-300">Zero knowledge. Consider the simulator <span class="math">\\mathrm{S}</span> for <span class="math">\\mathsf{AS}</span> that works as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{S}^{\\rho}(\\tau=\\bot,\\mathsf{pp}_{\\Phi}=\\mathsf{pp}_{\\mathsf{CM}},\\mathrm{i}_{\\Phi}=\\ell)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample vectors <span class="math">a,b\\in\\mathbb{F}^{\\ell}</span>.</li>

      <li>Sample opening randomness elements <span class="math">\\omega_{1},\\omega_{2},\\omega_{3}\\in\\mathbb{F}</span>.</li>

      <li>Compute <span class="math">C_{1}:=\\mathsf{CM.Commit}(\\mathsf{ck},a;\\omega_{1})</span>.</li>

      <li>Compute <span class="math">C_{2}:=\\mathsf{CM.Commit}(\\mathsf{ck},b;\\omega_{2})</span>.</li>

      <li>Compute <span class="math">C_{3}:=\\mathsf{CM.Commit}(\\mathsf{ck},a\\circ b;\\omega_{3})</span>.</li>

      <li>Set the accumulator instance <span class="math">\\mathsf{acc}.\\mathtt{x}:=(C_{1},C_{2},C_{3})</span>.</li>

      <li>Set the accumulator witness <span class="math">\\mathsf{acc}.\\mathtt{w}:=(a,b,\\omega_{1},\\omega_{2},\\omega_{3})</span>.</li>

      <li>Output <span class="math">\\mathsf{acc}:=(\\mathsf{acc}.\\mathtt{x},\\mathsf{acc}.\\mathtt{w})</span>.</li>

    </ol>

    <p class="text-gray-300">By construction, the sampled accumulator satisfies the decider. Moreover, the accumulator is distributed identically to an accumulator output by the (honest) accumulation prover. This is because all elements of the accumulator are random within the respective domains subject only to the condition that the decider accepts the accumulator.</p>

    <h2 id="sec-62" class="text-2xl font-bold">7.2.1 Knowledge soundness</h2>

    <p class="text-gray-300">We need only accumulate predicate inputs (as accumulators are split like predicate inputs and the decider equals the predicate being accumulated), so it suffices to demonstrate that the simplified knowledge soundness property from Section 4.1 holds. We describe an extractor and then analyze why it satisfies the property.</p>

    <p class="text-gray-300">Define the following algorithm:</p>

    <p class="text-gray-300"><span class="math">A^{\\rho}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai})\\big)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{i}_{\\Phi} = \\ell ,[\\mathsf{q}\\mathsf{x}_i]_{i = 1}^n,\\mathsf{acc},\\mathsf{pf})\\gets \\tilde{\\mathrm{P}}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}).</span></li>

      <li>Parse the accumulation proof <span class="math">\\mathsf{pf}</span> as <span class="math">(C_1^\\star, C_2^\\star, C_3^\\star, [C_{t,i}, C_{t,n+i}]_{i=1}^{n-1})</span>.</li>

      <li>Set the query <span class="math">\\mathfrak{q} := (\\ell, [\\mathfrak{q}\\mathfrak{x}_i]_{i=1}^n, C_1^\\star, C_2^\\star, C_3^\\star)</span>.</li>

      <li>Set the first output <span class="math">\\mathsf{o}</span> to be <span class="math">[C_{t,i}, C_{t,n+i}]_{i=1}^{n-1}</span>.</li>

      <li>Set the second output <span class="math">\\mathsf{o}&#x27;</span> to be the accumulator acc.</li>

      <li>Query the random oracle <span class="math">\\rho</span> at <span class="math">\\mathfrak{q}</span> and at <span class="math">(\\rho(\\mathfrak{q}), \\circ)</span>.</li>

      <li>Output <span class="math">(\\mathfrak{q},\\circ ,\\mathsf{o}^{\\prime})</span></li>

    </ol>

    <p class="text-gray-300">Define the forking lemma predicate:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{p}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}),(\\mathfrak{q},\\mathfrak{a}),\\mathsf{o},\\mathfrak{a}^{\\prime},\\mathsf{o}^{\\prime},\\mathsf{tr}\\big)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the query <span class="math">\\mathfrak{q}</span> as <span class="math">(\\ell, [\\mathrm{qx}_i]_{i=1}^n, C_1^\\star, C_2^\\star, C_3^\\star)</span>.</li>

      <li>Parse the first output <span class="math">\\mathsf{o}</span> as <span class="math">[C_{t,i}, C_{t,n+i}]_{i=1}^{n-1}</span>.</li>

      <li>Parse the second output <span class="math">\\mathsf{o}&#x27;</span> as an accumulator acc.</li>

      <li>Set the accumulation proof <span class="math">\\mathsf{pf} := (C_1^\\star, C_2^\\star, C_3^\\star, [C_{t,i}, C_{t,n+i}]_{i=1}^{n-1})</span>.</li>

      <li>Compute <span class="math">(\\mathsf{apk},\\mathsf{avk},\\mathsf{dk})\\coloneqq \\mathrm{I}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\ell)</span></li>

      <li>Check that <span class="math">\\mathfrak{a} \\neq 0</span>.</li>

      <li>Check that <span class="math">\\mathrm{V}(\\mathrm{avk},[\\mathrm{qx}_i]_{i = 1}^n,\\mathrm{acc}.\\mathbb{x},\\mathrm{pf})</span> outputs 1 when answering its first random oracle query with <span class="math">\\mathfrak{a}</span> and its second random oracle query with <span class="math">\\mathfrak{a}&#x27;</span>.</li>

      <li>Check that <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc})</span> outputs 1.</li>

    </ol>

    <p class="text-gray-300">For the remainder of the proof we implicitly consider only the case that <span class="math">\\mathrm{V}^{\\rho}(\\mathrm{avk},[\\mathrm{qx}_i]_{i = 1}^n,\\mathrm{acc}.\\mathbb{x},\\mathrm{pf}) = 1</span> and <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc}) = 1</span> for <span class="math">(\\mathrm{i}_{\\Phi},[\\mathrm{qx}_i]_{i = 1}^n,\\mathrm{acc},\\mathrm{pf})\\gets \\tilde{\\mathrm{P}}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai})</span> and <span class="math">(\\mathsf{apk},\\mathsf{avk},\\mathsf{dk})\\coloneqq \\mathrm{I}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\ell)</span>; otherwise, the implication holds vacuously. In this case the output of <span class="math">A</span> satisfies <span class="math">\\mathsf{p}</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, where the negligible loss accounts for the case that <span class="math">\\rho (\\mathfrak{q}) = 0</span>. Let <span class="math">\\mathsf{Fork}_2</span> be the algorithm given by applying Corollary 6.2 to the forking lemma predicate <span class="math">\\mathsf{p}</span>.</p>

    <p class="text-gray-300">E <span class="math">\\tilde{\\mathrm{P}},\\rho</span> (pp, pp, ai, r):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">(\\mathfrak{q},\\mathsf{o},\\mathsf{o}^{\\prime};\\mathsf{tr})\\gets A^{\\rho}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai});r\\big).</span></li>

      <li>Parse <span class="math">\\mathfrak{q}</span> as <span class="math">(\\ell, [\\mathrm{qx}_i]_{i=1}^n, C_1^\\star, C_2^\\star, C_3^\\star)</span>, <span class="math">\\mathsf{o}</span> as <span class="math">[C_{t,i}, C_{t,n+i}]_{i=1}^{n-1}</span>, and <span class="math">\\mathsf{o}&#x27;</span> as acc.</li>

      <li>Set the accumulation proof <span class="math">\\mathsf{pf} := (C_1^\\star, C_2^\\star, C_3^\\star, [C_{t,i}, C_{t,n+i}]_{i=1}^{n-1})</span>.</li>

      <li>Run <span class="math">[\\mu_j, \\mathsf{o}_j, [\\nu_{j,k}, \\mathsf{o}_{j,k}&#x27;]_{k=1}^{2n-1}]_{j=1}^{n+1} \\gets \\mathsf{Fork}_2^A(\\mathsf{pp}, 1^{n+1}, 1^{2n-1}, (\\mathfrak{q}, \\rho(\\mathfrak{q})), \\mathsf{o}, \\rho(\\rho(\\mathfrak{q}), \\mathsf{o}), \\mathsf{o}&#x27;, \\mathsf{tr}, r)</span>.</li>

      <li>For each <span class="math">j \\in [n + 1]</span> and for each <span class="math">k \\in [2n - 1]</span>:</li>

    </ol>

    <p class="text-gray-300">46</p>

    <p class="text-gray-300">parse <span class="math">\\mathsf{o}_{j,k}^{\\prime}</span> as <span class="math">\\mathsf{acc}^{(j,k)} = \\big((C_{1,\\star}^{(j,k)},C_{2,\\star}^{(j,k)},C_{3,\\star}^{(j,k)})</span>, <span class="math">(a_{\\star}^{(j,k)},b_{\\star}^{(j,k)},\\omega_{1,\\star}^{(j,k)},\\omega_{2,\\star}^{(j,k)},\\omega_{3,\\star}^{(j,k)})\\big)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">U_{j}</span> to be the Vandermonde matrix on <span class="math">(\\mu_j\\nu_{1,1},\\ldots ,\\mu_j\\nu_{1,n})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">V_{j}</span> to be the descending Vandermonde matrix on <span class="math">(\\nu_{j,1},\\ldots ,\\nu_{j,n})</span>: <span class="math">V_{j} := \\begin{pmatrix} \\nu_{j,1}^{n-1} &amp;amp; \\nu_{j,1}^{n-2} &amp;amp; \\cdots &amp;amp; 1 \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\nu_{j,n}^{n-1} &amp;amp; \\nu_{j,n}^{n-2} &amp;amp; \\cdots &amp;amp; 1 \\end{pmatrix}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">U_{1}, U_{2}, V_{1}, V_{2}</span> are not invertible, abort. Otherwise compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{pmatrix} \\bar{a}_{1} &amp;amp; \\bar{\\omega}_{1,1} \\\\ a_{2} &amp;amp; \\omega_{1,2} \\\\ \\vdots &amp;amp; \\vdots \\\\ a_{n} &amp;amp; \\omega_{1,n} \\end{pmatrix} := U_{1}^{-1} \\begin{pmatrix} a_{\\star}^{(1,1)} &amp;amp; \\omega_{1,\\star}^{(1,1)} \\\\ \\vdots &amp;amp; \\vdots \\\\ a_{\\star}^{(1,n)} &amp;amp; \\omega_{1,\\star}^{(1,n)} \\end{pmatrix} \\qquad \\begin{pmatrix} b_{1} &amp;amp; \\omega_{2,1} \\\\ \\vdots &amp;amp; \\vdots \\\\ b_{n-1} &amp;amp; \\omega_{2,n-1} \\\\ \\bar{b}_{n} &amp;amp; \\bar{\\omega}_{2,n} \\end{pmatrix} := V_{1}^{-1} \\begin{pmatrix} b_{\\star}^{(1,1)} &amp;amp; \\omega_{2,\\star}^{(1,1)} \\\\ \\vdots &amp;amp; \\vdots \\\\ b_{\\star}^{(1,n)} &amp;amp; \\omega_{2,\\star}^{(1,n)} \\end{pmatrix}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{pmatrix} \\bar{a}_{1}^{\\prime} &amp;amp; \\bar{\\omega}_{1,1}^{\\prime} \\\\ a_{2}^{\\prime} &amp;amp; \\omega_{1,2}^{\\prime} \\\\ \\vdots &amp;amp; \\vdots \\\\ a_{n}^{\\prime} &amp;amp; \\omega_{1,n}^{\\prime} \\end{pmatrix} := U_{2}^{-1} \\begin{pmatrix} a_{\\star}^{(2,1)} &amp;amp; \\omega_{1,\\star}^{(2,1)} \\\\ \\vdots &amp;amp; \\vdots \\\\ a_{\\star}^{(2,n)} &amp;amp; \\omega_{1,\\star}^{(2,n)} \\end{pmatrix} \\qquad \\begin{pmatrix} b_{1}^{\\prime} &amp;amp; \\omega_{2,1}^{\\prime} \\\\ \\vdots &amp;amp; \\vdots \\\\ b_{n-1}^{\\prime} &amp;amp; \\omega_{2,n-1}^{\\prime} \\\\ \\bar{b}_{n}^{\\prime} &amp;amp; \\bar{\\omega}_{2,n}^{\\prime} \\end{pmatrix} := V_{2}^{-1} \\begin{pmatrix} b_{\\star}^{(2,1)} &amp;amp; \\omega_{2,\\star}^{(2,1)} \\\\ \\vdots &amp;amp; \\vdots \\\\ b_{\\star}^{(2,n)} &amp;amp; \\omega_{2,\\star}^{(2,n)} \\end{pmatrix}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">a_{1} := \\frac{\\mu_{2}^{n} \\bar{a}_{1} - \\mu_{1}^{n} \\bar{a}_{1}^{\\prime}}{\\mu_{2}^{n} - \\mu_{1}^{n}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\omega_{1,1} := \\frac{\\mu_{2}^{n} \\bar{\\omega}_{1,1} - \\mu_{1}^{n} \\bar{\\omega}_{1,1}^{\\prime}}{\\mu_{2}^{n} - \\mu_{1}^{n}}</span></div>

    <div class="my-4 text-center"><span class="math-block">b_{n} := \\frac{\\mu_{2} \\bar{b}_{n} - \\mu_{1} \\bar{b}_{n}^{\\prime}}{\\mu_{2} - \\mu_{1}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\omega_{2,n} := \\frac{\\mu_{2} \\bar{\\omega}_{2,n} - \\mu_{1} \\bar{\\omega}_{2,n}^{\\prime}}{\\mu_{2} - \\mu_{1}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">j \\in [n + 1]</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Set <span class="math">P_{j}</span> to be the Vandermonde matrix on <span class="math">(\\nu_{j,1},\\ldots ,\\nu_{j,2n - 1})</span>.</p>

    <p class="text-gray-300">(b) If <span class="math">P_{j}</span> is not invertible, abort. Otherwise compute</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{pmatrix} \\tau_{1}^{(j)} \\\\ \\vdots \\\\ \\tau_{2n-1}^{(j)} \\end{pmatrix} := P_{j}^{-1} \\begin{pmatrix} \\omega_{3,\\star}^{(j,1)} \\\\ \\vdots \\\\ \\omega_{3,\\star}^{(j,2n-1)} \\end{pmatrix}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">M</span> to be the Vandermonde matrix on <span class="math">(\\mu_1,\\ldots ,\\mu_{n + 1})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">M</span> is not invertible, abort. Otherwise compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{pmatrix} \\omega_{3,1} \\\\ \\vdots \\\\ \\omega_{3,n+1} \\end{pmatrix} := M^{-1} \\begin{pmatrix} \\tau_{n}^{(1)} \\\\ \\vdots \\\\ \\tau_{n}^{(n+1)} \\end{pmatrix}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i \\in [n]</span>, set <span class="math">\\mathsf{qw}_i := (a_i, b_i, \\omega_{1,i}, \\omega_{2,i}, \\omega_{3,i})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\left(\\mathrm{i}_{\\Phi},[(\\mathsf{qx}_i,\\mathsf{qw}_i)]_{i = 1}^{n},\\mathsf{acc},\\mathsf{pf}\\right)</span>.</li>

    </ol>

    <p class="text-gray-300">By the properties of <span class="math">\\mathsf{Fork}_2</span> guaranteed in Corollary 6.2, <span class="math">\\mathrm{E}_{\\hat{\\mathrm{P}}}</span> runs in expected polynomial time and, moreover, except with probability <span class="math">\\mathrm{negl}(\\lambda)</span> the following event <span class="math">E</span> occurs:</p>

    <p class="text-gray-300"><span class="math">\\{\\mu_j\\}_{j\\in[n+1]}</span> are pairwise distinct</p>

    <p class="text-gray-300">and <span class="math">\\forall j\\in[n+1]</span> it holds that <span class="math">\\{\\nu_{j,k}\\}_{k\\in[2n-1]}</span> are pairwise distinct</p>

    <p class="text-gray-300">and <span class="math">\\forall j\\in[n+1]\\ \\forall k\\in[2n-1]</span> it holds that <span class="math">\\mathsf{p}\\big{(}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}),(\\mathsf{q},\\mu_{j}),\\mathsf{o}_{j},\\nu_{j,k},\\mathsf{o}^{\\prime}_{j,k},\\mathsf{tr}_{\\mathsf{q}}\\big{)}=1</span>.</p>

    <p class="text-gray-300">Conditioned on <span class="math">E</span>, since the challenges are all distinct, the Vandermonde matrices <span class="math">\\{U_{j}\\}_{j=1,2}</span>, <span class="math">\\{V_{j}\\}_{j=1,2}</span>, <span class="math">\\{P_{j}\\}_{j=1,\\ldots,n+1}</span>, and <span class="math">M</span> are all invertible, and so the extractor does not abort. (Note that for <span class="math">U_{j}</span> to be invertible, we need that <span class="math">\\mu_{j}\\neq 0</span>, which we guarantee by the definition of <span class="math">\\mathsf{p}</span>.)</p>

    <p class="text-gray-300">The claim below completes the proof, because it is immediate from that claim and the above discussion that with all but negligible probability, for all <span class="math">i\\in[n]</span>,</p>

    <p class="text-gray-300"><span class="math">\\Phi_{\\text{\\tiny HP}}\\big{(}\\mathsf{pp}_{\\Phi},\\mathsf{i}_{\\Phi}=\\ell,\\mathsf{qx}_{i}=(C_{1,i},C_{2,i},C_{3,i}),\\mathsf{qw}_{i}=(a_{i},b_{i},\\omega_{1,i},\\omega_{2,i},\\omega_{3,i})\\big{)}=1\\enspace.</span></p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Claim 7.3.</h6>

    <p class="text-gray-300">The event <span class="math">E</span> implies that for every <span class="math">i\\in[n]</span> it holds that:</p>

    <p class="text-gray-300"><span class="math">C_{1,i}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},a_{i};\\omega_{1,i})\\enspace,</span> <span class="math">C_{2,i}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},b_{i};\\omega_{2,i})\\enspace,</span> <span class="math">C_{3,i}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},a_{i}\\circ b_{i};\\omega_{3,i})\\enspace.</span></p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Define the following vectors:</p>

    <p class="text-gray-300"><span class="math">\\forall j\\in[n],\\ \\vec{C}_{1}^{(j)}:=(C_{1,1}+\\mu_{j}^{n}C_{1}^{\\star},C_{1,2},\\ldots,C_{1,n})</span> <span class="math">\\forall j\\in[n],\\ \\vec{C}_{1,\\star}^{(j)}:=(C_{1,\\star}^{(j,1)},\\ldots,C_{1,\\star}^{(j,n)})</span> <span class="math">\\forall j\\in[n],\\ \\vec{C}_{2}^{(j)}:=(C_{2,1},\\ldots,C_{2,n-1},C_{2,n}+\\mu_{j}C_{2}^{\\star})</span> <span class="math">\\forall j\\in[n],\\ \\vec{C}_{2,\\star}^{(j)}:=(C_{2,\\star}^{(j,1)},\\ldots,C_{2,\\star}^{(j,n)})</span> <span class="math">\\vec{C}_{3}:=(C_{3,1},\\ldots,C_{3,n},C_{3}^{\\star})</span> <span class="math">\\forall j\\in[n],\\ \\vec{C}_{3,\\star}^{(j)}:=(C_{3,\\star}^{(j,1)},\\ldots,C_{3,\\star}^{(j,2n-1)})</span></p>

    <p class="text-gray-300">For each <span class="math">j\\in[n]</span>, define the following vector</p>

    <p class="text-gray-300"><span class="math">\\vec{C}_{t}^{(j)}:=\\ \\Big{(}C_{t,1}^{(j)},\\ldots C_{t,n-1}^{(j)},\\mu_{j}^{n}C_{3}^{\\star}+\\sum_{i=1}^{n}\\mu_{j}^{i-1}C_{3,i},C_{t,n+1}^{(j)},\\ldots,C_{t,2n-1}^{(j)}\\Big{)}\\enspace.</span></p>

    <p class="text-gray-300">Fix <span class="math">j\\in[n]</span> and <span class="math">k\\in[2n-1]</span>. Since the accumulation verifier accepts <span class="math">(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{n},\\mathsf{acc}^{(j,k)},\\mathsf{pf})</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\vec{C}_{1,\\star}=U_{1}\\cdot\\vec{C}_{1}^{(1)}\\quad,\\quad\\vec{C}_{2,\\star}=V_{1}\\cdot\\vec{C}_{2}^{(1)}\\quad,\\quad\\vec{C}_{3,\\star}^{(j)}=P_{j}\\cdot\\vec{C}_{t}^{(j)}\\quad,\\quad\\vec{C}_{1,\\star}=U_{2}\\cdot\\vec{C}_{1}^{(2)}\\quad,\\quad\\vec{C}_{2,\\star}=V_{2}\\cdot\\vec{C}_{2}^{(2)}\\enspace.</span></p>

    <p class="text-gray-300">Moreover, since the decider accepts <span class="math">(\\mathsf{dk},\\mathsf{acc}^{(j,k)})</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">C_{1,\\star}^{(j,k)}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},a_{\\star}^{(j,k)};\\omega_{1,\\star}^{(j,k)})\\enspace,</span> <span class="math">C_{2,\\star}^{(j,k)}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},b_{\\star}^{(j,k)};\\omega_{2,\\star}^{(j,k)})\\enspace,</span> <span class="math">C_{3,\\star}^{(j,k)}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},a_{\\star}^{(j,k)}\\circ b_{\\star}^{(j,k)};\\omega_{3,\\star}^{(j,k)})\\enspace.</span></p>

    <p class="text-gray-300">Using the homomorphic property of <span class="math">\\mathsf{CM.Commit}</span>, and because <span class="math">\\vec{C}_{1}=U_{1}^{-1}\\vec{C}_{1,\\star}</span>, it holds for all <span class="math">i\\in\\{2,\\ldots,n\\}</span> that</p>

    <p class="text-gray-300"><span class="math">C_{1,i}</span> <span class="math">=\\sum_{k=1}^{n}U_{1}^{-1}[i,k]C_{1,\\star}^{(1,k)}</span> <span class="math">=\\sum_{k=1}^{n}U_{1}^{-1}[i,k]\\mathsf{CM.Commit}(\\mathsf{ck},a_{\\star}^{(j,k)};\\omega_{1,\\star}^{(j,k)})</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},\\sum_{k=1}^{n}U_{1}^{-1}[i,k]a_{\\star}^{(1,k)};\\sum_{k=1}^{n}U_{1}^{-1}[i,k]\\omega_{1,\\star}^{(1,k)})</span></p>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname {C M}. \\operatorname {C o m m i t} (\\operatorname {c k}, a _ {i}; \\omega_ {1, i}).</span></div>

    <p class="text-gray-300">Similarly, since  <span class="math">\\vec{C}_2 = V_1^{-1}\\vec{C}_{2,\\star}</span> , it holds that, for all  <span class="math">i\\in \\{1,\\ldots ,n - 1\\}</span> ,  <span class="math">C_{2,i} = \\mathsf{CM}.Committ(\\mathsf{ck},b_i;\\omega_{2,i})</span> . Furthermore,</p>

    <div class="my-4 text-center"><span class="math-block">C _ {1, 1} + \\mu_ {1} ^ {n} C _ {1} ^ {\\star} = \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, \\bar {a} _ {1}; \\bar {\\omega} _ {1, 1}), \\qquad C _ {1, 1} + \\mu_ {2} ^ {n} C _ {1} ^ {\\star} = \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, \\bar {a} _ {1} ^ {\\prime}; \\bar {\\omega} _ {1, 1} ^ {\\prime}),</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {2, n} + \\mu_ {1} C _ {2} ^ {\\star} = \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, \\bar {b} _ {n}; \\bar {\\omega} _ {2, n}), \\qquad C _ {2, n} + \\mu_ {2} C _ {2} ^ {\\star} = \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, \\bar {b} _ {2} ^ {\\prime}; \\bar {\\omega} _ {2, n} ^ {\\prime}).</span></div>

    <p class="text-gray-300">From this we can see that if  <span class="math">\\mu_1 \\neq \\mu_2</span>  (which is implied by  <span class="math">E</span> ) then  <span class="math">C_{1,1} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, a_1; \\omega_{1,1})</span>  and  <span class="math">C_{2,n} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, b_n; \\omega_{2,n})</span> . Define  <span class="math">a^\\star \\coloneqq \\frac{\\bar{a}_1 - \\bar{a}_1&#x27;}{\\mu_1^n - \\mu_2^n}</span> ,  <span class="math">\\omega_1^\\star \\coloneqq \\frac{\\bar{\\omega}_{1,1} - \\bar{\\omega}_{1,1}&#x27;}{\\mu_1^n - \\mu_2^n}</span>  and  <span class="math">b^\\star \\coloneqq \\frac{\\bar{b}_n - \\bar{b}_n&#x27;}{\\mu_1 - \\mu_2}</span> ,  <span class="math">\\omega_2^\\star \\coloneqq \\frac{\\bar{\\omega}_{2,n} - \\bar{\\omega}_{2,n}&#x27;}{\\mu_1 - \\mu_2}</span> . By the homomorphic property of the commitment scheme we have that for all  <span class="math">j \\in [n]</span></p>

    <div class="my-4 text-center"><span class="math-block">C _ {1, 1} + \\mu_ {j} ^ {n} C _ {1} ^ {\\star} = \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, a _ {1} + \\mu_ {j} ^ {n} a ^ {\\star}; \\omega_ {1, 1} + \\mu_ {j} ^ {n} \\omega_ {1} ^ {\\star}),</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {2, n} + \\mu_ {j} C _ {2} ^ {\\star} = \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, b _ {n} + \\mu_ {j} b ^ {\\star}; \\omega_ {2, n} + \\mu_ {j} \\omega_ {2} ^ {\\star}).</span></div>

    <p class="text-gray-300">Fix  <span class="math">j \\in [n]</span> . Recall that  <span class="math">U_{j}</span>  is the Vandermonde matrix on  <span class="math">(\\mu_j\\nu_{j,1},\\ldots ,\\mu_j\\nu_{j,n})</span> , and that  <span class="math">V_{j}</span>  is the descending Vandermonde matrix on  <span class="math">(\\nu_{j,1},\\dots,\\nu_{j,n})</span> . Observe that since  <span class="math">\\vec{C}_{1,\\star}^{(j)} = U_j\\cdot \\vec{C}_1^{(j)}</span>  and  <span class="math">\\vec{C}_{2,\\star}^{(j)} = V_j\\cdot \\vec{C}_2^{(j)}</span> ,  <span class="math">C_{3,\\star}^{(j,k)} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck},(a^{\\star}\\mu_{j}^{n} + \\sum_{i = 1}^{n}a_{i}\\mu_{j}^{i - 1}\\nu_{j,k}^{i - 1})\\circ (b^{\\star}\\mu_{j} + \\sum_{i = 1}^{n}b_{i}\\nu_{j,k}^{n - i});\\omega_{3,\\star}^{(j,k)})</span> . For  <span class="math">i \\in [2n - 1]</span> , let  <span class="math">t_i^{(j)}</span>  be the coefficient of  <span class="math">X^{i - 1}</span>  in the polynomial  <span class="math">z_{j}(X) := (a^{\\star}\\mu_{j}^{n} + \\sum_{i = 1}^{n}a_{i}\\mu_{j}^{i - 1}X^{i - 1})\\circ (b^{\\star}\\mu_{j} + \\sum_{i = 1}^{n}b_{i}X^{n - i})</span> , so that  <span class="math">C_{3,\\star}^{(j,k)} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck},\\sum_{i = 1}^{2n - 1}t_i^{(j)}\\nu_{j,k}^{i - 1};\\omega_{3,\\star}^{(j,k)})</span> . Recall that  <span class="math">t_n^{(j)} = \\mu^n\\cdot (a^\\star \\circ b_1 + a_n\\circ b^\\star) + \\sum_{i = 1}^{n}\\mu_j^{i - 1}a_i\\circ b_i</span> .</p>

    <p class="text-gray-300">Next, for each  <span class="math">j \\in [n]</span> , since  <span class="math">\\vec{C}_t^{(j)} = P_j^{-1}\\vec{C}_{3,\\star}^{(j)}</span> , it follows that for  <span class="math">i \\in [2n - 1] \\setminus \\{n\\}</span> ,  <span class="math">C_{t,i}^{(j)} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, t_i^{(j)}; \\tau_i^{(j)})</span>  and that  <span class="math">C_{t,n}^{(j)} := \\mu_j^n C_3^\\star + \\sum_{i=1}^n \\mu_j^{i-1} C_{3,i} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, t_n^{(j)}; \\tau_n^{(j)})</span> . Letting  <span class="math">\\vec{C}_\\circ := (C_{t,n}^{(1)}, \\ldots, C_{t,n}^{(n+1)})</span>  we see that  <span class="math">\\vec{C}_\\circ = M \\cdot \\vec{C}_3</span> , so that for all  <span class="math">i \\in [n]</span> ,  <span class="math">C_{3,i} = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, a_i \\circ b_i; \\omega_{3,i})</span> . Note that the  <span class="math">(n+1)</span> -th entry of  <span class="math">\\vec{C}_3</span>  is  <span class="math">C_3^\\star</span> , which commits to  <span class="math">a^\\star \\circ b_1 + a_n \\circ b^\\star</span> .</p>

    <p class="text-gray-300">50</p>

    <p class="text-gray-300">In Section 8.1 we describe a zkNARK for R1CS and then in Section 8.2 we describe a split accumulation scheme for it; security proofs are in Section 8.3.</p>

    <h2 id="sec-66" class="text-2xl font-bold">8.1 zkNARK for R1CS</h2>

    <p class="text-gray-300">We describe a zkNARK for R1CS (see Definition 8.1) in the ROM; the protocol is the result of applying the Fiat-Shamir transformation to an underlying sigma protocol for R1CS based on Pedersen commitments. Following the definition of a non-interactive argument in the ROM from Section 3.1, we describe the generator <span class="math">\\mathcal{G}</span>, indexer <span class="math">\\mathcal{I}</span>, prover <span class="math">\\mathcal{P}</span>, and verifier <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300"><strong>Definition 8.1.</strong> The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}(\\mathbb{F})</span> is the set of all triples <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span> where <span class="math">\\dot{\\mathfrak{s}} = (A,B,C,\\mathfrak{n})</span> is a triple of three coefficient matrices in <span class="math">\\mathbb{F}^{\\mathsf{M}\\times \\mathsf{N}}</span> and an instance size <span class="math">\\mathfrak{n}\\in \\mathbb{N}</span>, <span class="math">\\mathfrak{x} = x\\in \\mathbb{F}^{\\mathfrak{n}}</span> is an R1CS input, and <span class="math">\\mathfrak{w} = w\\in \\mathbb{F}^{\\mathsf{N} - \\mathfrak{n}}</span> is an R1CS witness such that <span class="math">Az\\circ Bz = Cz</span> for <span class="math">z\\coloneqq (x,w)</span>.</p>

    <p class="text-gray-300"><strong>Generator.</strong> The generator <span class="math">\\mathcal{G}</span> has query access to a random oracle <span class="math">\\rho_{\\mathrm{NARK}}</span> (but happens not to use it here) and receives as input the security parameter <span class="math">\\lambda</span> in unary and works as follows. Sample the description of a prime-order group <span class="math">(\\mathbb{G},q,G)\\gets \\mathrm{SampleGrp}(1^{\\lambda})</span>; here <span class="math">q</span> is the prime order of the group and <span class="math">G</span> is a generator for the group; henceforth we denote by <span class="math">\\mathbb{F}</span> the field of prime order <span class="math">q</span>. Output the public parameters <span class="math">\\mathsf{pp} := (\\mathbb{G},q,G)</span>.</p>

    <p class="text-gray-300"><strong>Indexer.</strong> The indexer <span class="math">\\mathcal{I}</span> has query access to a random oracle <span class="math">\\rho_{\\mathrm{NARK}}</span>, receives as input public parameters <span class="math">\\mathsf{pp}</span> and an index <span class="math">\\mathfrak{i} = (A,B,C,\\mathfrak{n})</span>, and works as follows. Use the random oracle to hash the coefficient matrices: <span class="math">\\tau \\coloneqq \\rho_{\\mathrm{NARK}}(A,B,C,\\mathfrak{n})</span>. Letting <span class="math">\\mathsf{M}</span> be the number of rows in a coefficient matrix, use the random oracle <span class="math">\\rho_{\\mathrm{NARK}}</span> to sample group generators to form a commitment key <span class="math">\\operatorname{ck} := (G_1,\\ldots ,G_M,H)\\in \\mathbb{G}^{\\mathsf{M} + 1}</span> for the Pedersen commitment with messages in <span class="math">\\mathbb{F}^{\\mathsf{M}}</span> (the extra group element <span class="math">H</span> is used for hiding). Output the index proving key <span class="math">\\mathrm{ipk} := (\\operatorname{ck},A,B,C,\\mathfrak{n},\\tau)</span> and index verification key <span class="math">\\mathrm{ivk} := \\mathrm{ipk}</span>. (Here, unlike in the split accumulation scheme in Section 8.2, the indexer can be folded into the prover and verifier as the verifier runs in linear time.)</p>

    <p class="text-gray-300"><strong>Prover.</strong> The prover <span class="math">\\mathcal{P}</span> has query access to a random oracle <span class="math">\\rho_{\\mathrm{NARK}}</span>, receives as input the index proving key <span class="math">\\mathrm{ipk} = (\\operatorname{ck}, A, B, C, \\mathfrak{n}, \\tau)</span>, an instance <span class="math">\\mathfrak{x} = x \\in \\mathbb{F}^{\\mathfrak{n}}</span>, and a witness <span class="math">\\mathfrak{w} = w \\in \\mathbb{F}^{\\mathbb{N} - \\mathfrak{n}}</span>, and works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assemble the full assignment <span class="math">z \\coloneqq (x, w) \\in \\mathbb{F}^{\\mathbb{N}}</span>.</li>

      <li>Sample randomness <span class="math">r \\in \\mathbb{F}^{\\mathbb{N} - \\mathfrak{n}}</span> that will be used to blind the witness <span class="math">w</span>.</li>

      <li>Compute linear combinations of the full assignment <span class="math">z</span> and (padded) randomness <span class="math">r</span> (they are in <span class="math">\\mathbb{F}^{\\mathsf{M}}</span>):</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} z _ {A} := A z, \\quad z _ {B} := B z, \\quad z _ {C} := C z, \\\\ r _ {A} := A \\left[ \\begin{array}{c} 0 ^ {\\mathsf {n}} \\\\ r \\end{array} \\right], \\quad r _ {B} := B \\left[ \\begin{array}{c} 0 ^ {\\mathsf {n}} \\\\ r \\end{array} \\right], \\quad r _ {C} := C \\left[ \\begin{array}{c} 0 ^ {\\mathsf {n}} \\\\ r \\end{array} \\right]. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commit to all the linear combinations: sample <span class="math">\\omega_{A},\\omega_{B},\\omega_{C},\\omega_{A}^{\\prime},\\omega_{B}^{\\prime},\\omega_{C}^{\\prime}\\in \\mathbb{F}</span> and compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} C _ {A} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, z _ {A}; \\omega_ {A}), \\quad C _ {B} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, z _ {B}; \\omega_ {B}), \\quad C _ {C} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, z _ {C}; \\omega_ {C}), \\\\ C _ {A} ^ {\\prime} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, r _ {A}; \\omega_ {A} ^ {\\prime}), \\quad C _ {B} ^ {\\prime} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, r _ {B}; \\omega_ {B} ^ {\\prime}), \\quad C _ {C} ^ {\\prime} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, r _ {C}; \\omega_ {C} ^ {\\prime}). \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commit to cross terms: sample <span class="math">\\omega_{1},\\omega_{2}\\in \\mathbb{F}</span> and compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C _ {1} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, z _ {A} \\circ r _ {B} + z _ {B} \\circ r _ {A}; \\omega_ {1}) \\quad \\text {and} \\quad C _ {2} := \\mathsf {C M}. \\mathsf {C o m m i t} (\\mathsf {c k}, r _ {A} \\circ r _ {B}; \\omega_ {2}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\pi_1 \\coloneqq (C_A, C_B, C_C, C&#x27;_A, C&#x27;_B, C&#x27;_C, C_1, C_2)</span> as the sigma protocol's prover commitment.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the random oracle to compute the sigma protocol’s challenge <span class="math">\\gamma:=\\rho_{\\texttt{NARK}}(\\tau,x,\\pi_{1})\\in\\mathbb{F}</span>.</li>

      <li>Blind the witness by computing <span class="math">s:=w+\\gamma r\\in\\mathbb{F}^{\\mathsf{N}-\\mathsf{n}}</span>.</li>

      <li>Blind the randomness for linear combinations: <span class="math">\\sigma_{A}:=\\omega_{A}+\\gamma\\omega_{A}^{\\prime}</span>, <span class="math">\\sigma_{B}:=\\omega_{B}+\\gamma\\omega_{B}^{\\prime}</span>, <span class="math">\\sigma_{C}:=\\omega_{C}+\\gamma\\omega_{C}^{\\prime}</span>.</li>

      <li>Blind the randomness for cross terms: <span class="math">\\sigma_{\\circ}:=\\omega_{C}+\\gamma\\omega_{1}+\\gamma^{2}\\omega_{2}</span>.</li>

      <li>Set <span class="math">\\pi_{2}:=(s,\\sigma_{A},\\sigma_{B},\\sigma_{C},\\sigma_{\\circ})</span> as the sigma protocol’s prover response.</li>

      <li>Output the proof string <span class="math">\\pi:=(\\pi_{1},\\pi_{2})</span>.</li>

    </ol>

    <h5 id="sec-67" class="text-base font-semibold mt-4">Verifier.</h5>

    <p class="text-gray-300">The prover <span class="math">\\mathcal{V}</span> has query access to a random oracle <span class="math">\\rho_{\\texttt{NARK}}</span>, receives as input the index verification key <span class="math">\\mathrm{ivk}=(\\mathsf{ck},A,B,C,\\mathsf{n},\\tau)</span> and an instance <span class="math">\\mathtt{z}\\mathtt{s}=x\\in\\mathbb{F}^{\\mathsf{n}}</span>, and works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the proof <span class="math">\\pi</span> as a pair <span class="math">(\\pi_{1},\\pi_{2})</span> consisting of a sigma protocol commitment and response.</li>

      <li>Use the random oracle to compute the sigma protocol’s challenge <span class="math">\\gamma:=\\rho_{\\texttt{NARK}}(\\tau,x,\\pi_{1})\\in\\mathbb{F}</span>.</li>

      <li>Compute linear combinations of the shifted assignment (they are in <span class="math">\\mathbb{F}^{\\mathsf{M}}</span>):</li>

    </ol>

    <p class="text-gray-300"><span class="math">s_{A}:=A\\begin{bmatrix}x\\\\ s\\end{bmatrix}\\text{, }s_{B}:=B\\begin{bmatrix}x\\\\ s\\end{bmatrix}\\text{, }s_{C}:=C\\begin{bmatrix}x\\\\ s\\end{bmatrix}\\text{ .}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of the linear combinations with the commitments:</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{A}+\\gamma C_{A}^{\\prime}=\\mathsf{CM.Commit}(\\mathsf{ck},s_{A};\\sigma_{A})\\text{,}</span> <span class="math">C_{B}+\\gamma C_{B}^{\\prime}=\\mathsf{CM.Commit}(\\mathsf{ck},s_{B};\\sigma_{B})\\text{,}</span> <span class="math">C_{C}+\\gamma C_{C}^{\\prime}=\\mathsf{CM.Commit}(\\mathsf{ck},s_{C};\\sigma_{C})\\text{.}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check consistency of the Hadamard product with the commitment:</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{C}+\\gamma C_{1}+\\gamma^{2}C_{2}=\\mathsf{CM.Commit}(\\mathsf{ck},s_{A}\\circ s_{B};\\sigma_{\\circ})\\text{ .}</span></p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">8.2 Split accumulation for the zkNARK verifier</h3>

    <p class="text-gray-300">We describe a split accumulation scheme <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> for the zkNARK for R1CS in Section 8.1. As a subroutine we use an accumulation scheme <span class="math">\\mathsf{AS}_{\\text{\\tiny HP}}=(\\mathrm{G}_{\\text{\\tiny HP}},\\mathrm{I}_{\\text{\\tiny HP}},\\mathrm{P}_{\\text{\\tiny HP}},\\mathrm{V}_{\\text{\\tiny HP}},\\mathrm{D}_{\\text{\\tiny HP}})</span> for the Hadamard product predicate <span class="math">\\Phi_{\\text{\\tiny HP}}</span> (e.g., the one we construct in Section 7). We use domain separation on the given random oracle <span class="math">\\rho</span> for different tasks: we use <span class="math">\\rho_{\\text{\\tiny HP}}</span> to denote the oracle used for one invocation of <span class="math">\\mathsf{AS}_{\\text{\\tiny HP}}</span>; <span class="math">\\rho_{\\texttt{NARK}}</span> to denote the oracle used to run the zkNARK for R1CS; and <span class="math">\\rho_{\\texttt{AS}}</span> to denote the random oracle used by <span class="math">\\mathsf{AS}</span> for other tasks. We use red text to denote features required to achieve zero knowledge accumulation, provided that <span class="math">\\mathsf{AS}_{\\text{\\tiny HP}}</span> is itself a zero knowledge accumulation scheme. (Dropping the red text leads to secure, but not zero knowledge, accumulation.)</p>

    <h5 id="sec-69" class="text-base font-semibold mt-4">Predicate inputs.</h5>

    <p class="text-gray-300">Following Definition 5.1, the predicate to accumulate is the NARK verifier, with the following split in a predicate input q obtained from an R1CS instance <span class="math">x</span> and proof <span class="math">\\pi=(\\pi_{1},\\pi_{2})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The instance part of q consists of the R1CS input <span class="math">x</span> and the sigma protocol’s commitment <span class="math">\\pi_{1}</span>. This amounts to <span class="math">8</span> group elements and n field elements (which is short).</li>

      <li>The witness part of q consists of the sigma protocol’s response <span class="math">\\pi_{2}</span>. This amounts to <span class="math">\\mathsf{N}-\\mathsf{n}+4</span> field elements (which is proportional to the number of rows of the R1CS matrices).</li>

    </ul>

    <p class="text-gray-300">Accumulator. The format of an accumulator acc is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The instance part of acc consists of  <span class="math">\\mathsf{acc}.\\mathbf{x} = (C_x, C_A, C_B, C_C, \\mathsf{acc}_{\\mathsf{HP}}.\\mathbf{x})</span> .</li>

      <li>The witness part of acc consists of  <span class="math">\\mathsf{acc}.\\mathsf{w} = (x,s,\\sigma_A,\\sigma_B,\\sigma_C,\\mathsf{acc}_{\\mathsf{HP}}.\\mathsf{w})</span></li>

    </ul>

    <p class="text-gray-300">Note that a split accumulator has a different format to a predicate input. The size of acc.x does not depend on the size of the public input  <span class="math">x</span> , as required by our PCD construction (Theorem 5.3).</p>

    <p class="text-gray-300">Generator. The generator  <span class="math">G</span>  runs  <span class="math">G_{HP}</span>  as a subroutine and outputs its output  <span class="math">pp := pp_{HP}</span> .</p>

    <p class="text-gray-300">Indexer. The indexer I receives as input accumulation public parameters  <span class="math">\\mathsf{pp} = \\mathsf{pp}_{\\mathsf{HP}}</span>  (output by G), predicate public parameters  <span class="math">\\mathsf{pp}_{\\Phi} = \\mathsf{pp}_{\\mathsf{NARK}}</span>  (the public parameters of the NARK per Definition 5.1), predicate index  <span class="math">\\mathsf{i}_{\\Phi} = (A, B, C, \\mathsf{n})</span>  (the index of the relation verified by the NARK per Definition 5.1), and works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Invoke the NARK indexer (ipk, ivk) :=  <span class="math">\\mathcal{I}_{\\mathrm{NARK}}^{\\rho_{\\mathrm{NARK}}}(\\mathsf{pp}_{\\mathrm{NARK}}, \\mathsf{i}_{\\Phi})</span> , and then obtain ck and  <span class="math">\\tau</span>  from ipk.</li>

      <li>Set the vector length to be  <span class="math">\\ell \\coloneqq \\mathsf{M}</span> , the number of rows in each R1CS coefficient matrix.</li>

      <li>Invoke  <span class="math">\\mathrm{I}_{\\mathrm{HP}}(\\mathsf{pp}_{\\mathrm{HP}}, \\mathsf{ck}, \\ell)</span>  to obtain  <span class="math">(\\mathsf{apk}_{\\mathrm{HP}}, \\mathsf{avk}_{\\mathrm{HP}}, \\mathsf{dk}_{\\mathrm{HP}})</span> . (Here we provide  <span class="math">\\mathsf{ck}</span>  in place of  <span class="math">\\mathsf{pp}_{\\Phi_{\\mathrm{HP}}}</span> , making use of the fact that for the Pedersen commitment, these have the same form.)</li>

      <li>Output (apk, avk, dk) :=  <span class="math">\\left((A,B,C,\\mathsf{n},\\tau ,\\mathsf{apk}_{\\mathsf{HP}}),(\\tau ,\\mathsf{n},\\mathsf{avk}_{\\mathsf{HP}}),(A,B,C,\\mathsf{n},\\mathsf{ck},\\mathsf{dk}_{\\mathsf{HP}})\\right)</span> .</li>

    </ul>

    <p class="text-gray-300">Accumulation prover. On input the accumulation proving key  <span class="math">\\mathsf{apk} = (A,B,C,\\mathsf{n},\\tau ,\\mathsf{apk}_{\\mathsf{HP}})</span> , predicate instance-witness pairs  <span class="math">[(qx_i,qw_i)]_{i = 1}^n</span> , and old split accumulators  <span class="math">[\\mathsf{acc}_j]_{j = 1}^m = [(\\mathsf{acc}_j.\\mathbf{x},\\mathsf{acc}_j.\\mathbf{w})]_{j = 1}^m</span> , P works as below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i\\in [n]</span></li>

    </ol>

    <p class="text-gray-300">(a) Compute the challenge of the  <span class="math">i</span> -th proof:  <span class="math">\\gamma_{i} := \\rho_{\\mathrm{NARK}}(\\tau, \\mathbf{q}\\mathbf{x}_{i})</span> . (b) Set  <span class="math">\\mathsf{qx}_{\\mathsf{HP},i} := (\\mathsf{qx}_i.C_A + \\gamma_i\\cdot \\mathsf{qx}_i.C_A&#x27;,\\mathsf{qx}_i.C_B + \\gamma_i\\cdot \\mathsf{qx}_i.C_B&#x27;,\\mathsf{qx}_i.C_C + \\gamma_i\\cdot \\mathsf{qx}_i.C_1 + \\gamma_i^2\\cdot \\mathsf{qx}_i.C_2)</span> . (c) Set  <span class="math">\\mathsf{qw}_{\\mathsf{HP},i} := \\big(A \\cdot (\\mathsf{qx}_i.x, \\mathsf{qw}_i.s), B \\cdot (\\mathsf{qx}_i.x, \\mathsf{qw}_i.s), \\mathsf{qw}_i.\\sigma_A, \\mathsf{qw}_i.\\sigma_B, \\mathsf{qw}_i.\\sigma_\\circ \\big)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j\\in [m]</span></li>

    </ol>

    <p class="text-gray-300">(a) Set  <span class="math">\\mathsf{acc}_{\\mathsf{HP},j}.\\mathbf{x} := \\mathsf{acc}_j.\\mathbf{x}.\\mathsf{acc}_{\\mathsf{HP}}.\\mathbf{x}</span> . (b) Set  <span class="math">\\mathsf{acc}_{\\mathsf{HP},j}.\\mathsf{w} := \\mathsf{acc}_j.\\mathsf{w}.\\mathsf{acc}_{\\mathsf{HP}}.\\mathsf{w}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Accumulate Hadamard products:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\operatorname {a c c} _ {\\mathrm {H P}}, \\operatorname {p f} _ {\\mathrm {H P}}\\right) := \\mathsf {A S} _ {\\mathrm {H P}}. \\mathrm {P} ^ {\\rho_ {\\mathrm {H P}}} \\left(\\operatorname {a p k} _ {\\mathrm {H P}}, \\left[ \\left(\\mathrm {q x} _ {\\mathrm {H P}, i}, \\mathrm {q w} _ {\\mathrm {H P}, i}\\right) \\right] _ {i = 1} ^ {n}, \\left[ \\left(\\operatorname {a c c} _ {\\mathrm {H P}, j}. \\mathrm {x}, \\operatorname {a c c} _ {\\mathrm {H P}, j}. \\mathrm {w}\\right) \\right] _ {j = 1} ^ {m}\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample randomness  <span class="math">x^{\\star} \\in \\mathbb{F}^{n}</span> ,  <span class="math">s^{\\star} \\in \\mathbb{F}^{N - n}</span> , and  <span class="math">\\omega_{A}^{\\star}, \\omega_{B}^{\\star}, \\omega_{C}^{\\star} \\in \\mathbb{F}</span>  and compute the following commitments:</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_x^\\star \\coloneqq \\mathsf{CM}</span>  .Commit  <span class="math">(\\mathsf{ck},x^{\\star};0)</span></p>

    <p class="text-gray-300"><span class="math">C_A^\\star \\coloneqq \\mathsf{CM}</span>  .Commit  <span class="math">\\left(\\mathsf{ck},A\\cdot \\left[ \\begin{array}{c}x^{\\star}\\\\ s^{\\star} \\end{array} \\right];\\omega_{A}^{\\star}\\right)</span></p>

    <p class="text-gray-300"><span class="math">C_B^\\star \\coloneqq \\mathsf{CM}</span>  .Commit  <span class="math">\\left(\\mathsf{ck},B\\cdot \\left[ \\begin{array}{c}x^{\\star}\\\\ s^{\\star} \\end{array} \\right];\\omega_{B}^{\\star}\\right)</span></p>

    <p class="text-gray-300"><span class="math">C_C^\\star \\coloneqq \\mathsf{CM}</span>  .Commit  <span class="math">\\left(\\mathsf{ck},C\\cdot \\left[ \\begin{array}{c}x^{\\star}\\\\ s^{\\star} \\end{array} \\right];\\omega_{C}^{\\star}\\right)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the random oracle to compute  <span class="math">\\beta \\coloneqq \\rho_{\\mathrm{AS}}(\\tau, [\\mathsf{acc}_j.\\mathbf{x}]_{j=1}^m, [\\mathsf{qx}_i]_{i=1}^n, C_x^\\star, C_A^\\star, C_B^\\star, C_C^\\star) \\in \\mathbb{F}</span> .</li>

      <li>Compute the accumulator instance  <span class="math">\\mathsf{acc}.\\mathbf{x} := (C_x, C_A, C_B, C_C, \\mathsf{acc}_{\\mathsf{HP}}.\\mathbf{x})</span>  where:</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_x\\coloneqq \\sum_{j = 1}^m\\beta^{j - 1}\\cdot \\mathsf{acc}_j.\\mathbf{x}.C_x + \\sum_{i = 1}^n\\beta^{m + i - 1}\\cdot \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck},\\mathsf{qx}_i.x;0) + \\beta^{m + n}\\cdot C_x^\\star ,</span></p>

    <p class="text-gray-300"><span class="math">C_A\\coloneqq \\sum_{j = 1}^m\\beta^{j - 1}\\cdot \\mathsf{acc}_j.\\mathbf{x}.C_A + \\sum_{i = 1}^n\\beta^{m + i - 1}\\cdot \\left(\\mathsf{qx}_i.C_A + \\gamma_i\\cdot \\mathsf{qx}_i.C_A&#x27;\\right) + \\beta^{m + n}\\cdot C_A^\\star ,</span></p>

    <div class="my-4 text-center"><span class="math-block">C _ {B} := \\sum_ {j = 1} ^ {m} \\beta^ {j - 1} \\cdot \\mathsf {a c c} _ {j}. \\mathbf {x}. C _ {B} + \\sum_ {i = 1} ^ {n} \\beta^ {m + i - 1} \\cdot \\left(\\mathsf {q x} _ {i}. C _ {B} + \\gamma_ {i} \\cdot \\mathsf {q x} _ {i}. C _ {B} ^ {\\prime}\\right) + \\beta^ {m + n} \\cdot C _ {B} ^ {\\star},</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {C} := \\sum_ {j = 1} ^ {m} \\beta^ {j - 1} \\cdot \\mathsf {a c c} _ {j}. \\mathbf {x}. C _ {C} + \\sum_ {i = 1} ^ {n} \\beta^ {m + i - 1} \\cdot \\left(\\mathsf {q x} _ {i}. C _ {C} + \\gamma_ {i} \\cdot \\mathsf {q x} _ {i}. C _ {C} ^ {\\prime}\\right) + \\beta^ {m + n} \\cdot C _ {C} ^ {\\star}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the accumulator witness <span class="math">\\mathsf{acc.w} := (x, s, \\sigma_A, \\sigma_B, \\sigma_C, \\mathsf{acc}_{\\mathsf{HP}.w})</span> where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">x := \\sum_ {j = 1} ^ {m} \\beta^ {j - 1} \\cdot \\mathsf {a c c} _ {j}. \\mathbf {w}. x + \\sum_ {i = 1} ^ {n} \\beta^ {m + i - 1} \\cdot \\mathsf {q x} _ {i}. x + \\beta^ {m + n} \\cdot x ^ {\\star},</span></div>

    <div class="my-4 text-center"><span class="math-block">s := \\sum_ {j = 1} ^ {m} \\beta^ {j - 1} \\cdot \\mathsf {a c c} _ {j}. \\mathbf {w}. s + \\sum_ {i = 1} ^ {n} \\beta^ {m + i - 1} \\cdot \\mathsf {q w} _ {i}. s + \\beta^ {m + n} \\cdot s ^ {\\star},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {A} := \\sum_ {j = 1} ^ {m} \\beta^ {j - 1} \\cdot \\mathsf {a c c} _ {j}. \\mathbf {w}. \\sigma_ {A} + \\sum_ {i = 1} ^ {n} \\beta^ {m + i - 1} \\cdot \\mathsf {q w} _ {i}. \\sigma_ {A} + \\beta^ {m + n} \\cdot \\omega_ {A} ^ {\\star},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {B} := \\sum_ {j = 1} ^ {m} \\beta^ {j - 1} \\cdot \\mathsf {a c c} _ {j}. \\mathbf {w}. \\sigma_ {B} + \\sum_ {i = 1} ^ {n} \\beta^ {m + i - 1} \\cdot \\mathsf {q w} _ {i}. \\sigma_ {B} + \\beta^ {m + n} \\cdot \\omega_ {B} ^ {\\star},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {C} := \\sum_ {j = 1} ^ {m} \\beta^ {j - 1} \\cdot \\mathsf {a c c} _ {j}. \\mathbf {w}. \\sigma_ {C} + \\sum_ {i = 1} ^ {n} \\beta^ {m + i - 1} \\cdot \\mathsf {q w} _ {i}. \\sigma_ {C} + \\beta^ {m + n} \\cdot \\omega_ {C} ^ {\\star}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set the split accumulator <span class="math">\\mathsf{acc} := (\\mathsf{acc}.x, \\mathsf{acc}.w)</span> and accumulation proof <span class="math">\\mathsf{pf} := (\\mathsf{pf}_{\\mathsf{HP}}, C_x^<em>, C_A^</em>, C_B^<em>, C_C^</em>)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output (acc, pf).</li>

    </ol>

    <p class="text-gray-300"><strong>Accumulation verifier.</strong> On input the accumulator verification key <span class="math">\\mathsf{avk} = (\\tau, \\mathsf{n}, \\mathsf{avk}_{\\mathsf{HP}})</span>, predicate instances <span class="math">[qx_i]_i^n</span>, old accumulator instances <span class="math">[acc_j.x]_{j=1}^m</span>, a new accumulator instance <span class="math">\\mathsf{acc.x} = (C_x, C_A, C_B, C_C, \\mathsf{acc}_{\\mathsf{HP}.x})</span>, and an accumulation proof <span class="math">\\mathsf{pf} = (\\mathsf{pf}_{\\mathsf{HP}}, C_x^<em>, C_A^</em>, C_B^<em>, C_C^</em>)</span>, V works as below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">[\\gamma_i]_{i=1}^n</span> as in Step 1a of the accumulation prover P.</li>

      <li>Compute <span class="math">[qx_{HP,i}]_{i=1}^n</span> as in Step 1b of the accumulation prover P.</li>

      <li>Compute <span class="math">[acc_{HP,j}.x]_{j=1}^m</span> as in Step 2a of the accumulation prover P.</li>

      <li>Check that <span class="math">\\mathsf{AS}_{\\mathsf{HP}}.\\mathsf{V}^{\\rho_{\\mathsf{HP}}}(\\mathsf{avk}_{\\mathsf{HP}},[qx_{HP,i}]_{i = 1}^{n},[acc_{HP,j}.x]_{j = 1}^{m},acc_{HP}.x,pf_{\\mathsf{HP}}) = 1.</span></li>

      <li>Compute <span class="math">\\beta</span> as in Step 5 of the accumulation prover P.</li>

      <li>Perform the assignments in Step 6 of the accumulation prover <span class="math">\\mathrm{P}</span> as equality checks (between the new accumulator instance and the input instances and old accumulator instances).</li>

    </ol>

    <p class="text-gray-300"><strong>Decider.</strong> On input the decision key <span class="math">\\mathsf{dk} = (A,B,C,\\mathsf{n},\\mathsf{ck},\\mathsf{dk}_{\\mathsf{HP}})</span> and an accumulator <span class="math">\\mathsf{acc}</span>, D works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the accumulator instance <span class="math">\\mathsf{acc}.x</span> as <span class="math">(C_x, C_A, C_B, C_C, \\mathsf{acc}_{\\mathsf{HP}}.x)</span>.</li>

      <li>Parse the accumulator witness <span class="math">\\mathsf{acc.w}</span> as <span class="math">(x,s,\\sigma_A,\\sigma_B,\\sigma_C,\\mathsf{acc}_{\\mathsf{HP}.w})</span>.</li>

      <li>Compute <span class="math">s_A := A \\begin{bmatrix} x \\\\ s \\end{bmatrix}, s_B := B \\begin{bmatrix} x \\\\ s \\end{bmatrix}, s_C := C \\begin{bmatrix} x \\\\ s \\end{bmatrix}</span>, which are vectors in <span class="math">\\mathbb{F}^M</span>.</li>

      <li>Check that <span class="math">C_x = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, x; 0)</span>.</li>

      <li>Check that <span class="math">C_A = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, s_A; \\sigma_A)</span>.</li>

      <li>Check that <span class="math">C_B = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, s_B; \\sigma_B)</span>.</li>

      <li>Check that <span class="math">C_C = \\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, s_C; \\sigma_C)</span>.</li>

      <li>Set <span class="math">\\mathsf{acc}_{\\mathsf{HP}} := (\\mathsf{acc}_{\\mathsf{HP}}. \\mathbf{x}, \\mathsf{acc}_{\\mathsf{HP}}. \\mathbf{w})</span> and check that <span class="math">\\mathsf{AS}_{\\mathsf{HP}}. \\mathsf{D}(\\mathsf{dk}_{\\mathsf{HP}}, \\mathsf{acc}_{\\mathsf{HP}}) = 1</span>.</li>

    </ol>

    <h2 id="sec-70" class="text-2xl font-bold">8.3 Security proofs</h2>

    <p class="text-gray-300">We prove that the non-interactive argument for R1CS in Section 8.1 satisfies the zero knowledge and knowledge soundness definitions from Section 3.1. Then we provide proof sketches that the accumulation scheme for it in Section 8.2 satisfies the zero knowledge and knowledge soundness definitions from Section 4.</p>

    <p class="text-gray-300"><strong>Lemma 8.2.</strong> The non-interactive argument for R1CS satisfies perfect zero knowledge.</p>

    <p class="text-gray-300">Proof. Consider the simulator  <span class="math">S</span>  that is first given the security parameter  <span class="math">\\lambda</span>  in unary and invokes the generator  <span class="math">\\mathcal{G}</span>  to sample the public parameters (in particular, there are no trapdoors). Subsequently,  <span class="math">S</span>  receives as input an index  <span class="math">\\mathbb{i} = (A, B, C, \\mathfrak{n})</span>  and an instance  <span class="math">\\mathbb{x} = x \\in \\mathbb{F}^{\\mathfrak{n}}</span> , and works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a commitment key ck and hash of coefficient matrices  <span class="math">\\tau</span>  like the indexer  <span class="math">\\mathcal{I}</span>  does.</li>

      <li>Sample the following at random:  <span class="math">s \\in \\mathbb{F}^{\\mathbb{N} - \\mathfrak{n}}</span> ,  <span class="math">\\sigma_A, \\sigma_B, \\sigma_C, \\sigma_\\circ \\in \\mathbb{F}</span> , and  <span class="math">C_A&#x27;, C_B&#x27;, C_1, C_2 \\in \\mathbb{G}</span> .</li>

      <li>Set  <span class="math">\\pi_2\\coloneqq (x,s,\\sigma_A,\\sigma_B,\\sigma_C,\\sigma_\\circ)</span></li>

      <li>Compute  <span class="math">s_A \\coloneqq A\\left[ \\begin{array}{c}x\\\\ s \\end{array} \\right], s_B \\coloneqq B\\left[ \\begin{array}{c}x\\\\ s \\end{array} \\right], s_C \\coloneqq C\\left[ \\begin{array}{c}x\\\\ s \\end{array} \\right]</span> .</li>

      <li>Compute  <span class="math">C_x \\coloneqq \\mathsf{CM}</span> . Commit(ck,  <span class="math">x</span> ; 0)</li>

      <li>Sample a random challenge  <span class="math">\\gamma \\in \\mathbb{F}</span></li>

      <li>Compute  <span class="math">C_A \\coloneqq \\mathsf{CM}</span> . Commit(ck,  <span class="math">s_A</span> ;  <span class="math">\\sigma_A</span> ) -  <span class="math">\\gamma C_A&#x27;</span> .</li>

      <li>Compute  <span class="math">C_B \\coloneqq \\mathsf{CM}</span> . Commit(ck,  <span class="math">s_B</span> ;  <span class="math">\\sigma_B</span> ) -  <span class="math">\\gamma C_B&#x27;</span> .</li>

      <li>Compute  <span class="math">C_C \\coloneqq \\mathsf{CM}</span> . Commit(ck,  <span class="math">s_A \\circ s_B</span> ;  <span class="math">\\sigma_C</span> ) -  <span class="math">\\gamma C_1 - \\gamma^2 C_2</span> .</li>

      <li>Compute  <span class="math">C_C^\\prime \\coloneqq \\gamma^{-1}\\bigl (\\mathsf{CM}. \\mathsf{Commit}(\\mathsf{ck}, s_C; \\sigma_C) - C_C\\bigr)</span> .</li>

      <li>Set  <span class="math">\\pi_1\\coloneqq (C_A,C_B,C_C,C_A&#x27;,C_B&#x27;,C_C&#x27;,C_1,C_2)</span></li>

      <li>Program the random oracle  <span class="math">\\rho</span>  to output  <span class="math">\\gamma</span>  on input  <span class="math">\\pi_1</span> .</li>

      <li>Output  <span class="math">\\pi \\coloneqq (\\pi_1,\\pi_2)</span> , along with the programming  <span class="math">\\mu \\coloneqq [\\pi_1\\mapsto \\gamma ]</span></li>

    </ol>

    <p class="text-gray-300">By construction the output proof string  <span class="math">\\pi</span>  makes the verifier accept when its random oracle is programmed with  <span class="math">\\mu</span> . Moreover, the distribution of all elements in the proof string  <span class="math">\\pi</span>  is random subject to the condition that the proof string  <span class="math">\\pi</span>  is accepting.</p>

    <p class="text-gray-300">Lemma 8.3. The non-interactive argument for RICS satisfies knowledge soundness.</p>

    <p class="text-gray-300">Proof. We prove a stronger knowledge soundness property that what is required in Section 3.1: there exists an extractor  <span class="math">\\mathcal{E}</span>  such that for every (non-uniform) adversary  <span class="math">\\tilde{\\mathcal{P}}</span>  running in expected polynomial time and auxiliary input distribution  <span class="math">\\mathcal{D}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathbb {x}, \\pi) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (1 ^ {\\lambda}) \\\\ (\\mathbb {i}, \\mathbb {x}, \\pi ; r) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {a i}) &amp;amp; \\\\ \\mathrm {w} \\leftarrow \\mathcal {E} ^ {\\tilde {\\mathcal {P}}, \\rho} (\\mathsf {p p}, \\mathsf {a i}, r) &amp;amp; \\\\ (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {i}) &amp;amp; \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda) .</span></div>

    <p class="text-gray-300">We construct the extractor  <span class="math">\\mathcal{E}</span>  based on our forking lemma (Lemma 6.1).</p>

    <p class="text-gray-300">Define the following algorithm:</p>

    <p class="text-gray-300"><span class="math">A^{\\rho}((\\mathsf{pp},\\mathsf{ai}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathbb{i},\\mathbb{x},\\pi)\\gets \\tilde{\\mathcal{P}}^{\\rho}(\\mathsf{pp},\\mathsf{ai})</span></li>

      <li>Compute  <span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\coloneqq \\mathcal{I}^{\\rho}(\\mathsf{pp},\\mathfrak{i})</span></li>

      <li>Parse the index verification key ivk as  <span class="math">(\\mathsf{ck},A,B,C,\\mathsf{n},\\tau)</span> , and the proof string  <span class="math">\\pi</span>  as  <span class="math">(\\pi_1,\\pi_2)</span> .</li>

      <li>Set the query  <span class="math">\\mathfrak{q} \\coloneqq (\\tau, \\mathbb{x}, \\pi_1)</span> .</li>

      <li>Set the output o to  <span class="math">(\\dot{\\mathfrak{i}},\\pi_2)</span></li>

      <li>Query the random oracle  <span class="math">\\rho</span>  at  <span class="math">\\mathfrak{q}</span> .</li>

      <li>Output  <span class="math">(\\mathfrak{q},\\mathfrak{o})</span></li>

    </ol>

    <p class="text-gray-300">Define the forking lemma predicate:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{p}\\big((\\mathsf{pp},\\mathsf{ai}),(\\mathsf{q},\\mathsf{a}),\\mathsf{o},\\mathsf{tr}\\big)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the query <span class="math">\\mathfrak{q}</span> as <span class="math">(\\tau, \\Xi, \\pi_1)</span>.</li>

      <li>Parse the output <span class="math">\\mathsf{o}</span> as a pair <span class="math">(\\dot{\\mathfrak{s}}, \\pi_2)</span>.</li>

      <li>Check that <span class="math">\\tau = \\operatorname{tr}(\\dot{\\mathfrak{s}})</span>; if not, output 0.</li>

      <li>Compute <span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\coloneqq \\mathcal{I}^{\\rho}(\\mathsf{pp},\\dot{\\mathfrak{s}})</span>, answering its queries to <span class="math">\\rho</span> with <span class="math">\\operatorname{tr}</span>.</li>

      <li>Check that <span class="math">\\mathcal{V}^{\\rho}\\big(\\mathrm{ivk},\\Xi ,(\\pi_1,\\pi_2)\\big)</span> outputs 1 when answering its query to <span class="math">\\rho</span> with <span class="math">\\mathfrak{a}</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}</span> be the extractor that runs the forking algorithm <span class="math">\\mathrm{Fork}^A</span> obtained by applying Lemma 6.1 to <span class="math">\\mathfrak{p}</span> to obtain three outputs. With all but negligible probability it obtains <span class="math">(\\tau, \\Xi, \\pi_1)</span> and tuples <span class="math">(\\gamma, (\\dot{\\mathfrak{s}}, \\pi_2)), (\\gamma&#x27;, (\\dot{\\mathfrak{s}}&#x27;, \\pi_2&#x27;))</span>, <span class="math">(\\gamma&#x27;&#x27;, (\\dot{\\mathfrak{s}}&#x27;&#x27;, \\pi_2&#x27;&#x27;))</span> satisfying <span class="math">\\mathfrak{p}</span> with <span class="math">\\gamma, \\gamma&#x27;, \\gamma&#x27;&#x27;</span> pairwise distinct. This implies that <span class="math">(\\pi_1, \\gamma, \\pi_2)</span> is an accepting transcript for the underlying sigma protocol with respect to <span class="math">\\dot{\\mathfrak{s}}</span>; similarly for <span class="math">(\\pi_1, \\gamma&#x27;, \\pi_2&#x27;)</span> with respect to <span class="math">\\dot{\\mathfrak{s}}&#x27;</span> and <span class="math">(\\pi_1, \\gamma&#x27;&#x27;, \\pi_2&#x27;&#x27;)</span> with respect to <span class="math">\\dot{\\mathfrak{s}}&#x27;&#x27;</span>. Moreover, since <span class="math">\\tau = \\operatorname{tr}(\\dot{\\mathfrak{s}}) = \\operatorname{tr}(\\dot{\\mathfrak{s}}&#x27;) = \\operatorname{tr}(\\dot{\\mathfrak{s}}&#x27;&#x27;)</span>, it holds by collision resistance of the random oracle that <span class="math">\\dot{\\mathfrak{s}} = \\dot{\\mathfrak{s}}&#x27; = \\dot{\\mathfrak{s}}&#x27;&#x27;</span> with all but negligible probability. The extractor then computes and outputs <span class="math">w := \\frac{\\gamma}{\\gamma - \\gamma&#x27;} s&#x27; - \\frac{\\gamma&#x27;}{\\gamma - \\gamma&#x27;} s \\in \\mathbb{F}^{\\mathsf{N} - \\mathsf{n}}</span>.</p>

    <p class="text-gray-300">We argue that <span class="math">\\mathfrak{w} := w</span> is a valid witness for the index-instance pair <span class="math">(\\dot{\\mathfrak{s}}, \\Xi)</span> output by <span class="math">\\tilde{\\mathcal{P}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define <span class="math">r \\coloneqq \\frac{1}{\\gamma - \\gamma&#x27;} (s - s&#x27;) \\in \\mathbb{F}^{\\mathsf{N} - \\mathsf{n}}</span>. We first extract an opening of <span class="math">C_A</span> to $A[x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w]<span class="math">. Since the verifier accepts, </span>C_A + \\gamma C_A'<span class="math"> opens to </span>A[x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s] = A[x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(w + \\gamma r)]<span class="math">; likewise for </span>\\gamma'<span class="math"> and </span>s'<span class="math">. Using the linear homomorphism of </span>\\mathsf{CM}<span class="math">, we can solve the system to open </span>C_A<span class="math"> to </span>A[x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w]<span class="math">. Similar reasoning allows us to open </span>C_B, C_C<span class="math"> to </span>B[x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w], C[x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w]$ respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By definition of <span class="math">w, r</span> it holds that <span class="math">s = w + \\gamma r</span> and <span class="math">s&#x27; = w + \\gamma&#x27; r</span>. Moreover by the binding property of CM it holds that $s_A'' = A[x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(w + \\gamma'' r)]<span class="math">, and likewise for </span>s_B''$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next we use this fact with the Hadamard product check to show that the R1CS equation holds.</p>

    <p class="text-gray-300">We argue that <span class="math">C_C</span> commits to the Hadamard product of the vectors inside <span class="math">C_A</span> and <span class="math">C_B</span>. Note that the following holds as a polynomial identity in <span class="math">Y</span>:</p>

    <div class="my-4 text-center"><span class="math-block">A \\left[ \\begin{array}{c} x \\\\ w + Y r \\end{array} \\right] \\circ B \\left[ \\begin{array}{c} x \\\\ w + Y r \\end{array} \\right] \\equiv A \\left[ \\begin{array}{c} x \\\\ w \\end{array} \\right] \\circ B \\left[ \\begin{array}{c} x \\\\ w \\end{array} \\right] + \\left(A \\left[ \\begin{array}{c} x \\\\ w \\end{array} \\right] \\circ B \\left[ \\begin{array}{c} 0 \\\\ r \\end{array} \\right] + A \\left[ \\begin{array}{c} 0 \\\\ r \\end{array} \\right] \\circ B \\left[ \\begin{array}{c} x \\\\ w \\end{array} \\right]\\right) Y + \\left(A \\left[ \\begin{array}{c} 0 \\\\ r \\end{array} \\right] \\circ B \\left[ \\begin{array}{c} 0 \\\\ r \\end{array} \\right]\\right) Y ^ {2}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the NARK verifier accepts, we know that <span class="math">C_C + \\gamma C_1 + \\gamma^2 C_2</span> is a commitment to the evaluation of the above polynomial at <span class="math">\\gamma</span>; the same is true with respect to <span class="math">\\gamma&#x27;</span> and <span class="math">\\gamma&#x27;&#x27;</span> for the associated commitments. We can hence solve a linear system to open <span class="math">C_C</span> to $A[x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w] \\circ B[x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w]<span class="math">. By the binding of CM, it then holds that </span>C[x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w] = A[x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w] \\circ B[x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w]<span class="math">. This means that </span>\\mathfrak{w} = w<span class="math"> is a valid R1CS witness with respect to </span>(\\dot{\\mathfrak{s}}, \\Xi)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 8.4.</strong> The split accumulation scheme for R1CS satisfies perfect zero knowledge.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathrm{S}_{\\mathrm{HP}}</span> be the simulator for <span class="math">\\mathrm{AS}_{\\mathrm{HP}}</span>, and suppose that it does not rely on a trapdoor or program the random oracle (this is the case for our construction in Section 7). Consider the simulator <span class="math">\\mathrm{S}</span> for <span class="math">\\mathrm{AS}</span> that works as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{S}^{\\rho}(\\tau = \\bot ,\\mathsf{pp}_{\\Phi} = \\mathsf{pp}_{\\mathsf{NARK}},\\mathrm{i}_{\\Phi} = (A,B,C,\\mathsf{n}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">(x,s)\\in \\mathbb{F}^{\\mathbb{N}}</span>.</li>

      <li>Compute <span class="math">s_A \\coloneqq A \\cdot (x, s)</span>, <span class="math">s_B \\coloneqq B \\cdot (x, s)</span>, <span class="math">s_C \\coloneqq C \\cdot (x, s)</span>, which are vectors in <span class="math">\\mathbb{F}^{\\mathsf{M}}</span>.</li>

      <li>Compute <span class="math">C_x \\coloneqq \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck}, x; 0)</span>.</li>

      <li>Compute <span class="math">C_A \\coloneqq \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck}, s_A; \\sigma_A)</span>.</li>

    </ol>

    <p class="text-gray-300">55</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">C_B := \\mathsf{CM.Commit}(\\mathsf{ck}, s_B; \\sigma_B)</span>.</li>

      <li>Compute <span class="math">C_C := \\mathsf{CM.Commit}(\\mathsf{ck}, s_C; \\sigma_C)</span>.</li>

      <li>Sample <span class="math">\\mathsf{acc}_{\\mathsf{HP}} \\gets \\mathsf{S}_{\\mathsf{HP}}(\\tau_{\\mathsf{HP}} = \\bot, \\mathsf{pp}_{\\Phi}, \\ell)</span>.</li>

      <li>Set the accumulator instance <span class="math">\\mathsf{acc}.\\mathbf{x} := (C_x, C_A, C_B, C_C, \\mathsf{acc}_{\\mathsf{HP}}.\\mathbf{x})</span>.</li>

      <li>Set the accumulator witness <span class="math">\\mathsf{acc.w} := (x, s, \\sigma_A, \\sigma_B, \\sigma_C, \\mathsf{acc}_{\\mathsf{HP}}.\\mathbf{w})</span>.</li>

      <li>Output <span class="math">\\mathsf{acc} := (\\mathsf{acc}.\\mathbf{x}, \\mathsf{acc}.\\mathbf{w})</span>.</li>

    </ol>

    <p class="text-gray-300">By construction, the sampled accumulator satisfies the decider. Moreover, the accumulator is distributed identically as an accumulator output by the (honest) accumulation prover. This is because <span class="math">\\mathsf{acc}_{\\mathsf{HP}}</span> is sampled by the simulator <span class="math">\\mathsf{S}_{\\mathsf{HP}}</span> for <span class="math">\\mathsf{AS}_{\\mathsf{HP}}</span> (which we have assumed is zero knowledge) and all other elements of the accumulator are random within the respective domains subject only to the condition that the decider accepts the accumulator.</p>

    <p class="text-gray-300"><strong>Lemma 8.5.</strong> The split accumulation scheme for R1CS satisfies knowledge soundness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We describe an extractor <span class="math">\\mathbf{E}</span> and then argue that it satisfies the knowledge property in Section 4; <span class="math">\\mathbf{E}</span> has access to the random oracle <span class="math">\\rho</span> that consists of three domain-separated random oracles <span class="math">\\rho = (\\rho_{\\mathrm{AS}}, \\rho_{\\mathrm{HP}}, \\rho_{\\mathrm{NARK}})</span>.</p>

    <p class="text-gray-300">Below we use the notation <span class="math">(A^{\\rho_{\\mathrm{int}}})^{\\rho_{\\mathrm{ext}}}</span> to distinguish between an "external" oracle <span class="math">\\rho_{\\mathrm{ext}}</span> that is exposed to the extractor and "internal" oracles <span class="math">\\rho_{\\mathrm{int}}</span> that are used only to run the adversary <span class="math">\\tilde{\\mathbf{P}}</span>.</p>

    <p class="text-gray-300">Define the following algorithm:</p>

    <div class="my-4 text-center"><span class="math-block">(A^{\\rho_{\\mathrm{HP}}, \\rho_{\\mathrm{NARK}}})^{\\rho_{\\mathrm{AS}}} \\left((\\mathsf{pp}, \\mathsf{pp}_{\\Phi}, \\mathsf{ai})\\right):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{i}_{\\Phi} = (A,B,C,\\mathsf{n}),[\\mathsf{acc}_j.\\mathbf{x}]_{j = 1}^n,[\\mathsf{qx}_i]_{i = 1}^n,\\mathsf{acc},\\mathsf{pf}) \\gets \\tilde{\\mathbf{P}}^\\rho (\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}).</span></li>

      <li>Compute <span class="math">\\tau \\coloneqq \\rho_{\\mathrm{NARK}}(A,B,C,\\mathsf{n})</span></li>

      <li>Set the query <span class="math">\\mathfrak{q} := (\\tau, [\\mathsf{acc}_j.\\mathbf{x}]_{j=1}^m, [\\mathsf{qx}_i]_{i=1}^n, C_x^\\star, C_A^\\star, C_B^\\star, C_C^\\star)</span>.</li>

      <li>Set the output <span class="math">\\mathsf{o} := (\\mathsf{i}_{\\Phi}, \\mathsf{acc}, \\mathsf{pf})</span>.</li>

      <li>Query the random oracle <span class="math">\\rho_{\\mathrm{AS}}</span> at <span class="math">\\mathfrak{q}</span>.</li>

      <li>Output <span class="math">(\\mathfrak{q},\\mathfrak{o})</span></li>

    </ol>

    <p class="text-gray-300">Define the forking lemma predicate:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{p}^{\\rho_{\\mathrm{HP}}, \\rho_{\\mathrm{NARK}}} \\left((\\mathsf{pp}, \\mathsf{pp}_{\\Phi}, \\mathsf{ai}), (\\mathfrak{q}, \\mathfrak{a}), \\mathsf{o}, \\mathsf{tr}\\right):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the query <span class="math">\\mathfrak{q}</span> as <span class="math">(\\tau, [\\mathsf{acc}_j.\\mathbf{x}]_{j=1}^m, [\\mathsf{qx}_i]_{i=1}^n, C_x^\\star, C_A^\\star, C_B^\\star, C_C^\\star)</span>.</li>

      <li>Parse the output <span class="math">\\mathsf{o}</span> as <span class="math">(\\mathrm{i}_{\\Phi}, \\mathrm{acc}, \\mathrm{pf})</span>.</li>

      <li>Check that <span class="math">\\tau = \\rho_{\\mathrm{NARK}}(\\mathrm{i}_{\\Phi})</span>.</li>

      <li>Compute <span class="math">(\\mathsf{apk}, \\mathsf{avk}, \\mathsf{dk}) := \\mathsf{I}^{\\rho_{\\mathrm{NARK}}}(\\mathsf{pp}, \\mathsf{pp}_{\\Phi}, \\mathrm{i}_{\\Phi})</span>.</li>

      <li>Check that <span class="math">\\mathrm{V}^{\\rho_{\\mathrm{HP}}, \\rho_{\\mathrm{NARK}}}(\\mathsf{avk}, [\\mathsf{qx}_i]_{i=1}^n, [\\mathsf{acc}_j.\\mathbf{x}]_{j=1}^m, \\mathsf{acc}.\\mathbf{x}, \\mathsf{pf})</span> outputs 1 when answering its query to <span class="math">\\rho_{\\mathrm{AS}}</span> with <span class="math">\\mathfrak{a}</span>.</li>

      <li>Check that <span class="math">\\mathrm{D}(\\mathrm{dk}, \\mathrm{acc})</span> outputs 1.</li>

    </ol>

    <p class="text-gray-300">Finally, define an adversary <span class="math">\\tilde{\\mathbf{P}}_{\\mathrm{HP}}</span> for the Hadamard product accumulation scheme <span class="math">\\mathsf{AS}_{\\mathsf{HP}}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">(\\tilde{\\mathrm{P}}_{\\mathrm{HP}}^{\\rho_{\\mathrm{AS}}, \\rho_{\\mathrm{NARK}}})^{\\rho_{\\mathrm{HP}}}(\\mathsf{pp}, \\mathsf{pp}_{\\Phi}, \\mathsf{ai}):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{i}_{\\Phi} = (A,B,C,\\mathsf{n}),[\\mathsf{qx}_i]_{i = 1}^n,[\\mathsf{acc}_j.\\mathbf{x}]_{j = 1}^m,\\mathsf{acc},\\mathsf{pf}) \\gets \\tilde{\\mathrm{P}}^\\rho (\\mathsf{pp} = \\mathsf{pp}_{\\mathsf{AS}_{\\mathsf{HP}}},\\mathsf{pp}_{\\Phi} = \\mathsf{pp}_{\\mathsf{HP}},\\mathsf{ai})</span>.</li>

      <li>Compute <span class="math">\\mathsf{qx}_{\\mathsf{HP},i}</span> from <span class="math">\\mathsf{qx}_i</span> for all <span class="math">i\\in [n]</span> as in Step 1b of the accumulation prover.</li>

      <li>Set the vector length to be <span class="math">\\ell \\coloneqq \\mathsf{M}</span>, the number of rows in each R1CS coefficient matrix.</li>

      <li>Output <span class="math">(\\ell, [\\mathsf{qx}_{\\mathsf{HP},i}]_{i=1}^n, [\\mathsf{acc}_j.\\mathbf{x}.\\mathsf{acc}_{\\mathsf{HP}}.\\mathbf{x}]_{j=1}^m)</span>.</li>

    </ol>

    <p class="text-gray-300">56</p>

    <p class="text-gray-300">For the remainder of the proof we implicitly consider only the case that  <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[\\mathsf{qx}_i]_{i = 1}^n,[\\mathsf{acc}_j.\\mathbf{x}]_{j = 1}^m,\\mathsf{acc}.\\mathbf{x},\\mathsf{pf}) = 1</span>  and  <span class="math">\\mathrm{D(dk,acc)} = 1</span>  for  <span class="math">(\\mathrm{i}_{\\Phi},[\\mathrm{qx}_i]_{i = 1}^n,[\\mathrm{acc}_j.\\mathbf{x}]_{j = 1}^m,\\mathrm{acc},\\mathrm{pf})\\gets \\tilde{\\mathrm{P}}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai})</span>  and (apk, avk, dk) := I(pp, pp, iΦ); otherwise, the implication holds vacuously. In this case the output of  <span class="math">A</span>  satisfies p with probability 1. Let Fork be the algorithm given by applying Lemma 6.1 to the forking lemma predicate p.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{E}^{\\tilde{\\mathrm{P}},\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai},r)</span>  for  <span class="math">\\rho = (\\rho_{\\mathrm{AS}},\\rho_{\\mathrm{HP}},\\rho_{\\mathrm{NARK}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">(\\mathfrak{q},\\mathfrak{o};\\mathfrak{tr})\\gets A^{\\rho}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai});r\\big).</span></li>

      <li>Parse the query  <span class="math">\\mathfrak{q}</span>  as  <span class="math">(\\tau, [\\mathrm{acc}_j.\\mathbf{x}]_{j=1}^m, [\\mathrm{qx}_i]_{i=1}^n, C_x^\\star, C_A^\\star, C_B^\\star, C_C^\\star)</span> .</li>

      <li>Parse the output o as a tuple  <span class="math">(\\mathrm{i}_{\\Phi},\\mathrm{acc},\\mathrm{pf})</span></li>

      <li>Run  <span class="math">\\mathrm{E}_{\\mathrm{HP}}^{(\\tilde{\\mathrm{P}}_{\\mathrm{HP}}^{\\rho_{\\mathrm{AS}},\\rho_{\\mathrm{NARK}}),\\rho_{\\mathrm{HP}}}}</span>  to extract predicate witnesses  <span class="math">[\\mathsf{qw}_{\\mathsf{HP},i}]_{i = 1}^{n}</span>  and accumulator witnesses  <span class="math">[\\mathsf{acc}_{\\mathsf{HP},j}.\\mathbf{w}]_{j = 1}^{m}</span> .</li>

      <li>Run  <span class="math">[\\beta_j, \\mathsf{o}_j]_{j=1}^{n+m+1} \\gets \\mathsf{Fork}^{(A^{\\rho_{\\mathrm{HP}},\\rho_{\\mathrm{NARK}}})}(\\mathsf{pp}, 1^{n+m+1}, (\\mathfrak{q}, \\rho(\\mathfrak{q})), \\mathsf{o}, \\mathsf{tr}_{\\mathfrak{q}}, r)</span> .</li>

      <li>For each  <span class="math">j \\in [n + m + 1]</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>parse the output  <span class="math">\\mathsf{o}_j</span>  as a tuple  <span class="math">(\\mathrm{i}_{\\Phi}^{(j)}, \\mathrm{acc}^{(j)}, \\mathrm{pf}^{(j)})</span> , and the accumulator  <span class="math">\\mathrm{acc}^{(j)}</span>  as  <span class="math">(\\mathrm{acc}.\\mathbf{x}^{(j)}, \\mathrm{acc}.\\mathbf{w}^{(j)})</span> ;</li>

      <li>parse the accumulator instance  <span class="math">\\mathsf{acc}.\\mathbf{x}^{(j)}</span>  as  <span class="math">(C_{x,\\star}^{(j)}, C_{A,\\star}^{(j)}, C_{B,\\star}^{(j)}, C_{C,\\star}^{(j)}, \\mathsf{acc}_{\\mathsf{HP},\\star}.\\mathbf{x}^{(j)})</span> ;</li>

      <li>parse the accumulator witness  <span class="math">\\mathsf{acc}.\\mathbf{w}^{(j)}</span>  as  <span class="math">(x_{\\star}^{(j)}, s_{\\star}^{(j)}, \\sigma_{A,\\star}^{(j)}, \\sigma_{B,\\star}^{(j)}, \\sigma_{C,\\star}^{(j)}, \\mathsf{acc}_{\\mathsf{HP},\\star}.\\mathbf{w}^{(j)})</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">M</span>  to be the Vandermonde matrix on  <span class="math">(1, \\beta, \\ldots, \\beta^{m + n})</span> .</li>

      <li>If  <span class="math">M</span>  is not invertible, abort. Otherwise compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c c c} x _ {1} &amp;amp; s _ {1} &amp;amp; \\sigma_ {A, 1} &amp;amp; \\sigma_ {B, 1} &amp;amp; \\sigma_ {C, 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\vdots \\\\ x _ {k} &amp;amp; s _ {k} &amp;amp; \\sigma_ {A, k} &amp;amp; \\sigma_ {B, k} &amp;amp; \\sigma_ {C, k} \\end{array} \\right) := M ^ {- 1} \\cdot \\left( \\begin{array}{c c c c c} x _ {\\star} ^ {(1)} &amp;amp; s _ {\\star} ^ {(1)} &amp;amp; \\sigma_ {A, \\star} ^ {(1)} &amp;amp; \\sigma_ {B, \\star} ^ {(1)} &amp;amp; \\sigma_ {C, \\star} ^ {(1)} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\vdots &amp;amp; \\vdots \\\\ x _ {\\star} ^ {(k)} &amp;amp; s _ {\\star} ^ {(k)} &amp;amp; \\sigma_ {A, \\star} ^ {(k)} &amp;amp; \\sigma_ {B, \\star} ^ {(k)} &amp;amp; \\sigma_ {C, \\star} ^ {(k)} \\end{array} \\right),</span></div>

    <p class="text-gray-300">where  <span class="math">k\\coloneqq n + m + 1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i\\in [n]</span>  , set  <span class="math">\\mathsf{qw}_i = (s_i,\\sigma_{A,i},\\sigma_{B,i},\\sigma_{C,i},\\mathsf{qw}_{\\mathsf{HP},i})</span></li>

      <li>For each  <span class="math">j\\in [m]</span> <span class="math">\\mathsf{acc}_j.\\mathbf{w} = (x_{n + j},s_{n + j},\\sigma_{A,n + j},\\sigma_{B,n + j},\\sigma_{C,n + j},\\mathsf{acc}_{\\mathsf{HP},j}.\\mathbf{w})</span></li>

      <li>Output  <span class="math">\\left(\\mathrm{i}_{\\Phi},\\mathrm{acc},[(\\mathrm{qx}_i,\\mathrm{qw}_i)]_{i = 1}^n,[(\\mathrm{acc}_j.\\mathbf{x},\\mathrm{acc}_j.\\mathbf{w})]_{j = 1}^m,\\mathrm{pf}\\right)</span></li>

    </ol>

    <p class="text-gray-300">By the properties of Fork guaranteed in Lemma 6.1, and the extraction guarantee of  <span class="math">\\mathsf{AS}_{\\mathsf{HP}}</span>  (Theorem 7.2),  <span class="math">\\mathrm{E}_{\\tilde{\\mathrm{P}}}</span>  runs in expected polynomial time and, except with probability  <span class="math">\\mathrm{negl}(\\lambda)</span> , the following event  <span class="math">E</span>  holds:</p>

    <p class="text-gray-300"><span class="math">[\\beta_j]_{j = 1}^{n + m + 1}</span>  are pairwise distinct</p>

    <p class="text-gray-300">and  <span class="math">\\forall j\\in [n + m + 1]</span> <span class="math">\\mathsf{p}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}),(\\mathfrak{q},\\beta_j),\\mathsf{o}_j,\\mathsf{tr}_{\\mathfrak{q}}\\big) = 1,</span></p>

    <p class="text-gray-300">and  <span class="math">\\forall i\\in [n]</span> <span class="math">\\Phi_{\\mathrm{HP}}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{qx}_{\\mathsf{HP},i},\\mathsf{qw}_{\\mathsf{HP},i}) = 1,</span></p>

    <p class="text-gray-300">and  <span class="math">\\forall j\\in [m]</span> <span class="math">\\mathrm{D}_{\\mathrm{HP}}\\big(\\mathrm{dk},(\\mathrm{acc}_{\\mathrm{HP},j}.\\mathbf{x},\\mathrm{acc}_{\\mathrm{HP},j}.\\mathbf{w})\\big) = 1.</span></p>

    <p class="text-gray-300">Moreover, since  <span class="math">\\rho_{\\mathrm{NARK}}(i_{\\Phi}^{(j)}) = \\tau</span>  for all  <span class="math">j</span> , with all but negligible probability (over the randomness of  <span class="math">\\rho_{\\mathrm{NARK}}</span> ),  <span class="math">i_{\\Phi}^{(1)} = \\dots = i_{\\Phi}^{(n + m + 1)}</span> . Hence we consider a single index  <span class="math">i_{\\Phi} = (A,B,C,n)</span>  for the remainder of the proof.</p>

    <p class="text-gray-300">We complete the proof of knowledge soundness by showing two claims. Claim 8.6 shows that the extracted assignments  <span class="math">s_i</span>  obey the correct linear relations with respect to the commitments output by  <span class="math">A</span> . Claim 8.7 then uses the binding property of the commitment scheme and the guarantee of the Hadamard product extractor to show that these assignments satisfy the R1CS equation and the decider as appropriate.</p>

    <p class="text-gray-300">Claim 8.6. Define the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ n ] \\qquad \\qquad s _ {A} ^ {(i)} := A \\left[ \\begin{array}{c} \\mathsf {q x} _ {i}. x \\\\ s _ {i} \\end{array} \\right] \\qquad \\qquad s _ {B} ^ {(i)} := B \\left[ \\begin{array}{c} \\mathsf {q x} _ {i}. x \\\\ s _ {i} \\end{array} \\right] \\qquad \\qquad s _ {C} ^ {(i)} := C \\left[ \\begin{array}{c} \\mathsf {q x} _ {i}. x \\\\ s _ {i} \\end{array} \\right]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in [ m ] \\qquad s _ {A} ^ {(n + j)} := A \\left[ \\begin{array}{c} x _ {n + j} \\\\ s _ {n + j} \\end{array} \\right] \\qquad s _ {B} ^ {(n + j)} := B \\left[ \\begin{array}{c} x _ {n + j} \\\\ s _ {n + j} \\end{array} \\right] \\qquad s _ {C} ^ {(n + j)} := C \\left[ \\begin{array}{c} x _ {n + j} \\\\ s _ {n + j} \\end{array} \\right]</span></div>

    <p class="text-gray-300">The event <span class="math">E</span> implies that with overwhelming probability:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ n ] \\quad \\mathbf {q x} _ {i}. C _ {A} + \\gamma_ {i} \\cdot \\mathbf {q x} _ {i}. C _ {A} ^ {\\prime} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {A} ^ {(i)}; \\sigma_ {A, i}) ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {q x} _ {i}. C _ {B} + \\gamma_ {i} \\cdot \\mathbf {q x} _ {i}. C _ {B} ^ {\\prime} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {B} ^ {(i)}; \\sigma_ {B, i}) ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {q x} _ {i}. C _ {C} + \\gamma_ {i} \\cdot \\mathbf {q x} _ {i}. C _ {C} ^ {\\prime} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {C} ^ {(i)}; \\sigma_ {C, i}) ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in [ m ] \\quad \\mathbf {a c c} _ {j}. \\mathbf {x}. C _ {x} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, x _ {n + j}; 0),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a c c} _ {j}. \\mathbf {x}. C _ {A} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {A} ^ {(n + j)}; \\sigma_ {A, n + j}) ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a c c} _ {j}. \\mathbf {x}. C _ {B} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {B} ^ {(n + j)}; \\sigma_ {B, n + j}) ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a c c} _ {j}. \\mathbf {x}. C _ {C} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {C} ^ {(n + j)}; \\sigma_ {C, n + j}) .</span></div>

    <p class="text-gray-300">Proof. We prove the statements for <span class="math">A</span>. The statements for <span class="math">B, C</span> follow similarly.</p>

    <p class="text-gray-300">Define the following <span class="math">(n + m + 1)</span>-entry vectors:</p>

    <div class="my-4 text-center"><span class="math-block">\\vec {C} _ {A} := \\left(\\mathbf {q x} _ {1}. C _ {A} + \\gamma_ {1} \\cdot \\mathbf {q x} _ {1}. C _ {A} ^ {\\prime}, \\dots , \\mathbf {q x} _ {n}. C _ {A} + \\gamma_ {n} \\cdot \\mathbf {q x} _ {n}. C _ {A} ^ {\\prime}, \\mathbf {a c c} _ {1}. \\mathbf {x}. C _ {A}, \\dots , \\mathbf {a c c} _ {m}. \\mathbf {x}. C _ {A}, C _ {A} ^ {\\star}\\right) ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vec {C} _ {A, \\star} := \\left(C _ {A, \\star} ^ {(1)}, \\dots , C _ {A, \\star} ^ {(n + m + 1)}\\right) .</span></div>

    <p class="text-gray-300">Recall that if <span class="math">\\mathfrak{p}</span> holds then both the accumulation verifier and decider accept. Since the accumulation verifier accepts, it holds that <span class="math">\\vec{C}_{A,\\star} = MC_A</span>. Moreover, since the decider accepts <span class="math">[(dk, acc^{(j)})]_{i=1}^{n+m+1}</span>, it holds for all <span class="math">j \\in [n+m+1]</span> that <span class="math">C_{A,\\star}^{(j)} = \\mathsf{CM}. \\text{Commit}(\\mathsf{ck}, A[x_{\\star}^{(j)} s_{\\star}^{(j)}]; \\sigma_{A,\\star}^{(j)})</span>. Using the homomorphic property of CM. Commit and that <span class="math">M^{-1}\\vec{C}_{A,\\star} = \\vec{C}_A</span>, we conclude that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ n ] \\mathbf {q x} _ {i}. C _ {A} + \\gamma_ {i} \\cdot \\mathbf {q x} _ {i}. C _ {A} ^ {\\prime} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, A \\left[ \\begin{array}{c} x _ {i} \\\\ s _ {i} \\end{array} \\right]; \\sigma_ {A, i}) = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {A} ^ {(i)}; \\sigma_ {A, i}) ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in [ m ] \\mathbf {a c c} _ {j}. \\mathbf {x}. C _ {A} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, A \\left[ \\begin{array}{c} x _ {n + j} \\\\ s _ {n + j} \\end{array} \\right]; \\sigma_ {A, n + j}) = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {A} ^ {(n + j)}; \\sigma_ {A, n + j}) .</span></div>

    <p class="text-gray-300">Finally, similarly to the above, since the accumulation verifier and decider accept, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ n ] \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {q x} _ {i}. x; 0) = \\mathbf {C M}. \\text {C o m m i t} (x _ {i}; 0),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in [ m ] \\mathbf {a c c} _ {j}. \\mathbf {x}. C _ {x} = \\mathbf {C M}. \\text {C o m m i t} (x _ {n + j}; 0) .</span></div>

    <p class="text-gray-300">Hence by the binding property of CM, <span class="math">x_{i} = \\mathbf{q}\\mathbf{x}_{i}.x</span> for all <span class="math">i\\in [n]</span> with all but negligible probability.</p>

    <p class="text-gray-300">Claim 8.7. The event <span class="math">E</span> implies that with overwhelming probability it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ n ] A \\left[ \\begin{array}{c} \\mathbf {q x} _ {i}. x \\\\ s _ {i} \\end{array} \\right] \\circ B \\left[ \\begin{array}{c} \\mathbf {q x} _ {i}. x \\\\ s _ {i} \\end{array} \\right] = C \\left[ \\begin{array}{c} \\mathbf {q x} _ {i}. x \\\\ s _ {i} \\end{array} \\right]  ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in [ m ] \\mathrm {D} \\left(\\mathrm {d k}, \\left(\\mathrm {a c c} _ {j}. \\mathrm {x}, \\mathrm {a c c} _ {j}. \\mathrm {w}\\right)\\right) = 1 .</span></div>

    <p class="text-gray-300">Proof. Fix <span class="math">i \\in [n]</span> and write <span class="math">\\mathbf{qw}_{\\mathrm{HP},i} = (a^{(i)}, b^{(i)}, \\omega_1^{(i)}, \\omega_2^{(i)}, \\omega_3^{(i)})</span>. The event <span class="math">E</span> implies that</p>

    <div class="my-4 text-center"><span class="math-block">C _ {1} = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, a ^ {(i)}; \\omega_ {1} ^ {(i)}) = \\mathbf {C M}. \\text {C o m m i t} (\\mathbf {c k}, s _ {A} ^ {(i)}, \\sigma_ {A, i}) ,</span></div>

    <p class="text-gray-300"><span class="math">C_{2}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},b^{(i)};\\omega_{2}^{(i)})=\\mathsf{CM.Commit}(\\mathsf{ck},s_{B}^{(i)};\\sigma_{B,i})\\enspace,</span> <span class="math">C_{3}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},a^{(i)}\\circ b^{(i)};\\omega_{3}^{(i)})=\\mathsf{CM.Commit}(\\mathsf{ck},s_{C}^{(i)};\\sigma_{C,i})\\enspace.</span></p>

    <p class="text-gray-300">If it is not the case that <span class="math">a^{(i)}=s_{A}^{(i)}</span>, <span class="math">b^{(i)}=s_{B}^{(i)}</span>, and <span class="math">a^{(i)}\\circ b^{(i)}=s_{C}^{(i)}</span>, then the extractor breaks the binding property of <span class="math">\\mathsf{CM}</span>, which can occur with only negligible probability. It follows that with all but negligible probability, <span class="math">s_{A}^{(i)}\\circ s_{B}^{(i)}=s_{C}^{(i)}</span>.</p>

    <p class="text-gray-300">The event <span class="math">E</span> also implies that <span class="math">\\mathrm{E}_{\\mathsf{HP}}</span> produces <span class="math">[\\mathsf{acc}_{\\mathsf{HP},j}.\\mathtt{w}]_{j=1}^{m}</span> such that <span class="math">\\mathrm{D}_{\\mathsf{HP}}\\big{(}\\mathsf{dk},(\\mathsf{acc}_{\\mathsf{HP},j}.\\mathtt{x},\\mathsf{acc}_{\\mathsf{HP},j}.\\mathtt{w})\\big{)}=1</span> for all <span class="math">j\\in[m]</span>. Together with Claim 8.6 this shows that for all <span class="math">j\\in[m]</span>, <span class="math">\\mathrm{D}\\big{(}\\mathsf{dk},(\\mathsf{acc}_{j}.\\mathtt{x},\\mathsf{acc}_{j}.\\mathtt{w})\\big{)}=1</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">9 Implementation</p>

    <p class="text-gray-300">We contribute a generic and modular implementation of proof-carrying data based on accumulation schemes. Our implementation includes several components of independent interest.</p>

    <h5 id="sec-71" class="text-base font-semibold mt-4">Framework for accumulation.</h5>

    <p class="text-gray-300">We design and implement a generic framework for accumulation schemes that supports arbitrary predicates/relations. The main interface is a Rust trait that defines the behavior of any (atomic or split) accumulation scheme. We implement this trait for several accumulation schemes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the atomic accumulation scheme <span class="math">\\mathsf{AS}_{\\text{AGM}}</span> in [BCMS20] for the PC scheme <span class="math">\\mathsf{PC}_{\\text{AGM}}</span>;</li>

      <li>the atomic accumulation scheme <span class="math">\\mathsf{AS}_{\\text{IPA}}</span> in [BCMS20] for the PC scheme <span class="math">\\mathsf{PC}_{\\text{IPA}}</span>;</li>

      <li>the split accumulation scheme <span class="math">\\mathsf{AS}_{\\text{PC}}</span> in Appendix A for the polynomial commitment predicate <span class="math">\\Phi_{\\text{PC}}</span> (corresponding to the check algorithm of the trivial PC scheme <span class="math">\\mathsf{PC}_{\\text{Ped}}</span>);</li>

      <li>the split accumulation scheme <span class="math">\\mathsf{AS}_{\\text{HP}}</span> in Section 7 for the Hadamard product predicate <span class="math">\\Phi_{\\text{HP}}</span>;</li>

      <li>the split accumulation scheme <span class="math">\\mathsf{AS}_{\\text{R1CS}}</span> for the zkNARK for R1CS in Section 8.</li>

    </ul>

    <p class="text-gray-300">Our framework also provides a generic trait for defining R1CS constraints for the verifier of an accumulation scheme. We use this trait to implement R1CS constraints for all of these accumulation schemes.</p>

    <h5 id="sec-72" class="text-base font-semibold mt-4">PCD from accumulation.</h5>

    <p class="text-gray-300">We provide a generic construction of PCD from accumulation, which simultaneously supports the case of atomic accumulation from [BCMS20] and the case of split accumulation from Section 5. Our code builds on and extends an existing PCD library that offers a generic “PCD” trait. We instantiate this PCD trait via a modular construction, which takes as ingredients any NARK (as defined by an appropriate trait), accumulation scheme for that NARK that implements the accumulation trait (from above), and constraints for the accumulation verifier. We use our concrete instantiations of these ingredients to achieve recursion based on accumulation for each of <span class="math">\\mathsf{PC}_{\\text{AGM}}</span>, <span class="math">\\mathsf{PC}_{\\text{IPA}}</span>, <span class="math">\\Phi_{\\text{PC}}</span>, and <span class="math">\\Phi_{\\text{HP}}</span>. In particular, we obtain a simple construction of PCD based on the zkNARK for R1CS and its split accumulation from Section 8.1.</p>

    <h5 id="sec-73" class="text-base font-semibold mt-4">Cycles of elliptic curves.</h5>

    <p class="text-gray-300">All PCD constructions in our implementation rely on the technique of cycles of elliptic curves [BCTV14]: PCD based on <span class="math">\\mathsf{PC}_{\\text{AGM}}</span> uses cycles of pairing-friendly curves, while PCD based on <span class="math">\\mathsf{PC}_{\\text{IPA}}</span>, <span class="math">\\Phi_{\\text{PC}}</span>, and <span class="math">\\Phi_{\\text{HP}}</span> uses cycles of standard curves. For all of these, we rely on existing implementations from the arkworks ecosystem: for pairing-friendly cycles we use the MNT cycle of curves (low security and high security variants), while for standard cycles we use the Pasta cycle of curves [Hop20].</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Remark 9.1.</h6>

    <p class="text-gray-300">Many of the aforementioned accumulation schemes compute linear combinations with respect to powers of a single challenge derived from the random oracle. In our implementation, when possible, we instead use linear combinations where the coefficients are multiple independent challenges obtained from the random oracle, because this leads to lower constraint costs for the accumulation verifier.</p>

    <p class="text-gray-300">This modification requires minor modifications in the security proofs. The knowledge extractor rewinds the prover several times to build a tree of accepting transcripts, and extraction succeeds if certain matrices constructed from the challenges of these transcripts are invertible. When using powers of challenges each matrix is a Vandermonde matrix, which is invertible precisely when the challenges are distinct, and this occurs with all but negligible probability. Similarly, when using independent challenges, each matrix consists of rows of random independent challenges, and such a matrix is invertible with all but negligible probability.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 6: Diagram illustrating components in our implementation. The gray boxes denote components that exist in prior libraries; the orange boxes denote our implementation of components from [BCMS20]; and the yellow boxes denote our implementation of components contributed in this work.</p>

    <p class="text-gray-300">We perform an evaluation focused on the discrete logarithm setting. In Section 10.1 we describe the concrete costs of our zkNARK for R1CS and its split accumulation scheme; and in Section 10.2 we compare the costs of atomic versus split accumulation for PC schemes based on Pedersen commitments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Figure 7 we report the asymptotic cost of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (the constraint cost of  </span>\\mathrm{V}<span class="math"> ) in  </span>\\mathsf{AS}_{\\mathsf{IPA}}<span class="math"> ,  </span>\\mathsf{AS}_{\\mathsf{PC}}<span class="math"> , and  </span>\\mathsf{AS}_{\\mathsf{R1CS}}$ . Note that because these accumulation schemes share many common subcomponents (scalar multiplication, random oracle calls, non-native field arithmetic), any improvements would preserve the relative cost.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Experimental setup. All experiments are performed using a single thread on a machine with an Intel Xeon 6136 CPU at  <span class="math">3.0\\mathrm{GHz}</span> . The reported numbers are for schemes instantiated over the 255-bit prime-order Pallas curve in the Pasta cycle [Hop20]; results for the Vesta curve in that cycle would be similar.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 7: Comparison of the constraint cost of the accumulation verifier V in  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span> ,  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span> , and  <span class="math">\\mathsf{AS}_{\\mathsf{R1CS}}</span>  when varying the number of constraints (for  <span class="math">\\mathsf{AS}_{\\mathsf{R1CS}}</span> ) or the degree of the accumulated polynomial (for  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span> ) from  <span class="math">2^{10}</span>  to  <span class="math">2^{20}</span> . Note that the cost of accumulating  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{PC}_{\\mathsf{Pad}}</span>  is a lower bound on the cost of accumulating any SNARK built atop those, and this enables comparing against the cost of  <span class="math">\\mathsf{AS}_{\\mathsf{R1CS}}</span> .</p>

    <p class="text-gray-300">In Tables 2 and 3, we compare the costs of our accumulation scheme for our zkNARK for R1CS for an illustrative number of constraints, with and without zero knowledge. We include the metric of lines of code (LoC) to highlight the simplicity of our constructions. We focus on the special case where the accumulation scheme is used to accumulate one new proof into one old accumulator to obtain a new accumulator (this corresponds to the case of IVC). We find that the cost in both cases is modest, and the overhead of zero knowledge is less than a factor of 2 in the number of constraints. Furthermore, the measured cost matches</p>

    <p class="text-gray-300">the expected asymptotic cost. In more detail, while the prover time and decider time are both linear in the number of constraints, the verifier cost (both wall-clock time and constraint cost) does not grow with the number of constraints. This latter point is illustrated in Fig. 7.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zk?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LoC</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9 s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9 s</td>

            <td class="px-3 py-2 border-b border-gray-700">4.19 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">618</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">6.9 s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9 s</td>

            <td class="px-3 py-2 border-b border-gray-700">4.19 MB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Cost of proving and verifying a constraint system containing  <span class="math">{2}^{17}</span>  constraints.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zk?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">acc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LoC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">native</td>

            <td class="px-3 py-2 border-b border-gray-700">constraints</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">2 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">6.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">392 B</td>

            <td class="px-3 py-2 border-b border-gray-700">8.4 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">52×103</td>

            <td class="px-3 py-2 border-b border-gray-700">1258</td>

            <td class="px-3 py-2 border-b border-gray-700">1120</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">8.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">3 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">6.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">392 B</td>

            <td class="px-3 py-2 border-b border-gray-700">8.4 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">99×103</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We compare the costs of two accumulation schemes for two PC schemes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the atomic accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  in [BCMS20] for the PC scheme  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span> ;</li>

      <li>the split accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  in Appendix A for the predicate  <span class="math">\\Phi_{\\mathsf{PC}}</span>  corresponding to  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span> .</li>

    </ul>

    <p class="text-gray-300">In Section 10.2.1 we compare the two polynomial commitment schemes  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span> , and in Section 10.2.2 we compare the two corresponding accumulation schemes  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span> .</p>

    <p class="text-gray-300">We compare the performance of  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span>  in Table 4, reporting experiments for an illustrative choice of polynomial degree  <span class="math">d</span> . In both PC schemes all operations (commit, open, check) are linear in the degree  <span class="math">d</span> , though for  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span>  opening is concretely much cheaper than  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span>  (primarily because  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span>  has a trivial opening procedure). The main difference between the two PC schemes is that an evaluation proof in  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span>  is  <span class="math">O(d)</span>  field elements while an evaluation proof in  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span>  is  <span class="math">O(\\log d)</span>  group elements; this asymptotic difference is apparent in the reported numbers (the proof size for  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span>  is significantly larger than for  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span> ). We also report lines of code to realize the same abstract PC scheme trait, to support the (intuitive) claim that  <span class="math">\\mathsf{PC}_{\\mathsf{Ped}}</span>  is a much simpler primitive than  <span class="math">\\mathsf{PC}_{\\mathsf{IPA}}</span> .</p>

    <p class="text-gray-300">Table 3: Cost of accumulating a NARK proof and an old accumulator, for a constraint system of size  <span class="math">{2}^{17}</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PC scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Open</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Check</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LoC</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PCIPA</td>

            <td class="px-3 py-2 border-b border-gray-700">8.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">106.6 s</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2 s</td>

            <td class="px-3 py-2 border-b border-gray-700">33 B</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4 kB O(log d) G</td>

            <td class="px-3 py-2 border-b border-gray-700">1120</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PCPed</td>

            <td class="px-3 py-2 border-b border-gray-700">8.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.43 s</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">33 B</td>

            <td class="px-3 py-2 border-b border-gray-700">33.5 MB O(d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">608</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Comparison between the PC schemes  <span class="math">{\\mathrm{{PC}}}_{\\mathrm{{IPA}}}</span>  and  <span class="math">{\\mathrm{{PC}}}_{\\mathrm{{Ped}}}</span>  for polynomials of degree  <span class="math">d = {2}^{20}</span>  .</p>

    <p class="text-gray-300">We compare the performance of  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  in Table 5, reporting experiments for an illustrative choice of polynomial degree  <span class="math">d</span> . We focus on the special case where the accumulation scheme is used to accumulate one</p>

    <p class="text-gray-300">new polynomial evaluation claim into one old accumulator to obtain a new accumulator. Our experiments indicate that  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  is cheaper than  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  across all metrics except for accumulator size, and more generally that performance is consistent with the asymptotic comparison from Table 1. In more detail:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>While prover time (per claim) in both  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  are linear in the degree  <span class="math">d</span> , our experiments show that  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  is concretely much more expensive than  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span> .</li>

      <li>Decider time in both  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  are linear in the degree  <span class="math">d</span> , and our experiments show that the two schemes have similar concrete performance.</li>

      <li>Verifier time (per claim) in  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  is logarithmic while in  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  it is constant, and our experiments confirm that  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  is concretely significantly more expensive than  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span> .</li>

      <li>Verifier constraint cost is much higher for  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span> , even though both schemes use the same underlying constraint gadget libraries.</li>

      <li>The size of an atomic accumulator for  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  is logarithmic, and amounts to a few kilobytes; in contrast an accumulator for  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  is much larger, but is split into a short instance part (106 bytes) and a long witness part (33.5 megabytes).</li>

    </ul>

    <p class="text-gray-300">Overall the expensive parts of  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  are exactly where intended (a large accumulation witness part) in exchange for a very cheap verifier and a very short accumulation instance part; all other metrics are comparable to (and concretely better than for)  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">acc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LoC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">native</td>

            <td class="px-3 py-2 border-b border-gray-700">constraints</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ASIPA</td>

            <td class="px-3 py-2 border-b border-gray-700">117.6 s</td>

            <td class="px-3 py-2 border-b border-gray-700">14 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.58 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">435×103</td>

            <td class="px-3 py-2 border-b border-gray-700">664</td>

            <td class="px-3 py-2 border-b border-gray-700">1232</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ASPC</td>

            <td class="px-3 py-2 border-b border-gray-700">25.2 s</td>

            <td class="px-3 py-2 border-b border-gray-700">2 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">8.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">106 B</td>

            <td class="px-3 py-2 border-b border-gray-700">33.5 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">30×103</td>

            <td class="px-3 py-2 border-b border-gray-700">571</td>

            <td class="px-3 py-2 border-b border-gray-700">395</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Comparison between the accumulation schemes  <span class="math">\\mathsf{AS}_{\\mathsf{IPA}}</span>  and  <span class="math">\\mathsf{AS}_{\\mathsf{PC}}</span>  for polynomials of degree  <span class="math">d = 2^{20}</span> , when accumulating one old accumulator and one evaluation claim into a new accumulator.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Figure 7, we also compare  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (the constraint cost of  </span>\\mathrm{V}<span class="math"> ) in both  </span>\\mathsf{AS}_{\\mathsf{PC}}<span class="math">  and  </span>\\mathsf{AS}_{\\mathsf{IPA}}<span class="math">  as we accumulate polynomial evaluation claims of degree  </span>d<span class="math">  in the range  </span>2^{10}<span class="math">  to  </span>2^{20}<span class="math"> . As expected, the cost for  </span>\\mathsf{AS}_{\\mathsf{PC}}<span class="math">  is a small constant, whereas the cost of  </span>\\mathsf{AS}_{\\mathsf{IPA}}$  grows logarithmically (and is concretely much larger).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A Split accumulation for Pedersen polynomial commitments</p>

    <p class="text-gray-300">We construct a split accumulation scheme for Pedersen commitments to polynomials. We define the predicate we accumulate and then state our theorem. The remainder of the section is dedicated to proving the theorem.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Definition A.1.</h6>

    <p class="text-gray-300">The (Pedersen) polynomial commitment predicate <span class="math">\\Phi_{\\textsc{pc}}</span> takes as input: (i) public parameters <span class="math">\\mathsf{pp}_{\\Phi}=\\mathsf{pp}_{\\mathsf{CM}}</span> for the Pedersen commitment scheme (for messages of some maximum length <span class="math">D+1</span>); (ii) an index <span class="math">\\mathsf{i}_{\\Phi}=d</span> specifying a supported degree (at most <span class="math">D</span>); (iii) an instance <span class="math">\\mathsf{qx}=(C,z,v)\\in\\mathbb{G}\\times\\mathbb{F}\\times\\mathbb{F}</span> consisting of a commitment to a polynomial, a point at which it is evaluated, and the evaluation; (iv) a witness <span class="math">\\mathsf{qw}=p\\in\\mathbb{F}^{\\leq d}[X]</span> consisting of the committed polynomial. The predicate <span class="math">\\Phi_{\\textsc{pc}}</span> computes the Pedersen commitment key <span class="math">\\mathsf{ck}:=\\mathsf{CM}</span>.<span class="math">\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{CM}},d+1)</span> for messages of length <span class="math">d+1</span>, and checks that <span class="math">C=\\mathsf{CM}</span>.<span class="math">\\mathsf{Commit}(\\mathsf{ck},p)</span>, <span class="math">p(z)=v</span>, and <span class="math">\\deg(p)\\leq d</span>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Theorem A.2.</h6>

    <p class="text-gray-300">The scheme <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> constructed in Appendix A.1 is a split accumulation scheme in the random oracle model (assuming the hardness of the discrete logarithm problem) for the polynomial commitment predicate <span class="math">\\Phi_{\\textsc{pc}}</span> in Definition A.1. <span class="math">\\mathsf{AS}</span> achieves the efficiency stated below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: <span class="math">\\mathrm{G}(1^{\\lambda})</span> runs in time <span class="math">O(\\lambda)</span>.</li>

      <li>Indexer: The time of <span class="math">\\mathrm{I}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{i}_{\\Phi}=d)</span> is dominated by the time to run <span class="math">\\mathsf{CM}</span>.<span class="math">\\mathsf{Trim}</span> for messages of length <span class="math">d+1</span>.</li>

      <li>Accumulation prover: The time of <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[(\\mathsf{qx}_{i},\\mathsf{qw}_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m})</span> is dominated by the time to commit to <span class="math">n+m</span> polynomials of degree <span class="math">d</span> (i.e, <span class="math">n+m</span> multi-scalar multiplications of size <span class="math">d+1</span>).</li>

      <li>Accumulation verifier: The time of <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{n},[\\mathsf{acc}_{j}.\\mathtt{x}]_{j=1}^{m},\\mathsf{acc}.\\mathtt{x},\\mathsf{pf})</span> is dominated by <span class="math">O(n+m)</span> field additions/multiplications and <span class="math">O(n+m)</span> group scalar multiplications.</li>

      <li>Decider: The time of <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})</span> is dominated by the time to commit to a polynomial of degree at most <span class="math">d</span>.</li>

      <li>Sizes: An accumulator <span class="math">\\mathsf{acc}</span> consists of (a) an accumulator instance <span class="math">\\mathsf{acc}.\\mathtt{x}</span> consisting of a commitment and two field elements, and (b) an accumulator witness <span class="math">\\mathsf{acc}.\\mathtt{w}</span> consisting of a polynomial of degree less than <span class="math">d</span>. An accumulation proof <span class="math">\\mathsf{pf}</span> consists of <span class="math">n</span> commitments and <span class="math">2n+2m</span> field elements.</li>

    </ul>

    <p class="text-gray-300">Recall from Section 2.6 that the predicate <span class="math">\\Phi_{\\textsc{pc}}</span> can be seen as equivalent to checking an evaluation claim in the trivial polynomial commitment (PC) scheme <span class="math">\\mathsf{PC}_{\\textsc{pnd}}</span>: the evaluation proof is simply the original polynomial. This PC scheme is a drop-in replacement for PC schemes used in existing SNARKs <em>[x11, x10]</em>, and facilitates accumulation of the verifier for the resulting SNARKs.</p>

    <h3 id="sec-82" class="text-xl font-semibold mt-8">A.1 Construction</h3>

    <p class="text-gray-300">We describe the accumulation scheme <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> for the Pedersen polynomial commitment predicate <span class="math">\\Phi_{\\textsc{pc}}</span>. Predicate instances <span class="math">\\mathsf{qx}</span> have the form <span class="math">(C,z,v)</span>, and predicate witnesses <span class="math">\\mathsf{qw}</span> consist of a polynomial <span class="math">p</span> (allegedly, committed inside <span class="math">C</span> and such that <span class="math">p(z)=v</span> and <span class="math">\\deg(p)&lt;d</span>). An accumulator <span class="math">\\mathsf{acc}</span> is split in two parts that are analogous to predicate instances and predicate witnesses. Jumping ahead, the decider <span class="math">\\mathrm{D}</span> is equal to the predicate <span class="math">\\Phi_{\\textsc{pc}}</span>; therefore, there is no distinction between inputs and prior accumulators, and so it suffices to accumulate inputs only.</p>

    <p class="text-gray-300">Generator. The generator <span class="math">\\mathrm{G}</span> receives as input <span class="math">\\mathsf{pp}:=1^{\\lambda}</span> and outputs <span class="math">1^{\\lambda}</span>. (In other words, <span class="math">\\mathrm{G}</span> does not have to create additional public parameters beyond those used by <span class="math">\\Phi_{\\textsc{pc}}</span>.)</p>

    <p class="text-gray-300">Indexer. On input the accumulator parameters <span class="math">\\mathsf{pp}</span>, predicate parameters <span class="math">\\mathsf{pp}_{\\Phi}=\\mathsf{pp}_{\\mathsf{PC}}</span>, and a predicate index <span class="math">\\mathsf{i}_{\\Phi}=d</span>, the indexer <span class="math">\\mathrm{I}</span> computes the commitment key <span class="math">\\mathsf{ck}:=\\mathsf{CM}</span>.<span class="math">\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{PC}},d+1)</span>, and then outputs the accumulator proving key <span class="math">\\mathsf{apk}:=\\mathsf{ck}</span>, the accumulator verification key <span class="math">\\mathsf{avk}:=d</span>, and the decision key <span class="math">\\mathsf{dk}:=\\mathsf{ck}</span>.</p>

    <p class="text-gray-300">Accumulation prover. On input the accumulation proving key apk and predicate instance-witness pairs  <span class="math">[(qx_i, qw_i)]_{i=1}^n</span>  (of the same form as split accumulators  <span class="math">[acc_j]_{j=1}^m = [(acc_j.x, acc_j.w)]_{j=1}^m</span> ), P works as below.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk} = \\mathsf{ck},[(\\mathsf{qx}_i,\\mathsf{qw}_i)]_{i = 1}^n)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i</span>  in  <span class="math">[n]</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Parse the predicate instance  <span class="math">\\mathsf{qx}_i</span>  as an evaluation claim  <span class="math">(C_i, z_i, v_i) \\in \\mathbb{G} \\times \\mathbb{F} \\times \\mathbb{F}</span> . (b) Parse the predicate witness  <span class="math">\\mathsf{qw}_i</span>  as a polynomial  <span class="math">p_i(X) \\in \\mathbb{F}^{\\leq \\mathsf{ck}.d}[X]</span> . (c) Compute the witness polynomial  <span class="math">w_{i}(X)\\coloneqq \\frac{p_{i}(X) - v_{i}}{X - z_{i}}\\in \\mathbb{F}[X]</span> . (d) Compute a commitment to  <span class="math">w_{i}(X)\\colon W_{i}\\coloneqq \\mathsf{CM. Commit}(\\mathsf{ck},w_{i})\\in \\mathbb{G}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the random oracle to compute the evaluation point  <span class="math">z_{\\star} \\coloneqq \\rho(d, [(C_i, z_i, v_i, W_i)]_{i=1}^n) \\in \\mathbb{F}</span> .</li>

      <li>For each  <span class="math">i</span>  in  <span class="math">[n]</span> , compute the evaluations  <span class="math">y_{i} \\coloneqq p_{i}(z_{\\star}) \\in \\mathbb{F}</span>  and  <span class="math">y_{i}&#x27; \\coloneqq w_{i}(z_{\\star}) \\in \\mathbb{F}</span> .</li>

      <li>Use the random oracle to compute the challenge  <span class="math">\\alpha \\coloneqq \\rho (z_{\\star},[(y_i,y_i&#x27;)]_{i = 1}^n)\\in \\mathbb{F}</span></li>

      <li>Compute the linear combination  <span class="math">p_{\\star}(X)\\coloneqq \\sum_{i = 1}^{n}\\alpha^{i - 1}\\cdot p_i(X) + \\sum_{i = 1}^{n}\\alpha^{n + i - 1}\\cdot w_i(X)\\in \\mathbb{F}[X].</span></li>

      <li>Compute the evaluation  <span class="math">v_{\\star} \\coloneqq p_{\\star}(z_{\\star}) \\in \\mathbb{F}</span> .</li>

      <li>Compute the linear combination  <span class="math">C_{\\star} \\coloneqq \\sum_{i=1}^{n} \\alpha^{i-1} \\cdot C_i + \\sum_{i=1}^{n} \\alpha^{n+i-1} \\cdot W_i \\in \\mathbb{G}</span> .</li>

      <li>Set the split accumulator acc := (acc.x, acc.w) where acc.x :=  <span class="math">(C_{\\star}, z_{\\star}, v_{\\star})</span>  and acc.w :=  <span class="math">p_{\\star}</span> .</li>

      <li>Set the accumulation proof pf :=  <span class="math">[(W_i, y_i, y_i&#x27;)]_{i=1}^n</span> .</li>

      <li>Output (acc, pf).</li>

    </ol>

    <p class="text-gray-300">Accumulation verifier. On input the accumulator verification key avk, predicate instances  <span class="math">[qx_i]_{i=1}^n</span>  (of the same form as accumulator instances  <span class="math">[acc_j.x]_{j=1}^m</span> ), a new accumulator instance acc.x, and an accumulation proof pf, V works as below.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk} = d, [\\mathsf{qx}_i]_{i=1}^n, \\mathsf{acc.x}, \\mathsf{pf})</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i\\in [n]</span>  , parse  <span class="math">\\mathsf{qx}_i</span>  as  <span class="math">(C_i,z_i,v_i)</span></li>

      <li>Parse acc.x as  <span class="math">(C_{\\star},z_{\\star},v_{\\star})</span>  , and pf as  <span class="math">[(W_i,y_i,y_i&#x27;)]_{i = 1}^n</span></li>

      <li>Check that  <span class="math">z_{\\star} = \\rho (d,[(C_i,z_i,v_i,W_i)]_{i = 1}^n)</span></li>

      <li>For each  <span class="math">i\\in [n]</span>  , check that  <span class="math">y_{i} - v_{i} = y_{i}^{\\prime}\\cdot (z_{\\star} - z_{i})</span></li>

      <li>Compute  <span class="math">\\alpha \\coloneqq \\rho (z_{\\star},[(y_i,y_i&#x27;)]_{i = 1}^n)</span></li>

      <li>Check that  <span class="math">v_{\\star} = \\sum_{i=1}^{n} \\alpha^{i-1} \\cdot y_i + \\sum_{i=i}^{n} \\alpha^{n+i-1} \\cdot y_i&#x27;</span> .</li>

      <li>Check that  <span class="math">C_{\\star} = \\sum_{i=1}^{n} \\alpha^{i-1} \\cdot C_i + \\sum_{i=1}^{n} \\alpha^{n+i-1} \\cdot W_i</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decider. On input the decision key  <span class="math">\\mathrm{dk} = \\mathrm{ck}</span>  and an accumulator acc, D parses acc.x as  <span class="math">(C,z,v)</span> , parses acc.w as  <span class="math">p</span> , and checks  <span class="math">C = \\mathsf{CM. Commit}(\\mathsf{ck},p)</span> ,  <span class="math">p(z) = v</span> , and  $\\deg (p) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ck}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following lemma, due to [BCMS20], bounds the probability that applying the random oracle to a binding commitment to a polynomial yields a zero of that polynomial. We refer to this as a zero-finding game. Here we have adapted the lemma to expected-time adversaries; the proof is essentially unchanged.</p>

    <p class="text-gray-300">The statement of the lemma involves the definition of a binding commitment scheme, given below. Even if in this paper we focus on accumulation schemes based on Pedersen commitments, in the security proofs we need to invoke the lemma on binding commitment schemes that are related, but not equal, to Pedersen commitments. Hence we require this technical lemma with respect to a general binding commitment scheme.</p>

    <p class="text-gray-300">Lemma A.3 ([BCMS20]). Let  <span class="math">\\mathsf{CM} = (\\mathsf{Setup}, \\mathsf{Trim}, \\mathsf{Commit})</span>  be a binding commitment scheme and  <span class="math">L</span>  a message format for CM. Let  <span class="math">F \\colon \\mathbb{N} \\to \\mathbb{N}</span>  be a field size function,  <span class="math">N \\in \\mathbb{N}</span>  a number of variables, and  <span class="math">D \\in \\mathbb{N}</span>  a total degree bound. For every family of (possibly inefficient) functions  <span class="math">\\{f_{\\mathsf{pp}} \\colon \\mathcal{M}_{\\mathsf{pp}} \\to \\mathbb{F}_{\\mathsf{pp}}^{\\leq D}[X_1, \\ldots, X_N]\\}_{\\mathsf{pp}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mapping messages to polynomials of degree at most  <span class="math">D</span>  over fields of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{\\mathsf{pp}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq F(\\lambda)<span class="math">  and every  </span>t<span class="math"> -query oracle algorithm  </span>\\mathcal{A}$  that runs in expected polynomial time, the following holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathfrak {p} \\in \\mathcal {M} _ {\\mathsf {c k}} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {C M . S e t u p} (1 ^ {\\lambda}, L) \\\\ \\wedge \\boldsymbol {z} \\in \\mathbb {F} _ {\\mathsf {p p}} ^ {N} &amp;amp; (\\ell , \\mathfrak {p}, \\omega) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ \\wedge p \\not \\equiv 0 &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {C M . T r i m} (\\mathsf {p p}, \\ell) \\\\ \\wedge p (\\boldsymbol {z}) = 0 &amp;amp; C \\leftarrow \\mathsf {C M . C o m m i t} (\\mathsf {c k}, \\mathfrak {p}; \\omega) \\\\ &amp;amp; \\boldsymbol {z} \\leftarrow \\rho (C) \\\\ &amp;amp; p \\leftarrow f _ {\\mathsf {p p}} (\\mathfrak {p}) \\end{array} \\right] \\leq \\sqrt {\\frac {(t + 1) \\cdot D}{F (\\lambda)}} + \\operatorname {n e g l} (\\lambda) .</span></div>

    <p class="text-gray-300">Remark A.4. For Lemma A.3 to hold, the algorithms of CM must not have access to the random oracle  <span class="math">\\rho</span>  used to generate the challenge point  <span class="math">z</span> . The lemma is otherwise black-box with respect to CM, and so CM itself may use other oracles. The lemma continues to hold when  <span class="math">\\mathcal{A}</span>  has access to these additional oracles. We use this fact later to justify the security of domain separation.</p>

    <p class="text-gray-300">We prove that the accumulation scheme constructed in the previous section satisfies the claimed efficiency properties and achieves completeness, and then, in Appendix A.3.1, that it achieves knowledge soundness.</p>

    <p class="text-gray-300">Efficiency. We now analyze the efficiency of our accumulation scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator:  <span class="math">\\mathrm{G}(1^{\\lambda})</span>  outputs  <span class="math">1^{\\lambda}</span> , and hence runs in time  <span class="math">O(\\lambda)</span> .</li>

      <li>Indexer:  <span class="math">\\mathrm{I}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathrm{i}_{\\Phi})</span>  invokes CM.Trim, and hence runs in time  <span class="math">O_{\\lambda}(d)</span> .</li>

      <li>Accumulation prover:  <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[(\\mathsf{qx}_i,\\mathsf{qw}_i)]_{i = 1}^n)</span>  computes a commitment to the degree  <span class="math">\\deg (p_i) - 1</span>  witness polynomial  <span class="math">w_{i}</span>  for each input  <span class="math">\\mathsf{qx}_i = (C_i,z_i,v_i)</span> . The time to generate these  <span class="math">n</span>  commitments dominates the running time of  <span class="math">\\mathrm{P}</span> .</li>

      <li>Accumulation verifier:  <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[\\mathsf{qx}_i]_{i = 1}^n,\\mathsf{acc.}\\underline{x},\\mathsf{pf})</span>  computes a random linear combination between  <span class="math">2n</span>  commitments, and hence its running time is as claimed.</li>

      <li>Decider:  <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc})</span>  invokes CM.Commit and checks that the output matches the accumulator.</li>

      <li>Sizes: The accumulator instance acc.  <span class="math">\\underline{x}</span>  consists of a polynomial commitment  <span class="math">C</span> , an evaluation point  <span class="math">z</span>  and an evaluation claim  <span class="math">v</span> . The accumulator witness acc.  <span class="math">\\mathbf{w}</span>  is a polynomial of degree  <span class="math">d</span> . The accumulation proof pf contains  <span class="math">O(n)</span>  group and field elements.</li>

    </ul>

    <p class="text-gray-300">Completeness. Since we need only accumulate predicate inputs (as accumulators are split like predicate inputs and the decider equals the predicate being accumulated), it suffices to demonstrate that the simplified completeness property from Section 4.1 holds. Fix an (unbounded) adversary  <span class="math">\\mathcal{A}</span> . For each  <span class="math">i\\in [n]</span> , since</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi_ {P C} \\left(\\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}, \\mathsf {q x} _ {i} = \\left(C _ {i}, z _ {i}, v _ {i}\\right), \\mathsf {q w} _ {i} = p _ {i}\\right) = 1,</span></div>

    <p class="text-gray-300">we know that  <span class="math">C_i = \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck},p_i)</span>  and  <span class="math">p_i(z_i) = v_i</span> ; this implies that each witness polynomial  <span class="math">w_{i}(X) = \\frac{p_{i}(X) - v_{i}}{X - z_{i}}</span>  is indeed a polynomial of degree  <span class="math">d - 1</span> .</p>

    <p class="text-gray-300">Together with the fact that the accumulation prover  <span class="math">\\mathrm{P}</span>  behaves honestly, the foregoing facts imply that  <span class="math">C</span>  is a well-formed commitment to  <span class="math">p_{\\star} = \\sum_{i=1}^{n} \\alpha^i p_i + \\sum_{i=1}^{n} \\alpha^{n+i} w_i</span> , and that  <span class="math">p_{\\star}(z_{\\star}) = v_{\\star}</span> , as required.</p>

    <p class="text-gray-300">We need only accumulate predicate inputs (as accumulators are split like predicate inputs and the decider equals the predicate being accumulated), so it suffices to demonstrate that the simplified knowledge soundness property from Section 4.1 holds. We describe an extractor and then analyze why it satisfies the property.</p>

    <p class="text-gray-300">Define the following algorithm:</p>

    <p class="text-gray-300"><span class="math">A^{\\rho}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{i}_{\\Phi} = d, [\\mathrm{qx}_i]_{i=1}^n, \\mathrm{acc}, \\mathrm{pf}) \\gets \\tilde{\\mathrm{P}}^\\rho(\\mathrm{pp}, \\mathrm{pp}_{\\Phi}, \\mathrm{ai})</span> .</li>

      <li>Parse, for each  <span class="math">i\\in [n]</span> <span class="math">\\mathbf{q}\\mathbf{x}_i</span>  as  <span class="math">(C_i,z_i,v_i)</span></li>

      <li>Parse acc as  <span class="math">(C,z,v;p)</span> , and pf as  <span class="math">[(W_i,y_i,y_i&#x27;)]_{i = 1}^n</span></li>

      <li>Set  <span class="math">\\mathfrak{q} \\coloneqq (z, [y_i, y_i&#x27;]_{i=1}^n)</span> .</li>

      <li>Set  <span class="math">\\mathsf{o} \\coloneqq (\\mathrm{i}_{\\Phi}, [\\mathrm{qx}_i]_{i=1}^n, \\mathrm{acc}, \\mathrm{pf})</span> .</li>

      <li>Query  <span class="math">\\rho</span>  at the points  <span class="math">(d,[(C_i,z_i,v_i,W_i)]_{i = 1}^n)</span>  and  <span class="math">\\mathfrak{q}</span> , if not already queried by  <span class="math">\\tilde{\\mathrm{P}}</span> .</li>

      <li>Output  <span class="math">(\\mathfrak{q},\\mathfrak{o})</span></li>

    </ol>

    <p class="text-gray-300">Define the forking lemma predicate:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{p}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}),(\\mathfrak{q},\\mathfrak{a}),\\mathsf{o},\\mathsf{tr}\\big)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that tr contains no collisions.</li>

      <li>Parse the query  <span class="math">\\mathfrak{q}</span>  as  <span class="math">(z,[(y_i,y_i&#x27;)]_{i = 1}^n)</span> , and the output o as  <span class="math">(\\mathrm{i}_{\\Phi} = d,[\\mathrm{qx}_i]_{i = 1}^n,\\mathrm{acc},\\mathrm{pf})</span></li>

      <li>Compute  <span class="math">(\\mathsf{apk},\\mathsf{avk},\\mathsf{dk})\\coloneqq \\mathrm{I}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},d)</span></li>

      <li>Check that  <span class="math">\\mathrm{V}(\\mathrm{avk}, [\\mathrm{qx}_i]_{i=1}^n, \\mathrm{acc}.\\mathbb{x}, \\mathrm{pf})</span>  outputs 1 when answering its first query according to tr and its second query with  <span class="math">\\mathfrak{a}</span> . (If the first query is outside of the support of tr then output 0.)</li>

      <li>Check that  <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc})</span>  outputs 1.</li>

    </ol>

    <p class="text-gray-300">For the remainder of the proof we implicitly consider only the case that  <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[\\mathsf{qx}_i]_{i = 1}^n,\\mathsf{acc}.\\mathbb{x},\\mathsf{pf}) = 1</span>  and  <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc}) = 1</span>  for  <span class="math">(\\mathrm{i}_{\\Phi},[\\mathsf{qx}_i]_{i = 1}^n,\\mathsf{acc},\\mathsf{pf})\\gets \\tilde{\\mathrm{P}}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai})</span>  and  <span class="math">(\\mathsf{apk},\\mathsf{avk},\\mathsf{dk}):= \\mathrm{I}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},d)</span> ; otherwise, the implication holds vacuously. The probability that  <span class="math">\\mathrm{V}</span>  accepts when its first query is outside of the support of  <span class="math">\\mathsf{tr}_{\\mathfrak{q}}</span> , or that  <span class="math">\\mathsf{tr}</span>  contains a collision, is  <span class="math">O(t^{2} / 2^{\\lambda})</span> , and so the output of  <span class="math">A</span>  fails to satisfy  <span class="math">\\mathfrak{p}</span>  with probability at most  <span class="math">\\mathrm{negl}(\\lambda)</span> . Let Fork be the algorithm given by applying Lemma 6.1 to the forking lemma predicate  <span class="math">\\mathfrak{p}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathrm{E}^{\\tilde{\\mathrm{P}},\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai},r)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">(\\mathfrak{q},\\mathfrak{o};\\mathfrak{tr})\\gets A^{\\rho}\\big((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai});r\\big)</span>  ; parse o as  <span class="math">(\\mathrm{i}_{\\Phi} = d,[\\mathrm{qx}_i]_{i = 1}^n,\\mathrm{acc},\\mathrm{pf})</span></li>

      <li>Run  <span class="math">(\\alpha_{1},\\mathsf{o}_{1},\\ldots ,\\alpha_{2n},\\mathsf{o}_{2n})\\gets \\mathsf{Fork}^{A}((\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}),1^{2n},(\\mathfrak{q},\\rho (\\mathfrak{q})),\\mathsf{o},\\mathsf{tr}_{\\mathfrak{q}},r).</span></li>

      <li>For  <span class="math">j \\in [2n]</span> :</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>parse  <span class="math">\\mathsf{o}_j</span>  as  <span class="math">(\\mathrm{i}_{\\Phi}^{(j)} = d, [\\mathrm{qx}_i^{(j)}]_{i=1}^n, \\mathrm{pf}^{(j)}, \\mathrm{acc}^{(j)})</span> ;</li>

      <li>parse  <span class="math">\\mathsf{acc}^{(j)}</span>  as  <span class="math">\\mathsf{acc}^{(j)}.\\mathbb{x} = (C_{\\star}^{(j)},z_{\\star}^{(j)},v_{\\star}^{(j)})\\in \\mathbb{G}\\times \\mathbb{F}\\times \\mathbb{F}</span>  and  <span class="math">\\mathsf{acc}^{(j)}.\\mathsf{w} = p_{\\star}^{(j)}\\in \\mathbb{F}^{\\leq d}[X]</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\vec{p}_{\\star} := \\begin{pmatrix} p_{\\star}^{(1)} \\\\ \\vdots \\\\ p_{\\star}^{(2n)} \\end{pmatrix}</span> , and set  <span class="math">M</span>  to be the Vandermonde matrix on  <span class="math">(\\alpha_1, \\ldots, \\alpha_{2n})</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. If  <span class="math">M</span>  is invertible, compute  $(\\vec{p} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}) \\coloneqq M^{-1} \\cdot \\vec{p}_{\\star}$ ; otherwise, abort.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\left(\\mathrm{i}_{\\Phi},[(\\mathrm{qx}_i,p_i)]_{i = 1}^n,\\mathrm{acc},\\mathrm{pf}\\right)</span></li>

    </ol>

    <p class="text-gray-300">By the properties of Fork guaranteed in Lemma 6.1,  <span class="math">\\mathrm{E}_{\\tilde{\\mathrm{P}}}</span>  runs in expected polynomial time and, moreover, except with probability  <span class="math">\\mathrm{negl}(\\lambda)</span>  the following event  <span class="math">E</span>  holds:</p>

    <p class="text-gray-300"><span class="math">\\{\\alpha_{j}\\}_{j\\in[2n]}</span> are pairwise distinct and <span class="math">\\forall j\\in[2n]</span> <span class="math">\\mathsf{p}\\big{(}(\\mathsf{pp},\\mathsf{pp}_{\\Phi},\\mathsf{ai}),(\\mathsf{q},\\alpha_{j}),\\mathsf{o}_{j},\\mathsf{tr}_{\\mathsf{q}}\\big{)}=1</span>.</p>

    <p class="text-gray-300">Conditioned on <span class="math">E</span>, we observe the following. First, since the <span class="math">\\alpha_{j}</span> are distinct, <span class="math">M</span> is invertible. Next, let <span class="math">(z_{\\star},[(y_{i},y_{i}^{\\prime})]_{i=1}^{n}):=\\mathsf{q}</span>; note that <span class="math">z_{\\star}^{(j)}=z_{\\star}</span> and <span class="math">(d^{(j)},[\\mathsf{qx}_{i}^{(j)},W_{i}^{(j)}]_{i=1}^{n})=\\mathsf{tr}_{\\mathsf{q}}^{-1}(z_{\\star})=(d,[\\mathsf{qx}_{i},W_{i}]_{i=1}^{n})</span> for all <span class="math">j</span>, whence also <span class="math">\\mathsf{pf}^{(j)}=\\mathsf{pf}</span> for all <span class="math">j</span>. The function <span class="math">\\mathsf{tr}_{\\mathsf{q}}^{-1}</span> is well-defined only because <span class="math">\\mathsf{p}</span> requires that <span class="math">\\mathsf{tr}_{\\mathsf{q}}</span> contains no collisions. For the remainder of the proof we therefore omit the superscripts on <span class="math">d,z_{\\star},\\mathsf{qx}_{i}=(C_{i},z_{i},v_{i})</span>, and <span class="math">\\mathsf{pf}=[(W_{i},y_{i},y_{i}^{\\prime})]_{i=1}^{n}</span>.</p>

    <p class="text-gray-300">We conclude the proof with two claims. In Claim A.5 we argue that the extracted polynomials <span class="math">\\vec{p},\\vec{w}</span> are openings of the corresponding commitments, and that their evaluations at <span class="math">z_{\\star}</span> are as claimed. In Claim A.6 we argue that the evaluations of the polynomials <span class="math">\\{p_{i}\\}_{i\\in[n]}</span> on the original query points <span class="math">\\{z_{i}\\}_{i\\in[n]}</span> are as claimed. Together these claims establish that, with all but negligible probability, for all <span class="math">i\\in[n]</span> it holds that <span class="math">\\Phi_{\\mathsf{PC}}(\\mathsf{pp}_{\\mathsf{CM}},d,(C_{i},z_{i},v_{i}),p_{i})=1</span>, which completes the proof of knowledge soundness.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Claim A.5.</h6>

    <p class="text-gray-300">The event <span class="math">E</span> implies that for each <span class="math">i\\in[n]</span>:</p>

    <p class="text-gray-300"><span class="math">C_{i}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},p_{i})\\;,</span> <span class="math">\\deg(p_{i})</span> <span class="math">\\leq d\\;,</span> <span class="math">p_{i}(z_{\\star})</span> <span class="math">=y_{i}\\;,</span> <span class="math">W_{i}</span> <span class="math">=\\mathsf{CM.Commit}(\\mathsf{ck},w_{i})\\;,</span> <span class="math">\\deg(w_{i})</span> <span class="math">\\leq d\\;,</span> <span class="math">w_{i}(z_{\\star})</span> <span class="math">=y_{i}^{\\prime}\\;.</span></p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Define the following vectors:</p>

    <p class="text-gray-300"><span class="math">\\vec{C}</span> <span class="math">:=(C_{1},\\ldots,C_{n})\\;,</span> <span class="math">\\vec{W}</span> <span class="math">:=(W_{1},\\ldots,W_{n})\\;,</span> <span class="math">\\vec{C}_{\\star}</span> <span class="math">:=(C_{\\star}^{(1)},\\ldots,C_{\\star}^{(2n)})\\;,</span> <span class="math">\\vec{y}</span> <span class="math">:=(y_{1},\\ldots,y_{n})\\;,</span> <span class="math">\\vec{y^{\\prime}}</span> <span class="math">:=(y_{1}^{\\prime},\\ldots,y_{n}^{\\prime})\\;,</span> <span class="math">\\vec{v}_{\\star}</span> <span class="math">:=(v_{\\star}^{(1)},\\ldots,v_{\\star}^{(2n)})\\;.</span></p>

    <p class="text-gray-300">Above, for each <span class="math">j\\in[2n]</span>, <span class="math">C_{\\star}^{j}</span> and <span class="math">v_{\\star}^{(j)}</span> are the commitment and claimed evaluation in <span class="math">\\mathsf{acc}^{(j)}</span>.<span class="math">\\mathbf{\\Xi}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the definition of the forking lemma predicate <span class="math">\\mathsf{p}</span>, the accumulation verifier <span class="math">\\mathrm{V}</span> accepts <span class="math">(\\mathsf{avk},[\\mathsf{qx}_{i}]_{i=1}^{n},\\mathsf{acc}^{(j)}.\\mathbf{\\Xi},\\mathsf{pf})</span> for all <span class="math">j\\in[2n]</span>. By the polynomial evaluation check in Step 6 of <span class="math">\\mathrm{V}</span> we obtain that $\\vec{v}=M\\cdot(\\vec{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{y^{\\prime}})<span class="math">, and by the commitment check in Step 7 we obtain that </span>\\vec{C}_{\\star}=M\\cdot(\\vec{C}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{W})<span class="math">. Moreover, since the decider accepts </span>(\\mathsf{avk},\\mathsf{acc}^{(j)})<span class="math"> for all </span>j\\in[2n]<span class="math">, it holds for all </span>j$ that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">C_{\\star}^{(j)}=\\mathsf{CM.Commit}(\\mathsf{ck},p_{\\star}^{(j)})\\;,\\;p_{\\star}^{(j)}(z_{\\star})=v_{\\star}^{(j)}\\;,\\;\\deg(p_{\\star}^{(j)})\\leq d\\;\\;.</span></p>

    <p class="text-gray-300">From this the degree bounds on <span class="math">p_{i},w_{i}</span> follow by linearity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $(\\vec{C}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{W})=M^{-1}\\cdot\\vec{C}_{\\star}<span class="math">, and by the homomorphic property of </span>\\mathsf{PC}_{\\mathsf{Ped}}<span class="math">, for each </span>i\\in[n]$ we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">C_{i}=\\sum_{j}M_{i,j}^{-1}C_{\\star}^{(j)}=\\mathsf{PC}_{\\mathsf{Ped}}.\\mathsf{Commit}(\\mathsf{ck},\\sum_{j}M_{i,j}^{-1}p_{\\star}^{(j)})=\\mathsf{PC}_{\\mathsf{Ped}}.\\mathsf{Commit}(\\mathsf{ck},p_{i})\\;\\;.</span></p>

    <p class="text-gray-300">Similarly, <span class="math">W_{i}=\\mathsf{PC}_{\\mathsf{Ped}}.\\mathsf{Commit}(\\mathsf{ck},w_{i})</span> for each <span class="math">i\\in[n]</span>.</p>

    <p class="text-gray-300">In addition, since <span class="math">(\\vec{y},\\vec{y^{\\prime}})=M^{-1}\\cdot\\vec{v}</span>, and <span class="math">p_{\\star}^{(j)}(z_{\\star})=v_{\\star}^{(j)}</span>, we have that <span class="math">p_{i}(z_{\\star})=\\sum_{j}M_{i,j}^{-1}v_{\\star}^{(j)}=y_{i}</span>, and <span class="math">w_{i}(z_{\\star})=\\sum_{j}M_{n+i,j}^{-1}v_{\\star}^{(j)}=y_{i}^{\\prime}</span>. ∎</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Claim A.6.</h6>

    <p class="text-gray-300">With probability at least <span class="math">1-\\mathrm{negl}(\\lambda)</span>, it holds that <span class="math">E</span> implies <span class="math">p_{i}(z_{i})=v_{i}</span> for all <span class="math">i\\in[n]</span>.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider a modification to <span class="math">\\mathrm{E}_{\\hat{\\mathrm{p}}}</span> that also outputs <span class="math">\\vec{w}</span>. By Claim A.5, if <span class="math">E</span> occurs then for each <span class="math">i\\in[n]</span> the tuple <span class="math">(C_{i},z_{i},v_{i},W_{i})</span> is a binding commitment to the polynomial <span class="math">p_{i}(X)-v_{i}-w_{i}(X)\\cdot(X-z_{i})</span> of degree at most <span class="math">d+1</span>, and further it holds that <span class="math">p_{i}(z_{i})=y_{i}</span> and <span class="math">w_{i}(z_{i})=y_{i}^{\\prime}</span>. Since the verifier accepts the output of <span class="math">\\mathrm{E}_{\\hat{\\mathrm{p}}}</span>, we have that <span class="math">z_{\\star}=\\mathsf{tr}(d,[(C_{i},z_{i},v_{i},W_{i})]_{i=1}^{n})=\\rho(d,[(C_{i},z_{i},v_{i},W_{i})]_{i=1}^{n})</span>, and that <span class="math">\\forall\\,i\\in[n]\\;y_{i}-v_{i}=y_{i}^{\\prime}\\cdot(z_{\\star}-z_{i})</span>. By Lemma A.3, except with probability <span class="math">\\mathrm{negl}(\\lambda)</span>, <span class="math">p_{i}(X)-v_{i}-w_{i}(X)\\cdot(X-z_{i})</span> is the zero polynomial, and so <span class="math">p_{i}(z_{i})=v_{i}</span>. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">This research was supported in part by the Ethereum Foundation, NSF, DARPA, a grant from ONR, and the Simons Foundation. Nicholas Spooner was supported by DARPA under Agreement No. HR00112020023.</p>

    <h2 id="sec-90" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBBPWM18] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 315–334.</li>

      <li>[BCCGP16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BCCT13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. “Recursive Composition and Bootstrapping for SNARKs and Proof-Carrying Data”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 111–120.</li>

      <li>[BCMS20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. “Proof-Carrying Data from Accumulation Schemes”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC ’20. 2020.</li>

      <li>[BCS16] E. Ben-Sasson, A. Chiesa, and N. Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: Proceedings of the 34th Annual International Cryptology Conference. CRYPTO ’14. 2014, pp. 276–294.</li>

      <li>[BDFG20] D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Halo Infinite: Recursive zk-SNARKs from any Additive Polynomial Commitment Scheme. Cryptology ePrint Archive, Report 2020/1536. 2020.</li>

      <li>[BGH19] S. Bowe, J. Grigg, and D. Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. 2019.</li>

      <li>[BMMTV19] B. Bünz, M. Maller, P. Mishra, N. Tyagi, and P. Vesely. Proofs for Inner Pairing Products and Applications. Cryptology ePrint Archive, Report 2019/1177. 2019.</li>

      <li>[BMRS20] J. Bonneau, I. Meckler, V. Rao, and E. Shapiro. Coda: Decentralized Cryptocurrency at Scale. Cryptology ePrint Archive, Report 2020/352. 2020.</li>

      <li>[BN06] M. Bellare and G. Neven. “Multi-signatures in the plain public-Key model and a general forking lemma”. In: Proceedings of the 13th ACM Conference on Computer and Communications Security. CCS ’06. 2006, pp. 390–399.</li>

      <li>[BR93] M. Bellare and P. Rogaway. “Random Oracles Are Practical: A Paradigm for Designing Efficient Protocols”. In: Proceedings of the 1st ACM Conference on Computer and Communications Security. CCS ’93. 1993, pp. 62–73.</li>

      <li>[CCDW20] W. Chen, A. Chiesa, E. Dauterman, and N. P. Ward. Reducing Participation Costs via Incremental Verification for Ledger Systems. Cryptology ePrint Archive, Report 2020/1522. 2020.</li>

      <li>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 738–768.</li>

      <li>[COS20] A. Chiesa, D. Ojha, and N. Spooner. “Fractal: Post-Quantum and Transparent Recursive Proofs from Holography”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 769–793.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[CT10] A. Chiesa and E. Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: Proceedings of the 1st Symposium on Innovations in Computer Science. ICS ’10. 2010, pp. 310–331.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CTV13] S. Chong, E. Tromer, and J. A. Vaughan. Enforcing Language Semantics Using Proof-Carrying Data. Cryptology ePrint Archive, Report 2013/513. 2013.</li>

      <li>[CTV15] A. Chiesa, E. Tromer, and M. Virza. “Cluster Computing in Zero Knowledge”. In: Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’15. 2015, pp. 371–403.</li>

      <li>[Gro16] J. Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[GT20] A. Ghoshal and S. Tessaro. Tight State-Restoration Soundness in the Algebraic Group Model. Cryptology ePrint Archive, Report 2020/1351. 2020.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive, Report 2019/953. 2019.</li>

      <li>[Halo20] S. Bowe, J. Grigg, and D. Hopwood. Halo2. 2020. URL: https://github.com/zcash/halo2.</li>

      <li>[Hop20] D. Hopwood. The Pasta Curves for Halo 2 and Beyond. https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/. 2020.</li>

      <li>[KB20] A. Kattis and J. Bonneau. Proof of Necessary Work: Succinct State Verification with Fairness Guarantees. Cryptology ePrint Archive, Report 2020/190. 2020.</li>

      <li>[Lin03] Y. Lindell. “Parallel Coin-Tossing and Constant-Round Secure Two-Party Computation”. In: Journal of Cryptology 16.3 (2003), pp. 143–184.</li>

      <li>[Mina] O(1) Labs. Mina Cryptocurrency. https://minaprotocol.com/. 2017.</li>

      <li>[NT16] A. Naveh and E. Tromer. “PhotoProof: Cryptographic Image Authentication for Any Set of Permissible Transformations”. In: Proceedings of the 37th IEEE Symposium on Security and Privacy. S&P ’16. 2016, pp. 255–271.</li>

      <li>[Pas03] R. Pass. “On Deniability in the Common Reference String and Random Oracle Model”. In: Proceedings of the 23rd Annual International Cryptology Conference. CRYPTO ’03. 2003, pp. 316–337.</li>

      <li>[Pickles20] O(1) Labs. Pickles. URL: https://github.com/o1-labs/marlin.</li>

      <li>[Val08] P. Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: Proceedings of the 5th Theory of Cryptography Conference. TCC ’08. 2008, pp. 1–18.</li>

      <li>[WTSTW18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. “Doubly-Efficient zkSNARKs Without Trusted Setup”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 926–943.</li>

    </ul>`;
---

<BaseLayout title="Proof-Carrying Data without Succinct Arguments (2020/1618)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1618
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
