---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/241';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'The combinatorics of the longest-chain rule: Linear consistency for proof-of-stake blockchains';
const AUTHORS_HTML = 'Erica Blum&lt;sup&gt;1&lt;/sup&gt; , Aggelos Kiayias2,5, Cristopher Moore&lt;sup&gt;3&lt;/sup&gt; , Saad Quader&lt;sup&gt;4&lt;/sup&gt; , and Alexander Russell4,5';

const CONTENT = `    <p class="text-gray-300">Erica Blum&lt;sup&gt;1&lt;/sup&gt; , Aggelos Kiayias2,5, Cristopher Moore&lt;sup&gt;3&lt;/sup&gt; , Saad Quader&lt;sup&gt;4&lt;/sup&gt; , and Alexander Russell4,5</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">University of Maryland, College Park University of Edinburgh Santa Fe Institute University of Connecticut 5 IOHK</p>

    </blockquote>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">November 22, 2019</p>

    </blockquote>

    </blockquote>

    <h4 id="sec-1" class="text-lg font-semibold mt-6"><strong>Abstract</strong></h4>

    <p class="text-gray-300">Blockchain data structures maintained via the longest-chain rule have emerged as a powerful algorithmic tool for consensus algorithms. The techniqueâ€”popularized by the Bitcoin protocolâ€”has proven to be remarkably exible and now supports consensus algorithms in a wide variety of settings. Despite such broad applicability and adoption, current analytic understanding of the technique is highly dependent on details of the protocol's leader election scheme. A particular challenge appears in the proof-of-stake setting, where existing analyses suer from quadratic dependence on sux length.</p>

    <p class="text-gray-300">We describe an axiomatic theory of blockchain dynamics that permits rigorous reasoning about the longestchain rule in quite general circumstances and establish boundsâ€”optimal to within a constantâ€”on the probability of a consistency violation. This settles a critical open question in the proof-of-stake setting where we achieve linear consistency for the rst time.</p>

    <p class="text-gray-300">Operationally, blockchain consensus protocols achieve consistency by instructing parties to remove a sux of a certain length from their local blockchain. While the analysis of Bitcoin guarantees consistency with error 2 âˆ’ğ‘˜ by removing ğ‘‚(ğ‘˜) blocks, recent work on proof-of-stake (PoS) blockchains has suered from quadratic dependence: (PoS) blockchain protocols, exemplied by Ouroboros (Crypto 2017), Ouroboros Praos (Eurocrypt 2018) and Sleepy Consensus (Asiacrypt 2017), can only establish that the length of this sux should be Î˜(ğ‘˜ ). This consistency guarantee is a fundamental design parameter for these systems, as the length of the sux is a lower bound for the time required to wait for transactions to settle. Whether this gap is an intrinsic limitation of PoSâ€”due to issues such as the &quot;nothing-at-stake&quot; problemâ€”has been an urgent open question, as deployed PoS blockchains further rely on consistency for protocol correctness: in particular, security of the protocol itself relies on this parameter. Our general theory directly improves the required sux length from Î˜(ğ‘˜ ) to Î˜(ğ‘˜). Thus we show, for the rst time, how PoS protocols can match proof-of-work blockchain protocols for exponentially decreasing consistency error.</p>

    <p class="text-gray-300">Our analysis focuses on the articulation of a two-dimensional stochastic process that captures the features of interest, an exact recursive closed form for the critical functional of the process, and tail bounds established for associated generating functions that dominate the failure events. Finally, the analysis provides an explicit polynomial-time algorithm for exactly computing the exponentially-decaying error function which can directly inform practice.</p>

    <p class="text-gray-300">Erica Blum's work was partly supported by nancial assistance award 70NANB19H126 from U.S. Department of Commerce, National Institute of Standards and Technology. Aggelos Kiayias' research was partly supported by H2020 Grant #780477, PRIViLEDGE. Cristopher Moore's research was partly supported by NSF grant BIGDATA-1838251. Alexander Russell's work was partly supported by NSF Grant #1717432.</p>

    <h2 id="sec-2" class="text-2xl font-bold"><strong>1 Introduction</strong></h2>

    <p class="text-gray-300">A blockchain is a data structure consisting of a collection of data blocks placed in linear order. It further requires that each block contains a collision-free hash of the previous block: thus blocks implicitly commit to the entire prex of the blockchain preceding them. This elementary data structure has remarkable applications in distributed computing, and now appears as an essential component of consensus protocols in a wide variety of models and settings; this notably includes both the &quot;permissionless&quot; setting popularized by Bitcoin and the classic &quot;permissioned&quot; model.</p>

    <p class="text-gray-300">Such consensus protocols call for players to collaboratively assemble a blockchain by repeatedly selecting players to add blocks. Specically, the protocol determines a stochastic process resembling a lottery: each &quot;leader&quot; selected by the lottery is then responsible for broadcasting a new block. While the algorithmic details of this lottery depend heavily on the protocol, the outcome can be privately determined and provides the winning player a proof of leadership that can be publicly demonstrated. Assuming that the expected wait time for some player to win the lottery is constant, the blockchain experiences steady growth when players follow the protocol.</p>

    <p class="text-gray-300">Network infelicities, adversarial behavior, or the possibility that two players simultaneously win the lottery can lead to disagreements among the players about the current blockchain. Thus protocols adopt a &quot;chain selection rule&quot; that determines how players should break ties among the various chains they observe on the network; ideally, the combination of the chain selection rule and the lottery should guarantee that the players' blockchains agree, perhaps with the exception of a short sux. The emblematic chain selection strategy among such systems is the <em>longest-chain rule</em>, which calls for players to adopt the longest chain among various contenders.</p>

    <p class="text-gray-300">The rst blockchain protocol was the core of the sensational Bitcoin system <a href="#page-32-0">[18]</a>; it adopted a lottery mechanism based on a cryptographic puzzle <a href="#page-32-1">[7,</a> <a href="#page-31-0">1]</a>â€”also known as <em>proof-of-work or PoW, for short</em>â€”and a chain selection rule favoring chains that represent more work. The system is particularly notable for its ability to survive in a permissionless settingâ€”where players may freely join and departâ€”even when a portion of the players are actively attacking the protocol. Unfortunately, the proof-of-work mechanism makes quite striking energy demands: the system currently consumes as much electricity as a small country.<a href="#page-1-0">1</a> This motivated the blockchain community to exploring alternative lottery mechanisms, e.g., proof-of-stake (PoS) <a href="#page-31-1">[3,</a> <a href="#page-33-0">21,</a> <a href="#page-32-2">13]</a>, proof of space <a href="#page-32-3">[8,</a> <a href="#page-32-4">20]</a> and others <a href="#page-32-5">[16]</a>. The proof-of-stake mechanism is particularly attractive from the perspective of eciency, as it makes no assumption of external computational resources.</p>

    <p class="text-gray-300">The fundamental consistency propertyâ€”critical in all these blockchain systemsâ€”is <em>common-prex</em> (cf. <a href="#page-32-6">[9]</a>). It precisely captures the intuition described above: by trimming a ğ‘˜-block sux from the chain held by any honest player the resulting blockchain is a prex of the blockchain possessed by any honest party at any future point of the execution. A principal goal in the analysis of these systems is a to guarantee common prex, for an appropriate value of ğ‘˜, even if some of the players collude to disrupt the protocol. Common prex is typically only shown to hold with high probability 1 âˆ’ ğœ€, where ğœ€ is an error term that is a function of ğ‘˜. The exact dependency of ğœ€ on ğ‘˜ is critically important: it determines the length of the sux that is to be removed from a blockchain in order to ensure that the remaining prex will be retained at any future point of the execution. This directly imposes a lower bound on how long one has to wait for information in the blockchain (such as a payment transaction) to &quot;settle.&quot; Additionally, many blockchain protocols internally rely on common prex for correctness; thus the relationship between ğœ€ and ğ‘˜ is critical to establishing the regime of correctness of the entire protocol.</p>

    <p class="text-gray-300">A relatively straightforward lower bound for ğœ€ is ğœ€ â‰¥ exp(âˆ’ğ›¼ğ‘˜) for some ğ›¼ &gt; 0. This lower bound applies when there is a coalition of adversarial players of constant fraction, the case of primary interest in practice. The result is easy to infer from the analysis of <a href="#page-32-0">[18]</a>, where a strategy is demonstrated that violates common prex with such probability (this is referred to as a &quot;double-spending&quot; attack in that paper). The tightness of this bound is an important open problem. For the special case of proof-of-work an upper bound of exp(âˆ’Î©(ğ‘˜)) was shown rst in <a href="#page-32-6">[9]</a> and further veried in extended security models by <a href="#page-32-7">[11,</a> <a href="#page-33-1">24]</a>. In the proof-of-stake setting, on the other hand, the tightness of the bound remains open. While recent proof-of-stake algorithms have been presented with rigorous analyses that rival proof-of-work in many regards, they suer from a quadratic relationship between ğ‘˜ and log(ğœ€). For example, the Ouroboros protocols <a href="#page-32-2">[13,</a> <a href="#page-32-8">6,</a> <a href="#page-31-2">2]</a>, as well as Snow White <a href="#page-31-3">[4]</a>, provide an upper bound</p>

    <p class="text-gray-300">&lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt;See e.g., <a href="https://digiconomist.net/bitcoin-energy-consumption">https://digiconomist.net/bitcoin-energy-consumption</a> where it is reported that Bitcoin annual energy consumption is on the order of at least 50 Twhr at the time of writing.</p>

    <p class="text-gray-300">on &lt;sup&gt;ğœ€&lt;/sup&gt; of exp(âˆ’Î©(&lt;sup&gt;âˆš&lt;/sup&gt; ğ‘˜)); this should be compared with ğœ€ = exp(âˆ’Î˜(ğ‘˜)) for proof-of-work. The signicant gap from the known lower bound was attributed to a notable, general attack that distinguished PoS from PoW: Known as the <em>nothing-at-stake</em> problem, this refers to the ability of an adversarial coalition of players to strategically reuse a winning PoS lottery to extend multiple blockchains.</p>

    <p class="text-gray-300"><strong>Our results.</strong> Our objective is to control the common-prex error ğœ€ as tightly as possible while making minimal assumptions on the underlying blockchain protocol. We work in a general model formulated by a simple family of <em>blockchain axioms</em>. The axioms themselves are easy to interpret and few in number. This permits us to abstract many features of the underlying blockchain protocol (e.g., the details of the leader-election process, the cryptographic security of the relevant signature schemes and hash functions, and randomness generation), while still establishing results that are strong enough to directly incorporate into existing specic analyses.</p>

    <p class="text-gray-300">Our most interesting nding is a quite tight theory of common prex that depends <em>only on the schedule of participants certied to add a block</em>. Under common assumptions about this schedule, we achieve the optimal relationship ğœ€ = exp(âˆ’Î˜(ğ‘˜)). This directly improves the common prex guarantees (and settlement times) of existing proof-of-stake blockchains such as Snow White <a href="#page-31-3">[4]</a>, Ouroboros <a href="#page-32-2">[13]</a>, Ouroboros Praos <a href="#page-32-8">[6]</a>, and Ouroboros Genesis <a href="#page-31-2">[2]</a>. Specically, this improves the scaling in the exponent from &lt;sup&gt;âˆš&lt;/sup&gt; ğ‘˜ to ğ‘˜ and establishes a tight characterization for ğœ€ = exp(âˆ’Î˜(ğ‘˜)). (In fact, we even obtain reasonable control of the constants.) We remark that our assumptions about the schedule distribution can be weakenedâ€”without any eect on the nal boundsâ€”to apply to martingale-style distributions such as those that arise in the analysis of adaptive adversaries <a href="#page-32-8">[6,</a> <a href="#page-31-2">2]</a>.</p>

    <p class="text-gray-300">Our new analysis oers an additional, but lower order, improvement for several of these blockchains. The existing analysis of, e.g., Ouroboros Praos <a href="#page-32-8">[6]</a>, required a union bound to be taken over the entire lifetime of the protocol in order to rule out a common prex violation at a particular point of time; thus such events were actually bounded above by a function of the form &lt;sup&gt;ğ‘‡&lt;/sup&gt; exp(âˆ’Î©(&lt;sup&gt;âˆš&lt;/sup&gt; ğ‘˜)), where ğ‘‡ is the lifetime of the protocol. While this event <em>does</em> depend on the entire dynamics of the protocol, we show how to avoid this pessimistic tail bound to achieve a &quot;single shot&quot; common prex violationâ€”at a particular time of interestâ€”of form exp(âˆ’Î˜(ğ‘˜)); this removes the dependence on ğ‘‡.</p>

    <p class="text-gray-300">From a technical perspective, we contrast the structure of our proofs with existing techniques for the PoW case. The PoW results nd a direct connection between common-prex and the behavior of a biased, one-dimensional random walk. Interestingly, our results give a tight relationship between the general (e.g., PoS) case and a pair of <em>coupled</em> biased random walks. A major challenge in the analysis is to bound the behavior of this richer stochastic process. Our tools yield precise, explicit upper bounds on the probability of persistence violations that can be directly applied to tune the parameters of deployed PoS systems. See Appendix <a href="#page-33-2">A</a> where we record some concrete results of the general theory. The importance of these results in the practice of PoS blockchain systems cannot be overstated: they provide, for the rst time, concrete error bounds for settlement times for PoS blockchains that follow the longest chain rule.</p>

    <p class="text-gray-300"><strong>Further analytic details.</strong> Our approach begins with the graph-theoretic framework of <em>forks</em> and <em>margin</em> developed for the analysis of the Ouroboros <a href="#page-32-2">[13]</a> protocol. (A fork is an abstraction of the protocol execution given the outcomes of the leader-election process.) We begin by generalizing the notion of margin to account for local, rather than global, features of a leader schedule, and provide an exact, recursive closed form for this new quantity (see Section <a href="#page-17-0">5)</a>. This proof identies an optimal online adversary (i.e., a fork-building strategy whose current decisions do not depend on the future) for PoS blockchain algorithms with the remarkable property that the sequence of forks produced by this adversary <em>simultaneously</em> achieve the worst-case (slot) common-prex violations associated with all slots (see Section <a href="#page-28-0">8)</a>. We then study the stochastic process generated when the <em>characteristic string</em>â€”a Boolean string representing the outcome of the leader election schemeâ€”is given by a family of i.i.d. Bernoulli random variables. In this case, we identify a generating function that bounds the tail events o interest, and analytically upper bound the growth of the function. We then show how to extend the analysis to the setting where the characteristic string is drawn from a martingale sequence. As it happens, this more general distribution arises naturally in the analyses of PoS protocols that survive adaptive adversaries; e.g., Ouroboros Genesis <a href="#page-31-2">[2]</a>. We obtain the pleasing result that the common prex error probability in the martingale case is no more than that in the i.i.d. Bernoulli case.</p>

    <p class="text-gray-300"><strong>Direct consequences.</strong> Our results establish consistency bounds in a quite general settingâ€”see below: In particular, they directly imply exp(âˆ’Î˜(ğ‘˜)) consistency for the Sleepy consensus (Snow White) <a href="#page-33-0">[21]</a>, Ouroboros <a href="#page-32-2">[13]</a>, Ouroboros Praos <a href="#page-32-8">[6]</a>, and Ouroboros Genesis <a href="#page-31-2">[2]</a> blockchain protocols. (The Ouroboros Praos and Ouroboros Genesis analyses in fact directly relied on an earlier e-print version of the present article for their settlement estimates.)</p>

    <p class="text-gray-300"><strong>Related work.</strong> Blockchain protocol analysis in the PoW-setting was initiated in <a href="#page-32-6">[9]</a> and further improved in <a href="#page-33-1">[24,</a> <a href="#page-32-7">11]</a>. The established security bounds for consistency are linear in the security parameter. Sleepy consensus <a href="#page-33-0">[21,</a> Theorem 13] provides a consistency bound of the form exp(âˆ’Î©(&lt;sup&gt;âˆš&lt;/sup&gt; ğ‘˜)). Note that <a href="#page-33-0">[21]</a> is not a PoS protocol per se, but it is possible to turn it into one (as was demonstrated in <a href="#page-31-3">[4]</a>). The analysis of the Ouroboros blockchain <a href="#page-32-2">[13]</a> achieves exp(âˆ’Î©(&lt;sup&gt;âˆš&lt;/sup&gt; ğ‘˜)). We remark that the analyses of Ouroboros Praos <a href="#page-32-8">[6]</a> and Ouroboros Genesis <a href="#page-31-2">[2]</a> developed signicant new machinery for handling other challenges (e.g., adaptive adversaries, partial synchrony), but directly referred to a preliminary version of this article to conclude their guarantees of exp(âˆ’Î©(ğ‘˜)).</p>

    <p class="text-gray-300">Our results complement the recent results of <a href="#page-31-4">[5]</a>, which also considers longest-chain PoS protocols. <a href="#page-31-4">[5]</a> focuses on identifying dynamics unique to longest-chain PoS protocols. In particular, they show that longest-chain PoS protocols that are <em>predictable</em> (i.e., for which some portion of the schedule of slot leaders is known ahead of time) are necessarily vulnerable to &quot;predictable double-spends.&quot; The conventional defense against such attacks is to wait for the specied settlement time to elapse before accepting a transaction, which (until now) has resulted in slow conrmation times. As such, <a href="#page-31-4">[5]</a> raised the question of whether long conrmation times are a necessary evil in longest-chain PoS blockchains. As double-spending attacks imply a consistency violation, our results show that PoS protocols can safely decrease settlement times to asymptotically match PoW protocols without sacricing security against double-spends.</p>

    <p class="text-gray-300">Because we focus on the longest-chain rule, our analysis is not applicable to protocols like Algorand <a href="#page-32-9">[15]</a> which, in fact, oer settlement in expected constant time without invoking blockchain reorganisation or forks; however, Algorand lacks the ability to operate in the &quot;sleepy&quot; <a href="#page-33-0">[21]</a> or &quot;dynamic availability&quot; <a href="#page-31-2">[2]</a> setting. In our combinatorial analysis, synchronous operation is assumed against a rushing adversary; this is without loss of generality vis-a-vis the result of <a href="#page-32-8">[6]</a> where it was shown how to reduce the combinatorial analysis in the partially synchronous setting to the synchronous one. We note that a number of works have shown how to use a blockchain protocol to bootstrap a cryptographic protocol that can oer faster settlement time under stronger assumptions than honest majority, e.g., Hybrid Consensus <a href="#page-33-3">[22]</a> or Thunderella <a href="#page-33-4">[23]</a>; our results are orthogonal and synergistic to those since they can be used to improve the settlement time bounds of the blockchain protocol that operates as a fallback mechanism.</p>

    <p class="text-gray-300"><strong>Outline.</strong> We begin in Section <a href="#page-3-0">2</a> by describing a simple general model for blockchain dynamics. Section <a href="#page-10-0">3</a> builds on this model to set down a number of basic denitions required for the proofs. The rst part of the main proof is described in Section <a href="#page-17-0">5,</a> which develops a &quot;relative&quot; version of the theory of margin from <a href="#page-32-2">[13]</a>; most details are then relegated to Section <a href="#page-25-0">7</a> in order to move quickly to the consistency estimates in Section <a href="#page-17-1">6.</a> In Section <a href="#page-28-0">8,</a> we present an optimal online adversary who can simultaneously maximize the relative margins for all prexes of the characteristic string. Finally, in Appendix <a href="#page-33-2">A,</a> we compute exact upper bounds on ğ‘˜-settlement error probabilities for various values of ğ‘˜ and describe a simple ğ‘‚(ğ‘˜ 3 )-time algorithm to compute these probabilities in general.</p>

    <h2 id="sec-3" class="text-2xl font-bold">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;<strong>2 The blockchain axioms and the settlement security model</strong></h2>

    <p class="text-gray-300">Typical blockchain consensus protocols call for each participant to maintain a <em>blockchain</em>; this is a data structure that organizes transactions and other protocol metadata into an ordered historical record of &quot;blocks.&quot; A basic design goal of these systems is to guarantee that participants' blockchains always agree on a common prex; the diering suxes of the chains held by various participants roughly correspond to the possible future states of the system. Thus the major analytic challenge is to ensure thatâ€”despite evolving adversarial control of some of the participantsâ€”the portion of honest participants' blockchains that might pairwise disagree is conned to a short sux. This analysis in turn supports the fundamental guarantee of <em>consistency</em> for these algorithms, which asserts that data appearing deep enough in the chain can be considered to be stable, or &quot;settled.&quot;</p>

    <p class="text-gray-300">We adopt a discrete notion of time organized into a sequence of <em>slots</em> {<em>sl</em>&lt;sup&gt;0&lt;/sup&gt; ,<em>sl</em>&lt;sup&gt;1&lt;/sup&gt; , â€¦} and assume all protocol participants have the luxury of synchronized clocks that report the current slot number. As discussed above, the protocols we consider rely on two algorithmic devices:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A <em>leader election mechanism</em>, which randomly assigns to each time slot a set of &quot;leaders&quot; permitted to post a new block in that slot.</li>
      <li>The <em>longest-chain rule</em>, which calls for the leader(s) of each slot to add a block to the end of the longest blockchain she has yet observed, and broadcast this new chain to other participants.</li>
    </ul>

    <p class="text-gray-300">The Bitcoin protocol uses a proof-of-work mechanism to carry out leader election, which can be modeled using a random oracle <a href="#page-32-6">[9,</a> <a href="#page-33-1">24,</a> <a href="#page-32-7">11]</a>. Proof-of-stake systems typically require more intricate leader election mechanisms; for example, the Ouroboros protocol <a href="#page-32-2">[13]</a> uses a full multi-party private computation to distribute clean randomness, while Snow White <a href="#page-31-3">[4]</a>, Algorand <a href="#page-32-9">[15]</a>, and Ouroboros Praos <a href="#page-32-8">[6]</a> use hashing and a family of values determined on-the-y. Despite these dierences, all existing analyses show that the leader election mechanism suitably approximates an ideal distribution, which is also the approach we will adopt for our analysis.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8"><strong>2.1 The blockchain axioms and forks</strong></h3>

    <p class="text-gray-300">To simplify our analysis, we assume a synchronous communication network in the presence of a <em>rushing</em> adversary: in particular, any message broadcast by an honest participant at the beginning of a particular slot is received by the adversary rst, who may decide strategically and individually for each recipient in the network whether to inject additional messages and in what order all messages are to be delivered prior to the conclusion of the slot. (See <a href="#page-10-1">Â§2.5</a> below for comments on this network assumption.)</p>

    <p class="text-gray-300">Given this, the behavior of the protocol when carried out by a group of honest participants (who follow the protocol in the presence of an adversary who may only reorganize messages) is clear. Assuming that the system is initialized with a common &quot;genesis block&quot; corresponding to <em>sl</em>&lt;sup&gt;0&lt;/sup&gt; and the leader election process in fact elects a single leader per slot, the players observe a common, linearly growing blockchain:</p>

    <p class="text-gray-300">    <img src="_page_4_Picture_8.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Here node ğ‘– represents the block broadcast by the leader of slot ğ‘– and the arrows represent the direction of increasing time. (Note that the requirement of a single leader per slot is important in this simple picture; it is possible for a network adversary to induce divergent views between the players by taking advantage of slots where more than a single honest participant is elected a leader.)</p>

    <p class="text-gray-300"><strong>The blockchain axioms: Informal discussion.</strong> The introduction of adversarial participants or multiple slot leaders complicates the family of possible blockchains that could emerge from this process. To explore this in the context of our protocols, we work with an abstract notion of a blockchain which ignores all internal structure. We consider a xed assignment of leaders to time slots, and assume that the blockchain uses a proof mechanism to ensure that any block labeled with slot <em>sl</em>&lt;sup&gt;ğ‘¡&lt;/sup&gt; was indeed produced by a leader of slot <em>sl</em>&lt;sup&gt;ğ‘¡&lt;/sup&gt; ; this is guaranteed in practice by appropriate use of a secure digital signature scheme.</p>

    <p class="text-gray-300">Specically, we treat a <em>blockchain</em> as a sequence of abstract blocks, each labeled with a slot number, so that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>A1</strong>. The blockchain begins with a xed &quot;genesis&quot; block, assigned to slot <em>sl</em>&lt;sup&gt;0&lt;/sup&gt; .</li>
      <li><strong>A2</strong>. The (slot) labels of the blocks are in strictly increasing order.</li>
    </ul>

    <p class="text-gray-300">It is further convenient to introduce the structure of a directed graph on our presentation, where each block is treated as a vertex; in light of the rst two axioms above, a blockchain is a path beginning with a special &quot;genesis&quot; vertex, labeled 0, followed by vertices with strictly increasing labels that indicate which slot is associated with the block.</p>

    <p class="text-gray-300"><span class="math">$0 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 7 \\rightarrow 9</span>$</p>

    <p class="text-gray-300">The protocols of interest call for honest players to add a single block during any slot. In particular:</p>

    <p class="text-gray-300"><strong>A3</strong>. If a slot  <span class="math">sl_t</span>  was assigned to a single honest player, then a single block is createdâ€”during the entire protocolâ€”with the label  <span class="math">sl_t</span> .</p>

    <p class="text-gray-300">Recall that blockchains are <em>immutable</em> in the sense that any block in the chain commits to the entire previous history of the chain; this is achieved in practice by including with each block a collision-free hash of the previous block. These properties imply that if a specific slot  <span class="math">sl_t</span>  was assigned to a unique honest player, then any chain that includes the unique block from  <span class="math">sl_t</span>  must also include that block's associated prefix in its entirety.</p>

    <p class="text-gray-300">As we analyze the dynamics of blockchain algorithms, it is convenient to maintain an entire family of blockchains at once. As a matter of bookkeeping, when two blockchains agree on a common prefix, we can glue together the associated paths to reflect this, as indicated below.</p>

    <p class="text-gray-300">    <img src="_page_5_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">When we glue together many chains to form such a diagram, we call it a &quot;fork&quot;â€”the precise definition appears below. Observe that while these two blockchains agree through the vertex (block) labeled 5, they contain (distinct) vertices labeled 9; this reflects two distinct blocks associated with slot 9 which, in light of the axiom above, must have been produced by an adversarial participant.</p>

    <p class="text-gray-300">Finally, as we assume that messages from honest players are delivered without delay, we note a direct consequence of the longest chain rule:</p>

    <p class="text-gray-300"><strong>A4</strong>. If two honestly generated blocks  <span class="math">B_1</span>  and  <span class="math">B_2</span>  are labeled with slots  <span class="math">sl_1</span>  and  <span class="math">sl_2</span>  for which  <span class="math">sl_1 &lt; sl_2</span> , then the length of the unique blockchain terminating at  <span class="math">B_1</span>  is strictly less than the length of the unique blockchain terminating at  <span class="math">B_2</span> .</p>

    <p class="text-gray-300">Recall that the honest participant assigned to slot  <span class="math">sl_2</span>  will be aware of the blockchain terminating at  <span class="math">B_1</span>  that was broadcast by the honest player in slot  <span class="math">sl_1</span>  as a result of synchronicity; according to the longest-chain rule, it must have placed  <span class="math">B_2</span>  on a chain that was at least this long. In contrast, not all participants are necessarily aware of all blocks generated by dishonest players, and indeed dishonest players may often want to delay the delivery of an adversarial block to a participant or show one block to some participants and show a completely different block to others.</p>

    <p class="text-gray-300">Characteristic strings, forks, and the formal axioms. Note that with the axioms we have discussed above, whether or not a particular fork diagram (such as the one just above) corresponds to a valid execution of the protocol depends on how the slots have been awarded to the parties by the leader election mechanism. We introduce the notion of a &quot;characteristic&quot; string as a convenient means of representing information about slot leaders in a given execution.</p>

    <p class="text-gray-300"><strong>Definition 1</strong> (Characteristic string). Let  <span class="math">sl_1, ..., sl_n</span>  be a sequence of slots. A characteristic string w is an element of  <span class="math">\\{0,1\\}^n</span>  defined for a particular execution of a blockchain protocol so that</p>

    <p class="text-gray-300"><span class="math">$w_t = \\begin{cases} 0 &amp; \\text{if } sl_t \\text{ was assigned to a single honest participant,} \\\\ 1 &amp; \\text{otherwise.} \\end{cases}</span>$</p>

    <p class="text-gray-300">For two Boolean strings x and w, we write x &lt; w iff x is a strict prefix of w. Similarly, we write  <span class="math">x \\le w</span>  iff either x = w or x &lt; w. The empty string  <span class="math">\\varepsilon</span>  is a prefix to any string. With this discussion behind us, we set down the formal object we use to reflect the various blockchains adopted by honest players during the execution of a blockchain protocol. This definition formalizes the blockchains axioms discussed above.</p>

    <p class="text-gray-300"><strong>Definition 2</strong> (Fork; [13]). Let  <span class="math">w \\in \\{0,1\\}^n</span>  and let  <span class="math">H = \\{i \\mid w_i = 0\\}</span> . A fork for the string w consists of a directed and rooted tree F = (V, E) with a labeling  <span class="math">\\ell : V \\to \\{0, 1, ..., n\\}</span> . We insist that each edge of F is directed away from the root vertex and further require that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;(F1.) the root vertex r has label  <span class="math">\\ell(r) = 0</span> ;</li>
      <li>(F2.) the labels of vertices along any directed path are strictly increasing;</li>
      <li>&lt;span id=&quot;page-6-3&quot;&gt;&lt;/span&gt;(F3.) each index  <span class="math">i \\in H</span>  is the label for exactly one vertex of F;</li>
      <li>&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;(F4.) for any vertices  <span class="math">i, j \\in H</span> , if i &lt; j, then the depth of vertex i in F is strictly less than the depth of vertex j in F.</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-6-2&quot;&gt;&lt;/span&gt;If F is a fork for the characteristic string w, we write  <span class="math">F \\vdash w</span> . Note that the conditions (F1.)â€“(F4.) are direct analogues of the axioms A1â€“A4 above. See Fig. 1 for an example fork. A final notational convention: If  <span class="math">F \\vdash x</span>  and  <span class="math">\\hat{F} \\vdash w</span> , we say that F is a <em>prefix</em> of  <span class="math">\\hat{F}</span> , written  <span class="math">F \\sqsubseteq \\hat{F}</span> , if  <span class="math">x \\le w</span>  and F appears as a consistently-labeled subgraph of  <span class="math">\\hat{F}</span> . (Specifically, each path of F appears, with identical labels, in  <span class="math">\\hat{F}</span> .)</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: A fork F for the characteristic string w = 010100110; vertices appear with their labels and honest vertices are highlighted with double borders. Note that the depths of the (honest) vertices associated with the honest indices of w are strictly increasing. Note, also, that this fork has two disjoint paths of maximum depth.</p>

    <p class="text-gray-300">Let w be a characteristic string. The directed paths in the fork  <span class="math">F \\vdash w</span>  originating from the root are called <em>tines</em>; these are abstract representations of blockchains. (Note that a tine might not terminate at a leaf of the fork.) We naturally extend the label function  <span class="math">\\ell</span>  for tines: i.e.,  <span class="math">\\ell(t) \\triangleq \\ell(v)</span>  where the tine t terminates at vertex v. The length of a tine t is denoted by length(t).</p>

    <p class="text-gray-300"><strong>Viable tines.</strong> The longest-chain rule dictates that honest players build on chains that are at least as long as all previously broadcast honest chains. It is convenient to distinguish such tines in the analysis: specifically, a tine t of F is called <em>viable</em> if its length is at least the depth of any honest vertex v for which  <span class="math">\\ell(v) \\leq \\ell(t)</span> . A tine t is <em>viable at slot s</em> if the portion of t appearing over slots  <span class="math">0, \\ldots, s</span>  has length at least that of any honest vertices labeled from this set. (As noted, the properties (F3.) and (F4.) together imply that an honest observer at slot s will only adopt a viable tine.) The <em>honest depth</em> function  <span class="math">\\mathbf{d}: H \\to [n]</span>  gives the depth of the (unique) vertex associated with an honest slot; by (F4.),  <span class="math">\\mathbf{d}(\\cdot)</span>  is strictly increasing.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Settlement and the common prefix property</h3>

    <p class="text-gray-300">We are now ready to explore the power of an adversary in this setting who has corrupted a (perhaps evolving) coalition of the players. We focus on the possibility that such an adversary can blatantly confound consistency of the honest player's blockchains. In particular, we consider the possibility that, at some time t, the adversary conspires to produce two blockchains of maximum length that diverge prior to a previous slot  <span class="math">s \\le t</span> ; in this case honest players adopting the longest-chain rule may clearly disagree about the history of the blockchain after slot s. We call such a circumstance a <em>settlement violation</em>.</p>

    <p class="text-gray-300">To reflect this in our abstract language, let  <span class="math">F \\vdash w</span>  be a fork corresponding to an execution with characteristic string w. Such a settlement violation induces two viable times  <span class="math">t_1, t_2</span>  with the same length that diverge prior to a particular slot of interest. We record this below.</p>

    <p class="text-gray-300"><strong>Denition 3</strong> (Settlement with parameters ğ‘ , ğ‘˜ âˆˆ â„•)<strong>.</strong> <em>Let</em> ğ‘¤ âˆˆ {0, 1}&lt;sup&gt;ğ‘›&lt;/sup&gt; <em>be a characteristic string. Let</em> ğ¹ âŠ¢ ğ‘¤&lt;sup&gt;1&lt;/sup&gt; â€¦ ğ‘¤&lt;sup&gt;ğ‘¡&lt;/sup&gt; <em>be a fork for a prex of</em> ğ‘¤ <em>with</em> ğ‘  + ğ‘˜ â‰¤ ğ‘¡ â‰¤ ğ‘›<em>. We say that a slot</em> ğ‘  <em>is</em> not ğ‘˜-settled <em>in</em> ğ¹ <em>if the fork contains two tines</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>of maximum length that &quot;diverge prior to</em> ğ‘ <em>,&quot; i.e., they either contain dierent vertices labeled with</em> ğ‘ <em>, or one contains a vertex labeled with</em> ğ‘  <em>while the other does not. Note that such tines are viable by denition. Otherwise,</em> slot ğ‘  is ğ‘˜-settled in ğ¹<em>. We say that a slot</em> ğ‘  <em>is</em> ğ‘˜-settled <em>(for the characteristic string</em> ğ‘¤<em>) if it is</em> ğ‘˜<em>-settled in every fork</em> ğ¹ âŠ¢ ğ‘¤&lt;sup&gt;1&lt;/sup&gt; , â€¦ ğ‘¤&lt;sup&gt;ğ‘¡&lt;/sup&gt; <em>, for each</em> ğ‘¡ â‰¥ ğ‘  + ğ‘˜<em>.</em></p>

    <p class="text-gray-300"><strong>Common prex.</strong> Settlement violations are a convenient and intuitive proxy for the notion of common prex discussed in the introduction. Indeed, as we show in Section <a href="#page-13-0">4,</a> the two notions are equivalent, so we have the luxury of discussing settlement violations which have the advantage of a more ready interpretation. Concretely, we will simultaneously upper boundâ€”using the same analytic techniquesâ€”the probability of settlement violations and common prex violations.</p>

    <p class="text-gray-300">Recall that the common prex property with parameter ğ‘˜ asserts that, for any slot index ğ‘ , if an honest observer at slot ğ‘  + ğ‘˜ adopts a blockchain ğ’, the prex ğ’[0 âˆ¶ ğ‘ ] will be present in every honestly-held blockchain at or after slot ğ‘  + ğ‘˜. (Here, ğ’[0 âˆ¶ ğ‘ ] denotes the prex of the blockchain ğ’ containing only the blocks issued from slots 0, 1, â€¦ , ğ‘ .)</p>

    <p class="text-gray-300">We translate this property into the framework of forks. Consider a tine ğ‘¡ of a fork ğ¹ âŠ¢ ğ‘¤. The <em>trimmed</em> tine ğ‘¡ âŒˆğ‘˜ is dened as the portion of ğ‘¡ labeled with slots {0, â€¦ , ğ“(ğ‘¡) âˆ’ ğ‘˜}. For two tines, we use the notation ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âª¯ ğ‘¡&lt;sup&gt;2&lt;/sup&gt; to indicate that the tine ğ‘¡&lt;sup&gt;1&lt;/sup&gt; is a prex of tine ğ‘¡&lt;sup&gt;2&lt;/sup&gt; .</p>

    <p class="text-gray-300"><strong>Denition 4</strong> (Common Prex Property with parameter ğ‘˜ âˆˆ â„•)<strong>.</strong> <em>Let</em> ğ‘¤ <em>be a characteristic string. A fork</em> ğ¹ âŠ¢ ğ‘¤ <em>satises</em> &lt;sup&gt;ğ‘˜&lt;/sup&gt;<em>-</em>CPğ—Œğ—…ğ—ˆğ— <em>if, for all pairs</em> (ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡2 ) <em>of viable tines</em> ğ¹ <em>for which</em> ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) â‰¤ ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; )<em>, we have</em> ğ‘¡ âŒˆğ‘˜ 1 âª¯ ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>. Otherwise, we say that the tine-pair</em> (ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡2 ) <em>is a witness to a</em> ğ‘˜<em>-</em>CPğ—Œğ—…ğ—ˆğ— <em>violation. Finally,</em> ğ‘¤ satises ğ‘˜-CPğ—Œğ—…ğ—ˆğ— <em>if every fork</em> ğ¹ âŠ¢ ğ‘¤ <em>satises</em> ğ‘˜<em>-</em>CPğ—Œğ—…ğ—ˆğ— <em>.</em></p>

    <p class="text-gray-300">If a string ğ‘¤ does not possess the ğ‘˜-CPğ—Œğ—…ğ—ˆğ— property, we say that ğ‘¤ <em>violates</em> ğ‘˜<em>-</em>CPğ—Œğ—…ğ—ˆğ—. Observe that we dened the common prex property in terms of deleting any blocks associated with the <em>last</em> ğ‘˜ <em>trailing slots</em> from a local blockchain ğ’. Traditionally (cf. <a href="#page-32-10">[10]</a>), this property has been dened in terms of deleting a sux of (block-)length ğ‘˜ from ğ’. We denote the block-deletion-based version of the common prex property as the ğ‘˜-CP property. Note, however, that a ğ‘˜-CP violation immediately implies a ğ‘˜-CPğ—Œğ—…ğ—ˆğ— violation, so bounding the probability of a ğ‘˜-CPğ—Œğ—…ğ—ˆğ— violation is sucient to rule out both events.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8"><strong>2.3 Adversarial attacks on settlement time; the settlement game</strong></h3>

    <p class="text-gray-300">To clarify the relationship between forks and the chains at play in a canonical blockchain protocol, we dene a game-based model below that explicitly describes the relationship between forks and executions. By design, the probability that the adversary wins this game is at most the probability that a slot ğ‘  is not ğ‘˜-settled. We remark that while we focus on settlement violations for clarity, one could equally well have designed the game around common prex violations.</p>

    <p class="text-gray-300">Consider the (ğ’Ÿ, ğ‘‡;ğ‘ , ğ‘˜)<em>-settlement game</em>, played between an adversary ğ’œ and a challenger ğ’ with a leader election mechanism modeled by an ideal distribution ğ’Ÿ. Intuitively, the game should reect the ability of the adversary to achieve a settlement violation; that is, to present two maximally-long viable blockchains to a future honest observer, thus forcing them to choose between two alternate histories which disagree on slot ğ‘ . The challenger plays the role(s) of the honest players during the protocol.</p>

    <p class="text-gray-300">Note that in typical PoS settings the distribution ğ’Ÿ is determined by the combined stake held by the adversarial players, the leader election mechanism, and the dynamics of the protocol. The most common case (as seen in Snow White <a href="#page-33-0">[21]</a> and Ouroboros <a href="#page-32-2">[13]</a>) guarantees that the characteristic string ğ‘¤ = ğ‘¤&lt;sup&gt;1&lt;/sup&gt; â€¦ ğ‘¤&lt;sup&gt;ğ‘‡&lt;/sup&gt; is drawn from an i.i.d. distribution for which Pr[ğ‘¤&lt;sup&gt;ğ‘–&lt;/sup&gt; = 1] â‰¤ (1 âˆ’ ğœ–)âˆ•2; here the constant (1 âˆ’ ğœ–)âˆ•2 is directly related to the stake held by the adversary. Settings involving adaptive adversaries (e.g., Ouroboros Praos <a href="#page-32-8">[6]</a> and Ouroboros Genesis <a href="#page-31-2">[2]</a>) yield the weaker martingale-type guarantee that Pr[ğ‘¤&lt;sup&gt;ğ‘–&lt;/sup&gt; = 1 âˆ£ ğ‘¤&lt;sup&gt;1&lt;/sup&gt; , â€¦ , ğ‘¤ğ‘–âˆ’1] â‰¤ (1 âˆ’ ğœ–)âˆ•2.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">The <span class="math">(\\mathcal{D}, T; s, k)</span> -settlement game</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A characteristic string  <span class="math">w \\in \\{0,1\\}^T</span>  is drawn from  <span class="math">\\mathcal{D}</span>  and provided to  <span class="math">\\mathcal{A}</span> . (This reflects the results of the leader election mechanism.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">A_0 \\vdash \\varepsilon</span>  denote the initial fork for the empty string  <span class="math">\\varepsilon</span>  consisting of a single node corresponding to the genesis block.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each slot t = 1, ..., T in increasing order:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">w_t = 0</span> , this is an honest slot. In this case, the challenger is given the fork  <span class="math">A_{t-1} \\vdash w_1 \\dots w_{t-1}</span>  and must determine a new fork  <span class="math">F_t \\vdash w_1 \\dots w_t</span>  by adding a single vertex (labeled with t) to the end of a longest path in  <span class="math">A_{t-1}</span> . (If there are ties,  <span class="math">\\mathcal A</span>  may choose which path the challenger adopts.)</li>
      <li>(b) If  <span class="math">w_t = 1</span> , this is an adversarial slot.  <span class="math">\\mathcal{A}</span>  may set  <span class="math">F_t \\vdash w_1 \\dots w_t</span>  to be an arbitrary fork for which  <span class="math">A_{t-1} \\sqsubseteq F_t</span> .</li>
      <li>(c) (Adversarial augmentation.)  <span class="math">\\mathcal{A}</span>  determines an arbitrary fork  <span class="math">A_t \\vdash w_1 \\dots, w_t</span>  for which  <span class="math">F_t \\sqsubseteq A_t</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Recall that  <span class="math">F \\subseteq F&#x27;</span>  indicates that F' contains, as a consistently-labeled subgraph, the fork F.</p>

    <p class="text-gray-300">A wins the settlement game if slot s is not k-settled in some fork  <span class="math">A_t</span>  (with  <span class="math">t \\ge s + k</span> ).</p>

    <p class="text-gray-300"><strong>Definition 5.</strong> Let  <span class="math">\\mathcal{D}</span>  be a distribution on  <span class="math">\\{0,1\\}^T</span> . Then define the (s,k)-settlement insecurity of  <span class="math">\\mathcal{D}</span>  to be</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{S}^{s,k}[\\mathcal{D}] \\triangleq \\max_{\\mathcal{A}} \\Pr[\\mathcal{A} \\text{ wins the } (\\mathcal{D}, T; s, k) \\text{-settlement game}],</span>$</p>

    <p class="text-gray-300">this maximum taken over all adversaries A.</p>

    <p class="text-gray-300"><strong>Remarks.</strong> Observe that the adversarial augmentation step permits the adversary to &quot;suddenly&quot; inject new paths in the fork between two honest players at adjacent slots; this corresponds to circumstances when the adversary chooses to deliver a new blockchain to an honest participant which may consist of an earlier honest chain with some adversarial blocks appended to the end. Observe, additionally, that the behavior of the challenger in the game is entirely deterministic, as it simply plays according to the longest-chain rule (even permitting the adversary to break ties). Thus the result of the game is entirely determined by the characteristic string w drawn from  <span class="math">\\mathcal{D}</span>  and the choices of the adversary  <span class="math">\\mathcal{A}</span> . We record the following immediate conclusion:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;<strong>Lemma 1.</strong> Let  <span class="math">s, k, T \\in \\mathbb{N}</span> . Let  <span class="math">\\mathcal{D}</span>  be a distribution on  <span class="math">\\{0, 1\\}^T</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{S}^{s,k}[\\mathcal{D}] \\leq \\Pr_{w \\sim \\mathcal{D}}[\\text{slot } s \\text{ is not } k\\text{-settled } \\text{for } w].</span>$</p>

    <p class="text-gray-300">In the subsequent sections, we will develop some further notation and tools to analyze this event. We will investigate two different families of distributions, those with i.i.d. coordinates and those with martingale-type conditioning guarantees. For  <span class="math">T \\in \\mathbb{N}</span>  and  <span class="math">\\epsilon \\in (0,1)</span> , let  <span class="math">B_{\\epsilon} = (B_1, \\dots, B_n)</span>  denote the random variable taking values in  <span class="math">\\{0,1\\}^n</span>  so that the  <span class="math">B_i</span>  are independent and  <span class="math">\\Pr[B_i=1]=(1-\\epsilon)/2</span> ; we let  <span class="math">\\mathcal{B}_{\\epsilon}</span>  denote the distribution on  <span class="math">\\{0,1\\}^n</span>  associated with  <span class="math">B_{\\epsilon}</span> . When  <span class="math">\\epsilon</span>  can be inferred from context, we simply write B and B.</p>

    <p class="text-gray-300">We also study a more general family of distributions, defined next.</p>

    <p class="text-gray-300"><strong>Definition 6</strong> ( <span class="math">\\varepsilon</span> -martingale condition). Let  <span class="math">W = (W_1, ..., W_n)</span>  be a random variable taking values in  <span class="math">\\{0, 1\\}^n</span> . We say that W satisfies the  <span class="math">\\varepsilon</span> -martingale condition if for each  <span class="math">t \\in \\{1, ..., n\\}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[W_t \\mid W_1, \\cdots, W_{t-1}] \\le (1 - \\epsilon)/2.</span>$</p>

    <p class="text-gray-300">Equivalently,  <span class="math">\\Pr[W_t = 1 \\mid W_1, ..., W_{t-1}] \\le (1 - \\epsilon)/2</span> . The conditioning on the variables  <span class="math">W_1, ..., W_{t-1}</span>  is arbitrary in both cases; as a consequence,  <span class="math">\\Pr[W_t = 1] \\le (1 - \\epsilon)/2</span> . As a matter of notation, we let  <span class="math">\\mathcal{W}</span>  denote the distribution</p>

    <p class="text-gray-300">associated with the random variable W. We use the term &quot;Îµ-martingale condition&quot; to qualify both a random variable and its distribution.</p>

    <p class="text-gray-300">There are settings, such as Genesis [2], where this martingale-type conditioning is important. Note that  <span class="math">\\mathcal{B}_{\\varepsilon}</span>  satisfies the  <span class="math">\\varepsilon</span> -martingale condition. Now we are ready to state our main theorem.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-2&quot;&gt;&lt;/span&gt;<strong>Theorem 1</strong> (Main theorem). Let  <span class="math">\\epsilon \\in (0,1)</span> ,  <span class="math">s,k,T \\in \\mathbb{N}</span> . Let  <span class="math">\\mathcal{W}</span>  and  <span class="math">\\mathcal{B}_{\\epsilon}</span>  be two distributions on  <span class="math">\\{0,1\\}^T</span>  where  <span class="math">\\mathcal{B}_{\\epsilon}</span>  is defined above and  <span class="math">\\mathcal{W}</span>  satisfies the  <span class="math">\\epsilon</span> -martingale condition. Then</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{S}^{s,k}[\\mathcal{W}] \\leq \\mathbf{S}^{s,k}[\\mathcal{B}_{\\epsilon}] \\leq \\exp(-\\Omega(\\epsilon^3(1 - O(\\epsilon))k)).</span>$</p>

    <p class="text-gray-300">(Here, the asymptotic notation hides constants that do not depend on  <span class="math">\\epsilon</span>  or k.)</p>

    <p class="text-gray-300">By techniques similar to the ones used to prove this result, we obtain the following theorem pertaining directly to k-CP&lt;sup&gt;slot&lt;/sup&gt; (and k-CP).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;<strong>Theorem 2</strong> (Main theorem; k-CP version). Let  <span class="math">\\epsilon \\in (0,1)</span>  and  <span class="math">T \\in \\mathbb{N}</span> . Let  <span class="math">w \\in \\{0,1\\}^T</span>  be a random variable satisfying the  <span class="math">\\epsilon</span> -martingale condition. Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[w \\text{ violates } k\\text{-CP}] \\leq \\Pr[w \\text{ violates } k\\text{-CP}^{\\mathsf{slot}}] \\leq T \\cdot \\exp\\left(-\\Omega(\\varepsilon^3(1 - O(\\varepsilon))k)\\right).</span>$</p>

    <p class="text-gray-300">The proofs of these theorems are presented in Section 6.5. Additionally, we provide a  <span class="math">O(k^3)</span> -time algorithm for computing an explicit upper bound on these probabilities; cf. Appendix A.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.4 Survey of the proofs of the main theorems</h3>

    <p class="text-gray-300">A central object in our combinatorial analysis is an &quot;x-balanced fork&quot; for a characteristic string w = xy. Such a fork contains two distinct, maximum-length tines that are disjoint over y; see Definition 9 for details. A settlement violation for the slot |x| + 1 implies an x-balanced fork for the string xy; see Observation 1. In particular, for any distribution on characteristic strings in  <span class="math">\\{0,1\\}^n</span>  and  <span class="math">s + k \\le n</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{w}[\\text{slot } s \\text{ is not } k\\text{-settled}] \\leq \\Pr_{w}\\left[\\begin{array}{l} \\text{there is a decomposition } w = xyz \\text{ and} \\\\ \\text{a fork } F \\vdash xy, \\text{ where } |x| = s - 1 \\text{ and} \\\\ |y| \\geq k + 1, \\text{ so that } F \\text{ is } x\\text{-balanced} \\end{array}\\right].</span>$</p>

    <p class="text-gray-300">(This is a variant of Lemma 5 from Section 6.5.)</p>

    <p class="text-gray-300">As promised above, common prefix violations can be handled the same way: we likewise establish (see Section 4; Theorem 3) that a common prefix violation implies that there exists a balanced fork for some prefix of w. Specifically, for any distribution of characteristic strings,</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\Pr_{w}[w \\text{ violates } k\\text{-CP}^{\\text{slot}}] \\leq \\Pr_{w} \\begin{bmatrix} \\text{there is a decomposition } w = xyz \\text{ and } \\\\ \\text{a fork } F \\vdash xy, \\text{ where } |y| \\geq k+1, \\text{ so} \\\\ \\text{that } F \\text{ is } x\\text{-balanced} \\end{bmatrix}. \\tag{1}</span>$</p>

    <p class="text-gray-300">Next, in Section 5, we give a recursive expression for the combinatorial quantity &quot;relative margin,&quot; written  <span class="math">\\mu_x(y)</span>  (see Definition 13 in Section 3). We establish that, for an arbitrary decomposition of the characteristic string w=xy, the event &quot;there is an x-balanced fork for xy&quot; is equivalent to the event &quot;the relative margin  <span class="math">\\mu_x(y)</span>  is non-negative;&quot; this is Fact 1. In Lemma 3, we develop an exact recursive presentation for  <span class="math">\\mu_x(y)</span> ; hence we can bound the probability of a common prefix violation (or a settlement violation) by reasoning about the non-negativity of the relative margin and, in particular, without reasoning directly about forks.</p>

    <p class="text-gray-300">In Section 6, we prove two bounds for the probability</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{w=xy\\\\|x|=s}}[\\mu_x(y)\\geq 0],</span>$</p>

    <p class="text-gray-300">for a fixed length s. The first bound pertains to the setting where w = xy is drawn from  <span class="math">\\mathcal{B}_{\\varepsilon}</span> . The second pertains to any distribution  <span class="math">\\mathcal{W}</span>  satisfying the  <span class="math">\\varepsilon</span> -martingale condition. For characteristic strings with distribution  <span class="math">\\mathcal{B}_{\\varepsilon}</span> , we</p>

    <p class="text-gray-300">identify a random variable which stochastically dominates ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ‘¦) and is amenable to exact analysis via generating functions; this yields the bound</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{w=xy}[\\mu_x(y) \\ge 0] \\le \\exp(-\\Omega(|y|)).</span>$</p>

    <p class="text-gray-300">Notice that this bound does not depend on ğ‘ , the length of ğ‘¥. The result for distributions satisfying the ğœ–-martingale condition then follows from stochastic dominance (Lemma <a href="#page-19-0">4)</a>. See Section <a href="#page-17-1">6</a> for details.</p>

    <p class="text-gray-300">It immediately follows that an (ğ‘ , ğ‘˜)-settlement violation (or a ğ‘˜-CPğ—Œğ—…ğ—ˆğ— violation) is a rare event for distributions of interest. The multiplicative factor ğ‘‡ in Theorem <a href="#page-9-0">2</a> comes from a union bound taken over all prexes of ğ‘¤.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;<strong>2.5 Comments on the model</strong></h3>

    <p class="text-gray-300"><strong>Analysis in the</strong> âˆ†<strong>-synchronous setting.</strong> The security game above most naturally models a blockchain protocol over a synchronous network with immediate delivery (because each &quot;honest&quot; play of the challenger always builds on a fork that contains the fork generated by previous honest plays). However, the model can be easily adapted to protocols in the âˆ†-synchronous model adopted by the Snow White and Ouroboros Praos protocols and analyses. In particular, David et al. <a href="#page-32-8">[6]</a> developed a &quot;âˆ†-reduction&quot; mapping on the space of characteristic strings that permits analyses of forks (and the related statistics of interest, cf. <a href="#page-10-0">Â§3)</a> in the âˆ†-synchronous setting by a direct appeal to the synchronous setting.</p>

    <p class="text-gray-300"><strong>Public leader schedules.</strong> One attractive feature of this model is that it gives the adversary full information about the future schedule of leaders. The analysis of some protocols indeed demand this (e.g., Ouroboros, Snow White). Other protocolsâ€”especially those designed to oer security against adaptive adversaries (Praos, Genesis)â€”in fact contrive to keep the leader schedule private. Of course, as our analysis is in the more dicult &quot;full information&quot; model, it applies to all of these systems.</p>

    <p class="text-gray-300"><strong>Bootstrappingmulti-phase algorithms; stake shift.</strong> We remark that several existing proof-of-stake blockchain protocols proceed in phases, each of which is obligated to generate the randomness (for leader election, say) for the next phase based on the current stake distribution. The blockchain security properties of each phase are then individually analyzedâ€”assuming clean randomnessâ€”which yields a recursive security argument; in this context the game outlined above precisely reects the single phase analysis.</p>

    <h2 id="sec-10" class="text-2xl font-bold">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;<strong>3 Denitions</strong></h2>

    <p class="text-gray-300">We rely on the elementary framework of forks and margin from Kiayias et al. <a href="#page-32-2">[13]</a>. We restate and briey discuss the pertinent denitions below. With these basic notions behind us, we then dene a new &quot;relative&quot; notion of margin, which will allow us to signicantly improve the ecacy of these tools for reasoning about settlement times.</p>

    <p class="text-gray-300">Recall that for a given execution of the protocol, we record the result of the leader election process via a <em>characteristic string</em> ğ‘¤ âˆˆ {0, 1}&lt;sup&gt;ğ‘‡&lt;/sup&gt; , dened such that ğ‘¤&lt;sup&gt;ğ‘–&lt;/sup&gt; = 0 when a unique and honest party is assigned to slot ğ‘– and ğ‘¤&lt;sup&gt;ğ‘–&lt;/sup&gt; = 1 otherwise. A vertex of a fork is said to be <em>honest</em> if it is labeled with an index ğ‘– such that ğ‘¤&lt;sup&gt;ğ‘–&lt;/sup&gt; = 0.</p>

    <p class="text-gray-300"><strong>Denition 7</strong> (Tines, length, and height)<strong>.</strong> <em>Let</em> ğ¹ âŠ¢ ğ‘¤ <em>be a fork for a characteristic string. A</em> tine <em>of</em> ğ¹ <em>is a directed path starting from the root. For any tine</em> ğ‘¡ <em>we dene its</em> length <em>to be the number of edges in the path, and for any vertex</em> ğ‘£ <em>we dene its</em> depth <em>to be the length of the unique tine that ends at</em> ğ‘£<em>. If a tine</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>is a strict prex of another tine</em> ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>, we write</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; â‰º ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>. Similarly, if</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>is a non-strict prex of</em> ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>, we write</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âª¯ ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>. The longest common prex of two tines</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡2 <em>is denoted by</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âˆ© ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>. That is,</em> ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âˆ© ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) = max{ğ“(ğ‘¢) âˆ¶ ğ‘¢ âª¯ ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>and</em> ğ‘¢ âª¯ ğ‘¡&lt;sup&gt;2&lt;/sup&gt; }<em>. The</em> height <em>of a fork (as usual for a tree) is the length of the longest tine, denoted</em> height(ğ¹)<em>.</em></p>

    <p class="text-gray-300"><strong>Denition 8</strong> (The âˆ¼&lt;sup&gt;ğ‘¥&lt;/sup&gt; relations)<strong>.</strong> <em>For two tines</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>and</em> ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>of a fork</em> ğ¹<em>, we write</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âˆ¼ ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>when</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>and</em> ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>share an edge; otherwise we write</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; â‰ ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>. We generalize this equivalence relation to reect whether tines share an edge over a particular sux of</em> ğ‘¤<em>: for</em> ğ‘¤ = ğ‘¥ğ‘¦ <em>we dene</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âˆ¼&lt;sup&gt;ğ‘¥&lt;/sup&gt; ğ‘¡2 <em>if</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>and</em> ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>share an edge that terminates at some node labeled</em></p>

    <p class="text-gray-300"><em>with an index in</em> ğ‘¦<em>; otherwise, we write</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; â‰&lt;sup&gt;ğ‘¥&lt;/sup&gt; ğ‘¡2 <em>(observe that in this case the paths share no vertex labeled by a slot associated with</em> ğ‘¦<em>). We sometimes call such pairs of tines</em> disjoint <em>(or, if</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; â‰&lt;sup&gt;ğ‘¥&lt;/sup&gt; ğ‘¡2 <em>for a string</em> ğ‘¤ = ğ‘¥ğ‘¦<em>,</em> disjoint over ğ‘¦<em>). Note that</em> âˆ¼ <em>and</em> âˆ¼&lt;sup&gt;ğœ€&lt;/sup&gt; <em>are the same relation.</em></p>

    <p class="text-gray-300">The basic structure we use to use to reason about settlement times is that of a &quot;balanced fork.&quot;</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;<strong>Denition 9</strong> (Balanced fork; cf. &quot;at&quot; in <a href="#page-32-2">[13]</a>)<strong>.</strong> <em>A fork</em> ğ¹ <em>is</em> balanced <em>if it contains a pair of tines</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>and</em> ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>for which</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; â‰ ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>and</em> length(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) = length(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) = height(ğ¹)<em>. We dene a relative notion of balance as follows: a fork</em> ğ¹ âŠ¢ ğ‘¥ğ‘¦ <em>is</em> ğ‘¥-balanced <em>if it contains a pair of tines</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; <em>and</em> ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>for which</em> ğ‘¡&lt;sup&gt;1&lt;/sup&gt; â‰&lt;sup&gt;ğ‘¥&lt;/sup&gt; ğ‘¡&lt;sup&gt;2&lt;/sup&gt; <em>and</em> length(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) = length(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) = height(ğ¹)<em>.</em></p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-2&quot;&gt;&lt;/span&gt;Thus, balanced forks contain two completely disjoint, maximum-length tines, while ğ‘¥-balanced forks contain two maximum-length tines that may share edges in ğ‘¥ but must be disjoint over the rest of the string. See Figures <a href="#page-11-2">2</a> and <a href="#page-11-3">3</a> for examples of balanced forks.</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: A balanced fork</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-3&quot;&gt;&lt;/span&gt;    <img src="_page_11_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: An ğ‘¥-balanced fork, where ğ‘¥ = 00</p>

    <p class="text-gray-300"><strong>Balanced forks and settlement time.</strong> A fundamental question arising in typical blockchain settings is how to determine <em>settlement time</em>, the delay after which the contents of a particular block of a blockchain can be considered stable. The existence of a balanced fork is a precise indicator for &quot;settlement violations&quot; in this sense. Specically, consider a characteristic string ğ‘¥ğ‘¦ and a transaction appearing in a block associated with the rst slot of ğ‘¦ (that is, slot |ğ‘¥| + 1). One clear violation of settlement at this point of the execution is the existence of two chainsâ€”each of maximum lengthâ€”which diverge <em>prior to</em> ğ‘¦; in particular, this indicates that there is an ğ‘¥-balanced fork ğ¹ for ğ‘¥ğ‘¦. Let us record this observation below.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;<strong>Observation 1.</strong> <em>Let</em> ğ‘ , ğ‘˜ âˆˆ â„• <em>be given and let</em> ğ‘¤ <em>be a characteristic string. Slot</em> ğ‘  <em>is not</em> ğ‘˜<em>-settled for the characteristic string</em> ğ‘¤ <em>if there exist a decomposition</em> ğ‘¤ = ğ‘¥ğ‘¦ğ‘§<em>, where</em> |ğ‘¥| = ğ‘  âˆ’ 1 <em>and</em> |ğ‘¦| â‰¥ ğ‘˜ + 1<em>, and an</em> ğ‘¥<em>-balanced fork for</em> ğ‘¥ğ‘¦<em>.</em></p>

    <p class="text-gray-300">In fact, every ğ‘˜-CPğ—Œğ—…ğ—ˆğ— violation produces a balanced fork as well; see Theorem <a href="#page-13-1">3</a> in Section <a href="#page-13-0">4.</a> In particular, to provide a rigorous ğ‘˜-slot settlement guaranteeâ€”which is to say that the transaction can be considered settled once ğ‘˜ slots have gone byâ€”it suces to show that with overwhelming probability in choice of the characteristic string determined by the leader election process (of a full execution of the protocol), no such forks are possible. Specically, if the protocol runs for a total of ğ‘‡ time steps yielding the characteristics string ğ‘¤ = ğ‘¥ğ‘¦ (where</p>

    <p class="text-gray-300">ğ‘¤ âˆˆ {0, 1}&lt;sup&gt;ğ‘‡&lt;/sup&gt; and the transaction of interest appears in slot |ğ‘¥| + 1 as above) then it suces to ensure that there is no ğ‘¥-balanced fork for ğ‘¥ğ‘¦Ì‚, where ğ‘¦Ì‚ is an arbitrary prex of ğ‘¦ of length at least ğ‘˜ + 1; see Corollary <a href="#page-18-0">1</a> in Section <a href="#page-17-1">6.</a> Note that for systems adopting the longest chain rule, this condition must necessarily involve the <em>entire future dynamics</em> of the blockchain. We remark that our analysis below will in fact let us take ğ‘‡ = âˆ.</p>

    <p class="text-gray-300"><strong>Denition 10</strong> (Closed fork)<strong>.</strong> <em>A fork</em> ğ¹ <em>is</em> closed <em>if every leaf is honest. For convenience, we say the trivial fork is closed.</em></p>

    <p class="text-gray-300">Closed forks have two nice properties that make them especially useful in reasoning about the view of honest parties. First, a closed fork must have a unique longest tine (since honest parties are aware of all previous honest blocks, and honest parties observe the longest chain rule). Second, recalling our description of the settlement game, closed forks intuitively capture decision points for the adversary. The adversary can potentially show many tines to many honest parties, but once an honest node has been placed on top of a tine, any adversarial blocks beneath it are part of the public record and are visible to all honest parties. For these reasons, we will often nd it easier to reason about closed forks than arbitrary forks.</p>

    <p class="text-gray-300">The next few denitions are the start of a general toolkit for reasoning about an adversary's capacity to build highly diverging paths in forks, based on the underlying characteristic string.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;<strong>Denition 11</strong> (Gap, reserve, and reach)<strong>.</strong> <em>For a closed fork</em> ğ¹ âŠ¢ ğ‘¤ <em>and its unique longest tine</em> ğ‘¡Ì‚<em>, we dene the</em> gap <em>of a tine</em> ğ‘¡ <em>to be</em> gap(ğ‘¡) = length(ğ‘¡Ì‚) âˆ’ length(ğ‘¡)<em>. Furthermore, we dene the</em> reserve <em>of</em> ğ‘¡<em>, denoted</em> reserve(ğ‘¡)<em>, to be the number of adversarial indices in</em> ğ‘¤ <em>that appear after the terminating vertex of</em> ğ‘¡<em>. More precisely, if</em> ğ‘£ <em>is the last vertex of</em> ğ‘¡<em>, then</em></p>

    <p class="text-gray-300"><span class="math">$\\operatorname{reserve}(t) = \\left| \\left\\{ i \\mid w_i = 1 \\ and \\ i &gt; \\ell(v) \\right\\} \\right|.</span>$</p>

    <p class="text-gray-300"><em>These quantities together dene the</em> reach <em>of a tine:</em> reach(ğ‘¡) = reserve(ğ‘¡) âˆ’ gap(ğ‘¡)<em>.</em></p>

    <p class="text-gray-300">The notion of reach can be intuitively understood as a measurement of the resources available to our adversary in the settlement game. Reserve tracks the number of slots in which the adversary has the right to issue new blocks. When reserve exceeds gap (or equivalently, when reach is nonnegative), such a tine could be extendedâ€”using a sequence of dishonest blocksâ€”until it is as long as the longest tine. Such a tine could be oered to an honest player who would prefer it over, e.g., the current longest tine in the fork. In contrast, a tine with negative reach is too far behind to be directly useful to the adversary at that time.</p>

    <p class="text-gray-300"><strong>Denition 12</strong> (Maximum reach)<strong>.</strong> <em>For a closed fork</em> ğ¹ âŠ¢ ğ‘¤<em>, we dene</em> ğœŒ(ğ¹) <em>to be the largest reach attained by any tine of</em> ğ¹<em>, i.e.,</em></p>

    <p class="text-gray-300"><span class="math">$\\rho(F) = \\max_{t} \\operatorname{reach}(t).</span>$</p>

    <p class="text-gray-300"><em>Note that</em> ğœŒ(ğ¹) <em>is never negative (as the longest tine of any fork always has reach at least 0). We overload this notation to denote the maximum reach over all forks for a given characteristic string:</em></p>

    <p class="text-gray-300"><span class="math">$\\rho(w) = \\max_{\\substack{F \\vdash w \\\\ F \\ closed}} \\left[ \\max_{t} \\ \\operatorname{reach}(t) \\right].</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;<strong>Denition 13</strong> (Margin)<strong>.</strong> <em>The</em> margin <em>of a fork</em> ğ¹ âŠ¢ ğ‘¤<em>, denoted</em> ğœ‡(ğ¹)<em>, is dened as</em></p>

    <p class="text-gray-300"><span class="math">$\\mu(F) = \\max_{t_1 \\sim t_2} \\left( \\min\\{ \\operatorname{reach}(t_1), \\operatorname{reach}(t_2) \\} \\right), \\tag{2}</span>$</p>

    <p class="text-gray-300"><em>where this maximum is extended over all pairs of disjoint tines of</em> ğ¹<em>; thus margin reects the &quot;second best&quot; reach obtained over all disjoint tines. In order to study splits in the chain over particular portions of a string, we generalize this to dene a &quot;relative&quot; notion of margin: If</em> ğ‘¤ = ğ‘¥ğ‘¦ <em>for two strings</em> ğ‘¥ <em>and</em> ğ‘¦ <em>and, as above,</em> ğ¹ âŠ¢ ğ‘¤<em>, we dene</em></p>

    <p class="text-gray-300"><span class="math">$\\mu_{x}(F) = \\max_{t_{1} \\sim_{x} t_{2}} \\left( \\min\\{\\operatorname{reach}(t_{1}), \\operatorname{reach}(t_{2})\\} \\right).</span>$</p>

    <p class="text-gray-300"><em>Note that</em> ğœ‡&lt;sup&gt;ğœ€&lt;/sup&gt; (ğ¹) = ğœ‡(ğ¹)<em>.</em> For convenience, we once again overload this notation to denote the margin of a string.  <span class="math">\\mu(w)</span>  refers to the maximum value of  <span class="math">\\mu(F)</span>  over all possible closed forks F for a characteristic string w:</p>

    <p class="text-gray-300"><span class="math">$\\mu(w) = \\max_{\\substack{F \\vdash w, \\\\ F \\ closed}} \\mu(F).</span>$</p>

    <p class="text-gray-300"><em>Likewise, if</em> w = xy <em>for two strings</em> x <em>and</em> y <em>we define</em></p>

    <p class="text-gray-300"><span class="math">$\\mu_{X}(y) = \\max_{F \\vdash w, \\atop F \\text{ closed}} \\mu_{X}(F).</span>$</p>

    <p class="text-gray-300">Note that, at least informally, &quot;second-best&quot; tines are of natural interest to an adversary intent on the construction of an <em>x</em>-balanced fork, which involves two (partially disjoint) long tines.</p>

    <p class="text-gray-300"><strong>Balanced forks and relative margin.</strong> Kiayias et al. [13] showed that a balanced fork can be constructed for a given characteristic string w if and only if there exists some closed  <span class="math">F \\vdash w</span>  such that  <span class="math">\\mu(F) \\ge 0</span> . We record a relative version of this theorem below, which will ultimately allow us to extend the analysis of [13] to more general class of disagreement and settlement failures.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-2&quot;&gt;&lt;/span&gt;<strong>Fact 1.</strong> Let  <span class="math">xy \\in \\{0,1\\}^n</span>  be a characteristic string. Then there is an x-balanced fork  <span class="math">F \\vdash xy</span>  if and only if  <span class="math">\\mu_x(y) \\ge 0</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is immediate from the definitions. We sketch the details for completeness.</p>

    <p class="text-gray-300">Suppose F is an x-balanced fork for xy. Then F must contain a pair of tines  <span class="math">t_1</span>  and  <span class="math">t_2</span>  for which  <span class="math">t_1 \\nsim_x t_2</span>  and length <span class="math">(t_1) = \\text{length}(t_2) = \\text{height}(F)</span> . We observe that (1)  <span class="math">\\text{gap}(t_i) = 0</span>  for both  <span class="math">t_1</span>  and  <span class="math">t_2</span> , and (2) reserve is always a nonnegative quantity. Together with the definition of reach, these two facts immediately imply  <span class="math">\\text{reach}(t_i) \\geq 0</span> . Because  <span class="math">t_1</span>  and  <span class="math">t_2</span>  are edge-disjoint over y and  <span class="math">\\text{min}\\{\\text{reach}(t_1), \\text{reach}(t_2)\\} \\geq 0</span> , we conclude that  <span class="math">\\mu_x(y) \\geq 0</span> , as desired.</p>

    <p class="text-gray-300">Suppose  <span class="math">\\mu_x(y) \\ge 0</span> . Then there is some closed fork F for xy such that  <span class="math">\\mu_x(F) \\ge 0</span> . By the definition of relative margin, we know that F has two tines  <span class="math">t_1</span> ,  <span class="math">t_2</span>  such that  <span class="math">t_1 \\nsim_x t_2</span>  and reach <span class="math">(t_i) \\ge 0</span> . Recall that we define reach by reach(t) = reserve(t) - gap(t), and so in this case it follows that  <span class="math">\\text{reserve}(t_i) - \\text{gap}(t_i) \\ge 0</span> . Thus, an x-balanced fork  <span class="math">F&#x27; \\vdash xy</span>  can be constructed from F by appending a path of  <span class="math">\\text{gap}(t_i)</span>  adversarial vertices to each  <span class="math">t_i</span> .</p>

    <p class="text-gray-300">As indicated above, we can define the &quot;forkability&quot; of a characteristic string in terms of its margin.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-3&quot;&gt;&lt;/span&gt;<strong>Definition 14</strong> (Forkable strings). A charactersitic string w is forkable if its margin is non-negative, i.e.,  <span class="math">\\mu(w) \\ge 0</span> . Equivalently, w is forkable if there is a balanced fork for w.</p>

    <p class="text-gray-300">Although this definition is not necessary for our presentation, it reflects the terminology of existing literature.</p>

    <h2 id="sec-11" class="text-2xl font-bold">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;4 Common prefix violation and balanced forks</h2>

    <p class="text-gray-300">In this section, we show that a common prefix violation implies the existence of a balanced fork. This allows us to bound consistency errors by reasoning about balanced forks. In particular, inequality (1) is a direct consequence of the theorem below.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;<strong>Theorem 3.</strong> Let  <span class="math">k, T \\in \\mathbb{N}</span> . Let  <span class="math">w \\in \\{0, 1\\}^T</span>  be a characteristic string which violates k-CP&lt;sup&gt;slot&lt;/sup&gt;. Then there exist a decomposition w = xyz and a fork  <span class="math">\\hat{F} \\vdash xy</span> , where  <span class="math">|y| \\ge k + 1</span> , so that  <span class="math">\\hat{F}</span>  is x-balanced.</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that  <span class="math">\\ell(t)</span>  is the slot index of the last vertex of tine t. Define  <span class="math">A \\triangleq \\bigcup_{F \\vdash w} A_F</span>  where, for a given fork  <span class="math">F \\vdash w</span> , define</p>

    <p class="text-gray-300"><span class="math">$A_F \\triangleq \\left\\{ \\begin{aligned} \\tau_1, \\tau_2 &amp; \\text{ are two viable tines in the fork } F, \\\\ (\\tau_1, \\tau_2) &amp; \\colon \\ell(\\tau_1) \\leq \\ell(\\tau_2), \\text{ and the pair } (\\tau_1, \\tau_2) \\text{ is a} \\\\ &amp; \\text{witness to a } k\\text{-CP}^{\\text{slot}} \\text{ violation} \\end{aligned} \\right\\}.</span>$</p>

    <p class="text-gray-300">Define the <em>slot divergence</em> of two tines as  <span class="math">\\operatorname{div}_{\\operatorname{slot}}(\\tau_1, \\tau_2) \\triangleq \\ell(\\tau_1) - \\ell(\\tau_1 \\cap \\tau_2)</span>  where  <span class="math">\\tau_1 \\cap \\tau_2</span>  denotes the common prefix of the tines  <span class="math">\\tau_1</span>  and  <span class="math">\\tau_2</span> . Recalling the definition of a k-CP&lt;sup&gt;slot&lt;/sup&gt; violation, it is clear that</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{div}_{\\mathsf{slot}}(\\tau_1, \\tau_2) \\ge k + 1 \\quad \\text{for all } (\\tau_1, \\tau_2) \\in A. \\tag{3}</span>$</p>

    <p class="text-gray-300">Notice that there must be a tine-pair  <span class="math">(t_1, t_2) \\in A</span>  which satisfies the following two conditions:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\operatorname{div}_{\\mathsf{slot}}(t_1, t_2)</span>$
is maximal over  <span class="math">A</span> , and (4)</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;
<span class="math">$|\\ell(t_2) - \\ell(t_1)|</span>$
is minimal among all tine-pairs in A for which (4) holds. (5)</p>

    <p class="text-gray-300">The tines  <span class="math">t_1</span> ,  <span class="math">t_2</span>  will play a special role in our proof; let F be a fork containing these tines.</p>

    <p class="text-gray-300">The prefix x, fork  <span class="math">F_x</span> , and vertex u. Let u denote the last vertex on the tine  <span class="math">t_1 \\cap t_2</span> , as shown in the diagram below, and let  <span class="math">\\alpha \\triangleq \\ell(u) = \\ell(t_1 \\cap t_2)</span> . Let  <span class="math">x \\triangleq w_1, \\dots, w_\\alpha</span>  and let  <span class="math">F_x</span>  be the fork-prefix of F supported on x. We will argue that u must be honest and, in addition, that  <span class="math">F_x</span>  must contain a unique longest tine  <span class="math">t_u</span>  terminating at the vertex u. We will also identify a substring  <span class="math">y, |y| \\geq k + 1</span>  such that w can be written as w = xyz. Then we will construct a balanced fork  <span class="math">\\tilde{F}_y \\vdash y</span>  by modifying the subgraph of F supported on y. We will finish the proof by constructing an x-balanced fork by suitably appending  <span class="math">\\tilde{F}_y</span>  to  <span class="math">F_x</span> .</p>

    <p class="text-gray-300">    <img src="_page_14_Picture_7.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">u must be an honest vertex. We observe, first of all, that the vertex u cannot be adversarial: otherwise it is easy to construct an alternative fork  <span class="math">F&#x27; \\vdash w</span>  and a pair of tines in F' that violate (4). Specifically, construct F' from F by adding a new (adversarial) vertex u' to F for which  <span class="math">\\ell(u&#x27;) = \\ell(u)</span> , adding an edge to u' from the vertex preceding u, and replacing the edge of  <span class="math">t_1</span>  following u with one from u'; then the other relevant properties of the fork are maintained, but the slot divergence of the resulting tines has increased by at least one. (See the diagram below.)</p>

    <p class="text-gray-300">    <img src="_page_14_Picture_9.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><span class="math">F_x</span>  has a unique, longest (and honest) tine  <span class="math">t_u</span> . A similar argument implies that the fork  <span class="math">F_x</span>  has a unique vertex of depth depth(u): namely, u itself. In the presence of another vertex u' (of  <span class="math">F_x</span> ) with depth depth(u), &quot;redirecting&quot;  <span class="math">t_1</span>  through u' (as in the argument above) would likewise result in a fork with a larger slot divergence. To see this, notice that  <span class="math">\\ell(u&#x27;)</span>  must be strictly less than  <span class="math">\\ell(u)</span>  since  <span class="math">\\ell(u)</span>  is an honest slot (which means u is the only vertex at that slot). Thus  <span class="math">\\ell(\\cdot)</span>  would indeed be increasing along this new tine (resulting from redirecting  <span class="math">t_1</span> ). As  <span class="math">\\alpha</span>  is the last index of the string x, this additionally implies that  <span class="math">F_x</span>  has no vertices of depth exceeding depth(u). Let  <span class="math">t_u \\in F_x</span>  be the tine with  <span class="math">\\ell(t_u) = \\alpha</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-2&quot;&gt;&lt;/span&gt;The honest tine
<span class="math">$t_u</span>$
is the unique longest tine in  <span class="math">F_x</span> . (6)</p>

    <p class="text-gray-300"><strong>Identifying</strong> ğ‘¦<strong>.</strong> Let ğ›½ denote the smallest honest index of ğ‘¤ for which ğ›½ â‰¥ ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ), with the convention that if there is no such index we dene ğ›½ = ğ‘‡ + 1. Observe that ğ›½ âˆ’ 1 â‰¥ ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ). (If ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) is an honest slot then ğ›½ = ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) but ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) &lt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ). The case ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) = ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) is possible if ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) is an adversarial slot; but then ğ›½ &gt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ).) These indices, ğ›¼ and ğ›½, distinguish the substrings ğ‘¦ = ğ‘¤ğ›¼+1 â€¦ ğ‘¤ğ›½âˆ’1 and ğ‘§ = ğ‘¤&lt;sup&gt;ğ›½&lt;/sup&gt; â€¦ ğ‘¤ğ‘‡; we will focus on ğ‘¦ in the remainder of the proof. Since the function ğ“(â‹…) is strictly increasing along any tine, observe that</p>

    <p class="text-gray-300"><span class="math">$|y|=\\beta-\\alpha-1\\geq \\ell(t_1)-\\ell(u)\\geq k+1\\,.</span>$</p>

    <p class="text-gray-300">Hence ğ‘¦ has the desired length and it suces to establish that it is forkable. We can extract from ğ¹ a balanced fork (for ğ‘¦) in two steps: (i.) we subject the fork ğ¹ to some minor restructuring to ensure that all &quot;long&quot; tines pass through ğ‘¢; (ii.) we construct a at fork by treating the vertex ğ‘¢ as the root of a portion of the subtree of ğ¹ labeled with the indices of ğ‘¦. At the conclusion of the construction, the segments of the two tines ğ‘¡&lt;sup&gt;1&lt;/sup&gt; and ğ‘¡&lt;sup&gt;2&lt;/sup&gt; will yield the required &quot;long, disjoint, equal-length&quot; tines satisfying the denition of a balanced fork.</p>

    <p class="text-gray-300"><strong>Honest indices in</strong> ğ‘¥ğ‘¦ <strong>have low depths.</strong> The minimality assumption <a href="#page-14-1">(5)</a> implies that any honest index â„ for which â„ &lt; ğ›½ has depth no more than min(length(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ), length(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; )): specically,</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;
<span class="math">$h &lt; \\beta \\implies \\mathbf{d}(h) \\le \\min(\\operatorname{length}(t_1), \\operatorname{length}(t_2)).</span>$
(7)</p>

    <p class="text-gray-300">To see this, consider an honest index â„, â„ &lt; ğ›½ and a tine ğ‘¡&lt;sup&gt;â„&lt;/sup&gt; for which ğ“(ğ‘¡â„) = â„. Recall that ğ‘¡&lt;sup&gt;1&lt;/sup&gt; and ğ‘¡&lt;sup&gt;2&lt;/sup&gt; are viable and that â„ &lt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ). (If ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) is honest, it is obvious. Otherwise, â„ &lt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) &lt; ğ›½ since ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) is adversarial.) As ğ‘¡&lt;sup&gt;2&lt;/sup&gt; is viable, it follows immediately that ğ(â„) = length(ğ‘¡â„) â‰¤ length(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ). Similarly, if â„ â‰¤ ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) then ğ(â„) â‰¤ length(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) since ğ‘¡&lt;sup&gt;1&lt;/sup&gt; is viable as well. The remaining case, i.e., when ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) &lt; â„ &lt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ), can be ruled out by the argument below.</p>

    <p class="text-gray-300"><strong>There is no honest index between</strong> ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) <strong>and</strong> ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; )<strong>.</strong> We claim that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;There is no honest index
<span class="math">$h</span>$
satisfying  <span class="math">\\ell(t_1) &lt; h &lt; \\ell(t_2)</span> . (8)</p>

    <p class="text-gray-300">The claim above is trivially true if ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) = ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ). Otherwise, suppose (toward a contradiction) that â„ is an honest index satisfying ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) &lt; â„ &lt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ). Let ğ‘¡&lt;sup&gt;â„&lt;/sup&gt; be the (honest) tine at slot â„. The tine-pair (ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡â„) may or may not be in ğ´. We will show that both cases lead to contradictions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡â„) is in ğ´ and ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âˆ© ğ‘¡â„) â‰¤ ğ“(ğ‘¢), divğ—Œğ—…ğ—ˆğ—(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡â„) is at least divğ—Œğ—…ğ—ˆğ—(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡2 ). In fact, due to <a href="#page-14-0">(4)</a>, this inequality must be an equality. However, the assumption ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) &lt; â„ &lt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) contradicts <a href="#page-14-1">(5)</a>.</li>
      <li>If (ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡â„) is in ğ´ and ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; âˆ© ğ‘¡â„) &gt; ğ“(ğ‘¢), it follows that divğ—Œğ—…ğ—ˆğ—(ğ‘¡â„, ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) &gt; divğ—Œğ—…ğ—ˆğ—(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡2 ). As the latter quantity is at least ğ‘˜ + 1, (ğ‘¡â„, ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) must be in ğ´. The preceding inequality, however, contradicts <a href="#page-14-0">(4)</a>.</li>
      <li>If (ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡â„) âˆ‰ ğ´, divğ—Œğ—…ğ—ˆğ—(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡â„) is at most ğ‘˜. As divğ—Œğ—…ğ—ˆğ—(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡2 ) is at least ğ‘˜ + 1, ğ‘¡&lt;sup&gt;â„&lt;/sup&gt; and ğ‘¡&lt;sup&gt;1&lt;/sup&gt; must share a vertex after slot ğ“(ğ‘¢). Since ğ“(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; ) &lt; â„ &lt; ğ“(ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) by assumption, divğ—Œğ—…ğ—ˆğ—(ğ‘¡â„, ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) &gt; divğ—Œğ—…ğ—ˆğ—(ğ‘¡&lt;sup&gt;1&lt;/sup&gt; , ğ‘¡2 ) â‰¥ ğ‘˜ + 1 and, as a result, (ğ‘¡â„, ğ‘¡&lt;sup&gt;2&lt;/sup&gt; ) âˆˆ ğ´. However, the preceding strict inequality violates condition <a href="#page-14-0">(4)</a>.</li>
    </ul>

    <p class="text-gray-300"><strong>A fork</strong> ğ¹ âŠ³ğ‘¢âŠ² <strong>where all long tines go through</strong> ğ‘¢<strong>.</strong> In light of the remarks above, we observe that the fork ğ¹ may be &quot;pinched&quot; at ğ‘¢ to yield an essentially identical fork ğ¹ âŠ³ğ‘¢âŠ² âŠ¢ ğ‘¤ with the exception that all tines of length exceeding depth(ğ‘¢) pass through the vertex ğ‘¢. Specically, the fork ğ¹ âŠ³ğ‘¢âŠ² âŠ¢ ğ‘¤ is dened to be the graph obtained from ğ¹ by changing every edge of ğ¹ directed towards a vertex of depth depth(ğ‘¢) + 1 so that it originates from ğ‘¢. To see that the resulting tree is a well-dened fork, it suces to check that ğ“(â‹…) is still increasing along all tines of ğ¹ âŠ³ğ‘¢âŠ². For this purpose, consider the eect of this pinching on an individual tine ğ‘¡ terminating at a particular vertex ğ‘£â€”it is replaced with a tine ğ‘¡ âŠ³ğ‘¢âŠ² dened so that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If length(ğ‘¡) â‰¤ depth(ğ‘¢), the tine ğ‘¡ is unchanged: ğ‘¡ âŠ³ğ‘¢âŠ² = ğ‘¡.</li>
      <li>Otherwise, length(ğ‘¡) &gt; depth(ğ‘¢) and ğ‘¡ has a vertex ğ‘£ of depth depth(ğ‘¢) + 1; note that ğ“(ğ‘£) &gt; ğ“(ğ‘¢) because ğ¹&lt;sup&gt;ğ‘¥&lt;/sup&gt; contains no vertices of depth exceeding depth(ğ‘¢). Then ğ‘¡ âŠ³ğ‘¢âŠ² is dened to be the path given by the tine terminating at ğ‘¢, a (new) edge from ğ‘¢ to ğ‘£, and the sux of ğ‘¡ beginning at ğ‘§. (As ğ“(ğ‘£) &gt; ğ“(ğ‘¢) this has the increasing label property.)</li>
    </ul>

    <p class="text-gray-300">Thus the tree ğ¹ âŠ³ğ‘¢âŠ² is a legal fork on the same vertex set; note that the depths of vertices in ğ¹ and ğ¹ âŠ³ğ‘¢âŠ² are identical. Constructing a shallow fork  <span class="math">F_y \\vdash y</span> . By excising the tree rooted at u from this pinched fork  <span class="math">F^{\\triangleright u \\triangleleft}</span> , we may extract a fork for the string  <span class="math">w_{\\alpha+1} \\dots w_T</span> . Specifically, consider the induced subgraph  <span class="math">F^{u \\triangleleft}</span>  of  <span class="math">F^{\\triangleright u \\triangleleft}</span>  given by the vertices  <span class="math">\\{u\\} \\cup \\{v \\mid \\text{depth}(v) &gt; \\text{depth}(u)\\}</span> . By treating u as a root vertex and suitably defining the labels  <span class="math">\\ell^{u \\triangleleft}</span>  of  <span class="math">F^{u \\triangleleft}</span>  so that  <span class="math">\\ell^{u \\triangleleft}(v) = \\ell(v) - \\ell(u)</span> , this subgraph has the defining properties of a fork for  <span class="math">w_{\\alpha+1} \\dots w_T</span> . In particular, considering that  <span class="math">\\alpha</span>  is honest it follows that each honest index  <span class="math">h &gt; \\alpha</span>  has depth  <span class="math">\\mathbf{d}(h) &gt; \\text{length}(u)</span>  and hence h labels a vertex in  <span class="math">F^{u \\triangleleft}</span> . For a tine t of  <span class="math">F^{\\triangleright u \\triangleleft}</span> , we let  <span class="math">t^{u \\triangleleft}</span>  denote the suffix of this tine beginning at u, which forms a tine in  <span class="math">F^{u \\triangleleft}</span> . (If length(t) t depth(t), we define  <span class="math">t^{u \\triangleleft}</span>  to consist solely of the vertex t.) Note that  <span class="math">t_1^{u \\triangleleft}</span>  and  <span class="math">t_2^{u \\triangleleft}</span>  share no edges in the fork t is a share t and t is a share t in the fork t in the fork t is a share t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the fork t in the form t in the fork t in the fork t in the fork t in the fork t in the form t in the fork t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in the form t in</p>

    <p class="text-gray-300">Finally, let  <span class="math">F_y</span>  denote the subtree obtained from  <span class="math">F^{u\\triangleleft}</span>  as the union of all tines  <span class="math">t^{u\\triangleleft}</span>  of  <span class="math">F^{u\\triangleleft}</span>  so that all labels of  <span class="math">t^{u\\triangleleft}</span>  are drawn from y (as it appears as a prefix of  <span class="math">w_{\\alpha+1} \\dots w_T</span> ), and</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{length}(t^{u \\triangleleft}) \\le \\max_{\\substack{h \\le |y| \\\\ h \\text{ honest}}} \\mathbf{d}(h). \\tag{9}</span>$</p>

    <p class="text-gray-300">It is immediate that  <span class="math">F_v \\vdash y</span> .</p>

    <p class="text-gray-300"><strong>Two longest viable tines in</strong>  <span class="math">F_y</span> . Consider the tines  <span class="math">t_1^{u \\lhd}</span>  and  <span class="math">t_2^{u \\lhd}</span> . As mentioned above, they share no edges in  <span class="math">F^{u \\lhd}</span>  and hence the prefixes  <span class="math">\\check{t_1}</span>  and  <span class="math">\\check{t_2}</span>  (of  <span class="math">t_1^{u \\lhd}</span>  and  <span class="math">t_2^{u \\lhd}</span> ) appearing in  <span class="math">F_y</span>  share no edges. We wish to show that these prefixes have the maximal length in  <span class="math">F_y</span> , making  <span class="math">F_y</span>  balanced, as desired. Let h be the largest honest index in y. Since the lengths of the tines in  <span class="math">F_y</span>  are at most  <span class="math">\\mathbf{d}(h)</span> , it suffices to show that the lengths of  <span class="math">\\check{t_i}</span> ,  <span class="math">i \\in \\{1, 2\\}</span>  is at least  <span class="math">\\mathbf{d}(h)</span> .</p>

    <p class="text-gray-300">This is immediate for the tine  <span class="math">\\check{t}_1</span>  since all labels of  <span class="math">t_1^{u \\triangleleft}</span>  are drawn from y and, considering (7), its depth is at least that of all relevant honest vertices. As for  <span class="math">\\check{t}_2</span> , observe that if  <span class="math">\\ell(t_2)</span>  is not honest then  <span class="math">\\beta &gt; \\ell(t_2)</span>  so that, as with  <span class="math">\\check{t}_1</span> , the tine  <span class="math">\\check{t}_2</span>  is labeled by y so that the same argument, relying on (7), ensures that the length( <span class="math">\\check{t}_2</span> ) is at least the depth of all relevant honest vertices. If  <span class="math">\\ell(t_2)</span>  is honest,  <span class="math">\\beta = \\ell(t_2)</span> , and the terminal vertex of  <span class="math">t_2^{u \\triangleleft}</span>  does not appear in  <span class="math">F_y</span>  (as  <span class="math">\\ell(t_2^{u \\triangleleft})</span> ) falls outside y). In this case, however, length( <span class="math">t_2^{u \\triangleleft}</span> ) &gt;  <span class="math">\\mathbf{d}(h)</span>  for any honest index h of h. It follows that length(h), which equals length(h) â€“ 1, is at least the depth of any honest index of h, as desired. Thus we have proved</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\check{t}_1</span>$
and  <span class="math">\\check{t}_2</span>  are two maximally long viable tines in  <span class="math">F_v \\vdash y</span> . (10)</p>

    <p class="text-gray-300"><strong>Constructing a flat fork</strong>  <span class="math">\\tilde{F}_y \\vdash y</span> . Let us identify the fork prefix  <span class="math">\\tilde{F}_y \\sqsubseteq F_y</span>  which is either identical to  <span class="math">F_y</span>  or differs from  <span class="math">F_y</span>  in only one of the tines  <span class="math">\\check{t}_1, \\check{t}_2</span> . In particular, if length( <span class="math">\\check{t}_1</span> ) = length( <span class="math">\\check{t}_2</span> ), we set  <span class="math">\\tilde{F}_y = F_y</span> . Otherwise, let  <span class="math">\\check{t}_a</span>  be the longer of the two tines  <span class="math">\\check{t}_1, \\check{t}_2</span> ; let  <span class="math">\\check{t}_b</span>  be the shorter one. We modify  <span class="math">F_y</span>  by deleting some trailing adversarial nodes from  <span class="math">\\check{t}_a</span>  until it has the same length as  <span class="math">\\check{t}_b</span> ; we set  <span class="math">\\tilde{F}_y</span>  as the resulting fork and, in addition, set  <span class="math">\\check{t}_b = \\check{t}_b</span>  and  <span class="math">\\check{t}_a</span>  as the tine after trimming  <span class="math">\\check{t}_a</span> .</p>

    <p class="text-gray-300">We claim that  <span class="math">\\tilde{F}_y</span>  is balanced. The claim is obvious if length( <span class="math">\\check{t}_1</span> ) = length( <span class="math">\\check{t}_2</span> ). Otherwise, thanks to (10), it remains to show that the longer tine,  <span class="math">\\check{t}_a</span> , has sufficiently many trailing adversarial nodes which, if deleted, yields length( <span class="math">\\tilde{t}_1</span> ) = length( <span class="math">\\tilde{t}_2</span> ). To that end, let  <span class="math">h_i</span>  be the index of the last honest vertex on  <span class="math">\\check{t}_i \\in F_y</span> ,  <span class="math">i \\in \\{1, 2\\}</span> .</p>

    <p class="text-gray-300">Suppose length( <span class="math">\\check{t}_2</span> ) &gt; length( <span class="math">\\check{t}_1</span> ). By (8), we also have length( <span class="math">\\check{t}_1</span> )  <span class="math">\\geq \\mathbf{d}(h_2)</span>  and hence we can trim some of the trailing adversarial nodes from  <span class="math">\\check{t}_2</span>  to get the tine  <span class="math">\\tilde{t}_2</span>  whose length is the same as that of  <span class="math">\\check{t}_1</span> . Otherwise, suppose length( <span class="math">\\check{t}_1</span> ) &gt; length( <span class="math">\\check{t}_2</span> ). Since  <span class="math">t_2</span>  is a viable tine in F, we also have length( <span class="math">\\check{t}_2</span> )  <span class="math">\\geq \\mathbf{d}(h_1)</span> . Thus we can trim some of the trailing adversarial nodes from  <span class="math">\\check{t}_1</span>  to have a tine  <span class="math">\\tilde{t}_1</span>  whose length is the same as that of  <span class="math">\\check{t}_2</span> . In any case, the quantity min(length( <span class="math">\\check{t}_1</span> ), length( <span class="math">\\check{t}_2</span> )) remains the same as min(length( <span class="math">\\check{t}_1</span> ), length( <span class="math">\\check{t}_2</span> )). Thus the fork  <span class="math">\\check{F}_y</span>  has at least two tines,  <span class="math">\\check{t}_1</span>  and  <span class="math">\\check{t}_2</span> , that achieve the maximum length of all tines in  <span class="math">\\check{F}_y</span> ; hence  <span class="math">\\check{F}_y</span>  is balanced.</p>

    <p class="text-gray-300">An x-balanced fork  <span class="math">\\hat{F} \\sqsubseteq F</span> . Let us identify the root of the fork  <span class="math">\\tilde{F}_y</span>  with the vertex u of  <span class="math">F_x</span>  and let  <span class="math">\\hat{F}</span>  be the resulting graph (after &quot;gluing&quot; the root of  <span class="math">\\tilde{F}_y</span>  to u). By (6), it is easy to see that the fork  <span class="math">\\hat{F} \\sqsubseteq F</span>  is indeed a valid fork on the string xy. Moreover,  <span class="math">\\hat{F}</span>  is x-balanced since  <span class="math">\\tilde{F}_y</span>  is balanced. The claim in Theorem 3 follows immediately since  <span class="math">|y| \\ge k + 1</span> .</p>

    <h2 id="sec-12" class="text-2xl font-bold">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;<strong>5 A simple recursive formulation of relative margin</strong></h2>

    <p class="text-gray-300">A signicant nding of Kiayias et al. <a href="#page-32-2">[13]</a> is that the margin of a characteristic string ğœ‡(ğ‘¤)â€”the maximum value of a quantity taken over a (typically) exponentially-large family of forksâ€”can be given a simple, mutually recursive formulation with the associated quantity of reach ğœŒ(ğ‘¤). Specically, they prove the following lemma.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-3&quot;&gt;&lt;/span&gt;<strong>Lemma 2</strong> (<a href="#page-32-2">[13,</a> Lemma 4.19])<strong>.</strong> ğœŒ(ğœ€) = 0 <em>where</em> ğœ€ <em>is the empty string, and, for all nonempty strings</em> ğ‘¤ âˆˆ {0, 1}&lt;sup&gt;âˆ—&lt;/sup&gt; <em>,</em></p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-6&quot;&gt;&lt;/span&gt;
<span class="math">$\\rho(w1) = \\rho(w) + 1, \\quad and \\quad \\rho(w0) = \\begin{cases} 0 &amp; \\text{if } \\rho(w) = 0, \\\\ \\rho(w) - 1 &amp; \\text{otherwise.} \\end{cases}</span>$
(11)</p>

    <p class="text-gray-300"><em>Furthermore, margin satises the mutually recursive relationship</em> ğœ‡(ğœ€) = 0 <em>and for all</em> ğ‘¤ âˆˆ {0, 1}&lt;sup&gt;âˆ—&lt;/sup&gt; <em>,</em></p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-5&quot;&gt;&lt;/span&gt;
<span class="math">$\\mu(w1) = \\mu(w) + 1</span>$
, and  <span class="math">\\mu(w0) = \\begin{cases} 0 &amp; \\text{if } \\rho(w) &gt; \\mu(w) = 0, \\\\ \\mu(w) - 1 &amp; \\text{otherwise.} \\end{cases}</span>  (12)</p>

    <p class="text-gray-300"><em>Additionally, there exists a closed fork</em> ğ¹ âŠ¢ ğ‘¤ <em>such that</em> ğœŒ(ğ¹) = ğœŒ(ğ‘¤) <em>and</em> ğœ‡(ğ¹) = ğœ‡(ğ‘¤)<em>.</em></p>

    <p class="text-gray-300">We prove an analogous recursive statement for relative margin, recorded below.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-2&quot;&gt;&lt;/span&gt;<strong>Lemma 3</strong> (Relative margin)<strong>.</strong> <em>Given a xed string</em> ğ‘¥ âˆˆ {0, 1}*<em>,</em> ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğœ€) = ğœŒ(ğ‘¥) <em>where</em> ğœ€ <em>is the empty string, and, for all nonempty strings</em> ğ‘¤ = ğ‘¥ğ‘¦ âˆˆ {0, 1}*,</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-4&quot;&gt;&lt;/span&gt;
<span class="math">$\\mu_{x}(y1) = \\mu_{x}(y) + 1, \\quad and \\quad \\mu_{x}(y0) = \\begin{cases} 0 &amp; \\text{if } \\rho(xy) &gt; \\mu_{x}(y) = 0, \\\\ \\mu_{x}(y) - 1 &amp; \\text{otherwise.} \\end{cases}</span>$
(13)</p>

    <p class="text-gray-300"><em>Additionally, there exists a closed fork</em> ğ¹ âŠ¢ ğ‘¥ğ‘¦ <em>such that</em> ğœŒ(ğ¹) = ğœŒ(ğ‘¥ğ‘¦) <em>and</em> ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ¹) = ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ‘¦)<em>.</em></p>

    <p class="text-gray-300">We delay the proof of Lemma <a href="#page-17-2">3</a> to Section <a href="#page-25-0">7,</a> preferring to immediately focus on the application to settlement times in Section <a href="#page-17-1">6.</a></p>

    <p class="text-gray-300"><strong>Discussion.</strong> The proof of Lemma <a href="#page-17-2">3</a> shares many technical similarities with the proof of Lemma <a href="#page-17-3">2</a> given by Kiayias et al. <a href="#page-32-2">[13]</a>. However, there is an important respect in which the proofs dier. Each of the proofs requires the denition of a particular adversary (which, in eect, constructs a fork achieving the worst case reach and margin guaranteed by the lemma). The adversary constructed by <a href="#page-32-2">[13]</a> can create a balanced fork for ğ‘¤ whenever ğœ‡(ğ‘¤) â‰¥ 0 (i.e., ğ‘¤ is &quot;forkable&quot;). However, the adversary only focuses on the problem of producing disjoint tines over the <em>entire string</em> ğ‘¤ (consistent with the denition of ğœ‡(â‹…)). The &quot;optimal online adversary,&quot; developed in Section <a href="#page-28-0">8,</a> uses a more sophisticated rule for extending chains (tines) of the fork. Notably, this adversary can <em>simultaneously maximize relative margin over all prexes of the string</em>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;<strong>6 General settlement guarantees and proof of main theorems</strong></h2>

    <p class="text-gray-300">With the recursive formulation for relative margin in hand, we study the stochastic process that arises when the characteristic string ğ‘¤ is chosen from a distribution satisfying the ğœ–-martingale condition. Let us write ğ‘¤ = ğ‘¥ğ‘¦ (where the decomposition is arbitrary) and let ğ¸ be the event that the relative margin ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ‘¦) is non-negative. As Fact <a href="#page-13-2">1</a> and Observation <a href="#page-11-1">1</a> point out, this event has a direct bearing on the settlement violation on ğ‘¤.</p>

    <p class="text-gray-300">In this section, we prove two bounds on the probability of the event ğ¸. The rst bound corresponds to the distribution â„¬&lt;sup&gt;ğœ–&lt;/sup&gt; whereas the second bound applies to any distribution that satises the ğœ–-martingale condition. (Recall that the distribution â„¬&lt;sup&gt;ğœ–&lt;/sup&gt; , mentioned in Theorem <a href="#page-9-2">1,</a> satises the ğœ–-martingale condition with equality.) Our exposition in this section culminates in the proofs of our main theorems.</p>

    <p class="text-gray-300">We start with the following theorem which is a direct consequences of these bounds; see Section <a href="#page-18-1">6.1</a> for a proof.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-2&quot;&gt;&lt;/span&gt;<strong>Theorem 4.</strong> Let  <span class="math">T, k \\in \\mathbb{N}</span> . Let  <span class="math">w \\in \\{0, 1\\}^T</span>  be a random variable satisfying the  <span class="math">\\varepsilon</span> -martingale condition. Consider the decomposition w = xy, |y| = k. Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{w=xy}[\\text{there is an }x\\text{-balanced fork for }xy] = \\Pr_{w=xy}[\\mu_{x}(y) \\ge 0] \\le \\exp(-\\Omega(k)).</span>$</p>

    <p class="text-gray-300">(The asymptotic notation hides constants that depend only on  <span class="math">\\epsilon</span> .)</p>

    <p class="text-gray-300">Notice how the final bound does not depend on |x|. Indeed, as we show in Lemma 4, the reach of a Boolean string x drawn from the distribution  <span class="math">\\mathcal{B}_{\\varepsilon}</span>  converges to a fixed exponential distribution as  <span class="math">|x| \\to \\infty</span> . This limiting distribution &quot;stochastically dominates&quot; any distribution that satisfies the  <span class="math">\\varepsilon</span> -martingale condition; see Section 6.2. The following corollary is immediate.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;<strong>Corollary 1.</strong> Let  <span class="math">T, s, k \\in \\mathbb{N}</span> . Let  <span class="math">w \\in \\{0, 1\\}^T</span>  be a random variable satisfying the  <span class="math">\\varepsilon</span> -martingale condition. Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{w} \\begin{bmatrix} \\text{there is a decomposition } w = xyz, \\text{ where} \\\\ |x| = s - 1 \\text{ and } |y| \\ge k, \\text{ so that } \\mu_{x}(y) \\ge 0 \\end{bmatrix} \\le O(1) \\cdot \\exp(-\\Omega(k)). \\tag{14}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Notice that Theorem 4 works for <em>any</em> prefix x of the characteristic string w = xy. Thus we can fix the prefix x with length s-1 and sum the bound in Theorem 4 over all suffixes y with length at least k. This would give an upper bound to the left-hand side of our claim, the bound being  <span class="math">\\sum_{t&gt;k} \\exp(-\\Omega(t)) = O(1) \\cdot \\exp(-\\Omega(k))</span> .</p>

    <p class="text-gray-300">We obtain another imporant corollary by setting |x| = 0 and |y| = n in Theorem 4.</p>

    <p class="text-gray-300"><strong>Corollary 2.</strong> Let  <span class="math">w \\in \\{0,1\\}^n</span>  be a random variable satisfying the  <span class="math">\\epsilon</span> -martingale condition. Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[w \\text{ is forkable}] = \\Pr[\\mu(w) \\ge 0] \\le \\exp(-\\Omega(n)).</span>$</p>

    <p class="text-gray-300">Thus forkable strings are rare where &quot;forkable&quot; is defined in Definition 14. This result significantly strengthens the  <span class="math">\\exp(-\\Omega(\\sqrt{n}))</span>  bound obtained in Theorem 4.13 of [13]. The improvement comes in two respects: first, Corollary 1 improves the exponent from  <span class="math">\\sqrt{n}</span>  to n, and second, the characteristic string is allowed to be drawn from any distribution satisfying the  <span class="math">\\epsilon</span> -martingale condition. For comparison, the characteristic string in Theorem 4.13 of [13] has the distribution  <span class="math">\\mathcal{B}_{\\epsilon}</span> , i.e., the bits were i.i.d. Bernoulli random variables with expectation  <span class="math">(1 - \\epsilon)/2</span> .</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;6.1 Two bounds for non-negative relative margin</h4>

    <p class="text-gray-300">The main ingredients to proving Theorem 4 are two bounds on the event that for a characteristic string xy, the relative margin  <span class="math">\\mu_x(y)</span>  is non-negative.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-4&quot;&gt;&lt;/span&gt;<strong>Bound 1.</strong> Let  <span class="math">x \\in \\{0,1\\}^m</span>  and  <span class="math">y \\in \\{0,1\\}^k</span>  be independent random variables, each chosen according to  <span class="math">\\mathcal{B}_{\\varepsilon}</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mu_x(y) \\ge 0] \\le \\exp(-\\epsilon^3 (1 - O(\\epsilon))k/2)</span>$
.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-3&quot;&gt;&lt;/span&gt;<strong>Bound 2.</strong> Let  <span class="math">x \\in \\{0,1\\}^m</span>  and  <span class="math">y \\in \\{0,1\\}^k</span>  be random variables (jointly) satisfying the  <span class="math">\\epsilon</span> -martingale condition with respect to the ordering  <span class="math">x_1, \\dots, x_m, y_1, \\dots, y_k</span> . Let  <span class="math">x&#x27; \\in \\{0,1\\}^m</span>  and  <span class="math">y&#x27; \\in \\{0,1\\}^k</span>  be independent random variables, each chosen independently according to  <span class="math">\\mathcal{B}_{\\epsilon}</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mu_x(y) \\ge 0] \\le \\Pr[\\mu_{x&#x27;}(y&#x27;) \\ge 0] \\le \\exp(-\\epsilon^3 (1 - O(\\epsilon))k/2).</span>$</p>

    <p class="text-gray-300"><strong>Proof of Theorem 4.</strong> The equality is Fact 1 and the inequality is Bound 2.  <span class="math">\\Box</span></p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;6.2 A stochastically dominant prefix distribution</h4>

    <p class="text-gray-300">Stochastic dominance plays an important role in the arguments below. First of all, we observe that the distribution  <span class="math">\\mathcal{B}_{\\varepsilon}</span>  stochastically dominates any distribution satisfying the  <span class="math">\\varepsilon</span> -martingale condition; this yields the first inequality in Theorem 1. A more delicate application of stochastic dominance is used in order to achieving bounds, such as those of Section 6.1, that are independent of the length of x. This follows from the fact that reach( <span class="math">\\mathcal{B}_{\\varepsilon}</span> ) converges to a particular, dominant distribution as its argument increases in length.</p>

    <p class="text-gray-300">For notational convenience, we denote the probability distribution associated with a random variable using uppercase script letters; for example, the distribution of a random variable R is denoted by  <span class="math">\\mathcal{R}</span> . This usage should be clear from the context.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-3&quot;&gt;&lt;/span&gt;<strong>Definition 15</strong> (Monotonicity and stochastic dominance). Let  <span class="math">\\Omega</span>  be a set endowed with a partial order  <span class="math">\\leq</span> . A subset  <span class="math">A \\subset \\Omega</span>  is monotone if for all  <span class="math">x \\leq y</span> ,  <span class="math">x \\in A</span>  implies  <span class="math">y \\in A</span> . Let X and Y be random variables taking values in  <span class="math">\\Omega</span> . We say that X stochastically dominates Y, written  <span class="math">Y \\leq X</span> , if  <span class="math">X(A) \\geq \\mathcal{Y}(A)</span>  for all monotone  <span class="math">A \\subseteq \\Omega</span> . As a special case, when  <span class="math">\\Omega = \\mathbb{R}</span> ,  <span class="math">Y \\leq X</span>  if  <span class="math">\\Pr[X \\geq \\Lambda] \\geq \\Pr[Y \\geq \\Lambda]</span>  for every  <span class="math">\\Lambda \\in \\mathbb{R}</span> . We extend this notion to probability distributions in the natural way.</p>

    <p class="text-gray-300">Observe that for any non-decreasing function u defined on  <span class="math">\\Omega</span> ,  <span class="math">Y \\leq X</span>  implies  <span class="math">u(Y) \\leq u(X)</span> . Finally, we note that for real-valued random variables X, Y, and Z, if  <span class="math">Y \\leq X</span>  and Z is independent of both X and Y, then  <span class="math">Z + Y \\leq Z + X</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;<strong>Lemma 4.</strong> Suppose  <span class="math">W = (W_1, ..., W_n) \\in \\{0,1\\}^n</span>  satisfies the  <span class="math">\\epsilon</span> -martingale condition. Let  <span class="math">\\epsilon \\in (0,1)</span>  and  <span class="math">B = (B_1, ..., B_n) \\in \\{0,1\\}^n</span>  where each  <span class="math">B_i</span>  is independent with expectation  <span class="math">(1-\\epsilon)/2</span> . Let  <span class="math">R_\\infty \\in \\{0,1,...\\}</span>  be a random variable whose distribution  <span class="math">\\mathcal{R}_\\infty</span>  is defined as</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathcal{R}_{\\infty}(k) = \\Pr[R_{\\infty} = k] \\triangleq \\left(\\frac{2\\epsilon}{1+\\epsilon}\\right) \\cdot \\left(\\frac{1-\\epsilon}{1+\\epsilon}\\right)^{k} \\qquad \\text{for } k = 0, 1, 2, \\dots</span>$
(15)</p>

    <p class="text-gray-300">Then  <span class="math">\\rho(W) \\leq \\rho(B) \\leq R_{\\infty}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We begin by observing that B stochastically dominates W. As a matter of notation, for any fixed values  <span class="math">w_1, \\dots, w_k \\in \\{0, 1\\}^k</span> , let</p>

    <p class="text-gray-300"><span class="math">$\\theta[w_1, ..., w_k] = \\Pr[W_{k+1} = 1 \\mid W_i = w_i, \\text{ for } i \\le k] \\le (1 - \\epsilon)/2</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\theta[\\varepsilon] = \\Pr[W_1 = 1]</span>  where  <span class="math">\\varepsilon</span>  is the empty string. Then consider n uniform and independent real numbers  <span class="math">(A_1, \\dots, A_n)</span> , each taking a value in the unit interval [0, 1]; we use these random variables to construct a monotone coupling between W and B. Specifically, define  <span class="math">\\beta : [0, 1]^n \\to \\{0, 1\\}^n</span>  by the rule  <span class="math">\\beta(\\alpha_1, \\dots, \\alpha_n) = (b_1, \\dots, b_n)</span>  where</p>

    <p class="text-gray-300"><span class="math">$b_t = \\begin{cases} 1 &amp; \\text{if } \\alpha_t \\le (1 - \\epsilon)/2, \\\\ 0 &amp; \\text{if } \\alpha_t &gt; (1 - \\epsilon)/2, \\end{cases}</span>$</p>

    <p class="text-gray-300">and define  <span class="math">B=(B_1,\\ldots,B_n)=\\beta(A_1,\\ldots,A_n)</span> ; these  <span class="math">B_i</span> s are independent zero-one Bernoulli random variables with expectation  <span class="math">(1-\\epsilon)/2</span> . Likewise define the function  <span class="math">\\omega:[0,1]^n\\to\\{0,1\\}^n</span>  so that  <span class="math">\\omega(\\alpha_1,\\ldots,\\alpha_n)=(w_1,\\ldots,w_n)</span>  where each  <span class="math">w_t</span>  is assigned by the iterative rule</p>

    <p class="text-gray-300"><span class="math">$w_{t+1} = \\begin{cases} 1 &amp; \\text{if } \\alpha \\leq \\theta[w_1, \\dots, w_t], \\\\ 0 &amp; \\text{if } \\alpha &gt; \\theta[w_1, \\dots, w_t], \\end{cases}</span>$</p>

    <p class="text-gray-300">and observe that the probability law of  <span class="math">\\omega(A_1, \\dots, A_n)</span>  is precisely that of  <span class="math">W = (W_1, \\dots, W_n)</span> . For convenience, we simply identify the random variable W with  <span class="math">\\omega(A_1, \\dots, A_n)</span> . Note that for any  <span class="math">\\alpha = (\\alpha_1, \\dots, \\alpha_n)</span>  and for each i, the ith coordinates of  <span class="math">\\beta(\\alpha)</span>  and  <span class="math">\\omega(\\alpha)</span>  satisfy  <span class="math">\\omega(\\alpha)_i \\leq \\beta(\\alpha)_i</span>  (which is to say that  <span class="math">W_i \\leq B_i</span>  with probability 1). But this is equivalent to saying  <span class="math">W \\leq B</span> . (See [14, Lemma 22.5].) Now consider the following partial order  <span class="math">\\leq</span>  on the n-bit Boolean strings: for  <span class="math">x, y \\in \\{0, 1\\}^n</span> , we write  <span class="math">x \\leq y</span>  if and only if  <span class="math">x_i = 1</span>  implies  <span class="math">y_i = 1, i \\in [n]</span> . Since</p>

    <p class="text-gray-300"><span class="math">\\rho</span>  is non-decreasing with respect to this partial order, we have  <span class="math">\\rho(\\omega(\\alpha)) \\leq \\rho(\\beta(\\alpha))</span>  with probability 1 and hence  <span class="math">\\rho(W) \\leq \\rho(B)</span>  as well.</p>

    <p class="text-gray-300">To complete the proof, we now establish that  <span class="math">\\rho(B) \\leq R_{\\infty}</span> . We remark that the random variables  <span class="math">\\rho(B)</span>  (and  <span class="math">R_{\\infty}</span> ) have an immediate interpretation in terms of the Markov chain corresponding to a biased random walk on  <span class="math">\\mathbb{Z}</span>  with a &quot;reflecting boundary&quot; at -1. Specifically, consider the Markov chain on  <span class="math">\\{0, 1, ...\\}</span>  given by the transition diagram</p>

    <p class="text-gray-300">where edges pointing right have probability  <span class="math">(1 - \\varepsilon)/2</span>  and edges pointing leftâ€”including the loop at 0â€”have probability  <span class="math">(1 + \\varepsilon)/2</span> . Examining the recursive description of  <span class="math">\\rho(w)</span> , it is easy to confirm that the random variable  <span class="math">\\rho(B_1, \\dots, B_n)</span>  is precisely given by the result of evolving the Markov chain above for n steps with all probability initially placed at 0. It is further easy to confirm that the distribution given by (15) above is stationary for this chain.</p>

    <p class="text-gray-300">To establish stochastic dominance, it is convenient to work with the underlying distributions and consider walks of varying lengths: let  <span class="math">\\mathcal{R}_n: \\mathbb{Z} \\to \\mathbb{R}</span>  denote the probability distribution given by  <span class="math">\\rho(B_1, \\dots, B_n)</span> ; likewise define  <span class="math">\\mathcal{R}_{\\infty}</span> . For a distribution  <span class="math">\\mathcal{R}</span>  on  <span class="math">\\mathbb{Z}</span> , we define  <span class="math">[\\mathcal{R}]_0</span>  to denote the probability distribution obtained by shifting all probability mass on negative numbers to zero; that is, for  <span class="math">x \\in \\mathbb{Z}</span> ,</p>

    <p class="text-gray-300"><span class="math">$[\\mathcal{R}]_0(x) = \\begin{cases} \\mathcal{R}(x) &amp; \\text{if } x &gt; 0, \\\\ \\sum_{t \\le 0} \\mathcal{R}(t) &amp; \\text{if } x = 0, \\\\ 0 &amp; \\text{if } x &lt; 0. \\end{cases}</span>$</p>

    <p class="text-gray-300">We observe that if  <span class="math">A \\leq C</span>  then  <span class="math">[A]_0 \\leq [C]_0</span>  for any distributions A and C on  <span class="math">\\mathbb{Z}</span> . It will also be convenient to introduce the shift operators: for a distribution  <span class="math">\\mathcal{R}: \\mathbb{Z} \\to \\mathbb{R}</span>  and an integer k, we define  <span class="math">S^k \\mathcal{R}</span>  to be the distribution given by the rule  <span class="math">S^k \\mathcal{R}(x) = \\mathcal{R}(x-k)</span> . With these operators in place, we may write</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_t = \\left(\\frac{1-\\epsilon}{2}\\right) S^1 \\mathcal{R}_{t-1} + \\left(\\frac{1+\\epsilon}{2}\\right) \\left[S^{-1} \\mathcal{R}_{t-1}\\right]_0 \\;,</span>$</p>

    <p class="text-gray-300">with the understanding that  <span class="math">\\mathcal{R}_0</span>  is the distribution placing unit probability at 0. The proof now proceeds by induction. It is clear that  <span class="math">\\mathcal{R}_0 \\leq \\mathcal{R}_{\\infty}</span> . Assuming that  <span class="math">\\mathcal{R}_n \\leq \\mathcal{R}_{\\infty}</span> , we note that for any k</p>

    <p class="text-gray-300"><span class="math">$S^k \\mathcal{R}_n \\leq S^k \\mathcal{R}_\\infty</span>$
and, additionally, that  <span class="math">[S^{-1} \\mathcal{R}_n]_0 \\leq [S^{-1} \\mathcal{R}_\\infty]_0</span> .</p>

    <p class="text-gray-300">Finally, it is clear that stochastic dominance respects convex combinations, in the sense that if  <span class="math">A_1 \\leq C_1</span>  and  <span class="math">A_2 \\leq C_2</span>  then  <span class="math">\\lambda A_1 + (1 - \\lambda)A_2 \\leq \\lambda C_1 + (1 - \\lambda)C_2</span>  (for  <span class="math">0 \\leq \\lambda \\leq 1</span> ). We conclude that</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_{t+1} = \\left(\\frac{1-\\epsilon}{2}\\right)S^1\\mathcal{R}_t + \\left(\\frac{1+\\epsilon}{2}\\right)\\left[S^{-1}\\mathcal{R}_t\\right]_0 \\leq \\left(\\frac{1-\\epsilon}{2}\\right)S^1\\mathcal{R}_\\infty + \\left(\\frac{1+\\epsilon}{2}\\right)\\left[S^{-1}\\mathcal{R}_\\infty\\right]_0 \\;.</span>$</p>

    <p class="text-gray-300">By inspection, the right-hand side equals  <span class="math">\\mathcal{R}_{\\infty}</span> , as desired. Hence  <span class="math">\\rho(B) \\leq R_{\\infty}</span> .</p>

    <p class="text-gray-300"><strong>Remark.</strong> In fact, the random variable  <span class="math">\\rho(B)</span>  actually converges to  <span class="math">R_{\\infty}</span>  as  <span class="math">n \\to \\infty</span> . This can be seen, for example, by solving for the stationary distribution of the Markov chain in the proof above. However, we will only require the dominance for our exposition. Importantly, since  <span class="math">\\mu_X(\\varepsilon) = \\rho(x)</span> , and  <span class="math">\\Pr[\\mu_X(y) \\ge 0]</span>  increases monotonically with an increase in  <span class="math">\\Pr[\\mu_X(\\varepsilon) \\ge r]</span>  for any  <span class="math">r \\ge 0</span> , it suffices to take  <span class="math">|x| \\to \\infty</span>  when reasoning about an upper bound on  <span class="math">\\Pr[\\mu_X(y) \\ge 0]</span> .</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">6.3 Proof of Bound 1</h4>

    <p class="text-gray-300">Anticipating the proof, we make a few remarks about generating functions and stochastic dominance. We reserve the term <em>generating function</em> to refer to an &quot;ordinary&quot; generating function which represents a sequence  <span class="math">a_0, a_1, ...</span>  of non-negative real numbers by the formal power series  <span class="math">A(Z) = \\sum_{t=0}^{\\infty} a_t Z^t</span> . When  <span class="math">A(1) = \\sum_t a_t = 1</span>  we say that</p>

    <p class="text-gray-300">the generating function is a <em>probability generating function</em>; in this case, the generating function A can naturally be associated with the integer-valued random variable A for which  <span class="math">\\Pr[A=k]=a_k</span> . If the probability generating functions A and B are associated with the random variables A and B, it is easy to check that  <span class="math">A \\cdot B</span>  is the generating function associated with the convolution A+B (where A and B are assumed to be independent). Translating the notion of stochastic dominance to the setting with generating functions, we say that the generating function A <em>stochastically dominates</em> B if  <span class="math">\\sum_{t \\leq T} a_t \\leq \\sum_{t \\leq T} b_t</span>  for all  <span class="math">T \\geq 0</span> ; we write  <span class="math">B \\leq A</span>  to denote this state of affairs. If  <span class="math">B_1 \\leq A_1</span>  and  <span class="math">B_2 \\leq A_2</span>  then  <span class="math">B_1 \\cdot B_2 \\leq A_1 \\cdot A_2</span>  and  <span class="math">\\alpha B_1 + \\beta B_2 \\leq \\alpha A_1 + \\beta A_2</span>  (for any  <span class="math">\\alpha, \\beta \\geq 0</span> ). Moreover, if  <span class="math">B \\leq A</span>  then it can be checked that  <span class="math">B(C) \\leq A(C)</span>  for any probability generating function C(Z), where we write A(C) to denote the composition A(C(Z)).</p>

    <p class="text-gray-300">Finally, we remark that if A(Z) is a generating function which converges as a function of a complex Z for |Z| &lt; R for some non-negative R, R is called the <em>radius of convergence</em> of A. It follows from [26, Theorem 2.19] that  <span class="math">\\lim_{k\\to\\infty} a_k R^k = 0</span>  and  <span class="math">|a_k| = O(R^{-k})</span> . In addition, if A is a probability generating function associated with the random variable A then it follows that  <span class="math">\\Pr[A \\ge T] = O(R^{-T})</span> .</p>

    <p class="text-gray-300">We define  <span class="math">p = (1 - \\epsilon)/2</span>  and q = 1 - p and as in the proof of Bound 2, consider the independent  <span class="math">\\{0, 1\\}</span> -valued random variables  <span class="math">w_1, w_2, ...</span>  where  <span class="math">\\Pr[w_t = 1] = p</span> . We also define the associated  <span class="math">\\{\\pm 1\\}</span> -valued random variables  <span class="math">W_t = (-1)^{1+w_t}</span> .</p>

    <p class="text-gray-300">Although our actual interest is in the random variable  <span class="math">\\mu_x(y)</span>  from (13) on a characteristic string w = xy, we begin by analyzing the case when |x| = 0.</p>

    <p class="text-gray-300"><strong>Case 1:</strong> x <strong>is the empty string.</strong> In this case, the random variable  <span class="math">\\mu_x(y)</span>  is identical to  <span class="math">\\mu(w)</span>  from (12) with w = y. Our strategy is to study the probability generating function</p>

    <p class="text-gray-300"><span class="math">$L(Z) = \\sum_{t=0}^{\\infty} \\ell_t Z^t</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\ell_t = \\Pr[t \\text{ is the last time } \\mu_t = 0]</span> . Controlling the decay of the coefficients  <span class="math">\\ell_t</span>  suffices to give a bound on the probability that  <span class="math">w_1 \\dots w_k</span>  is forkable because</p>

    <p class="text-gray-300"><span class="math">$\\Pr[w_1 \\dots w_k \\text{ is forkable}] \\le 1 - \\sum_{t=0}^{k-1} \\ell_t = \\sum_{t=k}^{\\infty} \\ell_t.</span>$</p>

    <p class="text-gray-300">It seems challenging to give a closed-form algebraic expression for the generating function L; our approach is to develop a closed-form expression for a probability generating function  <span class="math">\\hat{L} = \\sum_t \\hat{\\ell}_t Z^t</span>  which stochastically dominates L and apply the analytic properties of this closed form to bound the partial sums  <span class="math">\\sum_{t \\geq k} \\hat{\\ell}_k</span> . Observe that if  <span class="math">L \\leq \\hat{L}</span>  then the series  <span class="math">\\hat{L}</span>  gives rise to an upper bound on the probability that  <span class="math">w_1 \\dots w_k</span>  is forkable as  <span class="math">\\sum_{t=k}^{\\infty} \\ell_t \\leq \\sum_{t=k}^{\\infty} \\hat{\\ell}_t</span> . The coupled random variables  <span class="math">\\rho_t</span>  and  <span class="math">\\mu_t</span>  are Markovian in the sense that values  <span class="math">(\\rho_s, \\mu_s)</span>  for  <span class="math">s \\geq t</span>  are entirely</p>

    <p class="text-gray-300">The coupled random variables  <span class="math">\\rho_t</span>  and  <span class="math">\\mu_t</span>  are Markovian in the sense that values  <span class="math">(\\rho_s, \\mu_s)</span>  for  <span class="math">s \\ge t</span>  are entirely determined by  <span class="math">(\\rho_t, \\mu_t)</span>  and the subsequent values  <span class="math">W_{t+1}</span> , ... of the underlying variables  <span class="math">W_t</span> . We organize the sequence  <span class="math">(\\rho_0, \\mu_0)</span> ,  <span class="math">(\\rho_1, \\mu_1)</span> , ... into &quot;epochs&quot; punctuated by those times t for which  <span class="math">\\rho_t = \\mu_t = 0</span> . With this in mind, we define  <span class="math">\\mathsf{M}(Z) = \\sum m_t Z^t</span>  to be the generating function for the first completion of such an epoch, corresponding to the least t &gt; 0 for which  <span class="math">\\rho_t = \\mu_t = 0</span> . As we discuss below,  <span class="math">\\mathsf{M}(Z)</span>  is not a probability generating function, but rather  <span class="math">\\mathsf{M}(1) = 1 - \\varepsilon</span> . It follows that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;
<span class="math">$L(Z) = \\left(1 + (1 - \\epsilon) \\cdot \\frac{\\mathsf{M}(Z)}{\\mathsf{M}(1)} + \\left((1 - \\epsilon) \\cdot \\frac{\\mathsf{M}(Z)}{\\mathsf{M}(1)}\\right)^2 + \\cdots\\right) \\cdot \\epsilon</span>$</p>

    <p class="text-gray-300"><span class="math">$= (1 + \\mathsf{M}(Z) + \\mathsf{M}(Z)^2 + \\cdots) \\cdot \\epsilon</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{\\epsilon}{1 - \\mathsf{M}(Z)}.</span>$
(16)</p>

    <p class="text-gray-300">The expression above represents the following geometric process: before the beginning of an epoch, we &quot;ask&quot; whether the walk is ever going to come back to zero. With probability  <span class="math">\\epsilon</span> , the answer is &quot;no&quot; and we stop the process. Otherwise, i.e., with probability  <span class="math">1 - \\epsilon</span> , we commence an epoch which is guaranteed to finish; then we ask again.</p>

    <p class="text-gray-300">Below we develop an analytic expression for a generating function ğ–¬Ì‚ for which ğ–¬ âª¯ ğ–¬Ì‚ and dene Ì‚ğ–« = ğœ–âˆ•(1 âˆ’ ğ–¬Ì‚ (ğ‘)). We then proceed as outlined above, noting that ğ–« âª¯ Ì‚ğ–« and using the asymptotics of Ì‚ğ–« to upper bound the probability that a string is forkable.</p>

    <p class="text-gray-300">In preparation for dening ğ–¬Ì‚ , we set down two elementary generating functions for the &quot;descent&quot; and &quot;ascent&quot; stopping times. Treating the random variables ğ‘Š&lt;sup&gt;1&lt;/sup&gt; , â€¦ as dening a (negatively) biased random walk, dene ğ–£ to be the generating function for the <em>descent stopping time</em> of the walk; this is the rst time the random walk, starting at 0, visits âˆ’1. The natural recursive formulation of the descent time yields a simple algebraic equation for the descent generating function, ğ–£(ğ‘) = ğ‘ğ‘ + ğ‘ğ‘ğ–£(ğ‘) 2 , and from this we may conclude</p>

    <p class="text-gray-300"><span class="math">$D(Z) = \\frac{1 - \\sqrt{1 - 4pqZ^2}}{2pZ} \\,.</span>$</p>

    <p class="text-gray-300">We likewise consider the generating function ğ– (ğ‘) for the <em>ascent stopping time</em>, associated with the rst time the walk, starting at 0, visits 1: we have ğ– (ğ‘) = ğ‘ğ‘ + ğ‘ğ‘ğ– (ğ‘) 2 and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{A}(Z) = \\frac{1 - \\sqrt{1 - 4pqZ^2}}{2qZ} \\,.</span>$</p>

    <p class="text-gray-300">Note that while ğ–£ is a probability generating function, the generating function ğ–  is not: according to the classical &quot;gambler's ruin&quot; analysis <a href="#page-32-12">[12]</a>, the probability that a negatively-biased random walk starting at 0 ever rises to 1 is exactly ğ‘âˆ•ğ‘; thus ğ– (1) = ğ‘âˆ•ğ‘.</p>

    <p class="text-gray-300">Returning to the generating function ğ–¬ above, we note that an epoch can have one of two &quot;shapes&quot;: in the rst case, the epoch is given by a walk for which ğ‘Š&lt;sup&gt;1&lt;/sup&gt; = 1 followed by a descent (so that ğœŒ returns to zero); in the second case, the epoch is given by a walk for which ğ‘Š&lt;sup&gt;1&lt;/sup&gt; = âˆ’1, followed by an ascent (so that ğœ‡ returns to zero), followed by the eventual return of ğœŒ to 0. Considering that when ğœŒ&lt;sup&gt;ğ‘¡&lt;/sup&gt; &gt; 0 it will return to zero in the future almost surely, it follows that the probability that such a biased random walk will complete an epoch is ğ‘ + ğ‘(ğ‘âˆ•ğ‘) = 2ğ‘ = 1 âˆ’ ğœ–, as mentioned in the discussion of <a href="#page-21-0">(16)</a> above. One technical diculty arising in a complete analysis of ğ–¬ concerns the second case discussed above: while the distribution of the smallest ğ‘¡ &gt; 0 for which ğœ‡&lt;sup&gt;ğ‘¡&lt;/sup&gt; = 0 is proportional to ğ–  above, the distribution of the smallest subsequent time ğ‘¡ â€² for which ğœŒ&lt;sup&gt;ğ‘¡&lt;/sup&gt; â€² = 0 depends on the value ğ‘¡. More specically, the distribution of the return time depends on the value of ğœŒ&lt;sup&gt;ğ‘¡&lt;/sup&gt; . Considering that ğœŒ&lt;sup&gt;ğ‘¡&lt;/sup&gt; â‰¤ ğ‘¡, however, this conditional distribution (of the return time of ğœŒ to zero conditioned on ğ‘¡) is stochastically dominated by ğ–£ ğ‘¡ , the time to descend ğ‘¡ steps. This yields the following generating function ğ–¬Ì‚ which, as described, stochastically dominates ğ–¬:</p>

    <p class="text-gray-300"><span class="math">$\\hat{\\mathsf{M}}(Z) = pZ \\cdot \\mathsf{D}(Z) + qZ \\cdot \\mathsf{D}(Z) \\cdot \\mathsf{A}(Z \\cdot \\mathsf{D}(Z)) \\,.</span>$</p>

    <p class="text-gray-300">It remains to establish a bound on the radius of convergence of Ì‚ğ–«. Recall that if the radius of convergence of Ì‚ğ–« is exp(ğ›¿) it follows that Pr[ğ‘¤&lt;sup&gt;1&lt;/sup&gt; â€¦ ğ‘¤&lt;sup&gt;ğ‘˜&lt;/sup&gt; is forkable] = ğ‘‚(exp(âˆ’ğ›¿ğ‘˜)). A sucient condition for convergence of Ì‚ğ–«(ğ‘§) = ğœ–âˆ•(1 âˆ’ ğ–¬Ì‚ (ğ‘§)) at ğ‘§ is that that all generating functions appearing in the denition of ğ–¬Ì‚ converge at ğ‘§ and that the resulting value ğ–¬Ì‚ (ğ‘§) &lt; 1.</p>

    <p class="text-gray-300">The generating function ğ–£(ğ‘§) (and ğ– (ğ‘§)) converges when the discriminant 1 âˆ’ 4ğ‘ğ‘ğ‘§&lt;sup&gt;2&lt;/sup&gt; is positive; equivalently |ğ‘§| &lt;sup&gt;&amp;&lt;/sup&gt;lt; 1âˆ•âˆš 1 âˆ’ ğœ– 2 or |ğ‘§| &lt; 1 + ğœ– &lt;sup&gt;2&lt;/sup&gt;âˆ•2 + ğ‘‚(ğœ– 4 ). Considering ğ–¬Ì‚ , it remains to determine when the second term, ğ‘ğ‘§ğ·(ğ‘§)ğ– (ğ‘§ğ–£(ğ‘§)), converges; this is likewise determined by positivity of the discriminant, which is to say that</p>

    <p class="text-gray-300"><span class="math">$1 - (1 - \\epsilon^2) \\left( \\frac{1 - \\sqrt{1 - (1 - \\epsilon^2)z^2}}{1 - \\epsilon} \\right)^2 &gt; 0.</span>$</p>

    <p class="text-gray-300">Equivalently,</p>

    <p class="text-gray-300"><span class="math">$|z| &lt; \\sqrt{\\frac{1}{1+\\epsilon} \\left(\\frac{2}{\\sqrt{1-\\epsilon^2}} - \\frac{1}{1+\\epsilon}\\right)} = 1 + \\epsilon^3/2 + O(\\epsilon^4).</span>$</p>

    <p class="text-gray-300">Note that when the series ğ‘ğ‘§ â‹… ğ–£(ğ‘§) converges, it converges to a value less than 1âˆ•2; the same is true of ğ‘ğ‘§ â‹… ğ– (ğ‘§). It follows that for |ğ‘§| = 1 + ğœ– &lt;sup&gt;3&lt;/sup&gt;âˆ•2 + ğ‘‚(ğœ– 4 ), |ğ–¬Ì‚ (ğ‘§)| &lt; 1 and Ì‚ğ–«(ğ‘§) converges, as desired. We conclude that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;
<span class="math">$Pr[w_1 \\dots w_k \\text{ is forkable}] = \\exp(-\\epsilon^3 (1 + O(\\epsilon))k/2). \\tag{17}</span>$</p>

    <p class="text-gray-300"><strong>Case 2:</strong> x <strong>is non-empty.</strong> The relative margin before y begins is  <span class="math">\\mu_x(\\varepsilon)</span> . Recalling that  <span class="math">\\mu_x(\\varepsilon) = \\rho(x)</span>  and conditioning on the event that  <span class="math">\\rho(x) = r</span> , let us define the random variables  <span class="math">\\{\\tilde{\\mu}_t\\}</span>  for  <span class="math">t = 0, 1, 2, \\cdots</span>  as follows:  <span class="math">\\tilde{\\mu}_0 = \\rho(x)</span>  and</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\tilde{\\mu}_t = s] = \\Pr[\\mu_x(y) = s \\mid \\rho(x) = r \\text{ and } |y| = t].</span>$</p>

    <p class="text-gray-300">If the  <span class="math">\\tilde{\\mu}</span>  random walk makes the rth descent at some time t &lt; n, then  <span class="math">\\tilde{\\mu}_t = 0</span>  and the remainder of the walk is identical to an (k-t)-step  <span class="math">\\mu</span>  random walk which we have already analyzed. Hence we investigate the probability generating function</p>

    <p class="text-gray-300"><span class="math">$B_r(Z) = D(Z)^r L(Z)</span>$
with coefficients  <span class="math">b_t^{(r)} := \\Pr[t \\text{ is the last time } \\tilde{\\mu}_t = 0 \\mid \\tilde{\\mu}_0 = r]</span></p>

    <p class="text-gray-300">where  <span class="math">t = 0, 1, 2, \\cdots</span> . Our interest lies in the quantity</p>

    <p class="text-gray-300"><span class="math">$b_t := \\Pr[t \\text{ is the last time } \\tilde{\\mu}_t = 0] = \\sum_{r \\ge 0} b_t^{(r)} \\mathcal{R}_m(r)</span>$
,</p>

    <p class="text-gray-300">where the <em>reach distribution</em>  <span class="math">\\mathcal{R}_m: \\mathbb{Z} \\to [0,1]</span>  associated with the random variable  <span class="math">\\rho(x), |x| = m</span>  is defined as</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-3&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathcal{R}_m(r) = \\Pr_{x:|x|=m} [\\rho(x) = r]. \\tag{18}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">R_m(Z)</span>  be the probability generating function for the distribution  <span class="math">\\mathcal{R}_m</span> . Using Lemma 4 and Definition 15, we deduce that  <span class="math">R_m \\leq R_\\infty</span>  for every  <span class="math">m \\geq 0</span>  since  <span class="math">\\mathcal{R}_m \\leq \\mathcal{R}_\\infty</span> . In addition, it is easy to check from (15) that the probability generating function for  <span class="math">\\mathcal{R}_\\infty</span>  is in fact  <span class="math">R_\\infty(Z) = (1-\\beta)/(1-\\beta Z)</span>  where  <span class="math">\\beta := (1-\\epsilon)/(1+\\epsilon)</span> . Thus the generating function corresponding to the probabilities  <span class="math">\\{b_t\\}_{t=0}^\\infty</span>  is</p>

    <p class="text-gray-300"><span class="math">$B(Z) = \\sum_{t=0}^{\\infty} b_t Z^t = \\sum_{r=0}^{\\infty} \\mathcal{R}_m(r) \\sum_{t=0}^{\\infty} b_t^{(r)} Z^t = \\sum_{r=0}^{\\infty} \\mathcal{R}_m(r) B_r(Z)</span>$</p>

    <p class="text-gray-300"><span class="math">$= L(Z) \\sum_{r=0}^{\\infty} \\mathcal{R}_m(r) D(Z)^r = L(Z) R_m(D(Z)) \\le \\hat{L}(Z) R_{\\infty}(D(Z))</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{(1-\\beta)\\hat{L}(Z)}{1-\\beta D(Z)}.</span>$
(19)</p>

    <p class="text-gray-300">The dominance notation above follows because  <span class="math">L \\leq \\hat{L}</span>  and  <span class="math">R_m \\leq R_{\\infty}</span> .</p>

    <p class="text-gray-300">For B(Z) to converge, we need to check that D(Z) should never converge to  <span class="math">1/\\beta</span> . One can easily check that the radius of convergence of D(Z)â€”which is  <span class="math">1/\\sqrt{1-\\epsilon^2}</span> â€”is strictly less than  <span class="math">1/\\beta</span>  when  <span class="math">\\epsilon &gt; 0</span> . We conclude that B(Z) converges if both D(Z) and L(Z) converge. The radius of convergence of B(Z) would be the smaller of the radii of convergence of D(Z) and L(Z). We already know from the previous analysis that  <span class="math">\\hat{L}(Z)</span>  has the smaller radius of the two; therefore, the bound in (17) applies to the relative margin  <span class="math">\\mu_X(y)</span>  for  <span class="math">|x| \\ge 0</span> .</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-23-2&quot;&gt;&lt;/span&gt;6.4 Proof of Bound 2</h4>

    <p class="text-gray-300">Let  <span class="math">\\epsilon \\in (0,1)</span> ,  <span class="math">W \\in \\{0,1\\}^m</span> ,  <span class="math">W&#x27; \\in \\{0,1\\}^k</span>  where both  <span class="math">(W_1,\\ldots,W_n)</span>  and  <span class="math">(W&#x27;_1,\\ldots,W&#x27;_n)</span>  satisfy the  <span class="math">\\epsilon</span> -martingale condition. Let  <span class="math">B \\in \\{0,1\\}^m</span> ,  <span class="math">B&#x27; \\in \\{0,1\\}^k</span>  where the components of B,B' are independent with expectation  <span class="math">(1-\\epsilon)/2</span> . By Lemma 4,</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;
<span class="math">$W \\le B</span>$
and  <span class="math">W&#x27; \\le B&#x27;</span> . (*)</p>

    <p class="text-gray-300">Let us define the partial order  <span class="math">\\leq</span>  on Boolean strings  <span class="math">\\{0,1\\}^k, k \\in \\mathbb{N}</span>  as follows:  <span class="math">a \\leq b</span>  if and only if for all  <span class="math">i \\in [k]</span> ,  <span class="math">a_i = 1</span>  implies  <span class="math">b_i = 1</span> . Let  <span class="math">\\mu : \\{0,1\\}^k \\to \\mathbb{Z}</span>  be the margin function from Lemma 3. Observe that for Boolean strings a, a', b, b' with |a| = |a'| and |b| = |b'|, (i.)  <span class="math">b \\leq b&#x27;</span>  implies  <span class="math">\\mu_a(b) \\leq \\mu_a(b&#x27;)</span>  and (ii.)  <span class="math">a \\leq a&#x27;</span>  implies  <span class="math">\\mu_a(b) \\leq \\mu_{a&#x27;}(b)</span> . That is,</p>

    <p class="text-gray-300"><span class="math">$\\mu_a(b)</span>$
is non-decreasing in both  <span class="math">a</span>  and  <span class="math">b</span> . (â€ )</p>

    <p class="text-gray-300">Using (*) and (â€ ), it follows that  <span class="math">\\mu_W(W&#x27;) \\prec \\mu_R(B&#x27;)</span> . Writing x = W and y = W', we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mu_x(y) \\ge 0] = \\Pr[\\mu_W(W&#x27;) \\ge 0] \\le \\Pr[\\mu_B(B&#x27;) \\ge 0]</span>$</p>

    <p class="text-gray-300">where the inequality comes from the definition of stochastic dominance. A bound on the right-hand side is obtained in Bound 1.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">In Appendix B, we present a weaker bound on  <span class="math">\\Pr[\\mu_x(y) \\ge 0]</span>  where the sequence  <span class="math">x_1, \\dots, x_m, y_1, \\dots, y_k</span>  satisfies  <span class="math">\\epsilon</span> -martingale conditions. The proof directly uses the properties of the martingale and Azuma's inequality but it does not use a stochastic dominance argument. Although it gives a bound of  <span class="math">3 \\exp\\left(-\\epsilon^4(1-O(\\epsilon))k/64\\right)</span> , the reader might find the proof of independent interest.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;6.5 Proof of main theorems</h4>

    <p class="text-gray-300"><strong>Proof of Theorem 1.</strong> Let us start with the following observation. It allows us to formulate the (s, k)-settlement insecurity of a distribution  <span class="math">\\mathcal{D}</span>  directly in terms of the relative margin.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-1&quot;&gt;&lt;/span&gt;<strong>Lemma 5.</strong> Let  <span class="math">s, k, T \\in \\mathbb{N}</span> . Let  <span class="math">\\mathcal{D}</span>  be any distribution on  <span class="math">\\{0, 1\\}^T</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{S}^{s,k}[\\mathcal{D}] \\leq \\Pr_{w \\sim \\mathcal{D}} \\left[ \\begin{aligned} &amp; \\text{there is a decomposition } w = xyz, \\text{ where} \\\\ &amp; |x| = s - 1 \\text{ and } |y| \\geq k + 1, \\text{ so that } \\mu_x(y) \\geq \\end{aligned} \\right].</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Lemma 1 implies that  <span class="math">\\mathbf{S}^{s,k}[\\mathcal{D}]</span>  is no more than the probability that slot s is not k-settled for the characteristic string w. By Observation 1, this probability, in turn, is no more than the probability that there exists an x-balanced fork  <span class="math">F \\vdash xy</span>  where we write  <span class="math">w = xyz, |x| = s - 1, |y| \\ge k + 1, |z| \\ge 0</span> . Finally, Fact 1 states that for any characteristic string xy, the two events &quot;exists an x-balanced fork  <span class="math">F \\vdash xy</span> &quot; and &quot; <span class="math">\\mu_x(y)</span>  is non-negative&quot; have the same measure. Hence the claim follows.</p>

    <p class="text-gray-300">If the distribution  <span class="math">\\mathcal{D}</span>  in the lemma above satisfies the  <span class="math">\\epsilon</span> -martingale condition, the probability in this lemma is no more than the probability in the left-hand side of Corollary 1. Finally, by retracing the proof of Corollary 1 using the explicit probability from Bound 2, we see that the bound in Corollary 1 is  <span class="math">O(1) \\cdot \\exp(-\\Omega(\\epsilon^3(1-O(\\epsilon))k))</span> . Since  <span class="math">\\mathcal{B}_{\\epsilon}</span>  satisfies the  <span class="math">\\epsilon</span> -martingale condition, we conclude that  <span class="math">\\mathbf{S}^{s,k}[\\mathcal{B}_{\\epsilon}]</span>  is no more than this quantity as well.</p>

    <p class="text-gray-300">For any player playing the settlement game, the set of strings on which the player wins is monotone with respect to the partial order  <span class="math">\\leq</span>  defined in Section 6.4. To see why, note that if the adversary wins with a specific string w, he can certainly win with any string w' where  <span class="math">w \\leq w&#x27;</span> . As  <span class="math">\\mathcal{B}_{\\varepsilon}</span>  stochastically dominates  <span class="math">\\mathcal{W}</span> , it follows that  <span class="math">\\mathbf{S}^{s,k}[\\mathcal{W}] \\leq \\mathbf{S}^{s,k}[\\mathcal{B}_{\\varepsilon}]</span> .</p>

    <p class="text-gray-300"><strong>Proof of Theorem 2</strong> For the first inequality, observe that if w violates k-CP, it must violate k-CP&lt;sup&gt;slot&lt;/sup&gt; as well. It remains to prove the second inequality. Let  <span class="math">\\mathcal{D}</span>  be any distribution on  <span class="math">\\{0,1\\}^T</span> . We can apply Fact 1 on the statement of Theorem 3 to deduce that</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{w \\sim \\mathcal{D}}[w \\text{ violates } k\\text{-}\\mathrm{CP}^{\\mathsf{slot}}] \\leq \\Pr_{w \\sim \\mathcal{D}}\\left[\\text{there is a decomposition } w = xyz, \\\\ \\text{where } |y| \\geq k, \\text{ so that } \\mu_x(y) \\geq 0 \\right].</span>$</p>

    <p class="text-gray-300">By using a union bound over |x|, the above probability is at most</p>

    <p class="text-gray-300"><span class="math">$\\sum_{s=1}^{T-k+1} \\quad \\Pr_{w} \\left[ \\text{there is a decomposition } w = xyz, \\text{ where } \\\\ |x| = s-1 \\text{ and } |y| \\geq k, \\text{ so that } \\mu_{x}(y) \\geq 0 \\right].</span>$</p>

    <p class="text-gray-300">Since w satisfies the  <span class="math">\\varepsilon</span> -martingale condition, we can upper bound the probability inside the sum using Corollary 1. As we have seen in the proof of Theorem 1, the bound in Corollary 1 is  <span class="math">O(1) \\cdot \\exp(-\\Omega(\\varepsilon^3(1 - O(\\varepsilon))k))</span> . It follows that the sum above is at most  <span class="math">T \\exp(-\\Omega(\\varepsilon^3(1 - O(\\varepsilon))k))</span> .</p>

    <p class="text-gray-300">It remains to prove the recursive formulation of the relative margin from Section 5; we tackle it in the next section.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;7 Proof of the relative margin recurrence</h3>

    <p class="text-gray-300">We set the stage by formally defining fork prefixes.</p>

    <p class="text-gray-300"><strong>Definition 16</strong> (Fork prefixes). Let  <span class="math">w, x \\in \\{0, 1\\}^*</span>  so that  <span class="math">x \\le w</span> . Let F, F' be two forks for x and w, respectively. We say that F is a prefix of F' if F is a consistently labeled subgraph of F'. That is, all vertices and edges of F also appear in F' and the label of any vertex appearing in both F and F' is identical. We denote this relationship by  <span class="math">F \\sqsubseteq F&#x27;</span> .</p>

    <p class="text-gray-300">When speaking about a tine that appears in both F and F', we place the fork in the subscript of relevant properties, e.g., writing reach&lt;sub&gt;F&lt;/sub&gt;, etc.</p>

    <p class="text-gray-300">Observe that for any Boolean strings x and  <span class="math">w, x \\le w</span> , one can <em>extend</em> (i.e., augment) a fork prefix  <span class="math">F \\vdash x</span>  into a larger fork  <span class="math">F&#x27; \\vdash w</span>  so that  <span class="math">F \\sqsubseteq F&#x27;</span> . A <em>conservative extension</em> is a minimal extension in that it consumes the least amount of reserve (cf. Definition 11), leaving the remaining reserve to be used in future. Extensions and, in particular, conservative extensions play a critical role in the exposition that follows.</p>

    <p class="text-gray-300"><strong>Definition 17</strong> (Conservative extension of closed forks). Let w be a Boolean string, F a closed fork for w, and let s be an honest tine in F. Let F' be a closed fork for w0 so that  <span class="math">F \\sqsubseteq F&#x27;</span>  and F' contains an honest tine  <span class="math">\\sigma</span> ,  <span class="math">\\ell(\\sigma) = |w| + 1</span> . We say that F' is an extension of F or, equivalently, that  <span class="math">\\sigma</span>  is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or, equivalently, that F' is an extension of F or equivalently, that F' is an extension of F or equivalently, that F' is an extension of F or equivalently, that F' is an extension of F or equivalently.</p>

    <p class="text-gray-300">Clearly,  <span class="math">\\sigma</span>  is the longest tine in F'. Since  <span class="math">\\sigma</span>  is honest, it follows that length( <span class="math">\\sigma</span> )  <span class="math">\\geq 1 + \\text{height}(F) = 1 + \\text{length}(s) + \\text{gap}(s)</span> . The root-to-leaf path in F' that ends at  <span class="math">\\sigma</span>  contains at least gap(s) adversarial vertices  <span class="math">u \\in F&#x27;</span>  so that  <span class="math">\\ell(u) \\in [\\ell(s) + 1, |w|]</span>  and  <span class="math">u \\notin F</span> . If  <span class="math">\\sigma</span>  is a conservative extension, the number of such vertices is exactly gap(s) and, in particular, the height of F' is exactly one more than the height of F.</p>

    <p class="text-gray-300">The main ingredients to proving Lemma 3 are a fork-building strategy for the string xy and Propositions 1 and 2. Specifically, recall equation (13). The first proposition shows that the fork  <span class="math">F \\vdash xy0</span>  built by the said strategy achieves  <span class="math">\\mu_x(F) \\ge \\mu_x(y0)</span>  while the second proposition shows that this value, in fact, is the largest possible, i.e.,  <span class="math">\\mu_x(y0) \\le \\mu_x(y0)</span> . In addition, any fork-building strategy whose forks satisfy the premise of Proposition 1 can be used to prove Lemma 3.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-25-2&quot;&gt;&lt;/span&gt;7.1 A fork-building strategy to maximize x-relative margin</h3>

    <p class="text-gray-300">Any fork  <span class="math">F \\vdash xy</span>  contains two tines  <span class="math">t_x, t_\\rho</span>  so that  <span class="math">\\operatorname{reach}(t_\\rho) = \\rho(F)</span> ,  <span class="math">\\operatorname{reach}_F(t_x) = \\mu_x(F)</span> , and the tines  <span class="math">t_x, t_\\rho</span>  are disjoint over the suffix y. We say that the tine-pair  <span class="math">(t_\\rho, t_x)</span>  is a <em>witness</em> to  <span class="math">\\mu_x(F)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">x,y\\in\\{0,1\\}^*</span>  and write w=xy. Recursively build closed forks  <span class="math">F_0,F_1,\\ldots,F_{|w|}</span>  where  <span class="math">F_i\\vdash w_1\\ldots w_i, i\\geq 1</span>  and  <span class="math">F_0\\vdash \\varepsilon</span>  is the trivial fork consisting of a single vertex corresponding to the genesis block. For  <span class="math">i=0,1,\\ldots,|w|-1</span>  in increasing order, do as follows. If  <span class="math">w_{i+1}=1</span> , set  <span class="math">F_{i+1}\\leftarrow F_i</span> . If  <span class="math">w_{i+1}=0</span> , set  <span class="math">F_{i+1}\\vdash w0</span>  as a conservative extension of  <span class="math">F_i\\vdash w</span>  so that  <span class="math">\\sigma\\in F_{i+1}, \\ell(\\sigma)=i+1</span>  is a conservative extension of a tine  <span class="math">s\\in F_i</span>  identified as follows. If  <span class="math">F_i</span>  contains no zero-reach tine, s is the unique longest tine in  <span class="math">F_i</span> . Otherwise, first identify a maximal-reach tine  <span class="math">t_\\rho\\in F_i</span>  as follows: if  <span class="math">i\\geq |x|+1</span> ,  <span class="math">t_\\rho</span>  is a maximal-reach tine in  <span class="math">F_i</span>  which belongs to a tine-pair witnessing  <span class="math">\\mu_x(F_i)</span> ; otherwise,  <span class="math">t_\\rho</span>  can be an arbitrary maximal-reach tine in  <span class="math">F_i</span> . Finally, s is the zero-reach tine in  <span class="math">F_i</span>  that diverges earliest from  <span class="math">t_\\rho</span> . If there are multiple candidates for s or  <span class="math">t_\\rho</span> , break tie arbitrarily.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;<strong>Proposition 1.</strong> Let x, y be arbitrary Boolean strings,  <span class="math">|y| \\ge 1</span>  and w = xy. Let  <span class="math">F \\vdash w</span>  and  <span class="math">F&#x27; \\vdash w0</span>  be two closed forks built by the strategy above so that  <span class="math">F \\sqsubseteq F&#x27;</span>  and suppose, in addition, that  <span class="math">\\rho(F) = \\rho(xy)</span>  and  <span class="math">\\mu_x(F) = \\mu_x(y)</span> . Then  <span class="math">\\rho(F&#x27;) = \\rho(xy0)</span>  and  <span class="math">\\mu_x(F&#x27;) \\ge \\mu_x(y0)</span> .</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">7.2 Proof of Proposition 1</h4>

    <p class="text-gray-300">Before we proceed further, let us record two useful results related to conservative extensions and closed fork prefixes.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-25-3&quot;&gt;&lt;/span&gt;<strong>Claim 1</strong> (A conservative extension has reach zero). <em>Consider closed forks</em>  <span class="math">F \\vdash w, F&#x27; \\vdash w0</span>  <em>such that</em>  <span class="math">F \\sqsubseteq F&#x27;</span> . <em>If a tine t of</em> F' <em>is a conservative extension then</em> reach <span class="math">_{F&#x27;}(t) = 0</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We have assumed that t is a conservative extension, so its terminal vertex must be the new honest node. By definition, reach&lt;sub&gt;E'&lt;/sub&gt;(t) = reserve&lt;sub&gt;E'&lt;/sub&gt;(t) - gap&lt;sub&gt;E'&lt;/sub&gt;(t). Honest players will only place nodes at a depth strictly greater than all other honest nodes, so we infer that t is the longest tine of F', and so  <span class="math">gap_{vl}(t) = 0</span> . Moreover, we observe that there are no 1s occurring after this point in the characteristic string, and so reserve&lt;sub&gt;E'&lt;/sub&gt;(t) = 0. Plugging these values into our definition of reach we see that  <span class="math">\\operatorname{reach}_{F&#x27;}(t) = 0 - 0 = 0</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;<strong>Claim 2</strong> (Reach of non-extended tines). Consider a closed fork  <span class="math">F \\vdash w</span>  and some closed fork  <span class="math">F&#x27; \\vdash w0</span>  such that  <span class="math">F \\sqsubseteq F&#x27;</span> . If  <span class="math">t \\in F</span>  then  <span class="math">\\operatorname{reach}_{F&#x27;}(t) \\leq \\operatorname{reach}_{F}(t) - 1</span> . The inequality becomes and equality if F' is obtained via a conservative extension from F.</p>

    <p class="text-gray-300"><em>Proof.</em> Definitionally, we know that  <span class="math">\\operatorname{reach}_{F&#x27;}(t) = \\operatorname{reserve}_{F&#x27;}(t) - \\operatorname{gap}_{F&#x27;}(t)</span> . From F to F', the length of the longest tine increases by at least one, and the length of t does not change, so we observe that  <span class="math">gap_{F&#x27;}(t) \\ge gap_{F}(t) + 1</span>  with equality only for conservative extensions. The reserve of t does not change, because there are no new 1s in the characteristic string. Therefore,  <span class="math">\\operatorname{reach}_{F&#x27;}(t) = \\operatorname{reserve}_{F&#x27;}(t) - \\operatorname{gap}_{F&#x27;}(t) \\le \\operatorname{reserve}_{F}(t) - \\operatorname{gap}_{F}(t) - 1 = \\operatorname{reach}_{F}(t) - 1</span> .</p>

    <p class="text-gray-300">Assume the premise of Proposition 1. That is, F is a fork for xy so that  <span class="math">\\rho(F) = \\rho(xy)</span> ,  <span class="math">\\mu_x(F) = \\mu_x(y)</span> , and the tine  <span class="math">t_{\\rho}</span>  identified by the fork-building strategy in Section 7.1 belongs to an F-tine-pair  <span class="math">(t_{\\rho}, t_{x})</span>  that witnesses  <span class="math">\\mu_{x}(F)</span> . To recap, this means reach&lt;sub&gt;F&lt;/sub&gt; <span class="math">(t_o) = \\rho(F) = \\rho(x)</span> , reach&lt;sub&gt;F&lt;/sub&gt; <span class="math">(t_x) = \\mu_x(F) = \\mu_x(y)</span> , and the tines  <span class="math">t_o</span> ,  <span class="math">t_x</span>  are disjoint over y (i.e.,  <span class="math">\\ell(t_0 \\cap t_x) \\le |x|</span> ). In addition, since  <span class="math">\\sigma \\in F&#x27;</span>  is a conservative extension of s, we have reach  <span class="math">F&#x27;(\\sigma) = 0</span> . Finally, let <em>S</em> be the set of all zero-reach tines in <em>F</em>.</p>

    <p class="text-gray-300">We will break this part of the proof into several cases based on the relative reach and margin of the fork.</p>

    <p class="text-gray-300"><strong>Case 1:</strong>  <span class="math">\\rho(xy) &gt; 0</span>  and  <span class="math">\\mu_x(y) = 0</span> . We wish to show that  <span class="math">\\rho(F&#x27;) = \\rho(xy0)</span>  and  <span class="math">\\mu_x(F&#x27;) \\ge 0</span> . Since  <span class="math">\\rho(F) &gt; 0</span> ,  <span class="math">s \\ne t_0</span> and therefore, By (11) and Claim 2, Thus  <span class="math">\\rho(F&#x27;) \\ge \\operatorname{reach}_{F&#x27;}(t_{\\rho}) = \\operatorname{reach}_{F}(t_{\\rho}) - 1 = \\rho(xy) - 1 = \\rho(xy)</span> . Therefore,  <span class="math">\\rho(F&#x27;) = \\rho(xy0).</span></p>

    <p class="text-gray-300">Since  <span class="math">\\mu_x(y) = 0</span> ,  <span class="math">t_x</span>  is a candidate for being selected as s and hence  <span class="math">\\ell(s \\cap t_0) \\le \\ell(t_x \\cap t_0) \\le |x|</span> . Thus  <span class="math">\\sigma, t_0 \\in F&#x27;</span> are disjoint over y0 and, therefore,  <span class="math">\\mu_x(F&#x27;) \\ge \\operatorname{reach}_{F&#x27;}(\\sigma) = 0</span> .</p>

    <p class="text-gray-300">Case 2:  <span class="math">\\rho(xy) = 0</span> . We wish to show that  <span class="math">\\rho(F&#x27;) = \\rho(xy0)</span>  and  <span class="math">\\mu_x(F&#x27;) \\ge \\mu_x(y) - 1</span> . Since there is at least one zero-reach tine, reach&lt;sub&gt;F&lt;/sub&gt;(s) = 0 and, in addition,  <span class="math">t_o \\in S</span> ,  <span class="math">|S| \\ge 1</span> . Since reach&lt;sub&gt;F'&lt;/sub&gt;( <span class="math">\\sigma</span> ) = 0 =  <span class="math">\\rho(xy0)</span>  by (11),  <span class="math">\\sigma</span>  has the maximal reach in F' and, in particular,  <span class="math">\\rho(F&#x27;) = \\rho(xy0)</span> . Depending on S and s, there are three possibilities. If  <span class="math">s = t_{\\rho}</span> , this means  <span class="math">S = \\{t_{\\rho}\\}</span> ,  <span class="math">t_x</span> 's F'-reach is one less than its F-reach, and  <span class="math">\\sigma</span> ,  <span class="math">t_x</span>  are still disjoint over y0. Hence  <span class="math">\\mu_x(F&#x27;) \\ge \\operatorname{reach}_F(t_x) - 1 = \\mu_x(y) - 1</span> . If  <span class="math">s = t_x</span> , then  <span class="math">t_o</span> 's F'-reach is one less than its F-reach and  <span class="math">\\sigma, t_o</span> are disjoint over y0. Hence  <span class="math">\\mu_x(F&#x27;) \\ge \\operatorname{reach}_F(t_o) - 1 = \\rho(xy) - 1 \\ge \\mu_x(y) - 1</span> . Finally, suppose  <span class="math">s \\ne t_o</span>  and  <span class="math">s \\neq t_x</span> . Then  <span class="math">\\mu_x(y) = \\operatorname{reach}_F(t_x) &lt; 0</span>  and, in addition, s (and  <span class="math">\\sigma</span> ) must share an edge with  <span class="math">t_{\\sigma}</span>  somewhere over y since otherwise, we would have achieved  <span class="math">\\mu_x(y) = 0</span> . As a result,  <span class="math">t_x</span>  and  <span class="math">\\sigma</span>  must be disjoint over y0. Hence  <span class="math">\\mu_x(F&#x27;) \\ge \\operatorname{reach}_{F&#x27;}(t_x) = \\operatorname{reach}_F(t_x) - 1 = \\mu_x(y) - 1.</span></p>

    <p class="text-gray-300"><strong>Case 3:</strong>  <span class="math">\\rho(xy) &gt; 0</span> ,  <span class="math">\\mu_X(y) \\neq 0</span> . We wish to show that  <span class="math">\\rho(F&#x27;) = \\rho(xy0)</span>  and  <span class="math">\\mu_X(F&#x27;) \\geq \\mu_X(y) - 1</span> . In this case,  <span class="math">s \\neq t_0</span> and  <span class="math">s \\neq t_x</span>  and therefore, reach <span class="math">_{F&#x27;}(t_i) = \\operatorname{reach}_{F}(t_i) - 1</span>  for i = 1, 2. The tines  <span class="math">t_\\rho, t_x</span>  are still disjoint over y0. In addition,  <span class="math">t_{\\rho}</span>  will still have the maximal reach in F' since  <span class="math">\\operatorname{reach}_{F&#x27;}(t_{\\rho}) = \\rho(xy) - 1 = \\rho(xy0)</span>  by 11. Therefore,  <span class="math">\\rho(F&#x27;) = \\rho(xy0)</span>  and, in addition,  <span class="math">\\mu_x(F&#x27;) \\ge \\operatorname{reach}_{F&#x27;}(t_x) = \\operatorname{reach}_{F}(t_x) - 1 = \\mu_x(y) - 1</span> .</p>

    <p class="text-gray-300">This complete the proof of Proposition 1.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">7.3 Proof of Lemma 3</h4>

    <p class="text-gray-300">Let F be a closed fork for the characteristic string xy. Let  <span class="math">t_o, t_x \\in F</span>  be the two tines that witness  <span class="math">\\mu_x(F)</span> , i.e.,  <span class="math">\\operatorname{reach}(t_{\\rho}) = \\rho(F)</span> ,  <span class="math">\\operatorname{reach}_F(t_x) = \\mu_x(F)</span> , and  <span class="math">t_{\\rho}</span> ,  <span class="math">t_x</span>  are disjoint over y. Let  <span class="math">\\hat{t}</span>  be the longest tine in F.</p>

    <p class="text-gray-300">In the base case, where  <span class="math">y = \\varepsilon</span> , we observe that any two tines of F are disjoint over y. Moreover, even a single tine  <span class="math">t_0</span>  is disjoint with itself over  <span class="math">\\varepsilon</span> . Therefore, the relative margin  <span class="math">\\mu_x(\\varepsilon)</span>  must be greater than or equal to the reach of the tine t that achieves reach <span class="math">(t) = \\rho(x)</span> . The relative margin must also be less than or equal to  <span class="math">\\rho(x)</span> , because that is, by definition, the maximum reach over all tines in all forks  <span class="math">F \\vdash w</span> . Putting these facts together, we have  <span class="math">\\mu_x(\\varepsilon) = \\rho(x)</span> .</p>

    <p class="text-gray-300">Moving beyond the base case, we will consider a pair of closed forks  <span class="math">F \\vdash xy</span>  and  <span class="math">F&#x27; \\vdash xyb</span>  such that  <span class="math">F \\sqsubseteq F&#x27;</span> ,  <span class="math">x, y \\in \\{0, 1\\}^*</span> ,  <span class="math">|y| \\ge 1</span> , and  <span class="math">b \\in \\{0, 1\\}</span> . If b = 1, we have set F' = F. The reach of each tine increases by 1 from F to F' since the gap has not changed but the reserve has increased by one. Therefore,  <span class="math">\\mu_x(y1) = \\mu_x(y) + 1</span> , as desired. If b = 0, however, things are more nuanced. Consider the following proposition:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;<strong>Proposition 2.</strong> Let x, y be arbitrary Boolean strings,  <span class="math">|y| \\ge 1</span> , and w = xy0. Then  <span class="math">\\mu_x(y0) \\le 0</span>  if  <span class="math">\\rho(xy) &gt; \\mu_x(y) = 0</span> , and  <span class="math">\\mu_x(y0) \\le \\mu_x(y) - 1</span>  otherwise.</p>

    <p class="text-gray-300">Recall that  <span class="math">\\mu_x(F&#x27;) \\ge \\mu_x(y0)</span>  by Proposition 1. Combining this with Proposition 2 above, we conclude that  <span class="math">\\mu_x(F&#x27;) = \\mu_x(y0)</span>  and, in addition, that the fork F' actually achieves the maximum reach and the maximum relative margin for the characteristic string xy0. It remains to prove Proposition 2.</p>

    <p class="text-gray-300"><em>Proof of Proposition 2.</em> Suppose  <span class="math">F&#x27; \\vdash xy0</span>  is a closed fork such that  <span class="math">\\rho(xy0) = \\rho(F&#x27;)</span>  and  <span class="math">\\mu_x(y0) = \\mu_x(F&#x27;)</span> . Let  <span class="math">t_\\rho, t_x \\in F&#x27;</span>  to be a pair of tines disjoint over y in F' such that  <span class="math">\\operatorname{reach}_{F&#x27;}(t_\\rho) = \\rho(F&#x27;)</span>  and  <span class="math">\\operatorname{reach}_{F&#x27;}(t_x) = \\mu_x(F&#x27;) = \\mu_x(y0)</span> . Let  <span class="math">F \\vdash xy</span>  be the unique closed fork such that  <span class="math">F \\sqsubseteq F&#x27;</span> . Note that while F' is an extension of F, it is not necessarily a conservative extension.</p>

    <p class="text-gray-300"><strong>Case 1:</strong>  <span class="math">\\rho(xy) &gt; 0</span>  <strong>and</strong>  <span class="math">\\mu_x(y) = 0</span> . We wish to show that  <span class="math">\\mu_x(y0) \\le 0</span> . Suppose (toward a contradiction) that  <span class="math">\\mu_x(y0) &gt; 0</span> . Then neither  <span class="math">t_\\rho</span>  or  <span class="math">t_x</span>  is a conservative extension because, as we proved in Claim 1, conservative extensions have reach exactly 0. This means that  <span class="math">t_\\rho</span>  and  <span class="math">t_x</span>  existed in F, and had strictly greater reach in F than they do presently in F' (by Claim 2). Because  <span class="math">t_\\rho</span>  and  <span class="math">t_x</span>  are disjoint over y0, they must also be disjoint over y; therefore the  <span class="math">\\mu_x(F)</span>  must be at least min{reach}_F(t_\\rho), reach <span class="math">_F(t_x)</span> }. Following this line of reasoning, we have  <span class="math">0 = \\mu_x(y) \\ge \\min_{i \\in \\{1,2\\}} \\{\\operatorname{reach}_{F}(t_i)\\} &gt; \\min_{i \\in \\{1,2\\}} \\{\\operatorname{reach}_{F}(t_i)\\} = \\mu_x(F&#x27;) = \\mu_x(y0) &gt; 0</span> , a contradiction, as desired.</p>

    <p class="text-gray-300">Case 2:  <span class="math">\\rho(xy)=0</span> . We wish to show that  <span class="math">\\mu_x(y0) \\leq \\mu_x(y)-1</span>  or, equivalently, that  <span class="math">\\mu_x(y0) &lt; \\mu_x(y)</span> . First, we claim that  <span class="math">t_\\rho</span>  must arise from an extension. Suppose, toward a contradiction, that  <span class="math">t_\\rho</span>  is not an extension, i.e.,  <span class="math">t_\\rho \\in F</span> . The fact that  <span class="math">t_\\rho</span>  achieves the maximum reach in F' implies that  <span class="math">t_\\rho</span>  has non-negative reach since the longest honest tine always achieves reach 0. Furthermore, Claim 2 states that all tines other than the extended tine see their reach decrease. Therefore,  <span class="math">t_\\rho \\in F</span>  must have had a strictly positive reach. But this contradicts the central assumption of the case, i.e., that  <span class="math">\\rho(xy)=0</span> . Therefore, we conclude that  <span class="math">t_\\rho \\in F&#x27;</span> ,  <span class="math">t_\\rho \\notin F</span> , and, since F' differs from F by a single extension,  <span class="math">t_x \\in F</span> .</p>

    <p class="text-gray-300">Let  <span class="math">s \\in F</span>  be the tine-prefix of  <span class="math">t_\\rho \\in F&#x27;</span>  so that  <span class="math">t_\\rho</span>  is an extension of s. Since  <span class="math">\\operatorname{reach}_{F&#x27;}(t_\\rho) = \\rho(xy0) = 0</span>  by (11),  <span class="math">\\operatorname{reach}_F(s)</span>  must be at least 0. Additionally, since  <span class="math">\\rho(xy) = 0</span> ,  <span class="math">\\operatorname{reach}_F(s) \\leq 0</span> . Together, these statements tell us that  <span class="math">\\operatorname{reach}_F(s) = 0</span> . Restricting our view to F, we see that s and  <span class="math">t_x</span>  are disjoint over y and so it must be true that  <span class="math">\\min\\{\\operatorname{reach}_F(s), \\operatorname{reach}_F(t_x)\\} \\leq \\mu_x(y)</span> . Because  <span class="math">\\operatorname{reach}_F(s) = 0</span>  and  <span class="math">\\operatorname{reach}_F(t_x) \\leq \\rho(xy) = 0</span> , we can simplify that statement to  <span class="math">\\operatorname{reach}_F(t_x) \\leq \\mu_x(y)</span> . Finally, since  <span class="math">t_x \\in F</span> , Claim 2 tells us that  <span class="math">\\operatorname{reach}_F(t_x) &lt; \\operatorname{reach}_F(t_x)</span> . Taken together, these two inequalities show that  <span class="math">\\mu_x(y0) = \\operatorname{reach}_{F&#x27;}(t_x) &lt; \\operatorname{reach}_F(t_x) \\leq \\mu_x(y)</span> .</p>

    <p class="text-gray-300"><strong>Case 3:</strong>  <span class="math">\\rho(xy) &gt; 0</span> ,  <span class="math">\\mu_x(y) \\neq 0</span> . We wish to show that  <span class="math">\\mu_x(y0) \\leq \\mu_x(y) - 1</span>  or, equivalently, that  <span class="math">\\mu_x(y0) &lt; \\mu_x(y)</span> . Note that by 11,  <span class="math">\\rho(xy0) = \\rho(xy) - 1 \\geq 0</span> . We will break this case into two sub-cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If both  <span class="math">t_{\\rho}, t_{x} \\in F</span> . Then  <span class="math">t_{\\rho}, t_{x} \\in F</span>  and, consequently,  <span class="math">\\min\\{\\operatorname{reach}_{F}(t_{\\rho}), \\operatorname{reach}_{F}(t_{x})\\} \\leq \\mu_{x}(y)</span>  since  <span class="math">t_{\\rho}</span>  and  <span class="math">t_{x}</span>  must be disjoint over y. Furthermore, by Claim 2,  <span class="math">\\operatorname{reach}_{F&#x27;}(t_{i}) &lt; \\operatorname{reach}_{F}(t_{i})</span>  for  <span class="math">i \\in \\{1, 2\\}</span> . Therefore,  <span class="math">\\mu_{x}(y_{0}) = \\operatorname{reach}_{F&#x27;}(t_{x}) = \\min\\{\\operatorname{reach}_{F&#x27;}(t_{\\rho}), \\operatorname{reach}_{F&#x27;}(t_{\\rho}), \\operatorname{reach}_{F}(t_{\\rho}), \\operatorname{reach}_{F}(t_{x})\\} \\leq \\mu_{x}(y)</span> , as desired.</li>
      <li>If either  <span class="math">t_{\\rho} \\notin F</span>  or  <span class="math">t_{x} \\notin F</span> . It must be true that  <span class="math">\\operatorname{reach}_{F&#x27;}(t_{x}) \\leq 0</span> , because either  <span class="math">t_{x}</span>  is the extension (and therefore has reach exactly 0) or  <span class="math">t_{\\rho}</span>  is the extension and we have  <span class="math">\\operatorname{reach}_{F&#x27;}(t_{x}) = \\mu_{x}(y0) \\leq \\rho(xy0) = \\operatorname{reach}_{F&#x27;}(t_{\\rho}) = 0</span> . Recall that we have assumed  <span class="math">\\mu_{x}(y) \\neq 0</span> . If  <span class="math">\\mu_{x}(y) &gt; 0</span> , we are done: certainly  <span class="math">\\mu_{x}(y0) \\leq 0 &lt; \\mu_{x}(y)</span> . If, however,  <span class="math">\\mu_{x}(y) &lt; 0</span> , there is more work to do. In this case, we claim that  <span class="math">t_{x} \\in F</span> , i.e.,  <span class="math">t_{x}</span>  did not arise from an extension. To see why, consider the following: if  <span class="math">t_{x}</span>  arose from extension, then there must be some  <span class="math">s \\in F</span>  so that  <span class="math">s &lt; t_{x}</span>  and  <span class="math">\\operatorname{reach}_{F}(s) \\geq 0</span> . Additionally, by our claim about non-extended tines, we see that</li>
    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname{reach}_F(t_\\rho) &gt; \\operatorname{reach}_{F&#x27;}(t_\\rho) = \\rho(xy0) \\ge 0</span> . Therefore,  <span class="math">\\mu_x(y) \\ge \\min\\{\\operatorname{reach}_F(t_\\rho), \\operatorname{reach}_F(s)\\} \\ge 0</span> , contradicting our assumption that  <span class="math">\\mu_x(y) &lt; 0</span> . Thus  <span class="math">t_x \\in F</span> .</p>

    <p class="text-gray-300">The only remaining scenario is the one in which  <span class="math">\\mu_x(y) &lt; 0</span>  and  <span class="math">t_\\rho</span>  arises from an extension of some tine  <span class="math">s \\in F</span> , reach <span class="math">_F(s) \\ge 0</span> . In this scenario,  <span class="math">t_x</span>  cannot have been the extension (since there is only one). By Claim 2, reach <span class="math">_F(t_x) &gt; \\operatorname{reach}_{F&#x27;}(t_x)</span> . Using a now-familiar line of reasoning, note that the two tines  <span class="math">t_x</span>  and s are disjoint over y and, therefore,  <span class="math">\\mu_x(y) \\ge \\min\\{\\operatorname{reach}_F(s), \\operatorname{reach}_{F&#x27;}(t_x)\\}</span> . Since,  <span class="math">\\mu_x(y) &lt; 0</span>  by assumption and  <span class="math">\\operatorname{reach}_F(s) \\ge 0</span> , it follows that  <span class="math">\\mu_x(y) \\ge \\operatorname{reach}_{F&#x27;}(t_x) &gt; \\operatorname{reach}_{F&#x27;}(t_x) = \\mu_x(y_x)</span> , as desired.</p>

    <p class="text-gray-300">This completes the proof of Lemma 3.</p>

    <h2 id="sec-23" class="text-2xl font-bold">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;8 Canonical forks and an optimal online adversary</h2>

    <p class="text-gray-300">Let w be a characteristic string, written w = xy, and recall the online fork-building strategy from Section 7.1. In Proposition 1, we showed that the fork produced by this strategy (for the string w) always contains a tine-pair  <span class="math">(t_\\rho, t_x)</span>  that witnesses  <span class="math">\\mu_x(y)</span> . In this section, we present an online fork-building strategy which produces a fork that <em>simultaneously</em> contains, for every prefix  <span class="math">x \\le w</span> , a tine-pair that witnesses  <span class="math">\\mu_x(y)</span> . These forks are called <em>canonical forks</em>, defined below.</p>

    <p class="text-gray-300"><strong>Definition 18</strong> (Canonical forks). Let  <span class="math">w_1 \\dots w_T \\in \\{0,1\\}^T</span> . For  <span class="math">n=0,1,\\dots,T</span> , a canonical fork  <span class="math">F_n</span>  for  <span class="math">w=w_1\\dots w_n</span>  is inductively defined as follows. If n=0 then  <span class="math">F_0</span>  is the trivial fork for the empty string; it consists of a single (honest) vertex and no edge. If  <span class="math">n\\geq 1</span> , the following holds:  <span class="math">F_n</span>  is a closed fork so that  <span class="math">F_{n-1} \\sqsubseteq F_n</span> .  <span class="math">F_n</span>  contains an honest tine  <span class="math">\\tau_\\rho</span>  so that reach <span class="math">(\\tau_\\rho) = \\rho(F_n) = \\rho(w)</span> . For every decomposition  <span class="math">w=xy, x \\prec w</span> ,  <span class="math">F_n</span>  contains two honest tines  <span class="math">\\tau_x, \\tau_{\\rho x}</span>  so that the tine-pair  <span class="math">(\\tau_{\\rho x}, \\tau_x)</span>  witnesses  <span class="math">\\mu_x(F_n) = \\mu_x(y)</span> . The (possibly non-distinct) designated tines  <span class="math">\\tau_\\rho, \\tau_{\\rho x}, \\tau_x, x \\prec w</span>  are called the witness tines.</p>

    <p class="text-gray-300">Note that if one's objective is to create a fork which contains many early-diverging tine-pairs witnessing large relative margins, a canonical fork is the best one can hope for.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">8.1 An online strategy for building canonical forks</h3>

    <p class="text-gray-300">Let w be a characteristic string, written as w=xy, and let F be a fork for w. If the tines  <span class="math">t_1,t_2\\in F</span>  are disjoint over y, we say  <span class="math">t_1</span>  and  <span class="math">t_2</span>  are y-disjoint, or equivalently,  <span class="math">t_1</span>  is y-disjoint with  <span class="math">t_2</span> . Note that this means  <span class="math">\\ell(t_1\\cap t_2)\\leq |x|</span> . Let  <span class="math">\\leq_{\\pi}</span>  be the lexicographical ordering of the tines where each tine is represented as the list of vertex labels appearing in the tine's root-to-leaf path. If two tines have the same vertex labels,  <span class="math">\\leq_{\\pi}</span>  must break tie in an arbitrary but consistent way.</p>

    <p class="text-gray-300">For a fixed fork, let A, B be two sets of tines. We define the <em>early-divergence witness for</em> (A, B) as follows. Let  <span class="math">C_{AB}</span>  be an ordered set of tine-pairs  <span class="math">(t&#x27;_a, t&#x27;_b), a&#x27; \\in A, b&#x27; \\in B</span>  that minimize  <span class="math">\\ell(t_a \\cap t_b), t_a \\in A, t_b \\in B</span> . The order of the elements in  <span class="math">C_{AB}</span>  is the following:  <span class="math">(t_1, t_2) \\leq (t&#x27;_1, t&#x27;_2)</span>  if and only if  <span class="math">t_1 \\leq_{\\pi} t&#x27;_1</span>  and  <span class="math">t_2 \\leq_{\\pi} t&#x27;_2</span> . The first element of  <span class="math">C_{AB}</span>  is called the early-divergence witness for (A, B).</p>

    <p class="text-gray-300">The fork-building strategy  <span class="math">\\mathcal{A}^*</span>  presented in Figure 4 builds canonical forks in an online fashion, i.e., it scans the characteristic string w once, from left to right, maintains a &quot;current fork,&quot; and updates it after seeing each new symbol by only adding new vertices. Since the final fork  <span class="math">F \\vdash w</span>  is canonical, it satisfies  <span class="math">\\mu_x(F) = \\mu_x(y)</span>  simultaeneously for all decompositions w = xy; hence we call  <span class="math">\\mathcal{A}^*</span>  the <em>optimal online adversary</em>.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-28-1&quot;&gt;&lt;/span&gt;<strong>Theorem 5</strong> ( <span class="math">\\mathcal{A}^*</span>  builds canonical forks). Let  <span class="math">w \\in \\{0,1\\}^n</span>  and  <span class="math">b \\in \\{0,1\\}</span> . Let  <span class="math">F \\vdash w</span>  and  <span class="math">F&#x27; \\vdash wb</span>  be two closed forks built by the strategy  <span class="math">\\mathcal{A}^*</span>  so that  <span class="math">F \\sqsubseteq F&#x27;</span>  and suppose, in addition, that F is canonical. Then F' is canonical as well.</p>

    <p class="text-gray-300">We remark that the fork-building strategy  <span class="math">\\mathcal{A}^*</span>  would certainly satisfy Proposition 1 and, therefore, satisfy the recurrence relation (13) as well.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">The strategy <span class="math">\\mathcal{A}^*</span></h4>

    <p class="text-gray-300">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;Let  <span class="math">w=w_1\\dots w_n\\in\\{0,1\\}^n</span>  and  <span class="math">w_{n+1}\\in\\{0,1\\}</span> . If n=0, set  <span class="math">F_0\\vdash\\varepsilon</span>  as the trivial fork comprising a single vertex. Otherwise, for  <span class="math">n\\geq 0</span> , let  <span class="math">F_n</span>  be the closed fork built recursively by  <span class="math">\\mathcal{A}^*</span>  for the string w. If  <span class="math">w_{n+1}=1</span> , set  <span class="math">F_{n+1}=F_n</span> . Otherwise, the closed fork  <span class="math">F_{n+1}\\vdash w0</span>  is the result of a single conservative extension of a tine  <span class="math">s\\in F_n</span>  into a new honest tine  <span class="math">\\sigma\\in F_{n+1}</span> ,  <span class="math">\\ell(\\sigma)=n+1</span> ; The tine s can be identified as follows. If  <span class="math">F_n</span>  contains no tine with reach zero, s is the unique longest tine in  <span class="math">F_n</span> . Otherwise, s is the reach-zero tine that diverges earliest with respect to the set of maximal-reach tines in  <span class="math">F_n</span> . If there are multiple candidates for s, select the one with the smallest  <span class="math">\\leq_{\\pi}</span> -rank.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Designating the witness tines</h4>

    <p class="text-gray-300">Writing  <span class="math">w&#x27; = ww_{n+1}</span> ,  <span class="math">F = F_n</span> , and  <span class="math">F&#x27; = F_{n+1}</span> , identify the tines  <span class="math">\\tau_\\rho, \\tau_w, \\tau_x, \\tau_{\\rho x} \\in F&#x27;, x &lt; w</span>  as follows. Let R (resp. R') be the set of F-tines (resp. F'-tines) with the maximal F-reach (resp. F'-reach). Set  <span class="math">\\tau_\\rho</span>  as the element of R' with smallest  <span class="math">\\leq_{\\pi}</span> -rank. Set  <span class="math">(\\tau_w, \\tau_{\\rho w})</span>  as the early-divergence witness for (R, R'). For every decomposition w = xy,  <span class="math">|y| \\geq 1</span> ,  <span class="math">|x| \\geq 0</span> , do as follows. Let  <span class="math">B_x</span>  be the set of F'-tines that are  <span class="math">yw_{n+1}</span> -disjoint with <em>some</em> maximal-reach tine in R'. Let  <span class="math">C_x \\subseteq B_x</span>  contain the tines with the maximal F'-reach, the maximum taken over  <span class="math">B_x</span> . Set  <span class="math">(\\tau_x, \\tau_{\\rho x})</span>  as the early-divergence witness for  <span class="math">(C_x, R&#x27;)</span> .</p>

    <p class="text-gray-300">Figure 4: Optimal online adversary  <span class="math">A^*</span></p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">8.2 Winning the <span class="math">(\\mathcal{D}, T; s, k)</span> -settlement game, optimally</h3>

    <p class="text-gray-300">Consider the player in the  <span class="math">(\\mathcal{D}, T; s, k)</span> -settlement game who, at the first step, samples a characteristic string  <span class="math">w \\sim \\mathcal{D}, w = w_1 w_2 \\dots w_T</span> . Since the challenger is deterministic, the game is completely determined by the characteristic string and the choices of the player. In particular, for a given prefix x &lt; w, |x| = s - 1, consider the decompositions w = xyz. The player's chance of winning the game will be maximized if, for every  <span class="math">y, |y| \\ge k + 1</span>  (so that  <span class="math">n = |xy| \\ge s + k</span> ), the fork  <span class="math">F_n \\vdash xy</span>  contains a tine-pair  <span class="math">(\\tau_{\\rho x}, \\tau_x)</span>  that witnesses  <span class="math">\\mu_x(y)</span> . In fact, if  <span class="math">\\mu_x(y) \\ge 0</span>  for some y then, as shown in Fact 1, the player wins the game by augmenting  <span class="math">F_n</span>  to an x-balanced fork  <span class="math">A_n \\vdash xy</span> .</p>

    <p class="text-gray-300">Note, in addition, that if  <span class="math">F_n</span>  is canonical, the player can optimally play  <span class="math">(\\mathcal{D}, T; s, k)</span> -settlement games <em>simultaneously</em> for every  <span class="math">s \\in [n-k]</span> . That is, given a distribution  <span class="math">\\mathcal{D}</span> , a canonical fork  <span class="math">F_n</span>  gives the player the largest probability of causing a settlement violation at as many slots  <span class="math">s \\in [n-k]</span>  as possible, at once.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">8.3 Proof of Theorem 5</h4>

    <p class="text-gray-300">For convenience, let us record the following fact which compacts Claims 1 and 2.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-29-1&quot;&gt;&lt;/span&gt;<strong>Fact 2.</strong> Let  <span class="math">F \\vdash w</span>  and  <span class="math">F&#x27; \\vdash w0</span>  be closed forks so that  <span class="math">F \\sqsubseteq F&#x27;</span>  and F' differs from F by a single conservative extension  <span class="math">\\sigma \\in F&#x27;</span> ,  <span class="math">\\ell(\\sigma) = |w| + 1</span> . Then  <span class="math">\\operatorname{reach}_{F&#x27;}(t) = \\operatorname{reach}_{F}(t) - 1</span>  for every  <span class="math">t \\in F</span>  and, in addition,  <span class="math">\\operatorname{reach}_{F&#x27;}(\\sigma) = 0</span> .</p>

    <p class="text-gray-300">In the rest of the proof, we will frequently use the above fact along with Lemma 2 and Lemma 3, often without an explicit reference.</p>

    <p class="text-gray-300">By assumption, F is a canonical fork. Thus  <span class="math">\\operatorname{reach}_F(t_\\rho) = \\rho(w)</span>  and for every  <span class="math">\\operatorname{prefix} x \\prec w</span> ,  <span class="math">\\operatorname{reach}_F(t_x) = \\mu_x(y)</span> . Let w' = wb and let  <span class="math">\\tau_\\rho, \\tau_w, \\tau_{\\rho w}, \\tau_x, \\tau_{\\rho x} \\in F&#x27;, x \\prec w</span>  be the purported witness tines in F'. Note that  <span class="math">\\tau_x</span>  must be yb-disjoint with  <span class="math">\\tau_{\\rho x}</span>  by construction. Similarly,  <span class="math">\\tau_w</span>  must be  <span class="math">w_{n+1}</span> -disjoint with  <span class="math">\\tau_{\\rho w}</span>  since both cannot contain the unique vertex from slot n+1. It is evident from the construction that  <span class="math">\\rho(F&#x27;) = \\operatorname{reach}_{F&#x27;}(\\tau_\\rho) = \\operatorname{reach}_{F&#x27;}(\\tau_{\\rho w}) = \\operatorname{reach}_{F&#x27;}(\\tau_{\\rho x})</span>  for  <span class="math">x \\prec w</span> . Therefore, we wish to show that  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_\\rho) = \\rho(wb)</span> ,  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_w) = \\mu_w(b)</span>  and  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x) = \\mu_x(yb)</span>  for  <span class="math">x \\prec w</span> .</p>

    <p class="text-gray-300">If b=1. In this case, F'=F and w'=w1. Examining the rule for assigning  <span class="math">\\tau_{\\rho}, \\tau_{x}, \\tau_{\\rho x}</span> , and  <span class="math">\\tau_{w}</span> , we see that  <span class="math">\\tau_{\\rho}=t_{\\rho}, \\tau_{w}=t_{\\rho}, \\tau_{x}=t_{x}</span> , and  <span class="math">\\tau_{\\rho x}=t_{\\rho x}</span>  for all x &lt; w. Since F'=F and b=1, the F'-reach of every F-tine is one plus its F-reach. Thus for any x, x &lt; w, writing w'=xy1, we have  <span class="math">\\mu_{x}(y1)=1+\\mu_{x}(y)=1</span></p>

    <p class="text-gray-300"><span class="math">1 + \\operatorname{reach}_F(t_x) = \\operatorname{reach}_{F&#x27;}(t_x) = \\operatorname{reach}_{F&#x27;}(\\tau_x)</span> . Similarly,  <span class="math">\\rho(w1) = 1 + \\rho(w) = \\operatorname{reach}_{F&#x27;}(t_\\rho) = \\operatorname{reach}_{F&#x27;}(\\tau_\\rho)</span> . By construction,  <span class="math">\\tau_w</span>  has the largest reach in F; but this means  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_w) = \\operatorname{reach}_{F&#x27;}(t_\\rho) = \\rho(F&#x27;) = \\rho(w1)</span>  but, on the other hand,  <span class="math">\\mu_w(1) = 1 + \\mu_w(\\varepsilon) = 1 + \\rho(w) = \\rho(w1)</span> ; hence  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_w) = \\mu_w(1)</span> .</p>

    <p class="text-gray-300">If b = 0. The contingencies of this case are covered by Propositions 3, 4, and 5 below.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt;<strong>Proposition 3.</strong> Assume the premise of Theorem 5 with b=0. Then F' contains a witness tine  <span class="math">\\tau_{\\rho}</span>  so that reach <span class="math">_{F&#x27;}(\\tau_{\\rho})=\\rho(w0)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that the tine  <span class="math">\\sigma \\in F&#x27;</span> ,  <span class="math">\\ell(\\sigma) = |w| + 1</span>  is a conservative extension to a tine  <span class="math">s \\in F</span> , reach&lt;sub&gt;F&lt;/sub&gt;(s) = 0 so that reach&lt;sub&gt;F'&lt;/sub&gt; <span class="math">(\\sigma) = 0</span> . Also recall that  <span class="math">\\mu_z(\\varepsilon) = \\rho(z)</span>  for any characteristic string z. Finally, note that it suffices to show that reach&lt;sub&gt;F'&lt;/sub&gt; <span class="math">(\\tau_{\\rho}) \\ge \\rho(w0)</span> .</p>

    <p class="text-gray-300">Suppose  <span class="math">\\rho(w) &gt; 0</span> . Using Fact 2, Lemma 3, and examining the rule for assigning  <span class="math">\\tau_{\\rho}</span> , we see that  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_{\\rho}) \\geq \\operatorname{reach}_{F&#x27;}(t_{\\rho}) = \\operatorname{reach}_{F}(t_{\\rho}) - 1 = \\rho(w) - 1 = \\rho(w0)</span> . On the other hand, if  <span class="math">\\rho(w) = 0</span>  then  <span class="math">\\rho(w0)</span>  is zero as well. It follows that  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_{\\rho}) \\geq \\operatorname{reach}_{F&#x27;}(\\sigma) = 0 = \\rho(w0)</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-1&quot;&gt;&lt;/span&gt;<strong>Proposition 4.</strong> Assume the premise of Theorem 5 with b = 0. Then F' contains a tine-pair  <span class="math">(\\tau_{\\rho w}, \\tau_w)</span>  that witnesses  <span class="math">\\mu_w(0)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that the tine  <span class="math">\\sigma \\in F&#x27;</span> ,  <span class="math">\\ell(\\sigma) = |w| + 1</span>  is a conservative extension to a tine  <span class="math">s \\in F</span> , reach <span class="math">_F(s) = 0</span>  so that reach <span class="math">_{F&#x27;}(\\sigma) = 0</span> . In addition, since F' contains a single vertex at slot |w| + 1,  <span class="math">\\tau_w</span>  and  <span class="math">\\tau_{\\rho w}</span>  are disjoint over the suffix  <span class="math">w_{n+1}</span>  and, moreover, reach <span class="math">_{F&#x27;}(\\tau_{\\rho w}) = \\rho(F&#x27;) = \\rho(w0)</span>  by Proposition 3. Now consider the following contingencies based on  <span class="math">\\rho(w)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\rho(w) &gt; 0</span> . Thus  <span class="math">\\mu_w(0) = \\mu_w(\\varepsilon) 1 = \\rho(w) 1 = \\rho(w0)</span> . There are two mutually exclusive scenarios based on  <span class="math">\\tau_{\\rho w}</span>  and  <span class="math">\\sigma</span> . If  <span class="math">\\tau_{\\rho w} = \\sigma</span>  then, by construction,  <span class="math">\\tau_w \\neq \\sigma</span>  (since  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span> ) and, in addition, reach  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  are two mutually exclusive scenarios based on  <span class="math">\\tau_{\\rho w}</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  are the  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  are the  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{\\rho w}, \\tau_w) \\leq |w|</span>  and  <span class="math">\\ell(\\tau_{</span></li>
      <li>If  <span class="math">\\rho(w) = 0</span> . Since  <span class="math">\\rho(F) = \\rho(w) = 0</span> , Fact 2 tells us that every F-tine must have a negative reach in F'. Since  <span class="math">\\rho(F&#x27;)</span>  is non-negative, it must be the case that  <span class="math">\\tau_{\\rho w} = \\sigma</span> . We can reuse the argument from the subcase &quot; <span class="math">\\tau_{\\rho w} = \\sigma</span> &quot; of the preceding case and conclude that  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_w) = \\mu_w(0)</span> .</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-30-2&quot;&gt;&lt;/span&gt;<strong>Proposition 5.</strong> Assume the premise of Theorem 5 with b = 0. Let x &lt; w and write w = xy. Then F' contains a tine-pair  <span class="math">(\\tau_{ox}, \\tau_x)</span>  that witnesses  <span class="math">\\mu_x(y0)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> By construction, reach <span class="math">_{F&#x27;}(\\tau_x) = \\mu_x(F&#x27;)</span>  and, by the definition of relative margin,  <span class="math">\\mu_x(F&#x27;) \\leq \\mu_x(y)</span> . In light of (13), it suffices to show that reach <span class="math">_{F&#x27;}(\\tau_x) \\geq 0</span>  if  <span class="math">\\rho(xy) &gt; \\mu_x(y) = 0</span> , and reach <span class="math">_{F&#x27;}(\\tau_x) \\geq \\mu_x(y) - 1</span>  otherwise. Let R be the set of F-tines with the maximal F-reach and let R' be the set of R'-tines with the maximal R'-reach; thus  <span class="math">\\pi_{\\rho x} \\in R&#x27;</span> . We know that  <span class="math">\\pi_{\\rho x} \\in R&#x27;</span> . We know that  <span class="math">\\pi_{\\rho x} \\in R&#x27;</span>  is  <span class="math">\\pi_{\\rho x} \\in R&#x27;</span> . Consider the following mutually exclusive cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\rho(w) &gt; 0</span>  and  <span class="math">\\mu_X(y) = 0</span> . In this case,  <span class="math">\\mu_X(y0) = 0</span>  using Lemma 3. Since  <span class="math">\\operatorname{reach}_F(s) = 0 &lt; \\operatorname{reach}_F(t_{\\rho X}) = \\rho(w)</span> , it follows that  <span class="math">s \\neq t_{\\rho X}</span> . In addition, observe that  <span class="math">t_{\\rho X}</span>  must be in R'. By our choice of s,  <span class="math">\\ell(s \\cap t_{\\rho X}) \\leq \\ell(t_X \\cap t_{\\rho X})</span>  since  <span class="math">\\operatorname{reach}_F(t_X) = \\mu_X(y) = 0 = \\operatorname{reach}_F(s)</span> . Since  <span class="math">t_X</span>  is y-disjoint with  <span class="math">t_{\\rho X}</span> , so is s. Recall that  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_X)</span>  is the largest among all tines that are y0-disjoint with  <span class="math">\\tau_{\\rho X}</span> .    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\tau_{\\rho x} = t_{\\rho x}</span> . Thus  <span class="math">t_x</span>  is y0-disjoint with  <span class="math">\\tau_{\\rho x}</span> . Since  <span class="math">\\ell(\\sigma) = |w| + 1</span> ,  <span class="math">\\sigma</span>  must be y0-disjoint with  <span class="math">t_{\\rho x} = \\tau_{\\rho x}</span> , it follows that  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x) \\ge \\operatorname{reach}_{F&#x27;}(\\sigma) = 0 = \\mu_x(y0)</span> .</li>
      <li>If  <span class="math">\\tau_{\\rho x} \\neq t_{\\rho x}</span> . This happens when  <span class="math">\\rho(w) = 1</span> ,  <span class="math">\\rho(w0) = 0</span> , and  <span class="math">t_{\\rho x}</span> ,  <span class="math">\\sigma \\in R&#x27;</span> . Note that  <span class="math">|R&#x27;| \\geq 2</span>  since both  <span class="math">\\sigma, t_{\\rho x} \\in R&#x27;</span>  but  <span class="math">\\sigma \\neq t_{\\rho x}</span> . If there are two y0-disjoint tines  <span class="math">r&#x27;_1, r&#x27;_2 \\in R&#x27;</span>  then  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x) \\geq 0 = \\mu_x(y0)</span> . Otherwise, all tines  <span class="math">r&#x27; \\in R&#x27;</span>  share a vertex indexed by y. Since  <span class="math">t_x</span>  is y-disjoint with  <span class="math">t_{\\rho x}</span> ,  <span class="math">t_x</span>  must be y-disjoint (and thus y0-disjoint) with every  <span class="math">r&#x27; \\in R&#x27;</span>  as well. Examining the rule for assigning  <span class="math">\\tau_x</span> , we conclude that  <span class="math">\\tau_x = t_x</span>  and, therefore,  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x) = \\operatorname{reach}_{F&#x27;}(t_x) = \\mu_x(y) = 0 = \\mu_x(y0)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If  <span class="math">\\rho(w)=0</span> . Let x &lt; w and note that  <span class="math">\\mu_X(y0)=\\mu_X(y)-1</span> . Since  <span class="math">\\rho(w)=0</span> , reach <span class="math">_F(s)=0</span>  all F-tines will have a negative reach in F'; by Fact 2,  <span class="math">\\sigma</span>  is the only tine in F' with the maximal reach  <span class="math">\\rho(F&#x27;)=\\rho(w0)=0</span> , i.e.,  <span class="math">\\tau_{\\rho x}=\\tau_{\\rho}=\\sigma</span> . In addition, we must also have reach <span class="math">_F(s)=0</span> , i.e.,  <span class="math">s\\in R</span> ; we conclude that s has the smallest  <span class="math">\\leq_{\\pi}</span>  rank among all members of R and, therefore,  <span class="math">s=t_{\\rho}</span> . It follows that  <span class="math">\\tau_x</span>  is y0-disjoint with  <span class="math">s=t_{\\rho}</span>  and, in particular,  <span class="math">\\tau_x\\in F</span> . Considering  <span class="math">t_x</span> , if it is y-disjoint with  <span class="math">t_{\\rho}</span>  then we must have  <span class="math">\\tau_x=t_x</span> ; in this case,  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x)=\\operatorname{reach}_{F&#x27;}(t_x)=\\operatorname{reach}_{F}(t_x)-1=\\mu_X(y)-1=\\mu_X(y0)</span> . Otherwise,  <span class="math">\\ell(t_x\\cap t_{\\rho})\\geq |x|+1</span>  and there must be a tine  <span class="math">t_{\\rho x}\\in F</span>  that is y-disjoint with  <span class="math">t_x</span>  (and hence, with  <span class="math">\\tau_{\\rho x}</span> ). Therefore,  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x)\\geq \\operatorname{reach}_{F&#x27;}(t_{\\rho x})\\geq \\operatorname{reach}_{F&#x27;}(t_x)=\\operatorname{reach}_{F}(t_x)-1=\\mu_X(y)-1</span> . Here, the first inequality follows from the construction of  <span class="math">\\tau_x</span>  and the second one follows since  <span class="math">t_{\\rho x}</span> ) has the maximal reach in F.</p>

    <p class="text-gray-300">If  <span class="math">\\rho(w) &gt; 0</span>  and  <span class="math">\\mu_x(y) \\neq 0</span> . There can be two cases depending on whether s has zero reach in F.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\operatorname{reach}_F(s) = 0</span> . Then  <span class="math">s \\notin \\{t_{\\rho x}, t_x\\}</span> . Observe that  <span class="math">\\operatorname{reach}_{F&#x27;}(t_{\\rho x}) = \\operatorname{reach}_F(t_{\\rho x}) 1 = \\rho(w) 1 = \\rho(w0)</span> . It follows that  <span class="math">t_{\\rho x} \\in R&#x27;</span> . Since  <span class="math">t_x</span>  is y0-disjoint with  <span class="math">t_{\\rho x} \\in R&#x27;</span>  and, in addition, that  <span class="math">\\tau_x</span>  has the largest reach among all tines that are y0-disjoint with some member of R', we conclude that  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x) \\geq \\operatorname{reach}_{F&#x27;}(t_x) = \\operatorname{reach}_F(t_x) 1 = \\mu_x(y) 1 = \\mu_x(y0)</span> .</li>
      <li>If  <span class="math">\\operatorname{reach}_F(s) \\geq 1</span> . In this case, s is the longest tine in F. Considering fork F', if some tine  <span class="math">r&#x27; \\in R&#x27;</span>  is y0-disjoint with  <span class="math">t_x</span>  then  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x) \\geq \\operatorname{reach}_{F&#x27;}(t_x) = \\operatorname{reach}_F(t_x) 1 = \\mu_x(y) 1 = \\mu_x(y)</span> 0. Otherwise,  <span class="math">\\ell(r&#x27; \\cap t_x) &gt; |x|</span>  for every tine  <span class="math">r&#x27; \\in R&#x27;</span> , i.e., no maximal-reach F'-tine is y0-disjoint with  <span class="math">t_x</span> . Since  <span class="math">\\ell(t_x, t_{\\rho x}) \\leq |x|</span>  by assumption and  <span class="math">\\tau_{\\rho x} \\in R&#x27;</span> , it follows that  <span class="math">\\ell(\\tau_{\\rho x} \\cap t_{\\rho x}) \\leq |x|</span> , i.e.,  <span class="math">t_{\\rho x}</span>  is y0-disjoint with  <span class="math">\\tau_{\\rho x}</span> . Therefore,  <span class="math">\\operatorname{reach}_{F&#x27;}(\\tau_x) \\geq \\operatorname{reach}_{F&#x27;}(t_{\\rho x}) = \\operatorname{reach}_F(t_{\\rho x}) 1 = \\rho(w) 1 \\geq \\mu_x(y) 1 = \\mu_x(y)</span> 0. Here, the second inequality is true since  <span class="math">\\mu_x(y) \\leq \\rho(xy) = \\rho(w)</span> .</li>
    </ul>

    <p class="text-gray-300">This completes the proof of Theorem 5.</p>

    <p class="text-gray-300">In regards to the canonical fork  <span class="math">F \\vdash w</span>  produced by the strategy  <span class="math">\\mathcal{A}^*</span>  (see Figure 4), it is possible to maintain witness tines  <span class="math">\\tau_\\rho, \\tau_m&#x27; \\in F</span> , for integers  <span class="math">m = -|w|, \\dots, |w|</span> , so that for every prefix  <span class="math">x \\prec w</span> , the tine-pair  <span class="math">(\\tau_\\rho, \\tau_{\\mu_x(y)}&#x27;)</span>  witnesses  <span class="math">\\mu_x(y)</span> . In particular, a single maxmimal-reach tine  <span class="math">\\tau_\\rho</span>  appears in every witness tine-pair. We omit futher details.</p>

    <h2 id="sec-29" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We are grateful to Shreyas Gandlur and Bruce Hajek (UIUC) for their suggestion about using the dominance argument in the proof of Bound 2.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">References</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-31-0&quot;&gt;&lt;/span&gt;[1] Adam Back. Hashcash. http://www.cypherspace.org/hashcash, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-31-2&quot;&gt;&lt;/span&gt;[2] Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas. Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. <em>IACR Cryptology ePrint Archive</em>, 2018:378, 2018.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-31-1&quot;&gt;&lt;/span&gt;[3] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. <em>CoRR</em>, abs/1406.5694, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-31-3&quot;&gt;&lt;/span&gt;[4] Iddo Bentov, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. <em>IACR Cryptology ePrint Archive</em>, 2016:919, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-31-4&quot;&gt;&lt;/span&gt;[5] Jonah Brown-Cohen, Arvind Narayanan, Christos-Alexandros Psomas, and S. Matthew Weinberg. Formal barriers to longest-chain proof-of-stake protocols. <em>CoRR</em>, abs/1809.06528, 2018.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-8&quot;&gt;&lt;/span&gt;[6] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In Nielsen and Rijmen <a href="#page-32-13">[19]</a>, pages 66â€“98.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-1&quot;&gt;&lt;/span&gt;[7] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In Ernest F. Brickell, editor, <em>Advances in Cryptology â€“ CRYPTO'92</em>, volume 740 of <em>Lecture Notes in Computer Science</em>, pages 139â€“147, Santa Barbara, CA, USA, August 16â€“20, 1993. Springer, Heidelberg, Germany.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-3&quot;&gt;&lt;/span&gt;[8] Stefan Dziembowski, Sebastian Faust, Vladimir Kolmogorov, and Krzysztof Pietrzak. Proofs of space. In Rosario Gennaro and Matthew J. B. Robshaw, editors, <em>Advances in Cryptology â€“ CRYPTO 2015, Part II</em>, volume 9216 of <em>Lecture Notes in Computer Science</em>, pages 585â€“605, Santa Barbara, CA, USA, August 16â€“20, 2015. Springer, Heidelberg, Germany.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-6&quot;&gt;&lt;/span&gt;[9] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, <em>Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Soa, Bulgaria, April 26-30, 2015, Proceedings, Part II</em>, volume 9057 of <em>Lecture Notes in Computer Science</em>, pages 281â€“310. Springer, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-10&quot;&gt;&lt;/span&gt;[10] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol with chains of variable diculty. In Jonathan Katz and Hovav Shacham, editors, <em>Advances in Cryptology â€“ CRYPTO 2017, Part I</em>, volume 10401 of <em>Lecture Notes in Computer Science</em>, pages 291â€“323, Santa Barbara, CA, USA, August 20â€“24, 2017. Springer, Heidelberg, Germany.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-7&quot;&gt;&lt;/span&gt;[11] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol with chains of variable diculty. In Jonathan Katz and Hovav Shacham, editors, <em>Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I</em>, volume 10401 of <em>Lecture Notes in Computer Science</em>, pages 291â€“323. Springer, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-12&quot;&gt;&lt;/span&gt;[12] Charles M. Grinstead and J. Laurie Snell. <em>Introduction to Probability</em>. American Mathematical Association, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-2&quot;&gt;&lt;/span&gt;[13] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Jonathan Katz and Hovav Shacham, editors, <em>Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference</em>, volume 10401 of <em>Lecture Notes in Computer Science</em>, pages 357â€“388. Springer, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-11&quot;&gt;&lt;/span&gt;[14] David A Levin, Yuval Peres, and Elizabeth L Wilmer. <em>Markov chains and mixing times</em>, volume 58. American Mathematical Society, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-9&quot;&gt;&lt;/span&gt;[15] Silvio Micali. ALGORAND: the ecient and democratic ledger. <em>CoRR</em>, abs/1607.01341, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-5&quot;&gt;&lt;/span&gt;[16] Tal Moran and Ilan Orlov. Proofs of space-time and rational proofs of storage. Cryptology ePrint Archive, Report 2016/035, 2016. <a href="http://eprint.iacr.org/2016/035">http://eprint.iacr.org/2016/035</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-14&quot;&gt;&lt;/span&gt;[17] Rajeev Motwani and Prabhakar Raghavan. <em>Randomized Algorithms</em>. Cambridge University Press, New York, NY, USA, 1995.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-0&quot;&gt;&lt;/span&gt;[18] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-13&quot;&gt;&lt;/span&gt;[19] Jesper Buus Nielsen and Vincent Rijmen, editors. <em>Advances in Cryptology - EUROCRYPT 2018 - 37th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Tel Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part II</em>, volume 10821 of <em>Lecture Notes in Computer Science</em>, 2018. Springer.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-4&quot;&gt;&lt;/span&gt;[20] Sunoo Park, Krzysztof Pietrzak, Albert Kwon, JoÃ«l Alwen, Georg Fuchsbauer, and Peter Gazi. Spacemint: A cryptocurrency based on proofs of space. <em>IACR Cryptology ePrint Archive</em>, 2015:528, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-0&quot;&gt;&lt;/span&gt;[21] Rafael Pass and Elaine Shi. The sleepy model of consensus. In Tsuyoshi Takagi and Thomas Peyrin, editors, <em>Advances in Cryptology - ASIACRYPT 2017 - 23rd International Conference on the Theory and Applications of Cryptology and Information Security, Hong Kong, China, December 3-7, 2017, Proceedings, Part II</em>, volume 10625 of <em>Lecture Notes in Computer Science</em>, pages 380â€“409. Springer, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-3&quot;&gt;&lt;/span&gt;[22] Rafael Pass and Elaine Shi. Hybrid consensus: Ecient consensus in the permissionless model. In AndrÃ©a W. Richa, editor, <em>31st International Symposium on Distributed Computing, DISC 2017, October 16-20, 2017, Vienna, Austria</em>, volume 91 of <em>LIPIcs</em>, pages 39:1â€“39:16. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-4&quot;&gt;&lt;/span&gt;[23] Rafael Pass and Elaine Shi. Thunderella: Blockchains with optimistic instant conrmation. In Nielsen and Rijmen <a href="#page-32-13">[19]</a>, pages 3â€“33.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-1&quot;&gt;&lt;/span&gt;[24] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Jean-SÃ©bastien Coron and Jesper Buus Nielsen, editors, <em>Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II</em>, volume 10211 of <em>Lecture Notes in Computer Science</em>, pages 643â€“673, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-6&quot;&gt;&lt;/span&gt;[25] Saad Quader and Alexander Russell. C++ source code to compute settlement error estimates. <a href="https://github.com/saad0105050/forkable-strings-code">https:</a> <a href="https://github.com/saad0105050/forkable-strings-code">//github.com/saad0105050/forkable-strings-code</a>, 2018. Accessed: 2019-10-14.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-5&quot;&gt;&lt;/span&gt;[26] Herbert S Wilf. <em>generatingfunctionology</em>. AK Peters/CRC Press, 3 edition, 2005.</p></li>
    </ul>

    <h2 id="sec-31" class="text-2xl font-bold">&lt;span id=&quot;page-33-2&quot;&gt;&lt;/span&gt;<strong>A Exact settlement probabilities</strong></h2>

    <p class="text-gray-300">Let ğ‘š, ğ‘˜ âˆˆ â„• and ğœ– âˆˆ (0, 1]. Let ğ‘¤ be a characteristic string of length ğ‘‡ = ğ‘š + ğ‘˜ such that the bits of ğ‘¤ are i.i.d. Bernoulli with expectation ğ›¼ = (1 âˆ’ ğœ–)âˆ•2. Write ğ‘¤ as ğ‘¤ = ğ‘¥ğ‘¦ where |ğ‘¥| = ğ‘š, |ğ‘¦| = ğ‘˜. The recursive denition of relative margin (cf. Lemma <a href="#page-17-2">3)</a> implies an algorithm for computing the probability Pr[ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ‘¦) â‰¥ 0] in time poly(ğ‘š, ğ‘˜). In typical circumstances, however, it is more interesting to establish an explicit upper bound on Pr[ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ‘¦) â‰¥ 0] where |ğ‘¥| â†’ âˆ; this corresponds to the case where the distribution of the initial reach ğœŒ(ğ‘¥) is the dominant distribution â„›&lt;sup&gt;âˆ&lt;/sup&gt; in Lemma <a href="#page-19-0">4.</a> Due to dominance, â„›âˆ(ğ‘š) serves as an upper bound on ğœŒ(ğ‘¥) for any nite ğ‘š = |ğ‘¥|. For this purpose, one can implicitly maintain a sequence of matrices (ğ‘€&lt;sup&gt;ğ‘¡&lt;/sup&gt; ) for ğ‘¡ = 0, 1, 2, â‹¯ , ğ‘˜ such that ğ‘€&lt;sup&gt;0&lt;/sup&gt; (ğ‘Ÿ, ğ‘Ÿ) = â„›âˆ(ğ‘Ÿ) for all 0 â‰¤ ğ‘Ÿ â‰¤ 2ğ‘˜ and the invariant</p>

    <p class="text-gray-300"><span class="math">$M_t(r, s) = \\Pr_{y \\sim \\mathcal{B}(t, \\alpha)} [\\rho(xy) = r \\text{ and } \\mu_x(y) = s]</span>$</p>

    <p class="text-gray-300">is satised for every integer ğ‘¡ âˆˆ [1, ğ‘˜], ğ‘Ÿ âˆˆ [0, 2ğ‘˜], and ğ‘  âˆˆ [âˆ’2ğ‘˜, 2ğ‘˜]. Here, ğ‘€(ğ‘–, ğ‘—) denotes the entry at the ğ‘–th row and ğ‘—th column of the matrix ğ‘€. Observe that ğ‘€&lt;sup&gt;ğ‘¡&lt;/sup&gt; (ğ‘Ÿ, ğ‘ ) can be computed solely from the neighboring cells of ğ‘€ğ‘¡âˆ’1, that is, from the values ğ‘€ğ‘¡âˆ’1(ğ‘Ÿ Â± 1, ğ‘  Â± 1). Of course, only the transitions approved by the recursions in Lemma <a href="#page-17-3">2</a> and Lemma <a href="#page-17-2">3</a> should be considered.</p>

    <p class="text-gray-300">Finally, one can compute Pr[ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ‘¦) â‰¥ 0] by summing ğ‘€&lt;sup&gt;ğ‘˜&lt;/sup&gt; (ğ‘Ÿ, ğ‘ ) for ğ‘Ÿ, ğ‘  â‰¥ 0. Table <a href="#page-34-1">1</a> contains these probabilities where ğ›¼ ranges from 0.05 to 0.40 and ğ‘˜ ranges from 50 to 1000. In addition, Figure <a href="#page-34-2">5</a> shows the base-10 logarithm of these probabilities. The points corresponding to a xed ğ›¼ appear to form a straight line. This means the probability decays exponentially in ğ‘˜, or equivalently, that the exponent depends linearly on ğ‘˜, as stipulated by Bound <a href="#page-18-4">1.</a></p>

    <p class="text-gray-300">A C++ implementation of the above algorithm is publicly available at <a href="https://github.com/saad0105050/forkable-strings-code">https://github.com/saad0105050/forkable</a><a href="https://github.com/saad0105050/forkable-strings-code">strings-code</a> <a href="#page-33-6">[25]</a>.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-1&quot;&gt;&lt;/span&gt;Table 1: Exact probabilities Pr[ğœ‡&lt;sup&gt;ğ‘¥&lt;/sup&gt; (ğ‘¦) â‰¥ 0] where the bits of the characteristic string ğ‘¥ğ‘¦ are i.i.d. Bernoulli with expectation ğ›¼. Each row of the table corresponds to a dierent ğ‘˜ = |ğ‘¦|.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">ğ‘˜</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">ğ›¼</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.40</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.37E-15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.16E-09</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.02E-06</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.68E-05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.96E-03</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.86E-02</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.36E-02</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.92E-01</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.23E-28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.10E-18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.52E-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.28E-08</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.03E-05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.00E-04</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.72E-02</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.37E-01</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">150</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.83E-42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.24E-26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.22E-17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.05E-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.54E-08</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.57E-05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.30E-03</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.74E-02</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">200</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.49E-56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.82E-35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.21E-23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.61E-15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.98E-10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.60E-06</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.40E-04</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.36E-02</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">250</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.49E-69</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.31E-43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.46E-28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.27E-19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.61E-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.21E-08</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.25E-04</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.69E-02</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">300</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.42E-83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.89E-51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.05E-34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.14E-22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.67E-15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.25E-09</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.44E-05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.52E-03</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">350</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.84E-97</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.29E-60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.75E-39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.02E-26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.67E-17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.46E-10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.78E-06</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.31E-03</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">400</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.80E-110</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.64E-68</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.06E-45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.02E-30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.52E-19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.59E-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.37E-07</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.18E-03</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">450</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.13E-124</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.60E-76</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.10E-50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.13E-33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.36E-21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.97E-13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.84E-07</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.11E-03</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.47E-138</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.00E-85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.26E-56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.67E-37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.32E-24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.34E-14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.60E-08</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.62E-04</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">550</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.17E-151</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.07E-93</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.51E-61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.51E-40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.95E-26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.02E-16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.05E-09</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.86E-04</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.98E-165</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.35E-101</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.70E-67</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.00E-44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.13E-28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.71E-17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.38E-09</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.45E-04</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">650</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.14E-178</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.91E-110</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.01E-72</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.06E-47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.15E-30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.22E-18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.71E-10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.37E-05</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">700</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.62E-192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.59E-118</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.04E-77</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.83E-51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.19E-33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.51E-20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.31E-11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.75E-05</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">750</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.02E-206</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.14E-126</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.61E-83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.52E-55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.33E-35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.48E-21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.04E-11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.91E-05</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">800</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.38E-219</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.99E-135</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.25E-88</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.00E-58</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.80E-37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.12E-22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.04E-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.69E-06</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">850</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.17E-233</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.19E-143</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.33E-94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.31E-62</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.69E-40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.04E-24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.00E-13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.93E-06</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">900</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.27E-247</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.61E-152</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.50E-99</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.41E-65</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.23E-42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.27E-25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.84E-14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.50E-06</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">950</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.67E-260</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.22E-160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.19E-105</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.75E-69</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.82E-44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.02E-26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.54E-14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.27E-06</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.83E-274</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.85E-168</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.80E-110</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.98E-73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.52E-46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.61E-28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.01E-15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.48E-07</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-34-2&quot;&gt;&lt;/span&gt;    <img src="_page_34_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 5: The probabilities from Table <a href="#page-34-1">1</a> drawn in the base-10 logarithmic scale.</p>

    <h2 id="sec-32" class="text-2xl font-bold">&lt;span id=&quot;page-34-0&quot;&gt;&lt;/span&gt;<strong>B A forkability bound for strings satisfying the</strong> ğœ–<strong>-martingale condition</strong></h2>

    <p class="text-gray-300">Below we present a bound (Bound <a href="#page-35-0">3)</a> on the probability that a characteristic string satisfying the ğœ–-martingale condition has a non-negative relative margin. We remark that the bound below is weaker than Bound <a href="#page-18-3">2.</a> Before we proceed, recall the following standard large deviation bound for supermartingales.</p>

    <p class="text-gray-300"><strong>Theorem 6</strong> (Azuma's inequality (Azuma; Hoeffding). See [17, 4.16] for a discussion). Let  <span class="math">X_0, ..., X_n</span>  be a sequence of real-valued random variables so that, for all t,  <span class="math">\\mathbb{E}[X_{t+1} \\mid X_0, ..., X_t] \\leq X_t</span>  and  <span class="math">|X_{t+1} - X_t| \\leq c</span>  for some constant c. Then  <span class="math">\\Pr[X_n - X_0 \\geq \\Lambda] \\leq \\exp(-\\Lambda^2/2nc^2)</span>  for every  <span class="math">\\Lambda \\geq 0</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-35-0&quot;&gt;&lt;/span&gt;<strong>Bound 3.</strong> Let  <span class="math">x \\in \\{0,1\\}^m</span>  and  <span class="math">y \\in \\{0,1\\}^k</span>  be random variables, satisfying the  <span class="math">\\epsilon</span> -martingale condition (with respect to the ordering  <span class="math">x_1, \\dots, x_m, y_1, \\dots, y_k</span> ). Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mu_x(y) \\ge 0] \\le 3 \\exp(-\\epsilon^4 (1 - O(\\epsilon))k/64)</span>$
.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">w_1, w_2, ...</span>  be random variables obeying the  <span class="math">\\varepsilon</span> -martingale condition. Specifically,  <span class="math">\\Pr[w_t = 1 \\mid E] \\le (1-\\varepsilon)/2</span>  conditioned on any event E expressed in the variables  <span class="math">w_1, ..., w_{t-1}</span> . For convenience, define the associated  <span class="math">\\{\\pm 1\\}</span> -valued random variables  <span class="math">W_t = (-1)^{1+w_t}</span>  and observe that  <span class="math">\\mathbb{E}[W_t] \\le -\\varepsilon</span> .</p>

    <p class="text-gray-300">If x is empty. Observe that in this case, the relative margin  <span class="math">\\mu_x(y)</span>  reduces to the non-relative margin  <span class="math">\\mu(y)</span>  from Lemma 2. Since the sequence  <span class="math">y_1, y_2, ...</span>  in the statement of the claim is identical to the sequence  <span class="math">w_1, w_2, ...</span>  defined above, we focus on the reach and margin of the latter sequence. Specifically, define  <span class="math">\\rho_t = \\rho(w_1 ... w_t)</span>  and  <span class="math">\\mu_t = \\mu(w_1 ... w_t)</span>  to be the two random variables from Lemma 2 acting on the string  <span class="math">w = w_1 ... w_t</span> . The analysis will rely on the ancillary random variables  <span class="math">\\overline{\\mu}_t = \\min(0, \\mu_t)</span> . Observe that  <span class="math">\\Pr[w \\text{ forkable}] = \\Pr[\\mu(w) \\ge 0] = \\Pr[\\overline{\\mu}_k = 0]</span> , so we may focus on the event that  <span class="math">\\overline{\\mu}_k = 0</span> . As an additional preparatory step, define the constant  <span class="math">\\alpha = (1+\\epsilon)/(2\\epsilon) \\ge 1</span>  and define the random variables  <span class="math">\\Phi_t \\in \\mathbb{R}</span>  by the inner product</p>

    <p class="text-gray-300"><span class="math">$\\Phi_t = (\\rho_t, \\overline{\\mu}_t) \\cdot \\begin{pmatrix} 1 \\\\ \\alpha \\end{pmatrix} = \\rho_t + \\alpha \\overline{\\mu}_t.</span>$</p>

    <p class="text-gray-300">The  <span class="math">\\Phi_t</span>  will act as a &quot;potential function&quot; in the analysis: we will establish that  <span class="math">\\Phi_k &lt; 0</span>  with high probability and, considering that  <span class="math">\\alpha \\overline{\\mu}_k \\le \\rho_k + \\alpha \\overline{\\mu}_k = \\Phi_k</span> , this implies  <span class="math">\\overline{\\mu}_k &lt; 0</span> , as desired.</p>

    <p class="text-gray-300">Let  <span class="math">\\Delta_t = \\Phi_t - \\Phi_{t-1}</span> ; we claim thatâ€”conditioned on any fixed value  <span class="math">(\\rho, \\mu)</span>  for  <span class="math">(\\rho_t, \\mu_t)</span> â€”the random variable  <span class="math">\\Delta_{t+1} \\in [-(1+\\alpha), 1+\\alpha]</span>  has expectation no more than  <span class="math">-\\epsilon</span> . The analysis has four cases, depending on the various regimes of  <span class="math">\\rho</span>  and  <span class="math">\\mu</span>  from Lemma 2. When  <span class="math">\\rho &gt; 0</span>  and  <span class="math">\\mu &lt; 0</span> ,  <span class="math">\\rho_{t+1} = \\rho + W_{t+1}</span>  and  <span class="math">\\overline{\\mu}_{t+1} = \\overline{\\mu} + W_{t+1}</span> , where  <span class="math">\\overline{\\mu} = \\max(0, \\mu)</span> ; then  <span class="math">\\Delta_{t+1} = (1+\\alpha)W_{t+1}</span>  and  <span class="math">\\mathbb{E}[\\Delta_{t+1}] \\le -(1+\\alpha)\\epsilon \\le -\\epsilon</span> . When  <span class="math">\\rho &gt; 0</span>  and  <span class="math">\\mu \\ge 0</span> ,  <span class="math">\\rho_{t+1} = \\rho + W_{t+1}</span>  but  <span class="math">\\overline{\\mu}_{t+1} = \\overline{\\mu}</span>  so that  <span class="math">\\Delta_{t+1} = W_{t+1}</span>  and  <span class="math">\\mathbb{E}[\\Delta_{t+1}] \\le -\\epsilon</span> . Similarly, when  <span class="math">\\rho = 0</span>  and  <span class="math">\\mu &lt; 0</span> ,  <span class="math">\\overline{\\mu}_{t+1} = \\overline{\\mu} + W_{t+1}</span>  while  <span class="math">\\rho_{t+1} = \\rho + \\max(0, W_{t+1})</span> ; we may compute</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[\\Delta_{t+1}] \\leq \\frac{1-\\epsilon}{2}(1+\\alpha) - \\frac{1+\\epsilon}{2}\\alpha = \\frac{1-\\epsilon}{2} - \\epsilon\\alpha = \\frac{1-\\epsilon}{2} - \\epsilon\\left(\\frac{1}{\\epsilon} \\cdot \\frac{1+\\epsilon}{2}\\right) = -\\epsilon\\,.</span>$</p>

    <p class="text-gray-300">Finally, when  <span class="math">\\rho=\\mu=0</span>  exactly one of the two random variables  <span class="math">\\rho_{t+1}</span>  and  <span class="math">\\overline{\\mu}_{t+1}</span>  differs from zero: if  <span class="math">W_{t+1}=1</span>  then  <span class="math">(\\rho_{t+1},\\overline{\\mu}_{t+1})=(1,0)</span> ; likewise, if  <span class="math">W_{t+1}=-1</span>  then  <span class="math">(\\rho_{t+1},\\overline{\\mu}_{t+1})=(0,-1)</span> . It follows that</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[\\Delta_{t+1}] \\leq \\frac{1-\\epsilon}{2} - \\frac{1+\\epsilon}{2}\\alpha \\leq -\\epsilon \\,.</span>$</p>

    <p class="text-gray-300">Thus  <span class="math">\\mathbb{E}[\\Phi_k] = \\mathbb{E}\\sum_{t=1}^k \\Delta_t \\le -\\epsilon k</span> . We wish to apply Azuma's inequality to conclude that  <span class="math">\\Pr[\\Phi_k \\ge 0]</span>  is exponentially small. For this purpose, we transform the random variables  <span class="math">\\Phi_t</span>  to a related supermartingale by shifting them: specifically, define  <span class="math">\\tilde{\\Phi}_t = \\Phi_t + \\epsilon t</span>  and  <span class="math">\\tilde{\\Delta}_t = \\Delta_t + \\epsilon</span>  so that  <span class="math">\\tilde{\\Phi}_t = \\sum_i^t \\tilde{\\Delta}_t</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[\\tilde{\\Phi}_{t+1} \\mid \\tilde{\\Phi}_1, \\dots, \\tilde{\\Phi}_t] = \\mathbb{E}[\\tilde{\\Phi}_{t+1} \\mid W_1, \\dots, W_t] \\leq \\tilde{\\Phi}_t \\,, \\qquad \\tilde{\\Delta}_t \\in [-(1+\\alpha)+\\epsilon, 1+\\alpha+\\epsilon] \\,,</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\tilde{\\Phi}_k = \\Phi_k + \\epsilon k</span> . It follows from Azuma's inequality that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-36-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\begin{split} \\Pr[w \\text{ forkable}] &amp;= \\Pr[\\overline{\\mu}_k = 0] \\leq \\Pr[\\Phi_k \\geq 0] = \\Pr[\\tilde{\\Phi}_k \\geq \\varepsilon k] \\\\ &amp;\\leq \\exp\\left(-\\frac{\\varepsilon^2 k^2}{2k(1+\\alpha+\\varepsilon)^2}\\right) = \\exp\\left(-\\left(\\frac{2\\varepsilon^2}{1+3\\varepsilon+2\\varepsilon^2}\\right)^2 \\cdot \\frac{k}{2}\\right) \\\\ &amp;\\leq \\exp\\left(-\\frac{2\\varepsilon^4}{1+35\\varepsilon} \\cdot k\\right). \\end{split} \\tag{20}</span>$</p>

    <p class="text-gray-300">If x is not empty. In this case, we go back to study the sequences x and y as in the statement of the claim. Recall the reach distribution (i.e., the distribution of the random variable  <span class="math">\\rho(x)</span> )  <span class="math">\\mathcal{R}_m:\\mathbb{Z}\\to[0,1]</span>  from (18). Since  <span class="math">x=(x_1,\\ldots,x_m)</span>  satisfies the  <span class="math">\\varepsilon</span> -martingale condition, Lemma 4 states that  <span class="math">\\mathcal{R}_m\\leq\\mathcal{R}_\\infty</span> . We reserve the symbol  <span class="math">\\mu_x^{(r)}</span>  for the relative margin random walk  <span class="math">\\mu_x</span>  which starts at a non-negative initial position r. Thus  <span class="math">\\rho(x)=\\mu_x(\\varepsilon)=r</span> , and</p>

    <p class="text-gray-300">&lt;span id=&quot;page-36-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\Pr[\\mu_{x}(y) \\ge 0] = \\sum_{r \\ge 0} \\mathcal{R}_{m}(r) \\Pr[\\mu_{x}^{(r)}(y) \\ge 0] \\le \\sum_{r \\ge 0} \\mathcal{R}_{\\infty}(r) \\Pr[\\mu_{x}^{(r)}(y) \\ge 0]</span>$
(21)</p>

    <p class="text-gray-300">since the sequence  <span class="math">(\\Pr[\\mu_x^{(r)}(y) \\ge 0])_{r=0}^{\\infty}</span>  is non-decreasing and  <span class="math">\\mathcal{R}_m \\le \\mathcal{R}_{\\infty}</span> . Fix a &quot;large enough&quot; positive integer  <span class="math">r^*</span>  whose value will be assigned later in the analysis. Let us define the following events:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Event  <span class="math">B_r</span> : it occurs when  <span class="math">r \\in [0, r^*]</span>  and the  <span class="math">\\mu_\\chi^{(r)}</span>  walk is strictly positive on every prefix of y with length at most k/2; and</li>
      <li>Event  <span class="math">C_{r,s}</span> : it occurs when  <span class="math">r \\in [0, r^*]</span>  and  <span class="math">\\hat{y}</span>  is the smallest prefix of y of length  <span class="math">s \\in [r, k/2]</span>  such that  <span class="math">\\mu_x^{(r)}(\\hat{y}) = 0</span> . We say that  <span class="math">\\hat{y}</span>  is a witnesses to the event  <span class="math">C_{r,s}</span> .</li>
    </ul>

    <p class="text-gray-300">The right-hand side of (21) can be written as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{r&gt;r^*} \\mathcal{R}_{\\infty}(r) \\Pr[\\mu_x^{(r)}(y) \\geq 0] + \\sum_{r \\leq r^*} \\mathcal{R}_{\\infty}(r) \\Pr[\\mathsf{B}_r] \\cdot \\Pr\\left[\\mu_x^{(r)}(y) \\geq 0 \\mid \\mathsf{B}_r\\right] \\\\ &amp;+ \\sum_{r \\leq r^*} \\mathcal{R}_{\\infty}(r) \\sum_{s=r}^{k/2} \\Pr[\\mathsf{C}_{r,s}] \\cdot \\Pr[\\mu_x^{(r)}(y) \\geq 0 \\mid \\mathsf{C}_{r,s}] \\,. \\end{split}</span>$</p>

    <p class="text-gray-300">We observe that the probabilities  <span class="math">\\Pr[\\mu_x^{(r)}(y) \\ge 0]</span>  and  <span class="math">\\Pr[\\mu_x^{(r)}(y) \\ge 0 \\mid \\mathsf{B}_r]</span>  are at most one. In addition, recall that for two non-negative sequences  <span class="math">(a_i)</span> ,  <span class="math">(b_i)</span>  of equal lengths, we have  <span class="math">\\sum a_i b_i \\le \\max b_i</span>  if  <span class="math">\\sum a_i \\le 1</span> . Thus (21) can be simplified as</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\Pr[\\mu_{x}(y) \\geq 0] &amp;\\leq \\sum_{r &gt; r^{*}} \\mathcal{R}_{\\infty}(r) + \\sum_{r \\leq r^{*}} \\mathcal{R}_{\\infty}(r) \\Pr[\\mathsf{B}_{r}] \\\\ &amp;+ \\sum_{r \\leq r^{*}} \\mathcal{R}_{\\infty}(r) \\max_{r \\leq s \\leq k/2} \\Pr[\\mu_{x}^{(r)}(y) \\geq 0 \\mid \\mathsf{C}_{r,s}] \\\\ &amp;\\leq \\sum_{r &gt; r^{*}} \\mathcal{R}_{\\infty}(r) + \\max_{r \\leq r^{*}} \\Pr[\\mathsf{B}_{r}] + \\max_{\\substack{r \\leq r^{*} \\\\ r \\leq s \\leq k/2}} \\Pr[\\mu_{x}^{(r)}(y) \\geq 0 \\mid \\mathsf{C}_{r,s}]. \\end{aligned} \\tag{22}</span>$</p>

    <p class="text-gray-300">The first term in (22) is the right-tail of the distribution  <span class="math">\\mathcal{R}_{\\infty}</span> . Using Lemma 4, this quantity is at most  <span class="math">\\beta^{r^*}</span>  where  <span class="math">\\beta := (1 - \\epsilon)/(1 + \\epsilon)</span> . Furthermore, it can be easily checked that the above quantity is at most  <span class="math">\\exp(-5\\epsilon/3)</span> . The second term in (22) concerns the event  <span class="math">B_r</span>  and calls for more care. Define</p>

    <p class="text-gray-300">&lt;span id=&quot;page-36-1&quot;&gt;&lt;/span&gt;
<span class="math">$S_k^{(r)} := \\sum_{t=0}^k W_t</span>$</p>

    <p class="text-gray-300">where  <span class="math">W_0 = r</span>  and the random variables  <span class="math">W_t</span>  are defined at the outset of this proof for  <span class="math">t \\ge 1</span> . We know that the  <span class="math">\\mu_x^{(r)}</span>  walk starts with  <span class="math">\\rho(x) = \\mu(x) = r \\ge 0</span> . Since  <span class="math">B_r</span>  holds, both the margin  <span class="math">\\mu_x(\\hat{y})</span>  and the reach  <span class="math">\\rho(x\\hat{y})</span>  remain non-negative for all prefixes  <span class="math">\\hat{y}</span>  of length  <span class="math">t = 1, 2, \\dots, k/2</span> . These two facts imply that the random variable  <span class="math">\\mu_x^{(r)}(\\hat{y})</span>  is identical to the sum  <span class="math">S_t^{(r)}</span>  for all prefixes  <span class="math">\\hat{y}</span>  of length  <span class="math">t = 1, 2, \\dots, k/2</span> .</p>

    <p class="text-gray-300">To be precise,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{B}_r] = \\Pr[S_t^{(r)} \\ge 0 \\quad \\text{for all } t \\le k/2].</span>$</p>

    <p class="text-gray-300">The latter probability is at most  <span class="math">\\Pr[S_{k/2}^{(r)} \\ge 0]</span>  because the event  <span class="math">S_{k/2}^{(r)} \\ge 0</span>  does not constrain the intermediate sums  <span class="math">S_t^{(r)}</span>  for t &lt; k/2. Since  <span class="math">\\Pr[S_{k/2}^{(r)} \\ge 0]</span>  increases monotonically in r, we conclude that the second term in (22) is at most  <span class="math">\\Pr[S_{k/2}^{(r^*)} \\ge 0]</span> . Now we are free to shift our focus from the relative margin walk to the sum of a martingale sequence.</p>

    <p class="text-gray-300">For notational clarity, let us write  <span class="math">S:=S_{k/2}^{(r^*)}</span> . Since the sequence  <span class="math">(w_t)</span>  obeys the  <span class="math">\\epsilon</span> -martingale condition,  <span class="math">\\mathbb{E} S</span>  is at most  <span class="math">M:=r^*-k\\epsilon/2</span> . Let us set  <span class="math">r^*=W_0=k\\epsilon/4</span> . Then  <span class="math">\\mathbb{E} S</span>  is at most  <span class="math">-k\\epsilon/4</span>  and Azuma's inequality gives us</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S \\geq 0] = \\Pr[(S - \\mathbb{E}\\,S) \\geq k\\varepsilon/4] \\leq \\exp\\left(-\\frac{(k\\varepsilon/4)^2}{2(k/2)\\cdot 2^2}\\right) = \\exp\\left(-\\frac{k\\varepsilon^2}{64}\\right).</span>$</p>

    <p class="text-gray-300">This is an upper bound on the second term in (22).</p>

    <p class="text-gray-300">The third term in (22) concerns the event  <span class="math">C_{r,s}</span>  and it can be bounded using our existing analysis of the |x|=0 case. Specifically, suppose  <span class="math">y=\\hat{y}z</span>  where  <span class="math">\\hat{y}</span>  is a witness to the event  <span class="math">C_{r,s}</span> . Since the  <span class="math">\\mu_x^{(r)}</span>  walk remains non-negative over the entire string  <span class="math">\\hat{y}</span> , it follows that  <span class="math">\\rho(x\\hat{y})=\\mu(x\\hat{y})=0</span>  and as a consequence, the  <span class="math">\\mu_{x\\hat{y}}</span>  walk on z is identical to the  <span class="math">\\mu</span>  walk on z. Our analysis in the |x|=0 case suggests that  <span class="math">\\Pr[\\mu(z)\\geq 0]</span>  is at most  <span class="math">A(k-s,\\varepsilon)</span>  where |z|=k-s and  <span class="math">A(k,\\varepsilon)</span>  is the bound in (20). Since  <span class="math">A(\\cdot,\\varepsilon)</span>  decreases monotonically in the first argument,  <span class="math">A(k-s,\\varepsilon)</span>  is at most  <span class="math">A(k/2,\\varepsilon)</span> . However, since the last quantity is independent of r, the third term in (22) is at most  <span class="math">A(k/2,\\varepsilon)=\\exp\\left(-k\\varepsilon^4/(1+35\\varepsilon)\\right)</span> .</p>

    <p class="text-gray-300">Returning to (22) and using  <span class="math">r^* = k\\epsilon/4</span> , we get</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mu_x(y) \\ge 0] \\le \\exp\\left(-\\frac{5\\epsilon}{3} \\cdot \\frac{k\\epsilon}{4}\\right) + \\exp\\left(-\\frac{2\\epsilon^4}{1 + 35\\epsilon} \\cdot \\frac{n}{2}\\right) + \\exp\\left(-\\frac{k\\epsilon^2}{64}\\right).</span>$</p>

    <p class="text-gray-300">It is easy to check that the above quantity is at most  <span class="math">3 \\exp\\left(-k\\varepsilon^4/(64+35\\varepsilon)\\right) = 3 \\exp\\left(-\\varepsilon^4(1-O(\\varepsilon))k/64\\right)</span> .</p>

`;
---

<BaseLayout title="The combinatorics of the longest-chain rule: Linear consiste... (2017/241)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/241
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-combinatorics-of-the-longest-chain-rule-linear-2017" />
  </article>
</BaseLayout>
