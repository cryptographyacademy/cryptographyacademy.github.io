---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/222';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Tight security bounds for key-alternating ciphers';
const AUTHORS_HTML = 'Shan Chen, John Steinberger';

const CONTENT = `    <p class="text-gray-300">Shan Chen, John Steinberger* **</p>

    <p class="text-gray-300">Institute for Interdisciplinary Information Sciences, Tsinghua University, Beijing.</p>

    <p class="text-gray-300">dragoncs16@gmail.com, jpsteinb@gmail.com</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Abstract. A  <span class="math">t</span> -round key-alternating cipher (also called iterated Even-Mansour cipher) can be viewed as an abstraction of AES. It defines a cipher  <span class="math">E</span>  from  <span class="math">t</span>  fixed public permutations  <span class="math">P_{1}, \\ldots, P_{t} : \\{0, 1\\}^{n} \\to \\{0, 1\\}^{n}</span>  and a key  $k = k_{0} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{t} \\in \\{0, 1\\}^{n(t + 1)}<span class="math">  by setting  </span>E_{k}(x) = k_{t} \\oplus P_{t}(k_{t - 1} \\oplus P_{t - 1}(\\cdots k_{1} \\oplus P_{1}(k_{0} \\oplus x) \\cdots))<span class="math"> . The indistinguishability of  </span>E_{k}<span class="math">  from a truly random permutation by an adversary who also has oracle access to the (public) random permutations  </span>P_{1}, \\ldots, P_{t}<span class="math">  was investigated in 1997 by Even and Mansour for  </span>t = 1<span class="math">  and for higher values of  </span>t<span class="math">  in a series of recent papers. For  </span>t = 1<span class="math"> , Even and Mansour proved indistinguishability security up to  </span>2^{n/2}<span class="math">  queries, which is tight. Much later Bogdanov et al. (2011) conjectured that security should be  </span>2^{\\frac{1}{t + 1} n}<span class="math">  queries for general  </span>t<span class="math"> , which matches an easy distinguishing attack (so security cannot be more). A number of partial results have been obtained supporting this conjecture, besides Even and Mansour&#x27;s original result for  </span>t = 1<span class="math"> : Bogdanov et al. proved security of  </span>2^{\\frac{2}{3} n}<span class="math">  for  </span>t \\geq 2<span class="math"> , Steinberger (2012) proved security of  </span>2^{\\frac{2}{4} n}<span class="math">  for  </span>t \\geq 3<span class="math"> , and Lampe, Patarin and Seurin (2012) proved security of  </span>2^{\\frac{1}{t + 2} n}<span class="math">  for all even values of  </span>t<span class="math"> , thus &quot;barely&quot; falling short of the desired  </span>2^{\\frac{1}{t + 1} n}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our contribution in this work is to prove the long-sought-for security bound of  <span class="math">2^{\\frac{1}{t + 1} n}</span> , up to a constant multiplicative factor depending on  <span class="math">t</span> . Our method is essentially an application of Patarin's H-coefficient technique.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given  <span class="math">t</span>  permutations  <span class="math">P_{1},\\ldots ,P_{t}:\\{0,1\\}^{n}\\to \\{0,1\\}^{n}</span>  the  <span class="math">t</span> -round key-alternating cipher based on  <span class="math">P_{1},\\ldots ,P_{t}</span>  is a blockcipher  <span class="math">E:\\{0,1\\}^{(t + 1)n}\\times \\{0,1\\}^n\\to \\{0,1\\}^n</span>  of keyspace  <span class="math">\\{0,1\\}^{(t + 1)n}</span>  and message space  <span class="math">\\{0,1\\}^n</span> , where for a key  $k = k_0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_t\\in \\{0,1\\}^{(t + 1)n}<span class="math">  and a message  </span>x\\in \\{0,1\\}^n$  we set</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">E (k, x) = k _ {t} \\oplus P _ {t} \\left(k _ {t - 1} \\oplus P _ {t - 1} \\left(\\dots P _ {1} \\left(k _ {0} \\oplus x\\right) \\dots\\right)\\right). \\tag {1}</span></div>

    <p class="text-gray-300">(See Figure 1.) Plainly,  <span class="math">E(k,\\cdot)</span>  is a permutation of  <span class="math">\\{0,1\\}^n</span>  for each fixed  <span class="math">k\\in \\{0,1\\}^{(t + 1)n}</span> ; we let  <span class="math">E^{-1}(k,\\cdot)</span>  denote the inverse permutation. The  <span class="math">P_{i}</span> 's are called the round permutations of  <span class="math">E</span>  and  <span class="math">t</span>  is the number of rounds of  <span class="math">E</span> . Thus  <span class="math">t</span>  and the permutations  <span class="math">P_{1},\\ldots ,P_{t}</span>  are parameters determining  <span class="math">E</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. A  <span class="math">t</span> -round key alternating cipher.</p>

    <p class="text-gray-300">Key-alternating ciphers were first proposed (for values of  <span class="math">t</span>  greater than 1) by the designers of AES [5,6], the Advanced Encryption Standard. Indeed, AES-128 itself can be viewed as a particular</p>

    <p class="text-gray-300">instantiation of the key-alternating cipher paradigm in which the round permutations <span class="math">P_{1},\\ldots,P_{t}</span> equal a single permutation <span class="math">P</span> (the Rijndael round function, in this case), in which <span class="math">t=10</span>, and in which only a subset of the <span class="math">\\{0,1\\}^{(t+1)n}=\\{0,1\\}^{11n}</span> possible keys are used (more precisely, the <span class="math">11n</span> bits of key are derived pseudorandomly from a seed of <span class="math">n</span> bits, making the key space <span class="math">\\{0,1\\}^{n}=\\{0,1\\}^{128}</span>). However, for <span class="math">t=1</span> the design was proposed much earlier by Even and Mansour as a means of constructing a blockcipher from a fixed permutation <em>[7]</em>. Indeed, key-alternating ciphers also go by the name of iterated Even-Mansour ciphers.</p>

    <p class="text-gray-300">Even and Mansour accompanied their proposal with “provable security” guarantees by showing that, for <span class="math">t=1</span>, an adversary needs roughly <span class="math">2^{n/2}</span> queries to distinguish <span class="math">E(k,\\cdot)</span> for a random key <span class="math">k</span> (<span class="math">k</span> being hidden from the adversary) from a true random permutation, in a model where the adversary is given oracle access to <span class="math">E(k,\\cdot)</span>, <span class="math">E^{-1}(k,\\cdot)</span> as well as to <span class="math">P_{1}</span>, <span class="math">P_{1}^{-1}</span>, where <span class="math">P_{1}</span> is modeled as a random permutation (in the dummy world, the adversary is given oracle access to two independent random permutations and their inverses). Their bound was matched by Daemen <em>[4]</em>, who showed a <span class="math">2^{n/2}</span>-query distinguishing attack for <span class="math">t=1</span>.</p>

    <p class="text-gray-300">For <span class="math">t&gt;1</span>, we can generalize the Even-Mansour indistinguishability experiment by giving the adversary oracle access to <span class="math">P_{1},\\ldots,P_{t}</span> and their inverses and to <span class="math">E(k,\\cdot)</span>, <span class="math">E^{-1}(k,\\cdot)</span> in the real world (for a randomly chosen, hidden <span class="math">k\\in\\{0,1\\}^{(t+1)n}</span>), and to a tuple of <span class="math">t+1</span> independent random permutations and their inverses in the “ideal” or “dummy” world (see Figure 2). In this case, Daemen’s attack can be easily generalized to an attack of query complexity <span class="math">2^{\\frac{t}{t+1}n}</span>, as pointed out by Bogdanov et al. <em>[2]</em>, but the security analysis of Even and Mansour could not be easily generalized to match this bound (though security of <span class="math">2^{n/2}</span> queries still holds, and is easy to prove in a black-box fashion from the Even-Mansour result).</p>

    <p class="text-gray-300">Bogdanov et al. did show, though, security of <span class="math">2^{\\frac{2}{3}n}</span> for <span class="math">t\\geq 2</span> (modulo lower-order terms), which is tight for <span class="math">t=2</span> as it matches the <span class="math">2^{\\frac{t}{t+1}n}</span>-query attack. Later Steinberger <em>[19]</em> improved this bound to <span class="math">2^{\\frac{2}{4}n}</span> queries for <span class="math">t\\geq 3</span> by modifying technical aspects of Bogdanov et al.’s analysis. Orthogonally and simultaneously, Lampe, Patarin and Seurin <em>[13]</em> used coupling-based techniques to show security of <span class="math">2^{\\frac{t}{t+1}n}</span> queries for nonadaptive adversaries and security <span class="math">2^{\\frac{t}{t+2}n}</span> for adaptive adversaries (and even values of <span class="math">t</span>). While the bound <span class="math">2^{\\frac{t}{t+2}n}</span> might seem “almost” sharp, we note that</p>

    <p class="text-gray-300"><span class="math">2^{\\frac{t}{t+2}n}=2^{\\frac{(t/2)}{(t/2)+1}n}</span></p>

    <p class="text-gray-300">is actually the conjectured adaptive security for <span class="math">t/2</span> rounds. Indeed, Lampe et al. basically show that an adaptive adversary attacking the <span class="math">t</span>-round construction has no more advantage than a nonadapative adversary attacking <span class="math">t/2</span> rounds (this reduction follows upon work of Maurer et al. <em>[16, 17]</em>). Seen this way, Lampe et al.’s result appears less sharp. The issue is not only qualitative since their bound only improves on Steinberger’s for <span class="math">t\\geq 8</span>.</p>

    <p class="text-gray-300">Our results. In this paper we finally prove security of <span class="math">2^{\\frac{t}{t+1}n}</span> queries for key-alternating ciphers, which has been the conjectured security since the paper of Bogdanov et al., and which is provably tight by the attack in the same paper. More precisely, we show that an adaptive adversary making at most <span class="math">q</span> queries to each of its oracles has distinguishing advantage bounded by <span class="math">O(1)q^{t+1}/N^{t}+O(1)</span>, where <span class="math">N=2^{n}</span> and the two <span class="math">O(1)</span> terms depend on <span class="math">t</span>. (See Section 2 for a formal statement.)</p>

    <p class="text-gray-300">Our techniques are (maybe disappointingly) not as conceptually novel as those of <em>[19]</em> or <em>[13]</em>, as we simply apply Patarin’s H-coefficient technique. The crucial step is lower bounding the probability of a certain event, namely of the event that <span class="math">q</span> input-output values become linked when <span class="math">t</span> partially defined composed permutations (whose composition so far poses no contradiction to the linking of said <span class="math">q</span> input-output pairs) are randomly extended. The surprising aspect of these computations is that various “second-order” factors (that one might otherwise expect to not matter) actually need to be taken into account. Informally, this can be ascribed to the fact that the values of <span class="math">q</span> under consideration are far beyond birthday.</p>

    <p class="text-gray-300">Besides shedding some light on the structural and probabilistic aspects of key-alternating ciphers in the ideal permutation model, we also hope this paper will serve as a useful additional tutorial on (or introduction to) Patarin’s H-coefficient technique, which still seems to suffer from a lack of exposure.</p>

    <p class="text-gray-300">We note that <em>[13]</em> also uses H-coefficient-based techniques and, indeed, our approach is much more closely inspired by that of <em>[13]</em> than by <em>[2, 19]</em>.</p>

    <p class="text-gray-300">Paper organization. Definitions relating to key-alternating ciphers as well as a formal statement of our main result are given in Section 2. An overview of the H-coefficient technique is given in Section 3. The proof of the main theorem is given in Section 4.</p>

    <p class="text-gray-300">Extensions. As we note in the proof, our main result holds even if the subkeys <span class="math">k_{0},\\ldots,k_{t}</span> are only <span class="math">t</span>-wise independent instead of <span class="math">(t+1)</span>-wise independent. This is particularly interesting for <span class="math">t=1</span>. Along different lines, and as pointed out to us by Jooyoung Lee, our result also implies tight security bounds for the “XOR-cascade” cipher introduced by Gaži and Tessaro <em>[9, 10]</em> via a reduction by Peter Gaži <em>[10, 11]</em>.</p>

    <p class="text-gray-300">Acknowledgments. The authors would like to thank Jooyoung Lee, Rodolphe Lampe and Yannick Seurin for helpful conversations.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Definitions and Main Result</h2>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: The two worlds for the Even-Mansour security experiment. In World 1 the distinguisher <span class="math">D</span> has oracle access to random permutations <span class="math">P_{1},\\ldots,P_{t}</span> and the key-alternating cipher <span class="math">E_{k}</span> (cf. Eq. (1)) for a random key <span class="math">k</span>. In World 2, <span class="math">D</span> has oracle access to <span class="math">t+1</span> independent random permutations. In either world <span class="math">D</span> also has oracle access to the inverse of each permutation.</p>

    <p class="text-gray-300">A <span class="math">t</span>-round key-alternating cipher <span class="math">E</span> has keyspace <span class="math">\\{0,1\\}^{(t+1)n}</span> and message space <span class="math">\\{0,1\\}^{n}</span>. We refer back to equation (1) for the definition of <span class="math">E(k,x)</span> (which implicitly depends on the choice of round permutations <span class="math">P_{1}</span>, …, <span class="math">P_{t}</span>). We note that <span class="math">E^{-1}(k,y)</span> has an analoguous formula in which <span class="math">P_{t}^{-1}</span>, …, <span class="math">P_{1}^{-1}</span> are called. We write <span class="math">E_{k}</span> for the permutation <span class="math">E(k,\\cdot)</span>.</p>

    <p class="text-gray-300">We work in the ideal permutation model. For our purposes, the PRP security of a <span class="math">t</span>-round key-alternating cipher <span class="math">E</span> against a distinguisher (or “adversary”) <span class="math">D</span> is defined as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{PRP}}_{E,t}(D)=\\Pr[k=k_{0}\\cdots k_{t}\\longleftarrow\\{0,1\\}^{(t+1)n};D^{E_{k},P_{1},\\ldots,P_{t}}=1]-\\Pr[D^{Q,P_{1},\\ldots,P_{t}}=1]</span> (2)</p>

    <p class="text-gray-300">where in each experiment <span class="math">Q</span>, <span class="math">P_{1},\\ldots,P_{t}</span> are independent uniform random permutations, where <span class="math">D^{A}</span> denotes that <span class="math">D</span> has oracle access to <span class="math">A</span> and <span class="math">A^{-1}</span> (since all oracles are permutations), and where <span class="math">k=k_{0}\\cdots k_{t}</span> is selected uniformly at random (and hidden from <span class="math">D</span>). See Figure 2. We further define</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{PRP}}_{E,t}(q_{e},q)=\\max_{D}\\mathbf{Adv}^{\\mathrm{PRP}}_{E,t}(D)</span></p>

    <p class="text-gray-300">where the maximum is taken over all distinguishers <span class="math">D</span> that make at most <span class="math">q_{e}</span> queries to their first oracle and at most <span class="math">q</span> queries to each of their other oracles. (The notation <span class="math">\\mathbf{Adv}^{\\mathrm{PRP}}_{E,t}(\\cdot)</span> is thus overloaded.)</p>

    <p class="text-gray-300">Accounting for cipher queries and permutation queries separately has the main advantage of clarifying “which <span class="math">q</span> is which” in the security bound. Lampe et al. <em>[13]</em> do an even more fine-grained query accounting, with a separate variable for each permutation; this can be done here, too, but in our case the conceptual gain doesn’t seem worth the notational complication. We also note that, besides <span class="math">t</span>, <span class="math">n</span> is a parameter on which <span class="math">E</span> (and hence <span class="math">\\mathbf{Adv}^{\\mathrm{PRP}}_{E,t}(q)</span>) depends.</p>

    <p class="text-gray-300">(As an aside, we note the above indistinguishability experiment differs from the recently popular framework of <em>indifferentiability</em> by, among others, the presence of a secret key and the absence of a simulator; the similarity, on the other hand, is that the adversary can query the internal components of the structure. The end goal of the security proof is also different, since we simply prove PRP-security (with tight bounds) whereas indifferentiability aims to prove something much stronger, but, typically, with much inferior bounds. See <em>[1, 14]</em> for indifferentiability results on key-alternating ciphers.)</p>

    <p class="text-gray-300">Our main result is the following:</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">N=2^{n}</span> and let <span class="math">q\\leq N/3</span>, <span class="math">t\\geq 1</span>. Then for any constant <span class="math">C&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{PRP}}_{E,t}(q_{e},q)\\leq\\frac{q_{e}q^{t}}{N^{t}}\\cdot Ct^{2}(6C)^{t}+(t+1)^{2}\\frac{1}{C}.</span></p>

    <p class="text-gray-300">The presence of the adjustable constant <span class="math">C</span> in Theorem 1 is typical of security proofs that involve a threshold-based “bad event”. The constant corresponds to the bad event’s (adjustable) threshold. Some terms in the security bound grow with <span class="math">C</span>, others decrease with <span class="math">C</span>, and for every <span class="math">q_{e}</span>, <span class="math">q</span>, <span class="math">t</span> and <span class="math">N</span> there is an optimal <span class="math">C</span>. Choosing</p>

    <p class="text-gray-300"><span class="math">C=\\left(\\frac{(t+1)N^{t}}{6^{t}t^{2}q_{e}q^{t}}\\right)^{1/(t+2)}</span></p>

    <p class="text-gray-300">(which happens to be the analytical optimum) and using a little algebra yields the following, more readable corollary for the case <span class="math">q=q_{e}</span>:</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">N=2^{n}</span>, <span class="math">q\\leq N/3</span>, <span class="math">t\\geq 1</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{PRP}}_{E,t}(q,q)\\leq(t+1)^{2}(t+2)\\left(\\frac{6tq}{N^{t/(t+1)}}\\right)^{(t+1)/(t+2)}.</span> (3)</p>

    <p class="text-gray-300">Security therefore holds up to about <span class="math">q\\approx N^{\\frac{t}{t+1}}/6t^{4}</span>, with “security exponent” <span class="math">(t+1)/(t+2)</span>. Since <span class="math">t</span> is typically viewed as a constant the polynomial factor <span class="math">6t^{4}</span> is not bothersome from the asymptotic point of view even though, obviously, such a factor considerably waters down the security bound for concrete parameters like <span class="math">t=10</span>, <span class="math">n=128</span>. We also note that if we fix <span class="math">q</span> and <span class="math">N</span> and let <span class="math">t\\to\\infty</span> then (3) becomes worse and worse (i.e., closer to <span class="math">1</span> and eventually greater than <span class="math">1</span>) for sufficiently large <span class="math">t</span>. This apparent security degradation is obviously an artefact of our bound, since a straightforward reduction shows that security can only increase with <span class="math">t</span>.</p>

    <p class="text-gray-300"><em>Generalization.</em> In the case when <span class="math">D</span>’s queries are accounted for by <span class="math">t+1</span> separate variables <span class="math">q_{e},q_{1},\\ldots,q_{t}</span>, the product <span class="math">q_{e}q^{t}</span> in Theorem 1 should simply be replaced by <span class="math">q_{e}q_{1}\\cdots q_{t}</span>. The proof of this more general fact is easy to reconstruct from the proof of Theorem 1 given here.</p>

    <h2 id="sec-6" class="text-2xl font-bold">3 The H-coefficient Technique in a Nutshell</h2>

    <p class="text-gray-300">In this section we give a quick high-level outline of Patarin’s H-coefficient technique. Indeed, we imagine that many readers might feel more curiosity about the high-level approach than about the technical details of our proof. This tutorial takes a broader view than Patarin’s own <em>[18]</em>, but <em>[18]</em> mentions refinements for nonadaptive adversaries and “plaintext only” attacks that we don’t touch upon here. We emphasize that the material in this section is “informal by design”.</p>

    <p class="text-gray-300">The general setting is that of a <span class="math">q</span>-query information-theoretic distinguisher <span class="math">D</span> interacting with one of two oracles, the “real world” oracle or the “ideal world” oracle. (Each oracle might consist of several interfaces for <span class="math">D</span> to query.) By such interaction, <span class="math">D</span> creates a transcript, which is a list of queries made and answers returned. We can assume without loss of generality that <span class="math">D</span> is deterministic, and makes its final decision as a (deterministic) function of the transcript obtained.</p>

    <p class="text-gray-300">We note the probability of obtaining a certain transcript might be different in either world (even if nonzero in both worlds). Denoting <span class="math">X</span> the probability distribution on transcripts induced by the real world and denoting <span class="math">Y</span> the probability distribution on transcripts induced by the ideal world (for some fixed deterministic distinguisher <span class="math">D</span>) then <span class="math">D</span>’s distinguishing advantage (cf. (2)) is easily seen to be upper bounded by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y):=\\frac{1}{2}\\sum_{\\tau\\in\\mathcal{T}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X=\\tau]-\\Pr[Y=\\tau]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(the so-called <em>statistical distance</em> or <em>total variation distance</em> between <span class="math">X</span> and <span class="math">Y</span>) where <span class="math">\\mathcal{T}</span> denotes the set of possible transcripts.</p>

    <p class="text-gray-300">The technique’s central idea is to use the fact that</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)=1-E_{\\tau\\sim Y}\\big{[}\\min(1,\\Pr[X=\\tau]/\\Pr[Y=\\tau])\\big{]}</span> (4)</p>

    <p class="text-gray-300">in order to upper bound <span class="math">\\Delta(X,Y)</span>. Here <span class="math">E_{\\tau\\sim Y}[Z(\\tau)]</span> is the expectation of the random variable <span class="math">Z(\\tau)</span> when <span class="math">\\tau</span> is sampled according to <span class="math">Y</span>, and one assumes <span class="math">\\min(1,\\Pr[X=\\tau]/\\Pr[Y=\\tau])=1</span> if <span class="math">\\Pr[Y=\\tau]=0</span>. For completeness we record the easy proof of (4):</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)</span> <span class="math">=\\sum_{\\tau\\in\\mathcal{T}:\\Pr[Y=\\tau]&gt;\\Pr[X=\\tau]}(\\Pr[Y=\\tau]-\\Pr[X=\\tau])</span> <span class="math">=\\sum_{\\tau\\in\\mathcal{T}:\\Pr[Y=\\tau]&gt;\\Pr[X=\\tau]}\\Pr<a href="1-\\Pr[X=\\tau]/\\Pr[Y=\\tau]">Y=\\tau</a></span> <span class="math">=\\sum_{\\tau\\in\\mathcal{T}}\\Pr<a href="1-\\min(1,\\Pr[X=\\tau]/\\Pr[Y=\\tau]">Y=\\tau</a>)</span> <span class="math">=1-E_{\\tau\\sim Y}\\big{[}\\min(1,\\Pr[X=\\tau]/\\Pr[Y=\\tau])\\big{]}.</span></p>

    <p class="text-gray-300">Thus, by (4), upper bounding the distinguisher’s advantage reduces to lower bounding the expectation</p>

    <p class="text-gray-300"><span class="math">E_{\\tau\\sim Y}\\big{[}\\min(1,\\Pr[X=\\tau]/\\Pr[Y=\\tau])\\big{]}.</span> (5)</p>

    <p class="text-gray-300">Typically, some transcripts are better than others, in the sense that for some transcripts <span class="math">\\tau</span> the ratio</p>

    <p class="text-gray-300"><span class="math">\\Pr[X=\\tau]/\\Pr[Y=\\tau]</span></p>

    <p class="text-gray-300">might be quite small (when we would rather the ratio be near 1), but these “bad” transcripts occur with small probability. A typical proof classifies the set <span class="math">\\mathcal{T}</span> of possible transcripts into a finite number of combinatorially distinct classes <span class="math">\\mathcal{T}_{1},\\ldots,\\mathcal{T}_{k}</span> and exhibits values <span class="math">\\varepsilon_{1},\\ldots,\\varepsilon_{k}\\geq 0</span> such that</p>

    <p class="text-gray-300"><span class="math">\\tau\\in\\mathcal{T}_{i}\\implies\\Pr[X=\\tau]/\\Pr[Y=\\tau]\\geq 1-\\varepsilon_{i}.</span> (6)</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">E_{\\tau\\sim Y}\\big{[}\\min(1,\\Pr[X=\\tau]/\\Pr[Y=\\tau])\\big{]}\\geq\\sum_{i=1}^{k}\\Pr<a href="1-\\varepsilon_{i}">Y\\in\\mathcal{T}_{i}</a></span></p>

    <p class="text-gray-300">and, by (4),</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)\\leq\\sum_{i=1}^{k}\\Pr[Y\\in\\mathcal{T}_{i}]\\varepsilon_{i}.</span></p>

    <p class="text-gray-300">The “ideal world” random variable <span class="math">Y</span> often has a very simple distribution, making the probabilities <span class="math">\\Pr[Y\\in\\mathcal{T}_{i}]</span> easy to compute. On the other hand, proving the lower bounds (6) for <span class="math">i=1\\dots k</span> can be difficult, and we rediscuss this issue below.</p>

    <p class="text-gray-300">Many proofs (including ours) have <span class="math">k=2</span>, with <span class="math">\\mathcal{T}_{1}</span> consisting of the set of “good” transcripts and <span class="math">\\mathcal{T}_{2}</span> consisting of the set of “bad” transcripts (i.e., those with small value of <span class="math">\\Pr[X=\\tau]/\\Pr[Y=\\tau]</span>); then <span class="math">\\varepsilon_{1}</span> is small and <span class="math">\\varepsilon_{2}</span> is large, while (hopefully) <span class="math">\\Pr[Y\\in\\mathcal{T}_{1}]</span> is large and <span class="math">\\Pr[Y\\in\\mathcal{T}_{2}]</span> is small, and</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)\\leq\\Pr[Y\\in\\mathcal{T}_{1}]\\varepsilon_{1}+\\Pr[Y\\in\\mathcal{T}_{2}]\\varepsilon_{2}\\leq\\varepsilon_{1}+\\Pr[Y\\in\\mathcal{T}_{2}].</span></p>

    <p class="text-gray-300">The final upper bound on <span class="math">\\Delta(X,Y)</span>, in this case, can thus be verbalized as “one minus the probability ratio of good transcripts [i.e., <span class="math">\\varepsilon_{1}</span>], plus the probability of a transcript being bad” (the latter probability being computed with respect to the distribution <span class="math">Y</span>). This is the form taken by our own bound.</p>

    <p class="text-gray-300">Theoretically, by using a sufficiently large (and possibly non-constant) value of <span class="math">k</span>, the H-coefficient technique can be used to give sharp indistinguishability bounds in <em>any</em> (information-theoretic) setting. However, lower bounding the probability ratio <span class="math">\\Pr[X=\\tau]/\\Pr[Y=\\tau]</span>, even when some structure is understood on <span class="math">\\tau</span>, can sometimes reveal itself to be an intractable problem (but see below for some general techniques). Moreover, other indistinguishability proof methods, such as game-playing or couplings, may be more appropriate or easier to apply than the H-coefficient technique depending on the situation.</p>

    <p class="text-gray-300">Lower bounding the ratio <span class="math">\\Pr[X=\\tau]/\\Pr[Y=\\tau]</span>. The random variables <span class="math">X</span> and <span class="math">Y</span> are, formally, defined on underlying probability spaces that contain respectively all the coins needed for the real and ideal world experiments. To be more illustrative, in the case of the key-alternating cipher distinguishability experiment <span class="math">X</span>’s underlying probability space consists of all possible <span class="math">(t+1)</span>-tuples of the form <span class="math">(k,P_{1},\\dots,P_{t})</span> where <span class="math">k\\in\\{0,1\\}^{(t+1)n}</span> and where each <span class="math">P_{i}</span> is a permutation of <span class="math">\\{0,1\\}^{n}</span>, while <span class="math">Y</span>’s underlying probability space is all <span class="math">(t+1)</span>-tuples of the form <span class="math">(Q,P_{1},\\dots,P_{t})</span> where <span class="math">Q</span> as well as each <span class="math">P_{i}</span> is a permutation of <span class="math">\\{0,1\\}^{n}</span>. (In either case the measure is uniform, and for simplicity we also assume uniform—and hence finite—probability spaces in our discussion here.) For the following, we write <span class="math">\\Omega_{X}</span>, <span class="math">\\Omega_{Y}</span> for the probability spaces on which respectively <span class="math">X</span> and <span class="math">Y</span> are defined. We note that each <span class="math">\\omega</span> in <span class="math">\\Omega_{X}</span> or <span class="math">\\Omega_{Y}</span> can be viewed as an oracle for <span class="math">D</span> to interact with, thus we may use phrases such as “<span class="math">D</span> runs with oracle <span class="math">\\omega</span>”, etc. To summarize, <span class="math">X</span> and <span class="math">Y</span> are, formally, functions <span class="math">X:\\Omega_{X}\\to\\mathcal{T}</span>, <span class="math">Y:\\Omega_{Y}\\to\\mathcal{T}</span>, where <span class="math">X(\\omega)</span> is the transcript obtained by running <span class="math">D</span> with oracle <span class="math">\\omega\\in\\Omega_{X}</span>, and where <span class="math">Y(\\omega)</span> is the transcript obtained by running <span class="math">D</span> oracle <span class="math">\\omega\\in\\Omega_{Y}</span>.</p>

    <p class="text-gray-300">There is usually an obvious notion of “compatibility” between a transcript <span class="math">\\tau</span> and an element <span class="math">\\omega\\in\\Omega_{X}</span> or <span class="math">\\omega\\in\\Omega_{Y}</span>. For example, in the case of key-alternating ciphers, if <span class="math">\\tau</span> contains a query to <span class="math">P_{1}</span> and nothing else, the <span class="math">\\omega</span>’s in <span class="math">\\Omega_{X}</span> that are compatible with <span class="math">\\tau</span> will be exactly those where the <span class="math">P_{1}</span>-coordinate of <span class="math">\\omega</span> agrees with the query in <span class="math">\\tau</span>; there are <span class="math">2^{(t+1)n}\\cdot(2^{n}-1)!\\cdot(2^{n}!)^{t-1}</span> such “compatible” <span class="math">\\omega</span>’s in <span class="math">\\Omega_{X}</span>. For the same transcript, there would be <span class="math">(2^{n}-1)!\\cdot(2^{n}!)^{t}</span> compatible <span class="math">\\omega</span>’s in <span class="math">\\Omega_{Y}</span>. We write <span class="math">\\mathsf{comp}_{X}(\\tau)</span> for the set of <span class="math">\\omega</span>’s in <span class="math">\\Omega_{X}</span> compatible with a transcript <span class="math">\\tau</span>, and we define <span class="math">\\mathsf{comp}_{Y}(\\tau)</span> likewise with respect to <span class="math">\\Omega_{Y}</span>.</p>

    <p class="text-gray-300">We note that the statement “<span class="math">\\omega</span> is compatible with <span class="math">\\tau</span>” is actually not equivalent to the statement “running <span class="math">D</span> with oracle <span class="math">\\omega</span> produces <span class="math">\\tau</span>”. Indeed, some <span class="math">\\tau</span>’s may never be produced by <span class="math">D</span> at all; e.g., if a transcript <span class="math">\\tau</span> contains more than <span class="math">q</span> queries, or if it contains queries to <span class="math">P_{1}</span> when <span class="math">D</span> is a distinguisher that never queries <span class="math">P_{1}</span>, etc, then <span class="math">\\tau</span> is never produced by <span class="math">D</span> (i.e., <span class="math">\\Pr[X=\\tau]=\\Pr[Y=\\tau]=0</span>), but this does not prevent <span class="math">\\mathsf{comp}_{X}(\\tau)</span>, <span class="math">\\mathsf{comp}_{Y}(\\tau)</span> from being well-defined.</p>

    <p class="text-gray-300">A central insight of the H-coefficient technique (but which is usually taken for granted and used without mention) is that when <span class="math">\\tau</span> is a possible transcript of <span class="math">D</span> at all (i.e., if either <span class="math">\\Pr[X=\\tau]&gt;0</span> or <span class="math">\\Pr[Y=\\tau]&gt;0</span>) then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[X=\\tau]=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{X}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\qquad\\text{ and }\\qquad\\Pr[Y=\\tau]=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{Y}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These equalities, argued below, might seem obvious (or not) but one should note they carry some counterintuitive consequences. Firstly:</p>

    <p class="text-gray-300">(c1) The order in which queries appear in a transcript <span class="math">\\tau</span> does not affect the probability of <span class="math">\\tau</span> occurring; only the set of queries appearing in <span class="math">\\tau</span> matters.</p>

    <p class="text-gray-300">(This because the sets <span class="math">\\mathsf{comp}_X(\\tau)</span>, <span class="math">\\mathsf{comp}_Y(\\tau)</span> are unaffected by the order with which queries appear in <span class="math">\\tau</span>.) Along the same lines, one has:</p>

    <p class="text-gray-300">(c2) If two different (deterministic) distinguishers can obtain a transcript <span class="math">\\tau</span> each with nonzero probability, these distinguishers will obtain <span class="math">\\tau</span> with equal probability. Moreover, by (c1), this holds even if the transcript carries no information about the order in which queries are made.</p>

    <p class="text-gray-300">(This because the right-hand sides in (7) are distinguisher-independent.) Thus, if <span class="math">D_{1}</span> and <span class="math">D_{2}</span> are two adaptive, deterministic distinguishers that can arrive (by a potentially completely different query order) at transcripts <span class="math">\\tau_{1}</span> and <span class="math">\\tau_{2}</span> that contain the same set of queries, then <span class="math">D_{1}</span> has the same probability of obtaining <span class="math">\\tau_{1}</span> as <span class="math">D_{2}</span> has of obtaining <span class="math">\\tau_{2}</span>, with this equality holding separately both in the real and ideal worlds. While very basic, the order-independence property (c1) and distinguisher-independence property (c2) of deterministic distinguishers seem not to have been highlighted anywhere before. (A bit of thought reveals that (c1), (c2) will hold for any experiment (real, ideal, or whatever) involving a stateless set of oracles, in the sense that asking the same question twice to an oracle results twice the same answer. Then <span class="math">\\mathsf{comp}_{..}(\\tau)</span> has an obvious definition which is independent of the order with which the queries appear in <span class="math">\\tau</span>, and for which the proof sketch in the next paragraph goes through.)</p>

    <p class="text-gray-300">We now informally argue (7), focusing on the first equality (the <span class="math">X</span>-world) for concreteness. Firstly, executing <span class="math">D</span> with an <span class="math">\\omega \\in \\Omega_X</span>, <span class="math">\\omega \\notin \\mathsf{comp}_X(\\tau)</span> can obviously not produce <span class="math">\\tau</span> as a transcript, since <span class="math">\\omega</span> is not compatible with <span class="math">\\tau</span>. It therefore suffices to show that running <span class="math">D</span> on an oracle <span class="math">\\omega \\in \\mathsf{comp}_X(\\tau)</span> produces the transcript <span class="math">\\tau</span>. For this, we know by assumption that there exists² an <span class="math">\\omega&#x27; \\in \\Omega_X \\cup \\Omega_Y</span> such that running <span class="math">D</span> on oracle <span class="math">\\omega&#x27;</span> produces <span class="math">\\tau</span>. However, one can show by induction on the number of queries made by <span class="math">D</span> that the computations <span class="math">D^\\omega</span> and <span class="math">D^{\\omega&#x27;}</span> will not "diverge", since every time <span class="math">D</span> makes a query to <span class="math">\\omega&#x27;</span> this query appears in <span class="math">\\tau</span> and, hence, because <span class="math">\\omega \\in \\mathsf{comp}_X(\\tau)</span>, will be answered the same by <span class="math">\\omega</span> (also recall that <span class="math">D</span> is deterministic). Hence <span class="math">D^\\omega</span> will produce the same transcript as <span class="math">D^{\\omega&#x27;}</span>, i.e., <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">By (7), since</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {c o m p} _ {X} (\\tau) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_ {X} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\Pr_ {\\Omega_ {X}} [ \\omega \\in \\operatorname {c o m p} _ {X} (\\tau) ] \\quad \\text {and} \\quad \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {c o m p} _ {Y} (\\tau) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_ {Y} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\Pr_ {\\Omega_ {Y}} [ \\omega \\in \\operatorname {c o m p} _ {Y} (\\tau) ] \\tag {8}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">the ratio <span class="math">\\operatorname<em>{Pr}[X = \\tau] / \\operatorname</em>{Pr}[Y = \\tau]</span> is equal to</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\Pr_ {\\Omega_ {X}} [ \\omega \\in \\operatorname {c o m p} _ {X} (\\tau) ]}{\\Pr_ {\\Omega_ {Y}} [ \\omega \\in \\operatorname {c o m p} _ {Y} (\\tau) ]} \\tag {9}</span></div>

    <p class="text-gray-300">and it therefore suffices to lower bound the latter ratio of probabilities. (One could also try directly counting the size of the sets <span class="math">\\mathsf{comp}_X(\\tau)</span>, <span class="math">\\mathsf{comp}_Y(\\tau)</span>, however, this is often intractable for <span class="math">\\mathsf{comp}_X(\\tau)</span>, making a probabilistic approach preferable.) We note the ideal world probability <span class="math">\\operatorname*{Pr}_{\\Omega_Y}[\\omega \\in \\mathsf{comp}_Y(\\tau)]</span> is often quite trivial to compute, due to the ideal world's nice structure.</p>

    <p class="text-gray-300">Looking at (9) it is possible to wonder whether anything substantial has been gained so far, or whether notations are simply being shuffled around; after all, <span class="math">\\operatorname<em>{Pr}[X = \\tau]</span> and <span class="math">\\operatorname</em>{Pr}_{\\Omega_X}[\\omega \\in \\mathsf{comp}_X(\\tau)]</span> are "obviously the same thing"⁴ (and the same for <span class="math">Y</span>). However the probability <span class="math">\\operatorname*{Pr}_{\\Omega_X}[\\omega \\in \\mathsf{comp}_X(\\tau)]</span> offers</p>

    <p class="text-gray-300">¹ More formally, the oracle is a deterministic function taking as input a query and a (large) random tape, where the random tape is sampled and fixed at the start of the experiment.</p>

    <p class="text-gray-300">² Here <span class="math">\\omega&#x27;</span> could also lie outside <span class="math">\\Omega_X \\cup \\Omega_Y</span>; the argument goes through as long as there exists some oracle leading to the transcript <span class="math">\\tau</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">³ In fact, replacing $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_X(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_X(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by respectively </span>\\operatorname<em>{Pr}_{\\Omega_X}[\\omega \\in \\mathsf{comp}_X(\\tau)]<span class="math"> and </span>\\operatorname</em>{Pr}_{\\Omega_Y}[\\omega \\in \\mathsf{comp}_Y(\\tau)]<span class="math"> in (7) gives a more general formulation of these identities, for cases where the probability distributions on </span>\\Omega_X<span class="math">, </span>\\Omega_Y<span class="math"> are not uniform. W prefer the fractions </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_X(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_X(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ because these expressions seem more concrete.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">⁴ In fact, as already pointed out, <span class="math">\\operatorname<em>{Pr}[X = \\tau]</span> and <span class="math">\\operatorname</em>{Pr}_{\\Omega_X}[\\omega \\in \\mathsf{comp}_X(\\tau)]</span> are not the same thing for <span class="math">\\tau</span>'s outside the range of <span class="math">D</span>.</p>

    <p class="text-gray-300">a considerable conceptual advantage over the probability <span class="math">\\Pr[X=\\tau]</span>, as <span class="math">\\Pr_{\\Omega_{X}}[\\omega\\in\\mathsf{comp}_{X}(\\tau)]</span> refers to an experiment with a non-adaptive flavor (a transcript <span class="math">\\tau</span> is fixed, and a uniform random element of <span class="math">\\Omega_{X}</span> is drawn—what is the probability of compatibility?) while the probability <span class="math">\\Pr[X=\\tau]</span> refers, by definition, to the adaptive interaction of <span class="math">D</span> with its oracle, which is much messier to think about. Indeed, (c1) and (c2) already show that adaptivity is in a sense “thrown out” when (7) is applied.</p>

    <p class="text-gray-300">We finally note that a common way of computing</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\Omega_{X}}[\\omega\\in\\mathsf{comp}_{X}(\\tau)]</span></p>

    <p class="text-gray-300">is to write</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr_{\\Omega_{X}}[\\omega\\in\\mathsf{comp}_{X}(\\tau)]</span> $=\\Pr_{\\Omega_{X}}[\\omega\\in\\mathsf{comp}_{X}^{\\prime}(\\tau)]\\cdot\\Pr_{\\Omega_{X}}[\\omega\\in\\mathsf{comp}_{X}(\\tau)\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\omega\\in\\mathsf{comp}_{X}^{\\prime}(\\tau)]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for some set <span class="math">\\mathsf{comp}_{X}^{\\prime}(\\tau)\\subseteq\\Omega_{X}</span> such that <span class="math">\\mathsf{comp}_{X}(\\tau)\\subseteq\\mathsf{comp}_{X}^{\\prime}(\\tau)</span>. E.g., in the case of key-alternating ciphers, <span class="math">\\mathsf{comp}_{X}^{\\prime}(\\tau)</span> might be defined as all points of <span class="math">\\Omega_{X}</span> that at least agree with <span class="math">\\tau</span> on the queries to <span class="math">P_{1},\\ldots,P_{t}</span>, if not on the queries to <span class="math">P_{0}</span>. The question then becomes, when a uniform random element <span class="math">\\omega\\in\\mathsf{comp}_{X}^{\\prime}(\\tau)</span> is picked, what is the probability this <span class="math">\\omega</span> also agrees with the queries to <span class="math">P_{0}</span>?</p>

    <h2 id="sec-7" class="text-2xl font-bold">4 Proof of Theorem 1</h2>

    <p class="text-gray-300">We make the standard simplifying assumption that the distinguisher <span class="math">D</span> is deterministic. This assumption is without loss of generality since if <span class="math">D</span> is randomized it is easy to see that <span class="math">D</span>’s coins can be fixed to value such that the resulting “induced” distinguisher <span class="math">D</span> (running on the fixed random tape) has advantage at least that of the original randomized <span class="math">D</span>.</p>

    <p class="text-gray-300">For simplicity, we also assume the distinguisher never makes redundant queries; e.g., queries <span class="math">P_{i}</span> twice on the same point, or queries <span class="math">P_{i}(x)</span> obtaining answer <span class="math">y</span> and then later queries <span class="math">P_{i}^{-1}(y)</span>. Moreover, we will assume that <span class="math">D</span> makes exactly <span class="math">q_{e}</span> queries to its first oracle and exactly <span class="math">q</span> queries to each of its other oracles. This assumption is obviously without loss of generality.</p>

    <p class="text-gray-300">We refer to the case where <span class="math">D</span> has an oracle tuple of the type <span class="math">(E_{k},P_{1},\\ldots,P_{t})</span> as the “real world” and to the case when <span class="math">D</span> has an oracle tuple of the type <span class="math">(Q,P_{1},\\ldots,P_{t})</span> as the “ideal world”. For convenience, we will be generous with the distinguisher in the following way: at the end of the experiment (when the distinguisher has made its <span class="math">(t+1)q</span> queries, but before the distinguisher outputs its decision) we reveal the key <span class="math">k=k_{0}k_{1}\\cdots k_{t}</span> to the distinguisher in the real world, while in the ideal world we sample a dummy key <span class="math">k^{\\prime}=k_{0}^{\\prime}k_{1}^{\\prime}\\cdots k_{t}^{\\prime}</span> and reveal this dummy key to the distinguisher. A distinguisher playing this “enhanced” game is obviously at no disadvantage, since it can disregard the key if it wants.</p>

    <p class="text-gray-300">For the remainder of the proof we consider a fixed distinguisher <span class="math">D</span> conforming to the conventions above. We can summarize <span class="math">D</span>’s interaction with its oracles by a transcript consisting of a sequence of tuples of the form <span class="math">(i,\\sigma,x,y)</span> where <span class="math">i\\in\\{0,\\ldots,t\\}</span>, <span class="math">\\sigma\\in\\{+,-\\}</span> and <span class="math">x,y\\in\\{0,1\\}^{n}</span>, plus the key value <span class="math">k</span> at the end of the transcript. If <span class="math">\\sigma=+</span> such a tuple denotes that <span class="math">D</span> made the query <span class="math">P_{i}(x)</span> obtaining answer <span class="math">y</span>, or if <span class="math">\\sigma=-</span> that <span class="math">D</span> made the query <span class="math">P_{i}^{-1}(y)</span> obtaining answer <span class="math">x</span>, and <span class="math">D</span>’s interaction with its oracles (as well as <span class="math">D</span>’s final output bit) can be uniquely reconstructed from such a sequence of tuples. In fact, we can (and shall) encode the transcript as an <em>unordered set</em> of <em>directionless</em> tuples of the form <span class="math">(i,x,y)</span> (plus the key value <span class="math">k</span>). Indeed, given that <span class="math">D</span> is deterministic, <span class="math">D</span>’s interaction can still be reconstructed from such a transcript. (Consider that <span class="math">D</span> always makes the same first query, since it is deterministic; we can look up the answer to this query in the transcript, deduce the second query made by <span class="math">D</span> again since <span class="math">D</span> is deterministic, and so on.) All in all, therefore, the transcript can be encoded as a tuple <span class="math">(k,p_{0},p_{1},\\ldots,p_{t})</span> where <span class="math">k\\in\\{0,1\\}^{(t+1)n}</span> is the key (real or dummy) and where <span class="math">p_{i}</span>, <span class="math">i\\geq 1</span>, is a table containing <span class="math">q</span> pairs <span class="math">(x,y)</span>, where each such pair either indicates a query <span class="math">P_{i}(x)=y</span> or a query <span class="math">P_{i}^{-1}(y)=x</span> (which it is can</p>

    <p class="text-gray-300">deduced from the transcript), and where <span class="math">p_{0}</span> similarly contains the <span class="math">q_{e}</span> input-output pairs queried to the cipher. One can also view <span class="math">p_{i}</span> as a bipartite graph with shores <span class="math">\\{0,1\\}^{n}</span> and containing <span class="math">q</span> (resp. <span class="math">q_{e}</span>, in the case of <span class="math">p_{0}</span>) disjoint edges.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">\\mathcal{T}</span> denote the set of all possible transcripts, i.e., the set of all tuples of the form <span class="math">(k,p_{0},\\ldots,p_{t})</span> as described above. Thus $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{(t+1)n}\\big{(}\\binom{2^{n}}{q_{e}}\\frac{2^{n!}}{(2^{n}-q_{e})!}\\big{)}\\big{(}\\binom{2^{n}}{q}\\frac{2^{n!}}{(2^{n}-q)!}\\big{)}^{t}<span class="math">. We note that some elements of </span>\\mathcal{T}<span class="math">—in fact, most elements—may never be obtained by </span>D<span class="math">. For example, if </span>D<span class="math">’s first query is </span>P_{1}(0^{n})<span class="math"> then (this first query never varies and) any transcript obtained by </span>D<span class="math"> contains a pair of the form </span>(0^{n},y)<span class="math"> in the table </span>p_{1}<span class="math">, for some </span>y\\in\\{0,1\\}^{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{P}</span> be the set of all permutations of <span class="math">\\{0,1\\}^{n}</span>; thus $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(2^{n})!<span class="math">. Let </span>\\mathcal{P}^{t}=\\mathcal{P}\\times\\cdots\\times\\mathcal{P}<span class="math"> be the </span>t<span class="math">-fold direct product of </span>\\mathcal{P}<span class="math">. Let </span>\\Omega_{X}=\\{0,1\\}^{(t+1)n}\\times\\mathcal{P}^{t}<span class="math"> and let </span>\\Omega_{Y}=\\{0,1\\}^{(t+1)n}\\times\\mathcal{P}^{t+1}<span class="math">. In the obvious way, elements of </span>\\Omega_{X}<span class="math"> can be viewed as real world oracles for </span>D<span class="math"> while elements of </span>\\Omega_{Y}<span class="math"> can be viewed as “ideal world” oracles for </span>D<span class="math">. (We note that </span>\\Omega_{Y}<span class="math"> is slightly different from the </span>\\Omega_{Y}<span class="math"> appearing in the discussion of Section 3, due to our convention of giving away the key as part of the transcript.) We write </span>X(\\omega)<span class="math"> for the transcript obtained by running </span>D<span class="math"> with oracle </span>\\omega\\in\\Omega_{X}<span class="math">, and </span>Y(\\omega)<span class="math"> for the transcript obtained by running </span>D<span class="math"> with oracle </span>\\omega\\in\\Omega_{Y}<span class="math">. Thus </span>X:\\Omega_{X}\\to\\mathcal{T}<span class="math">, </span>Y:\\Omega_{Y}\\to\\mathcal{T}<span class="math"> and by endowing </span>\\Omega_{X}<span class="math">, </span>\\Omega_{Y}<span class="math"> with the uniform probability distribution, </span>X<span class="math"> and </span>Y<span class="math"> become random variables of range </span>\\mathcal{T}<span class="math">, whose distributions are exactly those obtained by running </span>D<span class="math"> in the real and ideal worlds respectively. Since </span>D<span class="math">’s output is a deterministic function of the transcript, </span>D$’s distinguishing advantage can be written</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[D(X)=1]-\\Pr[D(Y)=1]</span></p>

    <p class="text-gray-300">(here identifying <span class="math">D</span> with a function outputting a final decision from the transcript); thus <span class="math">D</span>’s advantage is upper bounded by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y)=\\frac{1}{2}\\sum_{\\tau\\in\\mathcal{T}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X=\\tau]-\\Pr[Y=\\tau]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">by standard considerations.</p>

    <p class="text-gray-300">In order to upper bound <span class="math">\\Delta(X,Y)</span> we make use of the equality</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)=1-E_{\\tau\\sim Y}\\big{[}\\min(1,\\Pr[X=\\tau]/\\Pr[Y=\\tau])\\big{]}</span></p>

    <p class="text-gray-300">mentioned in Section 3. More precisely, we will identify a set <span class="math">\\mathcal{T}_{1}\\subseteq\\mathcal{T}</span> of “good” query transcripts, and a set <span class="math">\\mathcal{T}_{2}\\subseteq\\mathcal{T}</span> of “bad” transcripts, such that <span class="math">\\mathcal{T}</span> is the disjoint union of <span class="math">\\mathcal{T}_{1}</span> and <span class="math">\\mathcal{T}_{2}</span>. Then, as shown in Section 3,</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)\\leq\\varepsilon_{1}+\\Pr[Y\\in\\mathcal{T}_{2}]</span> (10)</p>

    <p class="text-gray-300">where <span class="math">\\varepsilon_{1}</span> is a number such that</p>

    <p class="text-gray-300"><span class="math">\\frac{\\Pr[X=\\tau]}{\\Pr[Y=\\tau]}\\geq 1-\\varepsilon_{1}</span></p>

    <p class="text-gray-300">for all <span class="math">\\tau\\in\\mathcal{T}_{1}</span> such that <span class="math">\\Pr[Y=\\tau]&gt;0</span>.</p>

    <p class="text-gray-300">We next discuss the definitions of <span class="math">\\mathcal{T}_{1}</span> and <span class="math">\\mathcal{T}_{2}</span>; next we show <span class="math">\\Pr[Y\\in\\mathcal{T}_{2}]\\leq(t+1)^{2}\\frac{1}{C}</span>; and finally we will show <span class="math">\\Pr[X=\\tau]/\\Pr[Y=\\tau]\\geq 1-\\varepsilon_{1}</span> for <span class="math">\\tau\\in\\mathcal{T}_{1}</span> and <span class="math">\\varepsilon_{1}=q_{e}\\big{(}\\frac{q}{N}\\big{)}^{t}\\,Ct^{2}(6C)^{t}</span>. We will assume for these computations that <span class="math">Cq_{e}q^{t}&lt;N^{t}</span>. This assumption is without loss of generality since Theorem 1 is vacuously true otherwise.</p>

    <p class="text-gray-300">Bad Transcripts. Let <span class="math">\\tau=(k,p_{0},p_{1},\\ldots,p_{t})\\in\\mathcal{T}</span> be a transcript. We associate to <span class="math">\\tau</span> a graph <span class="math">G(\\tau)</span>, dubbed the round graph, that encodes the information contained in <span class="math">k</span> as well as in <span class="math">p_{1}</span>, <span class="math">\\ldots,p_{t}</span> (but that ignores <span class="math">p_{0}</span>). <span class="math">G(\\tau)</span> has <span class="math">2(t+1)\\cdot 2^{n}</span> vertices, grouped into “shores” of size <span class="math">2^{n}</span> each, with each shore being identified with a copy <span class="math">\\{0,1\\}^{n}</span>. We index the <span class="math">2(t+1)</span> shores as <span class="math">0^{-}</span>, <span class="math">0^{+}</span>, <span class="math">1^{-}</span>, <span class="math">1^{+}</span>, <span class="math">\\ldots</span>, <span class="math">t^{-}</span>, <span class="math">t^{+}</span>. Vertex <span class="math">y</span> in shore <span class="math">i^{-}</span> is connected to vertex <span class="math">y\\oplus k_{i}</span> in shore <span class="math">i^{+}</span> by an edge, and these are the only edges between</p>

    <p class="text-gray-300">hores <span class="math">i^{-}</span> and <span class="math">i^{+}</span>. Moreover, for each <span class="math">(x,y)\\in p_{i}</span>, <span class="math">1\\leq i\\leq t</span>, we connect vertex <span class="math">x</span> in shore <span class="math">(i-1)^{+}</span> to vertex <span class="math">y</span> in shore <span class="math">i^{-}</span>. Thus <span class="math">G(\\tau)</span> consists of <span class="math">(t+1)</span> full bipartite matchings (one per subkey) alternately glued with <span class="math">q</span>-edge partial matchings (one for each <span class="math">p_{i}</span>, <span class="math">1\\leq i\\leq t</span>). Since <span class="math">G(\\tau)</span> encodes all the information in <span class="math">k</span>, <span class="math">p_{1}</span>, <span class="math">\\dots,p_{t}</span>, we can also write a transcript <span class="math">\\tau</span> in the form <span class="math">\\tau=(p_{0},G)</span> where <span class="math">G=G(\\tau)</span>.</p>

    <p class="text-gray-300">Obviously, the presence of the full bipartite graphs corresponding to the subkeys <span class="math">k_{0}</span>, <span class="math">\\dots,k_{t}</span> within <span class="math">G(\\tau)</span> is not topologically interesting. Call an edge of <span class="math">G(\\tau)</span> a “key edge” if the edge joins the shores <span class="math">i^{-},i^{+}</span> for some <span class="math">i\\in\\{0,\\dots,t\\}</span>. We then define the <em>contracted round graph</em> <span class="math">\\tilde{G}(\\tau)</span> obtained from <span class="math">G(\\tau)</span> by contracting all key edges; thus <span class="math">\\tilde{G}(\\tau)</span> has only <span class="math">t+1</span> shores; moreover, when an edge <span class="math">(y,y\\oplus k_{i})</span> between shores <span class="math">i^{-}</span>, <span class="math">i^{+}</span> of <span class="math">G(\\tau)</span> is contracted, the resulting vertex of <span class="math">\\tilde{G}(\\tau)</span> is given label <span class="math">y</span> if <span class="math">0\\leq i\\leq t-1</span>, and is given label <span class="math">y\\oplus k_{i}</span> if <span class="math">i=t</span>. (The labeling of vertices of <span class="math">\\tilde{G}(\\tau)</span> is somewhat unimportant and arbitrary, but we adopt the above convention so that vertices in shores <span class="math">0^{-}</span> and <span class="math">t^{+}</span> of <span class="math">G(\\tau)</span> keep their original labels in <span class="math">\\tilde{G}(\\tau)</span>. The latter ensures compatibility between these vertex labels and triples in <span class="math">p_{0}</span>.) We note that a transcript <span class="math">\\tau</span> is not determined by the pair <span class="math">(p_{0},\\tilde{G}(\\tau))</span> (the key material being unrecoverable from the latter pair) but, as we will see, <span class="math">\\Pr[X=\\tau]</span> is determined by <span class="math">(p_{0},\\tilde{G}(\\tau))</span>.</p>

    <p class="text-gray-300">An edge between shores <span class="math">(i-1)</span> and <span class="math">i</span> of <span class="math">\\tilde{G}(\\tau)</span> is called an <em><span class="math">i</span>-edge</em>. (Each <span class="math">i</span>-edge arises from an entry in <span class="math">p_{i}</span>.) We write <span class="math">Z_{ij}(\\tilde{G}(\\tau))</span> for the set of (necessarily edge-disjoint) paths that exists between shores <span class="math">i</span> and <span class="math">j</span> of <span class="math">\\tilde{G}(\\tau)</span>. We write <span class="math">Z_{ij}^{-}(\\tilde{G}(\\tau))</span>, <span class="math">Z_{ij}^{+}(\\tilde{G}(\\tau))</span> for vertices of paths in <span class="math">Z_{ij}(\\tilde{G}(\\tau))</span> that are respectively in shores <span class="math">i</span> and <span class="math">j</span> of <span class="math">\\tilde{G}(\\tau)</span>. We write <span class="math">p_{0}^{-}=\\{x:(x,y)\\in p_{0}\\}</span> and <span class="math">p_{0}^{+}=\\{y:(x,y)\\in p_{0}\\}</span> be the projection of <span class="math">p_{0}</span> to its first and second coordinates respectively.</p>

    <p class="text-gray-300">We say a transcript <span class="math">\\tau</span> is <em>bad</em> if there exist <span class="math">0\\leq i&lt;j\\leq t</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{ij}(\\tilde{G}(\\tau))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{Cq^{j-i}}{N^{j-i-1}}$ (11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">or if there exists <span class="math">0\\leq i\\leq j\\leq t</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{(x,y)\\in p_{0}:x\\in Z_{0,i}^{-}(\\tilde{G}(\\tau))\\wedge y\\in Z_{j,t}^{+}(\\tilde{G}(\\tau))\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{Cq_{e}q^{i+t-j}}{N^{i+t-j}}.$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To motivate this definition we note that <span class="math">q^{j-i}/N^{j-i-1}</span> is exactly the expected number of paths from shore <span class="math">i</span> to shore <span class="math">j</span> in the ideal world, whereas, likewise, <span class="math">q_{e}q^{i+t-j}/N^{i+t-j}</span> is the expected number of paths from shore <span class="math">j</span> to shore <span class="math">i</span> that “wrap around” through an edge in <span class="math">p_{0}</span> (though such edges are not encoded in <span class="math">\\tilde{G}(\\tau)</span> and, hence, such “wrap around” paths don’t physically exist in <span class="math">\\tilde{G}(\\tau)</span>). The set of bad transcripts is denoted <span class="math">\\mathcal{T}_{2}</span> and we let <span class="math">T_{1}=\\mathcal{T}\\setminus\\mathcal{T}_{2}</span>. Transcripts in <span class="math">\\mathcal{T}_{1}</span> are called <em>good</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Probability of Badness. We next upper bound <span class="math">\\Pr_{\\tau\\sim Y}[\\tau\\in\\mathcal{T}_{2}]</span>. We view $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{ij}(\\tilde{G}(\\tau))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> as a random variable defined on </span>\\Omega_{Y}<span class="math">. Since </span>k<span class="math"> is independent of </span>p_{0},p_{1},\\dots,p_{t}$, any sequence</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(x_{i+1},y_{i+1})\\in p_{i+1},(x_{i+2},y_{i+2})\\in p_{i+2},\\dots,(x_{j},y_{j})\\in p_{j}</span></p>

    <p class="text-gray-300">of <span class="math">j-i</span> edges have probability <span class="math">(1/N)^{j-i-1}</span> of becoming connected by <span class="math">k_{i+1},\\dots,k_{j-1}</span>. (I.e., there is chance <span class="math">(1/N)^{j-i+1}</span> that <span class="math">k_{h}=y_{h}\\oplus x_{h+1}</span> for <span class="math">h=i+1,\\dots,j-1</span>.) By linearity of expectation, thus,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$E_{\\tau\\sim Y}\\big{[}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big{]}=\\frac{q^{j-i}}{N^{j-i-1}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">since there are <span class="math">q^{j-i}</span> such sequences of edges in <span class="math">p_{i+1},\\dots,p_{j}</span>. By Markov’s inequality, thus,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\tau\\sim Y}\\left[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{Cq^{j-i}}{N^{j-i-1}}\\right]\\leq\\frac{1}{C}$ (13)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for every <span class="math">0\\leq i&lt;j\\leq t</span>.</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Because $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q_e$, it is similarly easy to see that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{\\tau \\sim Y} \\left[ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ (x, y) \\in p_0 : x \\in Z_{0,i}^- \\wedge y \\in Z_{j,t}^+ \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right] = \\frac{q_e q^{i + (t - j)}}{N^{i + t - j}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for every <span class="math">0 \\leq i \\leq j \\leq t</span>, by which Markov again implies that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{\\tau \\sim Y} \\left[ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ (x, y) \\in p_0 : x \\in Z_{0,i}^- \\wedge y \\in Z_{j,t}^+ \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; C \\frac{q_e q^{i + (t - j)}}{N^{i + t - j}} \\right] \\leq \\frac{1}{C} \\tag{14}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for every <span class="math">0 \\leq i \\leq j \\leq t</span>.</p>

    <p class="text-gray-300">Collecting the probabilities (13) for <span class="math">0 \\leq i &amp;lt; j \\leq t</span> and (14) for <span class="math">0 \\leq i \\leq j \\leq t</span> we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\tau \\sim Y} [\\tau \\in \\mathcal{T}_2] \\leq \\binom{t + 1}{2} \\cdot \\frac{1}{C} + \\binom{t + 2}{2} \\cdot \\frac{1}{C} = (t + 1)^2 \\cdot \\frac{1}{C}. \\tag{15}</span></div>

    <p class="text-gray-300">LOWER BOUNDING <span class="math">\\operatorname<em>{Pr}[X = \\tau] / \\operatorname</em>{Pr}[Y = \\tau]</span> FOR <span class="math">\\tau \\in \\mathcal{T}_1</span>. An element <span class="math">\\omega = (k, P_1, \\ldots, P_t) \\in \\Omega_x</span> is compatible with a transcript <span class="math">\\tau = (k^<em>, p_0, \\ldots, p_t)</span> if <span class="math">k = k^</em></span>, if <span class="math">P_i(x) = y</span> for every <span class="math">(x, y) \\in p_i</span>, <span class="math">1 \\leq i \\leq t</span>, and if <span class="math">E_k(x) = y</span> for every <span class="math">(x, y) \\in p_0</span>, where <span class="math">E_k</span> stands for the Even-Mansour cipher instantiated with permutations <span class="math">P_1, \\ldots, P_t</span> (and key <span class="math">k</span>). We write <span class="math">\\mathsf{comp}_X(\\tau)</span> for the set of <span class="math">w</span>'s in <span class="math">\\Omega_X</span> that are compatible with <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">Analogously, an <span class="math">w = (k, P_0, P_1, \\ldots, P_t) \\in \\Omega_Y</span> is compatible with <span class="math">\\tau</span> if the same conditions as above are respected, but replacing the constraint <span class="math">E_k(x) = y</span> with <span class="math">P_0(x) = y</span> for <span class="math">(x, y) \\in p_0</span>. We write <span class="math">\\mathsf{comp}_Y(\\tau)</span> for the set of <span class="math">\\omega</span>'s in <span class="math">\\Omega_Y</span> that are compatible with <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">We also say <span class="math">\\omega = (k, P_1, \\ldots, P_t)</span> is partially compatible with <span class="math">\\tau = (k^<em>, p_0, p_1, \\ldots, p_t)</span> if <span class="math">k = k^</em></span> and if <span class="math">P_i(x) = y</span> for all <span class="math">(x, y) \\in p_i</span>, <span class="math">1 \\leq i \\leq t</span>. (Thus, the requirement that <span class="math">p_0</span> agrees with <span class="math">E_k</span> is dropped for partial compatibility.) Likewise <span class="math">\\omega \\in \\Omega_Y</span> is partially compatible with <span class="math">\\tau</span> if (exactly as above) <span class="math">k = k^*</span> and <span class="math">P_i(x) = y</span> for all <span class="math">(x, y) \\in p_i</span>, <span class="math">1 \\leq i \\leq t</span>. (Thus, the requirement that <span class="math">p_0</span> agrees with <span class="math">P_0</span> is dropped.) We write <span class="math">\\mathsf{comp}_X&#x27;(\\tau)</span>, <span class="math">\\mathsf{comp}_Y&#x27;(\\tau)</span> for the set of <span class="math">\\omega</span>'s in, respectively, <span class="math">\\Omega_X</span> or <span class="math">\\Omega_Y</span> that are partially compatible with <span class="math">\\tau</span>. Note that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_X'(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_Y'(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{1}{N^{t+1}} \\cdot \\prod_{i=1}^{t} \\frac{(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)!}{N!} \\tag{16}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for any transcript <span class="math">\\tau = (k, p_0, p_1, \\ldots, p_t)</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of pairs in </span>p_i$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that a transcript <span class="math">\\tau \\in \\mathcal{T}</span> is attainable if <span class="math">\\operatorname<em>{Pr}[Y = \\tau] &amp;gt; 0</span>. (Note that <span class="math">\\operatorname</em>{Pr}[X = \\tau] &amp;gt; 0 \\Rightarrow \\operatorname*{Pr}[Y = \\tau] &amp;gt; 0</span>.) In other words, a transcript is attainable if there exists an <span class="math">\\omega \\in \\Omega_Y</span> such that <span class="math">D^\\omega</span> produces the transcript <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">It is necessary and sufficient to lower bound <span class="math">\\operatorname<em>{Pr}[X = \\tau] / \\operatorname</em>{Pr}[Y = \\tau]</span> for attainable transcripts <span class="math">\\tau \\in \\mathcal{T}_1</span>. It is easy to check that for an attainable transcript <span class="math">\\tau</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[Y = \\tau] = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_Y(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\tag{17}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[X = \\tau] = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_X(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}. \\tag{18}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The elementary argument required to prove these identities is sketched in Section 3, and we omit it here. Thus, by (16),</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\operatorname{Pr}[X = \\tau]}{\\operatorname{Pr}[Y = \\tau]} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_X(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_X'(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\Bigg/ \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_Y(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{comp}_Y'(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\tag{19}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for <span class="math">\\tau</span> such that <span class="math">\\Pr[Y=\\tau]&gt;0</span>.</p>

    <p class="text-gray-300">For the remainder of the argument we fix an arbitrary transcript <span class="math">\\tau=(k,p_{0},p_{1},\\ldots,p_{t})\\in\\mathcal{T}_{1}</span>. We aim to lower bound the right-hand side fraction in (19).</p>

    <p class="text-gray-300">For random permutations <span class="math">P_{1},\\ldots,P_{t}</span> and partial permutations <span class="math">p_{1},\\ldots,p_{t}</span>, let <span class="math">P_{i}\\downarrow p_{i}</span> denote the event that <span class="math">P_{i}</span> extends <span class="math">p_{i}</span>, i.e., that <span class="math">P_{i}(x)=y</span> for all <span class="math">(x,y)\\in p_{i}</span>; then it is easy to see that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{X}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{X}^{\\prime}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\Pr\\left[E_{k}\\downarrow p_{0}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,k,P_{1}\\downarrow p_{1},\\ldots,P_{t}\\downarrow p_{k}\\right.\\right]$ (20)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the underlying probability space is the choice of the uniform random permutations <span class="math">P_{1},\\ldots,P_{t}</span> (the notation conditions on <span class="math">\\tau</span>’s key <span class="math">k</span> only to emphasize that <span class="math">k</span> is not randomly chosen) and where <span class="math">E_{k}\\downarrow p_{0}</span> is the event that <span class="math">E_{k}(x)=y</span> for all <span class="math">(x,y)\\in p_{0}</span>, where <span class="math">E_{k}</span> is the Even-Mansour cipher with key <span class="math">k</span> and permutations <span class="math">P_{1},\\ldots,P_{t}</span>. Similarly,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{Y}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{Y}^{\\prime}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\Pr\\left[P_{0}\\downarrow p_{0}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,k,P_{1}\\downarrow p_{1},\\ldots,P_{t}\\downarrow p_{k}\\right.\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the underlying probability space is the uniform random choice of <span class="math">P_{0},P_{1},\\ldots,P_{t}</span>. In the latter conditional probability, however, the event <span class="math">P_{0}\\downarrow p_{0}</span> is independent of the conditioned premise, so</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{Y}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{Y}^{\\prime}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\Pr\\left[P_{0}\\downarrow p_{0}\\right]=\\prod_{\\ell=0}^{q_{e}-1}\\frac{1}{N-\\ell}.$ (21)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To facilitate the computation of the conditional probability that appears in (20), let (in accordance with the definition of the graph <span class="math">\\tilde{G}(\\tau)</span> above) <span class="math">\\tilde{p}_{i}</span> be defined by</p>

    <p class="text-gray-300"><span class="math">(x,y)\\in\\tilde{p}_{i}\\iff(x\\oplus k_{i-1},y)\\in p_{i}</span></p>

    <p class="text-gray-300">for <span class="math">1\\leq i\\leq t-1</span>, and by</p>

    <p class="text-gray-300"><span class="math">(x,y)\\in\\tilde{p}_{i}\\iff(x\\oplus k_{i-1},y\\oplus k_{i})\\in p_{i}</span></p>

    <p class="text-gray-300">for <span class="math">i=t</span>. Thus <span class="math">\\tilde{p}_{1}</span>, …, <span class="math">\\tilde{p}_{t}</span> are the <span class="math">t</span> edge sets of the graph <span class="math">\\tilde{G}(\\tau)</span>, i.e., <span class="math">\\tilde{p}_{i}</span> is the set of edges between shores <span class="math">i-1</span> and <span class="math">i</span> of <span class="math">\\tilde{G}(\\tau)</span>. By elementary considerations, one has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[E_{k}\\downarrow p_{0}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,k,P_{1}\\downarrow p_{1},\\ldots,P_{t}\\downarrow p_{k}\\right.\\right]=\\Pr\\left[E_{0}\\downarrow p_{0}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,P_{1}\\downarrow\\tilde{p}_{1},\\ldots,P_{t}\\downarrow\\tilde{p}_{k}\\right.\\right]$ (22)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">E_{0}</span> denotes the Even-Mansour cipher instantiated with key <span class="math">0^{(t+1)n}</span>, and where the probability is taken (on either side) over the choice of the uniform random permutations <span class="math">P_{1},\\ldots,P_{t}</span>. We will therefore focus on the right-hand side probability in (22).</p>

    <p class="text-gray-300">We say shore <span class="math">i</span> of <span class="math">\\tilde{G}(\\tau)</span> is “to the left” of shore <span class="math">j</span> if <span class="math">i&lt;j</span>. We also view paths in <span class="math">\\tilde{G}(\\tau)</span> as oriented from left to right: the path “starts” at the leftmost vertex and “ends” at the rightmost vertex.</p>

    <p class="text-gray-300">Let <span class="math">(x_{1},y_{1}),\\ldots,(x_{q_{e}},y_{q_{e}})</span> be the <span class="math">q_{e}</span> edges in <span class="math">p_{0}</span>. We write <span class="math">\\mathsf{R}(x_{\\ell})</span> for the rightmost vertex in the path of <span class="math">\\tilde{G}(\\tau)</span> starting at <span class="math">x_{\\ell}</span>, and <span class="math">\\mathsf{L}(y_{\\ell})</span> for the leftmost vertex in the path of <span class="math">\\tilde{G}(\\tau)</span> ending at <span class="math">y_{\\ell}</span>. (More often than not, <span class="math">x_{\\ell}</span> and <span class="math">y_{\\ell}</span> are not adjacent to any edges of <span class="math">\\tilde{G}(\\tau)</span>, in which case <span class="math">\\mathsf{R}(x_{\\ell})=x_{\\ell}</span>, <span class="math">\\mathsf{L}(y_{\\ell})=y_{\\ell}</span>.) We write the index of the shore containing vertex <span class="math">v</span> as <span class="math">\\mathrm{Sh}(v)</span>. (Thus <span class="math">\\mathrm{Sh}(v)\\in\\{0,1,\\ldots,t\\}</span>.) Because <span class="math">\\tau</span> is good, and because we are assuming <span class="math">Cq_{e}(q/N)^{t}&lt;1</span>, <span class="math">\\mathrm{Sh}(\\mathsf{R}(x_{\\ell}))&lt;\\mathrm{Sh}(\\mathsf{L}(y_{\\ell}))</span> for <span class="math">1\\leq\\ell\\leq q_{e}</span>.</p>

    <p class="text-gray-300">A vertex in shore <span class="math">i\\geq 1</span> is left-free if it is not adjacent to a vertex in shore <span class="math">i-1</span>. A vertex in shore <span class="math">i\\leq t-1</span> is right-free if it is not adjacent to a vertex in shore <span class="math">i+1</span>.</p>

    <p class="text-gray-300">To compute the conditional probability</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[E_{0}\\downarrow p_{0}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,P_{1}\\downarrow\\tilde{p}_{1},\\ldots,P_{t}\\downarrow\\tilde{p}_{t}\\right.\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">we imagine the following experiment in <span class="math">q_{e}</span> stages. Let <span class="math">G_{0}=\\tilde{G}(\\tau)</span>. At the <span class="math">\\ell</span>-th stage, <span class="math">G_{\\ell}</span> is inductively defined from <span class="math">G_{\\ell-1}</span>. Let <span class="math">\\tilde{p}_{i}^{\\ell}</span> be the edges between shore <span class="math">i-1</span> and <span class="math">i</span> of <span class="math">G_{\\ell}</span>. Initially, <span class="math">G_{\\ell}=G_{\\ell-1}</span>. Then, as long as <span class="math">\\mathsf{R}(x_{\\ell})</span> is not in shore <span class="math">t</span>, a value <span class="math">y</span> is chosen uniformly at random from the set of left-free vertices in shore <span class="math">\\mathrm{Sh}(\\mathsf{R}(x_{\\ell}))+1</span>, and the edge <span class="math">(\\mathsf{R}(x_{\\ell}),y)</span> is added to <span class="math">\\tilde{p}_{\\mathrm{Sh}(\\mathsf{R}(x_{\\ell}))+1}^{\\ell}</span>. <span class="math">G_{\\ell}</span> is the result obtained when <span class="math">\\mathsf{R}(x_{\\ell})</span> reaches shore <span class="math">t</span>. Thus, <span class="math">G_{\\ell}</span> has at most <span class="math">t</span> more edges than <span class="math">G_{\\ell-1}</span>.</p>

    <p class="text-gray-300">Since the permutations <span class="math">P_{1},\\ldots,P_{t}</span> are uniformly random and independently chosen, it is easy to see that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[E_{0}\\downarrow p_{0}\\bigm{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P_{1}\\downarrow\\tilde{p}_{1},\\ldots,P_{t}\\downarrow\\tilde{p}_{t}\\right]=\\Pr\\left[G_{q_{e}}\\downarrow p_{0}\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for the random graph <span class="math">G_{q_{e}}</span> defined in the process above, where the notation <span class="math">G_{q_{e}}\\downarrow p_{0}</span> is a shorthand to indicate that vertices <span class="math">x_{\\ell}</span> and <span class="math">y_{\\ell}</span> are connected by a path in <span class="math">G_{q_{e}}</span> for <span class="math">1\\leq\\ell\\leq q_{e}</span>. Moreover, writing <span class="math">x_{\\ell}\\to y_{\\ell}</span> for the event that <span class="math">x_{\\ell}</span> and <span class="math">y_{\\ell}</span> are connected by a path in <span class="math">G_{\\ell}</span> (and thus in <span class="math">G_{q_{e}}</span>), and writing <span class="math">G_{\\ell}\\downarrow p_{0}</span> for the event <span class="math">x_{j}\\to y_{j}</span> for <span class="math">1\\leq j\\leq\\ell</span>, we finally find</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{X}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{X}^{\\prime}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\prod_{\\ell=0}^{q_{e}-1}\\Pr[x_{\\ell+1}\\to y_{\\ell+1}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,G_{\\ell}\\downarrow p_{0}].$ (23)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This formula should be compared with (21). Indeed, (21) and (23) imply that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{X}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{X}^{\\prime}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\left/\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{Y}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{comp}_{Y}^{\\prime}(\\tau)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\prod_{\\ell=0}^{q_{e}-1}\\frac{\\Pr[x_{\\ell+1}\\to y_{\\ell+1}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,G_{\\ell}\\downarrow p_{0}]}{1/(N-\\ell)}$ (24)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which suggests that to lower bound <span class="math">\\Pr[X=\\tau]/\\Pr[Y=\\tau]</span> one should compare $\\Pr[x_{\\ell+1}\\to y_{\\ell+1}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,G_{\\ell}\\downarrow p_{0}]<span class="math"> and </span>1/(N-\\ell)$. (More specifically, give a lower bound for the former that is not much less than the latter.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Some preliminary quantitative intuition for (24). Up to now, the proof has mostly been notational setup. (The possible exception is the upper bounding of <span class="math">\\Pr[\\tau\\in\\mathcal{T}_{2}]</span>, but this is just an application of Markov’s inequality, and the definition of <span class="math">\\mathcal{T}_{2}</span> is also the obvious one.) The heart of the proof, indeed, is lower bounding the product that appears in (24). At this stage we “pause” the proof to give some quantitative intuition about this product. This intuition shows, in particular, the need for a conservative computation. We will make the simplifying assumption that <span class="math">\\mathrm{Sh}(\\mathsf{R}(x_{\\ell}))=0</span>, <span class="math">\\mathrm{Sh}(\\mathsf{L}(y_{\\ell}))=t</span> for all <span class="math">1\\leq\\ell\\leq q_{e}</span>. (Which, as it turns out, still captures the most interesting features of the problem.)</p>

    <p class="text-gray-300">As a warm-up we can consider the case <span class="math">t=1</span>. In this case, firstly, the “simplifying assumption” <span class="math">\\mathrm{Sh}(\\mathsf{R}(x_{\\ell}))=0</span>, <span class="math">\\mathrm{Sh}(\\mathsf{L}(y_{\\ell}))=1</span> actually holds with probability <span class="math">1</span> for all <span class="math">\\tau\\in\\mathcal{T}_{1}</span>, by the second bad event in the definition of a bad transcript (i.e., (12)), and by our wlog assumption that</p>

    <p class="text-gray-300"><span class="math">1&gt;Cq_{e}(q/N)^{t}=Cq_{e}q/N.</span> (25)</p>

    <p class="text-gray-300">(In more detail, the right-hand side of (12) is <span class="math">Cq_{e}q/N</span> for <span class="math">i=j=0</span> or <span class="math">i=j=1</span>. Thus, if there exists an <span class="math">(x_{\\ell},y_{\\ell})\\in p_{0}</span> such that either <span class="math">\\mathsf{R}(x_{\\ell})=1</span> or <span class="math">\\mathsf{L}(y_{\\ell})=0</span>, then <span class="math">\\tau\\in\\mathcal{T}_{2}</span>.) Next (still for <span class="math">t=1</span>) it can be directly observed that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}\\right]=\\frac{1}{N-q-\\ell}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">since <span class="math">\\tilde{p}_{1}=\\tilde{p}_{1}^{0}</span> contains <span class="math">q</span> edges and since <span class="math">\\ell</span> additional edges have been drawn by the time <span class="math">G_{\\ell+1}</span> is constructed. In fact, the ratio <span class="math">1/(N-q-\\ell)</span> is <em>greater</em> than <span class="math">1/(N-\\ell)</span>, which means that in this case the product (24) is also greater than <span class="math">1</span>, and one can therefore use <span class="math">\\varepsilon_{1}=0</span>. I.e., for <span class="math">t=1</span> the distinguisher’s advantage is upper bounded by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{1}+\\Pr[Y\\in\\mathcal{T}_{2}]\\leq 0+\\Pr[Y\\in\\mathcal{T}_{2}]\\leq\\frac{2q_{e}q}{N}</span></p>

    <p class="text-gray-300">where the last inequality is obtained by direct inspection of the event <span class="math">\\tau \\in \\mathcal{T}_2</span> for <span class="math">t = 1</span>. (For <span class="math">t = 1</span>, the only thing that can cause a transcript to be bad is if <span class="math">p_0^- \\oplus k_0 \\cap p_1^- \\neq \\emptyset</span> or if <span class="math">p_0^+ \\oplus k_1 \\cap p_1^+ \\neq \\emptyset</span>.) Note that even while <span class="math">\\operatorname<em>{Pr}[X = \\tau] / \\operatorname</em>{Pr}[Y = \\tau] \\geq 1</span> for all <span class="math">\\tau \\in \\mathcal{T}_1</span> such that <span class="math">\\operatorname<em>{Pr}[Y = \\tau] &amp;gt; 0</span>, one has <span class="math">\\operatorname</em>{Pr}[X = \\tau] / \\operatorname<em>{Pr}[Y \\in \\tau] = 0</span> for most <span class="math">\\tau \\in \\mathcal{T}_2</span> such that <span class="math">\\operatorname</em>{Pr}[Y = \\tau] &amp;gt; 0</span>. This is why <span class="math">\\varepsilon_1</span> can attain zero.</p>

    <p class="text-gray-300">In passing, note we have proved the <span class="math">(2q_{e}q / N)</span>-security of the key-alternating cipher for <span class="math">t = 1</span>, which exactly recovers Even and Mansour's original result for <span class="math">t = 1</span>. The difference is that the H-coefficient technique "mechanizes" the bound-proving, to a certain extent. (Even and Mansour's proof [7] is more complicated, though it pursues the same basic idea. See also Kilian and Rogaway's paper on DESX [12] for a nice game-based take on this argument.)</p>

    <p class="text-gray-300">Given these auspicious beginnings for <span class="math">t = 1</span> one might feel inclined to optimism and to conjecture, say, that the product (24) is always greater than 1 for good transcripts. However, let us start by dashing these hopes with an example for <span class="math">t = 2</span>. For the example, assume that <span class="math">\\tilde{p}_1</span> and <span class="math">\\tilde{p}_2</span> are disjoint, i.e., no edge in <span class="math">\\tilde{p}_1</span> touches an edge in <span class="math">\\tilde{p}_2</span>. (Thus <span class="math">G_0 = \\tilde{G}(\\tau)</span> contains no paths of length 2.) The example will be clearer if we start by examining the case <span class="math">\\tilde{p}_1 = \\emptyset</span> (i.e., when there are no edges between shore 0 and shore 1). Then one can compute that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ x _ {1} \\rightarrow y _ {1} \\right] = \\left(1 - \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N}\\right) \\frac {1}{N - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\left(\\frac {N - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N}\\right) \\frac {1}{N - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac {1}{N}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Similarly,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ x _ {2} \\rightarrow y _ {2} \\mid G _ {1} \\downarrow p _ {0} \\right] = \\left(1 - \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N - 1}\\right) \\frac {1}{N - 1 - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac {1}{N - 1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">since the vertex in shore 1 to which <span class="math">x_{2}</span> is connected is sampled uniformly from a set of size <span class="math">N - 1</span>, and similarly the new vertex sampled in shore 2 (if such vertex is sampled) comes uniformly from a set of size $N - 1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{p}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. More generally, thus,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ x _ {\\ell + 1} \\rightarrow y _ {\\ell + 1} \\mid G _ {\\ell} \\downarrow p _ {0} \\right] = \\left(1 - \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N - \\ell}\\right) \\frac {1}{N - \\ell - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac {1}{N - \\ell}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">So far so good, but these computations are under the false assumption that <span class="math">\\tilde{p}_1 = \\emptyset</span>!</p>

    <p class="text-gray-300">Now we remove the assumption <span class="math">\\tilde{p}_1 = \\emptyset</span>, but keep the assumption that <span class="math">\\tilde{p}_1</span> and <span class="math">\\tilde{p}_2</span> are disjoint. In this case, one has</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ x _ {1} \\rightarrow y _ {1} \\right] = \\left(1 - \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {1} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\frac {1}{N - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\left(\\frac {N - 2 q}{N - q}\\right) \\frac {1}{N - q} = \\frac {N - 2 q}{(N - q) ^ {2}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As our interest is to compare this quantity to <span class="math">1 / N</span>, we further massage this expression by writing</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {N - 2 q}{(N - q) ^ {2}} = \\frac {1}{N} - \\frac {1}{N} + \\frac {N - 2 q}{(N - q) ^ {2}} = \\frac {1}{N} - \\frac {(N - q) ^ {2}}{N (N - q) ^ {2}} + \\frac {N (N - 2 q)}{N (N - q) ^ {2}} = \\frac {1}{N} - \\frac {q ^ {2}}{N (N - q) ^ {2}}.</span></div>

    <p class="text-gray-300">More generally, one finds that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ x _ {\\ell + 1} \\rightarrow y _ {\\ell + 1} \\mid G _ {\\ell} \\downarrow p _ {0} \\right] = \\left(1 - \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N - \\ell - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {1} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\frac {1}{N - \\ell - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {p} _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac {1}{N - \\ell} - \\frac {q ^ {2}}{(N - \\ell) (N - \\ell - q) ^ {2}} \\tag {26}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as can be seen by substituting <span class="math">N</span> by <span class="math">N - \\ell</span> everywhere in the first computation. Thus the probability $\\operatorname*{Pr}[x_{\\ell +1}\\to y_{\\ell +1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_0]<span class="math"> is now slightly lower than </span>1 / (N - \\ell)$, which rules out the optimistic conjecture</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5 In more detail: when we travel from <span class="math">x_{1}</span> to <span class="math">y_{1}</span>, the sampling process first chooses a random endpoint in shore 1 to attach <span class="math">x_{1}</span> to, and this endpoint has probability $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{p}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ N<span class="math"> of “hitting” an edge in </span>\\tilde{p}_2<span class="math"> (in which case we have no hope of reaching </span>y_{1}<span class="math">). If we don&#x27;t hit an edge in </span>\\tilde{p}_2<span class="math">, there is further chance </span>1 / (N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{p}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> that we reach </span>y_{1}<span class="math">, since the vertex in shore 2 is sampled uniformly at random from a set of size </span>N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{p}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">above. As for the value of the product (24) one finds, by (26),</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{\\ell=0}^{q_e-1} \\left(1 - \\frac{q^2}{(N - \\ell - q)^2}\\right) \\geq \\left(1 - \\frac{q^2}{(N - 2q)^2}\\right)^{q_e} \\geq 1 - \\frac{q_e q^2}{(N - 2q)^2}.</span></div>

    <p class="text-gray-300">This is acceptably close to 1 (i.e., taking <span class="math">\\varepsilon_1 = q_e q^2 / (N - 2q)^2</span> is acceptably close to zero) as long as <span class="math">q_e q^2 \\ll N^2</span>. We are (coincidentally or not, since the assumption <span class="math">q_e q^2 \\ll N^2</span> has already been used to upper bound <span class="math">\\operatorname{Pr}[\\tau \\in \\mathcal{T}_2]</span>) "bumping into" the security bound for <span class="math">t = 2</span>. Thus, the approach still works for <span class="math">t = 2</span>, but this time the approach "barely" works!</p>

    <p class="text-gray-300">In fact, the simplifying assumption that <span class="math">\\tilde{p}_1</span> and <span class="math">\\tilde{p}_2</span> are disjoint can easily be removed since, as is not hard to see, having <span class="math">\\tilde{p}_1</span> and <span class="math">\\tilde{p}_2</span> disjoint is actually the worst case possible<span class="math">^6</span> for <span class="math">t = 2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, the initial simplifying assumption that <span class="math">\\mathsf{R}(x_{\\ell}) = 0</span>, <span class="math">\\mathsf{L}(y_{\\ell}) = 2</span> for all <span class="math">\\ell</span> is also easy to remove for <span class="math">t = 2</span>, because $\\operatorname{Pr}[x_{\\ell + 1} \\to y_{\\ell + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell} \\downarrow p_0]<span class="math"> actually increases to </span>1 / (N - q - \\ell)<span class="math"> (cf. the case </span>t = 1<span class="math">) when either</span>^7<span class="math"> </span>\\mathsf{R}(x_{\\ell}) = 1<span class="math"> or </span>\\mathsf{L}(y_{\\ell}) = 1<span class="math">. Thus, the above computations essentially prove security of </span>q_e q^2 / N^2<span class="math"> for </span>t \\geq 2<span class="math"> (indeed, security is easily seen to &quot;transfer upwards&quot; from smaller to larger values of </span>t<span class="math">), which is the main result of Bogdanov et al. [2]. The proof sketched above is arguably simpler than Bogdanov et al.&#x27;s, though. (Also, Bogdanov et al. seem to forget that if the only goal is to prove security of </span>q_e q^2 / N^2<span class="math"> for </span>t \\geq 2<span class="math"> it suffices to restrict oneself to the case </span>t = 2<span class="math">. Their general approach, however, can be pushed slightly further to cover the case </span>t = 3$, as shown by Steinberger [19].)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now consider the case <span class="math">t = 3</span>. Already, doing an exact probability computation for the conditional probability $\\operatorname{Pr}[x_{\\ell + 1} \\to y_{\\ell + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell} \\downarrow p_0]<span class="math"> (as done in (26) for </span>t = 2<span class="math">) promises to be quite tedious for </span>t = 3<span class="math">, so we can look at doing back-of-the-envelope estimates instead. The simplest estimate is to lower bound the probability of </span>x_{\\ell + 1}<span class="math"> reaching </span>y_{\\ell + 1}$ by upper bounding the probability that the path being constructed meets a pre-existing edge in either shore 1 or shore 2, viz.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[x_{\\ell + 1} \\to y_{\\ell + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell} \\downarrow p_0] \\geq \\left(1 - \\frac{2q}{N - \\ell - q}\\right) \\frac{1}{N - \\ell - q} \\tag{27}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">2q / (N - \\ell - q)</span> is a (crude) upper bound on the probability that the path touches a pre-existing edge in either shore 1 or shore 2, and where <span class="math">1 / (N - \\ell - q)</span> is the probability of reaching <span class="math">y_{\\ell + 1}</span> if the path reaches a right-free vertex in shore 2. However, (27) is worse than (26), so we are heading at best for security of <span class="math">\\varepsilon_1 \\approx q_e q^2 / N^2</span> if we use this estimate. One can argue that <span class="math">2q / (N - \\ell - q)</span> can be replaced by <span class="math">q / (N - \\ell - q)</span> in (27) (because: if we hit an edge in <span class="math">\\tilde{p}_2</span> that is not adjacent to an edge in <span class="math">\\tilde{p}_3</span> this only helps us, and if we hit an edge in <span class="math">\\tilde{p}_2</span> that is adjacent to an edge in <span class="math">\\tilde{p}_3</span> this can be "billed" to the corresponding edge in <span class="math">\\tilde{p}_3</span>) but even so we are headed towards a security of <span class="math">q_e q^2 / N^2</span>, by comparison with (26). In fact, we can reflect that any approach that doesn't somehow seriously take into account the presence of three rounds is doomed to fail, because the computation for <span class="math">t = 2</span> is actually tight (cf. footnote 6), and thus cannot be tweaked to give security better than <span class="math">q_e q^2 / N^2</span>.</p>

    <p class="text-gray-300">As it turns out, the "exact but tedious" probability computation that we shied from above does deliver a bound that implies the desired security of <span class="math">q_{e}q^{3} / N^{3}</span>, even while back-of-the-envelope estimates indicate a security bound of <span class="math">q_{e}q^{2} / N^{2}</span>. Intuitively, the gain that occurs is due to the fact that when the path hits an edge of <span class="math">\\tilde{p}_2</span> not connected to an edge of <span class="math">\\tilde{p}_3</span>—and at most <span class="math">Cq^2 /N\\ll q</span> edges in <span class="math">\\tilde{p}_2</span> are adjacent to edges in <span class="math">\\tilde{p}_3</span>, by definition of <span class="math">\\mathcal{T}_2</span>—this is actually better than not hitting any edge at all in shore 1, because it guarantees we won't hit an edge in <span class="math">\\tilde{p}_3</span>. While this intuition is easy to see, it is somewhat</p>

    <p class="text-gray-300"><span class="math">^6</span> On the other hand, we cannot count on <span class="math">\\tilde{p}_1</span> and <span class="math">\\tilde{p}_2</span> having some small intersection in order to possibly repair our optimistic conjecture. Indeed, the distinguisher could make sure that <span class="math">\\tilde{p}_1</span> and <span class="math">\\tilde{p}_2</span> are almost certainly disjoint. For example, the distinguisher could make <span class="math">q</span> <span class="math">P_2</span>-queries with values that start with <span class="math">n/3</span> 0's, and also make <span class="math">q</span> <span class="math">P_1^{-1}</span>-queries with values that start with <span class="math">n/3</span> 0's. Then <span class="math">\\tilde{p}_1</span> and <span class="math">\\tilde{p}_2</span> are disjoint unless the first <span class="math">n/3</span> bits of the key are 0, which occurs with negligible probability.</p>

    <p class="text-gray-300"><span class="math">^7</span> Note that one always has <span class="math">\\mathsf{R}(x_{\\ell}) &amp;lt; \\mathsf{L}(y_{\\ell})</span> by the definition of <span class="math">\\mathcal{T}_2</span> and by the wlog assumption <span class="math">Cq_{e}q^{t} &amp;lt; N^{t}</span>.</p>

    <p class="text-gray-300">harder to believe such a small “second-order” effect would make a crucial difference in the final security bound. Yet, this is exactly so. In fact, given the “completeness” of the H-coefficient method it makes sense to have faith that the exact probability computation (if doable) will deliver security <span class="math">q_{e}q^{3}/N^{3}</span>. (Though in reality even this is not a given: by giving away the key at the end of each transcript we have been more generous to the adversary than those who devised the security conjecture of <span class="math">q_{e}q^{t}/N^{t}</span>, so it’s possible to conceive that it’s the “key’s fault” if the security is (apparently) topping off at <span class="math">q_{e}q^{2}/N^{2}</span> (as opposed to the fault of our lossy estimates). Note that even if we have the correct intuition, and we believe it isn’t the “key’s fault” and that the approach is theoretically sound, we are still up against the problem of actually doing the computations in a such way that the desired security gain becomes apparent, and isn’t lost in a sea of fractions.)</p>

    <p class="text-gray-300">We will show the “exact” probability computation for <span class="math">t=3</span> in the next subsection, where we will see it is neither more nor less terrible than might be expected. The <span class="math">t=3</span> computation also serves as a useful reference point for the general case.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Before that, we will estimate what kind of lower bound is actually needed for $\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]<span class="math"> in order to reach overall security </span>\\approx q_{e}q^{t}/N^{t}$. Writing</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]=\\frac{1}{N-\\ell}+z_{t}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">z_{t}</span> is an “error term” whose magnitude will determine <span class="math">\\varepsilon_{1}</span>, we find that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\prod_{\\ell=0}^{q_{e}-1}\\frac{\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]}{1/(N-\\ell)}=\\prod_{\\ell=0}^{q_{e}-1}(1-(N-\\ell)z_{t})\\geq(1-N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{q_{e}}\\geq 1-Nq_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus we will have $\\varepsilon_{1}\\approx Nq_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and so we need need </span>Nq_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ll 1<span class="math"> in order for </span>\\varepsilon_{1}$ to be small. Having</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q^{t}/N^{t+1}$ (28)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">gives us precisely this under the assumption <span class="math">q_{e}q^{t}/N^{t}\\ll 1</span>.</p>

    <p class="text-gray-300">The quantity <span class="math">q^{t}/N^{t}</span> affords a natural interpretation that resurfaces in the proof, so we will pre-emptively point out this interpretation here. Let <span class="math">0\\leq i_{0}&lt;\\ldots&lt;i_{s}=t</span> be some strictly increasing sequence of shore indices, <span class="math">s\\leq t</span>. If we select a vertex uniformly at random from shore <span class="math">i_{j}</span> of (say, for simplicity) <span class="math">G_{0}=\\tilde{G}(\\tau)</span> for <span class="math">1\\leq j\\leq s</span> then the probability that the selected vertex in shore <span class="math">i_{j}</span> is a vertex in <span class="math">Z_{i_{j-1}i_{j}}</span> for <span class="math">1\\leq j\\leq s</span> is upper bounded by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\prod_{j=1}^{s}\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{i_{j-1}i_{j}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N}\\leq\\prod_{j=1}^{s}\\left(\\frac{Cq^{i_{j}-i_{j-1}}}{N^{i_{j}-i_{j-1}-1}}\\bigg{/}N\\right)=C^{s}\\left(\\frac{q}{N}\\right)^{t-i_{0}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">given the definition of <span class="math">\\mathcal{T}_{2}</span>. Discarding the constant factor of <span class="math">C^{s}</span>, we see this probability is as small as <span class="math">q^{t}/N^{t}</span> as long as <span class="math">i_{0}=0</span>. As we will see in the general proof, the error term <span class="math">z_{t}</span> can be written as a linear combination of probabilities that are (close to) the form above, but involving nonzero values of <span class="math">i_{0}</span>. We will break up these probabilities into smaller (similar) probabilities such that all terms cancel except those with <span class="math">i_{0}=0</span>. The latter terms are small enough so that the sum of their absolute values is an “acceptable” upper bound on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. (The number of such small terms will be exponentially many in </span>t<span class="math">, as reflected in the bound of Theorem 1.) These hand-wavy ideas will make more sense after we see the case </span>t=3$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Details on the case <span class="math">t=3</span>. Let <span class="math">U_{ij}</span> be the set of paths from shore <span class="math">i</span> to shore <span class="math">j</span> in <span class="math">G(\\tau)</span>, <span class="math">0\\leq i&lt;j\\leq 3</span>, such that the vertex of the path in shore <span class="math">i</span> is left-free (i.e., is the head of the path), but where the vertex in shore <span class="math">j</span> may or may not be right-free. The <span class="math">U_{ij}</span>’s are therefore “half-open” paths. Note $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Cq^{j-1}/N^{j-i-1}<span class="math"> by definition of </span>\\mathcal{T}_{2}<span class="math">. For notational consistency with Lemma 1 below we rename </span>\\tilde{p}_{i}<span class="math"> as </span>E_{i}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for <span class="math">i = 1,2,3</span>. Thus $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q<span class="math"> and </span>E_i<span class="math"> is the set of edges between shores </span>(i - 1)<span class="math"> and </span>i<span class="math"> of </span>\\tilde{G}(\\tau)<span class="math">. Moreover, one can note that </span>E_i = \\bigcup_{0 \\leq j &lt; i} U_{ji}<span class="math"> for all </span>i$, with the latter being a disjoint union.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We start by computing <span class="math">\\operatorname{Pr}[x_1 \\to y_1]</span>, from which the general case $\\operatorname{Pr}[x_{\\ell + 1} \\to y_{\\ell + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_\\ell \\downarrow p_0]<span class="math"> will be easy to deduce. We view the underlying probability space as the selection of three vertices </span>u_1, u_2<span class="math"> and </span>u_3<span class="math"> from shores 1, 2 and 3 of </span>\\tilde{G}(\\tau)<span class="math"> respectively, such that </span>u_i<span class="math"> is selected independently and uniformly at random from the set of left-free vertices in shore </span>i<span class="math">. This defines a path </span>w_0 := x_1<span class="math">, </span>w_1 := u_1<span class="math">, </span>w_2<span class="math">, </span>w_3<span class="math"> where </span>w_2<span class="math"> equals </span>u_2<span class="math"> if </span>u_1<span class="math"> is right-free and equals the other endpoint of the edge adjacent to </span>u_1<span class="math"> otherwise, and where </span>w_3<span class="math"> equals </span>u_3<span class="math"> if </span>w_2<span class="math"> is right-free, otherwise equals the vertex in shore 3 adjacent to </span>w_2<span class="math">. Then </span>\\operatorname{Pr}[x_1 \\to y_1]<span class="math"> is equal to the probability that </span>w_3 = y_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since <span class="math">y_1</span> is left-free we have</p>

    <div class="my-4 text-center"><span class="math-block">w_3 = y_1 \\iff (u_3 = y_1) \\wedge \\neg (w_1 \\in U_{13} \\vee w_2 \\in U_{23}).</span></div>

    <p class="text-gray-300">(The event <span class="math">\\neg (w_1 \\in U_{13} \\vee w_2 \\in U_{23})</span> coincides with the event that <span class="math">w_2</span> is right-free.) Note the event <span class="math">u_3 = y_1</span> is independent from the event <span class="math">\\neg (w_1 \\in U_{13} \\vee w_2 \\in U_{23})</span>, and also that the events <span class="math">w_1 \\in U_{13}</span> and <span class="math">w_2 \\in U_{23}</span> are disjoint. Moreover,</p>

    <div class="my-4 text-center"><span class="math-block">w_2 \\in U_{23} \\iff (u_2 \\in U_{23}) \\wedge \\neg (w_1 \\in U_{12})</span></div>

    <p class="text-gray-300">since the vertices in shore 2 of <span class="math">U_{23}</span> are left-free. By independence of <span class="math">u_1</span> and <span class="math">u_2</span>, thus,</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{Pr}[w_2 \\in U_{23}] = \\operatorname{Pr}[u_2 \\in U_{23}] \\cdot (1 - \\operatorname{Pr}[w_1 \\in U_{12}]) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left(1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{12}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Thus</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{Pr}[w_3 = y_1] = \\operatorname{Pr}[u_3 = y_1] (1 - \\operatorname{Pr}[w_1 \\in U_{13}] - \\operatorname{Pr}[w_2 \\in U_{23}]) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left(1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{12}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+ \\frac{</td>

            <td class="px-3 py-2 border-b border-gray-700">U_{12}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">U_{23}</td>

            <td class="px-3 py-2 border-b border-gray-700">}{(N -</td>

            <td class="px-3 py-2 border-b border-gray-700">E_1</td>

            <td class="px-3 py-2 border-b border-gray-700">)(N -</td>

            <td class="px-3 py-2 border-b border-gray-700">E_2</td>

            <td class="px-3 py-2 border-b border-gray-700">)(N -</td>

            <td class="px-3 py-2 border-b border-gray-700">E_3</td>

            <td class="px-3 py-2 border-b border-gray-700">)}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Note that none of the terms above are as small as <span class="math">\\approx q^3 / N^4</span> (cf. (28)), even with the approximation $\\frac{1}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\approx \\frac{1}{N}<span class="math">, so none of the terms above can (yet) be folded into the error term.) Adding and subtracting the &quot;ideal&quot; probability </span>\\frac{1}{N}<span class="math"> to </span>\\frac{1}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ gives</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{N} - \\frac{1}{N} + \\frac{1}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{1}{N} + \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} = \\frac{1}{N} + \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{03}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Here $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{03}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> is basically the same order of magnitude as </span>q^3 / N^4<span class="math">, given that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{03}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{03}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq C q^3 / N^2$. So we can leave this term alone.) Next,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} = - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} = - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{01}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(same order of magnitude as <span class="math">q^{3}/N^{4}</span>, given that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Cq^{2}/N$), and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> </span>=-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where only $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{02}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$ is small enough to fit inside the error term. But then, of course, we lastly compute that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{12}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}+\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{12}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{23}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=\\frac{</td>

            <td class="px-3 py-2 border-b border-gray-700">U_{01}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">U_{12}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">U_{23}</td>

            <td class="px-3 py-2 border-b border-gray-700">}{N(N-</td>

            <td class="px-3 py-2 border-b border-gray-700">E_{1}</td>

            <td class="px-3 py-2 border-b border-gray-700">)(N-</td>

            <td class="px-3 py-2 border-b border-gray-700">E_{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">)(N-</td>

            <td class="px-3 py-2 border-b border-gray-700">E_{3}</td>

            <td class="px-3 py-2 border-b border-gray-700">)}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which is small enough to fit inside the error term. Collecting the leftovers after the various cancellations above, thus, we find</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr[w_{3}=y_{1}]</span> $=\\frac{1}{N}+\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{03}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{01}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{13}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where all the terms except <span class="math">\\frac{1}{N}</span> are “error-term small”. Moreover, when we compute $\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]<span class="math"> for </span>\\ell\\geq 1<span class="math"> we can discard the </span>\\ell<span class="math"> completed paths from shore </span>0<span class="math"> to shore </span>3<span class="math"> linking the vertex pairs </span>(x_{1},y_{1}),\\ldots,(x_{\\ell},y_{\\ell})<span class="math">, and thus reduce to the case </span>\\ell+1=1<span class="math"> with </span>N<span class="math"> replaced by </span>N-\\ell<span class="math">. I.e., the expression for </span>\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]<span class="math"> will be identical to (29) except with </span>N<span class="math"> replaced by </span>N-\\ell$ throughout.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From here the proof for <span class="math">t=3</span> can be finished without many suprises. (For more details, see how the general case is treated after Lemma 1.) The crux of the proof is indeed the very simple idea of adding and subtracting <span class="math">\\frac{1}{N}</span> from the probability, and of letting cancellations occur. This approach is purely algebraic. In Lemma 1 below, when we carry out the same process for an arbitrary value of <span class="math">t</span>, we will adopt a combinatorial approach that recasts the algebraic manipulations as manipulations of events. (This seems more satisfying because it gives the algebraic cancellations a combinatorial interpretation.) Doing so requires enlarging the probability space beyond its original confines. Indeed, for example, the original probability space has no event that occurs with probability <span class="math">\\frac{1}{N}</span> even while factors of <span class="math">\\frac{1}{N}</span> are ubiquitous in the final expression. Details follow below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Main Lemma. To accurately lower bound the probability $\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]<span class="math"> we will abstract the setup within which that probability computation takes place. Let </span>G<span class="math"> be a graph with </span>r+1<span class="math"> shores equal to </span>\\{0,1\\}^{n}<span class="math"> indexed </span>0,1,\\ldots,r<span class="math">. (Eventually, </span>r<span class="math"> will correspond to </span>\\mathsf{L}(y_{\\ell+1})-\\mathsf{R}(x_{\\ell+1})<span class="math">, and </span>G<span class="math"> will be the graph </span>G_{\\ell}<span class="math"> with shores </span>0,\\ldots,\\mathsf{R}(x_{\\ell+1})-1<span class="math"> and </span>\\mathsf{L}(y_{\\ell+1})+1,\\ldots,t<span class="math"> deleted.) The edges of </span>G<span class="math"> are divided into </span>r<span class="math"> sets </span>E_{1},\\ldots,E_{r}<span class="math"> where </span>E_{i}<span class="math"> is a (partial) matching between shores </span>i-1<span class="math"> and </span>i<span class="math">. Moreover, </span>G<span class="math"> has two distinguished vertices </span>u,v<span class="math"> in shores </span>0<span class="math">, </span>r<span class="math">, respectively, such that </span>u<span class="math"> is right-free and that </span>v<span class="math"> is left-free. These will eventually correspond to </span>x_{\\ell+1}<span class="math"> and </span>y_{\\ell+1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As above we define <span class="math">U_{ij}</span>, <span class="math">0\\leq i&lt;j\\leq r</span>, to be the set of paths from shore <span class="math">i</span> to shore <span class="math">j</span> of <span class="math">G</span> such that the vertex in shore <span class="math">i</span> is left-free, but where the vertex in shore <span class="math">j</span> may or may not be right-free.</p>

    <p class="text-gray-300">For <span class="math">1\\leq i\\leq r</span> we let <span class="math">u_{i}</span> be a vertex chosen uniformly at random from the set of left-free vertices in shore <span class="math">i</span>. The choice of <span class="math">u_{1},\\ldots,u_{r}</span> defines a path <span class="math">w_{0},w_{1},\\ldots,w_{r}</span> in the following way: we put <span class="math">w_{0}=u</span> and</p>

    <p class="text-gray-300">\\[ w_{i}=\\begin{cases}y&\\text{if there exists an edge }(w_{i-1},y)\\in E_{i},\\\\ u_{i}&\\text{otherwise}\\end{cases} \\]</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">for <span class="math">1\\leq i\\leq r</span>. We write <span class="math">\\Pr_{G}[u\\to v]=\\Pr_{G}[w_{r}=v]</span> for the probability that we arrive at vertex <span class="math">v</span> in shore <span class="math">r</span> by following this path. (In order not to confuse matters we do <em>not</em> view the above experiment as defining new edges that are added to <span class="math">G</span>. Thus <span class="math">G</span> is a static graph.)</p>

    <p class="text-gray-300">The next lemma constitutes the technical heart of our proof.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">Let <span class="math">G</span> be as described above, with <span class="math">U_{ij}</span> as described above. Then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{G}[u\\to v]=\\frac{1}{N}-\\frac{1}{N}\\sum_{\\sigma}(-1)^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\prod_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{i_{j}i_{j-1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{i_{j}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the sum is taken over all sequences <span class="math">\\sigma=(i_{0},\\ldots,i_{s})</span> with <span class="math">0=i_{0}&lt;\\ldots&lt;i_{s}=r</span>, and where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=s$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-9" class="text-base font-medium mt-4">Demonstration Proof</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A sequence <span class="math">\\sigma=(i_{0},\\ldots,i_{s})</span> such that <span class="math">0\\leq i_{0}&lt;\\ldots&lt;i_{s}\\leq r</span> is called an <span class="math">i_{0}i_{s}</span>-partition of size <span class="math">s</span>. We write $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=s<span class="math">, as in the lemma statement. We write </span>\\mathfrak{S}_{ij}<span class="math"> for the set of all </span>ij<span class="math">-partitions. For example, the sum in the lemma statement is taken over </span>\\mathfrak{S}_{0r}<span class="math">. We allow </span>s=0<span class="math"> and note that </span>\\mathfrak{S}_{ii}<span class="math"> contains the partition </span>\\sigma=(i)$ of size zero.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It will be notationally convenient if we add an <span class="math">(r+1)</span>-th shore to <span class="math">G</span>, with a single edge between shores <span class="math">r</span> and <span class="math">r+1</span> having endpoint at <span class="math">v</span> in shore <span class="math">r</span>. We extend the definitions of the set of paths <span class="math">U_{ij}</span> to allow <span class="math">j=r+1</span>. Note that <span class="math">U_{i(r+1)}=\\emptyset</span> for all <span class="math">i&lt;r</span> because <span class="math">v</span> is left-free and that <span class="math">U_{r(r+1)}</span> consists of the single edge adjacent to <span class="math">v</span>.</p>

    <p class="text-gray-300">For <span class="math">1\\leq i&lt;j\\leq r+1</span> (thus, in particular, <span class="math">1\\leq i\\leq r</span>) let <span class="math">\\odot_{ij}</span> denote the event that <span class="math">u_{i}\\in U_{ij}</span> and let <span class="math">\\otimes_{ij}</span> denote the event that <span class="math">w_{i}\\in U_{ij}</span>. Then <span class="math">\\odot_{r(r+1)}</span> is the event that <span class="math">u_{r}=v</span> and <span class="math">\\otimes_{r(r+1)}</span> is the event that <span class="math">w_{r}=v</span>. In particular <span class="math">\\Pr[u\\to v]=\\Pr[\\otimes_{r(r+1)}]</span>. (For the proof, we write simply <span class="math">\\Pr[u\\to v]</span> instead of <span class="math">\\Pr_{G}[u\\to v]</span>.)</p>

    <p class="text-gray-300">We will use “arithmetical” notation for boolean operations on events: <span class="math">AB</span> means the conjunction of events <span class="math">A</span> and <span class="math">B</span>, <span class="math">1-A</span> means the complement of <span class="math">A</span>, etc. When using such notation, one should identify an event <span class="math">A</span> with characteristic function <span class="math">1_{A}</span>; thus <span class="math">A+A\\neq A</span> (even though <span class="math">A\\cup A=A</span>) because <span class="math">1_{A}+1_{A}=2\\cdot 1_{A}\\neq 1_{A}</span>. While intermediate expressions may evaluate to functions that are not 0,1-valued, the final value of most expressions we give are 0,1-functions on the probability space (occasionally, the final value is a 0, -1-function). Moreover, if <span class="math">A_{1}+\\ldots+A_{g}-B_{1}\\ldots-B_{h}</span> is a linear combination of events that sums to a 0,1-function, then <span class="math">\\Pr[A_{1}+\\ldots-B_{h}]</span> makes sense and <span class="math">\\Pr[A_{1}+\\ldots-B_{h}]=\\Pr[A_{1}]+\\ldots-\\Pr[B_{h}]</span>. (On the other hand <span class="math">\\Pr[AB]=\\Pr[A]\\Pr[B]</span> if and only <span class="math">A</span> and <span class="math">B</span> are independent.) Finally, in this arithmetic an empty product corresponds to the certain event.</p>

    <p class="text-gray-300">We note that</p>

    <p class="text-gray-300"><span class="math">\\otimes_{ij}=\\odot_{ij}(1-\\otimes_{1i}-\\otimes_{2i}-\\ldots-\\otimes_{(i-1)i})</span> (30)</p>

    <p class="text-gray-300">for all <span class="math">1\\leq i&lt;j\\leq r+1</span>. Indeed, for the path <span class="math">w_{1},\\ldots,w_{r}</span> to “hit” the head of a path in <span class="math">U_{ij}</span>, we need <span class="math">u_{i}</span> to be the head of a path in <span class="math">U_{ij}</span> (this is the event <span class="math">\\odot_{ij}</span>) and we also need the path not to have been “hijacked” by a pre-existing path in <span class="math">G</span> that goes at least up to shore <span class="math">i</span>; this “hijack” occurs if and only if the event</p>

    <p class="text-gray-300"><span class="math">\\otimes_{1i}+\\otimes_{2i}+\\ldots+\\otimes_{(i-1)i}</span> (31)</p>

    <p class="text-gray-300">occurs. (Note the events in (31) are disjoint.) Whence (30). We note that only <span class="math">\\odot_{ij}</span> depends on <span class="math">j</span> in the right-hand side of (30).</p>

    <p class="text-gray-300">In particular, for <span class="math">j</span> in the relevant ranges,</p>

    <p class="text-gray-300"><span class="math">\\otimes_{1j}</span> <span class="math">=\\odot_{1j}</span> <span class="math">\\otimes_{2j}</span> <span class="math">=\\odot_{2j}(1-\\otimes_{12})=\\odot_{2j}(1-\\odot_{12})=\\odot_{2j}-\\odot_{12}\\odot_{2j}</span> <span class="math">\\otimes_{3j}</span> <span class="math">=\\odot_{3j}(1-\\otimes_{13}-\\otimes_{23})=\\odot_{3j}(1-\\odot_{13}-\\odot_{23}+\\odot_{12}\\odot_{23})</span> <span class="math">=\\odot_{3j}-\\odot_{13}\\odot_{3j}-\\odot_{23}\\odot_{3j}+\\odot_{12}\\odot_{23}\\odot_{3j}</span></p>

    <p class="text-gray-300">By repeatedly "unfolding" in this fashion the definition of the  <span class="math">\\otimes_{ij}</span> 's in terms of the  <span class="math">\\odot_{ij}</span> 's we arrive at the inclusion-exclusion formula</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\otimes_ {i j} = \\odot_ {i j} \\sum_ {y = 1} ^ {i} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y i}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}} \\tag {32}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the partition  <span class="math">\\sigma</span>  that appears in the sum is notated  $(i_0, \\ldots, i_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> . (We keep this convention, which already appeared in the lemma statement, for all sums with an index  </span>\\sigma$ .)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note, for completeness, the very standard proof of (32) by induction on  <span class="math">i</span> . The expression clearly holds for  <span class="math">i = 1</span>  since then the sum over  <span class="math">\\sigma</span>  contains a single element consisting of  <span class="math">(-1)^{0}</span>  times an empty product. Now assume  <span class="math">i &amp;gt; 1</span>  and that (32) holds for smaller values of  <span class="math">i</span> . By (30) and the induction hypothesis,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\otimes_ {i j} = \\odot_ {i j} \\left(1 - \\sum_ {x = 1} ^ {i - 1} \\otimes_ {x i}\\right) \\\\ = \\odot_ {i j} \\left(1 - \\sum_ {x = 1} ^ {i - 1} \\odot_ {x i} \\sum_ {y = 1} ^ {x} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y x}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}}\\right) \\\\ = \\odot_ {i j} \\left(1 - \\sum_ {y = 1} ^ {i - 1} \\sum_ {x = y} ^ {i - 1} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y x}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left(\\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}}\\right) \\odot_ {x i}\\right) \\\\ = \\odot_ {i j} \\left(1 - \\sum_ {y = 1} ^ {i - 1} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y i}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}}\\right) \\\\ = \\odot_ {i j} \\left(1 + \\sum_ {y = 1} ^ {i - 1} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y i}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}}\\right) \\tag {33} \\\\ = \\odot_ {i j} \\left(\\sum_ {y = 1} ^ {i} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y i}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}}\\right) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">which proves (32). In particular, (32) gives us the formulas</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\otimes_ {r (r + 1)} = \\odot_ {r (r + 1)} \\left(\\sum_ {y = 1} ^ {r} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y r}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}}\\right) \\tag {34} \\\\ = \\odot_ {r (r + 1)} + \\odot_ {r (r + 1)} \\sum_ {y = 1} ^ {r - 1} \\sum_ {\\sigma \\in \\mathfrak {S} _ {y r}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_ {i _ {h - 1} i _ {h}} \\tag {35} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for the event  <span class="math">\\otimes_{r(r + 1)}</span> .</p>

    <p class="text-gray-300">We next introduce a brand new probability space. For  <span class="math">1 \\leq i \\leq r</span>  let  <span class="math">u_i&#x27;</span>  be a vertex uniformly chosen in shore  <span class="math">i</span> , and let  <span class="math">u_i&#x27;&#x27;</span>  be a vertex uniformly and independently chosen among all left-free vertices in shore  <span class="math">i</span> . (So  <span class="math">u_i&#x27;&#x27;</span>  has the same distribution as  <span class="math">u_i</span> .) The vertices  <span class="math">u_1&#x27;&#x27;, \\ldots, u_r&#x27;&#x27;</span>  are independently distributed and also independent from the  <span class="math">u_i&#x27;</span> 's. However, we will introduce some correlations among  <span class="math">u_1&#x27;, \\ldots, u_r&#x27;</span> . Specifically, if  <span class="math">u_i&#x27;</span>  is not right-free,  <span class="math">i \\leq r - 1</span> , then  <span class="math">u_{i + 1}&#x27;</span>  must be (with probability 1) the other endpoint of the edge in  <span class="math">E_{i + 1}</span>  adjacent to  <span class="math">u_i&#x27;</span> ; otherwise, if  <span class="math">u_i&#x27;</span>  is right-free,  <span class="math">u_{i + 1}&#x27;</span>  should be left-free. To see that random variables  <span class="math">u_1&#x27;, \\ldots, u_r&#x27;</span>  really can be defined with this property (including the fact that  <span class="math">u_i&#x27;</span>  is, individually, uniform in shore  <span class="math">i</span> ) we imagine the following experiment: first  <span class="math">u_1&#x27;</span>  is chosen uniformly at random from shore 1; if</p>

    <p class="text-gray-300"><span class="math">u_{1}^{\\prime}</span> is adjacent to an edge in <span class="math">E_{2}</span>, <span class="math">u_{2}^{\\prime}</span> is defined as the other endpoint of that edge; otherwise <span class="math">u_{2}^{\\prime}</span> is chosen uniformly at random from the set of left-free vertices in shore 2, and so on (with the sampling of <span class="math">u_{3}^{\\prime}</span> depending on whether <span class="math">u_{2}^{\\prime}</span> is right-free or not). It is easy to see by induction on the shore index that each <span class="math">u_{i}^{\\prime}</span> is uniformly distributed in its shore. (One can reflect that <span class="math">u_{1}^{\\prime},\\ldots,u_{r}^{\\prime}</span> have a very similar distribution to the “real path” vertices <span class="math">w_{1},\\ldots,w_{r}</span> defined above, except for the fact that <span class="math">u_{1}^{\\prime}</span> might not be left-free in <span class="math">G</span>, while <span class="math">w_{1}</span> is always left-free in <span class="math">G</span>.)</p>

    <p class="text-gray-300">We next define a vertex <span class="math">u_{i}^{\\prime\\prime\\prime}</span> which is a deterministic function of <span class="math">u_{i}^{\\prime}</span> and <span class="math">u_{i}^{\\prime\\prime}</span>. Specifically, <span class="math">u_{i}^{\\prime\\prime\\prime}</span> is defined as being <span class="math">u_{i}^{\\prime}</span> if <span class="math">u_{i}^{\\prime}</span> is left-free, and is defined as being <span class="math">u_{i}^{\\prime\\prime}</span> otherwise. Thus <span class="math">u_{i}^{\\prime\\prime\\prime}</span> is always left-free, like <span class="math">u_{i}</span>.</p>

    <p class="text-gray-300">We next argue that <span class="math">u_{1}^{\\prime\\prime\\prime},\\ldots,u_{r}^{\\prime\\prime\\prime}</span> are independent, despite the dependencies among <span class="math">u_{1}^{\\prime},\\ldots,u_{r}^{\\prime}</span>. To see this it’s sufficient to argue that <span class="math">u_{i}^{\\prime\\prime\\prime}</span> is independent from <span class="math">u_{1}^{\\prime\\prime\\prime},\\ldots,u_{i-1}^{\\prime\\prime\\prime}</span>. If <span class="math">u_{i-1}^{\\prime}</span> is right-free then <span class="math">u_{i}^{\\prime\\prime\\prime}=u_{i}^{\\prime}</span> and this is obvious. If <span class="math">u_{i-1}^{\\prime}</span> is not right-free then <span class="math">u_{i}^{\\prime\\prime\\prime}=u_{i}^{\\prime\\prime}</span> and this is again obvious. Hence <span class="math">u_{1}^{\\prime\\prime\\prime},\\ldots,u_{r}^{\\prime\\prime\\prime}</span> are independent.</p>

    <p class="text-gray-300">Since <span class="math">u_{1}^{\\prime\\prime\\prime},\\ldots,u_{r}^{\\prime\\prime\\prime}</span> are independent they are equidistributed with <span class="math">u_{1},\\ldots,u_{r}</span>. In fact, we will identify <span class="math">u_{i}</span> with <span class="math">u_{i}^{\\prime\\prime\\prime}</span>. That is, we will choose to think of the actual process whereby <span class="math">u_{1},\\ldots,u_{r}</span> are sampled as being the following: <span class="math">u_{1}^{\\prime},\\ldots,u_{r}^{\\prime}</span> and <span class="math">u_{1}^{\\prime\\prime},\\ldots,u_{r}^{\\prime\\prime}</span> are sampled as described aboved; then we set <span class="math">u_{i}:=u_{i}^{\\prime\\prime\\prime}</span> for <span class="math">u_{i}^{\\prime\\prime\\prime}</span> as defined above from <span class="math">u_{i}^{\\prime}</span> and <span class="math">u_{i}^{\\prime\\prime}</span>. Since <span class="math">u_{1}^{\\prime\\prime\\prime},\\ldots,u_{r}^{\\prime\\prime\\prime}</span> are (totally) independent and since each <span class="math">u_{i}^{\\prime\\prime\\prime}</span> is uniformly distributed among all left-free vertices in shore <span class="math">i</span>, this definition of <span class="math">u_{1},\\ldots,u_{r}</span> produces an identical random experiment. Having identified <span class="math">u_{i}^{\\prime\\prime\\prime}</span> with <span class="math">u_{i}</span>, we will make no further mention of <span class="math">u_{1}^{\\prime\\prime\\prime},\\ldots,u_{r}^{\\prime\\prime\\prime}</span>, these being replaced by <span class="math">u_{1},\\ldots,u_{r}</span>. To summarize, <span class="math">u_{i}^{\\prime}</span> is the “primary choice” for <span class="math">u_{i}</span>, and if this primary choice fails (because it is not left-free), <span class="math">u_{i}</span> falls back onto the “secondary choice” <span class="math">u_{i}^{\\prime\\prime}</span>, which is left-free by design.</p>

    <p class="text-gray-300">We define events <span class="math">\\bigtriangleup_{ij}</span> and <span class="math">\\square_{ij}</span> with respect to <span class="math">u_{i}^{\\prime}</span> and <span class="math">u_{i}^{\\prime\\prime}</span> the same way <span class="math">\\odot_{ij}</span> is defined with respect to <span class="math">u_{i}</span>. More precisely, for <span class="math">0\\leq i&lt;j\\leq r+1</span>, the event <span class="math">\\bigtriangleup_{ij}</span> occurs if <span class="math">u_{h}^{\\prime}\\in U_{ij}</span> for any <span class="math">i\\leq h\\leq j</span>. Note that if <span class="math">u_{h}^{\\prime}\\in U_{ij}</span> for some <span class="math">h</span> in the range <span class="math">i\\leq h\\leq j</span>, then <span class="math">u_{z}^{\\prime}\\in U_{ij}</span> for all <span class="math">h</span> in the range <span class="math">\\max(1,i)\\leq h\\leq\\min(r,j)</span>, by the way the <span class="math">u_{i}^{\\prime}</span>’s are defined. (We need <span class="math">\\max(1,i)</span> and <span class="math">\\min(r,j)</span> because <span class="math">u_{0}^{\\prime}</span> and <span class="math">u_{r+1}^{\\prime}</span> are not defined.) We note that it would make little sense to define an event such as <span class="math">\\odot_{01}</span>, since <span class="math">u_{0}</span> is not defined, but it does make sense to define <span class="math">\\bigtriangleup_{01}</span>, since <span class="math">u_{1}^{\\prime}</span> may or may not be in <span class="math">U_{01}</span>. The definition of the <span class="math">\\square_{ij}</span>’s is exactly analogous to the <span class="math">\\odot_{ij}</span>’s: for <span class="math">1\\leq i&lt;j\\leq r+1</span>, <span class="math">\\square_{ij}</span> occurs if <span class="math">u_{i}^{\\prime\\prime}</span> is in <span class="math">U_{ij}</span>.</p>

    <p class="text-gray-300">We note that (i) <span class="math">\\bigtriangleup_{ij}</span> is independent from <span class="math">\\square_{i^{\\prime}j^{\\prime}}</span> if <span class="math">i\\neq i^{\\prime}</span>; (ii) <span class="math">\\bigtriangleup_{ij}</span> is independent from <span class="math">\\odot_{i^{\\prime}j^{\\prime}}</span> if <span class="math">i^{\\prime}\\neq i</span>; (iii) <span class="math">\\square_{ij}</span> is independent from <span class="math">\\odot_{i^{\\prime}j^{\\prime}}</span> if <span class="math">i^{\\prime}\\neq i</span>. We leave it to the reader to check these three facts, which can be argued using a similar case analysis as when we checked the independence of the <span class="math">u_{i}^{\\prime\\prime\\prime}</span>’s above.</p>

    <p class="text-gray-300">Note that for any <span class="math">1\\leq i&lt;j\\leq r+1</span> one has</p>

    <p class="text-gray-300"><span class="math">\\odot_{ij}=\\bigtriangleup_{ij}+\\sum_{x=0}^{i-1}\\bigtriangleup_{xi}\\square_{ij}</span></p>

    <p class="text-gray-300">because for the event <span class="math">u_{i}\\in U_{ij}</span> to occur we either need <span class="math">u_{i}^{\\prime}\\in U_{ij}</span> or else we need that <span class="math">u_{i}^{\\prime\\prime}\\in U_{ij}</span> and that <span class="math">u_{i}^{\\prime}</span> is not left-free, which means that <span class="math">u_{i}^{\\prime}\\in E_{i}=\\bigcup_{x=0}^{i-1}U_{xi}</span>, where the latter is a disjoint union. In fact, we even have the equality of events</p>

    <p class="text-gray-300"><span class="math">\\odot_{ij}=\\bigtriangleup_{ij}+\\sum_{x=0}^{i-1}\\bigtriangleup_{xi}\\odot_{ij}.</span> (36)</p>

    <p class="text-gray-300">because <span class="math">\\bigtriangleup_{xi}\\square_{ij}</span> if and only if <span class="math">\\bigtriangleup_{xi}\\odot_{ij}</span> for <span class="math">x&lt;i</span>, as is easy to verify.</p>

    <p class="text-gray-300">Applying (36) to the first term <span class="math">\\odot_{i_{0}i_{1}}</span> in each product of (35) as well as to standalone term <span class="math">\\odot_{r(r+)}</span> on the left of (35) yields</p>

    <p class="text-gray-300"><span class="math">\\otimes_{r(r+1)}=\\left(\\bigtriangleup_{r(r+1)}+\\sum_{x=0}^{r-1}\\bigtriangleup_{xr}\\odot_{r(r+1)}\\right)</span></p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\odot_{r(r+1)} \\sum_{y=1}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{yr}} (-1)^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left( \\triangle_{i_0 i_1} + \\sum_{x=0}^{i_0-1} \\triangle_{xi_0} \\odot_{i_0 i_1} \\right) \\prod_{h=2}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\odot_{i_{h-1} i_h} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+ \\odot_{r(r+1)} \\sum_{y=1}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{yr}} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\triangle_{i_0 i_1} \\prod_{h=2}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\odot_{i_{h-1} i_h} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+ \\odot_{r(r+1)} \\sum_{y=1}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{yr}} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\left( \\sum_{x=0}^{i_0-1} \\triangle_{xi_0} \\odot_{i_0 i_1} \\right) \\prod_{h=2}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\odot_{i_{h-1} i_h} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\triangle_{r(r+1)} + \\odot_{r(r+1)} \\sum_{x=0}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{xr},</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">=1} \\triangle_{i_0 i_1} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+ \\odot_{r(r+1)} \\sum_{y=1}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{yr}} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\triangle_{i_0 i_1} \\prod_{h=2}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\odot_{i_{h-1} i_h} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+ \\odot_{r(r+1)} \\sum_{x=0}^{r-2} \\sum_{y=x+1}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{yr}} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\triangle_{xi_0} \\odot_{i_0 i_1} \\prod_{h=2}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\odot_{i_{h-1} i_h} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\triangle_{r(r+1)} - \\odot_{r(r+1)} \\sum_{x=0}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{xr},</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">=1} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\triangle_{i_0 i_1} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+ \\odot_{r(r+1)} \\sum_{y=1}^{r-1} \\sum_{\\sigma \\in \\mathfrak{S}_{yr}} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\triangle_{i_0 i_1} \\prod_{h=2}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\odot_{i_{h-1} i_h} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- \\odot_{r(r+1)} \\sum_{x=0}^{r-2} \\sum_{\\sigma \\in \\mathfrak{S}_{xr},</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq 2} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\triangle_{i_0 i_1} \\prod_{h=2}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\odot_{i_{h-1} i_h} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\triangle_{r(r+1)} - \\odot_{r(r+1)} \\sum_{\\sigma \\in \\mathfrak{S}_{0r}} (-1)^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\triangle_{i_0 i_1} \\prod_{h=2}^{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\odot_{i_{h-1} i_h} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Taking probabilities, we finally obtain, $\\operatorname{Pr}[\\triangle_{ij}] = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N}<span class="math"> and </span>\\operatorname{Pr}[\\odot_{ij}] = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{r(r+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[\\otimes_{r(r+1)}] = \\frac{1}{N} - \\frac{1}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{\\sigma \\in \\mathfrak{S}_{0r}} (-1)^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{i_0 i_1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N} \\prod_{h=2}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{i_{h-1} i_h}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{i_{h-1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">as claimed.</p>

    <p class="text-gray-300">Reflections on the proof of Lemma 1. As noted in the proof the vertices <span class="math">u_1&#x27;, \\ldots, u_r&#x27;</span> are always "path-compatible" with <span class="math">G</span>, in the sense that if <span class="math">u_i&#x27;</span> is not right-free then <span class="math">u_{i+1}&#x27;</span> is the other endpoint of the edge to the right of <span class="math">u_i&#x27;</span>. Moreover, it's not hard to see that if <span class="math">w_i = u_i&#x27;</span> for some <span class="math">i</span>, then <span class="math">w_j = u_j&#x27;</span> for all <span class="math">j \\geq i</span>, and in particular <span class="math">w_r = u_r&#x27;</span>. For example, if <span class="math">u_1&#x27;</span> is left-free then <span class="math">w_1 = u_1&#x27; = u_1</span> and <span class="math">w_r = u_r&#x27;</span>. More</p>

    <p class="text-gray-300">generally, if there exists an <span class="math">i \\leq r</span> such that <span class="math">w_{i}</span> and <span class="math">u_{i}^{\\prime}</span> are both left-free in <span class="math">G</span>, then <span class="math">w_{i} = u_{i}^{\\prime}</span> and <span class="math">w_{r} = u_{r}^{\\prime}</span>. Conceptually, thus, the introduction of the "primary choices" <span class="math">u_{1}^{\\prime}, \\ldots, u_{r}^{\\prime}</span> can be seen as establishing a coupling between the endpoint <span class="math">u_{r}^{\\prime}</span> of an "ideal path" in <span class="math">G</span> ("ideal" because vertices are uniform in each shore, and in particular <span class="math">u_{r}^{\\prime}</span> is uniform in shore <span class="math">r</span>) and the endpoint <span class="math">w_{r}</span> of the "real path".</p>

    <p class="text-gray-300">While the proof of Lemma 1 can indeed be recast, with appropriate changes, as a coupling argument, the current proof isn't a coupling, technically speaking. More exactly, a coupling argument consists (philosophically at least) in "deforming" the probability space underlying a "real" random variable to better compare the behavior of the "real" random variable with that of an "ideal" random variable (whereby the two probability spaces become "aligned" or "almost aligned"). In the proof of Lemma 1 we carry through the deformation (or alignment) but eschew the comparison with the "ideal" random variable. Indeed, we don't need to compare against the "ideal" random variable when we can exactly compute the "real" random variable probability of interest to us!</p>

    <p class="text-gray-300">FINISHING THE PROOF OF THEOREM 1. We now apply Lemma 1 to lower bounding the product (24). For <span class="math">1 \\leq r \\leq t</span>, let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {L} _ {r} = \\{\\ell : \\mathsf {L} (y _ {\\ell}) - \\mathsf {R} (x _ {\\ell}) = r \\} \\subseteq \\{1, \\dots , q _ {e} \\}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where (we recall) the elements of <span class="math">p_0</span> are <span class="math">(x_1, y_1), \\ldots, (x_{q_e}, y_{q_e})</span>. By the definition of <span class="math">\\mathcal{T}_2</span>, <span class="math">\\mathcal{L}_1, \\ldots, \\mathcal{L}_t</span> cover <span class="math">\\{1, \\ldots, q_e\\}</span> (i.e., there is no <span class="math">\\ell</span> with <span class="math">\\mathsf{R}(x_\\ell) \\geq \\mathsf{L}(y_\\ell)</span>). Assuming the event <span class="math">G_\\ell \\downarrow p_0</span>, we apply Lemma 1 with the graph <span class="math">G</span> obtained by removing shores <span class="math">1, \\ldots, \\mathsf{R}(x_{\\ell+1}) - 1</span>, <span class="math">\\mathsf{L}(y_{\\ell+1}) + 1, \\ldots, t</span> from <span class="math">G_\\ell</span>, and also (mainly for convenience) removing completed paths between <span class="math">x_h</span> and <span class="math">y_h</span> for <span class="math">1 \\leq h \\leq \\ell</span>. (Thus the shores of <span class="math">G</span> will have size <span class="math">N - \\ell</span>, not <span class="math">N</span>.) Indeed, we committed a white lie when we stated in Lemma 1 that the shores of <span class="math">G</span> would be copies of <span class="math">\\{0,1\\}^n</span>. Of course, all that mattered was the size of those shores, and we can apply Lemma 1 by replacing <span class="math">N</span> with <span class="math">N - \\ell</span> throughout in the main bound.) Also, <span class="math">u = \\mathsf{R}(x_{\\ell+1})</span>, <span class="math">v = \\mathsf{L}(y_{\\ell+1})</span>. We note that with this definition of <span class="math">G</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{(i + \\mathsf{R}(x_{\\ell+1}))(j + \\mathsf{R}(x_{\\ell+1}))}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq C q^{j - i} / N^{j - i - 1}<span class="math"> (by the definition of </span>\\mathcal{T}_2<span class="math">) for </span>0 \\leq i &lt; j \\leq t<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q<span class="math"> for </span>1 \\leq i \\leq r<span class="math">. Thus for </span>\\ell + 1 \\in \\mathcal{L}_r$ we obtain, by Lemma 1,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ x _ {\\ell + 1} \\rightarrow y _ {\\ell + 1} \\mid G _ {\\ell} \\downarrow p _ {0} \\right] = \\frac {1}{N - \\ell} - \\frac {1}{N - \\ell} \\sum_ {\\sigma \\in \\mathfrak {S} _ {0 r}} (- 1) ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\prod_ {h = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U _ {i _ {h - 1} i _ {h}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{N - \\ell - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E _ {i _ {h}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac {1}{N - \\ell} - \\frac {1}{N - \\ell} 2 ^ {r - 1} \\left(\\frac {q}{N}\\right) ^ {r} \\left(\\frac {C N}{N - \\ell - q}\\right) ^ {</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\geq \\frac {1}{N - \\ell} - \\frac {1}{N - \\ell} \\left(\\frac {2 q}{N}\\right) ^ {r} \\left(\\frac {C N}{N - 2 q}\\right) ^ {r} \\\\ \\geq \\frac {1}{N - \\ell} - \\frac {1}{N - \\ell} \\left(\\frac {6 C q}{N}\\right) ^ {r}. \\end{array} $$</p>

    <p class="text-gray-300">8 This remark is made for the benefit of readers who know what couplings are. Basically, random variables <span class="math">X</span> and <span class="math">Y</span> defined on a common probability space and having a common range are "coupled" if some special effort has been made to define <span class="math">X</span> and <span class="math">Y</span> in such way that <span class="math">\\operatorname{Pr}[X \\neq Y]</span> is small, while preserving predefined distributions of <span class="math">X</span> and <span class="math">Y</span> over their ranges. Doing a coupling is useful because one has, among others, that <span class="math">\\Delta(X,Y) \\leq \\operatorname{Pr}[X \\neq Y]</span> for any <span class="math">X, Y</span> defined over the same probabilty space (without the latter condition, the expression <span class="math">\\operatorname{Pr}[X \\neq Y]</span> doesn't make sense).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]}{1/(N-\\ell)}=1-\\frac{2}{\\ell+1}\\frac{2}{\\ell^{2}}.$ (10)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t\\cdot\\frac{Cq_{e}q^{t-r}}{N^{t-r}}<span class="math"> by the definition of </span>\\mathcal{T}_{2}$, so</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\prod_{\\ell+1\\in\\mathcal{L}_{r}}\\frac{\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]}{1/(N-\\ell)}<span class="math"> </span>\\geq<span class="math"> </span>\\prod_{\\ell+1\\in\\mathcal{L}_{r}}\\left(1-\\left(\\frac{6Cq}{N}\\right)^{r}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\geq</span> <span class="math">1-\\frac{Ctq_{e}q^{t-r}}{N^{t-r}}\\left(\\frac{6Cq}{N}\\right)^{r}</span> <span class="math">=</span> <span class="math">1-\\frac{Ctq_{e}q^{t}}{N^{t}}(6C)^{r}</span></p>

    <p class="text-gray-300">Thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\prod_{\\ell=0}^{q_{e}-1}\\frac{\\Pr[x_{\\ell+1}\\to y_{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}\\downarrow p_{0}]}{1/(N-\\ell)}<span class="math"> </span>\\geq<span class="math"> </span>1-\\sum_{r=1}^{t}\\frac{Ctq_{e}q^{t}}{N^{t}}(6C)^{r}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\geq</span> <span class="math">1-\\frac{q_{e}q^{t}}{N^{t}}Ct^{2}(6C)^{t}.</span></p>

    <p class="text-gray-300">This means</p>

    <p class="text-gray-300"><span class="math">\\frac{\\Pr[X=\\tau]}{\\Pr[Y=\\tau]}\\geq 1-\\varepsilon_{1}</span></p>

    <p class="text-gray-300">for <span class="math">\\varepsilon_{1}=\\frac{q_{e}q^{t}}{N^{t}}Ct^{2}(6C)^{t}</span>, for all <span class="math">\\tau\\in\\mathcal{T}_{1}</span> such that <span class="math">\\Pr[Y=\\tau]&gt;0</span>. Having already established that <span class="math">\\Pr[Y\\in\\mathcal{T}_{2}]\\leq(t+1)^{2}\\frac{1}{C}</span>, this concludes the proof of Theorem 1 by (10).</p>

    <h2 id="sec-10" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Elena Andreeva, Andrey Bogdanov, Yevgeniy Dodis, Bart Mennink, John Steinberger, Indifferentiability of Key-Alternating Ciphers.</li>

      <li>[2] Andrey Bogdanov, Lars R. Knudsen, Gregor Leander, Francois-Xavier Standaert, John Steinberger and Elmar Tischhauser, Key-Alternating Ciphers in a Provable Setting: Encryption Using a Small Number of Public Permutations. EUROCRYPT 2012, LNCS 7237, pp. , Springer-Verlag, 2012.</li>

      <li>[3] Shan Chen and John Steinberger, Tight Security Bounds for Key-Alternating Ciphers. Eurocrypt 2014 (proceedings version of this paper).</li>

      <li>[4] Joan Daemen, Limitations of the Even-Mansour Construction. ASIACRYPT 1991, LNCS 739, pp. 495-498, Springer-Verlag, 1991.</li>

      <li>[5] Joan Daemen and Vincent Rijmen, The Design of Rijndael. Springer-Verlag, 2002.</li>

      <li>[6] Joan Daemen and Vincent Rijmen, The Wide Trail Design Strategy. IMA Int. Conf., LNCS 2260, pp. 222-238, Springer-Verlag, 2001.</li>

      <li>[7] Shimon Even and Yishay Mansour, A Construction of a Cipher From a Single Pseudorandom Permutation. ASIACRYPT 1991, LNCS 739, pp. 210–224, Springer-Verlag, 1993.</li>

      <li>[8] Shimon Even and Yishay Mansour, A Construction of a Cipher from a Single Pseudorandom Permutation. J. Cryptology, vol. 10, num. 3, pp. 151-162, 1997.</li>

      <li>[9] Peter Gaži and Stefano Tessaro, Efficient and optimally secure key-length extension for block ciphers via randomized cascading. EUROCRYPT 2012, Lecture Notes in Computer Science volume 7237, pp 63-80, 2012.</li>

      <li>[10] Peter Gaži, Plain versus Randomized Cascading-Based Key-Length Extension for Block Ciphers, CRYPTO 2013, Lecture Notes in Computer Science Volume 8042, pp 551–570, 2013.</li>

      <li>[11] Peter Gaži, Plain versus Randomized Cascading-Based Key-Length Extension for Block Ciphers, http://eprint.iacr.org/2013/019.pdf. Full version of <em>[10]</em>.</li>

      <li>[12] Joe Kilian and Phillip Rogaway, How to protect DES against exhaustive key search (an analysis of DESX). Journal of Cryptology 14 (1), 17-35 (2001).</li>

      <li>[13] Rudolphe Lampe, Jacques Patarin and Yannick Seurin, An Asymptotically Tight Security Analysis of the Iterated Even-Mansour Cipher, Asiacrypt 2012, Lecture Notes in Computer Science Volume 7658, pp 278-295, 2012.</li>

      <li>[14] Rudolphe Lampe and Yannick Seurin. How to Construct an Ideal Cipher from a Small Set of Public Permutations, Asiacrypt 2013.</li>

      <li>[15] Michael Luby and Charles Rackoff, How to Construct Pseudorandom Permutations from Pseudorandom Functions. SIAM J. Comput., vol. 17, num. 2, pp. 373-386, 1988.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[16] Ueli Maurer and Krzysztof Pietrzak, Composition of Random Systems: When Two Weak Make One Strong. TCC 2004, LNCS 2951, pp. 410–427, Feb 2004.</li>

      <li>[17] Ueli Maurer, Krzysztof Pietrzak and Renato Renner: Indistinguishability Amplification. CRYPTO 2007, LNCS 4622, pp. 130–149, 2007.</li>

      <li>[18] Jacques Patarin, The “Coefficients H” Technique, Selected Areas in Cryptography, LNCS 5381, 2009, pp. 328-345.</li>

      <li>[19] John Steinberger, Improved Security Bounds for Key-Alternating Ciphers via Hellinger Distance, http://eprint.iacr.org/2012/481.pdf.</li>

    </ul>`;
---

<BaseLayout title="Tight security bounds for key-alternating ciphers (2013/222)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/222
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
