---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1530';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Multivariate lookups based on logarithmic derivatives';
const AUTHORS_HTML = 'Ulrich Hab&ouml;ck';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Logarithmic derivatives translate products of linear factors into sums of their reciprocals, turning zeroes into simple poles of same multiplicity. Based on this simple fact, we construct an interactive oracle proof for multi-column lookups over the boolean hypercube, which makes use of a single multiplicity function instead of working with a rearranged union of table and witnesses. For single-column lookups the performance is comparable to the well-known Plookup strategy used by Hyperplonk+. However, the real power of our argument unfolds in the case of batch lookups when multiple columns are subject to a single-table lookup: While the number of field operations is comparable to the Hyperplonk+ lookup (extended to multiple columns), the oracles provided by our prover are much less expensive. For example, for columns of length 2^12, paper-pencil operation counts indicate that the logarithmic derivative lookup is between 1.5 and 4 times faster, depending on the number of columns.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Lookup arguments &middot; Interactive Oracle Proofs &middot; SNARKs</p>
    </section>

    <h2 id="sec-misc-1" class="text-2xl font-bold"><strong>Contents</strong></h2>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Introduction</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">2</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Preliminaries</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The Lagrange kernel of the boolean hypercube<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The formal derivate<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The logarithmic derivative</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lagrange interactive oracle proofs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The sumcheck protocol</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lookups based on the logarithmic derivative</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The protocol<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Soundness</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Computational cost and optimal sum size<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Vector-valued lookups<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><sup>&lowast;</sup>This updated version clarifies the trade-off between algebraic degree and the number of commitments, previously expressed by two protocol variants (one for small and one for large numbers of columns). It further discusses Polygon Miden's bounded multiplicity encoding, applied to domain-sized table lookups.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Mult</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">tivariate Plookup</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">15</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Batch-column Plookup</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Computational cost and optimal product size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bounded multiplicity encoding</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Com</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">nparison</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ack&#305;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">nowledgements</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{A}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">flookup proof of radical</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
          </tr>
        </tbody>
      </table>
    </div>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Lookup arguments prove a sequence of values being member of an, often prediscribed, table. They are an essential tool for improving the efficiency of arguments for statements which are otherwise quite expensive to arithmetize. Main applications are (1) lookups for relations of high algebraic complexity, and (2) lookups for interval ranges, the latter of which are extensively used by zero-knowledge virtual machines. Although closely related to permutation (or shuffle) arguments [BG12], a first explicit occurence of lookups dates back to the Arya paper [BCG <span class="math">^+</span> 18], to the best of our knowledge. While their argument handles multiplicities directly in a quite costly manner, Plookup [GW20] greatly improved over [BCG <span class="math">^+</span> 18] using a rather geometric approach. Since then Plookup (and variants of it) is the general purpose lookup argument used in practical applications.</p>

    <p class="text-gray-300">In this paper we describe a lookup argument based which is based on logarithmic derivatives. As in classical calculus, the formal logarithmic derivative turns products  <span class="math">\\prod_{i=1}^{N} (X - z_i)</span>  into sums of their reciprocals,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{N} \\frac{1}{X - z_i},</span>$</p>

    <p class="text-gray-300">having poles with the same multiplicity as the zeros of the product. Working with poles instead of zeros is extremly useful for lookup arguments. While the treatment of multiplicities is quite indirect and therefore costly in the product approach [BCG<sup>+</sup>18, GW20], it turns straight-forward when using logarithmic derivatives: Given a sequence of field elements  <span class="math">(a_i)_{i=1}^N</span>  and another sequence  <span class="math">(t_j)_{j=1}^M</span> , then  <span class="math">\\{a_i: i=1,\\ldots,N\\}\\subseteq\\{t_j: j=1,\\ldots,M\\}</span>  as sets, if and only if there exists a sequence of field elements  <span class="math">(m_j)_{j=1}^M</span>  (the multiplicities) such that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{N} \\frac{1}{X - a_i} = \\sum_{j=1}^{M} \\frac{m_j}{X - t_j}.</span>$</p>

    <p class="text-gray-300">(This holds under quite mild conditions on the field, see Lemma 5 for details.) Based on this fractional identity we construct a lookup argument which is more efficient than Plookup, which argues via a sorted union of witness and table sequence. This is particularly true in the case of <em>batch-column</em> lookups, where several sequences (&quot;columns&quot;) are subject to the same table lookup, a situation that often arises in zero-knowledge virtual machines, enforcing execution trace elements being valid machine words. For example, the arithmetic unit of Polygon's System Zero [Pol] has about 70 columns subject to one and the same range check, or the tinyRAM implementation of Orbis Labs [Lab] has 12 columns subject to one and the same lookup table. In our lookup the oracle costs, measuring the number and sizes of the oracles, are significantly lower than for a lookup based on the Plookup strategy.</p>

    <p class="text-gray-300">We stress the fact that we are not the only ones who exploit fractional decompositions for lookups and related problems. Bulletproof++ [Eag22] already uses logarithmic derivatives for range proofs. (This</p>

    <p class="text-gray-300">was not known to us until the present update of this write-up.) Although their treatment lacks formal justification, the key idea is the same as ours. Concurrently, improving the track of work [ZBK<sup>+</sup>22, PK22] on &quot;large-table&quot; lookups (Caulk and Caulk+), Flookup [GK22] describes an oracle proof for the radical of a witness sequence (i.e. the sequence with multiple occurrences removed) which is almost identical to the logarithmic derivative approach<sup>1</sup>. In the meantime, logarithmic derivatives are directly used in large-table lookups, yielding the currently most efficient argument Cached Quotients [EFG22].</p>

    <p class="text-gray-300">This document focuses on batch-column lookups in the multivariate setting. It is organized as follows. In Section 2, we gather the preliminaries used in the sequel: The Lagrange kernel over the boolean hypercube, basic facts on the formal logarithmic derivative, and a summary of the multivariate sumcheck argument. Besides that, we informally introduce Lagrange interactive oracle proofs, an oracle model we consider suitable for arguments which are based on the Lagrange representation of polynomials rather than their coefficients. In Section 3 we describe our lookup argument based on the logarithmic derivative. For comparison reasons, we add an extra section (Section 4) in which we outline batch-column lookups using the Plookup strategy, adapted to the boolean hypercube. These rely on the time shift from Hyperplonk [CBBZ22], and we consider them state-of-the-art in the multivariate setting.</p>

    <p class="text-gray-300">We finally point out, that although our protocol is written for the multilinear setting, its translation into a univariate proof is straight-forward. We expect these univariate arguments to improve similarly over multi-column lookups based on the Plookup strategy.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 The Lagrange kernel of the boolean hypercube</h3>

    <p class="text-gray-300">Let F denote a finite field, and  <span class="math">F^*</span>  its multiplicative group. Throughout the document we regard the boolean hypercube  <span class="math">H = \\{\\pm 1\\}^n</span>  as a multiplicative subgroup of  <span class="math">(F^*)^n</span> . For a multivariate function  <span class="math">f(X_1, \\ldots, X_n)</span> , we will often use the vector notation  <span class="math">\\vec{X} = (X_1, \\ldots, X_n)</span>  for its arguments, writing  <span class="math">f(\\vec{X}) := f(X_1, \\ldots, X_n)</span> . The Lagrange kernel of H is the multilinear polynomial</p>

    <p class="text-gray-300">
<span class="math">$L_H(\\vec{X}, \\vec{Y}) = \\frac{1}{2^n} \\cdot \\prod_{j=1}^n (1 + X_j \\cdot Y_j).</span>$
(1)</p>

    <p class="text-gray-300">Notice that  <span class="math">L_H(\\vec{X}, \\vec{Y})</span>  is symmetric in  <span class="math">\\vec{X}</span>  and  <span class="math">\\vec{Y}</span> , i.e.  <span class="math">L_H(\\vec{X}, \\vec{Y}) = L_H(\\vec{Y}, \\vec{X})</span> , and that (1) is evaluated within only  <span class="math">\\mathcal{O}(\\log |H|)</span>  field operations. Whenever  <span class="math">\\vec{y} \\in H</span>  we have that  <span class="math">L_H(\\vec{X}, \\vec{y})</span>  is the Lagrange polynomial on H, which is the unique multilinear polynomial which satisfies  <span class="math">L_H(\\vec{x}, \\vec{y}) = 1</span>  at  <span class="math">\\vec{x} = \\vec{y}</span> , and zero elsewhere on H. In particular for a function  <span class="math">f: H \\to F</span>  the inner product evaluation formula</p>

    <p class="text-gray-300"><span class="math">$\\langle f, L_H(., \\vec{y}) \\rangle_H := \\sum_{\\vec{x} \\in H} f(\\vec{x}) \\cdot L_H(\\vec{x}, \\vec{y}) = f(\\vec{y}).</span>$</p>

    <p class="text-gray-300">is valid for every  <span class="math">\\vec{y} \\in H</span> . This property extends beyond H, as the following Lemma shows.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let  <span class="math">p(\\vec{X})</span>  be the unique multilinear extension of  <span class="math">f: H \\to F</span> . Then for every  <span class="math">\\vec{y} \\in F^n</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\langle f, L_H(., \\vec{y}) \\rangle_H = \\sum_{x \\in H} f(\\vec{x}) \\cdot L_H(\\vec{x}, \\vec{y}) = p(\\vec{y}). \\tag{2}</span>$</p>

    <p class="text-gray-300">Proof. Since  <span class="math">p(\\vec{y}) = \\sum_{\\vec{x} \\in H} f(\\vec{z}) \\cdot L_H(\\vec{X}, \\vec{z})</span> , it suffices to show the claim for  <span class="math">p(X) = L_H(\\vec{X}, \\vec{z})</span> , with  <span class="math">\\vec{z} \\in H</span> . By the property of  <span class="math">L_H(\\vec{X}, \\vec{z})</span> , we have  <span class="math">\\langle L_H(\\cdot, \\vec{z}), L_H(\\cdot, \\vec{y}) \\rangle_H = L_H(\\vec{y}, \\vec{z})</span> , which by symmetry is equal to  <span class="math">L_H(\\vec{X}, \\vec{y})</span>  at  <span class="math">\\vec{X} = \\vec{z}</span> . This completes the proof of the Lemma.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup>Almost simultaneously, G. Roh, W. Dai, M. Jabbour, and A. He, published the same idea in a blog post [RDJH22].</p>

    <p class="text-gray-300">Note that for any  <span class="math">\\vec{y} \\in F^n</span> , the domain evaluation of  <span class="math">L_H(\\vec{X}, \\vec{y})</span>  over H can be computed in  <span class="math">\\mathcal{O}(|H|)</span>  field operations, by recursively computing the domain evaluation of the partial products  <span class="math">p_k(X_1, \\ldots, X_k, y_1, \\ldots, y_k) = \\frac{1}{2^n} \\cdot \\prod_{j=1}^k (1 + X_j \\cdot y_j)</span>  over  <span class="math">H_k = \\{\\pm 1\\}^k</span>  from the domain evaluation of  <span class="math">p_{k-1}</span> , where one starts with  <span class="math">f_0 = \\frac{1}{2^n}</span>  over the single-point domain  <span class="math">H_0</span> . Each recursion step costs  <span class="math">|H_{k-1}|</span>  field multiplications, denoted by M, and the same number of additions, denoted by M, yielding overall</p>

    <p class="text-gray-300"><span class="math">$\\sum_{k=1}^{n} |H_{k-1}| \\cdot (\\mathsf{M} + \\mathsf{A}) &lt; |H| \\cdot (\\mathsf{M} + \\mathsf{A}). \\tag{3}</span>$</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 The formal derivate</h3>

    <p class="text-gray-300">Given a univariate polynomial  <span class="math">p(X) = \\sum_{k=0}^{d} c_k \\cdot X^k</span>  over a general (possibly infinite) field F, its derivative is defined as</p>

    <p class="text-gray-300"><span class="math">$p&#x27;(X) := \\sum_{k=1}^{d} k \\cdot c_k \\cdot X^{k-1}.</span>$
(4)</p>

    <p class="text-gray-300">As in calculus, the derivative is linear, i.e. for every two polynomials  <span class="math">p_1(X), p_1(X) \\in F[X]</span> , and coefficients  <span class="math">\\lambda_1, \\lambda_2 \\in F</span> ,</p>

    <p class="text-gray-300"><span class="math">$(\\lambda_1 \\cdot p_1(X) + \\lambda_2 \\cdot p_1(X))&#x27; = \\lambda_1 \\cdot p_1&#x27;(X) + \\lambda_2 \\cdot p_2&#x27;(X)</span>$</p>

    <p class="text-gray-300">and we have the product rule</p>

    <p class="text-gray-300"><span class="math">$(p_1(X) \\cdot p_2(X))&#x27; = p_1&#x27;(X) \\cdot p_2(X) + p_1(X) \\cdot p_2&#x27;(X).</span>$</p>

    <p class="text-gray-300">For a function  <span class="math">\\frac{p(X)}{q(X)}</span>  from the rational function field F(X), the derivative is defined as the rational function</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{p(X)}{q(X)}\\right)&#x27; := \\frac{p&#x27;(X) \\cdot q(X) - p(X) \\cdot q&#x27;(X)}{q(X)^2}.</span>$
(5)</p>

    <p class="text-gray-300">By the product rule for polynomials, the definition does not depend on the representation of  <span class="math">\\frac{p(X)}{q(X)}</span> . Both linearity as well as the product rule extend to rational functions.</p>

    <p class="text-gray-300">For any polynomial  <span class="math">p(X) \\in F[X]</span> , if p'(X) = 0 then  <span class="math">p(X) = g(X^p)</span>  where p is the characteristic of the field F. In particular, if deg p(X) &lt; p, then the polynomial must be constant. As the analogous fact for fractions is not as commonly known, we give a proof of the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let F be a field of characteristic  <span class="math">p \\neq 0</span> , and  <span class="math">\\frac{p(X)}{q(X)}</span>  a rational function over F with both  <span class="math">\\deg p(X) &lt; p</span>  and  <span class="math">\\deg q(X) &lt; p</span> . If the formal derivative  <span class="math">\\left(\\frac{p(X)}{q(X)}\\right)&#x27; = 0</span> , then  <span class="math">\\frac{p(X)}{q(X)} = c</span>  for some constant  <span class="math">c \\in F</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> If q(X) is a constant, then the assertion of the Lemma follows from the corresponding statement for polynomials. Hence we assume that  <span class="math">\\deg q(X) &gt; 0</span> . Use polynomial division to obtain the representation</p>

    <p class="text-gray-300"><span class="math">$\\frac{p(X)}{q(X)} = m(X) + \\frac{r(X)}{q(X)},</span>$</p>

    <p class="text-gray-300">with  <span class="math">m(X), r(X) \\in F[X]</span> ,  <span class="math">\\deg m(X) \\leq \\deg p(X)</span> , and  <span class="math">\\deg r(X) &lt; \\deg q(X)</span>  whenever  <span class="math">r(X) \\neq 0</span> . By linearity of the derivative, we have  <span class="math">0 = \\left(\\frac{p(X)}{q(X)}\\right)&#x27; = m&#x27;(X) + \\left(\\frac{r(X)}{q(X)}\\right)&#x27;</span> , and therefore</p>

    <p class="text-gray-300">
<span class="math">$r&#x27;(X) \\cdot q(X) - r(X) \\cdot q&#x27;(X) = -m&#x27;(X) \\cdot q(X)^{2}.</span>$
(6)</p>

    <p class="text-gray-300">Comparing the degrees of left and right hand side in (6), we conclude that m'(X) = 0. Since  <span class="math">\\deg m(X) \\le \\deg p(X) &lt; p</span>  we have m(X) = c for some constant  <span class="math">c \\in F</span> . Furthermore, if we had  <span class="math">r(X) \\ne 0</span>  then the leading term of the left hand side in (6) would be</p>

    <p class="text-gray-300"><span class="math">$(k-n)\\cdot c_n\\cdot d_k\\cdot X^{n+k-1},</span>$</p>

    <p class="text-gray-300">with  <span class="math">c_n \\cdot X^n</span> , n &gt; 0, being the leading term of q(X), and  <span class="math">d_k \\cdot X^k</span> ,  <span class="math">0 \\le k &lt; n</span> , the leading term of r(X). As 0 &lt; n - k &lt; p, and both  <span class="math">c_n \\ne 0</span>  and  <span class="math">c_m \\ne 0</span> , the leading term of the left hand side of (6) would not vanish. Therefore it must hold that r(X) = 0 and the proof of the lemma is complete.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 The logarithmic derivative</h3>

    <p class="text-gray-300">The logarithmic derivate of a polynomial p(X) over a (general) field F is the rational function</p>

    <p class="text-gray-300"><span class="math">$\\frac{p&#x27;(X)}{p(X)}</span>$
.</p>

    <p class="text-gray-300">Note that the logarithmic derivative of the product  <span class="math">p_1(X) \\cdot p_2(X)</span>  of two polynomials  <span class="math">p_1(X), p_2(X)</span>  equals the sum of their logarithmic derivatives, since by the product rule we have</p>

    <p class="text-gray-300"><span class="math">$\\frac{(p_1(X) \\cdot p_2(X))&#x27;}{p_1(X) \\cdot p_2(X)} = \\frac{p_1&#x27;(X) \\cdot p_2(X) + p_1(X) \\cdot p_2&#x27;(X)}{p_1(X) \\cdot p_2(X)} = \\frac{p_1&#x27;(X)}{p_1(X)} + \\frac{p_2&#x27;(X)}{p_2(X)}.</span>$</p>

    <p class="text-gray-300">In particular the logarithmic derivative of a product  <span class="math">p(X) = \\prod_{i=1}^{n} (X + z_i)</span> , with each  <span class="math">z_i \\in F</span> , is equal to the sum</p>

    <p class="text-gray-300"><span class="math">$\\frac{p&#x27;(X)}{p(X)} = \\sum_{i=1}^{n} \\frac{1}{X + z_i}.</span>$
(7)</p>

    <p class="text-gray-300">The following lemma<sup>3</sup> is a simple consequence of Lemma 2 and essentially states that, under quite mild conditions on the field F, if two normalized polynomials have the same logarithmic derivative then they are equal. We state this fact for our use case of product representations.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let  <span class="math">(a_i)_{i=1}^n</span>  and  <span class="math">(b_i)_{i=1}^n</span>  be sequences over a field F with characteristic p &gt; n. Then  <span class="math">\\prod_{i=1}^n (X + a_i) = \\prod_{i=1}^n (X + b_i)</span>  in F[X] if and only if</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{n} \\frac{1}{X + a_i} = \\sum_{i=1}^{n} \\frac{1}{X + b_i}</span>$</p>

    <p class="text-gray-300">in the rational function field F(X).</p>

    <p class="text-gray-300"><em>Proof.</em> If  <span class="math">p_a(X) = \\prod_{i=1}^n (X + a_i)</span>  and  <span class="math">p_b(X) = \\prod_{i=1}^n (X + b_i)</span>  coincide, so do their logarithmic derivatives. To show the other direction, assume that  <span class="math">\\frac{p_a&#x27;(X)}{p_a(X)} = \\frac{p_b&#x27;(X)}{p_b(X)}</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{p_a(X)}{p_b(X)}\\right)&#x27; = \\frac{p&#x27;_a(X) \\cdot p_b(X) - p_a(X) \\cdot p&#x27;_b(X)}{p_b^2(X)} = 0.</span>$</p>

    <p class="text-gray-300">Hence by Lemma 2 we have  <span class="math">\\frac{p_a(X)}{p_b(X)} = c</span>  for some constant  <span class="math">c \\in F</span> . As both  <span class="math">p_a(X)</span>  and  <span class="math">p_b(X)</span>  have leading coefficient equal to 1, we conclude that c = 1, and the proof of the Lemma is complete.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>For general degrees of p(X) we would only be able to conclude that  <span class="math">m(X) = g(X^p)</span>  for some polynomial g(X).</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup>At the time of writing we learned that also others are aware of Lemma 3. In a Delendum Frontiers session on multi-party computation (6. Oct. 2022) an audience member pointed out its usefulness for permutation arguments.</p>

    <p class="text-gray-300"><strong>Remark 1.</strong> We stress the fact that Lemma 3 also applies to the case where F is the function field  <span class="math">F_p(Y_1, \\ldots, Y_k)</span>  over a finite field  <span class="math">F_p</span>  of characteristic p. This observation will be useful when generalizing the permutation argument to the case where  <span class="math">a_i</span>  and  <span class="math">b_i</span>  are multilinear polynomials in  <span class="math">Y_1, \\ldots, Y_n</span> .</p>

    <p class="text-gray-300">Given a product  <span class="math">p(X) = \\prod_{i=1}^{N} (X + a_i)</span>  we can gather the poles of its logarithmic derivative obtaining the fractional decomposition</p>

    <p class="text-gray-300"><span class="math">$\\frac{p&#x27;(X)}{p(X)} = \\sum_{a \\in F} \\frac{m(a)}{X + a},</span>$</p>

    <p class="text-gray-300">where  <span class="math">m(a) \\in \\{1, ..., N\\}</span>  is the multiplicity of the value a in  <span class="math">(a_i)_{i=1}^N</span> . Fractional decompositions are unique, as shown by the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> Let F be an arbitrary field and  <span class="math">m_1, m_2 : F \\to F</span>  any functions. Then  <span class="math">\\sum_{z \\in F} \\frac{m_1(z)}{X - z} = \\sum_{z \\in F} \\frac{m_2(z)}{X - z}</span>  in the rational function field F(X), if and only if  <span class="math">m_1(z) = m_2(z)</span>  for every  <span class="math">z \\in F</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that the fractional decompositions are equal. Then  <span class="math">\\sum_{z \\in F} \\frac{m_1(z) - m_2(z)}{X - z} = 0</span> , and therefore</p>

    <p class="text-gray-300"><span class="math">$p(X) = \\prod_{w \\in F} (X - w) \\cdot \\sum_{z \\in F} \\frac{m_1(z) - m_2(z)}{X - z} = \\sum_{z \\in F} (m_1(z) - m_2(z)) \\cdot \\prod_{w \\in F \\setminus \\{z\\}} (X - w) = 0.</span>$</p>

    <p class="text-gray-300">In particular,  <span class="math">p(z) = (m_1(z) - m_2(z)) \\cdot \\prod_{w \\in F \\setminus \\{z\\}} (z - w) = 0</span>  for every  <span class="math">z \\in F</span> . Since  <span class="math">\\prod_{w \\in F \\setminus \\{z\\}} (z - w) \\neq 0</span>  we must have  <span class="math">m_1(z) = m_2(z)</span>  for every  <span class="math">z \\in F</span> . The other direction is obvious.</p>

    <p class="text-gray-300">This leads to the following algebraic criterion for set membership, which is the key tool for our lookup arguments.</p>

    <p class="text-gray-300"><strong>Lemma 5</strong> (Set inclusion). Let F be a field of characteristic p &gt; N, and suppose that  <span class="math">(a_i)_{i=1}^N</span> ,  <span class="math">(b_i)_{i=1}^N</span>  are arbitrary sequences of field elements. Then  <span class="math">\\{a_i\\} \\subseteq \\{b_i\\}</span>  as sets (with multiples of values removed), if and only if there exists a sequence  <span class="math">(m_i)_{i=1}^N</span>  of field elements from  <span class="math">F_q \\subseteq F</span>  such that</p>

    <p class="text-gray-300">
<span class="math">$\\sum_{i=1}^{N} \\frac{1}{X + a_i} = \\sum_{i=1}^{N} \\frac{m_i}{X + b_i} \\tag{8}</span>$</p>

    <p class="text-gray-300">in the function field F(X). Moreover, we have equality of the sets  <span class="math">\\{a_i\\} = \\{b_i\\}</span> , if and only if  <span class="math">m_i \\neq 0</span> , for every i = 1, ..., N.</p>

    <p class="text-gray-300"><em>Proof.</em> Let us denote by  <span class="math">m_a(z)</span>  the multiplicity of a field element z in the sequence  <span class="math">(a_i)_{i=1}^N</span> . Likewise, we do for  <span class="math">(b_i)_{i=1}^N</span> . Note that since N &lt; p, the multiplicities can be regarded as non-zero elements from  <span class="math">F_p</span>  as a subset of F. Suppose that  <span class="math">\\{a_i\\} \\subseteq \\{b_i\\}</span>  as sets. Set  <span class="math">(m_i)</span>  as the normalized multiplicities  <span class="math">m_i = \\frac{m_a(b_i)}{m_b(b_i)}</span> . This choice of  <span class="math">(m_i)</span>  obviously satisfies (8).</p>

    <p class="text-gray-300">Conversely, suppose that (8) holds. Collecting fractions with the same denominator we obtain fractional representations for both sides of the equation (8),</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{N} \\frac{1}{X + a_i} = \\sum_{z \\in F} \\frac{m_a(z)}{X + z},</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{N} \\frac{m_i}{X + b_i} = \\sum_{z \\in F} \\frac{\\mu(z)}{X + z}.</span>$</p>

    <p class="text-gray-300">Note that since N &lt; p, we know that for each  <span class="math">z \\in \\{a_i\\}</span>  we have  <span class="math">m_a(z) \\neq 0</span> . By the uniqueness of fractional representations, Lemma 4,  <span class="math">m_a(z) = \\mu(z)</span>  for every  <span class="math">z \\in \\{a_i\\}</span> , and therefore each  <span class="math">z \\in \\{a_i\\}</span>  must occur also in  <span class="math">\\{b_i\\}</span> .</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8"><strong>2.4 Lagrange interactive oracle proofs</strong></h3>

    <p class="text-gray-300">The oracle proofs of many general purpose SNARKs such as Plonk <a href="#page-20-9">[GWC19]</a> or algebraic intermediate representations <a href="#page-19-4">[BSBHR18]</a> rely on witnesses that are given in Lagrange representation, i.e. by their values over a domain <em>H</em>. Their multivariate variants may completely avoid the usage of fast Fourier transforms whenever the polynomial commitment scheme can be turned into one that does not need to know the coefficients, neither when computing a commitment nor in an opening proof. Exactly this property is captured by <em>Lagrange oracle proofs</em>, rather than polynomial ones <a href="#page-19-5">[BFS20]</a>.</p>

    <p class="text-gray-300">A <em>Lagrange interactive oracle proof</em> (<em>Lagrange IOP</em>) over the boolean hypercube <em>H</em> = {&plusmn;1} <em>n</em> is an interactive protocol between two parties, the &quot;prover&quot; and the &quot;verifier&quot;. In each round, the verifier sends a message (typically a random challenge) and the prover computes one or several functions over the boolean hypercube, and gives the verifier oracle access to them. From the moment on it is given access, the verifier is allowed to query the oracles for their inner products with the Lagrange kernel <em>LH</em>(<em>. , ~y</em>), associated with an arbitrary vector <em>~y</em> &isin; <em>F n</em> .</p>

    <p class="text-gray-300">The security notions for Lagrange IOPs, such as completeness, (knowledge) soundness, and zeroknowledge, are exactly the same as for other interactive oracle proofs. We assume that the reader is familiear with these, and refer to <a href="#page-19-6">[BSCS16]</a> or <a href="#page-19-5">[BFS20]</a> for their formal definitions.</p>

    <p class="text-gray-300">Lagrange IOPs are turned into arguments by instantiating the Lagrange oracles by a <em>Lagrange commitment scheme</em>. A Lagrange commitment scheme is a commitment scheme for functions over <em>H</em> that comes with an evaluation proof for Lagrange queries. For example, inner product arguments <a href="#page-19-7">[BCC</a>+16] can be directly used to construct Lagrange commitment schemes, but also the multilinear variant <a href="#page-20-10">[PST13]</a> of the <a href="#page-20-11">[KZG10]</a> commitment scheme is easily modified to completely avoid dealing with coefficients. We suppose that this is well-known, and therefore we omit an explicit elaboration in this paper.</p>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8"><strong>2.5 The sumcheck protocol</strong></h3>

    <p class="text-gray-300">We give a concise summary on the multivariate sumcheck protocol <a href="#page-20-12">[LFKN92]</a>. Given a multivariate polynomial <em>p</em>(<em>X</em>1<em>, . . . , Xn</em>) &isin; <em>F</em>[<em>X</em>1<em>, . . . , Xn</em>], a prover wants to convince a verifier upon that</p>

    <p class="text-gray-300"><span class="math">$s = \\sum_{(x_1, \\dots, x_n) \\in \\{\\pm 1\\}^n} p(x_1, \\dots, x_n).</span>$</p>

    <p class="text-gray-300">This is done by a random folding procedure which, starting with <em>H</em><sup>0</sup> = {&plusmn;1} <em>n</em> , which stepwise reduces a claim on the sum over <em>H<sup>i</sup></em> = {&plusmn;1} <em>n</em>&minus;<em>i</em> , <em>i</em> = 0<em>, . . . , n</em> &minus; 1, to one over the hypercube <em>Hi</em>+1 of half the size. Eventually, one ends up with a claim over a single-point sum, which is paraphrased as the value of <em>p</em>(<em>X</em>1<em>, . . . , Xn</em>) at a random point (<em>r</em>1<em>, . . . , rn</em>) &isin; <em>F n</em> sampled in the course of the reduction steps.</p>

    <p class="text-gray-300"><strong>Protocol 1</strong> (Sumcheck protocol, <a href="#page-20-12">[LFKN92]</a>)<strong>.</strong> <em>Let p</em>(<em>X</em>1<em>, . . . , Xn</em>) <em>be a multivariate polynomial over a finite field F. The sumcheck protocol, in which a prover wants to convince the verifier upon the sum s</em> = P (<em>x</em>1<em>,...,xn</em>)&isin;{&plusmn;1}<em><sup>n</sup> p</em>(<em>x</em>1<em>, . . . , xn</em>)<em>, is as follows. We write s</em>0(<em>X</em>) <em>for the constant polynomial s</em><sup>0</sup> = <em>s.</em></p>

    <p class="text-gray-300">&bull; <em>In each round i</em> = 1<em>, . . . , n, the prover sends the coefficients of the univariate polynomial</em></p>

    <p class="text-gray-300"><span class="math">$s_i(X) = \\sum_{(x_{i+1},\\dots,x_n)\\in\\{\\pm 1\\}^{n-i}} p(r_1,\\dots,r_{i-1},X,x_{i+1},\\dots,x_n),</span>$</p>

    <p class="text-gray-300"><em>of degree d<sup>i</sup></em> &le; deg<em>X<sup>i</sup> p</em>(<em>X</em>1<em>, . . . , Xn</em>)<em>, where r</em>1<em>, . . . , ri</em>&minus;<sup>1</sup> <em>are the randomnesses received in the previous rounds. (In the first round i</em> = 1 <em>there are no previous randomnesses, and p</em>(<em>r</em>1<em>, . . . , ri</em>&minus;1<em>, X, xi</em>+1<em>, . . . , xn</em>) <em>is meant to denote p</em>(<em>X, x</em>2<em>, . . . , xn</em>)<em>.) The prover sends the coefficients of si</em>(<em>X</em>) <em>to the verifier, which checks whether the received polynomial si</em>(<em>X</em>) <em>is in fact of the expected degree and that</em></p>

    <p class="text-gray-300"><span class="math">$s_{i-1}(r_{i-1}) = s_i(+1) + s_i(-1).</span>$</p>

    <p class="text-gray-300"><em>(Again, in the first round i</em> = 1 <em>there is no r</em>0<em>, and the verifier checks wheather s</em><sup>0</sup> = <em>s</em>1(+1)+<em>s</em>1(&minus;1)<em>.) If so, the verifier samples random challenge r<sup>i</sup></em> &larr;$ <em>F uniformly from F and sends it to the prover.</em></p>

    <p class="text-gray-300"><em>After these rounds the verifier checks that sn</em>(<em>rn</em>) = <em>p</em>(<em>r</em>1<em>, . . . , rn</em>)<em>. If so, the verifier accepts (otherwise it rejects).</em></p>

    <p class="text-gray-300">Soundness of the sumcheck protocol is proven by a repeated application of the Schwartz-Zippel lemma. We omit a proof, and refer to <a href="#page-20-12">[LFKN92]</a> or <a href="#page-20-13">[Tha13]</a>.</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> (<a href="#page-20-12">[LFKN92]</a>)<strong>.</strong> <em>The sumcheck protocol (Protocol <a href="#page-6-2">1)</a> has soundness error</em></p>

    <p class="text-gray-300">
<span class="math">$\\varepsilon_{sumcheck} \\le \\frac{1}{|F|} \\cdot \\sum_{i=1}^{n} \\deg_{X_i} p(X_1, \\dots, X_n).</span>$
(9)</p>

    <p class="text-gray-300">The sumcheck protocol is easily extended to the sumcheck for a batch of polynomials <em>pi</em>(<em>X</em>1<em>, . . . , Xn</em>), <em>i</em> = 0<em>, . . . , L</em>, by letting the verifier sample a random vector (<em>&lambda;</em>1<em>, . . . , &lambda;L</em>) &larr;$ <em>F <sup>L</sup></em>, and a subsequent sumcheck protocol for the random linear combination</p>

    <p class="text-gray-300"><span class="math">$\\bar{p}(X_1,\\ldots,X_n) = p_0(X_1,\\ldots,X_n) + \\sum_{i=1}^L \\lambda_i \\cdot p_i(X_1,\\ldots,X_n).</span>$</p>

    <p class="text-gray-300">The soundness error bound increases only slightly,</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_{sumcheck} \\le \\frac{1}{|F|} \\cdot \\left( 1 + \\sum_{i=1}^{n} \\deg_{X_i} p(X_1, \\dots, X_n) \\right).</span>$
(10)</p>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8"><strong>Computational cost</strong></h3>

    <p class="text-gray-300">Let us discuss the prover cost of the sumcheck protocol for the case that <em>p</em>(<em>X~</em> ) = <em>p</em>(<em>X</em>1<em>, . . . , Xn</em>) is of the form</p>

    <p class="text-gray-300"><span class="math">$p(\\vec{X}) = Q(w_1(\\vec{X}), \\dots, w_{\\nu}(\\vec{X})),</span>$</p>

    <p class="text-gray-300">with each <em>wi</em>(<em>X~</em> ) &isin; <em>F</em>[<em>X</em>1<em>, . . . , Xn</em>] being multilinear, and</p>

    <p class="text-gray-300"><span class="math">$Q(Y_1, \\dots, Y_{\\nu}) = \\sum_{(i_1, \\dots, i_{\\nu}) \\in \\{0,1\\}^{\\nu}} c_{i_1, \\dots, i_{\\nu}} \\cdot Y_1^{i_1} \\cdots Y_{\\nu}^{i_{\\nu}}</span>$</p>

    <p class="text-gray-300">is a multivariate polynomial having (a typically low) absolute degree <em>d</em>. We denote the arithmetic complexity, i.e. the number of field multiplications M, substractions and additions A to evaluate <em>Q</em> by |<em>Q</em>|<sup>M</sup> and |<em>Q</em>|A, respectively. (For simplicity we count substractions as additions.) Each of the univariate polynomials <em>si</em>(<em>X</em>), <em>i</em> = 1<em>, . . . , n</em>, is of degree at most <em>d</em> the absolute degree of <em>Q</em>, and is computed from its values over a set <em>D</em> &supe; {&plusmn;1} of size |<em>D</em>| = <em>d</em> + 1. In each step <em>i</em> = 1<em>, . . . , n</em>, the values of <em>si</em>(<em>z</em>) for <em>z</em> &isin; <em>D</em> are obtained by linear interpolation of the domain evaluations of each</p>

    <p class="text-gray-300"><span class="math">$w_j(r_1,\\ldots,r_{i-1},\\pm 1,X_{i+1},\\ldots,X_n)</span>$</p>

    <p class="text-gray-300">over <em>H<sup>i</sup></em> = {&plusmn;1} <em><sup>n</sup></em>&minus;<em><sup>i</sup></em> as given from the previous step, to the domain evaluation</p>

    <p class="text-gray-300"><span class="math">$w_j(r_1,\\ldots,r_{i-1},z,X_{i+1},\\ldots,X_n),</span>$</p>

    <p class="text-gray-300">the values of which are used for computing <em>si</em>(<em>z</em>) = P (<em>xi</em>+1<em>,...,xn</em>)&isin;<em>H<sup>i</sup> Q</em>(<em>r</em>1<em>, . . . , ri</em>&minus;1<em>, z, xi</em>+1<em>, . . . , xn</em>). Given the random challenge <em>r<sup>i</sup></em> from the verifier, the domain evaluation of each</p>

    <p class="text-gray-300"><span class="math">$w_j(r_1,\\ldots,r_{i-1},r_i,X_{i+1},\\ldots,X_n)</span>$</p>

    <p class="text-gray-300">is computed by another linear interpolation. Linear interpolation costs  <span class="math">|H_i|</span>  multiplications and the same number of additions/substractions for each multilinear polynomial, the values of Q are obtained within  <span class="math">|Q|_{\\mathsf{M}} \\cdot \\mathsf{M} + |Q|_{\\mathsf{A}} \\cdot \\mathsf{A}</span> . In terms of field multiplications  <span class="math">\\mathsf{M}</span>  and substractions/additions  <span class="math">\\mathsf{A}</span> , step i consumes</p>

    <p class="text-gray-300"><span class="math">$\\nu \\cdot |H_i| \\cdot \\mathsf{A} + \\nu \\cdot (|D|-1) \\cdot |H_i| \\cdot (\\mathsf{M}+\\mathsf{A}) + |D| \\cdot |H_i| \\cdot (|Q|_\\mathsf{M} \\cdot \\mathsf{M} + |Q|_\\mathsf{A} \\cdot \\mathsf{A}) + |D| \\cdot |H_i| \\cdot \\mathsf{A},</span>$</p>

    <p class="text-gray-300">where the last term is for the domain sums. Since  <span class="math">\\sum_{i=1}^{n} |H_i| = |H| - 1</span> , the overall cost for the prover is bounded by</p>

    <p class="text-gray-300"><span class="math">$|H| \\cdot \\left(1 - \\frac{1}{|H|}\\right) \\cdot \\left(\\left(d \\cdot \\nu + (d+1) \\cdot |Q|_{\\mathsf{M}}\\right) \\cdot \\mathsf{M} + (d+1) \\cdot \\left(\\nu + |Q|_{\\mathsf{A}}\\right) + d\\right) \\cdot \\mathsf{A}\\right). \\tag{11}</span>$</p>

    <p class="text-gray-300">We shall use the simplified formula</p>

    <p class="text-gray-300">
<span class="math">$|H| \\cdot (d+1) \\cdot ((\\nu + |Q|_{\\mathsf{M}}) \\cdot \\mathsf{M} + (\\nu + |Q|_{\\mathsf{A}}) \\cdot \\mathsf{A}) \\tag{12}</span>$</p>

    <p class="text-gray-300">for the operation counts of our lookup protocol.</p>

    <p class="text-gray-300">Assume that F is a finite field, and that  <span class="math">f_1, \\ldots, f_M</span>  and  <span class="math">t: H \\to F</span>  are functions over the Boolean hypercube  <span class="math">H = \\{\\pm 1\\}^n</span> . By Lemma 5, it holds that  <span class="math">\\bigcup_{i=1}^M \\{f_i(\\vec{x})\\}_{\\vec{x} \\in H} \\subseteq \\{t(\\vec{x})\\}_{\\vec{x} \\in H}</span>  as sets, if and only if there exists a function  <span class="math">m: H \\to F</span>  such that</p>

    <p class="text-gray-300">
<span class="math">$\\sum_{\\vec{x} \\in H} \\sum_{i=1}^{M} \\frac{1}{X + f_i(\\vec{x})} = \\sum_{\\vec{x} \\in H} \\frac{m(\\vec{x})}{X + t(\\vec{x})},\\tag{13}</span>$</p>

    <p class="text-gray-300">assuming that the characteristic of F is larger than M times the size of the hypercube. If t is injective (which is typically the case for lookup tables) then m is the multiplicity function, counting the number of occurences for each value  <span class="math">t(\\vec{x})</span>  in  <span class="math">f_1, \\ldots, f_M</span>  altogether, i.e.  <span class="math">m(\\vec{x}) = m_f(t(\\vec{x})) = \\sum_{i=1}^M |\\{\\vec{y} \\in H : f_i(\\vec{y}) = t(\\vec{x})\\}|</span> . If t is not one-to-one, we set m as the normalized multiplicity function</p>

    <p class="text-gray-300">
<span class="math">$m(\\vec{x}) = \\frac{m_f(t(\\vec{x}))}{m_t(t(\\vec{x}))} = \\frac{\\sum_{i=1}^M |\\{\\vec{y} \\in H : f_i(\\vec{y}) = t(\\vec{x})\\}|}{|\\{\\vec{y} \\in H : t(\\vec{y}) = t(\\vec{x})\\}|}.</span>$
(14)</p>

    <p class="text-gray-300">Given a random challenge  <span class="math">x \\leftarrow F</span>  from the verifier, the prover shows that the rational identity (13) holds at X = x, i.e.</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in H} \\sum_{i=1}^{M} \\frac{1}{x + f_i(\\vec{x})} - \\frac{m(\\vec{x})}{x + t(\\vec{x})} = 0, \\tag{15}</span>$</p>

    <p class="text-gray-300">whenever evaluation is possible. However, in order to apply the sumcheck protocol we need to turn the fractional expression into a polynomial one. For that, the prover splits the sum into partial sums of (roughly) the same number of terms  <span class="math">\\ell</span> , and provides multilinear helper functions for each sum. These helper functions are subject to a domain identity of algebraic degree essentially equal to the number of reciprocal terms in the sum. In practice one chooses  <span class="math">\\ell</span>  so that the prover time is minimal for the given number of columns M. That optimum depends on the used polynomial commitment scheme. The costlier the computation of a commitment, the higher the algebraic degree for the domain identity of the helper function can be.</p>

    <p class="text-gray-300">In Section 3.1 we describe our batch-column lookup, Protocol 2, and we sketch its soundness analysis in Section 3.2. In the following Section 3.3 we give detailed operations counts for its oracle prover, which we then use to estimate the optimal choice of  <span class="math">\\ell</span>  assuming a commitment scheme which uses an ordinary</p>

    <p class="text-gray-300">sized elliptic curve<a href="#page-9-2">4</a> . Eventually, we point out the generalization of the lookup argument to vector-valued tables.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8"><strong>3.1 The protocol</strong></h3>

    <p class="text-gray-300">Let *<code>* be the chosen sum size, [0*, M*] = S*&lt;sup&gt;K&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt;*=1 *I&lt;sup&gt;k&lt;/sup&gt;* the decomposition of [0*, M*] into *K* = l *M*+1 *</code>* m subintervals <em>I<sup>k</sup></em> = [(<em>k</em> &minus; 1) &middot; *<code>, k* &middot; *</code><em>) &cap; [0</em>, M<em>], *k</em> = 1<em>, . . . , K</em>. Let</p>

    <p class="text-gray-300">
<span class="math">$h_k(\\vec{x}) = \\sum_{i \\in I_k} \\frac{m_i(\\vec{x})}{\\varphi_i(\\vec{x})}, \\quad k = 1, \\dots, K,</span>$
(16)</p>

    <p class="text-gray-300">be the respective partial sum of consecutive terms in the overall expression <em><sup>m</sup></em>(<em>x</em>) <em><sup>x</sup></em>+<em>t</em>(<em>~x</em>) &minus; 1 <em><sup>x</sup></em>+<em>f</em>1(<em>~x</em>) &minus;<em>. . .</em>&minus; 1 <em>x</em>+<em>fM</em>(<em>~x</em>) , where we used the notation</p>

    <p class="text-gray-300"><span class="math">$m_0(\\vec{x}) = m(\\vec{x}), \\quad \\varphi_0(\\vec{x}) = x + t(\\vec{x}),</span>$</p>

    <p class="text-gray-300"><span class="math">m_i(\\vec{x}) = -1, \\quad \\varphi_i(\\vec{x}) = x + f_i(\\vec{x}), \\quad i = 1, \\dots, M.</span></p>

    <p class="text-gray-300">The prover provides the oracles for <em>h</em>1<em>, . . . , hk</em>, subject to</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x}\\in H} h_1(\\vec{x}) + \\ldots + h_K(\\vec{x}) = 0,</span>$</p>

    <p class="text-gray-300">and the domain identities</p>

    <p class="text-gray-300">
<span class="math">$h_k(\\vec{x}) \\cdot \\prod_{i \\in I_k} \\varphi_i(\\vec{x}) = \\sum_{i \\in I_k} m_i(\\vec{x}) \\cdot \\prod_{j \\in I_k \\setminus \\{i\\}} \\varphi_j(\\vec{x})</span>$
(17)</p>

    <p class="text-gray-300">over <em>H</em>, the latter are reduced to sumchecks by applying the Lagrange kernel <em>LH</em>( <em>. , ~z</em>) at a randomly chosen <em>~z</em> &larr;$ <em>F n</em> . All sumchecks are then combined into a single one, using random scalars <em>&lambda;</em>1<em>, . . . , &lambda;<sup>K</sup></em> &larr;$ <em>F</em>.</p>

    <p class="text-gray-300"><strong>Protocol 2</strong> (Batch-column lookup over <em>H</em> = {&plusmn;1} <em>n</em> )<strong>.</strong> <em>Let M be an integer, and F a finite field with characteristic p &gt; M</em> &middot; 2 *n . Fix any integer <code>,* 1 &le; *</code>* &le; <em>M</em> + 1<em>, and let K</em> = l <em>M</em>+1 <em>\`</em> m <em>. Given any functions f</em>1<em>, . . . , fM, t</em> : <em>H</em> &rarr; <em>F on the boolean hypercube H</em> = {&plusmn;1} <em>n , the Lagrange IOP for that</em> S<em><sup>M</sup> <sup>i</sup></em>=1{<em>fi</em>(<em>~x</em>) : <em>~x</em> &isin; <em>H</em>} &sube; {<em>t</em>(<em>~x</em>) : <em>~x</em> &isin; <em>H</em>} <em>as sets is as follows.</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>1. The prover determines the (normalized) multiplicity function m</em> : <em>H</em> &rarr; <em>F as defined in</em> <a href="#page-8-2">(14)</a><em>, and sends the oracle for m to the verifier. The verifier answers with a random sample x</em> &larr;$ <em>F</em> {&minus;<em>t</em>(<em>~x</em>) : <em>~x</em> &isin; <em>H</em>}<em>.</em></li>
      <li><em>2. Given the challenge x from the verifier, the prover computes the values over H for the partial sums h</em>1(<em>~x</em>)<em>, . . . , hK</em>(<em>~x</em>) <em>as defined above, and sends their oracles to the verifier.</em></li>
      <li><em>3. The verifier responds with a random vector ~z</em> &larr;$ <em>F <sup>n</sup> and random batching scalars &lambda;</em>1<em>, . . . , &lambda;<sup>K</sup></em> &larr;$ <em>F. Now, both prover and verifier engage in the sumcheck protocol (Protocol <a href="#page-6-2">1)</a> for</em></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x}\\in H} Q(L_H(\\vec{x},\\vec{z}), m(\\vec{x}), \\varphi_0(\\vec{x}), \\dots, \\varphi_M(\\vec{x}), h_1(\\vec{x}), \\dots, h_K(\\vec{x})) = 0,</span>$</p>

    <p class="text-gray-300"><em>where</em></p>

    <p class="text-gray-300">
<span class="math">$Q(L, m, \\varphi_0, \\dots, \\varphi_M, h_1, \\dots, h_K) = \\sum_{k=1}^K h_k + L \\cdot \\lambda_k \\cdot \\left( h_k \\cdot \\prod_{i \\in I_k} \\varphi_i - \\sum_{i \\in I_k} m_i \\cdot \\prod_{j \\in I_k \\setminus \\{i\\}} \\varphi_j \\right), \\quad (18)</span>$</p>

    <p class="text-gray-300"><sup>4</sup>By ordinary sized we mean a 128 bit secure curve over a 256 bit large base field. This covers both KZG-like commitments in Barreto-Naehrig curves, and IPA commitments in an ordinary elliptic curve.</p>

    <p class="text-gray-300">with  <span class="math">m_0 = m</span> , and all other  <span class="math">m_i = -1</span> , i = 1, ..., M. The sumcheck protocol outputs the expected value v for the multivariate polynomial</p>

    <p class="text-gray-300">
<span class="math">$Q(L_H(\\vec{X}, \\vec{z}), m(\\vec{X}), \\varphi_0(\\vec{X}), \\dots, \\varphi_M(\\vec{X}), h_1(\\vec{X}), \\dots, h_K(\\vec{X}))</span>$</p>

    <p class="text-gray-300"><span class="math">$(19)</span>$</p>

    <p class="text-gray-300">at  <span class="math">\\vec{X} = \\vec{r}</span>  sampled by the verifier in the course of the protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier queries  <span class="math">[m], [t], [f_1], \\ldots, [f_M], [h_1], \\ldots, [h_K]</span>  for their inner product with  <span class="math">L_H(\\cdot, \\vec{r})</span> , and uses the answers to check whether (19) equals the expected value v at  <span class="math">\\vec{X} = \\vec{r}</span> . (The value  <span class="math">L_H(\\vec{r}, \\vec{z})</span>  is computed by the verifier.)</li>
    </ol>

    <p class="text-gray-300">Remark 3. We imposed the condition  <span class="math">x \\notin \\{-t(\\vec{x})\\}_{\\vec{x} \\in H}</span>  merely for completeness. However in some applications it may be not be desirable, or even not possible, to sample x from outside the range of t. There are several ways to handle this. One can simply omit the constraint on x, letting the verifier sample  <span class="math">x \\leftarrow_{\\</span>} F$  and the prover set  <span class="math">h_0</span>  arbitrary whenever (16) is not defined. This comes at no extra cost, but the obtained protocol is only overwhelmingly complete. That is, with a probability of at most  <span class="math">\\frac{|H|}{|F|}</span>  in the verifier randomness x, the honest prover does not succeed. In practice this is often considered acceptable, and many lookup implementations have a non-zero completeness error. Whenever this is not acceptable, one may modify the domain identity for  <span class="math">h_0</span>  to</p>

    <p class="text-gray-300"><span class="math">$\\left(h_0 \\cdot \\prod_{i \\in I_0} \\varphi_i - \\sum_{i \\in I_0} m_k \\cdot \\prod_{j \\neq i} \\varphi_j\\right) \\cdot \\varphi_0 = 0 \\tag{20}</span>$</p>

    <p class="text-gray-300">over H, which imposes no condition on  <span class="math">h_0</span>  whenever  <span class="math">\\varphi_0(\\vec{x}) = 0</span> . However, this approach comes at the cost of a slight increase in the degree of Q with respect to  <span class="math">\\varphi_0</span> .</p>

    <p class="text-gray-300">Let us point out two variations of Protocol 2. In the single-column case M=1 the lookup argument can be turned into a multiset check for the ranges of  <span class="math">f_1</span>  and t, by setting m as the constant function  <span class="math">m(\\vec{x})=1</span> . In this case only  <span class="math">h_0</span>  needs to be provided by the prover. More interestingly, Protocol 2 is easily extended to a proof of range equality, showing that  <span class="math">\\bigcup_{i=1}^{M} \\{f_i(\\vec{x})\\}_{\\vec{x}\\in H} = \\{t(\\vec{x})\\}_{\\vec{x}\\in H}</span>  as sets. For this the prover additionally shows that  <span class="math">m\\neq 0</span>  over H, which is done by providing another auxiliary function  <span class="math">g: H \\to F</span>  subject to  <span class="math">g \\cdot m = 1</span>  over H. However, we are not aware of any application of this fact.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Soundness</h3>

    <p class="text-gray-300">The soundness analysis of Protocol 2 is a straight-forward application of the Schwartz-Zippel lemma and the Lagrange-query to point-query correspondence stated by Lemma 1. We merely sketch it. The univariate rational lookup identity (13) is turned into a polynomial identity of degree at most  <span class="math">|H| \\cdot (M+1) - 1</span>  by multiplying it with the common denominator</p>

    <p class="text-gray-300"><span class="math">$\\prod_{\\vec{x} \\in H} (X + t(\\vec{x})) \\cdot \\prod_{i=1}^{M} (X + f_i(\\vec{x})). \\tag{21}</span>$</p>

    <p class="text-gray-300">Since we sample x from a set of size at least |F| - |H|, the soundness error this step is at most</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_1 \\le \\frac{(M+1) \\cdot |H| - 1}{|F| - |H|}.\\tag{22}</span>$</p>

    <p class="text-gray-300">The soundness error due to the reduction of the domain identities (17) to the Lagrange kernel based sumcheck is altogether</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_2 \\leq \\frac{K}{|F|},</span>$</p>

    <p class="text-gray-300">as scalar products with the Lagrange kernel translate to point evaluation of the multilinear extension. Finally, the batching step of the K+1 sumchecks has soundness error  <span class="math">\\varepsilon_3 = \\frac{1}{|F|}</span> . This yields the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> The interactive oracle proof described Protocol 2 has soundness error</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon &lt; \\frac{(M+1)\\cdot |H|-1}{|F|-|H|} + \\frac{K+1}{|F|} + \\varepsilon_{sumcheck},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\varepsilon_{sumcheck}</span>  is the soundness error of the sumcheck argument (9) over H for a multivariate polynomial in M+4 variables with maximum individual degree M+3.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Computational cost and optimal sum size</h3>

    <p class="text-gray-300">The polynomial Q from (18) has  <span class="math">\\nu = M + K + 3</span>  variables, and absolute degree  <span class="math">d = \\ell + 2</span> . Let us describe a domain evaluation strategy for Q which uses of batch inversion. This strategy allows us to evaluate Q much more efficiently than using (18), but demands a modification of the sumcheck operation count formula (12). Assume that in each group  <span class="math">I_k</span>  the inverses of  <span class="math">\\varphi_i</span>  are given, except for one distinct  <span class="math">i_k \\in I_k</span> . Then we may evaluate the domain identity terms in Q by the fractional representation</p>

    <p class="text-gray-300"><span class="math">$h_k \\cdot \\prod_{i \\in I_k} \\varphi_i - \\sum_{i \\in I_k} m_i \\cdot \\prod_{j \\in I_k \\setminus \\{i\\}} \\varphi_j = \\prod_{i \\in I_k \\setminus \\{i_k\\}} \\varphi_j \\cdot \\left( \\varphi_{i_k} \\cdot \\left( h_k - \\sum_{i \\in I_k \\setminus \\{i_k\\}} \\frac{m_i}{\\varphi_i} \\right) - m_{i_k} \\right)</span>$</p>

    <p class="text-gray-300">For  <span class="math">k \\geq 2</span> , all involved  <span class="math">m_i = -1</span> , and we have</p>

    <p class="text-gray-300">
<span class="math">$\\prod_{i \\in I_k \\setminus \\{i_k\\}} \\varphi_j \\cdot \\left( \\varphi_0 \\cdot \\left( h_k + \\sum_{i \\in I_k \\setminus \\{i_k\\}} \\frac{1}{\\varphi_i} \\right) + 1 \\right), \\tag{23}</span>$</p>

    <p class="text-gray-300">regardless of the choice of  <span class="math">i_k</span> . For the first group k=1, we chose  <span class="math">i_1=0</span> , so that</p>

    <p class="text-gray-300">
<span class="math">$\\prod_{i \\in I_1 \\setminus \\{0\\}} \\varphi_j \\cdot \\left( \\varphi_0 \\cdot \\left( h_k + \\sum_{i \\in I_1 \\setminus \\{0\\}} \\frac{1}{\\varphi_i} \\right) - m \\right). \\tag{24}</span>$</p>

    <p class="text-gray-300">In both cases (24) and (23) the evaluation costs are  <span class="math">\\ell \\cdot \\mathsf{M} + \\ell \\cdot \\mathsf{A}</span> , counting substractions as additions. Henceforth Q is evaluated in overall</p>

    <p class="text-gray-300"><span class="math">$K \\cdot (\\ell+2) \\cdot \\mathsf{M} + K \\cdot (\\ell+1) \\cdot \\mathsf{A}. \\tag{25}</span>$</p>

    <p class="text-gray-300">Now, to attribute the inverses in formula (12), we increase the multiplicative complexity by  <span class="math">3 \\cdot (M - K)</span> , which represents the fractional cost of the batch inversion<sup>5</sup> of all the  <span class="math">\\varphi_i</span>  except one in each of the groups. This yields the following equivalent complexities</p>

    <p class="text-gray-300"><span class="math">$|Q_{\\mathsf{M}}| = 3 \\cdot M + K \\cdot (\\ell-1), \\quad |Q_{\\mathsf{A}}| = K \\cdot (\\ell+1),</span>$</p>

    <p class="text-gray-300">which we may plug into formula (12).</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>Batch, or Montgomery inversion, of a sequence  <span class="math">(a_i)_{i=1}^N</span>  computes the inverses of  <span class="math">a_i^{-1}</span>  by recursively computing the cumulative products  <span class="math">p_i = a_1 \\cdot \\ldots \\cdot a_n</span> ,  <span class="math">i = 0, \\ldots, n</span> , then calculating their inverses  <span class="math">q_i = \\frac{1}{p_i}</span>  in a reverse manner starting with  <span class="math">q_n = \\frac{1}{p_n}</span> , and putting  <span class="math">q_{i-1} = q_i \\cdot a_i</span> , where i goes from n down to 1. The inverses are then derived via  <span class="math">a_i^{-1} = p_{i-1} \\cdot q_i</span> , where  <span class="math">p_0 := 1</span> . The overall cost of the batch inversion is  <span class="math">3 \\cdot (N-1)</span>  multiplications and a single inversion.</p>

    <p class="text-gray-300">Table 1: Benchmark of Halo2's Pippenger multi-scalar multiplication in the Pallas curve, varying the number N of scalars. The benchmarks where done on a AMD Ryzen 7 PRO 4750U, 32GB RAM DDR4, restricting to a single core.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log N</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Pippenger of size <span class="math">N</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">2^8 \\cdot N</span> field mult.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">equivalent field mult.</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">46.010 \\; \\text{ms}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.11 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 557 \\cdot M</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">153.67  ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">84.78 \\mathrm{\\ ms}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 464 \\cdot M</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">522.13  ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">169.70 \\; \\mathrm{ms}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 394 \\cdot M</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1.869~\\mathrm{ms}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">679.27~\\mathrm{ms}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 351 \\cdot M</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">The prover cost of Protocol 2 is as follows: Given the values of t and  <span class="math">f_1, \\ldots, f_M</span>  over H, computing  <span class="math">\\varphi_0 = x + t</span>  and  <span class="math">\\varphi_1 = x + f_1, \\ldots, \\varphi_M = x + f_M</span>  costs  <span class="math">|H| \\cdot (M+1) \\cdot \\mathsf{A}</span> , and their reciprocals  <span class="math">\\frac{1}{\\varphi_0}, \\ldots, \\frac{1}{\\varphi_M}</span>  are obtained within  <span class="math">3 \\cdot |H| \\cdot (M+1) \\cdot \\mathsf{M}</span> , using batch inversion. With these reciprocals we obtain the values for  <span class="math">h_1, \\ldots, h_K</span>  within overall  <span class="math">|H| \\cdot (\\mathsf{M} + K \\cdot (\\ell - 1) \\cdot \\mathsf{A})</span> . By the remark following Lemma 1, the values for  <span class="math">L_H(\\vec{X}, \\vec{y})</span>  over H are computed in  <span class="math">|H| \\cdot (\\mathsf{M} + \\mathsf{A})</span>  operations. Hence the total cost of the preparation phase is</p>

    <p class="text-gray-300"><span class="math">$|H| \\cdot ((3 \\cdot M + 5) \\cdot \\mathsf{M} + (M + K \\cdot (\\ell - 1) + 2) \\cdot \\mathsf{A}.</span>$</p>

    <p class="text-gray-300">According to (12) the sumcheck costs</p>

    <p class="text-gray-300"><span class="math">$|H| \\cdot (\\ell+3) \\cdot ((4 \\cdot M + 3 + \\ell \\cdot K) \\cdot M + (M+3 + (\\ell+2) \\cdot K) \\cdot A).</span>$</p>

    <p class="text-gray-300">However, as we may reuse the reciprocals of  <span class="math">\\varphi_0, \\ldots, \\varphi_M</span>  in the first step of the sumcheck, we may correct the sumcheck cost by substracting  <span class="math">|H| \\cdot 3 \\cdot (M - K)</span> . The total costs of the oracle prover are</p>

    <p class="text-gray-300">&bull; arithmetic costs of</p>

    <p class="text-gray-300"><span class="math">$|H| \\cdot (K+5+(\\ell+3)\\cdot (4\\cdot M+3+\\ell\\cdot K)) \\cdot M,</span>$
(26)</p>

    <p class="text-gray-300">neglecting field additions and substractions, and</p>

    <p class="text-gray-300">oracle costs of</p>

    <p class="text-gray-300"><span class="math">$K+1 = \\left\\lceil \\frac{M+1}{\\ell} \\right\\rceil + 1 \\tag{27}</span>$</p>

    <p class="text-gray-300">oracles of size |H|.</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">The optimal choice of <span class="math">\\ell</span></h4>

    <p class="text-gray-300">Let us discuss the concrete impact of the partial sum size  <span class="math">\\ell</span>  on the overall prover cost. If  <span class="math">\\ell=1</span> , then each reciprocal is given a helper function, resulting in M+1 additional commitments (besided the one for m) but a very low degree of Q, d=3. Increasing  <span class="math">\\ell</span>  reduces the number of commitments, but comes at the cost of a growing degree. The most extreme case is  <span class="math">\\ell=M+1</span> , where the prover provides a single additional commitment besides m, but needs to cope with a degree of d=M+3, resulting in sumcheck costs which are quadratic in M. The optimal choice for  <span class="math">\\ell</span>  is between these two cases, but depends on the concrete polynomial commitment scheme. We consider elliptic curve based commitments. To take the commitment costs into account we rely on the benchmarks from Table 1 which measure the equivalent number of field multiplications for a multi-scalar multiplication in an ordinary-sized elliptic curve of 128 bit security.</p>

    <p class="text-gray-300">Table 2: An estimate of the partial sum size  <span class="math">\\ell</span>  in Protocol 2, which minimizes the prover cost. The numbers are based on the operation counts (33) for the oracle prover and the benchmarks for a multiscalar multiplication in the Pallas curve, Table 1.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log N</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\ell</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">field mult. per col.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log IV</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 70</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">M = \\infty</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 70</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">M = \\infty</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 188</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 158</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 135</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 120</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 170</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 144</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 120</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 112</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 155</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 132</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 112</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 104</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 147</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 126</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 106</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot 99</span></td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Vector-valued lookups</h3>

    <p class="text-gray-300">As Plookup, Protocol 2 is easily generalized to functions with multilinear values,</p>

    <p class="text-gray-300"><span class="math">$t(\\vec{x}) = \\sum_{(j_1, \\dots, j_k) \\in \\{0, 1\\}^k} t_{j_1, \\dots, j_k}(\\vec{x}) \\cdot Y_1^{i_1} \\cdots Y_k^{j_k},</span>$
<span class="math">$f_i(\\vec{x}) = \\sum_{(j_1, \\dots, j_k) \\in \\{0, 1\\}^k} f_{i, j_1, \\dots, j_k}(\\vec{x}) \\cdot Y_1^{i_1} \\cdots Y_k^{j_k},</span>$</p>

    <p class="text-gray-300"><span class="math">i=1,\\ldots,M</span> , without changing the soundness error bound from Theorem 4. As  <span class="math">F[X,Y_1,\\ldots,Y_k]</span>  is a unique factorization domain, and polynomials of the form  <span class="math">X-\\sum_{(i_1,\\ldots,i_k)\\in\\{0,1\\}^k}c_{i_1,\\ldots,i_k}\\cdot Y_1^{i_1}\\cdots Y_k^{i_k}</span>  are irreducible, we may apply Lemma 5 to see that  <span class="math">\\bigcup_{i=1}^M\\{f_i(\\vec{x})\\}_{\\vec{x}\\in H}\\subseteq\\{t(\\vec{x})\\}_{\\vec{x}\\in H}</span>  as sets in the rational function field  <span class="math">F(X,Y_1,\\ldots,Y_k)</span> , if and only if there exists a function  <span class="math">m:H\\to F</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in H} \\sum_{i=1}^{M} \\frac{1}{X + f_i(\\vec{x})(\\vec{Y})} = \\sum_{\\vec{x} \\in H} \\frac{m(\\vec{x})}{X + t(\\vec{x})(\\vec{Y})}.</span>$</p>

    <p class="text-gray-300">The only change to Protocol 2 is that the verifier now samples x from F and  <span class="math">\\vec{y} = (y_1, \\dots, y_k)</span>  from  <span class="math">F^k</span> , and continues with  <span class="math">x - f_i(\\vec{x})</span>  and  <span class="math">x - t(\\vec{x})</span>  replaced by  <span class="math">x - f_i(\\vec{x})(\\vec{y})</span>  and  <span class="math">x - t(\\vec{x})(\\vec{y})</span> .</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Multivariate Plookup</h2>

    <p class="text-gray-300">In this section we sketch batch-column lookups using the Plookup strategy and the multivariate time shift introduced by Hyperplonk [CBBZ22]. The time shift  <span class="math">T: H \\to H</span>  on the boolean hypercube  <span class="math">H = \\{\\pm 1\\}^n</span>  is derived from the multiplication by a primitive root in  <span class="math">GF(2^n)</span> ,</p>

    <p class="text-gray-300"><span class="math">$T(x_1,\\ldots,x_n) = \\frac{1+x_n}{2} \\cdot (1,x_1,\\ldots,x_{n-1}) + \\frac{1-x_n}{2} \\cdot (-1,(-1)^{1-c_1} \\cdot x_1,\\ldots,(-1)^{1-c_{n-1}} \\cdot x_{n-1}),</span>$</p>

    <p class="text-gray-300">where the  <span class="math">c_i \\in \\{0, 1\\}</span>  are the coefficients of a primitive polynomial  <span class="math">1 + \\sum_{i=1}^{n-1} c_i \\cdot X^i + X^n</span>  over GF(2). The time shift acts transitively 6 on the punctuated hypercube</p>

    <p class="text-gray-300"><span class="math">$H&#x27; = H \\setminus \\{\\vec{1}\\},\\</span>$</p>

    <p class="text-gray-300">and more importantly, evaluations of a shifted function  <span class="math">f(T(\\vec{x}))</span>  can be simulated from two evaluations of f by</p>

    <p class="text-gray-300"><span class="math">$f(T(x_1,\\ldots,x_n)) = \\frac{1+x_n}{2} \\cdot f(1,x_1,\\ldots,x_{n-1}) + \\frac{1-x_n}{2} \\cdot f(-1,(-1)^{1-c_1} \\cdot x_1,\\ldots,(-1)^{1-c_{n-1}} \\cdot x_{n-1}).</span>$</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Batch-column Plookup</h3>

    <p class="text-gray-300">Let  <span class="math">t: H&#x27; \\to F</span>  be the lookup table, and  <span class="math">f_i: H&#x27; \\to F</span> ,  <span class="math">i=1,\\ldots,M</span> , the functions subject to the lookup. Although the functions are defined over the punctuated hypercube H', we assume arbitrary values at  <span class="math">\\vec{1}</span> . (These will be ignored by the lookup argument.) The prover provides the ordered union of the  <span class="math">f_i</span>  together with t in a piecewise manner, via the additional functions  <span class="math">s_i: H&#x27; \\to F</span> ,  <span class="math">i=1,\\ldots,M+1</span> . The <em>Plookup identity</em> (in the [Gab22] style) is then</p>

    <p class="text-gray-300"><span class="math">$\\prod_{\\vec{x} \\in H&#x27;} \\prod_{i=1}^{M} (X + s_i(\\vec{x}) + s_{i+1}(\\vec{x}) \\cdot Y) \\cdot (X + s_{M+1}(\\vec{x}) + s_1(T(\\vec{x})) \\cdot Y)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\prod_{\\vec{x} \\in H&#x27;} \\prod_{i=1}^{M} (X + f_i(\\vec{x}) + f_i(\\vec{x}) \\cdot Y) \\cdot (X + t(\\vec{x}) + t(T(\\vec{x})) \\cdot Y).</span>$</p>

    <p class="text-gray-300">The identity is reduced to a grand product over H' by random samples  <span class="math">\\alpha, \\beta \\leftarrow F</span>  for X and Y, yielding</p>

    <p class="text-gray-300">
<span class="math">$\\prod_{\\vec{x}\\in H&#x27;} h(\\vec{x}) = 1,\\tag{28}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">
<span class="math">$h(\\vec{x}) = \\frac{\\alpha + s_{M+1}(\\vec{x}) + s_1(T(\\vec{x})) \\cdot \\beta}{\\alpha + t(\\vec{x}) + t(T(\\vec{x})) \\cdot \\beta} \\cdot \\prod_{i=1}^{M} \\frac{(\\alpha + s_i(\\vec{x}) + s_{i+1}(\\vec{x}) \\cdot \\beta)}{(\\alpha + f_i(\\vec{x}) + f_i(\\vec{x}) \\cdot \\beta)}.</span>$
(29)</p>

    <p class="text-gray-300">As in Protocol 2, we control the algebraic degree of the resulting identity for (28) by splitting the product (29) into  <span class="math">K = \\left\\lceil \\frac{M+1}{\\ell} \\right\\rceil</span>  partial products of size  <span class="math">\\ell</span> , where  <span class="math">1 \\le \\ell \\le M+1</span> . For this we use the notation</p>

    <p class="text-gray-300"><span class="math">$\\varphi_0(\\vec{x}) = \\alpha + t(\\vec{x}) + \\beta \\cdot t(T(\\vec{x})),</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sigma_0(\\vec{x}) = \\alpha + s_{M+1}(\\vec{x}) + \\beta \\cdot s_1(T(\\vec{x})),</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>As a group automorphism it has  <span class="math">\\vec{1} = (1, 1, ..., 1)</span>  as a fixed point.</p>

    <p class="text-gray-300">and for  <span class="math">i = 1, \\ldots, M</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\varphi_i(\\vec{x}) = \\alpha + (1+\\beta) \\cdot f_i(\\vec{x}),</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sigma_i(\\vec{x}) = \\alpha + s_i(\\vec{x}) + \\beta \\cdot s_{i+1}(\\vec{x}).</span>$</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$h(\\vec{x}) = \\prod_{k=1}^{K} h_k(\\vec{x}),</span>$</p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span class="math">$h_k(\\vec{x}) = \\prod_{i \\in I_k} \\frac{\\sigma_i(\\vec{x})}{\\varphi_i(\\vec{x})},</span>$</p>

    <p class="text-gray-300">where  <span class="math">I_k = [(k-1) \\cdot \\ell, k \\cdot \\ell) \\cap [0, M]</span> . For each k = 1, ..., K, the prover computes the cumulative products of the values  <span class="math">h_k(\\vec{x})</span>  along the orbit of the time shift T on H', starting with  <span class="math">\\phi_k(-\\vec{1}) = 1</span> , and setting</p>

    <p class="text-gray-300"><span class="math">$\\phi_k(T^j(-\\vec{1})) = \\phi_k(T^{j-1}(-\\vec{1})) \\cdot h(T^{j-1}(-\\vec{1})),</span>$</p>

    <p class="text-gray-300">for j = 1, ..., |H'| - 1. At the remaining point  <span class="math">\\vec{x} = \\vec{1}</span>  outside H', the prover sets  <span class="math">\\phi_k</span>  to zero. Correctness of the grand product (28) is proven by the domain identities</p>

    <p class="text-gray-300"><span class="math">$\\phi_k(T(\\vec{x})) \\cdot \\prod_{i \\in I_k} \\varphi_i(\\vec{x}) - \\phi_k(\\vec{x}) \\cdot \\prod_{i \\in I_k} \\sigma_i(\\vec{x}) = 0,</span>$</p>

    <p class="text-gray-300">and the point identities</p>

    <p class="text-gray-300"><span class="math">$\\phi_1(-1) = 1,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_k(T^{-1}(-\\vec{1})) = \\phi_{(k \\bmod K)+1}(-\\vec{1}),</span>$</p>

    <p class="text-gray-300">where k = 1, ..., K. These identities are reduced to sumchecks over H by help of the Lagrange polynomials  <span class="math">L_H(.,-\\vec{1})</span>  and  <span class="math">L_H(.,\\vec{y})</span> , where  <span class="math">\\vec{y} \\leftarrow F^n</span> , and then combined into a single one by random batching scalars  <span class="math">\\lambda_1, ..., \\lambda_K \\leftarrow F</span> . The resulting overall sumcheck is</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{x} \\in H} Q(L_H(\\vec{x}, \\vec{y}), L_H(\\vec{x}, -\\vec{1}), \\varphi_0(\\vec{x}), \\dots, \\varphi_M(\\vec{x}), \\sigma_0(\\vec{x}), \\dots, \\sigma_M(\\vec{x}), \\phi_1(\\vec{x}), \\dots, \\phi_K(\\vec{x}), \\phi_1(T(\\vec{x})), \\dots, \\phi_K(T(\\vec{x})))</span>$</p>

    <p class="text-gray-300"><span class="math">$= 0,</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$Q(L_H, L, L_T, \\varphi_0, \\dots, \\varphi_M, \\sigma_0, \\dots, \\sigma_M, \\phi_1, \\dots, \\phi_K, \\phi_{1,T}, \\dots, \\phi_{K,T}) = L \\cdot (\\phi - 1) + \\sum_{k=1}^K \\lambda_k \\cdot L_H \\cdot \\left(\\phi_{k,T} \\cdot \\prod_{i \\in I_k} \\varphi_i - \\phi_k \\cdot \\prod_{i \\in I_k} \\sigma_i\\right) + \\mu_k \\cdot \\left(L_T \\cdot \\phi_k - L \\cdot \\phi_{(k \\bmod K) + 1}\\right).</span>$</p>

    <p class="text-gray-300"><span class="math">$(30)</span>$</p>

    <p class="text-gray-300">The sumcheck polynomial Q has absolute degree  <span class="math">d=\\ell+2</span> , which is the same as in Protocol 2, but about the double of variables,  <span class="math">\\nu=2\\cdot(M+1+K)+3</span> . Its arithmetic complexities are  <span class="math">|Q_{\\mathsf{M}}|=K\\cdot(2\\cdot\\ell+3)+2</span> ,  <span class="math">|Q_{\\mathsf{A}}|=4\\cdot K-1</span> .</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8"><strong>4.2 Computational cost and optimal product size</strong></h3>

    <p class="text-gray-300">The prover cost for the Plookup strategy is as follows. Computing the values for all <em>&#981;<sup>i</sup> , &sigma;<sup>i</sup></em> over <em>H</em> consumes overall</p>

    <p class="text-gray-300"><span class="math">$|H| \\cdot (2 \\cdot (M+1) \\cdot \\mathsf{M} + (3 \\cdot M + 4) \\cdot \\mathsf{A}),</span>$</p>

    <p class="text-gray-300">the quotients <em>hk</em>(<em>~x</em>) are obtained within |<em>H</em>| &middot; <em>K</em> &middot; (2 &middot; (<em>\`</em> &minus; 1) + 4) &middot; M, using batch inversion. From these values of the <em>&phi;k</em>(<em>x</em>) over <em>H</em> are derived by another <em>K</em> &middot; |<em>H</em>| &middot; M. The domain evaluation for <em>LH</em>(<em>X, ~y ~</em> ) is obtained within |<em>H</em>| &middot; (M + A) operations, resulting in the overall preparation cost</p>

    <p class="text-gray-300">
<span class="math">$|H| \\cdot ((2 \\cdot (M+1) + K \\cdot (2 \\cdot \\ell + 3) + 1) \\cdot M + (3 \\cdot M + 5) \\cdot A).</span>$
(31)</p>

    <p class="text-gray-300">According to <a href="#page-8-3">(12)</a> the sumcheck costs</p>

    <p class="text-gray-300">
<span class="math">$|H| \\cdot (\\ell+3) \\cdot ((2 \\cdot M + 7 + (2 \\cdot \\ell + 5) \\cdot K) \\cdot M + (2 \\cdot \\ell + 6) \\cdot (M+2+3 \\cdot K) \\cdot A).</span>$
(32)</p>

    <p class="text-gray-300">The total costs of the oracle prover are</p>

    <p class="text-gray-300">&bull; arithmetic costs of</p>

    <p class="text-gray-300">
<span class="math">$|H| \\cdot \\left( \\left( 2 \\cdot \\ell^2 + 13 \\cdot \\ell + 18 \\right) \\left\\lceil \\frac{M+1}{\\ell} \\right\\rceil + \\ell \\cdot (2 \\cdot M + 7) + 8 \\cdot (M+3) \\right) \\cdot \\mathsf{M},\\tag{33}</span>$</p>

    <p class="text-gray-300">neglecting field additions and substractions, and</p>

    <p class="text-gray-300">&bull; oracle costs of</p>

    <p class="text-gray-300"><span class="math">$M + K + 1 = M + \\left\\lceil \\frac{M+1}{\\ell} \\right\\rceil + 1</span>$
(34)</p>

    <p class="text-gray-300">functions of size |<em>H</em>|.</p>

    <h3 id="sec-misc-4" class="text-xl font-semibold mt-8"><strong>The optimal choice of</strong> <em>\`</em></h3>

    <p class="text-gray-300">As for Protocol <a href="#page-9-1">2,</a> the partial product size *<code>* determines the trade-off between algebraic degree and the number of commitments. Based on the multi-scalar multiplication benchmarks from Table [1,](#page-12-0) and the operation counts [\\(31\\)](#page-16-2) and [\\(32\\)](#page-16-3) we obtain the following estimates for the optimal choice of *</code>*, see Table <a href="#page-16-4">3.</a></p>

    <p class="text-gray-300">Table 3: An estimate of the partial sum size <em>\`</em> which minimizes the prover cost. The numbers are based on the operation counts <a href="#page-16-2">(31)</a> and <a href="#page-16-3">(32)</a> for the oracle prover and the benchmarks for a multi-scalar multiplication in the Pallas curve, Table <a href="#page-12-0">1.</a></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">log<br>N</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">\`</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">field mult. per col.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M<br>= 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M<br>= 20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M<br>= 70</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&infin;<br>M<br>=</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M<br>= 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M<br>= 20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M<br>= 70</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&infin;<br>M<br>=</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&middot;<br>N<br>750</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&middot;<br>N<br>717</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&middot;<br>N<br>687</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&middot;<br>N<br>675</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>637</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>609</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>584</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>572</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>553</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>528</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>506</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>496</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>503</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>479</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>458</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>&middot;<br>450</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8"><strong>4.3 Bounded multiplicity encoding</strong></h3>

    <p class="text-gray-300">The Polygon MidenVM <a href="#page-20-15">[Mid]</a> uses an improvement of Plookup, which reduces the number of commitments for the sorted union of <em>f</em>1<em>, . . . , f<sup>M</sup></em> and <em>t</em> by arranging it as runs of at most <em>B</em> = 2<em><sup>b</sup></em> occurences, where <em>b</em> &ge; 1. The length <em>m</em> of each run (reduced by one, as explained below) is then given bitwise,</p>

    <p class="text-gray-300"><span class="math">$m-1 = m_0 + m_1 \\cdot 2 + \\ldots + m_{b-1} \\cdot 2^{b-1},</span>$</p>

    <p class="text-gray-300">and the power of the corresponding term <em>Z</em> in the lookup product is selected by the expression</p>

    <p class="text-gray-300">
<span class="math">$V(Z, m_0, \\dots, m_{b-1}) = \\prod_{j=0}^{b-1} (m_j \\cdot Z^{2^j} + (1 - m_j) \\cdot 1) = Z^{m_0 + m_1 \\cdot 2 + \\dots + m_{b-1} \\cdot 2^{b-1}}.</span>$
(35)</p>

    <p class="text-gray-300">From this point of view it can be seen as an application of the Arya <a href="#page-19-3">[BCG</a>+18] multiplicity technique to Plookup. Although <a href="#page-20-15">[Mid]</a> restricts to range proofs (optimized for the cases of small ranges, the size of which is a fraction of the domain), we quickly outline its generalization to lookups of domain-sized tables.</p>

    <p class="text-gray-300">Let <em>N</em> be the size of the punctuated hypercube <em>H</em><sup>0</sup> . Instead of committing to the full-length union (<em>si</em>) (<em>M</em>+1)&middot;<em>N <sup>i</sup></em>=1 , the prover provides the compressed sequence</p>

    <p class="text-gray-300"><span class="math">$(r_j, (m_{j,0}, \\dots, m_{j,b-1}))_{j=1}^n</span>$</p>

    <p class="text-gray-300">of values <em>r<sup>j</sup></em> and their <em>B</em>-bounded run lengths <em>m<sup>j</sup></em> (minus one), represented bitwise by <em>mj,</em>0<em>, . . . , mj,b</em>&minus;<sup>1</sup> &isin; {0<em>,</em> 1}. Depending on the distribution of the values, the size <em>n</em> of the compressed sequence is bounded by</p>

    <p class="text-gray-300"><span class="math">$\\frac{M+1}{B} \\cdot N \\le n \\le \\left(\\frac{M}{B} + 1\\right) \\cdot N.</span>$</p>

    <p class="text-gray-300">(The left bound corrsponds to uniform distribution, and the right bound to the singleton case.) The lookup product over <em>s</em>, written in terms of the compressed sequence is then</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i=1}^{(M+1)\\cdot N} (X + s_i + s_{(i \\bmod N)+1} \\cdot Y) = \\prod_{j=1}^n V(X + (1+Y) \\cdot r_j, \\underbrace{m_0, \\dots, m_{b-1}}_{\\text{encoding } m_j - 1}) \\cdot (X + r_j + Y \\cdot r_{(j \\bmod n)+1}).</span>$</p>

    <p class="text-gray-300">As before, the compressed sequence is provided piecewise, splitted into functions over <em>H</em><sup>0</sup> . This results in</p>

    <p class="text-gray-300"><span class="math">$R = \\left\\lceil \\frac{M}{B} + 1 \\right\\rceil</span>$</p>

    <p class="text-gray-300">&quot;blocks&quot; of functions, <em>rk</em>(<em>~x</em>) and (<em>mk,</em>0(<em>~x</em>)<em>, . . . , mk,b</em>&minus;1(<em>~x</em>)), <em>k</em> = 1<em>, . . . , R</em>, subject to the lookup identity</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\prod_{\\vec{x} \\in H&#x27;} V(X + r_K(\\vec{x}) \\cdot (1 + Y), m_{R,0}(\\vec{x}), \\dots, m_{R,b-1}(\\vec{x})) \\cdot (X + r_R(\\vec{x}) + r_1(T(\\vec{x})) \\cdot Y) \\\\ \\cdot \\prod_{k=1}^{R-1} V(X + r_k(\\vec{x}) \\cdot (1 + Y), m_{k,0}(\\vec{x}), \\dots, m_{k,b-1}(\\vec{x})) \\cdot (X + r_k(\\vec{x}) + r_{k+1}(\\vec{x}) \\cdot Y) \\\\ &amp;= \\prod_{\\vec{x} \\in H&#x27;} (X + t(\\vec{x}) + t(T(\\vec{x})) \\cdot Y) \\cdot \\prod_{i=1}^{M} (X + f_i(\\vec{x}) \\cdot (1 + Y)), \\end{split}</span>$</p>

    <p class="text-gray-300">with <em>V</em> as above, and the boolean domain identities <em>mk,i</em>(<em>~x</em>) &middot; (1 &minus; <em>mk,i</em>(<em>~x</em>))<sup>2</sup> = 0, over <em>H</em>, for all <em>k, i</em>. Note that the commitment costs for <em>s</em> are reduced by the factor</p>

    <p class="text-gray-300"><span class="math">$\\frac{R \\cdot (1 + \\log_2 B)}{M + 1} \\approx \\frac{1 + \\log_2 B}{B},</span>$</p>

    <p class="text-gray-300">whereas the absolute degree of the lookup identity is almost invariant for large B, increasing only by the factor</p>

    <p class="text-gray-300"><span class="math">$\\frac{R}{M+1} \\cdot (B + \\log_2 B) \\approx 1 + \\frac{\\log_2 B}{B}.</span>$</p>

    <p class="text-gray-300">As the protocol is along the lines of plookup, we omit further details.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Comparison</h2>

    <p class="text-gray-300">The significant advantage of the logarithmic derivative lookup over Plookup is the lower oracle costs. While the Plookup strategy demands M+1 oracles for the sorted union of the M witness column and the table, the logarithmic derivative approach demands only a single one for the multiplicities. We compare the two strategies by their computational cost per column, when running them with the optimal sum/product size  <span class="math">\\ell</span>  as given in Table 2 and 3.</p>

    <p class="text-gray-300">Table 4: The estimated performance advantage of logarithmic derivative lookups (Protocol 2) over the multivariate Plookup strategy (Section 4.1), as the ratio of their number of field multiplications per column. The numbers are based on the equivalent number of field multiplications for a multi-scalar multiplication over the Pallas curve, given in Table 1.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log  H </span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">ratio Plookup / log. derivative</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M=1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M=5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M = 70</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">M=\\infty</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Let us give a rough comparison with the bounded multiplicity improvement of Plookup described in Section 4.3. For that we simply count the number of oracles needed for obtaining a quadratic overall domain identity (and hence a cubic sumcheck polynomial Q). Under this assumption,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The logarithmic derivative approach needs overall M+1 oracles: one for the multiplicity function, and M helper functions.</li>
      <li>Plookup demands overall  <span class="math">2 \\cdot (M+1)</span>  oracles: M+1 for the sorted union of table and witnesses, and M+1 for the cumulative products.</li>
      <li>With multiplicity encoding using b bits, Plookup is improved down to</li>
    </ul>

    <p class="text-gray-300"><span class="math">$M+1+\\left\\lceil\\frac{M}{2^b}+1\\right\\rceil\\cdot 3\\cdot b</span>$</p>

    <p class="text-gray-300">oracles: Each of the  <span class="math">\\left\\lceil \\frac{M}{2^b} + 1 \\right\\rceil</span>  blocks of the compressed representation consists of b+1 domain-sized functions (the multiplicity bits and the value), and to linearize each factor in the power selection expression (35), one additionally needs b-1 functions for the two-adic powers, and another b functions for the products with the bits. The grand product argument uses M+1 cumulative product functions.</p>

    <p class="text-gray-300">In its most extreme setting,  <span class="math">2^b = M</span> , and therefore only R = 2 blocks, the number of oracles for the multiplicity improvement is  <span class="math">M + 1 + 6 \\cdot \\log_2(M)</span> . We use this configuration in our comparison, Table 5.</p>

    <p class="text-gray-300">Table 5: A rough comparison of the three lookup protocols in their quadratic constraint variant. The table presents the overall number of commitments for a batch of <em>M</em> = 2<em><sup>b</sup></em> columns. (bPlookup denotes Plookup using multiplicity encoding with <em>b</em> bits.)</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">M<br>= 4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">M<br>= 8</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">M<br>= 16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">M<br>= 32</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">M<br>= 64</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">M<br>= 128</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log. derivative</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">129</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Plookup</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">130</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">258</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">bPlookup (b<br>= log2<br>(M))</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">101</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Multiplicity encoding seems to be beneficial only for quite large batches of columns. Below <em>M</em> = 32 columns it is expected to perform even worse than Plookup. However, for <em>M</em> = 64 and <em>M</em> = 128 that picture clearly changes. For these batch sizes it consumes only 78% and 66% of Plookups' number of commitments, respectively, which is still about 55% and 30% more than with the logarithmic derivative approach.</p>

    <p class="text-gray-300">The author would like to thank Rayan Matovu and Morgan Thomas for giving me the space and time to dwell on batch-column lookups during my employment at Orbis Labs. Special thanks to Marcin Bugaj for helping out with the Pippenger benchmarks. Furthermore, I would like to thank Ariel Gabizon for his feedback and useful discussions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[BCC+16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In M. Fischlin and J.S. Coron, editors, <em>EUROCRYPT 2016</em>, volume 9666 of <em>LNCS</em>. Springer, 2016. Full paper: <a href="https://eprint.iacr.org/2016/263" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2016/263</a>.</p></li>
      <li><p class="text-gray-300">[BCG+18] Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune Jakobsen, and Mary Maller. Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In <em>ASIACRYPT 2018</em>, volume 11272 of <em>LNCS</em>, 2018. Full paper: <a href="https://eprint.iacr.org/2018/380" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2018/380</a>.</p></li>
      <li><p class="text-gray-300">[BFS20] Benedikt B&uml;unz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In <em>EUROCRYPT 2020</em>, 2020. Full paper: <a href="https://eprint.iacr.org/2019/1229" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/1229</a>.</p></li>
      <li><p class="text-gray-300">[BG12] Stephanie Bayer and Jens Groth. Efficient zero-knowledge argument for correctness of a shuffle. In <em>EUROCRYPT 2012</em>, volume 7237 of <em>LNCS</em>. Springer, 2012.</p></li>
      <li><p class="text-gray-300">[BSBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. In <em>IACR ePrint Archive 2018/046</em>, 2018. <a href="https://eprint.iacr.org/2018/046" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2018/046</a>.</p></li>
      <li><p class="text-gray-300">[BSCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In <em>TCC 2016</em>, pages 31&ndash;60, 2016.</p></li>
      <li><p class="text-gray-300">[CBBZ22] Binyi Chen, Benedikt B&uml;unz, Dan Boneh, and Zhenfei Zhang. Hyperplonk: PLONK with a linear-time prover and high-degree costum gates. In <em>IACR ePrint Archive 2020/1355</em>, 2022. <a href="https://eprint.iacr.org/2022/1355" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2022/1355</a>.</p></li>
      <li><p class="text-gray-300">[Eag22] Liam Eagen. Bulletproofs++. In <em>IACR ePrint Archive 2022/510</em>, 2022. <a href="https://eprint.iacr.org/2022/510" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2022/510" target="_blank" rel="noopener noreferrer">iacr.org/2022/510</a>.</p></li>
      <li><p class="text-gray-300">[EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon. cq: Cached quotients for fast lookups. In <em>IACR ePrint Archive 2022/1763</em>, 2022. <a href="https://eprint.iacr.org/2022/1763" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2022/1763</a>.</p></li>
      <li><p class="text-gray-300">[Gab22] Ariel Gabizon. Multiset checks in PLONK and Plookup. hackmd.io, 2022. <a href="https://hackmd.io/@arielg/ByFgSDA7D" target="_blank" rel="noopener noreferrer">https://hackmd.</a> <a href="https://hackmd.io/@arielg/ByFgSDA7D" target="_blank" rel="noopener noreferrer">io/@arielg/ByFgSDA7D</a>.</p></li>
      <li><p class="text-gray-300">[GK22] Ariel Gabizon and Dmitry Khovratovich. flookup: Fractional decomposition-based lookups in quasi-linear time independent of the table size. In <em>IACR ePrint Archive 2022/1447</em>, 2022. <a href="https://eprint.iacr.org/2022/1447" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2022/1447</a>.</p></li>
      <li><p class="text-gray-300">[GW20] Ariel Gabizon and Zachary J. Williamson. Plookup: A simplified polynomial protocol for lookup tables. In <em>IACR ePrint Archive 2020/315</em>, 2020. <a href="https://eprint.iacr.org/2020/315" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2020/</a> <a href="https://eprint.iacr.org/2020/315" target="_blank" rel="noopener noreferrer">315</a>.</p></li>
      <li><p class="text-gray-300">[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical non-interactive arguments of knowledge. In <em>IACR ePrint Archive 2019/953</em>, 2019. <a href="https://eprint.iacr.org/2019/953" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/953</a>.</p></li>
      <li><p class="text-gray-300">[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commimtments to polynomials and their applications. In Abe M., editor, <em>ASIACRYPT 2010</em>, volume 6477 of <em>LNCS</em>. Springer, 2010.</p></li>
      <li><p class="text-gray-300">[Lab] Avi Dessauer (Orbis Labs). tiny-ram-halo2. <a href="https://github.com/Orbis-Tertius/tiny-ram-halo2" target="_blank" rel="noopener noreferrer">https://github.com/Orbis-Tertius/</a> <a href="https://github.com/Orbis-Tertius/tiny-ram-halo2" target="_blank" rel="noopener noreferrer">tiny-ram-halo2</a>.</p></li>
      <li><p class="text-gray-300">[LFKN92] Carsten Lund, Lance Fortnow, Howard Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. In <em>Journal of the Association for Computing Machinery</em>, volume 39, pages 859&ndash;868, 1992. Full paper: <a href="https://eprint.iacr.org/2017/1066" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2017/1066</a>.</p></li>
      <li><p class="text-gray-300">[Mid] Polygon Miden: A STARK-based virtual machine. <a href="https://github.com/maticnetwork/miden" target="_blank" rel="noopener noreferrer">https://github.com/maticnetwork/</a> <a href="https://github.com/maticnetwork/miden" target="_blank" rel="noopener noreferrer">miden</a>.</p></li>
      <li><p class="text-gray-300">[PK22] Jim Posen and Assimakis A. Kattis. Caulk+: Table-independent lookup arguments. In <em>IACR ePrint Archive 2022/957</em>, 2022. <a href="https://eprint.iacr.org/2022/957" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2022/957</a>.</p></li>
      <li><p class="text-gray-300">[Pol] Polygon Zero Team: plonky2. <a href="https://github.com/mir-protocol/plonky2" target="_blank" rel="noopener noreferrer">https://github.com/mir-protocol/plonky2</a>.</p></li>
      <li><p class="text-gray-300">[PST13] Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. Signatures of correct computation. In <em>TCC 3</em>, volume 7785 of <em>LNCS</em>. Springer, 2013.</p></li>
      <li><p class="text-gray-300">[RDJH22] Gyumin Roh, Wei Dai, Maria Jabbour, and Andrew He. New lookup argument. zkResearch, 2022. <a href="https://zkresear.ch/t/new-lookup-argument/32" target="_blank" rel="noopener noreferrer">https://zkresear.ch/t/new-lookup-argument/32</a>.</p></li>
      <li><p class="text-gray-300">[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In <em>CRYPTO 2013</em>, volume 8043 of <em>LNCS</em>, 2013. Full paper: <a href="https://eprint.iacr.org/2013/351" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2013/351</a>.</p></li>
      <li><p class="text-gray-300">[ZBK+22] Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. Caulk: Lookup arguments in sublinear time. In <em>IACR ePrint Archive 2022/621</em>, 2022. <a href="https://eprint.iacr.org/2022/621" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2022/621</a>.</p></li>
    </ul>

    <p class="text-gray-300">Section 5 of <a href="#page-20-6">[GK22]</a> describes a polynomial IOP for lookups, which is almost identical to the logarithmic derivative approach. We present its generalization to batch-lookups. Let <em>F</em> be an FFT-friendly finite field, having a multiplicative subgroup <em>H</em> = {<em>x</em> &isin; <em>F</em> : <em>x <sup>n</sup></em> = 1} of order <em>n</em>, and denote by <em>g</em> a generator of it. For showing that the ranges of witness function <em>f<sup>i</sup></em> : <em>H</em> &rarr; <em>F</em>, <em>i</em> = 0<em>, . . . , M</em> &minus; 1, are contained in the range of a table <em>t</em> : <em>H</em> &rarr; <em>F</em>, the fractional logaritmic derivative identity is turned into the polynomial identity</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in H} \\sum_{i=0}^{M-1} \\frac{v_T(X)}{X + f_i(x)} = \\sum_{x \\in H} m(x) \\cdot \\frac{v_T(X)}{X + t(x)},</span>$</p>

    <p class="text-gray-300">by multiplying with the precomputed table polynomial <em>v<sup>T</sup></em> (<em>X</em>) = Q <em><sup>x</sup></em>&isin;<em>H</em>(<em>X</em> + <em>t</em>(<em>x</em>)). Instead of the multiplicity function <em>m</em>, the prover explicitly provides the polynomial<a href="#page-21-1">7</a></p>

    <p class="text-gray-300"><span class="math">$R_T(X) = \\sum_{x \\in H} m(x) \\cdot \\frac{v_T(X)}{X - t(x)},</span>$</p>

    <p class="text-gray-300">and engages with the verifier in an IOP for showing that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in H} \\sum_{i=0}^{M-1} \\frac{v_T(X)}{X + f_i(x)} = R_T(X). \\tag{36}</span>$</p>

    <p class="text-gray-300">The verifier queries <em>v<sup>T</sup></em> (<em>X</em>) and <em>R<sup>T</sup></em> (<em>X</em>) at a random challenge <em>&alpha;</em> &larr;$ <em>F</em>, and both prover and verifier run a sumcheck argument for</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in H} \\sum_{i=0}^{M-1} \\frac{1}{\\varphi_i(x)} = \\frac{R_T(\\alpha)}{v_T(\\alpha)},</span>$</p>

    <p class="text-gray-300">where <em>&#981;i</em>(<em>x</em>) = <em>&alpha;</em> + <em>fi</em>(<em>x</em>). For this the prover provides the Lagrange representation of the sumcheck polynomial <em>&phi;</em>(<em>X</em>) subject to the domain identity</p>

    <p class="text-gray-300"><span class="math">$\\phi(g \\cdot x) - \\phi(x) + \\frac{R_T(\\alpha)}{|H| \\cdot v_T(\\alpha)} = \\sum_{i=0}^{M-1} \\frac{1}{\\varphi_i(x)}</span>$</p>

    <p class="text-gray-300">for all <em>x</em> &isin; <em>H</em>, or</p>

    <p class="text-gray-300"><span class="math">$\\left(\\phi(g \\cdot X) - \\phi(X) + \\frac{R_T(\\alpha)}{|H| \\cdot v_T(\\alpha)}\\right) \\cdot \\prod_{i=0}^{M-1} \\varphi_i(X) = \\prod_{i=0}^{M-1} \\varphi_i(X) \\cdot \\sum_{i=0}^{M-1} \\frac{1}{\\varphi_i(X)} \\mod v_H(X). \\tag{37}</span>$</p>

    <p class="text-gray-300">The overall identity is of the form</p>

    <p class="text-gray-300"><span class="math">$Q(\\phi_0(X), \\dots, \\phi_{M-1}(X), \\phi(X), \\phi(g \\cdot X)) = 0 \\mod v_H(X),</span>$</p>

    <p class="text-gray-300">with <em>Q</em> having <em>&nu;</em> = <em>M</em> + 2 variables and absolute degree <em>d</em> = <em>M</em> + 1.</p>

    <p class="text-gray-300"><sup>7</sup> In a variant of the protocol, communicated by A. Gabizon, the prover provides the Lagrange representation of <em>R<sup>T</sup></em> (<em>X</em>) with respect to the Lagrange basis of the table set {<em>t</em>(<em>x</em>) : <em>x</em> &isin; <em>H</em>}. As Lagrange IOPs with respect to several Lagrange bases have different impacts on the Lagrange commitment scheme (e.g., it leads to a separate commitment in a KZG-like scheme, or a separate inner product argument for an IPA-like scheme), we do not compare with this variant.</p>

    </section>
`;
---

<BaseLayout title="Multivariate lookups based on logarithmic derivatives (2022/1530)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1530
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">The Lagrange kernel of the boolean hypercube</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">The formal derivate</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">The logarithmic derivative</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Lagrange interactive oracle proofs</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">The sumcheck protocol</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Lookups based on the logarithmic derivative</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">The protocol</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Soundness</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Computational cost and optimal sum size</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Vector-valued lookups</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Multivariate Plookup</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Batch-column Plookup</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Computational cost and optimal product size</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Bounded multiplicity encoding</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Comparison</a></li>
        <li><a href="#sec-6" class="hover:text-white">Acknowledgements</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">The flookup proof of radical</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="multivariate-lookups-based-on-logarithmic-derivatives-2022" />
  </article>
</BaseLayout>
