---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/160';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Scalable Public-Key Tracing and Revoking';
const AUTHORS_HTML = 'Yevgeniy Dodis, Nelly Fazio, Aggelos Kiayias, Moti Yung';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Traitor Tracing Schemes constitute a very useful tool against
piracy in the context of digital content broadcast. In such
multi-recipient encryption schemes, each decryption key is
fingerprinted and when a pirate decoder is discovered, the
authorities can trace the identities of the users that
contributed in its construction (called traitors).

Public-key traitor tracing schemes allow for a multitude of
non-trusted content providers using the same set of keys, which
makes the scheme \`\`server-side scalable.&#x27;&#x27;
To make such schemes also \`\`client-side scalable,&#x27;&#x27; i.e. long lived and usable for a large population of subscribers that changes dynamically over time, it is crucial to implement efficient Add-user and Remove-user operations.
Previous work on public-key traitor tracing did not address this
dynamic scenario thoroughly, and there is no efficient scalable public
key traitor tracing scheme that allows an increasing number of Add-user and Remove-user operations.

To address these issues, we introduce the model of Scalable
Public-Key Traitor Tracing, and present the first construction of such
a scheme. Our model mandates for deterministic traitor tracing and an
unlimited number of efficient Add-user operations and Remove-user operations.
A scalable system achieves an unlimited number of revocations
while retaining high level of efficiency by dividing the run-time of
the system into periods. Each period has a saturation level for the
number of revocations. When a period becomes saturated, an _efficient_ New-period operation is issued by the system server that resets the saturation level.
We present a  formal adversarial model for our system taking into
account its periodic structure, and we prove our construction secure, both against adversaries that attempt to cheat the revocation mechanism as well as against adversaries that attempt to cheat the traitor tracing mechanism.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Digital Content Distribution &middot; Traitor Tracing &middot; Scalability &middot; Broadcast Encryption &middot; Multicast</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">An important application of global networking is digital content distribution. For such an application (e.g ., Pay-TV) to remain economically viable for the long run, it is important to design distribution schemes with certain basic properties: (1) security&mdash;this assures a subscription-based model of exclusive content reception; (2) scalability&mdash;which assures efficient operation supporting many content providers and a dynamically changing population of subscribers; and (3) piracy protection&mdash;to prevent or deter illegal distribution.</p>

    <p class="text-gray-300">To achieve security, a content distribution scheme requires the implementation of a multi-user encryption mechanism that assures that only current subscribers can receive the content.</p>

    <p class="text-gray-300">Regarding piracy protection, the state of the art method which applies to software-based platformindependent architectures, is the notion of traitor tracing schemes which we concentrate on in this work. A traitor tracing scheme is a multi-recipient encryption system that can be used for digital content distribution, with the property that the decryption key of each user is marked (fingerprinted). The server of the system is capable of using a traitor tracing algorithm: a procedure that given access to a pirate decoder is capable of recovering identities of subscribers that participated in its construction (called traitors). A traitor tracing scheme is, therefore, a deterrence to piracy due to the fear of exposure.</p>

    <p class="text-gray-300">Scalable Systems. In the context of content distribution, scalability has two facets: server-side and clientside.</p>

    <p class="text-gray-300">Server-side scalability is assured by employing a public-key scheme, which allows any third party to use the encryption mechanism and broadcast digital content to the set of subscribers. This is very appealing as it allows a multitude of digital-content providers (e.g. many different channels) to take advantage of the availability of secure broadcast to distribute their content without the need to maintain relationships with clients. The clients are, in fact, managed by the system server that is only responsible for maintaining and assigning the clients' decryption keys as well as publishing the encryption key. Namely, the server acts as a pure key (and account) management service.</p>

    <p class="text-gray-300">Regarding client-side scalability, observe that digital content distribution systems typically involve a large population of users (accounts), that is changing dynamically during the life-time of the system. New users should be introduced, and others need to be removed from the active user population entitled to receive the digital content. To allow for a scalable management of accounts, keys should be easy to generate and revoke.</p>

    <p class="text-gray-300">To date, no schemes have been proposed that provide both client-side and server-side scalability in the context of traitor tracing schemes. This motivates us to define and realize a Scalable Public-Key Traitor Tracing Schemes which achieves this combination.</p>

    <p class="text-gray-300">Previous Results. Traitor Tracing Schemes were introduced by Chor et al. [6], who employed a probabilistic design: each user possesses a different subset of a set of keys and tracing is achieved using the properties of the key assignment. The results of Chor et al. were later implemented with concrete combinatorial designs by [20]. These schemes do not possess a Remove-user operation. Later these results were extended by [11, 17], who also considered the combination of traitor tracing schemes with efficient revocation methods (cf. broadcast encryption, [10]). These schemes are not scalable, since (i) they do not support public-key technology in an efficient fashion, (ii) they employ combinatorial designs for the key-assignment that require a tight guess of an a-priori bound on the number of users,<sup>4</sup> and (iii) the ciphertext size is an increasing function of the total number of revoked users in the system's life-time.</p>

    <p class="text-gray-300">A &quot;native&quot; public-key traitor tracing scheme was introduced in [15, 3] (the latter introduced a publickey scheme with deterministic traceability); both schemes did not consider revocation of keys. This was considered in the work of [19], which described several schemes in the symmetric-key setting and a publickey scheme. In particular, one of the scheme proposed in [19] (Revocation Method 2), provides security guarantees comparable to those obtained by our scheme, but it applies to the symmetric-key setting, thus making it impossible for several content providers to serve the same user population without trusting each other, effectively forgoing server-side scalability (enjoyed by our scheme).</p>

    <p class="text-gray-300">On the other hand, the public-key method proposed in [19] provides server-side scalability, but can only withstand a bounded number of revocations: if the number of revocations executed in the life-time of the system exceeds the bound, previously revoked users could gain unlawful access to the system. Furthermore, the ciphertext size is linear in the revocation bound, something that prohibits (for efficiency purposes) to set the bound to a large value.</p>

    <p class="text-gray-300">Public-key traitor tracing schemes with comparable revocation capabilities as the scheme in [19] (bounded number of revocations) were also designed in [21] and [8, 9]. In all these schemes the bound on the number of revocations is proportional to the ciphertext size of the system. We remark that the scheme of [8] allows for an unlimited number of revocations, however this results in a degradation of the scheme's efficiency in the course of its run-time operation (as ciphertext sizes also depend logarithmically on the size of the user population). We note that client-side scalability was recognized as an important issue and was considered in the context of long lived broadcast encryption in [12]; it can also be achieved in the context of multicast refresh-key [22, 5, 19]. These schemes however, do not operate in a server-scalable environment. In conclusion,</p>

    <p class="text-gray-300"><sup>4</sup> Note that adding users beyond the bound would still be possible but it would be an expensive operation affecting the existing subscribers of the system.</p>

    <p class="text-gray-300">to the best of our knowledge, none of the existing schemes satisfies the requirements of a Scalable Public-Key Traitor Tracing Scheme.</p>

    <p class="text-gray-300">Our Results. We introduce the first carefully formalized model of a scalable public-key traitor tracing scheme where an unlimited number of users can be added and removed efficiently from the system and we present a concrete scheme meeting these requirements, based on the DDH assumption. Addition of users does not affect the keys of the existing users of the system. Furthermore, the design does not require an a-priori bound on the number of users. User removal is achieved by dividing the run-time of the system into periods; in each period a bounded number of user removals can be executed; unlimited number of user-removals is achieved in our design by the implementation of an efficient New-period operation.</p>

    <p class="text-gray-300">Our scheme allows efficient deterministic traitor tracing that recovers all traitors (in the non-black-box traceability setting), while supporting the black-box confirmation method [3], (for black-box traitor tracing model).</p>

    <p class="text-gray-300">In a scalable scheme, adversaries can run the Add-user protocol to introduce adversarially-controlled users in the system, and they can observe the modifications to the public key of the scheme that occur during the run-time operation of the scheme and potentially take advantage of them. We consider two types of adversaries, the ones that attempt to defeat the revocation mechanism of the system and the ones that try to elude the traceability capability. Since the adversarial goal is distinct in these two cases, we consider the following classification of adversaries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Window Adversary: the adversary obtains some user-keys that are subsequently revoked; the adversary remains active and observes the revocation of other users of the system (in fact we allow the adversary to adaptively select which users should be revoked). We show that our construction is secure against window adversaries as long as they are fully revoked in a &quot;window&quot; of the system's operation that has a certain length (which is specified as a system parameter).</li>
      <li>Traceability Adversary: the adversary obtains some user-keys and constructs a pirate decryption device, employing the secret user-key information (in fact we allow the adversary to adaptively select the identities of the traitors). We show that our construction is secure against this type of adversaries in the non-black-box traitor tracing model. Our traitor tracing algorithm is deterministic and recovers the identities of all traitors. Furthermore, our scheme supports the black-box confirmation method, that allows a form of traceability in the black-box traitor tracing model, [3].</li>
    </ul>

    <p class="text-gray-300">In Table 1, we compare our construction to previously proposed public-key schemes. The advantage of our scalable public-key traitor tracing scheme over previous results comes from the fact that any adversary fully revoked in a window of the system's operation will, in fact, &quot;expire.&quot; An expired adversary will be incapable of intercepting the scrambled content (in the semantic security sense) even if it remains active in the system (and can still observe and even cause other users to get revoked). It is the capability of our scheme to expire adversaries that allows for the enhanced functionality of an unlimited number of revocations. None of the previous public-key traitor tracing schemes with revocation capability [19, 21, 8, 9] possessed this crucial property. Although the work of [19] described a private-key scheme providing a similar kind of functionality, achieving this in the server-scalable, public-key setting, and properly formalizing the adversarial model constitutes a technical challenge and the undertaking of this work.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Our Model: Scalable Public-Key Tracing and Revoking</h2>

    <p class="text-gray-300">The life-time of a scalable public-key traitor tracing scheme is divided into periods. A period is an administrative unit managed based on activity and potentially time passing.</p>

    <p class="text-gray-300">A scalable scheme is comprised of the following basic procedures:</p>

    <p class="text-gray-300">&ndash; Setup. An initialization procedure that is executed by the server, which generates a master secret key MSK along with a public key PK; the server keeps MSK secret and publishes PK.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ciphertext Size Maximum</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Traceable</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Add-User</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remove-User</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Adversaries</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Coalition Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Expire</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CFN94 [6] (as PK)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(( v<br>3<br>)<br>log n)<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v/2 (probabilistic-BB) Bounded</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KD98 [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">UnboundedN/A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BF99 [3]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v/2 (any Non-BB) +</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bounded</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N/A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BB Confirmation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP00<br>[19]<br>(PK</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v/2 (Non-BB + spe</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">UnboundedUp to v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">revoca</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NO</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Scheme)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cialized adversaries)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">tions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TT01 [21]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BB Confirmation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">UnboundedUp to v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">revoca</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NO</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">tions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DF02 [8]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(v log n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Unbounded</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bounded</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Unbounded</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NO</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DF03 [9]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BB Confirmation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">UnboundedUp to v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">revoca</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NO</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">tions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">v/2 (any Non-BB) +</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">UnboundedUp</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">to<br>v<br>per</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">YES</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BB Confirmation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">period,<br>un</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">bounded overall</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1. Comparison of the main construction of this paper to previous public-key traitor tracing schemes. The parameters used in the table are n=# of users, v=# of revocations. Note that &quot;BB&quot; stands for Black-Box, BB-Confirmation stands for the Black-Box Confirmation method of [3] that requires exponential-time, and &quot;unbounded&quot; means that any polynomial number of users (in the security parameter) can be supported.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Broadcast Encryption. A public encryption algorithm E that takes as input the public key PK, and a plaintext M, and outputs a ciphertext C. The ciphertext C is distributed to a population of users through an insecure broadcast channel.</li>
      <li>Decryption. A deterministic algorithm D that takes as input the ciphertext C, and a user's secret key and decrypts C.</li>
      <li>Add-user. It is a key-generation procedure that results in a personalized secret key SK that can be used to invert the public key PK. It is executed by the server and secretly communicated to a new user of the system.</li>
      <li>Remove-user. A procedure that given a public key PK and a user's secret key SK, results in a public key PK<sup>0</sup> , so that for all messages M, E(PK<sup>0</sup> , M) should be &quot;incomprehensible&quot; for the user holding the revoked secret key SK, while non-removed users should be capable of decrypting it. The revocation procedure has a saturation limit that is an upper bound to the number of users that can be removed inside a period.</li>
      <li>Tracing. A procedure that given the contents of a pirate decoder outputs the identities of the traitor users whose keys are employed in the pirate decoder.</li>
      <li>New-period. A procedure executed by the server to initiate a fresh period, by means of transmitting (on the broadcast channel) a special message transmitted to the active subscribers of the system. Users removed in previous periods should be incapable of decrypting data subsequently transmitted within the new period. A New-period operation occurs when the saturation limit is reached (a reactive change), or when a certain time-limit is reached (a pro-active change).</li>
    </ul>

    <p class="text-gray-300">Scalability Objectives. The properties of the various functions of a scalable scheme should satisfy the following requirements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Efficient addition of unlimited number of users throughout the scheme's operation. Specifically, the Adduser operation should be a protocol executed between a new user and the server, that should have (i) communication independent of the size of the user population, and (ii) it should not involve the existing users of the system in any way.</p></li>
      <li><p class="text-gray-300">Efficient traitor tracing of a pirate decoder. Specifically, the tracing procedure should be polynomial-time in the number of users and the number of traitors.</p></li>
      <li><p class="text-gray-300">Efficient revocation of the decryption capabilities of a set of users inside a period, provided that the number of users to be removed is below the saturation limit. Specifically, Remove-user should have time complexity independent of the number of users, and should be executed solely by the server, affecting only the public key of the system.</p></li>
      <li><p class="text-gray-300">Efficient introduction of a new period. The communication overhead for changing a period should be independent of the number of users of the system and it should not require private communication channels between the server and the active users (but contrary to Remove-user it will require from users to modify their secret keys&mdash;as a result in our model users are stateless within a period and stateful across periods).</p></li>
    </ul>

    <p class="text-gray-300">FORMAL MODELING OF SCALABLE SCHEMES. The functionality of a scalable public-key traitor tracing scheme should be two fold: on one hand, it should be capable of identifying users that participate in the construction of pirate decoders; on the other hand, the system should be capable of revoking the decryption capabilities of &quot;bad&quot; users. We formally model the security of tracing and revocation in Section 5 and Section 6, respectively.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300">Throughout the paper, k will denote a security parameter; let q be a k-bit prime number and let  <span class="math">\\mathcal{G}</span>  be a large cyclic group of order q. We assume that  <span class="math">\\mathcal{G}</span>  is the (multiplicative) subgroup of order q of  <span class="math">\\mathbb{Z}_p^*</span> , where  <span class="math">q \\mid (p-1)</span>  and p is a large prime. Alternatively, one can take as group  <span class="math">\\mathcal{G}</span>  the (additive) group of points of an elliptic curve over a finite field.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Consider the two distributions over  <span class="math">\\mathcal{G}^4</span> :</p>

    <p class="text-gray-300"><span class="math">$R \\doteq \\{ \\langle g, g&#x27;, u, u&#x27; \\rangle \\mid g, g&#x27;, u, u&#x27; \\in \\mathcal{G} \\}</span>$</p>

    <p class="text-gray-300"><span class="math">$D \\doteq \\{ \\langle g, g&#x27;, u, u&#x27; \\rangle \\mid g, g&#x27;, u, u&#x27; \\in \\mathcal{G}, \\log_q u = \\log_{q&#x27;} u&#x27; \\}.</span>$</p>

    <p class="text-gray-300">For all 0/1-valued probabilistic polynomial-time algorithm  <span class="math">\\mathcal{A}</span>  and for all  <span class="math">k \\in \\mathbb{Z}_{\\geq 0}</span> , define the DDH advantage of  <span class="math">\\mathcal{A}</span>  against  <span class="math">\\mathcal{G}</span>  at k as:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{AdvDDH}_{\\mathcal{G},\\mathcal{A}}(k) &amp;\\doteq \\Big| \\Pr[\\tau = 1 \\mid \\rho \\xleftarrow{r} R; \\tau \\xleftarrow{r} \\mathcal{A}(1^k,\\rho)] - \\\\ \\Pr[\\tau = 1 \\mid \\rho \\xleftarrow{r} D; \\tau \\xleftarrow{r} \\mathcal{A}(1^k,\\rho)] \\Big|. \\end{split}</span>$</p>

    <p class="text-gray-300">where the probability is over the random coins of A and the random choice of  <span class="math">\\rho</span>  from R and D, respectively.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> Let  <span class="math">\\mathsf{AdvDDH}_{\\mathcal{G}}(k) \\doteq max_{\\mathcal{A}} \\mathsf{AdvDDH}_{\\mathcal{G},\\mathcal{A}}(k)</span> , where the max is over all probabilistic, polynomial-time 0/1-valued algorithms  <span class="math">\\mathcal{A}</span> .</p>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Assumption 1 (Decisional Diffie-Hellman Assumption)</h3>

    <p class="text-gray-300">The Decisional Diffie-Hellman (DDH) assumption for  <span class="math">\\mathcal{G}</span>  asserts that the function  <span class="math">AdvDDH_{\\mathcal{G}}(k)</span>  is negligible in k.</p>

    <p class="text-gray-300">In the following, we will also need a (weaker) assumption about the hardness of computing discrete logarithms in  <span class="math">\\mathcal{G}</span> .</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> For all probabilistic polynomial-time algorithm  <span class="math">\\mathcal{A}</span>  and for all  <span class="math">k \\in \\mathbb{Z}_{\\geq 0}</span> , define the DLog advantage of  <span class="math">\\mathcal{A}</span>  against  <span class="math">\\mathcal{G}</span>  at k as:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AdvDLog}_{\\mathcal{G},\\mathcal{A}}(k) \\doteq \\Pr[w&#x27; = w \\mid g, g&#x27; \\overset{r}{\\leftarrow} \\mathcal{G}; w \\leftarrow \\log_g g&#x27;; \\\\ w&#x27; \\leftarrow \\mathcal{A}(1^k, g, g&#x27;)].</span>$</p>

    <p class="text-gray-300">where the probability is over the random coins of A and the random choice of g, g' from G.</p>

    <p class="text-gray-300"><strong>Definition 4.</strong> Let  <span class="math">\\mathsf{AdvDLog}_{\\mathcal{G}}(k) \\doteq max_{\\mathcal{A}} \\mathsf{AdvDLog}_{\\mathcal{G},\\mathcal{A}}(k)</span> , where the max is over all probabilistic, polynomial-time algorithms  <span class="math">\\mathcal{A}</span> .</p>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8">Assumption 2 (Discrete Logarithm Assumption)</h3>

    <p class="text-gray-300">The Discrete Logarithm (DLog) assumption for  <span class="math">\\mathcal{G}</span>  asserts that the function  <span class="math">AdvDLog_{\\mathcal{G}}(k)</span>  is negligible in k.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Discrete-Log Representations</h3>

    <p class="text-gray-300">Let g be a generator of  <span class="math">\\mathcal{G}</span>  and let  <span class="math">h_0, h_1, \\ldots, h_v</span>  be elements of  <span class="math">\\mathcal{G}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$h_j = g^{r_j}</span>$</p>

    <p class="text-gray-300">with j = 0, ..., v and  <span class="math">r_0, ..., r_v \\in \\mathbb{Z}_q</span> . For a certain element  <span class="math">y \\doteq g^b</span>  of  <span class="math">\\mathcal{G}</span> , a representation of y with respect to the base  <span class="math">h_0, ..., h_v</span>  is a (v+1)-vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\delta} \\doteq \\langle \\delta_0, \\dots, \\delta_v \\rangle</span>$</p>

    <p class="text-gray-300">such that:</p>

    <p class="text-gray-300"><span class="math">$y = h_0^{\\delta_0} \\cdot \\ldots \\cdot h_v^{\\delta_v}</span>$</p>

    <p class="text-gray-300">or equivalently  <span class="math">\\boldsymbol{\\delta} \\cdot \\boldsymbol{r} = b</span>  where &quot;.&quot; denotes the inner product of two vectors modulo q.</p>

    <p class="text-gray-300">It is well known (e.g., see [4]) that obtaining representations of a given y w.r.t. some base  <span class="math">h_0, \\ldots, h_v</span>  is as hard as the discrete-log problem over  <span class="math">\\mathcal{G}</span> . Furthermore, it was shown in Lemma 3.2 of [3] that if some adversary is given m &lt; v random representations of some y with respect to some base, then any additional representation that can be obtained has to be a &quot;convex combination&quot; of the given representations (a convex combination of the vectors  <span class="math">\\boldsymbol{\\delta_1}, \\ldots, \\boldsymbol{\\delta_m}</span>  is a vector  <span class="math">\\sum_{\\ell=1}^m \\mu_\\ell \\boldsymbol{\\delta_\\ell}</span>  with  <span class="math">\\sum_{\\ell=1}^m \\mu_\\ell = 1</span> ). However, our scheme makes use of a particular family of discrete-log representations, introduced below. In Section 6 we will see how Lemma 3.2 of [3] can be modified accordingly.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Leap-Vectors</h3>

    <p class="text-gray-300">We introduce a new family of discrete-log representations, called <em>leap-vectors</em>. In what follows, we denote with  <span class="math">\\mathbb{Z}_q^v[x]</span>  the set of v-degree polynomials over  <span class="math">\\mathbb{Z}_q</span> ; and with  <span class="math">\\mathbb{Z}_q^{&lt; v}[x]</span>  the ring of polynomials over  <span class="math">\\mathbb{Z}_q</span>  with degree less than v.</p>

    <p class="text-gray-300"><strong>Definition 5.</strong> Given  <span class="math">z_1, \\ldots, z_v \\in \\mathbb{Z}_q</span>  and  <span class="math">P(x) \\in \\mathbb{Z}_q^v[x]</span> , the set  <span class="math">\\mathcal{L}_{z_1, \\ldots, z_v}^P</span>  of leap-vectors w.r.t.  <span class="math">P(\\cdot)</span>  and the values  <span class="math">z_1, \\ldots, z_v</span> , consists of all vectors  <span class="math">\\boldsymbol{\\alpha} \\in \\mathbb{Z}_q^{v+1}</span>  for which it holds that:</p>

    <p class="text-gray-300"><span class="math">$P(0) = \\alpha \\cdot \\langle 1, P(z_1), \\dots, P(z_v) \\rangle. \\tag{1}</span>$</p>

    <p class="text-gray-300">In other words, a leap-vector w.r.t.  <span class="math">P(\\cdot)</span>  and  <span class="math">z_1, \\ldots, z_v</span> , is a representation of  <span class="math">g^{P(0)}</span>  with respect to the base</p>

    <p class="text-gray-300"><span class="math">$q, q^{P(z_1)}, \\ldots, q^{P(z_v)}.</span>$</p>

    <p class="text-gray-300">Given any leap-vector  <span class="math">\\boldsymbol{\\alpha} := \\langle \\alpha_0, \\dots, \\alpha_v \\rangle</span>  w.r.t. some values  <span class="math">z_1, \\dots, z_v</span> , it is possible to derive the equation</p>

    <p class="text-gray-300"><span class="math">$\\alpha_0 = \\left(1 - \\sum_{\\ell=1}^v \\alpha_\\ell\\right) a_0 + \\sum_{j=1}^v \\left(\\sum_{\\ell=1}^v z_\\ell^j \\alpha_\\ell\\right) a_j</span>$</p>

    <p class="text-gray-300">over the coefficients of the polynomial</p>

    <p class="text-gray-300"><span class="math">$P(x) := a_0 + a_1 x + \\ldots + a_v x^v.</span>$</p>

    <p class="text-gray-300">If one possesses a point  <span class="math">\\langle x_i, P(x_i) \\rangle</span>  of the polynomial  <span class="math">P(\\cdot)</span> , it is possible to generate a leap-vector for the values  <span class="math">z_1, \\ldots, z_v</span>  (provided that  <span class="math">x_i \\notin \\{z_1, \\ldots, z_v\\}</span> ) using Lagrange interpolation.</p>

    <p class="text-gray-300"><strong>Definition 6.</strong> Given distinct  <span class="math">x_i, z_1, \\ldots, z_v \\in \\mathbb{Z}_q</span> , and  <span class="math">P(x) \\in \\mathbb{Z}_q^v[x]</span> , define the leap-vector  <span class="math">\\boldsymbol{\\nu}_{z_1, \\ldots, z_v}^{x_i, P}</span>  associated to the point  <span class="math">\\langle x_i, P(x_i) \\rangle</span>  w.r.t.  <span class="math">P(\\cdot)</span>  and  <span class="math">z_1, \\ldots, z_v</span>  as:</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\nu}_{z_1,\\dots,z_v}^{x_i,P} \\doteq \\langle \\lambda_0^{(i)} P(x_i), \\lambda_1^{(i)}, \\dots, \\lambda_v^{(i)} \\rangle \\tag{2}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\lambda_0^{(i)} \\doteq \\prod_{j=1}^{v} \\frac{x_i}{x_i - z_j} \\tag{3}</span>$</p>

    <p class="text-gray-300">and, for  <span class="math">\\ell = 1, \\ldots, v</span></p>

    <p class="text-gray-300"><span class="math">$\\lambda_{\\ell}^{(i)} \\doteq \\frac{z_{\\ell}}{z_{\\ell} - x_i} \\cdot \\prod_{\\substack{j=1\\\\j \\neq \\ell}}^{v} \\frac{z_{\\ell}}{z_{\\ell} - z_j}.</span>$
(4)</p>

    <p class="text-gray-300">An important property of leap-vectors is the following:</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> Given a polynomial  <span class="math">P(\\cdot) \\in \\mathbb{Z}_q^v[x]</span>  and the values  <span class="math">z_1, \\ldots, z_v \\in \\mathbb{Z}_q</span> , knowledge of a leap-vector  <span class="math">\\alpha \\in \\mathcal{L}_{z_1,\\ldots,z_v}^P</span>  implies knowledge of a linear equation on the coefficients of  <span class="math">P(\\cdot)</span>  linearly independent from the linear equations defined using  <span class="math">\\langle z_1, P(z_1) \\rangle, \\ldots, \\langle z_v, P(z_v) \\rangle</span> .</p>

    <p class="text-gray-300">Proof. Define</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\pi} \\doteq (P(z_1), P(z_2), \\dots, P(z_v), \\alpha_0)^T.</span>$</p>

    <p class="text-gray-300">The constraint on the coefficients  <span class="math">a_0, a_1, \\ldots, a_v</span>  of the polynomial  <span class="math">P(\\cdot)</span>  arising from points  <span class="math">\\langle z_1, P(z_1) \\rangle, \\ldots, \\langle z_v, P(z_v) \\rangle</span>  and the equation associated to the leap-vector  <span class="math">\\boldsymbol{\\alpha}</span> , can be represented as:</p>

    <p class="text-gray-300"><span class="math">$\\pi = \\mathbf{M} \\cdot \\mathbf{a}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{a} \\doteq (a_0, a_1, \\dots, a_v)^T</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{M} \\doteq \\begin{pmatrix} 1 &amp; z_1 &amp; \\dots &amp; z_1^v \\ 1 &amp; z_2 &amp; \\dots &amp; z_2^v \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\ 1 &amp; z_v &amp; \\dots &amp; z_v^v \\ 1 - \\sum_{j=1}^v \\alpha_j - \\sum_{j=1}^v \\alpha_j z_j \\dots - \\sum_{j=1}^v \\alpha_j z_j^v \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">Notice that matrix  <span class="math">\\mathbf{M}</span>  above is obtained from a Vandermonde matrix by adding a linear combination of the first v rows to the last one. Since every Vandermonde matrix has full rank, it follows that  <span class="math">\\mathbf{M}</span>  has full rank, too. Hence, the equation defined by the leap-vector  <span class="math">\\boldsymbol{\\alpha}</span>  is linearly independent to the equations defined by the points  <span class="math">\\langle z_1, P(z_1) \\rangle, \\ldots, \\langle z_v, P(z_v) \\rangle</span> .</p>

    <p class="text-gray-300">As a result, the possession of a leap-vector implies some knowledge about the polynomial  <span class="math">P(\\cdot)</span>  beyond what is implied by the points  <span class="math">\\langle z_1, P(z_1) \\rangle, \\ldots, \\langle z_v, P(z_v) \\rangle</span> . In other words, a leap-vector is the necessary information needed to leap from the values  <span class="math">P(z_1), \\ldots, P(z_v)</span>  to the value P(0).</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Our Scheme</h2>

    <p class="text-gray-300">Setup. The description of a cyclic multiplicative group  <span class="math">\\mathcal{G}</span>  of order q is generated. Then, two random generators  <span class="math">g, g&#x27; \\in \\mathcal{G}</span>  and two random polynomials  <span class="math">A(\\cdot), B(\\cdot) \\in \\mathbb{Z}_q^v[x]</span>  are selected. The parameter v will be also referred to as the saturation limit, whereas  <span class="math">m = \\lfloor \\frac{v}{2} \\rfloor</span>  will be the maximum traitor collusion size. Define</p>

    <p class="text-gray-300"><span class="math">$A(x) := a_0 + a_1 x + \\dots + a_v x^v</span>$</p>

    <p class="text-gray-300"><span class="math">B(x) := b_0 + b_1 x + \\dots + b_v x^v</span> .</p>

    <p class="text-gray-300">The master secret key is</p>

    <p class="text-gray-300"><span class="math">$MSK := (A(\\cdot), B(\\cdot))</span>$</p>

    <p class="text-gray-300">and the system's public key is</p>

    <p class="text-gray-300"><span class="math">$PK := \\langle g, g&#x27;, g^{A(0)} g&#x27;^{B(0)}, \\langle \\ell, g^{A(\\ell)} g&#x27;^{B(\\ell)} \\rangle_{\\ell=1}^{v} \\rangle</span>$</p>

    <p class="text-gray-300">where indices  <span class="math">1, \\ldots, v</span>  are used as place-holders. The server initiates a new period by publishing PK, and sets the <em>saturation level</em> L to 0. L is a system variable known to the server.</p>

    <p class="text-gray-300">Add-user. When a new user i requests to join the system, the server transmits (over a private channel) the tuple  <span class="math">\\langle x_i, A(x_i), B(x_i) \\rangle</span>  to user i, where</p>

    <p class="text-gray-300"><span class="math">$x_i \\stackrel{r}{\\leftarrow} \\mathbb{Z}_q \\quad x_i \\not\\in \\{1, \\dots, v\\} \\cup \\mathcal{U}.</span>$</p>

    <p class="text-gray-300">The set  <span class="math">\\mathcal{U}</span>  is the user-registry containing all values  <span class="math">x_i</span>  that were selected in previous executions of the Add-user protocol. Subsequently, the server records the value  <span class="math">x_i</span>  as associated to user i and adds  <span class="math">x_i</span>  to  <span class="math">\\mathcal{U}</span> .</p>

    <p class="text-gray-300">Encryption. The sender obtains the current public key of the system</p>

    <p class="text-gray-300"><span class="math">$PK := \\langle g, g&#x27;, y, \\langle z_1, h_1 \\rangle, \\dots, \\langle z_v, h_v \\rangle \\rangle</span>$</p>

    <p class="text-gray-300">(where  <span class="math">y = g^{A(0)}g&#x27;^{B(0)}</span>  and  <span class="math">h_{\\ell} = g^{A(z_{\\ell})}g&#x27;^{B(z_{\\ell})}</span> , for some identity  <span class="math">z_{\\ell}</span> ,  <span class="math">\\ell = 1, ..., v</span> ) and then employs the encryption function  <span class="math">\\mathcal{E}</span>  that, given the public key PK and a plaintext  <span class="math">M \\in \\mathcal{G}</span> , selects a random  <span class="math">r \\leftarrow \\mathbb{Z}_q</span>  and sets the corresponding ciphertext to be:</p>

    <p class="text-gray-300"><span class="math">$\\langle g^r, g&#x27;^r, y^r \\cdot M, \\langle z_1, h_1^r \\rangle, \\dots, \\langle z_v, h_v^r \\rangle \\rangle</span>$
.</p>

    <p class="text-gray-300">Decryption. The decryption algorithm  <span class="math">\\mathcal{D}</span>  takes as input a tuple of the form  <span class="math">\\langle x_i, A(x_i), B(x_i) \\rangle</span>  and a ciphertext</p>

    <p class="text-gray-300"><span class="math">$C = \\langle u, u&#x27;, u&#x27;&#x27;, \\langle z_1, u_1 \\rangle, \\dots, \\langle z_v, u_v \\rangle \\rangle.</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}</span>  first computes the leap-vectors</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\nu}_{A,i} \\doteq \\boldsymbol{\\nu}_{z_1,\\ldots,z_v}^{x_i,A} \\quad \\boldsymbol{\\nu}_{B,i} \\doteq \\boldsymbol{\\nu}_{z_1,\\ldots,z_v}^{x_i,B}</span>$</p>

    <p class="text-gray-300">associated to the points  <span class="math">\\langle x_i, A(x_i) \\rangle</span>  and  <span class="math">\\langle x_i, B(x_i) \\rangle</span>  with respect to the values  <span class="math">z_1, \\ldots, z_v</span> . Observe that, by Definition 6 (Equations (2) and (4)),  <span class="math">\\boldsymbol{\\nu}_{A,i}</span>  and  <span class="math">\\boldsymbol{\\nu}_{B,i}</span>  agree on all components except for the first: denoting with  <span class="math">(\\nu_{A,i})_{\\ell}</span>  (respectively  <span class="math">(\\nu_{B,i})_{\\ell}</span> ) the entry in  <span class="math">\\boldsymbol{\\nu}_{A,i}</span>  (respectively  <span class="math">\\boldsymbol{\\nu}_{B,i}</span> ) indexed by  <span class="math">\\ell</span> , it holds that  <span class="math">\\nu_{i,\\ell} \\doteq (\\nu_{A,i})_{\\ell} = (\\nu_{B,i})_{\\ell}</span> , for  <span class="math">\\ell = 1, \\ldots, v</span> .</p>

    <p class="text-gray-300">The decryption algorithm returns:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}(\\boldsymbol{C}) \\doteq \\frac{u&#x27;&#x27;}{u^{(\\nu_{A,i})_0} u&#x27;^{(\\nu_{B,i})_0} \\prod_{\\ell=1}^v u_\\ell^{\\nu_{i,\\ell}}}</span>$</p>

    <p class="text-gray-300">If C is a properly formed ciphertext, i.e.</p>

    <p class="text-gray-300"><span class="math">$C = \\langle g^r, g&#x27;^r, y^r \\cdot M, \\langle z_1, h_1^r \\rangle, \\dots, \\langle z_n, h_n^r \\rangle \\rangle</span>$</p>

    <p class="text-gray-300">then, due to the properties of the leap-vector representation (Equation (1)), we have:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}(C) = \\frac{g^{rA(0)}g&#x27;^{rB(0)}M}{g^{r(\\nu_{A,i})_0}g&#x27;^{r(\\nu_{B,i})_0}\\prod_{\\ell=1}^{v}g^{r\\nu_{i,\\ell}A(z_{\\ell})}g&#x27;^{r\\nu_{i,\\ell}B(z_{\\ell})}}</span>$
<span class="math">$= M</span>$</p>

    <p class="text-gray-300">Remove-user. Let  <span class="math">i_1, \\ldots, i_k</span>  be the identities of the users to be removed, so that  <span class="math">L+k \\leq v</span> . Suppose that the current public key is  <span class="math">PK = \\langle g, g&#x27;, y, \\langle z_1, h_1 \\rangle, \\ldots, \\langle z_v, h_v \\rangle \\rangle</span> . The revocation procedure uses the user-registry  <span class="math">\\mathcal{U}</span>  to retrieve the values  <span class="math">x_{i_1}, \\ldots, x_{i_k}</span>  and modifies the current public key PK as:</p>

    <p class="text-gray-300"><span class="math">$PK := \\langle g, g&#x27;, y, \\langle z_1, h_1 \\rangle, \\dots, \\langle z_L, h_L \\rangle,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\langle x_{i_1}, g^{A(x_{i_1})} g&#x27;^{B(x_{i_1})} \\rangle, \\dots, \\langle x_{i_k}, g^{A(x_{i_k})} g&#x27;^{B(x_{i_k})} \\rangle,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\langle z_{L+k+1}, h_{L+k+1} \\rangle, \\dots, \\langle z_v, h_v \\rangle \\rangle.</span>$</p>

    <p class="text-gray-300">Finally, the saturation level is increased to L := L + k.</p>

    <p class="text-gray-300">New-period. When a Remove-user operation is invoked such that the resulting saturation level L would &quot;overflow&quot; the saturation limit v, the server starts a new period. First, the server broadcasts a special message change period (signed, but not encrypted). Note that we assume that change-period is digitally signed by the server so that no third parties can maliciously initiate the New-period operation.</p>

    <p class="text-gray-300">Let  <span class="math">enc: \\mathbb{Z}_q \\to \\mathcal{G}</span>  be an easily invertible encoding that translates a number from  <span class="math">\\{0, \\ldots, q-1\\}</span>  into an element of  <span class="math">\\mathcal{G}</span> . If  <span class="math">\\mathcal{G}</span>  is the subgroup of  <span class="math">\\mathbb{Z}_p^*</span>  of oder  <span class="math">q = \\frac{p-1}{2}</span> , then enc can be implemented as follows:  <span class="math">enc(a) \\doteq (a+1)^2 \\mod p</span> . It is easy to see that  <span class="math">enc(a) \\in \\mathcal{G}</span>  for any  <span class="math">a \\in \\mathbb{Z}_q</span> : this is because  <span class="math">\\mathcal{G}</span>  is the subgroup of quadratic residues modulo p. The encoding function enc can be easily inverted as follows: given b := enc(a), compute the two square roots  <span class="math">\\rho_1, \\rho_2</span>  of a modulo p and define  <span class="math">enc^{-1}(b) = \\min\\{\\rho_1, \\rho_2\\} - 1</span>  where min treats  <span class="math">\\rho_1, \\rho_2</span>  as integers in  <span class="math">\\{0, \\ldots, p-1\\}</span> .</p>

    <p class="text-gray-300">The server selects  <span class="math">d_0, \\ldots, d_v, e_0, \\ldots, e_v \\stackrel{r}{\\leftarrow} \\mathbb{Z}_q</span>  and transmits the reset message</p>

    <p class="text-gray-300"><span class="math">$C_{\\mathsf{reset}} := \\langle \\mathcal{E}(PK, enc(d_0)), \\dots, \\mathcal{E}(PK, enc(d_v)), \\\\ \\mathcal{E}(PK, enc(e_0)), \\dots, \\mathcal{E}(PK, enc(e_v)) \\rangle</span>$</p>

    <p class="text-gray-300">where PK is the current public key of the system. Let  <span class="math">D(\\cdot)</span>  be the polynomial defined by  <span class="math">d_0, \\ldots, d_v</span>  and let  <span class="math">E(\\cdot)</span>  be the polynomial defined by  <span class="math">e_0, \\ldots, e_v</span> : namely,</p>

    <p class="text-gray-300"><span class="math">$D(x) = d_0 + d_1 x + \\dots + d_v x^v</span>$</p>

    <p class="text-gray-300"><span class="math">$E(x) = e_0 + e_1 x + \\dots + e_v x^v.</span>$</p>

    <p class="text-gray-300">At this point, the server resets the saturation level L := 0, updates the two secret polynomials to be:</p>

    <p class="text-gray-300"><span class="math">$A_{\\mathsf{new}}(\\cdot) := A(\\cdot) + D(\\cdot) \\pmod{q}</span>$
<span class="math">$B_{\\mathsf{new}}(\\cdot) := B(\\cdot) + E(\\cdot) \\pmod{q}</span>$</p>

    <p class="text-gray-300">and modifies the public key PK as follows:</p>

    <p class="text-gray-300"><span class="math">$PK_{\\mathsf{new}} := \\langle q, q&#x27;, q^{A_{\\mathsf{new}}(0)} q&#x27;^{B_{\\mathsf{new}}(0)}, \\langle \\ell, q^{A_{\\mathsf{new}}(\\ell)} q&#x27;^{B_{\\mathsf{new}}(\\ell)} \\rangle_{\\ell-1}^{v} \\rangle.</span>$</p>

    <p class="text-gray-300">Upon receiving the signed change period message, user i enters a wait-mode. When the user receives the reset message  <span class="math">C_{\\text{reset}}</span> , he/she decrypts all ciphertexts, decodes the coefficients  <span class="math">d_0, \\ldots, d_v, e_0, \\ldots, e_v</span>  using  <span class="math">enc^{-1}</span>  and forms the polynomials  <span class="math">D(\\cdot), E(\\cdot)</span> . Then, the user modifies his/her secret tuple  <span class="math">\\langle x_i, A(x_i), B(x_i) \\rangle</span>  to be the new tuple</p>

    <p class="text-gray-300"><span class="math">$\\langle x_i, A(x_i) + D(x_i), B(x_i) + E(x_i) \\rangle</span>$
.</p>

    <p class="text-gray-300">Remark. We notice that the efficiency of the New-period operation can be improved by using hybrid encryption. In particular, instead of computing and sending 2v + 2 ciphertexts under the current public-key (which incurs a cost of  <span class="math">\\mathcal{O}(v^2)</span>  in terms of communication), the server may pick a random session key k, use it to encrypt the 2v + 2 coefficients via a secure one-time symmetric-key encryption scheme, and broadcast the resulting ciphertext together with  <span class="math">\\mathcal{E}(PK, enc&#x27;(k))</span>  (where enc' is a suitable encoding of session keys into elements of  <span class="math">\\mathcal{G}</span> ). Each non-revoked user will then be able to recover the coefficients  <span class="math">d_0, \\ldots, d_v, e_0, \\ldots, e_v</span>  from such reset message by first recovering the session key k from the public-key ciphertext  <span class="math">\\mathcal{E}(PK, enc&#x27;(k))</span> , and then using k to decrypt the symmetric-key ciphertext. This will drop the communication cost to  <span class="math">\\mathcal{O}(v)</span> . We omit the details.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Dealing with Revocation</h2>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Model for Revocation</h3>

    <p class="text-gray-300">The public-key traitor tracing scheme described in Section 4 withstands a more powerful type of attack than what has been considered so far in previous related work [19, 21, 8, 9]. In our attack scenario, the adversary A is allowed not only to join the system up to a bounded number of times v (equal to the saturation level, which is fixed as a system parameter), but also to observe and even actively affect the evolution of the system, by specifying which users should be revoked and their relative order in the sequence of revocations. Notice that this type of adversary defeats all previous public-key traitor tracing schemes with fixed ciphertext size [19, 21, 9].</p>

    <p class="text-gray-300">More formally, in our model the adversary interleaves, in any adaptively-chosen order, two types of queries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Join query: it models the subscription to the system of a malicious user controlled by the adversary. To reply to such query, the server executes a variant of the Add-user operation, which allows the adversary to specify the identity for which she will get the decryption key, (whereas in a regular Add-user operation, the server would assign a random identity to the new user). Thus, the Join query models a more powerful adversary that can control the random choice of the server. Notice that, after a Join query, the adversary obtains a valid user-key capable of recovering subsequent encrypted broadcasts.</li>
      <li>Revoke query: it models the revocation of a user from the system. To reply to such query, the server performs a Remove-user operation and gives A the new public key that results after the invalidation of the key corresponding to the revoked user.</li>
    </ul>

    <p class="text-gray-300">Notice that the main constraint we impose to the adversary's behavior is that she can make at most v Join queries; no restriction is given for Revoke queries. Whenever A has finished collecting the amount of information she thinks she needs to maximize her chances of winning the game, the corrupted users are revoked, the adversary outputs a pair of messages and receives back the encryption of either one with equal probability.</p>

    <p class="text-gray-300">To fully appreciate the novelty of the attack scenario proposed above, recall that in the adversarial model that has been considered in previous work on public-key traitor tracing [19, 21, 8, 9], the only functionality conceded to A was to obtain the secret key of a user which was also simultaneously revoked from the system. In our model, such capability, usually called corruption, is split into two distinct operations. This clearly allows the adversary to mount more powerful attacks, and does indeed more closely model the reality, since the server does not always find out about &quot;bad&quot; users immediately. Moreover, keeping the Join and Revoke operations distinct, allows us to impose on the adversary the (minimal) restriction of obtaining at most v user-keys, without bounding the number of Revoke queries. This constitutes a major novelty of our adversarial model: previous work required both the number of revoked users and the number of compromised user-keys (tied together by the definition of corruption query) to be bounded by v.</p>

    <p class="text-gray-300">Clearly, for the challenge to the adversary not to be trivial, all the user-keys that A obtains through Join queries must have been rendered useless by corresponding subsequent Revoke queries. We model this necessary constraint by requiring that before asking for her challenge, A should enter a wait-mode during which all the (at most v) users she corrupted are revoked within a window of consecutive revocations that should not get interrupted by a New-period operation.</p>

    <p class="text-gray-300">It is interesting to point here some technical similarities of the window adversary model to a (lunch-time) Chosen Ciphertext Attack (CCA1). In particular, in a lunch-time attack the adversary, prior to obtaining the challenge, can query a decryption oracle to obtain decryptions of chosen ciphertexts; in the security proof, this introduces the technical challenge of simulating such decryption oracle. In the case of a windowadversary, the adversary can query the Join oracle to obtain valid decryption keys (that will be revoked afterwards). From a technical viewpoint, simulating the Join oracle is a technical challenge of similar nature to the task of simulating the decryption oracle of a CCA1 attacker. Indeed, in our security proof and system design we take advantage of techniques that were developed for dealing with CCA1 attacks.</p>

    <p class="text-gray-300">FORMAL MODEL FOR WINDOW ADVERSARY. We formalize the above attack scenario in terms of the window adversary attack game  <span class="math">\\mathbf{G}_{\\text{win}}^v(1^k)</span> , played between a challenger and the adversary  <span class="math">\\mathcal{A}</span> . This game consists of three stages, denoted respectively fst, snd and trd. To enable coordination between the three stages, at the end of each stage  <span class="math">\\mathcal{A}</span>  is allowed to output a piece of state information (via the variable aux), which will be given as input to the next stage.</p>

    <p class="text-gray-300">The first stage (fst) is a learning stage, in which the adversary is allowed to obtain the secret keys of at most v users and to make the system evolve via Revoke queries. At the end of this stage, all the corrupted users get revoked.</p>

    <p class="text-gray-300">The second stage (snd) is a choosing stage, in which  <span class="math">\\mathcal{A}</span>  picks two messages  <span class="math">M_0</span> ,  <span class="math">M_1</span>  that she deems she will be able to distinguish in the ciphertext form.</p>

    <p class="text-gray-300">In the third stage (trd),  <span class="math">\\mathcal{A}</span>  receives a challenge ciphertext  <span class="math">\\psi^*</span> , which consists of the encryption of either  <span class="math">M_0</span>  or  <span class="math">M_1</span>  with equal probability. The game ends with  <span class="math">\\mathcal{A}</span>  outputting her best guess to whether  <span class="math">M_0</span>  or  <span class="math">M_1</span>  was encrypted.</p>

    <pre><code class="language-text">1. Let \\langle PK, MSK \\rangle := \\mathsf{Setup}(1^k).

2. Let L := 0, \\mathsf{Corr} := \\emptyset.

3. Let state := \\langle L, PK, MSK, \\mathsf{Corr} \\rangle

4. aux \\leftarrow \\mathcal{A}^{\\mathsf{Join}(state, \\cdot), \\mathsf{Revoke}(state, \\cdot)}(\\mathsf{fst}, state.PK).

5. If L + |\\mathsf{Corr}| &gt; v then exit.

6. For all x_j \\in \\mathsf{Corr} do aux := aux||\\mathsf{Revoke}(state, x_j).

7. \\langle aux, M_0, M_1 \\rangle \\leftarrow \\mathcal{A}^{\\mathsf{Revoke}(state, \\cdot)}(\\mathsf{snd}, aux, state.PK).

8. \\psi^* \\leftarrow \\mathcal{E}(state.PK, M_{\\sigma^*}), where \\sigma^* \\leftarrow \\{0, 1\\}.

9. \\sigma \\leftarrow \\mathcal{A}^{\\mathsf{Revoke}(state, \\cdot)}(\\mathsf{trd}, aux, state.PK, \\psi^*).

10. Output Success if and only if \\sigma = \\sigma^*.
</code></pre>

    <p class="text-gray-300">The two oracles employed above are defined as follows:</p>

    <pre><code class="language-text">Join(state, x):
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) parse state as  <span class="math">\\langle L, PK, MSK, Corr \\rangle</span> ;</li>
      <li>(ii) parse PK as  <span class="math">\\langle g, g&#x27;, y, \\langle z_1, h_1 \\rangle, \\dots, \\langle z_v, h_v \\rangle \\rangle</span> ;</li>
      <li>(iii) parse MSK as  <span class="math">(A(\\cdot), B(\\cdot))</span> ;</li>
      <li>(iv) if  <span class="math">x \\in \\{1, \\dots, v\\}</span> , then exit;</li>
      <li>(v) set Corr := Corr  <span class="math">\\cup \\{x\\}</span>  and return (A(x), B(x)).</li>
    </ul>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">Revoke(state, x):</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) parse state as  <span class="math">\\langle L, PK, MSK, Corr \\rangle</span> ;</li>
      <li>(ii) parse PK as  <span class="math">\\langle g, g&#x27;, y, \\langle z_1, h_1 \\rangle, \\dots, \\langle z_v, h_v \\rangle \\rangle</span> ;</li>
      <li>(iii) parse MSK as  <span class="math">(A(\\cdot), B(\\cdot))</span> ;</li>
      <li>(iv) if  <span class="math">x \\in Corr</span> , then exit;</li>
      <li>(v) if L = v then a New-period operation is executed and state is updated accordingly (i.e., L is reset to 0, state.MSK is modified by adding the randomizing polynomials and state.PK changes correspondingly);</li>
      <li>(vi) set L := L + 1;</li>
      <li>(vii) update state. PK by replacing the pair  <span class="math">\\langle z_L, h_L \\rangle</span>  with  <span class="math">\\langle x, g^{A(x)} g&#x27;^{B(x)} \\rangle</span> ;</li>
      <li>(viii) output state.PK; if step (v) caused a New-period operation, then also output the corresponding reset message  <span class="math">C_{reset}</span> .</li>
    </ul>

    <p class="text-gray-300">Note that w.l.o.g. we assume that the adversary never corrupts the same user twice, as there is no extra information to be gained, and never revokes the users it corrupts, as they get explicitly revoked at step 6. of the attack game.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> Define A's advantage as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}_{\\mathcal{A}}(k) \\doteq |\\Pr(\\sigma = \\sigma^*) - 1/2|</span>$
.</p>

    <p class="text-gray-300">A public-key traitor tracing scheme is secure against window adversaries if for any PPT adversary  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathsf{Adv}_{\\mathcal{A}}(k)</span>  is negligible in k.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Security of Revocation</h3>

    <p class="text-gray-300">We now formally prove that the scalable public-key traitor tracing scheme described in Section 4 is secure against window adversaries (as defined above). In the security proof, we will follow the same structural approach used in [9], first advocated in [7]. Starting from the actual attack scenario, we will consider a sequence of hypothetical games, all defined over the same probability space. In each game, the adversary's view is obtained in different ways, but its distribution is still indistinguishable among the games.</p>

    <p class="text-gray-300">The security of our scheme relies on the DDH assumption (Assumption 1) as shown below in Theorem 1.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Under the decisional Diffie-Hellman Assumption for G, the scheme presented above is secure against window adversaries.</p>

    <p class="text-gray-300">Proof. We define a sequence of &quot;indistinguishable&quot; games  <span class="math">G_0, G_1, \\ldots</span> , all operating over the same underlying probability space. Starting from the actual adversarial game  <span class="math">G_0 = G_{\\text{win}}^v(1^k)</span> , we incrementally make slight modifications to the behavior of the oracles, thus changing the way the adversary's view is computed, while maintaining the views' distributions indistinguishable among the games. In the last game, it will be clear that the adversary has (at most) a negligible advantage; by the indistinguishability of any two consecutive games, it will follow that also in the original game the adversary's advantage is negligible. Recall that in each game  <span class="math">G_j</span> , the goal of adversary A is to output  <span class="math">\\sigma \\in \\{0,1\\}</span>  which is her best guess to the bit  <span class="math">\\sigma^*</span>  used at step 7. of the attack game  <span class="math">G_{\\text{win}}^v(1^k)</span>  to create the challenge ciphertext  <span class="math">\\psi^*</span> : let  <span class="math">T_j</span>  be the event that  <span class="math">\\sigma = \\sigma^*</span>  in game  <span class="math">G_j</span>  (i.e., the event that the game ends with Success as output). W.l.o.g., in the following we assume that the adversary corrupts exactly v users during the attack game.</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>0</sub>. Define <strong>G</strong><sub>0</sub> to be the original game  <span class="math">\\mathbf{G}_{win}^{v}(1^{k})</span> .</p>

    <p class="text-gray-300">Game  <span class="math">G_1</span> . Define the &quot;special&quot; New-period operation to be the first one to be caused by the Revoke oracle at step 7. of the attack game. Depending on the adversary's strategy, such &quot;special&quot; New-period operation may not occur at all.</p>

    <p class="text-gray-300">Game  <span class="math">G_1</span>  is identical to game  <span class="math">G_0</span> , except that, in  <span class="math">G_1</span> , the reset message output by the &quot;special&quot; New-period operation contains 2v + 2 encryptions of random elements of  <span class="math">\\mathbb{Z}_q</span> , rather than encryptions of the coefficients of the randomizing polynomials. This modification suggests that the secret polynomials which are contained in state.MSK at the beginning of the period initiated by the &quot;special&quot; New-period operation are totally random, even given all the information in the adversary's view.</p>

    <p class="text-gray-300">In Lemma 2 (whose proof is given below), we show that the chances of adversary  <span class="math">\\mathcal{A}</span>  winning game  <span class="math">\\mathbf{G}_1</span>  cannot be significantly better than her chances of winning game  <span class="math">\\mathbf{G}_0</span> : more precisely,</p>

    <p class="text-gray-300"><span class="math">$\\left|\\Pr[T_1] - \\Pr[T_0]\\right| \\le (4v + 4) \\operatorname{AdvDDH}_{\\mathcal{G}}(k). \\tag{5}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>2</sub>. To turn game  <span class="math">G_1</span>  into game  <span class="math">G_2</span> , step 8. of the attack game is modified as follows:</p>

    <p class="text-gray-300"><span class="math">$8&#x27;. \\psi^* \\leftarrow \\mathcal{E}(state.PK, M), \\text{ where } M \\stackrel{r}{\\leftarrow} \\mathcal{G}, \\sigma^* \\stackrel{r}{\\leftarrow} \\{0, 1\\}</span>$</p>

    <p class="text-gray-300">Because of this change, the challenge ciphertext  <span class="math">\\psi^*</span>  no longer contains  <span class="math">\\sigma^*</span> , nor does any other information in the adversary's view; therefore,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_2] = \\frac{1}{2}.\\tag{6}</span>$</p>

    <p class="text-gray-300">In Lemma 3, proven below, we show that the adversary has almost the same chances to guess  <span class="math">\\sigma^*</span>  in game  <span class="math">\\mathbf{G}_1</span>  and  <span class="math">\\mathbf{G}_2</span> : more precisely,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_2] - \\Pr[T_1] \\right| \\le 2 \\operatorname{AdvDDH}_{\\mathcal{G}}(k). \\tag{7}</span>$</p>

    <p class="text-gray-300">Combining Equations (5), (6), and (7) together, adversary A's advantage can be bounded as:</p>

    <p class="text-gray-300"><span class="math">$Adv_{\\mathcal{A}}(k) \\leq (4v+6) AdvDDH_{\\mathcal{G}}(k)</span>$
.</p>

    <p class="text-gray-300">The core of the proof of Theorem 1 is in the two lemmas that follow, Lemma 2 and Lemma 3.</p>

    <p class="text-gray-300">OVERVIEW OF THE PROOF TECHNIQUE. Throughout the paper, we make extensive use of a technical lemma, stated and proved as Lemma 9 in [7]. For ease of reference, we report it verbatim below.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let k,n be integers with  <span class="math">1 \\le k \\le n</span> , and let K be a finite field. Consider a probability space with random variables  <span class="math">\\alpha \\in K^{n \\times 1}, \\beta = (\\beta_1, \\dots, \\beta_k)^T \\in K^{k \\times 1}, \\gamma \\in K^{k \\times 1}</span> , and  <span class="math">M \\in K^{k \\times n}</span> , such that  <span class="math">\\alpha</span>  is uniformly distributed over  <span class="math">K^n, \\beta = M\\alpha + \\gamma</span> , and for  <span class="math">1 \\le i \\le k</span> , the first ith rows of M and  <span class="math">\\gamma</span>  are determined by  <span class="math">\\beta_1, \\dots, \\beta_{i-1}</span> . Then, conditioning on any fixed values of  <span class="math">\\beta_1, \\dots, \\beta_{k-1}</span>  such that the resulting matrix M has rank k, the value of  <span class="math">\\beta_k</span>  is uniformly distributed over K in the resulting conditional probability space.</p>

    <p class="text-gray-300">Our use of this technical lemma is quite uniform across the proofs to follow. In all cases, our main aim will be to prove that some quantity  <span class="math">\\mathsf{rand} \\in \\mathbb{Z}_q</span>  looks uniformly random to the adversary, despite all the other information in the adversary's view. At a high level, our approach is organized in the following steps.</p>

    <p class="text-gray-300">First, we consider all the randomness underlying a specific execution of the attack game. This will include, for instance, the random coins of the adversary, the randomness used in creating the challenge, etc. We then partition all the randomness in two parts: a quantity V and a vector  <span class="math">\\alpha</span> , such that conditioning on any fixed value of V,  <span class="math">\\alpha</span>  is still distributed uniformly at random in the appropriate vector space (which usually will have  <span class="math">\\mathbb{Z}_q</span>  as support).</p>

    <p class="text-gray-300">Second, we consider another vector  <span class="math">\\boldsymbol{\\beta}</span> , whose last entry is rand, with the property that fixing a value for  <span class="math">\\boldsymbol{V}</span>  and  <span class="math">\\boldsymbol{\\beta}</span>  also fixes the value of  <span class="math">\\boldsymbol{\\alpha}</span> , and thus all the information of the entire game (which in particular includes the information in the adversary's view).</p>

    <p class="text-gray-300">Third, we define a matrix <strong>M</strong> (and possibly a vector  <span class="math">\\gamma</span> ) describing the constraints binding vector  <span class="math">\\alpha</span>  to vector  <span class="math">\\beta</span> , thus obtaining a matrix equation of the form:</p>

    <p class="text-gray-300"><span class="math">$\\beta = \\mathbf{M} \\cdot \\boldsymbol{\\alpha} + \\boldsymbol{\\gamma}.</span>$</p>

    <p class="text-gray-300">Finally, we make sure that the preconditions of Lemma 1 are fulfilled; it will follow that the last entry of  <span class="math">\\beta</span>  (which is the quantity of interest rand), is distributed uniformly at random in  <span class="math">\\mathbb{Z}_q</span> , even conditioning on fixed values of V and of all the other entries of  <span class="math">\\beta</span> , or equivalently, conditioning on all the other information in the adversary's view.</p>

    <p class="text-gray-300">NOTATION. In what follows, we refer to the period initiated by the tth New-period operation as the tth period. Also, for notational convenience, we denote with  <span class="math">D^t(\\cdot)</span>  and  <span class="math">E^t(\\cdot)</span>  the randomizing polynomials chosen during the tth New-period operation and with  <span class="math">d_0^t, \\ldots, d_v^t</span>  and  <span class="math">e_0^t, \\ldots, e_v^t</span>  the corresponding coefficients. In some cases, it will be convenient to denote these 2v+2 coefficients with a uniform notation; for this reason, for  <span class="math">j=1,\\ldots,2v+2</span> , we additionally define  <span class="math">e_j^t</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$c_j^t \\doteq \\begin{cases} d_{j-1}^t &amp; \\text{if } j \\in \\{1, \\dots, v+1\\} \\\\ e_{j-v-2} &amp; \\text{if } j \\in \\{v+2, \\dots, 2v+2\\} \\end{cases}</span>$</p>

    <p class="text-gray-300">Moreover, let  <span class="math">A^t(\\cdot)</span>  and  <span class="math">B^t(\\cdot)</span>  be the values of the secret polynomials after the changes due to the tth Newperiod operation. In other words, the system starts with period number 0,  <span class="math">A^0(\\cdot)</span>  and  <span class="math">B^0(\\cdot)</span>  are the polynomials initially output by the Setup algorithm and</p>

    <p class="text-gray-300"><span class="math">$A^{t}(\\cdot) \\doteq A^{t-1}(\\cdot) + D^{t}(\\cdot) \\quad B^{t}(\\cdot) \\doteq B^{t-1}(\\cdot) + E^{t}(\\cdot). \\tag{8}</span>$</p>

    <p class="text-gray-300">Also define</p>

    <p class="text-gray-300"><span class="math">$D^{t_1,t_2}(\\cdot) \\doteq \\sum_{t=t_1}^{t_2} D^t(\\cdot) \\quad E^{t_1,t_2}(\\cdot) \\doteq \\sum_{t=t_1}^{t_2} E^t(\\cdot). \\tag{9}</span>$</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong>  <span class="math">|\\Pr[T_1] - \\Pr[T_0]| \\le (4v + 4) \\text{ AdvDDH}_{\\mathcal{G}}(k)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that  <span class="math">G_1</span>  differs from  <span class="math">G_0</span>  only in the way the reset message is computed for the &quot;special&quot; Newperiod operation: hence, if the adversary's strategy does not cause any New-period operation to occur during step 7. of the attack game, the two games are identical, so that in fact  <span class="math">Pr[T_1] = Pr[T_0]</span> , and the Lemma immediately follows.</p>

    <p class="text-gray-300">We now discuss the case in which the &quot;special&quot; New-period operation takes place: in particular, let  <span class="math">\\hat{t}</span>  be the period initiated by this operation and  <span class="math">D^{\\hat{t}}(\\cdot)</span>  and  <span class="math">E^{\\hat{t}}(\\cdot)</span>  be the randomizing polynomials used in such New-period operation. We then consider the sequence of 2v+3 hybrid games  <span class="math">\\mathbf{G}_{0,0},\\ldots,\\mathbf{G}_{0,2v+2}</span> , where  <span class="math">\\mathbf{G}_{0,i}</span>  is defined as  <span class="math">\\mathbf{G}_0</span> , except that the first i ciphertexts in the &quot;special&quot; reset message contain random values rather than coefficients of the randomizing polynomials  <span class="math">D^{\\hat{t}}(\\cdot)</span>  and  <span class="math">E^{\\hat{t}}(\\cdot)</span> . In other words,  <span class="math">\\mathbf{G}_{0,0} \\equiv \\mathbf{G}_0</span> ,  <span class="math">\\mathbf{G}_{0,2v+2} \\equiv \\mathbf{G}_1</span>  and two consecutive hybrid games  <span class="math">\\mathbf{G}_{0,i}</span>  and  <span class="math">\\mathbf{G}_{0,i+1}</span>  differ only in that the (i+1)th ciphertext of the &quot;special&quot; reset message contains the (i+1)th coefficient in game  <span class="math">\\mathbf{G}_{0,i}</span> , whereas it contains a random value in game  <span class="math">\\mathbf{G}_{0,i+1}</span> . Then, to prove the Lemma it suffices to show that for all  <span class="math">i=0,\\ldots,2v+1</span>  it holds:</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_{0,i+1}] - \\Pr[T_{0,i}] \\right| \\le 2 \\operatorname{AdvDDH}_{\\mathcal{G}}(k). \\tag{10}</span>$</p>

    <p class="text-gray-300">To this aim, fix i and consider the additional games  <span class="math">\\mathbf{G}_{0,i}^0 \\equiv \\mathbf{G}_{0,i}</span> ,  <span class="math">\\mathbf{G}_{0,i}^1</span> ,  <span class="math">\\mathbf{G}_{0,i}^2</span> ,  <span class="math">\\mathbf{G}_{0,i}^3</span> ,  <span class="math">\\mathbf{G}_{0,i}^4 \\equiv \\mathbf{G}_{0,i+1}</span> , defined as follows:</p>

    <p class="text-gray-300"><strong>Game G</strong> <span class="math">_{0,i}^1</span> . It operates as  <span class="math">\\mathbf{G}_{0,i}^0</span> , except that the (i+1)th ciphertext in the &quot;special&quot; reset message is computed as:</p>

    <p class="text-gray-300"><span class="math">$\\langle u, u&#x27;, u&#x27;&#x27;, \\langle z_{\\ell}, u^{A^{\\hat{t}-1}(z_{\\ell})} u&#x27;^{B^{\\hat{t}-1}(z_{\\ell})} \\rangle_{\\ell=1}^{v} \\rangle</span>$</p>

    <p class="text-gray-300">where  <span class="math">u \\doteq g^r</span> ,  <span class="math">u&#x27; \\doteq g&#x27;^r</span> ,  <span class="math">u&#x27;&#x27; \\doteq u^{A^{\\hat{t}-1}(0)} \\ u&#x27;^{B^{\\hat{t}-1}(0)} enc(c^{\\hat{t}}_{i+1})</span> ,  <span class="math">r \\leftarrow \\mathbb{Z}_q</span>  and  <span class="math">c^{\\hat{t}}_{i+1}</span>  is either the (i+1)th coefficient of the randomizing polynomial  <span class="math">D^{\\hat{t}}(\\cdot)</span>  (if  <span class="math">0 \\leq i \\leq v</span> ) or the (i-v)th coefficient of  <span class="math">E^{\\hat{t}}(\\cdot)</span>  (if  <span class="math">v+1 \\leq i \\leq 2v+1</span> ). Since such modification is just a syntactic change, it holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_{0i}^1] = \\Pr[T_{0i}^0]. \\tag{11}</span>$</p>

    <p class="text-gray-300">Game  <span class="math">G_{0,i}^2</span> . To turn game  <span class="math">G_{0,i}^1</span>  into game  <span class="math">G_{0,i}^2</span>  we make another change to the way in which the (i+1)th ciphertext in the &quot;special&quot; reset message is computed. Namely, the value u' is now computed as  <span class="math">u&#x27; \\doteq g&#x27;^{r&#x27;}</span> , for a random  <span class="math">r&#x27; \\in \\mathbb{Z}_q</span>  such that  <span class="math">r&#x27; \\neq r</span> . In other words, in game  <span class="math">G_{0,i}^2</span>  the values u and u' are nearly independent (being subject only to  <span class="math">r \\neq r&#x27;</span> ), whereas in game  <span class="math">G_{0,i}^1</span>  they are obtained using the same value r. Therefore, using a standard reduction argument, any difference in behavior between games  <span class="math">G_{0,i}^1</span>  and  <span class="math">G_{0,i}^2</span>  can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_{0i}^2] - \\Pr[T_{0i}^1] \\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k). \\tag{12}</span>$</p>

    <p class="text-gray-300">Note that for simplicity here (and throughout the rest of the paper) we omit the negligible additive term that is caused by the negligibly-rare event r = r'.</p>

    <p class="text-gray-300"><strong>Game</strong>  <span class="math">G_{0,i}^3</span> . To define game  <span class="math">G_{0,i}^3</span> , we again modify the (i+1)th ciphertext in the &quot;special&quot; reset message: specifically, the value u'' is now computed as  <span class="math">g^{r&#x27;&#x27;}</span> , for a random  <span class="math">r&#x27;&#x27; \\in \\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">We want to show that this modification does not alter the behavior of adversary  <span class="math">\\mathcal{A}</span>  or, more precisely, that  <span class="math">\\Pr[T_{0,i}^3] = \\Pr[T_{0,i}^2]</span> . To this aim, we first consider all the random variables affecting the adversary's view, and then we show that they are distributed according to the same joint distribution in both games.</p>

    <p class="text-gray-300">Let  <span class="math">\\bar{t}</span>  be the total number of New-period operations that occur during the entire game, and for  <span class="math">t=1,\\ldots,\\bar{t}</span> , let  <span class="math">c_1^t,\\ldots,c_{2v+2}^t</span>  be the coefficients of the randomizing polynomials  <span class="math">D^t(\\cdot)</span>  and  <span class="math">E^t(\\cdot)</span>  used in the tth New-period operation. For  <span class="math">t=1,\\ldots,\\bar{t},\\,t\\neq\\hat{t}</span> , and  <span class="math">j=1,\\ldots,2v+2</span> , let  <span class="math">r_j^t</span>  be the randomness used to encrypt (the encoding of) coefficient  <span class="math">c_j^t</span>  in the tth reset message.</p>

    <p class="text-gray-300">As for the &quot;special&quot; reset message (i.e., the one corresponding to  <span class="math">t = \\hat{t}</span> ), recall that in both game  <span class="math">\\mathbf{G}_{0,i}^2</span>  and game  <span class="math">\\mathbf{G}_{0,i}^3</span> , the first i ciphertexts consists of just random values  <span class="math">s_1, \\ldots, s_i \\in \\mathcal{G}</span> , rather than (the encoding of) the corresponding coefficients  <span class="math">c_1^{\\hat{t}}, \\ldots, c_i^{\\hat{t}}</span> . Coefficients  <span class="math">c_{i+2}^{\\hat{t}}, \\ldots, c_{iv+2}^{\\hat{t}}</span> , instead, are regularly</p>

    <p class="text-gray-300">encrypted under the public key  <span class="math">PK^{\\hat{t}-1}</span>  in both games: let  <span class="math">r_j^{\\hat{t}}</span>  be the randomness used in such encryptions, for  <span class="math">j=i+2,\\ldots,2v+2</span> . The ciphertext corresponding to coefficient  <span class="math">c_{i+1}</span>  in the &quot;special&quot; reset message constitutes the only difference between the adversary's view in game  <span class="math">\\mathbf{G}_{0,i}^2</span>  and  <span class="math">\\mathbf{G}_{0,i}^3</span> . In particular, such encryption is defined in terms of the values r, r' and r'': r and r' are randomly chosen from  <span class="math">\\mathbb{Z}_q</span>  in both games, whereas r'' is computed differently in the two games. For the sake of clarity, we will denote with  <span class="math">[r&#x27;&#x27;]_2</span>  and  <span class="math">[r&#x27;&#x27;]_3</span>  the value of such quantity in game  <span class="math">\\mathbf{G}_{0,i}^2</span>  and  <span class="math">\\mathbf{G}_{0,i}^3</span> , respectively. Notice that  <span class="math">[r&#x27;&#x27;]_2</span>  is a linear combination of r, r' (and other quantities), whereas  <span class="math">[r&#x27;&#x27;]_3</span>  is uniformly distributed in  <span class="math">\\mathbb{Z}_q</span> , independently of anything else.</p>

    <p class="text-gray-300">Define</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{W} \\doteq \\left( \\{c_j^t, r_j^t\\}_{\\substack{j=1\\\\ t \\neq \\hat{t}}}^{2v+2}, \\{c_j^{\\hat{t}}, s_j, r_j^{\\hat{t}}\\}_{j=1}^i, \\{c_j^{\\hat{t}}, r_j^{\\hat{t}}\\}_{j=i+1}^{2v+2}, r, r&#x27; \\right)</span>$</p>

    <p class="text-gray-300">and consider the quantity</p>

    <p class="text-gray-300"><span class="math">$V \\doteq (\\mathsf{Coins}, w, \\sigma^*, r^*, \\boldsymbol{W})</span>$</p>

    <p class="text-gray-300">where Coins represents the coin tosses of  <span class="math">\\mathcal{A}</span> ,  <span class="math">w \\doteq \\log_g g&#x27;</span> ,  <span class="math">\\sigma^*</span>  is the random bit chosen by the challenger in step 8. of the attack game and  <span class="math">r^*</span>  is the randomness used to create the challenge  <span class="math">\\psi^*</span> .</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of the 2v+2 coefficients of the polynomials  <span class="math">A^0(\\cdot)</span> ,  <span class="math">B^0(\\cdot)</span>  and can be represented by a vector  <span class="math">\\boldsymbol{\\alpha}</span>  uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\alpha} \\doteq (a_0, a_1, \\dots, a_v, b_0, b_1, \\dots, b_v)^T.</span>$</p>

    <p class="text-gray-300">Consider the vector  <span class="math">\\boldsymbol{\\beta} \\in \\mathbb{Z}_q^{(2v+2)\\times 1}</span>  defined as:</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\beta} \\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_v, \\mathbf{A}_1, \\dots, \\mathbf{A}_v, r&#x27;&#x27;)^T</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_0 \\doteq A^0(0) + wB^0(0)</span> ,  <span class="math">\\mathbf{X}_\\ell \\doteq A^0(\\ell) + wB^0(\\ell)</span>  and  <span class="math">\\mathbf{A}_\\ell \\doteq A^0(x_\\ell)</span>  for  <span class="math">\\ell = 1, ..., v</span> , and  <span class="math">r&#x27;&#x27; \\doteq \\log_q u&#x27;&#x27;</span> .</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the adversary's view is completely determined by V and  <span class="math">\\beta</span> . In particular, the initial public key  <span class="math">PK^0</span>  is fixed by  <span class="math">\\beta</span>  and w; the secret keys of the corrupted users are determined by the choice of  <span class="math">\\beta</span> , Coins and w; the &quot;special&quot; reset message is fixed by  <span class="math">PK^0</span> , Coins, r'' and all the randomness in W; and the resulting public key  <span class="math">PK^{\\hat{t}}</span>  only depends on  <span class="math">PK^0</span>  and W. Thus, if the distribution of V and  <span class="math">\\beta</span>  is the same in both games  <span class="math">G_{0,i}^2</span>  and  <span class="math">G_{0,i}^3</span> , it will follow that  <span class="math">\\Pr[T_{0,i}^3] = \\Pr[T_{0,i}^2]</span> . Since the definition of r'' is the only difference between game  <span class="math">G_{0,i}^2</span>  and  <span class="math">G_{0,i}^3</span> , and in  <span class="math">G_{0,i}^3</span>  the value of  <span class="math">[r&#x27;&#x27;]_3</span>  is chosen uniformly from  <span class="math">\\mathbb{Z}_q</span> , independently of anything else, it suffices to show that the distribution of  <span class="math">[r&#x27;&#x27;]_2</span> , conditioned on V and the first 2v+1 entries of  <span class="math">\\beta</span> , is also uniform in  <span class="math">\\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">In game  <span class="math">G_{0,i}^2</span> , the quantities in V,  <span class="math">\\beta</span>  and  <span class="math">\\alpha</span>  are related according to the following matrix equation:</p>

    <p class="text-gray-300"><span class="math">$[\\boldsymbol{\\beta}]_2 = \\mathbf{M} \\cdot \\boldsymbol{\\alpha} + \\boldsymbol{\\gamma}</span>$</p>

    <p class="text-gray-300">where  <span class="math">[\\boldsymbol{\\beta}]_2</span>  denotes the value of  <span class="math">\\boldsymbol{\\beta}</span>  in game  <span class="math">\\mathbf{G}_{0,i}^2</span>  (i.e. when the value of the last entry is  <span class="math">[r&#x27;&#x27;]_2</span> ),  <span class="math">\\boldsymbol{\\gamma} \\in \\mathbb{Z}_q^{(2v+2)\\times 1}</span>  is the vector</p>

    <p class="text-gray-300"><span class="math">$\\gamma \\doteq \\begin{pmatrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ rD^{0,\\hat{t}-1}(0) + wr&#x27;E^{0,\\hat{t}-1}(0) + \\log_g enc(c_{i+1}^{\\hat{t}}) \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(2v+2)\\times(2v+2)}</span>  is the matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{M} \\doteq \\begin{pmatrix} 1 &amp; 0 &amp; \\dots &amp; 0 &amp; w &amp; 0 &amp; \\dots &amp; 0 \\\\ 1 &amp; 1 &amp; \\dots &amp; 1 &amp; w &amp; w &amp; \\dots &amp; w \\\\ &amp; \\vdots &amp; &amp; &amp; \\vdots &amp; &amp; \\\\ 1 &amp; v &amp; \\dots &amp; v^v &amp; w &amp; wv &amp; \\dots &amp; wv^v \\\\ 1 &amp; x_1 &amp; \\dots &amp; x_1^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ &amp; \\vdots &amp; &amp; &amp; \\vdots &amp; &amp; \\\\ 1 &amp; x_v &amp; \\dots &amp; x_v^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ r &amp; 0 &amp; \\dots &amp; 0 &amp; wr&#x27; &amp; 0 &amp; \\dots &amp; 0 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">The above matrix describes all the constraints on  <span class="math">\\alpha</span>  arising from the information in the adversary's view in game  <span class="math">\\mathbf{G}_{0,i}^2</span>  (which, as noted above, can be described just by  <span class="math">\\mathbf{V}</span>  and  <span class="math">[\\boldsymbol{\\beta}]_2</span> ). In other words, all other constraints on  <span class="math">\\alpha</span>  are linear combination of the above, possibly using coefficients from  <span class="math">\\mathbf{V}</span> . In particular, the constraints that the adversary can derive from knowledge of the values  <span class="math">B^0(x_\\ell)</span> ,  <span class="math">\\ell=1,\\ldots,v</span>  (which come from the secret keys that  <span class="math">\\mathcal{A}</span>  got via Join queries) can be obtained from the constraints corresponding to  <span class="math">\\mathbf{X}_0, \\mathbf{X}_1, \\ldots, \\mathbf{X}_v, \\mathbf{A}_1, \\ldots, \\mathbf{A}_v</span>  and the value of w. As for Revoke queries, notice that the public key PK resulting from invalidating the secret key of an arbitrary user z during time period t, does not provide any new information about  <span class="math">\\alpha</span>  to the adversary. Indeed, PK only differs from the previous public key in that it contains the value  <span class="math">h_z = g^{A^t(z)}g&#x27;^{B^t(z)}</span>  which is determined by the quantity:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X} \\doteq A^{t}(z) + wB^{t}(z) - (D^{0,t}(z) + wE^{0,t}(z))</span>$</p>

    <p class="text-gray-300">=  <span class="math">A^{0}(z) + wB^{0}(z)</span> .</p>

    <p class="text-gray-300">Since such value is just a point of the polynomial v-degree  <span class="math">A^0(\\cdot) + wB^0(\\cdot)</span> , which is completely fixed by the values  <span class="math">\\mathbf{X}_0, \\mathbf{X}_1, \\ldots, \\mathbf{X}_v</span> , it immediately follows that the constraint on  <span class="math">\\boldsymbol{\\alpha}</span>  induced by  <span class="math">\\mathbf{X}</span>  is a linear combination of the first v+1 rows of  <span class="math">\\mathbf{M}</span> . Similarly, the v values  <span class="math">u_1, \\ldots, u_v</span>  included in the (v+1)th ciphertext of the &quot;special&quot; reset message are determined by the quantities  <span class="math">\\mathbf{X}_{z_1}, \\ldots, \\mathbf{X}_{z_v}</span> , where, for  <span class="math">\\ell = 1, \\ldots, v, \\mathbf{X}_{z_\\ell}</span>  is defined as:</p>

    <p class="text-gray-300"><span class="math">$rA^{\\hat{t}-1}(z_{\\ell}) + wr&#x27;B^{\\hat{t}-1}(z_{\\ell}) - (rD^{0,\\hat{t}-1}(z_{\\ell}) + wr&#x27;E^{0,\\hat{t}-1}(z_{\\ell}))</span>$</p>

    <p class="text-gray-300">or equivalently</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}_{z_{\\ell}} \\doteq rA^{0}(z_{\\ell}) + wr&#x27;B^{0}(z_{\\ell}).</span>$</p>

    <p class="text-gray-300">Such values are just points of the v-degree polynomial</p>

    <p class="text-gray-300"><span class="math">$rA^0(\\cdot) + wr&#x27;B^0(\\cdot)</span>$</p>

    <p class="text-gray-300">which is determined by  <span class="math">\\mathbf{A}_1, \\ldots, \\mathbf{A}_v, B^0(x_1), \\ldots, B^0(x_v), r, r&#x27;, w</span>  and  <span class="math">[r&#x27;&#x27;]_2</span> . Thus, it follows that all the constraints on  <span class="math">\\alpha</span>  induced  <span class="math">\\mathbf{X}_{z_1}, \\ldots, \\mathbf{X}_{z_v}</span>  by are linear combinations of the rows of  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">Moreover, <strong>M</strong> has rank (2v+2), provided that  <span class="math">r \\neq r&#x27;</span>  and  <span class="math">w \\neq 0</span> , since the corrupted users  <span class="math">x_1, \\ldots, x_v</span>  are assumed to be distinct.</p>

    <p class="text-gray-300">As soon as we fix a value for V, vector  <span class="math">\\gamma</span>  and the first v+1 rows of matrix  <span class="math">\\mathbf{M}</span>  are completely fixed, but  <span class="math">\\alpha</span>  is still distributed uniformly and independently at random in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> . If we additionally fix the value of the first (v+1) components of  <span class="math">[\\boldsymbol{\\beta}]_2</span> , the initial public key  <span class="math">PK^0</span>  is fixed; it follows that the first identity  <span class="math">x_1</span>  that  <span class="math">\\mathcal{A}</span>  chooses to corrupt is also fixed and thus the (v+2)th row of  <span class="math">\\mathbf{M}</span>  is determined. Fixing also a value for  <span class="math">\\mathbf{A}_1</span>  (which is the (v+2)th entry of  <span class="math">[\\boldsymbol{\\beta}]_2</span> ), the value of  <span class="math">\\mathbf{B}_1</span>  is fixed too, so that all the information on which the adversary can base her choice of  <span class="math">x_2</span>  is fixed, and thus the (v+3)th row of  <span class="math">\\mathbf{M}</span>  is determined as well. By a similar reasoning, it follows that fixing the first (v+i+1) entries of  <span class="math">[\\boldsymbol{\\beta}]_2</span>  determines the (v+i+2)th row of  <span class="math">\\mathbf{M}</span> , for  <span class="math">i=1,\\ldots,v</span> . Hence, by Lemma 1, we can conclude that the conditional distribution of  <span class="math">[r&#x27;&#x27;]_2</span> , w.r.t. V and to all other components of  <span class="math">[\\boldsymbol{\\beta}]_2</span> , is also uniform over  <span class="math">\\mathbb{Z}_q</span> , from which it follows that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_{0i}^3] = \\Pr[T_{0i}^2]. \\tag{13}</span>$</p>

    <p class="text-gray-300">Game  <span class="math">\\mathbf{G}_{0,i}^4</span> . Game  <span class="math">\\mathbf{G}_{0,i}^4</span>  is defined to be identical to  <span class="math">\\mathbf{G}_{0,i+1}</span> . Thus,  <span class="math">\\mathbf{G}_{0,i}^4</span>  differs from  <span class="math">\\mathbf{G}_{0,i}^3</span>  only in that the values u and u' in the (i+1)th ciphertext in the &quot;special&quot; reset message are consistent, rather than being nearly independent, as in game  <span class="math">\\mathbf{G}_{0,i}^3</span> . Namely, the values u and u' are now computed as  <span class="math">u \\doteq g^r</span>  and  <span class="math">u&#x27; \\doteq g&#x27;^r</span> , for the same random  <span class="math">r \\in \\mathbb{Z}_q</span> . It follows that any difference in behavior between games  <span class="math">\\mathbf{G}_{0,i}^3</span>  and  <span class="math">\\mathbf{G}_{0,i}^4</span>  can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_{0,i}^4] - \\Pr[T_{0,i}^3] \\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k). \\tag{14}</span>$</p>

    <p class="text-gray-300">Combining Equations (11), (12), (13) and (14) we get Equation (10), for all i = 0, ..., 2v + 1; then, by definition of the hybrid sequence  <span class="math">\\mathbf{G}_{0,0}, ..., \\mathbf{G}_{0,2v+2}</span> , the thesis follows.</p>

    <p class="text-gray-300">Lemma 3.  <span class="math">|\\Pr[T_2] - \\Pr[T_1]| \\le 2 \\operatorname{AdvDDH}_{\\mathcal{G}}(k)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that  <span class="math">\\mathbf{G}_2</span>  differs from  <span class="math">\\mathbf{G}_1</span>  only in the way the challenge ciphertext  <span class="math">\\psi^*</span>  is computed: in particular, in game  <span class="math">\\mathbf{G}_1</span> ,  <span class="math">\\psi^*</span>  encrypts either one of the two messages  <span class="math">M_0</span>  and  <span class="math">M_1</span>  chosen by the adversary, whereas in  <span class="math">\\mathbf{G}_2</span> ,  <span class="math">\\psi^*</span>  encrypts a totally random message  <span class="math">M \\leftarrow \\mathcal{G}</span> .</p>

    <p class="text-gray-300">To reach the thesis, we consider the sequence of games  <span class="math">\\mathbf{G}_1^0 \\equiv \\mathbf{G}_1</span> ,  <span class="math">\\mathbf{G}_1^1</span> ,  <span class="math">\\mathbf{G}_1^2</span> ,  <span class="math">\\mathbf{G}_1^3</span> ,  <span class="math">\\mathbf{G}_1^4 \\equiv \\mathbf{G}_2</span> , defined below.</p>

    <p class="text-gray-300"><strong>Game</strong>  <span class="math">G_1^1</span> . It operates as  <span class="math">G_1^0</span> , except that the challenge ciphertext is computed as follows:</p>

    <p class="text-gray-300"><span class="math">$\\langle u^*, u&#x27;^*, u&#x27;&#x27;^*, \\langle z_{\\ell}^*, u^{*A^{t^*}(z_{\\ell}^*)} u&#x27;^{*B^{t^*}(z_{\\ell}^*)} \\rangle_{\\ell=1}^{v} \\rangle</span>$</p>

    <p class="text-gray-300">where  <span class="math">u^* \\doteq g^{r^*}</span> ,  <span class="math">u&#x27;^* \\doteq g&#x27;^{r^*}</span> ,  <span class="math">u&#x27;&#x27;^* \\doteq u^{*A^{t^*}(0)}u&#x27;^{*B^{t^*}(0)} \\cdot M_{\\sigma^*}</span>  and  <span class="math">r^* \\leftarrow \\mathbb{Z}_q</span> . This syntactic change does not affect the adversary's view, and thus</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_1^1] = \\Pr[T_1^0].</span>$
(15)</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>1</sub><sup>2</sup>. To turn game <strong>G</strong><sub>1</sub><sup>1</sup> into game <strong>G</strong><sub>1</sub><sup>2</sup> we make another change to the way in which the challenge ciphertext is computed. Namely, the value  <span class="math">u&#x27;^*</span>  is now computed as  <span class="math">u&#x27;^* \\doteq g&#x27;^{r&#x27;^*}</span> , for a random  <span class="math">r&#x27;^* \\in \\mathbb{Z}_q</span>  such that  <span class="math">r&#x27;^* \\neq r^*</span> . In other words, in game <strong>G</strong><sub>1</sub><sup>2</sup> the values  <span class="math">u^*</span>  and  <span class="math">u&#x27;^*</span>  are nearly independent (being subject only to  <span class="math">r^* \\neq r&#x27;^*</span> ), whereas in game <strong>G</strong><sub>1</sub><sup>1</sup> they are obtained using the same value  <span class="math">r^*</span> . Therefore, using a standard reduction argument, any difference in behavior between games <strong>G</strong><sub>1</sub><sup>1</sup> and <strong>G</strong><sub>1</sub><sup>2</sup> can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left|\\Pr[T_1^2] - \\Pr[T_1^1]\\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k). \\tag{16}</span>$</p>

    <p class="text-gray-300"><strong>Game</strong>  <span class="math">\\mathbf{G}_1^3</span> . To define game  <span class="math">\\mathbf{G}_1^3</span> , we again modify the challenge ciphertext: specifically, the value  <span class="math">u&#x27;&#x27;^*</span>  is now computed as  <span class="math">g^{r&#x27;&#x27;^*}</span> , for a random  <span class="math">r&#x27;&#x27;^* \\in \\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">To prove that  <span class="math">\\Pr[T_1^3] = \\Pr[T_1^2]</span> , we first consider all the quantities that can affect event  <span class="math">T_1^2</span>  in game  <span class="math">\\mathbf{G}_1^3</span>  and event  <span class="math">T_1^3</span>  in game  <span class="math">\\mathbf{G}_1^3</span> , and then we show that these quantities have the same joint distribution in both games.</p>

    <p class="text-gray-300">Let  <span class="math">D^{t^*}(\\cdot)</span>  and  <span class="math">E^{t^*}(\\cdot)</span>  be the randomizing polynomials used in the last New-period operation before the challenge ciphertext was created. (If no New-period occurred at all during the attack game, then let both  <span class="math">D^{t^*}(\\cdot)</span>  and  <span class="math">E^{t^*}(\\cdot)</span>  be just the zero polynomial.)</p>

    <p class="text-gray-300">Let  <span class="math">\\bar{t}</span>  be the total number of New-period operations that occur during the entire game, and for  <span class="math">t=1,\\ldots,\\bar{t}</span> , let  <span class="math">c_1^t,\\ldots,c_{2v+2}^t</span>  be the coefficients of the randomizing polynomials  <span class="math">D^t(\\cdot)</span>  and  <span class="math">E^t(\\cdot)</span>  used in the tth New-period operation. For  <span class="math">t=1,\\ldots,\\bar{t}</span> , and  <span class="math">j=1,\\ldots,2v+2</span> , let  <span class="math">r_j^t</span>  be the randomness used to encrypt (the encoding of) coefficient  <span class="math">c_j^t</span>  in the tth reset message.</p>

    <p class="text-gray-300">Observe that the challenge ciphertext  <span class="math">\\psi^*</span>  is the only value in the adversary's view which is computed differently in game  <span class="math">\\mathbf{G}_1^2</span>  and game  <span class="math">\\mathbf{G}_1^3</span> . In particular, such encryption is defined in terms of the values  <span class="math">r^*</span> ,  <span class="math">r&#x27;^*</span>  and  <span class="math">r&#x27;&#x27;^*</span> :  <span class="math">r^*</span>  and  <span class="math">r&#x27;^*</span>  are randomly chosen from  <span class="math">\\mathbb{Z}_q</span>  in both games, whereas  <span class="math">r&#x27;&#x27;^*</span>  is computed differently in the two games. For the sake of clarity, we will denote with  <span class="math">[r&#x27;&#x27;^*]_2</span>  and  <span class="math">[r&#x27;&#x27;^*]_3</span>  the value of such quantity in game  <span class="math">\\mathbf{G}_1^2</span>  and  <span class="math">\\mathbf{G}_1^3</span> , respectively. Notice that  <span class="math">[r&#x27;&#x27;^*]_2</span>  is a linear combination of  <span class="math">r^*</span> ,  <span class="math">r&#x27;^*</span>  (and other quantities), whereas  <span class="math">[r&#x27;&#x27;^*]_3</span>  is uniformly distributed in  <span class="math">\\mathbb{Z}_q</span> , independently of anything else.</p>

    <p class="text-gray-300">The rest of our analysis proceeds differently depending on whether the adversary's strategy caused the &quot;special&quot; New-period operation to occur or not. The case in which no New-period operation occurred at step 7. of the attack game is slightly simpler, so we discuss it first.</p>

    <p class="text-gray-300">Case 1. Consider the quantity</p>

    <p class="text-gray-300"><span class="math">$V \\doteq (\\mathsf{Coins}, w, \\{\\{c_i^t, r_i^t\\}_{i=1}^{2v+2}\\}_{t=1}^{\\bar{t}}, \\sigma^*, r^*, r&#x27;^*\\}</span>$</p>

    <p class="text-gray-300">where Coins represents the coin tosses of  <span class="math">\\mathcal{A}</span> ,  <span class="math">w \\doteq \\log_g g&#x27;</span> , and  <span class="math">\\sigma^*</span>  is the random bit chosen by the challenger in step 8. of the attack game.</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of the 2v+2 coefficients of the polynomials  <span class="math">A^0(\\cdot)</span> ,  <span class="math">B^0(\\cdot)</span>  and can be represented by a vector  <span class="math">\\boldsymbol{\\alpha}</span>  uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\alpha} \\doteq (a_0, a_1, \\dots, a_v, b_0, b_1, \\dots, b_v)^T.</span>$</p>

    <p class="text-gray-300">Consider the vector  <span class="math">\\boldsymbol{\\beta} \\in \\mathbb{Z}_q^{(2v+2)\\times 1}</span>  defined as:</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\beta} \\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_v, \\mathbf{A}_1, \\dots, \\mathbf{A}_v, r&#x27;&#x27;^*)^T</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_0 \\doteq A^0(0) + wB^0(0)</span> ,  <span class="math">\\mathbf{X}_\\ell \\doteq A^0(\\ell) + wB^0(\\ell)</span>  and  <span class="math">\\mathbf{A}_\\ell \\doteq A^0(x_\\ell)</span>  for  <span class="math">\\ell = 1, \\dots, v</span> , and  <span class="math">r&#x27;&#x27;^* \\doteq \\log_g u&#x27;&#x27;^*</span> . It is clear by inspection that all the information in the adversary's view is completely determined by V and  <span class="math">\\beta</span> . Thus, if the distribution of V and  <span class="math">\\beta</span>  is the same in both games  <span class="math">\\mathbf{G}_1^2</span>  and  <span class="math">\\mathbf{G}_1^3</span> , it will follow that  <span class="math">\\Pr[T_1^3] = \\Pr[T_1^2]</span> . Since the definition of  <span class="math">r&#x27;&#x27;^*</span>  is the only difference between game  <span class="math">\\mathbf{G}_1^2</span>  and  <span class="math">\\mathbf{G}_1^3</span> , and in  <span class="math">\\mathbf{G}_1^3</span>  the value of  <span class="math">[r&#x27;&#x27;^*]_3</span>  is chosen uniformly from  <span class="math">\\mathbb{Z}_q</span> , independently of anything else, it suffices to show that the distribution of  <span class="math">[r&#x27;&#x27;^*]_2</span> , conditioned on V and the first 2v+1 entries of  <span class="math">\\beta</span> , is also uniform in  <span class="math">\\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">In game  <span class="math">G_1^2</span> , the quantities in V,  <span class="math">\\beta</span>  and  <span class="math">\\alpha</span>  are related according to the following matrix equation:</p>

    <p class="text-gray-300"><span class="math">$[\\boldsymbol{\\beta}]_2 = \\mathbf{M} \\cdot \\boldsymbol{\\alpha} + \\boldsymbol{\\gamma}</span>$</p>

    <p class="text-gray-300">where  <span class="math">[\\boldsymbol{\\beta}]_2</span>  denotes the value of  <span class="math">\\boldsymbol{\\beta}</span>  in game  <span class="math">\\mathbf{G}_1^2</span>  (i.e. when the value of the last entry is  <span class="math">[r&#x27;&#x27;^*]_2</span> ),  <span class="math">\\boldsymbol{\\gamma} \\in \\mathbb{Z}_q^{(2v+2)\\times 1}</span>  is the vector</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\begin{aligned} \\gamma &amp; \\dot= \\left(\\begin{array}{ccc} 0 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(2v+2) \\times (2v+2)}</span>  is the matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{M} \\doteq \\begin{pmatrix} 1 &amp; 0 &amp; \\dots &amp; 0 &amp; w &amp; 0 &amp; \\dots &amp; 0 \\\\ 1 &amp; 1 &amp; \\dots &amp; 1 &amp; w &amp; w &amp; \\dots &amp; w \\\\ &amp; \\vdots &amp; &amp; &amp; \\vdots &amp; &amp; &amp; \\vdots \\\\ 1 &amp; v &amp; \\dots &amp; v^{v} &amp; w &amp; wv &amp; \\dots &amp; wv^{v} \\\\ 1 &amp; x_{1} &amp; \\dots &amp; x_{1}^{v} &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ &amp; \\vdots &amp; &amp; &amp; &amp; \\vdots &amp; &amp; &amp; \\vdots \\\\ 1 &amp; x_{v} &amp; \\dots &amp; x_{v}^{v} &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ r^{*} &amp; 0 &amp; \\dots &amp; 0 &amp; wr&#x27;^{*} &amp; 0 &amp; \\dots &amp; 0 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">The above matrix <strong>M</strong> is square, has full rank (provided that  <span class="math">r^* \\neq r&#x27;^*</span>  and  <span class="math">w \\neq 0</span> ) and it describes all the constraints on the (2v + 2) unknowns represented by  <span class="math">\\alpha</span> , that can be derived from the information in</p>

    <p class="text-gray-300">the adversary's view in  <span class="math">\\mathbf{G}_1^2</span> . In particular, the fact that no New-period operation occurred during execution of step 7. of the attack game guarantees that the identities included in the public key  <span class="math">PK^*</span>  that was used to create the challenge ciphertext  <span class="math">\\psi^*</span>  are exactly those of the users corrupted by the adversary. Hence, the constraints on  <span class="math">\\boldsymbol{\\alpha}</span>  arising from the last v components of the challenge ciphertext  <span class="math">\\psi^*</span>  can be obtained as linear combination of the constraints specified by  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">As soon as we fix a value for V, the first 2v+1 entries of vector  <span class="math">\\gamma</span>  and the first v+1 rows of matrix  <span class="math">\\mathbf{M}</span>  are completely fixed, but  <span class="math">\\alpha</span>  is still distributed uniformly and independently at random in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> . If we additionally fix the value of the first (v+1) components of  <span class="math">[\\boldsymbol{\\beta}]_2</span> , the initial public key  <span class="math">PK^0</span>  is fixed; it follows that the first identity  <span class="math">x_1</span>  that  <span class="math">\\mathcal{A}</span>  chooses to corrupt is also fixed and thus the (v+2)th row of  <span class="math">\\mathbf{M}</span>  is determined. Fixing also a value for  <span class="math">A_1</span>  (which is the (v+2)th entry of  <span class="math">[\\boldsymbol{\\beta}]_2</span> ), the value of  <span class="math">B_1</span>  is fixed too, so that all the information on which the adversary can base her choice of  <span class="math">x_2</span>  is fixed, and thus the (v+3)th row of  <span class="math">\\mathbf{M}</span>  is determined as well. By a similar reasoning, it follows that fixing the first  <span class="math">(v+\\ell+1)</span>  entries of  <span class="math">[\\boldsymbol{\\beta}]_2</span>  determines the  <span class="math">(v+\\ell+1)</span> th row of  <span class="math">\\mathbf{M}</span> , for  <span class="math">\\ell=1,\\ldots,v</span> . In particular, fixing all the entries of the  <span class="math">[\\boldsymbol{\\beta}]_2</span>  but the last, fixes all the information that adversary  <span class="math">\\boldsymbol{\\mathcal{A}}</span>  sees before asking for her challenge: thus, her choice of  <span class="math">M_0</span> ,  <span class="math">M_1</span>  is determined, so that the last entry of  <span class="math">\\boldsymbol{\\gamma}</span>  is fixed, too. Hence, by Lemma 1, we can conclude that the conditional distribution of  <span class="math">[r&#x27;&#x27;^*]_2</span> , w.r.t. V and to all the other components of  <span class="math">[\\boldsymbol{\\beta}]_2</span> , is also uniform over  <span class="math">\\mathbb{Z}_q</span> , from which it follows that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_1^3] = \\Pr[T_1^2]. \\tag{17}</span>$</p>

    <p class="text-gray-300">CASE 2. We now discuss the case in which the &quot;special&quot; New-period operation takes place: in particular, let  <span class="math">D^{\\hat{t}}(\\cdot)</span>  and  <span class="math">E^{\\hat{t}}(\\cdot)</span>  be the randomizing polynomials used in such New-period operation. Consider the quantity</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{V} \\doteq \\left(\\mathsf{Coins}, w, \\{c_j^t, r_j^t\\}_{\\substack{j = 1 \\\\ t \\neq \\hat{t}}}^{2v+2}, \\{s_j, r_j^{\\hat{t}}\\}_{\\substack{j=1 \\\\ j=1}}^{2v+2}, \\sigma^*, r^*, r&#x27;^*\\right)</span>$</p>

    <p class="text-gray-300">where Coins represents the coin tosses of  <span class="math">\\mathcal{A}, w \\doteq \\log_g g&#x27;, \\sigma^*</span>  is the random bit chosen by the challenger in step 8. of the attack game, and  <span class="math">s_1, \\ldots, s_{2v+2}</span>  are the random elements of  <span class="math">\\mathcal{G}</span>  that are encrypted by the &quot;special&quot; New-period operation in place of the randomizing coefficients  <span class="math">d_0^{\\hat{t}}, d_1^{\\hat{t}}, \\ldots, d_v^{\\hat{t}}</span> , and  <span class="math">e_0^{\\hat{t}}, e_1^{\\hat{t}}, \\ldots, e_v^{\\hat{t}}</span> .</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of these randomizing coefficients, along with the 2v+2 coefficients of the polynomials  <span class="math">A^0(\\cdot)</span> ,  <span class="math">B^0(\\cdot)</span>  and can be represented by a vector  <span class="math">\\boldsymbol{\\alpha}</span>  uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(4v+4)\\times 1}</span> , given in Figure 1.</p>

    <p class="text-gray-300">Consider the vector  <span class="math">\\boldsymbol{\\beta} \\in \\mathbb{Z}_q^{(4v+3)\\times 1}</span>  defined in Figure 1: it is clear by inspection that all the information in the adversary's view is completely determined by  <span class="math">\\boldsymbol{V}</span>  and  <span class="math">\\boldsymbol{\\beta}</span> . In particular, the initial public key  <span class="math">PK^0</span>  is fixed by  <span class="math">\\boldsymbol{\\beta}</span>  and w; the secret keys of the corrupted users are determined by the choice of  <span class="math">\\boldsymbol{\\beta}</span> , Coins and w; the &quot;special&quot; reset message is fixed by  <span class="math">PK^0</span> , Coins, and all the randomness in  <span class="math">\\boldsymbol{V}</span> ; the resulting public key  <span class="math">PK^{\\hat{t}}</span>  only depends on  <span class="math">\\boldsymbol{\\beta}</span>  and w; and the adversary's choice of  <span class="math">M_0</span>  and  <span class="math">M_1</span>  is fixed by  <span class="math">\\boldsymbol{V}</span>  and the first 4v+2 entries of  <span class="math">\\boldsymbol{\\beta}</span> .</p>

    <p class="text-gray-300">Thus, if the distribution of V and  <span class="math">\\beta</span>  is the same in both games  <span class="math">\\mathbf{G}_1^2</span>  and  <span class="math">\\mathbf{G}_1^3</span> , it will follow that  <span class="math">\\Pr[T_1^3] = \\Pr[T_1^2]</span> . Since the definition of  <span class="math">r&#x27;&#x27;^*</span>  is the only difference between game  <span class="math">\\mathbf{G}_1^2</span>  and  <span class="math">\\mathbf{G}_1^3</span> , and in  <span class="math">\\mathbf{G}_1^3</span>  the value of  <span class="math">[r&#x27;&#x27;^*]_3</span>  is chosen uniformly from  <span class="math">\\mathbb{Z}_q</span> , independently of anything else, it suffices to show that the distribution of  <span class="math">[r&#x27;&#x27;^*]_2</span> , conditioned on V and the first 4v + 2 entries of  <span class="math">\\beta</span> , is also uniform in  <span class="math">\\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">In game  <span class="math">G_1^2</span> , the quantities in  <span class="math">V, \\beta</span>  and  <span class="math">\\alpha</span>  are related according to the following matrix equation:</p>

    <p class="text-gray-300"><span class="math">$[\\boldsymbol{\\beta}]_2 = \\mathbf{M} \\cdot \\boldsymbol{\\alpha} + \\boldsymbol{\\gamma}</span>$</p>

    <p class="text-gray-300">where  <span class="math">[\\boldsymbol{\\beta}]_2</span>  denotes the value of  <span class="math">\\boldsymbol{\\beta}</span>  in game  <span class="math">\\mathbf{G}_1^2</span>  (i.e. when the value of the last entry is  <span class="math">[r&#x27;&#x27;^*]_2</span> ) and  <span class="math">\\boldsymbol{\\gamma} \\in \\mathbb{Z}_q^{(4v+3)\\times 1}</span>  and  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(4v+3)\\times (4v+4)}</span>  are defined in Figure 1.</p>

    <p class="text-gray-300">The matrix  <span class="math">\\mathbf{M}</span>  in Figure 1 describes all the constraints on the (4v+4) unknowns represented by  <span class="math">\\boldsymbol{\\alpha}</span> , that can be derived from the information in the adversary's view in game  <span class="math">\\mathbf{G}_1^2</span> . Notice that  <span class="math">\\mathbf{M}</span>  includes the constraints on  <span class="math">\\boldsymbol{\\alpha}</span>  arising from the last v components of the challenge ciphertext  <span class="math">\\psi^*</span> . Moreover, since we are assuming that the &quot;special&quot; New-period operation took place during the execution of step 7. of the attack game, and that the adversary never revokes the users she corrupts, the identities  <span class="math">z_1^*, \\ldots, z_v^*</span>  specified in the</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\alpha &amp;\\doteq (a_0, a_1, \\dots, a_v, b_0, b_1, \\dots, b_v, d_0^i, d_1^i, \\dots, d_v^i, e_0^i, e_1^i, \\dots, e_v^i)^T \\\\ \\beta &amp;\\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_v, \\hat{\\mathbf{X}}_0, \\hat{\\mathbf{X}}_1, \\dots, \\hat{\\mathbf{X}}_v, \\mathbf{A}_1, \\dots, \\mathbf{A}_v, \\mathbf{X}_1^*, \\dots, \\mathbf{X}_v^*, r&#x27;&#x27;^*)^T \\\\ \\begin{pmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0</span>$</p>

    <p class="text-gray-300">Fig. 1. Vectors  <span class="math">\\boldsymbol{\\alpha} \\in \\mathbb{Z}_q^{(4v+4)\\times 1}</span> ,  <span class="math">\\boldsymbol{\\beta} \\in \\mathbb{Z}_q^{(4v+3)\\times 1}</span>  and  <span class="math">\\boldsymbol{\\gamma} \\in \\mathbb{Z}_q^{(4v+3)\\times 1}</span>  and the matrix  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(4v+3)\\times (4v+4)}</span>  used in the last information-theoretic argument of Lemma 3. Notation:  <span class="math">r&#x27;&#x27;^* \\doteq \\log_g u&#x27;&#x27;^*</span> ,  <span class="math">\\mathbf{X}_0 \\doteq A^0(0) + wB^0(0)</span> ,  <span class="math">\\hat{\\mathbf{X}}_0 \\doteq A^{\\hat{t}}(0) + wB^{\\hat{t}}(0)</span> , and for  <span class="math">\\ell = 1, \\ldots, v</span> ,  <span class="math">\\mathbf{X}_\\ell \\doteq A^0(\\ell) + wB^0(\\ell)</span> ,  <span class="math">\\hat{\\mathbf{X}}_\\ell \\doteq A^{\\hat{t}}(\\ell) + wB^{\\hat{t}}(\\ell)</span> ,  <span class="math">\\mathbf{A}_\\ell \\doteq A^0(x_\\ell)</span>  and  <span class="math">\\mathbf{X}_\\ell^* \\doteq r^*A^{\\ell^*}(z_\\ell^*) + wr&#x27;^*B^{\\ell^*}(z_\\ell^*)</span> .</p>

    <p class="text-gray-300">public key  <span class="math">PK^{t^*}</span>  that is used to create the challenge ciphertext are all different from the identities  <span class="math">x_1, \\ldots, x_v</span>  of the corrupted users, so that <strong>M</strong> has full rank, provided that  <span class="math">r^* \\neq r&#x27;^*</span>  and  <span class="math">w \\neq 0</span> .</p>

    <p class="text-gray-300">As soon as we fix a value for V, the first 4v+2 entries of vector  <span class="math">\\gamma</span>  and the first 2v+2 rows of matrix  <span class="math">\\mathbf{M}</span>  are completely fixed, but  <span class="math">\\alpha</span>  is still distributed uniformly and independently at random in  <span class="math">\\mathbb{Z}_q^{(4v+4)\\times 1}</span> . If we additionally fix the value of the first (2v+2) components of  <span class="math">[\\boldsymbol{\\beta}]_2</span> , the initial public key  <span class="math">PK^0</span>  is fixed (in fact, the public key  <span class="math">PK^{\\hat{t}}</span>  resulting from the &quot;special&quot; New-period operation gets fixed, too); it follows that</p>

    <p class="text-gray-300">the first identity  <span class="math">x_1</span>  that  <span class="math">\\mathcal{A}</span>  chooses to corrupt is also fixed and thus the (2v+3)th row of  <span class="math">\\mathbf{M}</span>  is determined. Fixing also a value for  <span class="math">\\mathbf{A}_1</span>  (which is the (2v+3)th entry of  <span class="math">[\\boldsymbol{\\beta}]_2</span> ), the value of  <span class="math">\\mathbf{B}_1</span>  is fixed too, so that all the information on which the adversary can base her choice of  <span class="math">x_2</span>  is fixed, and thus the (2v+4)th row of  <span class="math">\\mathbf{M}</span>  is determined as well. By a similar reasoning, it follows that fixing the first  <span class="math">(2v+\\ell+2)</span>  entries of  <span class="math">[\\boldsymbol{\\beta}]_2</span>  determines the  <span class="math">(2v+\\ell+3)</span> th row of  <span class="math">\\mathbf{M}</span> , for  <span class="math">\\ell=1,\\ldots,v</span> . In particular, fixing the first 3v+2 entries of  <span class="math">[\\boldsymbol{\\beta}]_2</span>  fixes all the information that adversary  <span class="math">\\boldsymbol{\\mathcal{A}}</span>  sees before asking for her challenge: thus, the identities  <span class="math">z_1^*</span> ,  <span class="math">\\ldots</span> ,  <span class="math">z_v^*</span> , as well as the two messages  <span class="math">M_0</span> ,  <span class="math">M_1</span>  chosen by  <span class="math">\\boldsymbol{\\mathcal{A}}</span>  are determined, so that all the remaining rows of  <span class="math">\\mathbf{M}</span> , as well as the last entry of  <span class="math">\\boldsymbol{\\gamma}</span>  get fixed, too. Hence, by Lemma 1, we can conclude that the conditional distribution of  <span class="math">[r&#x27;&#x27;^*]_2</span> , w.r.t.  <span class="math">\\boldsymbol{V}</span>  and to all other components of  <span class="math">[\\boldsymbol{\\beta}]_2</span> , is uniform over  <span class="math">\\mathbb{Z}_q</span> , from which it follows that Equation (17) holds in this case, too.</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>1</sub><sup>4</sup>. Game <strong>G</strong><sub>1</sub><sup>4</sup> is defined to be identical to <strong>G</strong><sub>2</sub>. Thus, <strong>G</strong><sub>1</sub><sup>4</sup> differs from <strong>G</strong><sub>1</sub><sup>3</sup> only in that the values  <span class="math">u^*</span>  and  <span class="math">u&#x27;^*</span>  in the challenge ciphertext  <span class="math">\\psi^*</span>  are consistent, rather than being nearly independent, as in game <strong>G</strong><sub>1</sub><sup>3</sup>. Namely, the values  <span class="math">u^*</span>  and  <span class="math">u&#x27;^*</span>  are now computed as  <span class="math">u^* \\doteq g^{r^*}</span>  and  <span class="math">u&#x27;^* \\doteq g&#x27;^{r^*}</span> , for the same random  <span class="math">r^* \\in \\mathbb{Z}_q</span> . It follows that any difference in behavior between games <strong>G</strong><sub>1</sub><sup>3</sup> and <strong>G</strong><sub>1</sub><sup>4</sup> can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left|\\Pr[T_1^4] - \\Pr[T_1^3]\\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k). \\tag{18}</span>$</p>

    <p class="text-gray-300">Combining Equations (15), (16), (17) and (18), the thesis follows.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Dealing with Traceability</h2>

    <p class="text-gray-300">The goal of a tracing algorithm is to obtain the identity of at least one of the pirates who colluded in creating a given &quot;pirate decoder&quot; D which, as in previous work, is assumed to be stateless. In this section we present a formal model for traceability and two tracing algorithms that can be integrated within the scheme described in Section 4.</p>

    <p class="text-gray-300">The first method, a black-box algorithm, repeatedly calls a black-box confirmation subroutine that, given a pirate decryption device and a subset of at most m suspected users,<sup>5</sup> checks whether the suspected set includes all the user-keys that were used to generate the pirate device, and if so outputs the identity of one of the traitors.</p>

    <p class="text-gray-300">The second method, a non-black-box algorithm, receives as input a &quot;valid&quot; key extracted from a pirate device which was constructed using the keys of at most m users and deterministically recovers the identities of all the traitors.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Model for Traceability</h3>

    <p class="text-gray-300">The traceability adversary operates similarly to the revocation adversary described in Section 5. Namely, after receiving the initial public key of the system, adversary  <span class="math">\\mathcal{A}</span>  can interleave (in any adaptively-chosen order) up to m Join queries, upon which  <span class="math">\\mathcal{A}</span>  receives the secret keys of the corresponding users (the traitors), and a polynomial number of Revoke queries. Notice that each Revoke will change the public key, and the adversary monitors these changes as well. Also notice that the final set of revoked users is likely very different, and typically disjoint from the set  <span class="math">\\mathcal{T}</span>  of traitors. At the end,  <span class="math">\\mathcal{A}</span>  outputs a pirate decoder D which presumably works well (in some sense more precisely clarified below), with the final public key  <span class="math">PK_{\\mathcal{A}}</span> .</p>

    <p class="text-gray-300">FORMAL MODEL FOR TRACEABILITY ADVERSARY. We formalize the above attack scenario in terms of the traceability adversary attack game  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^{m}(1^{k})</span> , played between a challenger and the adversary.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\langle PK, MSK \\rangle := \\mathsf{Setup}(1^k)</span> . 2. Let  <span class="math">L := 0, \\mathcal{T} := \\emptyset</span> .</li>
    </ol>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup> Recall, m denotes the <em>collusion</em> threshold, and should not be confused with the <em>revocation</em> threshold v defined in Section 4; e.g., in our schemes  <span class="math">m = \\lfloor \\frac{v}{2} \\rfloor</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">state := \\langle L, PK, MSK, \\mathcal{T} \\rangle</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">D \\leftarrow \\mathcal{A}^{\\mathsf{Join}(state,\\cdot)}, \\mathsf{Revoke}(state,\\cdot)(state.PK).</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">|\\mathcal{T}| &gt; m</span>  then exit.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse state as  <span class="math">\\langle L, PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, \\mathcal{T} \\rangle</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\langle D, PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, \\mathcal{T} \\rangle</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The definitions of the Join and Revoke oracles is the same as in Section 5.1, except that the role of the set Corr is now played by the set  <span class="math">\\mathcal{T}</span> .</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> For any public key PK, define the success probability of a decoder D as:</p>

    <p class="text-gray-300"><span class="math">$Succ_{PK}(\\mathsf{D}) \\doteq \\Pr[M&#x27; = M \\mid M \\xleftarrow{r} \\mathcal{G}; \\psi^* \\xleftarrow{r} \\mathcal{E}(PK, M); M&#x27; \\xleftarrow{r} \\mathsf{D}(\\psi^*)]</span>$</p>

    <p class="text-gray-300">where the probability is over the random choice of M, the randomness used to create the challenge ciphertext  <span class="math">\\psi^*</span>  and the coin tosses of D.</p>

    <p class="text-gray-300">Notice that the pirate decoder D expects to receive a ciphertext created under the public key  <span class="math">PK_A</span> , but the quantity  <span class="math">Succ_{PK}(D)</span>  can be defined for any public key anyway. Clearly, if D could notice the change, then it could stop working properly: in this case we can assume that it outputs a message  <span class="math">M&#x27; \\neq M</span> .</p>

    <p class="text-gray-300">The job of the tracing algorithm is to find one or all of the (at most) m traitors whose keys were used by A in building D. The precise security guarantees depend on whether tracing is black-box or not. We describe both tracing methods in Section 6.2 and 6.3, respectively.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Black-Box Tracing</h3>

    <p class="text-gray-300">In the black-box model, the tracing algorithm is only allowed to query the pirate decoder D on a polynomial number of a random-looking ciphertexts, and from the plain observation of D's input/output behavior, the tracing algorithm should successfully in identifying (at least) one of the traitors.</p>

    <p class="text-gray-300">This form of tracing is the most desirable, as it can be applied to any stateless pirate decoder. Similarly to previous work [3, 19, 21], though, the algorithm presented below only achieves a weaker variant of black-box tracing, called black-box confirmation. Informally, a black-box confirmation algorithm is a subroutine that tests whether a given set Susp of at most m suspected users does include all the traitors that cooperated to construct a given pirate decoder D, and if so, it outputs at least one such pirate. On a pessimistic note, this means that our tracing algorithm might have to go through all m-element subsets of the user universe  <span class="math">\\mathcal U</span>  to do full-fledged tracing. However, we point out that: (1) in many cases a lot of partial information about the set of corrupted users makes the search space dramatically smaller; (2) all previous public-key traitor tracing schemes suffer from the same problem; (3) as observed in [14], the problem seems to be inherent to this setting.</p>

    <p class="text-gray-300">However, we significantly improve upon previous black-box confirmation algorithms in the following respects: (1) formal modeling of the problem; (2) our algorithm allows the adversary to adaptively corrupt players before building the pirate decoder; (3) our algorithm can be successfully applied to pirate decoders that work on at least an  <span class="math">\\varepsilon</span> -fraction of correctly formed messages (rather than with probability 1), where  <span class="math">\\varepsilon</span>  is the desired threshold below which the decoder is considered &quot;useless&quot; (following the &quot;threshold tracing&quot; approach of [18]).</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Definition 9 (Black-Box Confirmation Algorithm).</h4>

    <p class="text-gray-300">A Black-Box Confirmation (BBC) algorithm is a probabilistic, polynomial time oracle machine, taking as oracle input a pirate decoder D, and as regular input a public key PK, the corresponding master secret key MSK, and a set Susp of suspected traitors. Its output is either a user's identity i or the special symbol?.</p>

    <h3 id="sec-misc-5" class="text-xl font-semibold mt-8">Definition 10 ( <span class="math">\\varepsilon</span> -Black-Box Confirmation Property).</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}</span>  be any probabilistic, polynomial-time adversary, and let  <span class="math">\\langle \\mathsf{D}, PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, T \\rangle</span>  be the output resulting from the adversary playing the traceability attack game  <span class="math">G^m_{\\mathsf{trt}}(1^k)</span>  with the challenger. A Black-Box Confirmation algorithm BBC satisfies  <span class="math">\\varepsilon</span> -Black-Box Confirmation if for any PPT adversary  <span class="math">\\mathcal{A}</span>  playing the  <span class="math">G^m_{\\mathsf{trt}}(1^k)</span>  game, the following two properties hold with all but negligible probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Confirmation: whenever  <span class="math">\\mathcal{T} \\subseteq \\mathsf{Susp}</span> , then the output of  <span class="math">\\mathsf{BBC}^\\mathsf{D}(PK_\\mathcal{A}, MSK_\\mathcal{A}, \\mathsf{Susp})</span>  is some identity  <span class="math">i \\in \\mathcal{T}</span> .</li>
      <li>Soundness: whenever  <span class="math">BBC^D(PK_A, MSK_A, Susp)</span>  outputs  <span class="math">i \\neq ?</span> , then  <span class="math">i \\in \\mathcal{T}</span> .</li>
    </ul>

    <p class="text-gray-300">Black-Box Confirmation Algorithm At a high level, our black-box confirmation algorithm BBC works as follows. Based on the current set I of suspected users (initially set to Susp) and using the master secret key  <span class="math">MSK_A</span> , it modifies the public key  <span class="math">PK_A</span>  into a fake public key PK(I). It then estimates the probability</p>

    <p class="text-gray-300"><span class="math">$\\delta(I) \\doteq \\mathsf{Succ}_{PK(I)}(\\mathsf{D})</span>$</p>

    <p class="text-gray-300">by observing the behavior of D when fed with encryptions of the form  <span class="math">\\mathcal{E}(PK(I), M)</span> , for random messages M. The Chernoff bound implies that the latter estimation can be done quickly and accurately (by computing statistics from repeated sampling), provided  <span class="math">\\delta(I)</span>  is &quot;large enough&quot; (specifically, at least  <span class="math">\\varepsilon/m</span> ). Now, BBC takes any index  <span class="math">i \\in I</span> , and accurately estimates  <span class="math">\\delta(I \\setminus \\{i\\})</span> . If the difference between  <span class="math">\\delta(I)</span>  and  <span class="math">\\delta(I \\setminus \\{i\\})</span>  is &quot;non-trivial&quot; (specifically, at least  <span class="math">\\varepsilon/2m</span> ), it proclaims i as a traitor. Otherwise, it sets  <span class="math">I := I \\setminus \\{i\\}</span> , and repeats the entire procedure until  <span class="math">I = \\emptyset</span>  (in which case it outputs?).</p>

    <p class="text-gray-300">The last main detail to be filled in is how the algorithm generates the fake public key PK(I). Recall from Section 4 that the master secret key  <span class="math">MSK_{\\mathcal{A}}</span>  consists of two random polynomials over  <span class="math">\\mathbb{Z}_q^v[x]</span> . Let  <span class="math">\\bar{t}</span>  be the total number of New-period operations that occur during the entire game, and for  <span class="math">t=1,\\ldots,\\bar{t}</span> , let  <span class="math">c_1^t,\\ldots,c_{2v+2}^t</span>  be the coefficients of the randomizing polynomials  <span class="math">D^t(\\cdot)</span>  and  <span class="math">E^t(\\cdot)</span>  used in the tth New-period operation. For  <span class="math">t=1,\\ldots,\\bar{t}</span> , and  <span class="math">j=1,\\ldots,2v+2</span> , let  <span class="math">r_j^t</span>  be the randomness used to encrypt (the encoding of) coefficient  <span class="math">c_j^t</span>  in the tth reset message. By Equation (8),  <span class="math">(A^{\\bar{t}}(\\cdot),B^{\\bar{t}}(\\cdot))</span>  denotes the master secret key corresponding to the public key  <span class="math">PK_{\\mathcal{A}}</span> . Given the set I, we create two polynomials  <span class="math">A&#x27;(\\cdot)</span>  and  <span class="math">B&#x27;(\\cdot)</span>  uniformly distributed over  <span class="math">\\mathbb{Z}_q^v[x]</span>  except they agree with  <span class="math">A^{\\bar{t}}(\\cdot)</span>  and  <span class="math">B^{\\bar{t}}(\\cdot)</span>  on points in I:</p>

    <p class="text-gray-300"><span class="math">$A&#x27;(x_s) = A^{\\bar{t}}(x_s)</span>$
<span class="math">B&#x27;(x_s) = B^{\\bar{t}}(x_s), \\forall s \\in I.</span></p>

    <p class="text-gray-300">Notice that, since  <span class="math">|I| \\le m \\le v/2</span> , this creates no problem. We then create the public key PK(I) as if the master secret key were  <span class="math">MSK&#x27; = (A&#x27;(\\cdot), B&#x27;(\\cdot))</span>  rather than  <span class="math">MSK_A = (A^{\\bar{t}}(\\cdot), B^{\\bar{t}}(\\cdot))</span> . Specifically, we define</p>

    <p class="text-gray-300"><span class="math">$PK(I) \\doteq (g, g&#x27;, y&#x27;, \\langle z_{\\ell}, h&#x27;_{\\ell} \\rangle_{\\ell=1}^{v}).</span>$</p>

    <p class="text-gray-300">where  <span class="math">y&#x27; \\doteq q^{A&#x27;(0)} \\cdot q&#x27;^{B&#x27;(0)}</span> , and  <span class="math">h&#x27;_{\\ell} \\doteq q^{A&#x27;(z_{\\ell})} \\cdot q&#x27;^{B&#x27;(z_{\\ell})}</span> , for  <span class="math">\\ell = 1, \\dots, v</span> .</p>

    <p class="text-gray-300">Correctness of Black-Box Tracing The correctness of the black-box tracing algorithm described above follows from Theorem 2 and Theorem 3 stated below. Theorem 2 implies that if the decoder was useful at the start (i.e.,  <span class="math">\\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D}) \\geq \\varepsilon</span> ) and  <span class="math">\\mathcal{T} \\subseteq \\mathsf{Susp}</span> , then the decoder cannot &quot;notice&quot; that  <span class="math">PK_{\\mathcal{A}}</span>  was changed to  <span class="math">PK(\\mathsf{Susp})</span> , i.e.  <span class="math">\\delta(\\mathsf{Susp}) \\gtrsim \\varepsilon</span> . Coupled with the obvious fact that  <span class="math">\\delta(\\emptyset)</span>  is negligible (since M is encrypted with a totally random one-time pad), we see that there must be a time when  <span class="math">\\delta(I)</span>  changes by a non-trivial amount (i.e., at least by  <span class="math">\\varepsilon/2m</span> ) when we remove some  <span class="math">i \\in I</span> . This i will then be output by our algorithm, and since i cannot be an innocent user (by Theorem 3 below), i must be one of the traitors. This shows the confirmation property.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Under the DDH assumption, if  <span class="math">T \\subseteq \\mathsf{Susp}</span>  and  <span class="math">|\\mathsf{Susp}| \\leq v</span> , then  <span class="math">|\\delta(\\mathsf{Susp}) - \\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D})|</span>  is negligible.</p>

    <p class="text-gray-300">Proof. We again follow the structural approach of defining a sequence of &quot;indistinguishable&quot; games  <span class="math">G_0, G_1, \\ldots</span> , all operating over the same underlying probability space. Each of these games consists of the BBC algorithm sending a ciphertext  <span class="math">\\psi^*</span>  to the pirate decoder D; different games only differs in the way  <span class="math">\\psi^*</span>  is computed. In the original game  <span class="math">G_0</span> , the goal of the decoder D is to output a message M' which is D's best guess at the random message M encrypted within  <span class="math">\\psi^*</span> ; for each game  <span class="math">G_j</span> , let  <span class="math">T_j</span>  be the event that M = M' in  <span class="math">G_j</span> .</p>

    <p class="text-gray-300">The relation  <span class="math">\\gtrsim</span>  is meant to indicate that  <span class="math">\\delta(\\mathsf{Susp})</span>  is greater than  <span class="math">\\varepsilon</span>  minus negligible terms.</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>0</sub>: This game defines the probability  <span class="math">\\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D})</span> . In this game, the BBC algorithm takes as input the public key  <span class="math">PK_{\\mathcal{A}}</span> , the corresponding master secret key  <span class="math">MSK_{\\mathcal{A}}</span>  and a set  <span class="math">\\mathsf{Susp}</span>  of suspected users; it then chooses a message  <span class="math">M \\stackrel{r}{\\leftarrow} \\mathcal{G}</span>  and, using the public key  <span class="math">PK_{\\mathcal{A}}</span> , encrypts it as follows:</p>

    <p class="text-gray-300">E1.
<span class="math">$r \\leftarrow \\mathbb{Z}_q</span>$</p>

    <p class="text-gray-300">E2.  <span class="math">u \\leftarrow g^r</span>
E3.  <span class="math">u&#x27; \\leftarrow g&#x27;^r</span>
E4.  <span class="math">u&#x27;&#x27; \\leftarrow M \\cdot g^{A^{\\bar{t}}(0)r} g&#x27;^{B^{\\bar{t}}(0)r}</span>
E5.  <span class="math">u_{\\ell} \\leftarrow g^{A^{\\bar{t}}(z_{\\ell})r} g&#x27;^{B^{\\bar{t}}(z_{\\ell})r}, \\quad \\ell = 1, \\dots, v</span>
E6.  <span class="math">\\psi^* \\leftarrow \\langle u, u&#x27;, u&#x27;&#x27;, \\langle z_1, u_1 \\rangle, \\dots, \\langle z_v, u_v \\rangle \\rangle</span></p>

    <p class="text-gray-300">By definition, we have that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_0] = \\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D}). \\tag{19}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>1</sub>: Game <strong>G</strong><sub>1</sub> is identical to game <strong>G</strong><sub>0</sub>, except that in game <strong>G</strong><sub>1</sub> steps E4 and E5 are substituted with:</p>

    <p class="text-gray-300">E4'.
<span class="math">$u&#x27;&#x27; \\leftarrow M \\cdot u^{A^{\\bar{t}}(0)} u&#x27;^{B^{\\bar{t}}(0)}</span>$</p>

    <p class="text-gray-300">E5'.  <span class="math">u_{\\ell} \\leftarrow u^{A^{\\bar{t}}(z_{\\ell})} u&#x27;^{B^{\\bar{t}}(z_{\\ell})}</span> .  <span class="math">\\ell = 1, \\dots, v</span></p>

    <p class="text-gray-300">Notice that the point of these changes is just to make explicit any functional dependency of  <span class="math">\\psi^*</span>  on the quantities u and u'. Since we just made a conceptual change, it clearly holds that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_1] = \\Pr[T_0]. \\tag{20}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>2</sub>: To define game  <span class="math">G_2</span> , we make more changes to the encryption algorithm as follows:</p>

    <p class="text-gray-300">E1'.
<span class="math">$r \\leftarrow \\mathbb{Z}_q</span>$
;  <span class="math">r&#x27; \\leftarrow \\mathbb{Z}_q \\setminus \\{r\\}</span>
E3'.  <span class="math">u&#x27; \\leftarrow q&#x27;^{r&#x27;}</span></p>

    <p class="text-gray-300">Notice that while in game  <span class="math">\\mathbf{G}_1</span>  the value u and u' are obtained using the same value r, in game  <span class="math">\\mathbf{G}_2</span>  they are nearly independent, being subject only to  <span class="math">r \\neq r&#x27;</span> . Therefore, using a standard reduction argument, any non-negligible difference in behavior between games  <span class="math">\\mathbf{G}_1</span>  and  <span class="math">\\mathbf{G}_2</span>  can be used to construct a PPT adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_2] - \\Pr[T_1] \\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k). \\tag{21}</span>$</p>

    <p class="text-gray-300"><strong>Game</strong>  <span class="math">G_3</span> : To turn game  <span class="math">G_2</span>  into game  <span class="math">G_3</span> , we consider the set Susp and construct the public key PK(Susp) as described above; specifically, two random polynomials  <span class="math">A&#x27;(\\cdot)</span>  and  <span class="math">B&#x27;(\\cdot)</span>  are chosen such that</p>

    <p class="text-gray-300"><span class="math">$A&#x27;(x_s) = A^{\\bar{t}}(x_s) \\quad B&#x27;(x_s) = B^{\\bar{t}}(x_s), \\ \\forall s \\in \\mathsf{Susp}</span>$</p>

    <p class="text-gray-300">and PK(Susp) is set to be:</p>

    <p class="text-gray-300"><span class="math">$PK(\\mathsf{Susp}) \\doteq \\langle g, g&#x27;, g^{A&#x27;(0)} g&#x27;^{B&#x27;(0)}, \\langle z_\\ell, g^{A&#x27;(z_\\ell)} g&#x27;^{B&#x27;(z_\\ell)} \\rangle_{\\ell=1}^v \\rangle.</span>$</p>

    <p class="text-gray-300">Then, we change steps E4' and E5' of the encryption algorithm of game  <span class="math">\\mathbf{G}_2</span>  as follows:</p>

    <p class="text-gray-300">E4&quot;.
<span class="math">$u&#x27;&#x27; \\leftarrow M \\cdot u^{A&#x27;(0)} u&#x27;^{B&#x27;(0)}</span>$</p>

    <p class="text-gray-300">E5&quot;.  <span class="math">u_{\\ell} \\leftarrow u^{A&#x27;(z_{\\ell})} u&#x27;^{B&#x27;(z_{\\ell})}, \\quad \\ell = 1, \\dots, v</span></p>

    <p class="text-gray-300">Using the technique outlined in Section 5.2, in Lemma 4 below, we show that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_3] = \\Pr[T_2]. \\tag{23}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>4</sub>: In game  <span class="math">\\mathbf{G}_4</span> , we &quot;undo&quot; the changes of game  <span class="math">\\mathbf{G}_2</span> , restoring lines E1 and E3 of the encryption oracle to their original values:</p>

    <p class="text-gray-300"><span class="math">$E1&#x27;&#x27;</span>$
.  <span class="math">r \\leftarrow \\mathbb{Z}_q</span>
<span class="math">E3&#x27;&#x27;</span> .  <span class="math">u&#x27; \\leftarrow g&#x27;^r</span></p>

    <p class="text-gray-300">Notice that in game  <span class="math">G_4</span>  the value u and u' are again obtained using the same value r, whereas in game  <span class="math">G_3</span>  they are nearly independent, being subject only to  <span class="math">r \\neq r&#x27;</span> . Therefore, using a standard reduction argument, any non-negligible difference in behavior between games  <span class="math">G_3</span>  and  <span class="math">G_4</span>  can be used to construct a PPT adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_4] - \\Pr[T_3] \\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k).</span>$
(24)</p>

    <p class="text-gray-300">Finally, observe that in  <span class="math">G_4</span>  the encryption of the random message M is obtained using the public key PK(Susp): thus, game  <span class="math">G_4</span>  is exactly the game which defines the probability  <span class="math">\\delta(Susp)</span>  i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_4] = \\delta(\\mathsf{Susp}). \\tag{25}</span>$</p>

    <p class="text-gray-300">&#1055;</p>

    <p class="text-gray-300">Combining Equations (19), (20), (21), (23), (24) and (25), we can conclude that  <span class="math">\\mathcal{A}</span>  has only a negligible chance to tell whether the message M was encrypted under the public keys  <span class="math">PK_{\\mathcal{A}}</span>  or  <span class="math">PK(\\mathsf{Susp})</span> ; more precisely:</p>

    <p class="text-gray-300"><span class="math">$|\\delta(\\mathsf{Susp}) - \\mathsf{Succ}_{PK_{A}}(\\mathsf{D})| \\leq 2 \\; \\mathsf{AdvDDH}_{\\mathcal{G}}(k).</span>$</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong>  <span class="math">Pr[T_3] = Pr[T_2]</span></p>

    <p class="text-gray-300"><em>Proof.</em> To prove the Lemma, we consider all the quantities that can affect event  <span class="math">T_2</span>  in game  <span class="math">\\mathbf{G}_2</span>  and event  <span class="math">T_3</span>  in game  <span class="math">\\mathbf{G}_3</span> , and then we show that these quantities are distributed according to the same joint distribution in both games.</p>

    <p class="text-gray-300">Consider the quantity:</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{V} \\doteq (\\mathsf{Coins}_{\\mathcal{A}}, \\mathsf{Coins}_{\\mathsf{D}}, w, M, r, r&#x27;, \\{\\{\\boldsymbol{c}_j^t, r_j^t\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}})</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span>  denotes the coin tosses of  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathsf{Coins}_{\\mathsf{D}}</span>  denotes the coin tosses of  <span class="math">\\mathsf{D}</span> ,  <span class="math">w \\doteq \\log_g g&#x27;</span> , M is the random message encrypted within  <span class="math">\\psi^*</span> , r and r' are the random values used to create  <span class="math">\\psi^*</span> , and</p>

    <p class="text-gray-300"><span class="math">$\\{\\{c_j^t, r_j^t\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}}</span>$</p>

    <p class="text-gray-300">represents all the randomness used in the  <span class="math">\\bar{t}</span>  New-period operations that took place during the  <span class="math">\\mathbf{G}_{\\mathsf{trt}}^m(1^k)</span>  attack game.</p>

    <p class="text-gray-300">The remaining randomness used during games  <span class="math">\\mathbf{G}_2</span>  and  <span class="math">\\mathbf{G}_3</span>  consists of the 4v+4 coefficients of the polynomials  <span class="math">A^0(\\cdot)</span> ,  <span class="math">B^0(\\cdot)</span>  (chosen by the Setup algorithm in step 1. of the  <span class="math">\\mathbf{G}^m_{\\mathrm{trt}}(1^k)</span>  attack game) and  <span class="math">A&#x27;(\\cdot)</span> ,  <span class="math">B&#x27;(\\cdot)</span>  (used in game  <span class="math">\\mathbf{G}_3</span> ). This randomness can be represented with the vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\alpha} \\doteq (a_0, a_1, \\dots, a_v, b_0, b_1, \\dots, b_v)^T</span>$</p>

    <p class="text-gray-300">which is uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> , and the vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\alpha}&#x27; \\doteq (a_0&#x27;, a_1&#x27;, \\dots, a_v&#x27;, b_0&#x27;, b_1&#x27;, \\dots, b_v&#x27;)^T</span>$</p>

    <p class="text-gray-300">which is uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> , subject to the constraints arising from imposing Equation (22). Let  <span class="math">\\mathcal{T} = \\{t_1, \\dots, t_m\\}</span>  be the set of traitors and set</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}_j \\doteq A^{\\bar{t}}(x_{t_i}) \\quad \\mathbf{B}_j \\doteq B^{\\bar{t}}(x_{t_i}), \\ j = 1, \\dots, m.</span>$</p>

    <p class="text-gray-300">Notice that, since  <span class="math">\\mathcal{T} \\subseteq \\mathsf{Susp}</span> , for  <span class="math">j = 1, \\dots, m</span> , it holds that  <span class="math">\\mathbf{A}_j = A&#x27;(x_{t_j})</span>  and  <span class="math">\\mathbf{B}_j = B&#x27;(x_{t_j})</span> . Consider the quantity  <span class="math">\\bar{\\beta} \\in \\mathbb{Z}_q^{(v+m+1)\\times 1}</span>  defined as:</p>

    <p class="text-gray-300"><span class="math">$\\bar{\\boldsymbol{\\beta}} \\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_v, \\mathbf{A}_1, \\dots, \\mathbf{A}_m)^T</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_0 \\doteq A^0(0) + wB^0(0)</span> , and  <span class="math">\\mathbf{X}_{\\ell} \\doteq A^0(\\ell) + wB^0(\\ell)</span> , for  <span class="math">\\ell = 1, \\dots, v</span> .</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the view of the adversary  <span class="math">\\mathcal{A}</span>  during the attack game  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^m(1^k)</span>  is completely determined by  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\bar{\\boldsymbol{\\beta}}</span> . In particular, the initial public key  <span class="math">PK^0</span>  is fixed by  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and w, and the secret keys of the traitors are determined by the choice of  <span class="math">\\bar{\\boldsymbol{\\beta}}</span> ,  <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span>  and w.</p>

    <p class="text-gray-300">Besides the information in  <span class="math">\\mathcal{A}</span> 's view, which is completely determined by the value of V and  <span class="math">\\bar{\\beta}</span> , the only other quantity affecting D's behavior is the ciphertext  <span class="math">\\psi^*</span> . This ciphertext is computed differently in games  <span class="math">\\mathbf{G}_2</span>  and  <span class="math">\\mathbf{G}_3</span> : for the sake of clarity, we will denote with  <span class="math">[\\psi^*]_2</span>  and  <span class="math">[\\psi^*]_3</span>  the value of such quantity in game  <span class="math">\\mathbf{G}_2</span>  and  <span class="math">\\mathbf{G}_3</span> , respectively. We now want to show that, conditioned on all the other information in D's view,  <span class="math">[\\psi^*]_2</span>  and  <span class="math">[\\psi^*]_3</span>  are distributed according to the same distribution in the two games.</p>

    <p class="text-gray-300">In game  <span class="math">\\mathbf{G}_2</span> , the ciphertext  <span class="math">[\\psi^*]_2</span>  sent to the decoder is completely determined by  <span class="math">\\mathbf{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and by the v-degree polynomial  <span class="math">X^{\\bar{t}}(\\cdot) \\doteq rA^{\\bar{t}}(\\cdot) + wr&#x27;B^{\\bar{t}}(\\cdot)</span> . Similarly, in game  <span class="math">\\mathbf{G}_3</span> , the ciphertext  <span class="math">[\\psi^*]_3</span>  is completely determined by  <span class="math">\\mathbf{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and by the v-degree polynomial  <span class="math">X&#x27;(\\cdot) \\doteq rA&#x27;(\\cdot) + wr&#x27;B&#x27;(\\cdot)</span> . Moreover,  <span class="math">[\\psi^*]_2</span>  depends on  <span class="math">\\mathbf{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and  <span class="math">X^{\\bar{t}}(\\cdot)</span>  according to the same functional dependence of  <span class="math">[\\psi^*]_3</span>  upon  <span class="math">\\mathbf{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and  <span class="math">X&#x27;(\\cdot)</span> . Therefore, to prove the Lemma, it suffices to show that, conditioning on any fixed values of  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\bar{\\boldsymbol{\\beta}}</span> ,  <span class="math">X^{\\bar{t}}(\\cdot)</span>  and  <span class="math">X&#x27;(\\cdot)</span>  are distributed according to the same conditional probability distribution; namely, both are random polynomials over  <span class="math">\\mathbb{Z}_q^v[x]</span> , subject to the constraint that their values at  <span class="math">x_{t_i}</span>  is  <span class="math">r\\mathbf{A}_j + wr&#x27;\\mathbf{B}_j</span> , for  <span class="math">j = 1, \\ldots, m</span> .</p>

    <p class="text-gray-300">By Lagrange interpolation,  <span class="math">X^{\\bar{t}}(\\cdot)</span>  can be identified with its value at the points 0, 1, ..., v-m,  <span class="math">x_{t_1}</span> , ...,  <span class="math">x_{t_m}</span> ; define</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}_{\\ell}^{\\bar{t}} \\doteq X^{\\bar{t}}(\\ell), \\ \\ell = 0, \\dots, v - m</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}_{v-m+j}^{\\bar{t}} \\doteq X^{\\bar{t}}(x_{i_j}), \\ j = 1, \\dots, m.</span>$</p>

    <p class="text-gray-300">Similarly, we can also identify  <span class="math">X&#x27;(\\cdot)</span>  with its value at the same v+1 points; define</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}&#x27;_{\\ell} \\doteq X&#x27;(\\ell), \\ \\ell = 0, \\dots, v - m</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}&#x27;_{v-m+j} \\doteq X&#x27;(x_{t_j}), \\ j = 1, \\dots, m.</span>$</p>

    <p class="text-gray-300">As noticed above, the assumption that  <span class="math">\\mathcal{T} \\subseteq \\mathsf{Susp}</span>  implies that for  <span class="math">j = 1, \\ldots, m</span> :</p>

    <p class="text-gray-300"><span class="math">$A^{\\bar{t}}(x_{t_j}) = A&#x27;(x_{t_j}) = \\mathbf{A}_j, \\quad B^{\\bar{t}}(x_{t_j}) = B&#x27;(x_{t_j}) = \\mathbf{B}_j.</span>$</p>

    <p class="text-gray-300">Therefore, it follows that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}_{v-m+j} = \\mathbf{X}&#x27;_{v-m+j}, \\ j = 1, \\dots, m.</span>$
(26)</p>

    <p class="text-gray-300">It only remains to be proven that, conditioning on fixed values of V and  <span class="math">\\bar{\\beta}</span> , the tuple  <span class="math">\\mathbf{X}_0^{\\bar{t}}, \\ldots, \\mathbf{X}_{v-m}^{\\bar{t}}</span>  and the tuple  <span class="math">\\mathbf{X}_0&#x27;, \\ldots, \\mathbf{X}_{v-m}&#x27;</span>  are distributed according to same joint conditional distribution. (Notice that fixing a value for V and  <span class="math">\\bar{\\beta}</span> , immediately fixes a value for the tuple  <span class="math">\\mathbf{X}_{v-m+j}^{\\bar{t}}, j=1,\\ldots,m</span> , which by (26) is equal to  <span class="math">\\mathbf{X}_{v-m+j}&#x27;, j=1,\\ldots,m</span> .)</p>

    <p class="text-gray-300">Recall that, in game  <span class="math">\\mathbf{G}_3</span> , the polynomials  <span class="math">A&#x27;(\\cdot)</span>  and  <span class="math">B&#x27;(\\cdot)</span>  are chosen uniformly at random from  <span class="math">\\mathbb{Z}_q^v[x]</span> , independently from anything else, but subject to the constraints in (22). Thus, the polynomial  <span class="math">X&#x27;(\\cdot) = rA&#x27;(\\cdot) + wr&#x27;B&#x27;(\\cdot)</span>  is also random in  <span class="math">\\mathbb{Z}_q^v[x]</span> , subject to the constraint that its value at  <span class="math">x_s</span>  is</p>

    <p class="text-gray-300"><span class="math">$rA^{\\bar{t}}(x_s) + wr&#x27;B^{\\bar{t}}(x_s), \\ \\forall s \\in \\mathsf{Susp}.</span>$</p>

    <p class="text-gray-300">Therefore, conditioning on fixed values of V and  <span class="math">\\bar{\\beta}</span> , the tuple  <span class="math">\\mathbf{X}&#x27;_0, \\ldots, \\mathbf{X}&#x27;_{v-m}</span>  is distributed uniformly at random in  <span class="math">\\mathbb{Z}_q^{(v-m+1)\\times 1}</span> . Hence, it suffices to show that, for  <span class="math">\\ell=0,\\ldots,v-m</span> , the conditional distribution of  <span class="math">\\mathbf{X}_{\\ell}^{\\bar{t}}</span>  w.r.t. V,  <span class="math">\\bar{\\beta}</span>  and  <span class="math">\\mathbf{X}_0^{\\bar{t}},\\ldots,\\mathbf{X}_{\\ell-1}^{\\bar{t}}</span>  is uniform over  <span class="math">\\mathbb{Z}_q</span> . To this aim, fix  <span class="math">\\ell \\in \\{0,\\ldots,v-m\\}</span> , and consider the following matrix equation:</p>

    <p class="text-gray-300"><span class="math">$\\beta_{\\ell} = \\mathbf{M}_{\\ell} \\cdot \\boldsymbol{\\alpha} + \\boldsymbol{\\gamma}_{\\ell}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\boldsymbol{\\beta}_{\\ell} \\in \\mathbb{Z}_q^{(v+m+\\ell+2)\\times 1}</span>  is the vector</p>

    <p class="text-gray-300">is the vector
<span class="math">$\\boldsymbol{\\beta}_\\ell \\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_v, \\mathbf{A}_1, \\dots, \\mathbf{A}_m, \\mathbf{X}_0^{\\bar{t}}, \\mathbf{X}_1^{\\bar{t}}, \\dots, \\mathbf{X}_\\ell^{\\bar{t}})^T,</span>$</p>

    <p class="text-gray-300"><span class="math">\\gamma_{\\ell} \\in \\mathbb{Z}_q^{(v+m+\\ell+2) \\times 1}</span>  is the vector</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\begin{aligned} \\gamma_{\\ell} &amp;\\doteq \\begin{pmatrix} 0 \\ 0 \\ D^{0,\\bar{t}}(x_{t_1}) \\ &amp;\\vdots \\ D^{0,\\bar{t}}(x_{t_m}) \\ rD^{0,\\bar{t}}(0) + wr&#x27;E^{0,\\bar{t}}(0) \\ rD^{0,\\bar{t}}(1) + wr&#x27;E^{0,\\bar{t}}(1) \\ &amp;\\vdots \\ rD^{0,\\bar{t}}(\\ell) + wr&#x27;E^{0,\\bar{t}}(\\ell) \\end{pmatrix} \\end{aligned}</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\mathbf{M}_{\\ell} \\in \\mathbb{Z}_q^{(v+m+\\ell+2)\\times(2v+2)}</span>  is the matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{M}_{\\ell} \\doteq \\begin{pmatrix} 1 &amp; 0 &amp; \\dots &amp; 0 &amp; w &amp; 0 &amp; \\dots &amp; 0 \\ 1 &amp; 1 &amp; \\dots &amp; 1 &amp; w &amp; w &amp; \\dots &amp; w \\ &amp; \\vdots &amp; &amp; &amp; \\vdots \\ 1 &amp; v &amp; \\dots &amp; v^v &amp; w &amp; wv &amp; \\dots &amp; wv^v \\ 1 &amp; x_{t_1} &amp; \\dots &amp; x_{t_1}^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\ &amp; \\vdots &amp; &amp; &amp; \\vdots \\ 1 &amp; x_{t_m} &amp; \\dots &amp; x_{t_m}^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\ r &amp; 0 &amp; \\dots &amp; 0 &amp; wr&#x27; &amp; 0 &amp; \\dots &amp; 0 \\ r &amp; r &amp; \\dots &amp; r &amp; wr&#x27; &amp; wr&#x27; &amp; \\dots &amp; wr&#x27; \\ &amp; \\vdots &amp; &amp; &amp; \\vdots \\ r &amp; r\\ell &amp; \\dots &amp; r\\ell^v &amp; wr&#x27; &amp; wr&#x27;\\ell &amp; \\dots &amp; wr&#x27;\\ell^v \\ \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">By inspection, it is possible to see that the rows of matrix  <span class="math">\\mathbf{M}_{\\ell}</span>  are linearly independent, provided that  <span class="math">r \\neq r&#x27;</span>  and  <span class="math">w \\neq 0</span> : thus, the rank of  <span class="math">\\mathbf{M}_{\\ell}</span>  is  <span class="math">v + m + \\ell + 2</span> . As soon as we fix  <span class="math">\\mathbf{V}</span> , vector  <span class="math">\\gamma_{\\ell}</span>  and the first v + 1 rows of  <span class="math">\\mathbf{M}_{\\ell}</span>  are determined, but  <span class="math">\\boldsymbol{\\alpha}</span>  is still distributed uniformly and independently at random in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> . Similarly to the proof of Lemma 3, it is also possible to show that fixing the first v + j entries of  <span class="math">\\bar{\\beta}</span>  determines the (v+j+1)th row of  <span class="math">\\mathbf{M}_{\\ell}</span> , for  <span class="math">j=1,\\ldots,m</span> ; and that moreover, fixing the first v+m+1 entries of  <span class="math">\\bar{\\beta}</span>  determines all the remaining rows of  <span class="math">\\mathbf{M}_{\\ell}</span> .</p>

    <p class="text-gray-300">Hence, by Lemma 1, we can conclude that the conditional distribution of  <span class="math">\\mathbf{X}_{\\ell}^{\\bar{t}}</span>  w.r.t.  <span class="math">(\\mathbf{V}, \\bar{\\boldsymbol{\\beta}}, \\mathbf{X}_{0}^{\\bar{t}}, \\ldots, \\mathbf{X}_{\\ell-1}^{\\bar{t}})</span>  is uniform over  <span class="math">\\mathbb{Z}_{q}</span> ,  <span class="math">\\forall \\ell \\in \\{0, \\ldots, v-m\\}</span> . In other words, the value of  <span class="math">X^{\\bar{t}}(\\cdot)</span>  at any point is uniformly random, subject to the constraint</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}^{\\bar{t}}(x_{t_j}) = r\\mathbf{A}_j + wr&#x27;\\mathbf{B}_j, \\ \\forall t_j \\in \\mathcal{T}.</span>$</p>

    <p class="text-gray-300">Thus,  <span class="math">(V, \\bar{\\beta}, X^{\\bar{t}}(\\cdot))</span>  has the same joint distribution as  <span class="math">(V, \\bar{\\beta}, X&#x27;(\\cdot))</span> , completing the proof.</p>

    <p class="text-gray-300">We now move on to prove the soundness of the BBC algorithm, showing that it can accuse an innocent user with at most negligible probability. Informally this is true because, under the DDH assumption it is impossible to notice if the values  <span class="math">A&#x27;(x_i)</span>  and  <span class="math">B&#x27;(x_i)</span>  (which are unknown to the adversary since i is assumed to be honest), were replaced by random noise  <span class="math">A&#x27;&#x27;(x_i)</span>  and  <span class="math">B&#x27;&#x27;(x_i)</span> . Thus, the behavior of the decoder will be the same regardless of whether PK(I) or  <span class="math">PK(I \\setminus \\{i\\})</span>  was used to encrypt the ciphertext. Since our algorithm only accuses a user i when a sensible change occurs in the decryption capability of the pirate decoder, it follows that an innocent user will be blamed with at most negligible probability.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> Under the DDH assumption, if  <span class="math">|I| \\leq v</span>  and  <span class="math">i \\notin \\mathcal{T}</span> , then  <span class="math">|\\delta(I) - \\delta(I \\setminus \\{i\\})|</span>  is negligible.</p>

    <p class="text-gray-300"><em>Proof.</em> Proceeding as in the proof of Theorem 2, we define a sequence of &quot;indistinguishable&quot; games  <span class="math">G_0</span> ,  <span class="math">G_1</span> , ...: for each game  <span class="math">G_j</span> , let  <span class="math">T_j</span>  be the event that decoder D correctly decrypts the challenge sent by the BBC algorithm in game  <span class="math">G_j</span> .</p>

    <p class="text-gray-300"><strong>Game</strong>  <span class="math">G_0</span> : This game describes the experiment which defines the value of  <span class="math">\\delta(I)</span> . In this game, the decoder D is fed with ciphertexts obtained encrypting random messages under the fake public key PK(I), defined as:</p>

    <p class="text-gray-300"><span class="math">$PK(I) = \\langle q, q&#x27;, q^{A&#x27;(0)} q&#x27;^{B&#x27;(0)}, \\langle z_{\\ell}, q^{A&#x27;(z_{\\ell})} q&#x27;^{B&#x27;(z_{\\ell})} \\rangle_{\\ell-1}^{v} \\rangle</span>$</p>

    <p class="text-gray-300">where  <span class="math">A&#x27;(\\cdot)</span>  and  <span class="math">B&#x27;(\\cdot)</span>  are random v-degree polynomials subject to:</p>

    <p class="text-gray-300"><span class="math">$A&#x27;(x_s) = A^{\\bar{t}}(x_s) \\quad B&#x27;(x_s) = B^{\\bar{t}}(x_s), \\ \\forall s \\in I.</span>$</p>

    <p class="text-gray-300">More precisely, the BBC algorithm chooses a random message M and encrypts it as follows:</p>

    <p class="text-gray-300">E1.
<span class="math">$r \\leftarrow \\mathbb{Z}_q</span>$</p>

    <p class="text-gray-300">E2.  <span class="math">u \\leftarrow g^r</span>
E3.  <span class="math">u&#x27; \\leftarrow g&#x27;^r</span>
E4.  <span class="math">u&#x27;&#x27; \\leftarrow M \\cdot g^{A&#x27;(0)r} g&#x27;^{B&#x27;(0)r}</span>
E5.  <span class="math">u_\\ell \\leftarrow g^{A&#x27;(z_\\ell)r} g&#x27;^{B&#x27;(z_\\ell)r}, \\quad \\ell = 1, \\dots, v</span>
E6.  <span class="math">\\psi^* \\leftarrow \\langle u, u&#x27;, u&#x27;&#x27;, \\langle z_1, u_1 \\rangle, \\dots, \\langle z_r, u_r \\rangle \\rangle</span></p>

    <p class="text-gray-300">By definition, we have that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_0] = \\delta(I). \\tag{28}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>1</sub>: Game  <span class="math">G_1</span>  is identical to game  <span class="math">G_0</span> , except that in game  <span class="math">G_1</span>  steps E4 and E5 are substituted with:</p>

    <p class="text-gray-300">E4'.
<span class="math">$u&#x27;&#x27; \\leftarrow M \\cdot u^{A&#x27;(0)} u&#x27;^{B&#x27;(0)}</span>$</p>

    <p class="text-gray-300">E5'.  <span class="math">u_{\\ell} \\leftarrow u^{A&#x27;(z_{\\ell})} u&#x27;^{B&#x27;(z_{\\ell})}, \\quad \\ell = 1, \\dots, v</span></p>

    <p class="text-gray-300">Notice that the point of these changes is just to make explicit any functional dependency of  <span class="math">\\psi^*</span>  on the quantities u and u'. Since we just made a conceptual change, it clearly holds that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_1] = \\Pr[T_0]. \\tag{29}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>2</sub>: Game  <span class="math">G_2</span>  is identical to game  <span class="math">G_1</span> , except that in game  <span class="math">G_2</span>  steps E1 and E3 are substituted with:</p>

    <p class="text-gray-300">E1'.
<span class="math">$r \\leftarrow \\mathbb{Z}_q</span>$
;  <span class="math">r&#x27; \\leftarrow \\mathbb{Z}_q \\setminus \\{r\\}</span>
E3'.  <span class="math">u&#x27; \\leftarrow q&#x27;^{r&#x27;}</span></p>

    <p class="text-gray-300">Notice that while in game G<sup>1</sup> the value u and u <sup>0</sup> are obtained using the same value r, in game G<sup>2</sup> they are nearly independent, being subject only to r 6= r 0 . Therefore, using a standard reduction argument, any non-negligible difference in behavior between games G<sup>1</sup> and G<sup>2</sup> can be used to construct a PPT adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_2] - \\Pr[T_1] \\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k).</span>$
(30)</p>

    <p class="text-gray-300">Game G3: To turn game G<sup>2</sup> into game G3, we consider the set I \\ {i} and construct the public key PK(I \\ {i}): two new random v-degree polynomials A00(&middot;) and B00(&middot;) are chosen such that</p>

    <p class="text-gray-300"><span class="math">$A&#x27;&#x27;(x_s) = A^{\\bar{t}}(x_s) \\quad B&#x27;&#x27;(x_s) = B^{\\bar{t}}(x_s), \\ \\forall s \\in I \\setminus \\{i\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\tag{31}</span>$</p>

    <p class="text-gray-300">and PK(I \\ {i}) is set to be:</p>

    <p class="text-gray-300"><span class="math">$PK(I \\setminus \\{i\\}) \\doteq \\langle g, g&#x27;, g^{A&#x27;&#x27;(0)} g&#x27;^{B&#x27;&#x27;(0)}, \\langle z_{\\ell}, g^{A&#x27;&#x27;(z_{\\ell})} g&#x27;^{B&#x27;&#x27;(z_{\\ell})} \\rangle_{\\ell=1}^{v} \\rangle.</span>$</p>

    <p class="text-gray-300">Notice that, for s &isin; I \\ {i}, it holds that A00(xs) = A<sup>0</sup> (xs) and B00(xs) = B<sup>0</sup> (xs). Finally, we change steps E4 <sup>0</sup> and E5 <sup>0</sup> of the encryption algorithm as follows:</p>

    <p class="text-gray-300">E4&quot;.
<span class="math">$u&#x27;&#x27; \\leftarrow M \\cdot u^{A&#x27;&#x27;(0)} u&#x27;^{B&#x27;&#x27;(0)}</span>$</p>

    <p class="text-gray-300">E5&quot;.  <span class="math">u_{\\ell} \\leftarrow u^{A&#x27;&#x27;(z_{\\ell})} u&#x27;^{B&#x27;&#x27;(z_{\\ell})}, \\quad \\ell = 1, \\dots, v</span></p>

    <p class="text-gray-300">Using the technique described in Section 5.2, in Lemma 5 below, we show that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_3] = \\Pr[T_2]. \\tag{32}</span>$</p>

    <p class="text-gray-300">Game G4: In game G4, we &quot;undo&quot; the changes of game G2, restoring lines E1 and E3 of the encryption oracle to their original values:</p>

    <p class="text-gray-300"><span class="math">$E1&#x27;&#x27;</span>$
.  <span class="math">r \\leftarrow \\mathbb{Z}_q</span>
<span class="math">E3&#x27;&#x27;</span> .  <span class="math">u&#x27; \\leftarrow g&#x27;^r</span></p>

    <p class="text-gray-300">Notice that in game G<sup>4</sup> the value u and u <sup>0</sup> are again obtained using the same value r, whereas in game G<sup>3</sup> they are nearly independent, being subject only to r 6= r 0 . Therefore, using a standard reduction argument, any non-negligible difference in behavior between games G<sup>3</sup> and G<sup>4</sup> can be used to construct a PPT adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr[T_4] - \\Pr[T_3] \\right| \\le \\mathsf{AdvDDH}_{\\mathcal{G}}(k).</span>$
(33)</p>

    <p class="text-gray-300">In game G4, the encryption of the random message M is obtained using the public key PK(I \\ {i}): thus, game G<sup>4</sup> is exactly the game defining &delta;(I \\ {i}) i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[T_4] = \\delta(I \\setminus \\{i\\}). \\tag{34}</span>$</p>

    <p class="text-gray-300">By Equations (28), (29), (30), (32), (33) and (34), we can conclude that the adversary has only a negligible chance to tell whether the message M was encrypted under PK(I) or PK(I \\ {i}); more precisely:</p>

    <p class="text-gray-300"><span class="math">$|\\delta(I) - \\delta(I \\setminus \\{i\\})| \\le 2 \\text{ AdvDDH}_{\\mathcal{G}}(k).</span>$</p>

    <p class="text-gray-300">Lemma 5. Pr[T3] = Pr[T2]</p>

    <p class="text-gray-300"><em>Proof.</em> To prove the Lemma, we consider all the quantities that can affect event  <span class="math">T_2</span>  in game  <span class="math">\\mathbf{G}_2</span>  and event  <span class="math">T_3</span>  in game  <span class="math">\\mathbf{G}_3</span> , and then we show that these quantities are distributed according to the same joint distribution in both games.</p>

    <p class="text-gray-300">Let  <span class="math">\\bar{m} \\doteq |\\mathcal{T} \\cap I|</span> , where  <span class="math">\\mathcal{T} = \\{t_1, \\dots, t_m\\}</span>  is the set of traitors; w.l.o.g. assume that  <span class="math">\\mathcal{T} \\cap I = \\{t_1, \\dots, t_{\\bar{m}}\\}</span> . Also, set</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}_j \\doteq A^{\\bar{t}}(x_{t_j}) \\quad \\mathbf{B}_j \\doteq B^{\\bar{t}}(x_{t_j}), \\ j = 1, \\dots, m.</span>$</p>

    <p class="text-gray-300">Notice that, since  <span class="math">i \\notin \\mathcal{T}</span> , for  <span class="math">1 \\leq j \\leq \\bar{m}</span>  it also holds that:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}_{j} = A&#x27;(x_{t_{j}}) = A&#x27;&#x27;(x_{t_{j}}) \\quad \\mathbf{B}_{j} = B&#x27;(x_{t_{j}}) = B&#x27;&#x27;(x_{t_{j}}).</span>$</p>

    <p class="text-gray-300">Consider the quantity:</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{V} \\doteq (\\mathsf{Coins}_{\\mathcal{A}}, \\mathsf{Coins}_{\\mathsf{D}}, w, M, r, r&#x27;, \\{\\{c_i^t, r_i^t\\}_{i=1}^{2v+2}\\}_{t=1}^{\\bar{t}})</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span>  denotes the coin tosses of  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathsf{Coins}_{\\mathsf{D}}</span>  denotes the coin tosses of  <span class="math">\\mathsf{D}</span> ,  <span class="math">w \\doteq \\log_g g&#x27;</span> ,  <span class="math">\\mathbf{X}_{\\ell} \\doteq (A^0(\\ell) + B^0(\\ell))</span>  for  <span class="math">\\ell = 0, \\dots, v</span> , M is the random message encrypted within  <span class="math">\\psi^*</span> , r and r' are the random values used to create  <span class="math">\\psi^*</span> , and</p>

    <p class="text-gray-300"><span class="math">$\\{\\{c_i^t, r_i^t\\}_{i=1}^{2v+2}\\}_{t=1}^{\\bar{t}}</span>$</p>

    <p class="text-gray-300">represents all the randomness used in the  <span class="math">\\bar{t}</span>  New-period operations that took place during the attack game  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^{m}(1^{k})</span> .</p>

    <p class="text-gray-300">The remaining randomness used during games  <span class="math">\\mathbf{G}_2</span>  and  <span class="math">\\mathbf{G}_3</span>  consists of the 6v+6 coefficients of the polynomials  <span class="math">A^0(\\cdot)</span> ,  <span class="math">B^0(\\cdot)</span>  (chosen by the Setup algorithm in step 1. of the  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^m(1^k)</span>  attack game),  <span class="math">A&#x27;(\\cdot)</span> ,  <span class="math">B&#x27;(\\cdot)</span>  (used in game  <span class="math">\\mathbf{G}_2</span> ), and  <span class="math">A&#x27;&#x27;(\\cdot)</span> ,  <span class="math">B&#x27;&#x27;(\\cdot)</span>  (used in game  <span class="math">\\mathbf{G}_3</span> ). This randomness can be represented with the vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\alpha} \\doteq (a_0, a_1, \\dots, a_v, b_0, b_1, \\dots, b_v)^T</span>$</p>

    <p class="text-gray-300">which is uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> , the vector</p>

    <p class="text-gray-300"><span class="math">$\\alpha&#x27; \\doteq (a&#x27;_0, a&#x27;_1, \\dots, a&#x27;_v, b&#x27;_0, b&#x27;_1, \\dots, b&#x27;_v)^T</span>$</p>

    <p class="text-gray-300">which is uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> , subject to the constraints arising from imposing Equation (27), and the vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\alpha}&#x27;&#x27; \\doteq (a_0&#x27;&#x27;, a_1&#x27;&#x27;, \\dots, a_v&#x27;&#x27;, b_0&#x27;&#x27;, b_1&#x27;&#x27;, \\dots, b_v&#x27;&#x27;)^T</span>$</p>

    <p class="text-gray-300">which is uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> , subject to the constraints arising from imposing Equation (31). Consider the quantity  <span class="math">\\bar{\\beta} \\in \\mathbb{Z}_q^{(v+\\bar{m}+1)\\times 1}</span>  defined as:</p>

    <p class="text-gray-300"><span class="math">$\\bar{\\boldsymbol{\\beta}} \\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_n, \\mathbf{A}_1, \\dots, \\mathbf{A}_{\\bar{m}})^T</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_0 \\doteq A^0(0) + wB^0(0)</span> , and  <span class="math">\\mathbf{X}_{\\ell} \\doteq A^0(\\ell) + wB^0(\\ell)</span> , for  <span class="math">\\ell = 1, \\dots, v</span> .</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the view of the adversary  <span class="math">\\mathcal{A}</span>  during the attack game  <span class="math">\\mathbf{G}_{\\mathsf{trt}}^m(1^k)</span>  is completely determined by  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\bar{\\boldsymbol{\\beta}}</span> . In particular, the initial public key  <span class="math">PK^0</span>  is fixed by  <span class="math">\\mathbf{V}</span> , and the secret keys of the traitors are determined by the choice of  <span class="math">\\bar{\\boldsymbol{\\beta}}</span> ,  <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span>  and w.</p>

    <p class="text-gray-300">Besides the information in  <span class="math">\\mathcal{A}</span> 's view, the only other quantity affecting D's behavior is the ciphertext  <span class="math">\\psi^*</span> . This ciphertext is computed differently in games  <span class="math">\\mathbf{G}_2</span>  and  <span class="math">\\mathbf{G}_3</span> : for the sake of clarity, we will denote with  <span class="math">[\\psi^*]_2</span>  and  <span class="math">[\\psi^*]_3</span>  the value of such quantity in game  <span class="math">\\mathbf{G}_2</span>  and  <span class="math">\\mathbf{G}_3</span> , respectively. We now want to show that, conditioned on all the other information in D's view,  <span class="math">[\\psi^*]_2</span>  and  <span class="math">[\\psi^*]_3</span>  are distributed according to the same distribution in the two games.</p>

    <p class="text-gray-300">In game  <span class="math">\\mathbf{G}_2</span> , the ciphertext  <span class="math">[\\psi^*]_2</span>  sent to the decoder is completely determined by  <span class="math">\\boldsymbol{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and by the v-degree polynomial  <span class="math">X&#x27; \\doteq rA&#x27;(\\cdot) + wr&#x27;B&#x27;(\\cdot)</span> . Similarly, in game  <span class="math">\\mathbf{G}_3</span> , the ciphertext  <span class="math">[\\psi^*]_3</span>  is completely determined by  <span class="math">\\boldsymbol{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and by the v-degree polynomial  <span class="math">X&#x27;&#x27;(\\cdot) \\doteq rA&#x27;&#x27;(\\cdot) + wr&#x27;B&#x27;&#x27;(\\cdot)</span> . Moreover,  <span class="math">[\\psi^*]_2</span>  depends on  <span class="math">\\boldsymbol{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and  <span class="math">X&#x27;(\\cdot)</span>  according to the same functional dependence of  <span class="math">[\\psi^*]_3</span>  upon  <span class="math">\\boldsymbol{V}</span> ,  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  and  <span class="math">X&#x27;&#x27;(\\cdot)</span> . Therefore, to prove the</p>

    <p class="text-gray-300">Lemma, it suffices to show that, conditioning on any fixed values of V and  <span class="math">\\bar{\\beta}</span> ,  <span class="math">X&#x27;(\\cdot)</span>  and  <span class="math">X&#x27;&#x27;(\\cdot)</span>  are distributed according to the same conditional probability distribution.</p>

    <p class="text-gray-300">Recall that, in game  <span class="math">\\mathbf{G}_2</span> , the polynomials  <span class="math">A&#x27;(\\cdot)</span>  and  <span class="math">B&#x27;(\\cdot)</span>  are chosen uniformly at random from  <span class="math">\\mathbb{Z}_q^v[x]</span> , independently from anything else, but subject to the constraints in (27). Thus, the polynomial  <span class="math">X&#x27;(\\cdot) = rA&#x27;(\\cdot) + wr&#x27;B&#x27;(\\cdot)</span>  is also random in  <span class="math">\\mathbb{Z}_q^v[x]</span> , subject to the constraint that its value at  <span class="math">x_s</span>  is</p>

    <p class="text-gray-300"><span class="math">$rA^{\\bar{t}}(x_s) + wr&#x27;B^{\\bar{t}}(x_s), \\ \\forall s \\in I.</span>$</p>

    <p class="text-gray-300">Similarly, in game  <span class="math">\\mathbf{G}_3</span> , the polynomials  <span class="math">A&#x27;&#x27;(\\cdot)</span>  and  <span class="math">B&#x27;&#x27;(\\cdot)</span>  are chosen uniformly at random from  <span class="math">\\mathbb{Z}_q^v[x]</span> , independently from anything else, but subject to the constraints in (31). Thus, the polynomial  <span class="math">X&#x27;&#x27;(\\cdot) = rA&#x27;&#x27;(\\cdot) + wr&#x27;B&#x27;&#x27;(\\cdot)</span>  is also random in  <span class="math">\\mathbb{Z}_q^v[x]</span> , subject to the constraint that its value at  <span class="math">x_s</span>  is</p>

    <p class="text-gray-300"><span class="math">$rA^{\\bar{t}}(x_s) + wr&#x27;B^{\\bar{t}}(x_s), \\ \\forall s \\in I \\setminus \\{i\\}.</span>$</p>

    <p class="text-gray-300">In other words, the distributions of  <span class="math">X&#x27;(\\cdot)</span>  and  <span class="math">X&#x27;&#x27;(\\cdot)</span>  only differ in that the value of  <span class="math">X&#x27;(\\cdot)</span>  at  <span class="math">x_i</span>  is fixed to be</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}_i&#x27; \\doteq rA^{\\bar{t}}(x_i) + wr&#x27;B^{\\bar{t}}(x_i)</span>$</p>

    <p class="text-gray-300">whereas the value of  <span class="math">X&#x27;&#x27;(\\cdot)</span>  at  <span class="math">x_i</span>  is a random element in  <span class="math">\\mathbb{Z}_q</span> . Thus, to prove that  <span class="math">X&#x27;(\\cdot)</span>  and  <span class="math">X&#x27;&#x27;(\\cdot)</span>  have the same conditional probability distribution w.r.t. V and  <span class="math">\\bar{\\beta}</span> , it suffices to show that, conditioning on any fixed values of V and  <span class="math">\\bar{\\beta}</span> , the value  <span class="math">X&#x27;_i</span>  is distributed uniformly at random in  <span class="math">\\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">To this aim, consider the following matrix equation:</p>

    <p class="text-gray-300"><span class="math">$\\beta = \\mathbf{M} \\cdot \\boldsymbol{\\alpha} + \\boldsymbol{\\gamma}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\boldsymbol{\\beta} \\in \\mathbb{Z}_q^{(v+\\bar{m}+2)\\times 1}</span>  is the vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\beta} \\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_v, \\mathbf{A}_1, \\dots, \\mathbf{A}_{\\bar{m}}, \\mathbf{X}_i&#x27;)^T,</span>$</p>

    <p class="text-gray-300"><span class="math">\\gamma \\in \\mathbb{Z}_q^{(v+\\bar{m}+2) \\times 1}</span>  is the vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\gamma} \\doteq \\begin{pmatrix} 0 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(v+\\bar{m}+2)\\times(2v+2)}</span>  is the matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{M} \\doteq \\begin{pmatrix} 1 &amp; 0 &amp; \\dots &amp; 0 &amp; w &amp; 0 &amp; \\dots &amp; 0 \\\\ 1 &amp; 1 &amp; \\dots &amp; 1 &amp; w &amp; w &amp; \\dots &amp; w \\\\ &amp; \\vdots &amp; &amp; &amp; \\vdots \\\\ \\vdots &amp; &amp; &amp; &amp; \\vdots \\\\ 1 &amp; v &amp; \\dots &amp; v^v &amp; w &amp; wv &amp; \\dots &amp; wv^v \\\\ 1 &amp; x_{t_1} &amp; \\dots &amp; x_{t_1}^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ &amp; &amp; \\vdots &amp; &amp; &amp; \\vdots \\\\ 1 &amp; x_{t_m} &amp; \\dots &amp; x_{t_m}^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ r &amp; rx_i &amp; \\dots &amp; rx_i^v &amp; wr&#x27; &amp; wr&#x27;x_i &amp; \\dots &amp; wr&#x27;x_i^v \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">By inspection, it is possible to see that the rows of matrix  <span class="math">\\mathbf{M}</span>  are linearly independent, provided that  <span class="math">r \\neq r&#x27;</span>  and  <span class="math">w \\neq 0</span> : thus, the rank of  <span class="math">\\mathbf{M}</span>  is  <span class="math">v + \\bar{m} + 2</span> . As soon as we fix  <span class="math">\\mathbf{V}</span> , vector  <span class="math">\\boldsymbol{\\gamma}</span>  and the first v + 1 rows of</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}</span>  are determined, but  <span class="math">\\boldsymbol{\\alpha}</span>  is still distributed uniformly and independently at random in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> . Similarly to the proof of Lemma 3, it is also possible to show that fixing the first v+j entries of  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  determines the (v+j+1)th row of  <span class="math">\\mathbf{M}</span> , for  <span class="math">j=1,\\ldots,\\bar{m}</span> ; and that moreover, fixing the first  <span class="math">v+\\bar{m}+1</span>  entries of  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  determines all the remaining rows of  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">Hence, by Lemma 1, we can conclude that the conditional distribution of  <span class="math">\\mathbf{X}_i&#x27;</span>  w.r.t.  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\bar{\\boldsymbol{\\beta}}</span>  is uniform over  <span class="math">\\mathbb{Z}_q</span> . In other words, conditioning on the information seen by the adversary before receiving the challenge  <span class="math">\\psi^*</span> , the value of  <span class="math">X&#x27;(\\cdot)</span>  at  <span class="math">x_i</span>  looks random over  <span class="math">\\mathbb{Z}_q</span> . It follows that  <span class="math">(\\mathbf{V}, \\bar{\\boldsymbol{\\beta}}, X&#x27;(\\cdot))</span>  has the same joint distribution as  <span class="math">(\\mathbf{V}, \\bar{\\boldsymbol{\\beta}}, X&#x27;&#x27;(\\cdot))</span> , completing the proof.</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Non-Black-Box Tracing</h3>

    <p class="text-gray-300">In Section 6.3 we describe a non-black-box tracing algorithm which builds on the results of [3,19], but it is tailored to our family of representations. Then, in Section 6.3, we analyze its security properties in the formal model for traceability of Section 6.1, under a non-black-box assumption, given below as Assumption 3. Before that, however, we develop some notation.</p>

    <p class="text-gray-300">NOTATION. Recall that in the scheme of Section 4, the secret key of user  <span class="math">x_i</span>  consists of two points  <span class="math">A(x_i)</span> ,  <span class="math">B(x_i)</span> , which can be combined with the system's public key to obtain two leap vectors to be used in the decryption algorithm. More precisely, given the current public key</p>

    <p class="text-gray-300"><span class="math">$PK \\doteq \\langle g, g&#x27;, y, \\langle z_1, h_1 \\rangle, \\dots, \\langle z_v, h_v \\rangle \\rangle,</span>$</p>

    <p class="text-gray-300">it is possible to construct (by Definition 6) two leap vectors</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\nu}_{A,i} \\doteq \\boldsymbol{\\nu}_{z_1,\\ldots,z_v}^{x_i,A} \\quad \\boldsymbol{\\nu}_{B,i} \\doteq \\boldsymbol{\\nu}_{z_1,\\ldots,z_v}^{x_i,B}</span>$</p>

    <p class="text-gray-300">where  <span class="math">(A(\\cdot), B(\\cdot))</span>  is the master secret key corresponding to the current public key PK. By Equations (2) and (4),  <span class="math">\\nu_{A,i}</span>  and  <span class="math">\\nu_{B,i}</span>  agree on the last v components; thus, under the current public key PK, user  <span class="math">x_i</span> 's secret key can be compactly rewritten as</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\boldsymbol{\\delta}_{i} &amp;\\doteq \\langle (\\nu_{A,i})_{0}, (\\nu_{B,i})_{0}, \\boldsymbol{\\delta}&#x27;_{i} \\rangle \\\\ &amp;\\doteq \\langle \\lambda_{0}^{(i)} A(x_{i}), \\lambda_{0}^{(i)} B(x_{i}), \\langle \\lambda_{1}^{(i)}, \\dots, \\lambda_{v}^{(i)} \\rangle \\rangle, \\end{aligned}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\lambda_0^{(i)}</span> ,  <span class="math">\\lambda_1^{(i)}</span> ,..., <span class="math">\\lambda_v^{(i)}</span>  are the Lagrange coefficients defined in Equations (3) and (4); recall that, for notational convenience, we use superscript (i) to make explicit that a given set of Lagrange coefficients is relative to user  <span class="math">x_i</span> .</p>

    <p class="text-gray-300">Notice that such vector  <span class="math">\\boldsymbol{\\delta}_i</span>  is a representation of y w.r.t.  <span class="math">g, g&#x27;, h_1, \\ldots, h_v</span> ; for short, when this is the case, in the following we will just say that  <span class="math">\\boldsymbol{\\delta}_i</span>  is a valid representation of the public key PK. Also notice that any such valid representation  <span class="math">\\boldsymbol{\\delta}</span>  of the current public key PK would work for decrypting messages encrypted with PK; for a generic valid representation</p>

    <p class="text-gray-300"><span class="math">$\\delta \\doteq \\langle \\gamma_a, \\gamma_b, \\gamma_1, \\dots, \\gamma_v \\rangle</span>$</p>

    <p class="text-gray-300">we will denote with  <span class="math">\\delta&#x27;</span>  its last v entries:</p>

    <p class="text-gray-300"><span class="math">$\\delta&#x27; \\doteq \\langle \\gamma_1, \\ldots, \\gamma_n \\rangle.</span>$</p>

    <p class="text-gray-300">In the non-black-box model, the tracing algorithm is assumed to be able of inspecting the content of a successful pirate decoder, and to extract the secret key hidden within it. More precisely, in designing and analyzing our non-black-box tracing algorithm, we make the following assumption:</p>

    <h3 id="sec-misc-6" class="text-xl font-semibold mt-8">Assumption 3 (Non-Black-Box Assumption)</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}</span>  be any probabilistic, polynomial-time adversary, and let  <span class="math">\\langle \\mathsf{D}, PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, T \\rangle</span>  be the output resulting from the adversary playing the traceability attack game  <span class="math">G^m_{\\mathsf{trt}}(1^k)</span>  with the challenger. If  <span class="math">\\mathsf{D}</span>  can correctly decrypt random ciphertexts encrypted using  <span class="math">PK_{\\mathcal{A}}</span>  (in other words,  <span class="math">\\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D}) = 1</span> ), then  <span class="math">\\mathsf{D}</span>  contains a valid representation  <span class="math">\\delta</span>  of  <span class="math">PK_{\\mathcal{A}}</span> , and it is possible to reverse-engineer  <span class="math">\\mathsf{D}</span>  and extract  <span class="math">\\delta</span> .</p>

    <p class="text-gray-300">Assumption 3 is partially supported by Proposition 1 and it is essentially equivalent to what was previously assumed in [3]. It is also a priori much less restrictive than the non-black-box assumption made in [19], where the non-black-box analysis is subject to the hypothesis that the illegal key extracted from the pirate decoder is a convex linear combination of some of the traitors' keys. In fact, in Lemma 6 (whose proof is given in Section 6.3) we show that in our context, the seemingly more restrictive assumption from [19] actually follows from Assumption 3 and Assumption 2.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> Let  <span class="math">\\mathcal{A}</span>  be any probabilistic, polynomial-time adversary, and let  <span class="math">\\langle \\mathsf{D}, PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, T \\rangle</span>  be the output resulting from the adversary playing the traceability attack game  <span class="math">G^m_{\\mathsf{trt}}(1^k)</span>  with the challenger. Also let  <span class="math">\\mathcal{T} \\doteq \\{t_1, \\ldots, t_m\\}</span>  and, for  <span class="math">j = 1, \\ldots, m</span> , denote with  <span class="math">\\delta_{t_j}</span>  the compact representation of the secret key of user  <span class="math">t_j</span>  w.r.t. the public key  <span class="math">PK_{\\mathcal{A}}</span> . If the pirate decoder  <span class="math">\\mathsf{D}</span>  output by  <span class="math">\\mathcal{A}</span>  contains a valid representation  <span class="math">\\delta</span>  for the public key  <span class="math">PK_{\\mathcal{A}}</span> , such that  <span class="math">\\delta&#x27;</span>  is not a linear combination of  <span class="math">\\delta&#x27;_{t_1}, \\ldots, \\delta&#x27;_{t_m}</span> , then the discrete-log problem over  <span class="math">\\mathcal{G}</span>  is solvable.</p>

    <p class="text-gray-300">Non-Black-Box Tracing Algorithm We present a deterministic tracing algorithm that recovers, under Assumptions 2 and 3, the identities of the traitors that created the pirate key. Suppose that the content of a pirate decoder is exposed. By Assumption 3, it is possible to extract from D a valid representation  <span class="math">\\delta</span>  of the current public key  <span class="math">PK_{\\mathcal{A}}</span> . Define  <span class="math">\\{x_1, \\ldots, x_n\\}</span>  to be the set of all values assigned to the users in the system (where n denotes the total number of users in the system), and let  <span class="math">\\delta_1, \\ldots, \\delta_n</span>  be the corresponding secret keys. Let  <span class="math">\\{z_{i_1}, \\ldots, z_{i_v}\\}</span>  be the set of values of the revoked users specified in the current public key. Remember that the user-key of user j w.r.t. the current public key can be compactly represented in the form</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\delta_j} \\doteq \\langle \\lambda_0^{(j)} A(x_j), \\lambda_0^{(j)} B(x_j), \\lambda_{i_1}^{(j)}, \\dots, \\lambda_{i_n}^{(j)} \\rangle</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\lambda_j^{(j)}, \\lambda_{i_1}^{(j)}, \\dots, \\lambda_{i_v}^{(j)}</span>  are the Lagrange coefficients defined in Equations (3) and (4). Notice that, for any polynomial  <span class="math">P \\in \\mathbb{Z}_q^v[x]</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$P(0) = \\lambda_0^{(j)} P(x_j) + \\lambda_{i_1}^{(j)} P(x_{i_1}) + \\ldots + \\lambda_{i_r}^{(j)} P(x_{i_r}).</span>$</p>

    <p class="text-gray-300">Consider the matrix  <span class="math">\\mathbf{A} \\in \\mathbb{Z}_q^{n \\times v}</span>  whose jth row is  <span class="math">\\boldsymbol{\\delta_j&#x27;}</span> ,  <span class="math">j = 1, \\dots, n</span> , i.e.:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A} \\doteq \\begin{pmatrix} \\lambda_{i_1}^{(1)} &amp; \\dots &amp; \\lambda_{i_v}^{(1)} \\\\ &amp; \\dots &amp; \\\\ \\lambda_{i_1}^{(n)} &amp; \\dots &amp; \\lambda_{i_v}^{(n)} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">Define the identities of the traitors to be  <span class="math">\\{t_1,\\ldots,t_m\\}\\subseteq\\{1,\\ldots,n\\}</span> . By Lemma 6 and Assumption 2,  <span class="math">\\boldsymbol{\\delta&#x27;}</span>  must be a linear combination of the vectors  <span class="math">\\boldsymbol{\\delta&#x27;_{t_1}},\\ldots,\\boldsymbol{\\delta&#x27;_{t_m}}</span>  obtained by projecting the traitors' user-keys  <span class="math">\\boldsymbol{\\delta_{t_1}},\\ldots,\\boldsymbol{\\delta_{t_m}}</span>  onto the last v components. It follows that  <span class="math">\\boldsymbol{\\delta&#x27;}</span>  also lies in the linear span of  <span class="math">\\boldsymbol{\\delta&#x27;_1},\\ldots,\\boldsymbol{\\delta&#x27;_n}</span> . More precisely, there exists a vector  <span class="math">\\boldsymbol{\\varphi}</span>  of Hamming weight at most m such that</p>

    <p class="text-gray-300"><span class="math">$\\delta&#x27; = \\varphi \\cdot \\mathbf{A}. \\tag{35}</span>$</p>

    <p class="text-gray-300">Consider the two matrices:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{B} \\doteq \\begin{pmatrix} x_{i_1} \\dots x_{i_1}^v \\\\ \\dots \\\\ x_{i_v} \\dots x_{i_v}^v \\end{pmatrix} \\quad \\mathbf{H} \\doteq \\begin{pmatrix} -\\lambda_0^{(1)} x_1 \\dots -\\lambda_1^1 x_1^v \\\\ \\dots \\\\ -\\lambda_0^{(n)} x_n \\dots -\\lambda_0^{(n)} x_n^v \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">It is easy to verify that  <span class="math">\\mathbf{A} \\cdot \\mathbf{B} = \\mathbf{H}</span> . Multiplying (35) by  <span class="math">\\mathbf{B}</span> , we get</p>

    <p class="text-gray-300"><span class="math">$\\varphi \\cdot \\mathbf{H} = \\boldsymbol{\\delta&#x27;&#x27;}</span>$</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{\\phantom{a}^7}</span>  W.l.o.g. we are assuming that the current saturation level L is equal to v.</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\delta&#x27;&#x27;} \\doteq \\boldsymbol{\\delta&#x27;} \\cdot \\mathbf{B}. \\tag{36}</span>$</p>

    <p class="text-gray-300">Let C denote the linear code over Z n q that has H as its parity-check matrix, i.e.</p>

    <p class="text-gray-300"><span class="math">$c \\in \\mathcal{C} \\iff c \\cdot \\mathbf{H} = \\mathbf{0}.</span>$</p>

    <p class="text-gray-300">Let &lambda;1, . . . , &lambda;<sup>n</sup> be the Lagrange coefficients corresponding to {x1, . . . , xn}; thus, for all P &isin; Z &lt;n q [x], it holds that</p>

    <p class="text-gray-300"><span class="math">$P(0) = \\lambda_1 P(x_1) + \\ldots + \\lambda_n P(x_n).</span>$</p>

    <p class="text-gray-300">In Lemma 7 (Section 6.3), we prove that C is a Generalized Reed-Solomon Code (GRS), with distance (v+1). For more details about Generalized Reed-Solomon Codes, see e.g. [16]. Generalized Reed-Solomon Codes can be decoded efficiently by the algorithm of Berlekamp and Welch [1]. This means that, for any e &le; m and any vector &micro; &isin; Z n q , there exists (at most) a unique vector &omega; &isin; C that disagrees with &micro; in at most e positions (since C has distance (v+1) and m = b v 2 c). Moreover, such unique vector &omega; &isin; C (if it exists) can be recovered in deterministic polynomial-time. We now describe how this can be exploited to reconstruct &#981; given &delta; 0 .</p>

    <p class="text-gray-300">First, we compute an arbitrary vector &thetasym; &isin; Z n q that satisfies the system of equations</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\vartheta} \\cdot \\mathbf{H} = \\boldsymbol{\\delta}^{\\prime\\prime}. \\tag{37}</span>$</p>

    <p class="text-gray-300">where &delta; <sup>00</sup> is defined in Equation (36). Note that such &thetasym; can be found by standard linear algebra since Equation (37) induces a system of v equations with n unknowns, n &gt; v, and H contains a non-singular minor of size v. It is easy to verify that the vector</p>

    <p class="text-gray-300"><span class="math">$\\pmb{\\omega} \\doteq \\pmb{\\vartheta} - \\pmb{\\varphi}</span>$</p>

    <p class="text-gray-300">belongs to the linear code C; indeed,</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\omega \\cdot \\mathbf{H} &amp;= \\vartheta \\cdot \\mathbf{H} - \\varphi \\cdot \\mathbf{H} \\\\ &amp;= \\delta&#x27;&#x27; - \\delta&#x27;&#x27; \\\\ &amp;= 0. \\end{aligned}</span>$</p>

    <p class="text-gray-300">As a result, the vector &thetasym; can be expressed as &thetasym; = &omega; + &#981;.</p>

    <p class="text-gray-300">Provided that the number of traitors is at most m, it holds that the Hamming weight of &#981; is less than or equal to m and as a result &thetasym; is an n-vector that differs in at most m positions from the vector &omega; (which belongs to C): in other words, we can view &thetasym; as a &quot;partially corrupted&quot; version of the codeword &omega;. Therefore, we can recover &omega; from &thetasym;, by running the Berlekamp-Welch decoding algorithm for GRS-codes on input &thetasym;. At this point, &#981; can be computed as &#981; = &thetasym; &minus; &omega;.</p>

    <p class="text-gray-300">By Equation (35), &#981; is a vector of Hamming weight at most m, whose non-zero components correspond to the identities of the traitors; thus, the traitors' identities can be recovered as</p>

    <p class="text-gray-300"><span class="math">$\\{t_1,\\ldots,t_m\\}=j\\in\\{1,\\ldots,n\\}\\land\\varphi_j\\neq0\\}.</span>$</p>

    <p class="text-gray-300">Time-Complexity. The tracing procedure has time complexity O(n 2 ), which can be optimized to O(n(log n) 2 ), if matrix operations are implemented in a more sophisticated manner, see e.g. [2]. If the number of traitors exceeds the bound m, it is still possible to extract candidate sets of potential traitors using the Guruswami-Sudan algorithm [13], which performs GRS-decoding &quot;beyond the error-correction bound&quot;. This will work provided that the size of the traitor coalition is less than or equal to n &minus; p n(n &minus; v).</p>

    <p class="text-gray-300">Correctness of Non-Black-Box Tracing Given Lemmas 6 and 7, the correctness of the non-black-box tracing algorithm described above follows from the properties of algebraic decoding of GRS codes. Thus, to conclude the argument, we now move on to the proofs of these Lemmas.</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Proof of Lemma 6</h4>

    <p class="text-gray-300">Let g be a generator of  <span class="math">\\mathcal{G}</span> , and let  <span class="math">g&#x27; \\doteq g^w</span> . Using adversary  <span class="math">\\mathcal{A}</span>  described in the attack game  <span class="math">\\mathbf{G}_{\\mathsf{trt}}^m(1^k)</span> , we want to show how to recover the value w. In performing step 1. of  <span class="math">\\mathbf{G}_{\\mathsf{trt}}^m(1^k)</span> , choose two random polynomials  <span class="math">A^0(x)</span>  and  <span class="math">B^0(x)</span>  and set the initial public key to be</p>

    <p class="text-gray-300"><span class="math">$\\langle g, g&#x27;, g^{A^0(0)}g&#x27;^{B^0(0)}, \\langle \\ell, g^{A^0(\\ell)}g&#x27;^{B^0(\\ell)}\\rangle_{\\ell-1}^v \\rangle</span>$
.</p>

    <p class="text-gray-300">The game then proceeds as described in Section 6.1; in particular, let  <span class="math">\\bar{t}</span>  be the number of New-period operation occurring during the entire game. Eventually, adversary  <span class="math">\\mathcal{A}</span>  outputs a pirate decoder D from which (by Assumption 3) it is possible to extract a vector</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\delta} = \\langle \\gamma_a, \\gamma_b, \\gamma_1, \\dots, \\gamma_v \\rangle,</span>$</p>

    <p class="text-gray-300">which is a valid representation of the final public key  <span class="math">PK_{\\mathcal{A}}</span> . In formula,</p>

    <p class="text-gray-300"><span class="math">$y = g^{\\gamma_a} g&#x27;^{\\gamma_b} \\prod_{\\ell=1}^v h_\\ell^{\\gamma_\\ell} \\tag{38}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$PK_{\\mathcal{A}} \\doteq \\langle g, g&#x27;, y, \\langle x_{i_{\\ell}}, h_{\\ell} \\rangle_{\\ell-1}^{v} \\rangle.</span>$</p>

    <p class="text-gray-300">Considering discrete logarithms to the base g of Equation (38), we get:</p>

    <p class="text-gray-300"><span class="math">$A^{\\bar{t}}(0) + wB^{\\bar{t}}(0) = \\gamma_a + \\sum_{\\ell=1}^{v} A^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell} + w\\left(\\gamma_b + \\sum_{\\ell=1}^{v} B^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell}\\right)</span>$</p>

    <p class="text-gray-300">that can be rewritten as:</p>

    <p class="text-gray-300"><span class="math">$w\\left(\\gamma_b + \\sum_{\\ell=1}^{v} B^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell} - B^{\\bar{t}}(0)\\right) = A^{\\bar{t}}(0) - \\gamma_a - \\sum_{\\ell=1}^{v} A^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell}</span>$
(39)</p>

    <p class="text-gray-300">Notice that both the right-hand side and the coefficient of w in (39) are known, so that if such coefficient is non-zero (or, equivalently, if the right-hand side of (39) is non-zero), then we can successfully recover the value of w, thus violating Assumption 2. To complete the argument, it then suffices to show that the right-hand side of (39) is zero only with negligible probability, or equivalently that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\gamma_a = \\bar{\\gamma}_a] = 1/q \\tag{40}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\bar{\\gamma}_a \\doteq A^{\\bar{t}}(0) - \\sum_{\\ell=1}^v A^{\\bar{t}}(x_{i_\\ell}).</span>$</p>

    <p class="text-gray-300">To this aim, below we prove that, conditioning on all the other information in  <span class="math">\\mathcal{A}</span> 's view, the quantity  <span class="math">\\bar{\\gamma}_a</span>  is uniformly distributed in  <span class="math">\\mathbb{Z}_q</span> . It will follow that  <span class="math">\\mathcal{A}</span> 's chances of outputting a value  <span class="math">\\gamma_a</span>  equal to  <span class="math">\\bar{\\gamma}_a</span>  are just 1 in q, proving Equation (39) and thus the Lemma.</p>

    <p class="text-gray-300">To prove that  <span class="math">\\bar{\\gamma}_a</span>  is distributed uniformly in  <span class="math">\\mathbb{Z}_q</span> , we again make use of Lemma 1 following the same approach described in Section 5.2.</p>

    <p class="text-gray-300">Consider the quantity</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{V} \\doteq (\\mathsf{Coins}, w, \\{\\{c_j^t, r_j^t\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}})</span>$</p>

    <p class="text-gray-300">where Coins represents the coin tosses of  <span class="math">\\mathcal{A}</span> ,  <span class="math">w \\doteq \\log_g g&#x27;</span> , and  <span class="math">\\{\\{c_j^t, r_j^t\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}}</span>  represents all the randomness used in the  <span class="math">\\bar{t}</span>  New-period operations that took place during the  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^t(1^k)</span>  attack game.</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of the 2v+2 coefficients of the polynomials  <span class="math">A^0(\\cdot)</span> ,  <span class="math">B^0(\\cdot)</span>  and can be represented by a vector  <span class="math">\\boldsymbol{\\alpha}</span>  uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\alpha} \\doteq (a_0, a_1, \\dots, a_v, b_0, b_1, \\dots, b_v)^T.</span>$</p>

    <p class="text-gray-300">Consider the vector  <span class="math">\\boldsymbol{\\beta} \\in \\mathbb{Z}_q^{(v+m+2)\\times 1}</span>  defined as:</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{\\beta} \\doteq (\\mathbf{X}_0, \\mathbf{X}_1, \\dots, \\mathbf{X}_v, \\mathbf{A}_1, \\dots, \\mathbf{A}_m, \\bar{\\gamma}_a)^T</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_0 \\doteq A^0(0) + wB^0(0)</span> ,  <span class="math">\\mathbf{X}_\\ell \\doteq A^0(\\ell) + wB^0(\\ell)</span> , for  <span class="math">\\ell = 1, ..., v</span>  and  <span class="math">\\mathbf{A}_j \\doteq A^0(t_j)</span>  for j = 1, ..., m.</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the view of the adversary  <span class="math">\\mathcal{A}</span>  during the attack game  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^m(1^k)</span>  is completely determined by  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\boldsymbol{\\beta}</span> . In particular, the initial public key  <span class="math">PK^0</span>  is fixed by  <span class="math">\\boldsymbol{\\beta}</span>  and w, and the secret keys of the traitors are determined by the choice of  <span class="math">\\boldsymbol{\\beta}</span> , Coins and w.</p>

    <p class="text-gray-300">The quantities in V,  <span class="math">\\beta</span>  and  <span class="math">\\alpha</span>  are related according to the following matrix equation:</p>

    <p class="text-gray-300"><span class="math">$\\beta = \\mathbf{M} \\cdot \\boldsymbol{\\alpha} + \\boldsymbol{\\gamma}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\gamma \\in \\mathbb{Z}_q^{(v+m+2)\\times 1}</span>  is the vector</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\begin{aligned} \\begin{aligned} &amp;0 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(v+m+2)\\times(2v+2)}</span>  is the matrix</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} 1 &amp; 0 &amp; \\dots &amp; 0 &amp; w &amp; 0 &amp; \\dots &amp; 0 \\\\ 1 &amp; 1 &amp; \\dots &amp; 1 &amp; w &amp; w &amp; \\dots &amp; w \\\\ &amp; &amp; \\vdots &amp; &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ 1 &amp; v &amp; \\dots &amp; v^v &amp; w &amp; wv &amp; \\dots &amp; wv^v \\\\ 1 &amp; x_{t_1} &amp; \\dots &amp; x_{t_1}^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ &amp; &amp; \\vdots &amp; &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ 1 &amp; x_{t_m} &amp; \\dots &amp; x_{t_m}^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ 1 - \\sum_{\\ell=1}^v \\gamma_\\ell - \\sum_{\\ell=1}^v \\gamma_\\ell x_{i_\\ell} &amp; \\dots &amp; -\\sum_{\\ell=1}^v \\gamma_\\ell x_{i_\\ell}^v &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">By inspection, it is possible to see that the first v+m+1 rows of  <span class="math">\\mathbf{M}</span>  are linearly independent, provided that  <span class="math">w \\neq 0</span> . To see that the rank of  <span class="math">\\mathbf{M}</span>  is indeed v+m+2, define  <span class="math">\\mathbf{T} \\in \\mathbb{Z}_q^{m \\times v}</span>  to be the minor of matrix  <span class="math">\\mathbf{A}</span>  resulting from considering only rows  <span class="math">t_1, \\ldots, t_m</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{T} \\doteq \\begin{pmatrix} \\lambda_{i_1}^{(t_1)} &amp; \\dots &amp; \\lambda_{i_v}^{(t_1)} \\ \\dots &amp; \\dots &amp; \\dots \\ \\lambda_{i_1}^{(t_m)} &amp; \\dots &amp; \\lambda_{i_v}^{(t_m)} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">It is possible to show that if the last row of  <span class="math">\\mathbf{M}</span>  were in the linear span of the first v+m+1 rows of  <span class="math">\\mathbf{M}</span> , it would follow that  <span class="math">\\boldsymbol{\\delta}&#x27;</span>  should belong to the linear span of the rows of  <span class="math">\\mathbf{T}</span> . But since, by hypothesis,  <span class="math">\\boldsymbol{\\delta}&#x27;</span>  is not a linear combination of  <span class="math">\\boldsymbol{\\delta}&#x27;_{t_1}, \\ldots, \\boldsymbol{\\delta}&#x27;_{t_m}</span> , the matrix  <span class="math">\\mathbf{M}</span>  must have full rank.</p>

    <p class="text-gray-300">As soon as we fix V, the first v+m+1 entries of  <span class="math">\\gamma</span>  and the first v+1 rows of  <span class="math">\\mathbf{M}</span>  are determined, but  <span class="math">\\alpha</span>  is still distributed uniformly and independently at random in  <span class="math">\\mathbb{Z}_q^{(2v+2)\\times 1}</span> . Similarly to the proof of Lemma 3, it is also possible to show that fixing the first v+j+1 entries of  <span class="math">\\beta</span>  determines the (v+j+2)th row of  <span class="math">\\mathbf{M}</span> , for  <span class="math">j=1,\\ldots,m</span> ; and that moreover, fixing the first v+m+1 entries of  <span class="math">\\beta</span>  also determines the last rows of  <span class="math">\\gamma</span>  and of  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">Hence, by Lemma 1, we can conclude that the conditional distribution of  <span class="math">\\bar{\\gamma}_a</span>  w.r.t. V, and to the first v+m+1 entries of  <span class="math">\\beta</span> , is uniform over  <span class="math">\\mathbb{Z}_q</span> . In other words, conditioning on all the other information in  <span class="math">\\mathcal{A}</span> 's view, the quantity  <span class="math">\\bar{\\gamma}_a</span>  is uniformly distributed over  <span class="math">\\mathbb{Z}_q</span> . Equation (39), and thus the Lemma, follows.</p>

    <p class="text-gray-300">Lemma 7. Consider the Generalized Reed-Solomon code:</p>

    <p class="text-gray-300"><span class="math">$C&#x27; \\doteq \\left\\{ \\left\\langle -\\frac{\\lambda_1}{\\lambda_0^{(1)}} P(x_1), \\dots, -\\frac{\\lambda_n}{\\lambda_0^{(n)}} P(x_n) \\right\\rangle \\mid P \\in \\mathbb{Z}_q^{&lt; n-v}[x] \\right\\}.</span>$</p>

    <p class="text-gray-300">It holds that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">C = C'.</p></li>
      <li><p class="text-gray-300">C is a linear code with message-rate (n-v)/n and distance v+1.</p></li>
    </ol>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Proof.</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We only need to show that  <span class="math">\\mathcal{C}&#x27; \\subseteq \\mathcal{C}</span> . Indeed, assuming that  <span class="math">\\mathcal{C}&#x27;</span>  is a linear sub-space of  <span class="math">\\mathcal{C}</span> , since  <span class="math">\\dim(\\mathcal{C}) = n - v = \\dim(\\mathcal{C}&#x27;)</span> , it immediately follows that  <span class="math">\\mathcal{C} = \\mathcal{C}&#x27;</span> .</li>
    </ol>

    <p class="text-gray-300">To prove that  <span class="math">\\mathcal{C}&#x27; \\subseteq \\mathcal{C}</span> , notice that if  <span class="math">\\langle c_1, \\ldots, c_n \\rangle \\in \\mathcal{C}&#x27;</span> , then it is of the form</p>

    <p class="text-gray-300"><span class="math">$\\left\\langle -\\frac{\\lambda_1}{\\lambda_0^{(1)}} P(x_1), \\dots, -\\frac{\\lambda_n}{\\lambda_0^{(n)}} P(x_n) \\right\\rangle</span>$</p>

    <p class="text-gray-300">for some polynomial  <span class="math">P \\in \\mathbb{Z}_q^{&lt; n-v}[x]</span> . We now verify that  <span class="math">\\langle c_1, \\ldots, c_n \\rangle</span>  belongs to  <span class="math">\\mathcal{C}</span> . First, notice that for  <span class="math">\\ell = 1, \\ldots, v</span> , multiplying  <span class="math">\\langle c_1, \\ldots, c_n \\rangle</span>  by the  <span class="math">\\ell</span> th column of  <span class="math">\\mathbf{H}</span>  we get</p>

    <p class="text-gray-300"><span class="math">$\\langle c_1, \\dots, c_n \\rangle \\cdot \\langle -\\lambda_0^{(1)} x_1^{\\ell}, \\dots, -\\lambda_0^{(n)} x_n^{\\ell} \\rangle = \\sum_{i=1}^n \\lambda_i P(x_i) x_i^{\\ell}.</span>$</p>

    <p class="text-gray-300">Now observe that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{n} \\lambda_i P(x_i) x_i^{\\ell} = 0</span>$</p>

    <p class="text-gray-300">by the choice of  <span class="math">\\lambda_1, \\ldots, \\lambda_n</span>  and the facts that  <span class="math">\\operatorname{degree}(P) &lt; n - v</span>  and  <span class="math">\\ell \\le v</span>  (just consider the polynomial  <span class="math">Q(x) \\doteq P(x)x^{\\ell} \\in \\mathbb{Z}_q^{&lt; n}[x]</span> ). It follows that</p>

    <p class="text-gray-300"><span class="math">$\\langle c_1,\\ldots,c_n\\rangle\\cdot\\mathbf{H}=\\mathbf{0}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Observe that a vector of  <span class="math">\\mathbb{Z}_q^{n-v}</span>  can be encoded as the coefficients of a polynomial  <span class="math">P \\in \\mathbb{Z}_q^{&lt; n-v}[x]</span> . The corresponding codeword of  <span class="math">\\mathcal{C}</span>  will be the vector</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\langle -\\frac{\\lambda_1}{\\lambda_0^{(1)}}P(x_1),\\ldots,-\\frac{\\lambda_n}{\\lambda_0^{(n)}}P(x_n)\\rangle.</span>$</p>

    <p class="text-gray-300">To see that the distance of the linear code is v+1 observe that any two different codewords of C can agree on at most n-v-1 positions, or equivalently any two distinct codewords differ on at least v+1 positions.  <span class="math">\\square</span></p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Conclusions and Future Work</h2>

    <p class="text-gray-300">We introduce the first public-key traitor tracing scheme where an unlimited number of users can be efficiently added and removed from the system. Our scheme enjoys both client-side scalability, by supporting a dynamically-changing user population, and server-side scalability, as it enables many content providers to use a common content distribution infrastructure.</p>

    <p class="text-gray-300">We present a formal model for scalable public-key traitor tracing, and a thorough analysis of the revocation and tracing properties of our scheme against adaptive adversaries.</p>

    <p class="text-gray-300">At a technical level, our adversarial model improves over previous modeling for public-key traitor tracing by capturing a larger class of adversaries, endowed with greater control over system, than what previously considered in the related literature. In particular, in our model the adversary can control an a priori unbounded number of user additions and removals. The main limitation of our formal model is that the adversary is supposed to be fully revoked in a &quot;window&quot; of the system.</p>

    <p class="text-gray-300">An interesting open problem left open by our research consists of extending our results to a more general adversarial model, in which the adversary is not supposed to obey the &quot;window&quot; constrain.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We are grateful to Antonio Nicolosi for his constructive criticism and encouraging support throughout this research.</p>

    <p class="text-gray-300">We thank the anonymous referees for helping in improving the readability of the paper, and one of them in particular for pointing out a flaw in an early version of our scheme.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>E.R. Berlekamp and L. R. Welch. Error Correction of Algebraic Block Codes, 1986. U.S. Patent, Number 4,633,470.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. Bini and V. Y. Pan. Polynomial and Matrix Computations (vol. 1): Fundamental Algorithms. Birkhauser-Verlag, 1994.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. Boneh and M. Franklin. An Efficient Public Key Traitor Tracing Scheme. In Advances in Cryptology&mdash;Crypto '99, pages 338&ndash;353. Springer-Verlag, 1999. LNCS 1666. Full version available at crypto.stanford.edu/&tilde;dabo/pubs.html.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. Brands. Rethinking Public Key Infrastructures and Digital Certificates&mdash;Building in Privacy. PhD thesis, Technical University of Eindhoven, 1999.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>R. Canetti, J. Garay, G. Itkis, D. Micciancio, M. Naor, and B. Pinkas. Multicast Security: A Taxonomy and some Efficient Constructions. In Proceedings of IEEE INFOCOM '99, volume 2, pages 708&ndash;716, 1999.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>B. Chor, A. Fiat, and N. Naor. Tracing Traitors. In Advances in Cryptology&mdash;Crypto '94, pages 257&ndash;270. Springer-Verlag, 1994. LNCS 839.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>R. Cramer and V. Shoup. Design and Analysis of Practical Public-Key Encryption Scheme Secure against Adaptive Chosen Ciphertext Attack. SIAM Journal on Computing, 33(1):167&ndash;226, 2003.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Y. Dodis and N. Fazio. Public-Key Broadcast Encryption for Statless Receivers. In Digital Rights Management&mdash; DRM '02, pages 61&ndash;80. Springer, 2002. LNCS 2696.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Y. Dodis and N. Fazio. Public-Key Trace and Revoke Scheme Secure against Adaptive Chosen Ciphertext Attack. In Public Key Cryptography&mdash;PKC '03, pages 100&ndash;115. Springer-Verlag, 2003. LNCS 2567.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Fiat and M. Naor. Broadcast Encryption. In Advances in Cryptology&mdash;Crypto '93, pages 480&ndash;491. Springer-Verlag, 1993. LNCS 773.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>E. Gafni, J. Staddon, and Y. L. Yin. Efficient Methods for Integrating Traceability and Broadcast Encryption. In Advances in Cryptology&mdash;Crypto '99, pages 372&ndash;387. Springer-Verlag, 1999. LNCS 1666.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A Garay, J. Staddon, and A. Wool. Long-Lived Broadcast Encryption. In Advances in Cryptology&mdash;Crypto 2000, pages 333&ndash;352. Springer-Verlag, 2000. LNCS 1880.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>V. Guruswami and M. Sudan. Improved Decoding of Reed-Solomon and Algebraic-Geometric Codes. In IEEE Symposium on Foundations of Computer Science, pages 28&ndash;39, 1998.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Kiayias and M. Yung. Self Protecting Pirates and Black-Box Traitor Tracing. In Advances in Cryptology&mdash; Crypto '01, pages 63&ndash;79. Springer-Verlag, 2001. LNCS 2139.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>K. Kurosawa and Y. Desmedt. Optimum Traitor Tracing and new Direction for Asymmetricity. In Advances in Cryptology&mdash;EuroCrypt '98, pages 145&ndash;157. Springer-Verlag, 1998. LNCS 1403.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>F. J. MacWilliams and N. Sloane. The Theory of Error Correcting Codes. North Holland, Amsterdam, 1977.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. Naor, M. Naor, and J. Lotspiech. Revocation and Tracing Schemes for Stateless Receivers. In Advances in Cryptology&mdash;Crypto '01, pages 41&ndash;62. Springer-Verlag, 2001. LNCS 2139.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Naor and B. Pinkas. Threshold Traitor Tracing. In Advances in Cryptology&mdash;Crypto '98, pages 502&ndash;517. Springer-Verlag, 1998. LNCS 1462.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Naor and B. Pinkas. Efficient Trace and Revoke Schemes. In Financial Cryptography&mdash;FC 2000, pages 1&ndash;20. Springer-Verlag, 2000. LNCS 1962. Full version available at www.wisdom.weizmann.ac.il/&tilde;naor/onpub.html.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. R. Stinson and R. Wei. Combinatorial Properties and Constructions of Traceability Schemes and Frameproof Codes. SIAM Journal on Discrete Mathematics, 11(1):41&ndash;53, 1998.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>W.G. Tzeng and Z.J. Tzeng. A Public-Key Traitor Tracing Scheme with Revocation Using Dynamics Shares. In Public Key Cryptography&mdash;PKC '01, pages 207&ndash;224. Springer-Verlag, 2001. LNCS 1992.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. Wallner, E. Harder, and R. Agee. Key Management for Multicast: Issues and Architectures. Available at ftp://ftp.ietf.org/rfc/rfc2627.txt, 1997.</li>
    </ul></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Scalable Public-Key Tracing and Revoking (2004/160)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/160
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="scalable-public-key-tracing-and-revoking-2004" />
  </article>
</BaseLayout>
