---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/160';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Scalable Public-Key Tracing and Revoking';
const AUTHORS_HTML = 'Yevgeniy Dodis, Nelly Fazio, Aggelos Kiayias, Moti Yung';

const CONTENT = `    <p class="text-gray-300">Yevgeniy Dodis [ Computer Science Department Courant Institute of Mathematical Sciences New York University, New York, NY, USA {dodis,fazio}@cs.nyu.edu ] Nelly Fazio [ Computer Science & Engineering Department University of Connecticut, Storrs, CT, USA aggelos@cse.uconn.edu ] Aggelos Kiayias [ Department of Computer Science Columbia University, New York, NY, USA moti@cs.columbia.edu ] Moti Yung [ Department of Computer Science Columbia University, New York, NY, USA</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Traitor Tracing Schemes constitute a very useful tool against piracy in the context of digital content broadcast. In such multi-recipient encryption schemes, each decryption key is fingerprinted and when a pirate decoder is discovered, the authorities can trace the identities of the users that contributed in its construction (called traitors). Public-key traitor tracing schemes allow for a multitude of non-trusted content providers using the same set of keys, which makes the scheme “server-side scalable.” To make such schemes also “client-side scalable,” i.e. long lived and usable for a large population of subscribers that changes dynamically over time, it is crucial to implement efficient Add-user and Remove-user operations. Previous work on public-key traitor tracing did not address this dynamic scenario thoroughly, and there is no efficient scalable public key traitor tracing scheme that allows an increasing number of Add-user and Remove-user operations. To address these issues, we introduce the model of Scalable Public-Key Traitor Tracing, and present the first construction of such a scheme. Our model mandates for deterministic traitor tracing and an unlimited number of efficient Add-user operations and Remove-user operations. A scalable system achieves an unlimited number of revocations while retaining high level of efficiency by dividing the run-time of the system into periods. Each period has a saturation level for the number of revocations. When a period becomes saturated, an efficient New-period operation is issued by the system server that resets the saturation level. We present a formal adversarial model for our system taking into account its periodic structure, and we prove our construction secure, both against adversaries that attempt to cheat the revocation mechanism as well as against adversaries that attempt to cheat the traitor tracing mechanism.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">keywords:</h6>

    <p class="text-gray-300">Digital Content Distribution – Traitor Tracing – Scalability – Broadcast Encryption – Multicast</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">An important application of global networking is digital content distribution. For such an application (e.g ., Pay-TV) to remain economically viable for the long run, it is important to design distribution schemes with certain basic properties: (1) security—this assures a subscription-based model of exclusive content reception; (2) scalability—which assures efficient operation supporting many content providers and a dynamically changing population of subscribers; and (3) piracy protection—to prevent or deter illegal distribution.</p>

    <p class="text-gray-300">To achieve security, a content distribution scheme requires the implementation of a multi-user encryption mechanism that assures that only current subscribers can receive the content.</p>

    <p class="text-gray-300">Regarding piracy protection, the state of the art method which applies to software-based platform-independent architectures, is the notion of traitor tracing schemes which we concentrate on in this work. A traitor tracing scheme is a multi-recipient encryption system that can be used for digital content distribution, with the property that the decryption key of each user is marked (fingerprinted). The server of the system is capable of using a traitor tracing algorithm: a procedure that given access to a pirate decoder is capable</p>

    <p class="text-gray-300">of recovering identities of subscribers that participated in its construction (called traitors). A traitor tracing scheme is, therefore, a deterrence to piracy due to the fear of exposure.</p>

    <p class="text-gray-300">Scalable Systems. In the context of content distribution, scalability has two facets: server-side and client-side.</p>

    <p class="text-gray-300">Server-side scalability is assured by employing a public-key scheme, which allows any third party to use the encryption mechanism and broadcast digital content to the set of subscribers. This is very appealing as it allows a multitude of digital-content providers (e.g. many different channels) to take advantage of the availability of secure broadcast to distribute their content without the need to maintain relationships with clients. The clients are, in fact, managed by the system server that is only responsible for maintaining and assigning the clients’ decryption keys as well as publishing the encryption key. Namely, the server acts as a pure key (and account) management service.</p>

    <p class="text-gray-300">Regarding client-side scalability, observe that digital content distribution systems typically involve a large population of users (accounts), that is changing dynamically during the life-time of the system. New users should be introduced, and others need to be removed from the active user population entitled to receive the digital content. To allow for a scalable management of accounts, keys should be easy to generate and revoke.</p>

    <p class="text-gray-300">To date, no schemes have been proposed that provide both client-side and server-side scalability in the context of traitor tracing schemes. This motivates us to define and realize a Scalable Public-Key Traitor Tracing Schemes which achieves this combination.</p>

    <p class="text-gray-300">Previous Results. Traitor Tracing Schemes were introduced by Chor et al. <em>[6]</em>, who employed a probabilistic design: each user possesses a different subset of a set of keys and tracing is achieved using the properties of the key assignment. The results of Chor et al. were later implemented with concrete combinatorial designs by <em>[20]</em>. These schemes do not possess a Remove-user operation. Later these results were extended by <em>[11, 17]</em>, who also considered the combination of traitor tracing schemes with efficient revocation methods (cf. broadcast encryption, <em>[10]</em>). These schemes are not scalable, since (i) they do not support public-key technology in an efficient fashion, (ii) they employ combinatorial designs for the key-assignment that require a tight guess of an a-priori bound on the number of users, and (iii) the ciphertext size is an increasing function of the total number of revoked users in the system’s life-time.</p>

    <p class="text-gray-300">A “native” public-key traitor tracing scheme was introduced in <em>[15, 3]</em> (the latter introduced a public-key scheme with deterministic traceability); both schemes did not consider revocation of keys. This was considered in the work of <em>[19]</em>, which described several schemes in the symmetric-key setting and a public-key scheme. In particular, one of the scheme proposed in <em>[19]</em> (Revocation Method 2), provides security guarantees comparable to those obtained by our scheme, but it applies to the symmetric-key setting, thus making it impossible for several content providers to serve the same user population without trusting each other, effectively forgoing server-side scalability (enjoyed by our scheme).</p>

    <p class="text-gray-300">On the other hand, the public-key method proposed in <em>[19]</em> provides server-side scalability, but can only withstand a bounded number of revocations: if the number of revocations executed in the life-time of the system exceeds the bound, previously revoked users could gain unlawful access to the system. Furthermore, the ciphertext size is linear in the revocation bound, something that prohibits (for efficiency purposes) to set the bound to a large value.</p>

    <p class="text-gray-300">Public-key traitor tracing schemes with comparable revocation capabilities as the scheme in <em>[19]</em> (bounded number of revocations) were also designed in <em>[21]</em> and <em>[8, 9]</em>. In all these schemes the bound on the number of revocations is proportional to the ciphertext size of the system. We remark that the scheme of <em>[8]</em> allows for an unlimited number of revocations, however this results in a degradation of the scheme’s efficiency in the course of its run-time operation (as ciphertext sizes also depend logarithmically on the size of the user population). We note that client-side scalability was recognized as an important issue and was considered in the context of long lived broadcast encryption in <em>[12]</em>; it can also be achieved in the context of multicast refresh-key <em>[22, 5, 19]</em>. These schemes however, do not operate in a server-scalable environment. In conclusion,</p>

    <p class="text-gray-300">to the best of our knowledge, none of the existing schemes satisfies the requirements of a Scalable Public-Key Traitor Tracing Scheme.</p>

    <p class="text-gray-300">Our Results. We introduce the first carefully formalized model of a scalable public-key traitor tracing scheme where an unlimited number of users can be added and removed efficiently from the system and we present a concrete scheme meeting these requirements, based on the DDH assumption. Addition of users does not affect the keys of the existing users of the system. Furthermore, the design does not require an a-priori bound on the number of users. User removal is achieved by dividing the run-time of the system into periods; in each period a bounded number of user removals can be executed; unlimited number of user-removals is achieved in our design by the implementation of an efficient New-period operation.</p>

    <p class="text-gray-300">Our scheme allows efficient deterministic traitor tracing that recovers all traitors (in the non-black-box traceability setting), while supporting the black-box confirmation method <em>[3]</em>, (for black-box traitor tracing model).</p>

    <p class="text-gray-300">In a scalable scheme, adversaries can run the Add-user protocol to introduce adversarially-controlled users in the system, and they can observe the modifications to the public key of the scheme that occur during the run-time operation of the scheme and potentially take advantage of them. We consider two types of adversaries, the ones that attempt to defeat the revocation mechanism of the system and the ones that try to elude the traceability capability. Since the adversarial goal is distinct in these two cases, we consider the following classification of adversaries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Window Adversary: the adversary obtains some user-keys that are subsequently revoked; the adversary remains active and observes the revocation of other users of the system (in fact we allow the adversary to adaptively select which users should be revoked). We show that our construction is secure against window adversaries as long as they are fully revoked in a “window” of the system’s operation that has a certain length (which is specified as a system parameter).</li>

      <li>Traceability Adversary: the adversary obtains some user-keys and constructs a pirate decryption device, employing the secret user-key information (in fact we allow the adversary to adaptively select the identities of the traitors). We show that our construction is secure against this type of adversaries in the non-black-box traitor tracing model. Our traitor tracing algorithm is deterministic and recovers the identities of all traitors. Furthermore, our scheme supports the black-box confirmation method, that allows a form of traceability in the black-box traitor tracing model, <em>[3]</em>.</li>

    </ul>

    <p class="text-gray-300">In Table 1, we compare our construction to previously proposed public-key schemes. The advantage of our scalable public-key traitor tracing scheme over previous results comes from the fact that any adversary fully revoked in a window of the system’s operation will, in fact, “expire.” An expired adversary will be incapable of intercepting the scrambled content (in the semantic security sense) even if it remains active in the system (and can still observe and even cause other users to get revoked). It is the capability of our scheme to expire adversaries that allows for the enhanced functionality of an unlimited number of revocations. None of the previous public-key traitor tracing schemes with revocation capability <em>[19, 21, 8, 9]</em> possessed this crucial property. Although the work of <em>[19]</em> described a private-key scheme providing a similar kind of functionality, achieving this in the server-scalable, public-key setting, and properly formalizing the adversarial model constitutes a technical challenge and the undertaking of this work.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Our Model: Scalable Public-Key Tracing and Revoking</h2>

    <p class="text-gray-300">The life-time of a scalable public-key traitor tracing scheme is divided into periods. A period is an administrative unit managed based on activity and potentially time passing.</p>

    <p class="text-gray-300">A scalable scheme is comprised of the following basic procedures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup. An initialization procedure that is executed by the server, which generates a master secret key <span class="math">MSK</span> along with a public key <span class="math">PK</span>; the server keeps <span class="math">MSK</span> secret and publishes <span class="math">PK</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ciphertext Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Maximum Traceable Coalition Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Add-User</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remove-User</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adversaries Expire</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CFN94 [6] (as PK)</td>

            <td class="px-3 py-2 border-b border-gray-700">O((5/2)3 log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">v/2 (probabilistic-BB)</td>

            <td class="px-3 py-2 border-b border-gray-700">Bounded</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KD98 [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Unbounded</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BF99 [3]</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">v/2 (any Non-BB) + BB Confirmation</td>

            <td class="px-3 py-2 border-b border-gray-700">Bounded</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NP00 [19] (PK-Scheme)</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">v/2 (Non-BB + spe-cialized adversaries)</td>

            <td class="px-3 py-2 border-b border-gray-700">Unbounded</td>

            <td class="px-3 py-2 border-b border-gray-700">Up to v revoca-tions</td>

            <td class="px-3 py-2 border-b border-gray-700">NO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TT01 [21]</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">BB Confirmation</td>

            <td class="px-3 py-2 border-b border-gray-700">Unbounded</td>

            <td class="px-3 py-2 border-b border-gray-700">Up to v revoca-tions</td>

            <td class="px-3 py-2 border-b border-gray-700">NO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DF02 [8]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(v log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">Unbounded</td>

            <td class="px-3 py-2 border-b border-gray-700">Bounded</td>

            <td class="px-3 py-2 border-b border-gray-700">Unbounded</td>

            <td class="px-3 py-2 border-b border-gray-700">NO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DF03 [9]</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">BB Confirmation</td>

            <td class="px-3 py-2 border-b border-gray-700">Unbounded</td>

            <td class="px-3 py-2 border-b border-gray-700">Up to v revoca-tions</td>

            <td class="px-3 py-2 border-b border-gray-700">NO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">v/2 (any Non-BB) + BB Confirmation</td>

            <td class="px-3 py-2 border-b border-gray-700">Unbounded</td>

            <td class="px-3 py-2 border-b border-gray-700">Up to v per period, un-bounded overall</td>

            <td class="px-3 py-2 border-b border-gray-700">YES</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Comparison of the main construction of this paper to previous public-key traitor tracing schemes. The parameters used in the table are  <span class="math">n = \\#</span>  of users,  <span class="math">v = \\#</span>  of revocations. Note that "BB" stands for Black-Box, BB-Confirmation stands for the Black-Box Confirmation method of [3] that requires exponential-time, and "unbounded" means that any polynomial number of users (in the security parameter) can be supported.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Broadcast Encryption. A public encryption algorithm  <span class="math">\\mathcal{E}</span>  that takes as input the public key  <span class="math">PK</span> , and a plaintext  <span class="math">M</span> , and outputs a ciphertext  <span class="math">C</span> . The ciphertext  <span class="math">C</span>  is distributed to a population of users through an insecure broadcast channel.</li>

      <li>Decryption. A deterministic algorithm  <span class="math">\\mathcal{D}</span>  that takes as input the ciphertext  <span class="math">C</span> , and a user's secret key and decrypts  <span class="math">C</span> .</li>

      <li>Add-user. It is a key-generation procedure that results in a personalized secret key  <span class="math">SK</span>  that can be used to invert the public key  <span class="math">PK</span> . It is executed by the server and secretly communicated to a new user of the system.</li>

      <li>Remove-user. A procedure that given a public key  <span class="math">PK</span>  and a user's secret key  <span class="math">SK</span> , results in a public key  <span class="math">PK&#x27;</span> , so that for all messages  <span class="math">M</span> ,  <span class="math">\\mathcal{E}(PK&#x27;, M)</span>  should be "incomprehensible" for the user holding the revoked secret key  <span class="math">SK</span> , while non-removed users should be capable of decrypting it. The revocation procedure has a saturation limit that is an upper bound to the number of users that can be removed inside a period.</li>

      <li>Tracing. A procedure that given the contents of a pirate decoder outputs the identities of the traitor users whose keys are employed in the pirate decoder.</li>

      <li>New-period. A procedure executed by the server to initiate a fresh period, by means of transmitting (on the broadcast channel) a special message transmitted to the active subscribers of the system. Users removed in previous periods should be incapable of decrypting data subsequently transmitted within the new period. A New-period operation occurs when the saturation limit is reached (a reactive change), or when a certain time-limit is reached (a pro-active change).</li>

    </ul>

    <p class="text-gray-300">SCALABILITY OBJECTIVES. The properties of the various functions of a scalable scheme should satisfy the following requirements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficient addition of unlimited number of users throughout the scheme's operation. Specifically, the Add-user operation should be a protocol executed between a new user and the server, that should have (i) communication independent of the size of the user population, and (ii) it should not involve the existing users of the system in any way.</li>

      <li>Efficient traitor tracing of a pirate decoder. Specifically, the tracing procedure should be polynomial-time in the number of users and the number of traitors.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficient revocation of the decryption capabilities of a set of users inside a period, provided that the number of users to be removed is below the saturation limit. Specifically, Remove-user should have time complexity independent of the number of users, and should be executed solely by the server, affecting only the public key of the system.</li>

      <li>Efficient introduction of a new period. The communication overhead for changing a period should be independent of the number of users of the system and it should not require private communication channels between the server and the active users (but contrary to Remove-user it will require from users to modify their secret keys—as a result in our model users are stateless within a period and stateful across periods).</li>

    </ul>

    <p class="text-gray-300">Formal Modeling of Scalable Schemes. The functionality of a scalable public-key traitor tracing scheme should be two fold: on one hand, it should be capable of identifying users that participate in the construction of pirate decoders; on the other hand, the system should be capable of revoking the decryption capabilities of “bad” users. We formally model the security of tracing and revocation in Section 5 and Section 6, respectively.</p>

    <h2 id="sec-6" class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300">Throughout the paper, <span class="math">k</span> will denote a security parameter; let <span class="math">q</span> be a <span class="math">k</span>-bit prime number and let <span class="math">\\mathcal{G}</span> be a large cyclic group of order <span class="math">q</span>. We assume that <span class="math">\\mathcal{G}</span> is the (multiplicative) subgroup of order <span class="math">q</span> of <span class="math">\\mathbb{Z}_{p}^{*}</span>, where <span class="math">q\\mid(p-1)</span> and <span class="math">p</span> is a large prime. Alternatively, one can take as group <span class="math">\\mathcal{G}</span> the (additive) group of points of an elliptic curve over a finite field.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Consider the two distributions over <span class="math">\\mathcal{G}^{4}</span>:</p>

    <p class="text-gray-300"><span class="math">R\\doteq\\{\\langle g,g^{\\prime},u,u^{\\prime}\\rangle\\mid g,g^{\\prime},u,u^{\\prime}\\in\\mathcal{G}\\}</span> <span class="math">D\\doteq\\{\\langle g,g^{\\prime},u,u^{\\prime}\\rangle\\mid g,g^{\\prime},u,u^{\\prime}\\in\\mathcal{G},\\log_{g}u=\\log_{g^{\\prime}}u^{\\prime}\\}.</span></p>

    <p class="text-gray-300">For all 0/1-valued probabilistic polynomial-time algorithm <span class="math">\\mathcal{A}</span> and for all <span class="math">k\\in\\mathbb{Z}_{\\geq 0}</span> , define the <span class="math">\\mathsf{DDH}</span> advantage of <span class="math">\\mathcal{A}</span> against <span class="math">\\mathcal{G}</span> at <span class="math">k</span> as:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{AdvDDH}_{\\mathcal{G},\\mathcal{A}}(k)\\doteq\\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[\\tau=1\\mid\\rho\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\;R;\\tau\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\;\\mathcal{A}(1^{k},\\rho)]-$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the probability is over the random coins of <span class="math">\\mathcal{A}</span> and the random choice of <span class="math">\\rho</span> from <span class="math">R</span> and <span class="math">D</span>, respectively.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{AdvDDH}_{\\mathcal{G}}(k)\\doteq\\max_{\\mathcal{A}}\\mathsf{AdvDDH}_{\\mathcal{G},\\mathcal{A}}(k)</span>, where the <span class="math">max</span> is over all probabilistic, polynomial-time 0/1-valued algorithms <span class="math">\\mathcal{A}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Assumption 1 (Decisional Diffie-Hellman Assumption)</h6>

    <p class="text-gray-300">The Decisional Diffie-Hellman (<span class="math">\\mathsf{DDH}</span>) assumption for <span class="math">\\mathcal{G}</span> asserts that the function <span class="math">\\mathsf{AdvDDH}_{\\mathcal{G}}(k)</span> is negligible in <span class="math">k</span>.</p>

    <p class="text-gray-300">In the following, we will also need a (weaker) assumption about the hardness of computing discrete logarithms in <span class="math">\\mathcal{G}</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">For all probabilistic polynomial-time algorithm <span class="math">\\mathcal{A}</span> and for all <span class="math">k\\in\\mathbb{Z}_{\\geq 0}</span> , define the <span class="math">\\mathsf{DLog}</span> advantage of <span class="math">\\mathcal{A}</span> against <span class="math">\\mathcal{G}</span> at <span class="math">k</span> as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AdvDLog}_{\\mathcal{G},\\mathcal{A}}(k)\\doteq\\Pr[w^{\\prime}=w\\mid g,g^{\\prime}\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\;\\mathcal{G};w\\leftarrow\\log_{g}g^{\\prime};</span> <span class="math">w^{\\prime}\\leftarrow\\mathcal{A}(1^{k},g,g^{\\prime})].</span></p>

    <p class="text-gray-300">where the probability is over the random coins of <span class="math">\\mathcal{A}</span> and the random choice of <span class="math">g,g^{\\prime}</span> from <span class="math">\\mathcal{G}</span>.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{AdvDLog}_{\\mathcal{G}}(k)\\doteq max_{\\mathcal{A}}\\mathsf{AdvDLog}_{\\mathcal{G},\\mathcal{A}}(k)</span>, where the <span class="math">max</span> is over all probabilistic, polynomial-time algorithms <span class="math">\\mathcal{A}</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Assumption 2 (Discrete Logarithm Assumption)</h6>

    <p class="text-gray-300">The Discrete Logarithm (<span class="math">\\mathsf{DLog}</span>) assumption for <span class="math">\\mathcal{G}</span> asserts that the function <span class="math">\\mathsf{AdvDLog}_{\\mathcal{G}}(k)</span> is negligible in <span class="math">k</span>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.1 Discrete-Log Representations</h3>

    <p class="text-gray-300">Let <span class="math">g</span> be a generator of <span class="math">\\mathcal{G}</span> and let <span class="math">h_{0},h_{1},\\ldots,h_{v}</span> be elements of <span class="math">\\mathcal{G}</span> such that</p>

    <p class="text-gray-300"><span class="math">h_{j}=g^{r_{j}}</span></p>

    <p class="text-gray-300">with <span class="math">j=0,\\ldots,v</span> and <span class="math">r_{0},\\ldots,r_{v}\\in\\mathbb{Z}_{q}</span>. For a certain element <span class="math">y\\doteq g^{b}</span> of <span class="math">\\mathcal{G}</span>, a representation of <span class="math">y</span> with respect to the base <span class="math">h_{0},\\ldots,h_{v}</span> is a <span class="math">(v+1)</span>-vector</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\delta}\\doteq\\langle\\delta_{0},\\ldots,\\delta_{v}\\rangle</span></p>

    <p class="text-gray-300">such that:</p>

    <p class="text-gray-300"><span class="math">y=h_{0}^{\\delta_{0}}\\cdot\\ldots\\cdot h_{v}^{\\delta_{v}}</span></p>

    <p class="text-gray-300">or equivalently <span class="math">\\boldsymbol{\\delta}\\cdot\\boldsymbol{r}=b</span> where “<span class="math">\\cdot</span>” denotes the inner product of two vectors modulo <span class="math">q</span>.</p>

    <p class="text-gray-300">It is well known (e.g., see <em>[4]</em>) that obtaining representations of a given <span class="math">y</span> w.r.t. some base <span class="math">h_{0},\\ldots,h_{v}</span> is as hard as the discrete-log problem over <span class="math">\\mathcal{G}</span>. Furthermore, it was shown in Lemma 3.2 of <em>[3]</em> that if some adversary is given <span class="math">m&lt;v</span> random representations of some <span class="math">y</span> with respect to some base, then any additional representation that can be obtained has to be a “convex combination” of the given representations (a convex combination of the vectors <span class="math">\\boldsymbol{\\delta_{1}},\\ldots,\\boldsymbol{\\delta_{m}}</span> is a vector <span class="math">\\sum_{\\ell=1}^{m}\\mu_{\\ell}\\boldsymbol{\\delta_{\\ell}}</span> with <span class="math">\\sum_{\\ell=1}^{m}\\mu_{\\ell}=1</span>). However, our scheme makes use of a particular family of discrete-log representations, introduced below. In Section 6 we will see how Lemma 3.2 of <em>[3]</em> can be modified accordingly.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.2 Leap-Vectors</h3>

    <p class="text-gray-300">We introduce a new family of discrete-log representations, called <em>leap-vectors</em>. In what follows, we denote with <span class="math">\\mathbb{Z}_{q}^{v}[x]</span> the set of <span class="math">v</span>-degree polynomials over <span class="math">\\mathbb{Z}_{q}</span>; and with <span class="math">\\mathbb{Z}_{q}^{&lt;v}[x]</span> the ring of polynomials over <span class="math">\\mathbb{Z}_{q}</span> with degree less than <span class="math">v</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">Given <span class="math">z_{1},\\ldots,z_{v}\\in\\mathbb{Z}_{q}</span> and <span class="math">P(x)\\in\\mathbb{Z}_{q}^{v}[x]</span>, the set <span class="math">\\mathcal{L}_{z_{1},\\ldots,z_{v}}^{P}</span> of leap-vectors w.r.t. <span class="math">P(\\cdot)</span> and the values <span class="math">z_{1},\\ldots,z_{v}</span>, consists of all vectors <span class="math">\\boldsymbol{\\alpha}\\in\\mathbb{Z}_{q}^{v+1}</span> for which it holds that:</p>

    <p class="text-gray-300"><span class="math">P(0)=\\boldsymbol{\\alpha}\\cdot\\langle 1,P(z_{1}),\\ldots,P(z_{v})\\rangle.</span> (1)</p>

    <p class="text-gray-300">In other words, a leap-vector w.r.t. <span class="math">P(\\cdot)</span> and <span class="math">z_{1},\\ldots,z_{v}</span>, is a representation of <span class="math">g^{P(0)}</span> with respect to the base</p>

    <p class="text-gray-300"><span class="math">g,g^{P(z_{1})},\\ldots,g^{P(z_{v})}.</span></p>

    <p class="text-gray-300">Given any leap-vector <span class="math">\\boldsymbol{\\alpha}:=\\langle\\alpha_{0},\\ldots,\\alpha_{v}\\rangle</span> w.r.t. some values <span class="math">z_{1},\\ldots,z_{v}</span>, it is possible to derive the equation</p>

    <p class="text-gray-300"><span class="math">\\alpha_{0}=\\left(1-\\sum_{\\ell=1}^{v}\\alpha_{\\ell}\\right)a_{0}+\\sum_{j=1}^{v}\\left(\\sum_{\\ell=1}^{v}z_{\\ell}^{j}\\alpha_{\\ell}\\right)a_{j}</span></p>

    <p class="text-gray-300">over the coefficients of the polynomial</p>

    <p class="text-gray-300"><span class="math">P(x):=a_{0}+a_{1}x+\\ldots+a_{v}x^{v}.</span></p>

    <p class="text-gray-300">If one possesses a point <span class="math">\\langle x_{i},P(x_{i})\\rangle</span> of the polynomial <span class="math">P(\\cdot)</span>, it is possible to generate a leap-vector for the values <span class="math">z_{1},\\ldots,z_{v}</span> (provided that <span class="math">x_{i}\\not\\in\\{z_{1},\\ldots,z_{v}\\}</span>) using Lagrange interpolation.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">Given distinct <span class="math">x_{i},z_{1},\\ldots,z_{v}\\in\\mathbb{Z}_{q}</span>, and <span class="math">P(x)\\in\\mathbb{Z}_{q}^{v}[x]</span>, define the leap-vector <span class="math">\\bm{\\nu}_{z_{1},\\ldots,z_{v}}^{x_{i},P}</span> associated to the point <span class="math">\\langle x_{i},P(x_{i})\\rangle</span> w.r.t. <span class="math">P(\\cdot)</span> and <span class="math">z_{1},\\ldots,z_{v}</span> as:</p>

    <p class="text-gray-300"><span class="math">\\bm{\\nu}_{z_{1},\\ldots,z_{v}}^{x_{i},P}\\doteq\\langle\\lambda_{0}^{(i)}P(x_{i}),\\lambda_{1}^{(i)},\\ldots,\\lambda_{v}^{(i)}\\rangle</span> (2)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\lambda_{0}^{(i)}\\doteq\\prod_{j=1}^{v}\\frac{x_{i}}{x_{i}-z_{j}}</span> (3)</p>

    <p class="text-gray-300">and, for <span class="math">\\ell=1,\\ldots,v</span></p>

    <p class="text-gray-300"><span class="math">\\lambda_{\\ell}^{(i)}\\doteq\\frac{z_{\\ell}}{z_{\\ell}-x_{i}}\\cdot\\prod_{\\stackrel{{\\scriptstyle j=1}}{{\\scriptstyle j\\neq 1}}}^{v}\\frac{z_{\\ell}}{z_{\\ell}-z_{j}}.</span> (4)</p>

    <p class="text-gray-300">An important property of leap-vectors is the following:</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Given a polynomial <span class="math">P(\\cdot)\\in\\mathbb{Z}_{q}^{v}[x]</span> and the values <span class="math">z_{1},\\ldots,z_{v}\\in\\mathbb{Z}_{q}</span>, knowledge of a leap-vector <span class="math">\\bm{\\alpha}\\in\\mathcal{L}_{z_{1},\\ldots,z_{v}}^{P}</span> implies knowledge of a linear equation on the coefficients of <span class="math">P(\\cdot)</span> linearly independent from the linear equations defined using <span class="math">\\langle z_{1},P(z_{1})\\rangle,\\ldots,\\langle z_{v},P(z_{v})\\rangle</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Define</p>

    <p class="text-gray-300"><span class="math">\\bm{\\pi}\\doteq(P(z_{1}),P(z_{2}),\\ldots,P(z_{v}),\\alpha_{0})^{T}.</span></p>

    <p class="text-gray-300">The constraint on the coefficients <span class="math">a_{0},a_{1},\\ldots,a_{v}</span> of the polynomial <span class="math">P(\\cdot)</span> arising from points <span class="math">\\langle z_{1},P(z_{1})\\rangle,\\ldots,\\langle z_{v},P(z_{v})\\rangle</span> and the equation associated to the leap-vector <span class="math">\\bm{\\alpha}</span>, can be represented as:</p>

    <p class="text-gray-300"><span class="math">\\bm{\\pi}=\\mathbf{M}\\cdot\\bm{a}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\bm{a}\\doteq(a_{0},a_{1},\\ldots,a_{v})^{T}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">\\[ \\mathbf{M}\\doteq\\left(\\begin{array}[]{cccc}1&z_{1}&\\ldots&z_{1}^{v}\\\\ 1&z_{2}&\\ldots&z_{2}^{v}\\\\ \\vdots&\\vdots&\\vdots&\\vdots\\\\ 1&z_{v}&\\ldots&z_{v}^{v}\\\\ 1-\\sum_{j=1}^{v}\\alpha_{j}&-\\sum_{j=1}^{v}\\alpha_{j}z_{j}&\\ldots&-\\sum_{j=1}^{v}\\alpha_{j}z_{j}^{v}\\end{array}\\right) \\]</p>

    <p class="text-gray-300">Notice that matrix <span class="math">\\mathbf{M}</span> above is obtained from a Vandermonde matrix by adding a linear combination of the first <span class="math">v</span> rows to the last one. Since every Vandermonde matrix has full rank, it follows that <span class="math">\\mathbf{M}</span> has full rank, too. Hence, the equation defined by the leap-vector <span class="math">\\bm{\\alpha}</span> is linearly independent to the equations defined by the points <span class="math">\\langle z_{1},P(z_{1})\\rangle,\\ldots,\\langle z_{v},P(z_{v})\\rangle</span>. ∎</p>

    <p class="text-gray-300">As a result, the possession of a leap-vector implies some knowledge about the polynomial <span class="math">P(\\cdot)</span> <em>beyond</em> what is implied by the points <span class="math">\\langle z_{1},P(z_{1})\\rangle,\\ldots,\\langle z_{v},P(z_{v})\\rangle</span>. In other words, a leap-vector is the necessary information needed to <em>leap</em> from the values <span class="math">P(z_{1}),\\ldots,P(z_{v})</span> to the value <span class="math">P(0)</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">4 Our Scheme</h2>

    <p class="text-gray-300">Setup. The description of a cyclic multiplicative group <span class="math">\\mathcal{G}</span> of order <span class="math">q</span> is generated. Then, two random generators <span class="math">g,g^{\\prime}\\in\\mathcal{G}</span> and two random polynomials <span class="math">A(\\cdot),B(\\cdot)\\in\\mathbb{Z}_{q}^{v}[x]</span> are selected. The parameter <span class="math">v</span> will be also referred to as the <em>saturation limit</em>, whereas <span class="math">m=\\lfloor\\frac{v}{2}\\rfloor</span> will be the <em>maximum traitor collusion size</em>. Define</p>

    <p class="text-gray-300"><span class="math">A(x)</span> <span class="math">:=a_{0}+a_{1}x+\\ldots+a_{v}x^{v}</span> <span class="math">B(x)</span> <span class="math">:=b_{0}+b_{1}x+\\ldots+b_{v}x^{v}.</span></p>

    <p class="text-gray-300">The master secret key is</p>

    <p class="text-gray-300"><span class="math">MSK:=(A(\\cdot),B(\\cdot))</span></p>

    <p class="text-gray-300">and the system’s public key is</p>

    <p class="text-gray-300"><span class="math">PK:=\\langle g,g^{\\prime},g^{A(0)}g^{\\prime B(0)},\\langle\\ell,g^{A(\\ell)}g^{\\prime B(\\ell)}\\rangle_{\\ell=1}^{v}\\rangle</span></p>

    <p class="text-gray-300">where indices <span class="math">1,\\ldots,v</span> are used as place-holders. The server initiates a new period by publishing <span class="math">PK</span>, and sets the saturation level <span class="math">L</span> to <span class="math">0</span>. <span class="math">L</span> is a system variable known to the server.</p>

    <p class="text-gray-300">Add-user. When a new user <span class="math">i</span> requests to join the system, the server transmits (over a private channel) the tuple <span class="math">\\langle x_{i},A(x_{i}),B(x_{i})\\rangle</span> to user <span class="math">i</span>, where</p>

    <p class="text-gray-300"><span class="math">x_{i}\\xleftarrow{r}\\mathbb{Z}_{q}\\quad x_{i}\\not\\in\\{1,\\ldots,v\\}\\cup\\mathcal{U}.</span></p>

    <p class="text-gray-300">The set <span class="math">\\mathcal{U}</span> is the user-registry containing all values <span class="math">x_{i}</span> that were selected in previous executions of the Add-user protocol. Subsequently, the server records the value <span class="math">x_{i}</span> as associated to user <span class="math">i</span> and adds <span class="math">x_{i}</span> to <span class="math">\\mathcal{U}</span>.</p>

    <p class="text-gray-300">Encryption. The sender obtains the current public key of the system</p>

    <p class="text-gray-300"><span class="math">PK:=\\langle g,g^{\\prime},y,\\langle z_{1},h_{1}\\rangle,\\ldots,\\langle z_{v},h_{v}\\rangle\\rangle</span></p>

    <p class="text-gray-300">(where <span class="math">y=g^{A(0)}g^{\\prime B(0)}</span> and <span class="math">h_{\\ell}=g^{A(z_{\\ell})}g^{\\prime B(z_{\\ell})}</span>, for some identity <span class="math">z_{\\ell}</span>, <span class="math">\\ell=1</span>, <span class="math">\\ldots</span>, <span class="math">v</span>) and then employs the encryption function <span class="math">\\mathcal{E}</span> that, given the public key <span class="math">PK</span> and a plaintext <span class="math">M\\in\\mathcal{G}</span>, selects a random <span class="math">r\\xleftarrow{r}\\mathbb{Z}_{q}</span> and sets the corresponding ciphertext to be:</p>

    <p class="text-gray-300"><span class="math">\\langle g^{r},g^{\\prime r},y^{r}\\cdot M,\\langle z_{1},h_{1}^{r}\\rangle,\\ldots,\\langle z_{v},h_{v}^{r}\\rangle\\rangle.</span></p>

    <p class="text-gray-300">Decryption. The decryption algorithm <span class="math">\\mathcal{D}</span> takes as input a tuple of the form <span class="math">\\langle x_{i},A(x_{i}),B(x_{i})\\rangle</span> and a ciphertext</p>

    <p class="text-gray-300"><span class="math">\\bm{C}=\\langle u,u^{\\prime},u^{\\prime\\prime},\\langle z_{1},u_{1}\\rangle,\\ldots,\\langle z_{v},u_{v}\\rangle\\rangle.</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}</span> first computes the leap-vectors</p>

    <p class="text-gray-300"><span class="math">\\bm{\\nu}_{A,i}\\doteq\\bm{\\nu}_{z_{1},\\ldots,z_{v}}^{x_{i},A}\\quad\\bm{\\nu}_{B,i}\\doteq\\bm{\\nu}_{z_{1},\\ldots,z_{v}}^{x_{i},B}</span></p>

    <p class="text-gray-300">associated to the points <span class="math">\\langle x_{i},A(x_{i})\\rangle</span> and <span class="math">\\langle x_{i},B(x_{i})\\rangle</span> with respect to the values <span class="math">z_{1},\\ldots,z_{v}</span>. Observe that, by Definition 6 (Equations (2) and (4)), <span class="math">\\bm{\\nu}_{A,i}</span> and <span class="math">\\bm{\\nu}_{B,i}</span> agree on all components except for the first: denoting with <span class="math">(\\nu_{A,i})_{\\ell}</span> (respectively <span class="math">(\\nu_{B,i})_{\\ell}</span>) the entry in <span class="math">\\bm{\\nu}_{A,i}</span> (respectively <span class="math">\\bm{\\nu}_{B,i}</span>) indexed by <span class="math">\\ell</span>, it holds that <span class="math">\\nu_{i,\\ell}\\doteq(\\nu_{A,i})_{\\ell}=(\\nu_{B,i})_{\\ell}</span>, for <span class="math">\\ell=1,\\ldots,v</span>.</p>

    <p class="text-gray-300">The decryption algorithm returns:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}(\\bm{C})\\doteq\\frac{u^{\\prime\\prime}}{u^{(\\nu_{A,i})_{0}}u^{\\prime(\\nu_{B,i})_{0}}\\prod_{\\ell=1}^{v}u_{\\ell}^{\\nu_{i,\\ell}}}</span></p>

    <p class="text-gray-300">If <span class="math">\\bm{C}</span> is a properly formed ciphertext, i.e.</p>

    <p class="text-gray-300"><span class="math">\\bm{C}=\\langle g^{r},g^{\\prime r},y^{r}\\cdot M,\\langle z_{1},h_{1}^{r}\\rangle,\\ldots,\\langle z_{v},h_{v}^{r}\\rangle\\rangle</span></p>

    <p class="text-gray-300">then, due to the properties of the leap-vector representation (Equation (1)), we have:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}(\\bm{C})</span> <span class="math">=\\frac{g^{rA(0)}g^{\\prime rB(0)}M}{g^{r(\\nu_{A,i})_{0}}g^{\\prime r(\\nu_{B,i})_{0}}\\prod_{\\ell=1}^{v}g^{r\\nu_{i,\\ell}A(z_{\\ell})}g^{\\prime r\\nu_{i,\\ell}B(z_{\\ell})}}</span> <span class="math">=M</span></p>

    <p class="text-gray-300"><span class="math">\\lim_{k\\to\\infty}\\frac{1}{k!}\\sum_{k=1}^{n}\\frac{1}{k!}\\sum_{k=1}^{n-1}\\frac{1}{k!}.</span></p>

    <p class="text-gray-300">Remove-user. Let <span class="math">i_{1},\\ldots,i_{k}</span> be the identities of the users to be removed, so that <span class="math">L+k\\leq v</span>. Suppose that the current public key is <span class="math">PK=\\langle g,g^{\\prime},y,\\langle z_{1},h_{1}\\rangle,\\ldots,\\langle z_{v},h_{v}\\rangle\\rangle</span>. The revocation procedure uses the user-registry <span class="math">\\mathcal{U}</span> to retrieve the values <span class="math">x_{i_{1}},\\ldots,x_{i_{k}}</span> and modifies the current public key <span class="math">PK</span> as:</p>

    <p class="text-gray-300"><span class="math">PK:=</span> <span class="math">\\langle g,g^{\\prime},y,\\langle z_{1},h_{1}\\rangle,\\ldots,\\langle z_{L},h_{L}\\rangle,</span> <span class="math">\\langle x_{i_{1}},g^{A(x_{i_{1}})}g^{\\prime B(x_{i_{1}})}\\rangle,\\ldots,\\langle x_{i_{k}},g^{A(x_{i_{k}})}g^{\\prime B(x_{i_{k}})}\\rangle,</span> <span class="math">\\langle z_{L+k+1},h_{L+k+1}\\rangle,\\ldots,\\langle z_{v},h_{v}\\rangle\\rangle.</span></p>

    <p class="text-gray-300">Finally, the saturation level is increased to <span class="math">L:=L+k</span>.</p>

    <p class="text-gray-300">New-period. When a Remove-user operation is invoked such that the resulting saturation level <span class="math">L</span> would “overflow” the saturation limit <span class="math">v</span>, the server starts a new period. First, the server broadcasts a special message change period (signed, but not encrypted). Note that we assume that change-period is digitally signed by the server so that no third parties can maliciously initiate the New-period operation.</p>

    <p class="text-gray-300">Let <span class="math">enc:\\mathbb{Z}_{q}\\to\\mathcal{G}</span> be an easily invertible encoding that translates a number from <span class="math">\\{0,\\ldots,q-1\\}</span> into an element of <span class="math">\\mathcal{G}</span>. If <span class="math">\\mathcal{G}</span> is the subgroup of <span class="math">\\mathbb{Z}_{p}^{*}</span> of oder <span class="math">q=\\frac{p-1}{2}</span>, then <span class="math">enc</span> can be implemented as follows: <span class="math">enc(a)\\doteq(a+1)^{2}\\bmod p</span>. It is easy to see that <span class="math">enc(a)\\in\\mathcal{G}</span> for any <span class="math">a\\in\\mathbb{Z}_{q}</span>: this is because <span class="math">\\mathcal{G}</span> is the subgroup of quadratic residues modulo <span class="math">p</span>. The encoding function <span class="math">enc</span> can be easily inverted as follows: given <span class="math">b:=enc(a)</span>, compute the two square roots <span class="math">\\rho_{1},\\rho_{2}</span> of <span class="math">a</span> modulo <span class="math">p</span> and define <span class="math">enc^{-1}(b)=\\min\\{\\rho_{1},\\rho_{2}\\}-1</span> where <span class="math">\\min</span> treats <span class="math">\\rho_{1},\\rho_{2}</span> as integers in <span class="math">\\{0,\\ldots,p-1\\}</span>.</p>

    <p class="text-gray-300">The server selects <span class="math">d_{0},\\ldots,d_{v},e_{0},\\ldots,e_{v}\\stackrel{{\\scriptstyle\\text{\\tiny</span>F<span class="math">}}}{{\\leftarrow}}\\mathbb{Z}_{q}</span> and transmits the reset message</p>

    <p class="text-gray-300"><span class="math">C_{\\textsf{reset}}:=</span> <span class="math">\\langle\\mathcal{E}(PK,enc(d_{0})),\\ldots,\\mathcal{E}(PK,enc(d_{v})),</span> <span class="math">\\mathcal{E}(PK,enc(e_{0})),\\ldots,\\mathcal{E}(PK,enc(e_{v}))\\rangle</span></p>

    <p class="text-gray-300">where <span class="math">PK</span> is the current public key of the system. Let <span class="math">D(\\cdot)</span> be the polynomial defined by <span class="math">d_{0},\\ldots,d_{v}</span> and let <span class="math">E(\\cdot)</span> be the polynomial defined by <span class="math">e_{0},\\ldots,e_{v}</span>: namely,</p>

    <p class="text-gray-300"><span class="math">D(x)</span> <span class="math">=d_{0}+d_{1}x+\\ldots+d_{v}x^{v}</span> <span class="math">E(x)</span> <span class="math">=e_{0}+e_{1}x+\\ldots+e_{v}x^{v}.</span></p>

    <p class="text-gray-300">At this point, the server resets the saturation level <span class="math">L:=0</span>, updates the two secret polynomials to be:</p>

    <p class="text-gray-300"><span class="math">A_{\\textsf{new}}(\\cdot)</span> <span class="math">:=A(\\cdot)+D(\\cdot)\\pmod{q}</span> <span class="math">B_{\\textsf{new}}(\\cdot)</span> <span class="math">:=B(\\cdot)+E(\\cdot)\\pmod{q}</span></p>

    <p class="text-gray-300">and modifies the public key <span class="math">PK</span> as follows:</p>

    <p class="text-gray-300"><span class="math">PK_{\\textsf{new}}:=\\langle g,g^{\\prime},g^{A_{\\textsf{new}}(0)}g^{\\prime B_{\\textsf{new}}(0)},\\langle\\ell,g^{A_{\\textsf{new}}(\\ell)}g^{\\prime B_{\\textsf{new}}(\\ell)}\\rangle_{\\ell=1}^{v}\\rangle.</span></p>

    <p class="text-gray-300">Upon receiving the signed change period message, user <span class="math">i</span> enters a wait-mode. When the user receives the reset message <span class="math">C_{\\textsf{reset}}</span>, he/she decrypts all ciphertexts, decodes the coefficients <span class="math">d_{0},\\ldots,d_{v},e_{0},\\ldots,e_{v}</span> using <span class="math">enc^{-1}</span> and forms the polynomials <span class="math">D(\\cdot),E(\\cdot)</span>. Then, the user modifies his/her secret tuple <span class="math">\\langle x_{i},A(x_{i}),B(x_{i})\\rangle</span> to be the new tuple</p>

    <p class="text-gray-300"><span class="math">\\langle x_{i},A(x_{i})+D(x_{i}),B(x_{i})+E(x_{i})\\rangle.</span></p>

    <p class="text-gray-300">Remark. We notice that the efficiency of the New-period operation can be improved by using hybrid encryption. In particular, instead of computing and sending <span class="math">2v+2</span> ciphertexts under the current public-key (which incurs a cost of <span class="math">\\mathcal{O}(v^{2})</span> in terms of communication), the server may pick a random session key <span class="math">k</span>, use it to encrypt the <span class="math">2v+2</span> coefficients via a secure one-time symmetric-key encryption scheme, and broadcast the resulting ciphertext together with <span class="math">\\mathcal{E}(PK,enc^{\\prime}(k))</span> (where <span class="math">enc^{\\prime}</span> is a suitable encoding of session keys into elements of <span class="math">\\mathcal{G}</span>). Each non-revoked user will then be able to recover the coefficients <span class="math">d_{0}</span>, <span class="math">\\ldots</span>, <span class="math">d_{v}</span>, <span class="math">e_{0}</span>, <span class="math">\\ldots</span>, <span class="math">e_{v}</span> from such reset message by first recovering the session key <span class="math">k</span> from the public-key ciphertext <span class="math">\\mathcal{E}(PK,enc^{\\prime}(k))</span>, and then using <span class="math">k</span> to decrypt the symmetric-key ciphertext. This will drop the communication cost to <span class="math">\\mathcal{O}(v)</span>. We omit the details.</p>

    <p class="text-gray-300">5 Dealing with Revocation</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.1 Model for Revocation</h3>

    <p class="text-gray-300">The public-key traitor tracing scheme described in Section 4 withstands a more powerful type of attack than what has been considered so far in previous related work <em>[19, 21, 8, 9]</em>. In our attack scenario, the adversary <span class="math">\\mathcal{A}</span> is allowed not only to join the system up to a bounded number of times <span class="math">v</span> (equal to the <em>saturation level</em>, which is fixed as a system parameter), but also to observe and even actively affect the evolution of the system, by specifying which users should be revoked and their relative order in the sequence of revocations. Notice that this type of adversary defeats all previous public-key traitor tracing schemes with fixed ciphertext size <em>[19, 21, 9]</em>.</p>

    <p class="text-gray-300">More formally, in our model the adversary interleaves, in any adaptively-chosen order, two types of queries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Join query: it models the subscription to the system of a malicious user controlled by the adversary. To reply to such query, the server executes a variant of the Add-user operation, which allows the adversary to specify the identity for which she will get the decryption key, (whereas in a regular Add-user operation, the server would assign a random identity to the new user). Thus, the Join query models a more powerful adversary that can control the random choice of the server. Notice that, after a Join query, the adversary obtains a valid user-key capable of recovering subsequent encrypted broadcasts.</li>

      <li>Revoke query: it models the revocation of a user from the system. To reply to such query, the server performs a Remove-user operation and gives <span class="math">\\mathcal{A}</span> the new public key that results after the invalidation of the key corresponding to the revoked user.</li>

    </ul>

    <p class="text-gray-300">Notice that the main constraint we impose to the adversary’s behavior is that she can make at most <span class="math">v</span> Join queries; no restriction is given for Revoke queries. Whenever <span class="math">\\mathcal{A}</span> has finished collecting the amount of information she thinks she needs to maximize her chances of winning the game, the corrupted users are revoked, the adversary outputs a pair of messages and receives back the encryption of either one with equal probability.</p>

    <p class="text-gray-300">To fully appreciate the novelty of the attack scenario proposed above, recall that in the adversarial model that has been considered in previous work on public-key traitor tracing <em>[19, 21, 8, 9]</em>, the only functionality conceded to <span class="math">\\mathcal{A}</span> was to obtain the secret key of a user which was also <em>simultaneously</em> revoked from the system. In our model, such capability, usually called <em>corruption</em>, is split into two distinct operations. This clearly allows the adversary to mount more powerful attacks, and does indeed more closely model the reality, since the server does not always find out about “bad” users immediately. Moreover, keeping the Join and Revoke operations distinct, allows us to impose on the adversary the (minimal) restriction of obtaining at most <span class="math">v</span> user-keys, without bounding the number of Revoke queries. This constitutes a major novelty of our adversarial model: previous work required both the number of revoked users and the number of compromised user-keys (tied together by the definition of <em>corruption</em> query) to be bounded by <span class="math">v</span>.</p>

    <p class="text-gray-300">Clearly, for the challenge to the adversary not to be trivial, all the user-keys that <span class="math">\\mathcal{A}</span> obtains through Join queries must have been rendered useless by corresponding subsequent Revoke queries. We model this necessary constraint by requiring that before asking for her challenge, <span class="math">\\mathcal{A}</span> should enter a wait-mode during which all the (at most <span class="math">v</span>) users she corrupted are revoked within a window of consecutive revocations that should not get interrupted by a New-period operation.</p>

    <p class="text-gray-300">It is interesting to point here some technical similarities of the window adversary model to a (lunch-time) Chosen Ciphertext Attack (CCA1). In particular, in a lunch-time attack the adversary, prior to obtaining the challenge, can query a decryption oracle to obtain decryptions of chosen ciphertexts; in the security proof, this introduces the technical challenge of simulating such decryption oracle. In the case of a window-adversary, the adversary can query the Join oracle to obtain valid decryption keys (that will be revoked afterwards). From a technical viewpoint, simulating the Join oracle is a technical challenge of similar nature to the task of simulating the decryption oracle of a CCA1 attacker. Indeed, in our security proof and system design we take advantage of techniques that were developed for dealing with CCA1 attacks.</p>

    <p class="text-gray-300">Formal Model for Window Adversary. We formalize the above attack scenario in terms of the window adversary attack game <span class="math">\\mathbf{G}_{\\mathsf{win}}^{v}(1^{k})</span>, played between a challenger and the adversary <span class="math">\\mathcal{A}</span>. This game consists of three stages, denoted respectively <span class="math">\\mathsf{fst}</span>, <span class="math">\\mathsf{snd}</span> and <span class="math">\\mathsf{trd}</span>. To enable coordination between the three stages, at the end of each stage <span class="math">\\mathcal{A}</span> is allowed to output a piece of state information (via the variable <span class="math">aux</span>), which will be given as input to the next stage.</p>

    <p class="text-gray-300">The first stage (<span class="math">\\mathsf{fst}</span>) is a learning stage, in which the adversary is allowed to obtain the secret keys of at most <span class="math">v</span> users and to make the system evolve via <span class="math">\\mathsf{Revoke}</span> queries. At the end of this stage, all the corrupted users get revoked.</p>

    <p class="text-gray-300">The second stage (<span class="math">\\mathsf{snd}</span>) is a choosing stage, in which <span class="math">\\mathcal{A}</span> picks two messages <span class="math">M_{0}</span>, <span class="math">M_{1}</span> that she deems she will be able to distinguish in the ciphertext form.</p>

    <p class="text-gray-300">In the third stage (<span class="math">\\mathsf{trd}</span>), <span class="math">\\mathcal{A}</span> receives a challenge ciphertext <span class="math">\\psi^{*}</span>, which consists of the encryption of either <span class="math">M_{0}</span> or <span class="math">M_{1}</span> with equal probability. The game ends with <span class="math">\\mathcal{A}</span> outputting her best guess to whether <span class="math">M_{0}</span> or <span class="math">M_{1}</span> was encrypted.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\langle PK,MSK\\rangle:=\\mathsf{Setup}(1^{k})</span>.</li>

      <li>Let <span class="math">L:=0</span>, <span class="math">\\mathsf{Corr}:=\\emptyset</span>.</li>

      <li>Let <span class="math">state:=\\langle L,PK,MSK,\\mathsf{Corr}\\rangle</span></li>

      <li><span class="math">aux\\leftarrow\\mathcal{A}^{\\mathsf{Join}(state,\\cdot),\\mathsf{Revoke}(state,\\cdot)}(\\mathsf{fst},state.PK)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. If $L+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Corr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>v<span class="math"> then </span>\\mathsf{exit}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\langle aux,M_{0},M_{1}\\rangle\\leftarrow\\mathcal{A}^{\\mathsf{Revoke}(state,\\cdot)}(\\mathsf{snd},aux,state.PK)</span>.</li>

      <li><span class="math">\\psi^{<em>}\\leftarrow\\mathcal{E}(state.PK,M_{\\sigma^{</em>}})</span>, where <span class="math">\\sigma^{*}\\xleftarrow{\\tau}\\{0,1\\}</span>.</li>

      <li><span class="math">\\sigma\\leftarrow\\mathcal{A}^{\\mathsf{Revoke}(state,\\cdot)}(\\mathsf{trd},aux,state.PK,\\psi^{*})</span>.</li>

      <li>Output <span class="math">\\mathsf{Success}</span> if and only if <span class="math">\\sigma=\\sigma^{*}</span>.</li>

    </ol>

    <p class="text-gray-300">The two oracles employed above are defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Join}(state,x)\\ :</span></p>

    <p class="text-gray-300">(i) parse <span class="math">state</span> as <span class="math">\\langle L,PK,MSK,\\mathsf{Corr}\\rangle</span>;</p>

    <p class="text-gray-300">(ii) parse <span class="math">PK</span> as <span class="math">\\langle g,g^{\\prime},y,\\langle z_{1},h_{1}\\rangle,\\ldots,\\langle z_{v},h_{v}\\rangle\\rangle</span>;</p>

    <p class="text-gray-300">(iii) parse <span class="math">MSK</span> as <span class="math">(A(\\cdot),B(\\cdot))</span>;</p>

    <p class="text-gray-300">(iv) if <span class="math">x\\in\\{1,\\ldots,v\\}</span>, then <span class="math">\\mathsf{exit}</span>;</p>

    <p class="text-gray-300">(v) set <span class="math">\\mathsf{Corr}:=\\mathsf{Corr}\\cup\\{x\\}</span> and return <span class="math">(A(x),B(x))</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Revoke}(state,x)\\ :</span></p>

    <p class="text-gray-300">(i) parse <span class="math">state</span> as <span class="math">\\langle L,PK,MSK,\\mathsf{Corr}\\rangle</span>;</p>

    <p class="text-gray-300">(ii) parse <span class="math">PK</span> as <span class="math">\\langle g,g^{\\prime},y,\\langle z_{1},h_{1}\\rangle,\\ldots,\\langle z_{v},h_{v}\\rangle\\rangle</span>;</p>

    <p class="text-gray-300">(iii) parse <span class="math">MSK</span> as <span class="math">(A(\\cdot),B(\\cdot))</span>;</p>

    <p class="text-gray-300">(iv) if <span class="math">x\\in\\mathsf{Corr}</span>, then <span class="math">\\mathsf{exit}</span>;</p>

    <p class="text-gray-300">(v) if <span class="math">L=v</span> then a <span class="math">\\mathsf{New}</span>-<span class="math">\\mathsf{period}</span> operation is executed and <span class="math">state</span> is updated accordingly (i.e., <span class="math">L</span> is reset to <span class="math">0</span>, <span class="math">state.MSK</span> is modified by adding the randomizing polynomials and <span class="math">state.PK</span> changes correspondingly);</p>

    <p class="text-gray-300">(vi) set <span class="math">L:=L+1</span>;</p>

    <p class="text-gray-300">(vii) update <span class="math">state.PK</span> by replacing the pair <span class="math">\\langle z_{L},h_{L}\\rangle</span> with <span class="math">\\langle x,g^{A(x)}g^{\\prime B(x)}\\rangle</span>;</p>

    <p class="text-gray-300">(viii) output <span class="math">state.PK</span>; if step (v) caused a <span class="math">\\mathsf{New}</span>-<span class="math">\\mathsf{period}</span> operation, then also output the corresponding reset message <span class="math">C_{\\mathsf{reset}}</span>.</p>

    <p class="text-gray-300">Note that w.l.o.g. we assume that the adversary never corrupts the same user twice, as there is no extra information to be gained, and never revokes the users it corrupts, as they get explicitly revoked at step 6. of the attack game.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">Define <span class="math">\\mathcal{A}</span>’s advantage as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}(k)\\doteq\\mid\\Pr(\\sigma=\\sigma^{*})-1/2\\mid.</span></p>

    <p class="text-gray-300">A public-key traitor tracing scheme is secure against window adversaries if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, <span class="math">\\mathsf{Adv}_{\\mathcal{A}}(k)</span> is negligible in <span class="math">k</span> .</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">5.2 Security of Revocation</p>

    <p class="text-gray-300">We now formally prove that the scalable public-key traitor tracing scheme described in Section 4 is secure against window adversaries (as defined above). In the security proof, we will follow the same structural approach used in <em>[9]</em>, first advocated in <em>[7]</em>. Starting from the actual attack scenario, we will consider a sequence of hypothetical games, all defined over the same probability space. In each game, the adversary’s view is obtained in different ways, but its distribution is still indistinguishable among the games.</p>

    <p class="text-gray-300">The security of our scheme relies on the <span class="math">\\mathsf{DDH}</span> assumption (Assumption 1) as shown below in Theorem 1.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Under the decisional Diffie-Hellman Assumption for <span class="math">\\mathcal{G}</span>, the scheme presented above is secure against window adversaries.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We define a sequence of “indistinguishable” games <span class="math">\\mathbf{G}_{0},\\mathbf{G}_{1},\\ldots</span>, all operating over the same underlying probability space. Starting from the actual adversarial game <span class="math">\\mathbf{G}_{0}=\\mathbf{G}_{\\mathsf{win}}^{v}(1^{k})</span>, we incrementally make slight modifications to the behavior of the oracles, thus changing the way the adversary’s view is computed, while maintaining the views’ distributions indistinguishable among the games. In the last game, it will be clear that the adversary has (at most) a negligible advantage; by the indistinguishability of any two consecutive games, it will follow that also in the original game the adversary’s advantage is negligible. Recall that in each game <span class="math">\\mathbf{G}_{j}</span>, the goal of adversary <span class="math">\\mathcal{A}</span> is to output <span class="math">\\sigma\\in\\{0,1\\}</span> which is her best guess to the bit <span class="math">\\sigma^{<em>}</span> used at step 7. of the attack game <span class="math">\\mathbf{G}_{\\mathsf{win}}^{v}(1^{k})</span> to create the challenge ciphertext <span class="math">\\psi^{</em>}</span>: let <span class="math">T_{j}</span> be the event that <span class="math">\\sigma=\\sigma^{*}</span> in game <span class="math">\\mathbf{G}_{j}</span> (i.e., the event that the game ends with <span class="math">\\mathsf{Success}</span> as output). W.l.o.g., in the following we assume that the adversary corrupts exactly <span class="math">v</span> users during the attack game.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{0}</span>. Define <span class="math">\\mathbf{G}_{0}</span> to be the original game <span class="math">\\mathbf{G}_{\\mathsf{win}}^{v}(1^{k})</span>.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}</span>. Define the “special” <span class="math">\\mathsf{New}\\text{-}\\mathsf{period}</span> operation to be the first one to be caused by the <span class="math">\\mathsf{Re}\\mathsf{v}\\mathsf{o}\\mathsf{k}\\mathsf{e}</span> oracle at step 7. of the attack game. Depending on the adversary’s strategy, such “special” <span class="math">\\mathsf{New}\\text{-}\\mathsf{period}</span> operation may not occur at all.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}</span> is identical to game <span class="math">\\mathbf{G}_{0}</span>, except that, in <span class="math">\\mathbf{G}_{1}</span>, the <span class="math">\\mathsf{reset}</span> message output by the “special” <span class="math">\\mathsf{New}\\text{-}\\mathsf{period}</span> operation contains <span class="math">2v+2</span> encryptions of random elements of <span class="math">\\mathbb{Z}_{q}</span>, rather than encryptions of the coefficients of the randomizing polynomials. This modification suggests that the secret polynomials which are contained in <span class="math">state.MSK</span> at the beginning of the period initiated by the “special” <span class="math">\\mathsf{New}\\text{-}\\mathsf{period}</span> operation are totally random, even given all the information in the adversary’s view.</p>

    <p class="text-gray-300">In Lemma 2 (whose proof is given below), we show that the chances of adversary <span class="math">\\mathcal{A}</span> winning game <span class="math">\\mathbf{G}_{1}</span> cannot be significantly better than her chances of winning game <span class="math">\\mathbf{G}_{0}</span>: more precisely,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{1}]-\\Pr[T_{0}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq(4v+4)\\;\\mathsf{AdvDDH}_{\\mathcal{G}}(k).$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{2}</span>. To turn game <span class="math">\\mathbf{G}_{1}</span> into game <span class="math">\\mathbf{G}_{2}</span>, step 8. of the attack game is modified as follows:</p>

    <p class="text-gray-300"><span class="math">8^{\\prime}.\\;\\psi^{<em>}\\leftarrow\\mathcal{E}(state.PK,M),\\text{where }M\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathcal{G},\\sigma^{</em>}\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\{0,1\\}</span></p>

    <p class="text-gray-300">Because of this change, the challenge ciphertext <span class="math">\\psi^{<em>}</span> no longer contains <span class="math">\\sigma^{</em>}</span>, nor does any other information in the adversary’s view; therefore,</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{2}]=\\frac{1}{2}.</span> (6)</p>

    <p class="text-gray-300">In Lemma 3, proven below, we show that the adversary has almost the same chances to guess <span class="math">\\sigma^{*}</span> in game <span class="math">\\mathbf{G}_{1}</span> and <span class="math">\\mathbf{G}_{2}</span>: more precisely,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{2}]-\\Pr[T_{1}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq 2\\;\\mathsf{AdvDDH}_{\\mathcal{G}}(k).$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Equations (5), (6), and (7) together, adversary <span class="math">\\mathcal{A}</span>’s advantage can be bounded as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}(k)\\leq(4v+6)\\;\\mathsf{AdvDDH}_{\\mathcal{G}}(k).</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The core of the proof of Theorem 1 is in the two lemmas that follow, Lemma 2 and Lemma 3.</p>

    <p class="text-gray-300">Overview of the Proof Technique. Throughout the paper, we make extensive use of a technical lemma, stated and proved as Lemma 9 in <em>[7]</em>. For ease of reference, we report it verbatim below.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">k,n</span> be integers with <span class="math">1\\leq k\\leq n</span>, and let <span class="math">K</span> be a finite field. Consider a probability space with random variables <span class="math">\\bm{\\alpha}\\in K^{n\\times 1},\\bm{\\beta}=(\\beta_{1},\\ldots,\\beta_{k})^{T}\\in K^{k\\times 1},\\bm{\\gamma}\\in K^{k\\times 1}</span>, and <span class="math">\\bm{M}\\in K^{k\\times n}</span>, such that <span class="math">\\bm{\\alpha}</span> is uniformly distributed over <span class="math">K^{n},\\bm{\\beta}=\\bm{M}\\bm{\\alpha}+\\bm{\\gamma}</span>, and for <span class="math">1\\leq i\\leq k</span>, the first <span class="math">i</span>th rows of <span class="math">\\bm{M}</span> and <span class="math">\\bm{\\gamma}</span> are determined by <span class="math">\\beta_{1},\\ldots,\\beta_{i-1}</span>. Then, conditioning on any fixed values of <span class="math">\\beta_{1},\\ldots,\\beta_{k-1}</span> such that the resulting matrix <span class="math">\\bm{M}</span> has rank <span class="math">k</span>, the value of <span class="math">\\beta_{k}</span> is uniformly distributed over <span class="math">K</span> in the resulting conditional probability space.</p>

    <p class="text-gray-300">Our use of this technical lemma is quite uniform across the proofs to follow. In all cases, our main aim will be to prove that some quantity <span class="math">\\mathsf{rand}\\in\\mathbb{Z}_{q}</span> looks uniformly random to the adversary, despite all the other information in the adversary’s view. At a high level, our approach is organized in the following steps.</p>

    <p class="text-gray-300">First, we consider all the randomness underlying a specific execution of the attack game. This will include, for instance, the random coins of the adversary, the randomness used in creating the challenge, etc. We then partition all the randomness in two parts: a quantity <span class="math">\\bm{V}</span> and a vector <span class="math">\\bm{\\alpha}</span>, such that conditioning on any fixed value of <span class="math">\\bm{V}</span>, <span class="math">\\bm{\\alpha}</span> is still distributed uniformly at random in the appropriate vector space (which usually will have <span class="math">\\mathbb{Z}_{q}</span> as support).</p>

    <p class="text-gray-300">Second, we consider another vector <span class="math">\\bm{\\beta}</span>, whose last entry is <span class="math">\\mathsf{rand}</span>, with the property that fixing a value for <span class="math">\\bm{V}</span> and <span class="math">\\bm{\\beta}</span> also fixes the value of <span class="math">\\bm{\\alpha}</span>, and thus all the information of the entire game (which in particular includes the information in the adversary’s view).</p>

    <p class="text-gray-300">Third, we define a matrix <span class="math">\\mathbf{M}</span> (and possibly a vector <span class="math">\\bm{\\gamma}</span>) describing the constraints binding vector <span class="math">\\bm{\\alpha}</span> to vector <span class="math">\\bm{\\beta}</span>, thus obtaining a matrix equation of the form:</p>

    <p class="text-gray-300"><span class="math">\\bm{\\beta}=\\mathbf{M}\\cdot\\bm{\\alpha}+\\bm{\\gamma}.</span></p>

    <p class="text-gray-300">Finally, we make sure that the preconditions of Lemma 1 are fulfilled; it will follow that the last entry of <span class="math">\\bm{\\beta}</span> (which is the quantity of interest <span class="math">\\mathsf{rand}</span>), is distributed uniformly at random in <span class="math">\\mathbb{Z}_{q}</span>, even conditioning on fixed values of <span class="math">\\bm{V}</span> and of all the other entries of <span class="math">\\bm{\\beta}</span>, or equivalently, conditioning on all the other information in the adversary’s view.</p>

    <p class="text-gray-300">Notation. In what follows, we refer to the period initiated by the <span class="math">t</span>th <span class="math">\\mathsf{New}</span>-period operation as the <span class="math">t</span>th period. Also, for notational convenience, we denote with <span class="math">D^{t}(\\cdot)</span> and <span class="math">E^{t}(\\cdot)</span> the randomizing polynomials chosen during the <span class="math">t</span>th <span class="math">\\mathsf{New}</span>-period operation and with <span class="math">d^{t}_{0},\\ldots,d^{t}_{v}</span> and <span class="math">e^{t}_{0},\\ldots,e^{t}_{v}</span> the corresponding coefficients. In some cases, it will be convenient to denote these <span class="math">2v+2</span> coefficients with a uniform notation; for this reason, for <span class="math">j=1,\\ldots,2v+2</span>, we additionally define <span class="math">c^{t}_{j}</span> as follows:</p>

    <p class="text-gray-300">\\[ c^{t}_{j}\\doteq\\begin{cases}d^{t}_{j-1}&\\text{if }j\\in\\{1,\\ldots,v+1\\}\\\\ e_{j-v-2}&\\text{if }j\\in\\{v+2,\\ldots,2v+2\\}\\end{cases} \\]</p>

    <p class="text-gray-300">Moreover, let <span class="math">A^{t}(\\cdot)</span> and <span class="math">B^{t}(\\cdot)</span> be the values of the secret polynomials after the changes due to the <span class="math">t</span>th <span class="math">\\mathsf{New}</span>-period operation. In other words, the system starts with period number <span class="math">0</span>, <span class="math">A^{0}(\\cdot)</span> and <span class="math">B^{0}(\\cdot)</span> are the polynomials initially output by the <span class="math">\\mathsf{Setup}</span> algorithm and</p>

    <p class="text-gray-300"><span class="math">A^{t}(\\cdot)\\doteq A^{t-1}(\\cdot)+D^{t}(\\cdot)\\quad B^{t}(\\cdot)\\doteq B^{t-1}(\\cdot)+E^{t}(\\cdot).</span> (8)</p>

    <p class="text-gray-300">Also define</p>

    <p class="text-gray-300"><span class="math">D^{t_{1},t_{2}}(\\cdot)\\doteq\\sum_{t=t_{1}}^{t_{2}}D^{t}(\\cdot)\\quad E^{t_{1},t_{2}}(\\cdot)\\doteq\\sum_{t=t_{1}}^{t_{2}}E^{t}(\\cdot).</span> (9)</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{1}]-\\Pr[T_{0}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq(4v+4)\\;\\mathsf{AdvDDH}_{\\mathcal{G}}(k).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that <span class="math">\\mathbf{G}_{1}</span> differs from <span class="math">\\mathbf{G}_{0}</span> only in the way the reset message is computed for the “special” New-period operation: hence, if the adversary’s strategy does not cause any New-period operation to occur during step 7. of the attack game, the two games are identical, so that in fact <span class="math">\\Pr[T_{1}]=\\Pr[T_{0}]</span>, and the Lemma immediately follows.</p>

    <p class="text-gray-300">We now discuss the case in which the “special” New-period operation takes place: in particular, let <span class="math">\\hat{t}</span> be the period initiated by this operation and <span class="math">D^{\\hat{t}}(\\cdot)</span> and <span class="math">E^{\\hat{t}}(\\cdot)</span> be the randomizing polynomials used in such New-period operation. We then consider the sequence of <span class="math">2v+3</span> hybrid games <span class="math">\\mathbf{G}_{0,0},\\ldots,\\mathbf{G}_{0,2v+2}</span>, where <span class="math">\\mathbf{G}_{0,i}</span> is defined as <span class="math">\\mathbf{G}_{0}</span>, except that the first <span class="math">i</span> ciphertexts in the “special” reset message contain random values rather than coefficients of the randomizing polynomials <span class="math">D^{\\hat{t}}(\\cdot)</span> and <span class="math">E^{\\hat{t}}(\\cdot)</span>. In other words, <span class="math">\\mathbf{G}_{0,0}\\equiv\\mathbf{G}_{0}</span>, <span class="math">\\mathbf{G}_{0,2v+2}\\equiv\\mathbf{G}_{1}</span> and two consecutive hybrid games <span class="math">\\mathbf{G}_{0,i}</span> and <span class="math">\\mathbf{G}_{0,i+1}</span> differ only in that the <span class="math">(i+1)</span>th ciphertext of the “special” reset message contains the <span class="math">(i+1)</span>th coefficient in game <span class="math">\\mathbf{G}_{0,i}</span>, whereas it contains a random value in game <span class="math">\\mathbf{G}_{0,i+1}</span>. Then, to prove the Lemma it suffices to show that for all <span class="math">i=0,\\ldots,2v+1</span> it holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{0,i+1}]-\\Pr[T_{0,i}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq 2\\text{ <span class="math">\\mathsf{AdvDDH}_{\\mathcal{G}}(k)</span>}.$ (10)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To this aim, fix <span class="math">i</span> and consider the additional games <span class="math">\\mathbf{G}_{0,i}^{0}\\equiv\\mathbf{G}_{0,i}</span>, <span class="math">\\mathbf{G}_{0,i}^{1}</span>, <span class="math">\\mathbf{G}_{0,i}^{2}</span>, <span class="math">\\mathbf{G}_{0,i}^{3}</span>, <span class="math">\\mathbf{G}_{0,i}^{4}\\equiv\\mathbf{G}_{0,i+1}</span>, defined as follows:</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{0,i}^{1}</span>. It operates as <span class="math">\\mathbf{G}_{0,i}^{0}</span>, except that the <span class="math">(i+1)</span>th ciphertext in the “special” reset message is computed as:</p>

    <p class="text-gray-300"><span class="math">\\langle u,u^{\\prime},u^{\\prime\\prime},\\langle z_{\\ell},u^{A^{\\hat{t}-1}(z_{\\ell})}u^{\\prime B^{\\hat{t}-1}(z_{\\ell})}\\rangle_{\\ell=1}^{v}\\rangle</span></p>

    <p class="text-gray-300">where <span class="math">u\\doteq g^{r}</span>, <span class="math">u^{\\prime}\\doteq g^{\\prime r}</span>, <span class="math">u^{\\prime\\prime}\\doteq u^{A^{\\hat{t}-1}(0)}</span> <span class="math">u^{\\prime B^{\\hat{t}-1}(0)}enc(c_{i+1}^{\\hat{t}})</span>, <span class="math">r\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}</span> and <span class="math">c_{i+1}^{\\hat{t}}</span> is either the <span class="math">(i+1)</span>th coefficient of the randomizing polynomial <span class="math">D^{\\hat{t}}(\\cdot)</span> (if <span class="math">0\\leq i\\leq v</span>) or the <span class="math">(i-v)</span>th coefficient of <span class="math">E^{\\hat{t}}(\\cdot)</span> (if <span class="math">v+1\\leq i\\leq 2v+1</span>). Since such modification is just a syntactic change, it holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{0,i}^{1}]=\\Pr[T_{0,i}^{0}].</span> (11)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{0,i}^{2}</span>. To turn game <span class="math">\\mathbf{G}_{0,i}^{1}</span> into game <span class="math">\\mathbf{G}_{0,i}^{2}</span> we make another change to the way in which the <span class="math">(i+1)</span>th ciphertext in the “special” reset message is computed. Namely, the value <span class="math">u^{\\prime}</span> is now computed as <span class="math">u^{\\prime}\\doteq g^{\\prime r^{\\prime}}</span>, for a random <span class="math">r^{\\prime}\\in\\mathbb{Z}_{q}</span> such that <span class="math">r^{\\prime}\\neq r</span>. In other words, in game <span class="math">\\mathbf{G}_{0,i}^{2}</span> the values <span class="math">u</span> and <span class="math">u^{\\prime}</span> are nearly independent (being subject only to <span class="math">r\\neq r^{\\prime}</span>), whereas in game <span class="math">\\mathbf{G}_{0,i}^{1}</span> they are obtained using the same value <span class="math">r</span>. Therefore, using a standard reduction argument, any difference in behavior between games <span class="math">\\mathbf{G}_{0,i}^{1}</span> and <span class="math">\\mathbf{G}_{0,i}^{2}</span> can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{0,i}^{2}]-\\Pr[T_{0,i}^{1}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\text{ <span class="math">\\mathsf{AdvDDH}_{\\mathcal{G}}(k)</span>}.$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that for simplicity here (and throughout the rest of the paper) we omit the negligible additive term that is caused by the negligibly-rare event <span class="math">r=r^{\\prime}</span>.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{0,i}^{3}</span>. To define game <span class="math">\\mathbf{G}_{0,i}^{3}</span>, we again modify the <span class="math">(i+1)</span>th ciphertext in the “special” reset message: specifically, the value <span class="math">u^{\\prime\\prime}</span> is now computed as <span class="math">g^{r^{\\prime\\prime}}</span>, for a random <span class="math">r^{\\prime\\prime}\\in\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">We want to show that this modification does not alter the behavior of adversary <span class="math">\\mathcal{A}</span> or, more precisely, that <span class="math">\\Pr[T_{0,i}^{3}]=\\Pr[T_{0,i}^{2}]</span>. To this aim, we first consider all the random variables affecting the adversary’s view, and then we show that they are distributed according to the same joint distribution in both games.</p>

    <p class="text-gray-300">Let <span class="math">\\bar{t}</span> be the total number of New-period operations that occur during the entire game, and for <span class="math">t=1,\\ldots,\\bar{t}</span>, let <span class="math">c_{1}^{t}</span>, <span class="math">\\ldots</span>, <span class="math">c_{2v+2}^{t}</span> be the coefficients of the randomizing polynomials <span class="math">D^{t}(\\cdot)</span> and <span class="math">E^{t}(\\cdot)</span> used in the <span class="math">t</span>th New-period operation. For <span class="math">t=1,\\ldots,\\bar{t}</span>, <span class="math">t\\neq\\hat{t}</span>, and <span class="math">j=1,\\ldots,2v+2</span>, let <span class="math">r_{j}^{t}</span> be the randomness used to encrypt (the encoding of) coefficient <span class="math">c_{j}^{t}</span> in the <span class="math">t</span>th reset message.</p>

    <p class="text-gray-300">As for the “special” reset message (i.e., the one corresponding to <span class="math">t=\\hat{t}</span>), recall that in both game <span class="math">\\mathbf{G}_{0,i}^{2}</span> and game <span class="math">\\mathbf{G}_{0,i}^{3}</span>, the first <span class="math">i</span> ciphertexts consists of just random values <span class="math">s_{1}</span>, <span class="math">\\ldots</span>, <span class="math">s_{i}\\in\\mathcal{G}</span>, rather than (the encoding of) the corresponding coefficients <span class="math">c_{1}^{\\hat{t}}</span>, <span class="math">\\ldots</span>, <span class="math">c_{i}^{\\hat{t}}</span>. Coefficients <span class="math">c_{i+2}^{\\hat{t}}</span>, <span class="math">\\ldots</span>, <span class="math">c_{2v+2}^{\\hat{t}}</span>, instead, are regularly</p>

    <p class="text-gray-300">encrypted under the public key <span class="math">PK^{\\bar{t}-1}</span> in both games: let <span class="math">r_j^{\\bar{t}}</span> be the randomness used in such encryptions, for <span class="math">j = i+2,\\ldots,2v+2</span>. The ciphertext corresponding to coefficient <span class="math">c_{i+1}</span> in the "special" reset message constitutes the only difference between the adversary's view in game <span class="math">\\mathbf{G}_{0,i}^{2}</span> and <span class="math">\\mathbf{G}_{0,i}^{3}</span>. In particular, such encryption is defined in terms of the values <span class="math">r</span>, <span class="math">r&#x27;</span> and <span class="math">r&#x27;&#x27;</span>: <span class="math">r</span> and <span class="math">r&#x27;</span> are randomly chosen from <span class="math">\\mathbb{Z}_q</span> in both games, whereas <span class="math">r&#x27;&#x27;</span> is computed differently in the two games. For the sake of clarity, we will denote with <span class="math">[r&#x27;&#x27;]_2</span> and <span class="math">[r&#x27;&#x27;]_3</span> the value of such quantity in game <span class="math">\\mathbf{G}_{0,i}^{2}</span> and <span class="math">\\mathbf{G}_{0,i}^{3}</span>, respectively. Notice that <span class="math">[r&#x27;&#x27;]_2</span> is a linear combination of <span class="math">r</span>, <span class="math">r&#x27;</span> (and other quantities), whereas <span class="math">[r&#x27;&#x27;]_3</span> is uniformly distributed in <span class="math">\\mathbb{Z}_q</span>, independently of anything else.</p>

    <p class="text-gray-300">Define</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {W} \\doteq \\Big (\\{c _ {j} ^ {t}, r _ {j} ^ {t} \\} _ {\\substack {j = 1 \\\\ t \\neq \\bar {t}}} ^ {2 v + 2}, \\{c _ {j} ^ {\\bar {t}}, s _ {j}, r _ {j} ^ {\\bar {t}} \\} _ {j = 1} ^ {i}, \\{c _ {j} ^ {\\bar {t}}, r _ {j} ^ {\\bar {t}} \\} _ {j = i + 1} ^ {2 v + 2}, r, r ^ {\\prime} \\Big)</span></div>

    <p class="text-gray-300">and consider the quantity</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {V} \\doteq (\\text {Coins}, w, \\sigma^ {*}, r ^ {*}, \\boldsymbol {W})</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{Coins}</span> represents the coin tosses of <span class="math">\\mathcal{A}</span>, <span class="math">w \\doteq \\log_g g&#x27;</span>, <span class="math">\\sigma^<em></span> is the random bit chosen by the challenger in step 8. of the attack game and <span class="math">r^</em></span> is the randomness used to create the challenge <span class="math">\\psi^*</span>.</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of the <span class="math">2v + 2</span> coefficients of the polynomials <span class="math">A^0(\\cdot)</span>, <span class="math">B^0(\\cdot)</span> and can be represented by a vector <span class="math">\\alpha</span> uniformly distributed in <span class="math">\\mathbb{Z}_q^{(2v + 2)\\times 1}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\alpha} \\doteq (a _ {0}, a _ {1}, \\dots , a _ {v}, b _ {0}, b _ {1}, \\dots , b _ {v}) ^ {T}.</span></div>

    <p class="text-gray-300">Consider the vector <span class="math">\\beta \\in \\mathbb{Z}_q^{(2v + 2)\\times 1}</span> defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} \\doteq (\\mathbf {X} _ {0}, \\mathbf {X} _ {1}, \\dots , \\mathbf {X} _ {v}, \\mathbf {A} _ {1}, \\dots , \\mathbf {A} _ {v}, r ^ {\\prime \\prime}) ^ {T}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{X}_0\\doteq A^0 (0) + wB^0 (0)</span>, <span class="math">\\mathbf{X}_{\\ell}\\doteq A^{0}(\\ell) + wB^{0}(\\ell)</span> and <span class="math">\\mathbf{A}_{\\ell}\\doteq A^{0}(x_{\\ell})</span> for <span class="math">\\ell = 1,\\dots ,v</span>, and <span class="math">r&#x27;&#x27;\\doteq \\log_g u&#x27;&#x27;</span></p>

    <p class="text-gray-300">It is clear by inspection that all the information in the adversary's view is completely determined by <span class="math">\\mathbf{V}</span> and <span class="math">\\beta</span>. In particular, the initial public key <span class="math">PK^0</span> is fixed by <span class="math">\\beta</span> and <span class="math">w</span>; the secret keys of the corrupted users are determined by the choice of <span class="math">\\beta</span>, Coins and <span class="math">w</span>; the "special" reset message is fixed by <span class="math">PK^0</span>, Coins, <span class="math">r&#x27;&#x27;</span> and all the randomness in <span class="math">\\mathbf{W}</span>; and the resulting public key <span class="math">PK^{\\bar{t}}</span> only depends on <span class="math">PK^0</span> and <span class="math">\\mathbf{W}</span>. Thus, if the distribution of <span class="math">\\mathbf{V}</span> and <span class="math">\\beta</span> is the same in both games <span class="math">\\mathbf{G}_{0,i}^{2}</span> and <span class="math">\\mathbf{G}_{0,i}^{3}</span>, it will follow that <span class="math">\\operatorname<em>{Pr}[T_{0,i}^{3}] = \\operatorname</em>{Pr}[T_{0,i}^{2}]</span>. Since the definition of <span class="math">r&#x27;&#x27;</span> is the only difference between game <span class="math">\\mathbf{G}_{0,i}^{2}</span> and <span class="math">\\mathbf{G}_{0,i}^{3}</span>, and in <span class="math">\\mathbf{G}_{0,i}^{3}</span> the value of <span class="math">[r&#x27;&#x27;]_3</span> is chosen uniformly from <span class="math">\\mathbb{Z}_q</span>, independently of anything else, it suffices to show that the distribution of <span class="math">[r&#x27;&#x27;]_2</span>, conditioned on <span class="math">\\mathbf{V}</span> and the first <span class="math">2v + 1</span> entries of <span class="math">\\beta</span>, is also uniform in <span class="math">\\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">In game <span class="math">\\mathbf{G}_{0,i}^{2}</span>, the quantities in <span class="math">\\mathbf{V}</span>, <span class="math">\\beta</span> and <span class="math">\\alpha</span> are related according to the following matrix equation:</p>

    <div class="my-4 text-center"><span class="math-block">[ \\boldsymbol {\\beta} ] _ {2} = \\mathbf {M} \\cdot \\boldsymbol {\\alpha} + \\boldsymbol {\\gamma}</span></div>

    <p class="text-gray-300">where <span class="math">[\\beta]_2</span> denotes the value of <span class="math">\\beta</span> in game <span class="math">\\mathbf{G}_{0,i}^2</span> (i.e. when the value of the last entry is <span class="math">[r&#x27;&#x27;]_2</span>), <span class="math">\\gamma \\in \\mathbb{Z}_q^{(2v + 2)\\times 1}</span> is the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\gamma} \\doteq \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ r D ^ {0, \\bar {t} - 1} (0) + w r ^ {\\prime} E ^ {0, \\bar {t} - 1} (0) + \\log_ {g} e n c (c _ {i + 1} ^ {\\bar {t}}) \\end{array} \\right)</span></div>

    <p class="text-gray-300">and <span class="math">\\mathbf{M}\\in\\mathbb{Z}_{q}^{(2v+2)\\times(2v+2)}</span> is the matrix</p>

    <p class="text-gray-300">\\[ \\mathbf{M}\\doteq\\left(\\begin{array}[]{cccccccc}1&0&\\ldots&0&w&0&\\ldots&0\\\\ 1&1&\\ldots&1&w&w&\\ldots&w\\\\ &\\vdots&&&\\vdots&\\\\ 1&v&\\ldots&v^{v}&w&wv&\\ldots&wv^{v}\\\\ 1&x_{1}&\\ldots&x_{1}^{v}&0&0&\\ldots&0\\\\ &\\vdots&&&\\vdots&\\\\ 1&x_{v}&\\ldots&x_{v}^{v}&0&0&\\ldots&0\\\\ r&0&\\ldots&0&wr^{\\prime}&0&\\ldots&0\\end{array}\\right) \\]</p>

    <p class="text-gray-300">The above matrix describes all the constraints on <span class="math">\\boldsymbol{\\alpha}</span> arising from the information in the adversary’s view in game <span class="math">\\mathbf{G}_{0,i}^{2}</span> (which, as noted above, can be described just by <span class="math">\\boldsymbol{V}</span> and <span class="math">[\\boldsymbol{\\beta}]_{2}</span>). In other words, all other constraints on <span class="math">\\boldsymbol{\\alpha}</span> are linear combination of the above, possibly using coefficients from <span class="math">\\boldsymbol{V}</span>. In particular, the constraints that the adversary can derive from knowledge of the values <span class="math">B^{0}(x_{\\ell})</span>, <span class="math">\\ell=1,\\ldots,v</span> (which come from the secret keys that <span class="math">\\mathcal{A}</span> got via Join queries) can be obtained from the constraints corresponding to <span class="math">\\mathbf{X}_{0}</span>, <span class="math">\\mathbf{X}_{1}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{X}_{v}</span>, <span class="math">\\mathbf{A}_{1}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{A}_{v}</span> and the value of <span class="math">w</span>. As for Revoke queries, notice that the public key <span class="math">PK</span> resulting from invalidating the secret key of an arbitrary user <span class="math">z</span> during time period <span class="math">t</span>, does not provide any new information about <span class="math">\\boldsymbol{\\alpha}</span> to the adversary. Indeed, <span class="math">PK</span> only differs from the previous public key in that it contains the value <span class="math">h_{z}=g^{A^{t}(z)}g^{\\prime B^{t}(z)}</span> which is determined by the quantity:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}</span> <span class="math">\\doteq A^{t}(z)+wB^{t}(z)-(D^{0,t}(z)+wE^{0,t}(z))</span> <span class="math">=A^{0}(z)+wB^{0}(z).</span></p>

    <p class="text-gray-300">Since such value is just a point of the polynomial <span class="math">v</span>-degree <span class="math">A^{0}(\\cdot)+wB^{0}(\\cdot)</span>, which is completely fixed by the values <span class="math">\\mathbf{X}_{0}</span>, <span class="math">\\mathbf{X}_{1}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{X}_{v}</span>, it immediately follows that the constraint on <span class="math">\\boldsymbol{\\alpha}</span> induced by <span class="math">\\mathbf{X}</span> is a linear combination of the first <span class="math">v+1</span> rows of <span class="math">\\mathbf{M}</span>. Similarly, the <span class="math">v</span> values <span class="math">u_{1}</span>, <span class="math">\\ldots</span>, <span class="math">u_{v}</span> included in the <span class="math">(v+1)</span>th ciphertext of the “special” reset message are determined by the quantities <span class="math">\\mathbf{X}_{z_{1}}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{X}_{z_{v}}</span>, where, for <span class="math">\\ell=1,\\ldots,v</span>, <span class="math">\\mathbf{X}_{z_{\\ell}}</span> is defined as:</p>

    <p class="text-gray-300"><span class="math">rA^{\\hat{t}-1}(z_{\\ell})+wr^{\\prime}B^{\\hat{t}-1}(z_{\\ell})-(rD^{0,\\hat{t}-1}(z_{\\ell})+wr^{\\prime}E^{0,\\hat{t}-1}(z_{\\ell}))</span></p>

    <p class="text-gray-300">or equivalently</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}_{z_{\\ell}}\\doteq rA^{0}(z_{\\ell})+wr^{\\prime}B^{0}(z_{\\ell}).</span></p>

    <p class="text-gray-300">Such values are just points of the <span class="math">v</span>-degree polynomial</p>

    <p class="text-gray-300"><span class="math">rA^{0}(\\cdot)+wr^{\\prime}B^{0}(\\cdot)</span></p>

    <p class="text-gray-300">which is determined by <span class="math">\\mathbf{A}_{1}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{A}_{v}</span>, <span class="math">B^{0}(x_{1})</span>, <span class="math">\\ldots</span>, <span class="math">B^{0}(x_{v})</span>, <span class="math">r</span>, <span class="math">r^{\\prime}</span>, <span class="math">w</span> and <span class="math">[r^{\\prime\\prime}]_{2}</span>. Thus, it follows that all the constraints on <span class="math">\\boldsymbol{\\alpha}</span> induced <span class="math">\\mathbf{X}_{z_{1}}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{X}_{z_{v}}</span> by are linear combinations of the rows of <span class="math">\\mathbf{M}</span>.</p>

    <p class="text-gray-300">Moreover, <span class="math">\\mathbf{M}</span> has rank <span class="math">(2v+2)</span>, provided that <span class="math">r\\neq r^{\\prime}</span> and <span class="math">w\\neq 0</span>, since the corrupted users <span class="math">x_{1}</span>, <span class="math">\\ldots</span>, <span class="math">x_{v}</span> are assumed to be distinct.</p>

    <p class="text-gray-300">As soon as we fix a value for <span class="math">\\boldsymbol{V}</span>, vector <span class="math">\\boldsymbol{\\gamma}</span> and the first <span class="math">v+1</span> rows of matrix <span class="math">\\mathbf{M}</span> are completely fixed, but <span class="math">\\boldsymbol{\\alpha}</span> is still distributed uniformly and independently at random in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>. If we additionally fix the value of the first <span class="math">(v+1)</span> components of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>, the initial public key <span class="math">PK^{0}</span> is fixed; it follows that the first identity <span class="math">x_{1}</span> that <span class="math">\\mathcal{A}</span> chooses to corrupt is also fixed and thus the <span class="math">(v+2)</span>th row of <span class="math">\\mathbf{M}</span> is determined. Fixing also a value for <span class="math">\\mathbf{A}_{1}</span> (which is the <span class="math">(v+2)</span>th entry of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>), the value of <span class="math">\\mathbf{B}_{1}</span> is fixed too, so that all the information on which the adversary can base her choice of <span class="math">x_{2}</span> is fixed, and thus the <span class="math">(v+3)</span>th row of <span class="math">\\mathbf{M}</span> is determined as well. By a similar reasoning, it follows that fixing the first <span class="math">(v+i+1)</span> entries of <span class="math">[\\boldsymbol{\\beta}]_{2}</span> determines the <span class="math">(v+i+2)</span>th row of <span class="math">\\mathbf{M}</span>, for <span class="math">i=1,\\ldots,v</span>. Hence, by Lemma 1, we can conclude that the conditional distribution of <span class="math">[r^{\\prime\\prime}]_{2}</span>, w.r.t. <span class="math">\\boldsymbol{V}</span> and to all other components of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>, is also uniform over <span class="math">\\mathbb{Z}_{q}</span>, from which it follows that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{0,i}^{3}]=\\Pr[T_{0,i}^{2}].</span> (13)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G}_{0,i}^{4}</span>. Game <span class="math">\\mathbf{G}_{0,i}^{4}</span>. Game <span class="math">\\mathbf{G}_{0,i}^{4}</span> is defined to be identical to <span class="math">\\mathbf{G}_{0,i+1}</span>. Thus, <span class="math">\\mathbf{G}_{0,i}^{4}</span> differs from <span class="math">\\mathbf{G}_{0,i}^{3}</span> only in that the values <span class="math">u</span> and <span class="math">u^{\\prime}</span> in the <span class="math">(i+1)</span>th ciphertext in the “special” reset message are consistent, rather than being nearly independent, as in game <span class="math">\\mathbf{G}_{0,i}^{3}</span>. Namely, the values <span class="math">u</span> and <span class="math">u^{\\prime}</span> are now computed as <span class="math">u\\doteq g^{r}</span> and <span class="math">u^{\\prime}\\doteq g^{\\prime r}</span>, for the same random <span class="math">r\\in\\mathbb{Z}_{q}</span>. It follows that any difference in behavior between games <span class="math">\\mathbf{G}_{0,i}^{3}</span> and <span class="math">\\mathbf{G}_{0,i}^{4}</span> can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{0,i}^{4}]-\\Pr[T_{0,i}^{3}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\ \\mathsf{AdvDDH}_{\\mathcal{G}}(k).$ (14)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Equations (11), (12), (13) and (14) we get Equation (10), for all <span class="math">i=0,\\ldots,2v+1</span>; then, by definition of the hybrid sequence <span class="math">\\mathbf{G}_{0,0},\\ldots,\\mathbf{G}_{0,2v+2}</span>, the thesis follows. ∎</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{2}]-\\Pr[T_{1}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq 2\\ \\mathsf{AdvDDH}_{\\mathcal{G}}(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that <span class="math">\\mathbf{G}_{2}</span> differs from <span class="math">\\mathbf{G}_{1}</span> only in the way the challenge ciphertext <span class="math">\\psi^{<em>}</span> is computed: in particular, in game <span class="math">\\mathbf{G}_{1}</span>, <span class="math">\\psi^{</em>}</span> encrypts either one of the two messages <span class="math">M_{0}</span> and <span class="math">M_{1}</span> chosen by the adversary, whereas in <span class="math">\\mathbf{G}_{2}</span>, <span class="math">\\psi^{*}</span> encrypts a totally random message <span class="math">M\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathcal{G}</span>.</p>

    <p class="text-gray-300">To reach the thesis, we consider the sequence of games <span class="math">\\mathbf{G}_{1}^{0}\\equiv\\mathbf{G}_{1}</span>, <span class="math">\\mathbf{G}_{1}^{1}</span>, <span class="math">\\mathbf{G}_{1}^{2}</span>, <span class="math">\\mathbf{G}_{1}^{3}</span>, <span class="math">\\mathbf{G}_{1}^{4}\\equiv\\mathbf{G}_{2}</span>, defined below.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}^{1}</span>. It operates as <span class="math">\\mathbf{G}_{1}^{0}</span>, except that the challenge ciphertext is computed as follows:</p>

    <p class="text-gray-300"><span class="math">\\langle u^{<em>},u^{\\prime</em>},u^{\\prime\\prime<em>},\\langle z_{\\ell}^{</em>},u^{<em>A^{t^{</em>}}(z_{\\ell}^{<em>})}u^{\\prime</em>B^{t^{<em>}}(z_{\\ell}^{</em>})}\\rangle_{\\ell=1}^{v}\\rangle</span></p>

    <p class="text-gray-300">where <span class="math">u^{<em>}\\doteq g^{r^{</em>}}</span>, <span class="math">u^{\\prime<em>}\\doteq g^{\\prime r^{</em>}}</span>, <span class="math">u^{\\prime\\prime<em>}\\doteq u^{</em>A^{t^{<em>}}(0)}u^{\\prime</em>B^{t^{<em>}}(0)}\\cdot M_{\\sigma^{</em>}}</span> and <span class="math">r^{*}\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}</span>. This syntactic change does not affect the adversary’s view, and thus</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{1}^{1}]=\\Pr[T_{1}^{0}].</span> (15)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}^{2}</span>. To turn game <span class="math">\\mathbf{G}_{1}^{1}</span> into game <span class="math">\\mathbf{G}_{1}^{2}</span> we make another change to the way in which the challenge ciphertext is computed. Namely, the value <span class="math">u^{\\prime<em>}</span> is now computed as <span class="math">u^{\\prime</em>}\\doteq g^{\\prime r^{\\prime<em>}}</span>, for a random <span class="math">r^{\\prime</em>}\\in\\mathbb{Z}_{q}</span> such that <span class="math">r^{\\prime<em>}\\neq r^{</em>}</span>. In other words, in game <span class="math">\\mathbf{G}_{1}^{2}</span> the values <span class="math">u^{<em>}</span> and <span class="math">u^{\\prime</em>}</span> are nearly independent (being subject only to <span class="math">r^{<em>}\\neq r^{\\prime</em>}</span>), whereas in game <span class="math">\\mathbf{G}_{1}^{1}</span> they are obtained using the same value <span class="math">r^{*}</span>. Therefore, using a standard reduction argument, any difference in behavior between games <span class="math">\\mathbf{G}_{1}^{1}</span> and <span class="math">\\mathbf{G}_{1}^{2}</span> can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{1}^{2}]-\\Pr[T_{1}^{1}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\ \\mathsf{AdvDDH}_{\\mathcal{G}}(k).$ (16)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}^{3}</span>. To define game <span class="math">\\mathbf{G}_{1}^{3}</span>, we again modify the challenge ciphertext: specifically, the value <span class="math">u^{\\prime\\prime<em>}</span> is now computed as <span class="math">g^{r^{\\prime\\prime</em>}}</span>, for a random <span class="math">r^{\\prime\\prime*}\\in\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">To prove that <span class="math">\\Pr[T_{1}^{3}]=\\Pr[T_{1}^{2}]</span>, we first consider all the quantities that can affect event <span class="math">T_{1}^{2}</span> in game <span class="math">\\mathbf{G}_{1}^{2}</span> and event <span class="math">T_{1}^{3}</span> in game <span class="math">\\mathbf{G}_{1}^{3}</span>, and then we show that these quantities have the same joint distribution in both games.</p>

    <p class="text-gray-300">Let <span class="math">D^{t^{<em>}}(\\cdot)</span> and <span class="math">E^{t^{</em>}}(\\cdot)</span> be the randomizing polynomials used in the last New-period operation before the challenge ciphertext was created. (If no New-period occurred at all during the attack game, then let both <span class="math">D^{t^{<em>}}(\\cdot)</span> and <span class="math">E^{t^{</em>}}(\\cdot)</span> be just the zero polynomial.)</p>

    <p class="text-gray-300">Let <span class="math">\\bar{t}</span> be the total number of New-period operations that occur during the entire game, and for <span class="math">t=1,\\ldots,\\bar{t}</span>, let <span class="math">c_{1}^{t},\\ldots,c_{2v+2}^{t}</span> be the coefficients of the randomizing polynomials <span class="math">D^{t}(\\cdot)</span> and <span class="math">E^{t}(\\cdot)</span> used in the <span class="math">t</span>th New-period operation. For <span class="math">t=1,\\ldots,\\bar{t}</span>, and <span class="math">j=1,\\ldots,2v+2</span>, let <span class="math">r_{j}^{t}</span> be the randomness used to encrypt (the encoding of) coefficient <span class="math">c_{j}^{t}</span> in the <span class="math">t</span>th reset message.</p>

    <p class="text-gray-300">Observe that the challenge ciphertext <span class="math">\\psi^{<em>}</span> is the only value in the adversary’s view which is computed differently in game <span class="math">\\mathbf{G}_{1}^{2}</span> and game <span class="math">\\mathbf{G}_{1}^{3}</span>. In particular, such encryption is defined in terms of the values <span class="math">r^{</em>}</span>, <span class="math">r^{\\prime<em>}</span> and <span class="math">r^{\\prime\\prime</em>}</span>: <span class="math">r^{<em>}</span> and <span class="math">r^{\\prime</em>}</span> are randomly chosen from <span class="math">\\mathbb{Z}_{q}</span> in both games, whereas <span class="math">r^{\\prime\\prime<em>}</span> is computed differently in the two games. For the sake of clarity, we will denote with <span class="math">[r^{\\prime\\prime</em>}]_{2}</span> and <span class="math">[r^{\\prime\\prime<em>}]_{3}</span> the value of such quantity in game <span class="math">\\mathbf{G}_{1}^{2}</span> and <span class="math">\\mathbf{G}_{1}^{3}</span>, respectively. Notice that <span class="math">[r^{\\prime\\prime</em>}]_{2}</span> is a linear combination of <span class="math">r^{<em>}</span>, <span class="math">r^{\\prime</em>}</span> (and other quantities), whereas <span class="math">[r^{\\prime\\prime*}]_{3}</span> is uniformly distributed in <span class="math">\\mathbb{Z}_{q}</span>, independently of anything else.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The rest of our analysis proceeds differently depending on whether the adversary's strategy caused the "special" New-period operation to occur or not. The case in which no New-period operation occurred at step 7. of the attack game is slightly simpler, so we discuss it first.</p>

    <p class="text-gray-300">CASE 1. Consider the quantity</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {V} \\doteq (\\text {Coins}, w, \\{\\{c _ {j} ^ {t}, r _ {j} ^ {t} \\} _ {j = 1} ^ {2 v + 2} \\} _ {t = 1} ^ {\\bar {t}}, \\sigma^ {*}, r ^ {*}, r ^ {\\prime *} \\}</span></div>

    <p class="text-gray-300">where Coins represents the coin tosses of  <span class="math">\\mathcal{A}</span> ,  <span class="math">w \\doteq \\log_g g&#x27;</span> , and  <span class="math">\\sigma^*</span>  is the random bit chosen by the challenger in step 8. of the attack game.</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of the  <span class="math">2v + 2</span>  coefficients of the polynomials  <span class="math">A^0 (\\cdot)</span> ,  <span class="math">B^{0}(\\cdot)</span>  and can be represented by a vector  <span class="math">\\pmb{\\alpha}</span>  uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v + 2)\\times 1}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\alpha} \\doteq (a _ {0}, a _ {1}, \\dots , a _ {v}, b _ {0}, b _ {1}, \\dots , b _ {v}) ^ {T}.</span></div>

    <p class="text-gray-300">Consider the vector  <span class="math">\\beta \\in \\mathbb{Z}_q^{(2v + 2)\\times 1}</span>  defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} \\doteq (\\mathbf {X} _ {0}, \\mathbf {X} _ {1}, \\dots , \\mathbf {X} _ {v}, \\mathbf {A} _ {1}, \\dots , \\mathbf {A} _ {v}, r ^ {\\prime \\prime *}) ^ {T}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_0\\dot{=} A^0 (0) + wB^0 (0)</span> ,  <span class="math">\\mathbf{X}_{\\ell}\\doteq A^{0}(\\ell) + wB^{0}(\\ell)</span>  and  <span class="math">\\mathbf{A}_{\\ell}\\doteq A^{0}(x_{\\ell})</span>  for  <span class="math">\\ell = 1,\\ldots ,v</span> , and  <span class="math">r^{\\prime \\prime <em>} \\doteq \\log_g u^{\\prime \\prime </em>}</span> .</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the adversary's view is completely determined by  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\beta</span> . Thus, if the distribution of  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\beta</span>  is the same in both games  <span class="math">\\mathbf{G}_1^2</span>  and  <span class="math">\\mathbf{G}_1^3</span> , it will follow that  <span class="math">\\operatorname<em>{Pr}[T_1^3] = \\operatorname</em>{Pr}[T_1^2]</span> . Since the definition of  <span class="math">r&#x27;&#x27;^<em></span>  is the only difference between game  <span class="math">\\mathbf{G}_1^2</span>  and  <span class="math">\\mathbf{G}_1^3</span> , and in  <span class="math">\\mathbf{G}_1^3</span>  the value of  <span class="math">[r&#x27;&#x27;^</em>]_3</span>  is chosen uniformly from  <span class="math">\\mathbb{Z}_q</span> , independently of anything else, it suffices to show that the distribution of  <span class="math">[r&#x27;&#x27;^*]_2</span> , conditioned on  <span class="math">\\mathbf{V}</span>  and the first  <span class="math">2v + 1</span>  entries of  <span class="math">\\beta</span> , is also uniform in  <span class="math">\\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">In game  <span class="math">\\mathbf{G}_1^2</span> , the quantities in  <span class="math">\\mathbf{V}</span> ,  <span class="math">\\beta</span>  and  <span class="math">\\alpha</span>  are related according to the following matrix equation:</p>

    <div class="my-4 text-center"><span class="math-block">[ \\beta ] _ {2} = \\mathbf {M} \\cdot \\boldsymbol {\\alpha} + \\gamma</span></div>

    <p class="text-gray-300">where  <span class="math">[\\beta]_2</span>  denotes the value of  <span class="math">\\beta</span>  in game  <span class="math">\\mathbf{G}_1^2</span>  (i.e. when the value of the last entry is  <span class="math">[r&#x27;&#x27;_*]_2</span> ),  <span class="math">\\gamma \\in \\mathbb{Z}_q^{(2v + 2) \\times 1}</span>  is the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\gamma \\doteq \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ r ^ {*} (D ^ {0, t ^ {*}} (0)) + w r ^ {\\prime *} (E ^ {0, t ^ {*}} (0)) + \\log_ {g} M _ {\\sigma^ {*}} \\end{array} \\right)</span></div>

    <p class="text-gray-300">and  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(2v + 2) \\times (2v + 2)}</span>  is the matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {M} \\doteq \\left( \\begin{array}{c c c c c c c} 1 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 &amp;amp; w &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; 1 &amp;amp; w &amp;amp; w &amp;amp; \\ldots &amp;amp; w \\\\ &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots &amp;amp; \\\\ 1 &amp;amp; v &amp;amp; \\ldots &amp;amp; v ^ {v} &amp;amp; w &amp;amp; w v &amp;amp; \\ldots &amp;amp; w v ^ {v} \\\\ 1 &amp;amp; x _ {1} &amp;amp; \\ldots &amp;amp; x _ {1} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots &amp;amp; \\\\ 1 &amp;amp; x _ {v} &amp;amp; \\ldots &amp;amp; x _ {v} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ r ^ {*} &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 &amp;amp; w r ^ {\\prime *} &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\end{array} \\right)</span></div>

    <p class="text-gray-300">The above matrix  <span class="math">\\mathbf{M}</span>  is square, has full rank (provided that  <span class="math">r^<em> \\neq r&#x27;^</em></span>  and  <span class="math">w \\neq 0</span> ) and it describes all the constraints on the  <span class="math">(2v + 2)</span>  unknowns represented by  <span class="math">\\alpha</span> , that can be derived from the information in</p>

    <p class="text-gray-300">the adversary’s view in <span class="math">\\mathbf{G}_{1}^{2}</span>. In particular, the fact that no New-period operation occurred during execution of step 7. of the attack game guarantees that the identities included in the public key <span class="math">PK^{<em>}</span> that was used to create the challenge ciphertext <span class="math">\\psi^{</em>}</span> are exactly those of the users corrupted by the adversary. Hence, the constraints on <span class="math">\\boldsymbol{\\alpha}</span> arising from the last <span class="math">v</span> components of the challenge ciphertext <span class="math">\\psi^{*}</span> can be obtained as linear combination of the constraints specified by <span class="math">\\mathbf{M}</span>.</p>

    <p class="text-gray-300">As soon as we fix a value for <span class="math">\\boldsymbol{V}</span>, the first <span class="math">2v+1</span> entries of vector <span class="math">\\boldsymbol{\\gamma}</span> and the first <span class="math">v+1</span> rows of matrix <span class="math">\\mathbf{M}</span> are completely fixed, but <span class="math">\\boldsymbol{\\alpha}</span> is still distributed uniformly and independently at random in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>. If we additionally fix the value of the first <span class="math">(v+1)</span> components of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>, the initial public key <span class="math">PK^{0}</span> is fixed; it follows that the first identity <span class="math">x_{1}</span> that <span class="math">\\mathcal{A}</span> chooses to corrupt is also fixed and thus the <span class="math">(v+2)</span>th row of <span class="math">\\mathbf{M}</span> is determined. Fixing also a value for <span class="math">A_{1}</span> (which is the <span class="math">(v+2)</span>th entry of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>), the value of <span class="math">B_{1}</span> is fixed too, so that all the information on which the adversary can base her choice of <span class="math">x_{2}</span> is fixed, and thus the <span class="math">(v+3)</span>th row of <span class="math">\\mathbf{M}</span> is determined as well. By a similar reasoning, it follows that fixing the first <span class="math">(v+\\ell+1)</span> entries of <span class="math">[\\boldsymbol{\\beta}]_{2}</span> determines the <span class="math">(v+\\ell+2)</span>th row of <span class="math">\\mathbf{M}</span>, for <span class="math">\\ell=1,\\ldots,v</span>. In particular, fixing all the entries of the <span class="math">[\\boldsymbol{\\beta}]_{2}</span> but the last, fixes all the information that adversary <span class="math">\\mathcal{A}</span> sees before asking for her challenge: thus, her choice of <span class="math">M_{0}</span>, <span class="math">M_{1}</span> is determined, so that the last entry of <span class="math">\\boldsymbol{\\gamma}</span> is fixed, too. Hence, by Lemma 1, we can conclude that the conditional distribution of <span class="math">[r^{\\prime\\prime*}]_{2}</span>, w.r.t. <span class="math">\\boldsymbol{V}</span> and to all the other components of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>, is also uniform over <span class="math">\\mathbb{Z}_{q}</span>, from which it follows that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{1}^{3}]=\\Pr[T_{1}^{2}].</span> (17)</p>

    <p class="text-gray-300">Case 2. We now discuss the case in which the “special” New-period operation takes place: in particular, let <span class="math">D^{\\hat{t}}(\\cdot)</span> and <span class="math">E^{\\hat{t}}(\\cdot)</span> be the randomizing polynomials used in such New-period operation. Consider the quantity</p>

    <p class="text-gray-300">\\[ \\boldsymbol{V}\\doteq\\Big{(}\\mathsf{Coins},w,\\{c_{j}^{t},r_{j}^{t}\\}_{j=1\\atop t\\neq\\hat{t}}^{2v+2},\\{s_{j},r_{j}^{\\hat{t}}\\}_{j=1}^{2v+2},\\sigma^{<em>},r^{</em>},r^{\\prime*}\\Big{)} \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Coins}</span> represents the coin tosses of <span class="math">\\mathcal{A}</span>, <span class="math">w\\doteq\\log_{g}g^{\\prime}</span>, <span class="math">\\sigma^{*}</span> is the random bit chosen by the challenger in step 8. of the attack game, and <span class="math">s_{1}</span>, <span class="math">\\ldots</span>, <span class="math">s_{2v+2}</span> are the random elements of <span class="math">\\mathcal{G}</span> that are encrypted by the “special” New-period operation in place of the randomizing coefficients <span class="math">d_{0}^{\\hat{t}}</span>, <span class="math">d_{1}^{\\hat{t}}</span>, <span class="math">\\ldots</span>, <span class="math">d_{v}^{\\hat{t}}</span>, and <span class="math">e_{0}^{\\hat{t}}</span>, <span class="math">e_{1}^{\\hat{t}}</span>, <span class="math">\\ldots</span>, <span class="math">e_{v}^{\\hat{t}}</span>.</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of these randomizing coefficients, along with the <span class="math">2v+2</span> coefficients of the polynomials <span class="math">A^{0}(\\cdot)</span>, <span class="math">B^{0}(\\cdot)</span> and can be represented by a vector <span class="math">\\boldsymbol{\\alpha}</span> uniformly distributed in <span class="math">\\mathbb{Z}_{q}^{(4v+4)\\times 1}</span>, given in Figure 1.</p>

    <p class="text-gray-300">Consider the vector <span class="math">\\boldsymbol{\\beta}\\in\\mathbb{Z}_{q}^{(4v+3)\\times 1}</span> defined in Figure 1: it is clear by inspection that all the information in the adversary’s view is completely determined by <span class="math">\\boldsymbol{V}</span> and <span class="math">\\boldsymbol{\\beta}</span>. In particular, the initial public key <span class="math">PK^{0}</span> is fixed by <span class="math">\\boldsymbol{\\beta}</span> and <span class="math">w</span>; the secret keys of the corrupted users are determined by the choice of <span class="math">\\boldsymbol{\\beta}</span>, <span class="math">\\mathsf{Coins}</span> and <span class="math">w</span>; the “special” reset message is fixed by <span class="math">PK^{0}</span>, <span class="math">\\mathsf{Coins}</span>, and all the randomness in <span class="math">\\boldsymbol{V}</span>; the resulting public key <span class="math">PK^{\\hat{t}}</span> only depends on <span class="math">\\boldsymbol{\\beta}</span> and <span class="math">w</span>; and the adversary’s choice of <span class="math">M_{0}</span> and <span class="math">M_{1}</span> is fixed by <span class="math">\\boldsymbol{V}</span> and the first <span class="math">4v+2</span> entries of <span class="math">\\boldsymbol{\\beta}</span>.</p>

    <p class="text-gray-300">Thus, if the distribution of <span class="math">\\boldsymbol{V}</span> and <span class="math">\\boldsymbol{\\beta}</span> is the same in both games <span class="math">\\mathbf{G}_{1}^{2}</span> and <span class="math">\\mathbf{G}_{1}^{3}</span>, it will follow that <span class="math">\\Pr[T_{1}^{3}]=\\Pr[T_{1}^{2}]</span>. Since the definition of <span class="math">r^{\\prime\\prime<em>}</span> is the only difference between game <span class="math">\\mathbf{G}_{1}^{2}</span> and <span class="math">\\mathbf{G}_{1}^{3}</span>, and in <span class="math">\\mathbf{G}_{1}^{3}</span> the value of <span class="math">[r^{\\prime\\prime</em>}]_{3}</span> is chosen uniformly from <span class="math">\\mathbb{Z}_{q}</span>, independently of anything else, it suffices to show that the distribution of <span class="math">[r^{\\prime\\prime*}]_{2}</span>, conditioned on <span class="math">\\boldsymbol{V}</span> and the first <span class="math">4v+2</span> entries of <span class="math">\\boldsymbol{\\beta}</span>, is also uniform in <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">In game <span class="math">\\mathbf{G}_{1}^{2}</span>, the quantities in <span class="math">\\boldsymbol{V}</span>, <span class="math">\\boldsymbol{\\beta}</span> and <span class="math">\\boldsymbol{\\alpha}</span> are related according to the following matrix equation:</p>

    <p class="text-gray-300"><span class="math">[\\boldsymbol{\\beta}]_{2}=\\mathbf{M}\\cdot\\boldsymbol{\\alpha}+\\boldsymbol{\\gamma}</span></p>

    <p class="text-gray-300">where <span class="math">[\\boldsymbol{\\beta}]_{2}</span> denotes the value of <span class="math">\\boldsymbol{\\beta}</span> in game <span class="math">\\mathbf{G}_{1}^{2}</span> (i.e. when the value of the last entry is <span class="math">[r^{\\prime\\prime*}]_{2}</span>) and <span class="math">\\boldsymbol{\\gamma}\\in\\mathbb{Z}_{q}^{(4v+3)\\times 1}</span> and <span class="math">\\mathbf{M}\\in\\mathbb{Z}_{q}^{(4v+3)\\times(4v+4)}</span> are defined in Figure 1.</p>

    <p class="text-gray-300">The matrix <span class="math">\\mathbf{M}</span> in Figure 1 describes all the constraints on the <span class="math">(4v+4)</span> unknowns represented by <span class="math">\\boldsymbol{\\alpha}</span>, that can be derived from the information in the adversary’s view in game <span class="math">\\mathbf{G}_{1}^{2}</span>. Notice that <span class="math">\\mathbf{M}</span> includes the constraints on <span class="math">\\boldsymbol{\\alpha}</span> arising from the last <span class="math">v</span> components of the challenge ciphertext <span class="math">\\psi^{<em>}</span>. Moreover, since we are assuming that the “special” New-period operation took place during the execution of step 7. of the attack game, and that the adversary never revokes the users she corrupts, the identities <span class="math">z_{1}^{</em>}</span>, <span class="math">\\ldots</span>, <span class="math">z_{v}^{*}</span> specified in the</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Vectors  <span class="math">\\alpha \\in \\mathbb{Z}_q^{(4v + 4)\\times 1}</span> ,  <span class="math">\\beta \\in \\mathbb{Z}_q^{(4v + 3)\\times 1}</span>  and the matrix  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(4v + 3)\\times (4v + 4)}</span>  used in the last information-theoretic argument of Lemma 3. Notation:  <span class="math">r^{\\prime \\prime <em>} \\doteq \\log_g u^{\\prime \\prime </em>}</span> ,  <span class="math">\\mathbf{X}_0 \\doteq A^0(0) + wB^0(0)</span> ,  <span class="math">\\hat{\\mathbf{X}}_0 \\doteq A^\\ell(0) + wB^\\ell(0)</span> , and for  <span class="math">\\ell = 1, \\ldots, v</span> ,  <span class="math">\\mathbf{X}_{\\ell} \\doteq A^0(\\ell) + wB^0(\\ell)</span> ,  <span class="math">\\hat{\\mathbf{X}}_{\\ell} \\doteq A^\\ell(\\ell) + wB^\\ell(\\ell)</span> ,  <span class="math">\\mathbf{A}_{\\ell} \\doteq A^0(x_{\\ell})</span>  and  <span class="math">\\mathbf{X}_{\\ell}^<em> \\doteq r^</em>A^{t^<em>} (z_{\\ell}^</em>) + wr&#x27;^<em>B^{t^</em>} (z_{\\ell}^*)</span> .</p>

    <p class="text-gray-300">public key  <span class="math">PK^{t^<em>}</span>  that is used to create the challenge ciphertext are all different from the identities  <span class="math">x_1, \\ldots, x_v</span>  of the corrupted users, so that  <span class="math">\\mathbf{M}</span>  has full rank, provided that  <span class="math">r^</em> \\neq r&#x27;^*</span>  and  <span class="math">w \\neq 0</span> .</p>

    <p class="text-gray-300">As soon as we fix a value for  <span class="math">\\mathbf{V}</span> , the first  <span class="math">4v + 2</span>  entries of vector  <span class="math">\\gamma</span>  and the first  <span class="math">2v + 2</span>  rows of matrix  <span class="math">\\mathbf{M}</span>  are completely fixed, but  <span class="math">\\alpha</span>  is still distributed uniformly and independently at random in  <span class="math">\\mathbb{Z}_q^{(4v + 4)\\times 1}</span> . If we additionally fix the value of the first  <span class="math">(2v + 2)</span>  components of  <span class="math">[\\beta]_2</span> , the initial public key  <span class="math">PK^0</span>  is fixed (in fact, the public key  <span class="math">PK^\\ell</span>  resulting from the "special" New-period operation gets fixed, too); it follows that</p>

    <p class="text-gray-300">the first identity <span class="math">x_{1}</span> that <span class="math">\\mathcal{A}</span> chooses to corrupt is also fixed and thus the <span class="math">(2v+3)</span>th row of <span class="math">\\mathbf{M}</span> is determined. Fixing also a value for <span class="math">\\mathbf{A}_{1}</span> (which is the <span class="math">(2v+3)</span>th entry of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>), the value of <span class="math">\\mathbf{B}_{1}</span> is fixed too, so that all the information on which the adversary can base her choice of <span class="math">x_{2}</span> is fixed, and thus the <span class="math">(2v+4)</span>th row of <span class="math">\\mathbf{M}</span> is determined as well. By a similar reasoning, it follows that fixing the first <span class="math">(2v+\\ell+2)</span> entries of <span class="math">[\\boldsymbol{\\beta}]_{2}</span> determines the <span class="math">(2v+\\ell+3)</span>th row of <span class="math">\\mathbf{M}</span>, for <span class="math">\\ell=1,\\ldots,v</span>. In particular, fixing the first <span class="math">3v+2</span> entries of <span class="math">[\\boldsymbol{\\beta}]_{2}</span> fixes all the information that adversary <span class="math">\\mathcal{A}</span> sees before asking for her challenge: thus, the identities <span class="math">z_{1}^{<em>}</span>, <span class="math">\\ldots</span>, <span class="math">z_{v}^{</em>}</span>, as well as the two messages <span class="math">M_{0}</span>, <span class="math">M_{1}</span> chosen by <span class="math">\\mathcal{A}</span> are determined, so that all the remaining rows of <span class="math">\\mathbf{M}</span>, as well as the last entry of <span class="math">\\boldsymbol{\\gamma}</span> get fixed, too. Hence, by Lemma 1, we can conclude that the conditional distribution of <span class="math">[r^{\\prime\\prime*}]_{2}</span>, w.r.t. <span class="math">\\boldsymbol{V}</span> and to all other components of <span class="math">[\\boldsymbol{\\beta}]_{2}</span>, is uniform over <span class="math">\\mathbb{Z}_{q}</span>, from which it follows that Equation (17) holds in this case, too.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}^{4}</span>. Game <span class="math">\\mathbf{G}_{1}^{4}</span> is defined to be identical to <span class="math">\\mathbf{G}_{2}</span>. Thus, <span class="math">\\mathbf{G}_{1}^{4}</span> differs from <span class="math">\\mathbf{G}_{1}^{3}</span> only in that the values <span class="math">u^{<em>}</span> and <span class="math">u^{\\prime</em>}</span> in the challenge ciphertext <span class="math">\\psi^{<em>}</span> are consistent, rather than being nearly independent, as in game <span class="math">\\mathbf{G}_{1}^{3}</span>. Namely, the values <span class="math">u^{</em>}</span> and <span class="math">u^{\\prime<em>}</span> are now computed as <span class="math">u^{</em>}\\doteq g^{r^{<em>}}</span> and <span class="math">u^{\\prime</em>}\\doteq g^{\\prime r^{<em>}}</span>, for the same random <span class="math">r^{</em>}\\in\\mathbb{Z}_{q}</span>. It follows that any difference in behavior between games <span class="math">\\mathbf{G}_{1}^{3}</span> and <span class="math">\\mathbf{G}_{1}^{4}</span> can be used to distinguish Diffie-Hellman tuples from totally random tuples. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{1}^{4}]-\\Pr[T_{1}^{3}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\texttt{ AdvDDH}_{\\mathcal{G}}(k).$ (18)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Equations (15), (16), (17) and (18), the thesis follows. ∎</p>

    <h2 id="sec-29" class="text-2xl font-bold">6 Dealing with Traceability</h2>

    <p class="text-gray-300">The goal of a tracing algorithm is to obtain the identity of at least one of the pirates who colluded in creating a given “pirate decoder” <span class="math">\\mathsf{D}</span> which, as in previous work, is assumed to be stateless. In this section we present a formal model for traceability and two tracing algorithms that can be integrated within the scheme described in Section 4.</p>

    <p class="text-gray-300">The first method, a <em>black-box algorithm</em>, repeatedly calls a <em>black-box confirmation</em> subroutine that, given a pirate decryption device and a subset of at most <span class="math">m</span> suspected users, checks whether the suspected set includes all the user-keys that were used to generate the pirate device, and if so outputs the identity of one of the traitors.</p>

    <p class="text-gray-300">The second method, a <em>non-black-box algorithm</em>, receives as input a “valid” key extracted from a pirate device which was constructed using the keys of at most <span class="math">m</span> users and deterministically recovers the identities of all the traitors.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">6.1 Model for Traceability</h3>

    <p class="text-gray-300">The traceability adversary operates similarly to the revocation adversary described in Section 5. Namely, after receiving the initial public key of the system, adversary <span class="math">\\mathcal{A}</span> can interleave (in any adaptively-chosen order) up to <span class="math">m</span> Join queries, upon which <span class="math">\\mathcal{A}</span> receives the secret keys of the corresponding users (the <em>traitors</em>), and a polynomial number of Revoke queries. Notice that each Revoke will change the public key, and the adversary monitors these changes as well. Also notice that the final set of revoked users is likely very different, and typically disjoint from the set <span class="math">\\mathcal{T}</span> of traitors. At the end, <span class="math">\\mathcal{A}</span> outputs a pirate decoder <span class="math">\\mathsf{D}</span> which presumably works well (in some sense more precisely clarified below), with the final public key <span class="math">PK_{\\mathcal{A}}</span>.</p>

    <p class="text-gray-300">Formal Model for Traceability Adversary. We formalize the above attack scenario in terms of the traceability adversary attack game <span class="math">\\mathbf{G}_{\\text{trt}}^{m}(1^{k})</span>, played between a challenger and the adversary.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\langle PK,MSK\\rangle:=\\mathsf{Setup}(1^{k})</span>.</li>

      <li>Let <span class="math">L:=0</span>, <span class="math">\\mathcal{T}:=\\emptyset</span>.</li>

    </ol>

    <p class="text-gray-300">3.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">state:=\\langle L,PK,MSK,\\mathcal{T}\\rangle</span>.</li>

      <li><span class="math">\\mathsf{D}\\leftarrow\\mathcal{A}^{\\textsf{Join}(state,:),\\textsf{Revoke}(state,:)}(state.PK)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>m$ then exit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">state</span> as <span class="math">\\langle L,PK_{\\mathcal{A}},MSK_{\\mathcal{A}},\\mathcal{T}\\rangle</span>.</li>

      <li>Output <span class="math">\\langle\\mathsf{D},PK_{\\mathcal{A}},MSK_{\\mathcal{A}},\\mathcal{T}\\rangle</span>.</li>

    </ol>

    <p class="text-gray-300">The definitions of the Join and Revoke oracles is the same as in Section 5.1, except that the role of the set Corr is now played by the set <span class="math">\\mathcal{T}</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">For any public key <span class="math">PK</span>, define the success probability of a decoder <span class="math">\\mathsf{D}</span> as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Succ}_{PK}(\\mathsf{D})\\doteq\\Pr[M^{\\prime}=M\\mid M\\stackrel{{\\scriptstyle\\text{\\tiny</span>\\leftarrow<span class="math">}}}{{\\leftarrow}}\\mathcal{G};\\psi^{<em>}\\stackrel{{\\scriptstyle\\text{\\tiny</span>\\leftarrow<span class="math">}}}{{\\leftarrow}}\\mathcal{E}(PK,M);</span> <span class="math">M^{\\prime}\\stackrel{{\\scriptstyle\\text{\\tiny</span>\\leftarrow<span class="math">}}}{{\\leftarrow}}\\mathsf{D}(\\psi^{</em>})]</span></p>

    <p class="text-gray-300">where the probability is over the random choice of <span class="math">M</span>, the randomness used to create the challenge ciphertext <span class="math">\\psi^{*}</span> and the coin tosses of <span class="math">\\mathsf{D}</span>.</p>

    <p class="text-gray-300">Notice that the pirate decoder <span class="math">\\mathsf{D}</span> expects to receive a ciphertext created under the public key <span class="math">PK_{\\mathcal{A}}</span>, but the quantity <span class="math">\\mathsf{Succ}_{PK}(\\mathsf{D})</span> can be defined for any public key anyway. Clearly, if <span class="math">\\mathsf{D}</span> could notice the change, then it could stop working properly: in this case we can assume that it outputs a message <span class="math">M^{\\prime}\\neq M</span>.</p>

    <p class="text-gray-300">The job of the tracing algorithm is to find one or all of the (at most) <span class="math">m</span> traitors whose keys were used by <span class="math">\\mathcal{A}</span> in building <span class="math">\\mathsf{D}</span>. The precise security guarantees depend on whether tracing is black-box or not. We describe both tracing methods in Section 6.2 and 6.3, respectively.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">6.2 Black-Box Tracing</h3>

    <p class="text-gray-300">In the black-box model, the tracing algorithm is only allowed to query the pirate decoder <span class="math">\\mathsf{D}</span> on a polynomial number of a random-looking ciphertexts, and from the plain observation of <span class="math">\\mathsf{D}</span>’s input/output behavior, the tracing algorithm should successfully in identifying (at least) one of the traitors.</p>

    <p class="text-gray-300">This form of tracing is the most desirable, as it can be applied to any stateless pirate decoder. Similarly to previous work <em>[3, 19, 21]</em>, though, the algorithm presented below only achieves a weaker variant of black-box tracing, called black-box confirmation. Informally, a black-box confirmation algorithm is a subroutine that tests whether a given set <span class="math">\\mathsf{Susp}</span> of at most <span class="math">m</span> suspected users does include all the traitors that cooperated to construct a given pirate decoder <span class="math">\\mathsf{D}</span>, and if so, it outputs at least one such pirate. On a pessimistic note, this means that our tracing algorithm might have to go through all <span class="math">m</span>-element subsets of the user universe <span class="math">\\mathcal{U}</span> to do full-fledged tracing. However, we point out that: (1) in many cases a lot of partial information about the set of corrupted users makes the search space dramatically smaller; (2) all previous public-key traitor tracing schemes suffer from the same problem; (3) as observed in <em>[14]</em>, the problem seems to be inherent to this setting.</p>

    <p class="text-gray-300">However, we significantly improve upon previous black-box confirmation algorithms in the following respects: (1) formal modeling of the problem; (2) our algorithm allows the adversary to adaptively corrupt players before building the pirate decoder; (3) our algorithm can be successfully applied to pirate decoders that work on at least an <span class="math">\\varepsilon</span>-fraction of correctly formed messages (rather than with probability 1), where <span class="math">\\varepsilon</span> is the desired threshold below which the decoder is considered “useless” (following the “threshold tracing” approach of <em>[18]</em>).</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 9 (Black-Box Confirmation Algorithm).</h6>

    <p class="text-gray-300">A <em>Black-Box Confirmation</em> (<span class="math">\\mathsf{BBC}</span>) algorithm is a probabilistic, polynomial time oracle machine, taking as oracle input a pirate decoder <span class="math">\\mathsf{D}</span>, and as regular input a public key <span class="math">PK</span>, the corresponding master secret key <span class="math">MSK</span>, and a set <span class="math">\\mathsf{Susp}</span> of suspected traitors. Its output is either a user’s identity <span class="math">i</span> or the special symbol <span class="math">\\mathsf{?}</span>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 10 (<span class="math">\\varepsilon</span>-Black-Box Confirmation Property).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be any probabilistic, polynomial-time adversary, and let <span class="math">\\langle\\mathsf{D}</span>, <span class="math">PK_{\\mathcal{A}}</span>, <span class="math">MSK_{\\mathcal{A}}</span>, <span class="math">\\mathcal{T}\\rangle</span> be the output resulting from the adversary playing the traceability attack game <span class="math">\\bm{G}_{\\mathsf{ot}}^{m}(1^{k})</span> with the challenger. A Black-Box Confirmation algorithm <span class="math">\\mathsf{BBC}</span> satisfies <span class="math">\\varepsilon</span>-Black-Box Confirmation if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span> playing the <span class="math">\\bm{G}_{\\mathsf{ot}}^{m}(1^{k})</span> game, the following two properties hold with all but negligible probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Confirmation: whenever <span class="math">\\mathcal{T} \\subseteq \\mathrm{Susp}</span>, then the output of <span class="math">\\mathrm{BBC}^{\\mathrm{D}}(PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, \\mathrm{Susp})</span> is some identity <span class="math">i \\in \\mathcal{T}</span>.</li>

      <li>Soundness: whenever <span class="math">\\mathrm{BBC}^{\\mathrm{D}}(PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, \\mathrm{Susp})</span> outputs <span class="math">i \\neq ?</span>, then <span class="math">i \\in \\mathcal{T}</span>.</li>

    </ul>

    <p class="text-gray-300">Black-Box Confirmation Algorithm At a high level, our black-box confirmation algorithm BBC works as follows. Based on the current set <span class="math">I</span> of suspected users (initially set to Susp) and using the master secret key <span class="math">MSK_{\\mathcal{A}}</span>, it modifies the public key <span class="math">PK_{\\mathcal{A}}</span> into a fake public key <span class="math">PK(I)</span>. It then estimates the probability</p>

    <div class="my-4 text-center"><span class="math-block">\\delta (I) \\doteq \\operatorname {S u c c} _ {P K (I)} (\\mathsf {D})</span></div>

    <p class="text-gray-300">by observing the behavior of <span class="math">\\mathsf{D}</span> when fed with encryptions of the form <span class="math">\\mathcal{E}(PK(I),M)</span>, for random messages <span class="math">M</span>. The Chernoff bound implies that the latter estimation can be done quickly and accurately (by computing statistics from repeated sampling), provided <span class="math">\\delta (I)</span> is "large enough" (specifically, at least <span class="math">\\varepsilon /m</span>). Now, BBC takes any index <span class="math">i\\in I</span>, and accurately estimates <span class="math">\\delta (I\\setminus \\{i\\})</span>. If the difference between <span class="math">\\delta (I)</span> and <span class="math">\\delta (I\\setminus \\{i\\})</span> is "non-trivial" (specifically, at least <span class="math">\\varepsilon /2m</span>), it proclaims <span class="math">i</span> as a traitor. Otherwise, it sets <span class="math">I\\coloneqq I\\setminus \\{i\\}</span>, and repeats the entire procedure until <span class="math">I = \\emptyset</span> (in which case it outputs?).</p>

    <p class="text-gray-300">The last main detail to be filled in is how the algorithm generates the fake public key <span class="math">PK(I)</span>. Recall from Section 4 that the master secret key <span class="math">MSK_{\\mathcal{A}}</span> consists of two random polynomials over <span class="math">\\mathbb{Z}_q^v[x]</span>. Let <span class="math">\\bar{t}</span> be the total number of New-period operations that occur during the entire game, and for <span class="math">t = 1,\\dots ,\\bar{t}</span>, let <span class="math">c_1^t,\\ldots ,c_{2v + 2}^t</span> be the coefficients of the randomizing polynomials <span class="math">D^{t}(\\cdot)</span> and <span class="math">E^{t}(\\cdot)</span> used in the <span class="math">t</span>th New-period operation. For <span class="math">t = 1,\\dots ,\\bar{t}</span>, and <span class="math">j = 1,\\dots ,2v + 2</span>, let <span class="math">r_j^t</span> be the randomness used to encrypt (the encoding of) coefficient <span class="math">c_{j}^{t}</span> in the <span class="math">t</span>th reset message. By Equation (8), <span class="math">(A^{\\bar{t}}(\\cdot),B^{\\bar{t}}(\\cdot))</span> denotes the master secret key corresponding to the public key <span class="math">PK_{\\mathcal{A}}</span>. Given the set <span class="math">I</span>, we create two polynomials <span class="math">A^{\\prime}(\\cdot)</span> and <span class="math">B^{\\prime}(\\cdot)</span> uniformly distributed over <span class="math">\\mathbb{Z}_q^v[x]</span> except they agree with <span class="math">A^{\\bar{t}}(\\cdot)</span> and <span class="math">B^{\\bar{t}}(\\cdot)</span> on points in <span class="math">I</span>:</p>

    <div class="my-4 text-center"><span class="math-block">A ^ {\\prime} (x _ {s}) = A ^ {\\bar {t}} (x _ {s}) \\quad B ^ {\\prime} (x _ {s}) = B ^ {\\bar {t}} (x _ {s}), \\forall s \\in I.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notice that, since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m \\leq v / 2<span class="math">, this creates no problem. We then create the public key </span>PK(I)<span class="math"> as if the master secret key were </span>MSK' = (A'(\\cdot), B'(\\cdot))<span class="math"> rather than </span>MSK_{\\mathcal{A}} = (A^{\\bar{t}}(\\cdot), B^{\\bar{t}}(\\cdot))$. Specifically, we define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">P K (I) \\doteq (g, g ^ {\\prime}, y ^ {\\prime}, \\langle z _ {\\ell}, h _ {\\ell} ^ {\\prime} \\rangle_ {\\ell = 1} ^ {v}).</span></div>

    <p class="text-gray-300">where <span class="math">y^\\prime \\doteq g^{A^\\prime (0)}\\cdot g^{\\prime B^\\prime (0)}</span>, and <span class="math">h_\\ell^\\prime \\doteq g^{A^\\prime (z_\\ell)}</span> and <span class="math">g^{\\prime B^{\\prime}(z_{\\ell})}</span>, for <span class="math">\\ell = 1,\\ldots ,v</span>.</p>

    <p class="text-gray-300">Correctness of Black-Box Tracing The correctness of the black-box tracing algorithm described above follows from Theorem 2 and Theorem 3 stated below. Theorem 2 implies that if the decoder was useful at the start (i.e., <span class="math">\\operatorname{Suc}_{PK_A}(\\mathsf{D}) \\geq \\varepsilon</span>) and <span class="math">\\mathcal{T} \\subseteq \\operatorname{Susp}</span>, then the decoder cannot "notice" that <span class="math">PK_{\\mathcal{A}}</span> was changed to <span class="math">PK(\\operatorname{Susp})</span>, i.e. <span class="math">\\delta(\\operatorname{Susp}) \\gtrsim \\varepsilon</span>. Coupled with the obvious fact that <span class="math">\\delta(\\emptyset)</span> is negligible (since <span class="math">M</span> is encrypted with a totally random one-time pad), we see that there must be a time when <span class="math">\\delta(I)</span> changes by a non-trivial amount (i.e., at least by <span class="math">\\varepsilon / 2m</span>) when we remove some <span class="math">i \\in I</span>. This <span class="math">i</span> will then be output by our algorithm, and since <span class="math">i</span> cannot be an innocent user (by Theorem 3 below), <span class="math">i</span> must be one of the traitors. This shows the confirmation property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2. Under the DDH assumption, if <span class="math">\\mathcal{T} \\subseteq \\mathrm{Susp}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Susp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq v<span class="math">, then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta (\\mathrm{Susp}) - \\mathrm{Suc}_{PK_{\\mathcal{A}}}(\\mathsf{D})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. We again follow the structural approach of defining a sequence of "indistinguishable" games <span class="math">\\mathbf{G}_0, \\mathbf{G}_1, \\ldots</span>, all operating over the same underlying probability space. Each of these games consists of the BBC algorithm sending a ciphertext <span class="math">\\psi^<em></span> to the pirate decoder <span class="math">\\mathsf{D}</span>; different games only differ in the way <span class="math">\\psi^</em></span> is computed. In the original game <span class="math">\\mathbf{G}_0</span>, the goal of the decoder <span class="math">\\mathsf{D}</span> is to output a message <span class="math">M&#x27;</span> which is <span class="math">\\mathsf{D}</span>'s best guess at the random message <span class="math">M</span> encrypted within <span class="math">\\psi^*</span>; for each game <span class="math">\\mathbf{G}_j</span>, let <span class="math">T_j</span> be the event that <span class="math">M = M&#x27;</span> in <span class="math">\\mathbf{G}_j</span>.</p>

    <p class="text-gray-300">6 The relation <span class="math">\\gtrsim</span> is meant to indicate that <span class="math">\\delta(\\mathrm{Susp})</span> is greater than <span class="math">\\varepsilon</span> minus negligible terms.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G}_{0}</span>: This game defines the probability <span class="math">\\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D})</span>. In this game, the <span class="math">\\mathsf{BBC}</span> algorithm takes as input the public key <span class="math">PK_{\\mathcal{A}}</span>, the corresponding master secret key <span class="math">MSK_{\\mathcal{A}}</span> and a set <span class="math">\\mathsf{Susp}</span> of suspected users; it then chooses a message <span class="math">M\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathcal{G}</span> and, using the public key <span class="math">PK_{\\mathcal{A}}</span>, encrypts it as follows:</p>

    <p class="text-gray-300"><span class="math">E1.</span> <span class="math">r\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}</span> <span class="math">E2.</span> <span class="math">u\\leftarrow g^{r}</span> <span class="math">E3.</span> <span class="math">u^{\\prime}\\leftarrow g^{\\prime r}</span> <span class="math">E4.</span> <span class="math">u^{\\prime\\prime}\\leftarrow M\\cdot g^{A^{\\ell}(0)r}g^{\\prime B^{\\ell}(0)r}</span> <span class="math">E5.</span> <span class="math">u_{\\ell}\\leftarrow g^{A^{\\ell}(z_{\\ell})r}g^{\\prime B^{\\ell}(z_{\\ell})r},\\quad\\ell=1,\\ldots,v</span> <span class="math">E6.</span> <span class="math">\\psi^{*}\\leftarrow\\langle u,u^{\\prime},u^{\\prime\\prime},\\langle z_{1},u_{1}\\rangle,\\ldots,\\langle z_{v},u_{v}\\rangle\\rangle</span></p>

    <p class="text-gray-300">By definition, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{0}]=\\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D}).</span> (19)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}</span>: Game <span class="math">\\mathbf{G}_{1}</span> is identical to game <span class="math">\\mathbf{G}_{0}</span>, except that in game <span class="math">\\mathbf{G}_{1}</span> steps <span class="math">E4</span> and <span class="math">E5</span> are substituted with:</p>

    <p class="text-gray-300"><span class="math">E4^{\\prime}.</span> <span class="math">u^{\\prime\\prime}\\leftarrow M\\cdot u^{A^{\\ell}(0)}u^{\\prime B^{\\ell}(0)}</span> <span class="math">E5^{\\prime}.</span> <span class="math">u_{\\ell}\\leftarrow u^{A^{\\ell}(z_{\\ell})}u^{\\prime B^{\\ell}(z_{\\ell})},\\quad\\ell=1,\\ldots,v</span></p>

    <p class="text-gray-300">Notice that the point of these changes is just to make explicit any functional dependency of <span class="math">\\psi^{*}</span> on the quantities <span class="math">u</span> and <span class="math">u^{\\prime}</span>. Since we just made a conceptual change, it clearly holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{1}]=\\Pr[T_{0}].</span> (20)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{2}</span>: To define game <span class="math">\\mathbf{G}_{2}</span>, we make more changes to the encryption algorithm as follows:</p>

    <p class="text-gray-300"><span class="math">E1^{\\prime}.</span> <span class="math">r\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q};\\quad r^{\\prime}\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}\\setminus\\{r\\}</span> <span class="math">E3^{\\prime}.</span> <span class="math">u^{\\prime}\\leftarrow g^{\\prime r^{\\prime}}</span></p>

    <p class="text-gray-300">Notice that while in game <span class="math">\\mathbf{G}_{1}</span> the value <span class="math">u</span> and <span class="math">u^{\\prime}</span> are obtained using the same value <span class="math">r</span>, in game <span class="math">\\mathbf{G}_{2}</span> they are nearly independent, being subject only to <span class="math">r\\neq r^{\\prime}</span>. Therefore, using a standard reduction argument, any non-negligible difference in behavior between games <span class="math">\\mathbf{G}_{1}</span> and <span class="math">\\mathbf{G}_{2}</span> can be used to construct a <span class="math">\\mathsf{PPT}</span> adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[T_{2}]-\\Pr[T_{1}]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\ \\mathsf{AdvDDH}_{\\mathcal{G}}(k).$ (21)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{3}</span>: To turn game <span class="math">\\mathbf{G}_{2}</span> into game <span class="math">\\mathbf{G}_{3}</span>, we consider the set <span class="math">\\mathsf{Susp}</span> and construct the public key <span class="math">PK(\\mathsf{Susp})</span> as described above; specifically, two random polynomials <span class="math">A^{\\prime}(\\cdot)</span> and <span class="math">B^{\\prime}(\\cdot)</span> are chosen such that</p>

    <p class="text-gray-300"><span class="math">A^{\\prime}(x_{s})=A^{\\bar{t}}(x_{s})\\quad B^{\\prime}(x_{s})=B^{\\bar{t}}(x_{s}),\\;\\forall s\\in\\mathsf{Susp}</span> (22)</p>

    <p class="text-gray-300">and <span class="math">PK(\\mathsf{Susp})</span> is set to be:</p>

    <p class="text-gray-300"><span class="math">PK(\\mathsf{Susp})\\doteq\\langle g,g^{\\prime},g^{A^{\\prime}(0)}g^{\\prime B^{\\prime}(0)},\\langle z_{\\ell},g^{A^{\\prime}(z_{\\ell})}g^{\\prime B^{\\prime}(z_{\\ell})}\\rangle_{\\ell=1}^{v}\\rangle.</span></p>

    <p class="text-gray-300">Then, we change steps <span class="math">E4^{\\prime}</span> and <span class="math">E5^{\\prime}</span> of the encryption algorithm of game <span class="math">\\mathbf{G}_{2}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">E4^{\\prime\\prime}.</span> <span class="math">u^{\\prime\\prime}\\leftarrow M\\cdot u^{A^{\\prime}(0)}u^{\\prime B^{\\prime}(0)}</span> <span class="math">E5^{\\prime\\prime}.</span> <span class="math">u_{\\ell}\\leftarrow u^{A^{\\prime}(z_{\\ell})}u^{\\prime B^{\\prime}(z_{\\ell})},\\quad\\ell=1,\\ldots,v</span></p>

    <p class="text-gray-300">Using the technique outlined in Section 5.2, in Lemma 4 below, we show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{3}]=\\Pr[T_{2}].</span> (23)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{4}</span>: In game <span class="math">\\mathbf{G}_{4}</span>, we “undo” the changes of game <span class="math">\\mathbf{G}_{2}</span>, restoring lines <span class="math">E1</span> and <span class="math">E3</span> of the encryption oracle to their original values:</p>

    <p class="text-gray-300"><span class="math">E1^{\\prime\\prime}.\\quad r\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}</span> <span class="math">E3^{\\prime\\prime}.\\quad u^{\\prime}\\leftarrow g^{\\prime r}</span></p>

    <p class="text-gray-300">Notice that in game <span class="math">\\mathbf{G}_{4}</span> the value <span class="math">u</span> and <span class="math">u^{\\prime}</span> are again obtained using the same value <span class="math">r</span>, whereas in game <span class="math">\\mathbf{G}_{3}</span> they are nearly independent, being subject only to <span class="math">r\\neq r^{\\prime}</span>. Therefore, using a standard reduction argument, any non-negligible difference in behavior between games <span class="math">\\mathbf{G}_{3}</span> and <span class="math">\\mathbf{G}_{4}</span> can be used to construct a PPT adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{4}]-\\Pr[T_{3}]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\ \\mathsf{AdvDDH}_{\\mathcal{G}}(k).$ (24)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, observe that in <span class="math">\\mathbf{G}_{4}</span> the encryption of the random message <span class="math">M</span> is obtained using the public key <span class="math">PK(\\mathsf{Susp})</span>: thus, game <span class="math">\\mathbf{G}_{4}</span> is exactly the game which defines the probability <span class="math">\\delta(\\mathsf{Susp})</span> i.e.,</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{4}]=\\delta(\\mathsf{Susp}).</span> (25)</p>

    <p class="text-gray-300">Combining Equations (19), (20), (21), (23), (24) and (25), we can conclude that <span class="math">\\mathcal{A}</span> has only a negligible chance to tell whether the message <span class="math">M</span> was encrypted under the public keys <span class="math">PK_{\\mathcal{A}}</span> or <span class="math">PK(\\mathsf{Susp})</span>; more precisely:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta(\\mathsf{Susp})-\\mathsf{Succ}_{PK_{\\mathcal{A}}}(\\mathsf{D})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\ \\mathsf{AdvDDH}_{\\mathcal{G}}(k).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300"><span class="math">\\Pr[T_{3}]=\\Pr[T_{2}]</span></p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prove the Lemma, we consider all the quantities that can affect event <span class="math">T_{2}</span> in game <span class="math">\\mathbf{G}_{2}</span> and event <span class="math">T_{3}</span> in game <span class="math">\\mathbf{G}_{3}</span>, and then we show that these quantities are distributed according to the same joint distribution in both games.</p>

    <p class="text-gray-300">Consider the quantity:</p>

    <p class="text-gray-300"><span class="math">\\bm{V}\\doteq(\\mathsf{Coins}_{\\mathcal{A}},\\mathsf{Coins}_{\\mathsf{D}},w,M,r,r^{\\prime},\\{\\{c_{j}^{t},r_{j}^{t}\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span> denotes the coin tosses of <span class="math">\\mathcal{A}</span>, <span class="math">\\mathsf{Coins}_{\\mathsf{D}}</span> denotes the coin tosses of <span class="math">\\mathsf{D}</span>, <span class="math">w\\doteq\\log_{g}g^{\\prime}</span>, <span class="math">M</span> is the random message encrypted within <span class="math">\\psi^{<em>}</span>, <span class="math">r</span> and <span class="math">r^{\\prime}</span> are the random values used to create <span class="math">\\psi^{</em>}</span>, and</p>

    <p class="text-gray-300"><span class="math">\\{\\{c_{j}^{t},r_{j}^{t}\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}}</span></p>

    <p class="text-gray-300">represents all the randomness used in the <span class="math">\\bar{t}</span> New-period operations that took place during the <span class="math">\\mathbf{G}_{\\mathsf{trt}}^{m}(1^{k})</span> attack game.</p>

    <p class="text-gray-300">The remaining randomness used during games <span class="math">\\mathbf{G}_{2}</span> and <span class="math">\\mathbf{G}_{3}</span> consists of the <span class="math">4v+4</span> coefficients of the polynomials <span class="math">A^{0}(\\cdot)</span>, <span class="math">B^{0}(\\cdot)</span> (chosen by the Setup algorithm in step 1. of the <span class="math">\\mathbf{G}_{\\mathsf{trt}}^{m}(1^{k})</span> attack game) and <span class="math">A^{\\prime}(\\cdot)</span>, <span class="math">B^{\\prime}(\\cdot)</span> (used in game <span class="math">\\mathbf{G}_{3}</span>). This randomness can be represented with the vector</p>

    <p class="text-gray-300"><span class="math">\\bm{\\alpha}\\doteq(a_{0},a_{1},\\ldots,a_{v},b_{0},b_{1},\\ldots,b_{v})^{T}</span></p>

    <p class="text-gray-300">which is uniformly distributed in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>, and the vector</p>

    <p class="text-gray-300"><span class="math">\\bm{\\alpha}^{\\prime}\\doteq(a_{0}^{\\prime},a_{1}^{\\prime},\\ldots,a_{v}^{\\prime},b_{0}^{\\prime},b_{1}^{\\prime},\\ldots,b_{v}^{\\prime})^{T}</span></p>

    <p class="text-gray-300">which is uniformly distributed in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>, subject to the constraints arising from imposing Equation (22).</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{T}=\\{t_{1},\\ldots,t_{m}\\}</span> be the set of traitors and set</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}_{j}\\doteq A^{\\bar{t}}(x_{t_{j}})\\quad\\mathbf{B}_{j}\\doteq B^{\\bar{t}}(x_{t_{j}}),\\ j=1,\\ldots,m.</span></p>

    <p class="text-gray-300">Notice that, since <span class="math">\\mathcal{T}\\subseteq\\mathsf{Susp}</span>, for <span class="math">j=1,\\ldots,m</span>, it holds that <span class="math">\\mathbf{A}_{j}=A^{\\prime}(x_{t_{j}})</span> and <span class="math">\\mathbf{B}_{j}=B^{\\prime}(x_{t_{j}})</span>.</p>

    <p class="text-gray-300">Consider the quantity <span class="math">\\bar{\\bm{\\beta}}\\in\\mathbb{Z}_{q}^{(v+m+1)\\times 1}</span> defined as:</p>

    <p class="text-gray-300"><span class="math">\\bar{\\bm{\\beta}}\\doteq(\\mathbf{X}_{0},\\mathbf{X}_{1},\\ldots,\\mathbf{X}_{v},\\mathbf{A}_{1},\\ldots,\\mathbf{A}_{m})^{T}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{X}_{0}\\doteq A^{0}(0)+wB^{0}(0)</span>, and <span class="math">\\mathbf{X}_{\\ell}\\doteq A^{0}(\\ell)+wB^{0}(\\ell)</span>, for <span class="math">\\ell=1,\\ldots,v</span>.</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the view of the adversary <span class="math">\\mathcal{A}</span> during the attack game <span class="math">\\mathbf{G}_{\\mathsf{trt}}^{m}(1^{k})</span> is completely determined by <span class="math">\\bm{V}</span> and <span class="math">\\bar{\\bm{\\beta}}</span>. In particular, the initial public key <span class="math">PK^{0}</span> is fixed by <span class="math">\\bar{\\bm{\\beta}}</span> and <span class="math">w</span>, and the secret keys of the traitors are determined by the choice of <span class="math">\\bar{\\bm{\\beta}}</span>, <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span> and <span class="math">w</span>.</p>

    <p class="text-gray-300">Besides the information in <span class="math">\\mathcal{A}</span>’s view, which is completely determined by the value of <span class="math">\\bm{V}</span> and <span class="math">\\bar{\\bm{\\beta}}</span>, the only other quantity affecting <span class="math">\\mathsf{D}</span>’s behavior is the ciphertext <span class="math">\\psi^{<em>}</span>. This ciphertext is computed differently in games <span class="math">\\mathbf{G}_{2}</span> and <span class="math">\\mathbf{G}_{3}</span>: for the sake of clarity, we will denote with <span class="math">[\\psi^{</em>}]_{2}</span> and <span class="math">[\\psi^{<em>}]_{3}</span> the value of such quantity in game <span class="math">\\mathbf{G}_{2}</span> and <span class="math">\\mathbf{G}_{3}</span>, respectively. We now want to show that, conditioned on all the other information in <span class="math">\\mathsf{D}</span>’s view, <span class="math">[\\psi^{</em>}]_{2}</span> and <span class="math">[\\psi^{*}]_{3}</span> are distributed according to the same distribution in the two games.</p>

    <p class="text-gray-300">In game <span class="math">\\mathbf{G}_{2}</span>, the ciphertext <span class="math">[\\psi^{<em>}]_{2}</span> sent to the decoder is completely determined by <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and by the <span class="math">v</span>-degree polynomial <span class="math">X^{\\bar{t}}(\\cdot)\\doteq rA^{\\bar{t}}(\\cdot)+wr^{\\prime}B^{\\bar{t}}(\\cdot)</span>. Similarly, in game <span class="math">\\mathbf{G}_{3}</span>, the ciphertext <span class="math">[\\psi^{</em>}]_{3}</span> is completely determined by <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and by the <span class="math">v</span>-degree polynomial <span class="math">X^{\\prime}(\\cdot)\\doteq rA^{\\prime}(\\cdot)+wr^{\\prime}B^{\\prime}(\\cdot)</span>. Moreover, <span class="math">[\\psi^{<em>}]_{2}</span> depends on <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and <span class="math">X^{\\bar{t}}(\\cdot)</span> according to the same functional dependence of <span class="math">[\\psi^{</em>}]_{3}</span> upon <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and <span class="math">X^{\\prime}(\\cdot)</span>. Therefore, to prove the Lemma, it suffices to show that, conditioning on any fixed values of <span class="math">\\bm{V}</span> and <span class="math">\\bar{\\bm{\\beta}}</span>, <span class="math">X^{\\bar{t}}(\\cdot)</span> and <span class="math">X^{\\prime}(\\cdot)</span> are distributed according to the same conditional probability distribution; namely, both are random polynomials over <span class="math">\\mathbb{Z}_{q}^{v}[x]</span>, subject to the constraint that their values at <span class="math">x_{t_{j}}</span> is <span class="math">r\\mathbf{A}_{j}+wr^{\\prime}\\mathbf{B}_{j}</span>, for <span class="math">j=1,\\ldots,m</span>.</p>

    <p class="text-gray-300">By Lagrange interpolation, <span class="math">X^{\\bar{t}}(\\cdot)</span> can be identified with its value at the points <span class="math">0</span>, <span class="math">1</span>, <span class="math">\\ldots</span>, <span class="math">v-m</span>, <span class="math">x_{t_{1}}</span>, <span class="math">\\ldots</span>, <span class="math">x_{t_{m}}</span>; define</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}_{\\ell}^{\\bar{t}}\\doteq X^{\\bar{t}}(\\ell),\\ \\ell=0,\\ldots,v-m</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}_{v-m+j}^{\\bar{t}}\\doteq X^{\\bar{t}}(x_{i_{j}}),\\ j=1,\\ldots,m.</span></p>

    <p class="text-gray-300">Similarly, we can also identify <span class="math">X^{\\prime}(\\cdot)</span> with its value at the same <span class="math">v+1</span> points; define</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}_{\\ell}^{\\prime}\\doteq X^{\\prime}(\\ell),\\ \\ell=0,\\ldots,v-m</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}_{v-m+j}^{\\prime}\\doteq X^{\\prime}(x_{t_{j}}),\\ j=1,\\ldots,m.</span></p>

    <p class="text-gray-300">As noticed above, the assumption that <span class="math">\\mathcal{T}\\subseteq\\mathsf{Susp}</span> implies that for <span class="math">j=1,\\ldots,m</span>:</p>

    <p class="text-gray-300"><span class="math">A^{\\bar{t}}(x_{t_{j}})=A^{\\prime}(x_{t_{j}})=\\mathbf{A}_{j},\\quad B^{\\bar{t}}(x_{t_{j}})=B^{\\prime}(x_{t_{j}})=\\mathbf{B}_{j}.</span></p>

    <p class="text-gray-300">Therefore, it follows that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}_{v-m+j}=\\mathbf{X}_{v-m+j}^{\\prime},\\ j=1,\\ldots,m.</span> (26)</p>

    <p class="text-gray-300">It only remains to be proven that, conditioning on fixed values of <span class="math">\\bm{V}</span> and <span class="math">\\bar{\\bm{\\beta}}</span>, the tuple <span class="math">\\mathbf{X}_{0}^{\\bar{t}}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{X}_{v-m}^{\\bar{t}}</span> and the tuple <span class="math">\\mathbf{X}_{0}^{\\prime}</span>, <span class="math">\\ldots</span>, <span class="math">\\mathbf{X}_{v-m}^{\\prime}</span> are distributed according to same joint conditional distribution. (Notice that fixing a value for <span class="math">\\bm{V}</span> and <span class="math">\\bar{\\bm{\\beta}}</span>, immediately fixes a value for the tuple <span class="math">\\mathbf{X}_{v-m+j}^{\\bar{t}}</span>, <span class="math">j=1</span>, <span class="math">\\ldots</span>, <span class="math">m</span>, which by (26) is equal to <span class="math">\\mathbf{X}_{v-m+j}^{\\prime}</span>, <span class="math">j=1</span>, <span class="math">\\ldots</span>, <span class="math">m</span>.)</p>

    <p class="text-gray-300">Recall that, in game <span class="math">\\mathbf{G}_{3}</span>, the polynomials <span class="math">A^{\\prime}(\\cdot)</span> and <span class="math">B^{\\prime}(\\cdot)</span> are chosen uniformly at random from <span class="math">\\mathbb{Z}_{q}^{v}[x]</span>, independently from anything else, but subject to the constraints in (22). Thus, the polynomial <span class="math">X^{\\prime}(\\cdot)=rA^{\\prime}(\\cdot)+wr^{\\prime}B^{\\prime}(\\cdot)</span> is also random in <span class="math">\\mathbb{Z}_{q}^{v}[x]</span>, subject to the constraint that its value at <span class="math">x_{s}</span> is</p>

    <p class="text-gray-300"><span class="math">rA^{\\bar{t}}(x_{s})+wr^{\\prime}B^{\\bar{t}}(x_{s}),\\ \\forall s\\in\\mathsf{Susp}.</span></p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Therefore, conditioning on fixed values of <span class="math">\\mathbf{V}</span> and <span class="math">\\bar{\\beta}</span>, the tuple <span class="math">\\mathbf{X}_0&#x27;, \\ldots, \\mathbf{X}_{v - m}&#x27;</span> is distributed uniformly at random in <span class="math">\\mathbb{Z}_q^{(v - m + 1)\\times 1}</span>. Hence, it suffices to show that, for <span class="math">\\ell = 0, \\ldots, v - m</span>, the conditional distribution of <span class="math">\\mathbf{X}_{\\ell}^{\\ell}</span> w.r.t. <span class="math">\\mathbf{V}</span>, <span class="math">\\bar{\\beta}</span> and <span class="math">\\mathbf{X}_0^{\\ell}, \\ldots, \\mathbf{X}_{\\ell - 1}^{\\ell}</span> is uniform over <span class="math">\\mathbb{Z}_q</span>. To this aim, fix <span class="math">\\ell \\in \\{0, \\ldots, v - m\\}</span>, and consider the following matrix equation:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} _ {\\ell} = \\mathbf {M} _ {\\ell} \\cdot \\boldsymbol {\\alpha} + \\boldsymbol {\\gamma} _ {\\ell}</span></div>

    <p class="text-gray-300">where <span class="math">\\beta_{\\ell} \\in \\mathbb{Z}_{q}^{(v + m + \\ell + 2) \\times 1}</span> is the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} _ {\\ell} \\doteq (\\mathbf {X} _ {0}, \\mathbf {X} _ {1}, \\ldots , \\mathbf {X} _ {v}, \\mathbf {A} _ {1}, \\ldots , \\mathbf {A} _ {m}, \\mathbf {X} _ {0} ^ {\\ell}, \\mathbf {X} _ {1} ^ {\\ell}, \\ldots , \\mathbf {X} _ {\\ell} ^ {\\ell}) ^ {T},</span></div>

    <p class="text-gray-300"><span class="math">\\pmb{\\gamma}_{\\ell} \\in \\mathbb{Z}_{q}^{(v + m + \\ell + 2) \\times 1}</span> is the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\gamma} _ {\\ell} \\doteq \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ D ^ {0, \\bar {t}} (x _ {t _ {1}}) \\\\ \\vdots \\\\ D ^ {0, \\bar {t}} (x _ {t _ {m}}) \\\\ r D ^ {0, \\bar {t}} (0) + w r ^ {\\prime} E ^ {0, \\bar {t}} (0) \\\\ r D ^ {0, \\bar {t}} (1) + w r ^ {\\prime} E ^ {0, \\bar {t}} (1) \\\\ \\vdots \\\\ r D ^ {0, \\bar {t}} (\\ell) + w r ^ {\\prime} E ^ {0, \\bar {t}} (\\ell) \\end{array} \\right)</span></div>

    <p class="text-gray-300">and <span class="math">\\mathbf{M}_{\\ell} \\in \\mathbb{Z}_q^{(v + m + \\ell + 2) \\times (2v + 2)}</span> is the matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {M} _ {\\ell} \\doteq \\left( \\begin{array}{c c c c c c c c} 1 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 &amp;amp; w &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; 1 &amp;amp; w &amp;amp; w &amp;amp; \\ldots &amp;amp; w \\\\ &amp;amp; &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ 1 &amp;amp; v &amp;amp; \\ldots &amp;amp; v ^ {v} &amp;amp; w &amp;amp; w v &amp;amp; \\ldots &amp;amp; w v ^ {v} \\\\ 1 &amp;amp; x _ {t _ {1}} &amp;amp; \\ldots &amp;amp; x _ {t _ {1}} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ &amp;amp; &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ 1 &amp;amp; x _ {t _ {m}} &amp;amp; \\ldots &amp;amp; x _ {t _ {m}} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ r &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 &amp;amp; w r ^ {\\prime} &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ r &amp;amp; r &amp;amp; \\ldots &amp;amp; r &amp;amp; w r ^ {\\prime} &amp;amp; w r ^ {\\prime} &amp;amp; \\ldots &amp;amp; w r ^ {\\prime} \\\\ &amp;amp; &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ r &amp;amp; r \\ell &amp;amp; \\ldots &amp;amp; r \\ell^ {v} &amp;amp; w r ^ {\\prime} &amp;amp; w r ^ {\\prime} \\ell &amp;amp; \\ldots &amp;amp; w r ^ {\\prime} \\ell^ {v} \\end{array} \\right)</span></div>

    <p class="text-gray-300">By inspection, it is possible to see that the rows of matrix <span class="math">\\mathbf{M}_{\\ell}</span> are linearly independent, provided that <span class="math">r \\neq r&#x27;</span> and <span class="math">w \\neq 0</span>: thus, the rank of <span class="math">\\mathbf{M}_{\\ell}</span> is <span class="math">v + m + \\ell + 2</span>. As soon as we fix <span class="math">\\mathbf{V}</span>, vector <span class="math">\\gamma_{\\ell}</span> and the first <span class="math">v + 1</span> rows of <span class="math">\\mathbf{M}_{\\ell}</span> are determined, but <span class="math">\\alpha</span> is still distributed uniformly and independently at random in <span class="math">\\mathbb{Z}_q^{(2v + 2)\\times 1}</span>. Similarly to the proof of Lemma 3, it is also possible to show that fixing the first <span class="math">v + j</span> entries of <span class="math">\\bar{\\beta}</span> determines the <span class="math">(v + j + 1)</span>th row of <span class="math">\\mathbf{M}_{\\ell}</span>, for <span class="math">j = 1,\\dots,m</span>; and that moreover, fixing the first <span class="math">v + m + 1</span> entries of <span class="math">\\bar{\\beta}</span> determines all the remaining rows of <span class="math">\\mathbf{M}_{\\ell}</span>.</p>

    <p class="text-gray-300">Hence, by Lemma 1, we can conclude that the conditional distribution of <span class="math">\\mathbf{X}_{\\ell}^{\\ell}</span> w.r.t. <span class="math">(\\mathbf{V}, \\bar{\\beta}, \\mathbf{X}_0^\\ell, \\ldots, \\mathbf{X}_{\\ell-1}^\\ell)</span> is uniform over <span class="math">\\mathbb{Z}_q</span>, <span class="math">\\forall \\ell \\in \\{0, \\dots, v - m\\}</span>. In other words, the value of <span class="math">X^{\\bar{t}}(\\cdot)</span> at any point is uniformly random, subject to the constraint</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {X} ^ {\\bar {t}} (x _ {t _ {j}}) = r \\mathbf {A} _ {j} + w r ^ {\\prime} \\mathbf {B} _ {j}, \\forall t _ {j} \\in \\mathcal {T}.</span></div>

    <p class="text-gray-300">Thus, <span class="math">(\\mathbf{V}, \\bar{\\beta}, X^{\\bar{t}}(\\cdot)))</span> has the same joint distribution as <span class="math">(\\mathbf{V}, \\bar{\\beta}, X&#x27;(\\cdot))</span>, completing the proof.</p>

    <p class="text-gray-300">We now move on to prove the soundness of the BBC algorithm, showing that it can accuse an innocent user with at most negligible probability. Informally this is true because, under the DDH assumption it is impossible to notice if the values <span class="math">A^{\\prime}(x_{i})</span> and <span class="math">B^{\\prime}(x_{i})</span> (which are unknown to the adversary since <span class="math">i</span> is assumed to be honest), were replaced by random noise <span class="math">A^{\\prime\\prime}(x_{i})</span> and <span class="math">B^{\\prime\\prime}(x_{i})</span>. Thus, the behavior of the decoder will be the same regardless of whether <span class="math">PK(I)</span> or <span class="math">PK(I\\setminus\\{i\\})</span> was used to encrypt the ciphertext. Since our algorithm only accuses a user <span class="math">i</span> when a sensible change occurs in the decryption capability of the pirate decoder, it follows that an innocent user will be blamed with at most negligible probability.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Under the DDH assumption, if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq v<span class="math"> and </span>i\\not\\in\\mathcal{T}<span class="math">, then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta(I)-\\delta(I\\setminus\\{i\\})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Proceeding as in the proof of Theorem 2, we define a sequence of “indistinguishable” games <span class="math">\\mathbf{G}_{0}</span>, <span class="math">\\mathbf{G}_{1}</span>, …: for each game <span class="math">\\mathbf{G}_{j}</span>, let <span class="math">T_{j}</span> be the event that decoder <span class="math">\\mathsf{D}</span> correctly decrypts the challenge sent by the BBC algorithm in game <span class="math">\\mathbf{G}_{j}</span>.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{0}</span>: This game describes the experiment which defines the value of <span class="math">\\delta(I)</span>. In this game, the decoder <span class="math">\\mathsf{D}</span> is fed with ciphertexts obtained encrypting random messages under the fake public key <span class="math">PK(I)</span>, defined as:</p>

    <p class="text-gray-300"><span class="math">PK(I)=\\langle g,g^{\\prime},g^{A^{\\prime}(0)}g^{\\prime B^{\\prime}(0)},\\langle z_{\\ell},g^{A^{\\prime}(z_{\\ell})}g^{\\prime B^{\\prime}(z_{\\ell})}\\rangle_{\\ell=1}^{v}\\rangle</span></p>

    <p class="text-gray-300">where <span class="math">A^{\\prime}(\\cdot)</span> and <span class="math">B^{\\prime}(\\cdot)</span> are random <span class="math">v</span>-degree polynomials subject to:</p>

    <p class="text-gray-300"><span class="math">A^{\\prime}(x_{s})=A^{\\ell}(x_{s})\\quad B^{\\prime}(x_{s})=B^{\\ell}(x_{s}),\\;\\forall s\\in I.</span> (27)</p>

    <p class="text-gray-300">More precisely, the BBC algorithm chooses a random message <span class="math">M</span> and encrypts it as follows:</p>

    <p class="text-gray-300"><span class="math">E1.</span> <span class="math">r\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}</span> <span class="math">E2.</span> <span class="math">u\\leftarrow g^{r}</span> <span class="math">E3.</span> <span class="math">u^{\\prime}\\leftarrow g^{\\prime r}</span> <span class="math">E4.</span> <span class="math">u^{\\prime\\prime}\\leftarrow M\\cdot g^{A^{\\prime}(0)r}g^{\\prime B^{\\prime}(0)r}</span> <span class="math">E5.</span> <span class="math">u_{\\ell}\\leftarrow g^{A^{\\prime}(z_{\\ell})r}g^{\\prime B^{\\prime}(z_{\\ell})r},\\quad\\ell=1,\\dots,v</span> <span class="math">E6.</span> <span class="math">\\psi^{*}\\leftarrow\\langle u,u^{\\prime},u^{\\prime\\prime},\\langle z_{1},u_{1}\\rangle,\\dots,\\langle z_{v},u_{v}\\rangle\\rangle</span></p>

    <p class="text-gray-300">By definition, we have that:</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{0}]=\\delta(I).</span> (28)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}</span>: Game <span class="math">\\mathbf{G}_{1}</span> is identical to game <span class="math">\\mathbf{G}_{0}</span>, except that in game <span class="math">\\mathbf{G}_{1}</span> steps <span class="math">E4</span> and <span class="math">E5</span> are substituted with:</p>

    <p class="text-gray-300"><span class="math">E4^{\\prime}.</span> <span class="math">u^{\\prime\\prime}\\leftarrow M\\cdot u^{A^{\\prime}(0)}u^{\\prime B^{\\prime}(0)}</span> <span class="math">E5^{\\prime}.</span> <span class="math">u_{\\ell}\\leftarrow u^{A^{\\prime}(z_{\\ell})}u^{\\prime B^{\\prime}(z_{\\ell})},\\quad\\ell=1,\\dots,v</span></p>

    <p class="text-gray-300">Notice that the point of these changes is just to make explicit any functional dependency of <span class="math">\\psi^{*}</span> on the quantities <span class="math">u</span> and <span class="math">u^{\\prime}</span>. Since we just made a conceptual change, it clearly holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{1}]=\\Pr[T_{0}].</span> (29)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{2}</span>: Game <span class="math">\\mathbf{G}_{2}</span> is identical to game <span class="math">\\mathbf{G}_{1}</span>, except that in game <span class="math">\\mathbf{G}_{2}</span> steps <span class="math">E1</span> and <span class="math">E3</span> are substituted with:</p>

    <p class="text-gray-300"><span class="math">E1^{\\prime}.</span> <span class="math">r\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q};\\quad r^{\\prime}\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}\\setminus\\{r\\}</span> <span class="math">E3^{\\prime}.</span> <span class="math">u^{\\prime}\\leftarrow g^{\\prime r^{\\prime}}</span></p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Notice that while in game <span class="math">\\mathbf{G}_{1}</span> the value <span class="math">u</span> and <span class="math">u^{\\prime}</span> are obtained using the same value <span class="math">r</span>, in game <span class="math">\\mathbf{G}_{2}</span> they are nearly independent, being subject only to <span class="math">r\\neq r^{\\prime}</span>. Therefore, using a standard reduction argument, any non-negligible difference in behavior between games <span class="math">\\mathbf{G}_{1}</span> and <span class="math">\\mathbf{G}_{2}</span> can be used to construct a PPT adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{2}]-\\Pr[T_{1}]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\texttt{ AdvDDH}_{\\mathcal{G}}(k).$ (30)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{3}</span>: To turn game <span class="math">\\mathbf{G}_{2}</span> into game <span class="math">\\mathbf{G}_{3}</span>, we consider the set <span class="math">I\\setminus\\{i\\}</span> and construct the public key <span class="math">PK(I\\setminus\\{i\\})</span>: two new random <span class="math">v</span>-degree polynomials <span class="math">A^{\\prime\\prime}(\\cdot)</span> and <span class="math">B^{\\prime\\prime}(\\cdot)</span> are chosen such that</p>

    <p class="text-gray-300"><span class="math">A^{\\prime\\prime}(x_{s})=A^{\\bar{t}}(x_{s})\\quad B^{\\prime\\prime}(x_{s})=B^{\\bar{t}}(x_{s}),\\;\\forall s\\in I\\setminus\\{i\\}</span> (31)</p>

    <p class="text-gray-300">and <span class="math">PK(I\\setminus\\{i\\})</span> is set to be:</p>

    <p class="text-gray-300"><span class="math">PK(I\\setminus\\{i\\})\\doteq\\langle g,g^{\\prime},g^{A^{\\prime\\prime}(0)}g^{\\prime B^{\\prime\\prime}(0)},\\langle z_{\\ell},g^{A^{\\prime\\prime}(z_{\\ell})}g^{\\prime B^{\\prime\\prime}(z_{\\ell})}\\rangle_{\\ell=1}^{v}\\rangle.</span></p>

    <p class="text-gray-300">Notice that, for <span class="math">s\\in I\\setminus\\{i\\}</span>, it holds that <span class="math">A^{\\prime\\prime}(x_{s})=A^{\\prime}(x_{s})</span> and <span class="math">B^{\\prime\\prime}(x_{s})=B^{\\prime}(x_{s})</span>.</p>

    <p class="text-gray-300">Finally, we change steps <span class="math">E4^{\\prime}</span> and <span class="math">E5^{\\prime}</span> of the encryption algorithm as follows:</p>

    <p class="text-gray-300"><span class="math">E4^{\\prime\\prime}.\\quad u^{\\prime\\prime}\\leftarrow M\\cdot u^{A^{\\prime\\prime}(0)}u^{\\prime B^{\\prime\\prime}(0)}</span> <span class="math">E5^{\\prime\\prime}.\\quad u_{\\ell}\\leftarrow u^{A^{\\prime\\prime}(z_{\\ell})}u^{\\prime B^{\\prime\\prime}(z_{\\ell})},\\quad\\ell=1,\\ldots,v</span></p>

    <p class="text-gray-300">Using the technique described in Section 5.2, in Lemma 5 below, we show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{3}]=\\Pr[T_{2}].</span> (32)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{4}</span>: In game <span class="math">\\mathbf{G}_{4}</span>, we “undo” the changes of game <span class="math">\\mathbf{G}_{2}</span>, restoring lines <span class="math">E1</span> and <span class="math">E3</span> of the encryption oracle to their original values:</p>

    <p class="text-gray-300"><span class="math">E1^{\\prime\\prime}.\\quad r\\stackrel{{\\scriptstyle r}}{{\\leftarrow}}\\mathbb{Z}_{q}</span> <span class="math">E3^{\\prime\\prime}.\\quad u^{\\prime}\\leftarrow g^{\\prime r}</span></p>

    <p class="text-gray-300">Notice that in game <span class="math">\\mathbf{G}_{4}</span> the value <span class="math">u</span> and <span class="math">u^{\\prime}</span> are again obtained using the same value <span class="math">r</span>, whereas in game <span class="math">\\mathbf{G}_{3}</span> they are nearly independent, being subject only to <span class="math">r\\neq r^{\\prime}</span>. Therefore, using a standard reduction argument, any non-negligible difference in behavior between games <span class="math">\\mathbf{G}_{3}</span> and <span class="math">\\mathbf{G}_{4}</span> can be used to construct a PPT adversary able to distinguish Diffie-Hellman tuples from totally random tuples with non-negligible advantage. Hence,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[T_{4}]-\\Pr[T_{3}]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\texttt{ AdvDDH}_{\\mathcal{G}}(k).$ (33)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In game <span class="math">\\mathbf{G}_{4}</span>, the encryption of the random message <span class="math">M</span> is obtained using the public key <span class="math">PK(I\\setminus\\{i\\})</span>: thus, game <span class="math">\\mathbf{G}_{4}</span> is exactly the game defining <span class="math">\\delta(I\\setminus\\{i\\})</span> i.e.,</p>

    <p class="text-gray-300"><span class="math">\\Pr[T_{4}]=\\delta(I\\setminus\\{i\\}).</span> (34)</p>

    <p class="text-gray-300">By Equations (28), (29), (30), (32), (33) and (34), we can conclude that the adversary has only a negligible chance to tell whether the message <span class="math">M</span> was encrypted under <span class="math">PK(I)</span> or <span class="math">PK(I\\setminus\\{i\\})</span>; more precisely:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta(I)-\\delta(I\\setminus\\{i\\})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\texttt{ AdvDDH}_{\\mathcal{G}}(k).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300"><span class="math">\\Pr[T_{3}]=\\Pr[T_{2}]</span></p>

    <p class="text-gray-300">roof.</p>

    <p class="text-gray-300">To prove the Lemma, we consider all the quantities that can affect event <span class="math">T_{2}</span> in game <span class="math">\\mathbf{G}_{2}</span> and event <span class="math">T_{3}</span> in game <span class="math">\\mathbf{G}_{3}</span>, and then we show that these quantities are distributed according to the same joint distribution in both games.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\bar{m}\\doteq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}\\cap I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\mathcal{T}=\\{t_{1},\\ldots,t_{m}\\}<span class="math"> is the set of traitors; w.l.o.g. assume that </span>\\mathcal{T}\\cap I=\\{t_{1},\\ldots,t_{\\bar{m}}\\}$. Also, set</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{A}_{j}\\doteq A^{\\bar{t}}(x_{t_{j}})\\quad\\mathbf{B}_{j}\\doteq B^{\\bar{t}}(x_{t_{j}}),\\ j=1,\\ldots,m.</span></p>

    <p class="text-gray-300">Notice that, since <span class="math">i\\not\\in\\mathcal{T}</span>, for <span class="math">1\\leq j\\leq\\bar{m}</span> it also holds that:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}_{j}=A^{\\prime}(x_{t_{j}})=A^{\\prime\\prime}(x_{t_{j}})\\quad\\mathbf{B}_{j}=B^{\\prime}(x_{t_{j}})=B^{\\prime\\prime}(x_{t_{j}}).</span></p>

    <p class="text-gray-300">Consider the quantity:</p>

    <p class="text-gray-300"><span class="math">\\bm{V}\\doteq(\\mathsf{Coins}_{\\mathcal{A}},\\mathsf{Coins}_{\\mathsf{D}},w,M,r,r^{\\prime},\\{\\{c_{j}^{t},r_{j}^{t}\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span> denotes the coin tosses of <span class="math">\\mathcal{A}</span>, <span class="math">\\mathsf{Coins}_{\\mathsf{D}}</span> denotes the coin tosses of <span class="math">\\mathsf{D}</span>, <span class="math">w\\doteq\\log_{g}g^{\\prime}</span>, <span class="math">\\mathbf{X}_{\\ell}\\doteq(A^{0}(\\ell)+B^{0}(\\ell))</span> for <span class="math">\\ell=0,\\ldots,v</span>, <span class="math">M</span> is the random message encrypted within <span class="math">\\psi^{<em>}</span>, <span class="math">r</span> and <span class="math">r^{\\prime}</span> are the random values used to create <span class="math">\\psi^{</em>}</span>, and</p>

    <p class="text-gray-300"><span class="math">\\{\\{c_{j}^{t},r_{j}^{t}\\}_{j=1}^{2v+2}\\}_{t=1}^{\\bar{t}}</span></p>

    <p class="text-gray-300">represents all the randomness used in the <span class="math">\\bar{t}</span> New-period operations that took place during the attack game <span class="math">\\mathbf{G}_{\\mathsf{trt}}^{m}(1^{k})</span>.</p>

    <p class="text-gray-300">The remaining randomness used during games <span class="math">\\mathbf{G}_{2}</span> and <span class="math">\\mathbf{G}_{3}</span> consists of the <span class="math">6v+6</span> coefficients of the polynomials <span class="math">A^{0}(\\cdot)</span>, <span class="math">B^{0}(\\cdot)</span> (chosen by the Setup algorithm in step 1. of the <span class="math">\\mathbf{G}_{\\mathsf{trt}}^{m}(1^{k})</span> attack game), <span class="math">A^{\\prime}(\\cdot)</span>, <span class="math">B^{\\prime}(\\cdot)</span> (used in game <span class="math">\\mathbf{G}_{2}</span>), and <span class="math">A^{\\prime\\prime}(\\cdot)</span>, <span class="math">B^{\\prime\\prime}(\\cdot)</span> (used in game <span class="math">\\mathbf{G}_{3}</span>). This randomness can be represented with the vector</p>

    <p class="text-gray-300"><span class="math">\\bm{\\alpha}\\doteq(a_{0},a_{1},\\ldots,a_{v},b_{0},b_{1},\\ldots,b_{v})^{T}</span></p>

    <p class="text-gray-300">which is uniformly distributed in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>, the vector</p>

    <p class="text-gray-300"><span class="math">\\bm{\\alpha}^{\\prime}\\doteq(a_{0}^{\\prime},a_{1}^{\\prime},\\ldots,a_{v}^{\\prime},b_{0}^{\\prime},b_{1}^{\\prime},\\ldots,b_{v}^{\\prime})^{T}</span></p>

    <p class="text-gray-300">which is uniformly distributed in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>, subject to the constraints arising from imposing Equation (27), and the vector</p>

    <p class="text-gray-300"><span class="math">\\bm{\\alpha}^{\\prime\\prime}\\doteq(a_{0}^{\\prime\\prime},a_{1}^{\\prime\\prime},\\ldots,a_{v}^{\\prime\\prime},b_{0}^{\\prime\\prime},b_{1}^{\\prime\\prime},\\ldots,b_{v}^{\\prime\\prime})^{T}</span></p>

    <p class="text-gray-300">which is uniformly distributed in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>, subject to the constraints arising from imposing Equation (31).</p>

    <p class="text-gray-300">Consider the quantity <span class="math">\\bar{\\bm{\\beta}}\\in\\mathbb{Z}_{q}^{(v+\\bar{m}+1)\\times 1}</span> defined as:</p>

    <p class="text-gray-300"><span class="math">\\bar{\\bm{\\beta}}\\doteq(\\mathbf{X}_{0},\\mathbf{X}_{1},\\ldots,\\mathbf{X}_{v},\\mathbf{A}_{1},\\ldots,\\mathbf{A}_{\\bar{m}})^{T}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{X}_{0}\\doteq A^{0}(0)+wB^{0}(0)</span>, and <span class="math">\\mathbf{X}_{\\ell}\\doteq A^{0}(\\ell)+wB^{0}(\\ell)</span>, for <span class="math">\\ell=1,\\ldots,v</span>.</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the view of the adversary <span class="math">\\mathcal{A}</span> during the attack game <span class="math">\\mathbf{G}_{\\mathsf{trt}}^{m}(1^{k})</span> is completely determined by <span class="math">\\bm{V}</span> and <span class="math">\\bar{\\bm{\\beta}}</span>. In particular, the initial public key <span class="math">PK^{0}</span> is fixed by <span class="math">\\bm{V}</span>, and the secret keys of the traitors are determined by the choice of <span class="math">\\bar{\\bm{\\beta}}</span>, <span class="math">\\mathsf{Coins}_{\\mathcal{A}}</span> and <span class="math">w</span>.</p>

    <p class="text-gray-300">Besides the information in <span class="math">\\mathcal{A}</span>’s view, the only other quantity affecting <span class="math">\\mathsf{D}</span>’s behavior is the ciphertext <span class="math">\\psi^{<em>}</span>. This ciphertext is computed differently in games <span class="math">\\mathbf{G}_{2}</span> and <span class="math">\\mathbf{G}_{3}</span>: for the sake of clarity, we will denote with <span class="math">[\\psi^{</em>}]_{2}</span> and <span class="math">[\\psi^{<em>}]_{3}</span> the value of such quantity in game <span class="math">\\mathbf{G}_{2}</span> and <span class="math">\\mathbf{G}_{3}</span>, respectively. We now want to show that, conditioned on all the other information in <span class="math">\\mathsf{D}</span>’s view, <span class="math">[\\psi^{</em>}]_{2}</span> and <span class="math">[\\psi^{*}]_{3}</span> are distributed according to the same distribution in the two games.</p>

    <p class="text-gray-300">In game <span class="math">\\mathbf{G}_{2}</span>, the ciphertext <span class="math">[\\psi^{<em>}]_{2}</span> sent to the decoder is completely determined by <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and by the <span class="math">v</span>-degree polynomial <span class="math">X^{\\prime}\\doteq rA^{\\prime}(\\cdot)+wr^{\\prime}B^{\\prime}(\\cdot)</span>. Similarly, in game <span class="math">\\mathbf{G}_{3}</span>, the ciphertext <span class="math">[\\psi^{</em>}]_{3}</span> is completely determined by <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and by the <span class="math">v</span>-degree polynomial <span class="math">X^{\\prime\\prime}(\\cdot)\\doteq rA^{\\prime\\prime}(\\cdot)+wr^{\\prime}B^{\\prime\\prime}(\\cdot)</span>. Moreover, <span class="math">[\\psi^{<em>}]_{2}</span> depends on <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and <span class="math">X^{\\prime}(\\cdot)</span> according to the same functional dependence of <span class="math">[\\psi^{</em>}]_{3}</span> upon <span class="math">\\bm{V}</span>, <span class="math">\\bar{\\bm{\\beta}}</span> and <span class="math">X^{\\prime\\prime}(\\cdot)</span>. Therefore, to prove the</p>

    <p class="text-gray-300">Lemma, it suffices to show that, conditioning on any fixed values of <span class="math">\\mathbf{V}</span> and <span class="math">\\bar{\\beta}</span>, <span class="math">X&#x27;(\\cdot)</span> and <span class="math">X&#x27;&#x27;(\\cdot)</span> are distributed according to the same conditional probability distribution.</p>

    <p class="text-gray-300">Recall that, in game <span class="math">\\mathbf{G}_2</span>, the polynomials <span class="math">A&#x27;(\\cdot)</span> and <span class="math">B&#x27;(\\cdot)</span> are chosen uniformly at random from <span class="math">\\mathbb{Z}_q^v[x]</span>, independently from anything else, but subject to the constraints in (27). Thus, the polynomial <span class="math">X&#x27;(\\cdot) = rA&#x27;(\\cdot) + wr&#x27;B&#x27;(\\cdot)</span> is also random in <span class="math">\\mathbb{Z}_q^v[x]</span>, subject to the constraint that its value at <span class="math">x_s</span> is</p>

    <div class="my-4 text-center"><span class="math-block">r A ^ {\\bar {t}} (x _ {s}) + w r ^ {\\prime} B ^ {\\bar {t}} (x _ {s}), \\forall s \\in I.</span></div>

    <p class="text-gray-300">Similarly, in game <span class="math">\\mathbf{G}_3</span>, the polynomials <span class="math">A&#x27;&#x27;(\\cdot)</span> and <span class="math">B&#x27;&#x27;(\\cdot)</span> are chosen uniformly at random from <span class="math">\\mathbb{Z}_q^v[x]</span>, independently from anything else, but subject to the constraints in (31). Thus, the polynomial <span class="math">X&#x27;&#x27;(\\cdot) = rA&#x27;&#x27;(\\cdot) + wr&#x27;B&#x27;&#x27;(\\cdot)</span> is also random in <span class="math">\\mathbb{Z}_q^v[x]</span>, subject to the constraint that its value at <span class="math">x_s</span> is</p>

    <div class="my-4 text-center"><span class="math-block">r A ^ {\\bar {t}} (x _ {s}) + w r ^ {\\prime} B ^ {\\bar {t}} (x _ {s}), \\forall s \\in I \\setminus \\{i \\}.</span></div>

    <p class="text-gray-300">In other words, the distributions of <span class="math">X&#x27;(\\cdot)</span> and <span class="math">X&#x27;&#x27;(\\cdot)</span> only differ in that the value of <span class="math">X&#x27;(\\cdot)</span> at <span class="math">x_i</span> is fixed to be</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {X} _ {i} ^ {\\prime} \\doteq r A ^ {\\bar {t}} (x _ {i}) + w r ^ {\\prime} B ^ {\\bar {t}} (x _ {i})</span></div>

    <p class="text-gray-300">whereas the value of <span class="math">X&#x27;&#x27;(\\cdot)</span> at <span class="math">x_i</span> is a random element in <span class="math">\\mathbb{Z}_q</span>. Thus, to prove that <span class="math">X&#x27;(\\cdot)</span> and <span class="math">X&#x27;&#x27;(\\cdot)</span> have the same conditional probability distribution w.r.t. <span class="math">\\mathbf{V}</span> and <span class="math">\\bar{\\beta}</span>, it suffices to show that, conditioning on any fixed values of <span class="math">\\mathbf{V}</span> and <span class="math">\\bar{\\beta}</span>, the value <span class="math">\\mathbf{X}_i&#x27;</span> is distributed uniformly at random in <span class="math">\\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">To this aim, consider the following matrix equation:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} = \\mathbf {M} \\cdot \\boldsymbol {\\alpha} + \\boldsymbol {\\gamma}</span></div>

    <p class="text-gray-300">where <span class="math">\\beta \\in \\mathbb{Z}_q^{(v + \\bar{m} +2)\\times 1}</span> is the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} \\doteq (\\mathbf {X} _ {0}, \\mathbf {X} _ {1}, \\dots , \\mathbf {X} _ {v}, \\mathbf {A} _ {1}, \\dots , \\mathbf {A} _ {\\bar {m}}, \\mathbf {X} _ {i} ^ {\\prime}) ^ {T},</span></div>

    <p class="text-gray-300"><span class="math">\\pmb{\\gamma} \\in \\mathbb{Z}_q^{(v + \\bar{m} + 2) \\times 1}</span> is the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\gamma} \\doteq \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ D ^ {0, \\bar {t}} (x _ {t _ {1}}) \\\\ \\vdots \\\\ D ^ {0, \\bar {t}} (x _ {t _ {\\bar {m}}}) \\\\ r D ^ {0, \\bar {t}} (x _ {i}) + w r ^ {\\prime} E ^ {0, \\bar {t}} (x _ {i}) \\end{array} \\right)</span></div>

    <p class="text-gray-300">and <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(v + \\bar{m} + 2) \\times (2v + 2)}</span> is the matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {M} \\doteq \\left( \\begin{array}{c c c c c c c c} 1 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 &amp;amp; w &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; 1 &amp;amp; w &amp;amp; w &amp;amp; \\ldots &amp;amp; w \\\\ &amp;amp; &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots &amp;amp; \\\\ 1 &amp;amp; v &amp;amp; \\ldots &amp;amp; v ^ {v} &amp;amp; w &amp;amp; w v &amp;amp; \\ldots &amp;amp; w v ^ {v} \\\\ 1 &amp;amp; x _ {t _ {1}} &amp;amp; \\ldots &amp;amp; x _ {t _ {1}} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ &amp;amp; &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots &amp;amp; \\\\ 1 &amp;amp; x _ {t _ {m}} &amp;amp; \\ldots &amp;amp; x _ {t _ {\\bar {m}}} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ r &amp;amp; r x _ {i} &amp;amp; \\ldots &amp;amp; r x _ {i} ^ {v} &amp;amp; w r ^ {\\prime} &amp;amp; w r ^ {\\prime} x _ {i} &amp;amp; \\ldots &amp;amp; w r ^ {\\prime} x _ {i} ^ {v} \\end{array} \\right)</span></div>

    <p class="text-gray-300">By inspection, it is possible to see that the rows of matrix <span class="math">\\mathbf{M}</span> are linearly independent, provided that <span class="math">r \\neq r&#x27;</span> and <span class="math">w \\neq 0</span>: thus, the rank of <span class="math">\\mathbf{M}</span> is <span class="math">v + \\bar{m} + 2</span>. As soon as we fix <span class="math">\\mathbf{V}</span>, vector <span class="math">\\gamma</span> and the first <span class="math">v + 1</span> rows of</p>

    <p class="text-gray-300">31</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}</span> are determined, but <span class="math">\\boldsymbol{\\alpha}</span> is still distributed uniformly and independently at random in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>. Similarly to the proof of Lemma 3, it is also possible to show that fixing the first <span class="math">v+j</span> entries of <span class="math">\\boldsymbol{\\bar{\\beta}}</span> determines the <span class="math">(v+j+1)</span>th row of <span class="math">\\mathbf{M}</span>, for <span class="math">j=1,\\ldots,\\bar{m}</span>; and that moreover, fixing the first <span class="math">v+\\bar{m}+1</span> entries of <span class="math">\\boldsymbol{\\bar{\\beta}}</span> determines all the remaining rows of <span class="math">\\mathbf{M}</span>.</p>

    <p class="text-gray-300">Hence, by Lemma 1, we can conclude that the conditional distribution of <span class="math">\\mathbf{X}_{i}^{\\prime}</span> w.r.t. <span class="math">\\boldsymbol{V}</span> and <span class="math">\\boldsymbol{\\bar{\\beta}}</span> is uniform over <span class="math">\\mathbb{Z}_{q}</span>. In other words, conditioning on the information seen by the adversary before receiving the challenge <span class="math">\\psi^{*}</span>, the value of <span class="math">X^{\\prime}(\\cdot)</span> at <span class="math">x_{i}</span> looks random over <span class="math">\\mathbb{Z}_{q}</span>. It follows that <span class="math">(\\boldsymbol{V},\\boldsymbol{\\bar{\\beta}},X^{\\prime}(\\cdot))</span> has the same joint distribution as <span class="math">(\\boldsymbol{V}</span>, <span class="math">\\boldsymbol{\\bar{\\beta}}</span>, <span class="math">X^{\\prime\\prime}(\\cdot))</span>, completing the proof. ∎</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">6.3 Non-Black-Box Tracing</h3>

    <p class="text-gray-300">In Section 6.3 we describe a non-black-box tracing algorithm which builds on the results of <em>[3, 19]</em>, but it is tailored to our family of representations. Then, in Section 6.3, we analyze its security properties in the formal model for traceability of Section 6.1, under a non-black-box assumption, given below as Assumption 3. Before that, however, we develop some notation.</p>

    <p class="text-gray-300">Notation. Recall that in the scheme of Section 4, the secret key of user <span class="math">x_{i}</span> consists of two points <span class="math">A(x_{i}),B(x_{i})</span>, which can be combined with the system’s public key to obtain two leap vectors to be used in the decryption algorithm. More precisely, given the current public key</p>

    <p class="text-gray-300"><span class="math">PK\\doteq\\langle g,g^{\\prime},y,\\langle z_{1},h_{1}\\rangle,\\ldots,\\langle z_{v},h_{v}\\rangle\\rangle,</span></p>

    <p class="text-gray-300">it is possible to construct (by Definition 6) two leap vectors</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\nu}_{A,i}\\doteq\\boldsymbol{\\nu}_{z_{1},\\ldots,z_{v}}^{x_{i},A}\\quad\\boldsymbol{\\nu}_{B,i}\\doteq\\boldsymbol{\\nu}_{z_{1},\\ldots,z_{v}}^{x_{i},B}</span></p>

    <p class="text-gray-300">where <span class="math">(A(\\cdot),B(\\cdot))</span> is the master secret key corresponding to the current public key <span class="math">PK</span>. By Equations (2) and (4), <span class="math">\\boldsymbol{\\nu}_{A,i}</span> and <span class="math">\\boldsymbol{\\nu}_{B,i}</span> agree on the last <span class="math">v</span> components; thus, under the current public key <span class="math">PK</span>, user <span class="math">x_{i}</span>’s secret key can be compactly rewritten as</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\delta}_{i}</span> <span class="math">\\doteq\\langle(\\nu_{A,i})_{0},(\\nu_{B,i})_{0},\\boldsymbol{\\delta}_{i}^{\\prime}\\rangle</span> <span class="math">\\doteq\\langle\\lambda_{0}^{(i)}A(x_{i}),\\lambda_{0}^{(i)}B(x_{i}),\\langle\\lambda_{1}^{(i)},\\ldots,\\lambda_{v}^{(i)}\\rangle\\rangle,</span></p>

    <p class="text-gray-300">where <span class="math">\\lambda_{0}^{(i)}</span>, <span class="math">\\lambda_{1}^{(i)},\\ldots,\\lambda_{v}^{(i)}</span> are the Lagrange coefficients defined in Equations (3) and (4); recall that, for notational convenience, we use superscript <span class="math">(i)</span> to make explicit that a given set of Lagrange coefficients is relative to user <span class="math">x_{i}</span>.</p>

    <p class="text-gray-300">Notice that such vector <span class="math">\\boldsymbol{\\delta}_{i}</span> is a representation of <span class="math">y</span> w.r.t. <span class="math">g</span>, <span class="math">g^{\\prime}</span>, <span class="math">h_{1}</span>, <span class="math">\\ldots</span>, <span class="math">h_{v}</span>; for short, when this is the case, in the following we will just say that <span class="math">\\boldsymbol{\\delta}_{i}</span> is a valid representation of the public key <span class="math">PK</span>. Also notice that <em>any</em> such valid representation <span class="math">\\boldsymbol{\\delta}</span> of the current public key <span class="math">PK</span> would work for decrypting messages encrypted with <span class="math">PK</span>; for a generic valid representation</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\delta}\\doteq\\langle\\gamma_{a},\\gamma_{b},\\gamma_{1},\\ldots,\\gamma_{v}\\rangle,</span></p>

    <p class="text-gray-300">we will denote with <span class="math">\\boldsymbol{\\delta}^{\\prime}</span> its last <span class="math">v</span> entries:</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\delta}^{\\prime}\\doteq\\langle\\gamma_{1},\\ldots,\\gamma_{v}\\rangle.</span></p>

    <p class="text-gray-300">In the non-black-box model, the tracing algorithm is assumed to be able of inspecting the content of a successful pirate decoder, and to extract the secret key hidden within it. More precisely, in designing and analyzing our non-black-box tracing algorithm, we make the following assumption:</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Assumption 3 (Non-Black-Box Assumption).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be any probabilistic, polynomial-time adversary, and let <span class="math">\\langle\\mathsf{D}</span>, <span class="math">PK_{\\mathcal{A}}</span>, <span class="math">MSK_{\\mathcal{A}}</span>, <span class="math">\\mathcal{T}\\rangle</span> be the output resulting from the adversary playing the traceability attack game <span class="math">\\boldsymbol{G}_{\\text{trt}}^{m}(1^{k})</span> with the challenger. If <span class="math">\\mathsf{D}</span> can correctly decrypt random ciphertexts encrypted using <span class="math">PK_{\\mathcal{A}}</span> (in other words, <span class="math">\\mathsf{Suc}_{PK_{\\mathcal{A}}}(\\mathsf{D})=1</span>), then <span class="math">\\mathsf{D}</span> contains a valid representation <span class="math">\\boldsymbol{\\delta}</span> of <span class="math">PK_{\\mathcal{A}}</span>, and it is possible to reverse-engineer <span class="math">\\mathsf{D}</span> and extract <span class="math">\\boldsymbol{\\delta}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Assumption 3 is partially supported by Proposition 1 and it is essentially equivalent to what was previously assumed in [3]. It is also <em>a priori</em> much less restrictive than the non-black-box assumption made in [19], where the non-black-box analysis is subject to the hypothesis that the illegal key extracted from the pirate decoder is a convex linear combination of some of the traitors’ keys. In fact, in Lemma 6 (whose proof is given in Section 6.3) we show that in our context, the seemingly more restrictive assumption from [19] actually follows from Assumption 3 and Assumption 2.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> Let <span class="math">\\mathcal{A}</span> be any probabilistic, polynomial-time adversary, and let <span class="math">\\langle \\mathsf{D}, PK_{\\mathcal{A}}, MSK_{\\mathcal{A}}, \\mathcal{T} \\rangle</span> be the output resulting from the adversary playing the traceability attack game <span class="math">\\mathbf{G}_{\\mathrm{trt}}^{m}(1^{k})</span> with the challenger. Also let <span class="math">\\mathcal{T} \\doteq \\{t_{1}, \\ldots, t_{m}\\}</span> and, for <span class="math">j = 1, \\ldots, m</span>, denote with <span class="math">\\delta_{t_j}</span> the compact representation of the secret key of user <span class="math">t_j</span> w.r.t. the public key <span class="math">PK_{\\mathcal{A}}</span>. If the pirate decoder <span class="math">\\mathsf{D}</span> output by <span class="math">\\mathcal{A}</span> contains a valid representation <span class="math">\\delta</span> for the public key <span class="math">PK_{\\mathcal{A}}</span>, such that <span class="math">\\delta&#x27;</span> is not a linear combination of <span class="math">\\delta_{t_1}&#x27;, \\ldots, \\delta_{t_m}&#x27;</span>, then the discrete-log problem over <span class="math">\\mathcal{G}</span> is solvable.</p>

    <p class="text-gray-300"><strong>Non-Black-Box Tracing Algorithm</strong> We present a deterministic tracing algorithm that recovers, under Assumptions 2 and 3, the identities of the traitors that created the pirate key. Suppose that the content of a pirate decoder is exposed. By Assumption 3, it is possible to extract from <span class="math">\\mathsf{D}</span> a valid representation <span class="math">\\delta</span> of the current public key <span class="math">PK_{\\mathcal{A}}</span>. Define <span class="math">\\{x_1,\\ldots ,x_n\\}</span> to be the set of all values assigned to the users in the system (where <span class="math">n</span> denotes the total number of users in the system), and let <span class="math">\\delta_{1},\\ldots ,\\delta_{n}</span> be the corresponding secret keys. Let <span class="math">\\{z_{i_1},\\dots ,z_{i_v}\\}</span> be the set of values of the revoked users specified in the current public key. Remember that the user-key of user <span class="math">j</span> w.r.t. the current public key can be compactly represented in the form</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\delta} _ {j} \\doteq \\langle \\lambda_ {0} ^ {(j)} A (x _ {j}), \\lambda_ {0} ^ {(j)} B (x _ {j}), \\lambda_ {i _ {1}} ^ {(j)}, \\dots , \\lambda_ {i _ {v}} ^ {(j)} \\rangle</span></div>

    <p class="text-gray-300">where <span class="math">\\lambda_j^{(j)},\\lambda_{i_1}^{(j)},\\ldots ,\\lambda_{i_v}^{(j)}</span> are the Lagrange coefficients defined in Equations (3) and (4). Notice that, for any polynomial <span class="math">P\\in \\mathbb{Z}_q^v [x]</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">P (0) = \\lambda_ {0} ^ {(j)} P (x _ {j}) + \\lambda_ {i _ {1}} ^ {(j)} P (x _ {i _ {1}}) + \\dots + \\lambda_ {i _ {v}} ^ {(j)} P (x _ {i _ {v}}).</span></div>

    <p class="text-gray-300">Consider the matrix <span class="math">\\mathbf{A} \\in \\mathbb{Z}_q^{n \\times v}</span> whose <span class="math">j</span>th row is <span class="math">\\delta_j&#x27;</span>, <span class="math">j = 1, \\ldots, n</span>, i.e.:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\doteq \\left( \\begin{array}{c c c} \\lambda_ {i _ {1}} ^ {(1)} &amp;amp; \\ldots &amp;amp; \\lambda_ {i _ {v}} ^ {(1)} \\\\ &amp;amp; \\ldots \\\\ \\lambda_ {i _ {1}} ^ {(n)} &amp;amp; \\ldots &amp;amp; \\lambda_ {i _ {v}} ^ {(n)} \\end{array} \\right)</span></div>

    <p class="text-gray-300">Define the identities of the traitors to be <span class="math">\\{t_1, \\ldots, t_m\\} \\subseteq \\{1, \\ldots, n\\}</span>. By Lemma 6 and Assumption 2, <span class="math">\\delta&#x27;</span> must be a linear combination of the vectors <span class="math">\\delta_{t_1}&#x27;, \\ldots, \\delta_{t_m}&#x27;</span> obtained by projecting the traitors' user-keys <span class="math">\\delta_{t_1}, \\ldots, \\delta_{t_m}</span> onto the last <span class="math">v</span> components. It follows that <span class="math">\\delta&#x27;&#x27;</span> also lies in the linear span of <span class="math">\\delta_1&#x27;, \\ldots, \\delta_n&#x27;</span>. More precisely, there exists a vector <span class="math">\\varphi</span> of Hamming weight at most <span class="math">m</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\delta} ^ {\\prime} = \\boldsymbol {\\varphi} \\cdot \\mathbf {A}. \\tag {35}</span></div>

    <p class="text-gray-300">Consider the two matrices:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} \\doteq \\left( \\begin{array}{c c c} x _ {i _ {1}} &amp;amp; \\ldots &amp;amp; x _ {i _ {1}} ^ {v} \\\\ &amp;amp; \\ldots \\\\ x _ {i _ {v}} &amp;amp; \\ldots &amp;amp; x _ {i _ {v}} ^ {v} \\end{array} \\right) \\quad \\mathbf {H} \\doteq \\left( \\begin{array}{c c c} - \\lambda_ {0} ^ {(1)} x _ {1} &amp;amp; \\ldots &amp;amp; - \\lambda_ {1} ^ {1} x _ {1} ^ {v} \\\\ &amp;amp; \\ldots \\\\ - \\lambda_ {0} ^ {(n)} x _ {n} &amp;amp; \\ldots &amp;amp; - \\lambda_ {0} ^ {(n)} x _ {n} ^ {v} \\end{array} \\right)</span></div>

    <p class="text-gray-300">It is easy to verify that <span class="math">\\mathbf{A} \\cdot \\mathbf{B} = \\mathbf{H}</span>. Multiplying (35) by <span class="math">\\mathbf{B}</span>, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\varphi} \\cdot \\mathbf {H} = \\boldsymbol {\\delta} ^ {\\prime \\prime}</span></div>

    <p class="text-gray-300">7 W.l.o.g. we are assuming that the current saturation level <span class="math">L</span> is equal to <span class="math">v</span>.</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\delta}^{\\prime\\prime}\\doteq\\boldsymbol{\\delta}^{\\prime}\\cdot\\mathbf{B}.</span> (36)</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> denote the linear code over <span class="math">\\mathbb{Z}_{q}^{n}</span> that has <span class="math">\\mathbf{H}</span> as its parity-check matrix, i.e.</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{c}\\in\\mathcal{C}\\Longleftrightarrow\\boldsymbol{c}\\cdot\\mathbf{H}=\\mathbf{0}.</span></p>

    <p class="text-gray-300">Let <span class="math">\\lambda_{1},\\ldots,\\lambda_{n}</span> be the Lagrange coefficients corresponding to <span class="math">\\{x_{1},\\ldots,x_{n}\\}</span>; thus, for all <span class="math">P\\in\\mathbb{Z}_{q}^{&lt;n}[x]</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">P(0)=\\lambda_{1}P(x_{1})+\\ldots+\\lambda_{n}P(x_{n}).</span></p>

    <p class="text-gray-300">In Lemma 7 (Section 6.3), we prove that <span class="math">\\mathcal{C}</span> is a Generalized Reed-Solomon Code (GRS), with distance <span class="math">(v+1)</span>. For more details about Generalized Reed-Solomon Codes, see e.g. <em>[16]</em>. Generalized Reed-Solomon Codes can be decoded efficiently by the algorithm of Berlekamp and Welch <em>[1]</em>. This means that, for any <span class="math">e\\leq m</span> and any vector <span class="math">\\boldsymbol{\\mu}\\in\\mathbb{Z}_{q}^{n}</span>, there exists (at most) a unique vector <span class="math">\\boldsymbol{\\omega}\\in\\mathcal{C}</span> that disagrees with <span class="math">\\boldsymbol{\\mu}</span> in at most <span class="math">e</span> positions (since <span class="math">\\mathcal{C}</span> has distance <span class="math">(v+1)</span> and <span class="math">m=\\lfloor\\frac{v}{2}\\rfloor</span>). Moreover, such unique vector <span class="math">\\boldsymbol{\\omega}\\in\\mathcal{C}</span> (if it exists) can be recovered in deterministic polynomial-time. We now describe how this can be exploited to reconstruct <span class="math">\\boldsymbol{\\varphi}</span> given <span class="math">\\boldsymbol{\\delta}^{\\prime}</span>.</p>

    <p class="text-gray-300">First, we compute an arbitrary vector <span class="math">\\boldsymbol{\\vartheta}\\in\\mathbb{Z}_{q}^{n}</span> that satisfies the system of equations</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\vartheta}\\cdot\\mathbf{H}=\\boldsymbol{\\delta}^{\\prime\\prime}.</span> (37)</p>

    <p class="text-gray-300">where <span class="math">\\boldsymbol{\\delta}^{\\prime\\prime}</span> is defined in Equation (36). Note that such <span class="math">\\boldsymbol{\\vartheta}</span> can be found by standard linear algebra since Equation (37) induces a system of <span class="math">v</span> equations with <span class="math">n</span> unknowns, <span class="math">n&gt;v</span>, and <span class="math">\\mathbf{H}</span> contains a non-singular minor of size <span class="math">v</span>. It is easy to verify that the vector</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\omega}\\doteq\\boldsymbol{\\vartheta}-\\boldsymbol{\\varphi}</span></p>

    <p class="text-gray-300">belongs to the linear code <span class="math">\\mathcal{C}</span>; indeed,</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\omega}\\cdot\\mathbf{H}</span> <span class="math">=\\boldsymbol{\\vartheta}\\cdot\\mathbf{H}-\\boldsymbol{\\varphi}\\cdot\\mathbf{H}</span> <span class="math">=\\boldsymbol{\\delta}^{\\prime\\prime}-\\boldsymbol{\\delta}^{\\prime\\prime}</span> <span class="math">=\\mathbf{0}.</span></p>

    <p class="text-gray-300">As a result, the vector <span class="math">\\boldsymbol{\\vartheta}</span> can be expressed as <span class="math">\\boldsymbol{\\vartheta}=\\boldsymbol{\\omega}+\\boldsymbol{\\varphi}</span>.</p>

    <p class="text-gray-300">Provided that the number of traitors is at most <span class="math">m</span>, it holds that the Hamming weight of <span class="math">\\boldsymbol{\\varphi}</span> is less than or equal to <span class="math">m</span> and as a result <span class="math">\\boldsymbol{\\vartheta}</span> is an <span class="math">n</span>-vector that differs in at most <span class="math">m</span> positions from the vector <span class="math">\\boldsymbol{\\omega}</span> (which belongs to <span class="math">\\mathcal{C}</span>): in other words, we can view <span class="math">\\boldsymbol{\\vartheta}</span> as a “partially corrupted” version of the codeword <span class="math">\\boldsymbol{\\omega}</span>. Therefore, we can recover <span class="math">\\boldsymbol{\\omega}</span> from <span class="math">\\boldsymbol{\\vartheta}</span>, by running the Berlekamp-Welch decoding algorithm for GRS-codes on input <span class="math">\\boldsymbol{\\vartheta}</span>. At this point, <span class="math">\\boldsymbol{\\varphi}</span> can be computed as <span class="math">\\boldsymbol{\\varphi}=\\boldsymbol{\\vartheta}-\\boldsymbol{\\omega}</span>.</p>

    <p class="text-gray-300">By Equation (35), <span class="math">\\boldsymbol{\\varphi}</span> is a vector of Hamming weight at most <span class="math">m</span>, whose non-zero components correspond to the identities of the traitors; thus, the traitors’ identities can be recovered as</p>

    <p class="text-gray-300"><span class="math">\\{t_{1},\\ldots,t_{m}\\}=j\\in\\{1,\\ldots,n\\}\\wedge\\boldsymbol{\\varphi}_{j}\\neq 0\\}.</span></p>

    <p class="text-gray-300">Time-Complexity. The tracing procedure has time complexity <span class="math">\\mathcal{O}(n^{2})</span>, which can be optimized to <span class="math">\\mathcal{O}(n(\\log n)^{2})</span>, if matrix operations are implemented in a more sophisticated manner, see e.g. <em>[2]</em>. If the number of traitors exceeds the bound <span class="math">m</span>, it is still possible to extract candidate sets of potential traitors using the Guruswami-Sudan algorithm <em>[13]</em>, which performs GRS-decoding “beyond the error-correction bound”. This will work provided that the size of the traitor coalition is less than or equal to <span class="math">n-\\sqrt{n(n-v)}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Correctness of Non-Black-Box Tracing</p>

    <p class="text-gray-300">Given Lemmas 6 and 7, the correctness of the non-black-box tracing algorithm described above follows from the properties of algebraic decoding of GRS codes. Thus, to conclude the argument, we now move on to the proofs of these Lemmas.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proof of Lemma 6.</h6>

    <p class="text-gray-300">Let <span class="math">g</span> be a generator of <span class="math">\\mathcal{G}</span>, and let <span class="math">g^{\\prime}\\doteq g^{w}</span>. Using adversary <span class="math">\\mathcal{A}</span> described in the attack game <span class="math">\\mathbf{G}^{m}_{\\text{trt}}(1^{k})</span>, we want to show how to recover the value <span class="math">w</span>. In performing step 1. of <span class="math">\\mathbf{G}^{m}_{\\text{trt}}(1^{k})</span>, choose two random polynomials <span class="math">A^{0}(x)</span> and <span class="math">B^{0}(x)</span> and set the initial public key to be</p>

    <p class="text-gray-300"><span class="math">\\langle g,g^{\\prime},g^{A^{0}(0)}g^{\\prime B^{0}(0)},\\langle\\ell,g^{A^{0}(\\ell)}g^{\\prime B^{0}(\\ell)}\\rangle^{v}_{\\ell=1}\\rangle.</span></p>

    <p class="text-gray-300">The game then proceeds as described in Section 6.1; in particular, let <span class="math">\\bar{t}</span> be the number of New-period operation occuring during the entire game. Eventually, adversary <span class="math">\\mathcal{A}</span> outputs a pirate decoder <span class="math">\\mathsf{D}</span> from which (by Assumption 3) it is possible to extract a vector</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\delta}=\\langle\\gamma_{a},\\gamma_{b},\\gamma_{1},\\ldots,\\gamma_{v}\\rangle,</span></p>

    <p class="text-gray-300">which is a valid representation of the final public key <span class="math">PK_{\\mathcal{A}}</span>. In formula,</p>

    <p class="text-gray-300"><span class="math">y=g^{\\gamma_{a}}g^{\\prime\\gamma_{b}}\\prod_{\\ell=1}^{v}h_{\\ell}^{\\gamma_{\\ell}}</span> (38)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">PK_{\\mathcal{A}}\\doteq\\langle g,g^{\\prime},y,\\langle x_{i_{\\ell}},h_{\\ell}\\rangle^{v}_{\\ell=1}\\rangle.</span></p>

    <p class="text-gray-300">Considering discrete logarithms to the base <span class="math">g</span> of Equation (38), we get:</p>

    <p class="text-gray-300"><span class="math">A^{\\bar{t}}(0)+wB^{\\bar{t}}(0)\\!=\\!\\gamma_{a}+\\sum_{\\ell=1}^{v}\\!A^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell}+w\\Big{(}\\!\\gamma_{b}+\\sum_{\\ell=1}^{v}\\!B^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell}\\!\\Big{)}</span></p>

    <p class="text-gray-300">that can be rewritten as:</p>

    <p class="text-gray-300"><span class="math">w\\Big{(}\\!\\gamma_{b}+\\sum_{\\ell=1}^{v}\\!B^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell}-B^{\\bar{t}}(0)\\!\\Big{)}\\!=\\!A^{\\bar{t}}(0)-\\gamma_{a}-\\sum_{\\ell=1}^{v}\\!A^{\\bar{t}}(x_{i_{\\ell}})\\gamma_{\\ell}</span> (39)</p>

    <p class="text-gray-300">Notice that both the right-hand side and the coefficient of <span class="math">w</span> in (39) are known, so that if such coefficient is non-zero (or, equivalently, if the right-hand side of (39) is non-zero), then we can successfully recover the value of <span class="math">w</span>, thus violating Assumption 2. To complete the argument, it then suffices to show that the right-hand side of (39) is zero only with negligible probability, or equivalently that:</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\gamma_{a}=\\bar{\\gamma}_{a}]=1/q</span> (40)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\bar{\\gamma}_{a}\\doteq A^{\\bar{t}}(0)-\\sum_{\\ell=1}^{v}A^{\\bar{t}}(x_{i_{\\ell}}).</span></p>

    <p class="text-gray-300">To this aim, below we prove that, conditioning on all the other information in <span class="math">\\mathcal{A}</span>’s view, the quantity <span class="math">\\bar{\\gamma}_{a}</span> is uniformly distributed in <span class="math">\\mathbb{Z}_{q}</span>. It will follow that <span class="math">\\mathcal{A}</span>’s chances of outputting a value <span class="math">\\gamma_{a}</span> equal to <span class="math">\\bar{\\gamma}_{a}</span> are just 1 in <span class="math">q</span>, proving Equation (39) and thus the Lemma.</p>

    <p class="text-gray-300">To prove that <span class="math">\\bar{\\gamma}_{a}</span> is distributed uniformly in <span class="math">\\mathbb{Z}_{q}</span>, we again make use of Lemma 1 following the same approach described in Section 5.2.</p>

    <p class="text-gray-300">Consider the quantity</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{V}\\doteq(\\mathsf{Coins},w,\\{\\{c_{j}^{t},r_{j}^{t}\\}_{j=1}^{2v+2}\\}_{\\ell=1}^{t})</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">where Coins represents the coin tosses of  <span class="math">\\mathcal{A}</span> ,  <span class="math">w \\doteq \\log_g g&#x27;</span> , and  <span class="math">\\{\\{c_j^t, r_j^t\\}_{j=1}^{2v+2}\\}_{t=1}^\\ell</span>  represents all the randomness used in the  <span class="math">\\bar{t}</span>  New-period operations that took place during the  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^m(1^k)</span>  attack game.</p>

    <p class="text-gray-300">The remaining randomness used during the attack game consists of the  <span class="math">2v + 2</span>  coefficients of the polynomials  <span class="math">A^0(\\cdot)</span> ,  <span class="math">B^0(\\cdot)</span>  and can be represented by a vector  <span class="math">\\alpha</span>  uniformly distributed in  <span class="math">\\mathbb{Z}_q^{(2v + 2) \\times 1}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\alpha} \\doteq (a _ {0}, a _ {1}, \\dots , a _ {v}, b _ {0}, b _ {1}, \\dots , b _ {v}) ^ {T}.</span></div>

    <p class="text-gray-300">Consider the vector  <span class="math">\\beta \\in \\mathbb{Z}_q^{(v + m + 2)\\times 1}</span>  defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} \\doteq (\\mathbf {X} _ {0}, \\mathbf {X} _ {1}, \\dots , \\mathbf {X} _ {v}, \\mathbf {A} _ {1}, \\dots , \\mathbf {A} _ {m}, \\bar {\\gamma} _ {a}) ^ {T}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_0\\dot{=} A^0 (0) + wB^0 (0)</span> ,  <span class="math">\\mathbf{X}_{\\ell}\\doteq A^{0}(\\ell) + wB^{0}(\\ell)</span> , for  <span class="math">\\ell = 1,\\ldots ,v</span>  and  <span class="math">\\mathbf{A}_j\\dot{=} A^0 (t_j)</span>  for  <span class="math">j = 1,\\dots ,m</span> .</p>

    <p class="text-gray-300">It is clear by inspection that all the information in the view of the adversary  <span class="math">\\mathcal{A}</span>  during the attack game  <span class="math">\\mathbf{G}_{\\mathrm{trt}}^{m}(1^{k})</span>  is completely determined by  <span class="math">\\pmb{V}</span>  and  <span class="math">\\beta</span> . In particular, the initial public key  <span class="math">PK^0</span>  is fixed by  <span class="math">\\beta</span>  and  <span class="math">w</span> , and the secret keys of the traitors are determined by the choice of  <span class="math">\\beta</span> , Coins and  <span class="math">w</span> .</p>

    <p class="text-gray-300">The quantities in  <span class="math">V</span> ,  <span class="math">\\beta</span>  and  <span class="math">\\alpha</span>  are related according to the following matrix equation:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\beta} = \\mathbf {M} \\cdot \\boldsymbol {\\alpha} + \\boldsymbol {\\gamma}</span></div>

    <p class="text-gray-300">where  <span class="math">\\pmb {\\gamma}\\in \\mathbb{Z}_q^{(v + m + 2)\\times 1}</span>  is the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\gamma} \\doteq \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ D ^ {0, \\bar {t}} (0) - \\sum_ {\\ell = 1} ^ {v} D ^ {0, \\bar {t}} (x _ {i _ {\\ell}}) \\gamma_ {\\ell} \\end{array} \\right)</span></div>

    <p class="text-gray-300">and  <span class="math">\\mathbf{M} \\in \\mathbb{Z}_q^{(v + m + 2) \\times (2v + 2)}</span>  is the matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c c c c c c} 1 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 &amp;amp; w &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; 1 &amp;amp; w &amp;amp; w &amp;amp; \\ldots &amp;amp; w \\\\ &amp;amp; &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ 1 &amp;amp; v &amp;amp; \\ldots &amp;amp; v ^ {v} &amp;amp; w &amp;amp; w v &amp;amp; \\ldots &amp;amp; w v ^ {v} \\\\ 1 &amp;amp; x _ {t _ {1}} &amp;amp; \\ldots &amp;amp; x _ {t _ {1}} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ &amp;amp; &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ 1 &amp;amp; x _ {t _ {m}} &amp;amp; \\ldots &amp;amp; x _ {t _ {m}} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ - \\sum_ {\\ell = 1} ^ {v} \\gamma_ {\\ell} - \\sum_ {\\ell = 1} ^ {v} \\gamma_ {\\ell} x _ {i _ {\\ell}} &amp;amp; \\ldots &amp;amp; - \\sum_ {\\ell = 1} ^ {v} \\gamma_ {\\ell} x _ {i _ {\\ell}} ^ {v} &amp;amp; 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\end{array} \\right)</span></div>

    <p class="text-gray-300">By inspection, it is possible to see that the first  <span class="math">v + m + 1</span>  rows of  <span class="math">\\mathbf{M}</span>  are linearly independent, provided that  <span class="math">w \\neq 0</span> . To see that the rank of  <span class="math">\\mathbf{M}</span>  is indeed  <span class="math">v + m + 2</span> , define  <span class="math">\\mathbf{T} \\in \\mathbb{Z}_q^{m \\times v}</span>  to be the minor of matrix  <span class="math">\\mathbf{A}</span>  resulting from considering only rows  <span class="math">t_1, \\ldots, t_m</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {T} \\doteq \\left( \\begin{array}{c c c} \\lambda_ {i _ {1}} ^ {(t _ {1})} &amp;amp; \\ldots &amp;amp; \\lambda_ {i _ {v}} ^ {(t _ {1})} \\\\ &amp;amp; \\ldots \\\\ \\lambda_ {i _ {1}} ^ {(t _ {m})} &amp;amp; \\ldots &amp;amp; \\lambda_ {i _ {v}} ^ {(t _ {m})} \\end{array} \\right)</span></div>

    <p class="text-gray-300">It is possible to show that if the last row of  <span class="math">\\mathbf{M}</span>  were in the linear span of the first  <span class="math">v + m + 1</span>  rows of  <span class="math">\\mathbf{M}</span> , it would follow that  <span class="math">\\pmb{\\delta}&#x27;</span>  should belong to the linear span of the rows of  <span class="math">\\mathbf{T}</span> . But since, by hypothesis,  <span class="math">\\pmb{\\delta}&#x27;</span>  is not a linear combination of  <span class="math">\\pmb{\\delta}_{t_1}&#x27;</span> , ...,  <span class="math">\\pmb{\\delta}_{t_m}&#x27;</span> , the matrix  <span class="math">\\mathbf{M}</span>  must have full rank.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">As soon as we fix <span class="math">\\bm{V}</span>, the first <span class="math">v+m+1</span> entries of <span class="math">\\bm{\\gamma}</span> and the first <span class="math">v+1</span> rows of <span class="math">\\mathbf{M}</span> are determined, but <span class="math">\\bm{\\alpha}</span> is still distributed uniformly and independently at random in <span class="math">\\mathbb{Z}_{q}^{(2v+2)\\times 1}</span>. Similarly to the proof of Lemma 3, it is also possible to show that fixing the first <span class="math">v+j+1</span> entries of <span class="math">\\bm{\\beta}</span> determines the <span class="math">(v+j+2)</span>th row of <span class="math">\\mathbf{M}</span>, for <span class="math">j=1,\\ldots,m</span>; and that moreover, fixing the first <span class="math">v+m+1</span> entries of <span class="math">\\bm{\\beta}</span> also determines the last rows of <span class="math">\\bm{\\gamma}</span> and of <span class="math">\\mathbf{M}</span>.</p>

    <p class="text-gray-300">Hence, by Lemma 1, we can conclude that the conditional distribution of <span class="math">\\bar{\\gamma}_{a}</span> w.r.t. <span class="math">\\bm{V}</span>, and to the first <span class="math">v+m+1</span> entries of <span class="math">\\bm{\\beta}</span>, is uniform over <span class="math">\\mathbb{Z}_{q}</span>. In other words, conditioning on all the other information in <span class="math">\\mathcal{A}</span>’s view, the quantity <span class="math">\\bar{\\gamma}_{a}</span> is uniformly distributed over <span class="math">\\mathbb{Z}_{q}</span>. Equation (39), and thus the Lemma, follows. ∎</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">Consider the Generalized Reed-Solomon code:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}^{\\prime}\\doteq\\big{\\{}\\langle-\\frac{\\lambda_{1}}{\\lambda_{0}^{(1)}}P(x_{1}),\\ldots,-\\frac{\\lambda_{n}}{\\lambda_{0}^{(n)}}P(x_{n})\\rangle\\mid P\\in\\mathbb{Z}_{q}^{&lt;n-v}[x]\\}.</span></p>

    <p class="text-gray-300">It holds that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}=\\mathcal{C}^{\\prime}</span>.</li>

      <li><span class="math">\\mathcal{C}</span> is a linear code with message-rate <span class="math">(n-v)/n</span> and distance <span class="math">v+1</span>.</li>

    </ol>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We only need to show that <span class="math">\\mathcal{C}^{\\prime}\\subseteq\\mathcal{C}</span>. Indeed, assuming that <span class="math">\\mathcal{C}^{\\prime}</span> is a linear sub-space of <span class="math">\\mathcal{C}</span>, since <span class="math">\\dim(\\mathcal{C})=n-v=\\dim(\\mathcal{C}^{\\prime})</span>, it immediately follows that <span class="math">\\mathcal{C}=\\mathcal{C}^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">To prove that <span class="math">\\mathcal{C}^{\\prime}\\subseteq\\mathcal{C}</span>, notice that if <span class="math">\\langle c_{1},\\ldots,c_{n}\\rangle\\in\\mathcal{C}^{\\prime}</span>, then it is of the form</p>

    <p class="text-gray-300"><span class="math">\\big{\\langle}-\\frac{\\lambda_{1}}{\\lambda_{0}^{(1)}}P(x_{1}),\\ldots,-\\frac{\\lambda_{n}}{\\lambda_{0}^{(n)}}P(x_{n})\\big{\\rangle}</span></p>

    <p class="text-gray-300">for some polynomial <span class="math">P\\in\\mathbb{Z}_{q}^{&lt;n-v}[x]</span>. We now verify that <span class="math">\\langle c_{1},\\ldots,c_{n}\\rangle</span> belongs to <span class="math">\\mathcal{C}</span>. First, notice that for <span class="math">\\ell=1,\\ldots,v</span>, multiplying <span class="math">\\langle c_{1},\\ldots,c_{n}\\rangle</span> by the <span class="math">\\ell</span>th column of <span class="math">\\mathbf{H}</span> we get</p>

    <p class="text-gray-300"><span class="math">\\langle c_{1},\\ldots,c_{n}\\rangle\\cdot\\langle-\\lambda_{0}^{(1)}x_{1}^{\\ell},\\ldots,-\\lambda_{0}^{(n)}x_{n}^{\\ell}\\rangle=\\sum_{i=1}^{n}\\lambda_{i}P(x_{i})x_{i}^{\\ell}.</span></p>

    <p class="text-gray-300">Now observe that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{n}\\lambda_{i}P(x_{i})x_{i}^{\\ell}=0</span></p>

    <p class="text-gray-300">by the choice of <span class="math">\\lambda_{1},\\ldots,\\lambda_{n}</span> and the facts that degree<span class="math">(P)&lt;n-v</span> and <span class="math">\\ell\\leq v</span> (just consider the polynomial <span class="math">Q(x)\\doteq P(x)x^{\\ell}\\in\\mathbb{Z}_{q}^{&lt;n}[x]</span>). It follows that</p>

    <p class="text-gray-300"><span class="math">\\langle c_{1},\\ldots,c_{n}\\rangle\\cdot\\mathbf{H}=\\mathbf{0}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Observe that a vector of <span class="math">\\mathbb{Z}_{q}^{n-v}</span> can be encoded as the coefficients of a polynomial <span class="math">P\\in\\mathbb{Z}_{q}^{&lt;n-v}[x]</span>. The corresponding codeword of <span class="math">\\mathcal{C}</span> will be the vector</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\big{\\langle}-\\frac{\\lambda_{1}}{\\lambda_{0}^{(1)}}P(x_{1}),\\ldots,-\\frac{\\lambda_{n}}{\\lambda_{0}^{(n)}}P(x_{n})\\big{\\rangle}.</span></p>

    <p class="text-gray-300">To see that the distance of the linear code is <span class="math">v+1</span> observe that any two different codewords of <span class="math">\\mathcal{C}</span> can agree on at most <span class="math">n-v-1</span> positions, or equivalently any two distinct codewords differ on at least <span class="math">v+1</span> positions. ∎</p>

    <p class="text-gray-300">7 Conclusions and Future Work</p>

    <p class="text-gray-300">We introduce the first public-key traitor tracing scheme where an unlimited number of users can be efficiently added and removed from the system. Our scheme enjoys both client-side scalability, by supporting a dynamically-changing user population, and server-side scalability, as it enables many content providers to use a common content distribution infrastructure.</p>

    <p class="text-gray-300">We present a formal model for scalable public-key traitor tracing, and a thorough analysis of the revocation and tracing properties of our scheme against adaptive adversaries.</p>

    <p class="text-gray-300">At a technical level, our adversarial model improves over previous modeling for public-key traitor tracing by capturing a larger class of adversaries, endowed with greater control over system, than what previously considered in the related literature. In particular, in our model the adversary can control an a priori unbounded number of user additions and removals. The main limitation of our formal model is that the adversary is supposed to be fully revoked in a “window” of the system.</p>

    <p class="text-gray-300">An interesting open problem left open by our research consists of extending our results to a more general adversarial model, in which the adversary is not supposed to obey the “window” constrain.</p>

    <h2 id="sec-45" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We are grateful to Antonio Nicolosi for his constructive criticism and encouraging support throughout this research.</p>

    <p class="text-gray-300">We thank the anonymous referees for helping in improving the readability of the paper, and one of them in particular for pointing out a flaw in an early version of our scheme.</p>

    <h2 id="sec-46" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] E.R. Berlekamp and L. R. Welch. Error Correction of Algebraic Block Codes, 1986. U.S. Patent, Number 4,633,470.</li>

      <li>[2] D. Bini and V. Y. Pan. Polynomial and Matrix Computations (vol. 1): Fundamental Algorithms. Birkhauser-Verlag, 1994.</li>

      <li>[3] D. Boneh and M. Franklin. An Efficient Public Key Traitor Tracing Scheme. In Advances in Cryptology—Crypto ’99, pages 338–353. Springer-Verlag, 1999. LNCS 1666. Full version available at crypto.stanford.edu/~dabo/pubs.html.</li>

      <li>[4] S. Brands. Rethinking Public Key Infrastructures and Digital Certificates—Building in Privacy. PhD thesis, Technical University of Eindhoven, 1999.</li>

      <li>[5] R. Canetti, J. Garay, G. Itkis, D. Micciancio, M. Naor, and B. Pinkas. Multicast Security: A Taxonomy and some Efficient Constructions. In Proceedings of IEEE INFOCOM ’99, volume 2, pages 708–716, 1999.</li>

      <li>[6] B. Chor, A. Fiat, and N. Naor. Tracing Traitors. In Advances in Cryptology—Crypto ’94, pages 257–270. Springer-Verlag, 1994. LNCS 839.</li>

      <li>[7] R. Cramer and V. Shoup. Design and Analysis of Practical Public-Key Encryption Scheme Secure against Adaptive Chosen Ciphertext Attack. SIAM Journal on Computing, 33(1):167–226, 2003.</li>

      <li>[8] Y. Dodis and N. Fazio. Public-Key Broadcast Encryption for Statless Receivers. In Digital Rights Management—DRM ’02, pages 61–80. Springer, 2002. LNCS 2696.</li>

      <li>[9] Y. Dodis and N. Fazio. Public-Key Trace and Revoke Scheme Secure against Adaptive Chosen Ciphertext Attack. In Public Key Cryptography—PKC ’03, pages 100–115. Springer-Verlag, 2003. LNCS 2567.</li>

      <li>[10] A. Fiat and M. Naor. Broadcast Encryption. In Advances in Cryptology—Crypto ’93, pages 480–491. Springer-Verlag, 1993. LNCS 773.</li>

      <li>[11] E. Gafni, J. Staddon, and Y. L. Yin. Efficient Methods for Integrating Traceability and Broadcast Encryption. In Advances in Cryptology—Crypto ’99, pages 372–387. Springer-Verlag, 1999. LNCS 1666.</li>

      <li>[12] A Garay, J. Staddon, and A. Wool. Long-Lived Broadcast Encryption. In Advances in Cryptology—Crypto 2000, pages 333–352. Springer-Verlag, 2000. LNCS 1880.</li>

      <li>[13] V. Guruswami and M. Sudan. Improved Decoding of Reed-Solomon and Algebraic-Geometric Codes. In IEEE Symposium on Foundations of Computer Science, pages 28–39, 1998.</li>

      <li>[</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Kiayias and M. Yung. Self Protecting Pirates and Black-Box Traitor Tracing. In Advances in Cryptology—Crypto ’01, pages 63–79. Springer-Verlag, 2001. LNCS 2139.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>15. K. Kurosawa and Y. Desmedt. Optimum Traitor Tracing and new Direction for Asymmetricity. In Advances in Cryptology—EuroCrypt ’98, pages 145–157. Springer-Verlag, 1998. LNCS 1403.</li>

      <li>16. F. J. MacWilliams and N. Sloane. The Theory of Error Correcting Codes. North Holland, Amsterdam, 1977.</li>

      <li>17. D. Naor, M. Naor, and J. Lotspiech. Revocation and Tracing Schemes for Stateless Receivers. In Advances in Cryptology—Crypto ’01, pages 41–62. Springer-Verlag, 2001. LNCS 2139.</li>

      <li>18. M. Naor and B. Pinkas. Threshold Traitor Tracing. In Advances in Cryptology—Crypto ’98, pages 502–517. Springer-Verlag, 1998. LNCS 1462.</li>

      <li>19. M. Naor and B. Pinkas. Efficient Trace and Revoke Schemes. In Financial Cryptography—FC 2000, pages 1–20. Springer-Verlag, 2000. LNCS 1962. Full version available at www.wisdom.weizmann.ac.il/~naor/onpub.html.</li>

      <li>20. D. R. Stinson and R. Wei. Combinatorial Properties and Constructions of Traceability Schemes and Frameproof Codes. SIAM Journal on Discrete Mathematics, 11(1):41–53, 1998.</li>

      <li>21. W.G. Tzeng and Z.J. Tzeng. A Public-Key Traitor Tracing Scheme with Revocation Using Dynamics Shares. In Public Key Cryptography—PKC ’01, pages 207–224. Springer-Verlag, 2001. LNCS 1992.</li>

      <li>22. D. Wallner, E. Harder, and R. Agee. Key Management for Multicast: Issues and Architectures. Available at ftp://ftp.ietf.org/rfc/rfc2627.txt, 1997.</li>

    </ul>`;
---

<BaseLayout title="Scalable Public-Key Tracing and Revoking (2004/160)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/160
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
