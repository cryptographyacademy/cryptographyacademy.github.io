---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/870';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'SoK: Gröbner Basis Algorithms for Arithmetization Oriented Ciphers';
const AUTHORS_HTML = 'Jan Ferdinand Sauer, Alan Szepieniec';

const CONTENT = `    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for Arithmetization Oriented Ciphers</p>

    <p class="text-gray-300">Jan Ferdinand Sauer and Alan Szepieniec</p>

    <p class="text-gray-300">AS Discrete Mathematics GmbH, Switzerland</p>

    <p class="text-gray-300">{ferdinand,alan}@asdm.gmbh</p>

    <p class="text-gray-300">Abstract. Many new ciphers target a concise algebraic description for efficient evaluation in a proof system or a multi-party computation. This new target for optimization introduces algebraic vulnerabilities, particularly involving Gröbner basis analysis. Unfortunately, the literature on Gröbner bases tends to be either purely mathematical, or focused on small fields. In this paper, we survey the most important algorithms and present them in an intuitive way. The discussion of their complexities enables researchers to assess the security of concrete arithmetization-oriented ciphers. Aside from streamlining the security analysis, this paper helps newcomers enter the field.</p>

    <p class="text-gray-300">Keywords: Algebraic Cryptanalysis · Gröbner Basis · Arithmetization Oriented Cipher.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">A range of emerging applications build on cryptographic protocols that employ arithmetization. This process first characterizes a computation as a sequence of basic finite field operations, and then performs these operations in the context of a cryptographic protocol that preserves some target security property, such as privacy, soundness, etc. Some examples of protocols that arithmetize are zero-knowledge proof systems [16, 56], succinct-verifier proof systems [27], and multi-party protocols [38] – all of which have numerous already-deployed applications both in a blockchain context and elsewhere.</p>

    <p class="text-gray-300">A recurring computational task in these applications consists of evaluating a keyed or unkeyed symmetric cryptographic primitive. However, traditional block ciphers and hash functions are optimized for hardware and software implementations, not for arithmetic simulation by a cryptographic protocol. The demand for high performance in these applications has brought about two notable changes to the symmetric cryptography landscape:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>New designs for symmetric primitives optimized for arithmetic protocols. Recent years have seen several new proposals and design strategies with this selling point: LowMC [6], MiMC [5], GMiMC [4], Jarvis and Friday [10], Vision and Rescue [7, 81], Starkad and Poseidon [58]. These so-called arithmetization-oriented ciphers (AOCs) target a concise description in terms of operations over a large finite field.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Renewed interest in the field of algebraic attacks on symmetric primitives.</li>

    </ol>

    <p class="text-gray-300">As a result of their concise description in terms of finite field operations, AOCs are vulnerable to a collection of attacks that exploit the low degree or sparsity of polynomial representations of the cipher under attack <em>[3, 18, 25, 66]</em>. Traditional ciphers mitigate this vulnerability by including operations not native to the working field in their circuit, resulting in a huge description in terms of polynomials. As a result, most of traditional symmetric cryptanalysis focuses on statistical attacks such as differential and linear cryptanalysis. For AOCs, these types of attacks are generally less relevant as a consequence of their large working field.</p>

    <p class="text-gray-300">One of the most powerful general-purpose algebraic attack methodologies revolves around the computation of a Gröbner basis from a set of polynomials. This Gröbner basis computation is one step in a polynomial system solving problem where the polynomials are provided by the cipher’s description, and the polynomials’ common solution contains the sought-after secret key or hash preimage. The complexity of polynomial system solving is therefore a vitally important question in the context of analyzing the security of an AOC or determining the correct parameters for a target security level.</p>

    <p class="text-gray-300">Unfortunately, polynomial system solving and Gröbner bases remain poorly understood subjects, particularly in the context of AOCs. There are several reasons for this poor understanding. Firstly, until recently, there was no demand for AOCs and thus no reason for cryptanalysts to study their security. Secondly, the field is not very developed, in the sense that contributions come from rather few researchers with diverse backgrounds, hampering collaboration. Thus thirdly, and most importantly, the literature on the topic is scattered across many sources, often contradictory, and in many cases out of date.</p>

    <p class="text-gray-300">This paper aims to systematize existing knowledge in the context of Gröbner basis attacks on AOCs. No scientific novelty is claimed; our contribution is merely the presentation of existing knowledge in an intuitive and self-consistent way. In doing so, we hope to make the field more accessible to researchers and eventually improve the understanding of the concrete security that various AOCs offer.</p>

    <p class="text-gray-300">The structure and scope of this paper is best illustrated in relation to the general attack pipeline, which consists of several steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial modeling. The cipher is described in terms of low-degree multivariate polynomials, such that any solution common to all polynomials results in a win for the attacker.</li>

      <li>Gröbner basis computation in degree-refining term order. A Gröbner basis algorithm computes a Gröbner basis for the ideal spanned by this list of polynomials, relative to a term order refining the degree, typically degrevlex.</li>

      <li>Term order change. The Gröbner basis with respect to degrevlex is transformed into a Gröbner basis for the same polynomial ideal but with respect to lex, an alternative term order.</li>

      <li>Solution readout. Using a mixture of the Euclidean algorithm, univariate polynomial factorization, and back-substitution of roots, an attacker extracts a common solution to the system of polynomials.</li>

    </ol>

    <p class="text-gray-300">Step 1, modeling the cipher and attack, is out of scope for this paper. We assume an attacker already knows which polynomials they want to find a solution to. Indeed, the concise polynomial formulation of AOCs is their selling point.</p>

    <p class="text-gray-300">In Section 2, we cover the basic definitions of variety, ideal, term order, and Gröbner basis. We show here how solution readout works for Gröbner bases in lex order of zero-dimensional ideals, and how a naïve transformation of Buchberger’s criterion gives rise to a correct (albeit slow) Gröbner basis algorithm.</p>

    <p class="text-gray-300">In Section 3, we cover the F_{4} and F_{5} algorithms, which constitute the state of the art. We also cover the XL family of algorithms, which is popular in the context of cryptanalysis and small fields. While these algorithms are often described as Gröbner-like due to their various similarities, the framing is quite different.</p>

    <p class="text-gray-300">In Section 4, we cover FGLM and sketch the Gröbner walk, the two most important term order change algorithms. It is important to consider the term order change as a separate step in the attack because the Gröbner basis computation does not always dominate. Indeed, it is possible to construct AOCs where the Gröbner basis comes for free, and where the cipher’s security comes from the difficulty of computing this term order change.</p>

    <p class="text-gray-300">We close in Section 5 with open questions and a discussion, and suggest future work.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 Gröbner Bases</h2>

    <p class="text-gray-300">After modeling a cryptographic primitive as a system of polynomial equations, the objective is to find a solution to that system of equations, i.e., some vector <span class="math">\\bm{a}</span> that simultaneously satisfies all multivariate polynomial equations. The set of all these values is called the variety.</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Definition 1 (Variety).</h6>

    <p class="text-gray-300">The variety of <span class="math">\\mathcal{F}\\subseteq\\mathbb{F}[\\mathbf{x}]</span> is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$V(\\mathcal{F})=\\left\\{(a_{0},\\ldots,a_{n-1})\\in\\overline{\\mathbb{F}}^{n}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\forall f\\in\\mathcal{F}:f(\\bm{a})=0\\right.\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that varieties are defined over the algebraic closure <span class="math">\\overline{\\mathbb{F}}</span> of <span class="math">\\mathbb{F}</span>. For this paper, solutions not lying in the base field <span class="math">\\mathbb{F}</span> are not of interest; only elements of <span class="math">\\mathbb{F}</span> are valid inputs (keys, messages, etc.) and outputs (ciphertexts, hashes, etc.). Therefore, special care must be taken to eliminate parasitical extension field solutions, for instance by adjoining the field equations.</p>

    <p class="text-gray-300">Identifying each equation with its polynomial allows us to operate on polynomials rather than on polynomial equations. Which operations on lists of polynomials can bring us closer to finding a solution? Linear algebra techniques suffice when the polynomials are linear. For higher degree polynomials, Gröbner basis algorithms provide a standard methodology. We motivate this notion before providing the definition.</p>

    <p class="text-gray-300">A natural requirement for allowable operations is that they neither create nor destroy solutions. Adding and subtracting the polynomial equations to derive new ones satisfies this requirement, as does multiplying them with scalar weights. In fact, the weights need not be scalars but can be drawn from the same ring of polynomials over which the original polynomials themselves are defined. This observation motivates the notion of <em>polynomial ideals</em>, a generalization of vector spaces that allows polynomial coefficients instead of just scalar coefficients.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Definition 2 (Polynomial ideal).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}=\\{f_{0},\\ldots,f_{s-1}\\}\\subseteq\\mathbb{F}[\\mathbf{x}]</span> be a set of polynomials. The ideal <span class="math">I</span> spanned by <span class="math">\\mathcal{F}</span> is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$I=\\langle\\mathcal{F}\\rangle=\\langle f_{0},\\ldots,f_{s-1}\\rangle=\\left\\{\\sum_{i=0}^{s-1}q_{i}f_{i}\\;\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\;q_{i}\\in\\mathbb{F}[\\mathbf{x}]\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The set of cosets of <span class="math">I</span> in <span class="math">\\mathbb{F}[\\mathbf{x}]</span>, together with polynomial addition and multiplication, forms a ring. We can therefore consider any polynomial <span class="math">f</span> equivalent to some polynomial <span class="math">g\\equiv f\\bmod I</span> whenever <span class="math">f-g\\in I</span>. Intuitively, a useful property of a basis for <span class="math">I</span> is for it to allow the computation of a canonical representative for each equivalence class, as this would admit an equivalence test. This property is useful for finding solutions because the equivalence class of all polynomials that encode information about the solution is <span class="math">0\\bmod I</span>. The canonical representatives therefore distinguish useful polynomials from not so useful ones.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This observation is related to divisibility of univariate polynomials. If <span class="math">f(x)</span> is a univariate polynomial and <span class="math">\\langle f(x)\\rangle</span> its ideal, then the computation of canonical representative of a polynomial <span class="math">g(x)</span> modulo <span class="math">\\langle f(x)\\rangle</span> follows straightforwardly from polynomial long division: the canonical representative of <span class="math">g(x)</span> is its remainder after division by <span class="math">f(x)</span>. Moreover, if <span class="math">a\\in\\mathbb{F}</span> is a root of <span class="math">f(x)</span>, then $(x-a)\\></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\>f(x)<span class="math"> and one might even write </span>f(x)\\in\\langle x-a\\rangle<span class="math"> or </span>f(x)\\equiv 0\\bmod x-a<span class="math">. If the roots of </span>f(x)<span class="math"> and of </span>g(x)<span class="math"> are disjoint sets, then </span>f(x)\\not\\equiv 0\\bmod g(x)<span class="math"> and </span>g(x)\\not\\equiv 0\\bmod f(x)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Unfortunately, polynomial division does not naturally generalize to multivariate polynomials. Univariate polynomial division relies on the natural order of univariate monomials; namely comparing degrees. That is, <span class="math">x^{a}\\prec x^{b}</span> if and only if <span class="math">a&lt;b</span>. Division of univariate monomial <span class="math">x^{a}</span> by <span class="math">x^{b}</span> results in <span class="math">x^{a-b}</span>, which is an element of <span class="math">\\mathbb{F}[x]</span> if <span class="math">a\\geqslant b</span>. The generalization to multivariate monomials is straightforward: <span class="math">\\mathbf{x}^{\\boldsymbol{\\alpha}}</span> divided by <span class="math">\\mathbf{x}^{\\boldsymbol{\\beta}}</span> results in <span class="math">\\mathbf{x}^{\\boldsymbol{\\alpha}-\\boldsymbol{\\beta}}</span>, an element of <span class="math">\\mathbb{F}[\\mathbf{x}]</span> if <span class="math">\\alpha_{i}\\geqslant\\beta_{i}</span> for all <span class="math">i</span>. However, generalizing polynomial division is a little more subtle. In the univariate case, the monomials with the highest power of the variable determine the next step in the division process. In the multivariate case, “highest power” is no inherent property: How do the degrees of <span class="math">x^{5}yz^{2}</span> and <span class="math">x^{2}y^{2}z^{4}</span> relate? In order to proceed, we must therefore fix the monomial order.</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">For multivariate division to be well defined, a monomial order  <span class="math">\\prec</span>  must respect multiplication with monomials, i.e., evaluating operator  <span class="math">\\prec</span>  must give the same result when both operands are multiplied by any monomial  <span class="math">m \\in \\mathcal{M}</span> . In other words,  <span class="math">\\forall m \\in \\mathcal{M}: \\mathbf{x}^{\\alpha} \\prec \\mathbf{x}^{\\beta} \\Leftrightarrow m\\mathbf{x}^{\\alpha} \\prec m\\mathbf{x}^{\\beta}</span> . Furthermore,  <span class="math">\\prec</span>  must be a well-order, i.e., (1) the monomial  <span class="math">1 = \\mathbf{x}^{(0,\\dots,0)}</span>  is the smallest element, and (2) any two monomials are comparable, i.e.,  <span class="math">\\prec</span>  is a total order. There are infinitely many orders, but common ones have descriptive identifiers.</p>

    <p class="text-gray-300">Lex In lexicographical order,  <span class="math">\\mathbf{x}^{\\alpha} \\prec_{\\mathrm{lex}} \\mathbf{x}^{\\beta}</span>  if and only if the first nonzero entry of  <span class="math">\\alpha - \\beta</span>  is negative. In other words,  <span class="math">\\mathbf{x}^{\\alpha} \\prec_{\\mathrm{lex}} \\mathbf{x}^{\\beta}</span>  if and only if there exists  <span class="math">0 \\leqslant i &amp;lt; n</span>  such that  <span class="math">\\alpha_i &amp;lt; \\beta_i</span>  and  <span class="math">\\alpha_j = \\beta_j</span>  for all  <span class="math">0 \\leqslant j &amp;lt; i</span> .</p>

    <p class="text-gray-300">Example 1. In  <span class="math">\\mathbb{F}[x,y,z]</span>  and lex order, we have  <span class="math">xy^2\\prec xy^2 z\\prec x^2 z^2\\prec x^2 yz\\prec x^3</span></p>

    <p class="text-gray-300">Deglex For degree lexicographical or graded lexicographical order, the monomial's total degrees are compared first, with ties broken by lex. In other words,  <span class="math">\\mathbf{x}^{\\alpha} \\prec_{\\mathrm{deglex}} \\mathbf{x}^{\\beta}</span>  if and only if  <span class="math">\\sum_{i} \\alpha_{i} &amp;lt; \\sum_{i} \\beta_{i}</span>  or  <span class="math">\\sum_{i} \\alpha_{i} = \\sum_{i} \\beta_{i}</span>  and  <span class="math">\\mathbf{x}^{\\alpha} \\prec_{\\mathrm{lex}} \\mathbf{x}^{\\beta}</span> .</p>

    <p class="text-gray-300">Example 2 (continued). In deglex order,  <span class="math">xy^2 \\prec x^3 \\prec xy^2 z \\prec x^2 z^2 \\prec x^2 yz</span> .</p>

    <p class="text-gray-300">Degrevlex The degree reverse lexicographical or graded reverse lexicographical order (abbreviated grevlex) also first considers the monomial's total degree. Ties are broken using invlex, which is lex with inversely labeled variables. The outcome of the comparison is reversed, such that invlex-smaller monomials of the same degree are considered degrevlex-greater. In other words,  <span class="math">\\mathbf{x}^{\\alpha} \\prec_{\\mathrm{degrevlex}} \\mathbf{x}^{\\beta}</span>  if and only if either  <span class="math">\\sum_{i} \\alpha_{i} &amp;lt; \\sum_{i} \\beta_{i}</span>  or  <span class="math">\\sum_{i} \\alpha_{i} = \\sum_{i} \\beta_{i}</span>  and  <span class="math">\\mathbf{x}^{\\alpha} \\succ_{\\mathrm{invlex}} \\mathbf{x}^{\\beta}</span> .</p>

    <p class="text-gray-300">Example 3 (continued). In degrevlex order,  <span class="math">xy^2 \\prec x^3 \\prec x^2 z^2 \\prec xy^2 z \\prec x^2 yz</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) lex</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) degrevlex Fig. 1. Two monomial orders over  <span class="math">\\mathbb{F}[x,y]</span> .</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">Definition 3 (Degree refining order). A monomial order  <span class="math">\\prec</span>  is degree refining if for any  <span class="math">\\mathbf{x}^{\\alpha},\\mathbf{x}^{\\beta}</span>  with  <span class="math">\\sum_{i}\\alpha_{i} &amp;lt; \\sum_{i}\\beta_{i}</span> , we have  <span class="math">\\mathbf{x}^{\\alpha}\\prec \\mathbf{x}^{\\beta}</span> .</p>

    <p class="text-gray-300">For example, both deglex and degrevlex are degree refining orders.</p>

    <p class="text-gray-300">Weight orders The most general way to define a monomial order is using a list of weight vectors  <span class="math">\\omega_{i}\\in \\mathbb{R}^{n}</span> , which can be arranged into a weight matrix  <span class="math">M_{\\omega}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\omega} = \\left( \\begin{array}{c} - \\omega_ {0} - \\\\ - \\omega_ {1} - \\\\ \\vdots \\\\ - \\omega_ {m} - \\end{array} \\right)</span></div>

    <p class="text-gray-300">Then,  <span class="math">\\mathbf{x}^{\\alpha} \\prec_{M_{\\omega}} \\mathbf{x}^{\\beta}</span>  if the first non-zero entry of vector  <span class="math">M_{\\omega} \\cdot \\alpha - M_{\\omega} \\cdot \\beta</span>  is negative. In other words, first the weight vector  <span class="math">\\omega_0</span>  is used to try and establish the relation of  <span class="math">\\mathbf{x}^{\\alpha}</span>  and  <span class="math">\\mathbf{x}^{\\beta}</span> , and in case of a tie, subsequent weight vectors are used for comparison.</p>

    <p class="text-gray-300">Example 4. The matrices</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\mathrm {l e x}} = \\left( \\begin{array}{c c c c c} 1 &amp;amp; 0 &amp;amp; \\dots &amp;amp; \\dots &amp;amp; 0 \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ 0 &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; 0 \\\\ 0 &amp;amp; \\dots &amp;amp; \\dots &amp;amp; 0 &amp;amp; 1 \\end{array} \\right), \\qquad M _ {\\mathrm {d e g r e v l e x}} = \\left( \\begin{array}{c c c c c} 1 &amp;amp; \\dots &amp;amp; \\dots &amp;amp; \\dots &amp;amp; 1 \\\\ 0 &amp;amp; \\dots &amp;amp; \\dots &amp;amp; 0 &amp;amp; - 1 \\\\ \\vdots &amp;amp; &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; 0 \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; 0 \\\\ 0 &amp;amp; - 1 &amp;amp; 0 &amp;amp; \\dots &amp;amp; 0 \\end{array} \\right)</span></div>

    <p class="text-gray-300">correspond to lex and degrevlex order, respectively. Note that a monomial order defined by  <span class="math">M_{\\omega}</span>  where  <span class="math">\\omega_0 = c \\cdot \\mathbf{1}</span> ,  <span class="math">c \\in \\mathbb{R} \\setminus \\{0\\}</span> , is a degree refining order.</p>

    <p class="text-gray-300">Any monomial order can be expressed using weight vectors, but not all matrices define a monomial order. A sufficient condition for a matrix  <span class="math">M_{\\omega}</span>  to define a monomial order is  <span class="math">M_{\\omega} \\in \\mathbb{R}^{n \\times n}</span>  with only non-negative entries and the rank of  <span class="math">M_{\\omega}</span>  be full. The example  <span class="math">M_{\\mathrm{degrevlex}}</span>  above shows that this is not a necessary condition. Without further discussion thereof,  <span class="math">\\ker(M) \\cap \\mathbb{Z}^n = \\{0\\}</span>  is such a necessary condition. An extended treatment of weight orders can be found in [37, Ch. 2, §4], [36, Ch. 1, §2], and [59, Sec. 1.2].</p>

    <p class="text-gray-300">Leading term, coefficient, and monomial Fixing any monomial order  <span class="math">\\prec</span>  gives rise to leading terms of polynomials. For  <span class="math">f = \\sum_{\\alpha} c_{\\alpha} \\mathbf{x}^{\\alpha}</span> , the leading term  <span class="math">\\operatorname{lt}(f)</span>  is defined as the  <span class="math">\\prec</span> -maximal non-zero summand of  <span class="math">f</span> , i.e.,  <span class="math">\\operatorname{lt}(f) = \\max_{\\prec} \\{c_{\\alpha} \\mathbf{x}^{\\alpha} \\mid c_{\\alpha} \\neq 0\\}</span> . The leading coefficient  <span class="math">\\mathsf{lc}</span>  and leading monomial  <span class="math">\\mathsf{lm}</span>  of  <span class="math">f</span>  are coefficient and monomial of  <span class="math">\\mathsf{lt}</span> , respectively, i.e.,  <span class="math">\\operatorname{lt}(f) = \\mathsf{lc}(f) \\cdot \\mathsf{lm}(f)</span> . All of  <span class="math">f</span> 's terms smaller than  <span class="math">\\operatorname{lt}(f)</span> , i.e.,  <span class="math">f - \\operatorname{lt}(f)</span> , comprise the tail of  <span class="math">f</span> . Extension of  <span class="math">\\mathsf{lt}</span> ,  <span class="math">\\mathsf{lc}</span> , and  <span class="math">\\mathsf{lm}</span>  to sets of polynomials are defined, e.g.,  <span class="math">\\operatorname{lt}(G) = \\bigcup_{g \\in G} \\operatorname{lt}(g)</span> .</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Definition of Gröbner Bases</h3>

    <p class="text-gray-300">A Gröbner basis of a polynomial Ideal <span class="math">I\\subseteq\\mathbb{F}[\\mathbf{x}]</span> is a finite set of polynomials <span class="math">G=\\{g_{0},\\ldots,g_{t-1}\\}</span> such that <span class="math">\\langle g_{0},\\ldots,g_{t-1}\\rangle=I</span> and such that <span class="math">G</span> has “nice” computational properties. For example, ideal membership <span class="math">f\\in I</span> can be decided easily with a Gröbner basis; determining inclusion or equivalence of ideals is straightforward (a direct consequence); and projecting <span class="math">I</span> into a ring with fewer variables is trivial for certain monomial orders. Perhaps most relevant for cryptanalysis is computing solutions of the underlying polynomial equations <span class="math">g_{i}=0</span>. This is straightforward for Gröbner bases in lex order, as we shall see in Section 2.3.</p>

    <p class="text-gray-300">Leading up to the definitions of Gröbner basis, the concepts of polynomial reduction and (fully reduced) remainders are useful. In essence, reducing one polynomial by a (set of) polynomials is a generalization of long division for univariate polynomials. Results of such reductions are not generally unique. However, uniqueness of remainders after reduction is guaranteed if the set of divisors is a Gröbner basis – another “nice” property. In the following, let <span class="math">f</span> be a polynomial, <span class="math">G=\\{g_{0},\\ldots,g_{t-1}\\}</span> a finite set of polynomials, and <span class="math">\\prec</span> a monomial order.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 4 (Polynomial reduction).</h6>

    <p class="text-gray-300">We say <span class="math">G</span> reduces <span class="math">f</span> to <span class="math">r</span> if there are polynomials <span class="math">r,q_{0},\\ldots,q_{t-1}\\in\\mathbb{F}[\\mathbf{x}]</span> such that <span class="math">f=\\sum_{i}q_{i}g_{i}+r</span> and <span class="math">\\mathsf{lm}(r)\\prec\\mathsf{lm}(f)</span>. Polynomial <span class="math">r</span> is called the <em>remainder</em> of the reduction of <span class="math">f</span> by <span class="math">G</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Note 1.</h6>

    <p class="text-gray-300">Polynomials <span class="math">q_{i}</span> can be efficiently computed using multivariate polynomial division. Such a division algorithm is reproduced in Appendix B.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 5 (Fully reduced).</h6>

    <p class="text-gray-300">We say <span class="math">r</span> is <em>fully reduced</em> with respect to <span class="math">G</span> if no further reduction of <span class="math">r</span> by <span class="math">G</span> is possible. In other words, no leading monomial of any element in <span class="math">G</span> divides any monomial of <span class="math">r</span>: <span class="math">\\forall l\\in\\mathsf{lm}(G),\\forall m\\in\\mathcal{M}(r):l\\not\\lvert\\,m</span>.</p>

    <p class="text-gray-300">We write <span class="math">f\\overset{\\rightarrow}{\\longrightarrow}r</span> to denote <em>full reduction</em> of <span class="math">f</span> by <span class="math">G</span> resulting in <span class="math">r</span>, i.e., such that <span class="math">r</span> is fully reduced with respect to <span class="math">G</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Example 5.</h6>

    <p class="text-gray-300">Fix monomial order lex. Let <span class="math">f=x^{2}y^{2}+y^{2}z^{2}-2y^{2}z</span> and <span class="math">G=\\{x^{2}y-2yz,y^{2}-z^{2},xz^{2}\\}</span>. For <span class="math">q_{0}=y,q_{1}=z^{2},q_{2}=0</span>, we have <span class="math">f=\\sum_{i}q_{i}g_{i}+z^{4}</span>. Since no element of <span class="math">\\mathsf{lm}(G)=\\{x^{2}y,y^{2},xz^{2}\\}</span> divides <span class="math">z^{4}</span>, the remainder <span class="math">z^{4}</span> is fully reduced with respect to <span class="math">G</span>. We can write <span class="math">f\\overset{\\rightarrow}{\\longrightarrow}z^{4}</span>.</p>

    <p class="text-gray-300">In general, the remainder <span class="math">r</span> after full reduction of <span class="math">f</span> is not unique. For example, choosing <span class="math">q_{0}=0,q_{1}=x^{2}+z^{2}-2z,q_{2}=x</span> above, we have full reduction <span class="math">f\\overset{\\rightarrow}{\\longrightarrow}z^{4}-2z^{3}</span>. However, reducing a polynomial by a Gröbner basis guarantees uniqueness of the remainder. In fact, this is one way to define Gröbner bases.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 6 (Gröbner basis by remainder).</h6>

    <p class="text-gray-300"><span class="math">G</span> is a Gröbner basis for I if and only if <span class="math">\\langle G\\rangle=I</span> and the remainder after full reduction by <span class="math">G</span> of any <span class="math">f\\in\\mathbb{F}[\\mathbf{x}]</span> is unique.</p>

    <p class="text-gray-300">An equivalent albeit less intuitive definition pertains to the leading monomials of <span class="math">G</span> and of elements of <span class="math">\\langle G\\rangle=I</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 7 (Gröbner basis by leading monomials).</h6>

    <p class="text-gray-300"><span class="math">G</span> is a Gröbner basis for <span class="math">I</span> if and only if <span class="math">\\langle G\\rangle=I</span> and <span class="math">\\langle\\mathsf{lm}(G)\\rangle=\\langle\\mathsf{lm}(I)\\rangle</span>.</p>

    <p class="text-gray-300">In other words, the ideal generated by the leading monomials of <span class="math">G</span> is equal to the ideal generated by the leading monomials of all elements of <span class="math">I</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Definitions 6 and 7 are equivalent.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">“<span class="math">7\\Rightarrow 6</span>”:</p>

    <p class="text-gray-300">Fully reducing <span class="math">f\\in\\mathbb{F}[\\mathbf{x}]</span> by <span class="math">G</span> gives <span class="math">r</span> such that <span class="math">f=g+r</span>, <span class="math">g=\\sum_{i=0}^{t-1}q_{i}g_{i}</span>, and <span class="math">\\mathsf{lm}(r)\\prec\\min_{i}(\\mathsf{lm}(g_{i}))</span>. Suppose there is another full reduction by <span class="math">G</span>, i.e., <span class="math">f=g^{\\prime}+r^{\\prime}</span> for <span class="math">g^{\\prime}=\\sum_{i=0}^{t-1}q_{i}^{\\prime}g_{i}</span>, resulting in different remainder <span class="math">r^{\\prime}\\neq r</span>. Then, the difference of the remainders <span class="math">r-r^{\\prime}=g^{\\prime}-g</span> is an element of <span class="math">I</span>. Consequently, the leading monomial of <span class="math">r-r^{\\prime}</span> is in <span class="math">\\langle\\mathsf{lm}(I)\\rangle</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\langle\\mathsf{lm}(I)\\rangle</span> is generated by monomials, <span class="math">\\mathsf{lm}(r-r^{\\prime})\\in\\langle\\mathsf{lm}(I)\\rangle</span> implies divisibility of <span class="math">\\mathsf{lm}(r-r^{\\prime})</span> by one of the basis elements of <span class="math">\\langle\\mathsf{lm}(I)\\rangle</span>. Since <span class="math">\\langle\\mathsf{lm}(I)\\rangle=\\langle\\mathsf{lm}(g_{0}),\\ldots,\\mathsf{lm}(g_{t-1})\\rangle</span>, this basis element is some <span class="math">\\mathsf{lm}(g_{i})</span>, i.e., <span class="math">\\mathsf{lm}(g_{i})\\mid\\mathsf{lm}(r-r^{\\prime})</span> and thus <span class="math">\\mathsf{lm}(g_{i})\\preceq\\mathsf{lm}(r-r^{\\prime})</span> for some <span class="math">g_{i}</span>. This contradicts <span class="math">\\mathsf{lm}(r-r^{\\prime})\\preceq\\max(\\mathsf{lm}(r),\\mathsf{lm}(r^{\\prime}))\\prec min_{i}(\\mathsf{lm}(g_{i}))</span>, proving <span class="math">r=r^{\\prime}</span> and thus uniqueness of the remainder.</p>

    <p class="text-gray-300">“<span class="math">6\\Rightarrow 7</span>”:</p>

    <p class="text-gray-300">Since <span class="math">\\langle\\mathsf{lm}(G)\\rangle</span> and <span class="math">\\langle\\mathsf{lm}(I)\\rangle</span> are both generated by monomials, showing their equality in terms of polynomial membership can be reduced to equality in terms of monomial membership, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\forall m\\in\\mathcal{M}:m\\in\\langle\\mathsf{lm}(G)\\rangle\\Leftrightarrow m\\in\\langle\\mathsf{lm}(I)\\rangle.</span> (1)</p>

    <p class="text-gray-300">To see that this reduction is valid, take polynomial <span class="math">f=\\sum_{\\boldsymbol{\\alpha}}c_{\\boldsymbol{\\alpha}}\\mathbf{x}^{\\boldsymbol{\\alpha}}\\in\\mathbb{F}[\\mathbf{x}]</span>. Then, <span class="math">f</span> is in <span class="math">\\langle\\mathsf{lm}(I)\\rangle</span> if and only if every <span class="math">\\mathbf{x}^{\\boldsymbol{\\alpha}}</span> is in <span class="math">\\langle\\mathsf{lm}(I)\\rangle</span>. Likewise, <span class="math">f</span> is in <span class="math">\\langle\\mathsf{lm}(G)\\rangle</span> if and only if every <span class="math">\\mathbf{x}^{\\boldsymbol{\\alpha}}</span> is in <span class="math">\\langle\\mathsf{lm}(G)\\rangle</span>. Therefore, it suffices to show that full reduction by <span class="math">G</span> leaving unique remainders implies Equation 1.</p>

    <p class="text-gray-300">Let <span class="math">f</span> be a nonzero monomial, i.e., <span class="math">\\mathsf{lm}(f)=f</span>, and <span class="math">f\\underset{G}{\\longrightarrow}r</span>. Distinguish 3 cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f\\prec\\mathsf{lm}(r)</span>.</li>

    </ol>

    <p class="text-gray-300">This case contradicts <span class="math">r</span> being the result of a reduction.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f=\\mathsf{lm}(r)</span>.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">f=r\\notin\\langle G\\rangle</span> because no reduction took place. Suppose <span class="math">f\\in\\langle\\mathsf{lm}(G)\\rangle</span>. Then <span class="math">f=\\sum q_{i}\\mathsf{lm}(g_{i})</span> for some <span class="math">q_{i}</span>, and since <span class="math">f</span> is a monomial, only one term in this sum remains, meaning <span class="math">f=q_{i}\\mathsf{lm}(g_{i})</span> for some <span class="math">i</span>. This contradicts no reduction haven taken place. Thus <span class="math">f\\notin\\langle\\mathsf{lm}(G)\\rangle</span>. Suppose <span class="math">f\\in\\langle\\mathsf{lm}(\\langle G\\rangle)\\rangle</span> so that <span class="math">f=\\mathsf{lm}(\\sum q_{i}g_{i})</span> for some <span class="math">q_{i}</span>. By “undropping” trailing terms, <span class="math">f=\\sum q_{i}g_{i}-r^{\\prime}</span> with <span class="math">\\mathsf{lm}(r^{\\prime})\\prec f</span>. If <span class="math">r^{\\prime}\\neq 0</span>, it is a second remainder. If <span class="math">r^{\\prime}=0</span> then <span class="math">f\\in\\langle G\\rangle</span>. Both are contradictions, so <span class="math">f\\notin\\langle\\mathsf{lm}(I)\\rangle</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f\\succ\\mathsf{lm}(r)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then <span class="math">f-r\\in\\langle G\\rangle</span> and <span class="math">f=\\mathsf{lm}(f)\\in\\langle\\mathsf{lm}(I)\\rangle</span>. Also <span class="math">f=\\sum q_{i}g_{i}+r</span> so some $\\mathsf{lm}(g_{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f<span class="math"> and </span>f\\in\\langle\\mathsf{lm}(G)\\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">\\mathcal{M}</span> $\\mathcal{M}(G)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(G)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(G)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(G)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\subset\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap\\mathcal{M}(I)\\cap</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">monomial of the S-polynomial is greater in the specified order, i.e.,  <span class="math">\\mathsf{Im}(S(f,g)) = xyz^2\\succ_{\\mathrm{deglex}}x^2 y = \\max \\{\\mathsf{Im}(f),\\mathsf{Im}(g)\\}</span> .</p>

    <p class="text-gray-300">By construction, the S-polynomial of  <span class="math">f_{i}, f_{j} \\in \\mathcal{F}</span>  lies in the ideal  <span class="math">\\langle \\mathcal{F} \\rangle</span> . Thus, if  <span class="math">\\mathcal{F}</span>  is a Gröbner basis, full reduction of  <span class="math">S(f_{i}, f_{j})</span>  for any  <span class="math">f_{i}, f_{j}</span>  will leave the unique remainder 0, as per Definition 6. Conversely, if the same full reduction results in  <span class="math">r \\neq 0</span> , then  <span class="math">\\mathcal{F}</span>  is not a Gröbner basis. In fact, we just articulated what is known as Buchberger's criterion for testing if a set of polynomials is a Gröbner basis. It turns out that Gröbner bases can be defined in terms of this criterion. The resulting notion is equivalent to Definitions 6 and 7 but requires only a finite number of checks to determine whether a set of polynomials  <span class="math">\\mathcal{F}</span>  is a Gröbner basis for  <span class="math">\\langle \\mathcal{F} \\rangle</span> .</p>

    <p class="text-gray-300">Theorem 2 (Buchberger's criterion).  <span class="math">G</span>  is a Gröbner basis for  <span class="math">\\langle G \\rangle</span>  if and only if  <span class="math">S(g_i, g_j) \\xrightarrow{G} 0</span>  for all critical pairs  <span class="math">(g_i, g_j) \\in G \\times G</span> .</p>

    <p class="text-gray-300">Proof. For a full proof, we refer to [20, 23, 37].</p>

    <p class="text-gray-300">Given that  <span class="math">S(f_{i},f_{j}) \\in \\langle \\mathcal{F} \\rangle</span> , remainder  <span class="math">r</span>  of  <span class="math">S(f_{i},f_{j})</span>  after full reduction by  <span class="math">\\mathcal{F}</span>  is also an element of  <span class="math">\\langle \\mathcal{F} \\rangle</span> . Thus, adding  <span class="math">r</span>  to  <span class="math">\\mathcal{F}</span>  does not change the ideal  <span class="math">\\langle \\mathcal{F} \\rangle</span> , but intuitively makes  <span class="math">\\mathcal{F}</span>  be "closer" to a Gröbner basis. This is the basic idea of Buchberger's algorithm [20, 23], shown in Algorithm 1.</p>

    <p class="text-gray-300">Intuitively, the algorithm's correctness follows directly from Buchberger's criterion. Showing termination is a little trickier. One essential ingredient is Hilbert's basis theorem [62], which implies that a Gröbner basis is always finite [37, Ch. 2, §5, Corr. 6]. Additionally, one needs to show that including a non-zero remainder of reducing an S-polynomial by a preliminary Gröbner basis brings us "closer" to a Gröbner basis. For proofs of correctness and termination, we refer to [20, 23, 37].</p>

    <p class="text-gray-300">Algorithm 1: BUCHBERGER'S ALGORITHM Input:  <span class="math">\\mathcal{F} = \\{f_0,\\dots ,f_{s - 1}\\} \\subseteq \\mathbb{F}[\\mathbf{x}]</span> Output: a Gröbner basis  <span class="math">G</span>  for  <span class="math">\\langle f_0,\\ldots ,f_{s - 1}\\rangle</span> 1  <span class="math">G = \\emptyset</span> 2  <span class="math">G^{\\prime} = F</span> 3 while  <span class="math">G\\neq G^{\\prime}</span>  do 4  <span class="math">G = G^{\\prime}</span> 5 foreach  <span class="math">(g_i,g_j)</span>  in  <span class="math">G\\times G</span>  do // critical pair 6  <span class="math">r = (\\mathrm{any})</span>  full reduction of  <span class="math">S(g_i,g_j)</span>  by  <span class="math">G</span>  //  <span class="math">S(g_i,g_j)\\to \\gamma r</span> 7 if  <span class="math">r\\neq 0</span>  then 8  <span class="math">\\begin{array}{r}\\lfloor G^{\\prime} = G^{\\prime}\\cup \\{r\\} \\end{array}</span> 9 return  <span class="math">G</span></p>

    <p class="text-gray-300">The complexity of Algorithm 1 is quite difficult to estimate since many choices - the monomial order, the order of selecting pairs  <span class="math">(g_i, g_j)</span> , and others -</p>

    <p class="text-gray-300">can influence execution dramatically. A lot of work has been put into finding upper and lower complexity bounds for Gröbner basis computations, independent of the algorithm. The general measure of this complexity is by the highest total degree <span class="math">d_{\\max}</span> among the polynomials in the Gröbner basis <span class="math">G</span> for some ideal <span class="math">I</span>, i.e., <span class="math">d_{\\max}=\\max\\{\\deg(g)\\mid g\\in G\\}</span>. Bounds exist for different input parameters, like the number <span class="math">s</span> of input polynomials <span class="math">\\{f_{0},\\ldots,f_{s-1}\\}</span>, their total degrees <span class="math">d_{i}=\\deg(f_{i})</span> with maximum <span class="math">d=\\max\\{d_{i}\\}</span>, the degrees’ arithmetic mean <span class="math">D</span>, or the dimension of the ideal <span class="math">\\dim(I)</span>. For the special case of underdetermined systems, i.e., <span class="math">s\\leqslant n</span>, <span class="math">d_{\\max}</span> is not greater than the <em>Bézout bound</em>, defined as the product of all <span class="math">d_{i}</span>, i.e., <span class="math">d_{\\max}\\leqslant\\prod_{i}d_{i}</span> <em>[69, Thm. 1]</em>. More generally, <span class="math">d_{\\max}</span> is doubly exponential in the number of variables, i.e., <span class="math">d_{\\max}\\leqslant 2\\left(\\frac{1}{2}d^{2}+d\\right)^{2^{n-1}}</span><em>[43]</em>, and this bound is tight in the worst-case <em>[72]</em>. A more recent bound is <span class="math">d_{\\max}\\leqslant d^{n^{\\Theta(1)}2^{\\Theta(\\dim(I))}}</span> <em>[73]</em>, depending also on the dimension of <span class="math">I</span>. For the special case of a zero-dimensional ideal, an even sharper bounds exists, with <span class="math">d_{\\max}</span> polynomial in <span class="math">\\max\\{S,D^{n}\\}</span>, where <span class="math">S</span> is the size of the input polynomials in dense representation and <span class="math">D</span> the arithmetic mean <span class="math">\\frac{\\sum d_{i}}{s}</span> <em>[61]</em>. A lower bound is <span class="math">d_{\\max}\\geqslant d^{2^{n/z}}</span> for sufficiently large <span class="math">n</span> and <span class="math">d</span> <em>[84]</em>.</p>

    <p class="text-gray-300">While these results paint a bleak picture for the worst case, Gröbner bases for many polynomial systems arising from “real-world” scenarios <em>can</em> be computed. Algorithms for this problem have improved dramatically over the last decades. Some of the most important ones are surveyed in Section 3.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.3 Computing <span class="math">V(I)</span> from <span class="math">G_{\\text{lex}}</span></h3>

    <p class="text-gray-300">Equipped with the tools to compute Gröbner bases, we can come back to what we originally set out to do: breaking a cryptographic primitive by efficiently computing solutions to the system of polynomials <span class="math">\\mathcal{F}</span> that model it, i.e., elements of the variety <span class="math">V(\\langle\\mathcal{F}\\rangle)</span>. Gröbner bases in <em>lex</em> order make it especially easy to achieve this. In this section, we provide intuition and an algorithm for the process of finding the variety’s elements. While applicable in greater generality, for this paper we are only interested in the case of <span class="math">\\mathbb{F}</span> being a finite field. For the theoretical background, we refer to <em>[37, Ch. 3, §1]</em>, which is treating <em>elimination ideals</em>, the <em>elimination theorem</em>, and the <em>extension theorem</em>, and uses these tools to prove the algorithm’s correctness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One more piece of terminology regarding a system’s number of solutions $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(\\mathcal{F})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ frequently occurs in the context of Gröbner basis theory.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 11 (Zero-dimensional ideal).</h6>

    <p class="text-gray-300">An ideal <span class="math">I</span> is <em>zero-dimensional</em> if and only if its variety <span class="math">V(I)</span> has finitely many elements.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 2.</h6>

    <p class="text-gray-300">Let <span class="math">I\\subseteq\\mathbb{F}_{q}[\\mathbf{x}]</span> be some ideal and <span class="math">\\mathcal{E}_{q}^{n}=\\langle x_{i}^{q}-x_{i}\\mid 0\\leqslant i&lt;n\\rangle</span> the ideal generated by all field equations. Then, <span class="math">I\\cup\\mathcal{E}_{q}^{n}</span> is zero-dimensional.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since <span class="math">V(I\\cup\\mathcal{E}_{q}^{n})=V(I)\\cap\\mathbb{F}_{q}^{n}</span>, we have <span class="math">\\dim(I\\cup\\mathcal{E}_{q}^{n})=0</span>. ∎</p>

    <p class="text-gray-300">A reduced <em>lex</em> ordered Gröbner basis <span class="math">G_{\\text{lex}}</span> of a zero-dimensional ideal has exactly one polynomial <span class="math">g</span> that is univariate in the <em>lex</em>-greatest variable <span class="math">x_{n-1}</span> *[36,</p>

    <p class="text-gray-300">Ch. 2, §3]. A root <span class="math">a_{n-1}</span> of <span class="math">g</span> can be the rightmost coordinate of an element <span class="math">(a_{0},\\ldots,a_{n-1})\\in V(I)</span>, and all such rightmost coordinates are roots of <span class="math">g</span>. That is, the roots of <span class="math">g</span> are a superset of the partial solutions to the system of equations defining <span class="math">I</span>. Substituting variable <span class="math">x_{n-1}</span> in <span class="math">G_{\\text{lex}}</span> by <span class="math">a_{n-1}</span> corresponds to a projection of <span class="math">I</span> into <span class="math">\\mathbb{F}[x_{0},\\ldots,x_{n-2}]</span>, a polynomial ring with one variable less. This substitution <span class="math">G_{\\text{lex}}(x_{n-1}=a_{n-1})</span> results in a new Gröbner basis, also in lex order, for <span class="math">I\\cap\\mathbb{F}[x_{0},\\ldots,x_{n-2}]</span>. Thus, above steps can be applied recursively until all variables have been eliminated. An element of <span class="math">V(I)</span> is then given by the univariate roots <span class="math">a_{i}</span> used for projection at each level of recursion. Backtracking to iterate over all roots generates all of <span class="math">V(I)</span>. A more formal description is given in Algorithm 2, and an example execution trace in Example 7 and Figure 2.</p>

    <p class="text-gray-300">Algorithm 2: Variety from <span class="math">G_{\\text{lex}}</span> Input: Gröbner basis <span class="math">G_{\\text{lex}}</span> of zero-dimensional ideal in lex order, number of variables <span class="math">n</span> Output: Variety <span class="math">V(\\langle G_{\\text{lex}}\\rangle)</span> 1 if <span class="math">n=0</span> then // only constants in <span class="math">G_{\\text{lex}}</span>: recursion ends 2 return {( )} // empty tuple, start of full solution 3 <span class="math">V=\\varnothing</span> 4 gcd_poly = gcd of all <span class="math">g_{i}\\in G</span> univariate in <span class="math">x_{n-1}</span> 5 partial_solutions = roots(gcd_poly) // intersection of roots of the <span class="math">g_{i}</span> 6 foreach root in partial_solutions do 7 <span class="math">G_{\\text{proj}}=G_{\\text{lex}}(x_{n-1}=\\text{root})</span> // project into <span class="math">\\mathbb{F}[x_{0},\\ldots,x_{n-2}]</span> 8 rest_of_solution = Variety from <span class="math">G_{\\text{lex}}(G_{\\text{proj}},\\,n-1)</span> 9 <span class="math">V=V\\cup\\{(s_{0},\\ldots,s_{n-2},\\text{root})\\mid\\textbf{s}\\in\\text{rest\\_of\\_solution}\\}</span> 10 return <span class="math">V</span></p>

    <p class="text-gray-300">In Line 5 of Algorithm 2, univariate root finding is used as a black-box subroutine. Efficient algorithms for this well-studied problem are, for example, Berlekamp’s algorithm <em>[17]</em>, the Cantor-Zassenhaus algorithm <em>[32]</em>, the Kaltofen-Shoup algorithm <em>[67]</em>, and Kedlaya-Umans improvements thereof <em>[68]</em>. The Kedlaya-Umans algorithm is the fastest currently known algorithm for finding univariate roots. It has complexity of <span class="math">d^{1.5}+d\\log q</span> operations in <span class="math">\\mathbb{F}_{q}</span> for polynomials of degree <span class="math">d</span> <em>[54, p. 405]</em>. An excellent introduction to the topic can be found in <em>[54, Ch. 14]</em>.</p>

    <p class="text-gray-300">In Line 4, parasitical solutions not lying in <span class="math">\\mathbb{F}_{q}</span> but in algebraic closure <span class="math">\\overline{\\mathbb{F}}_{q}</span> can be discarded by also including field equation <span class="math">x_{n-1}^{q}-x_{n-1}</span> in the gcd.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Example 7.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}[\\mathbf{x}]=\\mathbb{R}[x,y,z]</span> and</p>

    <p class="text-gray-300"><span class="math">f_{0}=x-y,\\quad f_{1}=xyz,\\quad f_{2}=x^{2}+y^{2}+z^{2}-1,</span></p>

    <p class="text-gray-300">the zeros of which respectively describe the “diagonal” plane <span class="math">x=y</span>, the union of the three planes separating the octants, and the unit sphere. Set <span class="math">I=\\langle f_{0},f_{1},f_{2}\\rangle</span></p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">The reduced Gröbner basis for  <span class="math">I</span>  in lex order is given by  <span class="math">G_{\\mathrm{lex}} = \\{g_0, g_1, g_2\\}</span>  with</p>

    <div class="my-4 text-center"><span class="math-block">g _ {0} = x - y, \\quad g _ {1} = y ^ {2} - 0. 5 z ^ {2} - 0. 5, \\quad g _ {2} = z ^ {3} - z.</span></div>

    <p class="text-gray-300">We have  <span class="math">g_0 = f_0</span>  describing the same plane as above. The zeroes of  <span class="math">g_1</span>  describe an elliptic cylinder along the  <span class="math">x</span> -axis, and the zeroes of  <span class="math">g_2</span>  are three planes coinciding with or orthogonal to the  <span class="math">x-y</span> -plane. Running Algorithm 2 on  <span class="math">G_{\\mathrm{lex}}</span>  results in the execution trace given in Figure 2. Reading out the four solutions, we have  <span class="math">V(I) = \\{\\pm (0,0,1), \\pm (1/\\sqrt{2}, 1/\\sqrt{2}, 0)\\}</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. Example execution trace of Algorithm 2 for Example 7.</p>

    <p class="text-gray-300">Note 2. Given a set of univariate polynomials  <span class="math">f_{i}(x)</span> , the Euclidean algorithm computes their polynomial gcd, containing exactly all shared factors. The roots of this gcd are those roots shared by all the  <span class="math">f_{i}</span> . In the multivariate case, the gcd of some  <span class="math">f_{i}(\\mathbf{x})</span>  is not defined since  <span class="math">\\mathbb{F}[x_0,\\ldots ,x_{n - 1}]</span>  is not generally a Euclidean domain for  <span class="math">n &amp;gt; 2</span> . The variety  <span class="math">V</span>  of the ideal spanned by the  <span class="math">f_{i}(\\mathbf{x})</span> , efficiently computable given a Gröbner basis, contains all  <span class="math">\\pmb{a}</span>  for which all  <span class="math">f_{i}</span>  evaluate to 0, the property of a shared root. Gröbner basis algorithms are thus a multivariate generalization of the Euclidean algorithm.</p>

    <p class="text-gray-300">Note 3. The number of elements in a lex Gröbner basis  <span class="math">G</span>  for ideal  <span class="math">I</span>  generally tends to be (much) larger than the number of polynomials  <span class="math">f_{i}</span>  originally defining  <span class="math">I</span> , even though Example 7 does not show this phenomenon.</p>

    <p class="text-gray-300">Note 4. A Gröbner basis  <span class="math">G_{\\mathrm{lex}}</span>  for ideal  <span class="math">I</span>  in lex order contains a lot more information than strictly necessary for, say, multivariate polynomial division having unique remainders. In particular,  <span class="math">G_{\\mathrm{lex}}</span>  allows to easily compute a Gröbner basis</p>

    <p class="text-gray-300">for the intersection <span class="math">I\\cap\\mathbb{F}[x_{0},\\ldots,x_{\\ell}]</span> for <span class="math">\\ell&lt;n</span>, simply by dropping all elements of <span class="math">G_{\\text{lex}}</span> containing variables greater than <span class="math">x_{\\ell}</span>. Computing a Gröbner basis for such an intersection using a degree refining order, like <em>degrevlex</em>, is not straightforward. This intuitively – albeit not rigorously – explains why computing a Gröbner basis in <em>lex</em> order is generally much more difficult than computing a Gröbner basis in, say, <em>degrevlex</em> order <em>[15]</em>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3 Computing Gröbner Bases</h2>

    <p class="text-gray-300">In the previous section, we presented a generic way to compute a Gröbner basis, namely Buchberger’s algorithm. Directly using this algorithm is usually too inefficient to be of any practical use. This is because Buchberger’s algorithm performs a lot of unnecessary reductions, i.e., reductions where the remainder is zero. Improvements to Buchberger’s algorithm exist, mostly in the form of criteria predicting when a critical pair reduces to zero. This allows the algorithm to discard such a pair before the costly reduction step is being performed <em>[21, 55, 57, 79]</em>.</p>

    <p class="text-gray-300">The two Gröbner basis algorithms <span class="math">F_{4}</span> and <span class="math">F_{5}</span> have structural similarities to Buchberger’s algorithm, but use a number of additional concepts. Since they constitute the state of the art, especially for attacking AOCs, we present them in detail in Sections 3.1 and 3.2. Furthermore, the algorithms <em>eXtended Linearization</em> (XL) and <em>Mutant XL</em>, both of which directly compute elements of an ideal’s variety, are explained in Section 3.3. Other approaches, for example <em>Slimgb</em> <em>[19]</em>, <em>MMM</em> <em>[71]</em>, or <em>M4GB</em> <em>[65]</em>, as well as concepts like <em>dynamic</em> Gröbner basis algorithms <em>[28, 30, 80]</em>, are not discussed in this document.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.1 F_{4}</h3>

    <p class="text-gray-300">Buchberger’s algorithm considers every combination of two elements from the working Gröbner basis, computes this critical pair’s S-polynomial, and reduces that S-polynomial by the working basis to check whether it reduces to zero. For every reduction, polynomial division by the working basis is started “from scratch,” potentially performing the same computation more than once. For example, if we first reduce some <span class="math">f</span> to <span class="math">0</span>, any polynomial multiple <span class="math">g</span> of <span class="math">f</span> will also reduce to <span class="math">0</span> and we know this if <span class="math">g</span> has been reduced to <span class="math">f</span>. The Gröbner basis algorithm F_{4} due to Faugère leverages such prior reductions by <em>batching</em>. More concretely, the coefficients of multiple S-Polynomials are put into a specially crafted matrix, the echelon row-reduced form of which yields their fully reduced remainders. This results in an overall faster Gröbner basis algorithm because (1) multiple S-polynomials are being reduced at the same time, enabling the re-use of intermediary results, and (2) existing fast linear algebra techniques and implementations can be used. We motivate the inner workings of F_{4} by introducing the <em>Macaulay matrix</em> of a set of polynomials, which is a more general concept than the matrices used in F_{4}.</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">Definition 12 (Macaulay matrix [70, Notation 3]). Given a set of polynomials  <span class="math">\\mathcal{F} \\subseteq \\mathbb{F}[\\mathbf{x}]</span>  and monomial order  <span class="math">\\prec</span> , the Macaulay matrix  <span class="math">M_d(\\mathcal{F})</span>  of degree  <span class="math">d</span>  is a matrix with coefficients in  <span class="math">\\mathbb{F}</span> . Let  <span class="math">\\mathbf{x}_d</span>  denote the  <span class="math">\\prec</span> -greatest monomial of total degree  <span class="math">d</span> . The  <span class="math">\\binom{n+d}{n}</span>  columns are labeled by all monomials  <span class="math">\\mathbf{x}^{\\alpha}</span>  with  <span class="math">\\mathbf{x}^{\\alpha} \\preceq \\mathbf{x}_d</span>  and sorted, from left to right, in  <span class="math">\\prec</span> -descending order. The rows are labeled by all monomial multiples  <span class="math">\\mathbf{x}^{\\beta}f_i</span> ,  <span class="math">f_i \\in \\mathcal{F}</span> , such that  <span class="math">lt(\\mathbf{x}^{\\beta}f_i) \\preceq \\mathbf{x}_d</span> . Entry  <span class="math">m_{k,l}</span>  of  <span class="math">M_d(\\mathcal{F})</span>  is the coefficient of monomial  <span class="math">\\mathbf{x}^{\\alpha}</span>  in polynomial  <span class="math">\\mathbf{x}^{\\beta}f_i</span> , where  <span class="math">\\mathbf{x}^{\\alpha}</span>  is the label of column  <span class="math">l</span>  and  <span class="math">\\mathbf{x}^{\\beta}f_i</span>  is the label of row  <span class="math">k</span> .</p>

    <p class="text-gray-300">Example 8. For degrevlex order, the Macaulay matrix of degree 2 of bivariate polynomials  <span class="math">\\mathcal{F} = \\{f_0, f_1\\} = \\{x^2 + y^2, x + 2y\\} \\subseteq \\mathbb{F}[x, y]</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">M _ {2} (\\mathcal {F}) = \\begin{array}{c c c c c c} &amp;amp; x ^ {2} &amp;amp; x y &amp;amp; y ^ {2} &amp;amp; x &amp;amp; y \\\\ f _ {0} &amp;amp; 1 &amp;amp; &amp;amp; 1 &amp;amp; &amp;amp; \\\\ f _ {1} &amp;amp; &amp;amp; &amp;amp; &amp;amp; 1 &amp;amp; 2 \\\\ y f _ {1} &amp;amp; &amp;amp; 1 &amp;amp; 2 &amp;amp; &amp;amp; \\\\ x f _ {1} &amp;amp; 1 &amp;amp; 2 &amp;amp; &amp;amp; &amp;amp; \\end{array} .</span></div>

    <p class="text-gray-300">Performing a row operation on a Macaulay matrix such that a non-zero coefficient gets canceled, corresponds to one step in the polynomial reduction algorithm. Thus, computing the row-reduced echelon form of a Macaulay matrix corresponds to full polynomial reduction of all polynomials by all polynomials. If the Macaulay matrix  <span class="math">M_{d}(\\mathcal{F})</span>  is of high enough degree  <span class="math">d</span> , its row-reduced echelon form gives rise to a Gröbner basis for  <span class="math">\\mathcal{F}</span>  [69, Sec. III B]. However, the combination of two problems makes this approach intractable in practice: (1) Not knowing beforehand which degree  <span class="math">d</span>  is high enough, and (2) the roughly cubic complexity of echelon row-reducing a matrix.</p>

    <p class="text-gray-300">For these reasons, the  <span class="math">\\mathrm{F}_4</span>  algorithm does not reduce the Macaulay matrix. Instead, a matrix  <span class="math">M</span>  containing just enough information for full polynomial reduction of a subset of the critical pairs is constructed at each step. Intuitively,  <span class="math">M</span>  is a less verbose version of a Macaulay matrix, where rows and columns not contributing to the polynomial reduction are not included. This omission decreases computation time and memory requirements. The relevant rows are those corresponding to polynomials that might at some point during the polynomial division process cancel some monomial. Also,  <span class="math">M</span>  does not contain any zero-columns, like the column with label "1" in Example 8. A formal description of which polynomials are included is given in subroutine "Symbolic Preprocessing" in Algorithm 3.</p>

    <p class="text-gray-300">The matrix  <span class="math">M</span>  and the insight that computing its row-reduced echelon form corresponds to full polynomial reduction of all its polynomials are the reasons  <span class="math">\\mathrm{F}_4</span>  is so much more efficient than Buchberger's algorithm. The question of which polynomials to include in  <span class="math">M</span>  gives rise to the selection strategy. Many selection strategies exist [46, Sec. 2.5], really making  <span class="math">\\mathrm{F}_4</span>  a family of algorithms. The fastest strategy in practice, thus dubbed the normal strategy, is to pick those pairs  <span class="math">\\{i,j\\}</span></p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">Algorithm 3: SYMBOLIC PREPROCESSING Input: S-Polynomial "halves"  <span class="math">L\\subseteq \\mathbb{F}[\\mathbf{x}]</span>  , working Gröbner basis  <span class="math">G</span>  Output:  <span class="math">M</span> 1 processed_monons  <span class="math">= \\mathsf{lm}(L)</span> 2 while processed_monons  <span class="math">\\neq \\mathcal{M}(L)</span>  do 3  <span class="math">\\mathbf{x}^{\\beta} = \\max_{\\prec}\\{\\mathcal{M}(L)\\setminus</span>  processed_monons} 4 processed_monons  <span class="math">=</span>  processed_monons  <span class="math">\\cup \\{\\mathbf{x}^{\\beta}\\}</span> 5 if  <span class="math">\\exists g\\in G</span>  such that  <span class="math">\\mathsf{lm}(g)\\mid \\mathbf{x}^{\\beta}</span>  then 6 L=LU  <span class="math">\\left\\{\\frac{\\mathbf{x}^{\\beta}}{\\mathsf{lm}(g)}\\cdot g\\right\\}</span> 7  <span class="math">M =</span>  matrix with columns labeled by  <span class="math">\\mathcal{M}(L)</span>  in  <span class="math">\\prec</span>  decreasing order, rows are respective coefficients of elements of  <span class="math">L</span> 8 return  <span class="math">M</span></p>

    <p class="text-gray-300">with lowest total degree of  <span class="math">\\operatorname{lcm}(\\mathsf{lm}(f_i),\\mathsf{lm}(f_j))</span> . Intuitively, this strategy keeps the degree of the working polynomials as small as possible at all times.</p>

    <p class="text-gray-300">After  <span class="math">M</span>  is computed and echelon row-reduced, all those polynomials with leading monomial not already in the preliminary Gröbner basis  <span class="math">G</span>  are added to it. The list of critical pairs is then updated using these new elements. Thus, Buchberger's criterion (Theorem 2) works as the termination criterion once again. The complete algorithm is given in Algorithm 4. For a proof of its correctness and termination, we refer to [46, Thm. 2.2] or [37, Ch. 10, §3].</p>

    <p class="text-gray-300">Algorithm 4:  <span class="math">\\mathrm{F}_4</span> Input:  <span class="math">\\mathcal{F} = \\{f_0,\\dots ,f_{s - 1}\\} \\subseteq \\mathbb{F}[\\mathbf{x}]</span>  Output: a Gröbner basis  <span class="math">G</span>  for  <span class="math">\\langle f_0,\\ldots ,f_{s - 1}\\rangle</span> <span class="math">G = \\mathcal{F}</span> <span class="math">t = s</span> <span class="math">B = \\{\\{i,j\\} \\mid 0\\leqslant i &amp;lt;   j &amp;lt;   s\\}</span>  // indices of crit. pairs not considered yet while  <span class="math">B\\neq \\emptyset</span>  do Select non-empty  <span class="math">B^{\\prime}\\subseteq B</span>  // e.g., according to normal strategy</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">B = B\\setminus B^{\\prime}</span> $L = \\left\\{\\frac{\\mathrm{lcm}(\\mathrm{lm}(f_i),\\mathrm{lm}(f_j))}{\\mathcal{H}(f_i)}\\cdot f_i\\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i,j\\} \\in B'\\right\\}$  // S-polynomial "halves"</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">M =</span>  SYMBOLIC PREPROCESSING(L,G) <span class="math">N =</span>  row-reduced echelon form of  <span class="math">M</span> <span class="math">N^{+} = \\{n\\in \\mathrm{rows}(N)\\mid \\mathrm{lm}(n)\\notin \\langle \\mathrm{lm}(\\mathrm{rows}(M))\\rangle \\}</span>  // only new lead monoms foreach  <span class="math">r</span>  in rows  <span class="math">(N^{+})</span>  do <span class="math">f_{t} =</span>  polynomial form of  <span class="math">r</span> <span class="math">G = G\\cup \\{f_t\\}</span> <span class="math">B = B\\cup \\{\\{i,t\\} \\mid 0\\leqslant i &amp;lt;   t\\}</span> <span class="math">t = t + 1</span> return  <span class="math">G</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{F}_{4}</span> as given in Algorithm 4 can be heavily improved upon. For example, results of subroutine “Symbolic Preprocessing” can be reused between iterations. Furthermore, there are a number of criteria to determine whether the S-polynomial of a critical pair will reduce to zero, including acclaimed Gebauer-Möller installation <em>[21, 22, 29, 55, 63]</em>. Originally applied to Buchberger’s algorithm, they can be made use of in <span class="math">\\mathrm{F}_{4}</span> as well. Apart from discarding unnecessary critical pairs, the order in which pairs are selected plays a crucial role for computation speed. For an in-depth review of such improvements, we refer to <em>[46, Sec. 2.4]</em> and <em>[37, Ch. 10, §3]</em>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.2 <span class="math">\\mathrm{F}_{5}</span></h3>

    <p class="text-gray-300">Both Buchberger’s algorithm and <span class="math">\\mathrm{F}_{4}</span> compute, in some form, the S-polynomial of a critical pair and reduce that S-polynomial by the current preliminary Gröbner basis. Any nonzero remainder is added to the working Gröbner basis. However, a reduction to zero does not produce new information, but does waste time. In practice, roughly 90% of <span class="math">\\mathrm{F}_{4}</span>’s execution time is spent performing such useless computations <em>[47]</em>. Establishing ahead of time whether a reduction is necessary thus greatly improves overall performance.</p>

    <p class="text-gray-300">Using a combination of <em>syzygies</em>, which are kernel elements of map <span class="math">\\phi_{\\mathcal{F}}(\\boldsymbol{\\omega})=\\sum_{i}\\omega_{i}f_{i}</span> for input set <span class="math">\\mathcal{F}</span>, and <em>signatures</em>, the <span class="math">\\mathrm{F}_{5}</span> criterion allows the <span class="math">\\mathrm{F}_{5}</span> algorithm to skip a lot of useless reductions. In fact, if the input system is a <em>regular sequence</em>, no useless reduction is performed at all.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 13 (Regular sequence of polynomials <em>[14, Def. 2]</em>).</h6>

    <p class="text-gray-300">A list of polynomials <span class="math">f_{0},\\ldots,f_{s-1}\\in\\mathbb{F}[\\mathbf{x}]</span> is a <em>regular sequence</em> if, for all <span class="math">0\\leqslant i&lt;s</span>, polynomial <span class="math">f_{i}^{h}</span> is not a zero-divisor in quotient ring</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}[\\mathbf{x}]\\Big{/}\\langle f_{0}^{h},\\ldots,f_{i-1}^{h}\\rangle\\,,</span></p>

    <p class="text-gray-300">where <span class="math">f_{i}^{h}</span> is the homogeneous part of <span class="math">f_{i}</span> of highest degree.</p>

    <p class="text-gray-300">Intuitively, a regular sequence is a generalization of linear independence, where no <span class="math">f_{i}</span> can be expressed through a polynomially weighted sum <span class="math">\\sum_{j=0}^{i-1}q_{j}f_{j}</span>, i.e., <span class="math">f_{i}</span> does not lie in the ideal spanned by the <span class="math">f_{j}</span> with <span class="math">j&lt;i</span>.</p>

    <p class="text-gray-300">Some further concepts are necessary before the <span class="math">\\mathrm{F}_{5}</span> algorithm can be properly introduced. For this, we follow <em>[37, Ch. 10, §4]</em> as opposed to the original publication <em>[47]</em>, allowing to present <span class="math">\\mathrm{F}_{5}</span> in a way structurally similar to both Buchberger’s algorithm and <span class="math">\\mathrm{F}_{4}</span>. If the set of generator polynomials <span class="math">\\mathcal{F}</span> for ideal <span class="math">I</span> is clear from context, we set <span class="math">\\phi=\\phi_{\\mathcal{F}}</span>.</p>

    <p class="text-gray-300">Any element <span class="math">g</span> of the ideal defined by <span class="math">\\langle\\mathcal{F}\\rangle</span>, including elements of a Gröbner basis for <span class="math">I</span>, is a polynomially weighted sum of the generator polynomials <span class="math">f_{i}\\in\\mathcal{F}</span>. That is, <span class="math">g=\\sum_{i}\\omega_{i}f_{i}</span> for some <span class="math">\\boldsymbol{\\omega}\\in\\mathbb{F}[\\mathbf{x}]^{s}</span>, defining the function <span class="math">\\phi_{\\mathcal{F}}(\\boldsymbol{\\omega})=\\sum_{i}\\omega_{i}f_{i}</span>.</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">This sum is implicitly computed in both Buchberger's algorithm and  <span class="math">\\mathrm{F}_4</span> , since the main interest lies with the resulting polynomial  <span class="math">g</span> .  <span class="math">\\mathrm{F}_5</span>  computes and uses these weights explicitly. These vectors of origin succinctly keep track of how the algorithm arrived at, for example, a Gröbner basis element, and enable the algorithm to avoid redundant deductions. A vector of origin  <span class="math">\\omega</span>  is an element of the  <span class="math">s</span> -dimensional free module on  <span class="math">\\mathbb{F}[\\mathbf{x}]</span> , i.e.,  <span class="math">\\omega \\in \\mathbb{F}[\\mathbf{x}]^s</span> . Observe that the image of module  <span class="math">\\mathbb{F}[\\mathbf{x}]^s</span>  under  <span class="math">\\phi_{\\mathcal{F}}</span>  is exactly the ideal spanned by  <span class="math">\\mathcal{F}</span> , i.e.,  <span class="math">\\phi_{\\mathcal{F}}(\\mathbb{F}[\\mathbf{x}]^s) = \\langle \\mathcal{F} \\rangle</span> .</p>

    <p class="text-gray-300">Monomial order  <span class="math">\\prec</span>  can be extended to order  <span class="math">\\preccurlyeq</span>  on vectors of origin. The most common extension is position-over-term ordering  <span class="math">\\preccurlyeq_{\\mathrm{pot}}</span> , where the indices of the vectors' highest-index non-zero entry are compared first, with ties broken by comparing the entries leading monomials according to  <span class="math">\\prec</span> .</p>

    <p class="text-gray-300">Definition 14 ( <span class="math">\\preccurlyeq_{\\mathrm{pot}}</span> ). For order  <span class="math">\\preccurlyeq</span> , extending  <span class="math">\\prec</span>  to vectors of polynomials, we have  <span class="math">g \\preccurlyeq h</span>  if there exists index  <span class="math">i</span>  such that for all  <span class="math">j &amp;gt; i</span> , we have  <span class="math">g_j = h_j = 0</span>  and either  <span class="math">g_i = 0 \\neq h_i</span>  or  <span class="math">l^0</span> <span class="math">lm(g_i) \\prec lm(h_i)</span> .</p>

    <p class="text-gray-300">Example 9. Extending  <span class="math">\\prec_{\\mathrm{lex}}</span>  to  <span class="math">\\preccurlyeq_{\\mathrm{pot}}</span> , we have the following ordering.</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c} x ^ {2} \\\\ 0 \\\\ 0 \\end{array} \\right) \\preccurlyeq \\left( \\begin{array}{c} x \\\\ x + y ^ {4} \\\\ 0 \\end{array} \\right) \\preccurlyeq \\left( \\begin{array}{c} y \\\\ x ^ {2} \\\\ 0 \\end{array} \\right) \\equiv \\left( \\begin{array}{c} x ^ {5} y ^ {4} + 1 \\\\ - 3 x ^ {2} + x y ^ {3} \\\\ 0 \\end{array} \\right) \\preccurlyeq \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ 1 \\end{array} \\right)</span></div>

    <p class="text-gray-300">Definition 15 (Signature). The signature  <span class="math">\\mathfrak{s}</span>  of vector of polynomials  <span class="math">\\pmb{g}</span>  is  <span class="math">\\mathfrak{s}(\\pmb{g}) = l\\mathfrak{m}(g_i)\\pmb{e}_i</span> , where the highest-index non-zero entry  <span class="math">g_i</span>  of  <span class="math">\\pmb{g}</span>  is at position  <span class="math">i</span> .</p>

    <p class="text-gray-300">Example 10 (continued). The signatures of the vectors used in Example 9 are as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c} x ^ {2} \\\\ 0 \\\\ 0 \\end{array} \\right) \\preccurlyeq \\left( \\begin{array}{c} 0 \\\\ x \\\\ 0 \\end{array} \\right) \\preccurlyeq \\left( \\begin{array}{c} 0 \\\\ x ^ {2} \\\\ 0 \\end{array} \\right) \\equiv \\left( \\begin{array}{c} 0 \\\\ x ^ {2} \\\\ 0 \\end{array} \\right) \\preccurlyeq \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ 1 \\end{array} \\right)</span></div>

    <p class="text-gray-300">Intuitively, the signature is a vector's minimal amount of information needed for correct sorting according to  <span class="math">\\preccurlyeq</span> .</p>

    <p class="text-gray-300">The  <span class="math">\\mathrm{F}_5</span>  criterion considers only signatures of vectors of origin, not the full vectors or their evaluation under  <span class="math">\\phi</span> . A good part of  <span class="math">\\mathrm{F}_5</span> 's efficiency can be attributed to the fact that operations on and comparisons of signatures can be performed very efficiently. Since signatures are the product of some monomial and a unit vector, divisibility of monomials can be extended to signatures in a straightforward manner.</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 16 (Signature divisibility). For vectors of origin <span class="math">\\pmb{g}</span> and <span class="math">\\pmb{h}</span>, we say <span class="math">\\mathfrak{s}(\\pmb{g}) = \\mathbf{x}^{\\alpha}\\pmb{e}_{i}</span> divides <span class="math">\\mathfrak{s}(\\pmb{h}) = \\mathbf{x}^{\\beta}\\pmb{e}_{j}</span>, and write $\\mathfrak{s}(\\pmb{g})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{s}(\\pmb{h})<span class="math">, if </span>i = j<span class="math"> and </span>\\mathbf{x}^{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}^{\\beta}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Vectors of origin that are kernel elements of <span class="math">\\phi</span> are called syzygy vectors and are of special interest for <span class="math">\\mathrm{F}_5</span>.</p>

    <p class="text-gray-300">Definition 17 (Syzygy vector). A vector of origin <span class="math">\\mathbf{s} \\in \\mathbb{F}[\\mathbf{x}]^s</span> is called a syzygy vector if it maps to 0 under <span class="math">\\phi</span>, i.e., <span class="math">\\phi(\\mathbf{s}) = 0</span>.</p>

    <p class="text-gray-300">It is easy to see that the set of syzygy vectors is a submodule of <span class="math">\\mathbb{F}[\\mathbf{x}]^s</span>. Since the zero polynomial does not contribute any information to the Gröbner basis computation, it is helpful to identify syzygy vectors early. For ideal <span class="math">I = \\langle f_0, \\ldots, f_{s-1} \\rangle</span>, some syzygy vectors are trivial to state.</p>

    <p class="text-gray-300">Definition 18 (Koszul syzygy). For any <span class="math">0 \\leqslant i &amp;lt; j &amp;lt; s</span>, the vector <span class="math">f_{i}\\pmb{e}_{j} - f_{j}\\pmb{e}_{i}</span> is a syzygy vector. It is called a Koszul syzygy, or principal syzygy.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{F}</span> is a regular sequence, the set of Koszul syzygies is a basis for the entire submodule of syzygies [44, Corr. 7.1]</p>

    <p class="text-gray-300"><span class="math">\\mathrm{F}_5</span> performs an analog to polynomial reduction by a working Gröbner basis, but on vectors of origin and with an "early abort." More concretely, when reducing <span class="math">\\phi(\\pmb{f})</span> by a set of polynomials <span class="math">\\phi(\\pmb{G}) = \\{\\phi(\\pmb{g}_i) \\mid \\pmb{g}_i \\in \\pmb{G}\\}</span>, a step of the polynomial division algorithm is only performed if the signature <span class="math">\\mathfrak{s}(\\pmb{f})</span> does not change with regards to <span class="math">\\preccurlyeq</span>.</p>

    <p class="text-gray-300">Definition 19 (s-reduction). We say that <span class="math">\\pmb{G} \\subseteq \\mathbb{F}[\\mathbf{x}]^s</span> s-reduces <span class="math">\\pmb{f} \\in \\mathbb{F}[\\mathbf{x}]^s</span> to <span class="math">\\pmb{h} \\in \\mathbb{F}[\\mathbf{x}]^s</span> if there exist <span class="math">\\pmb{g}_i \\in \\pmb{G}</span>, <span class="math">\\mathbf{x}^\\alpha \\in \\mathbb{F}[\\mathbf{x}]</span>, and <span class="math">c \\in \\mathbb{F}</span>, such that</p>

    <p class="text-gray-300">(1) <span class="math">\\pmb{h} = \\pmb{f} - c\\mathbf{x}^{\\alpha}\\pmb{g}_{i}</span> (2) <span class="math">\\operatorname{lt}(\\phi(c\\mathbf{x}^{\\alpha}\\pmb{g}_i))</span> is a term in <span class="math">\\phi(\\pmb{f})</span>, and either (3a) <span class="math">\\mathfrak{s}(\\pmb{f}) \\succcurlyeq \\mathfrak{s}(\\mathbf{x}^{\\alpha}\\pmb{g}_i)</span> or (3b) <span class="math">\\mathfrak{s}(\\pmb{f}) = \\mathfrak{s}(\\mathbf{x}^{\\alpha}\\pmb{g}_{i})</span></p>

    <p class="text-gray-300">If Condition (3a) holds, the <span class="math">\\mathfrak{s}</span>-reduction is regular. Otherwise, if Condition (3b) holds, the <span class="math">\\mathfrak{s}</span>-reduction is singular. Vector <span class="math">\\pmb{f}</span> is fully <span class="math">\\mathfrak{s}</span>-reduced with respect to <span class="math">\\pmb{G}</span> if no <span class="math">\\mathfrak{s}</span>-reduction of <span class="math">\\pmb{f}</span> by <span class="math">\\pmb{G}</span> is possible.</p>

    <p class="text-gray-300">Observe that Condition (2) corresponds to one step in the multivariate polynomial division algorithm. The Conditions (3a) and (3b) define the "early abort." Full regular <span class="math">\\mathfrak{s}</span>-reduction means that <span class="math">\\phi(\\pmb{f})</span> is reduced as much as possible without changing signature <span class="math">\\mathfrak{s}(\\pmb{f})</span>. A corresponding algorithm can be found in Appendix C.</p>

    <p class="text-gray-300">Definition 20 (s-reduction to zero). We say that <span class="math">\\pmb{f}</span> s-reduces to zero by <span class="math">\\pmb{G}</span> if there exists some syzygy vector <span class="math">\\pmb{s}</span> such that <span class="math">\\pmb{f}</span> can be <span class="math">\\mathfrak{s}</span>-reduced to <span class="math">\\pmb{s}</span> by <span class="math">\\pmb{G}</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\pmb{f}</span> <span class="math">\\mathfrak{s}</span>-reducing to zero by <span class="math">\\pmb{G}</span> implies <span class="math">\\phi(\\pmb{f}) \\underset{\\phi(\\pmb{G})}{=} 0</span>, where <span class="math">\\phi(\\pmb{G}) = \\{\\phi(\\pmb{g}_i) \\mid \\pmb{g}_i \\in \\pmb{G}\\}</span>, but not necessarily that full <span class="math">\\mathfrak{s}</span>-reduction of <span class="math">\\pmb{f}</span> by <span class="math">\\pmb{G}</span> is <span class="math">\\pmb{0} \\in \\mathbb{F}[\\mathbf{x}]^s</span> or <span class="math">\\phi(\\pmb{f}) = 0 \\in \\mathbb{F}[\\mathbf{x}]</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 21 (Signature Gröbner basis).</h6>

    <p class="text-gray-300">A set of vectors of origin <span class="math">\\bm{G}=\\{\\bm{g}_{0},\\ldots,\\bm{g}_{t-1}\\}\\subseteq\\mathbb{F}[\\mathbf{x}]^{s}</span> with monic <span class="math">\\phi(\\bm{g}_{i})</span> is called <em>signature Gröbner basis</em> for ideal <span class="math">I</span> generated by <span class="math">\\mathcal{F}=\\{f_{0},\\ldots,f_{s-1}\\}</span> if all vectors of origin <span class="math">\\bm{f}\\in\\mathbb{F}[\\mathbf{x}]^{s}</span> <span class="math">\\mathfrak{s}</span>-reduce to zero by <span class="math">\\bm{G}</span>.</p>

    <p class="text-gray-300">Similarly, <span class="math">\\bm{G}</span> is a <em>signature Gröbner basis below signature <span class="math">\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span></em> if all vectors of origin <span class="math">\\bm{f}\\in\\mathbb{F}[\\mathbf{x}]^{s}</span> with signature <span class="math">\\mathfrak{s}(\\bm{f})\\preccurlyeq\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span> <span class="math">\\mathfrak{s}</span>-reduce to zero by <span class="math">\\bm{G}</span>.</p>

    <p class="text-gray-300">Observe that by the definition of <span class="math">\\phi</span>, we have <span class="math">\\phi(\\mathbb{F}[\\mathbf{x}]^{s})=\\langle\\mathcal{F}\\rangle=I</span>, intuiting the requirement that <em>all</em> vectors of origin <span class="math">\\bm{f}\\in\\mathbb{F}[\\mathbf{x}]^{s}</span> need to reduce to zero by <span class="math">\\bm{G}</span>. Like the original Definitions 6 and 7 for Gröbner bases, Definition 21 is not practical to compute a signature Gröbner basis. This is remedied by generalizing Buchberger’s criterion to vectors of origin. Thus, Buchberger’s criterion is used again to ensure correctness. The central concept of Buchberger’s criterion are S-polynomials, and their generalization to vectors of origin leads to <em>S-vectors</em>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 22 (S-vector).</h6>

    <p class="text-gray-300">The <em>S-vector</em> of <span class="math">\\bm{f}</span> and <span class="math">\\bm{g}</span> with monic <span class="math">\\phi(\\bm{f})</span>, <span class="math">\\phi(\\bm{g})</span> is</p>

    <p class="text-gray-300"><span class="math">S(\\bm{f},\\bm{g})=\\frac{u}{lm(\\phi(\\bm{f}))}\\bm{f}-\\frac{u}{lm(\\phi(\\bm{g}))}\\bm{g},\\quad u=\\mathrm{lcm}(lm(\\phi(\\bm{f}),\\phi(\\bm{g})))\\enspace.</span></p>

    <p class="text-gray-300">If <span class="math">\\mathfrak{s}(\\bm{f})\\neq\\mathfrak{s}(\\bm{g})</span>, the <em>S-vector</em> <span class="math">S(\\bm{f},\\bm{g})</span> is called <em>regular</em>. Otherwise, the <em>S-vector</em> is called <em>singular</em>.</p>

    <p class="text-gray-300">Observe that <span class="math">\\phi</span> is a homomorphism from the set of S-vectors of <span class="math">\\mathbb{F}[\\mathbf{x}]^{s}</span> to the set of S-polynomials of <span class="math">\\mathbb{F}[\\mathbf{x}]</span>:</p>

    <p class="text-gray-300"><span class="math">\\phi(S(\\bm{f},\\bm{g}))=S(\\phi(\\bm{f}),\\phi(\\bm{g})).</span> (2)</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 3 (Vectorized Buchberger’s criterion).</h6>

    <p class="text-gray-300">Let <span class="math">\\bm{G}=\\{\\bm{g}_{0},\\ldots,\\bm{g}_{t-1}\\}</span>, <span class="math">\\bm{g}_{i}\\in\\mathbb{F}[\\mathbf{x}]^{s}</span> with monic <span class="math">\\phi(\\bm{g}_{i})</span>, and <span class="math">I=\\langle f_{0},\\ldots,f_{s-1}\\rangle</span> an ideal in <span class="math">\\mathbb{F}[\\mathbf{x}]</span>. Then, <span class="math">\\bm{G}</span> is a signature Gröbner basis for <span class="math">I</span> if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S-vector <span class="math">S(\\bm{g}_{i},\\bm{g}_{j})</span> <span class="math">\\mathfrak{s}</span>-reduces to zero by <span class="math">\\bm{G}</span> for any <span class="math">0\\leqslant i,j&lt;t</span>, and</li>

      <li>unit vector <span class="math">\\bm{e}_{i}</span> <span class="math">\\mathfrak{s}</span>-reduces to zero by <span class="math">\\bm{G}</span> for any <span class="math">0\\leqslant i&lt;s</span>.</li>

    </ol>

    <p class="text-gray-300">Similarly, <span class="math">\\bm{G}</span> is a signature Gröbner basis below <span class="math">\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span> for <span class="math">I</span> if and only if above conditions hold for all S-vectors and unit vectors with signature <span class="math">\\preccurlyeq\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">(idea). Using the homomorphic property of <span class="math">\\phi</span> from Equation 2, Theorem 3 can be reduced to the original Buchberger criterion of Theorem 2.</p>

    <p class="text-gray-300">Note that condition 2 ensures that <span class="math">\\bm{G}</span> is a signature Gröbner basis for <span class="math">I</span>, not for some ideal <span class="math">J\\subsetneq I</span> strictly contained in <span class="math">I</span>. Signature Gröbner bases imply <em>actual</em> Gröbner bases in the following manner.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\bm{G}=\\{\\bm{g}_{0},\\ldots,\\bm{g}_{t-1}\\}</span> be a signature Gröbner basis for <span class="math">I=\\langle\\mathcal{F}\\rangle</span>. Then, <span class="math">\\phi(\\bm{G})=\\{\\phi(\\bm{g}_{i})\\mid\\bm{g}_{i}\\in\\bm{G}\\}</span> is a Gröbner basis for <span class="math">I</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By the definition of signature Gröbner basis, all elements of <span class="math">\\mathbb{F}[\\mathbf{x}]^{s}</span> <span class="math">\\mathfrak{s}</span>-reduce to zero by <span class="math">\\bm{G}</span>. This includes all S-vectors <span class="math">S(\\bm{g}_{i},\\bm{g}_{j})</span> for any <span class="math">\\bm{g}_{i},\\bm{g}_{j}\\in\\bm{G}</span>. Since Equation 2 holds, we have <span class="math">S(\\phi(\\bm{g}_{i}),\\phi(\\bm{g}_{j}))\\mathop{\\stackrel{{\\scriptstyle\\rightarrow}}{{=}}}\\limits_{\\widetilde{=}(\\bm{G})}0</span>. Thus, Buchberger’s criterion applies to <span class="math">\\phi(\\bm{G})</span>. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Above definitions give the tools to state the two propositions comprising the F_{5} criterion. The first proposition discards vectors of origin whose corresponding polynomial are a strict multiple of an already identified Gröbner basis element.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proposition 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\bm{g}</span> and <span class="math">\\bm{h}</span> be vectors of origin with <span class="math">\\mathfrak{s}(\\bm{g})=\\mathfrak{s}(\\bm{h})</span>. Let <span class="math">\\bm{G}</span> be a signature Gröbner basis below this signature. If <span class="math">\\bm{g}</span> and <span class="math">\\bm{h}</span> are fully regular <span class="math">\\mathfrak{s}</span>-reduced by <span class="math">\\bm{G}</span>, then <span class="math">\\phi(\\bm{g})=\\phi(\\bm{h})</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume that <span class="math">\\phi(\\bm{g})\\neq\\phi(\\bm{h})</span>. Then, without loss of generality, <span class="math">\\bm{0}\\neq\\mathfrak{s}(\\bm{g}-\\bm{h})\\preccurlyeq\\mathfrak{s}(\\bm{g})</span>. Thus, <span class="math">\\bm{g}-\\bm{h}</span> <span class="math">\\mathfrak{s}</span>-reduces to zero by <span class="math">\\bm{G}</span>. Let <span class="math">\\bm{m}</span> be the <span class="math">\\preccurlyeq</span>-leading term of <span class="math">\\bm{g}-\\bm{h}</span>. Without loss of generality, <span class="math">\\bm{m}</span> appears in <span class="math">\\bm{g}</span>. This implies that <span class="math">\\bm{g}</span> is not regular <span class="math">\\mathfrak{s}</span>-reduced by <span class="math">\\bm{G}</span>, contradicting the assumption. ∎</p>

    <p class="text-gray-300">The second proposition in the F_{5} criterion uses syzygy vectors to detect unnecessary reductions ahead of time. In an earlier attempt to leverage syzygies for faster Gröbner basis computation, the overhead of computing a basis for the syzygy submodule outweighed the resulting savings <em>[79]</em>. F_{5} improves on this by building the syzygy submodule basis and the signature Gröbner basis at the same time.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proposition 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\bm{G}=\\{\\bm{g}_{0},\\ldots,\\bm{g}_{t-1}\\}</span> be a signature Gröbner basis below signature <span class="math">\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span> for ideal <span class="math">I</span>. Let <span class="math">\\bm{h}=S(\\bm{g}_{i},\\bm{g}_{j})</span> with signature <span class="math">\\mathfrak{s}(\\bm{h})</span> at most <span class="math">\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span>. If there exists syzygy vector <span class="math">\\bm{s}</span> such that <span class="math">\\mathfrak{s}(\\bm{s})\\!\\mid\\!\\mathfrak{s}(\\bm{h})</span>, then <span class="math">\\bm{h}</span> <span class="math">\\mathfrak{s}</span>-reduces to zero by <span class="math">\\bm{G}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By the definition of signature division, there exists <span class="math">\\mathbf{x}^{\\bm{\\gamma}}</span> such that <span class="math">\\mathfrak{s}(\\mathbf{x}^{\\bm{\\gamma}}\\bm{s})=\\mathfrak{s}(\\bm{h})</span>. Thus, <span class="math">\\bm{h}^{\\prime}=\\bm{h}-\\mathbf{x}^{\\bm{\\gamma}}\\bm{s}\\preccurlyeq\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span>. Consequently, <span class="math">\\bm{h}^{\\prime}</span> <span class="math">\\mathfrak{s}</span>-reduces to zero by <span class="math">\\bm{G}</span>, i.e., to some syzygy vector <span class="math">\\bm{s}^{\\prime}</span>. Thus, <span class="math">\\bm{h}</span> <span class="math">\\mathfrak{s}</span>-reduces to <span class="math">\\bm{s}^{\\prime\\prime}</span> by <span class="math">\\bm{G}</span>, where <span class="math">\\bm{s}^{\\prime\\prime}</span> is the <span class="math">\\mathfrak{s}</span>-reduction of <span class="math">\\bm{s}^{\\prime}+\\mathbf{x}^{\\bm{\\gamma}}\\bm{s}</span> by <span class="math">\\bm{G}</span>. Since the set of syzygies form a module, <span class="math">\\bm{s}^{\\prime\\prime}</span> is a syzygy vector. It follows that <span class="math">\\bm{h}</span> <span class="math">\\mathfrak{s}</span>-reduces to zero by <span class="math">\\bm{G}</span>. ∎</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 23 (F_{5} criterion).</h6>

    <p class="text-gray-300">For signature Gröbner basis <span class="math">\\bm{G}</span> for <span class="math">I=\\langle\\mathcal{F}\\rangle</span> below signature <span class="math">\\mathbf{x}^{\\bm{\\alpha}}\\bm{e}_{i}</span>, a set of syzygy vectors <span class="math">\\bm{S}</span>, and vector of origin <span class="math">\\bm{f}</span> fully regular <span class="math">\\mathfrak{s}</span>-reduced by <span class="math">\\bm{G}</span>, the F_{5} criterion is true if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there is no <span class="math">\\bm{g}_{i}\\in\\bm{G}</span> with <span class="math">\\mathfrak{s}(\\bm{g}_{i})=\\mathfrak{s}(\\bm{f})</span>, and</li>

      <li>there is no <span class="math">\\bm{s}\\in\\bm{S}</span> with <span class="math">\\mathfrak{s}(\\bm{s})\\!\\mid\\!\\mathfrak{s}(\\bm{f})</span>.</li>

    </ol>

    <p class="text-gray-300">It is possible to combine the criterion’s two checks using rewriting, for which we refer to <em>[45]</em>. With the F_{5} criterion at its heart, F_{5} is given in Algorithm 5. We present F_{5} more in line with later improvements and generalizations, like RB <em>[44, Alg. 3]</em> and GVW <em>[52, 53]</em>, highlighting the structural similarities to Buchberger’s algorithm and F_{4}. F_{5} is in fact a family of algorithms, since several selection strategies for Line 5 exist. Selecting the <span class="math">\\preccurlyeq</span>-smallest vector, i.e., the vector with smallest signature, is the most efficient strategy in practice. This way, F_{5} first computes a Gröbner basis for ideal <span class="math">\\langle f_{0}\\rangle</span>, then for <span class="math">\\langle f_{0},f_{1}\\rangle</span>, then <span class="math">\\langle f_{0},f_{1},f_{2}\\rangle</span>, and so on.</p>

    <p class="text-gray-300">The F_{4} and F_{5} families of algorithms are not disjoint. Concretely, the selection strategy in Line 5 can be altered such that multiple vectors of origin are</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">| Algorithm 5: F5 |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| Input: F = {f0, ..., fs-1} ⊆ F[x] |</p>

    <p class="text-gray-300">| Output: a Gröbner basis G for ⟨f0, ..., fs-1⟩ |</p>

    <p class="text-gray-300">| 1 G = ∅ // preliminary signature Gröbner basis below some signature |</p>

    <p class="text-gray-300">| 2 P = {e0, ..., es-1} // ensures G is not basis for strict sub-ideal |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3 S = {f1e1 - f2e1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 ≤ i < j < s} // Koszul syzygies</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 4 while P ≠ ∅ do |</p>

    <p class="text-gray-300">| 5 g = some element of P // e.g., <-smallest |</p>

    <p class="text-gray-300">| 6 P = P \\ {g} |</p>

    <p class="text-gray-300">| 7 if F5-CRITERION(g, G, S) then |</p>

    <p class="text-gray-300">| 8 h = regular s-reduction of g by G |</p>

    <p class="text-gray-300">| 9 if φF(h) = 0 then |</p>

    <p class="text-gray-300">| 10 S = S ∪ {h} |</p>

    <p class="text-gray-300">| 11 else |</p>

    <p class="text-gray-300">| 12 h = 1/n(φF(h)) h // normalize |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13 P = P ∪ {S(k, h)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k ∈ G and s(k) ≠ s(h)}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 14 G = G ∪ {h} |</p>

    <p class="text-gray-300">| 15 return φF(G) |</p>

    <p class="text-gray-300">chosen. This allows to incorporate techniques from  <span class="math">\\mathrm{F}_4</span> , in particular simultaneous reduction of polynomials. These ideas are expanded upon in, for example, MatrixF <span class="math">_5</span>  [11, Sec. 1.5.2] and  <span class="math">\\mathrm{F}_{4/5}</span>  [1].</p>

    <p class="text-gray-300">Intuitively, the correctness of  <span class="math">\\mathrm{F}_5</span>  follows from Theorem 3 and Propositions 4 and 5, i.e., the vectorized Buchberger criterion and the fact that the  <span class="math">\\mathrm{F}_5</span>  criterion discards only unnecessary critical pairs. Because the original publication's proof of termination for general systems of polynomials was flawed, many algorithms slightly altering  <span class="math">\\mathrm{F}_5</span>  to guarantee termination have appeared. An excellent survey, putting these variations as well as generalizations and extensions of  <span class="math">\\mathrm{F}_5</span>  in relation using unified notation and terminology, is due to Eder &amp; Faugère [44]. For the full proof of termination of  <span class="math">\\mathrm{F}_5</span>  as presented here, we refer to [44, Sec. 10].</p>

    <p class="text-gray-300">Complexity Even though there is a compact description of  <span class="math">\\mathrm{F}_5</span> , it is quite difficult to estimate its complexity directly. The algorithm terminates when set  <span class="math">P</span>  is empty. Since  <span class="math">P</span>  is growing and shrinking depending on how often the  <span class="math">\\mathrm{F}_5</span>  criterion does or does not apply, the point of termination is inherently difficult to predict. After all, if some method could easily predict applicability of the  <span class="math">\\mathrm{F}_5</span>  criterion, it would automatically give rise to an even faster Gröbner basis algorithm. However, since  <span class="math">\\mathrm{F}_5</span>  does eventually terminate, we know that at some point, set  <span class="math">P</span>  will not grow anymore. In a degree refining monomial order, the total degree of the highest-degree  <span class="math">\\operatorname{lcm}(\\phi(\\pmb{k}), \\phi(\\pmb{h}))</span>  for which  <span class="math">\\mathfrak{s}(\\pmb{k}) \\neq \\mathfrak{s}(\\pmb{h})</span>  appearing in Line 13 at any point during  <span class="math">\\mathrm{F}_5</span> 's execution coincides with the degree of regularity,[1] also</p>

    <p class="text-gray-300">known as the Hilbert regularity, of <span class="math">\\mathcal{F}</span> <em>[12]</em>. For a formal treatment of this notion, we refer to <em>[37, Ch. 9, §3]</em>.</p>

    <p class="text-gray-300">The degree of regularity gives an upper bound for the total degree of polynomials appearing during <span class="math">\\mathrm{F}_{5}</span>’s execution. Consequently, it is used to estimate the complexity of <span class="math">\\mathrm{F}_{5}</span>. Namely, for a polynomial ring with <span class="math">n</span> variables, running <span class="math">\\mathrm{F}_{5}</span> on a system of polynomials <span class="math">f_{0},\\ldots,f_{s-1}</span> whose degree of regularity is <span class="math">d_{\\mathrm{reg}}</span>, the complexity of <span class="math">\\mathrm{F}_{5}</span> is in <span class="math">O\\big{(}\\binom{n+d_{\\mathrm{reg}}}{n}^{\\omega}\\big{)}</span>, where <span class="math">\\omega</span> is the linear algebra constant <em>[12, Thm. 7]</em>.</p>

    <p class="text-gray-300">Intuitively, this complexity comes from the regular <span class="math">\\mathfrak{s}</span>-reductions in Line 8. These reductions are most costly when the degrees of <span class="math">\\phi(\\boldsymbol{g})</span> or of the polynomials in <span class="math">\\phi(\\boldsymbol{G})</span> are the largest, i.e., are equal to the degree of regularity. For the sake of estimating the complexity, imagine keeping the underlying working Gröbner basis <span class="math">\\phi(\\boldsymbol{G})</span> as a triangulated Macaulay matrix of width <span class="math">m</span>. The regular <span class="math">\\mathfrak{s}</span>-reduction can then be performed with complexity in <span class="math">O(m^{\\omega})</span> using linear algebra techniques. The width <span class="math">m</span> of the Macaulay matrix corresponds to the number of monomials in <span class="math">n</span> variables up to degree <span class="math">d_{\\mathrm{reg}}</span>, i.e., <span class="math">m=\\binom{n+d_{\\mathrm{reg}}}{n}</span>. For a more detailed treatment, we refer to <em>[12, 13]</em>.</p>

    <p class="text-gray-300">In the same manner, the degree of regularity allows estimating the complexity of <span class="math">\\mathrm{F}_{4}</span>. Perhaps surprisingly, the complexities of <span class="math">\\mathrm{F}_{4}</span> and <span class="math">\\mathrm{F}_{5}</span> are asymptotically the same, but experiments show that the terms obscured by big-O notation are quite different between the two <em>[41]</em>.</p>

    <p class="text-gray-300">Unfortunately, we don’t know if it is generally possible to compute the degree of regularity faster than running <span class="math">\\mathrm{F}_{5}</span>. However, for the class of regular polynomial systems, a shortcut exists. The degree of regularity <span class="math">d_{\\mathrm{reg}}</span> of a regular system adheres to the Macaulay bound <em>[12]</em>, i.e.,</p>

    <p class="text-gray-300"><span class="math">d_{\\mathrm{reg}}(\\mathcal{F})=1+\\sum_{i=0}^{s-1}\\deg(f_{i})-1.</span> (3)</p>

    <p class="text-gray-300">If the system is overdetermined, as can be the case for some cryptographic applications, it is inherently irregular. Here, the notion of semi-regularity generalizes regularity. Briefly summarized, the degree of regularity of a semi-regular sequence is the index of the first non-positive coefficient in the projective Hilbert series of <span class="math">(f_{0}^{h},\\ldots,f_{s-1}^{h})</span>. For a more detailed treatment, we refer to <em>[14, Sec. 2.3]</em>.</p>

    <p class="text-gray-300">Two approaches exist for estimating the degree of regularity of the polynomial system arising from an AOC. The first is to assume, argue, or ideally prove that the primitive’s system of polynomials is (semi-)regular. In this case, the degree of (semi-)regularity can easily be computed from the Hilbert series of the ideal defined by the primitive’s polynomial system. The second is using <span class="math">\\mathrm{F}_{5}</span> to find the degree of regularity for several round-reduced variants of the primitive, then extrapolating to the full-round primitive. It is an open question whether the actual degree of regularity of the full-round primitive generally corresponds to the extrapolated value.</p>

    <p class="text-gray-300">3.3 eXtended Linearization, with Mutants and Wiedemann</p>

    <p class="text-gray-300">As outlined in Section 1, Gröbner bases are only of incidental interest when algebraically attacking an AOC. The actual objective is finding an element of the variety corresponding to the secret key, hash preimage, etc. The <em>eXtended Linearization</em> (XL) <em>[35]</em> family of algorithms, including its various extensions and improvements <em>[24, 26, 39, 74, 75, 76, 77]</em>, strives to find this element directly. This changes the general attack pipeline given in Section 1: after polynomially modeling the primitive, the intermediary steps of computing a Gröbner basis, changing the term order, and reading out the solution are condensed into one step, namely running XL or one of its extensions to directly arrive at the solution.</p>

    <p class="text-gray-300">In this section, we outline XL and its two most important improvements <em>Wiedemann XL</em> <em>[76, Ch. 5.3]</em> and <em>Mutant XL</em> <em>[26, 39]</em>. Additionally, we point out similarities between Gröbner basis algorithm F_{4} and the MXL algorithms <em>[2]</em>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">eXtended Linearization</h4>

    <p class="text-gray-300">The two core techniques of XL are, to no surprise, <em>extending</em> and <em>linearization</em>. Extending a system of polynomials <span class="math">\\mathcal{F}</span> means multiplying its elements by all monomials <span class="math">m\\in\\mathcal{M}</span> up to a certain degree <span class="math">d</span>: <span class="math">\\{m\\cdot f\\mid m\\in\\mathcal{M},\\deg(m)\\leqslant d,f\\in\\mathcal{F}\\}</span>. Linearizing a system of polynomials corresponds to building its Macaulay matrix as described in Definition 12. This amounts to dropping all algebraic relations between the monomials by interpreting the polynomial’s coefficients as vectors over the underlying field. Techniques from linear algebra then allow to efficiently solve the (“polynomial”) system. The cost of this approach is an explosion in the number of solutions for the linear system which are not solutions for the polynomial system, i.e., the introduction of parasitical solutions.</p>

    <p class="text-gray-300">The XL algorithm combats the potentially prohibitive memory requirements of this explosion, as well as the prohibitive time needed to sift through all solutions to identify non-parasitical ones, by simplifying the polynomial system once a partial solution is identified. This, in turn, introduces the disadvantage that the algorithm might fail because a specific partial solution cannot be extended to a full solution.</p>

    <p class="text-gray-300">The XL algorithm is given in Algorithm 6. Its inputs are the polynomial system <span class="math">\\mathcal{F}</span> and additional user-defined integer <span class="math">D</span>, which essentially defines the degree up to which the Macaulay matrices are built. XL iterates the steps <em>extension</em>, <em>linearization</em>, <em>solution finding</em>, and <em>system simplification</em>. The partial solution coming from the univariate polynomial <span class="math">f_{\\text{uni}}</span> is recorded in <span class="math">v</span> to successively build an element of the variety. If the current partial solution cannot be extended, and assuming the primitive under attack was correctly modeled, the partial solution of a previous iteration was an incorrect choice. In this case, XL terminates with an error. Re-running it with different randomness might lead to a different result.</p>

    <p class="text-gray-300">The monomial order of 5 can be <em>lex</em> order, but doesn’t have to be. In particular, any monomial order such that variable <span class="math">x_{i}</span> only appears in the right-most columns of the Macaulay matrix is sufficient, although generally, not all such monomial orders will lead to the same performance of XL. Interestingly</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">| Algorithm 6: XL |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| Input: F = {f0, ..., fs-1} ⊆ F[x], integer D |</p>

    <p class="text-gray-300">| Output: an element v of the variety V(F) |</p>

    <p class="text-gray-300">| 1 v = () |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 dmax = max({deg(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f ∈ F})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 3 for 0 ≤ i < n do |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fext = {m · f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m ∈ M, deg(m) ≤ D - dmax, f ∈ F} // extend</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Fech = row reduced echelon form of Fmat</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">Fnew = polynomials of Fech</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">if ∃funi ∈ Fnew with funi univariate in xi then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">ri = a root of funi // solve, e.g., using Berlekamp's algorithm</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">v = v</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ri // record partial solution</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">F = {f(xi = ri)</td>

            <td class="px-3 py-2 border-b border-gray-700">f ∈ F} // simplify system</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">return error // partial solution cannot be extended</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">return v</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">enough, the monomial order does not have to be the same across iterations, in contrast to the previously discussed (Gröbner basis) algorithms.</p>

    <p class="text-gray-300">The complexity of XL is not trivial to estimate. The bulk of the work is computing the echelon row reduced form of the Macaulay matrices. XL's operating degree corresponds to the highest degree  <span class="math">d</span>  for which a Macaulay matrix was constructed during the algorithm's execution. However, both the operating degree as well the Macaulay matrices' sizes are difficult to know before executing XL.</p>

    <p class="text-gray-300">(Parallel) Wiedemann XL Solving the linear system of Line 6 with sparse linear algebra techniques due to Wiedemann [83] gives rise to WXL [76, Ch. 5.3]. An explanation of Wiedemann's algorithm is beyond the scope of this document. The main improvement of WXL over XL is the lower linear algebra constant for matrix multiplication of 2 plus an additional term dependent on the sparsity of the matrices, which is generally not known beforehand. Again, estimating the sizes of the involved Macaulay matrices is non-trivial, and will be expanded upon below.</p>

    <p class="text-gray-300">WXL is parallelizable, and the resulting algorithm consequently named PWXL [76, 77]. The existence of WXL highlights the importance of using the linear algebra constant implied by sparse techniques, while PWXL necessitates to take parallelization into account when conservatively estimating the complexity of a Gröbner basis computation.</p>

    <p class="text-gray-300">Mutant XL A different improvement of XL is the introduction of so-called mutants, leading to Mutant XL [26, 39]. Mutants are polynomials used to keep the linear systems as small as possible.</p>

    <p class="text-gray-300">Intuitively, for polynomial system  <span class="math">\\mathcal{F} = \\{f_0,\\dots ,f_{s - 1}\\}</span> , a mutant is a polynomial  <span class="math">f\\in \\langle \\mathcal{F}\\rangle</span>  resulting in a degree drop. More formally, any expression of  <span class="math">f\\in \\langle \\mathcal{F}\\rangle</span></p>

    <p class="text-gray-300">as <span class="math">f=\\sum_{i}h_{i}f_{i}</span> yields a list of polynomials <span class="math">(h_{0},\\ldots,h_{s-1})</span> denoted <em>representation</em> of <span class="math">f</span>. The <em>level</em> of a representation is the highest total degree of any <span class="math">h_{i}f_{i}</span>, and the <em>level of <span class="math">f</span></em> is the smallest level of all its representations.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 24 (Mutant)</h6>

    <p class="text-gray-300">A polynomial <span class="math">f\\in\\langle\\mathcal{F}\\rangle</span> that has a level strictly greater than its total degree <span class="math">\\deg(f)</span> is a <em>mutant</em>.</p>

    <p class="text-gray-300">An algorithmic description of a simplified MXL is given in Algorithm 7. It essentially performs the following steps: First, the working polynomials are multiplied by all monomials up to certain degree. Linearizing the polynomials results in a linear system. These steps amount to the construction of a Macaulay matrix of some degree <span class="math">d</span>, as before. The linear system is triangularized and any mutants, which can be identified using <span class="math">d_{\\text{mut}}</span>, are added to the set of working polynomials. When a univariate polynomial is computed, one of its roots is recorded as part of the solution, and the system of polynomials is simplified accordingly, as before. Once the partial solution has been fully extended, the algorithm terminates, yielding the element of the variety.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Relationship between <span class="math">F_{\\downarrow}</span> and MXL</h4>

    <p class="text-gray-300">Interestingly, the MXL algorithms are essentially equivalent to <span class="math">\\mathrm{F}_{4}</span> with the normal selection strategy <em>[2, 9]</em>, albeit with a different time-memory trade-off. Consequently, estimating the complexity of MXL is similarly difficult.</p>

    <p class="text-gray-300">The relation between <span class="math">\\mathrm{F}_{5}</span>’s degree of regularity and MXL’s operating degree, especially in the context of AOCs, is unclear. There are certain systems of polynomials for which the operating degree is dramatically higher <em>[40]</em>. For other systems, experiments indicate that the operating degree is at most 2 higher than the degree of regularity. Using yet again different parameters, a more mathematical approach describes the asymptotic difference to be at most 1 <em>[85]</em>. When estimating the complexity of Gröbner basis computations conservatively, using the degree of regularity seems like a good choice.</p>

    <h2 id="sec-37" class="text-2xl font-bold">4 Term Order Change Algorithms</h2>

    <p class="text-gray-300">Out of all monomial orders, computing a Gröbner basis in <em>degrevlex</em> order is usually the fastest <em>[15]</em>. However, extracting the variety of an ideal is efficient only with a <em>lex</em>-ordered Gröbner basis. The runtime difference between computing bases for the two orders is usually so large that it is faster to first compute a <em>degrevlex</em>-ordered basis, then perform a <em>term order change</em> to get a <em>lex</em>-ordered basis. The two most important term order change algorithms are <em>FGLM</em> <em>[48]</em> and the <em>Gröbner Walk</em> <em>[33]</em>, introduced in Sections 4.1 and 4.3, respectively.</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">| Algorithm 7: SIMPLIFIED MXL |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| Input: F = {f0, ..., fs-1} ⊆ F[x] with ⟨F⟩ zero-dimensional |</p>

    <p class="text-gray-300">| Output: an element v of the variety V(F) |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 dmax = max{deg(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f ∈ F}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 3 mutants = ∅ |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4 v = (ε, ..., ε) // variety element with ε as placeholder.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 5 while True do |</p>

    <p class="text-gray-300">| 6 Fmat = Macaulay matrix of F in degrevlex order of degree dmax |</p>

    <p class="text-gray-300">| 7 Fech = row reduced echelon form of Fmat // echelonize |</p>

    <p class="text-gray-300">| 8 Fnew = polynomials of Fech |</p>

    <p class="text-gray-300">| 9 if ∃funi ∈ Fnew with funi univariate in some xi then |</p>

    <p class="text-gray-300">| 10 ri = a root of funi // solve, e.g., using Berlekamp's algorithm |</p>

    <p class="text-gray-300">| 11 vi = ri // record partial solution |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12 Fnew = {f(xi = ri)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f ∈ Fnew} // simplify system</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 13 if ∅ε ∈ v then |</p>

    <p class="text-gray-300">| 14 return v // solution found |</p>

    <p class="text-gray-300">| 15 else |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16 dmax = max{deg(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f ∈ Fnew}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 18 else |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19 mutants = mutants ∪ {f ∈ Fnew</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(f) < dmut, lm(f)∉ lm(F)}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 20 if mutants ≠ ∅ then |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">21 dmin = min{deg(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f ∈ mutants}) // multiply mutants</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 23 mutants = mutants \\ mutantsel |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">24 mutantsext = {m·f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m ∈ M, deg(m) = 1, f ∈ mutantsel}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 25 Fnew = Fnew ∪ mutantsext |</p>

    <p class="text-gray-300">| 26 dmut = dmin + 1 |</p>

    <p class="text-gray-300">| 27 else |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">28 Fsel = {f ∈ Fnew</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(f) = dmax} // extend</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 30 Fnew = Fnew ∪ Fext |</p>

    <p class="text-gray-300">| 31 dmax = dmax + 1 |</p>

    <p class="text-gray-300">| 32 dmut = dmax |</p>

    <p class="text-gray-300">| 33 F = Fnew |</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">Gröbner bases for the same ideal but with respect to different monomial orders can differ drastically. For a (not so drastic) example, the following two Gröbner bases  <span class="math">G_{\\mathrm{lex}}</span>  and  <span class="math">G_{\\mathrm{invlex}}</span>  generate the same ideal  <span class="math">I</span>  but share no polynomial.</p>

    <p class="text-gray-300">|  Glex = { g0 = x3 - x2 - y6 + y5, Ginvlex = { g0 = y5 - x2y - x4 + 2x3 - x2, g1 = xy4 + y7 - y6, g1 = xy4 + x2y + x4 - x3, g2 = xy4 + y6, g2 = x2y2 - x4 + x3, g3 = x3y, g4 = x5 - x4}  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">Consequently, full reduction of, for example,  <span class="math">f = x^{5} + x^{2}y^{2} - y^{6}</span>  by  <span class="math">G_{\\mathrm{lex}}</span>  yields remainder  <span class="math">r_{\\mathrm{lex}} = x^2 + 2y^7 - y^5</span> , which is quite different from  <span class="math">r_{\\mathrm{invlex}} = -x^2 y + x^4</span> , the remainder of  <span class="math">f</span>  after full reduction by  <span class="math">G_{\\mathrm{invlex}}</span> .</p>

    <p class="text-gray-300">The monomials that are not reducible by a Gröbner basis fall into a staircase, defined by the leading monomials of the basis. An example is given in Figure 3, visualizing the staircases defined by  <span class="math">G_{\\mathrm{lex}}</span>  and  <span class="math">G_{\\mathrm{invlex}}</span> . Monomials in the shaded area are reducible by the respective Gröbner basis. All monomials comprising the remainder after full reduction lie inside the staircase.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a)  <span class="math">G_{\\mathrm{lex}}</span></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b)  <span class="math">G_{\\mathrm{invlex}}</span> Fig. 3. Staircases of  <span class="math">G_{\\mathrm{lex}}</span>  and  <span class="math">G_{\\mathrm{invlex}}</span> . Monomials of  <span class="math">r_{\\mathrm{invlex}}</span>  are encircled (O).</p>

    <p class="text-gray-300">While  <span class="math">r_{\\mathrm{invlex}}</span>  is not further reducible by  <span class="math">G_{\\mathrm{invlex}}</span> , the monomials of  <span class="math">r_{\\mathrm{invlex}}</span>  can be reduced by  <span class="math">G_{\\mathrm{lex}}</span> , and vice versa. In Figures 3a and 3b, the monomials of  <span class="math">r_{\\mathrm{invlex}}</span>  are encircled, showing that they fall outside the staircase defined by  <span class="math">G_{\\mathrm{lex}}</span> . Full reduction of terms  <span class="math">-x^2 y</span>  and  <span class="math">x^4</span>  from  <span class="math">r_{\\mathrm{invlex}}</span>  by  <span class="math">G_{\\mathrm{lex}}</span>  gives polynomials  <span class="math">(y^7 - y^6)</span>  and  <span class="math">(x^2 + y^7 + y^6 - y^5)</span> , respectively. The sum of these two polynomials is equal to  <span class="math">r_{\\mathrm{lex}}</span> . The example, a summary of which can be found in Figure 4, shows two things: (1) Reducing a polynomial is the same as reducing its monomials, then summing, and (2) given a mapping between all staircase monomials of one Gröbner basis  <span class="math">G_{\\mathrm{old}}</span>  and their reduced forms by another Gröbner basis  <span class="math">G_{\\mathrm{new}}</span> , it is easy to "convert" polynomials reduced by  <span class="math">G_{\\mathrm{old}}</span>  to polynomials reduced by</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 4. Monomials and their full reductions, allowing conversion of remainders.</p>

    <p class="text-gray-300"><span class="math">G_{\\mathrm{new}}</span> , without changing their residue class. This mapping is the central tool in the FGLM term order change algorithm.</p>

    <p class="text-gray-300">The remaining question is how to find a mapping between staircase monomials of  <span class="math">G_{\\mathrm{old}}</span>  to their  <span class="math">G_{\\mathrm{new}}</span> -reduced forms when  <span class="math">G_{\\mathrm{new}}</span>  is not known. For this task, FGLM uses linear algebra in the quotient ring  <span class="math">\\mathbb{F}[\\mathbf{x}] / I</span>  taken as an  <span class="math">\\mathbb{F}</span> -vector space. The monomials in the staircase given by  <span class="math">G_{\\mathrm{old}}</span>  are a basis for this vector space, since any monomial outside the staircase can be reduced to a polynomial whose monomials fall inside the staircase. FGLM iterates over all monomials in  <span class="math">\\prec_{\\mathrm{new}}</span> -increasing order and reduces them by  <span class="math">G_{\\mathrm{old}}</span> , thereby building a mapping like in above example. The mapping can be taken as a dictionary: The monomials are the keys, the (polynomial) remainders of the monomials after reduction by  <span class="math">G_{\\mathrm{old}}</span>  are the values. Crucially, at every step the current remainder is checked for a linear dependency on the values already in the dictionary. Finding such a linear relation is straightforward, for example with the Gauß'ian algorithm. If a linear relation exists, it means that the current remainder is in the ideal  <span class="math">I</span> , since full reduction by  <span class="math">G_{\\mathrm{old}}</span>  results in 0. Applying the found linear relation to the corresponding keys then gives an element of the new Gröbner basis  <span class="math">G_{\\mathrm{new}}</span> . Any monomials divisible by the leading term of the new basis element need not be considered when iterating all monomials, since they fall outside the staircase of  <span class="math">G_{\\mathrm{new}}</span>  and thus cannot be a basis element of  <span class="math">G_{\\mathrm{new}}</span> .</p>

    <p class="text-gray-300">Because FGLM considers all monomials not divisible by some leading monomial of  <span class="math">G_{\\mathrm{new}}</span> , the algorithm does not terminate if there are infinitely many such monomials. Thus, the  <span class="math">\\mathbb{F}</span> -vector space  <span class="math">\\mathbb{F}[\\mathbf{x}] / I</span>  has to be of finite dimension, meaning that ideal  <span class="math">I</span>  has to be zero-dimensional.</p>

    <p class="text-gray-300">In summary, FGLM iterates over monomials until it hits the border of the staircase defined by  <span class="math">G_{\\mathrm{new}}</span> , which can be efficiently detected through linear dependencies between the monomials' reduced forms. The monomials are iterated over in  <span class="math">\\prec_{\\mathrm{new}}</span> -ascending order, determining the order  <span class="math">G_{\\mathrm{new}}</span>  is a Gröbner basis for. The full algorithm is given in Algorithm 8.</p>

    <p class="text-gray-300">Example 11. We present here a walk-through of Algorithm 8. The inputs are lex as the new monomial order  <span class="math">\\prec_{\\mathrm{new}}</span> , Gröbner basis  <span class="math">G_{\\mathrm{invlex}}</span>  (on the facing page) as</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">Algorithm 8: FGLM Input:  <span class="math">\\prec_{\\mathrm{new}}</span> <span class="math">G_{\\mathrm{old}}</span> <span class="math">\\prec_{\\mathrm{old}}</span>  Output:  <span class="math">G_{\\mathrm{new}}</span> 1 dict  <span class="math">= \\emptyset</span> 2  <span class="math">G_{\\mathrm{new}} = \\emptyset</span> 3 next_monons  <span class="math">= \\{1\\}</span> 4 while next_monons  <span class="math">\\neq \\emptyset</span>  do 5 monom  <span class="math">= \\min_{\\prec_{\\mathrm{new}}}\\{\\mathrm{next\\_monoms}\\}</span> 6 next_monons  <span class="math">=</span>  next_monons\\{monom}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7 if  <span class="math">\\nexists g\\in G_{\\mathrm{new}}</span>  such that  <span class="math">\\mathsf{Im}_{\\prec_{\\mathrm{new}}}(g)</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">monom then //still within staircase</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">8 reduced_monom  <span class="math">=</span>  full reduction of monom by  <span class="math">G_{\\mathrm{old}}</span>  //requires  <span class="math">\\prec_{\\mathrm{old}}</span> 9 if reduced_monom  <span class="math">^+</span> <span class="math">\\sum_{\\nu \\in \\mathrm{dict}}\\omega_{\\nu}\\cdot</span>  value(  <span class="math">\\nu = 0</span>  for some  <span class="math">\\omega_{\\nu}\\in \\mathbb{F}</span>  then 10  <span class="math">G_{\\mathrm{new}} = G_{\\mathrm{new}}\\cup \\{\\mathrm{monom} + \\sum_{\\nu \\in \\mathrm{dict}}\\omega_{\\nu}\\cdot \\nu \\}</span> 11 else 12 dict  <span class="math">=</span>  dictU{monom:reduced_monom}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13 next_monons  <span class="math">=</span>  next_mononsU{xivmonom</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i  <span class="math">\\in \\{0,\\dots ,n - 1\\}</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">14 return  <span class="math">G_{\\mathrm{new}}</span></p>

    <p class="text-gray-300"><span class="math">G_{\\mathrm{old}}</span> , and  <span class="math">invlex</span>  as the corresponding monomial order  <span class="math">\\prec_{\\mathrm{old}}</span> . The evolution of variables are listed in Table 1.</p>

    <p class="text-gray-300">In iteration 1 of the main loop (Line 4), we have  <span class="math">\\text{monom} = 1</span> . Since  <span class="math">G_{\\text{new}} = \\emptyset</span> , the outer if-clause (Line 7) evaluates to true. Reducing 1 by  <span class="math">G_{\\text{old}}</span>  results in 1, and since dict is empty, no  <span class="math">\\omega_{\\nu}</span>  exist such that the second if-clause (Line 9) could evaluate to true. Thus, after the first iteration, we have  <span class="math">\\text{dict} = \\{1 : 1\\}</span>  and  <span class="math">\\text{next\\_monoms} = \\{y, x\\}</span> .</p>

    <p class="text-gray-300">In iteration 2, monom is set to the  <span class="math">\\prec_{\\mathrm{new}}</span> -smallest monomial in next_monons, which is  <span class="math">y</span> . Both if-clauses evaluate as before and no reduction of monom takes place, resulting in  <span class="math">\\text{dict} = \\{1 : 1, y : y\\}</span>  and  <span class="math">\\text{next\\_monoms} = \\{y^2, x, xy\\}</span>  after iteration 2. Iterations 3 through 5 are executed similarly.</p>

    <p class="text-gray-300">In iteration 6,  <span class="math">\\text{monom} = y^5</span>  is reducible by  <span class="math">G_{\\text{old}}</span> . The two if-clauses still evaluate to true and false respectively, resulting in new dictionary entry  <span class="math">\\{y^5 : x^2 y + x^4 - 2x^3 + x^2\\}</span> . Variable next_monons now equals  <span class="math">\\{y^6, x, xy, xy^2, xy^3, xy^4, xy^5\\}</span> . Iterations 7 and 8 behave similarly, with dictionary entries  <span class="math">\\{y^6 : x^2 y + x^4 - x^3\\}</span>  and  <span class="math">\\{y^7 : x^4 - x^3\\}</span>  being added respectively.</p>

    <p class="text-gray-300">In iteration 9, we have  <span class="math">\\text{monom} = y^8</span> . Reduction of  <span class="math">\\text{monom}</span>  by  <span class="math">G_{\\text{old}}</span>  results in reduced_monom = 0. This means that  <span class="math">\\text{monom}</span>  is an element of the ideal  <span class="math">\\langle G_{\\text{old}} \\rangle</span> . Clearly, there is a linear dependency between reduced_monom and the dict-values, namely  <span class="math">\\omega_{\\nu} = 0</span>  for all  <span class="math">\\nu \\in \\text{dict}</span> . The second if-clause thus evaluates to true for the first time, and after iteration 9, we have  <span class="math">G_{\\text{new}} = \\{y^8\\}</span> . Variable next_monons now equals  <span class="math">\\{xy^i \\mid 0 \\leqslant i \\leqslant 7\\}</span> . Iterations 10 through 13 again simply add entries to the dictionary and expand the set next_monons.</p>

    <p class="text-gray-300">In iteration 14, we have  <span class="math">\\text{monom} = xy^4</span>  with reduced_monom  <span class="math">= -x^{2}y - x^{4} + x^{3}</span> . Setting  <span class="math">\\omega_{y^6} = 1</span> , there is a linear dependency between reduced_monom</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">Table 1. Variables in Example 11 before execution of the main loop. The dict can be inferred from columns monom and reduced monom.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">iteration</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">monom</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">reduced_monom</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">next_monoms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gnew</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">{1}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">{y,x}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">y</td>

            <td class="px-3 py-2 border-b border-gray-700">y</td>

            <td class="px-3 py-2 border-b border-gray-700">{y2,x,xy}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">y2</td>

            <td class="px-3 py-2 border-b border-gray-700">y2</td>

            <td class="px-3 py-2 border-b border-gray-700">{y3,x,xy,xy2}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">y3</td>

            <td class="px-3 py-2 border-b border-gray-700">y3</td>

            <td class="px-3 py-2 border-b border-gray-700">{y4,x,xy,xy2,xy3}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">y4</td>

            <td class="px-3 py-2 border-b border-gray-700">y4</td>

            <td class="px-3 py-2 border-b border-gray-700">{y5,x,xy,xy2,xy3,xy4}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">y5</td>

            <td class="px-3 py-2 border-b border-gray-700">x2y+x4-2x3+x2</td>

            <td class="px-3 py-2 border-b border-gray-700">{y6,x,xy,xy2,xy3,xy4,xy5}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">y6</td>

            <td class="px-3 py-2 border-b border-gray-700">x4y+x4-x3</td>

            <td class="px-3 py-2 border-b border-gray-700">{y7,x,xy,xy2,xy3,xy4,xy5,xy6}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">y7</td>

            <td class="px-3 py-2 border-b border-gray-700">x4-x3</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,x,xy,xy2,xy3,xy4,xy5,xy6,xy7}</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">y8</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">{x,xy,xy2,xy3,xy4,xy5,xy6,xy7}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">{xy,xy2,xy3,xy4,xy5,xy6,xy7,x2}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">xy</td>

            <td class="px-3 py-2 border-b border-gray-700">xy</td>

            <td class="px-3 py-2 border-b border-gray-700">{xy2,xy3,xy4,xy5,xy6,xy7,x2,x2y}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">xy2</td>

            <td class="px-3 py-2 border-b border-gray-700">xy2</td>

            <td class="px-3 py-2 border-b border-gray-700">{xy3,xy4,xy5,xy6,xy7,x2,x2y,x2y2}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">xy3</td>

            <td class="px-3 py-2 border-b border-gray-700">xy3</td>

            <td class="px-3 py-2 border-b border-gray-700">{xy4,xy5,xy6,xy7,x2,x2y,x2y2,x2y3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">xy4</td>

            <td class="px-3 py-2 border-b border-gray-700">-x2y-x4+x3</td>

            <td class="px-3 py-2 border-b border-gray-700">{xy5,xy6,xy7,x2,x2y,x2y2,x2y3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">xy5</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">{xy6,xy7,x2,x2y,x2y2,x2y3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">xy6</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">{xy7,x2,x2y,x2y2,x2y3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">xy7</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">{x2,x2y,x2y2,x2y3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">x2</td>

            <td class="px-3 py-2 border-b border-gray-700">x2</td>

            <td class="px-3 py-2 border-b border-gray-700">{x2y,x2y2,x2y3,x3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">x2y</td>

            <td class="px-3 py-2 border-b border-gray-700">x2y</td>

            <td class="px-3 py-2 border-b border-gray-700">{x2y2,x2y3,x3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6,x2y+y5-y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">x2y2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">{x2y3,x3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6,x2y+y5-y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">x2y3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">{x3}</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6,x2y+y5-y6}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">x3</td>

            <td class="px-3 py-2 border-b border-gray-700">x3</td>

            <td class="px-3 py-2 border-b border-gray-700">∅</td>

            <td class="px-3 py-2 border-b border-gray-700">{y8,xy4+y6,x2y+y5-y6,x3-x2-y6+y5}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (a) Visualization of variables. (b) Linear relation and  <span class="math">\\omega_{\\nu}</span> 's. Fig. 5. Visualization of iteration 19 of Example 11. Right-hand Figure 5b highlights the linear relation between dictionary values and reduced_monom, resulting in a new basis element composed of monom and corresponding dictionary keys. In left-hand Figure 5a, the staircase of basis  <span class="math">G_{\\mathrm{old}}</span>  is blue, partial staircase of  <span class="math">G_{\\mathrm{new}}</span>  is red. Their elements' leading monomials are marked ( <span class="math">\\times</span>  and  <span class="math">\\blacksquare</span>  respectively). Arrows indicate, in order, the monomials monom of previous iterations. Elements of next_monoms are encircled ( <span class="math">\\bigcirc</span> ).</p>

    <p class="text-gray-300">and the values of dict, namely reduced_monom +  <span class="math">\\omega_{y^6}</span>  value  <span class="math">(y^{6}) = 0</span> . Thus, the second if-clause evaluates to true and monom +  <span class="math">\\sum_{\\nu \\in \\mathrm{dict}}\\omega_{\\nu}\\cdot \\nu = xy^{4} + y^{6}</span>  is added to  <span class="math">G_{\\mathrm{new}}</span>  as a new basis element. Variable next_monoms is now  <span class="math">\\{xy^5,xy^6,xy^7,x^2,x^2 y,x^2 y^2,x^2 y^3\\}</span> .</p>

    <p class="text-gray-300">The leading monomial with respect to  <span class="math">\\prec_{\\mathrm{new}}</span>  of the newly added basis element  <span class="math">\\mathsf{Im}_{\\prec_{\\mathrm{new}}}(xy^4 + y^6) = xy^4</span>  divides the three  <span class="math">\\prec_{\\mathrm{new}}</span> -smallest elements of next_monoms. Thus, the outer if-clause evaluates to true in iterations 15 through 17. We already know these monomials to be in the ideal, and they are removed from next_monoms without further processing. Iteration 18 removes  <span class="math">x^2</span>  from next_monoms, creates dictionary entry  <span class="math">\\{x^2 : x^2\\}</span> , and adds  <span class="math">x^3</span>  to next_monoms. (The monomial  <span class="math">x^2y</span> , also computed in Line 13, is already an element of set next_monoms.)</p>

    <p class="text-gray-300">Iteration 19 is visualized in Figure 5. Setting  <span class="math">\\omega_{y^6} = -1</span>  and  <span class="math">\\omega_{y^7} = 1</span>  results in a linear dependency, and the inner if-clause evaluates to true. Element  <span class="math">x^{2}y + y^{5} - y^{6}</span>  is added to  <span class="math">G_{\\mathrm{new}}</span> . Consequently, in iterations 20 and 21, the two  <span class="math">\\prec_{\\mathrm{new}}</span> -smallest elements of next_monoms, i.e.,  <span class="math">x^{2}y^{2}</span>  and  <span class="math">x^{2}y^{3}</span> , are discarded.</p>

    <p class="text-gray-300">In iteration 22, with monom  <span class="math">= x^3</span> ,  <span class="math">G_{\\mathrm{new}}</span>  is extended by  <span class="math">x^3 - x^2 + y^5 - y^6</span> . This results in empty next_monoms at the start of iteration 23. Variable  <span class="math">G_{\\mathrm{new}}</span>  now equals  <span class="math">G_{\\mathrm{lex}}</span>  on page 28. It is returned, and the algorithm terminates.</p>

    <p class="text-gray-300">Complexity Compared to the complexity of Gröbner basis computations, the complexity of FGLM is rather well understood. Essentially, in the outermost loop (Line 4), all monomials not reducible by  <span class="math">G_{\\mathrm{new}}</span> , i.e., all monomials in the staircase of  <span class="math">G_{\\mathrm{new}}</span> , are enumerated. These monomials correspond precisely to a</p>

    <p class="text-gray-300">basis <span class="math">B</span> of the <span class="math">\\mathbb{F}</span>-vector space <span class="math">\\mathbb{F}[\\mathbf{x}]/I</span>. Then, <span class="math">D=\\dim_{\\mathbb{F}}(\\mathbb{F}[\\mathbf{x}]/I)</span> is the <em>volume</em> of the staircase. Since <span class="math">I=\\langle G_{\\mathrm{old}}\\rangle=\\langle G_{\\mathrm{new}}\\rangle</span>, volume <span class="math">D</span> is independent of the Gröbner basis. As a consequence, <span class="math">D</span> can be easily deduced from any Gröbner basis’ leading monomials, in particular <span class="math">\\mathsf{lm}(G_{\\mathrm{old}})</span>.</p>

    <p class="text-gray-300">Any fully reduced polynomial has a maximum of <span class="math">D</span> terms. During the execution of FGLM, only fully reduced polynomials are stored in the dictionary. Representation of one such polynomial is possible with a vector of dimension <span class="math">D</span>, by listing all its coefficients. As every monomial in the staircase results in one entry in the dictionary, the dictionary’s values can be stored as one matrix of dimension at most <span class="math">D\\times D</span>. Keeping this matrix in triangular form allows the linear dependency check of 9 to be performed with complexity in <span class="math">O(D^{2})</span>. Since not only the monomials in the staircase but also those at the staircase’s border are enumerated during the execution of FGLM, up to <span class="math">nD</span> many such linear dependency checks are performed. The total complexity is thus in <span class="math">O(nD^{3})</span>. For a full proof of this sketch, we refer to <em>[48, Sec. 5]</em>.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.2 Sparse FGLM</h3>

    <p class="text-gray-300"><em>Sparse FGLM</em> <em>[49]</em> employs sparse linear algebra techniques to improve on FGLM in terms of complexity. Sparse FGLM is a randomized algorithm, possibly failing but detectably so. Furthermore, Sparse FGLM inherently converts a given Gröbner basis to <em>lex</em> order, i.e., does not take the target order as an input. Here, we only outline the steps of Sparse FGLM for recovering the univariate polynomial of the Gröbner basis in <em>lex</em> order. After relabeling variables such that this polynomial is in the variable for the key, the next steps are trivial. A parallel version of Sparse FGLM using Coppersmith’s Block-Wiedemann algorithm <em>[34]</em> is presented in <em>[64]</em>.</p>

    <p class="text-gray-300">Given a Gröbner basis <span class="math">G</span> for ideal <span class="math">I</span> over polynomial ring <span class="math">\\mathbb{F}[\\mathbf{x}]</span>, let <span class="math">B</span> denote any canonical basis of <span class="math">\\mathbb{F}</span>-vector space <span class="math">\\mathbb{F}[\\mathbf{x}]/I</span>, and <span class="math">D</span> the dimension of the space. The first step in Sparse FGLM is identifying multiplication matrix <span class="math">T\\in\\mathbb{F}^{D\\times D}</span> such that for all monomials <span class="math">m\\in\\mathbb{F}[\\mathbf{x}]/I</span>, we have <span class="math">T\\bm{m}=\\bm{x_{0}m}</span>, where <span class="math">\\bm{m}</span> and <span class="math">\\bm{x_{0}m}</span> are the vectorizations of <span class="math">m</span> and <span class="math">x_{0}m</span> according to <span class="math">B</span>, respectively. In particular, <span class="math">\\bm{x_{0}m}</span> is the vector representing <span class="math">x_{0}m</span> after reduction by <span class="math">G</span>. In the next step, Wiedemann’s sparse linear algebra solver finds a kernel vector <span class="math">\\bm{k}</span> of <span class="math">T</span>. A nonzero kernel element <span class="math">\\bm{k}</span> of <span class="math">T</span> corresponds to the weights of the FGLM linear relation, according to <span class="math">B</span>. Thus, <span class="math">\\bm{k}</span> gives rise to the univariate polynomial <span class="math">k\\in I</span> in the <em>lex</em>-ordered Gröbner basis.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The complexity of Sparse FGLM boils down to that of Wiedemann’s algorithm, i.e., <span class="math">O(DN_{0})</span>, where <span class="math">N_{0}</span> is the number of non-zero entries of <span class="math">T</span> <em>[54, Ch. 12.3]</em>. In general, <span class="math">N_{0}</span> is greater than <span class="math">D</span>, equality holding only for certain degenerated Gröbner bases, which allow to directly read off the interesting part of the solution. Sparsity of <span class="math">T</span> can be estimated in the following way. Let <span class="math">t</span> denote the number of monomials <span class="math">m</span> such that <span class="math">x_{0}m</span> can be reduced by <span class="math">G</span>, but <span class="math">m</span> cannot. Let further $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denote the number of non-zero non-leading coefficients of all elements of <span class="math">G</span>. Then, <span class="math">T</span> consists of <span class="math">t</span> columns with at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> non-zero entries, and each remaining column is some unit vector. In summary, </span>N_{0}\\leqslant t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(D-t)<span class="math">. For an asymptotic analysis of </span>T$’s sparsity, we refer to <em>[49, Sec. 6.4]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">4.3 The Gröbner Walk</h3>

    <p class="text-gray-300">The <em>Gröbner Walk</em> <em>[33]</em> is a term order change algorithm conceptually very different from FGLM. The Walk is of particular interest because it does not impose any restrictions on the ideal’s dimension but terminates even for positive-dimensional ideals. However, the ideals for the applications considered in this paper are always of dimension zero. Additionally, and in contrast to FGLM, the complexity of the Gröbner Walk is not well understood. Experimental comparisons indicate that it rarely outperforms FGLM. For these reasons, the Walk is only sketched. A comprehensive introduction is given in <em>[36, Ch. 8, §§4&5]</em>, whose example we use. Leading up to the Gröbner Walk, we first introduce the concepts of <em>marked</em> Gröbner bases, <em>Gröbner cones</em>, and <em>Gröbner fans</em> <em>[78]</em>.</p>

    <p class="text-gray-300">A useful concept for the remainder of this section is a polynomial’s <em>leading form</em>, a generalization of the leading term. A leading form is most easily described using monomial orders given by weight vectors, as introduced in Section 2.1. Given a monomial order <span class="math">\\prec_{\\boldsymbol{\\omega}}</span> by weight matrix <span class="math">(\\overrightarrow{M}_{\\boldsymbol{\\omega}})</span> where <span class="math">\\boldsymbol{\\omega}\\in\\mathbb{R}_{\\geqslant 0}^{n}</span> and <span class="math">M_{\\boldsymbol{\\omega}}\\in\\mathbb{R}^{(n-1)\\times n}</span>, the leading form of polynomial <span class="math">f=\\sum_{\\boldsymbol{\\alpha}}c_{\\boldsymbol{\\alpha}}\\mathbf{x}^{\\boldsymbol{\\alpha}}</span> is the sum of all <span class="math">\\boldsymbol{\\omega}</span>-maximal terms in <span class="math">f</span>, i.e., those terms for which <span class="math">\\boldsymbol{\\omega}\\cdot\\boldsymbol{\\alpha}</span> is maximal among all of <span class="math">f</span>’s terms with non-zero coefficients. For example, given <span class="math">f=x^{2}yz-xy^{2}z^{2}+3xyz\\in\\mathbb{F}[x,y,z]</span> and <span class="math">\\boldsymbol{\\omega}=(2,1,1)</span>, we have <span class="math">\\mathsf{lf}(f)=x^{2}yz-xy^{2}z^{2}</span>.</p>

    <p class="text-gray-300">A polynomial <span class="math">f</span> in conjunction with its leading form <span class="math">\\mathsf{lf}(f)</span> is called a <em>marked polynomial</em>. For ease of notation, the leading form is commonly underlined: <span class="math">f=\\underline{x^{2}yz-xy^{2}z^{2}}+3xyz</span>. As for leading terms, monomials, and coefficients, the extension to sets is defined: <span class="math">\\mathsf{lf}(\\mathcal{F})=\\bigcup_{f\\in\\mathcal{F}}\\mathsf{lf}(f)</span>.</p>

    <p class="text-gray-300">The (unique) reduced Gröbner basis for some monomial order <span class="math">\\prec_{\\boldsymbol{\\omega}}</span> is a <em>marked</em> Gröbner basis if all its elements are marked with respect to <span class="math">\\boldsymbol{\\omega}</span>. Given a fixed ideal <span class="math">I</span>, the marked Gröbner bases for different monomial orderings <span class="math">\\prec_{\\boldsymbol{\\omega}}</span> and <span class="math">\\prec_{\\boldsymbol{\\tau}}</span> can be the same. For example, the marked Gröbner basis of <span class="math">\\langle x+y\\rangle</span> with respect to both <em>lex</em> and <em>degrevlex</em> is <span class="math">\\{\\underline{x}+y\\}</span>, whereas for <em>invlex</em>, it is <span class="math">\\{x+\\underline{y}\\}</span>. Note that the (unmarked) reduced Gröbner basis of <span class="math">\\langle x+y\\rangle</span> is independent of the monomial order since none of the polynomial’s terms are distinguished.</p>

    <p class="text-gray-300">Two monomial orderings are considered equivalent for some ideal <span class="math">I</span> if their marked Gröbner bases coincide:</p>

    <p class="text-gray-300"><span class="math">\\prec_{\\boldsymbol{\\omega}}\\sim\\prec_{\\boldsymbol{\\tau}}\\quad\\Leftrightarrow\\quad\\mathsf{lf}_{\\boldsymbol{\\omega}}(I)=\\mathsf{lf}_{\\boldsymbol{\\tau}}(I)</span> (4)</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{lf}_{\\boldsymbol{\\gamma}}(I)</span> is the set of leading forms with respect to <span class="math">\\boldsymbol{\\gamma}</span> of the reduced Gröbner basis of <span class="math">I</span> with respect to <span class="math">\\prec_{\\boldsymbol{\\gamma}}</span>. The equivalence class of <span class="math">\\prec_{\\boldsymbol{\\omega}}</span> under <span class="math">\\sim</span> is called <em>Gröbner cone</em> <span class="math">C_{\\boldsymbol{\\omega}}(I)</span>. A Gröbner cone is a convex polyhedron <em>[50, Prop. 2.6]</em>.</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">The Gröbner cones partition <span class="math">\\mathbb{R}_{\\geqslant 0}^n</span>. Any ideal has only finitely many Gröbner cones [78, Lemma 2.6].</p>

    <p class="text-gray-300">Given Gröbner basis <span class="math">G_{\\omega} = \\{f_0, \\ldots, f_{s-1}\\}</span> for <span class="math">I</span> with respect to <span class="math">\\prec_{\\omega}</span>, we can also describe the cone <span class="math">C_{\\omega}(I)</span> as follows. Let <span class="math">f_i = c_{\\alpha_{i,\\max}} \\mathbf{x}^{\\alpha_{i,\\max}} + \\sum_j c_{\\alpha_{i,j}} \\mathbf{x}^{\\alpha_{i,j}}</span> where all coefficients <span class="math">c_{\\alpha_{i,\\max}}</span> and <span class="math">c_{\\alpha_{i,j}}</span> are non-zero and <span class="math">\\mathbf{x}^{\\alpha_{i,\\max}} \\succ_{\\omega} \\mathbf{x}^{\\alpha_{i,j}}</span> for all <span class="math">j</span>, i.e., <span class="math">\\mathbf{x}^{\\alpha_{i,\\max}}</span> is the leading monomial of <span class="math">f_i</span>. In other words, we have <span class="math">\\alpha_{i,\\max} \\cdot \\omega \\geqslant \\alpha_{i,j} \\cdot \\omega</span> for all <span class="math">j</span>. By setting <span class="math">\\mathbf{v}_{i,j} = (\\alpha_{i,\\max} - \\alpha_{i,j})</span>, we get a set of vectors <span class="math">\\{\\mathbf{v}_{i,j}\\} \\subseteq \\mathbb{R}^n</span> describing cone <span class="math">C_{\\omega}(I)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{R}_{\\geqslant 0}^n \\ni \\boldsymbol{\\tau} \\in C_{\\omega}(I) \\Leftrightarrow \\forall i, j: \\boldsymbol{v}_{i,j} \\cdot \\boldsymbol{\\tau} \\geqslant 0. \\tag{5}</span></div>

    <p class="text-gray-300">In particular, each <span class="math">\\mathbf{v}_{i,j}</span> corresponds to one face of the cone: if <span class="math">\\mathbf{v}_{i,j} \\cdot \\mathbf{\\tau} &amp;lt; 0</span> for some <span class="math">\\mathbf{\\tau}</span>, then <span class="math">\\mathbf{x}^{\\alpha_{i,\\max}} \\prec_{\\mathbf{\\tau}} \\mathbf{x}^{\\alpha_{i,j}}</span>, meaning <span class="math">\\mathrm{lf}_{\\mathbf{\\tau}}(f_i) \\neq \\mathrm{lf}_{\\omega}(f_i)</span>, i.e., <span class="math">\\mathbf{\\tau}</span> is not in the same cone as <span class="math">\\omega</span>.</p>

    <p class="text-gray-300"><strong>Definition 25 (Gröbner Fan [50]).</strong> The collection of all Gröbner cones <span class="math">\\{C_{\\omega}(I)\\}_{\\omega \\in \\mathbb{R}_{\\leqslant 0}^{n}}</span> of ideal <span class="math">I \\subseteq \\mathbb{F}[x_0, \\ldots, x_{n-1}]</span> is the Gröbner fan of <span class="math">I</span>.[6]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Example 12</strong> ([36, Ch. 8, §4]). The Gröbner fan of an ideal <span class="math">I</span> in (up to) 3 variables can be neatly visualized. Let <span class="math">G = \\{x^2 - y, xz - y^2 + yz\\} \\subseteq \\mathbb{F}[x, y, z]</span>. The intersection of all (seven) Gröbner cones in the Gröbner fan for <span class="math">G</span> with the hyperplane $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> are shown in Figure 6. The single ray marked </span>\\omega<span class="math"> corresponds to weight vector </span>(7, 7, 2)<span class="math">, intersecting the plane at </span>(7/16, 7/16, 1/8)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The Gröbner basis associated with <span class="math">\\omega</span> coincides with the Gröbner basis for <em>degrevlex</em>, namely <span class="math">\\{x^2 - y, y^2 - xz - yz\\}</span>. However, the marked Gröbner bases differ: for <span class="math">\\omega</span>, we have <span class="math">\\{\\underline{x}^2 - y, \\underline{y}^2 - xz - yz\\}</span>, but for <em>degrevlex</em>, the most dominant weight vector being <span class="math">(1, 1, 1)</span>, the marked Gröbner basis is <span class="math">\\{\\underline{x}^2 - y, \\underline{y}^2 - xz - yz\\}</span>.</p>

    <p class="text-gray-300">To increase intuition about the Walk, it is worth highlighting some correspondences between weight orders, leading forms, and a Gröbner cone's faces — see also Table 2 for a brief summary. In particular, given <span class="math">\\prec_{\\omega}</span> by weight matrix <span class="math">(\\underline{M}_{\\omega})</span>, note that if a polynomial <span class="math">f</span>'s leading form coincides with its leading term, i.e., if <span class="math">\\mathrm{lf}_{\\omega}(f) = \\mathrm{lt}_{\\omega}(f)</span>, then weight vector <span class="math">\\omega</span> suffices to identify the leading term of <span class="math">f</span>. However, if <span class="math">f</span> has more than one <span class="math">\\omega</span>-maximal term, weight vectors of <span class="math">M_{\\omega}</span> are needed to "break ties" for correct monomial sorting, and we have <span class="math">\\mathrm{lf}_{\\omega}(f) \\neq \\mathrm{lt}_{\\omega}(f)</span>. This (lack of) necessity for breaking ties, i.e., whether a single weight vector suffices to identify the leading monomial, directly corresponds to a Gröbner cone's interior and faces. Infinitely many monomial orderings exist for which some <span class="math">\\omega</span> is the most significant weight vector. Regardless, if <span class="math">\\omega</span> is in the interior of its cone <span class="math">C_{\\omega}(I)</span> — for example as in Figure 6 — the reduced Gröbner basis <span class="math">G_{\\omega}</span> is the same for all these monomial orderings. However, for a vector <span class="math">\\tau</span> on a cone's face — like <span class="math">(1/3, 1/3, 1/3)</span> in Figure 6 — there are <span class="math">M_0, M_1</span> such that the Gröbner bases for monomial orders implied by <span class="math">(\\underline{M}_0)</span> and <span class="math">(\\underline{M}_1)</span> differ. The additional weight vectors in <span class="math">M_0</span> and <span class="math">M_1</span> define how to break ties between <span class="math">\\tau</span>-maximal monomials. The Walk uses such "neighboring" monomial orders to convert between arbitrary monomial orders.</p>

    <p class="text-gray-300">[6] For reasons of simplicity, we omit the concepts of <em>Gröbner regions</em> and <em>restricted</em> or <em>extended</em> Gröbner fans. For details, see [50, 78].</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 6. A slice of the Gröbner fan of  <span class="math">G</span> . Vector  <span class="math">\\omega</span>  corresponds to weight (7, 7, 2). The red line corresponds to the path for the Gröbner Walk from normalized  <span class="math">\\omega</span>  to (1, 0, 0). The (single) intersection of that path with a cones' face is encircled.</p>

    <p class="text-gray-300">Given a starting monomial order  <span class="math">\\prec_{\\omega}</span>  by weight matrix  <span class="math">\\left( \\begin{array}{c} \\omega \\\\ M_{\\omega} \\end{array} \\right)</span>  as before, a marked Gröbner basis  <span class="math">G_{\\omega}</span>  for  <span class="math">\\prec_{\\omega}</span> , and a target monomial order  <span class="math">\\prec_{\\tau}</span>  induced by  <span class="math">\\left( \\begin{array}{c} \\tau \\\\ M_{\\tau} \\end{array} \\right)</span> , the Classic Gröbner Walk [33] converts  <span class="math">G_{\\omega}</span>  into a Gröbner basis  <span class="math">G_{\\tau}</span>  for  <span class="math">\\prec_{\\tau}</span> . Since each Gröbner cone and the Gröbner fan are convex, there is a piecewise linear path from  <span class="math">\\omega</span>  to  <span class="math">\\tau</span>  through the Gröbner fan - for example the line segment  <span class="math">(1 - \\delta)\\omega + \\delta \\tau</span>  with  <span class="math">0 \\leqslant \\delta \\leqslant 1</span> . The Gröbner Walk "follows" this[17] path, starting from  <span class="math">\\omega</span> , by (1) crossing into the next neighboring cone in direction  <span class="math">\\tau</span> , and (2) transforming the working Gröbner basis to match that cone. These two steps are iterated until the cone containing the target monomial order is reached, i.e., until the working monomial order is equivalent to the target monomial order. Below, we first discuss the problem associated with step (1), identifying a face of</p>

    <p class="text-gray-300">Table 2. Correspondences between weight vectors, Gröbner cones, and If &amp; It.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ifω(f) = ltω(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ifω(f) ≠ ltω(f)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">one ω-maximal monomial in f</td>

            <td class="px-3 py-2 border-b border-gray-700">vs</td>

            <td class="px-3 py-2 border-b border-gray-700">multiple ω-maximal monomials in f</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">no need to break ties</td>

            <td class="px-3 py-2 border-b border-gray-700">vs</td>

            <td class="px-3 py-2 border-b border-gray-700">need to break ties</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">only need ω to identify ltω(f)</td>

            <td class="px-3 py-2 border-b border-gray-700">vs</td>

            <td class="px-3 py-2 border-b border-gray-700">need ω and Mω to identify ltω(f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ω in interior of Cω(I)</td>

            <td class="px-3 py-2 border-b border-gray-700">vs</td>

            <td class="px-3 py-2 border-b border-gray-700">ω on face of Cω(I)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">marked basis independent of Mω</td>

            <td class="px-3 py-2 border-b border-gray-700">vs</td>

            <td class="px-3 py-2 border-b border-gray-700">marked basis depends on Mω</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">the cone intersecting with the line segment, and then step (2), the Gröbner basis transformation between two neighboring cones.</p>

    <p class="text-gray-300">As explained above, the starting cone's constraints can be expressed by a set of vectors  <span class="math">\\{\\pmb{v}_{i,j}\\}</span>  corresponding to the cone's faces. The largest step we can take along the line segment  <span class="math">(1 - \\delta)\\pmb {\\omega} + \\delta \\pmb{\\tau}</span>  while staying in the same cone, i.e., adhering to  <span class="math">\\pmb{v}_{i,j}\\cdot \\pmb {\\gamma}\\geqslant 0</span>  , is</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {\\max } = \\max  \\left(\\left\\{\\delta \\in [ 0, 1 ] \\mid \\forall i, j: \\boldsymbol {v} _ {i, j} \\cdot \\left((1 - \\delta) \\boldsymbol {\\omega} + \\delta \\boldsymbol {\\tau}\\right) \\geqslant 0 \\right\\}\\right). \\tag {6}</span></div>

    <p class="text-gray-300">We can find  <span class="math">\\delta_{\\mathrm{max}}</span>  using Algorithm 9, iterating all faces of the current cone.</p>

    <p class="text-gray-300">Algorithm 9: Gröbner Walk's STEP Input:  <span class="math">\\omega, \\tau, \\{v_{i,j}\\}</span> Output:  <span class="math">\\delta_{\\mathrm{max}}</span> 1  <span class="math">\\delta_{\\mathrm{max}} = 1</span> 2 foreach  <span class="math">v \\in \\{v_{i,j}\\}</span>  do 3 if  <span class="math">v \\cdot \\tau &amp;lt; 0</span>  then // implies leading monomial would change 4  <span class="math">\\delta = \\frac{v \\cdot \\omega}{v \\cdot \\omega - v \\cdot \\tau}</span>  // biggest step adhering to  <span class="math">v</span> 5  <span class="math">\\delta_{\\mathrm{max}} = \\min(\\delta, \\delta_{\\mathrm{max}})</span>  // smallest of all biggest steps 6 return  <span class="math">\\delta_{\\mathrm{max}}</span></p>

    <p class="text-gray-300">Example 13 (continued). Let (normalized)  <span class="math">\\omega = (7/16, 7/16, 1/8)</span> ,  <span class="math">G_{\\omega} = \\{\\underline{x}_{-}^{2} - y, y_{-}^{2} - xz - yz\\} \\subseteq \\mathbb{F}[x, y, z]</span> , and  <span class="math">I = \\langle G \\rangle</span> , as before. The cone  <span class="math">C_{\\omega}(I)</span>  is defined through  <span class="math">x^{2} \\succeq_{\\omega} y</span>  from the first polynomial, and  <span class="math">y^{2} \\succeq_{\\omega} xz</span>  and  <span class="math">y^{2} \\succeq_{\\omega} yz</span>  from the second. Equivalently:</p>

    <div class="my-4 text-center"><span class="math-block">(2, 0, 0) \\cdot \\omega \\geqslant (0, 1, 0) \\cdot \\omega \\Leftrightarrow (2, - 1, 0) \\cdot \\omega \\geqslant 0 \\Leftrightarrow : v _ {0, 0} \\cdot \\omega \\geqslant 0</span></div>

    <div class="my-4 text-center"><span class="math-block">(0, 2, 0) \\cdot \\omega \\geqslant (1, 0, 1) \\cdot \\omega \\Leftrightarrow (- 1, 2, - 1) \\cdot \\omega \\geqslant 0 \\Leftrightarrow : v _ {1, 0} \\cdot \\omega \\geqslant 0</span></div>

    <div class="my-4 text-center"><span class="math-block">(0, 2, 0) \\cdot \\omega \\geqslant (0, 1, 1) \\cdot \\omega \\Leftrightarrow (0, 1, - 1) \\cdot \\omega \\geqslant 0 \\Leftrightarrow : v _ {1, 1} \\cdot \\omega \\geqslant 0</span></div>

    <p class="text-gray-300">Let the target monomial order be lex, with corresponding target weight vector  <span class="math">\\pmb{\\tau} = (1,0,0)</span> , coinciding with the  <span class="math">\\gamma_0</span> -axis in Figure 6. When executing Algorithm 9, we get  <span class="math">\\pmb{v}_{0,0} \\cdot \\pmb{\\tau} = 2</span> ,  <span class="math">\\pmb{v}_{1,0} \\cdot \\pmb{\\tau} = -1</span> , and  <span class="math">\\pmb{v}_{1,1} \\cdot \\pmb{\\tau} = 0</span> , resulting in  <span class="math">\\delta_{\\max} = \\frac{5/16}{5/16 + 1} = 5/21</span> .</p>

    <p class="text-gray-300">The next step in the Gröbner Walk is to bring a marked Gröbner basis over to a neighboring cone given a weight vector on the two cones' shared face - for example  <span class="math">(1 - \\delta_{\\max})\\omega + \\delta_{\\max}\\tau =: \\nu</span> . For reasons of brevity, we omit all proofs, referring to [33, 36] instead. The transformation requires the Gröbner basis of an intermediate, smaller problem, described next. To find that Gröbner basis, any algorithm, like those described in Section 3, can be used.</p>

    <p class="text-gray-300">The polynomials <span class="math">G_{\\text{inter}}</span> defining the intermediate problem are the leading forms of <span class="math">G_{\\boldsymbol{\\omega}}</span>’s elements with respect to <span class="math">\\boldsymbol{\\nu}</span>. In “nice” cases, namely if <span class="math">\\boldsymbol{\\nu}</span> describes the intersection of the line segment with the cone <span class="math">C_{\\boldsymbol{\\omega}}(I)</span> on exactly one face, <span class="math">G_{\\text{inter}}</span> consists only of monomials and one binomial. Let <span class="math">H</span> be the Gröbner basis for <span class="math">\\langle G_{\\text{inter}}\\rangle</span>. We can write each element of <span class="math">H</span> as <span class="math">h_{i}=\\sum_{g\\in G_{\\boldsymbol{\\omega}}}p_{i,g}\\textsf{lf}_{\\boldsymbol{\\nu}}(g)</span> for some polynomials <span class="math">p_{i,g}</span>. The same sum where the actual polynomials <span class="math">g</span> replace their respective leading forms, i.e., <span class="math">\\{\\sum_{g\\in G_{\\boldsymbol{\\omega}}}p_{i,g}g\\}_{i}</span>, gives a Gröbner basis <span class="math">G^{\\prime}_{\\boldsymbol{\\nu}}</span> with respect to <span class="math">\\prec_{\\boldsymbol{\\nu}}</span>. Reducing <span class="math">G^{\\prime}_{\\boldsymbol{\\nu}}</span>, i.e., computing the remainder of <span class="math">g</span> with respect to <span class="math">G^{\\prime}_{\\boldsymbol{\\nu}}\\setminus\\{g\\}</span> for every <span class="math">g\\in G^{\\prime}_{\\boldsymbol{\\nu}}</span>, gives the reduced Gröbner basis <span class="math">G_{\\boldsymbol{\\nu}}</span> for <span class="math">\\langle G_{\\boldsymbol{\\omega}}\\rangle</span> with respect to intermediary monomial order <span class="math">\\prec_{\\boldsymbol{\\nu}}</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Example 14 (continued).</h6>

    <p class="text-gray-300">For <span class="math">\\delta_{\\text{max}}</span> of the previous step, we have <span class="math">(1-\\delta_{\\text{max}})\\boldsymbol{\\omega}+\\delta_{\\text{max}}\\boldsymbol{\\tau}=(^{4/7,1/3,2/21})=:\\boldsymbol{\\nu}</span>. Combined with the target monomial order <em>lex</em>’s weight matrix <span class="math">M_{\\text{lex}}=(\\begin{smallmatrix}1&amp;0&amp;0\\\\ 0&amp;1&amp;0\\end{smallmatrix})</span> this gives rise to weight order matrix <span class="math">(\\,\\mathop{M}_{\\text{lex}}^{F})</span>, defining monomial order <span class="math">\\prec_{\\boldsymbol{\\nu}}</span>. The leading form of <span class="math">G_{\\boldsymbol{\\omega}}</span> with respect to <span class="math">\\prec_{\\boldsymbol{\\nu}}</span> is <span class="math">\\textsf{lf}_{\\boldsymbol{\\nu}}(G_{\\boldsymbol{\\omega}})=\\{x^{2},y^{2}-xz\\}</span>. The Gröbner basis of <span class="math">\\textsf{lf}_{\\boldsymbol{\\nu}}(G_{\\boldsymbol{\\omega}})</span>, also with respect to <span class="math">\\prec_{\\boldsymbol{\\nu}}</span>, is <span class="math">H=\\{x^{2},y^{2}-xz,xy^{2},y^{4}\\}</span>. We can write</p>

    <p class="text-gray-300"><span class="math">(1,0)\\cdot\\textsf{lf}_{\\boldsymbol{\\nu}}(G_{\\boldsymbol{\\omega}})</span> <span class="math">=x^{2},</span> <span class="math">(0,1)\\cdot\\textsf{lf}_{\\boldsymbol{\\nu}}(G_{\\boldsymbol{\\omega}})</span> <span class="math">=y^{2}-xz,</span> <span class="math">(z,x)\\cdot\\textsf{lf}_{\\boldsymbol{\\nu}}(G_{\\boldsymbol{\\omega}})</span> <span class="math">=xy^{2},</span> <span class="math">(z^{2},xz+y^{2})\\cdot\\textsf{lf}_{\\boldsymbol{\\nu}}(G_{\\boldsymbol{\\omega}})</span> <span class="math">=y^{4},</span></p>

    <p class="text-gray-300">where, resolving ambiguity caused by the abuse of notation, set <span class="math">\\textsf{lf}_{\\boldsymbol{\\nu}}(G_{\\boldsymbol{\\omega}})</span> is interpreted as a vector with elements in the same order as written above. By taking the identified linear combinations of not just the leading form of <span class="math">G_{\\boldsymbol{\\omega}}</span>, but the respective complete polynomials, we get set <span class="math">G^{\\prime}_{\\boldsymbol{\\nu}}</span> consisting of</p>

    <p class="text-gray-300"><span class="math">(1,0)\\cdot G_{\\boldsymbol{\\omega}}</span> <span class="math">=x^{2}-y,</span> <span class="math">(0,1)\\cdot G_{\\boldsymbol{\\omega}}</span> <span class="math">=y^{2}-xz-yz,</span> <span class="math">(z,x)\\cdot G_{\\boldsymbol{\\omega}}</span> <span class="math">=xy^{2}-xyz-yz,</span> <span class="math">(z^{2},xz+y^{2})\\cdot G_{\\boldsymbol{\\omega}}</span> <span class="math">=y^{4}-xyz^{2}-y^{3}z-yz^{2}.</span></p>

    <p class="text-gray-300">After reducing each <span class="math">g\\in G^{\\prime}_{\\boldsymbol{\\nu}}</span> by <span class="math">G^{\\prime}_{\\boldsymbol{\\nu}}\\setminus\\{g\\}</span>, we get</p>

    <p class="text-gray-300"><span class="math">G_{\\boldsymbol{\\nu}}=\\{x^{2}-y,xz-y^{2}+yz,xy^{2}-y^{3}+y^{2}z-yz,y^{4}-2y^{3}z+y^{2}z^{2}-yz^{2}\\},</span></p>

    <p class="text-gray-300">which is the reduced Gröbner basis of <span class="math">\\langle G_{\\boldsymbol{\\omega}}\\rangle</span> with respect to <span class="math">\\prec_{\\boldsymbol{\\nu}}</span>. Furthermore, we have <span class="math">\\prec_{\\boldsymbol{\\nu}}\\sim\\prec_{\\boldsymbol{\\tau}}</span>, and the Gröbner Walk terminates.</p>

    <p class="text-gray-300">No complexity bound for the Gröbner Walk is known. In part, this is due to one of the Walk’s sub-tasks involving the computation of Gröbner bases for ideals not known a-priori, where even <em>given</em> an ideal’s generating polynomials, estimating the complexity of the Gröbner basis computation is difficult. Additionally, the path</p>

    <p class="text-gray-300">through the fan dictates the number of transformations as well as the intermediate problems’ polynomials: an intersection with a face of low co-dimension corresponds to polynomials with fewer terms, for which finding a Gröbner basis appears to be easier. Since the shape of the Gröbner fan of an ideal is not known a priori, it is impossible to plot an optimal path.</p>

    <p class="text-gray-300">Several follow-up works improve on the Gröbner Walk as sketched here by identifying better paths. For example, <em>[8]</em> presents methods for heuristically perturbing weight vectors corresponding to starting, intermediate, and target monomial orders within their respective equivalence classes to intersect with the cones’ faces more favorably. Deterministic perturbations are discussed in <em>[82]</em>. Additional strategies to dodge intersections of high co-dimensionality include the <em>Evasive Walk</em> <em>[8]</em>, the <em>Fractal Walk</em> <em>[8]</em>, and the <em>Generic Gröbner Walk</em> <em>[51]</em>.</p>

    <h2 id="sec-42" class="text-2xl font-bold">5 Open Questions</h2>

    <p class="text-gray-300">We raise some selected questions specific to Gröbner basis attacks on AOCs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The degree of regularity is the primary metric when assessing an AOC’s resistance against Gröbner basis attacks. For general systems of polynomials, i.e., systems not known to be semi-regular, the only currently available method for computing the degree of regularity is to run F_{4} or F_{5} on that system. A method to compute – or more closely estimate – this degree without computing a full Gröbner basis would thus increase confidence in a cipher’s parameters.</li>

      <li>The polynomial description of some AOCs, e.g., MiMC’s, already forms a Gröbner basis, albeit not in <em>lex</em> order. The main difficulty in breaking the cipher lies then in extracting the polynomial univariate in the key. This is usually done by performing a term order change, potentially with early abort. The theoretical complexity of changing a term order is poorly understood. Current security arguments rely on the complexity of existing algorithms. While FGLM and Sparse FGLM are well understood, it is unknown whether their complexities are optimal, especially since the Gröbner Walk is reported to outperform FGLM sometimes.</li>

      <li>Generating the polynomial model for the AOC under attack is out of scope for this paper. Regardless, there are interesting open questions associated with that step.</li>

    </ul>

    <p class="text-gray-300">For example, given a single pair of plaintext & ciphertext – or a single hash digest – the resulting polynomial system is determined, which suffices for the attack strategy described in Section 1. Using multiple pairs of plaintext & ciphertext results in an overdetermined system. Intuitively, this added information should decrease an attack’s complexity, implying that finding solutions for the overdetermined system should be easier. However, it is</p>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">unclear whether this is generally the case, or how to exploit the additional information in other ways. Similarly, intuition suggests that finding a collision for a hash function should be easier than computing a (second) preimage. How to turn this intuition into a polynomial model is unclear.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- In a Gröbner basis attack on an AOC, we are only interested in the polynomial’s common solutions that are elements of base field <span class="math">\\mathbb{F}</span>. One way to ensure the absence of parasitical solutions, i.e., the exclusion of elements from <span class="math">\\overline{\\mathbb{F}}\\setminus\\mathbb{F}</span>, is to add the field equations to the polynomial system. The solutions of field equation <span class="math">x^{p}-x</span> for variable <span class="math">x</span>, where $p=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, are exactly the elements of </span>\\mathbb{F}$. Unfortunately, the field equations are of very high degree, which is detrimental for a Gröbner basis algorithm’s runtime if the field size is of cryptographic relevance <em>[31, Sec. 2.1]</em>. By introducing additional variables, we can “decompose” a field equation into multiple equations, each of lower degree. It is unknown whether such decompositions lead to faster Gröbner basis computations, and if so, what the optimal trade-off between the new equations’ degrees and the number of new variables is.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Like any modern symmetric primitive, AOCs are iterated ciphers. Thus, the derived system of polynomials inherently contains sets of structurally similar polynomials. Current Gröbner basis attacks against AOCs do not exploit such similarities because it is not obvious how to do so, if it is possible at all.</li>

      <li>The polynomials processed by <span class="math">\\mathrm{F}_{4}</span> and <span class="math">\\mathrm{F}_{5}</span> generally densify during execution. Modifications allowing application of sparse linear algebra methods would result in faster algorithms both asymptotically and for current problem sizes.</li>

      <li>Given a basis for a polynomial system’s syzygy submodule, <span class="math">\\mathrm{F}_{5}</span> performs no reduction to zero. Thus, an AOC’s security can be characterized by the “non-triviality” of its syzygy space. The most efficient currently known method of finding a syzygy basis is to run <span class="math">\\mathrm{F}_{5}</span>, where it is computed as a byproduct. Some faster method to lower-bound the size of – or directly compute – the syzygy basis and the non-triviality of the involved elements could thus be used to increase confidence in a cipher’s parameters.</li>

      <li>For some ciphers, security against Gröbner basis attacks is argued by extrapolating the degree of regularity from round-reduced variants <em>[7, 81]</em>. It is unknown whether this extrapolation accurately predicts the degree of regularity of the full-round primitive.</li>

    </ul>

    <p class="text-gray-300">This work was sponsored by the Ethereum Foundation.</p>

    <h2 id="sec-43" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Albrecht, M., Perry, J.: F4/5. arXiv preprint arXiv:1006.4933 (2010)</li>

      <li>[2] Albrecht, M.R., Cid, C., Faugère, J.C., Perret, L.: On the relation between the MXL family of algorithms and Gröbner basis algorithms. Journal of Symbolic Computation 47(8), 926–941 (2012)</li>

    </ul>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">3] Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic cryptanalysis of STARK-friendly designs: Application to MARVELlous and MiMC. In: Asiacrypt. pp. 371–397. Springer (2019)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[4] Albrecht, M.R., Grassi, L., Perrin, L., Ramacher, S., Rechberger, C., Rotaru, D., Roy, A., Schofnegger, M.: Feistel structures for MPC, and more. In: ESORICS. pp. 151–171. Springer (2019)</li>

      <li>[5] Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In: Asiacrypt. pp. 191–219. Springer (2016)</li>

      <li>[6] Albrecht, M.R., Rechberger, C., Schneider, T., Tiessen, T., Zohner, M.: Ciphers for MPC and FHE. In: EuroCrypt. pp. 430–454. Springer (2015)</li>

      <li>[7] Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of symmetric-key primitives for advanced cryptographic protocols. IACR ToSC 2020(3), 1–45 (2020)</li>

      <li>[8] Amrhein, B., Gloor, O., Küchlin, W.: On the walk. Theoretical Computer Science 187(1-2), 179–202 (1997)</li>

      <li>[9] Ars, G., Faugère, J.C., Imai, H., Kawazoe, M., Sugita, M.: Comparison between XL and Gröbner basis algorithms. In: Asiacrypt. pp. 338–353. Springer (2004)</li>

      <li>[10] Ashur, T., Dhooghe, S.: MARVELlous: a STARK-friendly family of cryptographic primitives. Cryptology ePrint Archive 2018, 1098 (2018)</li>

      <li>[11] Bardet, M.: Étude des systèmes algébriques surdéterminés. Applications aux codes correcteurs et à la cryptographie. Ph.D. thesis, Université Pierre et Marie Curie-Paris VI (2004)</li>

      <li>[12] Bardet, M., Faugère, J.C., Salvy, B.: On the complexity of Gröbner basis computation of semi-regular overdetermined algebraic equations. In: International Conference on Polynomial System Solving. pp. 71–74 (2004)</li>

      <li>[13] Bardet, M., Faugère, J.C., Salvy, B.: On the complexity of the F_{5} Gröbner basis algorithm. Journal of Symbolic Computation 70, 49–70 (2015)</li>

      <li>[14] Bardet, M., Faugère, J.C., Salvy, B., Yang, B.Y.: Asymptotic behaviour of the degree of regularity of semi-regular polynomial systems. In: Proceedings of MEGA. vol. 5 (2005)</li>

      <li>[15] Bayer, D., Stillman, M.: A theorem on refining division orders by the reverse lexicographic order. Duke Mathematical Journal 55(2), 321–328 (1987)</li>

      <li>[16] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive 2018, 46 (2018)</li>

      <li>[17] Berlekamp, E.R.: Factoring polynomials over finite fields. Bell System Technical Journal 46(8), 1853–1859 (1967)</li>

      <li>[18] Beyne, T., Canteaut, A., Dinur, I., Eichlseder, M., Leander, G., Leurent, G., Naya-Plasencia, M., Perrin, L., Sasaki, Y., Todo, Y., Wiemer, F.: Out of oddity – new cryptanalytic techniques against symmetric primitives optimized for integrity proof systems. In: CRYPTO. LNCS, vol. 12172, pp. 299–328. Springer (2020)</li>

      <li>[19] Brickenstein, M.: Slimgb: Gröbner bases with slim polynomials (2005)</li>

      <li>[20] Buchberger, B.: Ein Algorithmus zum Auffinden der Basiselemente des Restklassenringes nach einem nulldimensionalen Polynomideal. PhD thesis, Universität Innsbruck (1965)</li>

      <li>[21] Buchberger, B.: A criterion for detecting unnecessary reductions in the construction of Gröbner-bases. In: EUROSAM. pp. 3–21. Springer (1979)</li>

      <li>[22] Buchberger, B.: Gröbner bases: An algorithmic method in polynomial ideal theory. Multidimensional Systems Theory (1985)</li>

    </ul>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[23] Buchberger, B.: Bruno Buchberger’s PhD thesis 1965: An algorithm for finding the basis elements of the residue class ring of a zero dimensional polynomial ideal. Journal of Symbolic Computation 41(3-4), 475–511 (2006)</li>

      <li>[24] Buchmann, J., Cabarcas, D., Ding, J., Mohamed, M.S.E.: Flexible partial enlargement to accelerate Gröbner basis computation over <span class="math">\\mathbb{F}_{2}</span>. In: AFRICACRYPT. pp. 69–81. Springer (2010)</li>

      <li>[25] Buchmann, J., Pyshkin, A., Weinmann, R.P.: Block ciphers sensitive to Gröbner basis attacks. In: CT-RSA. pp. 313–331. Springer (2006)</li>

      <li>[26] Buchmann, J.A., Ding, J., Mohamed, M.S.E., Mohamed, W.S.A.E.: MutantXL: Solving multivariate polynomial equations for cryptanalysis. In: Dagstuhl Seminar Proceedings. Schloss Dagstuhl-Leibniz-Zentrum für Informatik (2009)</li>

      <li>[27] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: IEEE Symposium on Security and Privacy. pp. 315–334. IEEE (2018)</li>

      <li>[28] Caboara, M.: A dynamic algorithm for Gröbner basis computation. In: ISSAC. pp. 275–283 (1993)</li>

      <li>[29] Caboara, M., Kreuzer, M., Robbiano, L.: Minimal sets of critical pairs. In: Mathematical Software, pp. 390–404. World Scientific (2002)</li>

      <li>[30] Caboara, M., Perry, J.: Reducing the size and number of linear programs in a dynamic Gröbner basis algorithm. Applicable Algebra in Engineering, Communication and Computing 25(1-2), 99–117 (2014)</li>

      <li>[31] Caminata, A., Gorla, E.: Solving multivariate polynomial systems and an invariant from commutative algebra. Cryptology ePrint Archive (2017)</li>

      <li>[32] Cantor, D.G., Zassenhaus, H.: A new algorithm for factoring polynomials over finite fields. Mathematics of Computation pp. 587–592 (1981)</li>

      <li>[33] Collart, S., Kalkbrener, M., Mall, D.: Converting bases with the Gröbner walk. Journal of Symbolic Computation 24(3-4), 465–469 (1997)</li>

      <li>[34] Coppersmith, D.: Solving homogeneous linear equations over gf(2) via block Wiedemann algorithm. Mathematics of Computation 62(205), 333–350 (1994)</li>

      <li>[35] Courtois, N., Klimov, A., Patarin, J., Shamir, A.: Efficient algorithms for solving overdefined systems of multivariate polynomial equations. In: EuroCrypt. pp. 392–407. Springer (2000)</li>

      <li>[36] Cox, D.A., Little, J., O’Shea, D.: Using Algebraic Geometry, vol. 185. Springer Science &amp; Business Media (2006)</li>

      <li>[37] Cox, D.A., Little, J., O’Shea, D.: Ideals, Varieties, and Algorithms: An Introduction to Computational Algebraic Geometry and Commutative Algebra. Springer Science &amp; Business Media (2013)</li>

      <li>[38] Damgård, I., Pastro, V., Smart, N., Zakarias, S.: Multiparty computation from somewhat homomorphic encryption. In: CRYPTO. pp. 643–662. Springer (2012)</li>

      <li>[39] Ding, J., Buchmann, J., Mohamed, M.S.E., Mohamed, W.S.A.E., Weinmann, R.P.: MutantXL (2008)</li>

      <li>[40] Ding, J., Schmidt, D.: Solving degree and degree of regularity for polynomial systems over a finite fields. In: Number Theory and Cryptography, pp. 34–49. Springer (2013)</li>

      <li>[41] Ding, J., Zhang, Z., Deaton, J.: How much can f5 really do? Cryptology ePrint Archive 2021, 51 (2021)</li>

      <li>[42] Dubois, V., Gama, N.: The degree of regularity of HFE systems. In: Asiacrypt. pp. 557–576. Springer (2010)</li>

      <li>[43] Dubé, T.W.: The structure of polynomial ideals and Gröbner bases. SIAM Journal on Computing 19(4), 750–773 (1990)</li>

    </ul>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[44] Eder, C., Faugère, J.C.: A survey on signature-based algorithms for computing Gröbner bases. Journal of Symbolic Computation 80, 719–784 (2017)</li>

      <li>[45] Eder, C., Roune, B.H.: Signature rewriting in Gröbner basis computation. In: ISSAC. pp. 331–338 (2013)</li>

      <li>[46] Faugère, J.C.: A new efficient algorithm for computing Gröbner bases (<span class="math">F_{4}</span>). Journal of Pure and Applied Algebra 139(1-3), 61–88 (1999)</li>

      <li>[47] Faugère, J.C.: A new efficient algorithm for computing Gröbner bases without reduction to zero (<span class="math">F_{5}</span>). In: ISSAC. pp. 75–83 (2002)</li>

      <li>[48] Faugère, J.C., Gianni, P., Lazard, D., Mora, T.: Efficient computation of zero-dimensional Gröbner bases by change of ordering. Journal of Symbolic Computation 16(4), 329–344 (1993)</li>

      <li>[49] Faugère, J.C., Mou, C.: Sparse FGLM algorithms. Journal of Symbolic Computation 80, 538–569 (2017)</li>

      <li>[50] Fukuda, K., Jensen, A., Thomas, R.: Computing Gröbner fans. Mathematics of Computation 76(260), 2189–2212 (2007)</li>

      <li>[51] Fukuda, K., Jensen, A.N., Lauritzen, N., Thomas, R.: The generic Gröbner walk. Journal of Symbolic Computation 42(3), 298–312 (2007)</li>

      <li>[52] Gao, S., Volny IV, F., Wang, M.: A new algorithm for computing Gröbner bases. Cryptology ePrint Archive (2010)</li>

      <li>[53] Gao, S., Volny IV, F., Wang, M.: A new algorithm for computing Gröbner bases (rev. 2013) (2013)</li>

      <li>[54] von zur Gathen, J., Gerhard, J.: Modern Computer Algebra. Cambridge university press (2013)</li>

      <li>[55] Gebauer, R., Möller, H.M.: On an installation of Buchberger’s algorithm. Journal of Symbolic Computation 6(2-3), 275–286 (1988)</li>

      <li>[56] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: EuroCrypt. pp. 626–645. Springer (2013)</li>

      <li>[57] Giovini, A., Mora, T., Niesi, G., Robbiano, L., Traverso, C.: “One sugar cube, please” or selection strategies in the Buchberger algorithm. In: ISSAC. pp. 49–54 (1991)</li>

      <li>[58] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. In: USENIX Security. USENIX Association (2020)</li>

      <li>[59] Greuel, G.M., Pfister, G.: A Singular Introduction to Commutative Algebra. Springer Science &amp; Business Media (2012)</li>

      <li>[60] Hartshorne, R.: Algebraic Geometry, vol. 52. Springer Science &amp; Business Media (2013)</li>

      <li>[61] Hashemi, A., Lazard, D.: Sharper complexity bounds for zero-dimensional Gröbner bases and polynomial system solving. International Journal of Algebra and Computation 21(05), 703–713 (2011)</li>

      <li>[62] Hilbert, D.: Über die Theorie der algebraischen Formen. Mathematische Annalen 36(4), 473–534 (1890)</li>

      <li>[63] Hong, H., Perry, J.: Are Buchberger’s criteria necessary for the chain condition? Journal of Symbolic Computation 42(7), 717–732 (2007)</li>

      <li>[64] Hyun, S.G., Neiger, V., Rahkooy, H., Schost, É.: Block-Krylov techniques in the context of sparse-FGLM algorithms. Journal of Symbolic Computation 98, 163–191 (2020)</li>

      <li>[65] Ito, T., Shinohara, N., Uchiyama, S.: An efficient F_{4}-style based algorithm to solve MQ problems. In: International Workshop on Security. pp. 37–52. Springer (2019)</li>

      <li>[66] Jakobsen, T., Knudsen, L.R.: The interpolation attack on block ciphers. In: FSE. pp. 28–40. Springer (1997)</li>

    </ul>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(67) Kaltofen, E., Shoup, V.: Subquadratic-time factoring of polynomials over finite fields. Mathematics of Computation 67(223), 1179–1197 (1998)</li>

      <li>(68) Kedlaya, K.S., Umans, C.: Fast modular composition in any characteristic. In: FOCS. pp. 146–155. IEEE (2008)</li>

      <li>(69) Lazard, D.: Gröbner bases, Gaussian elimination and resolution of systems of algebraic equations. In: EUROCAL. pp. 146–156. Springer (1983)</li>

      <li>(70) Macaulay, F.S.: Some formulæ in elimination. Proceedings of the London Mathematical Society 1(1), 3–27 (1902)</li>

      <li>(71) Marinari, M.G., Moeller, H.M., Mora, T.: Gröbner bases of ideals defined by functionals with an application to ideals of projective points. Applicable Algebra in Engineering, Communication and Computing 4(2), 103–145 (1993)</li>

      <li>(72) Mayr, E.W., Meyer, A.R.: The complexity of the word problems for commutative semigroups and polynomial ideals. Advances in Mathematics 46(3), 305–329 (1982)</li>

      <li>(73) Mayr, E.W., Ritscher, S.: Dimension-dependent bounds for Gröbner bases of polynomial ideals. Journal of Symbolic Computation 49, 78–94 (2013)</li>

      <li>(74) Mohamed, M.S.E., Cabarcas, D., Ding, J., Buchmann, J., Bulygin, S.: <span class="math">\\mathrm{MXL}_{3}</span>: An efficient algorithm for computing Gröbner bases of zero-dimensional ideals. In: ICISC. pp. 87–100. Springer (2009)</li>

      <li>(75) Mohamed, M.S.E., Mohamed, W.S.A.E., Ding, J., Buchmann, J.: <span class="math">\\mathrm{MXL2}</span>: Solving polynomial equations over <span class="math">\\mathrm{GF}(2)</span> using an improved Mutant strategy. In: International Workshop on Post-Quantum Cryptography. pp. 203–215. Springer (2008)</li>

      <li>(76) Mohamed, W.S.A.: Improvements for the XL Algorithm with Applications to Algebraic Cryptanalysis. Ph.D. thesis, Technische Universität Darmstadt, Darmstadt (2011)</li>

      <li>(77) Mohamed, W.S.A., Ding, J., Kleinjung, T., Bulygin, S., Buchmann, J.: <span class="math">\\mathrm{PWXL}</span>: A parallel Wiedemann-XL algorithm for solving polynomial equations over <span class="math">\\mathrm{GF}(2)</span>. In: Conference on Symbolic Computation and Cryptography. p. 89. Citeseer (2010)</li>

      <li>(78) Mora, T., Robbiano, L.: The Gröbner fan of an ideal. Journal of Symbolic Computation 6(2-3), 183–208 (1988)</li>

      <li>(79) Möller, H.M., Mora, T., Traverso, C.: Gröbner bases computation using syzygies. In: ISSAC. pp. 320–328 (1992)</li>

      <li>(80) Perry, J.: Exploring the dynamic Buchberger algorithm. In: ISSAC. pp. 365–372 (2017)</li>

      <li>(81) Szepieniec, A., Ashur, T., Dhooghe, S.: Rescue-Prime: a standard specification (SoK). Cryptology ePrint Archive, Report 2020/1143 (2020)</li>

      <li>(82) Tran, Q.N.: A fast algorithm for Gröbner basis conversion and its applications. Journal of Symbolic Computation 30(4), 451–467 (2000)</li>

      <li>(83) Wiedemann, D.: Solving sparse linear equations over finite fields. IEEE Transactions on Information Theory 32(1), 54–62 (1986)</li>

      <li>(84) Yap, C.K.: A new lower bound construction for commutative Thue systems with applications. Journal of Symbolic Computation 12(1), 1–27 (1991)</li>

      <li>(85) Yeh, J.Y.C., Cheng, C.M., Yang, B.Y.: Operating degrees for XL vs. <span class="math">\\mathrm{F}_{4}/\\mathrm{F}_{5}</span> for generic <span class="math">\\mathcal{MQ}</span> with number of equations linear in that of variables. In: Number Theory and Cryptography, pp. 19–33. Springer (2013)</li>

    </ul>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">In Table 3, we briefly summarize the notation used in this document.</p>

    <p class="text-gray-300">Table 3: Notation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">symbol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">expansion</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">explanation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">field, typically of prime order</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">algebraic closure of F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F[x]</td>

            <td class="px-3 py-2 border-b border-gray-700">F[x0, ..., xn-1]</td>

            <td class="px-3 py-2 border-b border-gray-700">multivariate polynomial ring</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">variable</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">(x0, ..., xn-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">vector of variables</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α</td>

            <td class="px-3 py-2 border-b border-gray-700">(α0, ..., αn-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">exponent vector</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xα</td>

            <td class="px-3 py-2 border-b border-gray-700">(x0α0, ..., xn-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">monomial</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">deg(xα)</td>

            <td class="px-3 py-2 border-b border-gray-700">∑iαi</td>

            <td class="px-3 py-2 border-b border-gray-700">total degree of xα</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cαxα</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">term</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f</td>

            <td class="px-3 py-2 border-b border-gray-700">∑αcαxα</td>

            <td class="px-3 py-2 border-b border-gray-700">polynomial</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f- G r</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">full reduction of f by G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">set of all monomials</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M(f)</td>

            <td class="px-3 py-2 border-b border-gray-700">{xα</td>

            <td class="px-3 py-2 border-b border-gray-700">cα ≠ 0}</td>

            <td class="px-3 py-2 border-b border-gray-700">monomials occurring in f</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">∪g∈G M(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">extension of M(f) to sets</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">set of all terms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≠</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">monomial order on M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≠</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">extension of ≠ to F[x]s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lc(f)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">leading coefficient of f</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lm(f)</td>

            <td class="px-3 py-2 border-b border-gray-700">max≠{xα ∈ M(f)</td>

            <td class="px-3 py-2 border-b border-gray-700">cα ≠ 0}</td>

            <td class="px-3 py-2 border-b border-gray-700">leading monomial of f</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lt(f)</td>

            <td class="px-3 py-2 border-b border-gray-700">lc(f) · lm(f)</td>

            <td class="px-3 py-2 border-b border-gray-700">leading term of f</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lf(f)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">leading form of f</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lc(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">∪g∈G lc(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">extension of lc to sets</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lm(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">∪g∈G lm(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">extension of lm to sets</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lt(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">∪g∈G lt(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">extension of lt to sets</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">lf(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">∪g∈G lf(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">extension of lf to sets</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">polynomial ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">{f0, ..., fs-1}</td>

            <td class="px-3 py-2 border-b border-gray-700">{∑i pi fi</td>

            <td class="px-3 py-2 border-b border-gray-700">pi ∈ F[x]}</td>

            <td class="px-3 py-2 border-b border-gray-700">ideal spanned by the fi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f=0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">polynomial equation of f</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V(I)</td>

            <td class="px-3 py-2 border-b border-gray-700">{a ∈ Fn</td>

            <td class="px-3 py-2 border-b border-gray-700">∀f ∈ I : f(a) = 0}</td>

            <td class="px-3 py-2 border-b border-gray-700">affine variety of ideal I</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ei</td>

            <td class="px-3 py-2 border-b border-gray-700">(0, ..., 0, 1, 0, ..., 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">i-th unit vector</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">φF(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">∑i gi fi for fi ∈ F</td>

            <td class="px-3 py-2 border-b border-gray-700">map from F[x]s to F[x]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">lm≠(g)</td>

            <td class="px-3 py-2 border-b border-gray-700">signature vector of g ∈ F[x]s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">J.F. Sauer, A. Szepieniec</p>

    <p class="text-gray-300">We restate the multivariate division algorithm of [37, Ch. 2, §3] in Algorithm 10.</p>

    <p class="text-gray-300">| Algorithm 10: MULTIVARIATE POLYNOMIAL DIVISION |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| Input: polynomials f, g0, ..., gt-1 ∈ F[x] |</p>

    <p class="text-gray-300">| Output: polynomials q0, ..., qt-1, r ∈ F[x] such that f = ∑i=0t-1qi gi + r |</p>

    <p class="text-gray-300">| 1 q0 = ... = qt-1 = r = 0 |</p>

    <p class="text-gray-300">| 2 p = f |</p>

    <p class="text-gray-300">| 3 while p ≠ 0 do |</p>

    <p class="text-gray-300">| 4 i = 0 |</p>

    <p class="text-gray-300">| 5 division_occured = False |</p>

    <p class="text-gray-300">| 6 while i < t and not division_occured do |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7 if lt(gi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lt(p) then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 8 qi = qi + lt(p)/lt(gi) |</p>

    <p class="text-gray-300">| 9 p = p - (lt(p)/lt(gi)) gi |</p>

    <p class="text-gray-300">| 10 division_occured = True |</p>

    <p class="text-gray-300">| 11 else |</p>

    <p class="text-gray-300">| 12 i = i + 1 |</p>

    <p class="text-gray-300">| 13 if not division_occured then |</p>

    <p class="text-gray-300">| 14 r = r + lt(p) |</p>

    <p class="text-gray-300">| 15 p = p - lt(p) |</p>

    <p class="text-gray-300">| 16 return q0, ..., qt-1, r |</p>

    <p class="text-gray-300">SoK: Gröbner Basis Algorithms for AOCs</p>

    <p class="text-gray-300">In Algorithm 11, we describe regular  <span class="math">\\mathfrak{s}</span> -reduction of a vector of origin  <span class="math">\\pmb{f}</span>  by a set of vectors of origin  <span class="math">\\pmb{g}_0, \\dots, \\pmb{g}_{t-1}</span> , as given in [37, Ch. 10, §4]. The  <span class="math">\\mathrm{F}_5</span>  algorithm of Section 3.2 uses regular  <span class="math">\\mathfrak{s}</span> -reduction as a subroutine. Note the structural similarities to multivariate polynomial division of Algorithm 10.</p>

    <p class="text-gray-300">By changing the second condition in Line 8 to require equality of signatures, the  <span class="math">\\mathfrak{s}</span> -reduction becomes singular as opposed to regular. "Plain"  <span class="math">\\mathfrak{s}</span> -reduction, being neither regular nor singular, can be achieved by modifying the same condition to only disallow all signatures  <span class="math">\\gg</span> -greater than  <span class="math">\\mathfrak{s}(\\boldsymbol{r})</span> , i.e., allowing both regular and singular  <span class="math">\\mathfrak{s}</span> -reduction steps.</p>

    <p class="text-gray-300">Algorithm 11: REGULAR  <span class="math">\\mathfrak{s}</span> -REDUCTION Input: vectors of origin  <span class="math">f,g_0,\\ldots ,g_{t - 1}\\in \\mathbb{F}[\\mathbf{x}]^<em></span>  Output: vector of origin  <span class="math">\\pmb {r}\\in \\mathbb{F}[\\mathbf{x}]^{</em>}</span> 1  <span class="math">\\pmb {r} = \\pmb{f}</span> 2 poly_r = 0 3 while  <span class="math">\\phi (\\pmb {r})\\neq</span>  poly_r do 4  <span class="math">m = \\mathrm{lt}(\\phi (\\pmb {r}) - \\mathrm{poly\\_r})</span> 5  <span class="math">i = 0</span> 6 reduction_occured  <span class="math">=</span>  False 7 while  <span class="math">i &amp;lt;   t</span>  and not reduction_occured do 8 if  <span class="math">\\mathrm{lt}(\\phi (\\pmb {g}_i))\\mid m</span>  and  <span class="math">\\mathfrak{s}\\left(\\frac{m}{\\mathrm{lt}(\\phi(\\pmb{g}_i))}\\pmb {g}_i\\right)\\ll \\mathfrak{s}(\\pmb {r})</span>  then 9  <span class="math">\\begin{array}{r}\\pmb {r} = \\pmb {r} - \\frac{m}{\\mathrm{lt}(\\phi(\\pmb{g}_i))}\\pmb {g}_i\\\\ \\mathrm{reduction\\_occured} = \\mathrm{True}\\\\ \\mathrm{else}\\\\ \\mathrm{i} = i + 1 \\end{array}</span> 10 11 12 13 if not reduction_occured then 14 poly_r = poly_r + m 15 return  <span class="math">\\pmb{r}</span></p>`;
---

<BaseLayout title="SoK: Gröbner Basis Algorithms for Arithmetization Oriented C... (2021/870)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/870
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
