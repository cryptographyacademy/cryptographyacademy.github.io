---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/532';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Concretely-Efficient Zero-Knowledge Arguments for Arithmetic Circuits and Their Application to Lattice-Based Cryptography';
const AUTHORS_HTML = 'Carsten Baum, Ariel Nof';

const CONTENT = `    <p class="text-gray-300">Carsten Baum^{1} Ariel Nof^{2}</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In this work we present a new interactive Zero-Knowledge Argument of knowledge for general arithmetic circuits. Our protocol is based on the “MPC-in-the-head”-paradigm of Ishai et al. (STOC 2009) and follows the recent “MPC-in-the-head with Preprocessing” as proposed by Katz, Kolesnikov and Wang (ACM CCS 2018). However, in contrast to Katz et al. who used the “cut-and-choose” approach for pre-processing, we show how to incorporate the well-known “sacrificing” paradigm into “MPC-in-the-head”, which reduces the proof size when working over arithmetic circuits.</p>

    <p class="text-gray-300">Our argument system uses only lightweight symmetric-key primitives and utilizes a simplified version of the so-called SPDZ-protocol.</p>

    <p class="text-gray-300">Based on specific properties of our protocol we then show how it can be used to construct an efficient Zero-Knowledge Argument of Knowledge for instances of the Short Integer Solution (SIS) problem. We present different protocols that are tailored to specific uses of SIS, while utilizing the advantages of our scheme. In particular, we present a variant of our argument system that allows the parties to sample the circuit “on the fly”, which may be of independent interest.</p>

    <p class="text-gray-300">We furthermore implemented our Zero-Knowledge argument for SIS and show that using our protocols it is possible to run a complete interactive proof, even for general SIS instances which result in a circuit with <span class="math">&gt;10^{6}</span> gates, in less than 0.5 seconds.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero-Knowledge Arguments of Knowledge (ZKAoK) are interactive protocols that allow a computationally bounded prover to convince a verifier that he knows a witness for a certain statement, without revealing any further information about the witness. Since their introduction in the 80’s <em>[x10]</em> these protocols have been important building blocks for applications in cryptography. While solutions for very specific languages have been plentiful, many applications require the use of arbitrary (algebraic) circuits in order to prove complex relationships. For example, proving that two homomorphic commitments contain the same committed message is generally an easy task, while proving knowledge of a preimage of a SHA-256 hash requires more generic solutions. Recent years saw a variety of different techniques which aim at providing such ZKAoK (see <em>[x22, x11, x1, x12, x1, WTS^{+}18,BCR^{+}19]</em> to just name a few), varying in terms of argument size, prover/verification time, interaction and assumptions. While many of these systems perform very well with large witnesses and circuit sizes, none of them are a one-size-fits-all solution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As an example, consider the so-called Short Integer Solution (SIS) problem. Here, a verifier has a matrix <span class="math">\\mathbf{A}</span> and a vector <span class="math">\\mathbf{t}</span> while the prover wants to prove knowledge of a secret <span class="math">\\mathbf{s}</span> such that <span class="math">\\mathbf{t}=\\mathbf{A}\\mathbf{s}\\bmod q</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta<span class="math">. SIS and related problems are crucial building blocks for post-quantum lattice-based cryptography and constructing efficient ZKAoK with a small communication complexity and low prover’s running time has long been a problem: the soundness error of current special-purpose protocols is constant, meaning that the arguments have to be repeated many times to actually be convincing to a verifier. A particular, non-standard approach has been suggested by Bendlin &amp; Damgård <em>[x3]</em>, who were the first to examine arguments of knowledge for SIS using generic proof systems. They observed that for certain argument schemes, the function that is computed to validate a SIS instance has both a very low multiplication depth and low total number of multiplications, if the secret </span>\\mathbf{s}$ is a binary vector. However, many general ZKAoK systems only provide asymptotic efficiency, meaning that they require the circuit to be big before their strengths play out <em>[BBC^{+}18]</em>. Moreover, many of these approaches achieve sub-linear communication complexity at</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the cost of high prover’s running time <em>[x1, x16]</em>. Other approaches are insecure to post-quantum attacks <em>[WTS^{+}18, x21, x17]</em> or rely on knowledge assumptions that are poorly understood.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 ‘MPC-in-the-Head’ and Preprocessing</h3>

    <p class="text-gray-300">The “MPC-in-the-head” paradigm is a general technique which is used in our construction. Before outlining our contributions, we first describe this paradigm.</p>

    <p class="text-gray-300">MPC or Secure Multiparty Computation describes a type of interactive protocol which allows to securely compute functions on secret data. No information is leaked beyond the output of the function with correctness even in the presence of dishonest participants.</p>

    <p class="text-gray-300">MPC-in-the-head was introduced by Ishai et al. <em>[x15]</em> as a technique to construct generic zero-knowledge proofs from MPC protocols. Here, the statement to be proven is rewritten into a circuit <span class="math">C</span>, which outputs <span class="math">y</span> if and only if its input <span class="math">w</span> is a correct witness for the statement to be proven. The prover simulates all parties of an MPC protocol as well as their interaction in his head. These parties obtain a secret-sharing of the witness <span class="math">w</span> as their input, run a protocol to evaluate <span class="math">C</span> and send the outputs to the verifier. Moreover, the prover commits to the inputs as well as randomness and exchanged messages of each party separately, and opens a verifier-chosen subset of these commitments to the verifier. The verifier then checks if these parties were simulated correctly by the prover and that the messages and the outputs are consistent. On a very high level, this is a proof of the statement if the MPC scheme is robust against active attacks, and it is zero-knowledge due to the privacy of it.</p>

    <p class="text-gray-300">Preprocessing is a widely used optimization of practical MPC schemes. Here, each party begins the actual protocol with shares of correlated randomness, which is itself independent of the inputs of the protocol. This correlated randomness is then used to speed up the actual computation, and due to its independence of the inputs it can be computed ahead of time. To the best of our knowledge, the first MPC-in-the-head scheme that uses preprocessing was introduced in <em>[x18]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Our Contributions</h3>

    <p class="text-gray-300">In this work, we construct a new practically efficient ZKAoK for arithmetic circuits together with a multitude of techniques and apply these to construct interactive arguments for SIS. Our scheme is based on the “MPC-in-the-head” approach and uses only symmetric-key primitives. It has an argument size that only depends on non-linear gates of the circuit <span class="math">C</span> and low prover running time. We implemented our construction and report on its practicality. In more details:</p>

    <p class="text-gray-300">‘MPC-in-the-Head’ with Preprocessing. We first generalize the idea of <em>[x18]</em> to work over arithmetic circuits using a variant of the SPDZ MPC protocol <em>[x10, x17]</em> and provide a formal proof of security to their “cut-and-choose” preprocessing heuristic. Then, we present a new construction where we replace the “cut-and-choose” mechanism with a “sacrificing”-based approach. While both approaches have similar cost per MPC instance, our “sacrificing”-based approach yields a smaller cheating probability, which means that the number of MPC instances simulated in the proof can be significantly smaller, thus reducing the overall communication footprint. Our scheme is highly flexible in its choice of parameters. In particular, by changing the number of parties in the underlying MPC protocol, one can alternate between achieving low communication and low running time. Our construction only requires efficient standard symmetric primitives, and thus is plausibly post-quantum secure even in the non-interactive case <em>[x12]</em>. The two constructions can be found in Section 3.</p>

    <p class="text-gray-300">Application to SIS. The MPC scheme which we use in our construction allows to perform additions and multiplications with public values “for free”, meaning those do not have an impact on the size of the argument. In the SIS problem the verification of the input of the prover consists of computing a product with a public</p>

    <p class="text-gray-300">matrix <span class="math">\\mathbf{A}</span> <em>and</em> a proof that the secret <span class="math">\\mathbf{s}</span> contains bounded values, so the first part comes essentially for free. We initially tweak the approach of <em>[x1]</em> and only allow <span class="math">\\mathbf{s}</span> to consist of bits, which allows for a very fast argument of size using one square gate per element of <span class="math">\\mathbf{s}</span>. Then, we show how to handle more general distributions of <span class="math">\\mathbf{s}</span> and introduce some specific optimizations to reduce communication and computation. In particular, we show how to adapt advanced techniques such as rejection sampling into the MPC-in-the-head framework, which yields a circuit with only linear gates. This is described in Section 5.</p>

    <h5 id="sec-6" class="text-base font-semibold mt-4">Experimental Results</h5>

    <p class="text-gray-300">We implemented our zero-knowledge protocol for the Binary SIS problem (i.e., where the secret <span class="math">\\mathbf{s}</span> is a vector of bits) and ran extensive experiments with various sets of parameters – both for the SIS problem and for the simulated MPC protocol. For a 61-bit field and a matrix <span class="math">\\mathbf{A}</span> of size <span class="math">1024\\times 4096</span> (which suffices for many applications such as encryption or commitments), we are able to run our argument in 1.2 seconds for 40-bits of statistical security when working with a single thread. When utilizing 32 threads, this reduces to only 250 ms. This shows that general lattice-based ZK arguments (which do not rely on structured lattices) are practical and can be used in real-world applications. To the best of our knowledge, we are also the first to implement ZK arguments for general SIS. The results and all the details can be found in Section 6.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Sampling Circuits on the fly</h5>

    <p class="text-gray-300">A major source of optimizations to our application is the fact that our “MPC-in-the-head” protocol allows the prover and the verifier to negotiate the circuit <span class="math">C</span> <em>during the protocol</em>, under certain circumstances. This fact is used by us to construct circuits “on the fly” with fewer non-linear gates, which helps to reduce the argument size. Thus, as an additional contribution of this work, we provide formal definitions for an argument system where the circuit is sampled jointly by the prover and the verifier during the execution and show how to incorporate this into our protocols. This is described in Section 4.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Unless stated otherwise, operations in this work are carried out over the field <span class="math">\\mathbb{F}=\\mathbb{F}_{q}</span> for an odd prime <span class="math">q</span>. <span class="math">\\mathbb{F}_{q}</span>-elements are identified by the interval <span class="math">[-(q-1)/2,(q-1)/2]</span>. <span class="math">\\mathbb{B}</span> denotes the set <span class="math">\\{0,1\\}</span> while <span class="math">[n]</span> stands for <span class="math">\\{1,\\ldots,n\\}</span>. We use <span class="math">\\lambda</span> as the computational and <span class="math">\\kappa</span> as the statistical security parameters, and generally assume that <span class="math">q\\approx poly(\\lambda,\\kappa)</span>. We use bold lower-case letters such as <span class="math">\\mathbf{s}</span> to denote a vector and bold upper-case letters like <span class="math">\\mathbf{A}</span> for matrices. We let <span class="math">\\mathbf{s}[i]</span> denote the <span class="math">i</span>th component of the vector <span class="math">\\mathbf{s}</span>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Programming Model</h3>

    <p class="text-gray-300">Our notation for the circuits that we use in this paper will be similar to <em>[x2]</em>. The circuit <span class="math">C=(n_{\\texttt{in}},n_{\\texttt{out}},n_{C},L,R,F)</span> is defined over <span class="math">\\mathbb{F}</span>, and each wire <span class="math">w</span> will hold a value from <span class="math">\\mathbb{F}</span> or <span class="math">\\bot</span> initially. <span class="math">C</span> has <span class="math">n_{\\texttt{in}}</span> input wires, <span class="math">n_{\\texttt{out}}</span> output wires and <span class="math">n_{C}\\geq n_{\\texttt{in}}+n_{\\texttt{out}}</span> wires in total. We define <span class="math">\\mathcal{I}=\\{1,\\ldots,n_{\\texttt{in}}\\},\\mathcal{W}=\\{1,\\ldots,n_{C}\\}</span> and <span class="math">\\mathcal{O}=\\{n_{C}-n_{\\texttt{out}}+1,\\ldots,n_{C}\\}</span>. The circuit has <span class="math">n_{\\texttt{gates}}=n_{C}-n_{\\texttt{in}}</span> gates in total and we define the set <span class="math">\\mathcal{G}=\\{n_{\\texttt{in}}+1,\\ldots,n_{C}\\}</span>.</p>

    <p class="text-gray-300">We define functions <span class="math">L:\\mathcal{G}\\to\\mathcal{W}</span>, <span class="math">R:\\mathcal{G}\\to\\mathcal{W}\\cup\\{\\bot\\}</span> such that <span class="math">L(x)&lt;x</span> as well as <span class="math">L(x)&lt;R(x)&lt;x</span> if <span class="math">R(x)\\neq\\bot</span> (i.e., the function <span class="math">L(x)</span> returns the index of the left input wire of the gate whereas the function <span class="math">R(x)</span> returns the index of the right input wire if it exists). The function <span class="math">F:\\mathcal{G}\\times\\mathbb{F}\\times(\\mathbb{F}\\cup\\{\\bot\\})\\to\\mathbb{F}</span> determines the function which is computed by each gate.</p>

    <p class="text-gray-300">The algorithm <span class="math">\\texttt{eval}(C,\\mathbf{x})</span> with <span class="math">\\mathbf{x}\\in\\mathbb{F}^{n_{\\texttt{in}}}</span> is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i\\in[n_{\\texttt{in}}]</span> set <span class="math">w_{i}\\leftarrow\\mathbf{x}[i]</span>.</li>

      <li>For each <span class="math">g\\in\\mathcal{G}</span> set <span class="math">l\\leftarrow L(g),r\\leftarrow R(g)</span> and then <span class="math">w_{g}\\leftarrow F(g,l,r)</span>.</li>

      <li>Output <span class="math">\\mathbf{y}=(w_{n_{C}-n_{\\texttt{out}}+1},\\ldots,w_{n_{C}})^{\\top}</span>.</li>

    </ol>

    <p class="text-gray-300">We further restrict <span class="math">F</span> to compute certain functions only: (i) Add: On input <span class="math">x_{1},x_{2}</span> output <span class="math">x_{1}+x_{2}</span>, (ii) Mult: On input <span class="math">x_{1},x_{2}</span> output <span class="math">x_{1}\\times x_{2}</span>, (iii) CAdd: On input <span class="math">x</span> and for the hard-wired <span class="math">a</span> output <span class="math">x+a</span>, (iv) CMult: On input <span class="math">x</span> and for the hard-wired <span class="math">a</span> output <span class="math">x\\times a</span>; and (v) Square: On input <span class="math">x</span> output <span class="math">x^{2}</span>. We say that <span class="math">C(\\mathbf{x})=\\mathbf{y}</span> if <span class="math">\\texttt{eval}(C,\\mathbf{x})</span> returns the value <span class="math">\\mathbf{y}\\in\\mathbb{F}^{n_{\\texttt{out}}}</span>. We denote by <span class="math">n_{mul}</span> and <span class="math">n_{sq}</span> the number of multiplication and square gates in the circuit.</p>

    <p class="text-gray-300">2.2 Zero-Knowledge Arguments of Knowledge</p>

    <p class="text-gray-300">Let TM be an abbreviation for Turing Machines. An iTM is defined to be an interactive TM, i.e. a Turing Machine with a special communication tape and a PPT TM is a probabilistic polynomial-time TM. Let <span class="math">L_{R}\\subseteq\\mathbb{B}^{*}</span> be an NP language and <span class="math">R</span> be its related NP-relation for circuits over <span class="math">\\mathbb{F}</span>. Thus <span class="math">(x=(C,\\mathbf{y}),\\mathbf{w})\\in R</span> iff <span class="math">(C,\\mathbf{y})\\in L_{R}</span> and <span class="math">\\texttt{eval}(C,\\mathbf{w})=\\mathbf{y}</span>. We write <span class="math">R_{x}=\\{\\mathbf{w}\\mid(x,\\mathbf{w})\\in R\\}</span> for the set of witnesses for a fixed <span class="math">x</span>.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Honest Verifier Zero Knowledge Argument of Knowledge (HVZKAoK)</h4>

    <p class="text-gray-300">Assume <span class="math">(\\mathcal{P},\\mathcal{V})</span> is a pair of PPT iTMs and let <span class="math">\\xi:\\mathbb{B}^{<em>}\\rightarrow[0,1]</span> be a function. We say that <span class="math">(\\mathcal{P},\\mathcal{V})</span> is a </em>zero-knowledge argument of knowledge<em> for the relation <span class="math">R</span> with </em>knowledge error* <span class="math">\\xi</span> if the following properties hold:</p>

    <p class="text-gray-300">Completeness: If <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> follow the protocol on input <span class="math">x\\in L_{R}</span> and private input <span class="math">\\mathbf{w}\\in R_{x}</span> to <span class="math">\\mathcal{P}</span>, then <span class="math">\\mathcal{V}</span> always outputs <span class="math">1</span>.</p>

    <p class="text-gray-300">Knowledge Soundness: There exists a probabilistic algorithm <span class="math">\\mathcal{E}</span> called the <em>knowledge extractor</em>, such that for every interactive prover <span class="math">\\hat{\\mathcal{P}}</span> and every <span class="math">x\\in L_{R}</span>, the algorithm <span class="math">\\mathcal{E}</span> satisfies the following condition: let <span class="math">\\delta(x)</span> the probability that <span class="math">\\mathcal{V}</span> accepts on input <span class="math">x</span> after interacting with <span class="math">\\hat{\\mathcal{P}}</span>. If <span class="math">\\delta(x)&gt;\\xi(x)</span>, then upon input <span class="math">x\\in L_{R}</span> and oracle access to <span class="math">\\hat{\\mathcal{P}}</span>, the algorithm <span class="math">\\mathcal{E}</span> outputs a vector <span class="math">\\mathbf{w}\\in R_{x}</span> in expected number of steps bounded by <span class="math">O(\\frac{1}{\\delta(x)-\\xi(x)})</span>.</p>

    <p class="text-gray-300">Honest Verifier Zero-Knowledge: Let <span class="math">\\mathsf{view}^{\\mathcal{P}}_{\\mathcal{V}}(x,\\mathbf{w})</span> be a random variable describing the random challenge of <span class="math">\\mathcal{V}</span> and the messages <span class="math">\\mathcal{V}</span> receives from <span class="math">\\mathcal{P}</span> with input <span class="math">\\mathbf{w}</span> during the joint computation on common input <span class="math">x</span>. Then, there exists a PPT simulator <span class="math">\\mathcal{S}</span>, such that for all <span class="math">x\\in L_{R},\\mathbf{w}\\in R_{x}</span>: <span class="math">\\mathcal{S}(x)\\approx_{c}\\mathsf{view}^{\\mathcal{P}}_{\\mathcal{V}}(x,\\mathbf{w})</span>.</p>

    <p class="text-gray-300">This definition suffices, since public-coin protocols like the protocols we consider in this work, which satisfy the above properties, can be easily transformed to protocols which are zero-knowledge in general by having the verifier commit to its challenges at the beginning of the protocol. As is well known, it is possible to obtain a non-interactive zero-knowledge argument of knowledge (NIZKAoK) from any HVZKAoK via the Fiat-Shamir transformation <em>[x10]</em>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.3 Commitments and Collision-Resistant Hash Functions</h3>

    <p class="text-gray-300">We use <em>Commitments</em> and <em>Collision-Resistant</em> Hash Functions (CRHF) as buildings blocks in our constructions and thus introduce them now briefly. A commitment scheme allows one party to commit to a message <span class="math">m</span> by sending a commitment value which satisfies the following two properties: (i) <em>Hiding:</em> the commitment reveals nothing about <span class="math">m</span>.; and (ii) <em>Binding:</em> it is (computationally) infeasible for the committing party to open a committed message <span class="math">m</span> to different message <span class="math">m^{\\prime}\\neq m</span>. In this work, we assume that the commitment scheme is instantiated using a cryptographic hash function such as e.g. SHA-256, which we model as a Random Oracle for the purpose of giving a proof of security.</p>

    <p class="text-gray-300">A Collision-Resistant Hash Function (CRHF) is an efficiently computable function <span class="math">H</span> for which it is “hard” to find <span class="math">x,x^{\\prime}</span> such that <span class="math">H(x)=H(x^{\\prime})</span>. Usually, CRHFs are used to compress a long message into a short digest and thus for almost all messages a collision exists. CRHFs require that a collision is hard to find for any PPT algorithm.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.4 The Short Integer Solution Problem</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will now formalize the SIS problem, which was already informally introduced in the introduction. <span class="math">\\mathbb{F}_{q}</span> is the base field of the argument system. At the same time, the characteristic <span class="math">q</span> will also be the modulus of the SIS instance which is defined over <span class="math">\\mathbb{Z}_{q}</span>. To define the Short Integer Solution problem, let <span class="math">n,m\\in\\mathbb{N}</span> be such that <span class="math">n\\ll m</span>. We naturally embed <span class="math">\\mathbb{Z}_{q}</span> into <span class="math">\\mathbb{Z}</span> by identifying each <span class="math">\\mod q</span>-number with an element from the interval <span class="math">[-\\frac{q-1}{2},\\frac{q-1}{2}]\\subset\\mathbb{Z}</span>. We thereby let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> be the </span>\\infty<span class="math">-norm of the embedding of </span>\\mathbf{s}\\in\\mathbb{Z}_{q}^{m}<span class="math"> into the module </span>\\mathbb{Z}^{m}<span class="math">. Define </span>S^{m}_{\\beta}\\subset\\mathbb{Z}_{q}^{m}<span class="math"> as the subset of </span>m<span class="math">-element vectors with </span>\\ell_{\\infty}<span class="math">-norm </span>\\leq\\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Definition 1 (Short Integer Solution (SIS)). Let <span class="math">m, n, q</span> be as above and <span class="math">\\beta \\in \\mathbb{N}</span>. Given <span class="math">\\mathbf{A} \\in \\mathbb{Z}_q^{n \\times m}</span> and <span class="math">\\mathbf{t} \\in \\mathbb{Z}_q^n</span>, the (inhomogeneous) SIS-problem is to find <span class="math">\\mathbf{s} \\in \\mathbb{Z}_q^m</span> such that <span class="math">\\mathbf{t} = \\mathbf{A}\\mathbf{s} \\mod q</span> and <span class="math">\\mathbf{s} \\in S_\\beta^m</span>.</p>

    <p class="text-gray-300">We collect such <span class="math">(\\mathbf{A},\\mathbf{s},\\mathbf{t})</span> that fulfill Definition 1 in an NP-relation</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\mathrm {S I S}} ^ {m, n, q, \\beta} = \\{(x, w) = ((\\mathbf {A}, \\mathbf {t}), \\mathbf {s}) \\mid \\mathbf {s} \\in S _ {\\beta} ^ {m} \\wedge \\mathbf {A} \\in \\mathbb {F} _ {q} ^ {n \\times m} \\wedge \\mathbf {t} = \\mathbf {A s} \\}.</span></div>

    <p class="text-gray-300">In practice, one often encounters proofs that do not show exactly that <span class="math">\\mathbf{s} \\in S_{\\beta}^{m}</span> even though the prover has such a value as witness. Instead, they guarantee that the bound might be a bit bigger, by a factor at most <span class="math">\\omega</span> which usually is called slack. We have that <span class="math">R_{\\mathrm{SIS}}^{m,n,q,\\beta} \\subseteq R_{\\mathrm{SIS}}^{m,n,q,\\omega \\cdot \\beta}</span> if <span class="math">\\omega \\geq 1</span>, so any honest prover will still make the verifier accept if it proves <span class="math">R_{\\mathrm{SIS}}^{m,n,q,\\omega \\cdot \\beta}</span> instead. For simplicity, we also consider an instance of SIS where <span class="math">\\mathbf{s}</span> is binary.</p>

    <p class="text-gray-300">Definition 2 (Binary-SIS). Let <span class="math">m, n, q</span> be defined as above. Given <span class="math">\\mathbf{A} \\in \\mathbb{Z}_q^{n \\times m}</span> and <span class="math">\\mathbf{t} \\in \\mathbb{Z}_q^n</span>, the (inhomogeneous) Binary SIS-problem is to find <span class="math">\\mathbf{s} \\in \\mathbb{B}^m</span> such that <span class="math">\\mathbf{t} = \\mathbf{A}\\mathbf{s} \\mod q</span>.</p>

    <p class="text-gray-300">This Binary-SIS problem is not uncommon and e.g. [BD10,KTX08] used it. Its relation <span class="math">R_{\\mathbb{B} - \\mathbb{S}\\mathbb{I}\\mathbb{S}}^{m,n,q}</span> can be defined similarly as <span class="math">R_{\\mathbb{S}\\mathbb{I}\\mathbb{S}}^{m,n,q,\\beta}</span>.</p>

    <p class="text-gray-300">In this section, we introduce our honest verifier zero-knowledge argument of knowledge (HVZKAoK) protocols for satisfiability of arithmetic circuits. We begin by describing the underlying MPC protocol to securely compute an arithmetic circuit. Then, we present two HVZKAoKs based on the MPC protocol - one that relies on the "cut-and-choose" paradigm and one that uses "sacrificing". While the first is a direct extension of a recent work of [KKW18], the second one is completely new to the best of our knowledge.</p>

    <p class="text-gray-300">Our MPC protocol is a simplified version of the SPDZ protocol [DPSZ12]. Let <span class="math">N</span> denote the number of parties and let <span class="math">P_{1},\\ldots ,P_{N}</span> denote the parties participating in the protocol.</p>

    <p class="text-gray-300">Secret sharing scheme. Let <span class="math">\\llbracket x\\rrbracket</span> denote an additive sharing of <span class="math">x</span>, i.e., a sharing of <span class="math">x</span> consists of random <span class="math">x_{1},\\ldots ,x_{N}\\in \\mathbb{F}_{q}</span> such that <span class="math">x = \\sum_{i\\in [N]}x_{i}</span>, where <span class="math">P_{i}</span> holds <span class="math">x_{i}</span>. We define the following operations on shares:</p>

    <p class="text-gray-300">open([x]): To reveal the secret <span class="math">x</span> each party broadcasts its share <span class="math">x_{i}</span>. Upon receiving <span class="math">x_{j}</span> from each <span class="math">P_{j}</span>, <span class="math">P_{i}</span> sets <span class="math">x = \\sum_{j\\in [N]}x_{j}</span>.</p>

    <p class="text-gray-300"><span class="math">\\llbracket x\\rrbracket + \\llbracket y\\rrbracket</span>: Given two shares <span class="math">x_{i}</span> and <span class="math">y_{i}</span> of <span class="math">x</span> and <span class="math">y</span>, each party <span class="math">P_{i}</span> defines <span class="math">x_{i} + y_{i}</span> as its share of the result.</p>

    <p class="text-gray-300"><span class="math">\\sigma + \\llbracket x\\rrbracket</span>: Given a sharing <span class="math">\\llbracket x\\rrbracket</span> and a public constant <span class="math">\\sigma</span>, <span class="math">P_{1}</span> defines <span class="math">x_{1} + \\sigma</span> as its new share while other parties' shares remain the same.</p>

    <p class="text-gray-300"><span class="math">\\sigma \\cdot \\llbracket x\\rrbracket</span>: Given a sharing <span class="math">\\llbracket x\\rrbracket</span> and a public constant <span class="math">\\sigma</span>, each party <span class="math">P_{i}</span> defines <span class="math">\\sigma \\cdot x_{i}</span> as its share of the product.</p>

    <p class="text-gray-300">Multiplications. We say that <span class="math">(\\llbracket a\\rrbracket, \\llbracket b\\rrbracket, \\llbracket c\\rrbracket)</span> is a random multiplication triple if <span class="math">a</span> and <span class="math">b</span> are random and <span class="math">c = a \\cdot b</span>. To multiply <span class="math">\\llbracket x\\rrbracket</span> and <span class="math">\\llbracket y\\rrbracket</span> using a preprocessed random triple <span class="math">(\\llbracket a\\rrbracket, \\llbracket b\\rrbracket, \\llbracket c\\rrbracket)</span>, the parties do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties compute <span class="math">\\llbracket \\alpha \\rrbracket = \\llbracket x\\rrbracket -\\llbracket a\\rrbracket</span> and <span class="math">\\llbracket \\beta \\rrbracket = \\llbracket y\\rrbracket -\\llbracket b\\rrbracket</span></li>

      <li>The parties run open([α]) and open([β]) to obtain α and β.</li>

      <li>Each party computes <span class="math">\\llbracket z\\rrbracket = \\llbracket c\\rrbracket -\\alpha \\cdot \\llbracket b\\rrbracket -\\beta \\cdot \\llbracket a\\rrbracket +\\alpha \\cdot \\beta</span></li>

    </ol>

    <p class="text-gray-300">The above is a well-known [Bea91] technique and works because</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\llbracket z \\rrbracket = \\llbracket c \\rrbracket - \\alpha \\cdot \\llbracket b \\rrbracket - \\beta \\cdot \\llbracket a \\rrbracket + \\alpha \\cdot \\beta \\\\ = \\llbracket a b \\rrbracket - (x - a) \\cdot \\llbracket b \\rrbracket - (y - b) \\cdot \\llbracket a \\rrbracket + (x - a) \\cdot (y - b) \\\\ = \\llbracket x y \\rrbracket \\\\ \\end{array}</span></div>

    <p class="text-gray-300">4 It works like SPDZ in the sense that it considers dishonest majority, uses an additive secret sharing and multiplication triples, but without the information-theoretic MAC.</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Squaring</h4>

    <p class="text-gray-300">We say that <span class="math">(\\llbracket b\\rrbracket,\\llbracket d\\rrbracket)</span> is a random square if <span class="math">b</span> is random and <span class="math">d=b^{2}</span>. To compute <span class="math">\\llbracket x^{2}\\rrbracket</span> given <span class="math">\\llbracket x\\rrbracket</span> using a preprocessed <span class="math">(\\llbracket b\\rrbracket,\\llbracket d\\rrbracket)</span>, the parties do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties compute <span class="math">\\llbracket\\alpha\\rrbracket=\\llbracket x\\rrbracket-\\llbracket b\\rrbracket</span>.</li>

      <li>The parties run <span class="math">\\mathsf{open}(\\llbracket\\alpha\\rrbracket)</span> to obtain <span class="math">\\alpha</span>.</li>

      <li>Each party computes <span class="math">\\llbracket z\\rrbracket=\\alpha\\cdot(\\llbracket x\\rrbracket+\\llbracket b\\rrbracket)+\\llbracket d\\rrbracket</span>.</li>

    </ol>

    <p class="text-gray-300">Note that the above holds since</p>

    <p class="text-gray-300"><span class="math">\\llbracket z\\rrbracket</span> <span class="math">=\\alpha\\cdot(\\llbracket x\\rrbracket+\\llbracket b\\rrbracket)+\\llbracket d\\rrbracket=(x-b)\\cdot(\\llbracket x\\rrbracket+\\llbracket b\\rrbracket)+\\llbracket b^{2}\\rrbracket</span> <span class="math">=\\llbracket x^{2}-b^{2}+b^{2}\\rrbracket=\\llbracket x^{2}\\rrbracket.</span></p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">The protocol</h4>

    <p class="text-gray-300">The above building blocks can easily be combined to securely run <span class="math">\\mathsf{eval}(\\cdot)</span> on a circuit <span class="math">C</span>: after the inputs are secret-shared using <span class="math">\\llbracket\\cdot\\rrbracket</span>, the parties apply <span class="math">G</span> as defined in Section 2.1 consecutively to the shares. That is, addition gates and multiplication/addition by-a-public-constant gates are computed locally, whereas multiplication and square gates are computed using the above sub-protocols.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Security</h4>

    <p class="text-gray-300">For our purpose of using a MPC protocol to establish our zero-knowledge argument, the used protocol only needs to be secure in the presence of a semi-honest adversary. Furthermore, it suffices for the protocol to be secure in the client-server broadcast model, i.e., when the parties who run the protocol (the servers) do not hold input and do not see the final output, but rather receive shares of the inputs from the clients, perform the computation by only local computation as well as sending broadcast messages to each other, and then send the output shares back to the clients.</p>

    <p class="text-gray-300">Formally, let <span class="math">\\mathcal{F}_{\\mathsf{tr}}</span> and <span class="math">\\mathcal{F}_{\\mathsf{sq}}</span> be ideal functionalities that provide the parties with random multiplication triples and squares. We define <span class="math">\\mathsf{view}^{\\mathcal{F}_{\\mathsf{tr}},\\mathcal{F}_{\\mathsf{sq}}}_{I,\\pi}(C)</span> to be the view of a subset of parties <span class="math">I</span> during the execution of a protocol <span class="math">\\pi</span> on the circuit <span class="math">C</span>, in the <span class="math">(\\mathcal{F}_{\\mathsf{tr}},\\mathcal{F}_{\\mathsf{sq}})</span>-hybrid model and in the client-server model. The view consists of the input shares, the correlated randomness they receive from the functionalities and the messages they obtain from the other parties while evaluating <span class="math">C</span>. The security of <span class="math">\\pi</span> is stated in Theorem 1.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C</span> be an arithmetic circuit over the field <span class="math">\\mathbb{F}</span> and let <span class="math">\\pi</span> be the protocol described above. Then, for every subset of parties <span class="math">I\\subset\\{P_{1},\\ldots,P_{N}\\}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N-1<span class="math">, there exists a probabilistic polynomial-time algorithm </span>\\mathcal{S}<span class="math"> such that </span>\\{\\mathcal{S}(I,C)\\}_{\\equiv}\\{\\mathsf{view}^{\\mathcal{F}_{\\mathsf{tr}},\\mathcal{F}_{\\mathsf{sq}}}_{I,\\pi}(C)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Intuitively, this follows from the fact that the corrupted parties see only shares of the values on the wires of the circuit that could open to any value or random public values. Formally, the simulator <span class="math">\\mathcal{S}</span> begins by choosing <span class="math">t</span> random shares for each input wire and adding them to the view of the corrupted parties in <span class="math">I</span>. Then, it goes over the circuit in topological order; for addition gates and multiplication-by-a-constant, it does the local operation on the corrupted parties’ shares as defined by the protocol. For multiplication gates, <span class="math">\\mathcal{S}</span> chooses <span class="math">t</span> shares of <span class="math">a</span>,<span class="math">b</span> and <span class="math">c</span> and adds them to the corrupted parties’ view. Then, it chooses random <span class="math">\\alpha</span> and <span class="math">\\beta</span>, compute the honest parties’ shares of them accordingly (knowing the corrupted parties’ shares) and adds them to the view. Then, it computes the corrupted parties’ shares of <span class="math">z</span> as defined by the protocol. Similarly, for square gates, it chooses <span class="math">t</span> random shares for <span class="math">b</span> and <span class="math">d</span> and adds them to the view of the corrupted parties. Then, it chooses a random <span class="math">\\alpha</span>, computes the honest parties’ shares accordingly, adds them to the view and computes the corrupted parties’ shares of the output.</p>

    <p class="text-gray-300">The only difference between the simulated view and the real execution is the way <span class="math">\\alpha</span> and <span class="math">\\beta</span> are chosen. However, in both cases the these values are uniformly distributed. Thus, the view generated by the simulator is identically distributed to the view in the real execution as required. ∎</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.2 HVZKAoK Protocol using Cut and Choose</h3>

    <p class="text-gray-300">We now explain our first HVZKAoK protocol <span class="math">\\Pi_{\\mathsf{c\\&amp;c}}</span>, which is based on the MPC protocol from Section 3.1, and which relies on the cut–and–choose technique to generate correct random multiplication triples and squares. The formal description appears in Fig. 1.a and Fig. 1.b.</p>

    <p class="text-gray-300">Let  <span class="math">H</span>  be a CRHF and  <span class="math">\\mathsf{com}</span>  be the Random Oracle-based commitment scheme.</p>

    <p class="text-gray-300">Inputs: Both the prover  <span class="math">\\mathcal{P}</span>  and the verifier  <span class="math">\\mathcal{V}</span>  hold  <span class="math">\\mathbf{y} \\in \\mathbb{F}^{n_{\\mathrm{out}}}</span> , a description of an arithmetic circuit  <span class="math">C</span>  over a finite field  <span class="math">\\mathbb{F}</span>  and parameters  <span class="math">M, N, \\tau</span> ; the prover  <span class="math">\\mathcal{P}</span>  also holds a witness  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{n_{\\mathrm{in}}}</span>  such that  <span class="math">C(\\mathbf{w}) = \\mathbf{y}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  chooses a random salt salt  <span class="math">\\leftarrow \\{0,1\\}^{\\lambda}</span> .</li>

      <li>For each  <span class="math">e \\in [M]</span> :</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathcal{P}</span>  initializes an empty string  <span class="math">\\mathfrak{st}_e</span> (b)  <span class="math">\\mathcal{P}</span>  chooses a master seed  <span class="math">\\mathsf{sd}_e</span>  and uses it to generate  <span class="math">\\mathsf{sd}_{e,1},\\ldots ,\\mathsf{sd}_{e,N}</span> (c) For each multiplication gate  <span class="math">g_{k}\\in \\mathcal{G}</span></p>

    <p class="text-gray-300">i.  <span class="math">\\mathcal{P}</span>  defines three random sharings  <span class="math">\\llbracket a_{e,k}\\rrbracket ,\\llbracket b_{e,k}\\rrbracket</span>  and  <span class="math">\\llbracket c_{e,k}\\rrbracket</span>  by using  <span class="math">\\mathsf{sd}_{e,i}</span>  for each  <span class="math">i\\in [N]</span>  to generate  <span class="math">a_{e,k,i},b_{e,k,i}</span>  and  <span class="math">c_{e,k,i}</span> . ii.  <span class="math">\\mathcal{P}</span>  computes  <span class="math">a_{e,k} = \\sum_{i=1}^{N} a_{e,k,i}</span>  and  <span class="math">b_{e,k} = \\sum_{i=1}^{N} b_{e,k,i}</span>  and  <span class="math">c_{e,k} = a_{e,k} \\cdot b_{e,k}</span> .</p>

    <p class="text-gray-300">Then, it sets  <span class="math">\\varDelta_{e,k}=c_{e,k}-\\sum_{i=1}^{N}c_{e,k,i}</span>  and  <span class="math">\\mathsf{st}_e\\gets \\mathsf{st}_e\\parallel \\varDelta_{e,k}</span> .</p>

    <p class="text-gray-300">iii.  <span class="math">\\mathcal{P}</span>  sets the random triple for this gate to be  <span class="math">([a_{e,k}], [b_{e,k}], [c_{e,k}]) + \\varDelta_{e,k})</span> (d) For each square gate  <span class="math">g_{k}\\in \\mathcal{G}</span></p>

    <p class="text-gray-300">i.  <span class="math">\\mathcal{P}</span>  defines two random sharings  <span class="math">\\llbracket b_{e,k}\\rrbracket</span>  and  <span class="math">\\llbracket d_{e,k}\\rrbracket</span>  by using  <span class="math">\\mathsf{sd}_{e,i}</span>  for each  <span class="math">i\\in [N]</span>  to generate  <span class="math">b_{e,k,i}</span>  and  <span class="math">d_{e,k,i}</span> . ii.  <span class="math">\\mathcal{P}</span>  computes  <span class="math">b_{e,k} = \\sum_{i=1}^{N} b_{e,k,i}</span> .</p>

    <p class="text-gray-300">Then, it computes  <span class="math">\\varDelta_{e,k}=(b_{e,k})^{2}-\\sum_{i=1}^{N}d_{e,k,i}</span>  and  <span class="math">\\mathsf{st}_e\\gets \\mathsf{st}_e\\parallel \\varDelta_{e,k}</span> .</p>

    <p class="text-gray-300">iii.  <span class="math">\\mathcal{P}</span>  sets the random square for this gate to be  <span class="math">([b_{e,k}], [d_{e,k}]) + \\varDelta_{e,k})</span> (e)  <span class="math">\\mathcal{P}</span>  chooses a linear random sharing of the inputs:</p>

    <p class="text-gray-300">i. For each  <span class="math">i\\in [N]</span> <span class="math">\\mathcal{P}</span>  uses  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">w_{e,1,i},\\ldots ,w_{e,n_{\\mathrm{in}},i}</span> ii. For each  <span class="math">k\\in \\mathcal{I}</span> <span class="math">\\mathcal{P}</span>  sets  <span class="math">\\phi_{e,k} = w_k - \\sum_{i = 1}^N w_{e,k,i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(f)  <span class="math">\\mathcal{P}</span>  chooses a random string  <span class="math">g_{e} \\in \\mathbb{B}^{\\lambda}</span>  and then it computes  $\\Omega_{e} = \\operatorname{com}(\\phi_{e,1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{e,n_{\\mathrm{in}}}, g_{e}, \\mathsf{salt})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(g) For each  <span class="math">i\\in [N]</span> <span class="math">\\mathcal{P}</span>  uses  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">r_{e,i}\\in \\mathbb{B}^{\\lambda}</span>  and then it computes  <span class="math">\\Gamma_{e,i} = \\mathsf{com}(\\mathsf{sd}_{e,i},r_{e,i},\\mathsf{salt})</span> (h)  <span class="math">\\mathcal{P}</span>  uses  <span class="math">\\mathsf{sd}_e</span>  to generate a random string  <span class="math">s_e\\in \\mathbb{B}^\\lambda</span>  and computes  <span class="math">\\Gamma_{e} = \\mathsf{com}(\\mathsf{st}_{e},s_{e},\\mathsf{salt})</span> (i) Finally,  <span class="math">\\mathcal{P}</span>  computes  <span class="math">h_e = H(\\Gamma_e\\parallel \\Gamma_{e,1}\\parallel \\dots \\parallel \\Gamma_{e,N})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">h_{\\Gamma} = H(h_1\\parallel \\dots \\parallel h_M)</span> ,  <span class="math">h_{\\Omega} = H(\\Omega_1\\parallel \\dots \\parallel \\Omega_M)</span>  and sends them to  <span class="math">\\mathcal{V}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Round 2:  <span class="math">\\mathcal{V}</span>  chooses a random challenge  <span class="math">E\\subset [M]</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\tau<span class="math">  and sends it to  </span>\\mathcal{P}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1.a: The "Cut-and-Choose" Based HVZK Argument  <span class="math">\\Pi_{\\mathrm{c\\&amp;amp; c}}</span>  (Part 1)</p>

    <p class="text-gray-300">The idea behind the protocol is that the prover  <span class="math">\\mathcal{P}</span>  proves its knowledge of  <span class="math">\\mathbf{w}</span>  such that  <span class="math">C(\\mathbf{w}) = \\mathbf{y}</span>  by simulating a secure  <span class="math">N</span> -party computation of the circuit over an additive sharing of  <span class="math">\\mathbf{w}</span> , using the MPC protocol described above. Since  <span class="math">\\mathcal{P}</span>  knows the input and thus the values on each wire of the circuit, it can simulate the execution "in the head". Since our MPC protocol uses random triples and squares supplied by the ideal functionalities  <span class="math">\\mathcal{F}_{\\mathrm{tr}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{sq}}</span> , the prover  <span class="math">\\mathcal{P}</span>  needs to play their role as well. Clearly,  <span class="math">\\mathcal{P}</span>  may try to cheat in the simulated computation, aiming to cause the verifier  <span class="math">\\mathcal{V}</span>  to accept false statements. This is prevented by having  <span class="math">\\mathcal{V}</span>  challenging  <span class="math">\\mathcal{P}</span>  in two ways. First, after  <span class="math">\\mathcal{P}</span>  has committed to  <span class="math">M</span>  sets of random triples and squares,  <span class="math">\\mathcal{V}</span>  randomly selects  <span class="math">\\tau</span>  of them, which are then opened to it. The remaining  <span class="math">M - \\tau</span>  sets of the pre-processed data are used to support  <span class="math">M - \\tau</span>  circuit computations - each with different randomness. The prover  <span class="math">\\mathcal{P}</span>  performs these computations and commits to the views of the parties, to be then challenged for the second time by  <span class="math">\\mathcal{V}</span> . In this second challenge, the verifier chooses a random subset of  <span class="math">N - 1</span>  parties in each execution, whose views are opened and tested for consistency. If these two tests pass successfully and the output of the circuit is  <span class="math">\\mathbf{y}</span> , then  <span class="math">\\mathcal{V}</span>  outputs acc. Observe that  <span class="math">\\mathcal{V}</span>  cannot learn any information about the witness  <span class="math">\\mathbf{w}</span>  during the protocol: the opened pre-processing executions reveal only random data which is thrown away afterwards, and the  <span class="math">N - 1</span>  views that are opened do not reveal anything since the MPC protocol is resilient to  <span class="math">N - 1</span>  semi-honest parties. In more details, in Round 1,  <span class="math">\\mathcal{P}</span>  commits to  <span class="math">M</span>  pre-processing executions. A major source of saving here is using pseudo-randomness instead of pure randomness. Specifically,  <span class="math">\\mathcal{P}</span>  chooses a seed  <span class="math">\\mathsf{sd}_e</span>  for each execution  <span class="math">e</span> , from which it derives the seeds  <span class="math">\\mathsf{sd}_{e,i}</span>  for each party  <span class="math">P_i</span> . These seeds are used to generate all the random shares held by  <span class="math">P_i</span>  throughout the computation. Now, if execution  <span class="math">e</span>  is selected to be tested by  <span class="math">\\mathcal{V}</span>  in Round 2, then  <span class="math">\\mathcal{P}</span>  can just send  <span class="math">\\mathsf{sd}_e</span>  to  <span class="math">\\mathcal{V}</span> , thereby saving communication. For the  <span class="math">M - \\tau</span>  preprocessings</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\bar{E} = [M] \\setminus E</span> . First,  <span class="math">\\mathcal{P}</span>  chooses  <span class="math">\\mathsf{sd}_{\\bar{E}}</span> .</li>

      <li>For each  <span class="math">e \\in \\bar{E}</span> :</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathcal{P}</span>  initializes an empty string view  <span class="math">e</span> . Then, it goes over the circuit in topological order and simulates each gate's computation using the MPC protocol described in Section 3.1, while consuming the random triples and squares it prepared in Round 1.</p>

    <p class="text-gray-300">i. For each multiplication gate  <span class="math">g_{k}</span> ,  <span class="math">\\mathcal{P}</span>  sets</p>

    <p class="text-gray-300"><span class="math">\\mathsf{view}_e \\gets \\mathsf{view}_e \\parallel \\alpha_{e,k,1} \\parallel \\dots \\parallel \\alpha_{e,k,N} \\parallel \\beta_{e,k,1} \\parallel \\dots \\parallel \\beta_{e,k,N}</span> .</p>

    <p class="text-gray-300">ii. For each square gate  <span class="math">g_{k}</span> ,  <span class="math">\\mathcal{P}</span>  sets:  <span class="math">\\mathsf{view}_e \\gets \\mathsf{view}_e \\parallel \\alpha_{e,k,1} \\parallel \\dots \\parallel \\alpha_{e,k,N}</span> .</p>

    <p class="text-gray-300">(b) Let  <span class="math">o_{e,1,i},\\ldots ,o_{e,n_{\\mathrm{out}},i}</span>  be the shares on the output wires held by party  <span class="math">P_{i}</span>  at the end of the computation.</p>

    <p class="text-gray-300">Then, for each output wire  <span class="math">k \\in \\mathcal{O}</span> ,  <span class="math">\\mathcal{P}</span>  sets  <span class="math">\\mathsf{view}_e \\gets \\mathsf{view}_e \\parallel o_{e,k,1} \\parallel \\dots \\parallel o_{e,k,N}</span> .</p>

    <p class="text-gray-300">(c)  <span class="math">\\mathcal{P}</span>  uses  <span class="math">\\mathsf{sd}_{\\bar{E}}</span>  to generate  <span class="math">g_{e} \\in \\mathbb{B}^{\\lambda}</span>  and computes  <span class="math">\\Pi_{e} = \\mathsf{com}(\\mathsf{view}_{e}, g_{e}, \\mathsf{salt})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  <span class="math">\\mathcal{P}</span>  computes  $h_{\\pi} = H(\\Pi_{e_1}\\parallel \\dots \\parallel \\Pi_{e_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">\\{\\mathsf{sd}_e\\}_{e\\in E},\\{\\varOmega_e\\}_{e\\in E}</span>  and  <span class="math">h_\\pi</span>  to  <span class="math">\\nu</span></li>

    </ol>

    <p class="text-gray-300">Round 4: For each  <span class="math">e \\in \\bar{E}</span> :  <span class="math">\\mathcal{V}</span>  chooses a random  <span class="math">\\bar{i}_e \\in [N]</span>  and sends it to  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300">Round 5: For each  <span class="math">e \\in \\bar{E}</span> : Let  <span class="math">I_e = [N] \\setminus \\{\\bar{i}_e\\}</span> . Then,  <span class="math">\\mathcal{P}</span>  sends the following to  <span class="math">\\mathcal{V}</span> : (i) salt,  <span class="math">\\mathsf{sd}_{\\bar{E}}</span> ,  <span class="math">\\{\\mathsf{sd}_{e,i}\\}_{i \\in I_e}</span> ; (ii)  <span class="math">\\Gamma_{e,\\bar{i}_e}</span> ; (iii)  <span class="math">\\alpha_{e,k,\\bar{i}_e}</span> ,  <span class="math">\\beta_{e,k,\\bar{i}_e}</span>  and  <span class="math">\\Delta_{e,k}</span>  for each multiplication or square gate  <span class="math">g_k</span> ; (iv)  <span class="math">g_e</span>  and  <span class="math">\\{\\phi_{e,k}\\}_{k=1}^{n_{\\mathrm{in}}}</span> ; and (v)  <span class="math">o_{e,1,\\bar{i}_e}, \\ldots, o_{e,n_{\\mathrm{out}},\\bar{i}_e}</span> .</p>

    <p class="text-gray-300">Output:  <span class="math">\\mathcal{V}</span>  outputs acc iff all the following checks succeed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">e \\in E</span> ,  <span class="math">\\mathcal{V}</span>  uses  <span class="math">\\mathsf{sd}_e</span>  to compute  <span class="math">h_e</span>  as a honest prover would do.</li>

    </ol>

    <p class="text-gray-300">For each  <span class="math">e \\in \\bar{E}</span> ,  <span class="math">\\mathcal{V}</span>  uses  <span class="math">\\{\\mathsf{sd}_{e,i}\\}_{i \\in I_e}</span>  to compute  <span class="math">\\Gamma_{e,i}</span>  as a honest prover would do. Then, using  <span class="math">\\Gamma_{e,\\bar{i}_e}</span>  received from  <span class="math">\\mathcal{P}</span> , the verifier  <span class="math">\\mathcal{V}</span>  computes  <span class="math">h_e</span> .</p>

    <p class="text-gray-300">Then,  <span class="math">\\mathcal{V}</span>  checks that  <span class="math">h_{\\Gamma} = H(h_1\\parallel \\dots \\parallel h_M)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">e \\in \\bar{E}</span> ,  <span class="math">\\mathcal{V}</span>  computes  <span class="math">\\Omega_e</span>  using  <span class="math">\\{\\phi_{e,k}\\}_{k=1}^{n_{\\mathrm{in}}}</span>  and  <span class="math">g_e</span> . Then, using  <span class="math">\\{\\Omega_e\\}_{e \\in E}</span>  received from  <span class="math">\\mathcal{P}</span> , the verifier  <span class="math">\\mathcal{V}</span>  checks that  <span class="math">h_\\Omega = H(\\Omega_1 \\parallel \\dots \\parallel \\Omega_M)</span> .</li>

      <li>For each  <span class="math">e \\in \\bar{E}</span> ,  <span class="math">\\mathcal{V}</span>  computes  <span class="math">\\mathsf{view}_e</span>  as an honest prover would do by going over the circuit in topological order and using  <span class="math">\\{\\mathsf{sd}_{e,i}\\}_{i \\in I_e}</span> , the shares  <span class="math">\\alpha_{e,k,\\bar{i}_e}, \\beta_{e,k,\\bar{i}_e}</span>  and  <span class="math">\\Delta_{e,k}</span>  received from  <span class="math">\\mathcal{P}</span>  for each multiplication and square gate, and  <span class="math">\\{o_{e,k,\\bar{i}_e}\\}_{k=1}^{n_{\\mathrm{out}}}</span> . Then, it computes  <span class="math">\\Pi_e</span>  as a honest prover would do.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally,  <span class="math">\\mathcal{V}</span>  checks that  $h_{\\pi} = H(\\Pi_{e_1}\\parallel \\dots \\parallel \\Pi_{e_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">e \\in \\bar{E}</span> , for each  <span class="math">k \\in \\mathcal{O}</span> ,  <span class="math">\\mathcal{V}</span>  checks that  <span class="math">\\sum_{i=1}^{N} o_{e,k,i} = y_k</span></li>

    </ol>

    <p class="text-gray-300">Fig. 1.b: The "Cut-and-Choose" Based HVZK Argument  <span class="math">\\Pi_{ckc}</span>  (Part 2)</p>

    <p class="text-gray-300">which are used in the on-line execution in Round 3,  <span class="math">\\mathcal{P}</span>  cannot send the master seed but rather will have to send  <span class="math">N - 1</span>  seeds of the  <span class="math">N - 1</span>  parties chosen to be opened by  <span class="math">\\nu</span>  in Round 4. Thereby the data of one of the parties is kept secret. Observe, however, that not all the data held by the parties is random. In particular, when generating a multiplication triple  <span class="math">\\llbracket a_{e,k}\\rrbracket ,\\llbracket b_{e,k}\\rrbracket ,\\llbracket c_{e,k}\\rrbracket</span>  ( <span class="math">e</span>  is the execution index and  <span class="math">k</span>  is the index of the gate for which this triple is consumed), one can use the seeds of the parties to generate the sharing of  <span class="math">a_{e,k}</span>  and  <span class="math">b_{e,k}</span> , but once these are fixed, so is  <span class="math">c_{e,k} = a_{e,k}\\cdot b_{e,k}</span> . Therefore, when generating the sharing of  <span class="math">c_{e,k}</span> , it is necessary to "fix" the initial sharing derived from the random seeds. To obtain this, the prover also commits to the offset  <span class="math">\\varDelta_{e,k}</span>  for each execution  <span class="math">e</span>  and multiplication gate  <span class="math">g_{k}</span> , which is added to the initial random sharing  <span class="math">\\llbracket c_{e,k}\\rrbracket</span> . The same applies when generating random squares. Similarly, when the sharings of the inputs are generated in Round 3,  <span class="math">\\mathcal{P}</span>  can use the seeds of the parties to derive their shares, and then adjust this initial sharing by adding the offset (denoted by  <span class="math">\\phi_{e,k}</span> ) to obtain a correct sharing of the given input. Thus,  <span class="math">\\mathcal{P}</span>  must commit to the offset on each input wire as well. To further reduce communication, we hash all the commitments together and send only the hash value to  <span class="math">\\nu</span> .</p>

    <p class="text-gray-300">Cheating error (soundness). We compute the probability that  <span class="math">\\mathcal{V}</span>  outputs acc when  <span class="math">C(\\mathbf{w}) \\neq \\mathbf{y}</span> . Let  <span class="math">c</span>  be the number of pre-processing emulations where  <span class="math">\\mathcal{P}</span>  cheats (i.e., by generating incorrect squares or multiplication triples). Since  <span class="math">\\tau</span>  emulations out of  <span class="math">M</span>  are opened and tested by the verifier, we have that this step is passed without the cheating being detected with probability  <span class="math">\\frac{\\binom{M-\\tau}{\\tau}}{\\binom{M}{\\tau}}</span> . After this step,  <span class="math">M - \\tau</span>  circuit computations are</p>

    <p class="text-gray-300">being simulated by the prover. In order to make the output of the protocol be <span class="math">\\mathbf{y}</span>, <span class="math">\\mathcal{P}</span> must cheat (i.e., deviate from the specification of the MPC protocol) in <span class="math">M-\\tau-c</span> emulations. Since <span class="math">N-1</span> views are being opened in each such emulation, <span class="math">\\mathcal{P}</span> clearly will not sabotage the view of more than one party. Thus, the probability that this is not detected is <span class="math">\\frac{1}{N^{M-\\tau-c}}</span>. The overall success cheating probability is therefore</p>

    <p class="text-gray-300"><span class="math">\\xi_{\\mathsf{c\\&amp;c}}(M,N,\\tau)=\\max_{0\\leq c\\leq M-\\tau}\\left\\{\\frac{\\binom{M-c}{\\tau}}{\\binom{M}{\\tau}\\cdot N^{M-\\tau-c}}\\right\\}</span></p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Formal proof.</h4>

    <p class="text-gray-300">As mentioned before, the above protocol has appeared already in <em>[x13]</em> (for Boolean circuits, but extending it to Arithmetic circuits is straightforward). However, there it was described as an optimization to their baseline protocol and so was not formally proven. We therefore now give a full security proof.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">H</span> be a collision-resistant hash function and let <span class="math">\\mathsf{com}</span> be the Random Oracle-based commitment scheme. Then, the protocol <span class="math">\\Pi_{\\mathsf{c\\&amp;c}}</span> is an HVZKAoK with knowledge error (soundness) <span class="math">\\xi_{\\mathsf{c\\&amp;c}}(M,N,\\tau)</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the that each of the three properties defined in Section 2.2 are satisfied by our protocol.</p>

    <p class="text-gray-300">Completeness. This follows from the correctness of the MPC protocol.</p>

    <p class="text-gray-300">Honest Verifier Zero Knowledge. This property follows from the security of the MPC protocol as defined in Theorem 1 and by the hiding property of the commitment scheme. Specifically, let <span class="math">\\mathcal{S}_{\\pi}</span> be the simulator that exists for the MPC protocol described in the proof of Theorem 3.1. We construct a honest-verifier zero-knowledge simulator <span class="math">\\mathcal{S}</span> for our protocol, which works as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\mathcal{S}</span> chooses random <span class="math">E\\subset[M]</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\tau<span class="math">. Then, for each </span>e\\in\\bar{E}=[M]\\setminus E<span class="math">, it chooses a random </span>i_{e}\\in[N]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">e\\in E</span>, <span class="math">\\mathcal{S}</span> prepares the pre-processing data as an honest prover would do in Round 1, with one exception: it computes <span class="math">\\Pi_{e}</span> as a commitment to a 0-string.</li>

      <li>For each <span class="math">e\\in\\bar{E}</span>, <span class="math">\\mathcal{S}</span> chooses <span class="math">\\mathsf{sd}_{e,i}</span> for each <span class="math">i\\in I_{e}=[N]\\setminus\\{i_{e}\\}</span>. Then, for the pre-processing in Round 1, it generates <span class="math">\\mathsf{st}_{e}</span> by choosing random <span class="math">\\Delta_{e,k}</span> for each multiplication/square gate. In addition, it chooses random <span class="math">\\phi_{e,k}</span> for each input wire <span class="math">k</span> and compute <span class="math">\\Pi_{e}</span> accordingly. Proceeding to Round 3, <span class="math">\\mathcal{S}</span> generates <span class="math">\\mathsf{view}_{e}</span> by following the instructions of <span class="math">\\mathcal{S}_{\\pi}</span> with <span class="math">I=I_{e}</span> and using <span class="math">\\mathsf{sd}_{e,i}</span> to generate the required randomness. For the commitments <span class="math">I_{e,\\bar{i}_{e}}^{\\tau}</span>, <span class="math">\\mathcal{S}</span> uses the 0-string as the committed message.</li>

      <li>For each <span class="math">e\\in\\bar{E}</span>, for each <span class="math">k\\in\\mathcal{O}</span>, <span class="math">\\mathcal{S}</span> sets <span class="math">o_{e,k,i_{e}}=y_{k}-\\sum_{i\\in I_{e}}o_{e,i}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> computes all the hash values as an honest prover would do.</li>

      <li><span class="math">\\mathcal{S}</span> outputs the transcript of the protocol.</li>

    </ol>

    <p class="text-gray-300">From the indistinguishably of the transcript generated by <span class="math">\\mathcal{S}_{\\pi}</span> and the hiding property of the commitment scheme, it follows by a hybrid argument that the view generated by <span class="math">\\mathcal{S}</span> is computationally indistinguishable from the view of a real protocol instance.</p>

    <p class="text-gray-300">Knowledge Soundness. We proceed to prove the soundness property of the protocol. For simplicity we assume that the commitment scheme is perfectly binding and that there are no collisions for the hash function.</p>

    <p class="text-gray-300">We first argue that if the success probability <span class="math">\\delta(x)</span> is higher than <span class="math">\\xi_{\\mathsf{c\\&amp;c}}(M,N,\\tau)</span>, then there exists at least one MPC instance (out of <span class="math">M</span>) where the prover has committed to a valid witness <span class="math">\\mathbf{w}</span>. Recall that we consider deterministic provers (by fixing the random tape), so the first message where he commits to the input <span class="math">\\mathbf{w}</span> is fixed once we fix the randomness tape. Now, let <span class="math">\\mathbf{G}</span> be a 0/1-matrix where each column corresponds to a possible first challenge of <span class="math">\\mathcal{V}</span> (i.e., <span class="math">\\tau</span> pre-processings to be opened) and each row corresponds to a possible second challenge chosen by <span class="math">\\mathcal{V}</span> (i.e., <span class="math">M-\\tau</span> parties indices for which the view should <em>not</em> to be opened). Thus,</p>

    <p class="text-gray-300"><span class="math">\\delta(x)</span> is the fraction of '1' entries in <span class="math">\\mathbf{G}</span>. Let <span class="math">\\xi_{\\mathbf{c} \\&amp;amp; \\mathbf{c}}(M, N, \\tau) = \\frac{\\binom{M - c<em>}{\\tau}}{\\binom{M}{\\tau}} \\cdot N^{M - \\tau - c</em>}</span> (i.e., <span class="math">c<em></span> is the value for which the expression for <span class="math">\\xi</span> written above is maximized). We can write <span class="math">\\xi_{\\mathbf{c} \\&amp;amp; \\mathbf{c}}</span> also as <span class="math">\\frac{\\binom{M - c</em>}{\\tau} \\cdot N^{c<em>}}{\\binom{M}{\\tau} \\cdot N^{M - \\tau}}</span>. Observe that the number of entries in <span class="math">\\mathbf{G}</span> is <span class="math">\\binom{M}{\\tau} \\cdot N^{M - \\tau}</span>. From our assumption that <span class="math">\\delta(x) &amp;gt; \\frac{\\binom{M - c</em>}{\\tau} \\cdot N^{c<em>}}{\\binom{M}{\\tau} \\cdot N^{M - \\tau}}</span> it thus follows that the number of '1' entries in <span class="math">\\mathbf{G}</span> is higher than <span class="math">\\binom{M - c</em>}{\\tau} \\cdot N^{c<em>}</span>. Next, assume that in the interaction with the prover <span class="math">\\mathcal{P}^</em></span>, it corrupts <span class="math">c</span> of the pre-processings. Clearly, if any of these are opened, then the transcript won't be accepted by <span class="math">\\mathcal{V}</span>. Thus, there can be '1' entries only in <span class="math">\\binom{M - c}{\\tau}</span> columns in <span class="math">\\mathbf{G}</span>. For each of these columns, there exists <span class="math">N^c</span> possible challenges for the MPC instances where the pre-processing is incorrect. Since there are more than <span class="math">\\binom{M - c<em>}{\\tau} \\cdot N^{c</em>} \\geq \\binom{M - c}{\\tau} \\cdot N^c</span> entries with '1' in <span class="math">\\mathbf{G}</span>, then there must exist two accepting transcripts with the same first challenge <span class="math">E</span> and with different second challenge <span class="math">\\{i_e\\}_{e \\in \\bar{E}}</span> and <span class="math">\\{i&#x27;_e\\}_{e \\in \\bar{E}}</span>, where <span class="math">i_e \\neq i&#x27;_e</span> for an MPC instance <span class="math">e</span> with correct pre-processing. This means that all the views of the parties in <span class="math">e</span> are also correct. Thus, the witness used in this instance must be a valid witness.</p>

    <p class="text-gray-300">Next, given that a valid witness <span class="math">\\mathbf{w}</span> is used in execution <span class="math">e</span>, observe that it is possible to extract this witness using two accepting transcripts <span class="math">(E, \\{i_e\\}_{e \\in \\bar{E}}), (E&#x27;, \\{i&#x27;_e\\}_{e \\in \\bar{E}&#x27;})</span> when the challenge for <span class="math">e</span> is different. Specifically, it is required that one of the following will hold: <span class="math">e \\in E \\cup E&#x27; \\setminus E \\cap E&#x27;</span> or <span class="math">i&#x27;_e \\neq i_e</span>. This suffices since in the first case it is possible to extract the seeds of all parties from one transcript (where the pre-processing of <span class="math">e</span> is opened) and the adjustments sent by the <span class="math">\\mathcal{P}</span> from the second transcript (where <span class="math">e</span>'s pre-processing is not opened), thereby obtaining the input shares of all parties. In the second case, where <span class="math">i&#x27;_e \\neq i_e</span>, one of the transcripts reveals <span class="math">N - 1</span> input shares whereas the other reveals the remaining share, thereby again allowing us to compute the witness by adding all shares.</p>

    <p class="text-gray-300">Let <span class="math">\\delta(x) = \\xi_{\\mathbf{c} \\&amp;amp; \\mathbf{c}}(M, N, \\tau) + \\epsilon</span> for some <span class="math">\\epsilon &amp;gt; 0</span>. We now describe an extractor <span class="math">\\mathcal{E}</span> to obtain such two transcripts:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Probe the matrix <span class="math">\\mathbf{G}</span> until the first '1' entry was found. Denote by <span class="math">\\mathbf{c} = (c_1, \\ldots, c_M)</span> the challenge for this entry, where for each <span class="math">e \\in [M]</span>, <span class="math">c_e</span> is the challenge for the <span class="math">i</span>th execution.</li>

      <li>For each execution <span class="math">e</span> run an extractor <span class="math">\\mathcal{E}_e</span>, who probes <span class="math">\\mathbf{G}</span> at random until an entry '1' is found for which the challenge <span class="math">\\mathbf{c}&#x27;</span> is such that <span class="math">c_e&#x27; \\neq c_e</span>.</li>

      <li>For each <span class="math">\\mathbf{c}&#x27;</span> outputted by <span class="math">\\mathcal{E}_e</span>, extract the witness <span class="math">\\mathbf{w}</span> used in execution <span class="math">e</span> using <span class="math">\\mathbf{c}</span> and <span class="math">\\mathbf{c}&#x27;</span> (as explained in the text above), and check that <span class="math">C(\\mathbf{w}) = \\mathbf{y}</span>. If yes, output <span class="math">\\mathbf{w}</span> and halt.</li>

    </ol>

    <p class="text-gray-300">First, observe that the expected running time of the first step is <span class="math">\\frac{1}{\\delta} &amp;lt; \\frac{1}{\\epsilon}</span>. For the second step, we prove the following Lemma:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 1.</strong> Let <span class="math">J = \\{j_{e_1}, j_{e_2}, \\ldots\\} \\subseteq [M]</span> be the set of indices which correspond to executions with valid witnesses and let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote its size. Then there exists an </span>e \\in J<span class="math"> such that </span>\\operatorname*{Pr}\\left[\\mathrm{acc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_e' \\neq c_e\\right] \\geq \\epsilon / M<span class="math">, where </span>\\mathrm{acc}$ is the event where the verifier accepts.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> We denote by <span class="math">\\mathbf{Jeq}</span> the event <span class="math">\\forall e \\in J: c_e&#x27; = c_e</span> and by <span class="math">\\overline{\\mathbf{Jeq}}</span> its negation <span class="math">\\exists e \\in J: c_e&#x27; \\neq c_e</span>. Assume in contradiction that for all <span class="math">e \\in J</span> it holds that $\\operatorname*{Pr}\\left[\\mathrm{acc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_e' \\neq c_e\\right] &lt; \\epsilon / M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\delta(x) = \\Pr\\left[\\mathrm{acc} \\wedge \\mathrm{Jeq}\\right] + \\Pr\\left[\\mathrm{acc} \\wedge \\overline{\\mathrm{Jeq}}\\right] \\\\ \\leq \\Pr\\left[\\mathrm{acc} \\wedge \\mathrm{Jeq}\\right] + \\Pr\\left[\\mathrm{acc} \\mid \\overline{\\mathrm{Jeq}}\\right] \\\\ = \\Pr\\left[\\mathrm{acc} \\wedge \\mathrm{Jeq}\\right] + \\\\ \\quad \\Pr\\left[\\mathrm{acc} \\mid c_{e_{j_1}}&#x27; \\neq c_{e_{j_1}} \\vee c_{e_{j_2}}&#x27; \\neq c_{e_{j_2}} \\vee \\cdots\\right] \\\\ \\leq \\Pr\\left[\\mathrm{acc} \\wedge \\mathrm{Jeq}\\right] + \\sum_{e_j \\in J} \\Pr\\left[\\mathrm{acc} \\mid c_{e_j}&#x27; \\neq c_{e_j}\\right] \\\\ &amp;lt; \\Pr\\left[\\mathrm{acc} \\wedge \\mathrm{Jeq}\\right] + \\sum_{e_j \\in J} \\epsilon / M \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">\\leq\\Pr\\left[\\mathsf{acc}\\wedge\\mathsf{Jeq}\\right]+M\\cdot\\epsilon/M</span> <span class="math">=\\Pr\\left[\\mathsf{acc}\\wedge\\mathsf{Jeq}\\right]+\\epsilon</span> (1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the second inequality is obtained by using Union Bound, the third inequality follows from our assumption on $\\Pr\\left[\\mathsf{acc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{e}^{\\prime}\\neq c_{e}\\right]<span class="math"> for all </span>e\\in J<span class="math"> and the last inequality holds since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now proceed to bound <span class="math">\\Pr\\left[\\mathsf{acc}\\wedge\\mathsf{Jeq}\\right]</span>, which is the probability of acceptance with all challenges for the executions with the valid witness remaining unchanged. In the following, we say that <span class="math">c_{e}=0</span> if the challenge for <span class="math">e</span> is to open the pre-processing and <span class="math">c_{e}\\neq 0</span> otherwise. Now, without loss of generality, assume that for <span class="math">e\\in\\{e_{j_{1}},\\ldots,e_{j_{k}}\\}</span>, it holds that <span class="math">c_{e}=0</span>, whereas for $e\\in\\{e_{j_{k+1}},\\ldots,e_{j_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\}<span class="math"> it holds that </span>c_{e}\\neq 0<span class="math"> (i.e., exactly </span>k$ of the executions with valid witness were chosen to be opened). It follows that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[c_{e_{j_{1}}}=\\cdots=c_{e_{j_{k}}}=0\\wedge c_{e_{j_{k+1}}}\\neq 0\\wedge\\cdots\\wedge c_{e_{j_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}}\\neq 0\\right]=\\frac{\\binom{M-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\tau-k}}{\\binom{M}{\\tau}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as well as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathsf{Jeq}\\ \\bigg{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ c_{e_{j_{1}}}=\\cdots=c_{e_{j_{k}}}=0\\wedge c_{e_{j_{k+1}}}\\neq 0\\wedge\\cdots\\wedge c_{e_{j_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}}\\neq 0\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(recall that for executions $e_{j_{k+1}},\\ldots,e_{j_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math"> a second challenge is chosen with probability </span>1/N$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, observe that once the challenges of the executions with correct witness are fixed and remain unchanged, we can compute the probability of obtaining a second <span class="math">\\mathsf{acc}</span> using our formula of <span class="math">\\xi_{\\mathsf{ccc}}</span>. That is, conditioned on the event that <span class="math">k</span> MPC preprocessings are opened and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-k$ are not opened, it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathsf{acc}\\ \\bigg{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\mathsf{Jeq}\\ \\wedge\\ \\binom{c_{e_{j_{1}}}=\\cdots=c_{e_{j_{k}}}=0\\ \\wedge}{c_{e_{j_{k+1}}}\\neq 0\\wedge\\cdots\\wedge c_{e_{j_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}}\\neq 0}\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(note that here <span class="math">\\bar{c}</span> is the number of corrupted pre-processings only within the executions with bad witness. This means that <span class="math">\\bar{c}\\leq c</span>). This holds since if the probability was higher, then a valid witness must have been used in some of the executions. However, in (3), the distribution is only over executions with an invalid witness.</p>

    <p class="text-gray-300">Combining (2) and (3) together, we conclude that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathsf{acc}\\wedge\\mathsf{Jeq}\\ \\bigg{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\begin{matrix}c_{e_{j_{1}}}=\\cdots=c_{e_{j_{k}}}=0\\ \\wedge\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq\\frac{\\binom{M-</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">-\\bar{c}}{\\tau-k}}{\\binom{M-</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">}{\\tau-k}}\\cdot\\frac{1}{N^{M-</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">-\\tau+k-\\bar{c}}}\\cdot\\frac{\\binom{M-</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">}{\\tau-k}}{\\binom{M}{\\tau}}\\cdot\\frac{1}{N^{</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">-k}}$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=\\frac{\\binom{M-</td>

            <td class="px-3 py-2 border-b border-gray-700">J</td>

            <td class="px-3 py-2 border-b border-gray-700">-\\bar{c}}{\\tau-k}}{\\binom{M}{\\tau}}\\cdot\\frac{1}{N^{M-\\tau-\\bar{c}}}&lt;\\frac{\\binom{M-c<em>}{\\tau}}{\\binom{M}{\\tau}}\\cdot\\frac{1}{N^{M-\\tau-c</em>}}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the last inequality holds since <span class="math">\\bar{c}\\leq c</span> (<span class="math">c</span> is the number of overall corrupted pre-processings, where <span class="math">\\bar{c}</span> is the derived by looking only on bad processings of the executions), $k+(c-\\bar{c})\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (</span>c-\\bar{c}<span class="math"> is the number of corrupted pre-processings for executions with good witness while </span>k<span class="math"> is the number of such executions that are opened and so their pre-procssing must be correct) and so </span>k+c\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\bar{c}$ which means that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\binom{M-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\bar{c}}{\\tau-k}N^{\\bar{c}}\\leq\\binom{M-k-c}{\\tau-k}N^{c}\\leq\\binom{M-c}{\\tau}N^{c}\\leq\\binom{M-c<em>}{\\tau}N^{c</em>}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, the second inequality follows because <span class="math">\\binom{x-1}{y-1} &amp;lt; \\binom{x}{y}</span> and the last step is due to the definition of <span class="math">c*</span>.</p>

    <p class="text-gray-300">Finally, we show that <span class="math">\\operatorname<em>{Pr}\\left[\\mathsf{acc}\\wedge \\mathsf{Jeq}\\right]\\leq \\frac{\\binom{M - c</em>}{\\tau}}{\\binom{M}{\\tau}}\\cdot \\frac{1}{N^{M - \\tau - c*}}</span>. This easily holds since</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr} \\left[ \\begin{array}{c} \\mathsf{acc} \\\\ \\wedge \\mathsf{Jeq} \\end{array} \\right] &amp;= \\sum_{Q \\subseteq J} \\left( \\operatorname{Pr} \\left[ \\mathsf{acc} \\wedge \\mathsf{Jeq} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\forall e \\in Q: c_e = 0 \\wedge \\\\ \\forall e \\in J \\setminus Q: c_e \\neq 0 \\end{array} \\right. \\right. \\right. \\cdot \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp;\\quad \\left. \\operatorname{Pr} \\left[ \\forall e \\in Q: c_e = 0 \\wedge \\forall e \\in J \\setminus Q: c_e \\neq 0 \\right] \\right) \\tag{4} \\\\ &amp;\\leq \\frac{\\binom{M - c<em>}{\\tau}}{\\binom{M}{\\tau}} \\cdot \\frac{1}{N^{M - \\tau - c</em>}} \\cdot \\\\ &amp;\\quad \\sum_{Q \\subseteq J} \\operatorname{Pr} \\left[ \\begin{array}{c} \\forall e \\in Q: c_e = 0 \\wedge \\\\ \\forall e \\in J \\setminus Q: c_e \\neq 0 \\end{array} \\right] \\\\ &amp;= \\frac{\\binom{M - c<em>}{\\tau}}{\\binom{M}{\\tau}} \\cdot \\frac{1}{N^{M - \\tau - c</em>}}. \\end{aligned} $$</p>

    <p class="text-gray-300">Since <span class="math">1 = \\sum_{Q\\subseteq J}\\operatorname *{Pr}\\left[\\forall e\\in Q:c_e = 0\\wedge \\forall e\\in J\\setminus Q:c_e\\neq 0\\right]</span> the last equality holds, which follows from the fact that the events whose probability we compute are all disjunct, but together they cover all possible challenges occurring for the elements in <span class="math">J</span>.</p>

    <p class="text-gray-300">Going back to (1), we have that <span class="math">\\delta &amp;lt; \\epsilon + \\frac{\\binom{M - c<em>}{\\tau}}{\\binom{M}{\\tau}} \\cdot \\frac{1}{N^{M - c</em> - \\tau}}</span> in contradiction to the assumption that <span class="math">\\delta = \\xi(M, N, \\tau) + \\epsilon</span>. Thus, there must exist an execution <span class="math">e</span> with a valid witness, for which <span class="math">\\operatorname*{Pr}\\left[\\mathsf{acc} \\mid c_e&#x27; \\neq c_e\\right] \\geq \\epsilon / M</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that our extractor tries to extract the witness from all executions until it succeeds to extract a correct witness from some execution. From Lemma 1, there exists an execution <span class="math">e</span> with a valid witness for which the probability of probing an accepting transcript that allows us to extract is higher than <span class="math">\\frac{\\epsilon}{M}</span>. Thus, the expected number of steps until the witness is extracted is bounded by <span class="math">\\frac{M}{\\epsilon}</span>. Note that <span class="math">M</span> depends only on the statistical security parameter but its size in independent of the common input <span class="math">x</span> held by the prover and the verifier (which is the circuit in our ZKAoK system). Thus, we conclude that if the success cheating probability is higher than <span class="math">\\xi_{\\mathsf{c}\\&amp;amp; \\mathsf{c}}(M,N,\\tau)</span>, then a valid witness can be extracted in $O(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\epsilon})<span class="math"> expected number of steps (recall that the extractor checks the validity of witnesses by running </span>C(\\mathbf{w})<span class="math">. Thus, the running time also depends on the common input </span>x$ which is allowed by the definition). This concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication Cost Analysis. We now estimate the communication cost of the above protocol. The analysis includes the optimizations outlined at the end of the section. We denote by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{hash}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sd}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ the length of the hash values, seeds and commitments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The communication cost of messages sent from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span> in each round is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Round 1: 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Round 5: $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{sd}</td>

            <td class="px-3 py-2 border-b border-gray-700">+ (M - \\tau) \\cdot (\\log N \\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{sd}</td>

            <td class="px-3 py-2 border-b border-gray-700">) + (M - \\tau) \\cdot (</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{com}</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 3 \\log_2(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">) \\cdot n_{mul} + 2 \\log_2(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">) \\cdot n_{sq} + \\log_2(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">) \\cdot n_{\\mathrm{in}}) + (M - \\tau) \\cdot (\\log_2(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">))$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Summing the above, we obtain that the overall communication cost incurred by messages sent by <span class="math">\\mathcal{P}</span> is</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{hash}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 3 +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sd}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (\\tau + 1 + \\log N(M - \\tau)) +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2(M - \\tau) + \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">3.3 HVZKAoK Protocol Using Imperfect Preprocessing and Sacrificing</p>

    <p class="text-gray-300">We now present our second HVZKAoK protocol <span class="math">\\Pi_{\\tt sac}</span>. In this protocol, we rely on a method where one “sacrifices” random multiplication triples and squares in order to verify the correctness of multiplication and square operations. The idea of this protocol is that <span class="math">\\mathcal{P}</span> does not simulate the execution of a protocol to <em>compute</em> multiplication and square gates, but rather simulates an execution of a protocol to <em>verify</em> that the shares on the output wires of these gates are correctly defined. This means that now <span class="math">\\mathcal{P}</span> will first define and commit to sharings of the values on each wire of the circuit and then will simulate an execution of a verification protocol for multiplication and square gates (recall that for other gates the computation is local and thus no verification is required). We begin by describing the verification methods used in our protocol.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Verification of a multiplication triple using another.</h5>

    <p class="text-gray-300">This procedure is reminiscent to the recent work of <em>[x14]</em>. Given a random triple <span class="math">(\\llbracket a\\rrbracket,\\llbracket b\\rrbracket,\\llbracket c\\rrbracket)</span>, it is possible to verify the correctness of a triple <span class="math">(\\llbracket x\\rrbracket,\\llbracket y\\rrbracket,\\llbracket z\\rrbracket)</span>, i.e., that <span class="math">z=x\\cdot y</span>, without revealing any information on either of the triples, in the following way:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties generate a random <span class="math">\\epsilon\\in\\mathbb{F}</span>.</li>

      <li>The parties locally set <span class="math">\\llbracket\\alpha\\rrbracket=\\epsilon\\llbracket x\\rrbracket+\\llbracket a\\rrbracket</span>, <span class="math">\\llbracket\\beta\\rrbracket=\\llbracket y\\rrbracket+\\llbracket b\\rrbracket</span>.</li>

      <li>The parties run <span class="math">\\mathsf{open}(\\llbracket\\alpha\\rrbracket)</span> and <span class="math">\\mathsf{open}(\\llbracket\\beta\\rrbracket)</span> to obtain <span class="math">\\alpha</span> and <span class="math">\\beta</span>.</li>

      <li>The parties locally set <span class="math">\\llbracket v\\rrbracket=\\epsilon\\llbracket z\\rrbracket-\\llbracket c\\rrbracket+\\alpha\\cdot\\llbracket b\\rrbracket+\\beta\\cdot\\llbracket a\\rrbracket-\\alpha\\cdot\\beta</span>.</li>

      <li>The parties run <span class="math">\\mathsf{open}(\\llbracket v\\rrbracket)</span> to obtain <span class="math">v</span> and accept iff <span class="math">v=0</span>.</li>

    </ol>

    <p class="text-gray-300">Observe that if both triples are correct multiplication triples (i.e., <span class="math">z=xy</span> and <span class="math">c=ab</span>) then the parties will always accept since</p>

    <p class="text-gray-300"><span class="math">v</span> <span class="math">=\\epsilon\\cdot z-c+\\alpha\\cdot b+\\beta\\cdot a-\\alpha\\cdot\\beta</span> <span class="math">=\\epsilon\\cdot xy-ab+(\\epsilon\\cdot x+a)b+(y+b)a-(\\epsilon\\cdot x+a)(y+b)=0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In contrast, if one (or both) of the triples are incorrect, then the parties will accept with probability at most $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ as shown in Lemma 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">(\\llbracket a\\rrbracket,\\llbracket b\\rrbracket,\\llbracket c\\rrbracket)</span> or <span class="math">(\\llbracket x\\rrbracket,\\llbracket y\\rrbracket,\\llbracket z\\rrbracket)</span> is an incorrect multiplication triple then the parties output <span class="math">\\tt acc</span> in the sub-protocol above with probability $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\Delta_{z}=z-x\\cdot y</span> and <span class="math">\\Delta_{c}=c-a\\cdot b</span>. If the parties output <span class="math">\\tt acc</span> then it means that <span class="math">v=0</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">v</span> <span class="math">=\\epsilon\\cdot z-c+\\alpha\\cdot b+\\beta\\cdot a-\\alpha\\cdot\\beta</span> <span class="math">=\\epsilon\\cdot(xy+\\Delta_{z})-(ab+\\Delta_{c})+(\\epsilon\\cdot x+a)b+(y+b)a-</span> <span class="math">(\\epsilon\\cdot x+a)(y+b)</span> <span class="math">=\\epsilon\\Delta_{z}-\\Delta_{c}=0.</span></p>

    <p class="text-gray-300">Next, consider the following cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Case 1: <span class="math">\\Delta_{z}=0</span>, <span class="math">\\Delta_{c}\\neq 0</span>.</em> In this case, <span class="math">v=-\\Delta_{c}\\neq 0</span>. Thus, the parties will not output <span class="math">\\tt acc</span> in contradiction to the assumption.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Case 2: <span class="math">\\Delta_{z}\\neq 0</span>, <span class="math">\\Delta_{c}\\neq 0</span>.</em> In this case, <span class="math">v=0</span> iff <span class="math">\\epsilon=\\Delta_{c}\\cdot(\\Delta_{z})^{-1}</span>. Since <span class="math">\\epsilon</span> is uniformly distributed over <span class="math">\\mathbb{F}</span>, this happens with probability $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Going over all cases, we conclude that the lemma follows. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Verification of a square pair using another. Similarly, one can use a random square <span class="math">(\\llbracket b\\rrbracket,\\llbracket d\\rrbracket)</span> to verify the correctness of a given square <span class="math">(\\llbracket x\\rrbracket,\\llbracket z\\rrbracket)</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties generate a random <span class="math">\\epsilon\\in\\mathbb{F}</span>.</li>

      <li>The parties locally compute <span class="math">\\llbracket\\alpha\\rrbracket=\\llbracket x\\rrbracket-\\epsilon\\llbracket b\\rrbracket</span>.</li>

      <li>The parties run <span class="math">\\mathsf{open}(\\llbracket\\alpha\\rrbracket)</span> to obtain <span class="math">\\alpha</span>.</li>

      <li>Each party locally computes <span class="math">\\llbracket v\\rrbracket=\\llbracket z\\rrbracket-\\alpha\\cdot(\\llbracket x\\rrbracket+\\epsilon\\llbracket b\\rrbracket)-\\epsilon^{2}\\llbracket d\\rrbracket</span>.</li>

      <li>The parties run <span class="math">\\mathsf{open}(\\llbracket v\\rrbracket)</span> to obtain <span class="math">v</span> and accept iff <span class="math">v=0</span>.</li>

    </ol>

    <p class="text-gray-300">As before, if the squares are correct, i.e., <span class="math">z=x^{2}</span> and <span class="math">d=b^{2}</span>, then the parties will accept, since</p>

    <p class="text-gray-300"><span class="math">v</span> <span class="math">=z-\\alpha\\cdot(x+\\epsilon\\cdot b)-\\epsilon^{2}\\cdot d</span> <span class="math">=x^{2}-(x-\\epsilon\\cdot b)\\cdot(x+\\epsilon\\cdot b)-\\epsilon^{2}\\cdot b^{2}</span> <span class="math">=x^{2}-x^{2}+\\epsilon^{2}b^{2}-\\epsilon^{2}b^{2}=0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In contrast, if one of the random squares (or both) is incorrect, then the parties will accept with probability $\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. This is shown in Lemma 3 below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-29" class="text-base font-medium mt-4">Lemma 3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">(\\llbracket x\\rrbracket,\\llbracket z\\rrbracket)</span> or <span class="math">(\\llbracket b\\rrbracket,\\llbracket d\\rrbracket)</span> is an incorrect square, then the parties output <span class="math">\\mathsf{acc}</span> in the above protocol with probability $\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\Delta_{d}=d-b^{2}</span> and <span class="math">\\Delta_{z}=z-x^{2}</span> and assume that the parties output <span class="math">\\mathsf{acc}</span>. This means that</p>

    <p class="text-gray-300"><span class="math">v</span> <span class="math">=z-\\alpha\\cdot(x+\\epsilon\\cdot b)-\\epsilon^{2}\\cdot d</span> <span class="math">=x^{2}+\\Delta_{z}-(x-\\epsilon\\cdot b)\\cdot(x+\\epsilon\\cdot b)-\\epsilon^{2}\\cdot(b^{2}+\\Delta_{d})</span> <span class="math">=\\Delta_{z}-\\epsilon^{2}\\cdot\\Delta_{d}=0.</span></p>

    <p class="text-gray-300">We consider the following three cases:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Case 1: <span class="math">\\Delta_{z}=0</span>, <span class="math">\\Delta_{d}\\neq 0</span>.</em> In this case, <span class="math">v=0</span> iff $\\epsilon^{2}=0\\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which holds iff </span>\\epsilon=0<span class="math">. Since </span>\\epsilon<span class="math"> is chosen randomly from </span>\\mathbb{F}<span class="math">, this holds with probability </span>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Case 3: <span class="math">\\Delta_{z}\\neq 0</span>, <span class="math">\\Delta_{d}=0</span>.</em> In this case, <span class="math">v=\\Delta_{z}\\neq 0</span> and thus the parties will not output <span class="math">\\mathsf{acc}</span>.</li>

    </ul>

    <p class="text-gray-300">Going over all possible cases, we conclude that the lemma follows. ∎</p>

    <p class="text-gray-300"><em>The protocol.</em> Our AoK protocol is formally described in Fig. 2.a and Fig. 2.b. In this protocol, the prover <span class="math">\\mathcal{P}</span> first commits in Round 1 to sharings of the values on each wire of the circuit and to sharings of random multiplication triples and squares for <span class="math">M</span> independent executions. As in the previous protocol, we save communication by deriving all the random shares from a single seed. Then, in Round 2, <span class="math">\\mathcal{V}</span> challenges <span class="math">\\mathcal{P}</span> by choosing the randomness required for the verification procedure, i.e., an <span class="math">\\epsilon</span> value for each multiplication and square gate. Upon receiving the challenge from <span class="math">\\mathcal{V}</span>, <span class="math">\\mathcal{P}</span> simulates <span class="math">M</span> executions of the verification protocol in Round 3 and commits to the view of the parties in each execution. Then, in Round 4, <span class="math">\\mathcal{V}</span> picks its second challenge by choosing, for each execution, <span class="math">N-1</span> parties whose view will be opened and tested. In Round 5, <span class="math">\\mathcal{P}</span> sends to <span class="math">\\mathcal{V}</span> the seeds from which the randomness of the <span class="math">N-1</span> parties was derived and all the messages sent to these parties from the remaining party <span class="math">P_{\\zeta_{c}}</span>. As in <span class="math">\\Pi_{\\mathsf{c\\&amp;c}}</span>, for values that are fixed, i.e., inputs, multiplications and squares, <span class="math">\\mathcal{P}</span> sends also an offset (which was committed in the first round) to “fix“ the sharing to the correct value. As before, we further reduce the communication cost by hashing the commitments together and sending only the hash value. Finally, <span class="math">\\mathcal{V}</span> accepts if and only if all commitments are correct, the view of each party was computed correctly, the verification procedures conclude with the parties holding a sharing of <span class="math">0</span> for each multiplication/square gate and the output of the circuit is <span class="math">\\mathbf{y}</span></p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Cheating probability (soundness)</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We compute the probability that <span class="math">\\mathcal{V}</span> outputs acc when <span class="math">C(\\mathbf{w})\\neq\\mathbf{y}</span>. Observe that all the <span class="math">M</span> executions are independent of each other. When considering a single instance, <span class="math">\\mathcal{P}</span> can cheat in either computing the view of one of the parties or cheat by changing the shares on the output wire of a multiplication/square gate. In the former case, it will succeed with probability <span class="math">\\frac{1}{N}</span> whereas in the latter case it will succeed with probability $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> or </span>\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (note that if there are gates of both types in the circuit, it will be more beneficial for </span>\\mathcal{P}<span class="math"> to cheat in square gates since </span>\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$). Furthermore, the best strategy for the prover is to first cheat in multiplication/square gates and then if it didn’t receive the desired challenge that will cause the verification process to end successfully, it can manipulate one of the parties’ view. Thus, if there are square gates in the circuit, then the overall cheating probability is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\xi_{\\mathsf{sac}}(M,N)=\\left(\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\left(1-\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\cdot\\frac{1}{N}\\right)^{M}=\\left(\\frac{2N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot N}\\right)^{M}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similarly, if there are multiplication gates in the circuit (and no square gates), then the cheating probability is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\xi_{\\mathsf{sac}}(M,N)=\\left(\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\left(1-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\cdot\\frac{1}{N}\\right)^{M}=\\left(\\frac{N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot N}\\right)^{M}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It can be seen that the impact of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> on the cheating probability in practice is not important, as the </span>1/N<span class="math">-term will dominate the expression since </span>N\\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will give the full proof of the following</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Let <span class="math">H</span> be a collision-resistant hash function and let com be the Random Oracle-based commitment scheme. Then the protocol <span class="math">\\Pi_{\\mathsf{sac}}</span> is a HVZKAoK with knowledge error (soundness) <span class="math">\\xi_{\\mathsf{sac}}(M,N)</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove that each of the three properties defined in Section 2.2 are satisfied by our protocol.</p>

    <p class="text-gray-300">Completeness. This follows from the correctness of the MPC protocol.</p>

    <p class="text-gray-300">Honest Verifier Zero Knowledge. We construct a simulator <span class="math">\\mathcal{S}</span> for our protocol which works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">e=1,\\ldots,M</span>, <span class="math">\\mathcal{S}</span> chooses random challenges <span class="math">\\epsilon_{e,k}</span> for each multiplication and square gate <span class="math">g_{k}</span> in <span class="math">C</span> and random <span class="math">\\bar{i}_{e}\\in[N]</span>.</li>

      <li><span class="math">\\mathcal{S}</span> simulates the first step of the protocol: for each <span class="math">e\\in[M]</span> and <span class="math">i\\in[N]\\setminus\\bar{i}_{e}</span>, it defines the shares of the random multiplication triples and squares and the shares on each wire of the circuit as an honest prover would do. For generating <span class="math">\\mathsf{st}_{e}</span>, <span class="math">\\mathcal{S}</span> chooses random <span class="math">\\Delta_{e,k}</span> for each random triple/square gate and random <span class="math">\\varphi_{e,k}</span> for each multiplication/square gate and random <span class="math">\\phi_{e,k}</span> for each input wire <span class="math">k</span>. Then, it computes <span class="math">\\mathsf{st}_{e,i}</span> and <span class="math">\\Gamma_{e,i}</span> as an honest prover. For <span class="math">\\Gamma_{e,\\bar{i}_{e}}</span>, it uses the <span class="math">0</span>-string as the committed message. Finally, <span class="math">\\mathcal{S}</span> computes <span class="math">h_{\\Gamma}</span> as an honest prover.</li>

      <li><span class="math">\\mathcal{S}</span> simulates Round 3:</li>

    </ol>

    <p class="text-gray-300">(a) First, it initializes an empty string <span class="math">\\mathsf{view}_{e}</span> for all <span class="math">e\\in[M]</span>. (b) For each <span class="math">e\\in[M]</span>, it chooses random <span class="math">\\alpha_{e,k,i}</span> and <span class="math">\\beta_{e,k,i}</span> for each multiplication and square gate <span class="math">g_{k}</span> and <span class="math">i\\in[N]</span> and adds them to <span class="math">\\mathsf{view}_{e}</span> (note that here it chooses shares for all parties including party <span class="math">\\bar{i}_{e}</span>). (c) For each <span class="math">e\\in[M]</span>, multiplication/square gate <span class="math">g_{k}</span> and <span class="math">i\\in[N]\\setminus\\{\\bar{i}_{e}\\}</span>, <span class="math">\\mathcal{S}</span> computes <span class="math">v_{e,k,i}</span> as an honest prover. Then, it sets <span class="math">v_{e,k,\\bar{i}_{e}}</span> such that <span class="math">\\sum_{i=1}^{N}v_{e,k,i}=0</span> and adds <span class="math">v_{e,k,i}</span> for all <span class="math">i\\in[N]</span> to <span class="math">\\mathsf{view}_{e}</span>. (d) For each <span class="math">e\\in[M]</span>, <span class="math">i\\in[N]\\setminus\\{\\bar{i}_{e}\\}</span> and <span class="math">k\\in[n_{\\mathsf{out}}]</span>, <span class="math">\\mathcal{S}</span> computes <span class="math">o_{e,k,i}</span> as an honest prover. Then, it sets <span class="math">o_{e,k,\\bar{i}_{e}}</span> such that <span class="math">\\sum_{i=1}^{N}o_{e,k,i}=y_{k}</span> and adds <span class="math">o_{e,k,i}</span> for all <span class="math">i\\in[N],k\\in[n_{\\mathsf{out}}]</span> to <span class="math">\\mathsf{view}_{e}</span>. (e) <span class="math">\\mathcal{S}</span> computes <span class="math">\\{\\Pi_{e}\\}_{e\\in[M]}</span> and <span class="math">h_{\\pi}</span> as an honest prover would do.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> outputs the transcript of the protocol.</li>

    </ol>

    <p class="text-gray-300">The only difference between the simulation and a real execution is the way the commitments to the shares of party <span class="math">\\bar{i}_{e}</span> are computed and the way <span class="math">\\Delta_{e,k},\\phi_{e,k},\\varphi_{e,k},\\alpha_{e,k,i}</span> and <span class="math">\\beta_{e,k,i}</span> are chosen (in the simulation they are chosen uniformly whereas in the real execution they computed deterministically as the difference between</p>

    <p class="text-gray-300">Let  <span class="math">H</span>  be a CRHF and  <span class="math">\\mathsf{com}</span>  be the Random Oracle-based commitment scheme.</p>

    <p class="text-gray-300">Inputs: Both  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  hold  <span class="math">\\mathbf{y} \\in \\mathbb{F}^{n_{\\mathrm{out}}}</span> , a description  <span class="math">C</span>  over  <span class="math">\\mathbb{F}</span>  and parameters  <span class="math">M, N</span> ;  <span class="math">\\mathcal{P}</span>  additionally holds  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{n_{\\mathrm{in}}}</span>  such that  <span class="math">C(\\mathbf{w}) = \\mathbf{y}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  chooses a salt salt  <span class="math">\\leftarrow \\mathbb{B}^{\\lambda}</span>  and does the following for each  <span class="math">e\\in [M]</span></li>

    </ol>

    <p class="text-gray-300">(a) Initialize empty strings  <span class="math">\\mathsf{st}_e, \\{\\mathsf{st}_{e,i}\\}_{i \\in [N]}</span> . (b) Choose seeds  <span class="math">\\mathsf{sd}_e, \\{\\mathsf{sd}_{e,i}\\}_{i \\in [N]}</span>  and set  <span class="math">\\mathsf{st}_{e,i} \\gets \\mathsf{sd}_{e,i}</span>  for  <span class="math">i \\in [N]</span> . (c) Prepare the pre-processing data:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each multiplication gate  <span class="math">g_{k} \\in \\mathcal{G}</span> :</li>

    </ul>

    <p class="text-gray-300">i. For each  <span class="math">i \\in [N]</span> , use  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">a_{e,k,i}, b_{e,k,i}, c_{e,k,i}</span> . These shares define the random sharings  <span class="math">\\llbracket a_{e,k} \\rrbracket, \\llbracket b_{e,k} \\rrbracket</span>  and  <span class="math">\\llbracket c_{e,k} \\rrbracket</span> , where  <span class="math">a_{e,k} = \\sum_{i=1}^{N} a_{e,k,i}</span> ,  <span class="math">b_{e,k} = \\sum_{i=1}^{N} b_{e,k,i}</span>  and  <span class="math">c_{e,k} = \\sum_{i=1}^{N} c_{e,k,i}</span> . ii. Set  <span class="math">\\varDelta_{e,k}=a_{e,k}\\cdot b_{e,k}-c_{e,k}</span>  and  <span class="math">\\mathsf{st}_e\\gets \\mathsf{st}_e\\parallel \\varDelta_{e,k}</span> iii. Define the random triple for  <span class="math">g_{k}</span>  to be  <span class="math">([a_{e,k}], [b_{e,k}], [c_{e,k}]) + \\varDelta_{e,k})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each square gate  <span class="math">g_{k} \\in \\mathcal{G}</span> :</li>

    </ul>

    <p class="text-gray-300">i. For each  <span class="math">i \\in [N]</span>  use  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">b_{e,k,i}</span>  and  <span class="math">d_{e,k,i}</span> . These shares define the random sharings  <span class="math">\\llbracket b_{e,k} \\rrbracket</span>  and  <span class="math">\\llbracket d_{e,k} \\rrbracket</span> , where  <span class="math">b_{e,k} = \\sum_{i=1}^{N} b_{e,k,i}</span>  and  <span class="math">d_{e,k} = \\sum_{i=1}^{N} d_{e,k,i}</span> . ii. Set  <span class="math">\\varDelta_{e,k}=(b_{e,k})^{2}-d_{e,k}</span>  and  <span class="math">\\mathsf{st}_e\\gets \\mathsf{st}_e\\parallel \\varDelta_{e,k}</span> iii. Define the random square for  <span class="math">g_{k}</span>  to be  <span class="math">([b_{e,k}], [d_{e,k}]) + \\varDelta_{e,k})</span></p>

    <p class="text-gray-300">(d) Choose a random sharing of the inputs:</p>

    <p class="text-gray-300">i. For each  <span class="math">i \\in [N]</span> , use  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">w_{e,1,i}, \\ldots, w_{e,n_{\\mathrm{in}},i}</span> . These shares define the random sharings  <span class="math">\\llbracket w_{e,1} \\rrbracket, \\ldots, \\llbracket w_{e,n_{\\mathrm{in}}} \\rrbracket</span> , where  <span class="math">w_{e,k} = \\sum_{i=1}^{N} w_{e,k,i}</span> . ii. For each input wire  <span class="math">k \\in \\mathcal{I}</span>  set  <span class="math">\\phi_{e,k} = w_k - \\sum_{i=1}^{N-1} w_{e,k,i}</span>  and  <span class="math">\\mathsf{st}_e \\gets \\mathsf{st}_e \\parallel \\phi_{e,k}</span> . The sharing on this wire then is  <span class="math">[[w_{e,k}]] + \\phi_{e,k}</span> .</p>

    <p class="text-gray-300">(e) Simulate the computation of  <span class="math">C</span>  gate-by-gate in topological order:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each linear gate, compute the parties' output shares via the local operation described in Section 3.1.</li>

      <li>For each multiplication gate  <span class="math">g_{k} \\in \\mathcal{G}</span>  with  <span class="math">[[x_{k}], [[y_{k}]]</span>  as inputs:</li>

    </ul>

    <p class="text-gray-300">i. For each  <span class="math">i \\in [N]</span> , use  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">z_{e,k,i}</span>  which define the random sharing  <span class="math">\\llbracket z_{e,k} \\rrbracket</span>  where  <span class="math">z_{e,k} = \\sum_{i=1}^{N} z_{e,k,i}</span> . ii. Set:  <span class="math">\\varphi_{e,k} = x_k\\cdot y_k - \\sum_{i = 1}^{N}z_{e,k,i}</span>  and  <span class="math">\\mathsf{st}_e\\gets \\mathsf{st}_e\\parallel \\varphi_{e,k}</span></p>

    <p class="text-gray-300">The sharing on the output wire is defined to be  <span class="math">\\llbracket z_{e,k}\\rrbracket +\\varphi_{e,k}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each square gate  <span class="math">g_{k} \\in \\mathcal{G}</span>  with sharing  <span class="math">[[x_{k}]]</span>  on its input wire:</li>

    </ul>

    <p class="text-gray-300">i. For each  <span class="math">i \\in [N]</span>  use  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">z_{e,k,i}</span> . These shares define the random sharing  <span class="math">\\llbracket z_{e,k} \\rrbracket</span>  where  <span class="math">z_{e,k} = \\sum_{i=1}^{N} z_{e,k,i}</span> . ii. Set:  <span class="math">\\varphi_{e,k} = (x_k)^2 -\\sum_{i = 1}^N z_{e,k,i}</span>  and  <span class="math">\\mathsf{st}_e\\gets \\mathsf{st}_e\\parallel \\varphi_{e,k}</span></p>

    <p class="text-gray-300">The sharing on the output wire is defined to be  <span class="math">\\llbracket z_{e,k}\\rrbracket +\\varphi_{e,k}</span></p>

    <p class="text-gray-300">(f) Use  <span class="math">\\mathsf{sd}_e</span>  to generate  <span class="math">r_e\\in \\mathbb{B}^\\lambda</span>  and compute  <span class="math">\\Gamma_{e} = \\mathsf{com}(\\mathsf{st}_{e},r_{e},\\mathsf{salt})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(g) For each  <span class="math">i \\in [N]</span>  use  <span class="math">\\mathsf{sd}_{e,i}</span>  to generate  <span class="math">r_{e,i} \\in \\mathbb{B}^{\\lambda}</span>  and then compute  <span class="math">\\Gamma_{e,i} = \\mathsf{com}(\\mathsf{st}_{e,i}, r_{e,i}, \\mathsf{salt})</span> . Then set  $h_e = H(\\Gamma_e \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Gamma_{e,1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Gamma_{e,N})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">h_{\\Gamma} = H(h_1 \\parallel \\dots \\parallel h_M)</span>  and send it to  <span class="math">\\mathcal{V}</span> .</li>

    </ol>

    <p class="text-gray-300">Fig. 2.a: The "Sacrificing" Based Argument  <span class="math">\\Pi_{\\mathrm{sac}}</span>  (Part 1)</p>

    <p class="text-gray-300">random sharings and actual values that are on the wires). However, from the hiding property of the commitment the former does not change and since  <span class="math">\\varDelta_{e,k},\\phi_{e,k},\\varphi_{e,k},\\alpha_{e,k,i}</span>  and  <span class="math">\\beta_{e,k,i}</span>  are all uniformly distributed over  <span class="math">\\mathbb{F}</span>  in both executions, the distribution of the latter does not change as well (since all of them are defined by a random sharing which is kept secret from the verifier). Therefore, we conclude that the transcript generated by  <span class="math">\\mathcal{S}</span>  is indistinguishable from a real execution.</p>

    <p class="text-gray-300">Knowledge Soundness. As in the proof of Theorem 2, we assume for simplicity that the commitment scheme is perfectly binding and that there are no collisions for the hash function. In addition, we consider the case where there are only multiplication gates in the circuit. The proof for the case when there are also square gates is similar with the appropriate changes. Recall that we denote by  <span class="math">n_{mul}</span>  the number of multiplication gates in the circuit. Clearly, a cheating prover might not need to cheat in every multiplication gate in order</p>

    <p class="text-gray-300">|  Round 2: V chooses sd, and for each e ∈ [M] uses sd, to generate random coefficients εe,k for each multiplication/square gate gk. V then sends sd, to P.  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Round 3: P performs the following steps:  |</p>

    <p class="text-gray-300">|  1. Choose a random seed sdE. Use sd, to generate random εe,k as V would do.  |</p>

    <p class="text-gray-300">|  2. For each e ∈ [M]:  |</p>

    <p class="text-gray-300">|  (a) Initialize an empty string viewe.  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) For each multiplication gate gk (in topological order) simulate the verification procedure described in the text using εe,k. In addition, set: viewe← viewe</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">αe,k,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">αe,k,N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">βe,k,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">βe,k,N.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(d) Let ve,k,i be the sharing held by party Pi at the end of the verification procedure of gate gk. Then, for each i ∈ [N] set: viewe← viewe</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ve,k,1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ve,k,N.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(e) Let oe,1,i, ..., oenout,i be the shares on the output wires of C held by Pi. Then, for output wire k ∈ O set: viewe← viewe</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">oe,k,1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">oe,k,N.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3. Generate ge ∈ {0,1}3 from sdE and set Πe = com(viewe, ge, salt).  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Compute hπ = H(Π1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ΠM) and send it to V.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Round 4: For each e ∈ [M]: V sends a random i̅e ∈ [N] to P.  |</p>

    <p class="text-gray-300">|  Round 5: For each e ∈ [M]:  |</p>

    <p class="text-gray-300">|  Let Ie = [N] \\ {i̅e}. Then, P sends the following to V: salt, sdE, sde, {sde,i}i∈Ie, Γe,i̅e, {φe,k}nMk=1, the tuple (Δe,k, φe,k, αe,k,i̅e, βe,k,i̅e, ve,k,i̅e) for each multiplication or square gate gk, and oe,1,i̅e, ..., oenout,i̅e.  |</p>

    <p class="text-gray-300">|  Output: V outputs acc iff all the following checks succeed:  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For each e ∈ [M], V uses {sde,i}i∈Ie and the tuple received for each multiplication and square gate to compute the shares of the parties in Ie on each wire and their shares of each random triple and square. Then, it uses sde to compute Γe and uses {sde,i}i∈Ie to compute {Γe,i}i∈Ie as an honest prover would do. Then, using Γe,i̅e received from P, the verifier V computes he. Then, V checks that hΓ = H(h1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hM).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3. For each e ∈ [M] and multiplication/square gate gk, V checks if ∑i=1N ve,k,i = 0.  |</p>

    <p class="text-gray-300">|  4. For each e ∈ [M], for each k ∈ O, V checks that ∑i=1N oe,k,i = yk.  |</p>

    <p class="text-gray-300">Fig. 2.b: The "Sacrificing" Based Argument  <span class="math">\\varPi_{\\mathrm{sac}}</span>  (Part 2)</p>

    <p class="text-gray-300">to make the output correct, as this depends on the structure of the circuit. Thus, throughout the proof, we assume that the prover cheats in  <span class="math">k</span>  multiplications and that this suffices to totally manipulate the output.</p>

    <p class="text-gray-300">As the challenges of the different MPC instances are independent, we proceed by analyzing a single instance first (i.e. let  <span class="math">M = 1</span> ,  <span class="math">\\xi_{\\mathrm{sac}}(1,N) = \\xi_{\\mathrm{sac}}(N)</span> ) and then argue how this generalized to arbitrary choices of  <span class="math">M</span> . We begin by showing that if the cheating probability  <span class="math">\\delta(x)</span>  is higher than  <span class="math">\\xi_{\\mathrm{sac}}(N)</span> , then the prover must have committed to the correct witness  <span class="math">\\mathbf{w}</span> .</p>

    <p class="text-gray-300">Lemma 4. Let  <span class="math">M = 1</span> . If  <span class="math">\\delta(x) &amp;gt; \\xi_{\\mathrm{sac}}(N)</span> , then the prover  <span class="math">\\mathcal{P}^*</span>  must have committed to the correct witness w in Round 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. To see this, let  <span class="math">\\mathbf{G}</span>  be a  <span class="math">0/1</span>  matrix, where each column corresponds to a possible first challenge of the verifier, each row corresponds to a possible second challenge and the bit in each cell indicates whether the verifier outputs acc or not. It follows that there are  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}}<span class="math">  columns and  </span>N<span class="math">  rows in  </span>\\mathbf{G}<span class="math"> . Thus, if  </span>\\delta(x) &gt; \\frac{N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}{N \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , then the number of &#x27;1&#x27; entries in  </span>\\mathbf{G}<span class="math">  is larger than  </span>(N + \\mathbb{F} - 1) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul} - 1}<span class="math"> . Now, assume for the sake of contradiction that the prover has cheated in  </span>k &gt; 0<span class="math">  multiplication triples. By Lemma 2 there is one challenge for each of these gates for which the verifier won&#x27;t detect cheating. With loss of generality we say that the challenges  </span>\\epsilon_1, \\ldots, \\epsilon_k<span class="math">  are for the corrupted gates and challenges  </span>\\epsilon_{k+1}, \\ldots, \\epsilon_{n_{mul}}<span class="math">  are for the remaining gates, and denote the  </span>k<span class="math">  challenges, for which the verification procedure ends successfully, by  </span>\\bar{\\epsilon}_1, \\ldots, \\bar{\\epsilon}_k$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, there are $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}-k}<span class="math"> columns that can be filled with &#x27;1&#x27; entries (in each such column the challenges </span>\\epsilon_1,\\ldots ,\\epsilon_k<span class="math"> are fixed to </span>\\bar{\\epsilon}_1,\\ldots ,\\bar{\\epsilon}_k<span class="math"> and so it is required to choose a challenge only for the remaining </span>n_{mul} - k<span class="math"> multiplication gates). For the remaining columns, we claim that there must exist at least one column with more than a single &#x27;1&#x27; entry. This holds since otherwise the number of &#x27;1&#x27; entries in </span>\\mathbf{G}<span class="math"> is bounded by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}-k}\\cdot N + (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}-k})\\cdot 1 = (N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k -1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}-k}<span class="math"> (for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}-k}<span class="math"> columns all </span>N<span class="math"> entries are filled with &#x27;1&#x27; and for the other columns there is a single &#x27;1&#x27; entry). However, this is in contradiction to our assumption that there are more than </span>(N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul} - 1}<span class="math"> entries with &#x27;1&#x27; in </span>\\mathbf{G}$, since</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {n _ {m u l} - 1} \\geq (N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {k} - 1) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {n _ {m u l} - k} \\tag {5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(to see that this inequality holds, observe that it is equivalent to $(N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k - 1}\\geq N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k -1<span class="math"> which is equivalent to </span>N\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k - 1} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k - 1}\\geq N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k -1<span class="math"> which can be written as </span>(N - 1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k - 1}\\geq N - 1<span class="math"> which holds for any </span>k &gt; 0<span class="math">). We conclude that there must be a column with challenges </span>\\epsilon_1',\\ldots ,\\epsilon_{n_{mul}}'<span class="math"> such that </span>\\exists i\\in [k]:\\epsilon_i'\\neq \\bar{\\epsilon}_i<span class="math">, that has at least two &#x27;1&#x27; entries. That is, for the first challenge which corresponds to that column, the prover can answer successfully at least two different second challenges. Let </span>c_{1}<span class="math"> and </span>c_{2}<span class="math"> the challenges corresponding to such two accepting transcripts, i.e., both have the same first challenge </span>\\epsilon_1',\\dots,\\epsilon_{n_{mul}}'<span class="math"> and different second challenge </span>i_{1}<span class="math"> and </span>i_{2}<span class="math">. Note that it is possible to compute a witness from </span>c_{1}<span class="math"> and </span>c_{2}<span class="math">, since two different second challenges reveals the inputs of all the parties. Let </span>\\mathbf{w}^*<span class="math"> be the witness computed from </span>c_{1}<span class="math"> and </span>c_{2}<span class="math">. We argue that this is a valid witness, i.e., that </span>C(\\mathbf{w}) = \\mathbf{y}<span class="math">. This holds since when the verifier accepts, </span>C(\\mathbf{w})\\neq \\mathbf{y}<span class="math"> only if one of two events occur: (a) one of the parties&#x27; views is inconsistent but it is not chosen to be opened by </span>\\nu<span class="math"> or (b) there are multiplication gates that were not correctly computed but </span>\\nu<span class="math"> chooses the one single challenge that makes the verification procedure end successfully for each of these gates. However, the first event does not happen, since </span>c_{1}<span class="math"> and </span>c_{2}<span class="math"> differs in the second challenge, and thus all parties&#x27; views are covered and verified in the two executions. The second event does not happen as well for </span>c_{1}<span class="math"> and </span>c_{2}<span class="math"> since for both of them the first challenge has the property that </span>\\exists i\\in [k]:\\epsilon_i'\\neq \\bar{\\epsilon}_i<span class="math"> (recall that </span>\\bar{\\epsilon}_i<span class="math"> is the only challenge for the corrupted gate </span>i<span class="math"> that makes the verification procedure succeed). This contradicts our assumption on the number of multiplication triples which are incorrect. We conclude that </span>\\mathbf{w}$ must be a valid witness and thus the claim follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the protocol however we will have <span class="math">M &amp;gt; 1</span> MPC instances. We therefore define the set <span class="math">S</span> as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\tau = \\left( \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\epsilon_ {1} ^ {(1)}, \\ldots , \\epsilon_ {n _ {m u l}} ^ {(M)}, &amp; \\tau \\in \\mathbb {F} ^ {n _ {m u l} \\cdot M} \\times [ N ] ^ {M} \\wedge \\\\ i _ {1}, \\ldots , i _ {M} &amp; \\tau \\text { is challenge} \\\\ &amp; \\text { vector of accept-} \\\\ &amp; \\text { ing transcript} \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j = (\\epsilon_1^{(j)},\\ldots ,\\epsilon_{n_{mul}}^{(j)},i_j)<span class="math"> denotes the challenges of MPC instance </span>j<span class="math"> of the challenge vector </span>\\tau<span class="math"> and </span>\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P = i_j<span class="math"> denotes the choice of party which is not opened in the j-th MPC protocol. Furthermore, define </span>S_{1},\\dots,S_{M}<span class="math"> where </span>S_{j}$ is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\left(\\epsilon_ {1} ^ {(j)}, \\ldots , \\epsilon_ {n _ {m u l}} ^ {(j)}, i _ {j}\\right) \\in \\mathbb {F} ^ {n _ {m u l}} \\times [ N ] \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\exists \\tau \\in S \\wedge \\\\ \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {j} = \\left(\\epsilon_ {1} ^ {(j)}, \\ldots , \\epsilon_ {n _ {m u l}} ^ {(j)}, i _ {j}\\right) \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We start out with the fact that <span class="math">\\delta(x) &amp;gt; \\xi_{\\mathrm{sac}}(M, N)</span> and so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\delta(x) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}} \\cdot N)^M &gt; \\xi_{\\mathrm{sac}}(M, N) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}} \\cdot N)^M<span class="math">, which follows from the definition of </span>S<span class="math">. Now, assume that </span>\\forall j \\in [M] :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\xi(N) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}} \\cdot N)<span class="math">. Since </span>S = \\{\\tau \\mid \\forall j \\in [M] : \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j \\in S_j\\}<span class="math"> it must hold that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> because every </span>\\tau<span class="math"> must be a combination of different </span>\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j$. But that implies</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\xi_ {\\mathrm {s a c}} (N) ^ {M} \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {n _ {m u l}} \\cdot N) ^ {M} = \\xi_ {\\mathrm {s a c}} (M, N) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {n _ {m u l}} \\cdot N) ^ {M}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in contradiction to our assumption on the upper-bound of each $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore, there must exist a </span>j \\in [M]<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\xi_{\\mathrm{sac}}(N) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{n_{mul}} \\cdot N)$. From Lemma 4 it thus follows that this MPC instance must have the correct witness committed:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">Corollary 1. If <span class="math">\\delta(x) &amp;gt; \\xi_{\\mathrm{sac}}(M, N)</span>, then the prover <span class="math">\\mathcal{P}^*</span> must have committed to the correct witness <span class="math">\\mathbf{w}</span> in Round 1 in at least one of the MPC instances.</p>

    <p class="text-gray-300">Observe that once a correct witness is committed to in the first round in one of the MPC instances, then two accepting transcripts where the second challenge is different for such an instance are sufficient to extract it. We therefore can define an extractor <span class="math">\\mathcal{E}</span> (similar to the one in the proof of the previous protocol) which works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose random vectors <span class="math">\\tau \\in \\mathbb{F}^{n_{\\mathrm{mal}} \\cdot M} \\times [N]^M</span> until <span class="math">\\tau \\in S</span> was found.</li>

      <li>For each <span class="math">j \\in [M]</span> run the following in parallel:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Choose random vectors <span class="math">\\tau&#x27; \\in \\mathbb{F}^{n_{\\mathrm{mal}} \\cdot M} \\times [N]^M</span> such that $\\tau'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P \\neq \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P<span class="math"> until </span>\\tau' \\in S$ was found.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now prove that the expected running time of our extractor satisfies the security definition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 5. Let <span class="math">\\delta(x) = \\xi_{\\mathrm{sac}}(M, N) + \\varepsilon</span>. Then, the expected running time of extractor <span class="math">\\mathcal{E}</span> is $O(M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\varepsilon)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. The proof is very similar to the one of the previous protocol. We will find the first <span class="math">\\tau \\in S</span> in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\varepsilon)<span class="math"> by definition. Thus, let us argue that the overall expected runtime until we find a correct witness </span>\\mathbf{w}<span class="math"> is </span>M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\varepsilon$ as in the previous proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Corollary 1 there must be at least one MPC instance with a correct witness committed. Let <span class="math">k \\geq 1</span> be the overall number of these correct committed witnesses, and without loss of generality they are in MPC instances <span class="math">1, \\ldots, k</span>. As argued above, we can extract if we find <span class="math">\\tau&#x27;</span> such that $\\tau'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P \\neq \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P<span class="math"> for </span>j \\in [k]<span class="math">. For the sake of contradiction, assume that </span>\\operatorname*{Pr}\\left[\\mathsf{acc} \\mid \\tau'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P \\neq \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P\\right] &lt; \\varepsilon / M<span class="math"> for all </span>j \\in [k]$. We can rewrite the success probability as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta (x) = \\Pr [ \\mathbf {a c c} ] = \\Pr [ \\mathbf {a c c} \\wedge \\tau^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {1} ^ {P} = \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {1} ^ {P} \\wedge \\dots \\wedge \\tau^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {k} ^ {P} = \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {k} ^ {P} ] + \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\Pr \\left[ \\mathbf {a c c} \\wedge \\tau^ {\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {1} ^ {P} = \\tau</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {1} ^ {P} \\wedge \\dots \\wedge \\tau^ {\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {k} ^ {P} = \\tau</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {k} ^ {P} \\right] + \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\quad \\sum_ {j = 1} ^ {k} \\Pr \\left[ \\mathbf {a c c} \\wedge \\tau^ {\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {j} ^ {P} \\neq \\tau</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {j} ^ {P} \\right] \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">&lt; \\Pr \\left[ \\mathbf {a c c} \\wedge \\tau^ {\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {1} ^ {P} = \\tau</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {1} ^ {P} \\wedge \\dots \\wedge \\tau^ {\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {k} ^ {P} = \\tau</td>

            <td class="px-3 py-2 border-b border-gray-700">_ {k} ^ {P} \\right] + \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad M \\cdot (\\varepsilon / M) \\tag {6} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Pr \\left[ \\mathbf {a c c} \\mid \\tau^ {\\prime} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {1} ^ {P} = \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {1} ^ {P} \\wedge \\dots \\wedge \\tau^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {k} ^ {P} = \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {k} ^ {P} ] \\cdot \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\left(\\frac {(N +</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb {F}</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1)}{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb {F}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot N}\\right) ^ {M - k} \\cdot \\frac {1}{N ^ {k}} + \\varepsilon \\tag {7} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\frac {(N +</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb {F}</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1) ^ {M}}{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb {F}</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {M} \\cdot N ^ {M}} + \\varepsilon \\tag {8} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= \\xi_ {\\mathrm {s a c}} (N, M) + \\varepsilon = \\delta (x). \\\\ \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here Eq. (6) uses the assumed upper-bound on all $\\operatorname*{Pr}[\\mathsf{acc} \\mid \\tau'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P \\neq \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P]<span class="math"> while Eq. (7) follows from the assumption that the </span>M - k<span class="math"> instances have an incorrect witness and so by Lemma 4, the acceptance probability in each of them is bounded by </span>\\xi_{\\mathrm{sac}}(N)<span class="math"> and since the probability that the second challenge in the other </span>k<span class="math"> instances remains the same is </span>\\frac{1}{N^k}<span class="math">. Finally, Eq. (8) follows since </span>\\frac{(N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)^{M - k}}{(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot N)^{M - k} \\cdot N^k} = \\frac{(N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)^{M - k}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{M - k} \\cdot N^M}<span class="math"> and so </span>\\frac{(N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)^M - k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^M - k \\cdot N^M} &lt; \\frac{(N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)^M}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^M \\cdot N^M}<span class="math"> since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k &lt; (N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)^k<span class="math">, which holds because </span>N &gt; 1<span class="math"> and </span>k &gt; 0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The resulting contradiction implies that there exists an instance <span class="math">j</span> with valid witness such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname*{Pr}\\left[\\mathsf{acc} \\mid \\tau'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P \\neq \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_j^P\\right] \\geq \\varepsilon / M<span class="math"> which means that </span>\\mathcal{E}<span class="math"> will find the correct witness in expected runtime that is bounded by </span>O(M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\varepsilon)<span class="math"> as required (recall that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in our protocol is the size of the circuit </span>C$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have proved that if the cheating probability is higher then <span class="math">\\xi_{\\sf sac}(M,N)</span> by <span class="math">\\varepsilon</span>, then the prover must have committed to the correct witness and this can be extracted from him with expected running time that is bounded by $O(M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\varepsilon)<span class="math">. Note that </span>M<span class="math"> is independent from the common input and depends only on the statistical security parameter, and thus given a security parameter </span>M$ can be viewed as a constant. This concludes the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Computation and Communication Cost.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By inspecting both <span class="math">\\Pi_{\\sf sac}</span> and <span class="math">\\Pi_{\\sf c\\&amp;c}</span> one sees that for each multiplication gate <span class="math">O(M\\cdot N)</span> multiplications in <span class="math">\\mathbb{F}</span> must be computed. In practice, their runtime dominates those of the additions in <span class="math">\\mathbb{F}</span> which can be optimized by carrying out multiple <span class="math">\\mathbb{F}</span>-additions over the integers before applying a modular reduction. For large enough <span class="math">\\mathbb{F}</span> we have that <span class="math">\\xi_{\\sf sac}(M,N)\\approx(1/N)^{M}</span>, and so for statistical security parameter <span class="math">\\kappa</span> we have <span class="math">M\\cdot\\log N=\\kappa</span> which means that we will approximately have to perform $O(\\kappa\\cdot(N/\\log N)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> multiplications both at proving and verification time, but only over the field over which </span>C$ is actually defined.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we estimate both the practical and asymptotic communication cost of the <span class="math">\\Pi_{\\sf sac}</span> protocol. Again, denote by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf hash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf sd</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf com</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the length in bits of the hash values, seeds and commitments. The communication cost of messages sent from </span>\\mathcal{P}<span class="math"> to </span>\\mathcal{V}$ in each round is:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Round 1: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf hash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Round 5: $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sf sd</td>

            <td class="px-3 py-2 border-b border-gray-700">+M\\cdot(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sf sd</td>

            <td class="px-3 py-2 border-b border-gray-700">+\\log N\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sf sd</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sf com</td>

            <td class="px-3 py-2 border-b border-gray-700">+4\\log_{2}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">)\\cdot n_{mul}+3\\log_{2}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">)\\cdot n_{sq}+\\log_{2}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">)+\\log_{2}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">)\\cdot n_{\\sf in}+\\log_{2}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\sf base(\\sf hash,\\sf sd,\\sf com,M,N)=2\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf hash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf sd</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(2+M\\log N)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf com</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot M<span class="math"> for which we only write base when the context is clear. We obtain that the overall amount of bits sent from </span>\\mathcal{P}<span class="math">’s side is </span>\\sf base+\\log_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot M(4n_{mul}+3n_{sq}+n_{\\sf in}+2)<span class="math">. Asymptotically, by setting </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf hash</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf sd</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sf com</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(\\lambda)<span class="math">, </span>\\log_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=O(\\log(\\lambda))<span class="math"> and </span>M,N<span class="math"> as above we get that the communication cost of </span>\\mathcal{P}<span class="math"> is </span>O(\\log(\\lambda)\\cdot\\kappa\\cdot(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\log(N)))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">3.4 Optimizations</h3>

    <p class="text-gray-300">The following optimizations can directly be made to our protocols:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover is required to send <span class="math">N-1</span> seeds for each execution <span class="math">e</span> that was not chosen to be opened. Each of these seeds is used to generate the randomness of one party throughout the execution. As in <em>[x10]</em>, we can reduce the number of seeds that are sent from <span class="math">N-1</span> to <span class="math">\\log N</span> by using a binary tree.</li>

      <li>Each multiplication in <span class="math">\\Pi_{\\sf sac}</span> is being verified separately. In order to save communication it is possible to batch-verify of them by opening a random linear combination of all <span class="math">\\llbracket e\\rrbracket</span>-sharings.</li>

      <li>We can reduce communication by verifying the correctness of the circuit’s output in a batched manner, i.e., take a random linear combination of all outputs, where the randomness is chosen (as an additional challenge) by <span class="math">\\mathcal{V}</span>. Then, only the shares of this linear combination result are sent to <span class="math">\\mathcal{V}</span>.</li>

    </ol>

    <p class="text-gray-300">We now discuss each of these in more detail.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Reducing the number of seeds sent by the prover.</h4>

    <p class="text-gray-300">In both of our protocols, the prover is required to send <span class="math">N-1</span> seeds for each execution <span class="math">e</span> that was not chosen to be opened. Each of these seeds is used to generate the randomness of one party throughout the execution. As in <em>[x10]</em>, we can reduce the number of seeds that are sent from <span class="math">N-1</span> to <span class="math">\\log N</span> by using a binary tree. Specifically, let <span class="math">\\sf sd_{e}</span> be the root of a binary tree of height <span class="math">\\log N</span> where the seed in each internal node is used to generate the seeds of it’s two descendants. The value of the <span class="math">i</span>th leaf is labeled as <span class="math">\\sf sd_{e,i}</span> and used to generate the randomness of party <span class="math">P_{i}</span>.</p>

    <p class="text-gray-300">Now, when the verifier chooses a random <span class="math">\\tilde{i}_{e}\\in[N]</span> as its challenge, instead of sending him <span class="math">\\sf sd_{e,i}</span> for each <span class="math">i\\in[N]\\setminus\\{\\tilde{i}_{e}\\}</span>, it suffices to send just <span class="math">\\log N</span> seeds. Specifically, <span class="math">\\mathcal{P}</span> can iterate over the tree beginning with the root, and for each node <span class="math">j</span>, where <span class="math">\\sf sd_{e,\\tilde{i}_{e}}</span> is not in the induced sub-tree rooted at <span class="math">j</span>, send the seed of <span class="math">j</span> to the verifier. Once a seed has been chosen to be sent, <span class="math">\\mathcal{P}</span> does not proceed to traverse in the sub-tree rooted</p>

    <p class="text-gray-300">in <span class="math">j</span> but will descend into the other direction. Overall, in the first protocol, the communication induced by sending the seeds in <span class="math">M - \\tau</span> emulations is then reduced from <span class="math">(M - \\tau) \\cdot (N - 1)</span> seeds to <span class="math">(M - \\tau) \\log N</span>, whereas in the second protocol it is reduced from <span class="math">M \\cdot (N - 1)</span> seeds to <span class="math">M \\log N</span>, which can be significant when the number of parties is large.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Batch verification in <span class="math">\\Pi_{\\mathrm{sac}}</span>.</strong> In <span class="math">\\Pi_{\\mathrm{sac}}</span> each multiplication is being verified separately. In order to save communication it is possible to batch-verify all multiplications by taking a linear combination of all <span class="math">\\llbracket v\\rrbracket</span>s and open only the result. Specifically, given a batch of products <span class="math">(\\llbracket x_1\\rrbracket, \\llbracket y_1\\rrbracket, \\llbracket z_1\\rrbracket), \\ldots, (\\llbracket x_m\\rrbracket, \\llbracket y_m\\rrbracket, \\llbracket z_m\\rrbracket)</span> to verify using a batch of random triples <span class="math">(\\llbracket a_1\\rrbracket, \\llbracket b_1\\rrbracket, \\llbracket c_1\\rrbracket), \\ldots, (\\llbracket a_m\\rrbracket, \\llbracket b_m\\rrbracket, \\llbracket c_m\\rrbracket)</span> (the same applies to squares), the parties first compute <span class="math">\\llbracket v_k\\rrbracket = \\epsilon_k \\cdot \\llbracket z_k\\rrbracket - \\llbracket c_k\\rrbracket + \\alpha_k \\cdot \\llbracket b_k\\rrbracket + \\beta \\cdot \\llbracket a_k\\rrbracket - \\alpha_k \\cdot \\beta_k</span> for each <span class="math">k \\in [m]</span> (as in Lemma 2). Then, they jointly generate public random coefficients <span class="math">\\gamma_1, \\ldots, \\gamma_m \\in \\mathbb{F}</span> and locally compute <span class="math">\\llbracket v\\rrbracket = \\sum_{i=1}^{m} \\gamma_k \\cdot \\llbracket v_k\\rrbracket</span>. Finally, the parties open <span class="math">\\llbracket v\\rrbracket</span> and check equality to 0. If <span class="math">v_k = 0</span> for all <span class="math">k \\in [m]</span> then obviously <span class="math">v = 0</span> as well. In contrast, if there exists <span class="math">k \\in [m]</span> such that <span class="math">v_k \\neq 0</span>, then <span class="math">v = 0</span> with probability $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. This is summed up in the following two propositions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proposition 1.</strong> Let <span class="math">(\\llbracket x_1\\rrbracket, \\llbracket y_1\\rrbracket, \\llbracket z_1\\rrbracket), \\ldots, (\\llbracket x_m\\rrbracket, \\llbracket y_m\\rrbracket, \\llbracket z_m\\rrbracket)</span> and <span class="math">(\\llbracket a_1\\rrbracket, \\llbracket b_1\\rrbracket, \\llbracket c_1\\rrbracket), \\ldots, (\\llbracket a_m\\rrbracket, \\llbracket b_m\\rrbracket, \\llbracket c_m\\rrbracket)</span> be two lists of <span class="math">m</span> triples. If there exists <span class="math">\\hat{k} \\in [m]</span> such that <span class="math">(\\llbracket x_{\\hat{k}}\\rrbracket, \\llbracket y_{\\hat{k}}\\rrbracket, \\llbracket z_{\\hat{k}}\\rrbracket)</span> or <span class="math">(\\llbracket a_{\\hat{k}}\\rrbracket, \\llbracket b_{\\hat{k}}\\rrbracket, \\llbracket c_{\\hat{k}}\\rrbracket)</span> is incorrect, then the parties output <span class="math">\\mathsf{acc}</span> in the batch verification protocol with probability at most $\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> If the parties output <span class="math">\\mathsf{acc}</span>, this means that <span class="math">v = \\sum_{k=1}^{m} \\gamma_k \\cdot v_k = 0</span>. From Lemma 2 it follows that <span class="math">v_{\\hat{k}} = 0</span> with probability $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and so </span>v_{\\hat{k}} \\neq 0<span class="math"> with probability </span>1 - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. In the latter case, </span>v = 0<span class="math"> iff </span>\\gamma_{\\hat{k}} = (-\\sum_{\\substack{k=1 \\\\ k \\neq \\hat{k}}}^{m} \\gamma_k \\cdot v_k) \\cdot (v_{\\hat{k}})^{-1}<span class="math"> which happens with probability </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> since </span>\\gamma_{\\hat{k}}<span class="math"> is chosen uniformly from </span>\\mathbb{F}<span class="math">. Thus, we have that the overall probability that the parties output </span>\\mathsf{acc}<span class="math"> is bounded by </span>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + (1 - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt; \\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proposition 2.</strong> Let <span class="math">(\\llbracket x_1\\rrbracket, \\llbracket z_1\\rrbracket), \\ldots, (\\llbracket x_m\\rrbracket, \\llbracket z_m\\rrbracket)</span> and <span class="math">(\\llbracket b_1\\rrbracket, \\llbracket d_1\\rrbracket), \\ldots, (\\llbracket b_m\\rrbracket, \\llbracket d_m\\rrbracket)</span> be two lists of <span class="math">m</span> squares. If there exists <span class="math">\\hat{k} \\in [m]</span> such that <span class="math">(\\llbracket x_{\\hat{k}}\\rrbracket, \\llbracket z_{\\hat{k}}\\rrbracket)</span> or <span class="math">(\\llbracket b_{\\hat{k}}\\rrbracket, \\llbracket d_{\\hat{k}}\\rrbracket)</span> is incorrect, then the parties output <span class="math">\\mathsf{acc}</span> in the batch verification protocol with probability of at most $\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> From Lemma 3 it follows that <span class="math">v_{\\hat{k}} = 0</span> with probability $\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. Thus, the statement follows from exactly by the same argument as in the proof of Proposition 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plugging in the batch verification procedure, <span class="math">\\Pi_{\\mathrm{sac}}</span> is changed so that the random coefficients for the linear combination are chosen by the verifier and handed to the prover as and additional challenge. Specifically, in Round 2, the verifier picks a random coefficient <span class="math">\\gamma_{e,k}</span> for each instance <span class="math">e</span> and each multiplication/square gate, and hands it to the prover in addition to the random elements <span class="math">\\epsilon_{e,k}</span> that are used inside the verification procedure. Then, in Round 3 the prover simulates the verification procedure for each multiplication/square gate and then simulates each party <span class="math">i</span> locally taking the linear combination <span class="math">v_{e,i} = \\sum_{k} \\gamma_{e,k} \\cdot v_{e,k,i}</span>, where <span class="math">v_{e,k,i}</span> is its share of <span class="math">v_{e,k}</span>. Finally, <span class="math">\\mathcal{P}</span> sets $\\mathsf{view}_e \\gets \\mathsf{view}_e \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{e,1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{e,N}<span class="math">. This significantly reduces the communication of the protocol, since once the verifier chooses the one party </span>\\hat{i}_e<span class="math"> whose view is not opened in execution </span>e<span class="math">, the prover does not need to send the share of party </span>\\hat{i}_e<span class="math"> for each </span>v_{k,e}<span class="math">, but rather only its share of </span>v_e<span class="math">, since only one single value is opened and checked for the entire circuit. On the other hand, observe that using this optimization also affects the soundness of the protocol, as the probability of not being caught in the verification procedure is now increased to </span>\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> for cheating in multiplication gates and </span>\\frac{3}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ for square gates (observe that once again manipulating the output of square gates would be more beneficial for the prover). Thus, if there are square gates in the circuit, the updated cheating probability is bounded by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\xi_{\\mathrm{sac}}(M, N) = \\left(\\frac{3}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\left(1 - \\frac{3}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\frac{1}{N}\\right) = \\left(\\frac{3N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 3}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot N}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">whereas if there are multiplication gates in the circuit (and no square gates), the updated cheating probability is bounded by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\xi_{\\mathsf{sac}}(M,N)=\\left(\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\left(1-\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\cdot\\frac{1}{N}\\right)=\\left(\\frac{2N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot N}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Batching the output correctness check.</h4>

    <p class="text-gray-300">Similarly to this previous optimization, we can reduce communication by verifying the correctness of the circuit’s output in a batched manner, i.e., take a random linear combination of all outputs before sending it to <span class="math">\\mathcal{V}</span>. Recall that in both <span class="math">\\Pi_{\\mathsf{c\\&amp;c}}</span>, <span class="math">\\Pi_{\\mathsf{sac}}</span>, <span class="math">\\mathcal{V}</span> checks for each output wire <span class="math">k\\in[n_{\\mathsf{out}}]</span> in each execution <span class="math">e</span>, that the shares <span class="math">\\{o_{e,k,i}\\}_{i=1}^{N}</span> add up to the output <span class="math">y_{k}</span> that should be on that wire. This is the same as checking that <span class="math">\\sum_{i=1}^{N}o_{e,k,i}-y_{k}=0</span>. Thus, we can take a random linear combination <span class="math">\\sum_{k\\in[n_{\\mathsf{out}}]}\\gamma_{e,k}\\cdot(\\sum_{i=1}^{N}o_{e,k,i}-y_{k})</span> with values <span class="math">\\gamma_{e,k}</span> chosen by <span class="math">\\mathcal{V}</span> and check that the result equals <span class="math">0</span>. This reduces communication, because now the prover is required to send the verifier only one single output share of party <span class="math">\\bar{i}_{e}</span> instead of a share per each output wire (recall that for the other parties their entire view is revealed and thus the share on the output wires can be computed by the verifier).</p>

    <p class="text-gray-300">In order to plug this idea into <span class="math">\\Pi_{\\mathsf{c\\&amp;c}}</span> while maintaining security, we need to add another round where, after the view during the circuit computation is committed, the verifier chooses randomly the random coefficients <span class="math">\\gamma_{e,k}</span> for each execution <span class="math">e</span> and output wire <span class="math">k</span> and hands them to the prover who then computes for each party <span class="math">i</span> the random linear combination of its shares. Specifically, for each party <span class="math">i</span> with shares <span class="math">\\{o_{e,k,i}\\}_{k\\in[n_{\\mathsf{out}}]}</span>, it computes <span class="math">o_{e,i}=\\sum_{k\\in[n_{\\mathsf{out}}]}\\gamma_{e,k}\\cdot o_{e,k,i}</span>, and then commits to <span class="math">o_{e,1}\\parallel\\cdots\\parallel o_{e,N}</span> and sends the commitment to the verifier. Only then, the verifier chooses the party <span class="math">\\bar{i}_{e}</span>, whose view is kept secret and hands it to the prover. Then, in the final round, the prover sends all the data specified in the protocol’s description with the exception being that instead of sending <span class="math">\\{o_{e,k,\\bar{i}_{e}}\\}_{k\\in[n_{\\mathsf{out}}]}</span> for each execution <span class="math">e</span>, it suffices to send <span class="math">o_{e,\\bar{i}_{e}}</span> only. The verifier then computes <span class="math">o_{e,i}</span> for each <span class="math">i\\in[N]\\setminus\\{\\bar{i}_{e}\\}</span>, and using <span class="math">o_{e,\\bar{i}_{e}}</span> checks that <span class="math">\\sum_{i=1}^{N}o_{e,i}-\\sum_{k\\in[n_{\\mathsf{out}}]}\\gamma_{e,k}\\cdot y_{k}=0</span> for each execution <span class="math">e</span>.</p>

    <p class="text-gray-300">For <span class="math">\\Pi_{\\mathsf{sac}}</span> no additional rounds are required. After the prover <span class="math">\\mathcal{P}</span> has committed in the first round to the shares of the parties on all the wires of the circuit, <span class="math">\\mathcal{V}</span> can send the random coefficients along with the challenges it sends for the verification procedure. The prover <span class="math">\\mathcal{P}</span> then computes the linear combination of the output shares and commits to the obtained shares as explained above.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in the previous optimization, we need to update the soundness of the two protocols, since taking a random linear combination can result in having <span class="math">0</span>, even though the sharing on the output wires were not correct (this happens with probability $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> as in the previous optimization). In </span>\\Pi_{\\mathsf{c\\&c}}<span class="math"> we denote by </span>c_{1}<span class="math"> the number of pre-processings corrupted by the prover and by </span>c_{2}$ the number of emulations where the prover cheats in computing the view of one of the parties. In the remaining executions, the prover do not cheat (but only uses an invalid witness), hoping that the output verification will succeed due to the random linear combination. Then, we have that the cheating probability is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ \\xi_{\\mathsf{c\\&c}}(M,N,\\tau)=\\max_{\\begin{subarray}{c}0\\leq c_{1}\\leq M-\\tau\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\leq c_{2}\\leq M-\\tau-c_{1}\\end{subarray}}\\left\\{\\frac{\\binom{M-c_{1}}{\\tau}}{\\binom{M}{\\tau}\\cdot N^{c_{2}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{M-\\tau-c_{1}-c_{2}}}\\right\\}. \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We remark that in all our instantiations, it always hold that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg N<span class="math"> and thus the best strategy for a cheating prover is to set </span>c_{2}=M-\\tau-c_{1}$, which means that the cheating probability remains the same as before.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">\\Pi_{\\mathsf{sac}}</span>, we argue that the cheating probability <span class="math">\\xi_{\\mathsf{sac}}</span> remains the same. This holds since the current optimization is independent of the verification of multiplications/squares process, meaning that both generate different outputs which the verifier checks in the last round. In particular, when the prover cheats in one of the multiplications/squares, it can get away with it only by receiving the “correct” challenge for the verification process or by changing one view, exactly as before. Thus, for each instance, the prover can either manipulate the output of multiplication/square gates or act honestly with an invalid witness and hope that taking the random linear combination of the incorrect outputs will equal to the random linear combination of the publicly known outputs. Therefore, the cheating probability for each instance is bounded</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\max\\left\\{\\frac{2N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\cdot}N},\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\}<span class="math"> (in the case where the circuit consists of multiplication gates and no square gates; the analysis is similar for the other case). However, observe that </span>\\frac{2N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\cdot}N}>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (since </span>N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2>0$), and thus the soundness remains the same as before.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-39" class="text-2xl font-bold">4 Sampling Circuits on the Fly</h2>

    <p class="text-gray-300">At the end of the previous section we briefly mentioned an optimization where <span class="math">\\mathcal{V}</span> checks output correctness by looking only at a linear combination of the outputs instead of checking each output separately. In particular, this is done by having <span class="math">\\mathcal{V}</span> choosing random coefficients which will be used to compute the linear combination <em>after</em> <span class="math">\\mathcal{P}</span> fixes the inputs and (correlated) randomness of the simulated parties. This process can also be viewed as an interaction where the parties determine the final circuit’s structure during the execution, as here the challenge chosen by <span class="math">\\mathcal{V}</span> adds a layer on top of the initial circuit which consists of ‘multiplication-by-a-constant’ and addition gates. This idea, which we call “sampling the circuit on the fly” will be also used in some of the optimizations suggested for the application presented in Section 5. We therefore now formally establish this idea, so that security of optimizations of this kind can be derived easily without the need to re-prove security of the whole ZKAoK each time.</p>

    <p class="text-gray-300">Although in the above example only <span class="math">\\mathcal{V}</span> chooses the circuit that will be evaluated, we consider a broader definition where both <span class="math">\\mathcal{P},\\mathcal{V}</span> sample the circuit together. The sampling process must begin only after <span class="math">\\mathcal{P}</span> has committed and fixed the witness and randomness that will be used. This means that from this point on any form of cheating is possible only during the simulation of the MPC protocol to compute the sampled circuit, as the witness cannot be tailored anymore to the actually chosen circuit. We remark that although the circuit will be jointly sampled by both parties, we restrict the sampling done by <span class="math">\\mathcal{V}</span> to be independent of the messages of <span class="math">\\mathcal{P}</span> and to not require him to keep a secret state so that the overall protocol stays public-coin. <span class="math">\\mathcal{P}</span>, in contrast, will be allowed to make his choice depending on the witness that it committed or on other messages. At the same time, the choice of <span class="math">\\mathcal{P}</span> should neither allow him to break the soundness nor the zero-knowledge property.</p>

    <p class="text-gray-300">In this section, we first provide a formal definition for the notion of circuit sampling. Then, we show how to incorporate it into our argument system and finally explain (as an example) how the output linear combination optimization described above is an instantiation of the general notion and how it fits into the framework. We want to mention that, independently, Badetscher et al. <em>[x1]</em> introduced a similar concept but in an unrelated context.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">4.1 Definition of Circuit Sampling</h3>

    <p class="text-gray-300">First, we define the notion of circuit sampling for an NP relation.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 3 (<span class="math">R</span>-circuit Sampler).</h6>

    <p class="text-gray-300">Let <span class="math">R</span> be an NP relation and <span class="math">S_{\\mathcal{P}},S_{\\mathcal{V}}</span> be two non-empty sets that can be described with a string of polynomial length (in the security parameter <span class="math">\\lambda</span>). We say that <span class="math">\\mathsf{Sample}=(\\mathsf{ExtWitness},\\mathsf{Response},\\mathsf{SampCircuit})</span> is an <span class="math">R</span>-circuit sampler for <span class="math">(x,w)\\in R</span> if</p>

    <p class="text-gray-300">LetWitness is a PPT algorithm which on input <span class="math">(x,w)</span> outputs an extended witness <span class="math">\\widehat{w}</span>.</p>

    <p class="text-gray-300">Response is a PPT algorithm which on input <span class="math">(x,w,\\widehat{w},\\tau_{\\mathcal{V}})</span> outputs <span class="math">\\tau_{\\mathcal{P}}</span>.</p>

    <p class="text-gray-300">SampCircuit is a deterministic polynomial-time algorithm which on input <span class="math">(x,\\tau_{\\mathcal{V}},\\tau_{\\mathcal{P}})</span> outputs a circuit <span class="math">C</span> as well as a description of a set <span class="math">Y</span>.</p>

    <p class="text-gray-300">Furthermore, we require that membership in <span class="math">Y</span> can be decided in polynomial time. We next define a security game which follows the way we embed these algorithms into our protocols. Consider the following game, which we denote by <span class="math">\\mathsf{Game}_{R,\\mathcal{P}}\\left((x,w),S_{\\mathcal{P}},S_{\\mathcal{V}},\\lambda\\right)</span>, executed with <span class="math">\\mathcal{P}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> outputs <span class="math">\\widehat{w}</span>.</li>

      <li>Choose a random <span class="math">\\tau_{\\mathcal{V}}\\leftarrow S_{\\mathcal{V}}</span> and hand it to <span class="math">\\mathcal{P}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span> outputs <span class="math">\\tau_{\\mathcal{P}}\\in S_{\\mathcal{P}}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(C,Y)\\leftarrow\\mathsf{SampCircuit}(x,\\tau_{\\mathcal{P}},\\tau_{\\mathcal{V}})</span>.</li>

      <li>Output 1 iff <span class="math">C(\\widehat{w})\\in Y</span>.</li>

    </ol>

    <p class="text-gray-300">To understand the game, observe that Step 1 emulates the commitment to the witness, made by <span class="math">\\mathcal{P}</span> in the first step of our protocols, in Step 2 a challenge is chosen which is followed by the configuration chosen by <span class="math">\\mathcal{P}</span> in Step 3. Once all the input for <span class="math">\\mathsf{SampCircuit}</span> is gathered, <span class="math">(C,Y)</span> are being determined, and <span class="math">\\mathcal{P}</span> wins if computing the circuit <span class="math">C</span> on <span class="math">\\widehat{w}</span> yields a valid output. In the above definition there is no validation ensuring that <span class="math">\\tau_{\\mathcal{P}}</span> used in the game is valid. This can be done by <span class="math">\\mathsf{SampCircuit}</span> outputting <span class="math">Y=\\emptyset</span> for an <em>invalid</em> <span class="math">\\tau_{\\mathcal{P}}</span>.</p>

    <p class="text-gray-300">We have three requirements from the circuit sampler. First, an obvious requirement is that if <span class="math">\\mathcal{P}</span> uses the correct <span class="math">w</span> and chooses <span class="math">\\tau_{\\mathcal{P}}</span> honestly, then the output of the game should be 1 (except for a negligible probability).</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 4 (Correct <span class="math">R</span>-circuit Sampler)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Sample}</span> be an <span class="math">R</span>-circuit sampler. If when <span class="math">\\mathcal{P}</span> on input <span class="math">(x,w)\\in R</span> computes <span class="math">\\widehat{w}\\leftarrow\\mathsf{ExtWitness}(x,w)</span> and <span class="math">\\tau_{\\mathcal{P}}\\leftarrow\\mathsf{Response}(x,w,\\widehat{w},\\tau_{\\mathcal{V}})</span>, with probability negligibly close to 1 it holds that <span class="math">\\mathsf{Game}_{R,\\mathcal{P}}\\left((x,w),S_{\\mathcal{P}},S_{\\mathcal{V}},\\lambda\\right)=1</span> then we say that <span class="math">\\mathsf{Sample}</span> is correct.</p>

    <p class="text-gray-300">We furthermore require soundness. Similarly to the standard definition of it, here if <span class="math">\\mathcal{P}</span> wins in the above game with probability <span class="math">&gt;\\alpha</span>, then a correct witness for <span class="math">R</span> can be extracted.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 5 (<span class="math">\\alpha</span>-sound <span class="math">R</span>-circuit Sampler)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Sample}</span> be an <span class="math">R</span>-circuit sampler. If given <span class="math">\\Pr[\\mathsf{Game}_{R,\\mathcal{P}}\\left((x,w),S_{\\mathcal{P}},S_{\\mathcal{V}},\\lambda\\right)=1]&gt;\\alpha</span> (where the distribution is over <span class="math">\\tau_{\\mathcal{V}}\\in S_{\\mathcal{V}}</span>), there exists a deterministic polynomial-time extractor <span class="math">\\mathcal{E}(\\widehat{w})</span> which outputs <span class="math">(x,w^{\\prime})\\in R</span> then we say that <span class="math">\\mathsf{Sample}</span> is <span class="math">\\alpha</span>-sound.</p>

    <p class="text-gray-300">The definition may look similar to knowledge soundness as defined in Section 2.2, but there are crucial differences: <span class="math">\\mathcal{E}</span> runs on <span class="math">\\widehat{w}</span> in polynomial time and with probability 1. This is because extracting some <span class="math">w^{\\prime}</span> from <span class="math">\\widehat{w}</span> is an “easy” task (as we will see in all our circuit sampling uses) and so the only question is whether <span class="math">w^{\\prime}</span> is valid for <span class="math">R</span> or not. The definition thus says that if <span class="math">\\mathcal{P}</span> wins with probability higher than <span class="math">\\alpha</span>, then it must have used the correct witness <span class="math">w</span> to compute <span class="math">\\widehat{w}</span> which can be obtained.</p>

    <p class="text-gray-300">Finally, we also need to ensure that the additional interaction does not leak any information about <span class="math">w</span>. This is formalized in the standard way of requiring the existence of a simulator who can output an indistinguishable transcript without knowing <span class="math">w</span>. Clearly, the message <span class="math">\\tau_{\\mathcal{P}}</span> should not reveal any information about <span class="math">\\widehat{w}</span> to an outsider. However, we additionally need simulatability of <span class="math">C(\\widehat{w})</span>: the sampled circuit may enforce the relation <span class="math">R</span> in different ways than a static circuit would do, which could potentially leak information.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Definition 6 (Simulatable <span class="math">R</span>-circuit Sampler)</h6>

    <p class="text-gray-300">Let <span class="math">(x,w)\\in R</span> and <span class="math">\\mathsf{Sample}</span> be an <span class="math">R</span>-circuit sampler. Then we say that <span class="math">\\mathsf{Sample}</span> is simulatable if there exists a PPT algorithm <span class="math">\\mathcal{S}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\{(\\tau_{\\mathcal{P}},C(\\widehat{w}))\\leftarrow\\mathcal{P}(x,w,\\tau_{\\mathcal{V}})\\}\\approx_{s}\\{(\\tau_{\\mathcal{P}},C(\\widehat{w}))\\leftarrow\\mathcal{S}(x,\\tau_{\\mathcal{V}})\\}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathcal{P}</span> acts honestly as in Definition 4.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">4.2 Circuit Sampling and our ZKAoK</h3>

    <p class="text-gray-300">We now include the above approach into our second protocol <span class="math">\\Pi_{\\mathsf{sac}}</span>. The modified protocol <span class="math">\\Pi_{\\mathsf{sac}}^{\\mathrm{samp}}</span> works as follows, where we highlight the additional steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">e\\in[M]</span> (i.e. each MPC instance), <span class="math">\\mathcal{P}</span> computes <span class="math">\\widehat{w}_{e}\\leftarrow\\mathsf{ExtWitness}(x,w)</span>. Then, it chooses the randomness used for the execution <span class="math">e</span> (i.e., the seeds used to derive all randomness as well as the salt). Finally, <span class="math">\\mathcal{P}</span> commits to the extended witness and the randomness and sends it to <span class="math">\\mathcal{V}</span>.</li>

      <li>For each <span class="math">e\\in[M]</span>, <span class="math">\\mathcal{V}</span> samples <span class="math">\\tau_{\\mathcal{V},e}</span> as in Step 2 of the above game. It then sends <span class="math">\\tau_{\\mathcal{V},1},\\ldots,\\tau_{\\mathcal{V},M}</span> to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> locally computes <span class="math">\\tau_{\\mathcal{P},e}\\leftarrow\\mathsf{Response}(x,w,\\widehat{w}_{e},\\tau_{\\mathcal{V},e})</span> for each <span class="math">e\\in[M]</span> as well as <span class="math">(C_{e},Y_{e})\\leftarrow\\mathsf{SampCircuit}(x,\\tau_{\\mathcal{P},e},\\tau_{\\mathcal{V},e})</span>. It uses <span class="math">C_{e}</span> in MPC protocol instance <span class="math">e</span> and sends the remaining first round messages together with <span class="math">\\tau_{\\mathcal{P},e}</span> to <span class="math">\\mathcal{V}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{W}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{W}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{W}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span> function.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}</span> is a <span class="math">C_{e}(\\mathbf{w}_{e})</span></p>

    <p class="text-gray-300">found. Then, <span class="math">\\mathcal{E}</span> runs <span class="math">M</span> processes in parallel where process <span class="math">j</span> runs until a second accepting transcript has been found where the second challenge in execution <span class="math">j</span> is different from the challenge in the first accepting transcript. Holding two accepting transcripts where the second challenge is different is sufficient for extracting the committed witness (as <span class="math">\\mathcal{E}</span> has now the input shares of all parties), and so if the correct witness was found by one of the processes, then <span class="math">\\mathcal{E}</span> halts (recall that once a correct extended witness <span class="math">\\widehat{w}</span> is found then by the soundness of the sampler, <span class="math">\\mathbf{w}</span> is computed in polynomial time).</p>

    <p class="text-gray-300">Assume that <span class="math">\\delta(x)=\\Pr[\\mathsf{acc}]=(\\alpha+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N))^{M}+\\varepsilon</span> for some <span class="math">\\varepsilon&gt;0</span>. Then, the first step requires <span class="math">1/\\delta(x)&lt;1/\\varepsilon</span> expected number of steps. For the second step, we show that there exists an execution <span class="math">j\\in[M]</span> with the correct witness for which each attempt in the second step of <span class="math">\\mathcal{E}</span> succeeds with probability <span class="math">&gt;\\varepsilon/M</span>, implying that the correct witness will be found in the second step within expected <span class="math">M/\\varepsilon</span> number of steps.</p>

    <p class="text-gray-300">Assume without loss of generality that the first <span class="math">k</span> executions are the executions with the correct witness and assume in contradiction that the probability of finding the desired second accepting transcript in each of them is <span class="math">\\leq\\varepsilon/M</span>. Then, using exactly the same argument as in Lemma 5 (see Eq. 6 and 7) we have</p>

    <p class="text-gray-300"><span class="math">\\delta(x)=\\Pr\\left[\\mathsf{acc}\\right]\\leq(\\alpha+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N))^{M-k}\\cdot\\frac{1}{N^{k}}+\\varepsilon.</span></p>

    <p class="text-gray-300">To complete the proof, we therefore need to show that</p>

    <p class="text-gray-300"><span class="math">\\left(\\alpha+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N)\\right)^{M-k}\\cdot\\frac{1}{N^{k}}&lt;\\left(\\alpha+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N)\\right)^{M}.</span></p>

    <p class="text-gray-300">This is equivalent to showing that</p>

    <p class="text-gray-300"><span class="math">1&lt;\\left(\\alpha+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N)\\right)^{k}\\cdot N^{k}</span></p>

    <p class="text-gray-300">which holds if</p>

    <p class="text-gray-300"><span class="math">1&lt;\\left(\\alpha+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N)\\right)\\cdot N=\\alpha\\cdot N+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N)\\cdot N.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that $\\xi_{\\mathsf{sac}}(N)=\\frac{N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{N\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, and so we need to show that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$1<\\alpha\\cdot N+(1-\\alpha)\\cdot\\frac{N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that $1<\\frac{N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<N<span class="math"> (where the latter follows since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>1<span class="math"> and </span>N>1$). Thus, it follows that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$1<\\frac{N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\alpha\\cdot\\frac{N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+(1-\\alpha)\\cdot\\frac{N+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ (9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which is exactly what we wanted to show.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We conclude that <span class="math">\\delta(x)=\\Pr\\left[\\mathsf{acc}\\right]&lt;\\left(\\alpha+(1-\\alpha)\\cdot\\xi_{\\mathsf{sac}}(N)\\right)^{M}+\\varepsilon</span> in contradiction to our assumption. This means that our extractor can find the correct witness within expected number of $O(M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\epsilon)$ steps, exactly as in the proof of Theorem 3. This concludes the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Impact on the Argument Size and Runtime.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As one can see from the above description, adding Circuit Sampling to the protocol <span class="math">\\Pi_{\\mathsf{sac}}</span> adds another two rounds of communication. In terms of argument size, we essentially split Round 1 into two different parts and make two commitments instead of one which commit to preprocessed data and evaluation, but now separately. The extra cost is to send two extra commitments (thus base increases by $2\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$), which is negligible in comparison to the rest of the argument.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, it is possible to cut away the extra two rounds of communication by running the simulation <span class="math">C</span> in Round 3 only, at the expense of introducing more communication. This can be done by switching from the verification-based approach of <span class="math">\\Pi_{\\mathsf{sac}}</span> to the standard forward circuit evaluation of <span class="math">\\pi</span> where we check the triples/squares while we use them, which is possible because now evaluation is fully deterministic. This allows to perform evaluation and checking in one round in parallel. We leave a detailed analysis as future work.</p>

    <p class="text-gray-300">We now revisit the idea of output compression in the context of circuit sampling. Here  <span class="math">\\mathcal{V}</span>  chooses random coefficients that are used to compute the linear combination of the outputs, so that only one value is eventually opened by the resulting circuit instead of  <span class="math">n_{\\mathrm{out}}</span> .</p>

    <p class="text-gray-300">We first define the three algorithms of the circuit sampler for this optimization: ExtWitness receives  <span class="math">((C,\\mathbf{y}),\\mathbf{w})</span>  as an input and returns the extended witness  <span class="math">\\widehat{w}</span> , which in this case is just  <span class="math">\\mathbf{w}</span> . Response receives as an input the tuple  <span class="math">((C,\\mathbf{y}),\\mathbf{w},\\widehat{w},\\tau_{\\mathcal{V}})</span> , but note that in this optimization, the verifier's challenge  <span class="math">\\tau_{\\mathcal{V}}</span>  fully defines the circuit and thus the output of Response is just 1. Finally, SampCircuit receives  <span class="math">((C,\\mathbf{y}),\\tau_{\\mathcal{V}},\\tau_{\\mathcal{P}})</span>  as its input and returns the circuit  <span class="math">C&#x27;</span>  and the set  <span class="math">Y</span>  defined in the following way: The circuit  <span class="math">C&#x27;</span>  consists of the original circuit  <span class="math">C</span>  and the following layers which are added on top of it: (i) subtraction gates for subtracting each value on an output wire  <span class="math">\\mathbf{y}&#x27;[k]</span>  by the expected public value  <span class="math">\\mathbf{y}[k]</span> ; (ii) 'multiplication-by-a-constant' gates for each result of the previous layer, where the constants are defined by  <span class="math">\\tau_{\\mathcal{V}}</span> ; and (iii) addition gates for summing the results of the previous layer. The set  <span class="math">Y</span>  consists of one value only. We summarize the construction in Fig. 3.</p>

    <p class="text-gray-300">Let  <span class="math">C = (n_{\\mathrm{in}}, n_{\\mathrm{out}}, n_C, L, R, F)</span>  be a circuit over  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">ExtWitness: On input  <span class="math">(x = (C, \\mathbf{y}), \\mathbf{w})) \\in R</span>  set  <span class="math">\\widehat{w} \\coloneqq \\mathbf{w}</span> .</p>

    <p class="text-gray-300">SampCircuit: On input  <span class="math">\\tau_{\\mathcal{V}} = (\\gamma) \\in \\mathbb{F}^{n_{\\mathrm{out}}}</span>  output the circuit  <span class="math">C&#x27;</span>  doing the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\mathbf{y}&#x27; = C(\\widehat{w})</span>  where  <span class="math">\\mathbf{y}&#x27; \\in \\mathbb{F}^{n_{\\mathrm{out}}}</span>  and  <span class="math">y_1 = \\sum_{i=1}^{n_{\\mathrm{out}}} \\gamma[i] \\cdot (\\mathbf{y}&#x27;[i] - \\mathbf{y}[i])</span> .</li>

      <li>Output  <span class="math">y_{1}</span></li>

    </ol>

    <p class="text-gray-300">Furthermore output the set  <span class="math">Y = \\{(0)\\}</span> .</p>

    <p class="text-gray-300">Response: Output 1.</p>

    <p class="text-gray-300">Fig. 3: Batching the Output Check as a Circuit Sampler.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The three algorithms defined above satisfy the properties of the Circuit Sampler. Correctness is straightforward. Soundness of the sampler is  $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , since if  </span>w<span class="math">  is incorrect, then  </span>C(w) \\in Y<span class="math">  with probability  </span>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  because the random coefficients are uniform (see Lemma 2). Simulation follows since both  </span>\\tau_{\\mathcal{P}}<span class="math">  and  </span>Y$  are fixed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocols from Section 3 are asymptotically less communication-efficient than previous argument systems such as [AHIV17,BBC+18] as can be seen in the analysis. However, they have advantages when the circuit size is not too big or when there are many linear gates in the circuit, because the communication is dominated by the number of non-linear operations in the circuit  <span class="math">C</span>  and has very small circuit-independent cost. In this section, we exploit this fact to implement communication-efficient arguments of knowledge for different versions of the so-called Short-Integer Solution (SIS) problem.</p>

    <p class="text-gray-300">The section is organized as follows. We begin by presenting an interactive argument for binary secrets which does not allow any slack, which is the same as in [BD10]. The approach can be simply generalized to secrets from a larger interval, but only at the expense of vastly increasing the communication. Then, we introduce some optimizations that allow us to reduce the communication for the suggested arguments and then further squeeze down their size by introducing a slack factor. Throughout the section, for each approach that we present, we will mention what is the resulting size of the argument, based on the analysis of  <span class="math">\\Pi_{\\mathrm{sac}}^{\\mathrm{samp}}</span>  (which is the same as that of  <span class="math">\\Pi_{\\mathrm{sac}}</span> ).</p>

    <p class="text-gray-300">We start by presenting an argument for the Binary SIS problem as introduced in Section 2.4. The reason behind that is because general range proofs are hard using a circuit over  <span class="math">\\mathbb{F} = \\mathbb{F}_q</span>  whereas they are very</p>

    <p class="text-gray-300">simple for binary values. Moreover, the protocol we design for this problem will serve as a starting point for constructions supporting secrets from larger intervals.</p>

    <p class="text-gray-300">There are two main tasks that the protocol has to achieve, which is to show that the secret  <span class="math">\\mathbf{s}</span>  is a binary vector and the correctness of the product  <span class="math">\\mathbf{t} = \\mathbf{A}\\mathbf{s}</span> . The matrix multiplication uses a publicly known matrix, and since linear operations are free in our used MPC scheme computing  <span class="math">\\mathbf{t}</span>  can be done without increasing the proof size. What remains to show is that the witness consists of bits. This test is easy to perform because  <span class="math">\\mathbf{s}[i] \\in \\{0,1\\}</span>  is equivalent to  <span class="math">\\mathbf{s}[i]^2 - \\mathbf{s}[i] = 0</span> . We can therefore let the circuit  <span class="math">C</span>  compute the square of each element of  <span class="math">\\mathbf{s}</span>  and then perform a linear test. The obtained circuit is described in Fig. 4.</p>

    <p class="text-gray-300">Witness:  <span class="math">\\mathbf{w} = (\\mathbf{s}[1],\\dots ,\\mathbf{s}[m])\\in \\mathbb{F}^m</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall i\\in [m]</span>  compute  <span class="math">r_i\\gets \\mathbf{s}[i]^2</span></li>

      <li><span class="math">\\forall j\\in [n]</span>  compute  <span class="math">y_{j}\\gets \\sum_{i\\in [m]}a_{j,i}\\mathbf{s}[i]</span></li>

      <li><span class="math">\\forall i\\in [m]</span>  compute  <span class="math">y_{i + n}\\gets r_i - \\mathbf{s}[i]</span></li>

    </ol>

    <p class="text-gray-300">Output:  <span class="math">\\tilde{\\mathbf{y}}\\gets (y_1,\\dots ,y_{m + n})</span></p>

    <p class="text-gray-300">Fig. 4: A circuit representation of  <span class="math">R_{\\mathbb{B} - \\mathbb{S}\\mathbb{I}\\mathbb{S}}^{m,n,q}</span> ; The circuit contains  <span class="math">m</span>  square gates, has  <span class="math">m</span>  inputs and  <span class="math">m + n</span>  outputs.</p>

    <p class="text-gray-300">For ease of notation we let  <span class="math">a_{i,j} \\in \\mathbb{F}</span>  be the element in the  <span class="math">i</span> th row and the  <span class="math">j</span> th column of  <span class="math">\\mathbf{A}</span> . The circuit can be evaluated using one of the protocols from Section 3, with  <span class="math">\\mathcal{V}</span>  testing that the circuit's output  <span class="math">\\tilde{\\mathbf{y}}</span>  equals  <span class="math">(\\mathbf{t}[1], \\ldots, \\mathbf{t}[n], 0, \\dots, 0)</span> . This yields a highly efficient protocol, as there are only  <span class="math">m</span>  non-linear gates in the circuit that require communication, and all of them are square gates. Using the cost analysis from Section 3.3, we conclude that the total communication by  <span class="math">\\mathcal{P}</span>  is  <span class="math">\\text{base} + \\log q \\cdot M(4m + 2)</span>  bits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is immediate to extend the construction from Fig. 4 to other input distributions. We first generalize it to secrets  <span class="math">\\mathbf{s}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq 1<span class="math"> . Again, we want to mainly use squaring instead of multiplication gates. Since  </span>\\mathbf{s}[i] \\in \\{-1,0,1\\} \\iff \\mathbf{s}[i]^3 - \\mathbf{s}[i] = 0<span class="math">  we could implement this test using one squaring and one multiplication gate. To further optimize this, observe that the polynomial  </span>X^4 - X^2<span class="math">  has the same roots as  </span>X^3 - X<span class="math">  (albeit with different multiplicity) but can be computed using two squaring gates instead (since  </span>X^4 - X^2 = (X^2)^2 - X^2<span class="math"> ). Thus, in this setting,  </span>\\mathcal{P}<span class="math"> &#x27;s total communication is  </span>\\text{base} + \\log q \\cdot M(7m + 2)$  bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More generally, if we want to prove that  <span class="math">0 \\leq \\mathbf{s}[i] &amp;lt; 2^r</span>  for some fixed  <span class="math">r \\in \\mathbb{N}</span> , the most direct way is to again prove that  <span class="math">\\mathbf{s}[i]</span>  is the root of the polynomial  <span class="math">f(X) = \\Pi_{j=0}^{2^r-1}(X - j)</span> . This will increase the argument size by a factor of  <span class="math">2^r</span>  compared with the Binary SIS argument, but for the aforementioned interval one can reduce this to  <span class="math">O(r)</span> : a number  <span class="math">\\mathbf{s}[i]</span>  is in the interval  <span class="math">[0, 2^r - 1]</span>  if and only if there exists  <span class="math">s_{i,1}, \\ldots, s_{i,r}</span>  such that  <span class="math">\\mathbf{s}[i] = \\sum_{j=0}^{r-1} s_{i,j+1} 2^j</span>  and  <span class="math">s_{i,j} \\in \\mathbb{B}</span> . This means that the interval check can be done by providing the bit decomposition  <span class="math">s_{i,1}, \\ldots, s_{i,r}</span>  of each  <span class="math">\\mathbf{s}[i]</span> , testing if these  <span class="math">s_{i,j}</span>  are indeed bits (using one square gate per test) and then reconstructing  <span class="math">\\mathbf{s}[i]</span>  on the fly. The circuit construction is summarized in Fig. 5.</p>

    <p class="text-gray-300">The witness  <span class="math">\\mathbf{w}</span>  is valid if  <span class="math">\\tilde{\\mathbf{y}}</span>  equals  <span class="math">(\\mathbf{t}[1],\\dots ,\\mathbf{t}[n],0,\\dots ,0)</span> . While the witness is now expanded by a factor  <span class="math">r</span> , we in total only have to compute  <span class="math">m\\cdot r</span>  square gates. All other operations are linear and do not influence the argument size, which in total is  <span class="math">\\mathrm{base} + \\log q\\cdot M(4m\\cdot r + 2)</span>  bits.</p>

    <p class="text-gray-300">Proving Knowledge of general SIS instances. Finally, we aim at constructing an argument of knowledge for SIS as defined in Definition 1, for which we need  <span class="math">\\mathbf{s}[i] \\in [-\\beta, \\beta]</span>  or alternatively, that  <span class="math">((\\mathbf{A}, \\mathbf{y}), \\mathbf{s}) \\in R_{\\mathrm{SIS}}^{m,n,q,\\beta}</span> . Instead of proving this exact bound, we show that  <span class="math">((\\mathbf{A}, \\mathbf{y}), \\mathbf{s}) \\in R_{\\mathrm{SIS}}^{m,n,q,2\\beta}</span>  using the circuit representation from Fig. 5. Therefore, consider the following algorithm:</p>

    <p class="text-gray-300">Witness:  <span class="math">\\mathbf{w} = (s_{1,1},\\dots ,s_{1,r},\\dots ,s_{m,1},\\dots ,s_{m,r})\\in \\mathbb{F}_q^{m\\cdot r}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall i\\in [m],j\\in [r]</span>  compute  <span class="math">r_{i,j}\\gets s_{i,j}^2</span></li>

      <li><span class="math">\\forall i\\in [m]</span>  compute  <span class="math">\\mathbf{s}[i]\\gets \\sum_{j = 0}^{r - 1}s_{i,j + 1}2^j</span></li>

      <li><span class="math">\\forall j\\in [n]</span>  compute  <span class="math">y_{j}\\gets \\sum_{i\\in [m]}a_{j,i}\\mathbf{s}[i]</span></li>

      <li><span class="math">\\forall i\\in [m],j\\in [r]</span>  compute  <span class="math">y_{i,j}\\gets r_{i,j} - s_{i,j}</span></li>

    </ol>

    <p class="text-gray-300">Output:  <span class="math">\\hat{\\mathbf{y}}\\gets (y_1,\\dots ,y_n,y_{1,1},\\dots ,y_{m,r})</span></p>

    <p class="text-gray-300">Fig. 5: An Arithmetic circuit representation of  <span class="math">R_{\\mathrm{SIS}}^{m,n,q}</span>  where each  <span class="math">\\mathbf{s}[i]</span>  is in the interval  <span class="math">[0,2^r)</span> ; The circuit contains  <span class="math">m \\cdot r</span>  square gates, has  <span class="math">m \\cdot r</span>  inputs and  <span class="math">n + m \\cdot r</span>  outputs.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>  set  <span class="math">\\hat{\\mathbf{t}} = \\mathbf{t} + \\mathbf{A}\\beta</span>  and  <span class="math">\\mathcal{P}</span>  additionally sets  <span class="math">\\hat{\\mathbf{s}} = \\mathbf{s} + \\beta</span></li>

      <li>Choose the smallest  <span class="math">r \\in \\mathbb{N}</span>  such that  <span class="math">\\beta \\leq 2^r - 1</span> .</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>  run one of our two protocols on the circuit from Fig. 5 using the interval  <span class="math">[0,2^{r + 1} - 1]</span>  and with the common output being  <span class="math">(\\hat{\\mathbf{t}} [1],\\dots ,\\hat{\\mathbf{t}} [n],0,\\dots ,0)</span> .</li>

    </ol>

    <p class="text-gray-300">Then, the above algorithm is a zero-knowledge argument of knowledge for the SIS relation with slack 2 as long as  <span class="math">2\\beta &amp;lt; \\frac{q - 1}{2}</span> . To see this, we only have to look at correctness and soundness as the zero-knowledge property follows trivially. For correctness, the chosen  <span class="math">r</span>  will always lead to  <span class="math">\\hat{\\mathbf{s}}</span>  being in the right interval since  <span class="math">2\\beta \\leq 2(2^r - 1) &amp;lt; 2^{r + 1} - 1</span> . And due to the bound on  <span class="math">\\beta</span>  and  <span class="math">q</span> , adding and subtracting  <span class="math">\\beta</span>  will not cause a wrap-around mod  <span class="math">q</span> . For soundness, it is immediate that every extracted  <span class="math">\\hat{\\mathbf{s}}&#x27;</span>  with  <span class="math">\\hat{\\mathbf{t}} = \\mathbf{A}\\hat{\\mathbf{s}}&#x27;</span>  can be turned into a witness  <span class="math">\\mathbf{s}&#x27;</span>  for  <span class="math">\\mathbf{t}</span>  by setting  <span class="math">\\mathbf{s}&#x27; = \\hat{\\mathbf{s}}&#x27; - \\beta</span> . In this case, it holds for each coefficient  <span class="math">\\mathbf{s}&#x27;[i]</span>  that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {s} ^ {\\prime} [ i ] \\in [ - \\beta , 2 ^ {r + 1} - 1 - \\beta ] \\\\ \\in [ - \\beta , 2 ^ {r + 1} - 2 ^ {r} ] = [ - \\beta , 2 ^ {r} ] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Note that in the worst case,  <span class="math">\\beta</span>  is a power of 2 which means that we must set  <span class="math">r</span>  such that  <span class="math">2^r - 1 = 2\\beta - 1</span> . But then  <span class="math">\\mathbf{s}&#x27;[i] \\in [-\\beta, 2\\beta]</span>  and the claimed slack follows.</p>

    <p class="text-gray-300">It is possible to avoid the slack by choosing a different basis than powers of two for the decomposition, but we avoided this as it would have complicated the presentation. See e.g. [LNSW13] for more details.</p>

    <p class="text-gray-300">We now discuss an optimization which aims at reducing the argument size for the Binary SIS problem by reducing the number of non-linear gates in the circuit. Recall that in Fig. 4, we defined a circuit for this problem that has  <span class="math">m</span>  square gates. Each of the gates was used to verify that one of  <span class="math">m</span>  inputs is a bit. We now show how the number of square gates can be reduced to 1, at the cost of adding elements to the witness. This reduces the overall communication since adding an element to the witness increases the size of the argument per MPC instance by one field element, whereas evaluating a square gate requires sending at least two field elements (secret-shared random square, messages during evaluation of the gate etc.). The optimization uses circuit sampling where only  <span class="math">\\mathcal{V}</span>  has a challenge and so only  <span class="math">\\mathcal{V}</span>  is actually sampling the circuit alone.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume that we want to check if  <span class="math">m</span>  input sharings  <span class="math">\\mathbf{s}[1],\\ldots ,\\mathbf{s}[m]</span>  indeed are bits, and let  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg 2m<span class="math"> . We can implicitly define the polynomial  </span>D(X)\\in \\mathbb{F}[X]<span class="math">  of degree at most  </span>m - 1<span class="math">  such that  </span>\\forall i\\in [m]:D(i) = \\mathbf{s}[i]<span class="math"> . Furthermore, we know that there exists a polynomial  </span>B(X) = D(X)\\cdot D(X)<span class="math">  of degree at most  </span>2m - 2<span class="math">  such that  </span>\\forall i\\in \\mathbb{F}:D(i)^2 = B(i)<span class="math"> . We thus can say that  </span>\\forall i\\in [m]:\\mathbf{s}[i]\\in \\mathbb{B}<span class="math">  if and only if  </span>\\forall i\\in [m]:\\bar{B} (i) = D(i)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This allows us to construct a new circuit-sampling procedure. Instead of testing all  <span class="math">\\mathbf{s}[i]</span>  separately for being bits, we let the prover  <span class="math">\\mathcal{P}</span>  secret-share the predetermined  <span class="math">B(X)</span>  as part of the witness. Here, by our above observation that  <span class="math">\\forall i\\in [m]:B(i) = D(i)</span>  it is only necessary to share the points  <span class="math">B(m + 1),\\ldots ,B(2m - 1)</span>  (in addition to sharing all  <span class="math">\\mathbf{s}[i]</span> ). Then, using the fact that Lagrange-interpolation requires only linear operations (so it is entirely local in the underlying MPC scheme) we let  <span class="math">\\mathcal{V}</span>  send a challenge  <span class="math">x\\in \\mathbb{F}</span>  that is the point at which we will evaluate  <span class="math">D,B</span>  and test that  <span class="math">B(x) - D(x)^{2} = 0</span> . By the Schwartz-Zippel-Lemma, we then must</p>

    <p class="text-gray-300">Let  <span class="math">D(x)</span>  be a  <span class="math">(m - 1)</span> -degree polynomial such that  <span class="math">\\forall i \\in [m] : D(i) = \\mathbf{s}[i]</span>  and  <span class="math">B(x) = (D(x))^2</span>  be a  <span class="math">(2m - 2)</span> -degree polynomial. Let  <span class="math">S_D = \\{(i, D(i))\\}_{i \\in [m]}</span>  and  <span class="math">S_B = S_D \\cup \\{(i, B(i))\\}_{i \\in [2m - 1] \\setminus [m]}</span>  be the evaluation points of the polynomials  <span class="math">D, B</span> . We set  <span class="math">S_V = \\mathbb{F}^{n + 1}</span> .</p>

    <p class="text-gray-300">ExtWitness: On input</p>

    <div class="my-4 text-center"><span class="math-block">(x = (\\mathbf {A}, \\mathbf {t} [ 1 ], \\dots , \\mathbf {t} [ n ]), w = (\\mathbf {s} [ 1 ], \\dots , \\mathbf {s} [ m ])) \\in R _ {\\mathbb {S} - \\mathbb {S I S}} ^ {m, n, q}</span></div>

    <p class="text-gray-300">set  <span class="math">\\widehat{w} = (\\mathbf{s}[1],\\dots ,\\mathbf{s}[m],b_1,\\dots ,b_{m - 1})\\in \\mathbb{F}_q^{2m - 1}</span>  where  <span class="math">b_{i} = B(i + m) = D(i + m)^{2}</span></p>

    <p class="text-gray-300">SampCircuit: On input  <span class="math">\\tau_{\\mathcal{V}} = (\\gamma, x) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  output the circuit  <span class="math">C</span>  which performs the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall j\\in [n]</span>  compute  <span class="math">\\overline{y}_j\\gets \\sum_{i\\in [m]}a_j,\\mathbf{s}[i]</span></li>

      <li>Set  <span class="math">y_{1}\\gets \\sum_{j\\in [n]}\\gamma [j]\\cdot (\\overline{y}_{j} - \\mathbf{t}[j])</span></li>

      <li><span class="math">z_{1}\\gets \\sum_{j = 1}^{m}\\ell_{j}^{S_{D}}(x)\\cdot \\mathbf{s}[j]</span></li>

      <li><span class="math">z_{2}\\gets \\sum_{j = 1}^{m}\\ell_{j}^{S_{B}}(x)\\cdot \\mathbf{s}[j] + \\sum_{j = 1}^{m - 1}\\ell_{j + m}^{S_{B}}(x)\\cdot b_{j}</span></li>

      <li><span class="math">z_{3}\\gets z_{1}^{2}</span></li>

      <li><span class="math">y_{2}\\gets z_{3} - z_{2}</span></li>

      <li>Output of  <span class="math">C</span>  is  <span class="math">(y_{1},y_{2})</span></li>

    </ol>

    <p class="text-gray-300">Furthermore output the set  <span class="math">Y = \\{(0,0)\\}</span> .</p>

    <p class="text-gray-300">Response: Output 1.</p>

    <p class="text-gray-300">Fig. 6: Sampling of a circuit for  <span class="math">R_{\\mathbb{S} - \\mathbb{S}\\mathbb{I}\\mathbb{S}}^{m,n,q}</span> . This circuit contains 1 squaring gate, has  <span class="math">2m - 1</span>  inputs and 2 outputs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">have identity of  <span class="math">D(X)^2</span>  and  <span class="math">B(X)</span>  except with probability  $\\frac{2m - 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ . We now show that the above intuition yields a circuit sampler as outlined in Fig. 6:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 4. The aforementioned approach yields a perfectly correct,  $\\frac{2m - 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> -sound and perfectly simulatable circuit sampler for the relation  </span>R_{\\mathbb{S} - \\mathbb{S}\\mathbb{I}\\mathbb{S}}^{m,n,q}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Correctness and the simulation property follow directly from the definition of the algorithms. What remains to show is the  $\\frac{2m - 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ -soundness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix a string  <span class="math">\\widehat{w}</span>  and assume that soundness is higher than  $\\frac{2m - 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . As  </span>\\operatorname*{Pr}[y_1 = 0] &gt; \\frac{2m - 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &gt; \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  for all  </span>m &gt; 1<span class="math"> , this implies that  </span>\\widehat{w}[1], \\ldots, \\widehat{w}[m]<span class="math">  map to  </span>\\mathbf{t}<span class="math">  under multiplication with  </span>\\mathbf{A}<span class="math">  by the same argument as in Section 4.3. Consider the implicit polynomials  </span>D(X), B(X)<span class="math">  which were defined through  </span>\\widehat{w}<span class="math">  and assume that  </span>D(X)^2 \\neq B(X)<span class="math"> . Then by the Schwartz-Zippel Lemma the polynomial  </span>F(X) = D(X)^2 - B(X)<span class="math">  can have at most  </span>2m - 2<span class="math">  roots. But since  </span>\\operatorname*{Pr}[y_2 = 0] &gt; \\frac{2m - 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  its number of roots is bigger and so  </span>F(X)<span class="math">  must be the zero-polynomial. Due to the way  </span>D(X), B(X)<span class="math">  are constructed (i.e.,  </span>B(x) = D(x)<span class="math">  for all  </span>i \\in [m]<span class="math"> ), it thus follows that  </span>\\widehat{w}[1], \\ldots, \\widehat{w}[m]$  are bits, which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Applying this optimization and using  <span class="math">\\Pi_{\\mathrm{sat}}^{\\mathrm{samp}}</span> , we obtain that the total communication is base  <span class="math">+\\log q \\cdot M(2m + 4)</span>  bits which is approximately  <span class="math">\\log q \\cdot M(3m)</span>  bits smaller than the baseline approach.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">So far we have considered only arguments for SIS-instances where the gap between the norm of correct witnesses and the norm that the argument guarantees is small: if we start with  <span class="math">((\\mathbf{A},\\mathbf{y}),\\mathbf{s})\\in R_{\\mathrm{SIS}}^{m,n,q,\\beta}</span>  (i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq \\beta<span class="math"> ) then the soundness guarantee is that a witness  </span>\\mathbf{s}'<span class="math">  with  </span>((\\mathbf{A},\\mathbf{y}),\\mathbf{s}')\\in R_{\\mathrm{SIS}}^{m,n,q,\\omega \\beta}<span class="math">  could be extracted (i.e.,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq \\omega \\beta<span class="math"> ) where  </span>\\omega<span class="math">  is a small constant. However, the argument size depends on  </span>M\\cdot m\\cdot \\log_2(q)\\cdot \\log_2(\\beta)<span class="math">  as we have to perform non-linear computations for the bit-decomposition of each input  </span>\\mathbf{s}[i]<span class="math"> . The goal of this subsection is to give an approximate argument of size for the  </span>\\mathbf{s}[i]<span class="math">  without having to resort to bit-decomposition for each  </span>\\mathbf{s}[i]<span class="math"> . This would allow for a smaller number of square- or multiplication-gates as well as a more compact witness. On the other hand, the arguments will have a larger slack  </span>\\omega<span class="math">  which will now also depend on the number of inputs  </span>m$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To achieve a more compact argument, we will ask the prover to show that random linear combinations of elements from <span class="math">\\mathbf{s}</span> are small. For this we use a Lemma from <em>[x1]</em> who showed that random linear combinations mod <span class="math">q</span> of elements from <span class="math">\\mathbf{s}</span> are with certain probability not much smaller than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-55" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">For all <span class="math">\\mathbf{s}\\in\\mathbb{F}_{q}^{k}</span> it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\mathbf{c}\\leftarrow\\{0,1\\}^{k}}\\left[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{c},\\mathbf{s}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right]\\leq\\frac{1}{2}\\quad\\text{ and }\\quad\\Pr_{\\mathbf{C}\\leftarrow\\{0,1\\}^{\\ell\\times k}}\\left[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}\\cdot\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<\\frac{1}{2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right]\\leq 2^{-\\ell}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">See <em>[x1, Lemma 2.3 & Corollary 2.4]</em>. ∎</p>

    <p class="text-gray-300">The above Lemma only talks about the chance of detecting a vector of high norm by seeing <em>one</em> large element in the result of the product with a random binary matrix. We will now extend it to the case where we always see that lots such large elements in the product <span class="math">\\mathbf{C}\\cdot\\mathbf{s}</span>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\kappa,r\\in\\mathbb{N}^{+},\\mathbf{s}\\in\\mathbb{F}_{q}^{k},\\beta=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$ and define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathbf{C}\\leftarrow\\mathbb{B}^{(r\\cdot\\kappa)\\times k}}\\left[\\mathbf{C}\\cdot\\mathbf{s}\\not\\in S_{\\kappa}^{\\beta}\\right]\\leq\\exp\\left(-\\kappa\\frac{(r-2)^{2}}{2r}\\right).</span></p>

    <p class="text-gray-300">The proof follows by a Hoeffding-bound argument.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Set <span class="math">\\mathbf{r}=\\mathbf{C}\\cdot\\mathbf{s}</span> and define <span class="math">X_{i}\\in\\mathbb{B}</span> to be <span class="math">0</span> iff $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{r}[i]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\beta/2<span class="math"> and </span>1$ otherwise. From Lemma 7 it follows that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathbf{C}\\leftarrow\\mathbb{B}^{(r\\cdot\\kappa)\\times k}}[X_{i}=1]\\leq 1/2</span></p>

    <p class="text-gray-300">for all <span class="math">i\\in[r\\cdot\\kappa]</span>. Consider the mean <span class="math">\\overline{X}=\\frac{1}{r\\cdot\\kappa}\\sum_{i=1}^{r\\cdot\\kappa}X_{i}</span>. Then clearly <span class="math">E[\\overline{X}]=E[X_{i}]=\\Pr[X_{i}=1]\\leq 1/2</span> and thus <span class="math">-E[\\overline{X}]\\geq-1/2</span>.</p>

    <p class="text-gray-300">Using the one-sided Hoeffding inequality we obtain</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathbf{C}\\in\\mathbb{B}^{(r\\cdot\\kappa)\\times k}}\\left[\\overline{X}-E[\\overline{X}]\\geq\\frac{r-1}{r}-\\frac{1}{2}\\right]\\leq\\exp\\left(-2(r\\cdot\\kappa)\\cdot\\left(\\frac{r-2}{2r}\\right)^{2}\\right)</span></p>

    <p class="text-gray-300">Since <span class="math">-E[\\overline{X}]\\geq-1/2</span>, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathbf{C}\\in\\mathbb{B}^{(r\\cdot\\kappa)\\times k}}\\left[\\overline{X}\\geq\\frac{r-1}{r}\\right]\\leq\\exp\\left(-\\kappa\\cdot\\frac{(r-2)^{2}}{2r}\\right)</span></p>

    <p class="text-gray-300">Observe that for the event <span class="math">\\overline{X}\\geq 1-1/r</span> to happen, there must be <span class="math">\\leq\\kappa</span> variables for which <span class="math">X_{i}=0</span> (since in that case <span class="math">\\overline{X}=\\frac{1}{r\\cdot k}\\sum_{i=1}^{r\\cdot k}X_{i}\\geq\\frac{r\\cdot k-k}{r\\cdot k}=1-\\frac{1}{r}</span>). Thus,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathbf{C}\\in\\mathbb{B}^{(r\\cdot\\kappa)\\times k}}\\left[\\overline{X}\\geq\\frac{r-1}{r}\\right]=\\Pr_{\\mathbf{C}\\leftarrow\\mathbb{B}^{(r\\cdot\\kappa)\\times k}}\\left[\\mathbf{C}\\cdot\\mathbf{s}\\not\\in S_{\\kappa}^{\\beta}\\right]</span></p>

    <p class="text-gray-300">and the claim follows. ∎</p>

    <p class="text-gray-300">From the above Lemma we can easily derive the following:</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Corollary 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\kappa,r\\in\\mathbb{N}^{+},\\mathbf{s}\\in\\mathbb{F}_{q}^{k},\\beta=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> and define </span>S_{\\kappa}^{\\beta}=\\{\\mathbf{h}\\in\\mathbb{F}_{q}^{r\\cdot\\kappa}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\exists T\\subseteq[r\\cdot\\kappa]\\land</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\kappa\\land\\forall i\\in T:\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{h}[i]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1}{2}\\cdot\\beta\\}<span class="math">. If </span>r\\geq 5$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathbf{C}\\leftarrow\\mathbb{B}^{(r\\cdot\\kappa)\\times k}}\\left[\\mathbf{C}\\cdot\\mathbf{s}\\not\\in S_{\\kappa}^{\\beta}\\right]\\leq 2^{-\\kappa}.</span></p>

    <p class="text-gray-300">The above statements can directly be implemented in our argument system by the means of circuit sampling. Unfortunately, this results in a new problem, which is that we cannot output the product of <span class="math">\\mathbf{s}</span> with a random binary matrix to <span class="math">\\mathcal{V}</span> without necessarily leaking information about <span class="math">\\mathbf{s}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We resolve this problem using circuit sampling on the side of the prover and give two different solutions. The first idea is that <span class="math">\\mathcal{P}</span> can compute <span class="math">\\mathbf{u}=\\mathbf{C}\\mathbf{s}</span> and output <span class="math">\\mathbf{u}+\\text{&quot;small&quot;}</span> where "small" is a value of small norm. To achieve good soundness guarantees we let "small" only be polynomially bigger than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> and use Rejection Sampling to hide the information from the product. Alternatively, we can allow </span>\\mathcal{P}<span class="math"> to prove knowledge of the bit decomposition of each value of </span>\\mathbf{u}=\\mathbf{C}\\mathbf{s}$. We now describe both ideas in more detail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">1^{st}</span>  Approach: Rejection Sampling. In this solution, we let the prover  <span class="math">\\mathcal{P}</span>  add additional random elements  <span class="math">x_{1}, x_{2}, \\ldots</span>  to the witness, which are supposed to be small. The verifier  <span class="math">\\mathcal{V}</span>  will then, as part of his challenge in the circuit sampling, ask  <span class="math">\\mathcal{P}</span>  to open a subset of  <span class="math">x_{1}, x_{2}, \\ldots</span>  to show that most of the remaining ones are indeed of small size.  <span class="math">\\mathcal{P}</span>  will then open sums of each  <span class="math">\\mathbf{u}[i]</span>  with some  <span class="math">x_{j}</span> , subject to the constraint that this does not leak information about  <span class="math">\\mathbf{s}</span> .  <span class="math">\\mathcal{V}</span>  later tests that each such  <span class="math">\\mathbf{u}[i] + x_{j}</span>  is of bounded norm.</p>

    <p class="text-gray-300">Set  <span class="math">\\pi = 100</span> . We will have  <span class="math">S_{\\mathcal{V}} = \\{(\\gamma, E, \\mathbf{C}) \\in \\mathbb{F}_q^n \\times \\mathbb{B}^{16\\kappa} \\times \\mathbb{B}^{5\\kappa \\times m}\\}</span> .</p>

    <p class="text-gray-300">ExtWitness: On input</p>

    <div class="my-4 text-center"><span class="math-block">\\left(x = \\left(\\mathbf {t} [ 1 ], \\dots , \\mathbf {t} [ n ]\\right), w = \\left(\\mathbf {s} [ 1 ], \\dots , \\mathbf {s} [ m ]\\right)\\right) \\in R _ {\\text {S I S}} ^ {m, n, q, \\beta}</span></div>

    <p class="text-gray-300">sample  <span class="math">x_{1},\\ldots ,x_{16\\kappa}</span>  uniformly at random from  <span class="math">[- \\pi \\cdot m\\cdot \\beta ,\\pi \\cdot m\\cdot \\beta ]\\subset \\mathbb{F}</span> . Then set</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {w} = (\\mathbf {s} [ 1 ], \\dots , \\mathbf {s} [ m ], x _ {1}, \\dots , x _ {1 6 \\kappa}) \\in \\mathbb {F} _ {q} ^ {m + 1 6 \\kappa}.</span></div>

    <p class="text-gray-300">Response: On input  <span class="math">x, v, \\widehat{w}, \\tau_{\\mathcal{V}}</span>  do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">T \\gets \\emptyset</span>  and let  <span class="math">E</span>  be as in  <span class="math">\\tau_{\\mathcal{V}}</span> .</li>

      <li>Let  <span class="math">\\mathbf{u} \\gets \\mathbf{C}\\mathbf{s}</span> . For all  <span class="math">i \\in [5\\kappa]</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Set  <span class="math">v_{i} \\gets \\mathbf{u}[i] + x_{e}</span>  for the smallest  <span class="math">e \\in E</span> . (b) Set  <span class="math">E\\gets E\\setminus \\{e\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) Set  <span class="math">T \\gets T \\cup \\{(i, e)\\}</span>  if  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (\\pi - 1) \\cdot m \\cdot \\beta<span class="math"> , otherwise begin again for the next element in  </span>E$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\tau_{\\mathcal{P}} = T</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SampCircuit: On input  <span class="math">x, \\tau_{\\mathcal{P}} = T, \\tau_{\\mathcal{V}} = (\\gamma, E, \\mathbf{C})</span>  where  $\\ell =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  output the circuit  </span>C$  which performs the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\overline{y} \\gets \\mathbf{A}\\mathbf{s}</span> .</li>

      <li>Set  <span class="math">y \\gets \\sum_{j \\in [n]} \\gamma[j] \\cdot (\\overline{y}[j] - \\mathbf{t}[j])</span> .</li>

      <li>Write  <span class="math">\\overline{E} = \\{e_1, \\ldots, e_\\ell\\}</span> . Then for  <span class="math">i \\in [\\ell]</span>  set  <span class="math">v_i \\gets x_e</span> .</li>

      <li>Compute  <span class="math">\\mathbf{u} \\gets \\mathbf{C}\\mathbf{s}</span> .</li>

      <li>For  <span class="math">i\\in [5\\kappa ]</span>  set  <span class="math">v_{i + \\ell}\\gets \\mathbf{u}[i] + x_{t_i}</span>  where  <span class="math">(i,t_i)\\in T</span></li>

      <li>Output of  <span class="math">C</span>  is  <span class="math">(y, v_1, \\ldots, v_{\\ell + 5\\kappa})</span> .</li>

    </ol>

    <p class="text-gray-300">We implicitly set  <span class="math">Y</span>  to be</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{(0, v _ {1}, \\ldots , v _ {k + 5 \\kappa}) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\forall i \\in [ \\ell ]:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v _ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\pi \\cdot m \\cdot \\beta \\wedge \\\\ \\forall j \\in [ 5 \\kappa ]:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v _ {\\ell + j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (\\pi - 1) \\cdot m \\cdot \\beta \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Fig. 7: Sampling of a circuit for  <span class="math">R_{\\mathrm{SIS}}^{m,n,q,4\\pi m \\cdot \\beta}</span> .</p>

    <p class="text-gray-300">As part of rejection sampling a prover aborts whenever the argument would leak information. But our goal is that the argument is complete with overwhelming probability. To achieve this, we use an idea which is inspired by the "imperfect proof" of [BDLN16]. There, the authors gave a protocol that showed how to prove knowledge of  <span class="math">\\ell -\\kappa</span>  out of  <span class="math">\\ell</span>  SIS instances using cut-and-choose and rejection sampling. Their approach aborts only with negligible probability and turns out to be compatible with our application. The circuit sampler is fully described in Fig. 7, based on which we can show the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 5. The aforementioned approach yields a statistically correct,  <span class="math">\\alpha</span> -sound and perfectly simulatable circuit sampler for the relation  <span class="math">R_{\\mathrm{SIS}}^{m,n,q,4\\pi m\\cdot \\beta}</span>  where  $\\alpha = \\max \\{1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,2^{-\\kappa}\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. We prove that the sampler satisfies the definitions in Section 4.1.</p>

    <p class="text-gray-300">CORRECTNESS. We show that if the prover follows the sampler instructions, then  <span class="math">C(\\widehat{w}) \\in Y</span>  except for a negligible probability in  <span class="math">\\kappa</span> . Clearly, the event that  <span class="math">C(\\widehat{w}) \\notin Y</span>  occurs only when  <span class="math">16\\kappa</span>  samples of  <span class="math">x_{e}</span>  are not sufficient to terminate the process. We show that this indeed happens only with negligible probability. To prove this, we first compute the probability that  <span class="math">x_{e}</span>  is "thrown away" and not used in the sum with  <span class="math">\\mathbf{u}[i]</span> . As we assume that the prover acts honestly, we know that  <span class="math">x_{e} \\in [-\\pi \\cdot m \\cdot \\beta, \\pi \\cdot m \\cdot \\beta]</span> , i.e.,  <span class="math">x_{e}</span>  is sampled from a</p>

    <p class="text-gray-300">set of size <span class="math">2\\pi \\cdot m \\cdot \\beta + 1</span>. In addition <span class="math">-\\beta \\leq \\mathbf{s}[i] \\leq \\beta</span> and so <span class="math">-m\\beta \\leq \\mathbf{u}[i] \\leq m\\beta</span>. Denote by <span class="math">\\mathsf{bad}_x</span> the event that <span class="math">x_e</span> is not used. Thus, given <span class="math">\\mathbf{u}[i]</span>, we can write</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\mathbf {b a d} _ {x} \\right] = \\Pr \\left[ \\mathbf {u} [ i ] + x _ {e} &amp;lt;   - \\pi \\cdot m \\cdot \\beta + m \\cdot \\beta \\right] + \\\\ \\Pr \\left[ \\mathbf {u} [ i ] + x _ {e} &amp;gt; \\pi \\cdot m \\cdot \\beta - m \\cdot \\beta \\right] \\\\ = \\Pr \\left[ x _ {e} &amp;lt;   - \\pi \\cdot m \\cdot \\beta + m \\cdot \\beta - \\mathbf {u} [ i ] \\right] + \\\\ \\Pr \\left[ x _ {e} &amp;gt; \\pi \\cdot m \\cdot \\beta - m \\cdot \\beta - \\mathbf {u} [ i ] \\right] \\\\ = \\frac {\\pi \\cdot m \\cdot \\beta + m \\cdot \\beta - \\mathbf {u} [ i ] - (- \\pi \\cdot m \\cdot \\beta)}{2 \\pi \\cdot m \\cdot \\beta + 1} + \\\\ \\frac {\\pi \\cdot m \\cdot \\beta - (\\pi \\cdot m \\cdot \\beta - m \\cdot \\beta - \\mathbf {u} [ i ])}{2 \\pi \\cdot m \\cdot \\beta + 1} \\\\ = \\frac {2 m \\cdot \\beta}{2 \\pi \\cdot m \\cdot \\beta + 1} &amp;lt;   \\frac {2 m \\cdot \\beta}{2 \\pi \\cdot m \\cdot \\beta} = \\frac {1}{\\pi}. \\end{array}</span></div>

    <p class="text-gray-300">Note that this probability is independent of the value <span class="math">\\mathbf{u}[i]</span>. Therefore, given that each <span class="math">x_{e}</span> is being sent in the clear to <span class="math">\\mathcal{V}</span> with probability <span class="math">1 / 2</span>, we obtain that each <span class="math">x_{e}</span> is not used in the sum with <span class="math">\\mathbf{u}[i]</span> with probability <span class="math">p &amp;lt; 1 / 2 + 1 / 2 \\cdot 1 / \\pi</span>.</p>

    <p class="text-gray-300">We now compute the probability that there aren't enough samples of <span class="math">x_{e}</span> to construct the circuit. Let <span class="math">X_{e} \\in \\mathbb{B}</span> be a random variable such that <span class="math">X_{e} = 0</span> with probability <span class="math">p</span> and <span class="math">X_{e} = 1</span> with probability <span class="math">1 - p</span>. Furthermore, define <span class="math">\\overline{X} = \\frac{1}{16\\kappa}\\sum_{e=1}^{16\\kappa}X_{e}</span>. Since there are <span class="math">16\\kappa</span> samples of <span class="math">X_{e}</span> to begin with and <span class="math">5\\kappa</span> are required to complete the circuit construction successfully, we need to determine <span class="math">\\operatorname<em>{Pr}\\left[\\sum_{e=1}^{16\\kappa}X_{e} &amp;lt; 5\\kappa\\right] = \\operatorname</em>{Pr}\\left[\\overline{X} &amp;lt; \\frac{5}{16}\\right]</span>. Observe that furthermore <span class="math">E\\left[\\overline{X}\\right] = p &amp;lt; 1/2 + 1/2\\pi</span> and therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\bar {X} &amp;lt;   \\frac {5}{1 6} \\right] \\leq \\Pr \\left[ \\bar {X} - E [ \\bar {X} ] &amp;lt;   \\frac {5}{1 6} - \\frac {1}{2} - \\frac {1}{2 \\pi} \\right] \\\\ = \\Pr \\left[ E [ \\bar {X} ] - \\bar {X} &amp;gt; \\frac {3}{1 6} + \\frac {1}{2 \\pi} \\right]. \\end{array}</span></div>

    <p class="text-gray-300">Using the Hoeffding bound we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\sum_ {e = 1} ^ {1 6 \\kappa} X _ {e} &amp;lt;   5 \\kappa \\right] \\leq \\exp \\left(- 2 \\cdot 1 6 \\kappa \\cdot \\left(\\frac {3 \\pi + 8}{1 6 \\pi}\\right) ^ {2}\\right) \\\\ \\leq \\exp (- \\kappa) \\end{array}</span></div>

    <p class="text-gray-300">where the last inequality holds for any <span class="math">\\pi \\geq 1</span>.</p>

    <p class="text-gray-300">SIMULATABILITY. Recall that the definition of in Section 4.1, we need to show that a simulator who receives <span class="math">x, w</span> and <span class="math">\\tau_{\\mathcal{V}}</span> as its input can output <span class="math">\\tau_{\\mathcal{P}}</span> and <span class="math">C(\\widehat{w})</span> that are indistinguishable from an output of a real execution. As we have seen, the aforementioned "throwing away" probability is actually independent of the value <span class="math">\\mathbf{u}[i]</span> as long as <span class="math">\\mathbf{u}[i] \\in [-m \\cdot \\beta, m \\cdot \\beta]</span>. One can therefore simulate <span class="math">\\tau_{\\mathcal{P}}</span> by flipping a biased coin. To simulate <span class="math">C(\\widehat{w})</span>, each value <span class="math">v_{1}, \\ldots, v_{\\ell + 5\\kappa}</span> is simply chosen from its respective interval. This is obviously a perfect simulation for <span class="math">v_{1}, \\ldots, v_{\\ell}</span> whereas <span class="math">v_{\\ell + 1}, \\ldots, v_{\\ell + 5\\kappa}</span> is uniformly random in its interval by the choice of <span class="math">x_{i}</span> in Response.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\alpha</span>-SOUNDNESS. Let <span class="math">\\widehat{w}</span> be fixed and assume that the prover succeeds with probability $&gt; \\alpha = \\max \\{1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 2^{-\\kappa}\\}<span class="math">. As in previous arguments, this particularly implies that the committed </span>\\overline{\\mathbf{w}}<span class="math"> contains a correct preimage of </span>\\mathbf{t}<span class="math"> under multiplication with </span>\\mathbf{A}$ and it remains to show that this preimage is of correct size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the fact that each <span class="math">x_{e}</span> is chosen to be in the set <span class="math">E</span> with probability 1/2, it follows that all but <span class="math">\\kappa</span> of the unopened <span class="math">x_{e}</span> must be within the interval <span class="math">[-\\pi \\cdot \\beta \\cdot m, \\pi \\cdot \\beta \\cdot m]</span>, as otherwise the success probability of the prover must be lower than <span class="math">\\frac{1}{2^{\\kappa}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let's consider the vector <span class="math">\\mathbf{u}</span> which the prover computes. By Corollary 2 we know that if <span class="math">\\mathcal{P}</span> uses <span class="math">\\mathbf{s}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\geq (4\\pi - 2)m \\cdot \\beta + 2<span class="math"> then </span>\\mathbf{u} \\in S_{\\kappa}^{(4\\pi - 2)m\\beta + 2}<span class="math"> (i.e., there exist </span>&gt; \\kappa<span class="math"> values </span>\\mathbf{u}[j]<span class="math"> for which </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}[j]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">33</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">(2\\pi - 1)m \\cdot \\beta + 1)</span>, except with probability <span class="math">2^{-\\kappa}</span>. Thus for the output of the circuit to be in <span class="math">Y</span> each <span class="math">\\mathbf{u}[j]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}[j]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq (2\\pi - 1)m\\beta + 1 &gt; (2\\pi - 1)m\\beta<span class="math"> must be paired with a value </span>x_e<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\pi m\\beta<span class="math"> so that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}[j] + x_e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (\\pi - 1)m\\beta<span class="math">. As there are at most </span>\\kappa<span class="math"> many such &quot;bad&quot; </span>x_i<span class="math">, the prover can make at most </span>\\kappa<span class="math"> bad sums and at least one generated </span>v_j<span class="math"> will be outside of the interval and thus be noticed, except with probability </span>2^{-\\kappa}<span class="math">. Therefore, if the success probability of the prover is higher than </span>2^{-\\kappa}<span class="math">, then </span>\\widehat{w}<span class="math"> must contain a preimage of </span>\\mathbf{t}<span class="math"> of bound at most </span>4\\pi m\\beta \\geq (4\\pi - 2) \\cdot m \\cdot \\beta + 2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A drawback of this approach is the rather big slack of <span class="math">4\\pi \\cdot m</span>. This slack is caused by two reasons. First, there is an inherent increase of <span class="math">m</span> due to the use of Lemma 7. In addition, using Rejection Sampling means that we lose another factor <span class="math">\\pi = 100</span>. One could decrease the constant by using a discrete Gaussian distribution for the <span class="math">x_{i}</span> as in [Lyu12], but we opted for presenting the above idea due to its simplicity. On the positive side, there are no non-linear gates in the sampled circuit and <span class="math">\\mathcal{P}</span> will only have to add <span class="math">16 \\cdot \\kappa</span> more values to the witness, independently of <span class="math">\\beta</span>. The sampled circuit will output <span class="math">\\ell + 5\\kappa + 1</span> elements of <span class="math">\\mathbb{F}</span>, which in expectancy is around <span class="math">13\\kappa + 1</span> (since each of the <span class="math">16\\kappa</span> random samples is opened with probability <span class="math">1/2</span>).</p>

    <p class="text-gray-300">Summing up, the communication of the argument (excluding <span class="math">\\tau_{\\mathcal{P}}</span>) when using <span class="math">\\Pi_{\\mathrm{sac}}^{\\mathrm{samp}}</span> is base + log₂ q · M(m + 29κ + 1) bits.</p>

    <p class="text-gray-300"><strong>2nd Approach: The Power of Random Bits.</strong> The previous solution has the disadvantage of having a comparably high slack of <span class="math">4\\pi m</span>. On the other hand, it does not use any non-linear gates. We will now show how to decrease the slack to be essentially <span class="math">m</span> by reintroducing one square gate and adding computational work. To reduce the slack, we will again rely on Lemma 7. But instead of performing rejection sampling on the output, we perform a range proof for each element of the matrix product <span class="math">\\mathbf{u} = \\mathbf{C}\\mathbf{s}</span>. The problem that arises is that <span class="math">\\mathbf{C}</span> is only chosen at runtime, while the committed witness must be independent of the actual values in <span class="math">\\mathbf{C}</span>. At the same time, we must construct the argument in such a way that the circuit <span class="math">C</span> will not reveal any information about the product except for bounds on each value.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We resolve this problem as follows: if the witness has $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta<span class="math">, then since </span>\\mathbf{C} \\in \\mathbb{B}^{\\kappa \\times m}<span class="math"> it must hold that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq m \\cdot \\beta<span class="math">. Thus, letting </span>r<span class="math"> be the smallest integer such that </span>m \\cdot \\beta &lt; 2^r<span class="math">, it suffices for the prover to show that </span>\\mathbf{u}[i] \\in [-2^r, 2^r - 1]<span class="math"> (which can be done using bit decomposition as in the generalization of Section 5.1). To show the inclusion </span>\\mathcal{P}<span class="math"> can add random bits </span>x_0^i, \\ldots, x_r^i<span class="math"> to the witness. Then, once the challenge is received from </span>\\mathcal{V}<span class="math"> and </span>\\mathbf{u}<span class="math"> is known to </span>\\mathcal{P}<span class="math">, it can compute the bit decomposition </span>\\mathbf{u}[i] + 2^r = \\sum_{j=0}^{r} 2^j h_j^i<span class="math"> for each </span>i \\in [\\kappa]<span class="math"> and tell </span>\\mathcal{V}<span class="math"> for each </span>j \\in \\{0, \\ldots, r\\}<span class="math"> if it should use </span>x_j^i<span class="math"> or </span>1 - x_j^i<span class="math"> to represent </span>h_j^i<span class="math">. As all </span>x_i^j<span class="math"> are chosen randomly, this yields a simulatable circuit. The only issue that remains is for </span>\\mathcal{P}<span class="math"> to prove that each </span>x_i^j$ is indeed a bit. For this task, we use the method presented in Section 5.3, which uses polynomial evaluation and requires a single non-linear gate. The full circuit sampler can be found in Fig. 8.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 6.</strong> Assume that <span class="math">(q - 1) / 2 &amp;gt; 4m\\beta</span>. The aforementioned approach yields a perfectly correct, <span class="math">\\alpha</span>-sound and perfectly simulatable circuit sampler for the relation <span class="math">R_{\\mathrm{SIS}}^{m,n,q,2m\\cdot \\beta +4}</span> where $\\alpha = \\max \\{\\frac{2(r + 1)\\kappa - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},2^{-\\kappa}\\}<span class="math"> and </span>r<span class="math"> is the smallest integer such that </span>m\\cdot \\beta \\leq 2^r -1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> We prove that the sampler satisfies the definitions in Section 4.1.</p>

    <p class="text-gray-300"><strong>Correctness:</strong> Most of the correctness follows simply by linearity as in the other constructions, so we will focus on the bit-decomposition part.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The multiplication of <span class="math">\\mathbf{s}</span> with <span class="math">\\mathbf{C}</span> trivially yields a bound $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq m \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = m \\cdot \\beta<span class="math">. By shifting each </span>\\mathbf{u}[i]<span class="math"> with the constant </span>m \\cdot \\beta<span class="math"> we will have that </span>\\mathbf{u}[i] + m \\cdot \\beta \\in [0, 2^{r+1} - 1]<span class="math">. This can always be represented with </span>r + 1$ bits as in the protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>α-Soundness:</strong> The prover has three ways it can get away with using an invalid witness. The first is to use a input vector <span class="math">\\mathbf{s}</span> which is not a preimage of <span class="math">\\mathbf{t}</span> under multiplication with <span class="math">\\mathbf{A}</span>. But as in previous constructions this will only succeed with probability $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (due to the random linear combination of outputs). A second option to cheat is to use </span>x_j^i$ that are not bits. Following the same idea as in the proof of Theorem 4, this</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will have  <span class="math">S_{\\mathcal{V}} = \\{(\\gamma ,\\hat{x},\\mathbf{C})\\in \\mathbb{F}_q^n\\times \\mathbb{F}_q\\times \\mathbb{B}^{\\kappa \\times m}\\}</span>  Let  <span class="math">\\ell_j^T (x) = \\prod_{\\substack{1\\leq i\\leq h\\\\ i\\neq j}}\\frac{x - x_i}{x_j - x_i}</span>  be Lagrange coefficients, where  <span class="math">T = \\{(x_i,y_i)\\}_{i\\in h}</span>  is the set of points used for polynomial evaluation.</p>

    <p class="text-gray-300">ExtWitness: On input  <span class="math">(x = (\\mathbf{t}[1],\\dots ,\\mathbf{t}[n]),w = (\\mathbf{s}[1],\\dots ,\\mathbf{s}[m]))\\in R_{\\mathrm{SIS}}^{m,n,q,\\beta}</span>  do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i\\in [\\kappa ]</span>  sample the random bits  <span class="math">x_{1}^{i},\\ldots ,x_{r + 1}^{i}</span></li>

      <li>Compute the unique polynomial  <span class="math">D(X)</span>  of degree  <span class="math">(r + 1)\\kappa - 1</span>  where  <span class="math">D((i - 1)(r + 1) + j) = x_j^i</span>  for  <span class="math">i \\in [\\kappa], j \\in [r + 1]</span> . Furthermore, compute the polynomial  <span class="math">B(X) = (D(X))^2</span>  and set  <span class="math">S_D = \\{(i, D(i))\\}_{i \\in [(r + 1)\\kappa]}</span>  and  <span class="math">S_B = S_D \\cup \\{(i, B(i))\\}_{i \\in [2(r + 1)\\kappa - 1] \\setminus [(r + 1)\\kappa]}</span>  as the evaluation points of  <span class="math">D(X), B(X)</span> .</li>

      <li>Set</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\widehat {w} = \\left( \\begin{array}{c} \\mathbf {s} [ 1 ], \\ldots , \\mathbf {s} [ m ], z _ {1}, \\ldots , z _ {(r + 1) \\kappa - 1}, \\\\ x _ {1} ^ {1}, \\ldots , x _ {r + 1} ^ {1}, \\ldots , x _ {1} ^ {\\kappa}, \\ldots , x _ {r + 1} ^ {\\kappa} \\end{array} \\right) \\in \\mathbb {F} _ {q} ^ {m + (r + 1) \\kappa}</span></div>

    <p class="text-gray-300">where  <span class="math">z_{i} = B(i + (r + 1)\\kappa) = (D(i + (r + 1)\\kappa))^{2}</span> .</p>

    <p class="text-gray-300">Response: On input  <span class="math">x, v, \\widehat{w}, \\tau_{\\mathcal{V}}</span>  do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathbf{u} \\gets \\mathbf{C}\\mathbf{s}</span> . Then for all  <span class="math">i \\in [\\kappa]</span>  do the following:</li>

    </ol>

    <p class="text-gray-300">(a) Set  <span class="math">v_{i} \\gets \\mathbf{u}[i] + m \\cdot \\beta</span> . (b) Find  <span class="math">h_0^i,\\ldots ,h_r^i\\in \\mathbb{B}</span>  such that  <span class="math">v_{i} = \\sum_{j = 0}^{r}h_{j}^{i}2^{j}</span> (c) For each  <span class="math">j \\in \\{0, \\dots, r\\}</span>  set  <span class="math">b_j^i = 0</span>  if  <span class="math">h_j^i = x_j^i</span>  and  <span class="math">b_j^i = 1</span>  otherwise.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\tau_{\\mathcal{P}} = (\\{b_0^i,\\dots ,b_r^i\\}_{i\\in [\\kappa ]})</span></li>

    </ol>

    <p class="text-gray-300">SampCircuit: On input  <span class="math">x, \\tau_{\\mathcal{P}} = (\\{b_0^i, \\ldots, b_r^i\\}_{i \\in [\\kappa]}), \\tau_{\\mathcal{V}} = (\\gamma, \\hat{x}, \\mathbf{C})</span>  the circuit  <span class="math">C</span>  performs the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\overline{y} \\gets \\mathbf{A}\\mathbf{s}</span> .</li>

      <li>Set  <span class="math">y_{1}\\gets \\sum_{j\\in [n]}\\gamma [j]\\cdot (\\overline{y} [j] - \\mathbf{t}[j])</span></li>

      <li>Set  <span class="math">\\mathbf{u} \\gets \\mathbf{C}\\mathbf{s}</span> .</li>

      <li><span class="math">z_{1}\\gets \\sum_{i = 1}^{\\kappa}\\sum_{j = 1}^{r + 1}\\ell_{(i - 1)(r + 1) + j}^{S_{D}}(\\hat{x})\\cdot x_{j}^{i}</span></li>

      <li><span class="math">z_{2}\\gets \\sum_{i = 1}^{\\kappa}\\sum_{j = 1}^{r + 1}\\ell_{(i - 1)(r + 1) + j}^{S_{B}}(\\hat{x})\\cdot x_{j}^{i} + \\sum_{j = 1}^{(r + 1)\\kappa -1}\\ell_{j + (r + 1)\\kappa}^{S_{B}}(\\hat{x})\\cdot z_{j}</span></li>

      <li><span class="math">z_{3}\\gets z_{1}^{2}</span>  and  <span class="math">y_{2}\\gets z_{3} - z_{2}</span></li>

      <li>For each  <span class="math">i \\in [\\kappa], j \\in \\{0, \\dots, r\\}</span>  set  <span class="math">h_j^i = x_{j+1}^i</span>  if  <span class="math">b_j^i = 0</span>  and  <span class="math">h_j^i = 1 - x_{j-1}^i</span>  otherwise.</li>

      <li>For  <span class="math">i \\in [\\kappa]</span>  set  <span class="math">y_{i+2} \\gets \\mathbf{u}[i] + m \\cdot \\beta - \\left( \\sum_{j=0}^{r} h_j^i 2^j \\right)</span> .</li>

      <li>Output  <span class="math">(y_{1},\\ldots ,y_{\\kappa +2})</span></li>

    </ol>

    <p class="text-gray-300">We output the set  <span class="math">Y = \\{(0, \\dots, 0) \\in \\mathbb{F}_q^{\\kappa + 2}\\}</span> .</p>

    <p class="text-gray-300">Fig. 8: Sampling of a circuit for  <span class="math">R_{\\mathrm{SIS}}^{m,n,q,3m\\cdot \\beta}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover can succeed here with probability of at most  $\\frac{2(r + 1)\\kappa - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . The third way is to use an input vector with norm that is not in allowed range. We will show now that the success probability in this case is at most  </span>2^{-\\kappa}<span class="math"> . Observe that  </span>\\frac{2(r + 1)\\kappa - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &gt; \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  and so the overall soundness error is as defined in the Theorem.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the rest of the proof we assume that the committed values  <span class="math">x_{j}^{i}</span>  are bits. Assume that  <span class="math">\\mathbf{s}</span>  as committed in the witness  <span class="math">\\widehat{w}</span>  is such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\geq 2m\\beta + 4<span class="math"> . Then by Lemma 7 we have that  </span>\\operatorname*{Pr}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; m \\cdot \\beta + 2] \\leq 2^{-\\kappa}<span class="math"> . If  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\geq m \\cdot \\beta + 2<span class="math">  then there exists an index  </span>i<span class="math">  such that either  </span>\\mathbf{u}[i] \\in [-(q - 1)/2, -m \\cdot \\beta - 2]<span class="math">  or  </span>\\mathbf{u}[i] \\in [m \\cdot \\beta + 2, (q - 1)/2]<span class="math"> . In the first case we have  </span>v_{i} = \\mathbf{u}[i] + m \\cdot \\beta<span class="math">  which results in  </span>v_{i} \\in [-(q - 1)/2 + m \\cdot \\beta, -2]<span class="math"> . But no such  </span>v_{i}<span class="math">  can be represented as  </span>v_{i} = \\sum_{j=0}^{r} h_{j}^{i} 2^{j}<span class="math">  using bits  </span>h_{j}^{i}<span class="math">  only. If on the other hand  </span>\\mathbf{u}[i] \\in [m \\cdot \\beta + 2, (q - 1)/2]<span class="math">  then  </span>v_{i} \\in [2m \\cdot \\beta + 2, (q - 1)/2] \\cup [-(q - 1)/2, -(q - 1)/2 + m\\beta - 1]<span class="math"> . But the largest number which the sum  </span>\\sum_{j=0}^{r} h_{j}^{i} 2^{j}<span class="math">  can express with  </span>h_{j}^{i} \\in \\{0,1\\}<span class="math">  is  </span>2^{r+1} - 1 = 2m\\beta + 1<span class="math">  and the values from  </span>[(q - 1)/2, -(q - 1)/2 + m\\beta - 1]<span class="math">  are not expressible by the bound on  </span>q<span class="math"> . As the prover succeeds with probability strictly larger than  </span>2^{-\\kappa}<span class="math">  to represent all  </span>v_{i}<span class="math">  as bits, it must hold by Lemma 7 that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; 2m\\beta + 4$  and the claim follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">SIMULATABLE: The set  <span class="math">Y</span>  is fixed for all instances.  <span class="math">\\tau_{\\mathcal{P}}</span>  consists of bits  <span class="math">b_j^i</span>  which are the XOR of the bit decomposition of the secret  <span class="math">\\mathbf{u}[i] + m\\beta</span>  with uniformly random bits  <span class="math">x_j^i</span>  and thus perfectly simulatable.</p>

    <p class="text-gray-300">|   | Cut-and-Choose  |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">τ</td>

            <td class="px-3 py-2 border-b border-gray-700">Comm. of P (in KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">τ</td>

            <td class="px-3 py-2 border-b border-gray-700">Comm. of P (in KB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">31 + 0.123 · ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">61.1+0.246·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">22.4+0.069·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">44.8+0.144·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">20.7+0.051·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">42+0.114·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">23.4+0.057·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">41.5+0.096·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">23.8+0.051·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">50.4+0.114·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">26+0.051·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">53+0.108·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1: Parameters used in the experiments for  <span class="math">\\Pi_{\\mathrm{clc}}</span>  and argument size per parameter set as a function of  $\\rho = m \\cdot \\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The circuit we obtain has  <span class="math">m + \\kappa (r + 1)</span>  inputs, one square gate and  <span class="math">\\kappa +2</span>  outputs. Then the total communication of this argument when using  <span class="math">\\Pi_{\\mathrm{sac}}^{\\mathrm{samp}}</span>  is base  <span class="math">+\\log_2q\\cdot M(m + \\kappa (r + 2) + 5)</span>  bits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We ran extensive experiments to measure the performance of our two protocols for the Binary-SIS problem. As setup we used Amazon C5.9xlarge instances using two servers with Intel Platinum 8000 series processors (Skylake-SP) which have clock speed up to 3.4 GHZ, 36 virtual cores per server (utilized based on the experiment setup) and 72 Gb RAM. The network bandwidth between the nodes is 10Gpbs. For our implementation we used only the baseline construction for the Binary-SIS problem presented in Section 5.1. Nevertheless, this includes the three general optimizations described in Section 3.4. Hash functions as well as commitments were implemented using SHA-256. Generation of pseudo-randomness from a seed was done using AES in counter-mode where the seed is the AES key. Thus,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{hash}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 256<span class="math">  bits and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sd}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 128$  bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We used five sets of parameters for our experiments:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.  $\\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 15<span class="math"> ,  </span>n = 256<span class="math">  and  </span>m = 1024$ ;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3.  $\\log_2</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">= 31<span class="math"> ,  </span>n = 512<span class="math">  and  </span>m = 2048$ ;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4.  $\\log_2</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">= 59<span class="math"> ,  </span>n = 1024<span class="math">  and  </span>m = 4096$ ; and</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5.  $\\log_2</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">= 61<span class="math"> ,  </span>n = 1024<span class="math">  and  </span>m = 4096$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first parameter set reflects SIS-based constructions that do not need any additional functionality. For example, they can be used to instantiate [KTX08] with a binary secret. The second parameter set is then used to study the impact of using a much larger message in the commitment scheme, which also shows how the matrix size impacts the runtimes. The third set would be a typical example for SIS-based constructions such as somewhat homomorphic commitments and allows to prove that a committed message is small. An example for an application would be the commitment scheme of  <span class="math">\\mathrm{[BDL^{+}18]}</span> . The last two sets are used for applications such as somewhat homomorphic encryption schemes like [BGV14].</p>

    <p class="text-gray-300">We ran experiments for 40 and 80 bits of statistical security  <span class="math">\\kappa</span> . For the parameter  <span class="math">N</span> , i.e. the number of parties in the underlying MPC protocol, we used the values 2, 4, 8, 16, 32 and 64. Then, given the desired level of security and  <span class="math">N</span>  we searched for the parameters for each protocol that minimized the overall cost.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In  <span class="math">\\Pi_{\\mathrm{clc}}</span> , there are two parameters to define:  <span class="math">M</span>  (number of pre-processing executions) and  <span class="math">\\tau</span>  (number of pre-processing executions to open). To obtain these, we wrote a script that finds the minimal  <span class="math">M</span>  and  <span class="math">\\tau</span>  such that  <span class="math">\\xi(M, N, \\tau) \\leq 2^{-40}</span>  or  <span class="math">2^{-80}</span> . In  <span class="math">\\Pi_{\\mathrm{sac}}</span> , we observe that for our choices of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>N<span class="math"> , it holds that  </span>\\frac{3N +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 3}{N \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\approx \\frac{1}{N}<span class="math">  and so it suffices to choose  </span>M<span class="math">  such that  </span>\\xi(M, N) \\approx \\frac{1}{N^M} \\leq 2^{-40}<span class="math">  or  </span>2^{-80}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We summarize the parameters used in our experiments in Tables 1, 2. In addition, for each set of parameters we give the size of the argument in Kbits as a formula of the SIS problem parameters  $\\rho = m\\cdot \\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Sacrificing  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">Comm. of P (in KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">Comm. of P (in KB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">26.2+0.16·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">51.8+0.32·ρ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">16+0.08·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">31.3+0.16·ρ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">13.2+0.056·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">24.8+0.108·ρ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">10.9+0.04·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">21.2+0.08·ρ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9.9+0.032·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">19.1+0.064·ρ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">9.6+0.028·ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">18.6+0.056·ρ</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 2: Parameters used in the experiments for  <span class="math">\\Pi_{\\mathrm{sac}}</span>  and argument size per parameter set as a function of  $\\rho = m \\cdot \\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cut-and-Choose</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sacrificing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">τ</td>

            <td class="px-3 py-2 border-b border-gray-700">time</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">73.2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">295.8</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">252.3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">1010.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">1204.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that as the number of parties  <span class="math">N</span>  grows, the number of MPC instances in  <span class="math">\\varPi_{\\mathrm{sac}}</span>  becomes much smaller than the number required in  <span class="math">\\varPi_{\\mathrm{c\\&amp;amp; c}}</span> , which is translated to smaller proof size. This implies that our new 'sacrificing'-based approach outperforms the 'cut-and-choose'-based method for arithmetic circuits over large fields.</p>

    <p class="text-gray-300">Running times. In Table 3 we present the running times (in Msec.) of the two protocols for 40 bits of security respectively whereas the runtime for 80 bits can be found in Table 4. In Fig. 9 we present the running time as a function of the number of threads used. This experiment was ran only with the MPC instances that gave the best results in Table 3 and Table 4.</p>

    <p class="text-gray-300">Table 3: Best running times in MSec for different sets of SIS parameters,  <span class="math">\\kappa = 40</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cut-and-Choose</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sacrificing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">τ</td>

            <td class="px-3 py-2 border-b border-gray-700">time</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">time</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">118.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">589.2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">507.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">505.4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">436.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">2000.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">2138.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">2396.8</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">2432.3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Best running times in MSec for different sets of SIS problem parameters,  <span class="math">\\kappa = 40</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 9: Running time in Msec. as a function of the number of threads used, for the instance with the parameters:  <span class="math">\\rho = 61</span> ,  <span class="math">n = 1024</span> ,  <span class="math">m = 4096</span>  and  <span class="math">N = 2</span></p>

    <p class="text-gray-300">For each set of parameters for the SIS problem we report only the best running times achieved together with the MPC protocol parameters which lead to the result. As the number of non-linear gates in this circuit is small, it is not surprising that both schemes achieve similar results. Observe that small numbers of parties in the MPC protocol lead to faster running times, in contrast to proof size which is getting smaller when the number of parties is increased.</p>

    <p class="text-gray-300">It is worth noting that a major source of improvement we discovered was to postpone the modular reduction in the matrix multiplication to the end. That is, when the prover/verifier multiply a row in the matrix  <span class="math">\\mathbf{A}</span>  with a vector of shares of  <span class="math">\\mathbf{s}</span>  (which is eventually what the computed circuit does), it is highly beneficial to do the reduction modulo  <span class="math">q</span>  only at the end of the matrix multiplication. This simple optimization alone yields an improvement of approximately  <span class="math">33\\%</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using Multi-threads. The above results were obtained using a single thread. As computation time is the bottleneck, we examined what happens when working with multiple threads which seems to be a straightforward optimization. This experiment was run for the "toughest" instance of the SIS problem, with  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 61<span class="math"> ,  </span>n = 1024<span class="math">  and  </span>m = 4096<span class="math">  and with the MPC protocol parameters who yielded the best running time in Table 3. As we discovered, using two threads already cut the running time by half and using 20 threads speeds-up the runtime by more than  </span>80\\%$ . As a consequence, we obtain a ZKAoK that runs in less than 0.5 seconds even for the of SIS instance with the largest parameters. This is orders of magnitude faster than any previous implementation for arithmetic circuits of the same size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Faster Matrix Products &amp; Structured Lattices. In this work we solely focus on unstructured matrices  <span class="math">\\mathbf{A}</span>  for SIS. By micro-benchmarking the results, we observe that as the size of the matrix  <span class="math">\\mathbf{A}</span>  grows, the time spent on computing the matrix multiplication becomes dominant. In particular, for the large instances, matrix multiplication takes  <span class="math">&amp;gt;85\\%</span>  of the overall local computation time. As we use only textbook matrix multiplication, this leaves plenty of room for improvement. Furthermore, on the verifier side it is possible to batch the matrix multiplications together as only verification is needed. Another direction would be to use structured matrices i.e. structured lattices, which opens the door for FFT-like algorithms.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈ 232 Binary</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈ 232 β = 15</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈ 261 Binary</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈ 261 β = 15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Stern [Ste96]</td>

            <td class="px-3 py-2 border-b border-gray-700">971 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">7285 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">3703 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">27775 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero [AHIV17]</td>

            <td class="px-3 py-2 border-b border-gray-700">45 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">55 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">55 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">80 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ours, baseline</td>

            <td class="px-3 py-2 border-b border-gray-700">357KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2138 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1359KB</td>

            <td class="px-3 py-2 border-b border-gray-700">8148 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ours, amortized</td>

            <td class="px-3 py-2 border-b border-gray-700">179 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1069 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">680 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">4075 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Proof sizes for Binary-SIS and 5-bit secrets, small constant slack,  <span class="math">\\kappa = 40</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈ 261, Binary</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈ 261, β = 15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Stern [Ste96]</td>

            <td class="px-3 py-2 border-b border-gray-700">11851 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">88882 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero [AHIV17]</td>

            <td class="px-3 py-2 border-b border-gray-700">200 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">267 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ours, baseline</td>

            <td class="px-3 py-2 border-b border-gray-700">4077 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">24461 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ours, amortized</td>

            <td class="px-3 py-2 border-b border-gray-700">2041 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">12225 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Proof sizes for Binary-SIS and secrets of 5-bit size, small constant slack,  <span class="math">\\kappa = 128</span></p>

    <p class="text-gray-300">The landscape for (lattice-based) ZK arguments has drastically changed during the past years. We will now describe how our protocol compares with other state-of-the-art arguments of knowledge in terms of communication, computation time, accuracy of the proof and the cryptographic assumptions. As most of existing work focuses only on minimizing the proof size, we can only estimate in many cases what will be the running time compared to ours. For this section, we used  <span class="math">N = 16</span>  parties in underlying MPC protocol for our scheme and set  <span class="math">M</span>  accordingly to achieve the desired soundness. We stress that it is possible to further increase the number of parties in the underlying MPC and reduce the proof size even more, but at the cost of increasing also the running time.</p>

    <p class="text-gray-300">Protocols for exact SIS. We subsume all protocols that prove the exact solution here. These are either based on Stern-type arguments [LNSW13], direct applications of MPC-in-the-head/IOP [AHIV17,BCR+19] or special-purpose protocols [BLS19,Beu19,YAZ+19]. Though STARKs [BBHR19] fall into the second category, we do not consider those as related work as they are rather tailored to computations with looping components. While [LNSW13] is a specific technique tailored to problems such as SIS, [AHIV17,BCR+19] require an arithmetic circuit (similar to us) for the verification of the statement. The comparison in term of proof size to these works is presented in Table 5 for 40 bits of statistical security whereas Table 6 presents the proof sizes for 128-bit of soundness. Recall that 'baseline' refers to baseline protocol from Section 5.1 while 'amortized' refer to the protocol with the 'amortizing bit tests' optimization from Section 5.3.</p>

    <p class="text-gray-300">We did not include proof sizes for the Aurora protocol  <span class="math">\\left[\\mathrm{BCR}^{+}19\\right]</span> , as the authors there did not provide a general expression for the proof size, but rather experimental results for the binary field  <span class="math">\\mathbb{F}_{2^{192}}</span> . Nevertheless, we expect them to be comparable to the sizes reported for [AHIV17]. We note that the prover running time according to their experiments is  <span class="math">\\approx 200\\mathrm{s}</span> , and so is expected to be at least one order of magnitude bigger than in our protocols. The same applies to Ligero [AHIV17], which requires extensive FFT computations for large polynomials, which cause the prover's running time to be much higher than ours. We thus conclude that these approaches, which achieve sun-linear communication, outperform our approach in the non-interactive setting. However, in the interactive setting- for example, when used as a building block in a larger interactive protocol (that use e.g. lattice-based commitments) with strong runtime requirements then our computationally efficient prover is advantageous. Concurrently to this work, the works of [BLS19,Beu19,YAZ  <span class="math">^{+}19]</span>  have improved upon the state of the art of ZKAoK for lattice-based primitives. While it can be expected that their solutions have the same or better communication complexity than our approach for exact SIS, it is still</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Slack</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Binary SIS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIS with β = 15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sigma-protocol [Lyu12]</td>

            <td class="px-3 py-2 border-b border-gray-700">288m</td>

            <td class="px-3 py-2 border-b border-gray-700">184 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">223 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ours, Approach 1 (κ = 8)</td>

            <td class="px-3 py-2 border-b border-gray-700">400m</td>

            <td class="px-3 py-2 border-b border-gray-700">100 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">100 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ours, Approach 2 (κ = 8)</td>

            <td class="px-3 py-2 border-b border-gray-700">< 3m</td>

            <td class="px-3 py-2 border-b border-gray-700">96 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">97 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ours, Exact</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">179 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1069 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 7: Proof sizes for non-constant slack with  $\\log_2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = 32<span class="math">  and  </span>\\kappa = 40$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">unclear what is their computational cost, as none of these works provides an implementation. Furthermore, in comparison to their work our protocols can be used to prove arbitrary statements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocols for SIS with slack. Here, we compare with the argument system from the signature scheme of Lyu12 with our baseline protocol and with the two solutions described in Section 5.4. We see that in particular the 2nd protocol of Section 5.4 improves upon Lyu12 for all three considered cases. This is particularly true in the cases where the gap between  <span class="math">\\beta</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is small, as our proof size increases as  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  grows whereas the size of Lyu12 depends on the bound  </span>\\beta<span class="math">  but not on  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  when optimized correctly. At the same time, increasing  </span>\\beta$  seems not to substantially change the communication complexity of either of our two proofs, whereas it has a direct impact on Lyu12.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Other Approaches. Recently, del Pino et al. [dPLS19] showed how to obtain a ZK argument for our problem setting. While they have a drastically smaller proof size (in the order of 1.5KB), their construction relies on the DLog assumption and is therefore not post-quantum secure. Moreover, their computational efficiency relies on using structured lattices, which we do not need. The same applies to Hyrax  <span class="math">\\left[\\mathrm{WTS}^{+}18\\right]</span> , Sonic [MBKM19] or Libra  <span class="math">\\left[\\mathrm{XZZ}^{+}19\\right]</span> , who rely on the DLog-assumption. Older ZK-SNARKs such as [PHGR16,BSCTV14] would offer low argument size and verification time but in addition to large keys and a high prover runtime also rely on very strong assumptions. Similarly, the work of  <span class="math">\\left[\\mathrm{BCC}^{+}16\\right]</span>  is also in the DLog setting. Its lattice-based variant  <span class="math">\\left[\\mathrm{BBC}^{+}18\\right]</span>  is so far not implemented, may have large hidden constants and itself uses ZKAoKs for SIS as building blocks.</p>

    <p class="text-gray-300">The authors want to thank Roey Sefi and Assi Barak for their help with the implementation as well as Carmit Hazay, Yehuda Lindell and Avishay Yanai as well as the anonymous reviewers for their helpful comments.</p>

    <p class="text-gray-300">The work of both authors was mainly done at Bar Ilan University. Both authors acknowledge support by the BIU Center for Research in Applied Cryptography and Cyber Security in conjunction with the Israel National Cyber Bureau in the Prime Minister's Office. The work of Carsten was additionally funded by the European Research Council (ERC) under the European Unions' Horizon 2020 research and innovation programme under grant agreement No 669255 (MPCPRO).</p>

    <p class="text-gray-300">AHIV17. Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017. <span class="math">\\mathrm{BBC}^{+}18</span> . Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafael del Pino, Jens Groth, and Vadim Lyubashevsky. Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits. In Advances in Cryptology - CRYPTO 2018. Springer International Publishing, 2018. BBHR19. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Advances in Cryptology - CRYPTO 2019, pages 701-732, 2019.</p>

    <p class="text-gray-300">BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, Advances in Cryptology – EUROCRYPT 2016. Springer Berlin Heidelberg, 2016. BCR^{+}19. Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Advances in Cryptology - EUROCRYPT 2019, pages 103–128, 2019. BD10. Rikke Bendlin and Ivan Damgård. Threshold decryption and zero-knowledge proofs for lattice-based cryptosystems. In Theory of Cryptography Conference. Springer, 2010. BDL^{+}18. Carsten Baum, Ivan Damgård, Vadim Lyubashevsky, Sabine Oechsner, and Chris Peikert. More efficient commitments from structured lattice assumptions. In Dario Catalano and Roberto De Prisco, editors, Security and Cryptography for Networks, Cham, 2018. Springer International Publishing. BDLN16. Carsten Baum, Ivan Damgård, Kasper Green Larsen, and Michael Nielsen. How to prove knowledge of small secrets. In Annual Cryptology Conference. Springer, 2016. Bea91. Donald Beaver. Efficient multiparty protocols using circuit randomization. In Annual International Cryptology Conference. Springer, 1991. Beu19. Ward Beullens. On sigma protocols with helper for mq and pkp, fishy signature schemes and more. Cryptology ePrint Archive, Report 2019/490, 2019. https://eprint.iacr.org/2019/490. BGV14. Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. ACM Transactions on Computation Theory (TOCT), 6(3), 2014. BHR12. Mihir Bellare, Viet Tung Hoang, and Phillip Rogaway. Foundations of garbled circuits. In Proceedings of the 2012 ACM Conference on Computer and Communications Security. ACM, 2012. BJM19. Christian Badertscher, Daniel Jost, and Ueli Maurer. Agree-and-prove: Generalized proofs of knowledge and applications. Cryptology ePrint Archive, Report 2019/662, 2019. https://eprint.iacr.org/2019/662. BL17. Carsten Baum and Vadim Lyubashevsky. Simple amortized proofs of shortness for linear relations over polynomial rings, 2017. https://eprint.iacr.org/2017/759. BLS19. Jonathan Bootle, Vadim Lyubashevsky, and Gregor Seiler. Algebraic techniques for short(er) exact lattice-based zero-knowledge proofs. In Advances in Cryptology - CRYPTO 2019, pages 176–202, 2019. BSCTV14. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In USENIX Security Symposium, 2014. DFMS19. Jelle Don, Serge Fehr, Christian Majenz, and Christian Schaffner. Security of the fiat-shamir transformation in the quantum random-oracle model. In Advances in Cryptology - CRYPTO 2019, pages 356–383, 2019. DN19. Itai Dinur and Niv Nadler. Multi-target attacks on the picnic signature scheme and related protocols. In Advances in Cryptology - EUROCRYPT 2019, pages 699–727, 2019. dPLS19. Rafaël del Pino, Vadim Lyubashevsky, and Gregor Seiler. Short discrete log proofs for FHE and ring-lwe ciphertexts, 2019. DPSZ12. Ivan Damgård, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. Multiparty computation from somewhat homomorphic encryption. In Advances in Cryptology - CRYPTO 2012, 2012. FS86. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Advances in Cryptology - CRYPTO ’86, 1986. GMO16. Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster zero-knowledge for boolean circuits. In USENIX Security Symposium, 2016. GMR89. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on computing, 18(1), 1989. IKOS07. Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge from secure multiparty computation. In Proceedings of the thirty-ninth annual ACM Symposium on Theory of Computing. ACM, 2007. KKW18. Jonathan Katz, Vladimir Kolesnikov, and Xiao Wang. Improved non-interactive zero knowledge with applications to post-quantum signatures. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS 2018, 2018. KTX08. Akinori Kawachi, Keisuke Tanaka, and Keita Xagawa. Concurrently secure identification schemes based on the worst-case hardness of lattice problems. In International Conference on the Theory and Application of Cryptology and Information Security. Springer, 2008. LN17. Yehuda Lindell and Ariel Nof. A framework for constructing fast MPC over arithmetic circuits with malicious adversaries and an honest-majority. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS 2017, 2017.</p>

    <p class="text-gray-300">LNSW13. San Ling, Khoa Nguyen, Damien Stehlé, and Huaxiong Wang. Improved zero-knowledge proofs of knowledge for the isis problem, and applications. In Public-Key Cryptography – PKC 2013. Springer, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lyu12. Vadim Lyubashevsky. Lattice signatures without trapdoors. In Annual International Conference on the Theory and Applications of Cryptographic Techniques. Springer, 2012.</li>

      <li>MBKM19. Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, pages 2111–2128, 2019.</li>

      <li>PHGR16. Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. Communications of the ACM, 59(2), 2016.</li>

      <li>Ste96. Jacques Stern. A new paradigm for public key identification. IEEE Transactions on Information Theory, 42(6), 1996.</li>

      <li>WTS^{+}18. Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zksnarks without trusted setup. In 2018 IEEE Symposium on Security and Privacy, SP 2018, Proceedings, 2018.</li>

      <li>XZZ^{+}19. Tiacheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In Annual International Cryptology Conference, pages 733–764. Springer, 2019.</li>

      <li>YAZ^{+}19. Rupeng Yang, Man Ho Au, Zhenfei Zhang, Qiuliang Xu, Zuoxia Yu, and William Whyte. Efficient lattice-based zero-knowledge arguments with standard soundness: Construction and applications. In Advances in Cryptology - CRYPTO 2019, pages 147–175, 2019.</li>

    </ul>`;
---

<BaseLayout title="Concretely-Efficient Zero-Knowledge Arguments for Arithmetic... (2019/532)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/532
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
