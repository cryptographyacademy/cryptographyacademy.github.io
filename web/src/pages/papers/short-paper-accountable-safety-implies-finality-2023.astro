---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1301';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Short Paper: Accountable Safety Implies Finality';
const AUTHORS_HTML = 'Joachim Neu, Ertem Nusret Tas, David Tse';

const CONTENT = `    <p class="text-gray-300">Joachim Neu Ertem Nusret Tas David Tse</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Motivated by proof-of-stake (PoS) blockchains such as Ethereum, two key desiderata have recently been studied for Byzantine-fault tolerant (BFT) state-machine replication (SMR) consensus protocols: <em>Finality</em> means that the protocol retains consistency, as long as less than a certain fraction of validators are malicious, even in <em>partially-synchronous</em> environments that allow for temporary violations of assumed network delay bounds. <em>Accountable safety</em> means that in any case of inconsistency, a certain fraction of validators can be <em>identified</em> to have <em>provably</em> violated the protocol. Earlier works have developed impossibility results and protocol constructions for these properties separately. We show that accountable safety implies finality, thereby unifying earlier results.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Consensus.</h4>

    <p class="text-gray-300">The purpose of a consensus protocol for state-machine replication (SMR) is for a set of parties to reach agreement on how to sequence incoming transactions into a linear order called a <em>ledger</em>. This task is non-trivial because communication between parties might be delayed, and some parties might deviate from the protocol in an arbitrary manner (<em>Byzantine faults</em>) with the goal to undermine consensus. A consensus protocol is <em>secure</em> if even in the presence of these disturbances, it guarantees two complementary properties: <em>safety</em>, meaning that the ledgers output by non-faulty parties across time are consistent, and <em>liveness</em>, meaning that transactions make it to the output ledger ‘soon’. The protocol is then called Byzantine-fault tolerant (BFT), and the fraction of faulty parties it can tolerate while remaining secure is called its <em>resilience</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Finality.</h4>

    <p class="text-gray-300">This basic formulation has been extended in two directions. On the one hand, while some early consensus protocols <em>[9]</em> assume that network communication <em>always</em> obeys a <em>known</em> delay upper-bound (<em>i.e.</em>, <em>synchronous network</em> <em>[17]</em>), later constructions <em>[10, 5]</em> pushed to strengthen security to ensure consistency also under temporary network delay-bound violations (<em>i.e.</em>, <em>partially-synchronous network</em> <em>[10]</em>). Such periods of asynchrony might be caused, for instance, by temporary network partitions. The strengthened safety property that ensures consistency also under periods of asynchrony is called <em>finality</em> <em>[3, 24]</em>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Accountable Safety.</h4>

    <p class="text-gray-300">On the other hand, consensus protocols for proof-of-stake (PoS) blockchains such as Ethereum seek to strengthen safety to enable <em>accountability</em> <em>[3, 4, 25, 24, 29, 21, 7, 2, 13, 14, 27]</em>. In permissionless blockchains, parties</p>

    <p class="text-gray-300">are no longer inanimate computers which might exhibit technical faults but are otherwise aligned under the control of one organizational entity. Instead, parties are controlled by different mutually distrusting self-interested players that might deviate from the protocol if they expect a profit from doing so. In this setting, it was proposed to strengthen safety to <em>accountable safety</em>, where besides ensuring consistency up to some adversarial resilience, if the adversary exceeds that resilience and causes a safety violation, then a certain fraction of parties can also be identified to have provably violated the protocol.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Prior Works.</h4>

    <p class="text-gray-300">Various works have studied the fundamental limits of finality <em>[11, 10, 12]</em> and of accountable safety <em>[29]</em>, as well as their relationships to other desiderata such as liveness under dynamic participation <em>[16, 25]</em>, and how protocols can be constructed that achieve various combinations of these properties <em>[24, 25]</em>. While finality and accountable safety ‘feel similar’, characterizing their exact relation has remained open. For instance, some protocols provide finality but do not provide accountable safety <em>[29, 22]</em>. On the other hand, we readily observe (details in Section 5) that an additional round of voting to ‘checkpoint’ the output ledger of a consensus protocol designed for synchronous networks can also be used to upgrade that ledger to provide accountable safety, but does not yield a protocol for partially-synchronous networks. In particular, the so-extended protocol may not recover from liveness faults induced during a period of asynchrony (Section 5).</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Main Result.</h4>

    <p class="text-gray-300">We show that accountable safety implies finality (Section 3). To this end, on a high level, we show that for any given protocol, if there exists an adversary strategy that leads to a safety violation under partial synchrony, then there exists an adversary strategy that leads to a safety violation but not enough adversary parties can be identified as protocol violators, even if the network is delay-free, <em>i.e.</em>, messages arrive instantly. Intuitively, the more constraints there are on network delays, the easier it is for a protocol to guarantee accountable safety. Our argument shows that even the weakest form of accountable safety, namely for delay-free networks, is still so strong that it implies finality.</p>

    <p class="text-gray-300">Our result unifies prior works and directs future work (Section 4): The availability–accountability dilemma <em>[25]</em> turns out to be implied by the availability–finality dilemma <em>[24]</em>, a blockchain-variant of the CAP theorem <em>[12, 16]</em>. Impossibilities for accountability and liveness resiliences <em>[29]</em> turn out to be implied by impossibilities for consensus under partial synchrony <em>[10]</em>. Upgrading a ledger to provide accountable safety <em>[25, 21]</em> implies adding finality <em>[3, 28, 31, 8, 30, 19]</em>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2 Model</h2>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Notation.</h4>

    <p class="text-gray-300">For <span class="math">m\\in\\mathbb{N}</span>, let <span class="math">[m]\\triangleq\\{1,2,...,m\\}</span>. An event happens with probability <em>negligible</em> in the security parameter <span class="math">\\lambda</span> if its probability is <span class="math">o(1/\\operatorname{poly}(\\lambda))</span>.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Replicas and Clients.</h4>

    <p class="text-gray-300">SMR consensus protocols have two types of participants: <em>replicas</em> and <em>clients</em>. Replicas are input <em>transactions</em> by the environment, interact</p>

    <p class="text-gray-300">with each other towards agreeing on how these transactions should be ordered, and make some protocol messages (<em>e.g.</em>, blocks, votes) available to clients upon request. <em>Clients</em> query replicas for these protocol messages, and, upon collecting messages from a sufficiently large subset of replicas, output a sequence of transactions called the <em>ledger</em> and denoted by <span class="math">\\mathsf{LOG}</span>. The goal of the SMR protocol is to ensure that clients agree on a single ever-growing transaction sequence.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Environment and Adversary.</h4>

    <p class="text-gray-300">Each of the <span class="math">n</span> replicas has a (unique) cryptographic identity that is known to all parties. Up to <span class="math">f</span> replicas can be corrupted at the beginning of the protocol execution by a computationally-bounded <em>adversary</em> <span class="math">\\mathcal{A}</span>, which then obtains the internal state of these replicas, and can make them deviate from the protocol in arbitrary ways (Byzantine faults). The remaining <span class="math">(n-f)</span> replicas are <em>honest</em> and follow the protocol as specified.</p>

    <p class="text-gray-300">Time proceeds in slots. Replicas can exchange messages, subject to adversary delays. We consider a <em>partially-synchronous network</em> with adversary-environment tuple <span class="math">(\\mathcal{A}_{\\mathrm{p}},\\mathcal{Z}_{\\mathrm{p}})</span>, where the adversary can delay messages arbitrarily until a <em>global stabilization time</em> <span class="math">\\mathsf{GST}</span> that can be chosen adaptively by the adversary. After <span class="math">\\mathsf{GST}</span>, <span class="math">\\mathcal{A}_{\\mathrm{p}}</span> has to deliver messages within a delay upper-bound of <span class="math">\\Delta</span> which is known to the protocol. If <span class="math">\\mathsf{GST}</span> is known and zero, then the network is said to be <em>synchronous</em>, and denoted by <span class="math">(\\mathcal{A}_{\\mathrm{s}},\\mathcal{Z}_{\\mathrm{s}})</span>. Furthermore, a network is called <em>delay-free</em> and denoted by <span class="math">(\\mathcal{A}_{\\mathrm{i}},\\mathcal{Z}_{\\mathrm{i}})</span> if all messages reach their recipients instantaneously, <em>i.e.</em>, the network is synchronous with <span class="math">\\Delta=0</span>. The three network models are ordered in the sense that from partial synchrony to synchrony to delay-freeness, for fixed <span class="math">\\Delta</span>, the adversary’s capabilities are strictly increasingly constrained.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Safety and Liveness Resiliences.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathsf{LOG}^{\\mathsf{cl}}_{t}</span> denote the ledger in the view of a client <span class="math">\\mathsf{cl}</span> at time slot <span class="math">t</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 1</h6>

    <p class="text-gray-300">A consensus protocol is <em>secure</em> with confirmation time <span class="math">T_{\\mathrm{conf}}</span> iff:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Safety: For all <span class="math">t,t^{\\prime}</span> and <span class="math">\\mathsf{cl},\\mathsf{cl}^{\\prime}</span>, either <span class="math">\\mathsf{LOG}^{\\mathsf{cl}}_{t}</span> is a prefix of <span class="math">\\mathsf{LOG}^{\\mathsf{cl}^{\\prime}}_{t^{\\prime}}</span>, or vice versa.</li>

      <li>Liveness: If some <span class="math">\\mathsf{tx}</span> is input to an honest replica by some <span class="math">t</span>, then, for all <span class="math">t^{\\prime}\\geq\\max(t,\\mathsf{GST})+T_{\\mathrm{conf}}</span>, and all <span class="math">\\mathsf{cl}</span>, <span class="math">\\mathsf{tx}\\in\\mathsf{LOG}^{\\mathsf{cl}}_{t^{\\prime}}</span>.</li>

    </ul>

    <p class="text-gray-300">A protocol is said to provide <em><span class="math">f</span>-safety (<span class="math">f</span>-liveness)</em> if the protocol satisfies safety (liveness), except with negligible probability, for any adversary controlling at most <span class="math">f</span> replicas. Here, <span class="math">f</span> is the protocol’s safety (liveness) <em>resilience</em>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2</h6>

    <p class="text-gray-300">A consensus protocol satisfies <em><span class="math">f</span>-finality</em> (<em>i.e.</em>, is <em><span class="math">f</span>-final</em>) if it satisfies <span class="math">f</span>-safety under a partially-synchronous network.</p>

    <p class="text-gray-300">Note that <span class="math">f</span>-finality does not imply <span class="math">f</span>-liveness after <span class="math">\\mathsf{GST}</span>. An <span class="math">f</span>-final protocol may not be secure under partial synchrony due to liveness violations (cf. Section 5).</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Accountable-Safety Resilience.</h4>

    <p class="text-gray-300">Building on <em><span class="math">\\alpha</span>-accountable-safety</em> <em>[3, 21]</em>, the accountable-safety resilience of a protocol is defined (see <em>[25]</em> for details on replica–client interaction and forensic algorithm, there called ‘adjudication function’):</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 3</h6>

    <p class="text-gray-300">A consensus protocol provides <em>accountable safety</em> with resilience <span class="math">f_{\\mathrm{a}}</span> (<em>i.e.</em>, is <em><span class="math">f_{\\mathrm{a}}</span>-accountable safe</em>) iff whenever there is a safety violation, except with negligible probability, (i) at least <span class="math">f_{\\mathrm{a}}</span> adversarial replicas are identified by a <em>forensic algorithm</em> as protocol violators, and (ii) no honest replica is identified.</p>

    <p class="text-gray-300">Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> World 0</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> World 1 Fig.1. Execution of a consensus protocol with four replicas. World 0 is partially-synchronous, worlds 1, 2 and 3 are delay-free. Red replica  <span class="math">P_4</span>  is adversary in all worlds. Orange replicas are adversary but do not violate the protocol rules other than delaying the sending/receiving of messages to/from the honest replica. Green replicas are honest.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> World 2</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> World 3</p>

    <p class="text-gray-300">Specifically, if clients  <span class="math">\\mathsf{cl},\\mathsf{cl}^{\\prime}</span>  at  <span class="math">t,t^{\\prime}</span>  disagree on the output ledger, they exchange the protocol messages that led to their respective  <span class="math">\\mathsf{LOG}_t^{\\mathsf{cl}},\\mathsf{LOG}_{t&#x27;}^{\\mathsf{cl}&#x27;}</span> . Given a set of messages such that there are two subsets based on which a client would confirm two conflicting ledgers, each client can invoke the protocol's forensic algorithm to identify  <span class="math">f_{\\mathrm{a}}</span>  replicas who have provably violated the protocol [29]. Note that the functioning of the forensic algorithm is not conditional on assumptions such as a fraction of replicas being honest, and it does not falsely accuse honest replicas.</p>

    <p class="text-gray-300">By Definition 3, if a protocol provides  <span class="math">(f + 1)</span> -accountable safety under partial synchrony (which is the strongest form of accountable safety, considering that among the models considered here, the adversary's capabilities are least constrained in the partially-synchronous model), then it also satisfies safety under partial synchrony with up to  <span class="math">f</span>  adversary replicas, i.e., it is  <span class="math">f</span> -final. (This is because if the number of adversary replicas is less than  <span class="math">f + 1</span> , the forensic algorithm cannot identify at least  <span class="math">f + 1</span>  adversary replicas, implying that the protocol must be safe.) Perhaps more surprisingly, Theorem 1 below proves that if a protocol provides  <span class="math">(f + 1)</span> -accountable safety in a delay-free network (which is the weakest form of accountable safety, since the adversary's capabilities are most constrained in the delay-free network model), it must still be the case that the protocol is  <span class="math">f</span> -final. This immediately implies that for all network delay models,  <span class="math">(f + 1)</span> -accountable safety of a protocol implies  <span class="math">f</span> -finality for that protocol.</p>

    <p class="text-gray-300">Theorem 1. If a consensus protocol provides  <span class="math">(f + 1)</span> -accountable safety in a delay-free network, then it also satisfies  <span class="math">f</span> -finality.</p>

    <p class="text-gray-300">Intuition. For intuition, consider the scenario with  <span class="math">n = 4, f = 1</span> . We argue the equivalent claim that without 1-finality, there is no 2-accountable safety. For contradiction, consider a consensus protocol executed by four replicas  <span class="math">P_{i}</span> ,  <span class="math">i \\in [4]</span> , that is not 1-final, yet 2-accountable safe under a delay-free network.</p>

    <p class="text-gray-300">Consider the following executions: In world 0 (Figure 1), the network is partially-synchronous, and  <span class="math">P_4</span>  (red in Figure 1) is adversary. Besides protocol deviations of  <span class="math">P_4</span> , the adversary delays messages among honest replicas to cause</p>

    <p class="text-gray-300">a safety violation (which is possible because the protocol is assumed not 1-final). In worlds 1, 2, and 3 (Figure 1), the network is delay-free, and there are three adversary replicas. The replica <span class="math">P_{4}</span> is adversary, and in all of these worlds behaves the same as in world 0. The remaining adversary replicas (orange in Figure 1) behave like their honest counterparts in world 0, except they emulate the message delivery schedule an honest replica would have had in their place in world 0, by delaying the sending/receiving of messages to/from the honest replica. Clients observing the protocol cannot distinguish between any of the worlds 0, 1, 2, and 3. Therefore, there is a safety violation in worlds 1, 2, and 3 as well.</p>

    <p class="text-gray-300">Finally, since the protocol is assumed to be 2-accountable safe in a delay-free network, the forensic algorithm called by the clients identifies 2 replicas as protocol violators in each of the worlds 1, 2 and 3. However, as these worlds are indistinguishable, there is a non-negligible probability that the forensic algorithm wrongly identifies an honest replica, which is a contradiction, as desired.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof (of Theorem 1)</h6>

    <p class="text-gray-300">We prove the contrapositive. For contradiction, suppose a protocol does not satisfy <span class="math">f</span>-finality, yet provides <span class="math">(f+1)</span>-accountable safety under a delay-free network. We consider a world 0 with a partially-synchronous network, and <span class="math">n-f</span> worlds indexed by <span class="math">i\\in[n-f]</span> with delay-free networks.</p>

    <p class="text-gray-300">World 0: Consider clients cl, cl^{′} and <span class="math">n</span> replicas. The network is partially-synchronous and the adversary <span class="math">\\mathcal{A}_{\\mathrm{p}}</span> controls <span class="math">f</span> replicas, denoted by <span class="math">P_{n-f+1},\\ldots,P_{n}</span>. The remaining replicas are honest. Safety is violated and the clients cl and cl^{′} output conflicting ledgers with some non-negligible probability.</p>

    <p class="text-gray-300">World <span class="math">i</span>: Consider clients cl, cl^{′} and <span class="math">n</span> replicas. The network is delay-free and the adversary <span class="math">\\mathcal{A}_{\\mathrm{s}}^{(i)}</span> of world <span class="math">i</span> corrupts all replicas except <span class="math">P_{i}</span>. The <span class="math">f</span> replicas that were adversary in world 0 behave the same as in world 0. The remaining adversary replicas behave like the corresponding honest replicas in world 0, except they also emulate the network delay of world 0: For each message sent by <span class="math">P_{i}</span>, adversary replicas pretend as if the message was delivered at the time slot in which it was delivered in world 0, even though it was in fact delivered instantly in world <span class="math">i</span>. Adversary replicas also send the same messages to <span class="math">P_{i}</span> as in world 0, but they ensure that these messages are delivered to <span class="math">P_{i}</span> at the same time slots within world <span class="math">i</span> as they were delivered in world 0, by delaying the sending if necessary (after delayed sending, the delay-free network will deliver them instantly).</p>

    <p class="text-gray-300">As <span class="math">P_{i}</span> receives the same messages at the same time slots in world <span class="math">i</span> and world 0, it cannot distinguish the worlds, and <span class="math">P_{i}</span> shows the same behavior in both.</p>

    <p class="text-gray-300">As the adversary replicas simulate their behavior from world 0 within world <span class="math">i</span>, and <span class="math">P_{i}</span> shows the same behavior in both worlds, cl and cl^{′} cannot distinguish the two worlds 0 and <span class="math">i</span>. Thus, they output conflicting ledgers with non-negligible probability. In this case, by the assumed <span class="math">(f+1)</span>-accountable safety of the protocol under delay-free networks, the forensic algorithm, invoked with the information received by these clients from the replicas, identifies at least <span class="math">f+1</span> replicas as protocol violators in world <span class="math">i</span> with non-negligible probability.</p>

    <p class="text-gray-300">Finally, since the two worlds 0 and <span class="math">i</span> are indistinguishable for cl and cl^{′} for all <span class="math">i</span>, the worlds <span class="math">i\\in[n-f]</span> are indistinguishable as well for cl and cl^{′}. Thus, as</p>

    <p class="text-gray-300">long as <span class="math">n=O(\\mathrm{poly}(\\lambda))</span>, the forensic algorithm has a non-negligible probability to falsely accuse an honest replica, which is a contradiction. ∎</p>

    <p class="text-gray-300">Theorem 1 holds even if the forensic algorithm were to know whether the network is partially-synchronous or delay-free (while we block clients and replicas from learning this). In the proof above, indistinguishability between worlds <span class="math">0</span> and <span class="math">i</span> is used to infer that (i) safety is violated in world <span class="math">i</span> as it is in world <span class="math">0</span>, and (ii) worlds <span class="math">i,j&gt;0</span> are indistinguishable, and thus an honest replica is likely falsely accused. The argument for (i) remains, but since the forensic algorithm can now distinguish worlds <span class="math">0</span> and <span class="math">i</span>, we must argue for (ii) directly. Indeed, as worlds <span class="math">i,j&gt;0</span> are all delay-free, and this is the only extra information given to forensic algorithm, worlds <span class="math">i</span>, <span class="math">j</span> still cannot be distinguished by the forensic algorithm.</p>

    <h2 id="sec-20" class="text-2xl font-bold">4 Simplification of Earlier Results</h2>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">4.0.1 Impossibility of Finality <span class="math">\\implies</span> Impossibility of Accountability.</h4>

    <p class="text-gray-300">Earlier work <em>[29, Theorem B.1]</em> shows that no protocol can be <span class="math">f_{\\mathrm{a}}</span>-accountable safe and <span class="math">f_{\\mathrm{l}}</span>-live for <span class="math">2f_{\\mathrm{l}}+f_{\\mathrm{a}}&gt;n</span> under a synchronous or partially-synchronous network. This result follows directly from Theorem 1, combined with the safety–liveness bound under partial synchrony (<em>[10, Theorem 4.4]</em>) restated below:</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proposition 1 (From <em>[10]</em>, see also <em>[23, 15, 18]</em>).</h6>

    <p class="text-gray-300">No protocol can satisfy <span class="math">f_{\\mathrm{s}}</span>-finality, and <span class="math">f_{\\mathrm{l}}</span>-liveness under a delay-free network, for <span class="math">2f_{\\mathrm{l}}+f_{\\mathrm{s}}\\geq n</span>.</p>

    <p class="text-gray-300">In other words, given <span class="math">f_{\\mathrm{s}}</span>, <span class="math">f_{\\mathrm{l}}</span>, <span class="math">2f_{\\mathrm{l}}+f_{\\mathrm{s}}\\geq n</span>, no protocol can simultaneously preserve its safety under asynchrony with <span class="math">f_{\\mathrm{s}}</span> adversary replicas, and remain live with <span class="math">f_{\\mathrm{l}}</span> adversary replicas, even if the network is delay-free. This is stronger than the claim that no protocol provides <span class="math">f_{\\mathrm{s}}</span>-safety and <span class="math">f_{\\mathrm{l}}</span>-liveness under partial synchrony, yet this stronger result directly follows from the proof of <em>[10, Theorem 4.4]</em>. Combining Proposition 1 with Theorem 1, one readily obtains that no protocol can be <span class="math">f_{\\mathrm{a}}</span>-accountable safe and <span class="math">f_{\\mathrm{l}}</span>-live under a synchronous network for any <span class="math">\\Delta</span>, including a delay-free network, if <span class="math">2f_{\\mathrm{l}}+f_{\\mathrm{a}}&gt;n</span>:</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">No protocol can be <span class="math">f_{\\mathrm{a}}</span>-accountable safe and <span class="math">f_{\\mathrm{l}}</span>-live, for <span class="math">2f_{\\mathrm{l}}+f_{\\mathrm{a}}&gt;n</span>, under a synchronous or partially-synchronous network, for any <span class="math">\\Delta</span>.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">4.0.2 Availability–Finality Dilemma <span class="math">\\implies</span> Availability–Accountability Dilemma.</h4>

    <p class="text-gray-300">To state the availability–accountability dilemma, we recall the formal model for dynamic participation (i.e., temporary crash faults) <em>[25, 26]</em>. Before a <em>global awake time</em> <span class="math">\\mathsf{GAT}</span>, the adversary <span class="math">\\mathcal{A}</span> can determine for every honest replica and time slot, whether the replica is <em>awake</em> (i.e., online) or <em>asleep</em> (i.e., offline) in that slot. After <span class="math">\\mathsf{GAT}</span>, all honest replicas are awake. Awake replicas follow the protocol. Asleep replicas have a <em>temporary crash fault</em>, and do not execute the protocol in the respective time slot. Adversary replicas are always awake. Messages sent to a replica while asleep are processed by the replica whenever it wakes up. The adversary-environment tuple <span class="math">(\\mathcal{A}_{\\mathrm{pda}},\\mathcal{Z}_{\\mathrm{pda}})</span> models a partially-synchronous network with <span class="math">\\mathsf{GST}&lt;\\infty</span> and <span class="math">\\mathsf{GAT}\\in[0,\\infty)</span> that can be adaptively chosen by <span class="math">\\mathcal{A}_{\\mathrm{pda}}</span></p>

    <p class="text-gray-300">and which are not known by honest replicas or the protocol designer. Let <span class="math">\\beta</span> denote the largest <em>fraction</em> across all time slots, of adversary replicas among awake replicas. Below, <span class="math">\\beta_{\\text{s}}</span>-safety, <span class="math">\\beta_{\\text{f}}</span>-liveness, <span class="math">\\beta_{\\text{f}}</span>-finality, and <span class="math">\\beta_{\\text{a}}</span>-accountable safety are defined analogously to their definitions in Section 2. Using this model, we restate the blockchain CAP theorem (<em>[16, Theorem 4.1]</em>):</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proposition 2 (From <em>[16]</em>, see also <em>[12]</em>).</h6>

    <p class="text-gray-300">No protocol provides both <span class="math">\\beta_{\\text{f}}</span>-finality and <span class="math">\\beta_{\\text{l}}</span>-liveness for any <span class="math">\\beta_{\\text{f}},\\beta_{\\text{l}}\\geq 0</span> under <span class="math">(\\mathcal{A}_{\\text{pda}},\\mathcal{Z}_{\\text{pda}})</span>.</p>

    <p class="text-gray-300">One readily obtains the availability–accountability dilemma of <em>[25]</em> as a corollary of Theorem 1 and Proposition 2.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">No protocol provides both <span class="math">\\beta_{\\text{a}}</span>-accountable safety and <span class="math">\\beta_{\\text{l}}</span>-liveness for any <span class="math">\\beta_{\\text{a}}&gt;0,\\beta_{\\text{l}}\\geq 0</span> under <span class="math">(\\mathcal{A}_{\\text{pda}},\\mathcal{Z}_{\\text{pda}})</span>.</p>

    <h2 id="sec-27" class="text-2xl font-bold">5 Finality, Accountable Safety, and Security under Partial Synchrony</h2>

    <p class="text-gray-300">We clarify the relations among finality, accountable safety, and security under partial synchrony. Specifically, even though <span class="math">(f+1)</span>-accountable safety implies <span class="math">f</span>-finality, it does not imply security under partial synchrony. To illustrate this, we consider <span class="math">n,f</span> with <span class="math">n=3f+1</span>, and construct a protocol called SyncFin that is <span class="math">(f+1)</span>-accountable safe (and <span class="math">f</span>-safe under partial synchrony by Theorem 1), yet cannot recover liveness after <span class="math">\\mathsf{GST}</span> under partial synchrony, even though it is <span class="math">f</span>-live under synchrony (the largest possible liveness resilience, cf. Corollary 1).</p>

    <p class="text-gray-300">The SyncFin protocol consists of (i) an underlay consensus protocol executed by the <span class="math">n</span> replicas and secure under synchrony (<em>e.g.</em>, Sync HotStuff <em>[1]</em>, SyncStreamlet <em>[6]</em>), and (ii) an add-on ‘gadget’ of ‘finality signatures’ on the ledgers output by the underlay protocol. The gadget works as follows: Once for the first time at some height <span class="math">h</span> a block is confirmed by the underlay protocol in the view of a replica, the replica ‘votes for’ that respective chain in the gadget by broadcasting a <em>finality signature</em> on the block to all other replicas. A replica creates at most one finality signature per height, on the first block observed to be confirmed at that height by the underlay protocol. If it later observes a conflicting block become confirmed by the underlay protocol at the same height, it does not sign that block (or any descendent thereof). Clients confirm a block of this new protocol that is a composite of the underlay and finality-signature gadget, upon observing <span class="math">2f+1</span> finality signatures on a block and its prefix. A similar add-on was contemporaneously used for unrelated problems in <em>[20, 32]</em>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">SyncFin is <span class="math">(f+1)</span>-accountable safe and <span class="math">f</span>-live under synchrony.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof (Sketch).</h6>

    <p class="text-gray-300">If clients output conflicting ledgers, they must have observed conflicting blocks at the same height, each with <span class="math">2f+1</span> finality signatures. Since signing different blocks at the same height is a protocol violation, the forensic algorithm then identifies <span class="math">f+1</span> adversarial replicas by inspecting the double-signers. Thus, SyncFin is <span class="math">(f+1)</span>-accountable safe. As the underlay protocol is</p>

    <p class="text-gray-300">Joachim Neu, Ertem Nusret Tas, and David Tse</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 2. Venn diagram of protocols satisfying finality, accountable safety, security under partial synchrony, and dynamic participation. The key Theorem 1 of this work means that accountable safe protocols are contained in the set of final protocols.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300"><span class="math">f</span> -safe and  <span class="math">f</span> -live under synchrony, SyncFin is live under synchrony if there are  <span class="math">2f + 1</span>  or more honest replicas sending finality signatures.  <span class="math">\\square</span></p>

    <p class="text-gray-300">The SyncFin protocol is, however, not live under partial synchrony with any resilience. Before GST, the adversary can, with the help of a single adversary replica, cause two honest replicas to confirm conflicting, different blocks in the underlay, and send finality signatures on their respective blocks. After signing the blocks, the honest replicas refuse to sign any conflicting block, implying that even after GST, no block is guaranteed to receive finality signatures from  <span class="math">2f + 1</span>  replicas. Hence, SyncFin is not live after GST.</p>

    <p class="text-gray-300">We summarize the relation among protocols that satisfy finality, accountable safety, security under partial synchrony, and security under dynamic participation in Figure 2. The blue set contains protocols with  <span class="math">n = 3f + 1</span>  replicas that are  <span class="math">f</span> -final. The green set contains  <span class="math">f + 1</span> -accountable safe protocols, whereas the red one contains protocols that, in addition to being  <span class="math">f</span> -final, are also  <span class="math">f</span> -live after GST, i.e., they are  <span class="math">f</span> -secure under partial synchrony. Since  <span class="math">(f + 1)</span> -accountable safety implies  <span class="math">f</span> -finality (Theorem 1), the green set is within the blue one. By Proposition 2, no protocol is  <span class="math">\\beta_{\\mathrm{f}}</span> -final and  <span class="math">\\beta_{\\mathrm{l}}</span> -live under a dynamically available network for any  <span class="math">\\beta_{\\mathrm{f}}, \\beta_{\\mathrm{l}} \\geq 0</span> , i.e., the blue and the yellow sets do not intersect (and as a consequence, the green and yellow sets do not intersect—the availability—accountability dilemma, Corollary 2). Finally, Theorem 2 shows that SyncFin is  <span class="math">f</span> -accountable safe and  <span class="math">f</span> -live under synchrony, but as we have seen above, it is not  <span class="math">f</span> -live after GST under partial synchrony, so it is not in the red set. PBFT [5] is both  <span class="math">f</span> -accountable safe [29] and  <span class="math">f</span> -safe and live under partial synchrony. An example of a protocol that is not accountable safe, yet secure under partial synchrony is HotStuff-null [29].</p>

    <p class="text-gray-300">We thank Orfeas Stefanos Thyfronitis Litos, David Mazières, and Srivatsan Sridhar for fruitful discussions. JN, ENT and DT are supported by Ethereum Foundation and Input Output Global. JN is supported by the Protocol Labs PhD Fellowship. ENT is supported by the Stanford Center for Blockchain Research.</p>

    <p class="text-gray-300">Short Paper: Accountable Safety Implies Finality</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Abraham, I., Malkhi, D., Nayak, K., Ren, L., Yin, M.: Sync HotStuff: Simple and practical synchronous state machine replication. In: SP. pp. 106–118. IEEE (2020)</li>

      <li>[2] Buchman, E., Guerraoui, R., Komatovic, J., Milosevic, Z., Seredinschi, D., Widder, J.: Revisiting Tendermint: Design tradeoffs, accountability, and practical use. In: DSN (Supplements). pp. 11–14. IEEE (2022)</li>

      <li>[3] Buterin, V., Griffith, V.: Casper the friendly finality gadget. arXiv:1710.09437v4 [cs.CR] (2017), http://arxiv.org/abs/1710.09437v4</li>

      <li>[4] Buterin, V., Hernandez, D., Kamphefner, T., Pham, K., Qiao, Z., Ryan, D., Sin, J., Wang, Y., Zhang, Y.X.: Combining GHOST and Casper. arXiv:2003.03052v3 [cs.CR] (2020), http://arxiv.org/abs/2003.03052v3</li>

      <li>[5] Castro, M., Liskov, B.: Practical Byzantine fault tolerance. In: OSDI. pp. 173–186. USENIX Association (1999)</li>

      <li>[6] Chan, B.Y., Shi, E.: Streamlet: Textbook streamlined blockchains. In: AFT. pp. 1–11. ACM (2020)</li>

      <li>[7] Civit, P., Gilbert, S., Gramoli, V.: Polygraph: Accountable Byzantine agreement. In: ICDCS. pp. 403–413. IEEE (2021)</li>

      <li>[8] Dinsdale-Young, T., Magri, B., Matt, C., Nielsen, J.B., Tschudi, D.: Afgjort: A partially synchronous finality layer for blockchains. In: SCN. LNCS, vol. 12238, pp. 24–44. Springer (2020)</li>

      <li>[9] Dolev, D., Strong, H.R.: Authenticated algorithms for Byzantine agreement. SIAM J. Comput. 12(4), 656–666 (1983)</li>

      <li>[10] Dwork, C., Lynch, N.A., Stockmeyer, L.J.: Consensus in the presence of partial synchrony. J. ACM 35(2), 288–323 (1988)</li>

      <li>[11] Fischer, M.J., Lynch, N.A., Paterson, M.: Impossibility of distributed consensus with one faulty process. J. ACM 32(2), 374–382 (1985)</li>

      <li>[12] Gilbert, S., Lynch, N.A.: Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant web services. SIGACT News 33(2), 51–59 (2002)</li>

      <li>[13] Haeberlen, A., Kouznetsov, P., Druschel, P.: PeerReview: practical accountability for distributed systems. In: SOSP. pp. 175–188. ACM (2007)</li>

      <li>[14] Haeberlen, A., Kuznetsov, P.: The fault detection problem. In: OPODIS. LNCS, vol. 5923, pp. 99–114. Springer (2009)</li>

      <li>[15] Hirt, M., Kastrati, A., Liu-Zhang, C.: Multi-threshold asynchronous reliable broadcast and consensus. In: OPODIS. LIPIcs, vol. 184, pp. 6:1–6:16. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2020)</li>

      <li>[16] Lewis-Pye, A., Roughgarden, T.: Byzantine generals in the permissionless setting. In: FC (1). LNCS, vol. 13950, pp. 21–37. Springer (2023)</li>

      <li>[17] Lynch, N.A.: Distributed Algorithms. Morgan Kaufmann (1996)</li>

      <li>[18] Momose, A., Ren, L.: Multi-threshold Byzantine fault tolerance. In: CCS. pp. 1686–1699. ACM (2021)</li>

      <li>[19] Nakamura, R.: Hierarchical finality gadget (2020), https://ethresear.ch/t/hierarchical-finality-gadget/6829</li>

      <li>[20] Neu, J., Sridhar, S., Yang, L., Tse, D.: Optimal flexible consensus and its application to Ethereum. In: SP. IEEE (2024), https://eprint.iacr.org/2023/1211</li>

      <li>[21] Neu, J., Tas, E.N., Tse, D.: Snap-and-chat protocols: System aspects. arXiv:2010.10447v1 [cs.CR] (2020), http://arxiv.org/abs/2010.10447v1</li>

      <li>[22] Neu, J., Tas, E.N., Tse, D.: The availability-accountability dilemma and its resolution via accountability gadgets. arXiv:2105.06075v3 [cs.CR] (2021), http://arxiv.org/abs/2105.06075v3</li>

    </ul>

    <p class="text-gray-300">23] Neu, J., Tas, E.N., Tse, D.: The availability-accountability dilemma and its resolution via accountability gadgets. arXiv:2105.06075v1 [cs.CR] (2021), http://arxiv.org/abs/2105.06075v1</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[24] Neu, J., Tas, E.N., Tse, D.: Ebb-and-flow protocols: A resolution of the availability-finality dilemma. In: SP. pp. 446–465. IEEE (2021)</li>

      <li>[25] Neu, J., Tas, E.N., Tse, D.: The availability-accountability dilemma and its resolution via accountability gadgets. In: Financial Cryptography. LNCS, vol. 13411, pp. 541–559. Springer (2022)</li>

      <li>[26] Pass, R., Shi, E.: The sleepy model of consensus. In: ASIACRYPT (2). LNCS, vol. 10625, pp. 380–409. Springer (2017)</li>

      <li>[27] Ranchal-Pedrosa, A., Gramoli, V.: Blockchain is dead, long live blockchain! Accountable state machine replication for longlasting blockchain. arXiv:2007.10541v2 [cs.DC] (2020), http://arxiv.org/abs/2007.10541v2</li>

      <li>[28] Sankagiri, S., Wang, X., Kannan, S., Viswanath, P.: Blockchain CAP theorem allows user-dependent adaptivity and finality. In: Financial Cryptography (2). LNCS, vol. 12675, pp. 84–103. Springer (2021)</li>

      <li>[29] Sheng, P., Wang, G., Nayak, K., Kannan, S., Viswanath, P.: BFT protocol forensics. In: CCS. pp. 1722–1743. ACM (2021)</li>

      <li>[30] Skidanov, A.: Fast finality and resilience to long range attacks with proof of space-time and Casper-like finality gadget (2019), https://docs.near.org/vi/assets/files/PoST-dadcf9287d98201817066853315db91f.pdf</li>

      <li>[31] Stewart, A., Kokoris-Kogia, E.: GRANDPA: a Byzantine finality gadget. arXiv:2007.01560v1 [cs.DC] (2020), http://arxiv.org/abs/2007.01560v1</li>

      <li>[32] The Babylon Team: Bitcoin staking: Unlocking 21M Bitcoins to secure the proof-of-stake economy (2023), https://docs.babylonchain.io/papers/btc_staking_litepaper.pdf</li>

    </ul>`;
---

<BaseLayout title="Short Paper: Accountable Safety Implies Finality (2023/1301)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1301
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
