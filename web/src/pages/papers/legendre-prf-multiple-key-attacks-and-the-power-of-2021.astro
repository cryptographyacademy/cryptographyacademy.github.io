---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/645';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Legendre PRF (Multiple) Key Attacks and the Power of Preprocessing';
const AUTHORS_HTML = 'Alexander May, Floyd Zweydinger';

const CONTENT = `    <p class="text-gray-300">Alexander May* <span class="math">\\bullet</span>, Floyd Zweydinger Ruhr University Bochum, Germany {alex.may, floyd.zweydinger}@rub.de</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Due to its amazing speed and multiplicative properties the Legendre PRF recently finds widespread applications e.g. in Ethereum 2.0, multiparty computation and in the quantum-secure signature proposal LegRoast. However, its security is not yet extensively studied.</p>

    <p class="text-gray-300">The Legendre PRF computes for a key <span class="math">k</span> on input <span class="math">x</span> the Legendre symbol <span class="math">L_{k}(x)=\\left(\\frac{x+k}{p}\\right)</span> in some finite field <span class="math">\\mathbb{F}_{p}</span>. As standard notion, PRF security is analysed by giving an attacker oracle access to <span class="math">L_{k}(\\cdot)</span>. Khovratovich’s collision-based algorithm recovers <span class="math">k</span> using <span class="math">L_{k}(\\cdot)</span> in time <span class="math">\\sqrt{p}</span> with constant memory. It is a major open problem whether this birthday-bound complexity can be beaten.</p>

    <p class="text-gray-300">We show a somewhat surprising wide-ranging analogy between the discrete logarithm problem and Legendre symbol computations. This analogy allows us to adapt various algorithmic ideas from the discrete logarithm setting.</p>

    <p class="text-gray-300">More precisely, we present a small memory multiple-key attack on <span class="math">m</span> Legendre keys <span class="math">k_{1},\\ldots,k_{m}</span> in time <span class="math">\\sqrt{mp}</span>, i.e. with amortized cost <span class="math">\\sqrt{p/m}</span> per key. This multiple-key attack might be of interest in the Ethereum context, since recovering many keys simultaneously maximizes an attacker’s profit.</p>

    <p class="text-gray-300">Moreover, we show that the Legendre PRF admits precomputation attacks, where the precomputation depends on the public <span class="math">p</span> only – and not on a key <span class="math">k</span>. Namely, an attacker may compute e.g. in precomputation time <span class="math">p^{\\frac{2}{3}}</span> a hint of size <span class="math">p^{\\frac{1}{3}}</span>. On receiving access to <span class="math">L_{k}(\\cdot)</span> in an online phase, the attacker then uses the hint to recover the desired key <span class="math">k</span> in time only <span class="math">p^{\\frac{1}{3}}</span>. Thus, the attacker’s online complexity again beats the birthday-bound.</p>

    <p class="text-gray-300">In addition, our precomputation attack can also be combined with our multiple-key attack. We explicitly give various tradeoffs between precomputation and online phase. E.g. for attacking <span class="math">m</span> keys one may spend time <span class="math">mp^{\\frac{2}{3}}</span> in the precomputation phase for constructing a hint of size <span class="math">m^{2}p^{\\frac{1}{3}}</span>. In an online phase, one then finds all <span class="math">m</span> keys in total time only <span class="math">p^{\\frac{1}{3}}</span>.</p>

    <p class="text-gray-300">Precomputation attacks might again be interesting in the Ethereum 2.0 context, where keys are frequently changed such that a heavy key-independent precomputation pays off.</p>

    <h2 id="sec-3" class="text-2xl font-bold">I Introduction</h2>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">I-A Motivation</h3>

    <p class="text-gray-300">Blockchain technology received enormous attention over the past years by enabling secure, decentralized payments and multi party computations. One of the most famous and powerful implementation of this technology is the Ethereum Blockchain. The newly proposed Ethereum 2.0 protocol <em>[13, 14]</em> tries to increase throughput for validating transactions in order to become competitive with modern credit card transaction systems.</p>

    <p class="text-gray-300">Throughput is increased by moving away from the energy-consuming Proof-of-Work approach to a Proof-of-Stake. As opposed to Proof-of-Work, in Proof-of-Stake a user’s voting power is not tied to its computing power, but to the stake he owns. If the Legendre PRF does not provide sufficient security, a malicious user <span class="math">u</span> may let another user <span class="math">\\bar{u}</span> with Legendre key <span class="math">\\bar{k}</span> download and validate transactions. User <span class="math">u</span> then recovers <span class="math">\\bar{u}</span>’s secret key <span class="math">\\bar{k}</span> in order to maliciously claim <span class="math">\\bar{u}</span>’s reward.</p>

    <p class="text-gray-300">More recent Legendre PRF applications are in multi-party computation <em>[17]</em>, and in designing quantum secure signatures <em>[5]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">I-B Related work on Legendre PRF security</h3>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime and <span class="math">x\\in\\mathbb{F}_{p}</span>. We call <span class="math">x</span> a quadratic residue in the finite field’s multiplicative group <span class="math">\\mathbb{F}_{p}^{<em>}</span>, if there exists an <span class="math">y\\in\\mathbb{F}_{p}^{</em>}</span> with <span class="math">y^{2}=x</span>. We define the Legendre symbol</p>

    <p class="text-gray-300">\\[ \\left(\\frac{x}{p}\\right)=\\begin{cases}0&\\text{if }x=0\\\\ 1&\\text{if }x\\text{ is a quadratic residue}\\\\ -1&\\text{else.}\\end{cases} \\]</p>

    <p class="text-gray-300">It is well-known that <span class="math">\\left(\\frac{x}{p}\\right)=x^{\\frac{p-1}{2}}\\bmod p</span>. The multiplicativity of the Legendre symbol follows directly.</p>

    <p class="text-gray-300">Choose a key <span class="math">k\\in\\mathbb{F}_{p}</span>. Then the Legendre PRF, as proposed by Damgård <em>[8]</em>, is the function <span class="math">L_{k}:\\mathbb{F}_{p}\\rightarrow\\{-1,0,1\\}</span> with</p>

    <p class="text-gray-300"><span class="math">L_{k}(x)=\\left(\\frac{x+k}{p}\\right).</span></p>

    <p class="text-gray-300">Therefore, the Legendre PRF satisfies for all <span class="math">i\\in\\mathbb{F}_{p}</span></p>

    <p class="text-gray-300"><span class="math">L_{k}(x+i)=\\left(\\frac{x+k+i}{p}\\right)=L_{0}\\left(x+k+i\\right).</span></p>

    <p class="text-gray-300">Conversely, if <span class="math">L_{k}(x+i)=L_{0}(y+i)</span> for sufficiently many <span class="math">i</span>, then we can conclude that <span class="math">y=x+k\\bmod p</span>. Thus, finding <span class="math">x,y</span> satisfying the identity <span class="math">L_{k}(x+i)=L_{0}(y+i)</span> for sufficiently many <span class="math">i</span> gives us a way to compute <span class="math">k=y-x\\bmod p</span>. We call <span class="math">(x,y)\\in\\mathbb{F}_{p}\\times\\mathbb{F}_{p}</span> a collision between the two functions <span class="math">L_{k}(\\cdot)</span> and <span class="math">L_{0}(\\cdot)</span> if <span class="math">L_{k}(x+i)=L_{0}(y+i)</span> for</p>

    <p class="text-gray-300">all <span class="math">0\\leq i&lt;\\lceil 3\\log p\\rceil</span>. We show in our work that, assuming Legendre PRF security, enforcing the identity at <span class="math">\\lceil 3\\log p\\rceil</span> points is sufficient to guarantee that a collision <span class="math">(x,y)</span> yields the secret key <span class="math">k=y-x</span>.</p>

    <p class="text-gray-300">Notice that evaluation of <span class="math">L_{0}(\\cdot)</span> is possible using the public <span class="math">p</span> only, whereas evaluation of <span class="math">L_{k}(\\cdot)</span> requires oracle access. Oracle access realization is the usual cryptographic attack model for PRFs – which is for conservative reasons quite strong, and not always satisfied in practical applications.</p>

    <p class="text-gray-300">Khovratovich <em>[20]</em> defined a memoryless algorithm with <span class="math">L_{k}(\\cdot)</span> oracle access for recovering a Legendre key <span class="math">k</span> within the typical birthday-type time bound <span class="math">\\tilde{\\mathcal{O}}(\\sqrt{p})</span>, where the <span class="math">\\tilde{\\mathcal{O}}</span>-notation suppresses factors polynomial in <span class="math">\\log p</span>. In the less strong attack model without oracle access, but only <span class="math">M\\leq p^{\\frac{1}{4}}</span> evaluations of <span class="math">L_{k}(\\cdot)</span> on known points, Beullens, Beyne, Udovenko, Vitto <em>[4]</em> and Kaluderovic, Kleinjung, Kostic <em>[19]</em> proposed an algorithm with inferior time complexity <span class="math">\\mathcal{O}(p\\log^{2}p/M^{2})</span>.</p>

    <p class="text-gray-300">It was left as an open problem, whether the <span class="math">\\sqrt{p}</span> bound can be beaten with classical algorithms. We answer this question in the affirmative, when we either allow for (more expensive) precomputations that do not require <span class="math">L_{k}(\\cdot)</span> oracle access, and/or allow for amortized cost per key in multiple-key attacks.</p>

    <p class="text-gray-300">On quantum computers, Russell and Shparlinski <em>[26]</em> showed that <span class="math">k</span> can be recovered in polynomial time given oracle access to a quantum embedding of <span class="math">L_{k}(\\cdot)</span> that can be asked in superposition – a very strong and in practical settings sometimes questionable attack model.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">II-C Oracle-access based Attack Model</h3>

    <p class="text-gray-300">Our results can be seen as a generalization of Khovratovich’s memory-less algorithm <em>[20]</em> that also uses <span class="math">L_{k}(\\cdot)</span> oracle access. Most practical scenarios that we are aware of however do not provide such a strong attack model.</p>

    <p class="text-gray-300">E.g. in Ethereum 2.0 the so-called Proof-of-custody for user <span class="math">u</span> with secret key <span class="math">k</span> works as follows. User <span class="math">u</span> downloads periodically public data <span class="math">m_{i}</span>, hashes to <span class="math">h(m_{i})\\in\\mathbb{F}_{p}</span>, and publishes the bit <span class="math">L_{k}(h(m_{i}))</span>. After a certain time period, all users reveal their secret key <span class="math">k</span>. User <span class="math">u</span> can claim a reward on data <span class="math">m_{i}</span> only if all bits <span class="math">L_{k}(h(m_{i}))</span> verify correctly for all published <span class="math">m_{i}</span> within this time period. Hence, an attacker obtains evaluations of <span class="math">L_{k}(\\cdot)</span> only on random known points <span class="math">h(m_{i})</span>, rather than points of his choice.</p>

    <p class="text-gray-300">A similar attack scenario applies for the LegRoast signature scheme <em>[5]</em> that is based on the MPC-in-the-head paradigm <em>[18]</em>. Here, a user <span class="math">u</span>’s public key is an <span class="math">n</span>-bit string <span class="math">(L_{k}(x_{1}),\\ldots,L_{k}(x_{n}))</span>, where <span class="math">k</span> is <span class="math">u</span>’s secret key, and the <span class="math">x_{i}</span> are public and randomly chosen in <span class="math">\\mathbb{F}_{p}</span>. Again, an attacker obtains evaluations of <span class="math">L_{k}(\\cdot)</span> on random known points <span class="math">x_{i}</span>.</p>

    <p class="text-gray-300">The setting, where an attacker obtains PRF evaluations on known (random) points is called known plaintext attack in the literature. Many practical PRF applications, e.g. also for AES, only allow for known plaintext attacks. Nevertheless, for PRFs the well-established standard security notion is a chosen plaintext attack (CPA) that allows an attacker to query <span class="math">L_{k}(\\cdot)</span> on points adaptively chosen by himself, i.e., an attacker receives <span class="math">L_{k}(\\cdot)</span> oracle access.</p>

    <p class="text-gray-300">Since PRFs are widely applied in practice in various scenarios, it is crucial to establish security even against the stronger CPA type. In fact, our algorithms directly use adaptive CPA queries, e.g. for achieving small memory consumption. Thus, our cryptanalytic results are of interest to study the security of Ethereum 2.0 and LegRoast, but do not directly lead to an attack on these.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">II-D Our contributions</h3>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">II-D1 Legendre PRF vs dlog</h4>

    <p class="text-gray-300">Let us first discuss the analogy between attacking the Legendre PRF via collisions and collision-based discrete logarithm algorithms. Let <span class="math">G</span> be a discrete logarithm group of order <span class="math">q</span> with generator <span class="math">g</span>, and let <span class="math">h=g^{k^{\\prime}}</span> be a discrete logarithm instance. By finding <span class="math">(x,y)</span> such that <span class="math">hg^{x}=g^{y}</span>, we compute the discrete logarithm <span class="math">k^{\\prime}=y-x\\bmod q</span>, analogous to the Legendre setting.</p>

    <p class="text-gray-300">Just as <span class="math">L_{k}(\\frac{x+i}{p})=L_{0}(\\frac{y+i}{p})</span>, for sufficient many <span class="math">i</span>, the identity <span class="math">hg^{x}=g^{y}</span> is asymmetric in the sense that only the left-hand size depends on the secret discrete logarithm <span class="math">k^{\\prime}</span>, whereas the right-hand side can be computed solely based on the group specification. This asymmetry is used in precomputation attacks on the discrete logarithm as introduced in Mihalcik <em>[23]</em> Lee, Cheon, Hong <em>[22]</em> and Bernstein, Lange <em>[3]</em>, where one performs a (rather large) precomputation that depends on the group only, and outputs a (rather small) hint. Upon receiving a discrete logarithm instance, one then determines the unknown <span class="math">k^{\\prime}</span> more quickly using the hint. Various tradeoffs are possible, e.g. within precomputation time <span class="math">\\tilde{\\mathcal{O}}(q^{\\frac{2}{3}})</span> one can compute a hint of size <span class="math">\\tilde{\\mathcal{O}}(q^{\\frac{1}{3}})</span>. Upon receiving <span class="math">h=g^{k^{\\prime}}</span>, the hint then allows to determine <span class="math">k^{\\prime}</span> in time only <span class="math">\\tilde{\\mathcal{O}}(q^{\\frac{1}{3}})</span>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">II-D2 Legendre Precomputation Attack</h4>

    <p class="text-gray-300">As already pointed out, in the Legendre setting the identity <span class="math">L_{k}(\\frac{x+i}{p})=L_{0}(\\frac{y+i}{p})</span> offers a similar asymmetry. The identity’s right-hand side depends on <span class="math">p</span> only and thus allows for precomputation, whereas computation of the left-hand side requires <span class="math">L_{k}(\\cdot)</span> oracle access. Hence, it might not come as a surprise that we obtain a similar Legendre key precomputation attack. Analogous, we may spend <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{2}{3}})</span> time to compute a hint of size <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{1}{3}})</span>. Upon receiving access to <span class="math">L_{k}(\\cdot)</span>, we then compute the secret <span class="math">k</span> using only <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{1}{3}})</span> queries to <span class="math">L_{k}(\\cdot)</span>.</p>

    <p class="text-gray-300">Not only does our precomputation attack break the <span class="math">\\sqrt{p}</span>-bound for recovering Legendre keys – in the online phase, once we have precomputed our hint. Our attack also accounts for scenarios that only offer limited number of <span class="math">L_{k}(\\cdot)</span>-queries. Similar to the discrete logarithm setting, we get for Legendre keys various tradeoffs between precomputation, key recovery phase and success probability.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">II-D3 Legendre Multiple-Key Attack</h4>

    <p class="text-gray-300">In the discrete logarithm setting, it was first noticed by Kuhn and Struick <em>[21]</em> using ideas from Escott, Sager, Selkirk, Tsapakidis <em>[11]</em> that <span class="math">m</span> discrete logarithm instances <span class="math">h_{1}=g^{k^{\\prime}_{1}},\\ldots,h_{m}=g^{k^{\\prime}_{m}}</span> can be solved memory-less more efficiently than naively applying Pollard’s <span class="math">\\tilde{\\mathcal{O}}(\\sqrt{p})</span>-algorithm <span class="math">m</span> times. Namely,</p>

    <p class="text-gray-300">Kuhn and Struick showed that reusing the data structure for <span class="math">h_{1}</span>, the discrete logarithm of <span class="math">h_{2}</span> can be found slightly more efficient, and so on. In total, all <span class="math">m</span> discrete logarithm instances can be computed in time <span class="math">\\mathcal{O}(\\sqrt{mp})</span>.</p>

    <p class="text-gray-300">Again, the multiple-key discrete logarithm setting transfers to the Legendre PRF world. Namely, we are able to extend Khovratovich’s <span class="math">\\tilde{\\mathcal{O}}(\\sqrt{p})</span>-algorithm — the Legendre variant of Pollard — to a multiple-key attack on <span class="math">m</span> key simultaneously. To this end, we use some graph-based techniques that were introduced by Fouque, Joux, Mavromati <em>[15]</em>. As result, we obtain an attack on <span class="math">m</span> Legendre keys <span class="math">k_{1},\\ldots,k_{m}</span> using oracle access to <span class="math">L_{k_{1}}(\\cdot),\\ldots,L_{k_{m}}(\\cdot)</span> that recovers all <span class="math">m</span> keys in total time <span class="math">\\tilde{\\mathcal{O}}(\\sqrt{mp})</span>.</p>

    <p class="text-gray-300">Our total time in turn implies that the amortized cost per Legendre key is only <span class="math">\\tilde{\\mathcal{O}}(\\sqrt{p/m})</span>, again beating the <span class="math">\\sqrt{p}</span>-bound.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">IV-A4 Legendre Multiple-Key Attack with Precomputation</h4>

    <p class="text-gray-300">In the discrete logarithm setting, Corrigan-Gibbs and Kogan <em>[7]</em> showed that multiple-key attacks can be combined with precomputation, again allowing for various tradeoffs. We also transfer this combination to the Legendre key setting. This implies e.g. an attack that uses precomputation time <span class="math">\\tilde{\\mathcal{O}}(mp^{\\frac{1}{2}})</span> to build a hint of size <span class="math">\\tilde{\\mathcal{O}}(m^{2}p^{\\frac{1}{2}})</span>. Upon access to <span class="math">L_{k_{1}}(\\cdot),\\ldots,L_{k_{m}}(\\cdot)</span>, one then computes all <span class="math">m</span> keys in total time only <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{1}{2}})</span>.</p>

    <p class="text-gray-300">Notice that in the multiple-key setting a large precomputation pays off in the sense that its cost amortizes over all keys. This explains why the multi-key precomputation setting is especially attractive for recovering Legendre keys.</p>

    <p class="text-gray-300">Conclusion: Our attacks do not directly apply to Ethereum 2.0, since they require Legendre PRF oracle access <span class="math">L_{k}(\\cdot)</span>, that is typically not provided in a blockchain scenario. Nevertheless, precomputation as well as multiple-key attacks seem to be highly relevant in the Ethereum 2.0 context, where Legendre keys are frequently changed such that heavy key-independent precomputations pay off to optimize success probability in a (short) online key-dependent attack phase. Moreover, the more keys an attacker recovers in an online phase, the larger is his reward. Therefore, amortization of attack costs over many keys also pays off.</p>

    <p class="text-gray-300">In the light of our novel Legendre PRF precomputation attacks one might consider — rather than the previous <span class="math">p^{\\frac{1}{2}}</span>-security level provided by Khovratovich’s algorithm — a more conservative lower <span class="math">p^{\\frac{1}{2}}</span>-security level. Using this third-root bound, the 256-bit prime <span class="math">p</span> used by Ethereums 2.0 still provides a high security level (of at least 85-bit), even against attacks with <span class="math">L_{k}(\\cdot)</span> oracle access.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">IV-A5 More Dlog-like Attacks and Limitations</h4>

    <p class="text-gray-300">We would like to notice that other collision-based discrete logarithm algorithms also transfer to the Legendre setting. This includes Pollard’s Lambda method <em>[25]</em> for secrets within a certain range, as well as the Esser-May method <em>[12]</em> for secrets with low Hamming weight. However, we felt that these attacks are less relevant in the Legendre key setting, in which we are not aware of any application with Legendre keys in a certain range, or with small Hamming weight.</p>

    <p class="text-gray-300">Moreover, we would like to point out that despite the similarities between the discrete logarithm problem and the Legendre PRF, there also exists exist crucial differences that introduce technical difficulties for directly transferring discrete logarithm algorithms. Namely, the discrete logarithm setting provides us with a group structure that is heavily used in many algorithms. As an example, Corrigan-Gibbs and Kogan <em>[7]</em> compute in their multiple-key attack for some random <span class="math">r_{1},\\ldots,r_{m}</span> the value <span class="math">h=h^{r_{1}}\\cdot\\ldots\\cdot h^{r_{m}}</span> that has discrete logarithm <span class="math">r_{1}k_{1}^{\\prime}+\\ldots+r_{m}k_{m}^{\\prime}</span>. Thus, in the discrete logarithm setting we easily obtain random linear combinations of the <span class="math">k_{i}^{\\prime}</span>. This property greatly simplifies the analysis of Corrigan-Gibbs and Kogan’s algorithm.</p>

    <p class="text-gray-300">As opposed to the discrete logarithm, for the Legendre PRF we do not have a group structure. This implies that neither can we compute a multiple <span class="math">r_{1}k_{1},r_{1}\\in\\mathbb{F}_{p}</span> using the oracle <span class="math">L_{k_{1}}(\\cdot)</span>, nor are we able to compute <span class="math">k_{1}+k_{2}</span> using two oracles <span class="math">L_{k_{1}}(\\cdot)</span> and <span class="math">L_{k_{2}}(\\cdot)</span>.</p>

    <p class="text-gray-300">The missing group structure poses some additional technical problems, when we transfer in the subsequent chapters the above-mentioned discrete logarithm algorithms to the Legendre PRF setting. Nevertheless, we always succeed to design alternative algorithms that provide analogous complexity results.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">IV-A6 Related Work and Open Problems</h4>

    <p class="text-gray-300">Our work is not the first that uses collision-finding techniques in the context of precomputation without having a group structure. E.g. Coretti, Dodis, Guo and Steinberger <em>[6]</em> and later Akshima, Cash, Drucker and Wee <em>[1]</em> designed precomputation attacks and lower bounds for salted hash functions. They showed that the salting technique is a good defense against the efficacy of precomputations for hash function collisions.</p>

    <p class="text-gray-300">We are quite confident that the lower bounds of Corrigan-Gibbs and Kogan <em>[7]</em> from the discrete logarithm setting in generic groups also transfer to our Legendre PRF setting, when using only our limited set of allowed operations. However, we feel that such an artificially limited generic Legendre PRF model would only provide misleading security guarantees. As opposed to many discrete logarithm groups, where we only have generic attacks, the Legendre PRF setting seems to offer a richer mathematical structure. E.g. the attacks of Beullens, Beyne, Udovenko, Vitto <em>[4]</em> and Kaluderovic, Kleinjung, Kostic <em>[19]</em> exploit the Legendre symbol’s multiplicativity to reduce the number of <span class="math">L_{k}(\\cdot)</span> oracle calls. Unfortunately, we have to leave it open whether similar techniques can be applied in our setting.</p>

    <p class="text-gray-300">Since we are purely focusing on key-recovering attacks, one might also wonder whether there exist more efficient Legendre PRF distinguishers. Given the wide analogy between discrete logarithm and Legendre PRF attacks, it is tempting to adapt e.g. the more efficient DDH-like distinguisher of Corrigan-Gibbs and Kogan <em>[7]</em> to the Legendre PRF setting. We failed to construct distinguishers with better efficiency than our key-recovery attacks, and we leave their existence as an open problem.</p>

    <p class="text-gray-300">Our paper is structured as follows. In Section II we provide some basic definitions for properly defining collision-</p>

    <p class="text-gray-300">based random walk algorithms in the Legendre PRF setting. Our Legendre precomputation attack is given in Section III. For didactic reasons, we then first generalize in Section IV our precomputation attack to the multiple-key setting, since both algorithms share a similar analysis. Eventually, in Section V we provide our multiple-key attack <em>without</em> precomputation.</p>

    <h2 id="sec-14" class="text-2xl font-bold">II Legendre PRF Basics</h2>

    <p class="text-gray-300">All logarithms in this paper are base <span class="math">2</span>. Let <span class="math">p</span> be prime, and let <span class="math">(\\frac{x}{p})</span> be the Legendre symbol of <span class="math">x</span> in <span class="math">\\mathbb{F}_{p}</span>. Since <span class="math">(\\frac{x}{p})=x^{\\frac{p-1}{2}}\\bmod p</span>, the Legendre symbol can be computed in time <span class="math">\\mathcal{O}(\\log^{3}p)</span>, polynomial in the bit-size of <span class="math">p</span>.</p>

    <p class="text-gray-300">For ease of notation, throughout the paper we suppress all run time factors that are polynomial in <span class="math">\\log p</span>, by hiding them in soft-Oh notation, e.g. <span class="math">3p\\log^{2}p=\\mathcal{O}(p)</span>. We call any function inverse that grows faster than a polynomial in <span class="math">\\log p</span> negligible, denoted <span class="math">\\text{negl}(p)</span>. We call success probability <span class="math">1-\\text{negl}(p)</span> overwhelming.</p>

    <p class="text-gray-300">For a key <span class="math">k\\in\\mathbb{F}_{p}</span> the <em>original Legendre PRF</em> <em>[8]</em> is defined as the function</p>

    <p class="text-gray-300"><span class="math">\\bar{L}_{k}:\\mathbb{F}_{p}\\to\\{-1,0,1\\},\\ x\\mapsto\\left(\\frac{x+k}{p}\\right).</span></p>

    <p class="text-gray-300">Obviously, if <span class="math">y=x+k</span> then <span class="math">\\bar{L}_{0}(y)=\\bar{L}_{k}(x)</span>. In order to use collision-based algorithms, we would like to conclude that conversely <span class="math">\\bar{L}_{0}(y)=\\bar{L}_{k}(x)</span> implies <span class="math">y=x+k</span>. To this end, we define a function <span class="math">L_{k}</span> with sufficiently large range <span class="math">R</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 1 (Legendre point)</h6>

    <p class="text-gray-300">Define <span class="math">r=\\lceil 3\\log p\\rceil</span> and <span class="math">R=\\{-1,0,1\\}^{r}</span>. We set</p>

    <p class="text-gray-300"><span class="math">L_{k}:\\mathbb{F}_{p}\\to R,\\ x\\mapsto\\left(\\left(\\frac{x+k}{p}\\right),\\ldots,\\left(\\frac{x+k+r-1}{p}\\right)\\right).</span></p>

    <p class="text-gray-300">We denote by <span class="math">L:=L_{0}</span> the <em>key-independent</em> function, and we define the set of all <em>Legendre points</em> as <span class="math">P=\\{L(y)\\mid y\\in\\mathbb{F}_{p}\\}\\subset R</span>.</p>

    <p class="text-gray-300">Notice that <span class="math">L(x)\\in\\{-1,1\\}^{r}</span> unless <span class="math">x=0</span> or <span class="math">x&gt;p-r</span>. For simplicity, let us for a moment exclude these border cases. Under the assumption that <span class="math">\\bar{L}_{k}</span> is a PRF, it is not hard to see that the <span class="math">r</span>-bit range <span class="math">L:\\mathbb{F}_{p}\\to\\{-1,1\\}^{r}</span> is a secure PRG (pseudorandom number generator).</p>

    <p class="text-gray-300">In fact, Damgård suggested such a Legendre pseudorandom generator in <em>[8]</em>. Therefore, for a random seed <span class="math">x</span> the output <span class="math">L(x)</span> is supposed to be pseudorandom. There is strong theoretical and practical evidence <em>[2]</em>, <em>[4]</em>, <em>[9]</em>, <em>[19]</em>, <em>[24]</em>, <em>[26]</em> that the distribution of <span class="math">L(x)</span> is even statistically close to uniform in <span class="math">\\{-1,1\\}^{r}</span>. For simplicity of exposition, we heuristically assume such a uniform distribution. A failure of our heuristic would open the door for Legendre symbol distinguishing attacks.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Heuristic 1 (Uniformity)</h6>

    <p class="text-gray-300">Let <span class="math">x\\in\\{1,2,\\ldots,p-r\\}</span> be chosen uniformly at random. Then <span class="math">L(x)</span> is uniformly distributed in <span class="math">\\{-1,1\\}^{r}</span>. That is for all fixed <span class="math">c\\in\\{-1,1\\}^{r}</span> we have <span class="math">\\Pr[L(x)=c]=\\frac{1}{2^{c}}</span>.</p>

    <p class="text-gray-300">In the subsequent sections, we define random walks over the set <span class="math">P=\\{L(x)\\mid x\\in\\mathbb{F}_{p}\\}</span> of Legendre points. Notice that <span class="math">P</span> is <em>not</em> equipped with a group structure, as opposed to the discrete logarithm setting.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following Lemma 1 implies that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=p<span class="math"> with overwhelming probability. This in turn implies that collisions of our random walks result in recovery of the secret Legendre PRF key </span>k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">Let <span class="math">L_{k}:\\mathbb{F}_{p}\\to\\{-1,0,1\\}^{\\lceil 3\\log p\\rceil}</span>. Under Heuristic 1, with overwhelming probability all argument pairs <span class="math">x,y</span> with <span class="math">y\\neq x+k</span> satisfy <span class="math">L(y)\\neq L_{k}(x)</span>. Hence, with overwhelming probability</p>

    <p class="text-gray-300"><span class="math">L(y)=L_{k}(x)\\ \\Rightarrow\\ y=x+k.</span></p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof:</h6>

    <p class="text-gray-300">Let <span class="math">r=\\lceil 3\\log p\\rceil</span>, and let <span class="math">k\\in\\mathbb{F}_{p}</span> be chosen uniformly at randomly. First, consider the case of argument pairs <span class="math">x,y</span> such that at exactly one of <span class="math">L(y),L_{k}(x)</span> is in <span class="math">\\{-1,0,1\\}^{r}\\backslash\\{-1,1\\}^{r}</span>. That is, either <span class="math">L(y)</span> or <span class="math">L_{k}(x)</span> contains a zero entry. Then obviously <span class="math">L(y)\\neq L_{k}(x)</span>. Second, consider the case that <span class="math">L(y),L_{k}(x)</span> both contain zeros. By Definition 1, every Legendre point can have at most one zero. Since <span class="math">y\\neq x+k</span> the zero entries of <span class="math">L(y)</span>, <span class="math">L_{k}(x)</span> must be in different positions, again implying <span class="math">L(y)\\neq L_{k}(x)</span>.</p>

    <p class="text-gray-300">Thus, we may w.l.o.g. assume argument pairs <span class="math">x,y</span> with <span class="math">L(y),L_{k}(x)\\in\\{-1,1\\}^{r}</span>. Since <span class="math">k</span> is uniformly at random, by Heuristic 1 the Legendre point <span class="math">L_{k}(x)=L(k+x)</span> is also uniformly at random. Therefore,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[L(y)=L_{k}(x)\\mid y\\neq x+k\\right]=\\frac{1}{2^{r}}=\\frac{1}{2^{\\lceil 3\\log p\\rceil}}\\leq\\frac{1}{p^{3}}.</span></p>

    <p class="text-gray-300">The number of pairs <span class="math">x,y</span> with <span class="math">y\\neq x+k</span> is upper-bounded by <span class="math">p(p-1)</span>, since we exclude Legendre points with zero entries. Using Bernoulli’s inequality, all these <span class="math">x,y</span> satisfy <span class="math">L(y)\\neq L_{k}(x)</span> with probability at least</p>

    <p class="text-gray-300"><span class="math">\\left(1-\\frac{1}{p^{3}}\\right)^{p(p-1)}\\geq 1-\\frac{p(p-1)}{p^{3}}\\geq 1-\\frac{1}{p}.</span></p>

    <p class="text-gray-300"><span class="math">\\blacksquare</span></p>

    <h2 id="sec-19" class="text-2xl font-bold">III Precomputation Attack</h2>

    <p class="text-gray-300">Let us first give a high-level description of our Legendre PRF precomputation attack, see also Figure 1. In a nutshell, in the precomputation phase we perform sufficiently many <em>key-independent</em> random walks <span class="math">W_{1},\\ldots,W_{s}</span> on the set of Legendre points <span class="math">P</span> (Definition 1), where we only store the walks’ endpoints. The endpoints serve as a hint for the online phase.</p>

    <p class="text-gray-300">Upon receiving <span class="math">L_{k}(\\cdot)</span> oracle access, we then compute in the online phase the Legendre key <span class="math">k</span> by letting a <em>key-dependent</em> random walk <span class="math">\\overline{W}_{k}</span> – defined via <span class="math">L_{k}(\\cdot)</span> – collide with one of the precomputed walks. We detect the collision using our stored endpoints.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Precomputation attack</p>

    <h2 id="sec-20" class="text-2xl font-bold">A. Random Walks – Precomputation and Online</h2>

    <p class="text-gray-300">Let <span class="math">R = \\{-1,0,1\\}^{[3\\log p]}</span> and <span class="math">P = \\{L(y) \\mid y \\in \\mathbb{F}_p\\} \\subset R</span> (Definition 1). We define a random function <span class="math">f: P \\to \\mathbb{F}_p</span>. Notice that <span class="math">f</span> is compressing. In practice, <span class="math">f</span> may be instantiated via some appropriate hash function. The function <span class="math">f</span> helps us in a random walk <span class="math">W</span> to map Legendre points <span class="math">L(y)</span> back to arguments <span class="math">y&#x27;</span> for the Legendre PRF. We define <span class="math">W</span> on <span class="math">P</span> as follows.</p>

    <p class="text-gray-300"><strong>Precomputation phase.</strong> Let <span class="math">y^{(1)} \\in \\mathbb{F}_p</span>. Then <span class="math">W</span>'s starting point is <span class="math">L(y^{(1)}) \\in P</span>. Next, <span class="math">W</span> computes <span class="math">y^{(2)} = y^{(1)} + f(L(y^{(1)})) \\mod p</span> and steps to its second point <span class="math">L(y^{(2)}) \\in P</span>. In general, <span class="math">W</span> computes an arbitrary number of steps, where</p>

    <div class="my-4 text-center"><span class="math-block">y ^ {(i + 1)} = y ^ {(i)} + f \\left(L \\left(y ^ {(i)}\\right)\\right) \\bmod p \\text { for } i \\geq 1 \\tag {1}</span></div>

    <p class="text-gray-300">with random walk points <span class="math">L(y^{(i)}) \\in P</span>. Notice that <span class="math">W</span> is key-independent, since it does not involve oracle queries <span class="math">L_{k}(\\cdot)</span>. Thus, we can compute <span class="math">W</span> in a precomputation phase solely based on the public information <span class="math">p</span>. Assume that we walk <span class="math">W</span> for <span class="math">t/2</span> steps. Then we only store the endpoint <span class="math">L(y^{(t/2)})</span> and its argument <span class="math">y^{(t/2)}</span>. The endpoint <span class="math">L(y^{(t/2)})</span> allows us to detect collisions between walks, whereas <span class="math">y^{(t/2)}</span> allows us to find the Legendre key. This procedure is repeated with <span class="math">s</span> different starting points <span class="math">y_{1}^{(1)}, \\ldots, y_{s}^{(1)}</span>.</p>

    <p class="text-gray-300"><strong>Online phase.</strong> Now assume that we obtain <span class="math">L_{k}(\\cdot)</span> oracle access. We want to compute in an online phase the secret Legendre key <span class="math">k</span>. To this end we perform a key dependent walk <span class="math">\\overline{W}_k</span> as follows. Choose <span class="math">x^{(1)} \\in_R \\mathbb{F}_p</span> and compute starting point <span class="math">L_{k}(x^{(1)})</span>. In general, for a key dependent walk <span class="math">\\overline{W}_k</span> we calculate the next point as</p>

    <div class="my-4 text-center"><span class="math-block">x ^ {(i + 1)} = x ^ {(i)} + f \\left(L _ {k} \\left(x ^ {(i)}\\right)\\right) \\bmod p \\text { for } i \\geq 1 \\tag {2}</span></div>

    <p class="text-gray-300">with random walk points <span class="math">L_{k}\\left(x^{(i)}\\right)\\in P</span></p>

    <h2 id="sec-21" class="text-2xl font-bold">B. Colliding Walks solve Legendre.</h2>

    <p class="text-gray-300">Assume that a key-independent walk <span class="math">W</span> collides with a key-dependent walk <span class="math">\\overline{W}_k</span>. I.e., there exist arguments <span class="math">y^{(i)}, x^{(j)}</span> with colliding points</p>

    <div class="my-4 text-center"><span class="math-block">L (y ^ {(i)}) = L _ {k} (x ^ {(j)}).</span></div>

    <p class="text-gray-300">Using Lemma 1, we immediately conclude from such a collision that</p>

    <div class="my-4 text-center"><span class="math-block">k = y ^ {(i)} - x ^ {(j)} \\bmod p. \\tag {3}</span></div>

    <p class="text-gray-300">Moreover, we want to show that once two chains of points from <span class="math">P</span> computed in walks <span class="math">W, \\overline{W}_k</span> collide, they stay in the same points, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">L (y ^ {(i)}) = L _ {k} (x ^ {(j)}) \\Rightarrow L (y ^ {(i + 1)}) = L _ {k} (x ^ {(j + 1)}).</span></div>

    <p class="text-gray-300">To this end let us assume <span class="math">L(y^{(i)}) = L_k(x^{(j)})</span>. We already know that this implies <span class="math">y^{(i)} = x^{(j)} + k \\mod p</span>. Using Equation (1), we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} y ^ {(i + 1)} = y ^ {(i)} + f \\left(L \\left(y ^ {(i)}\\right)\\right) \\\\ = x ^ {(j)} + k + f \\left(L \\left(x ^ {(j)} + k\\right)\\right) \\bmod p. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This in turn implies</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} L \\left(y ^ {(i + 1)}\\right) = L \\left(x ^ {(j)} + k + f \\left(L \\left(x ^ {(j)} + k\\right)\\right)\\right) \\\\ = L _ {k} \\left(x ^ {(j)} + f \\left(L _ {k} \\left(x ^ {(j)}\\right)\\right)\\right) \\\\ = L _ {k} \\left(x ^ {(j + 1)}\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">It remains to show that we can efficiently find arguments <span class="math">y^{(i)}, x^{(j)}</span> with colliding points <span class="math">L(y^{(i)}), L_k(x^{(j)})</span>. Since from the first colliding point on both walks stay in the same points, walk <span class="math">\\overline{W}_k</span> eventually reaches <span class="math">W</span>'s endpoint. Let <span class="math">L(y^{(t/2)}) = L_k(x^{(j)})</span> denote this endpoint. The corresponding arguments <span class="math">y^{(t/2)}, x^{(j)}</span> reveal the Legendre secret key <span class="math">k</span> via Equation (3).</p>

    <p class="text-gray-300">The resulting precomputation attack PRE-LEGENDRE is described in Algorithm 1. Using the parameter choice <span class="math">s = t = p^{\\frac{1}{3}}</span> in the following Theorem 1, we achieve precomputation in time <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{2}{3}})</span> using a hint of size <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{1}{3}})</span>, whereas the online phase runs in time <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{1}{3}})</span> with constant success probability <span class="math">\\epsilon = \\Omega(st^2/p) = \\Omega(1)</span>.</p>

    <p class="text-gray-300"><strong>Theorem 1:</strong> Assume that we are given oracle access to a Legendre PRF <span class="math">L_{k}(\\cdot):\\mathbb{F}_{p}\\to P</span>. Under Heuristic 1, for any <span class="math">s,t\\in \\mathbb{N}</span> with <span class="math">s^2 t\\leq p</span> algorithm PREP-LEGENDRE precomputes in time <span class="math">\\tilde{\\mathcal{O}} (st)</span> a hint of size <span class="math">\\tilde{\\mathcal{O}} (s)</span>, which allows to find <span class="math">k</span> in online time <span class="math">\\tilde{\\mathcal{O}} (t)</span> with success probability <span class="math">\\Omega \\left(\\frac{st^2}{p}\\right)</span>.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Let us first consider correctness and success probability. If PRE-LEGENDRE finds a collision in line 12, then by Lemma 1 with overwhelming probability <span class="math">k</span> is the correct Legendre key. It remains to show that PRE-LEGENDRE does not output FAIL too often.</p>

    <p class="text-gray-300">We show that the success probability <span class="math">\\epsilon = \\operatorname{Pr}(\\overline{\\mathrm{FAIL}})</span> for finding a collision in line 12 of <span class="math">\\overline{W}_k</span> with some precomputed walk <span class="math">W_{\\ell}</span>'s endpoint is <span class="math">\\Omega(st^2/p)</span>. Hence, we obtain constant success probability for <span class="math">st^2 = \\Omega(p)</span>, e.g. for the choice <span class="math">s = t = \\lceil p^{\\frac{1}{3}} \\rceil</span>. Our analysis closely follows the analysis from Corrigan-Gibbs and Kogan [7] for the discrete logarithm setting.</p>

    <p class="text-gray-300">Algorithm 1: PRE-LEGENDRE Input:  <span class="math">p,L_{k}(\\cdot):\\mathbb{F}_{p}\\to P</span>  with  <span class="math">P = \\{L(y)\\mid y\\in</span> <span class="math">\\mathbb{F}_p\\} \\subset \\{0,\\pm 1\\}^{\\lceil 3\\log p\\rceil}</span> Output:  <span class="math">k\\in \\mathbb{F}_p</span> 1 begin 2 Choose  <span class="math">s,t\\in \\mathbb{N}</span>  s.t.  <span class="math">st^2\\leq p.\\triangleright</span>  E.g.  <span class="math">s,t = \\lceil p^{\\frac{1}{3}}\\rceil</span> 3 Define random  <span class="math">f:P\\rightarrow \\mathbb{F}_p</span> 4 for  <span class="math">\\ell = 1,\\dots ,s</span>  Precomputation phase 5 do 6 Choose a random  <span class="math">y_{\\ell}^{(1)}\\in \\mathbb{F}_{p}</span> 7 Start in  <span class="math">L(y_{\\ell}^{(1)})</span>  a  <span class="math">t / 2</span>  -step walk  <span class="math">W_{\\ell}</span>  (Eq. 1) 8  <span class="math">y_{\\ell}^{(i + 1)} = y_{\\ell}^{(i)} + f(L(y_{\\ell}^{(i)}))</span>  mod  <span class="math">p</span> 9 with points  <span class="math">L(y_{\\ell}^{(i)})\\in P</span> 10 11 12 13 14 15 16 end 17 end</p>

    <p class="text-gray-300">We first observe that the preprocessing walks  <span class="math">W_{1}, \\ldots, W_{s}</span>  with  <span class="math">t/2</span> -steps touch at most  <span class="math">st/2</span>  Legendre points. Moreover, we show that on expectation these  <span class="math">s</span>  walks touch at least  <span class="math">st/4</span>  distinct points.</p>

    <p class="text-gray-300">To prove this, let  <span class="math">X_{\\ell}</span>  be a random variable for the number of points touched by precomputation walk  <span class="math">W_{\\ell}</span> ,  <span class="math">\\ell = 1,\\dots ,s</span> . Further, let  <span class="math">X = X_{1} + \\ldots +X_{s}\\leq st / 2</span> . We show in the following that  <span class="math">\\operatorname *{Pr}[X\\geq st / 4]\\geq \\frac{1}{2}</span> .</p>

    <p class="text-gray-300">Using Bernoulli's inequality and  <span class="math">st^2 \\leq p</span> , every  <span class="math">t/2</span> -step walk touches the maximum number  <span class="math">t/2</span>  of new point with probability at least</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[X_{\\ell} = \\frac{t}{2}\\right] \\geq \\left(\\frac{p - st / 2}{p}\\right)^{\\frac{1}{2}} = \\left(1 - \\frac{st}{2p}\\right)^{\\frac{1}{2}} \\geq 1 - \\frac{st^2}{4p} \\geq \\frac{3}{4}.</span></p>

    <p class="text-gray-300">Therefore, every walk in the precomputation phase covers on expectation at least  <span class="math">\\mathbb{E}[X_{\\ell}] \\geq \\frac{3}{4} \\cdot \\frac{t}{2} = \\frac{3}{8} t</span>  new points. By linearity of expectation we have</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[X] = \\sum_{\\ell = 1}^{s}\\mathbb{E}[X_{\\ell}]\\geq \\frac{3}{8} st.</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Multiple-key precomputation attack. Here  <span class="math">W_{1}, \\ldots, W_{s}</span>  denote key-independent and  <span class="math">\\overline{W}_{k_1}, \\ldots, \\overline{W}_{k_m}</span>  key-dependent random walks.</p>

    <p class="text-gray-300">Using Markov's inequality and  <span class="math">X \\leq st / 2</span> , we obtain</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[X &amp;lt; \\frac{st}{4}\\right] \\leq \\operatorname</em>{Pr}\\left[\\frac{st}{2} - X \\leq \\frac{st}{4}\\right] \\leq \\frac{\\frac{st}{2} - \\mathbb{E}[X]}{\\frac{st}{4}} \\leq \\frac{1}{2}.</span></p>

    <p class="text-gray-300">Therefore,  <span class="math">\\operatorname*{Pr}[X\\geq st / 4]\\geq \\frac{1}{2}</span>  as desired.</p>

    <p class="text-gray-300">Let us assume in the following that  <span class="math">X \\geq st / 4</span>  Legendre points are covered during precomputation. Let  <span class="math">E</span>  be the event that within the first  <span class="math">t / 2</span>  steps of the  <span class="math">t</span> -step online walk  <span class="math">\\overline{W}_k</span>  we hit one of the  <span class="math">X</span>  covered points. Using  <span class="math">1 - x \\leq e^{-x}</span>  and  <span class="math">1 - e^{-x} \\geq x / 2</span>  for  <span class="math">x \\leq 1</span> , we obtain</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}[E]\\geq 1 - \\left(1 - \\frac{st}{4p}\\right)^{t / 2}\\geq 1 - e^{-\\frac{st^2}{8p}}\\geq \\frac{st^2}{16p}.</span></p>

    <p class="text-gray-300">Notice that the event  <span class="math">E</span>  implies that in the remaining  <span class="math">t/2</span>  steps of the online phase we must hit some precomputed endpoint  <span class="math">L(y_{\\ell}^{(t/2)})</span>  in  <span class="math">\\mathcal{L}</span> . This implies success probability at least</p>

    <p class="text-gray-300"><span class="math">\\epsilon = \\operatorname<em>{Pr}[X\\geq st / 4]\\cdot \\operatorname</em>{Pr}[E]\\geq \\frac{st^2}{32p}.</span></p>

    <p class="text-gray-300">Thus, with probability  <span class="math">\\epsilon</span>  we output the secret Legendre key  <span class="math">k</span> .</p>

    <p class="text-gray-300">It remains to show the complexity statements. Precomputation takes time  <span class="math">\\tilde{\\mathcal{O}}(st)</span>  using memory  <span class="math">\\tilde{\\mathcal{O}}(s)</span> . The online phase runs in time  <span class="math">\\tilde{\\mathcal{O}}(t)</span> .</p>

    <p class="text-gray-300">Remark 1: We may amplify the success probability of PRE-LEGENDRE arbitrary close to 1 by running more key-dependent walks with different starting points, while reusing the precomputation structure. This is our strategy in the experimental Section VI.</p>

    <p class="text-gray-300">The high-level idea of our precomputation attack on multiple keys is similar to our precomputation attack on a single key from the previous Section III, see also Figure 2.</p>

    <p class="text-gray-300">Again, in a precomputation phase we run only key-independent walks  <span class="math">W_{1}, \\ldots, W_{s}</span> , and store their endpoints</p>

    <p class="text-gray-300">in a list  <span class="math">\\mathcal{L}</span> . The endpoints serve as a hint for the online phase.</p>

    <p class="text-gray-300">Let us in the online phase attack Legendre keys  <span class="math">k_{1},\\ldots ,k_{m}</span> , for which we obtain oracle access to  <span class="math">L_{k_{\\ell}}(\\cdot)</span> ,  <span class="math">\\ell = 1,\\dots,m</span> . Using these oracles we define key-dependent walks  <span class="math">\\overline{W}_{k_{\\ell}}</span>  that with high probability collide into some precomputed walk  <span class="math">W_{i}</span> . As in Section III, collisions from  <span class="math">\\overline{W}_{k_{\\ell}}</span>  are detected via hitting some precomputed endpoint in  <span class="math">\\mathcal{L}</span> . A collision of  <span class="math">\\overline{W}_{k_{\\ell}}</span>  enables us to recover  <span class="math">k_{\\ell}</span>  using Equation (3).</p>

    <p class="text-gray-300">The resulting procedure is given in Algorithm 2. For the choice  <span class="math">s = m^2 p^{\\frac{1}{3}}</span>  and  <span class="math">t = p^{\\frac{1}{3}}</span>  in Theorem 2 we obtain precomputation time  <span class="math">\\tilde{\\mathcal{O}}(mp^{\\frac{2}{3}})</span>  and a hint of size  <span class="math">\\tilde{\\mathcal{O}}(m^2 p^{\\frac{1}{3}})</span> , whereas the online phase finishes in time only  <span class="math">\\tilde{\\mathcal{O}}(p^{\\frac{1}{3}})</span>  for computing all  <span class="math">m</span>  Legendre keys with constant success probability.</p>

    <p class="text-gray-300">Algorithm 2: PRE-MULT-LEGENDRE Input:  <span class="math">p, L_{k_1}(\\cdot), \\ldots, L_{k_m}(\\cdot): \\mathbb{F}_p \\to P</span>  with  <span class="math">P = \\{L(y) \\mid y \\in \\mathbb{F}_p\\} \\subset \\{0, \\pm 1\\}^{[3\\log p]}</span> Output:  <span class="math">\\{k_1, \\ldots, k_m\\} \\in \\mathbb{Z}_p^m</span> 1 begin 2 Choose  <span class="math">s, t \\in \\mathbb{N}</span>  with  <span class="math">st^2 \\leq m^2 p</span> . 3 Define random  <span class="math">f: P \\to \\mathbb{F}_p</span> . 4 for  <span class="math">\\ell = 1, \\ldots, s</span>  PRECOMPUTATION phase 5 do 6 Choose a random  <span class="math">y_\\ell^{(1)} \\in \\mathbb{F}_p</span> 7 Start in  <span class="math">L(y_\\ell^{(1)})</span>  a  <span class="math">\\frac{t}{2m}</span> -step walk  <span class="math">W_\\ell</span> <span class="math">y_\\ell^{(i+1)} = y_\\ell^{(i)} + f(L(y_\\ell^{(i)})) \\mod p</span> 8 with points  <span class="math">L(y_\\ell^{(i)}) \\in P</span> . 9 10 11 12 13 14 15 16 17 18 19 20 end</p>

    <p class="text-gray-300">Theorem 2: Assume that we are given oracle access to  <span class="math">m</span>  Legendre PRFs  <span class="math">L_{k_1}(\\cdot),\\ldots ,L_{k_m}(\\cdot):\\mathbb{F}_p\\to P</span> . Under</p>

    <p class="text-gray-300">Heuristic 1, for any  <span class="math">s,t\\in \\mathbb{N}</span>  with  <span class="math">st^2\\leq m^2 p</span>  algorithm PRE-MULT-LEGENDRE precomputes in time  <span class="math">\\tilde{\\mathcal{O}}\\left(\\frac{st}{m}\\right)</span>  a hint of size  <span class="math">\\tilde{\\mathcal{O}} (s)</span> , which allows to find each  <span class="math">k_{\\ell}</span> ,  <span class="math">1\\leq \\ell \\leq m</span>  with success probability  <span class="math">\\epsilon_{\\ell} = \\Omega \\left(\\frac{st^{2}}{m^{2}p}\\right)</span>  in total online time  <span class="math">\\tilde{\\mathcal{O}} (t)</span> .</p>

    <p class="text-gray-300">Proof: Let us first consider correctness and success probability. Here, we closely follow the analysis from the proof of Theorem 1. If we output in line 15 of PRE-MULT-LEGENDRE a key  <span class="math">k_{\\ell}</span>  then this key is correct by the discussion from Section III.</p>

    <p class="text-gray-300">It remains to show that the success probability  <span class="math">\\epsilon_{\\ell}</span>  for recovering key  <span class="math">k_{\\ell}</span>  is sufficiently large. We show that  <span class="math">\\epsilon_{\\ell} = \\Omega \\left(\\frac{st^2}{m^2p}\\right)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">X_{\\ell}</span>  be a random variable for the number of new points touched by the  <span class="math">\\frac{t}{2m}</span> -step precomputation walk  <span class="math">W_{\\ell}</span> ,  <span class="math">\\ell = 1, \\ldots, s</span> . Let  <span class="math">X = \\overline{X_1} + \\ldots + X_s</span> . Since  <span class="math">X_{\\ell} \\leq \\frac{t}{2m}</span> , we have  <span class="math">X \\leq \\frac{st}{2m}</span> . Using  <span class="math">st^2 \\leq m^2 p</span>  and Bernoulli's inequality, every walk touches the maximal number  <span class="math">\\frac{t}{2m}</span>  of new points with probability</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[X_{\\ell} = \\frac{t}{2m}\\right] \\geq \\left(\\frac{p - \\frac{st}{2m}}{p}\\right)^{\\frac{t}{2m}} = \\left(1 - \\frac{st}{2pm}\\right)^{\\frac{t}{2m}}</span> <span class="math">\\geq 1 - \\frac{st^2}{4m^2p} \\geq \\frac{3}{4}</span> .</p>

    <p class="text-gray-300">Thus,  <span class="math">\\mathbb{E}[X_i] \\geq \\frac{3}{4} \\frac{t}{2m} = \\frac{3t}{8m}</span>  and  <span class="math">\\mathbb{E}[X] \\geq \\frac{3st}{8m}</span> . Using Markov's inequality we get</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[X &amp;lt; \\frac{st}{4m}\\right] \\leq \\operatorname</em>{Pr}\\left[\\frac{st}{2m} - X \\leq \\frac{st}{4m}\\right] \\leq \\frac{\\frac{st}{2m} - \\mathbb{E}[X]}{\\frac{st}{4m}} \\leq \\frac{1}{2}</span> .</p>

    <p class="text-gray-300">This implies that with probability at least  <span class="math">\\frac{1}{2}</span>  our precomputation structure covers  <span class="math">X \\geq \\frac{st}{4m}</span>  points. Assume in the following that  <span class="math">X \\geq \\frac{st}{4m}</span> . Let  <span class="math">E_{\\ell}</span>  be the event that the key-dependent walk  <span class="math">\\overline{W}_{k_{\\ell}}</span>  hits within its first  <span class="math">\\frac{t}{2m}</span>  steps one of the  <span class="math">X</span>  covered point. Then</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}[E_{\\ell}]\\geq 1 - \\left(1 - \\frac{st}{4mp}\\right)^{\\frac{t}{2m}}\\geq 1 - e^{-\\frac{st^2}{8m^2p}}\\geq \\frac{st^2}{16m^2p}.</span></p>

    <p class="text-gray-300">In the event  <span class="math">E_{\\ell}</span> , we must hit by the discussion in section III-B in the remaining  <span class="math">\\frac{t}{2m}</span>  steps of walk  <span class="math">\\overline{W}_{k_{\\ell}}</span>  a precomputed endpoint in  <span class="math">\\mathcal{L}</span> . This in turn allows us to compute  <span class="math">k_{\\ell}</span> . Thus, we succeed to compute  <span class="math">k_{\\ell}</span>  with probability at least</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\ell} = \\operatorname<em>{Pr}\\left[X_{i}\\geq \\frac{st}{4m}\\right]\\cdot \\operatorname</em>{Pr}[E_{\\ell}]\\geq \\frac{st^{2}}{32m^{2}p} = \\Omega \\left(\\frac{st^{2}}{m^{2}p}\\right).</span></p>

    <p class="text-gray-300">It remains to show the complexity statements. The precomputation phase runs in time  <span class="math">\\tilde{\\mathcal{O}}\\left(\\frac{st}{m}\\right)</span>  using memory  <span class="math">\\tilde{\\mathcal{O}}(s)</span> . The online phase runs in time  <span class="math">\\tilde{\\mathcal{O}}(t)</span> .</p>

    <p class="text-gray-300">Remark 2: Theorem 2 guarantees constant success probability for each key  <span class="math">k_{\\ell}</span>  if  <span class="math">st^2 = \\Omega(m^2 p)</span> . If PRE-MULT-LEGENDRE fails to find some  <span class="math">k_{\\ell}</span> , we may simply rerun the key-dependent walk  <span class="math">W_{k_{\\ell}}</span>  with a fresh starting point. This is our strategy in the experimental Section VI.</p>

    <p class="text-gray-300">The strategy for our multiple-key attack substantially deviates from the algorithms in the previous sections. Recall</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Multiple-key attack.  <span class="math">D</span>  denotes a distinguished point set and  <span class="math">\\overline{W}_{k_1},\\ldots ,\\overline{W}_{k_7}</span>  are key-dependent random walks.</p>

    <p class="text-gray-300">that in Sections III and IV we computed in the precomputation phase fixed length key-independent walks together with their endpoints as hint. In the online phase we then let key-dependent walks collide into the precomputation walks, thereby detecting collisions via endpoints.</p>

    <p class="text-gray-300">In contrast, for our multiple-key attack without precomputation we solely compute key-dependent walks, and therefore only consider collisions between key-dependent walks, see also Figure 3. Our key-dependent walks are of variable length, and we stop them only if we hit some set  <span class="math">D \\subset P</span>  of distinguished Legendre points. These distinguished points allow us to detect collisions between two walks  <span class="math">\\overline{W}_{k_i}, \\overline{W}_{k_j}</span>  that use Legendre keys  <span class="math">k_i, k_j</span> . Such a collision in turn gives us a Legendre key relation for  <span class="math">k_i - k_j</span> . Upon having collected sufficiently many of such relations, we eventually compute the Legendre keys.</p>

    <p class="text-gray-300">The resulting algorithm recovers  <span class="math">m</span>  Legendre keys  <span class="math">k_{1},\\ldots ,k_{m}</span>  in time  <span class="math">\\hat{\\mathcal{O}} (\\sqrt{mp})</span>  using optimal memory  <span class="math">\\hat{\\mathcal{O}} (m)</span> . Notice that we already need memory  <span class="math">\\Omega (m)</span>  to store all keys. Our algorithm's complexity  <span class="math">\\hat{\\mathcal{O}} (\\sqrt{mp})</span>  should be compared with the naive approach that takes time  <span class="math">\\hat{\\mathcal{O}} (m\\sqrt{p})</span>  by running  <span class="math">m</span> -times Khovratovich's  <span class="math">\\hat{\\mathcal{O}} (\\sqrt{p})</span>  attack [20].</p>

    <p class="text-gray-300">We run  <span class="math">\\Theta(m)</span>  key-dependent walks  <span class="math">\\overline{W}_{k_{\\ell}}</span>  using  <span class="math">m</span>  oracles  <span class="math">L_{k_{\\ell}}(\\cdot), 1 \\leq \\ell \\leq m</span> , and as opposed to Sections III and IV no key-independent walk. These walks give us  <span class="math">\\Omega(m)</span>  mutual collisions. Let us assume that two walks  <span class="math">\\overline{W}_{k_{\\ell}}, \\overline{W}_{k_{\\ell&#x27;}}</span>  with different keys  <span class="math">k_{i} \\neq k_{j}</span>  collide. Then there exist  <span class="math">x_{\\ell}^{(u)}, x_{\\ell&#x27;}^{(v)}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">L _ {k _ {i}} \\left(x _ {\\ell} ^ {(u)}\\right) = L _ {k _ {j}} \\left(x _ {\\ell^ {\\prime}} ^ {(v)}\\right) = L \\left(x _ {\\ell^ {\\prime}} ^ {(v)} + k _ {j}\\right).</span></div>

    <p class="text-gray-300">Using Lemma 1, we conclude that</p>

    <div class="my-4 text-center"><span class="math-block">k _ {i} - k _ {j} = x _ {\\ell^ {\\prime}} ^ {(v)} - x _ {\\ell} ^ {(u)} \\bmod p. \\tag {4}</span></div>

    <p class="text-gray-300">Thus, every collision among two walks defines a relation as in Equation (4) between two keys  <span class="math">k_{i}, k_{j}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us define an undirected graph  <span class="math">G = (V, E)</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m<span class="math">  and an initially empty edge set  </span>E<span class="math"> . Every relation as in Equation (4) adds an edge  </span>\\{i, j\\}<span class="math">  to  </span>E<span class="math">  with label  </span>\\ell_{ij} = x_{\\ell'}^{(v)} - x_{\\ell}^{(u)} \\in \\mathbb{F}_p$ . Assume that we collected sufficiently many</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">edges such that  <span class="math">G</span>  gets connected, i.e.  <span class="math">G</span>  contains a spanning tree  <span class="math">T</span> . Take an arbitrary vertex  <span class="math">i \\in T</span>  corresponding to key  <span class="math">k_{i}</span> . Compute  <span class="math">k_{i}</span>  in time  <span class="math">\\hat{\\mathcal{O}}(\\sqrt{p})</span>  using Khovratovich's algorithm. Now, traverse  <span class="math">T</span>  starting in vertex  <span class="math">i</span> . Let  <span class="math">\\{i,j\\}</span>  be the first traversal edge with label  <span class="math">\\ell_{ij}</span> . Using the relation from Equation (4), we conclude that  <span class="math">k_{j} = k_{i} - \\ell_{ij}</span> . Thus, by traversing  <span class="math">T</span>  we recover all  <span class="math">m</span>  keys.</p>

    <p class="text-gray-300">In our algorithm, we will not wait until  <span class="math">G</span>  gets fully connected, since by the results of Erdős, Renyi [10] this requires  <span class="math">\\Omega(m \\log m)</span>  relations. Instead, we use from Erdős, Renyi [10] that after  <span class="math">\\Omega(m)</span>  relations,  <span class="math">G</span>  has a so-called giant component  <span class="math">V_G \\subseteq V</span> , a connected set of vertices that contains all but a (small) constant fraction of  <span class="math">V</span> . We compute a spanning tree  <span class="math">T</span>  in this giant component  <span class="math">V_G</span> , and recover by the above algorithm all keys within  <span class="math">V_G</span> . We then remove the known keys, and recursively run our algorithm on the remaining keys.</p>

    <p class="text-gray-300">Recall that we have to address a technical collision-detection issue, since as opposed to our algorithms from Sections III and IV we do no longer collide into some precomputed structure. Instead, our online walks mutually collide. In order to detect these collisions, we use the van Oorschot-Wiener distinguished point strategy [27].</p>

    <p class="text-gray-300">Let  <span class="math">g = (g_{1},\\ldots ,g_{r})\\in P</span>  be a Legendre point. Fix a random  <span class="math">d\\in \\{0,1\\} ^k</span>  with  <span class="math">k\\leq r</span> . Then we call  <span class="math">g</span>  distinguished if</p>

    <div class="my-4 text-center"><span class="math-block">(g _ {1}, \\dots , g _ {k}) = d,</span></div>

    <p class="text-gray-300">i.e., the Legendre point  <span class="math">g</span>  starts on its first  <span class="math">k</span>  coordinates with  <span class="math">d</span> . Under Heuristic 1, any random Legendre point is distinguished with probability  <span class="math">q = 2^{-k}</span> .</p>

    <p class="text-gray-300">Now, we run every walk  <span class="math">\\overline{W}_{k_{\\ell}}</span>  until it hits a distinguished point  <span class="math">g</span> , see Figure 3. We then store this distinguished points  <span class="math">g</span>  in a sorted list  <span class="math">\\mathcal{L}</span> . In our algorithm we choose  <span class="math">q</span>  (and therefore  <span class="math">k \\approx \\log(1/q)</span> ) such that with good probability our walks have the desired lengths. Assume now that two walks  <span class="math">\\overline{W}_{k_i}, \\overline{W}_{k_j}</span>  with different keys  <span class="math">k_i \\neq k_j</span>  collide. Then there exist  <span class="math">x_{\\ell}^{(u)}, x_{\\ell&#x27;}^{(v)}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">L _ {k _ {i}} \\left(x _ {\\ell} ^ {(u)}\\right) = L _ {k _ {j}} \\left(x _ {\\ell^ {\\prime}} ^ {(v)}\\right),</span></div>

    <p class="text-gray-300">from which we conclude via Equation (4) that</p>

    <div class="my-4 text-center"><span class="math-block">x _ {\\ell} ^ {(u)} = x _ {\\ell^ {\\prime}} ^ {(v)} + k _ {j} - k _ {i}.</span></div>

    <p class="text-gray-300">Analogous to Section III we show that once  <span class="math">\\overline{W}_{k_i},\\overline{W}_{k_j}</span>  collide, they stay in the same Legendre points, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">L _ {k _ {i}} \\left(x _ {\\ell} ^ {(u + 1)}\\right) = L _ {k _ {j}} \\left(x _ {\\ell^ {\\prime}} ^ {(v + 1)}\\right).</span></div>

    <p class="text-gray-300">This follows from</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} L _ {k _ {i}} \\left(x _ {\\ell} ^ {(u + 1)}\\right) = L _ {k _ {i}} \\left(x _ {\\ell} ^ {(u)} + f \\left(L _ {k _ {i}} \\left(x _ {\\ell} ^ {(u)}\\right)\\right)\\right) \\\\ = L _ {k _ {i}} \\left(x _ {\\ell^ {\\prime}} ^ {(v)} + k _ {j} - k _ {i} + f \\left(L _ {k _ {i}} \\left(x _ {\\ell^ {\\prime}} ^ {(v)} + k _ {j} - k _ {i}\\right)\\right)\\right) \\\\ = L \\left(x _ {\\ell^ {\\prime}} ^ {(v)} + k _ {j} + f \\left(L \\left(x _ {\\ell^ {\\prime}} ^ {(v)} + k _ {j}\\right)\\right)\\right) \\\\ = L _ {k _ {j}} \\left(x _ {\\ell^ {\\prime}} ^ {(v)} + f \\left(L _ {k _ {j}} \\left(x _ {\\ell^ {\\prime}} ^ {(v)}\\right)\\right)\\right) \\\\ = L _ {k _ {j}} \\left(x _ {\\ell^ {\\prime}} ^ {(v + 1)}\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Hence,  <span class="math">\\overline{W}_{k_i},\\overline{W}_{k_j}</span>  must eventually hit the same distinguished point  <span class="math">g = L_{k_i}(x_\\ell^{(u + c)}) = L_{k_j}(x_{\\ell &#x27;}^{(v + c)})\\in \\mathcal{L}</span>  for some  <span class="math">c\\geq 0</span>  . This allows us to derive a relation as in Equation (4).</p>

    <p class="text-gray-300">This ends the high-level description of our algorithm. The resulting procedure MULT-LEGENDRE is described in Algorithm 3.</p>

    <p class="text-gray-300">Theorem 3: Assume that we are given oracle access to  <span class="math">m</span>  Legendre PRFs  <span class="math">L_{k_1}(\\cdot),\\ldots ,L_{k_m}(\\cdot):\\mathbb{F}_p\\to P</span> . Under Heuristic 1, algorithm MULT-LEGENDRE finds all  <span class="math">k_{1},\\dots ,k_{m}</span>  in total time  <span class="math">\\tilde{\\mathcal{O}} (\\sqrt{mp})</span>  with overwhelming success probability.</p>

    <p class="text-gray-300">Proof: The correctness of MULT-LEGENDRE follows from the discussion above. In the following we show that in a single run of MULT-LEGENDRE we obtain with overwhelming probability  <span class="math">1 - \\mathrm{negl}(m)</span>  at least  <span class="math">98\\%</span>  of all keys.</p>

    <p class="text-gray-300">In a nutshell, we first prove that with overwhelming probability  <span class="math">3m</span>  out of our  <span class="math">4m</span>  walks  <span class="math">\\overline{W}_{k_{\\ell},i}</span>  perform at least  <span class="math">\\frac{t}{m}</span>  steps. From this we conclude that we obtain at least  <span class="math">2m</span>  key relations as in Equation (4), which in turn gives as a giant component in  <span class="math">G</span>  that allows us to recover at least  <span class="math">98\\%</span>  of our Legendre keys.</p>

    <p class="text-gray-300">Let us first prove that at least a  <span class="math">\\frac{3}{4}</span> -fraction of our random walks have length at least  <span class="math">\\frac{t}{m}</span> . Notice that all walks either hit a distinguished point, or run into a self loop. We detect potential self loop in line 11, hence we may assume w.l.o.g. that all walks end in a distinguished point.</p>

    <p class="text-gray-300">Let  <span class="math">X_{\\ell,i}</span>  be an indicator variable that takes value 1 iff walk  <span class="math">\\overline{W}_{k_{\\ell},i}</span>  has length at least  <span class="math">\\frac{t}{m}</span> . We hit a distinguished point with probability  <span class="math">2^{-k} \\leq q</span> . This implies</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ X _ {\\ell , i} = 1 \\right] \\geq (1 - q) ^ {\\frac {t}{m}} = \\left(1 - \\frac {m}{5 t}\\right) ^ {\\frac {t}{m}} \\geq 1 - \\frac {1}{5} = \\frac {4}{5}.</span></div>

    <p class="text-gray-300">Let  <span class="math">X = \\sum_{\\ell=1}^{m} \\sum_{i=1}^{4} X_{\\ell,i}</span> . Then the expected number of walks with length at least  <span class="math">\\frac{t}{m}</span>  is at least  <span class="math">\\mathbb{E}[X] \\geq \\frac{16}{5} m</span> . Let  <span class="math">\\mu = \\frac{16}{5} m</span> . Using the Chernoff bound  <span class="math">\\operatorname*{Pr}[X \\leq (1 - \\delta)\\mu] \\leq e^{-\\mu \\delta^2 / 2}</span> , we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ X \\leq 3 m ] \\leq e ^ {- \\frac {m}{1 6 0}}.</span></div>

    <p class="text-gray-300">Hence, with overwhelming probability  <span class="math">1 - \\mathrm{negl}(m)</span>  we obtain at least  <span class="math">3m + 1</span>  walks of length at least  <span class="math">\\frac{t}{m}</span> . In the following analysis, we consider those online walks with minimum length  <span class="math">\\frac{t}{m}</span> . We define an indicator variable  <span class="math">Y_{\\ell,\\ell&#x27;}</span></p>

    <p class="text-gray-300">Algorithm 3: MULT-LEGENDRE Input:  <span class="math">p,L_{k_1}(\\cdot),\\ldots ,L_{k_m}(\\cdot):\\mathbb{F}_p\\to P</span>  with  <span class="math">P = \\{L(y)\\mid y\\in \\mathbb{F}_p\\} \\subset \\{0,\\pm 1\\}^{\\lceil 3\\log p\\rceil}</span>  Output:  <span class="math">\\{k_1,\\dots ,k_m\\} \\in \\mathbb{Z}_p^m</span> 1 begin 2 Choose  <span class="math">t = \\lceil \\sqrt{mp}\\rceil</span> 3 Define random  <span class="math">f:P\\rightarrow \\mathbb{F}_p</span> 4 Set  <span class="math">q = \\frac{m}{5t}</span>  and  <span class="math">k = \\lceil \\log (1 / q)\\rceil</span> 5 Choose a random  <span class="math">d\\in \\{0,1\\} ^k</span> 6 Let  <span class="math">D = d\\times \\{0,1\\}^{r - k}\\subset P</span> 7 for  <span class="math">\\ell = 1,\\dots ,m</span>  do 8 for  <span class="math">i = 1,\\dots ,4</span>  do 9 Choose a random  <span class="math">x_{\\ell}^{(1)}\\in \\mathbb{F}_{p}</span> 10 Run from  <span class="math">L_{k_{\\ell}}(x_{\\ell}^{(1)})</span>  a random walk  <span class="math">\\overline{W}_{k_{\\ell},i}</span> <span class="math">x_{\\ell}^{(j + 1)} = x_{\\ell}^{(j)} + f(L_{k_{\\ell}}(x_{\\ell}^{(j)}))\\mod p,</span>  until  <span class="math">\\overline{W}_{k_{\\ell},i}</span>  hits a distinguished point  <span class="math">g_{\\ell} = L_{k_{\\ell}}(x_{\\ell}^{(j_{\\ell})})\\in D.</span>  if  <span class="math">\\overline{W}_{k_{\\ell},i}</span>  takes more than  <span class="math">8\\frac{t}{m}</span>  steps then go back to step 9.  <span class="math">\\triangleright</span>  detect loop 12 Store  <span class="math">(g_{\\ell},\\ell ,x_{\\ell}^{(j_{\\ell})})</span>  in list L. 13 end 14 end 15 Sort  <span class="math">\\mathcal{L}</span>  by its  <span class="math">1^{st}</span>  entry. 16 Define an undirected graph  <span class="math">G = (\\{1,\\dots m\\} ,\\emptyset)</span> 17 for every  <span class="math">(g_{\\ell},\\ell ,x_{\\ell}^{(j_{\\ell})})\\neq (g_{\\ell},\\ell^{\\prime},x_{\\ell^{\\prime}}^{(j_{\\ell^{\\prime}})})\\in \\mathcal{L}</span>  do 18 if  <span class="math">\\ell \\neq \\ell^{\\prime}</span>  then Include in  <span class="math">E</span>  edge  <span class="math">\\{\\ell ,\\ell &#x27;\\}</span>  with label  <span class="math">x_{\\ell^{\\prime}}^{(j_{\\ell^{\\prime}})} - x_{\\ell}^{(j_{\\ell})}</span> 20 end 21 Compute  <span class="math">G</span>  's largest connected component  <span class="math">V_{G} = \\{v_{1},\\dots v_{b}\\}</span>  and a spanning tree  <span class="math">T</span>  of  <span class="math">V_{G}</span> 22 Compute  <span class="math">k_{v_1}</span>  with Khovratovich's algorithm. 23 return  <span class="math">k_{v_1},\\ldots ,k_{v_b}</span>  by traversing  <span class="math">T</span> 24 Recursively call MULT-LEGENDRE with the remaining keys  <span class="math">\\{k_1,\\dots ,k_m\\} \\setminus \\{k_{v_1},\\dots ,k_{v_b}\\}</span></p>

    <p class="text-gray-300">that takes value 1 iff walks  <span class="math">\\overline{W}_{k_{\\ell},i}</span>  and  <span class="math">\\overline{W}_{k_{\\ell&#x27;},i&#x27;}</span>  for any  <span class="math">i,i&#x27; \\in \\{1,2,3,4\\}</span>  collide. Using  <span class="math">t^2 \\geq mp</span> , we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ Y _ {\\ell , \\ell^ {\\prime}} = 1 \\right] \\geq 1 - \\left(\\frac {p - \\frac {t}{m}}{p}\\right) ^ {\\frac {t}{m}} = 1 - \\left(1 - \\frac {t}{m p}\\right) ^ {\\frac {t}{m}} \\\\ \\geq 1 - e ^ {- \\frac {t ^ {2}}{m ^ {2} p}} \\geq \\frac {t ^ {2}}{2 m ^ {2} p} \\geq \\frac {1}{2 m}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Note that  <span class="math">Y_{\\ell, \\ell&#x27;} = 1</span>  iff walks  <span class="math">\\overline{W}_{k_{\\ell}, i}, \\overline{W}_{k_{\\ell&#x27;}, i&#x27;}</span>  give us a relation on two Legendre keys. Thus, in total we obtain at least  <span class="math">Y := \\sum_{1 \\leq \\ell &amp;lt; \\ell&#x27; \\leq 3m + 1} Y_{\\ell, \\ell&#x27;}</span>  key relations. Therefore, the expected number of relations is at least</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ Y ] \\geq \\left( \\begin{array}{c} 3 m + 1 \\\\ 2 \\end{array} \\right) \\cdot \\frac {1}{2 m} \\geq \\frac {9}{4} m.</span></div>

    <p class="text-gray-300">Notice that a  <span class="math">\\frac{1}{m}</span> -fraction of the relations are useless, since they do not satisfy condition  <span class="math">\\ell \\neq \\ell&#x27;</span>  in line 18, i.e. they involve the same key. Moreover, MULT-LEGENDRE may produce the same edge  <span class="math">\\{\\ell, \\ell&#x27;\\}</span>  several times. However, it is easy to see that the expected number of these duplicates is constant. After subtracting these (in total constant many) useless relations, we conclude via another Chernoff bound argument that  <span class="math">Y \\geq 2m</span>  with overwhelming probability.</p>

    <p class="text-gray-300">From the results of Erdős and Renyi [10] we know that graphs with  <span class="math">m</span>  vertices and  <span class="math">cm := 2m &amp;gt; \\frac{m}{2}</span>  randomly chosen edges contain with overwhelming probability a connected component of size at least</p>

    <div class="my-4 text-center"><span class="math-block">\\left(1 - \\frac {1}{2 c} \\sum_ {k = 1} ^ {\\infty} \\frac {k ^ {k - 1}}{k !} (2 c e ^ {- 2 c}) ^ {k}\\right) m &amp;gt; 0. 9 8 m.</span></div>

    <p class="text-gray-300">This eventually enables us to recover at least  <span class="math">98\\%</span>  of all Legendre keys in a single run of MULT-LEGENDRE.</p>

    <p class="text-gray-300">It remains to show the running time for recovering all keys  <span class="math">k_{1}, \\ldots, k_{m}</span> . Let us consider the two for-loops that construct  <span class="math">4m</span>  walks. We repeat the inner loop, whenever we encounter a walk that takes more than  <span class="math">8\\frac{t}{m}</span>  steps. This happens with probability at most</p>

    <div class="my-4 text-center"><span class="math-block">(1 - q) ^ {\\frac {8 t}{m}} \\leq e ^ {- \\frac {8}{5}} \\approx 0. 2.</span></div>

    <p class="text-gray-300">Thus, in each iteration of our for-loops with probability at least  <span class="math">\\frac{4}{5}</span>  a walk hits a distinguished point within  <span class="math">8\\frac{t}{m}</span>  steps and stops. Let  <span class="math">Y</span>  be a random variable for the number of iterations in both for-loops. Then  <span class="math">\\mathbb{E}[Y] \\leq 4m \\cdot \\frac{5}{4} = 5m</span> . By Markov's inequality</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ Y \\geq 1 0 m ] \\leq \\frac {5 m}{1 0 m} = \\frac {1}{2}.</span></div>

    <p class="text-gray-300">Hence, with probability at least  <span class="math">\\frac{1}{2}</span>  our walk construction is completed by running at most  <span class="math">10m</span>  iterations of length at most  <span class="math">8\\frac{t}{m}</span> . This takes time at most  <span class="math">\\tilde{\\mathcal{O}}(t)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On walk completion, our list  <span class="math">\\mathcal{L}</span>  contains  <span class="math">4m</span>  entries. Thus,  <span class="math">G = (V,E)</span>  can be constructed in time  <span class="math">\\tilde{\\mathcal{O}}(m)</span> . We run Depth First Search (DFS) on  <span class="math">G</span>  to compute a DFS tree  <span class="math">T</span>  of its giant component in time  $\\mathcal{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathcal{O}(m)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Khovratovich's algorithm in line 22 runs in time  <span class="math">\\tilde{\\mathcal{O}} (\\sqrt{p})</span>  and a traversal of  <span class="math">T</span>  can be done in time  <span class="math">\\mathcal{O}(m)</span> . Since  <span class="math">m\\leq p</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">m = \\sqrt {m} \\cdot \\sqrt {m} \\leq \\sqrt {m p} &amp;lt;   t.</span></div>

    <p class="text-gray-300">Thus, we obtain total run time  <span class="math">\\tilde{\\mathcal{O}}(t + m) = \\tilde{\\mathcal{O}}(t) = \\tilde{\\mathcal{O}}(\\sqrt{mp})</span>  of one iteration of MULT-LEGENDRE. As shown before, every iteration of MULT-LEGENDRE recovers at least a  <span class="math">98\\%</span>  fraction of Legendre keys. Hence, we recover all Legendre keys in time</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T (m, p) = \\tilde {\\mathcal {O}} (\\sqrt {m p}) + T (0. 0 2 m, p) \\\\ &amp;lt;   \\tilde {\\mathcal {O}} \\left(\\sum_ {i = 0} ^ {\\infty} (\\sqrt {0 . 0 2}) ^ {i} \\sqrt {m p}\\right) &amp;lt;   \\tilde {\\mathcal {O}} (1. 1 7 \\sqrt {m p}) \\\\ = \\tilde {\\mathcal {O}} (\\sqrt {m p}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Number of random walk steps as a function of  <span class="math">p</span>  on a double logarithmic scale. Comparison of our algorithm PRE-LEGENDRE, PRE-MULT-LEGENDRE ( <span class="math">m = p^{1/6}</span> ) and MULT-LEGENDRE ( <span class="math">m = p^{1/3}</span> ) to analogous discrete logarithm algorithms. Each data point is averaged over 10 samples, corresponding data points are interpolated by lines.</p>

    <p class="text-gray-300">Pre-Legendre Pre-Dlog ■Pre-Mult-Legendre Pre-Mult-Dlog Mult-Legendre Mult-Dlog</p>

    <p class="text-gray-300">Since our algorithms for computing the Legendre symbol involve the (natural) Heuristic 1 concerning uniformity of Legendre points, we check the validity of Heuristic 1 and therefore the statements of Theorems 1 to 3 experimentally. To this end, we implemented all three Legendre key algorithms PRE-LEGENDRE, PRE-MULT-LEGENDRE and MULT-LEGENDRE and analyzed the number of random walk steps as a function of the field size  <span class="math">p</span> .</p>

    <p class="text-gray-300">Let  <span class="math">g^{k_{\\ell}}</span>  be a discrete logarithm problem. For better comparison with our Legendre PRF algorithms, we also implemented discrete logarithm algorithms in the same field  <span class="math">\\mathbb{F}_p</span>  using analogous key-independent and key-dependent walks</p>

    <p class="text-gray-300"><span class="math">x^{(i + 1)} = g^{x^{(i)}}\\mod p</span>  , respectively  <span class="math">x^{(i + 1)} = g^{k_{\\ell}}\\cdot g^{x^{(i)}}\\mod p</span></p>

    <p class="text-gray-300">All benchmarks were performed on an Intel i7-8550U CPU @ 1.80GHz. Each data point represents the average over 10 samples. Our code is publically available at https://github.com/FloydZ/prep-legendre.</p>

    <p class="text-gray-300">The results are depicted in Figure 4. We see that our Legendre algorithms require as many random walk steps as the corresponding discrete logarithm implementations. This is what we expect under Heuristic 1. We therefore believe that precise estimations for the number of random walk steps - including the constant hidden in the  <span class="math">\\mathcal{O}</span> -notation, as extensively analyzed in the discrete logarithm literature (see Table 3 in [16] for an overview) - directly translate to the Legendre PRF setting.</p>

    <p class="text-gray-300">We experimentally validated the run time statements of our Theorems 1 to 3 as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pre-Legendre: Using the parameter choice <span class="math">s=t=p^{\\frac{1}{3}}</span>, we precomputed a hint of size <span class="math">s=p^{\\frac{1}{3}}</span>. In Figure 4, we depict the corresponding number of random walk steps in the online phase on a logarithmic scale. By Theorem 1, we require online at most <span class="math">t=p^{1/3}</span> random walk steps to recover the Legendre key with constant success probability. In our experiments, we repeated an unsuccessful <span class="math">t</span>-step random online walk with a different starting point, until we eventually found the Legendre key, see also Remark 1. Thus, we always succeeded at the cost of a slightly increased running time. The interpolation line through our data points has a slope of 0.34, showing that thereby we do not significantly sacrifice run time.</li>

      <li>Pre-Mult-Legendre: We chose to attack <span class="math">m=p^{\\frac{1}{6}}</span> with the parameter choice <span class="math">s=p^{\\frac{1}{3}}</span> and <span class="math">t=p^{\\frac{1}{2}}</span>. That is, we again precomputed a hint of size <span class="math">s=p^{\\frac{1}{3}}</span>. By Theorem 2, we require in total only <span class="math">t=p^{\\frac{1}{2}}</span> random walk steps to recover each key with constant success probability. As in the experiments for Pre-Legendre, we also repeated in the multiple-key setting unsuccessful walks with different starting points, until we eventually recovered the desired key, see Remark 2. Thus, our data points in Figure 4 reflect the total online time to recover all <span class="math">m=p^{\\frac{1}{6}}</span> keys. The slope of the interpolation line is 0.52, again showing that we only marginally sacrifice run time to recover all keys.</li>

      <li>Mult-Legendre: In the multiple-key setting without precomputation, we chose to attack <span class="math">m=p^{\\frac{4}{3}}</span> keys. By the proof Theorem 3, a single run of Mult-Legendre gives us at least <span class="math">2m</span> Legendre key relations, from which we can recover those keys that lie in the giant component of the graph <span class="math">G</span>. Experimentally, we recover on average 3.46<span class="math">m</span> relations. The collection step of our key relations is supposed to finish in time <span class="math">\\tilde{\\mathcal{O}}(\\sqrt{mp})=\\tilde{\\mathcal{O}}(p^{\\frac{2}{3}})</span>, which is validated by the slope 0.64 of our interpolation line.</li>

    </ul>

    <h2 id="sec-27" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Akshima, Cash, D., Drucker, A., Wee, H.: Time-space tradeoffs and short collisions in merkle-damgård hash functions. In: Micciancio, D., Ristenpart, T. (eds.) CRYPTO 2020, Part I. LNCS, vol. 12170, pp. 157–186. Springer, Heidelberg (Aug 2020)</li>

      <li>[2] Bach, E.: Realistic analysis of some randomized algorithms. Journal of Computer and System Sciences 42(1), 30–53 (1991)</li>

      <li>[3] Bernstein, D.J., Lange, T.: Computing small discrete logarithms faster. In: Galbraith, S.D., Nandi, M. (eds.) INDOCRYPT 2012. LNCS, vol. 7668, pp. 317–338. Springer, Heidelberg (Dec 2012)</li>

      <li>[4] Beullens, W., Beyne, T., Udovenko, A., Vitto, G.: Cryptanalysis of the Legendre PRF and generalizations. IACR Trans. Symm. Cryptol. 2020(1), 313–330 (2020)</li>

      <li>[5] Beullens, W., de Saint Guilhem, C.: LegRoast: Efficient post-quantum signatures from the Legendre PRF. In: Ding, J., Tillich, J.P. (eds.) Post-Quantum Cryptography - 11th International Conference, PQCrypto 2020. pp. 130–150. Springer, Heidelberg (2020)</li>

      <li>[6] Coretti, S., Dodis, Y., Guo, S., Steinberger, J.: Random oracles and non-uniformity. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 227–258. Springer (2018)</li>

      <li>[7] Corrigan-Gibbs, H., Kogan, D.: The discrete-logarithm problem with preprocessing. In: Nielsen, J.B., Rijmen, V. (eds.) EUROCRYPT 2018, Part II. LNCS, vol. 10821, pp. 415–447. Springer, Heidelberg (Apr / May 2018)</li>

      <li>[8] Damgård, I.: On the randomness of legendre and jacobi sequences. In: Goldwasser, S. (ed.) Advances in Cryptology - CRYPTO ’88, 8th Annual International Cryptology Conference, Santa Barbara, California, USA, August 21-25, 1988, Proceedings. Lecture Notes in Computer Science, vol. 403, pp. 163–172. Springer (1988), https://doi.org/10.1007/0-387-34799-2_13</li>

      <li>[9] Davenport, H.: On the distribution of quadratic residues (mod p). Journal of the London Mathematical Society s1-8(1), 46–52 (1933), https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/jlms/s1-8.1.46</li>

      <li>[10] Erdős, P., Rényi, A.: On the evolution of random graphs. Publ. Math. Inst. Hung. Acad. Sci 5(1), 17–60 (1960)</li>

      <li>[11] Escott, A., Sager, J., Selkirk, A., Tsapakidis, D.: Attacking elliptic curve cryptosystems using the parallel pollard rho method. CryptoBytes–The Technical Newsletter of RSA Laboratories 4(2), 15–19 (1999)</li>

      <li>[12] Esser, A., May, A.: Low weight discrete logarithm and subset sum in <span class="math">2^{0.65n}</span> with polynomial memory. In: Canteaut, A., Ishai, Y. (eds.) EUROCRYPT 2020, Part III. LNCS, vol. 12107, pp. 94–122. Springer, Heidelberg (May 2020)</li>

      <li>[13] Foundation, E.: Ethereum 2.0 (2020), https://ethereum.org/en/eth2/</li>

      <li>[14] Foundation, E.: Ethereum 2.0 (2020), https://github.com/ethereum/eth2.0-specs</li>

      <li>[15] Fouque, P.A., Joux, A., Mavromati, C.: Multi-user collisions: Applications to discrete logarithm, Even-Mansour and PRINCE. In: Sarkar, P., Iwata, T. (eds.) ASIACRYPT 2014, Part I. LNCS, vol. 8873, pp. 420–438. Springer, Heidelberg (Dec 2014)</li>

      <li>[16] Galbraith, S.D., Wang, P., Zhang, F.: Computing elliptic curve discrete logarithms with improved baby-step giant-step algorithm. Advances in Mathematics of Communications 11(3), 453 (2017)</li>

      <li>[17] Grassi, L., Rechberger, C., Rotaru, D., Scholl, P., Smart, N.P.: MPC-friendly symmetric key primitives. In: Weippl, E.R., Katzenbeisser, S., Kruegel, C., Myers, A.C., Halevi, S. (eds.) ACM CCS 2016. pp. 430–443. ACM Press (Oct 2016)</li>

      <li>[18] Ishai, Y., Kushilevitz, E., Ostrovsky, R., Sahai, A.: Zero-knowledge proofs from secure multiparty computation. SIAM Journal on Computing 39(3), 1121–1152 (2009)</li>

      <li>[19] Kaluderovic, N., Kleinjung, T., Kostic, D.: Improved key recovery on the legendre PRF (2020), https://eprint.iacr.org/2020/098</li>

      <li>[20] Khovratovich, D.: Key recovery attacks on the Legendre PRFs within the birthday bound. Cryptology ePrint Archive, Report 2019/862 (2019), https://eprint.iacr.org/2019/862</li>

      <li>[21] Kuhn, F., Struik, R.: Random walks revisited: Extensions of Pollard’s rho algorithm for computing multiple discrete logarithms. In: Vaudenay, S., Youssef, A.M. (eds.) SAC 2001. LNCS, vol. 2259, pp. 212–229. Springer, Heidelberg (Aug 2001)</li>

      <li>[22] Lee, H.T., Cheon, J.H., Hong, J.: Accelerating ID-based encryption based on trapdoor DL using pre-computation. Cryptology ePrint Archive, Report 2011/187 (2011), http://eprint.iacr.org/2011/187</li>

      <li>[23] Mihalcik, J.P.: An analysis of algorithms for solving discrete logarithms in fixed groups. master’s thesis. Naval Postgraduate School (2010), https://calhoun.nps.edu/bitstream/handle/10945/5395/10Mar_Mihalcik.pdf</li>

      <li>[24] Peralta, R.: On the distribution of quadratic residues and non-residues modulo a prime number. Mathematics of Computation 58(197), 433–440 (1992)</li>

      <li>[25] Pollard, J.M.: Monte carlo methods for index computation (mod p). Mathematics of computation 32(143), 918–924 (1978)</li>

      <li>[26] Russell, A., Shparlinski, I.E.: Classical and quantum function reconstruction via character evaluation. Journal of Complexity 20(2-3), 404–422 (2004)</li>

      <li>[27] van Oorschot, P.C., Wiener, M.J.: Parallel collision search with cryptanalytic applications. Journal of Cryptology 12(1), 1–28 (Jan 1999)</li>

    </ul>`;
---

<BaseLayout title="Legendre PRF (Multiple) Key Attacks and the Power of Preproc... (2021/645)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/645
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
