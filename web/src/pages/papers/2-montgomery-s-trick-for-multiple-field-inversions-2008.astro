---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2008/199';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Simultaneous field divisions: an extension of Montgomery&#x27;s trick';
const AUTHORS_HTML = 'David G.  Harris';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Montgomery&#x27;s trick is a technique which can be used to quickly compute multiple field inversion simultaneously. We extend this technique to simultaneous field divisions (that is, combinations of field multiplications and field inversion). The generalized Montgomery&#x27;s trick is faster in some fields than a simple inversion with Montgomery&#x27;s trick followed by a simple field multiplication</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Montgomery&#x27;s trick &middot; simultaneous inversion &middot; simultaneous division &middot; elliptic curve cryptosystem</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Field inversions are typically expensive to compute, requiring far more operations than simpler computations such as addition and multiplication. For example, inversion in a prime field requires computing an Extended GCD. If we have many independent inversions to compute, i.e. we want to compute</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{y_i} \\qquad i = 1, \\dots, N</span>$</p>

    <p class="text-gray-300">then the algorithm known as Montgomery's trick can be used to produce all N inverses simultaneously, at the cost of just one field inversion and 3N-2 field multiplications. In Section 2, we will review this algorithm.</p>

    <p class="text-gray-300">Often, however, the field inversion is part of a larger arithmetic computation. Suppose we wish to compute</p>

    <p class="text-gray-300"><span class="math">$\\frac{c}{y_i}</span>$
or  <span class="math">\\frac{c x_i}{y_i}</span></p>

    <p class="text-gray-300">Here, c is some constant multiplier applied to all of the N computations, and  <span class="math">x_i</span>  (optional) is some numerator that varies among the N separate computations. For example, to double an elliptic curve point (X,Y) in affine coordinates, one needs to compute</p>

    <p class="text-gray-300"><span class="math">$\\lambda = \\frac{3X^2 + a}{2Y}</span>$</p>

    <p class="text-gray-300">where a is a constant parameter of the elliptic curve.</p>

    <p class="text-gray-300">In this case, the simplest approach would be to use the numerator  <span class="math">x_i = 3X^2 + a</span> , the denominator  <span class="math">y_i = Y</span> , and the constant multiplier c = 1/2. As we will see, a better approach is to set  <span class="math">x_i = X^2 + (a/3)</span> ,  <span class="math">y_i = Y</span> , and the constant multiplier c = 3/2.</p>

    <p class="text-gray-300">Of course, we could use Montgomery's trick to compute all the denominators  <span class="math">1/y_i</span> , and then multiply by the numerators c and  <span class="math">x_i</span> , at the cost of additional field multiplications. There have been many applications of Montgomery's trick to elliptic curve arithmetic, such as [1] and [2], and they apparently have all followed this plan.</p>

    <p class="text-gray-300">However, there is an alternative, which is to modify Montgomery's trick to incorporate the multiplication of  <span class="math">x_i</span>  and c with the field inversion. In Section 4, we will describe how to do this. Because our algorithm incorporates a numerator as well as a denominator, we refer to this as a field <em>division</em> algorithm, as opposed to merely field <em>inversion</em>.</p>

    <p class="text-gray-300">We will first review Montgomery's trick for simultaneous field inversions as described in [1]. We are given N field elements  <span class="math">y_i \\in F</span> , and wish to compute  <span class="math">1/y_i</span>  for i = 1, ..., N. We will do this by performing two separate &quot;passes&quot; through the data. In the forward pass, we initialize  <span class="math">r_1 = y_i</span>  and compute the forward products</p>

    <p class="text-gray-300"><span class="math">$r_i = r_{i-1} \\times y_i, \\qquad i = 2, \\dots, N</span>$</p>

    <p class="text-gray-300">When this is done, we have  <span class="math">r_N = \\prod_{i=1}^N y_i</span> . We compute a single field inversion</p>

    <p class="text-gray-300"><span class="math">$I = r_N^{-1}</span>$</p>

    <p class="text-gray-300">Next, we enter the backward pass. To begin, we set  <span class="math">t_N = I</span>  and then for</p>

    <p class="text-gray-300"><span class="math">i = N, \\ldots, 2</span> , we compute the two products</p>

    <p class="text-gray-300"><span class="math">$1/y_i = t_i \\times r_{i-1}</span>$</p>

    <p class="text-gray-300"><span class="math">$t_{i-1} = t_i \\times y_i</span>$</p>

    <p class="text-gray-300">To finish, we set</p>

    <p class="text-gray-300"><span class="math">$1/y_1 = t_1</span>$</p>

    <p class="text-gray-300">In total, this algorithm requires a single field inverse; in the forward pass, it requires N-1 field multiplications; and in the backward pass, it requires 2N-2 field multiplications.</p>

    <p class="text-gray-300">One observation has been apparently overlooked or at least underestimated: the backward pass's two multiplications share a common factor. That is, instead of performing two unrelated multiplications</p>

    <p class="text-gray-300"><span class="math">$a \\times b</span>$
<span class="math">c \\times d</span></p>

    <p class="text-gray-300">we are performing two related multiplications</p>

    <p class="text-gray-300"><span class="math">$a \\times b</span>$
<span class="math">a \\times c</span></p>

    <p class="text-gray-300">For some fields, it may be faster to compute these two related multiplications as compared to unrelated multiplications. We will discuss this more in Section 3. For the moment, let us simply summarize the cost of this algorithm as</p>

    <p class="text-gray-300"><span class="math">$Cost = (N-1) \\times M_1 + (2N-2) \\times M_2 + Inversion</span>$</p>

    <p class="text-gray-300">where  <span class="math">M_1</span>  is the cost of an ordinary field multiplication;  <span class="math">M_2</span>  is half the cost of a pair of &quot;double multiplications&quot;, i.e. multiplications involving a shared multiplicand; and Inversion is the cost of a field inversion.</p>

    <p class="text-gray-300">To simplify the costing,  <span class="math">\\operatorname{Cost}/N</span>  as  <span class="math">N\\to\\infty</span>  goes to</p>

    <p class="text-gray-300"><span class="math">$Cost/N \\rightarrow M_1 + 2M_2</span>$</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Double multiplication</h2>

    <p class="text-gray-300">Depending on the specific field, computing a double multiplication</p>

    <p class="text-gray-300"><span class="math">$a \\times b</span>$
<span class="math">a \\times c</span></p>

    <p class="text-gray-300">may be less expensive than computing two unrelated multiplications. In costing field arithmetic, it is well-known that squaring may be cheaper than a general multiplication. By the same token, these double multiplications may be cheaper too and should be accounted separately. The reason is that many methods of multiplication are based on &quot;transforming&quot; one or both multiplicands. In a double multiplication, we need only transform a once.</p>

    <p class="text-gray-300">For example, in very large prime fields, (e.g. 2000+ bits), field multiplication is generally structured as first an ordinary integer multiplication followed by a modular reduction. For the integer multiplication one views the multiplicands as integer polynomials, which one Fourier transforms, multiplies pointwise, and then inverse transforms the product. A double multiplication saves a transform compared to two ordinary multiplications.</p>

    <p class="text-gray-300">As another example, in small prime fields  <span class="math">\\mathbf{F}_p</span>  (e.g. 100&mdash;400 bits) one typically represents the multiplicands in &quot;Montgomery form.&quot; In this case, if the radix size of the computer is W, we represent a by  <span class="math">a_0, \\ldots, a_{k-1}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$a = W^k(a_0 + a_1W + a_2W^2 + \\dots + a_{k-1}W^{k-1}) \\mod p</span>$</p>

    <p class="text-gray-300">To double-multiply a by b and c, we can use the Montgomery multiplication formula</p>

    <p class="text-gray-300"><span class="math">$ab = \\sum_{i=0}^{k-1} ((aW^{-i}) \\mod p) \\times b_{k-1-i}</span>$
<span class="math">$ac = \\sum_{i=0}^{k-1} ((aW^{-i}) \\mod p) \\times c_{k-1-i}</span>$</p>

    <p class="text-gray-300">Again, we are &quot;transforming&quot; a by successively dividing it by powers of W; and this transformation can be shared between the two products.</p>

    <p class="text-gray-300">In some fields, a double multiplication is not noticeably faster than two ordinary multiplications. For example, in medium prime fields  <span class="math">\\mathbf{F}_p</span> , multiplication is most efficiently computed by Karatsuba multiplication followed by modular reduction or Montgomery reduction. The Karatsuba algorithm does not take advantage of the common factor.</p>

    <p class="text-gray-300">In general, then, we can say that double multiplication can sometimes be faster, for some fields, than ordinary multiplication.</p>

    <p class="text-gray-300">To return to the problem at hand, suppose we wish to compute something more complicated than a simple field inversion. At first, let us analyze the computation</p>

    <p class="text-gray-300"><span class="math">$c/y_i</span>$
<span class="math">i=1,\\ldots,N</span></p>

    <p class="text-gray-300">Using the inversion algorithm, we could compute the denominators  <span class="math">1/y_i</span>  at a per-unit cost  <span class="math">M_1+2M_2</span> . We could then multiply by the constant numerator</p>

    <p class="text-gray-300">c to get a total cost of</p>

    <p class="text-gray-300"><span class="math">$Cost = N \\times M_1 + (2N - 2) \\times M_2 + Inversion + NM_c</span>$</p>

    <p class="text-gray-300">As  <span class="math">N \\to \\infty</span> , the per-unit cost is</p>

    <p class="text-gray-300"><span class="math">$Cost/N \\rightarrow M_1 + 2M_2 + M_c</span>$</p>

    <p class="text-gray-300">Note that we are treating multiplication by c differently than an ordinary multiplication. In many applications, c is small or has special structure making multiplication by c significantly cheaper than a general field multiplication. For example, in the case of elliptic curve affine point doubling, c = 3/2. We can multiply by 3/2 with just a few bit-shifts and field additions, so the cost to multiply by c will be small, although not totally negligible.</p>

    <p class="text-gray-300">We will now show how to combine the multiplications by c with the multiple inversion algorithm, resulting in a lower cost. As before, we have a forward pass, a field inversion, and a backward pass.</p>

    <p class="text-gray-300">To begin, we initialize the forward pass with  <span class="math">r_1 = y_1</span> , and then for i = 2, ..., N compute</p>

    <p class="text-gray-300"><span class="math">$r_i = r_{i-1} \\times y_i</span>$</p>

    <p class="text-gray-300">When this is done, we have  <span class="math">r_N = \\prod y_i</span> . We next compute</p>

    <p class="text-gray-300"><span class="math">$I = c \\times r_N^{-1}</span>$</p>

    <p class="text-gray-300">Next, we enter the backward pass. To begin, we set  <span class="math">t_N = I</span>  and then for</p>

    <p class="text-gray-300"><span class="math">i = N, \\dots, 2</span>  we compute the two products</p>

    <p class="text-gray-300"><span class="math">$c/y_i = t_i \\times r_{i-1}</span>$</p>

    <p class="text-gray-300"><span class="math">$t_{i-1} = t_i \\times y_i</span>$</p>

    <p class="text-gray-300">and finish by</p>

    <p class="text-gray-300"><span class="math">$c/y_1 = t_1</span>$</p>

    <p class="text-gray-300">In total, the cost of the foward pass is  <span class="math">(N-1) \\times M_1</span> ; we then perform a modular inversion and a single multiplication by c; finally, the backward pass costs  <span class="math">(N-1) \\times 2M_2</span> . In total, the cost is</p>

    <p class="text-gray-300">Cost =
<span class="math">$(N-1)M_1 + (2N-2)M_2 + M_c + \\text{Inversion}</span>$</p>

    <p class="text-gray-300">As  <span class="math">N \\to \\infty</span> , the per-unit cost tends to</p>

    <p class="text-gray-300"><span class="math">$Cost/N \\rightarrow M_1 + 2M_2</span>$</p>

    <p class="text-gray-300">Note that the multiplication by c has been completely amortized away, just like the field inversion. Although the cost of multiplying by c may be small, it is not negligible. A side benefit is that, even if c has a special form, there is no need for specialized computer code to multiply by it since it is no longer a time-critical step.</p>

    <p class="text-gray-300">Now let us consider the case of a variable numerator as well as variable denominator. We now wish to compute</p>

    <p class="text-gray-300"><span class="math">$c x_i/y_i \\qquad i=1,\\ldots,N</span>$</p>

    <p class="text-gray-300">Using the algorithm of Section 3, we could compute the fractions  <span class="math">c/y_i</span>  at a per-unit cost  <span class="math">M_1 + 2M_2</span> . We could then multiply by the numerators  <span class="math">x_i</span>  to get a total cost of</p>

    <p class="text-gray-300"><span class="math">$Cost = 2NM_1 + (2N - 2)M_2 + Inversion</span>$</p>

    <p class="text-gray-300">As  <span class="math">N \\to \\infty</span> , the per-unit cost is</p>

    <p class="text-gray-300"><span class="math">$Cost/N \\rightarrow 2M_1 + 2M_2</span>$</p>

    <p class="text-gray-300">We will now show how to interleave the multiplications by  <span class="math">x_i</span>  and c with the multiple inversion algorithm, resulting in a lower cost. As before, we have a forward pass, a field inversion, and a backward pass. All these stages are changed however.</p>

    <p class="text-gray-300">To begin, we start the forward pass by setting</p>

    <p class="text-gray-300"><span class="math">$r_1 = y_1</span>$</p>

    <p class="text-gray-300">and then for  <span class="math">i=2,\\ldots,N</span>  we compute</p>

    <p class="text-gray-300"><span class="math">$r_i = r_{i-1} \\times y_i</span>$</p>

    <p class="text-gray-300"><span class="math">$s_i = r_{i-1} \\times x_i</span>$</p>

    <p class="text-gray-300">Note that the two multiplications share a common factor, and thus this is a double multiplication.</p>

    <p class="text-gray-300">When this is done, we have  <span class="math">r_N = \\prod y_i</span> . We next compute</p>

    <p class="text-gray-300"><span class="math">$I = c \\times r_N^{-1}</span>$</p>

    <p class="text-gray-300">Next, we enter the backward pass. To begin, we set  <span class="math">t_N = I</span>  and then for  <span class="math">i = N, \\dots, 2</span>  we compute the two products</p>

    <p class="text-gray-300"><span class="math">$c x_i/y_i = t_i \\times s_i</span>$
<span class="math">$t_{i-1} = t_i \\times y_i</span>$</p>

    <p class="text-gray-300">and finally finish with</p>

    <p class="text-gray-300"><span class="math">$c x_1/y_1 = t_1 \\times x_1</span>$</p>

    <p class="text-gray-300">In total, the cost of the foward pass is  <span class="math">(N-1) \\times 2M_2</span> ; we then perform a modular inversion and a single multiplication by c; finally, the backward pass costs  <span class="math">M_1 + (N-1) \\times 2M_2</span> . In total, the cost is</p>

    <p class="text-gray-300"><span class="math">$Cost = M_1 + (4N - 4)M_2 + M_c + Inversion</span>$</p>

    <p class="text-gray-300">As  <span class="math">N \\to \\infty</span> , the per-unit cost tends to</p>

    <p class="text-gray-300"><span class="math">$Cost/N \\rightarrow 4M_2</span>$</p>

    <p class="text-gray-300">As compared to our previous cost, we have replaced the two unrelated multiplications by a double multiplication.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">Inversion in a field can be quite costly. For this reason, if many field inversions need to be computed, Montgomery's trick is a useful technique for replacing them all with a single field inversion and many multiplications.</p>

    <p class="text-gray-300">In many cases, such as elliptic curve affine point doubling, these field inversions go along with field multiplications, a combination we define as a field division. We have described an algorithm which incorporates this numerator into the Montgomery's trick, resulting in a computation which is faster than the simple Montgomery's trick in two cases: 1) If the numerator involves a constant term; or 2) If double multiplication (a pair of multiplications with common factor) can be computed more quickly than two unrelated multiplications.</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Acknowledgements</h2>

    <p class="text-gray-300">Thanks to Joana Silva for helping edit this paper, and for helping me with the publication process.</p>

    </section>

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8 Reference</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[1] H. Cohen, &quot;A Course in Computational Algebraic Number Theory.&quot; Graduate Texts in Math. 138, Springer-Verlage, 1993.</li>
      <li>[2] P. Mishra, S. Palash, &quot;Application of Montgomery's trick to scalar multiplication for elliptic and hyperelliptic curves using a fixed base point.&quot; PKC 2004, March 2004, pp. 41-54.</li>
    </ul>

    </section>
`;
---

<BaseLayout title="Simultaneous field divisions: an extension of Montgomery&#x27;s t... (2008/199)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2008 &middot; eprint 2008/199
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="2-montgomery-s-trick-for-multiple-field-inversions-2008" />
  </article>
</BaseLayout>
