---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/263';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting';
const AUTHORS_HTML = 'Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, Christophe Petit';

const CONTENT = `    <p class="text-gray-300">Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting†*</p>

    <p class="text-gray-300">Jonathan Bootle¹, Andrea Cerulli¹, Pyrros Chaidos¹**, Jens Groth¹, and Christophe Petit²</p>

    <p class="text-gray-300">¹ University College London {jonathan.bootle.14,andrea.cerulli.13,pyrros.chaidos.10,j.groth}@ucl.ac.uk ² University of Oxford christophe.petit@maths.ox.ac.uk</p>

    <p class="text-gray-300">Abstract. We provide a zero-knowledge argument for arithmetic circuit satisfiability with a communication complexity that grows logarithmically in the size of the circuit. The round complexity is also logarithmic and for an arithmetic circuit with fan-in 2 gates the computation of the prover and verifier is linear in the size of the circuit. The soundness of our argument relies solely on the well-established discrete logarithm assumption in prime order groups.</p>

    <p class="text-gray-300">At the heart of our new argument system is an efficient zero-knowledge argument of knowledge of openings of two Pedersen multicommitments satisfying an inner product relation, which is of independent interest. The inner product argument requires logarithmic communication, logarithmic interaction and linear computation for both the prover and the verifier. We also develop a scheme to commit to a polynomial and later reveal the evaluation at an arbitrary point, in a verifiable manner. This is used to build an optimized version of the constant round square root complexity argument of Groth (CRYPTO 2009), which reduces both communication and round complexity.</p>

    <p class="text-gray-300">Keywords: Sigma-protocol, zero-knowledge argument, arithmetic circuit, discrete logarithm assumption.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge proofs and arguments are ubiquitous in cryptography today, with prominent applications in authentication protocols, multi-party computation, encryption primitives, electronic voting systems and verifiable computation protocols.</p>

    <p class="text-gray-300">¹ This is the full version of an article with the same title that was accepted for publication at Eurocrypt 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The research leading to these results has received funding from the European Research Council under the European Union’s Seventh Framework Programme (FP/2007-2013) / ERC Grant Agreement n. 307937 and EPSRC grant EP/J009520/1.</li>

    </ul>

    <p class="text-gray-300">** Was supported by an EPSRC scholarship (EP/G037264/1 – Security Science DTC).</p>

    <p class="text-gray-300">Informally, a zero-knowledge argument involves two parties, the prover and the verifier, and allows the prover to prove to the verifier that a particular statement is true, without revealing anything else about the statement itself. Statements are of the form <span class="math">u\\in L</span>, where <span class="math">L</span> is a language in NP. We call <span class="math">w</span> a witness for a statement <span class="math">u</span> if <span class="math">(u,w)\\in R</span>, where <span class="math">R</span> is a polynomial time decidable binary relation associated with <span class="math">L</span>. We require the zero-knowledge argument to be complete, sound and zero-knowledge.</p>

    <p class="text-gray-300">A prover with a witness <span class="math">w</span> for <span class="math">u\\in L</span> can convince the verifier of this fact. A prover cannot convince a verifier when <span class="math">u\\notin L</span>. The interaction should not reveal anything to the verifier except that <span class="math">u\\in L</span>. In particular, it should not reveal the prover’s witness <span class="math">w</span>.</p>

    <p class="text-gray-300">Our goal is to build an efficient argument system for the satisfiability of an arithmetic circuit, i.e., a circuit that consists of addition and multiplication gates over a finite field <span class="math">\\mathbb{Z}_{p}</span>. Moreover we want to base the security of this argument solely on the discrete logarithm assumption: this will provide both strong security guarantees and good efficiency since there exists no known attacks better than generic ones for well-chosen elliptic curve subgroups.</p>

    <p class="text-gray-300">The most efficient zero-knowledge arguments solely based on the discrete logarithm assumption are Groth’s protocol based on linear algebra <em>[x10]</em> and its variant by Seo <em>[x21]</em>. Both of these protocols have a communication complexity that is proportional to the square root of the circuit size. This square root complexity has since then appeared as a (perhaps fundamental) barrier for discrete logarithm-based arguments for circuit satisfiability.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">We provide an honest verifier zero-knowledge argument for arithmetic circuit satisfiability based on the discrete logarithm assumption that only requires a <em>logarithmic</em> communication complexity. Our argument has perfect completeness and perfect special honest verifier zero-knowledge. Soundness is computational and based on the discrete logarithm assumption. We require a logarithmic number of moves, and both the prover and verifier have linear computational complexity. The argument is therefore efficient on all parameters with the biggest improvement being in the communication complexity.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Improved Square Root Complexity Argument.</h4>

    <p class="text-gray-300">We start from the circuit satisfiability argument of Groth <em>[x10]</em>, which requires <span class="math">7</span> moves and has square root communication complexity in the <em>total</em> number of gates. In this argument the prover commits to all the wires using homomorphic multicommitments, verifies addition gates using the homomorphic properties, and uses a product argument to show that the multiplication gates are satisfied.</p>

    <p class="text-gray-300">We first improve Groth’s argument into a <span class="math">5</span> moves argument with square root communication complexity in the number of <em>multiplication gates</em> only. We</p>

    <p class="text-gray-300">achieve fewer moves compared to <em>[x13]</em> by avoiding generic reductions to linear algebra statements. We remove the communication cost of the addition gates in the argument by providing a technique that can directly handle a set of Hadamard products and linear relations together. Another efficiency improvement is a subroutine to commit to a polynomial and later reveal its evaluation at an arbitrary point in a verifiable manner. In Section 3 we provide a protocol to perform this task, which has a square root communication complexity with respect to the degree of the polynomial, and which may be of independent interest.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Logarithmic Complexity Argument.</h4>

    <p class="text-gray-300">In spite of all these improvements, the above argument still requires a square root communication complexity with respect to multiplication gates. In the first move the prover commits to all circuit wires using <span class="math">3m</span> commitments to <span class="math">n</span> elements each, where <span class="math">mn=N</span> is a bound on the number of multiplication gates, and in the last move after receiving a challenge he opens one commitment that can be constructed from the previous ones and the challenge. By setting <span class="math">m\\approx n</span> we get a minimal communication complexity of <span class="math">O(\\sqrt{N})</span>.</p>

    <p class="text-gray-300">Our key idea to break this square root communication complexity barrier is to replace the last opening step in this protocol by an argument of knowledge of the opening values. Using specific properties of Pedersen multicommitments, namely homomorphic properties with respect to the keys, we rewrite this argument as an argument of knowledge of openings of two homomorphic commitments, satisfying an inner product relation. In Section 4 we provide an argument system for this problem, which only requires a logarithmic communication with respect to the vector sizes. The argument is built in a recursive way, reducing the size and complexity of the statement further in each recursion step. Using this inner product argument as a subroutine we obtain an arithmetic circuit satisfiability argument with logarithmic communication.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Implementation.</h4>

    <p class="text-gray-300">In Section 6 we report on an implementation of our arguments. To show the practicality of our results we compare the efficiency of our implementation to that of Pinocchio <em>[x15]</em>. Pinocchio is a practical verifiable computation scheme allowing a constrained client to outsource computation of a function to a powerful worker and to efficiently verify the outcome of the function. It uses quadratic arithmetic programs, a generalisation of arithmetic circuits, and for some functions achieves verification that is faster than local computation. While we do not achieve comparably fast verification, we compare favourably in terms of prover computation, and do so under simpler assumptions.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">Zero-knowledge proofs were invented by Goldwasser et al. <em>[x10]</em>. It is useful to distinguish between zero-knowledge <em>proofs</em>, with statistical soundness, and zero-knowledge <em>arguments</em> with computational soundness. In general proofs can only have computational zero-knowledge, while arguments may have perfect zero-knowledge. Goldreich et al. <em>[x11]</em> showed that all languages in NP have</p>

    <p class="text-gray-300">zero-knowledge proofs while Brassard et al. <em>[x1]</em> showed that all languages in NP have zero-knowledge arguments with perfect zero-knowledge.</p>

    <p class="text-gray-300">Gentry et al. <em>[GGI^{+}14]</em> used fully homomorphic encryption to construct zero-knowledge proofs where the communication complexity corresponds to the size of the witness. However, proofs cannot in general have communication that is smaller than the witness size unless surprising results about the complexity of solving SAT instances hold <em>[x11, x12]</em>.</p>

    <p class="text-gray-300">Kilian <em>[x22]</em> showed that in contrast to zero-knowledge proofs, zero-knowledge arguments can have very low communication complexity. His construction relied on the PCP theorem though, and did not yield a practical scheme.</p>

    <p class="text-gray-300">Schnorr <em>[x25]</em> and Guillou and Quisquater <em>[x14]</em> gave early examples of practical zero-knowledge arguments for concrete number theoretic problems. Extending Schnorr’s protocols, there have been many constructions of zero-knowledge arguments based on the discrete logarithm assumption. Cramer and Damgård <em>[x6]</em> gave a zero-knowledge argument for arithmetic circuit satisfiability, which has linear communication complexity.</p>

    <p class="text-gray-300">Currently the most efficient discrete logarithm based zero-knowledge arguments for arithmetic circuits are the ones by Groth <em>[x17]</em> and Seo <em>[x26]</em>, which are constant move arguments with a communication proportional to the square root of the circuit size. Using pairing-based cryptography instead of just relying on the discrete logarithm assumption, Groth <em>[x16]</em> extended these techniques to give a zero-knowledge argument with a cubic root communication complexity.</p>

    <p class="text-gray-300">There are recent works giving a logarithmic communication complexity for specific languages. Bayer and Groth <em>[x3]</em> show that one can prove that a polynomial evaluated at a secret committed value gives a certain output with a logarithmic communication complexity and Groth and Kohlweiss <em>[x15]</em> show that one can prove that one out of <span class="math">N</span> commitments contain <span class="math">0</span> with logarithmic communication complexity. These results are for very specific types of statements (with low circuit depth) and the techniques do not seem to generalize to arbitrary NP languages.</p>

    <p class="text-gray-300">An exciting line of research <em>[x18, x19, x2, x4, x5, x1, x10, x11, x12]</em> has developed many proposals for succinct non-interactive arguments (SNARGs) yielding pairing-based constructions where the arguments consist of a constant number of group elements. However, they all rely on a common reference string (with a special structure) and non-falsifiable knowledge extractor assumptions. In contrast, the arguments we develop here are based solely on the discrete logarithm assumption, and use a small common reference string which is independent of the circuit.</p>

    <p class="text-gray-300">Table 1 compares the most efficient previous zero-knowledge arguments based on the discrete logarithm assumption with our scheme, when allowing for <span class="math">5</span> moves or a logarithmic number of moves. Using <span class="math">5</span> moves, our scheme requires significantly less computation than <em>[x26]</em>. On the other hand when using a logarithmic number of moves and applying a reduction similar to <em>[x3]</em>, our scheme dramatically improves the communication costs with respect to all previ</p>

    <p class="text-gray-300">ous work without incurring any significant overhead. We note that [BG12] uses the reduction to reduce computation whereas we use it to reduce communication.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moves</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">mult.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CD98]</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6N</td>

            <td class="px-3 py-2 border-b border-gray-700">5N+2</td>

            <td class="px-3 py-2 border-b border-gray-700">6N</td>

            <td class="px-3 py-2 border-b border-gray-700">6N</td>

            <td class="px-3 py-2 border-b border-gray-700">6N</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gro09b]</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">9√N+4</td>

            <td class="px-3 py-2 border-b border-gray-700">7√N+6</td>

            <td class="px-3 py-2 border-b border-gray-700">6N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">39√N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gro09b]</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log N+5</td>

            <td class="px-3 py-2 border-b border-gray-700">2√N</td>

            <td class="px-3 py-2 border-b border-gray-700">7√N</td>

            <td class="px-3 py-2 border-b border-gray-700">6N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">18√N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Seo11]</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">30√N</td>

            <td class="px-3 py-2 border-b border-gray-700">7√N</td>

            <td class="px-3 py-2 border-b border-gray-700">6N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">77√N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This paper</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">2√N</td>

            <td class="px-3 py-2 border-b border-gray-700">2√N</td>

            <td class="px-3 py-2 border-b border-gray-700">6N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">3N log N</td>

            <td class="px-3 py-2 border-b border-gray-700">8√3N/ log N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This paper</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log N+1</td>

            <td class="px-3 py-2 border-b border-gray-700">4 log N+7</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log N+6</td>

            <td class="px-3 py-2 border-b border-gray-700">12N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">4N</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Efficiency comparison between our arguments and the most efficient interactive zero-knowledge arguments relying on discrete logarithm. We express communication in number of group elements  <span class="math">\\mathbb{G}</span>  and field elements  <span class="math">\\mathbb{Z}_p</span>  and computation costs in number of exponentiations over  <span class="math">\\mathbb{G}</span>  and multiplications over  <span class="math">\\mathbb{Z}_p</span> . The efficiency displayed is for a circuit with  <span class="math">N</span>  multiplication gates.</p>

    <p class="text-gray-300">As part of our construction we give a protocol for committing to a polynomial and later revealing an evaluation of the polynomial in a given point. Kate et al. [KZG10] have also provided protocols to commit to polynomials and then evaluate them at a given point in a verifiable way. Their protocols only require a constant number of commitments but security relies on pairing assumptions. Our polynomial commitment protocol has square root communication complexity but relies solely on the discrete logarithm assumption.</p>

    <p class="text-gray-300">We write  <span class="math">y = A(x; r)</span>  when the algorithm  <span class="math">A</span>  on input  <span class="math">x</span>  and randomness  <span class="math">r</span> , outputs  <span class="math">y</span> . We write  <span class="math">y \\gets A(x)</span>  for the process of picking randomness  <span class="math">r</span>  at random and setting  <span class="math">y = A(x; r)</span> . We also write  <span class="math">y \\gets S</span>  for sampling  <span class="math">y</span>  uniformly at random from the set  <span class="math">S</span> . We will assume one can sample uniformly at random from sets such as  <span class="math">\\mathbb{Z}_p</span>  and  <span class="math">\\mathbb{Z}_p^*</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithms in our schemes receive a security parameter  <span class="math">\\lambda</span>  as input (sometimes implicitly) written in unary. The intuition is that the higher the security parameter, the lower the risk of the scheme being broken. Given two functions  <span class="math">f, g: \\mathbb{N} \\to [0,1]</span>  we write  <span class="math">f(\\lambda) \\approx g(\\lambda)</span>  when  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\lambda) - g(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lambda^{-\\omega(1)}<span class="math"> . We say that  </span>f<span class="math">  is negligible when  </span>f(\\lambda) \\approx 0<span class="math">  and that  </span>f<span class="math">  is overwhelming when  </span>f(\\lambda) \\approx 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Throughout the paper we let  <span class="math">\\mathbb{G}</span>  be a group of prime order  <span class="math">p</span> . Let  <span class="math">\\pmb{g} = (g_1, \\dots, g_n) \\in \\mathbb{G}^n</span>  and  <span class="math">\\pmb{f} = (f_1, \\dots, f_n) \\in \\mathbb{Z}_p^n</span> . We write  <span class="math">\\pmb{g}^f</span>  for the multi-exponentiation  <span class="math">\\pmb{g}^f = \\prod_{i=1}^{n} g_i^{f_i}</span> . A multi-exponentiation of size  <span class="math">n</span>  can be computed at a cost of roughly  <span class="math">\\frac{n}{\\log n}</span>  single group exponentiations using the multi-exponentiation techniques of [Lim00, Möl01, MR08].</p>

    <p class="text-gray-300">2.1 The Discrete Logarithm Assumption</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let GGen be an algorithm that on input <span class="math">1^{\\lambda}</span> returns <span class="math">(\\mathbb{G},p,g)</span> such that <span class="math">\\mathbb{G}</span> is the description of a finite cyclic group of prime order <span class="math">p</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lambda<span class="math">, and </span>g<span class="math"> is a generator of </span>\\mathbb{G}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1 (Discrete Logarithm Assumption)</h6>

    <p class="text-gray-300">The discrete logarithm assumption holds relative to GGen if for all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(\\mathbb{G},p,g)\\leftarrow\\text{GGen}(1^{\\lambda});h\\leftarrow\\mathbb{G};a\\leftarrow\\mathcal{A}(\\mathbb{G},p,g,h):g^{a}=h\\right]\\approx 0</span></p>

    <p class="text-gray-300">In this definition, the value <span class="math">a</span> is called the discrete logarithm of <span class="math">h</span> in the basis <span class="math">g</span>. Note that the discrete logarithm assumption is defined with respect to a particular group generator algorithm GGen. According to current state-of-the-art cryptanalytic techniques, to get a security level of <span class="math">2^{-\\lambda}</span> the group generator may for example return well-chosen elliptic curve groups where group elements can be represented with <span class="math">O(\\lambda)</span> bits or multiplicative subgroups of finite fields with a large characteristic where group elements can be represented with <span class="math">O(\\lambda^{3})</span> bits. It is well-known that the discrete logarithm assumption is equivalent to the following assumption.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2 (Discrete Logarithm Relation Assumption)</h6>

    <p class="text-gray-300">For all <span class="math">n\\geq 1</span> and all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}(\\mathbb{G},p,g)\\leftarrow\\text{GGen}(1^{\\lambda});g_{1},\\ldots,g_{n}\\leftarrow\\mathbb{G};\\\\ a_{0},\\ldots,a_{n}\\leftarrow\\mathcal{A}(\\mathbb{G},p,g,\\{g_{i}\\}_{i})\\end{array}:\\exists a_{i}\\neq 0\\text{ and }g^{a_{0}}\\prod_{i=1}^{n}g_{i}^{a_{i}}=1\\right]\\approx 0 \\]</p>

    <p class="text-gray-300">We call such a product <span class="math">g^{a_{0}}\\prod_{i=1}^{n}g_{i}^{a_{i}}=1</span> a non-trivial discrete logarithm relation.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Pedersen Commitments</h3>

    <p class="text-gray-300">A non-interactive commitment scheme allows a sender to create a commitment to a secret value. She may later open the commitment and reveal the value in a verifiable manner. A commitment should be hiding, i.e., not reveal the secret value, and binding in the sense that a commitment cannot be opened to two different values.</p>

    <p class="text-gray-300">Formally, a non-interactive commitment scheme is a pair of probabilistic polynomial time algorithms (CGen, Com). The setup algorithm <span class="math">ck\\leftarrow\\text{CGen}(1^{\\lambda})</span> generates a commitment key <span class="math">ck</span>. The commitment key specifies a message space <span class="math">\\mathcal{M}_{ck}</span>, a randomness space <span class="math">\\mathcal{R}_{ck}</span> and a commitment space <span class="math">\\mathcal{C}_{ck}</span>. The commitment algorithm combined with the commitment key specifies a function <span class="math">\\text{Com}_{ck}:\\mathcal{M}_{ck}\\times\\mathcal{R}_{ck}\\rightarrow\\mathcal{C}_{ck}</span>. Given a message <span class="math">m\\in\\mathcal{M}_{ck}</span> the sender picks uniformly at random <span class="math">r\\leftarrow\\mathcal{R}_{ck}</span> and computes the commitment <span class="math">c=\\text{Com}_{ck}(m;r)</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3 (Perfectly hiding)</h6>

    <p class="text-gray-300">We say a non-interactive commitment scheme <span class="math">(\\text{CGen},\\text{Com})</span> is perfectly hiding if a commitment does not reveal the committed</p>

    <p class="text-gray-300">value. For all non-uniform polynomial time stateful interactive adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\begin{bmatrix}ck\\leftarrow\\text{CGen}(1^{\\lambda});(m_{0},m_{1})\\leftarrow\\mathcal{A}(ck);\\\\ b\\leftarrow\\{0,1\\};c\\leftarrow\\text{Com}_{ck}(m_{b})\\\\ \\end{bmatrix}:\\mathcal{A}(c)=b \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathcal{A}</span> outputs <span class="math">m_{0},m_{1}\\in\\mathcal{M}_{ck}</span>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 4 (Binding)</h6>

    <p class="text-gray-300">A non-interactive commitment scheme <span class="math">(\\text{CGen},\\text{Com})</span> is computationally binding if a commitment can only be opened to one value. For all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\begin{bmatrix}ck\\leftarrow\\text{CGen}(1^{\\lambda});\\\\ (m_{0},r_{0},m_{1},r_{1})\\leftarrow\\mathcal{A}(ck)\\;:\\end{bmatrix}\\;\\begin{array}[]{c}\\text{Com}_{ck}(m_{0};r_{0})=\\text{Com}_{ck}(m_{1};r_{1})\\\\ \\text{and }m_{0}\\neq m_{1}\\end{array} \\] <span class="math">\\approx 0</span></p>

    <p class="text-gray-300">where <span class="math">\\mathcal{A}</span> outputs <span class="math">m_{0},m_{1}\\in\\mathcal{M}_{ck}</span> and <span class="math">r_{0},r_{1}\\in\\mathcal{R}_{ck}</span>.</p>

    <p class="text-gray-300">We say a commitment scheme is homomorphic if for all valid keys <span class="math">ck</span> the message, randomness and commitment spaces are abelian groups and for all messages <span class="math">m_{0},m_{1}\\in\\mathcal{M}_{ck}</span> and randomness <span class="math">r_{0},r_{1}\\in\\mathcal{R}_{ck}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\text{Com}_{ck}(m_{0};r_{0})\\cdot\\text{Com}_{ck}(m_{1};r_{1})=\\text{Com}_{ck}(m_{0}+m_{1};r_{0}+r_{1}).</span></p>

    <p class="text-gray-300">The most prominent example of a homomorphic perfectly hiding commitment scheme is the Pedersen commitment scheme. Pedersen commitments have the form <span class="math">c=g^{r}h^{m}</span> where <span class="math">g,h</span> are group elements specified in the commitment key. The opening of a Pedersen commitment is <span class="math">(m,r)\\in\\mathbb{Z}_{p}^{2}</span>, from which anybody can recompute the commitment <span class="math">c</span> and verify it was a valid commitment. Since Pedersen commitments are random group elements, they are perfectly hiding. On the other hand, breaking the binding property of Pedersen commitments corresponds to breaking the discrete logarithm assumption.</p>

    <p class="text-gray-300">We will be using a variant of Pedersen commitments that allow us to commit to multiple values at once. The commitment key is <span class="math">ck=(\\mathbb{G},p,g,g_{1},\\ldots,g_{n})</span> and a commitment is of the form <span class="math">c=g^{r}\\prod_{i=1}^{n}g_{i}^{m_{i}}</span>. We write <span class="math">c=\\text{Com}_{ck}(m_{1},\\ldots,m_{n};r)</span> for this operation.</p>

    <p class="text-gray-300">With the Pedersen commitment scheme in mind, we will assume throughout the paper that the message space is <span class="math">\\mathbb{Z}_{p}^{n}</span> and the randomness space is <span class="math">\\mathbb{Z}_{p}</span>. The constructions we have in Sections 3 and 5.1 require a perfectly hiding, homomorphic commitment scheme so we are not limited to using the Pedersen commitment scheme. However, in Sections 4 and 5.2, we will rely on specific properties of the Pedersen scheme and work directly on the group elements in the key.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 Zero-knowledge Arguments of Knowledge</h3>

    <p class="text-gray-300">Let <span class="math">R</span> be a polynomial time decidable binary relation, i.e., a relation that defines a language in NP. We call <span class="math">w</span> a witness for a statement <span class="math">u</span> if <span class="math">(u,w)\\in R</span>.</p>

    <p class="text-gray-300">In the arguments we consider a prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span>, both of which are probabilistic polynomial time interactive algorithms. The transcript produced by <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> when interacting on inputs <span class="math">s</span> and <span class="math">t</span> is denoted by <span class="math">tr\\leftarrow\\langle\\mathcal{P}(s),\\mathcal{V}(t)\\rangle</span>. We write <span class="math">\\langle\\mathcal{P}(s),\\mathcal{V}(t)\\rangle=b</span> depending on whether the verifier rejects, <span class="math">b=0</span>, or accepts, <span class="math">b=1</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 5 (Argument of knowledge)</h6>

    <p class="text-gray-300">The pair <span class="math">(\\mathcal{P},\\mathcal{V})</span> is called an <em>argument of knowledge</em> for the relation <span class="math">R</span> if we have perfect completeness and statistical witness-extended emulation as defined below.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 6 (Perfect completeness)</h6>

    <p class="text-gray-300"><span class="math">(\\mathcal{P},\\mathcal{V})</span> has perfect completeness if for all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(u,w)\\leftarrow\\mathcal{A}(1^{\\lambda}):(u,w)\\not\\in R\\text{ or }\\langle\\mathcal{P}(u,w),\\mathcal{V}(u)\\rangle=1\\right]=1</span></p>

    <p class="text-gray-300">To define an argument of knowledge we follow Groth and Ishai <em>[x10]</em> that borrowed the term witness-extended emulation from Lindell <em>[x20]</em>. Informally, their definition says that given an adversary that produces an acceptable argument with some probability, there exists an emulator that produces a similar argument with the same probability together with a witness <span class="math">w</span>. Note that the emulator is allowed to rewind the prover and verifier’s interaction to any previous move.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 7 (Statistical witness-extended emulation)</h6>

    <p class="text-gray-300"><span class="math">(\\mathcal{P},\\mathcal{V})</span> has <em>statistical witness-extended emulation</em> if for all deterministic polynomial time <span class="math">\\mathcal{P}^{*}</span> there exists an expected polynomial time emulator <span class="math">\\mathcal{E}</span> such that for all interactive adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(u,s)\\leftarrow\\mathcal{A}(1^{\\lambda});tr\\leftarrow\\langle\\mathcal{P}^{<em>}(u,s),\\mathcal{V}(u)\\rangle:\\mathcal{A}(tr)=1\\right]</span> \\[ \\approx\\Pr\\left[\\begin{array}[]{l}(u,s)\\leftarrow\\mathcal{A}(1^{\\lambda});(tr,w)\\leftarrow\\mathcal{E}^{\\langle\\mathcal{P}^{</em>}(u,s),\\mathcal{V}(u)\\rangle}(u):\\\\ \\mathcal{A}(tr)=1\\text{ and if }tr\\text{ is accepting then }(u,w)\\in R\\end{array}\\right] \\]</p>

    <p class="text-gray-300">where the oracle called by <span class="math">\\mathcal{E}^{\\langle\\mathcal{P}^{*}(u,s),\\mathcal{V}(u)\\rangle}</span> permits rewinding to a specific point and resuming with fresh randomness for the verifier from this point onwards.</p>

    <p class="text-gray-300">In the definition, <span class="math">s</span> can be interpreted as the state of <span class="math">\\mathcal{P}^{<em>}</span>, including the randomness. So, whenever <span class="math">\\mathcal{P}^{</em>}</span> is able to make a convincing argument when in state <span class="math">s</span>, <span class="math">\\mathcal{E}</span> can extract a witness. This is why we call it an argument of knowledge.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 8 (Public coin)</h6>

    <p class="text-gray-300">An argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> is called <em>public coin</em> if the verifier chooses his messages uniformly at random and independently of the messages sent by the prover, i.e., the challenges correspond to the verifier’s randomness <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">An argument is zero-knowledge if it does not leak information about the witness beyond what can be inferred from the truth of the statement. We will present arguments that have special honest verifier zero-knowledge in the sense that if the verifier’s challenges are known in advance, then it is possible to simulate the entire argument without knowing the witness.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 9 (Perfect special honest verifier zero-knowledge)</h6>

    <p class="text-gray-300">A public coin argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> is called a *perfect special honest verifier zero knowledge</p>

    <p class="text-gray-300">(SHVZK) argument for <span class="math">R</span> if there exists a probabilistic polynomial time simulator <span class="math">\\mathcal{S}</span> such that for all interactive non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}(u,w,\\rho)\\leftarrow\\mathcal{A}(1^{\\lambda});tr\\leftarrow\\langle\\mathcal{P}(u,w),\\mathcal{V}(u;\\rho)\\rangle:(u,w)\\in R\\text{ and }\\mathcal{A}(tr)=1\\Big{]}</span> <span class="math">=\\Pr\\Big{[}(u,w,\\rho)\\leftarrow\\mathcal{A}(1^{\\lambda});tr\\leftarrow\\mathcal{S}(u,\\rho):(u,w)\\in R\\text{ and }\\mathcal{A}(tr)=1\\Big{]}</span></p>

    <p class="text-gray-300">where <span class="math">\\rho</span> is the public coin randomness used by the verifier.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Full zero-knowledge.</h4>

    <p class="text-gray-300">In real life applications special honest verifier zero-knowledge may not suffice since a malicious verifier may give non-random challenges. However, it is easy to convert an SHVZK argument into a full zero-knowledge argument secure against arbitrary verifiers in the common reference string model using standard techniques <em>[x10, x11]</em> . The conversion can be very efficient and only costs a small additive overhead.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">The Fiat-Shamir heuristic.</h4>

    <p class="text-gray-300">The Fiat-Shamir transformation takes an interactive public coin argument and replaces the challenges with the output of a cryptographic hash function. The idea is that the hash function will produce random looking output and therefore be a suitable replacement for the verifier. The Fiat-Shamir heuristic yields a non-interactive zero-knowledge argument in the random oracle model <em>[x3]</em>.</p>

    <p class="text-gray-300">The transformation can be applied to our arguments to make them non-interactive at the cost of using the random oracle model in the security proofs. From an efficiency point of view this is especially useful for the arguments in Sections 4 and 5.2, reducing a logarithmic number of moves to a single one.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">A general forking lemma.</h4>

    <p class="text-gray-300">Suppose that we have a <span class="math">(2\\mu+1)</span>-move public-coin argument with <span class="math">\\mu</span> challenges, <span class="math">x_{1},\\ldots,x_{\\mu}</span> in sequence. Let <span class="math">n_{i}\\geq 1</span> for <span class="math">1\\leq i\\leq\\mu</span>. Consider <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> accepting transcripts with challenges in the following tree format. The tree has depth <span class="math">\\mu</span> and <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> leaves. The root of the tree is labelled with the statement. Each node of depth <span class="math">i&lt;\\mu</span> has exactly <span class="math">n_{i}</span> children, each labelled with a distinct value for the <span class="math">i</span>th challenge <span class="math">x_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This can be referred to as an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of accepting transcripts. All of our arguments allow a witness to be extracted efficiently from an appropriate tree of accepting transcripts. This is a natural generalisation of special-soundness for Sigma-protocols, where <span class="math">\\mu=1</span> and <span class="math">n=2</span>. For simplicity in the following lemma, we assume that the challenges are chosen uniformly from <span class="math">\\mathbb{Z}_{p}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lambda$, but any sufficiently large challenge space would suffice.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 1 (Forking Lemma).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\mu+1)</span>-move, public coin interactive protocol. Let <span class="math">\\chi</span> be a witness extraction algorithm that always succeeds in extracting a witness from an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of accepting transcripts in probabilistic polynomial time. Assume that <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> is bounded above by a polynomial in the security parameter <span class="math">\\lambda</span>. Then <span class="math">(\\mathcal{P},\\mathcal{V})</span> has witness-extended emulation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For simplicity in the following proof, we assume challenges are chosen uniformly from <span class="math">\\mathbb{Z}_{p}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lambda$, but any sufficiently large challenge space would suffice.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that for deterministic polynomial time <span class="math">\\mathcal{P}^{*}</span> there is a non-uniform polynomial time interactive adversary <span class="math">\\mathcal{A}</span> in the sense of witness-extended emulation, such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}(u,s)\\leftarrow\\mathcal{A}(1^{\\lambda});tr\\leftarrow\\langle\\mathcal{P}^{*}(u,s),\\mathcal{V}(u)\\rangle:\\mathcal{A}(tr)=1\\Big{]}=\\epsilon.</span></p>

    <p class="text-gray-300">Note that if <span class="math">\\epsilon</span> is negligible, then we do not need to extract a witness, since the emulator can simply fail every time and trivially achieve witness-extended emulation. Therefore, from now on, we assume that <span class="math">\\epsilon</span> is not negligible.</p>

    <p class="text-gray-300">We construct an expected polynomial time emulator <span class="math">\\mathcal{E}</span>, which has access to a rewindable transcript oracle <span class="math">\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle</span> and produces a witness. This is done via recursive calls to tree-finders <span class="math">\\mathcal{T}</span> that deal with the protocol after the first few challenges are already fixed. The <span class="math">i</span>th tree-finder takes the previous challenges and partial transcript given to it as input, picks random values for <span class="math">x_{i+1}</span>, runs the prover on these values and hands the result to the next tree-finder. Each tree-finder may fail on the first value of <span class="math">x_{i+1}</span>, ensuring that the whole process runs in expected polynomial time. With overwhelming probability, the emulator obtains an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of transcripts and is then able to extract a witness, using the efficient algorithm <span class="math">\\chi</span> that exists by assumption.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}^{\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle}(u)\\rightarrow(tr,w)</span>:</li>

      <li>Run <span class="math">\\mathcal{T}^{\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle}(1)\\rightarrow(tr,\\texttt{tree})</span></li>

      <li>If <span class="math">\\texttt{tree}=\\bot</span> then return <span class="math">(tr,\\bot)</span>.</li>

      <li>If <span class="math">\\texttt{tree}</span> is not a valid <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of transcripts (i.e. there are collisions in certain challenges) then return <span class="math">(tr,\\bot)</span>.</li>

      <li>Else run <span class="math">w\\leftarrow\\chi(u,\\texttt{tree})</span>.</li>

      <li>Return <span class="math">(tr,w)</span></li>

      <li>For <span class="math">1\\leq i\\leq\\mu+1</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{T}^{\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle}(i)\\rightarrow(tr,\\texttt{tree})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i=\\mu+1</span></li>

      <li>Obtain a complete protocol transcript from <span class="math">tr\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle</span></li>

      <li>Run <span class="math">\\mathcal{V}(tr)\\rightarrow b</span></li>

      <li>If <span class="math">b=0</span> then return <span class="math">(tr,\\bot)</span>.</li>

      <li>If <span class="math">b=1</span> then set <span class="math">\\texttt{tree}=\\{tr\\}</span> and return <span class="math">(tr,\\texttt{tree})</span>.</li>

      <li>Run <span class="math">\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle</span> up to and including move <span class="math">2i+1</span>.</li>

      <li>Run <span class="math">\\mathcal{T}^{\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle}(i+1)\\rightarrow(tr,\\texttt{tree})</span></li>

      <li>If <span class="math">\\texttt{tree}=\\bot</span> then return <span class="math">(tr,\\bot)</span>.</li>

      <li>Set <span class="math">\\texttt{counter}=1</span></li>

      <li>While <span class="math">\\texttt{counter}&lt;n_{i}</span>:</li>

      <li>Rewind <span class="math">\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle</span> back until just before move <span class="math">2i</span>.</li>

      <li>Run <span class="math">\\mathcal{T}^{\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle}(i+1)\\rightarrow(tr^{\\prime},\\texttt{tree}^{\\prime})</span></li>

      <li>If <span class="math">\\texttt{tree}^{\\prime}\\neq\\bot</span>, append the <span class="math">\\texttt{tree}^{\\prime}</span> transcripts to <span class="math">\\texttt{tree}</span>, and increment <span class="math">\\texttt{counter}</span>.</li>

      <li>Return <span class="math">(tr,\\texttt{tree})</span></li>

    </ul>

    <p class="text-gray-300">Fix <span class="math">1\\leq i\\leq\\mu</span>, and fix <span class="math">x_{1},\\ldots,x_{i-1}</span>. We say that <span class="math">\\mathcal{T}(i)</span> has failed if it returns <span class="math">(tr,\\bot)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\epsilon^{\\prime}</span> be the probability that the <span class="math">\\mathcal{T}(i)</span> fails for this choice of challenges, and let <span class="math">\\epsilon^{\\prime}(x_{i})</span> be the probability that <span class="math">\\mathcal{T}(i+1)</span> fails for this choice of challenges continued with <span class="math">x_{i}</span>. The <span class="math">i</span>th tree-finder can fail only if the <span class="math">(i+1)</span>th tree-finder fails the first time it is called. This implies that for uniformly random <span class="math">x_{i}</span>, the probability that <span class="math">\\mathcal{T}(i+1)</span> fails is <span class="math">\\epsilon^{\\prime}=\\sum_{x_{i}\\in\\mathbb{Z}_{p}}\\Pr[X=x_{i}]\\epsilon^{\\prime}(x_{i})</span>.</p>

    <p class="text-gray-300">Therefore, the expected number of times that <span class="math">\\mathcal{T}(i)</span> runs <span class="math">\\mathcal{T}(i+1)</span> is <span class="math">1+\\epsilon^{\\prime}\\frac{(n_{i}-1)}{\\epsilon^{\\prime}}=n_{i}</span>. The final tree-finder <span class="math">\\mathcal{T}(k+1)</span> merely checks whether the transcript is accepting or not. Hence, the total expected running time for <span class="math">\\mathcal{T}(1)</span> to be <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> multiplied by the time taken to check whether a transcript is accepting. We conclude that the emulator <span class="math">\\mathcal{E}</span> runs in expected polynomial time.</p>

    <p class="text-gray-300">The first tree-finder <span class="math">\\mathcal{T}(1)</span> only outputs <span class="math">(tr,\\bot)</span> if the very first set of challenges generated by all of the emulators fails to produce an accepting transcript. This is exactly the probability that <span class="math">\\mathcal{P}^{*}</span> successfully produces an accepting transcript in one run.</p>

    <p class="text-gray-300">Given that we receive <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span> accepting transcripts in tree, we now consider the probability that they do not form an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree. This occurs only when the <span class="math">n_{i}</span> values of challenge <span class="math">x_{i}</span> used by <span class="math">\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle</span> while in the loop controlled by counter are not distinct, or in other words, there is a collision between these values, for some <span class="math">i</span>.</p>

    <p class="text-gray-300">By Markov’s inequality, an algorithm whose expected running time is <span class="math">t</span> will only run for longer than time <span class="math">T&gt;t</span> with probability <span class="math">\\frac{t}{T}</span>. Let <span class="math">t</span> be the expected running time of <span class="math">\\mathcal{E}</span>, which is bounded above by a polynomial in the security parameter. For easier analysis, we limit the actual running time of <span class="math">\\mathcal{E}</span> to <span class="math">T</span>, whose value will be chosen later.</p>

    <p class="text-gray-300">When <span class="math">\\mathcal{E}</span> runs in time at most <span class="math">T</span>, then at most <span class="math">T</span> uniformly random public coin challenges were selected by <span class="math">\\mathcal{V}</span> in <span class="math">\\langle\\mathcal{P}^{<em>},\\mathcal{V}\\rangle</span>. If there are no collisions between </em>any* of the public coins chosen, then there are certainly no collisions of the type which would prevent tree from being a <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of transcripts. The probability that there is a collision between <span class="math">T</span> values sampled uniformly from <span class="math">\\mathbb{Z}_{p}</span> is at most <span class="math">\\frac{T^{2}}{p}</span>.</p>

    <p class="text-gray-300">Now, we choose <span class="math">T=\\sqrt[3]{p}</span>. The probability that tree fails to be an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree is at most <span class="math">\\frac{t}{T}+\\frac{T^{2}}{p}</span> which is now equal to <span class="math">\\frac{t}{\\sqrt[3]{p}}+\\frac{1}{\\sqrt[3]{p}}</span>. This is negligible. Therefore, there is negligible probability of the tree-finding algorithms succeeding, yet <span class="math">\\mathcal{E}</span> failing to extract a witness. This proves the argument has statistical witness-extended emulation. ∎</p>

    <h2 id="sec-23" class="text-2xl font-bold">3 Commitments to Polynomials</h2>

    <p class="text-gray-300">In this section, we present a protocol to commit to a polynomial <span class="math">t(X)</span> and later reveal the evaluation of <span class="math">t(X)</span> at any point <span class="math">x\\in\\mathbb{Z}_{p}^{*}</span> together with a proof that enables a verifier to check that the evaluation is correct with respect to the committed <span class="math">t(X)</span>. We will consider Laurent polynomials <span class="math">t(X)\\in\\mathbb{Z}_{p}[X,X^{-1}]</span> i.e.</p>

    <p class="text-gray-300">polynomials in which we allow terms of negative degree. This protocol will be used as a subroutine for the arguments described in Sections 5.1 and 5.2.</p>

    <p class="text-gray-300">A simple solution for this problem would be to send commitments to coefficients of <span class="math">t(X)</span> individually, from which the evaluation of <span class="math">t(X)</span> at any particular point can be verified using the homomorphic properties. This solution requires <span class="math">d</span> group elements to be sent, where <span class="math">d</span> is the number of non-zero coefficients in <span class="math">t(X)</span>. As we shall show it is possible to reduce the communication costs to <span class="math">O(\\sqrt{d})</span> group elements, where <span class="math">d = d_{2} + d_{1}</span> if <span class="math">t(X) = \\sum_{k=-d_{1}}^{d_{2}} t_{k} X^{k}</span>.</p>

    <p class="text-gray-300">For clarity we first informally describe our protocol for a standard (not Laurent) polynomial <span class="math">t(X) = \\sum_{k=0}^{d} t_k X^k</span>. We then extend this informal description to Laurent polynomials with zero constant term. We finally provide a formal description of the protocol and analyze its security and efficiency.</p>

    <p class="text-gray-300">Main idea for standard polynomials. Let <span class="math">t(X) = \\sum_{k=0}^{d} t_k X^k</span> be a polynomial with coefficients in <span class="math">\\mathbb{Z}_p</span> and assume <span class="math">d + 1 = mn</span>. We can write <span class="math">t(X) = \\sum_{i=0}^{m-1} \\sum_{j=0}^{n-1} t_{i,j}(X) X^{in+j}</span> and arrange the coefficients in a <span class="math">m \\times n</span> matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c c} t _ {0, 0} &amp;amp; t _ {0, 1} &amp;amp; \\dots &amp;amp; t _ {0, n - 1} \\\\ t _ {1, 0} &amp;amp; t _ {1, 1} &amp;amp; \\dots &amp;amp; t _ {1, n - 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; &amp;amp; \\vdots \\\\ t _ {m - 1, 0} &amp;amp; t _ {n - 1, 1} &amp;amp; \\dots &amp;amp; t _ {m - 1, n - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">Now, <span class="math">t(X)</span> can be evaluated by multiplying the matrix by row and column vectors.</p>

    <div class="my-4 text-center"><span class="math-block">t (X) = \\left(1   X ^ {n} \\dots X ^ {(m - 1) n}\\right) \\left( \\begin{array}{c c c c} t _ {0, 0} &amp;amp; t _ {0, 1} &amp;amp; \\dots &amp;amp; t _ {0, n - 1} \\\\ t _ {1, 0} &amp;amp; t _ {1, 1} &amp;amp; \\dots &amp;amp; t _ {1, n - 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; &amp;amp; \\vdots \\\\ t _ {m - 1, 0} &amp;amp; t _ {n - 1, 1} &amp;amp; \\dots &amp;amp; t _ {m - 1, n - 1} \\end{array} \\right) \\left( \\begin{array}{c} 1 \\\\ X \\\\ \\vdots \\\\ X ^ {n - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">The idea behind the protocol is to commit to the rows of this matrix using commitments <span class="math">T_0, \\ldots, T_{m-1}</span>. Later, when given an evaluation point <span class="math">x \\in \\mathbb{Z}_p</span> we can use the homomorphic property of the commitment scheme to compute the commitment <span class="math">\\prod_{i=0}^{m-1} T_i^{x^{in}}</span> to the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {\\boldsymbol {t}} = \\left(1   x ^ {n} \\dots x ^ {(m - 1) n}\\right) \\left( \\begin{array}{c c c c} t _ {0, 0} &amp;amp; t _ {0, 1} &amp;amp; \\dots &amp;amp; t _ {0, n - 1} \\\\ t _ {1, 0} &amp;amp; t _ {1, 1} &amp;amp; \\dots &amp;amp; t _ {1, n - 1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; &amp;amp; \\vdots \\\\ t _ {m - 1, 0} &amp;amp; t _ {m - 1, 1} &amp;amp; \\dots &amp;amp; t _ {m - 1, n - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">The prover opens this latter commitment and now it is easy to compute <span class="math">v = t(x)</span> from <span class="math">\\bar{t}</span> and <span class="math">x</span>.</p>

    <p class="text-gray-300">The problem with this straightforward solution is that it leaks partial information about the coefficients of <span class="math">t(X)</span>. We remedy this by inserting some blinding values <span class="math">u_{1}, \\ldots, u_{n-1}</span> to hide the weighted sum of the coefficients in each column.</p>

    <p class="text-gray-300">However, we make sure that the blinding values cancel each other out so that we still get the correct evaluation of the polynomial. More precisely, we commit to the rows of the following <span class="math">(m + 1) \\times n</span> matrix</p>

    <div class="my-4 text-center"><span class="math-block">T = \\left( \\begin{array}{cccc} t_{0,0} &amp;amp; t_{0,1} - u_1 &amp;amp; \\cdots &amp;amp; t_{0,n-2} - u_{n-2} &amp;amp; t_{0,n-1} - u_{n-1} \\\\ t_{1,0} &amp;amp; t_{1,1} &amp;amp; \\cdots &amp;amp; t_{1,n-2} &amp;amp; t_{1,n-1} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; &amp;amp; &amp;amp; \\vdots \\\\ t_{m-1,0} &amp;amp; t_{m-1,1} &amp;amp; \\cdots &amp;amp; t_{m-1,n-2} &amp;amp; t_{m-1,n-1} \\\\ u_1 &amp;amp; u_2 &amp;amp; \\cdots &amp;amp; u_{n-1} &amp;amp; 0 \\end{array} \\right)</span></div>

    <p class="text-gray-300">with <span class="math">U</span> being a commitment to the last row. This time</p>

    <div class="my-4 text-center"><span class="math-block">t(X) = \\left(1 \\, X^n \\cdots X^{(m-1)n} \\, X\\right) \\, T \\left( \\begin{array}{c} 1 \\\\ X \\\\ X^2 \\\\ \\vdots \\\\ X^{n-1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">We now open <span class="math">U^x \\prod_{i=0}^{m-1} T_i^{x^{in}}</span> by revealing the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{\\boldsymbol{t}} = \\left(1 \\, x^n \\cdots x^{(m-1)n} \\, x\\right) \\, T</span></div>

    <p class="text-gray-300">This still allows us to compute <span class="math">t(x)</span>, but due to the blinders we no longer leak information about the coefficients of <span class="math">t(X)</span>. In fact, each element of <span class="math">\\tilde{\\pmb{t}}</span> is uniformly random, conditional on their weighted sum being equal to <span class="math">t(x)</span>, which the prover intends for the verifier to learn anyway.</p>

    <p class="text-gray-300"><strong>Extension to Laurent polynomials.</strong> Let now <span class="math">t(X)</span> be a Laurent polynomial <span class="math">t(X) = \\sum_{i=-d_1}^{d_2} t_i X^i</span> with constant term <span class="math">t_0 = 0</span>. Let <span class="math">m_1, m_2, n</span> be positive integers such that <span class="math">d_1 = nm_1</span> and <span class="math">d_2 = nm_2</span> and write <span class="math">t(X) = X^{-m_1n} t&#x27;(X) + X t&#x27;&#x27;(X)</span> for degree <span class="math">d_1 - 1</span> and <span class="math">d_2 - 1</span> polynomials <span class="math">t&#x27;(X), t&#x27;&#x27;(X) \\in \\mathbb{Z}_p[X]</span>. We can write <span class="math">t&#x27;(X) = \\sum_{i=0}^{m_1-1} \\sum_{j=0}^{n-1} t_{i,j}&#x27; X^{in+j}</span> and <span class="math">t&#x27;&#x27;(X) = \\sum_{i=0}^{m_2-1} \\sum_{j=0}^{n-1} t_{i,j}&#x27;&#x27; X^{in+j}</span>.</p>

    <p class="text-gray-300">We can arrange the coefficients of <span class="math">t&#x27;(X)</span> and <span class="math">t&#x27;&#x27;(X)</span> in a <span class="math">(m_1 + m_2) \\times n</span> matrix <span class="math">T</span>. We commit to both <span class="math">t&#x27;(X)</span> and <span class="math">t&#x27;&#x27;(X)</span> simultaneously by committing to the rows of the matrix using commitments <span class="math">T_i&#x27;</span> and <span class="math">T_i&#x27;&#x27;</span>. As when committing to polynomials we add blinders <span class="math">u_1, \\ldots, u_{n-1}</span> and make a commitment <span class="math">U</span> to the additional last row arising from this.</p>

    <div class="my-4 text-center"><span class="math-block">T = \\left( \\begin{array}{cccc} t_{0,0}&#x27; &amp;amp; t_{0,1}&#x27; &amp;amp; \\cdots &amp;amp; t_{0,n-1}&#x27; \\\\ t_{1,0}&#x27; &amp;amp; t_{1,1}&#x27; &amp;amp; \\cdots &amp;amp; t_{1,n-1}&#x27; \\\\ \\vdots &amp;amp; \\vdots &amp;amp; &amp;amp; \\vdots \\\\ t_{m_1-1,0}&#x27; &amp;amp; t_{m_1-1,1}&#x27; &amp;amp; \\cdots &amp;amp; t_{m_1-1,n-1}&#x27; \\\\ t_{0,0}&#x27;&#x27; &amp;amp; t_{0,1}&#x27;&#x27; - u_1 &amp;amp; \\cdots &amp;amp; t_{0,n-1}&#x27;&#x27; - u_{n-1} \\\\ t_{1,0}&#x27;&#x27; &amp;amp; t_{1,1}&#x27;&#x27; &amp;amp; \\cdots &amp;amp; t_{1,n-1}&#x27;&#x27; \\\\ \\vdots &amp;amp; \\vdots &amp;amp; &amp;amp; \\vdots \\\\ t_{m_2-1,0}&#x27;&#x27; &amp;amp; t_{m_2-1,1}&#x27;&#x27; &amp;amp; \\cdots &amp;amp; t_{m_2-1,n-1}&#x27;&#x27; \\\\ u_1 &amp;amp; u_2 &amp;amp; \\cdots &amp;amp; 0 \\end{array} \\right) = \\left( \\begin{array}{c} t_0&#x27; \\\\ t_1&#x27; \\\\ \\vdots \\\\ t_{m_1-1}&#x27; \\\\ t_0&#x27;&#x27; \\\\ t_1&#x27;&#x27; \\\\ \\vdots \\\\ t_{m_2-1}&#x27;&#x27; \\\\ u \\end{array} \\right)</span></div>

    <p class="text-gray-300">Define vectors</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {Z} = \\boldsymbol {Z} (X) = \\left(X ^ {- m _ {1} n}, X ^ {- (m _ {1} - 1) n}, \\dots , X ^ {- n}, X, X ^ {n + 1}, \\dots , X ^ {(m _ {2} - 1) n + 1}, X ^ {2}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {X} = \\boldsymbol {X} (X) = \\left( \\begin{array}{c} 1 \\\\ X \\\\ \\vdots \\\\ X ^ {n - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">and we have  <span class="math">t(X) = ZTX</span> .</p>

    <p class="text-gray-300">To evaluate at  <span class="math">x \\in \\mathbb{Z}_p^*</span>  we open  <span class="math">\\left(\\prod_{i=0}^{m_1-1}(T_i&#x27;)^{x^{(i-m_1)n}}\\right)\\left(\\prod_{i=0}^{m_2-1}(T_i&#x27;&#x27;)^{x^{in+1}}\\right)U^{x^2}</span>  to the vector  <span class="math">\\hat{\\pmb{t}} = \\pmb{Z}(x)T</span> . This allows us to compute  <span class="math">t(x)</span>  as  <span class="math">\\hat{\\pmb{t}}\\pmb{X}(x)</span> . The blinders hide the weighted sums of each column as before, and now the verifier is able to compute  <span class="math">t(x)</span>  without gaining additional information about its coefficients.</p>

    <p class="text-gray-300"><strong>Evaluation Protocol.</strong> Our protocol is made of the following three algorithms. For simplicity, we restrict our description to the case of Pedersen commitments, but all aspects of the construction and proof carry over in the general case.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PolyCommit  <span class="math">(ck, m_1, m_2, n, t(X)) \\to (\\mathsf{pc}, \\mathsf{st})</span> : Take as input a commitment key  <span class="math">ck</span>  and a Laurent polynomial  <span class="math">t(X) = \\sum_{i=-m_1n}^{nm_2} t_i X^i</span>  with constant coefficient  <span class="math">t_0 = 0</span> . Pick blinders  <span class="math">u_1, \\ldots, u_{n-1} \\gets \\mathbb{Z}_p</span>  and randomness  <span class="math">\\tau_u, \\tau_0&#x27;, \\ldots, \\tau_{m_1-1}&#x27;, \\tau_0&#x27;&#x27;, \\ldots, \\tau_{m_2-1}&#x27;&#x27; \\gets \\mathbb{Z}_p</span> . Set  <span class="math">\\pmb{\\tau} = (\\tau_0&#x27;, \\ldots, \\tau_{m_1-1}&#x27;, \\tau_0&#x27;&#x27;, \\ldots, \\tau_{m_2-1}&#x27;, \\tau_u)</span> . Compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">T _ {i} ^ {\\prime} = \\operatorname {C o m} _ {c k} \\left(\\boldsymbol {t} _ {i} ^ {\\prime}; \\tau_ {i} ^ {\\prime}\\right), \\quad T _ {i} ^ {\\prime \\prime} = \\operatorname {C o m} _ {c k} \\left(\\boldsymbol {t} _ {i} ^ {\\prime \\prime}; \\tau_ {i} ^ {\\prime \\prime}\\right), \\quad U = \\operatorname {C o m} _ {c k} (\\boldsymbol {u}; \\tau_ {u})</span></div>

    <p class="text-gray-300">Return a polynomial commitment  <span class="math">\\mathsf{pc} = \\left(\\{T_i&#x27;\\}_{i=0}^{m_1-1}, \\{T_i&#x27;&#x27;\\}_{i=0}^{m_2-1}, U\\right)</span>  and private information  <span class="math">\\mathsf{st} = (t(X), \\tau)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PolyEval  <span class="math">(\\mathsf{st},x)\\to \\mathsf{pe}</span>  : Compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\boldsymbol {t}} = \\boldsymbol {Z} (x) T, \\quad \\tilde {\\tau} = \\boldsymbol {Z} (x) \\cdot \\boldsymbol {\\tau}</span></div>

    <p class="text-gray-300">Return  <span class="math">\\mathsf{pe} = (\\tilde{\\pmb{t}},\\tilde{\\tau})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PolyVerify  <span class="math">(ck, m_1, m_2, n, \\mathsf{pc}, \\mathsf{pe}, x) \\to v</span> : The verifier checks whether</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m} _ {c k} (\\tilde {\\boldsymbol {t}}; \\tilde {\\tau}) = \\left(\\prod_ {i = 0} ^ {m _ {1} - 1} \\left(T _ {i} ^ {\\prime}\\right) ^ {x ^ {(i - m _ {1}) n}}\\right) \\left(\\prod_ {i = 0} ^ {m _ {2} - 1} \\left(T _ {i} ^ {\\prime \\prime}\\right) ^ {x ^ {i n + 1}}\\right) U ^ {x ^ {2}}</span></div>

    <p class="text-gray-300">If the check is satisfied the verifier returns  <span class="math">v = t(x) = \\tilde{\\pmb{t}}\\pmb {X}(x)</span> .</p>

    <p class="text-gray-300">Otherwise, the verifier rejects  <span class="math">\\mathsf{pe}</span>  as invalid with respect to  <span class="math">\\mathsf{pc}</span>  and  <span class="math">x</span>  and returns  <span class="math">v = \\bot</span> .</p>

    <p class="text-gray-300"><strong>Security Properties.</strong> We define three security properties for our protocol: completeness,  <span class="math">l</span> -special soundness, and special-honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">Later, the protocol is used as a sub-protocol inside our zero-knowledge arguments-of-knowledge. These properties will help us to prove the completeness, witness-extended emulation, and special honest verifier zero knowledge for the zero knowledge argument.</p>

    <p class="text-gray-300">The definition of completeness simply guarantees that if PolyCommit, PolyVerify are carried out honestly, then PolyVerify will accept and return a commitment to the evaluation of the polynomial.</p>

    <p class="text-gray-300"><strong>Definition 10 (Perfect Completeness). (PolyCommit, PolyEval, PolyVerify)</strong> has perfect completeness if for all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l} (ck, m_1, m_2, n, t(X), x) \\leftarrow \\mathcal{A}(1^\\lambda) \\\\ (\\mathsf{pc}, \\mathsf{st}) \\leftarrow \\operatorname{PolyCommit}(ck, m_1, m_2, n, t(X)) \\\\ \\mathsf{pe} \\leftarrow \\operatorname{PolyEval}(\\mathsf{st}, x) \\\\ v \\leftarrow \\operatorname{PolyVerify}(ck, m_1, m_2, n, \\mathsf{pc}, \\mathsf{pe}, x) \\end{array} : v = t(x) \\right] = 1</span></div>

    <p class="text-gray-300">where <span class="math">ck</span> is a key for a homomorphic commitment scheme, <span class="math">t(X)</span> is a Laurent polynomial of degrees <span class="math">d_1 = m_1n, d_2 = m_2n</span> and <span class="math">x \\in \\mathbb{Z}_p^*</span>.</p>

    <p class="text-gray-300">The definition of <span class="math">l</span>-Special Soundness says that given <span class="math">l</span> accepting evaluations for different evaluation points, but from the same commitment <span class="math">\\mathsf{pc}</span>, then it is possible to extract either a valid Laurent polynomial <span class="math">t(X)</span> with zero constant term that is consistent with the evaluations produced or a breach in the binding property of the commitment scheme. Furthermore, any other accepting evaluations for the same commitment will also be evaluations of <span class="math">t(X)</span>.</p>

    <p class="text-gray-300"><strong>Definition 11 (Statistical <span class="math">l</span>-Special Soundness). (PolyCommit, PolyEval, PolyVerify)</strong> is statistically <span class="math">l</span>-special sound if there exists a probabilistic polynomial time algorithm <span class="math">\\chi</span> that, given <span class="math">l</span> accepting transcripts with the same commitment <span class="math">\\mathsf{pc}</span>, either extracts the committed polynomial <span class="math">t(X)</span>, or extracts a break of the binding property of the underlying commitment scheme. For all adversaries <span class="math">\\mathcal{A}</span> and all <span class="math">L \\geq l</span></p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l l} ck \\leftarrow \\operatorname{CGen}(1^\\lambda) &amp;amp; \\forall i: v_i = \\mathbf{Z}(x_i) T \\mathbf{X}(x_i) \\\\ (m_1, m_2, n, \\mathsf{pc}, x_1, \\mathsf{pe}_1, \\ldots, x_L, \\mathsf{pe}_L) \\leftarrow \\mathcal{A}(ck) &amp;amp; \\text{or } \\exists j \\text{ s.t.} \\\\ \\operatorname{Parse} \\mathsf{pe}_i = (\\bar{t}_i, \\bar{\\tau}_i) &amp;amp; \\operatorname{Com}_{ck}(\\bar{t}_j; \\bar{\\tau}_j) = \\\\ (T, \\tau) \\leftarrow \\chi(ck, m_1, m_2, n, \\mathsf{pc}, x_1, \\mathsf{pe}_1, \\ldots, x_l, \\mathsf{pe}_l) &amp;amp; \\operatorname{Com}_{ck}(\\mathbf{Z}(x_j) T; \\mathbf{Z}(x_j) \\tau), \\\\ v_i \\leftarrow \\operatorname{PolyVerify}(ck, m_1, m_2, n, \\mathsf{pc}, \\mathsf{pe}_i, x_i) &amp;amp; \\text{where } \\bar{t}_j \\neq \\mathbf{Z}(x_j) T \\end{array} \\right] \\approx 1,</span></div>

    <p class="text-gray-300">where <span class="math">x_1, \\ldots, x_l</span> are distinct, <span class="math">x_i \\in \\mathbb{Z}_p^*</span>, <span class="math">\\mathsf{pe}_i \\in \\mathbb{Z}_p^n \\times \\mathbb{Z}_p</span>, <span class="math">T \\in \\mathbb{Z}_p^{(m_1 + m_2) \\times n}</span>, and <span class="math">\\tau \\in \\mathbb{Z}_p^{m_1 + m_2}</span>.</p>

    <p class="text-gray-300">Perfect special honest verifier zero-knowledge means that given any value <span class="math">v</span> and evaluation point <span class="math">x</span>, it is possible to simulate <span class="math">\\mathsf{pc}</span> and <span class="math">\\mathsf{pe}</span>, distributed exactly as in a real execution of the protocol where <span class="math">v</span> was the evaluation of <span class="math">t(X)</span> at <span class="math">x</span>.</p>

    <p class="text-gray-300"><strong>Definition 12 (Perfect Special Honest Verifier Zero Knowledge). (PolyCommit, PolyEval, PolyVerify)</strong> has perfect special honest verifier zero knowledge (SHVZK) if there exists a probabilistic polynomial time simulator <span class="math">\\mathcal{S}</span> such</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">that for all interactive non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{l} (ck, m_1, m_2, n, t(X), x) \\leftarrow \\mathcal{A}(1^{\\lambda}) \\\\ (\\mathsf{pc}, \\mathsf{st}) \\leftarrow \\text{PolyCommit}(ck, m_1, m_2, n, t(X)) : \\mathcal{A}(\\mathsf{pc}, \\mathsf{pe}) = 1 \\\\ \\mathsf{pe} \\leftarrow \\text{PolyEval}(\\mathsf{st}, x) \\end{array} \\right] \\\\ = \\Pr \\left[ \\begin{array}{l} (ck, m_1, m_2, n, t(X), x) \\leftarrow \\mathcal{A}(1^{\\lambda}) \\\\ (\\mathsf{pc}, \\mathsf{pe}) \\leftarrow \\mathcal{S}(ck, m_1, m_2, n, x, t(x)) : \\mathcal{A}(\\mathsf{pc}, \\mathsf{pe}) = 1 \\end{array} \\right] \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">ck</span> is a key for a homomorphic commitment scheme, <span class="math">t(X)</span> is a Laurent polynomial of degrees <span class="math">d_1 = m_1n</span>, <span class="math">d_2 = m_2n</span> and <span class="math">x \\in \\mathbb{Z}_p^*</span>.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> The polynomial commitment protocol has perfect completeness, perfect special honest verifier zero-knowledge and <span class="math">(m_1 + m_2)n + 1</span>-special soundness for extracting either a breach of the binding property of the commitment scheme or openings to the polynomial.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Direct verification of the protocol shows that the verifier correctly obtains the evaluation of the committed polynomial <span class="math">t(X)</span> at the point <span class="math">x</span>.</p>

    <p class="text-gray-300">For special honest verifier zero-knowledge suppose we have an evaluation point <span class="math">x</span> and an evaluation <span class="math">v</span>. To simulate the polynomial evaluation we first pick random <span class="math">\\bar{t}_2, \\ldots, \\bar{t}_n, \\bar{\\tau} \\gets \\mathbb{Z}_p</span> and <span class="math">T_0&#x27;, \\ldots, T_{m_1 - 1}&#x27;, T_0&#x27;&#x27;, \\ldots, T_{m_2 - 1}&#x27;&#x27; \\gets \\mathbb{G}</span>. Now, <span class="math">\\bar{t}_1</span> is computed as</p>

    <div class="my-4 text-center"><span class="math-block">\\bar{t}_1 = v - \\sum_{i=2}^{n} \\bar{t}_i x^{i-1}</span></div>

    <p class="text-gray-300">Let <span class="math">\\bar{\\pmb{t}} = (\\bar{t}_1, \\dots, \\bar{t}_n)</span> and compute</p>

    <div class="my-4 text-center"><span class="math-block">U = \\operatorname{Com}_{ck}(\\bar{\\boldsymbol{t}} x^{-2}; \\bar{\\tau} x^{-2}) \\left[ \\prod_{i=0}^{m_1 - 1} (T_i&#x27;)^{x^{(i - m_1)n}} \\right]^{x^{-2}} \\left[ \\prod_{i=0}^{m_2 - 1} (T_i&#x27;&#x27;)^{x^{in + 1}} \\right]^{x^{-2}}</span></div>

    <p class="text-gray-300">This is a perfect simulation. Given <span class="math">x, v</span> observe that both in the simulation and in the real execution we get uniformly random <span class="math">\\bar{t}_2, \\ldots, \\bar{t}_n, \\bar{\\tau} \\in \\mathbb{Z}_p</span> and <span class="math">T_0&#x27;, \\ldots, T_{m_1 - 1}&#x27;, T_0&#x27;&#x27;, \\ldots, T_{m_2 - 1}&#x27;&#x27; \\gets \\mathbb{G}</span>. Now, conditioning on the values of <span class="math">x, v</span> and the verification equations, <span class="math">U</span> and <span class="math">\\bar{t}_1</span> are uniquely determined. Therefore, the simulation is perfect, and we have special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Finally, for special soundness note that if we have valid evaluations of <span class="math">l = (m_1 + m_2)n + 2</span> different challenges <span class="math">x \\in \\mathbb{Z}_p^*</span> the vectors <span class="math">(x^{-m_1n}, \\ldots, x^{m_2n - n + 1})</span> form the rows of a Vandermonde matrix multiplied by <span class="math">x^{-m_1n}</span> and we can obtain any unit vector <span class="math">(0, \\ldots, 1, \\ldots, 0)</span> by taking an appropriate linear combination of these vectors. By taking the correct linear combinations of the <span class="math">l</span> verification equations</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Com}_{ck}(\\bar{\\boldsymbol{t}}; \\bar{\\tau}) = \\left[ \\prod_{i=0}^{m_1 - 1} (T_i&#x27;)^{x^{(i - m_1)n}} \\right] \\left[ \\prod_{i=0}^{m_2 - 1} (T_i&#x27;&#x27;)^{x^{in + 1}} \\right] U^{x^2}</span></div>

    <p class="text-gray-300"><span class="math">l</span> different challenges, we can then extract an opening of any <span class="math">T^{\\prime}_{i}=\\mathrm{Com}_{ck}(\\bm{t}^{\\prime}_{i};\\tau^{\\prime}_{i})</span>, <span class="math">T^{\\prime\\prime}_{i}=\\mathrm{Com}_{ck}(\\bm{t}^{\\prime\\prime}_{i};\\tau^{\\prime\\prime}_{i})</span> and <span class="math">U=\\mathrm{Com}_{ck}(\\bm{u};\\tau_{u})</span>.</p>

    <p class="text-gray-300">This implies that whenever we have <span class="math">L\\geq l</span> different challenges <span class="math">x\\in\\mathbb{Z}_{p}^{*}</span> with valid evaluations we must either have <span class="math">\\bar{\\bm{t}}=\\bm{Z}(x)T</span> for each <span class="math">(x,\\mathsf{pe})</span> pair, where the rows of <span class="math">T</span> are the extracted <span class="math">\\bm{t}^{\\prime}_{i}</span> and <span class="math">\\bm{t}^{\\prime\\prime}_{i}</span> and <span class="math">\\bm{u}</span>, or we could extract a violation of the binding property of the commitment scheme.</p>

    <p class="text-gray-300">In the first case where <span class="math">\\bar{\\bm{t}}=\\bm{Z}(x)T</span>, for each pair, <span class="math">\\chi</span> sets <span class="math">\\tau=(\\tau^{\\prime}_{0},\\ldots,\\tau^{\\prime}_{m_{1}-1}</span>, <span class="math">\\tau^{\\prime\\prime}_{0},\\ldots,\\tau^{\\prime\\prime}_{m_{2}-1},\\tau_{u})</span>, and sets <span class="math">S,\\bm{\\sigma}</span> to be all zeroes. Since <span class="math">\\bar{\\bm{t}}=\\bm{Z}(x)T</span>, it follows that <span class="math">v_{i}=\\bm{Z}(x_{i})T\\bm{X}(x_{i})</span> for each <span class="math">i</span>.</p>

    <p class="text-gray-300">Alternatively, if <span class="math">\\bar{\\bm{t}}_{i}\\neq\\bm{Z}(x_{i})T</span> for some <span class="math">x_{i}</span> and <span class="math">\\mathsf{pe}_{i}=(\\bar{\\bm{t}}_{i},\\bar{\\tau}_{i}</span>, then since the verifier was accepting, we have <span class="math">\\mathrm{Com}_{ck}(\\bar{\\bm{t}}_{i};\\bar{\\tau}_{i})=\\mathrm{Com}_{ck}(\\bm{Z}(x_{i})T;\\bm{Z}(x_{i})\\bm{\\tau})</span>, and this gives a violation of the binding property of the commitment scheme. ∎</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">We now discuss the efficiency of the above protocol when instantiated with the Pedersen multicommitment scheme. The outputs <span class="math">\\mathsf{pc}</span>, <span class="math">\\mathsf{pe}</span> of the polynomial commitment protocol have sizes of <span class="math">m_{1}+m_{2}+1</span> group elements and <span class="math">n+1</span> field elements respectively. The computational cost of computing <span class="math">\\mathsf{pc}</span> is dominated by computing commitments <span class="math">T^{\\prime}_{i}</span> and <span class="math">T^{\\prime\\prime}_{i}</span>, corresponding to <span class="math">m_{1}+m_{2}</span> <span class="math">n</span>-wide multi-exponentiations. Using multi-exponentiation techniques as in <em>[x14, x19, x16]</em>, the total cost is roughly <span class="math">\\frac{(m_{1}+m_{2})n}{\\log n}</span> group exponentiations. The main cost for computing <span class="math">\\mathsf{pe}</span> is dominated by the <span class="math">n(m_{1}+m_{2})</span> field multiplications required to compute <span class="math">\\bm{Z}T</span>. The dominant cost in PolyVerify is to check the verification equation. This costs roughly <span class="math">\\frac{m_{1}+m_{2}+n}{\\log\\left(m_{1}+m_{2}+n\\right)}</span> group exponentiations.</p>

    <h2 id="sec-25" class="text-2xl font-bold">4 Recursive Argument for Inner Product Evaluation</h2>

    <p class="text-gray-300">We will now give an inner product argument of knowledge of two vectors <span class="math">\\bm{a},\\bm{b}\\in\\mathbb{Z}_{p}^{n}</span> such that <span class="math">A=\\bm{g^{a}}</span>, <span class="math">B=\\bm{h^{b}}</span> and <span class="math">\\bm{a}\\cdot\\bm{b}=z</span>, given <span class="math">z\\in\\mathbb{Z}_{p}</span>, <span class="math">A</span>, <span class="math">B\\in\\mathbb{G}</span> and <span class="math">\\bm{g},\\bm{h}\\in\\mathbb{G}^{n}</span>. The argument will be used later as a subroutine where zero-knowledge is not required, so the prover could in principle just reveal the witness <span class="math">\\bm{a},\\bm{b}</span> to the verifier. In the following we show how to use interaction to reduce the communication from linear to logarithmic in <span class="math">n</span>, the length of the vectors.</p>

    <p class="text-gray-300">The basic step in our inner product argument is a 2-move reduction to a smaller statement using techniques similar to <em>[x2]</em>. It will suffice for the prover to reveal the witness for the smaller statement in order to convince the verifier about the validity of the original statement. In the full argument, prover and verifier recursively run the reduction to obtain increasingly smaller statements. The argument is then concluded with the prover revealing a witness for a very small statement. The outcome of this is a <span class="math">O(\\log n)</span>-move argument with an overall communication of <span class="math">O(\\log n)</span> group and field elements. The inner product argument will be used in the next section to build a logarithmic size argument for circuit satisfiability.</p>

    <p class="text-gray-300">Due to the obvious relationship with Pedersen commitments, we will think of multi-exponentiations <span class="math">\\bm{g^{a}}</span> and <span class="math">\\bm{h^{b}}</span> as commitments with randomness set equal to zero, and to <span class="math">\\bm{a},\\bm{b}</span> as openings with respect to commitment keys <span class="math">\\bm{g},\\bm{h}</span>.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now describe the basic step in our argument. Consider the common input for both prover and verifier to be of the form  <span class="math">(\\mathbb{G},p,\\pmb {g},A,\\pmb {h},B,z,m)</span>  where  <span class="math">m</span>  divides  <span class="math">n</span> , the length of the vectors. For arbitrary  <span class="math">n</span>  one can always reduce to the case where  $m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n<span class="math">  by appending at most  </span>m - 1<span class="math">  random group elements to  </span>\\pmb{g}<span class="math">  and  </span>\\pmb{h}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We split the bases for the multi-exponentiations into  <span class="math">m</span>  sets  <span class="math">\\pmb{g} = (\\pmb{g}_1, \\dots, \\pmb{g}_m)</span>  and  <span class="math">\\pmb{h} = (\\pmb{h}_1, \\dots, \\pmb{h}_m)</span> , where each set has size  <span class="math">\\frac{n}{m}</span> . We want to prove knowledge of vectors  <span class="math">\\pmb{a} = (\\pmb{a}_1, \\dots, \\pmb{a}_m)</span>  and  <span class="math">\\pmb{b} = (\\pmb{b}_1, \\dots, \\pmb{b}_m)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">A = \\boldsymbol {g} ^ {\\boldsymbol {a}} = \\prod_ {i = 1} ^ {m} \\boldsymbol {g} _ {i} ^ {\\boldsymbol {a} _ {i}} \\quad B = \\boldsymbol {h} ^ {\\boldsymbol {b}} = \\prod_ {i = 1} ^ {m} \\boldsymbol {h} _ {i} ^ {\\boldsymbol {b} _ {i}} \\quad \\boldsymbol {a} \\cdot \\boldsymbol {b} = \\sum_ {i = 1} ^ {m} \\boldsymbol {a} _ {i} \\cdot \\boldsymbol {b} _ {i} = z</span></div>

    <p class="text-gray-300">The key idea is for the prover to replace  <span class="math">A</span>  with  <span class="math">A&#x27;</span> , a commitment to a shorter vector  <span class="math">\\pmb{a}&#x27; = \\sum_{i=1}^{m} \\pmb{a}_i x^i</span> , given a random challenge  <span class="math">x \\gets \\mathbb{Z}_p^*</span>  provided by the verifier. In the argument, the prover first computes and sends</p>

    <div class="my-4 text-center"><span class="math-block">A _ {k} = \\prod_ {i = \\max  (1, 1 - k)} ^ {\\min  (m, m - k)} \\boldsymbol {g} _ {i} ^ {\\boldsymbol {a} _ {i + k}} \\quad \\text {f o r} k = 1 - m, \\dots , m - 1</span></div>

    <p class="text-gray-300">corresponding to the products over the diagonals of the following matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c c c c} \\boldsymbol {a} _ {1} &amp;amp; \\boldsymbol {a} _ {2} &amp;amp; \\dots &amp;amp; \\boldsymbol {a} _ {m} \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\boldsymbol {g} _ {1} \\quad \\left( \\begin{array}{c c c c} \\boldsymbol {g} _ {1} ^ {\\boldsymbol {a} _ {1}} &amp;amp; g _ {1} ^ {a _ {2}} &amp;amp; \\dots &amp;amp; \\boldsymbol {g} _ {1} ^ {\\boldsymbol {a} _ {m}} \\\\ \\ddots &amp;amp; \\boldsymbol {g} _ {2} ^ {\\boldsymbol {a} _ {2}} &amp;amp; \\ddots &amp;amp; \\vdots \\\\ g _ {m - 1} ^ {a _ {1}} &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; g _ {m - 1} ^ {a _ {m}} \\\\ \\boldsymbol {g} _ {m} ^ {\\boldsymbol {a} _ {1}} &amp;amp; g _ {m} ^ {a _ {2}} &amp;amp; \\dots &amp;amp; \\boldsymbol {g} _ {m} ^ {\\boldsymbol {a} _ {m}} \\end{array} \\right) \\quad A _ {m - 1} \\\\ \\begin{array}{c c c c} &amp;amp; &amp;amp; &amp;amp; A _ {m - 2} \\\\ A _ {1 - m} &amp;amp; A _ {2 - m} &amp;amp; \\dots &amp;amp; A _ {0} = A \\end{array} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Notice that  <span class="math">A_0 = A</span>  is already known to the verifier since it is part of the statement. The verifier now sends a random challenge  <span class="math">x \\gets \\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">At this point, both the prover and the verifier can compute  <span class="math">\\pmb{g}^{\\prime} \\coloneqq \\prod_{i=1}^{m} \\pmb{g}_{i}^{x^{-i}}</span>  and  <span class="math">A^{\\prime} \\coloneqq \\prod_{k=1-m}^{m-1} A_{k}^{x^{k}}</span> . If the prover is honest then we have  <span class="math">A^{\\prime} = (\\pmb{g}^{\\prime})^{\\pmb{a}^{\\prime}}</span> , namely  <span class="math">A^{\\prime}</span>  is a commitment to  <span class="math">\\pmb{a}^{\\prime}</span>  under the key  <span class="math">\\pmb{g}^{\\prime}</span> . Furthermore, even if the prover is dishonest, we can show that if the prover can open  <span class="math">A^{\\prime}</span>  with respect to the key  <span class="math">\\pmb{g}^{\\prime}</span>  for  <span class="math">2m-1</span>  different challenges, then we can extract opening  <span class="math">(\\pmb{a}_{1}, \\dots, \\pmb{a}_{m})</span>  corresponding to  <span class="math">A = \\prod_{i=1}^{m} \\pmb{g}_{i}^{\\pmb{a}_{i}}</span> .</p>

    <p class="text-gray-300">The same type of argument can be applied in parallel to  <span class="math">B</span>  with the inverse challenge  <span class="math">x^{-1}</span>  giving us a sum of the form  <span class="math">\\pmb{b}&#x27; = \\sum_{i=1}^{m} \\pmb{b}_i x^{-i}</span>  and a new base  <span class="math">\\pmb{h}&#x27; = \\prod_{i=1}^{m} \\pmb{h}_i^{x^i}</span> .</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">All that remains is to demonstrate that <span class="math">z</span> is the constant term in the product <span class="math">\\pmb{a}^{\\prime} \\cdot \\pmb{b}^{\\prime} = \\sum_{i=1}^{m} \\pmb{a}_{i} x^{i} \\cdot \\sum_{j=1}^{m} \\pmb{b}_{j} x^{-j}</span>. Similarly to <span class="math">A</span> and <span class="math">B</span>, the prover sends values</p>

    <div class="my-4 text-center"><span class="math-block">z _ {k} = \\sum_ {i = \\max  (1, 1 - k)} ^ {\\min  (m, m - k)} \\boldsymbol {a} _ {i} \\cdot \\boldsymbol {b} _ {i + k} \\quad \\text {for} \\ k = 1 - m, \\dots , m - 1</span></div>

    <p class="text-gray-300">where <span class="math">z_0 = z = \\sum_{i=1}^{m} \\pmb{a}_i \\cdot \\pmb{b}_i</span>, and shows that <span class="math">z&#x27; := \\pmb{a}&#x27; \\cdot \\pmb{b}&#x27; = \\sum_{k=1-m}^{m-1} z_k x^{-k}</span>.</p>

    <p class="text-gray-300">To summarise, after the challenge <span class="math">x</span> has been sent, both parties compute <span class="math">\\pmb{g}^{\\prime}, A^{\\prime}, \\pmb{h}^{\\prime}, B^{\\prime}, z^{\\prime}</span> and then run an argument for the knowledge of <span class="math">\\pmb{a}^{\\prime}, \\pmb{b}^{\\prime}</span> of length <span class="math">\\frac{n}{m}</span>. Given <span class="math">n = m_{\\mu}m_{\\mu - 1} \\cdots m_{1}</span>, we recursively apply this reduction over the factors of <span class="math">n</span> to obtain, after <span class="math">\\mu - 1</span> iterations, vectors of length <span class="math">m_{1}</span>. The prover concludes the argument by revealing a short witness associated with the last statement.</p>

    <h2 id="sec-27" class="text-2xl font-bold">4.2 Formal description</h2>

    <p class="text-gray-300">We now give a formal description of the argument of knowledge introduced above.</p>

    <p class="text-gray-300"><strong>Common input:</strong> <span class="math">(\\mathbb{G},p,\\pmb {g},A,\\pmb {h},B,z,m_{\\mu} = m,m_{\\mu -1} = m^{\\prime},\\ldots ,m_{1})</span> such that <span class="math">\\pmb {g},\\pmb {h}\\in \\mathbb{G}^n</span>, <span class="math">A,B\\in \\mathbb{G}</span> and <span class="math">n = \\prod_{i = 1}^{n}m_{i}</span>.</p>

    <p class="text-gray-300"><strong>Prover's witness:</strong> <span class="math">(\\pmb{a}_1, \\dots, \\pmb{a}_m, \\pmb{b}_1, \\dots, \\pmb{b}_m)</span> satisfying</p>

    <div class="my-4 text-center"><span class="math-block">A = \\prod_ {i = 1} ^ {m} \\boldsymbol {g} _ {i} ^ {\\boldsymbol {a} _ {i}} \\quad B = \\prod_ {i = 1} ^ {m} \\boldsymbol {h} _ {i} ^ {\\boldsymbol {b} _ {i}} \\quad \\sum_ {i = 1} ^ {m} \\boldsymbol {a} _ {i} \\cdot \\boldsymbol {b} _ {i} = z</span></div>

    <p class="text-gray-300"><strong>Argument if</strong> <span class="math">\\mu = 1</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\to \\mathbf{V}</span>: Send <span class="math">(a_{1},\\ldots ,a_{m},b_{1},\\ldots ,b_{m})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\gets \\mathbf{V}</span>: Accept if and only if</p>

    <div class="my-4 text-center"><span class="math-block">A = \\prod_ {i = 1} ^ {m} g _ {i} ^ {a _ {i}} \\quad B = \\prod_ {i = 1} ^ {m} h _ {i} ^ {b _ {i}} \\quad \\sum_ {i = 1} ^ {m} a _ {i} b _ {i} = z</span></div>

    <p class="text-gray-300"><strong>Reduction if</strong> <span class="math">\\mu \\neq 1</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\to \\mathbf{V}</span>: Send <span class="math">A_{1 - m}, B_{1 - m}, z_{1 - m}, \\ldots, A_{m - 1}, B_{m - 1}, z_{m - 1}</span> where</p>

    <div class="my-4 text-center"><span class="math-block">A _ {k} = \\prod_ {i = \\max  (1, 1 - k)} ^ {\\min  (m, m - k)} \\boldsymbol {g} _ {i} ^ {\\boldsymbol {a} _ {i + k}} \\quad B _ {k} = \\prod_ {i = \\max  (1, 1 - k)} ^ {\\min  (m, m - k)} \\boldsymbol {h} _ {i} ^ {\\boldsymbol {b} _ {i + k}} \\quad z _ {k} = \\sum_ {i = \\max  (1, 1 - k)} ^ {\\min  (m, m - k)} \\boldsymbol {a} _ {i} \\cdot \\boldsymbol {b} _ {i + k}</span></div>

    <p class="text-gray-300">Observe <span class="math">A_0 = A, B_0 = B, z_0 = z</span> so they can be omitted from the message.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\gets \\mathbf{V}</span>: <span class="math">x \\gets \\mathbb{P}_{\\mu}^{*}</span>.</p>

    <p class="text-gray-300">Both prover and verifier compute a reduced statement of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbb {G}, p, \\boldsymbol {g} ^ {\\prime}, A ^ {\\prime}, \\boldsymbol {h} ^ {\\prime}, B ^ {\\prime}, z ^ {\\prime}, m _ {\\mu - 1}, \\dots , m _ {1}\\right)</span></div>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {g} ^ {\\prime} = \\left(\\boldsymbol {g} _ {1} ^ {\\prime}, \\dots , \\boldsymbol {g} _ {m ^ {\\prime}} ^ {\\prime}\\right) = \\prod_ {i = 1} ^ {m} \\boldsymbol {g} _ {i} ^ {x ^ {- i}} \\quad A ^ {\\prime} = \\prod_ {k = 1 - m} ^ {m - 1} A _ {k} ^ {x ^ {k}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {h} ^ {\\prime} = \\left(\\boldsymbol {h} _ {1} ^ {\\prime}, \\dots , \\boldsymbol {h} _ {m ^ {\\prime}} ^ {\\prime}\\right) = \\prod_ {i = 1} ^ {m} \\boldsymbol {h} _ {i} ^ {x ^ {i}} \\quad B ^ {\\prime} = \\prod_ {k = 1 - m} ^ {m - 1} B _ {k} ^ {x ^ {- k}} \\quad z ^ {\\prime} = \\sum_ {k = 1 - m} ^ {m - 1} z _ {k} x ^ {- k}</span></div>

    <p class="text-gray-300">The prover computes a new witness as <span class="math">(\\pmb{a}_1&#x27;, \\dots, \\pmb{a}_{m&#x27;}) = \\sum_{i=1}^{m} \\pmb{a}_i x^i</span> and <span class="math">(\\pmb{b}_1&#x27;, \\dots, \\pmb{b}_{m&#x27;}) = \\sum_{i=1}^{m} \\pmb{b}_i x^{-i}</span>.</p>

    <h2 id="sec-28" class="text-2xl font-bold">Security Analysis.</h2>

    <p class="text-gray-300"><strong>Theorem 2.</strong> The argument has perfect completeness and statistical witness extended emulation for either extracting a non-trivial discrete logarithm relation or a valid witness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Perfect completeness can be verified directly. To prove witness-extended emulation we start by giving an extractor that either extracts a witness for the original statement or a non-trivial discrete logarithm relation.</p>

    <p class="text-gray-300">For <span class="math">\\mu = 1</span> we have (perfect) witness-extended emulation since the prover reveals a witness and the verifier checks it.</p>

    <p class="text-gray-300">Before discussing extraction in the recursive step, note that if we get a nontrivial discrete logarithm relation for <span class="math">\\pmb{g}_1&#x27;, \\dots, \\pmb{g}_{m&#x27;}&#x27;</span> then we also get a non-trivial discrete logarithm relation for <span class="math">\\pmb{g}_1, \\dots, \\pmb{g}_m</span>, since <span class="math">x \\neq 0</span>. A similar argument applies to <span class="math">\\pmb{h}_1&#x27;, \\dots, \\pmb{h}_{m&#x27;}&#x27;</span> and <span class="math">\\pmb{h}_1, \\dots, \\pmb{h}_m</span>.</p>

    <p class="text-gray-300">Now, assume we get witness <span class="math">\\pmb{a}^{\\prime}, \\pmb{b}^{\\prime}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">A ^ {\\prime} = \\prod_ {k = 1 - m} ^ {m - 1} A _ {k} ^ {x ^ {k}} = \\left(\\prod_ {i = 1} ^ {m} \\boldsymbol {g} _ {i} ^ {x ^ {- i}}\\right) ^ {\\boldsymbol {a} ^ {\\prime}} \\quad B ^ {\\prime} = \\prod_ {k = 1 - m} ^ {m - 1} B _ {k} ^ {x ^ {- k}} = \\left(\\prod_ {i = 1} ^ {m} \\boldsymbol {h} _ {i} ^ {x ^ {i}}\\right) ^ {\\boldsymbol {b} ^ {\\prime}} \\quad \\boldsymbol {a} ^ {\\prime} \\cdot \\boldsymbol {b} ^ {\\prime} = \\sum_ {k = 1 - m} ^ {m - 1} z _ {k} x ^ {- k}</span></div>

    <p class="text-gray-300">for <span class="math">2m - 1</span> different challenges <span class="math">x \\in \\mathbb{Z}_p^*</span>. We will show that they yield either a witness for the original statement, or a non-trivial discrete logarithm relation for either <span class="math">\\pmb{g}_1, \\dots, \\pmb{g}_m</span> or <span class="math">\\pmb{h}_1, \\dots, \\pmb{h}_m</span>.</p>

    <p class="text-gray-300">Take <span class="math">2m - 1</span> different challenges <span class="math">x \\in \\mathbb{Z}_p^*</span>. They form a shifted Vandermonde matrix with rows <span class="math">(x^{1 - m}, x^{2 - m}, \\ldots, x^{m - 1})</span>. By taking appropriate linear combinations of the vectors we can obtain any unit vector <span class="math">(0, \\ldots, 0, 1, 0, \\ldots, 0)</span>. Taking the same linear combinations of the <span class="math">2m - 1</span> equations</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {k = 1 - m} ^ {m - 1} A _ {k} ^ {x ^ {k}} = \\left(\\prod_ {i = 1} ^ {m} \\boldsymbol {g} _ {i} ^ {x ^ {- i}}\\right) ^ {\\boldsymbol {a} ^ {\\prime}} \\quad \\text{we get vectors} \\boldsymbol {a} _ {k, i} \\text{ such that} \\quad A _ {k} = \\prod_ {i = 1} ^ {m} \\boldsymbol {g} _ {i} ^ {\\boldsymbol {a} _ {k, i}}</span></div>

    <p class="text-gray-300">For each of the <span class="math">2m - 1</span> challenges, we now have <span class="math">\\prod_{k=1-m}^{m-1} A_k^{x^k} = \\left( \\prod_{i=1}^{m} \\pmb{g}_i^{x^{-i}} \\right)^{\\pmb{a}&#x27;}</span>, which means that for all <span class="math">i</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">x ^ {- i} \\boldsymbol {a} ^ {\\prime} = \\sum_ {k = 1 - m} ^ {m - 1} \\boldsymbol {a} _ {k, i} x ^ {k}</span></div>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">unless we encounter a non-trivial discrete logarithm relation for <span class="math">\\pmb{g}_1, \\dots, \\pmb{g}_m</span>. This means that <span class="math">\\pmb{a}&#x27; = \\sum_{k=1-m}^{m-1} \\pmb{a}_{k,i} x^{k+i}</span> for all <span class="math">i</span>, and in particular <span class="math">\\sum_{k=1-m}^{m-1} \\pmb{a}_{k,i} x^{k+i} = \\sum_{k=1-m}^{m-1} \\pmb{a}_{k,1} x^{k+1} = \\sum_{k=1-m}^{m-1} \\pmb{a}_{k,m} x^{k+m}</span>. Matching terms of degree outside <span class="math">\\{1, \\dots, m\\}</span> reveals <span class="math">\\pmb{a}_{k,i} = 0</span> for <span class="math">k + i \\notin \\{1, \\dots, m\\}</span>. Defining <span class="math">\\pmb{a}_i = \\pmb{a}_{0,i}</span>, and matching terms of similar degree we get</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {a} _ {k, i} = \\left\\{ \\begin{array}{l l} \\boldsymbol {a} _ {k + i} &amp;amp; \\text {if } k + i \\in \\{1, \\ldots , m \\} \\\\ 0 &amp;amp; \\text {otherwise} \\end{array} \\right.</span></div>

    <p class="text-gray-300">This means</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {a} ^ {\\prime} = \\sum_ {k = 1 - m} ^ {m - 1} \\boldsymbol {a} _ {k, 1} x ^ {k + 1} = \\sum_ {k = 0} ^ {m - 1} \\boldsymbol {a} _ {k + 1} x ^ {k + 1} = \\sum_ {i = 1} ^ {m} \\boldsymbol {a} _ {i} x ^ {i}</span></div>

    <p class="text-gray-300">A similar analysis of <span class="math">B_{1 - m}, \\ldots, B_{m - 1}</span> and openings <span class="math">\\pmb{b}&#x27;</span> for <span class="math">2m - 1</span> different challenges <span class="math">x^{-1} \\in \\mathbb{Z}_p^*</span> gives us either a non-trivial discrete logarithm relation for <span class="math">\\pmb{h}_1, \\ldots, \\pmb{h}_m</span> or vectors <span class="math">\\pmb{b}_i</span> such that <span class="math">\\pmb{b}&#x27; = \\sum_{i=1}^{m} \\pmb{b}_i x^{-i}</span> and <span class="math">B = \\prod_{i=1}^{m} \\pmb{h}_i^{\\pmb{b}_i}</span>.</p>

    <p class="text-gray-300">Finally, with <span class="math">\\sum_{i=1}^{m} \\pmb{a}_{i} x^{i} \\cdot \\sum_{j=1}^{m} \\pmb{b}_{j} x^{-j} = \\sum_{k=1-m}^{m-1} z_{k} x^{-k}</span> for <span class="math">2m-1</span> different challenges we get <span class="math">z = z_{0} = \\sum_{i=1}^{m} \\pmb{a}_{i} \\cdot \\pmb{b}_{i}</span>.</p>

    <p class="text-gray-300">We can now apply the forking lemma to a tree of size <span class="math">(2m_{\\mu} - 1)(2m_{\\mu -1} - 1)\\dots (2m_2 - 1)\\leq n^2</span>, which is polynomial in <span class="math">\\lambda</span>, to conclude that the argument has witness-extended emulation.</p>

    <p class="text-gray-300">Efficiency. The recursive argument uses <span class="math">2\\mu - 1</span> moves. The communication cost of all steps sums up to <span class="math">4\\sum_{i=2}^{\\mu}(m_i - 1)</span> group elements and <span class="math">2\\sum_{i=2}^{\\mu}(m_i - 1) + 2m_1</span> field elements.</p>

    <p class="text-gray-300">At each iteration, the main cost for the prover is computing the <span class="math">A_{k}</span> and <span class="math">B_{k}</span> values, using less than <span class="math">\\frac{4(m_{\\mu}^{2}m_{\\mu - 1}\\ldots m_{1})}{\\log(m_{\\mu}\\ldots m_{1})}</span> group exponentiations via multi-exponentiation techniques, and the <span class="math">z_{k}</span> values using <span class="math">m_{\\mu}^{2}m_{\\mu -1}\\dots m_{1}</span> field multiplications. The cost of computing the reduced statements is dominated by <span class="math">\\frac{2(m_{\\mu}m_{\\mu - 1}\\ldots m_{1})}{\\log m_{\\mu}}</span> group exponentiations for both the prover and the verifier. In the case where <span class="math">m_{\\mu} = \\ldots = m_{1} = m</span>, the verifier complexity is bounded above by <span class="math">\\frac{2m^{\\mu}}{\\log m}\\frac{m}{m - 1}</span> group exponentiations. The prover complexity is bounded above by <span class="math">\\frac{6m^{\\mu + 1}}{\\log m}\\frac{m}{m - 1}</span> group exponentiations and <span class="math">m^{\\mu +1}\\frac{m}{m - 1}</span> field multiplications.</p>

    <p class="text-gray-300">Zero-knowledge version. The above argument can be modified to become zero-knowledge. We leave the details to the reader as zero-knowledge is not needed for our use of this argument in the next section.</p>

    <p class="text-gray-300">In this section, we revisit zero knowledge arguments for the satisfiability of an arithmetic circuit under the discrete logarithm assumption. We will explain how</p>

    <p class="text-gray-300">to build an argument with square root communication complexity, and superior efficiency to the argument of <em>[x10]</em>. We then observe that our new argument involves computing a large inner product, and can achieve as good as logarithmic communication complexity by using our recursive inner product argument.</p>

    <p class="text-gray-300">At a high level, we transform an arithmetic circuit into two kinds of equations. Multiplication gates are directly represented as equations of the form <span class="math">a\\cdot b=c</span>, where <span class="math">a,b,c</span> represent the left, right and output wires. We will arrange these values in matrix form producing a Hadamard matrix product. This process will lead to duplicate values, when a wire is the output of one multiplication gate and the input of another, or when it is used as input multiple times. We keep track of this by using a series of linear constraints. For example, if the output of the first multiplication gate is the right input of the second, we would write <span class="math">c_{1}-b_{2}=0</span>.</p>

    <p class="text-gray-300">We also add linear constraints representing the addition and multiplication by constant gates of the circuit. We then rewrite those equations so that the only wires that are referenced in the equations are those linked to (non-constant) multiplication gates. We describe this process in Appendix A.</p>

    <p class="text-gray-300">Finally, we fold both the Hadamard matrix product and the linear constraints into a single polynomial equation, where a Laurent polynomial has <span class="math">0</span> as its constant term, and use the construction of Section 3 to prove this. We can optionally integrate the inner product argument of Section 4 to reduce communication.</p>

    <p class="text-gray-300">Our technique improves on the efficiency of <em>[x11]</em> by making three main changes, each resulting in efficiency improvements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We do not need commitments to the input and output wires of addition gates. We handle addition gates with linear consistency equations thus yielding a significant performance improvement proportional to the number of addition gates. This parallels <em>[x12]</em> who also manage to eliminate addition gates when constructing Quadratic Arithmetic Programs from circuits.</li>

      <li>We avoid black-box reductions to zero-knowledge arguments for generic linear algebra statements and instead design an argument directly for arithmetic circuit satisfiability. As a result, our square-root argument has only <span class="math">5</span> moves, while the argument from <em>[x11]</em> requires <span class="math">7</span> moves. We note that <em>[x23]</em> reduced the complexity of <em>[x11]</em> to <span class="math">5</span> moves as well, but at a significant computational overhead whereas we also reduce the computational cost.</li>

      <li>We use our protocol from Section 3 to reduce the communication costs of a polynomial commitment.</li>

    </ol>

    <p class="text-gray-300">These improvements give us a square root communication complexity with respect to the number of multiplication gates in the circuit. This is because for a circuit with <span class="math">N=mn</span> multiplication gates, the prover makes <span class="math">3m</span> commitments to wire values in his first move, and later provides an opening consisting of <span class="math">n</span> field elements to a homomorphic combination of these commitments. Optimising the parameters by choosing <span class="math">m\\approx n\\approx\\sqrt{N}</span> leads to square root complexity.</p>

    <p class="text-gray-300">In our square root complexity argument, the verifier uses the <span class="math">n</span> field elements to check an inner product relation. Our key idea to reduce communication further is to use our inner product evaluation argument instead of sending these field elements. This allows for verification of the inner product, and also provides an</p>

    <p class="text-gray-300">argument of knowledge of the opening of the commitment. We no longer need to open a large commitment, leading to a drastic reduction in communication complexity depending on the settings for the inner product argument.</p>

    <p class="text-gray-300">Below we give a first informal exposition of our arguments, and follow with a formal description.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">2.2.2 Reduction of Circuit Satisfiability to a Hadamard Matrix Product and Linear Constraints.</h4>

    <p class="text-gray-300">We consider an arithmetic circuit containing <span class="math">N=mn</span> multiplication gates over a field <span class="math">\\mathbb{Z}_{p}</span>. Without loss of generality, we assume that the circuit has been pre-processed (see Appendix A for a way to do this) , so that the input and the output wires feed into and go out from multiplication gates only. We number the multiplication gates from <span class="math">1</span> to <span class="math">N</span> and we arrange the inputs and outputs of these gates into three <span class="math">m\\times n</span> matrices <span class="math">A,B</span> and <span class="math">C</span> such that the <span class="math">(i,j)</span> entries of the matrices correspond to the left input, right input and output of the same multiplication gate.</p>

    <p class="text-gray-300">As shown in Appendix A, anarithmetic circuit can be described as a system of equations in the entries of the above matrices. The multiplication gates define a set of <span class="math">N</span> equations</p>

    <p class="text-gray-300"><span class="math">A\\circ B=C</span> (1)</p>

    <p class="text-gray-300">where <span class="math">\\circ</span> is the Hadamard (entry-wise) product. The circuit description also contains constraints on the wires between multiplication gates. Denoting the rows of the matrices <span class="math">A,B,C</span> as</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{i}=(a_{i,1},\\ldots,a_{i,n})\\quad\\bm{b}_{i}=(b_{i,1},\\ldots,b_{i,n})\\quad\\bm{c}_{i}=(c_{i,1},\\ldots,c_{i,n})\\quad\\text{for }i\\in\\{1,\\ldots,m\\}</span></p>

    <p class="text-gray-300">these constraints can be expressed as <span class="math">Q&lt;2N</span> linear equations of inputs and outputs of multiplication gates of the form</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{m}\\bm{a}_{i}\\cdot\\bm{w}_{q,a,i}+\\sum_{i=1}^{m}\\bm{b}_{i}\\cdot\\bm{w}_{q,b,i}+\\sum_{i=1}^{m}\\bm{c}_{i}\\cdot\\bm{w}_{q,c,i}=K_{q}\\quad\\text{ for }q\\in\\{1,\\ldots,Q\\}</span> (2)</p>

    <p class="text-gray-300">for constant vectors <span class="math">\\bm{w}_{q,a,i},\\bm{w}_{q,b,i},\\bm{w}_{q,c,i}</span> and scalars <span class="math">K_{q}</span>.</p>

    <p class="text-gray-300">For example, suppose that the circuit contains a single addition gate, with <span class="math">a_{1,1}</span> and <span class="math">a_{1,2}</span> as inputs, and <span class="math">b_{1,1}</span> as output. In this case, <span class="math">Q=1</span> and we would set <span class="math">\\bm{w}_{1,a,1}=(1,1,0,\\ldots,0)</span>, <span class="math">\\bm{w}_{1,b,1}=(-1,0,\\ldots,0)</span>, and all other <span class="math">\\bm{w}</span> vectors would be set to <span class="math">\\bm{0}</span>. Then (2) would simply read</p>

    <p class="text-gray-300"><span class="math">a_{1,1}+a_{1,2}-b_{1,1}=0</span></p>

    <p class="text-gray-300">to capture the constraint imposed by the addition gate.</p>

    <p class="text-gray-300">In total, to capture all multiplications and linear constraints, we have <span class="math">N+Q</span> equations that the wires must satisfy in order for the circuit to be satisfiable.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">2.2.3 Reduction to a Single Polynomial Equation.</h4>

    <p class="text-gray-300">Let <span class="math">Y</span> be a formal indeterminate. We will reduce the <span class="math">N+Q</span> equations above to a single polynomial equation</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">in <span class="math">Y</span> by embedding each equation into a distinct power of <span class="math">Y</span>. In our argument we will then require the prover to prove that this single equation holds when replacing <span class="math">Y</span> by a random challenge received from the verifier.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{Y}&#x27;</span> denote the vector <span class="math">(Y^m, \\ldots, Y^{mn})</span> and <span class="math">\\mathbf{Y}</span> denote <span class="math">(Y, Y^2, \\ldots, Y^m)</span>. Then, we can multiply (1) by <span class="math">\\mathbf{Y}</span> from the left and <span class="math">\\mathbf{Y}&#x27;^T</span> on the right to obtain <span class="math">\\mathbf{Y}(A \\circ B)\\mathbf{Y}&#x27;^T = \\mathbf{Y}C\\mathbf{Y}&#x27;^T</span>, or equivalently</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{m} Y^{i}(\\boldsymbol{a}_{i} \\circ \\boldsymbol{b}_{i}) \\cdot \\boldsymbol{Y}&#x27; = \\sum_{i=1}^{m} Y^{i}(\\boldsymbol{c}_{i} \\cdot \\boldsymbol{Y}&#x27;)</span></div>

    <p class="text-gray-300">Since <span class="math">(\\boldsymbol{a} \\circ \\boldsymbol{b}) \\cdot \\boldsymbol{Y}&#x27; = \\boldsymbol{a} \\cdot (\\boldsymbol{b} \\circ \\boldsymbol{Y}&#x27;)</span>, we obtain the following expression</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot (\\boldsymbol{b}_{i} \\circ \\boldsymbol{Y}&#x27;) Y^{i} = \\left(\\sum_{i=1}^{m} \\boldsymbol{c}_{i} Y^{i} \\cdot \\boldsymbol{Y}&#x27;\\right)</span></div>

    <p class="text-gray-300">This is easily seen to be equivalent to (1), because <span class="math">a_{i,j}b_{i,j} = c_{i,j}</span> appears in the coefficients of <span class="math">Y^{i + jm}</span>, and <span class="math">i + jm</span> takes every value from <span class="math">m + 1</span> to <span class="math">M = N + m</span> exactly once.</p>

    <p class="text-gray-300">Moreover, the <span class="math">Q</span> linear constraints on the wires in Eq. 2 are satisfied if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{q=1}^{Q} \\left(\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\boldsymbol{w}_{q,a,i} + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} \\cdot \\boldsymbol{w}_{q,b,i} + \\sum_{i=1}^{m} \\boldsymbol{c}_{i} \\cdot \\boldsymbol{w}_{q,c,i}\\right) Y^{q} = \\sum_{q=1}^{Q} K_{q} Y^{q}</span></div>

    <p class="text-gray-300">since the <span class="math">q</span>th constraint arises from comparing the coefficients of <span class="math">Y^q</span>. Combining the two polynomial equations by adding them after multiplying the latter by <span class="math">Y^M</span>, and swapping summations, we see that the circuit is satisfied if and only if</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\left(\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot (\\boldsymbol{b}_{i} \\circ \\boldsymbol{Y}') Y^{i}\\right) + \\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\left(\\sum_{q=1}^{Q} \\boldsymbol{w}_{q,a,i} Y^{M+q}\\right) + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} \\cdot \\left(\\sum_{q=1}^{Q} \\boldsymbol{w}_{q,b,i} Y^{M+q}\\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{i=1}^{m} \\boldsymbol{c}_{i} \\cdot \\left(- Y^{i} \\boldsymbol{Y}' + \\sum_{q=1}^{Q} \\boldsymbol{w}_{q,c,i} Y^{M+q}\\right) \\quad = \\quad \\left(\\sum_{q=1}^{Q} K_{q} Y^{M+q}\\right)</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Let us define</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w}_{a,i}(Y) = \\sum_{q=1}^{Q} \\boldsymbol{w}_{q,a,i} Y^{M+q} \\quad \\boldsymbol{w}_{b,i}(Y) = \\sum_{q=1}^{Q} \\boldsymbol{w}_{q,b,i} Y^{M+q}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w}_{c,i}(Y) = - Y^{i} \\boldsymbol{Y}&#x27; + \\sum_{q=1}^{Q} \\boldsymbol{w}_{q,c,i} Y^{M+q} \\quad K(Y) = \\sum_{q=1}^{Q} K_{q} Y^{M+q}</span></div>

    <p class="text-gray-300">Then the circuit is satisfied if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot (\\boldsymbol{b}_{i} \\circ \\boldsymbol{Y}&#x27;) Y^{i} + \\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\boldsymbol{w}_{a,i}(Y) + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} \\cdot \\boldsymbol{w}_{b,i}(Y) + \\sum_{i=1}^{m} \\boldsymbol{c}_{i} \\cdot \\boldsymbol{w}_{c,i}(Y) - K(Y) = 0 \\tag{3}</span></div>

    <p class="text-gray-300">In the argument, the prover will commit to <span class="math">\\bm{a}_{i},\\bm{b}_{i}</span> and <span class="math">\\bm{c}_{i}</span>. The verifier will then issue a random challenge <span class="math">y\\leftarrow\\mathbb{Z}_{p}^{*}</span> and the prover will convince the verifier that the committed values satisfy Eq. 3, evaluated on <span class="math">y</span>. If the committed values do not satisfy the polynomial equation, the probability the equality holds for a random <span class="math">y</span> is negligible, so the prover is unlikely to be able to convince the verifier.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">5.1 Square Root Communication Argument</h3>

    <p class="text-gray-300">In order to show that (3) is satisfied, we craft a special Laurent polynomial <span class="math">t(X)</span> in a second formal indeterminate <span class="math">X</span>, whose constant coefficient is exactly twice the left-hand side of (3). Therefore, this polynomial will have zero constant term if and only if (3) is satisfied. In our argument this is proved using the polynomial commitment protocol of Section 3. We define</p>

    <p class="text-gray-300"><span class="math">\\bm{r}(X)</span> <span class="math">:=\\sum_{i=1}^{m}\\bm{a}_{i}y^{i}X^{i}+\\sum_{i=1}^{m}\\bm{b}_{i}X^{-i}+X^{m}\\sum_{i=1}^{m}\\bm{c}_{i}X^{i}+\\bm{d}X^{2m+1}</span> <span class="math">\\bm{s}(X)</span> <span class="math">:=\\sum_{i=1}^{m}\\bm{w}_{a,i}(y)y^{-i}X^{-i}+\\sum_{i=1}^{m}\\bm{w}_{b,i}(y)X^{i}+X^{-m}\\sum_{i=1}^{m}\\bm{w}_{c,i}(y)X^{-i}</span> <span class="math">\\bm{r}^{\\prime}(X)</span> <span class="math">:=\\bm{r}(X)\\circ\\bm{y}^{\\prime}+2\\bm{s}(X)</span> <span class="math">t(X)</span> <span class="math">:=\\bm{r}(X)\\cdot\\bm{r}^{\\prime}(X)-2K(y)</span></p>

    <p class="text-gray-300">Here <span class="math">\\bm{y}^{\\prime}</span> is the vector <span class="math">\\bm{Y}^{\\prime}</span> evaluated at <span class="math">y</span>, and <span class="math">\\bm{d}</span> is a blinding vector consisting of random scalars that the prover commits to in the first round. In the square root argument the prover will reveal <span class="math">\\bm{r}(x)</span> for a randomly chosen challenge <span class="math">x\\in\\mathbb{Z}_{p}^{*}</span>, and the blinding vector <span class="math">\\bm{d}</span> ensures that we can reveal <span class="math">\\bm{r}(x)</span> without leaking information about <span class="math">\\bm{a}_{i},\\bm{b}_{i}</span> and <span class="math">\\bm{c}_{i}</span>. We also observe that <span class="math">\\bm{s}(x)</span> is efficiently computable from public information about the circuit and the challenges.</p>

    <p class="text-gray-300">We have designed these polynomials such that the constant term of <span class="math">\\bm{r}\\cdot(\\bm{r}\\circ\\bm{y}^{\\prime})</span> is equal to <span class="math">2\\sum_{i=1}^{m}\\bm{a}_{i}\\cdot(\\bm{b}_{i}\\circ\\bm{y}^{\\prime})y^{i}</span> and the constant term of <span class="math">\\bm{r}\\cdot\\bm{s}</span> is equal to <span class="math">\\sum_{i=1}^{m}\\bm{a}_{i}\\cdot\\bm{w}_{a,i}(y)+\\sum_{i=1}^{m}\\bm{b}_{i}\\cdot\\bm{w}_{b,i}(y)+\\sum_{i=1}^{m}\\bm{c}_{i}\\cdot\\bm{w}_{c,i}(y)</span>. We conclude that the constant term of <span class="math">t(X)</span> is exactly twice the left-hand side of (3), and is therefore zero if and only if the circuit is satisfied.</p>

    <p class="text-gray-300">We are now in a position to describe an argument with square root communication complexity.</p>

    <p class="text-gray-300">The prover first commits to vectors <span class="math">\\bm{a}_{i},\\bm{b}_{i},\\bm{c}_{i}</span> and <span class="math">\\bm{d}</span> and the verifier replies with a challenge <span class="math">y\\leftarrow\\mathbb{Z}_{p}^{<em>}</span>. The prover computes <span class="math">t(X)</span> and commits to it by using the algorithm PolyCommit defined in Section 3. Then, the verifier sends a random challenge <span class="math">x\\leftarrow\\mathbb{Z}_{p}^{</em>}</span> and the prover responds by revealing <span class="math">\\bm{r}(x)</span> and blinded openings <span class="math">\\mathsf{pe}</span> of <span class="math">t(X)</span> obtained by running algorithm PolyEval as described in Section 3.</p>

    <p class="text-gray-300">The verifier first checks that <span class="math">\\bm{r}(x)</span> is consistent with the previously sent commitments of <span class="math">\\bm{a}_{i},\\bm{b}_{i},\\bm{c}_{i}</span> and <span class="math">\\bm{d}</span> using the homomorphic properties of the commitment scheme. She also computes <span class="math">\\bm{s}(x),\\bm{r}^{\\prime}(x)</span> and <span class="math">K</span>. Then, she computes <span class="math">v=t(x)</span> using the PolyVerify algorithm of Section 3, and checks if <span class="math">v=\\bm{r}(x)\\cdot\\bm{r}^{\\prime}(x)-2K</span>. The verifier accepts the argument if both checks are satisfied.</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">As described so far, the argument requires communicating <span class="math">O(m)</span> group elements and <span class="math">O(n)</span> field elements, so setting <span class="math">m \\approx n</span> leads to square root communication. The argument improves on [Gro09b, Seo11] by requiring only 5 moves without computational overhead and significantly reduces the computational complexity. However, breaking this ostensible square root communication barrier requires new ideas that we describe in the next section.</p>

    <h2 id="sec-33" class="text-2xl font-bold">5.2 Breaking the Square Root Barrier</h2>

    <p class="text-gray-300">The square root complexity argument described above was designed so that the verifier uses <span class="math">\\boldsymbol{r} = \\boldsymbol{r}(x)</span> to check the inner product <span class="math">v = \\boldsymbol{r} \\cdot \\boldsymbol{r}&#x27; - 2K</span>, where <span class="math">v</span> is the evaluation of a committed polynomial at <span class="math">x</span>. Sending <span class="math">\\boldsymbol{r}</span> has a cost of <span class="math">n</span> field elements. In order to break the square root barrier we try to avoid sending <span class="math">\\boldsymbol{r}</span> directly so that we can then let <span class="math">n</span> be larger and <span class="math">m</span> be smaller and thus globally lower the communication of the argument.</p>

    <p class="text-gray-300">Rather than sending <span class="math">\\boldsymbol{r}</span> to the verifier, the prover could instead send commitments to <span class="math">\\boldsymbol{r}</span> and <span class="math">\\boldsymbol{r}&#x27;</span>, and use our inner product argument to show that <span class="math">v + 2K</span> was a correctly formed inner product. In fact, the prover does not even need to send commitments to <span class="math">\\boldsymbol{r}</span> and <span class="math">\\boldsymbol{r}&#x27;</span>! The verifier can compute a commitment to <span class="math">\\boldsymbol{r}(x)</span> directly from <span class="math">A_i, B_i, C_i</span> and <span class="math">D</span>, the commitments to <span class="math">\\boldsymbol{a}_i, \\boldsymbol{b}_i, \\boldsymbol{c}_i</span> and <span class="math">\\boldsymbol{d}</span> which were previously used to check that <span class="math">\\boldsymbol{r}</span> is correctly formed</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Com}_{ck}(\\boldsymbol{r}; 0) = \\operatorname{Com}_{ck}(0; -\\rho) \\left[ \\prod_{i=1}^{m} A_i^{x^i y^i} \\right] \\left[ \\prod_{i=1}^{m} B_i^{x^{-i}} \\right] \\left[ \\prod_{i=1}^{m} C_i^{x^{m+i}} \\right] D^{x^{2m+1}} = \\boldsymbol{g}^r</span></div>

    <p class="text-gray-300">where <span class="math">\\rho</span> is an appropriate randomness value, which is sent by the prover to the verifier, and the vector <span class="math">\\boldsymbol{g} = (g_1, \\ldots, g_n)</span> for a given commitment key <span class="math">ck = (\\mathbb{G}, p, g, g_1, \\ldots, g_n)</span>.</p>

    <p class="text-gray-300">As for a commitment to <span class="math">\\boldsymbol{r}&#x27;</span>, we observe that the Pedersen commitment, besides its well-known homomorphic properties with respect to the message and the randomness, also has the useful property that it is homomorphic with respect to the commitment key. Specifically, let <span class="math">\\boldsymbol{h} = (g_1^{y^{-m}}, \\ldots, g_n^{y^{-mn}})</span>, so that <span class="math">\\boldsymbol{g}^r = \\boldsymbol{h}^{r \\circ y&#x27;}</span>. Multiplying <span class="math">\\boldsymbol{g}^r</span> by <span class="math">\\boldsymbol{h}^{2s}</span>, the verifier obtains <span class="math">\\mathrm{Com}_{ck&#x27;}(\\boldsymbol{r}&#x27;; 0) = \\boldsymbol{h}^{r&#x27;}</span>, with respect to the new commitment key <span class="math">ck&#x27;</span> which uses <span class="math">\\boldsymbol{h}</span> instead of <span class="math">\\boldsymbol{g}</span>. We note that <span class="math">\\boldsymbol{h}</span> and <span class="math">\\boldsymbol{s} = \\boldsymbol{s}(x)</span> can be computed by the verifier.</p>

    <p class="text-gray-300">Now the prover and verifier can run the inner product argument with statement</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb{G}, p, \\boldsymbol{g}, r, \\boldsymbol{h}, r&#x27;, v + 2K, m_\\mu, m_{\\mu-1}, \\ldots, m_1) \\quad \\text{where}</span></div>

    <div class="my-4 text-center"><span class="math-block">ck = (\\mathbb{G}, p, g, \\boldsymbol{g}) \\quad n = m_\\mu m_{\\mu-1} \\cdots m_1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{g} = (g_1, g_2, \\ldots, g_n) \\quad \\boldsymbol{h} = (g_1^{y^{-m}}, g_2^{y^{-2m}}, \\ldots, g_n^{y^{-mn}})</span></div>

    <div class="my-4 text-center"><span class="math-block">R = \\operatorname{Com}_{ck}(0; -\\rho) \\left[ \\prod_{i=1}^{m} A_i^{x^i y^i} \\right] \\left[ \\prod_{i=1}^{m} B_i^{x^{-i}} \\right] \\left[ \\prod_{i=1}^{m} C_i^{x^{m+i}} \\right] D^{x^{2m+1}} = \\boldsymbol{g}^r</span></div>

    <div class="my-4 text-center"><span class="math-block">R&#x27; = R \\cdot \\boldsymbol{h}^{2s} = \\boldsymbol{h}^{r&#x27;}</span></div>

    <p class="text-gray-300">and the prover's witness is <span class="math">\\boldsymbol{r}, \\boldsymbol{r}&#x27;</span>.</p>

    <p class="text-gray-300">The values of <span class="math">m_\\mu, \\ldots, m_1</span> can be chosen according to the desired efficiency of the circuit satisfiability argument.</p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300">We now give the formal description of the above arguments of knowledge for the satisfiability of an arithmetic circuit <span class="math">C</span>. Both prover and verifier take the move parameter <span class="math">\\mu</span> as common input. For square root communication complexity, the inner product argument is not used and we set <span class="math">\\mu = 0</span>. For <span class="math">\\mu &amp;gt; 0</span>, the common input includes the values <span class="math">(m_{\\mu}, \\ldots, m_{1})</span> used in the inner product argument. The description of the arithmetic circuit <span class="math">C</span> is given as a number <span class="math">N</span> of multiplication gates and the values <span class="math">\\boldsymbol{w}_{q,a,i}, \\boldsymbol{w}_{q,b,i}, \\boldsymbol{w}_{q,c,i}</span>, which specify linear consistency constraints between the input and output values of the multiplication gates.</p>

    <p class="text-gray-300"><strong>Common Input</strong>: <span class="math">(ck, C, N, m, n, m_1&#x27;, m_2&#x27;, n&#x27;, m_\\mu, \\ldots, m_1, \\mu)</span> where <span class="math">ck</span> is a commitment key, <span class="math">C</span> is the description of an arithmetic circuit with <span class="math">N = mn</span> multiplication gates, <span class="math">\\mu</span> is the move parameter and <span class="math">n = m_\\mu \\cdots m_1</span>. Parameters <span class="math">(m_1&#x27;, m_2&#x27;, n&#x27;)</span> are set to satisfy both <span class="math">3m \\leq m_1&#x27; n&#x27;</span> and <span class="math">4m + 2 \\leq m_2&#x27; n&#x27;</span>.</p>

    <p class="text-gray-300"><strong>Prover's Witness</strong>: Satisfying assignments <span class="math">\\pmb{a}_i, \\pmb{b}_i</span> and <span class="math">\\pmb{c}_i</span> to the wires of <span class="math">C</span>.</p>

    <p class="text-gray-300"><strong>Argument</strong>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>P</strong> → <strong>V</strong>: Pick randomness <span class="math">\\alpha_{1}, \\beta_{1}, \\gamma_{1}, \\ldots, \\alpha_{m}, \\beta_{m}, \\gamma_{m}, \\delta \\gets \\mathbb{Z}_{p}</span> and blinding vector <span class="math">\\boldsymbol{d} \\gets \\mathbb{Z}_{p}^{n}</span>. Compute for <span class="math">i \\in \\{1, \\ldots, m\\}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">A _ {i} = \\operatorname {C o m} (\\boldsymbol {a} _ {i}; \\alpha_ {i}) \\quad B _ {i} = \\operatorname {C o m} (\\boldsymbol {b} _ {i}; \\beta_ {i}) \\quad C _ {i} = \\operatorname {C o m} (\\boldsymbol {c} _ {i}; \\gamma_ {i}) \\quad D = \\operatorname {C o m} (\\boldsymbol {d}; \\delta).</span></div>

    <p class="text-gray-300">Send to the verifier <span class="math">A_{1},B_{1},C_{1},\\ldots ,A_{m},B_{m},C_{m},D</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>P</strong> ← <strong>V</strong>: <span class="math">y \\gets \\mathbb{Z}_p^*</span>.</li>

    </ul>

    <p class="text-gray-300">As argued before, the circuit determines vectors of polynomials <span class="math">\\boldsymbol{w}_{a,i}(Y)</span>, <span class="math">\\boldsymbol{w}_{b,i}(Y)</span>, <span class="math">\\boldsymbol{w}_{c,i}(Y)</span> and <span class="math">K(Y)</span> such that <span class="math">C</span> is satisfiable if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 1} ^ {m} \\boldsymbol {a} _ {i} \\cdot (\\boldsymbol {b} _ {i} ^ {T} \\circ \\boldsymbol {Y} ^ {\\prime}) Y ^ {i} + \\sum_ {i = 1} ^ {m} \\boldsymbol {a} _ {i} \\cdot \\boldsymbol {w} _ {a, i} (Y) + \\sum_ {i = 1} ^ {m} \\boldsymbol {b} _ {i} \\cdot \\boldsymbol {w} _ {b, i} (Y) + \\sum_ {i = 1} ^ {m} \\boldsymbol {c} _ {i} \\cdot \\boldsymbol {w} _ {c, i} (Y) = K (Y)</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{Y}&#x27; = (Y^m, \\ldots, Y^{mn})</span>. Given <span class="math">y</span>, both the prover and verifier can compute <span class="math">K = K(y)</span>, <span class="math">\\mathbf{w}_{a,i} = \\mathbf{w}_{a,i}(y)</span>, <span class="math">\\mathbf{w}_{b,i} = \\mathbf{w}_{b,i}(y)</span> and <span class="math">\\mathbf{w}_{c,i} = \\mathbf{w}_{c,i}(y)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>P</strong> → <strong>V</strong>: Compute Laurent polynomials <span class="math">\\boldsymbol{r}, \\boldsymbol{s}, \\boldsymbol{r}&#x27;</span>, which have vector coefficients, and Laurent polynomial <span class="math">t</span>, in the indeterminate <span class="math">X</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {r} (X) = \\sum_ {i = 1} ^ {m} \\boldsymbol {a} _ {i} y ^ {i} X ^ {i} + \\sum_ {i = 1} ^ {m} \\boldsymbol {b} _ {i} X ^ {- i} + X ^ {m} \\sum_ {i = 1} ^ {m} \\boldsymbol {c} _ {i} X ^ {i} + d X ^ {2 m + 1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {s} (X) = \\sum_ {i = 1} ^ {m} \\boldsymbol {w} _ {a, i} y ^ {- i} X ^ {- i} + \\sum_ {i = 1} ^ {m} \\boldsymbol {w} _ {b, i} X ^ {i} + X ^ {- m} \\sum_ {i = 1} ^ {m} \\boldsymbol {w} _ {c, i} X ^ {- i}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {r} ^ {\\prime} (X) = \\boldsymbol {r} (X) \\circ \\boldsymbol {y} ^ {\\prime} + 2 \\boldsymbol {s} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">t (X) = \\boldsymbol {r} (X) \\cdot \\boldsymbol {r} ^ {\\prime} (X) - 2 K = \\sum_ {k = - 3 m} ^ {4 m + 2} t _ {k} X ^ {k}</span></div>

    <p class="text-gray-300">When the wires <span class="math">\\pmb{a}_i, \\pmb{b}_i, \\pmb{c}_i</span> correspond to a satisfying assignment, the Laurent polynomial <span class="math">t(X)</span> will have constant term <span class="math">t_0 = 0</span>.</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">Commit to <span class="math">t(X)</span> by running</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{pc}, \\mathsf{st}) \\leftarrow \\operatorname{PolyCommit}(ck, m_1&#x27;, m_2&#x27;, n&#x27;, t(X))</span></div>

    <p class="text-gray-300">Send <span class="math">\\mathsf{pc}</span> to the verifier.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\gets \\mathbf{V}: x \\gets \\mathbb{Z}_p^*</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\rightarrow \\mathbf{V}</span>: Compute <span class="math">\\mathrm{PolyEval}(\\mathsf{st}, x) \\rightarrow \\mathsf{pe}</span>, and</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{r} = \\sum_{i=1}^{m} \\boldsymbol{a}_i x^i y^i + \\sum_{i=1}^{m} \\boldsymbol{b}_i x^{-i} + x^m \\sum_{i=1}^{m} \\boldsymbol{c}_i x^i + \\boldsymbol{d} x^{2m+1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho = \\sum_{i=1}^{m} \\alpha_i x^i y^i + \\sum_{i=1}^{m} \\beta_i x^{-i} + x^m \\sum_{i=1}^{m} \\gamma_i x^i + \\delta x^{2m+1}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mu = 0</span>: the inner product argument is not used. The prover sends <span class="math">(\\mathsf{pe}, \\boldsymbol{r}, \\rho)</span> to the verifier.</li>

      <li>If <span class="math">\\mu &amp;gt; 0</span>: the inner product argument is used. The prover computes <span class="math">r&#x27; = r&#x27;(x)</span> and sends <span class="math">(\\mathsf{pe}, \\rho)</span> to the verifier.</li>

    </ul>

    <p class="text-gray-300"><strong>Verification</strong>: First, the verifier computes</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{PolyVerify}(ck, m_1&#x27;, m_2&#x27;, n&#x27;, \\mathsf{pc}, \\mathsf{pe}, x) \\rightarrow v</span></div>

    <p class="text-gray-300">and rejects the argument if <span class="math">v = \\bot</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mu = 0</span>: the inner product argument is not used. The verifier computes <span class="math">r&#x27; = r \\circ y&#x27; + 2s(x)</span>, and accepts only if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\boldsymbol{r} \\cdot \\boldsymbol{r}&#x27; - 2K = v \\\\ \\operatorname{Com}_{ck}(\\boldsymbol{r}; \\rho) = \\left[ \\prod_{i=1}^{m} A_i^{x^i y^i} \\right] \\left[ \\prod_{i=1}^{m} B_i^{x^{-i}} \\right] \\left[ \\prod_{i=1}^{m} C_i^{x^{m+i}} \\right] D^{x^{2m+1}} \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mu &amp;gt; 0</span>: prover and verifier run the inner product argument with common input</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb{G}, p, \\boldsymbol{g}, R, \\boldsymbol{h}, R&#x27;, v + 2K, m_\\mu, m_{\\mu-1}, \\dots, m_1) \\quad \\text{where}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} ck = (\\mathbb{G}, p, g, \\boldsymbol{g}) \\quad n = m_\\mu m_{\\mu-1} \\dots m_1 \\\\ \\boldsymbol{g} = (g_1, g_2, \\dots, g_n) \\quad \\boldsymbol{h} = (g_1^{y^{-m}}, g_2^{y^{-2m}}, \\dots, g_n^{y^{-mn}}) \\\\ R = \\operatorname{Com}_{ck}(0; -\\rho) \\left[ \\prod_{i=1}^{m} A_i^{x^i y^i} \\right] \\left[ \\prod_{i=1}^{m} B_i^{x^{-i}} \\right] \\left[ \\prod_{i=1}^{m} C_i^{x^{m+i}} \\right] D^{x^{2m+1}} = \\boldsymbol{g}^r \\\\ R&#x27; = R \\cdot \\boldsymbol{h}^{2s(x)} = \\boldsymbol{h}^{r&#x27;} \\end{array}</span></div>

    <p class="text-gray-300">and the prover's witness is <span class="math">\\boldsymbol{r}</span> and <span class="math">\\boldsymbol{r}&#x27;</span>.</p>

    <p class="text-gray-300">The verifier accepts if the inner product argument is accepting.</p>

    <p class="text-gray-300">Security Analysis.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">The argument for satisfiability of an arithmetic circuit has perfect completeness, perfect special honest verifier zero-knowledge and statistical witness-extended emulation for extracting either a breach of the binding property of the commitment scheme or a witness for the satisfiability of the circuit.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Perfect completeness follows by inspection and using the fact that the polynomial commitment protocol and inner product argument also have perfect completeness.</p>

    <p class="text-gray-300">For perfect special honest verifier zero-knowledge we are given <span class="math">y,x\\in\\mathbb{Z}_{p}^{*}</span>, which allows us to compute <span class="math">\\bm{w}_{a,i},\\bm{w}_{b,i},\\bm{w}_{c,i}</span> and <span class="math">K</span> from the circuit. The simulator picks <span class="math">\\bm{r}\\leftarrow\\mathbb{Z}_{p}^{n}</span> and <span class="math">\\rho\\leftarrow\\mathbb{Z}_{p}</span> and random commitments <span class="math">A_{i},B_{i}</span> and <span class="math">C_{i}</span>. It computes</p>

    <p class="text-gray-300"><span class="math">D=\\left[\\prod_{i=1}^{m}A_{i}^{x^{i}y^{i}}B_{i}^{x^{-i}}C_{i}^{x^{m+i}}\\mathrm{Com}_{ck}(-\\bm{r};-\\rho)\\right]^{-x^{-2m-1}}\\quad\\quad v=\\bm{r}\\cdot\\bm{r}^{\\prime}-2K</span></p>

    <p class="text-gray-300">and simulates <span class="math">\\mathsf{pc}</span> and <span class="math">\\mathsf{pe}</span> from the polynomial commitment protocol.</p>

    <p class="text-gray-300">To see that the simulated components have the same distribution as a real argument observe that since the commitment scheme is perfectly hiding the commitments <span class="math">A_{i},B_{i}</span> and <span class="math">C_{i}</span> have the same distribution as in a real argument. Also, in both the simulation and a real argument <span class="math">\\bm{r}</span> and <span class="math">\\rho</span> are uniformly random. Given these values the commitment <span class="math">D</span> is uniquely defined. Furthermore, since the polynomial commitment protocol is perfect special honest verifier zero-knowledge, <span class="math">\\mathsf{pc}</span> and <span class="math">\\mathsf{pe}</span> have the same distribution as in a real argument, conditioned on the value of <span class="math">v</span>.</p>

    <p class="text-gray-300">When <span class="math">\\mu&gt;0</span> we simply remove <span class="math">\\bm{r}</span> from the transcript and execute a fresh run of the inner product argument, given our knowledge of <span class="math">\\bm{r}</span>.</p>

    <p class="text-gray-300">It remains to show that we have witness-extended emulation. We treat the cases <span class="math">\\mu=0</span> and <span class="math">\\mu&gt;0</span> separately.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Square Root Argument</h4>

    <p class="text-gray-300">Assume that we have <span class="math">N+Q</span> different challenges <span class="math">y\\in\\mathbb{Z}_{p}^{<em>}</span> for the same initial message, and for each of these challenges a further <span class="math">7m+3</span> different challenges <span class="math">x\\in\\mathbb{Z}_{p}^{</em>}</span> for the same third message, all with valid answers. We begin by showing that from this information we either extract a satisfying assignment to the wires <span class="math">\\bm{a}_{i},\\bm{b}_{i},\\bm{c}_{i}</span> in the circuit, or encounter a breach of the binding property of the commitment scheme.</p>

    <p class="text-gray-300">Let us first consider a fixed initial transcript <span class="math">(A_{1},\\ldots,A_{m},\\ldots,C_{m},D,y,\\mathsf{pc})</span> and suppose we have valid arguments with <span class="math">3m+2</span> different values of <span class="math">x</span>. Then the vectors <span class="math">(x^{-m},\\ldots,x^{2m+1})</span> form the rows of a shifted Vandermonde matrix and we can obtain any unit vector <span class="math">(0,\\ldots,1,\\ldots,0)</span> by taking an appropriate linear combination of these vectors. By taking the correct linear combinations of the <span class="math">3m+2</span> verification equations <span class="math">D^{x^{2m+1}}\\prod_{i=1}^{m}A_{i}^{x^{i}y^{i}}B_{i}^{x^{-i}}C_{i}^{x^{m+i}}=\\mathrm{Com}_{ck}(\\bm{r};\\rho)</span>, we can then extract openings to each <span class="math">A_{i},B_{i}</span> and <span class="math">C_{i}</span>, since <span class="math">y\\in\\mathbb{Z}_{P}^{*}</span>.</p>

    <p class="text-gray-300">We have valid arguments for <span class="math">(m_{1}^{\\prime}+m_{2}^{\\prime})n^{\\prime}+1=7m+3</span> different challenges <span class="math">x\\in\\mathbb{Z}_{p}^{*}</span>. By the proof of Theorem 1 this implies that there exists a Laurent</p>

    <p class="text-gray-300">polynomial <span class="math">t(X)=\\sum_{i=-n^{\\prime}m_{1}^{\\prime}}^{n^{\\prime}m_{2}^{\\prime}}t_{i}x^{i}</span> with constant term <span class="math">t_{0}=0</span> that is consistent with respect to all <span class="math">3m+2</span> evaluations of <span class="math">\\bm{r}(X)\\cdot\\bm{r}^{\\prime}(X)-2K</span>. This directly implies that Equation 3 holds for <span class="math">Y=y</span>.</p>

    <p class="text-gray-300">Finally, suppose that this holds for <span class="math">N+Q</span> different challenges <span class="math">y\\in\\mathbb{Z}_{p}^{*}</span>. Then, we have equality of polynomials in Equation 3, since a non-zero polynomial of degree <span class="math">N+Q-1</span> cannot have <span class="math">N+Q</span> roots. This means that the circuit is satisfied.</p>

    <p class="text-gray-300">Now we can apply the forking lemma to get witness-extended emulation, as the tree formed by the transcripts has size <span class="math">(N+Q)\\cdot(7m+3)</span> which is polynomial in <span class="math">\\lambda</span>.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Inner Product Variant</h4>

    <p class="text-gray-300">Assume that we have <span class="math">(N+Q)\\cdot(7m+3)\\cdot(2m_{\\mu}-1)\\ldots(2m_{2}-1)</span> accepting transcripts for the same statement arranged in a tree as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The root is labeled with the statement.</li>

      <li>Each of the <span class="math">(N+Q)</span> depth 1 nodes is labeled with a different challenge <span class="math">y</span> and has <span class="math">7m+3</span> children labeled <span class="math">x</span>.</li>

      <li>The children are subtrees of size <span class="math">(2m_{\\mu}-1)\\ldots(2m_{2}-1)</span></li>

      <li>Each level has nodes labeled with the challenges <span class="math">x_{i}</span> used in the <span class="math">i</span>-th move of the recursive argument, and of degree <span class="math">2m_{\\mu-i+1}-1</span>.</li>

    </ul>

    <p class="text-gray-300">Given the above tree of transcripts, we are able to do a two-stage extraction: First, we invoke the witness-extended emulation of the recursive inner product argument. At this point, we either have a a non-trivial discrete logarithm relation, in which case we are done, or we have an accepting <span class="math">\\bm{r}</span> for each <span class="math">y,x</span> pair. In this case, we proceed with the second stage and repeat the extraction procedure for <span class="math">\\mu=0</span> to obtain either a witness for the original statement or a breach of the binding property of the commitment scheme.</p>

    <p class="text-gray-300">We now point out that the size of the tree will be <span class="math">O(N\\cdot(2m)^{\\mu})\\approx O(N^{2+\\log_{m}2})</span> which is polynomial in the security parameter <span class="math">\\lambda</span> and invoke the forking lemma to complete the proof. ∎</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">Efficiency</h3>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Square Root Communication.</h4>

    <p class="text-gray-300">When we set <span class="math">\\mu=0</span>, the argument above has a communication cost of <span class="math">m_{1}^{\\prime}+m_{2}^{\\prime}+2+1+3m</span> commitments and <span class="math">n+n^{\\prime}+2</span> field elements. Setting <span class="math">m\\approx\\sqrt{\\frac{N}{3}}</span>, <span class="math">n\\approx\\sqrt{3N}</span>, <span class="math">n^{\\prime}\\approx\\sqrt{7m}</span>, <span class="math">m_{1}^{\\prime}\\approx 3\\sqrt{\\frac{m}{7}}</span> and <span class="math">m_{2}^{\\prime}\\approx 4\\sqrt{\\frac{m}{7}}</span> we get a total communication complexity where the total number of group and field elements sent is as low as possible and approximately <span class="math">2\\sqrt{N}</span> each. The main computational cost for the prover is computing the initial commitments, corresponding to <span class="math">\\frac{3mn}{\\log n}</span> group exponentiations. The prover can compute <span class="math">t(X)</span> using FFT-based techniques. Assuming that <span class="math">p</span> is of a suitable form <em>[x1]</em>, the dominant number of multiplications for this process is <span class="math">\\frac{3}{2}mn\\log m</span>. The main cost in the verification is computing <span class="math">\\bm{s}(X)</span> given the description of the circuit which requires in the worst case <span class="math">Qn</span> multiplications in <span class="math">\\mathbb{Z}_{p}</span>, considering arbitrary fan-in</p>

    <p class="text-gray-300">addition gates. In case of <span class="math">O(N)</span>-size circuits with fan-in 2 gates, computing <span class="math">\\bm{s}(X)</span> requires <span class="math">O(N)</span> multiplications. Evaluating <span class="math">\\bm{s}(x)</span> requires <span class="math">3N</span> multiplications. The last verification equation costs roughly <span class="math">\\frac{(n+3m)}{\\log n+3m}</span> group exponentiations to the verifier.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6"><span class="math">(\\mu+1)</span>-Root Communication.</h4>

    <p class="text-gray-300">We can reduce communication by using <span class="math">\\mu=O(1)</span> iterations of the inner product argument. Choosing <span class="math">m=N^{\\frac{1}{\\mu+1}}</span>, <span class="math">n=N^{\\frac{\\mu}{\\mu+1}}</span> and <span class="math">m_{i}=(\\frac{N}{m})^{\\frac{1}{\\mu}}</span> will give us a communication complexity of <span class="math">4\\mu N^{\\frac{1}{\\mu+1}}</span> group elements and <span class="math">2\\mu N^{\\frac{1}{\\mu+1}}</span> field elements. The prover’s complexity is dominated by <span class="math">\\frac{6\\mu N}{\\log N}</span> group exponentiations and fewer than <span class="math">\\frac{3N}{2\\mu}\\log N</span> field multiplications. The verifier’s cost is dominated by <span class="math">\\frac{2\\mu N}{\\log N}</span> group exponentiations and <span class="math">O(N)</span> field multiplications.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Logarithmic Communication.</h4>

    <p class="text-gray-300">By increasing the number of iteration of the inner product argument we can further reduce the communication complexity.</p>

    <p class="text-gray-300">To minimize the communication, we set <span class="math">\\mu=\\log N-1</span>, <span class="math">n=\\frac{N}{2}</span>, <span class="math">m=m_{i}=2</span>, <span class="math">m_{1}^{\\prime}=2</span>, <span class="math">m_{2}^{\\prime}=3</span> and <span class="math">n^{\\prime}=4</span> in the above argument gives us <span class="math">2\\log N+1</span> moves. The total communication amounts to <span class="math">4\\log N+7</span> group elements and <span class="math">2\\log N+6</span> field elements. The prover computational cost is dominated by <span class="math">12N</span> group exponentiations, and <span class="math">O(N)</span> multiplications in <span class="math">\\mathbb{Z}_{p}</span>.The main verification cost is bounded by <span class="math">4N</span> group exponentiations and <span class="math">O(N)</span> multiplications in <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <p class="text-gray-300">Alternatively, we can optimize the computation while maintaining logarithmic communication by setting <span class="math">\\mu=\\log N-\\log\\log 2N</span>, <span class="math">m=\\log N</span>, <span class="math">n=\\frac{N}{\\log N}</span>, <span class="math">n^{\\prime}\\approx\\sqrt{7\\log N}</span>, <span class="math">m_{1}^{\\prime}\\approx 3\\sqrt{\\frac{\\log N}{7}}</span>, <span class="math">m_{2}^{\\prime}\\approx 4\\sqrt{\\frac{\\log N}{7}}</span>, <span class="math">m_{i}=2</span> for <span class="math">1\\leq i\\leq\\mu</span>. In this way we obtain a <span class="math">2\\log N-2\\log\\log N+1</span> moves argument. With respect to the previous settings, we now save <span class="math">2\\log\\log N</span> moves by starting the inner product argument with a smaller statement. The resulting communication is at most <span class="math">7\\log N+\\sqrt{7\\log N}</span> group elements and at most <span class="math">2\\log N+\\sqrt{7\\log N}</span> field elements. Thus, the prover computation is dominated by <span class="math">\\frac{3N}{\\log N}</span> group exponentiations and <span class="math">11N\\log\\log N</span> field multiplications. For the verifier, it is bounded from above by <span class="math">\\frac{4N}{\\log N\\log\\log N}</span> group exponentiations and <span class="math">O\\left(N\\right)</span> field multiplications.</p>

    <h2 id="sec-43" class="text-2xl font-bold">6 Implementation using Python</h2>

    <p class="text-gray-300">To verify the practicality of our construction we produced a proof of concept implementation in Python using the NumPy <em>[x13]</em> package. The more costly operations are executed natively: we use Petlib <em>[x2]</em> to outsource elliptic curve operations to the OpenSSL library, and also use a small C++ program to calculate the polynomial multiplication producing <span class="math">\\bm{t}(X)</span> using NTL <em>[x16]</em>. Our implementation is single-threaded, but the operations performed are easily parallelisable.</p>

    <p class="text-gray-300">Our implementation accepts the circuit description format used by Pinocchio <em>[x12]</em>, which it preprocesses to remove addition and multiplication by constant gates, encoding them as a constraint tableas in Appendix A. Pinocchio</p>

    <p class="text-gray-300">also supports split gates, taking as input a single arithmetic wire and producing a fixed number of binary wires as outputs, so the binary wires correspond to the binary representation of the arithmetic wire. We handle split gates by adding appropriate multiplication gates and constraints to ensure binary wires can only carry zeroes or ones, and that their values scaled by the appropriate powers of 2 sum up to the gate's input.</p>

    <p class="text-gray-300">Performance Comparison. We compared the performance of our implementation to that of Pinocchio [PHGR13] for a set of circuits produced by Pinocchio's toolchain. The circuits implement multiplication of a vector by a fixed matrix, multiplication of two matrices, evaluation of a multivariate polynomial, and other applications for which we refer to [PHGR13]. We used an i5-4690K running Pinocchio under Windows 10 and our software under Ubuntu 14.04 for the tests.</p>

    <p class="text-gray-300">We note here that Pinocchio operates in a pairing-based setting, using knowledge of exponent assumptions, whereas we operate in the discrete log setting. Even so, we feel the comparison is meaningful, as we are not aware of previous implementations of circuit-evaluation arguments in our setting.</p>

    <p class="text-gray-300">From the comparison in Table 2, it is clear that our implementation is extremely competitive in terms of prover computation, with the square root version outperforming Pinocchio by a factor larger than 10 for some applications. There is a significant amount of variance in terms of the speedups achieved. The worst cases are those where the number of constraints is high in comparison with the number of multiplication gates: the calculation of  <span class="math">s(X)</span>  is performed entirely in Python and thus becomes the dominant term in the computation. We expect that in a fully compiled implementation, optimisation would prevent this issue.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pinocchio(Constant)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Square Root</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Logarithmic</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(Constant)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Application</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult. Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">Key Gen Size s</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Prove s</td>

            <td class="px-3 py-2 border-b border-gray-700">Size S</td>

            <td class="px-3 py-2 border-b border-gray-700">Size B</td>

            <td class="px-3 py-2 border-b border-gray-700">Key Gen Size s</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Prove s</td>

            <td class="px-3 py-2 border-b border-gray-700">Size B</td>

            <td class="px-3 py-2 border-b border-gray-700">Key Gen Size s</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Prove s</td>

            <td class="px-3 py-2 border-b border-gray-700">Size B</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Prove s</td>

            <td class="px-3 py-2 border-b border-gray-700">Size B</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Prove s</td>

            <td class="px-3 py-2 border-b border-gray-700">Size B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Vector Matrix</td>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700">1120</td>

            <td class="px-3 py-2 border-b border-gray-700">0.38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">6K</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03</td>

            <td class="px-3 py-2 border-b border-gray-700">3872</td>

            <td class="px-3 py-2 border-b border-gray-700">0.55</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

            <td class="px-3 py-2 border-b border-gray-700">3552</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3M</td>

            <td class="px-3 py-2 border-b border-gray-700">0.23</td>

            <td class="px-3 py-2 border-b border-gray-700">.023</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Product</td>

            <td class="px-3 py-2 border-b border-gray-700">1000</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10</td>

            <td class="px-3 py-2 border-b border-gray-700">1440</td>

            <td class="px-3 py-2 border-b border-gray-700">0.76</td>

            <td class="px-3 py-2 border-b border-gray-700">0.61</td>

            <td class="px-3 py-2 border-b border-gray-700">8K</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

            <td class="px-3 py-2 border-b border-gray-700">6464</td>

            <td class="px-3 py-2 border-b border-gray-700">1.05</td>

            <td class="px-3 py-2 border-b border-gray-700">0.67</td>

            <td class="px-3 py-2 border-b border-gray-700">3744</td>

            <td class="px-3 py-2 border-b border-gray-700">0.93</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5M</td>

            <td class="px-3 py-2 border-b border-gray-700">0.53</td>

            <td class="px-3 py-2 border-b border-gray-700">.035</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Matrix</td>

            <td class="px-3 py-2 border-b border-gray-700">347K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">19K</td>

            <td class="px-3 py-2 border-b border-gray-700">14.7</td>

            <td class="px-3 py-2 border-b border-gray-700">3.4</td>

            <td class="px-3 py-2 border-b border-gray-700">76K</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

            <td class="px-3 py-2 border-b border-gray-700">618K</td>

            <td class="px-3 py-2 border-b border-gray-700">49.9</td>

            <td class="px-3 py-2 border-b border-gray-700">22.9</td>

            <td class="px-3 py-2 border-b border-gray-700">5792</td>

            <td class="px-3 py-2 border-b border-gray-700">47.3</td>

            <td class="px-3 py-2 border-b border-gray-700">97.9M</td>

            <td class="px-3 py-2 border-b border-gray-700">167.4</td>

            <td class="px-3 py-2 border-b border-gray-700">.201</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Product</td>

            <td class="px-3 py-2 border-b border-gray-700">1343K</td>

            <td class="px-3 py-2 border-b border-gray-700">2.7</td>

            <td class="px-3 py-2 border-b border-gray-700">37K</td>

            <td class="px-3 py-2 border-b border-gray-700">60.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12.7</td>

            <td class="px-3 py-2 border-b border-gray-700">160K</td>

            <td class="px-3 py-2 border-b border-gray-700">18.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2M</td>

            <td class="px-3 py-2 border-b border-gray-700">187.0</td>

            <td class="px-3 py-2 border-b border-gray-700">81.7</td>

            <td class="px-3 py-2 border-b border-gray-700">6496</td>

            <td class="px-3 py-2 border-b border-gray-700">170.4</td>

            <td class="px-3 py-2 border-b border-gray-700">374.8M</td>

            <td class="px-3 py-2 border-b border-gray-700">706.8</td>

            <td class="px-3 py-2 border-b border-gray-700">.503</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Polynomial</td>

            <td class="px-3 py-2 border-b border-gray-700">203K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

            <td class="px-3 py-2 border-b border-gray-700">14K</td>

            <td class="px-3 py-2 border-b border-gray-700">30.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.1</td>

            <td class="px-3 py-2 border-b border-gray-700">88K</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

            <td class="px-3 py-2 border-b border-gray-700">383K</td>

            <td class="px-3 py-2 border-b border-gray-700">53.1</td>

            <td class="px-3 py-2 border-b border-gray-700">14.0</td>

            <td class="px-3 py-2 border-b border-gray-700">5440</td>

            <td class="px-3 py-2 border-b border-gray-700">24.4</td>

            <td class="px-3 py-2 border-b border-gray-700">55.9M</td>

            <td class="px-3 py-2 border-b border-gray-700">146.8</td>

            <td class="px-3 py-2 border-b border-gray-700">.007</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Evaluation</td>

            <td class="px-3 py-2 border-b border-gray-700">571K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7</td>

            <td class="px-3 py-2 border-b border-gray-700">24K</td>

            <td class="px-3 py-2 border-b border-gray-700">97.0</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6</td>

            <td class="px-3 py-2 border-b border-gray-700">160K</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3</td>

            <td class="px-3 py-2 border-b border-gray-700">962K</td>

            <td class="px-3 py-2 border-b border-gray-700">164.5</td>

            <td class="px-3 py-2 border-b border-gray-700">36.0</td>

            <td class="px-3 py-2 border-b border-gray-700">6272</td>

            <td class="px-3 py-2 border-b border-gray-700">60.2</td>

            <td class="px-3 py-2 border-b border-gray-700">156.8M</td>

            <td class="px-3 py-2 border-b border-gray-700">422.1</td>

            <td class="px-3 py-2 border-b border-gray-700">.007</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Image</td>

            <td class="px-3 py-2 border-b border-gray-700">86K</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7</td>

            <td class="px-3 py-2 border-b border-gray-700">9K</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

            <td class="px-3 py-2 border-b border-gray-700">44K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">171K</td>

            <td class="px-3 py-2 border-b border-gray-700">11.4</td>

            <td class="px-3 py-2 border-b border-gray-700">6.2</td>

            <td class="px-3 py-2 border-b border-gray-700">5120</td>

            <td class="px-3 py-2 border-b border-gray-700">15.2</td>

            <td class="px-3 py-2 border-b border-gray-700">23.6M</td>

            <td class="px-3 py-2 border-b border-gray-700">25.1</td>

            <td class="px-3 py-2 border-b border-gray-700">.007</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Matching</td>

            <td class="px-3 py-2 border-b border-gray-700">278K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">17K</td>

            <td class="px-3 py-2 border-b border-gray-700">7.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">72K</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2</td>

            <td class="px-3 py-2 border-b border-gray-700">490K</td>

            <td class="px-3 py-2 border-b border-gray-700">34.3</td>

            <td class="px-3 py-2 border-b border-gray-700">18.1</td>

            <td class="px-3 py-2 border-b border-gray-700">5920</td>

            <td class="px-3 py-2 border-b border-gray-700">38.9</td>

            <td class="px-3 py-2 border-b border-gray-700">75.8M</td>

            <td class="px-3 py-2 border-b border-gray-700">88.8</td>

            <td class="px-3 py-2 border-b border-gray-700">.007</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Shortest</td>

            <td class="px-3 py-2 border-b border-gray-700">366K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">19K</td>

            <td class="px-3 py-2 border-b border-gray-700">9.3</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7</td>

            <td class="px-3 py-2 border-b border-gray-700">52K</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6</td>

            <td class="px-3 py-2 border-b border-gray-700">644K</td>

            <td class="px-3 py-2 border-b border-gray-700">45.6</td>

            <td class="px-3 py-2 border-b border-gray-700">23.9</td>

            <td class="px-3 py-2 border-b border-gray-700">5792</td>

            <td class="px-3 py-2 border-b border-gray-700">50.4</td>

            <td class="px-3 py-2 border-b border-gray-700">99.6M</td>

            <td class="px-3 py-2 border-b border-gray-700">130.7</td>

            <td class="px-3 py-2 border-b border-gray-700">.015</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Paths</td>

            <td class="px-3 py-2 border-b border-gray-700">1400K</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6</td>

            <td class="px-3 py-2 border-b border-gray-700">38K</td>

            <td class="px-3 py-2 border-b border-gray-700">35.1</td>

            <td class="px-3 py-2 border-b border-gray-700">12.6</td>

            <td class="px-3 py-2 border-b border-gray-700">72K</td>

            <td class="px-3 py-2 border-b border-gray-700">19.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2M</td>

            <td class="px-3 py-2 border-b border-gray-700">169.8</td>

            <td class="px-3 py-2 border-b border-gray-700">84.0</td>

            <td class="px-3 py-2 border-b border-gray-700">6496</td>

            <td class="px-3 py-2 border-b border-gray-700">177.6</td>

            <td class="px-3 py-2 border-b border-gray-700">381.4M</td>

            <td class="px-3 py-2 border-b border-gray-700">523.3</td>

            <td class="px-3 py-2 border-b border-gray-700">.026</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Gas</td>

            <td class="px-3 py-2 border-b border-gray-700">144K</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12K</td>

            <td class="px-3 py-2 border-b border-gray-700">8.8</td>

            <td class="px-3 py-2 border-b border-gray-700">6.1</td>

            <td class="px-3 py-2 border-b border-gray-700">64K</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3</td>

            <td class="px-3 py-2 border-b border-gray-700">271K</td>

            <td class="px-3 py-2 border-b border-gray-700">23.7</td>

            <td class="px-3 py-2 border-b border-gray-700">13.9</td>

            <td class="px-3 py-2 border-b border-gray-700">5440</td>

            <td class="px-3 py-2 border-b border-gray-700">22.6</td>

            <td class="px-3 py-2 border-b border-gray-700">39.6M</td>

            <td class="px-3 py-2 border-b border-gray-700">47.6</td>

            <td class="px-3 py-2 border-b border-gray-700">.007</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Simulation</td>

            <td class="px-3 py-2 border-b border-gray-700">283K</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">17K</td>

            <td class="px-3 py-2 border-b border-gray-700">26.7</td>

            <td class="px-3 py-2 border-b border-gray-700">20.7</td>

            <td class="px-3 py-2 border-b border-gray-700">160K</td>

            <td class="px-3 py-2 border-b border-gray-700">4.3</td>

            <td class="px-3 py-2 border-b border-gray-700">503K</td>

            <td class="px-3 py-2 border-b border-gray-700">54.8</td>

            <td class="px-3 py-2 border-b border-gray-700">34.5</td>

            <td class="px-3 py-2 border-b border-gray-700">5920</td>

            <td class="px-3 py-2 border-b border-gray-700">45.9</td>

            <td class="px-3 py-2 border-b border-gray-700">77.7M</td>

            <td class="px-3 py-2 border-b border-gray-700">103.1</td>

            <td class="px-3 py-2 border-b border-gray-700">.007</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SHA-1</td>

            <td class="px-3 py-2 border-b border-gray-700">24K</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">5K</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

            <td class="px-3 py-2 border-b border-gray-700">24K</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">54K</td>

            <td class="px-3 py-2 border-b border-gray-700">6.5</td>

            <td class="px-3 py-2 border-b border-gray-700">4.3</td>

            <td class="px-3 py-2 border-b border-gray-700">4992</td>

            <td class="px-3 py-2 border-b border-gray-700">7.9</td>

            <td class="px-3 py-2 border-b border-gray-700">6.5M</td>

            <td class="px-3 py-2 border-b border-gray-700">9.0</td>

            <td class="px-3 py-2 border-b border-gray-700">.007</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Performance comparison between our implementation and Pinocchio. Pinocchio was set to use public verifiability and zero-knowledge.</p>

    <p class="text-gray-300">The logarithmic communication version is slower in comparison but still outperforms Pinocchio for most applications. The performance also becomes more even, as the constraints are irrelevant in the recursive part.</p>

    <p class="text-gray-300">Our verification times are much higher than Pinocchio’s, which can often verify circuit evaluation faster than native execution of an equivalent program. As with the prover, some speedups can be gained by moving to a compiled language, but we would still not expect to match Pinocchio’s performance; our verification cost would still be linear. Our proofs are considerably larger as well, especially for the square root version.</p>

    <p class="text-gray-300">Our key generation is simply a commitment key generation, and is not application-specific. Therefore, it can be easily amortised even across different circuits. For a circuit with <span class="math">N</span> multiplication gates, the size of our commitment key is <span class="math">\\sqrt{N}</span> elements for the square root version and <span class="math">\\frac{N}{\\log N}</span> for the log version. In comparison, Pinocchio’s key generation is bound to specific circuits and produces keys of size <span class="math">8N</span>. Thus, if the keys need to be communicated, our arguments are competitive in terms of total communication if the number of circuit evaluations is up to <span class="math">\\sqrt{N}</span> for the square root version, and up to <span class="math">\\frac{N}{\\log N}</span> for the log version.</p>

    <p class="text-gray-300">A Arithmetic Circuits</p>

    <p class="text-gray-300">Our satisfiability arguments consider arithmetic circuits described as a list of multiplication gates together with a set of linear consistency equations relating the inputs and outputs of the gates. In this section, we show how to reduce an arbitrary arithmetic circuit to this format.</p>

    <p class="text-gray-300">An arithmetic circuit over a field <span class="math">\\mathbb{Z}_{p}</span> and variables <span class="math">(a_{1},\\ldots,a_{m})</span> is a directed acyclic graph whose vertices are called gates. Gates of in-degree <span class="math">0</span> are inputs to the circuit and labelled with some <span class="math">a_{i}</span> or a constant field element. All other gates are labelled <span class="math">+</span> or <span class="math">\\times</span>. We may consider fan-in <span class="math">2</span> circuits, in which case all of the <span class="math">+</span> and <span class="math">\\times</span> gates have in-degree <span class="math">2</span>, or arbitrary fan-in circuits.</p>

    <p class="text-gray-300">Arithmetic circuits can be described alternatively as a list of multiplication gates with a collection of linear consistency equations relating the inputs and outputs of the gates. Our zero-knowledge protocols for circuit satisfiability use circuits in this form. Any circuit described as an acyclic graph can be efficiently converted into the alternative description.</p>

    <p class="text-gray-300">We show how to remove addition and multiplication-by-constant gates from an arithmetic circuit <span class="math">A</span>, and replace them with bilinear consistency equations on the inputs and outputs of the remaining gates, such that satisfiability of the equations is equivalent to satisfiability in the original circuit.</p>

    <p class="text-gray-300">Let <span class="math">B</span> be the sub-circuit of <span class="math">A</span> containing all wires and gates before a multiplication gate, with <span class="math">m</span> input wires and <span class="math">n</span> output wires. Label the <span class="math">m</span> inputs of <span class="math">B</span> with the unit vectors <span class="math">\\boldsymbol{e}_{i}=(0,\\ldots,1,\\ldots,0)</span> of length <span class="math">m</span>. For every addition gate with inputs labelled as <span class="math">\\boldsymbol{x},\\boldsymbol{y}</span>, label the output wire as <span class="math">\\boldsymbol{x}+\\boldsymbol{y}</span>. For every multiplication-by-constant gate with inputs <span class="math">\\boldsymbol{x}</span> and constant <span class="math">c</span> label the output with <span class="math">c\\boldsymbol{x}</span>. By proceeding inductively, the <span class="math">n</span> outputs of <span class="math">B</span> are now labelled with vectors of length <span class="math">m</span> representing them as linear combinations of the inputs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This requires at most $m\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> arithmetic operations. Note however that all outputs of </span>B<span class="math"> are linear combinations of the inputs, and that </span>B<span class="math"> can be written with </span>n(2m-1)<span class="math"> fan-in </span>2<span class="math"> gates in such a way that the consistency equations can be trivially read off from the circuit description. More specifically, a linear combination </span>\\sum_{i=1}^{m}a_{i}x_{i}<span class="math"> can be produced using </span>m<span class="math"> multiplication-by-constant gates and </span>m-1$ addition gates to add the answers together.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can now remove the gates of <span class="math">B</span> from <span class="math">A</span>. We also remove any multiplication gates whose inputs are the inputs of the new circuit. Now we simply repeat the process of finding consistency equations until we have considered the whole of <span class="math">A</span>. In Figure 1 there is an example of a circuit together and the corresponding consistency equations.</p>

    <p class="text-gray-300">The first (input) and final (output) sub-circuits require additional processing. We show how to do this for the output sub-circuit. The input sub-circuit is very similarly handled.</p>

    <p class="text-gray-300">Let <span class="math">B</span> be the output sub-circuit. Write <span class="math">(a_{1},\\ldots,a_{m})=\\boldsymbol{a}</span> for the input wires of <span class="math">B</span> and <span class="math">(b_{1},\\ldots,b_{n})=\\boldsymbol{b}</span> for the output wires. Without loss of generality, we may ignore variable output wires. By construction of <span class="math">B</span>, each output <span class="math">b_{i}</span> is of the form <span class="math">\\sum_{i=1}^{n}q_{ij}a_{j}+p_{i}</span>, with consistency equations obtained as above. We write</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. A simple arithmetic circuit, and the corresponding consistency equations. The first sub-circuit contains the wires  <span class="math">a_1, b_1, c_1, a_2, b_2, c_2, a_3, a_3, c_3</span> . The second sub-circuit contains the wires  <span class="math">c_1, a_4, c_2, b_4, c_4, c_5, c_6</span> . The third sub-circuit  <span class="math">B</span>  contains the wires  <span class="math">c_3, c_4, a_5, b_5, a_6</span> .</p>

    <p class="text-gray-300"><span class="math">c_{1} = a_{4}</span></p>

    <p class="text-gray-300"><span class="math">c_{2} = b_{4}</span></p>

    <p class="text-gray-300"><span class="math">c_{4} = a_{5}</span></p>

    <p class="text-gray-300"><span class="math">4c_{3} + c_{4} = b_{5}</span></p>

    <p class="text-gray-300"><span class="math">4c_{3} + c_{4} = a_{6}</span></p>

    <p class="text-gray-300"><span class="math">4c_{3} = b_{6}</span></p>

    <p class="text-gray-300">this in terms of an  <span class="math">m \\times n</span>  matrix  <span class="math">\\mathbb{Q}</span>  and a column vector  <span class="math">\\pmb{p}</span>  of size  <span class="math">m</span> , namely</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {b} = \\mathrm {Q} \\boldsymbol {a} + \\boldsymbol {p}.</span></div>

    <p class="text-gray-300">Let  <span class="math">r</span>  be the rank of  <span class="math">\\mathbb{Q}</span> . We convert  <span class="math">\\mathbb{Q}</span>  into reduced row echelon form  <span class="math">\\mathsf{R}</span> , writing</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {b} ^ {\\prime \\prime} = \\mathsf {R} \\boldsymbol {a}.</span></div>

    <p class="text-gray-300">By the properties of reduced row echelon form, after relabelling the  <span class="math">a_{i}</span>  and permuting the columns of  <span class="math">\\mathsf{R}</span>  to match, we have that  <span class="math">b_{i}^{\\prime \\prime} = a_{i} + \\sum_{j = l + 1}^{m}r_{ij}a_{j}</span>  for  <span class="math">1\\leq i\\leq l</span> . Therefore, we may consider  <span class="math">a_{l + 1},\\ldots ,a_{m}</span>  as free wires and express other  <span class="math">a_{i}</span>  as linear functions of these wires plus constants.</p>

    <p class="text-gray-300">Note that if  <span class="math">b_i&#x27;&#x27; \\neq 0</span>  for some  <span class="math">i &amp;gt; l</span> , the circuit can never be satisfied anyway. However, assuming that our statement is a satisfiable circuit, with a witness consisting of satisfying wire values, this never occurs. Then the original circuit is satisfied if and only if the  <span class="math">a_i</span>  values satisfy the consistency equations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  <span class="math">\\mathbb{Q}</span>  is an  <span class="math">m \\times n</span>  matrix then it can be converted into reduced row echelon form using  <span class="math">O(\\max(m, n)mn)</span>  operations. It is trivial that  $m \\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>n \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . This gives an upper bound of  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3)$  computation for the output sub-circuit. Note that this is often a large over-estimate; this upper bound occurs for circuits of depth 1 where inputs feed into distinct gates. For circuits of large depth, where the same input is fed into several gates, the upper bound will definitely not be reached.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The case of the input sub-circuit is very similar, except that we take the transpose of the matrix.</p>

    <p class="text-gray-300">BCC88. Gilles Brassard, David Chaum, and Claude Crépeau. Minimum disclosure proofs of knowledge. Journal of Computer and System Sciences, 37(2):156-189, 1988.</p>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300">BCCT12. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>Innovations in Theoretical Computer Science - ITCS 2012</em>, pages 326–349, 2012.</p>

    <p class="text-gray-300">BCCT13. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In <em>Symposium on Theory of Computing Conference - TCC 2013</em>, pages 111–120, 2013.</p>

    <p class="text-gray-300">BCG⁺¹³. Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: verifying program executions succinctly and in Zero Knowledge. In <em>Advances in Cryptology - CRYPTO 2013</em>, pages 90–108, 2013.</p>

    <p class="text-gray-300">BCTV14. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In <em>USENIX Security Symposium 2014</em>, pages 781–796, 2014.</p>

    <p class="text-gray-300">BG12. Stephanie Bayer and Jens Groth. Efficient zero-knowledge argument for correctness of a shuffle. In <em>Advances in Cryptology - EUROCRYPT 2012</em>, pages 263–280, 2012.</p>

    <p class="text-gray-300">BG13. Stephanie Bayer and Jens Groth. Zero-knowledge argument for polynomial evaluation with application to blacklists. In <em>Advances in Cryptology - EUROCRYPT 2013</em>, pages 646–663, 2013.</p>

    <p class="text-gray-300">BR93. Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In <em>ACM conference on Computer and communications security - CCS 1993</em>, pages 62–73, 1993.</p>

    <p class="text-gray-300">Can89. David G Cantor. On arithmetical algorithms over finite fields. <em>Journal of Combinatorial Theory, Series A</em>, 50(2):285–300, 1989.</p>

    <p class="text-gray-300">CD98. Ronald Cramer and Ivan Damgård. Zero-knowledge proofs for finite field arithmetic; or: Can zero-knowledge be for free? In <em>Advances in Cryptology - CRYPTO 1998</em>, pages 424–441, 1998.</p>

    <p class="text-gray-300">Dan15. George Danezis. petlib: A python library that implements a number of privacy enhancing technologies (PETs), 2015.</p>

    <p class="text-gray-300">GGI⁺¹⁴. Craig Gentry, Jens Groth, Yuval Ishai, Chris Peikert, Amit Sahai, and Adam Smith. Using fully homomorphic hybrid encryption to minimize non-interactive zero-knowledge proofs. <em>Journal of Cryptology</em>, pages 1–24, 2014.</p>

    <p class="text-gray-300">GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>Advances in Cryptology - EUROCRYPT 2013</em>, pages 626–645, 2013.</p>

    <p class="text-gray-300">GH98. Oded Goldreich and Johan Håstad. On the complexity of interactive proofs with bounded communication. <em>Information Processing Letters</em>, 67(4):205–214, 1998.</p>

    <p class="text-gray-300">GI08. Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In <em>Advances in Cryptology - EUROCRYPT 2008</em>, pages 379–396, 2008.</p>

    <p class="text-gray-300">GK14. Jens Groth and Markulf Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In <em>Advances in Cryptology - EUROCRYPT 2015</em>, page 764, 2014.</p>

    <p class="text-gray-300">GMR89. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proofs. <em>SIAM Journal on Computing</em>, 18(1):186–208, 1989.</p>

    <p class="text-gray-300">GMW91. Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. Journal of the ACM, 38(3):691–729, 1991.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[12] Juan a. Garay, Philip MacKenzie, and Ke Yang. Strengthening zero-knowledge protocols using signatures. Journal of Cryptology, 19(2):169–209, 2006.</li>

      <li>[13] Louis C. Guillou and Jean-Jacques Quisquater. A practical zero-knowledge protocol fitted to security microprocessor minimizing both trasmission and memory. In Advances in Cryptology – EUROCRYPT 1998, pages 123–128, 1988.</li>

      <li>[14] Jens Groth. Honest verifier zero-knowledge arguments applied. PhD thesis, University of Aarhus, 2004.</li>

      <li>[15] Jens Groth. Efficient zero-knowledge arguments from two-tiered homomorphic commitments. In Advances in Cryptology – ASIACRYPT 2009, pages 431–448, 2009.</li>

      <li>[16] Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In Advances in Cryptology – CRYPTO 2009, pages 192–208, 2009.</li>

      <li>[17] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Advances in Cryptology – ASIACRYPT 2010, pages 321–340, 2010.</li>

      <li>[18] GVW02. Oded Goldreich, Salil P. Vadhan, and Avi Wigderson. On interactive proofs with a laconic prover. Computational Complexity, 11(1-2):1–53, 2002.</li>

      <li>[19] Kil92. Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In Symposium on Theory of Computing Conference – TCC 1992, pages 723–732, 1992.</li>

      <li>[20] KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Advances in Cryptology – ASIACRYPT 2010, pages 177–194, 2010.</li>

      <li>[21] Lim00. Chae Hoon Lim. Efficient multi-exponentiation and application to batch verification of digital signatures, 2000. Manuscript available at http://dasan.sejong.ac.kr/<span class="math">\\sim</span>chlim/pub/multi_exp.ps.</li>

      <li>[22] Lin03. Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. Journal of Cryptology, 16(3):143–184, 2003.</li>

      <li>[23] Lip12. Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Theory of Cryptography Conference – TCC 2012, pages 169–189, 2012.</li>

      <li>[24] Möl01. Bodo Möller. Algorithms for multi-exponentiation. In Selected Areas in Cryptography – SAC 2001, pages 165–180. Springer, 2001.</li>

      <li>[25] MR08. Bodo Möller and Andy Rupp. Faster multi-exponentiation through caching: accelerating (EC) DSA signature verification. In Security and Cryptography for Networks – SCN 2008, pages 39–56. Springer, 2008.</li>

      <li>[26] Oli06. Travis E Oliphant. A guide to NumPy, volume 1. Trelgol Publishing USA, 2006.</li>

      <li>[27] PHGR13. Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE Symposium on Security and Privacy, pages 238–252, 2013.</li>

      <li>[28] Sch91. Claus-Peter Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4(3):161–174, 1991.</li>

      <li>[29] Seo11. Jae Hong Seo. Round-efficient sub-linear zero-knowledge arguments for linear algebra. In Public Key Cryptography – PKC 2011, pages 387–402, 2011.</li>

      <li>[30] Sho01. Victor Shoup. NTL: A library for doing number theory, 2001.</li>

    </ul>`;
---

<BaseLayout title="Efficient Zero-Knowledge Arguments for Arithmetic Circuits i... (2016/263)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/263
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
