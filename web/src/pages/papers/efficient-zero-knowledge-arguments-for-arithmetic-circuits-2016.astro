---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/263';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = '**Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting†∗**';
const AUTHORS_HTML = 'Jonathan Bootle&lt;sup&gt;1&lt;/sup&gt; , Andrea Cerulli&lt;sup&gt;1&lt;/sup&gt; , Pyrros Chaidos&lt;sup&gt;1&lt;/sup&gt;∗∗, Jens Groth&lt;sup&gt;1&lt;/sup&gt; , and Christophe Petit&lt;sup&gt;2&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Jonathan Bootle&lt;sup&gt;1&lt;/sup&gt; , Andrea Cerulli&lt;sup&gt;1&lt;/sup&gt; , Pyrros Chaidos&lt;sup&gt;1&lt;/sup&gt;∗∗, Jens Groth&lt;sup&gt;1&lt;/sup&gt; , and Christophe Petit&lt;sup&gt;2&lt;/sup&gt;</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; University College London {<strong>jonathan.bootle.14,andrea.cerulli.13,pyrros.chaidos.10,j.groth</strong>}<strong>@ucl.ac.uk</strong> &lt;sup&gt;2&lt;/sup&gt; University of Oxford <strong>christophe.petit@maths.ox.ac.uk</strong></p>

    <p class="text-gray-300"><strong>Abstract.</strong> We provide a zero-knowledge argument for arithmetic circuit satisfiability with a communication complexity that grows logarithmically in the size of the circuit. The round complexity is also logarithmic and for an arithmetic circuit with fan-in 2 gates the computation of the prover and verifier is linear in the size of the circuit. The soundness of our argument relies solely on the well-established discrete logarithm assumption in prime order groups.</p>

    <p class="text-gray-300">At the heart of our new argument system is an efficient zero-knowledge argument of knowledge of openings of two Pedersen multicommitments satisfying an inner product relation, which is of independent interest. The inner product argument requires logarithmic communication, logarithmic interaction and linear computation for both the prover and the verifier. We also develop a scheme to commit to a polynomial and later reveal the evaluation at an arbitrary point, in a verifiable manner. This is used to build an optimized version of the constant round square root complexity argument of Groth (CRYPTO 2009), which reduces both communication and round complexity.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> Sigma-protocol, zero-knowledge argument, arithmetic circuit, discrete logarithm assumption.</p>

    <p class="text-gray-300">Zero-knowledge proofs and arguments are ubiquitous in cryptography today, with prominent applications in authentication protocols, multi-party computation, encryption primitives, electronic voting systems and verifiable computation protocols.</p>

    <p class="text-gray-300">&lt;sup&gt;†&lt;/sup&gt; This is the full version of an article with the same title that was accepted for publication at Eurocrypt 2016.</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt; The research leading to these results has received funding from the European Research Council under the European Union's Seventh Framework Programme (FP/2007-2013) / ERC Grant Agreement n. 307937 and EPSRC grant EP/J009520/1.</p>

    <p class="text-gray-300">&lt;sup&gt;∗∗&lt;/sup&gt; Was supported by an EPSRC scholarship (EP/G037264/1 – Security Science DTC).</p>

    <p class="text-gray-300">Informally, a zero-knowledge argument involves two parties, the prover and the verifier, and allows the prover to prove to the verifier that a particular statement is true, without revealing anything else about the statement itself. Statements are of the form <em>u</em> ∈ <em>L</em>, where <em>L</em> is a language in NP. We call <em>w</em> a witness for a statement <em>u</em> if (<em>u, w</em>) ∈ <em>R</em>, where <em>R</em> is a polynomial time decidable binary relation associated with <em>L</em>. We require the zero-knowledge argument to be complete, sound and zero-knowledge.</p>

    <p class="text-gray-300"><strong>Completeness:</strong> A prover with a witness <em>w</em> for <em>u</em> ∈ <em>L</em> can convince the verifier of this fact.</p>

    <p class="text-gray-300"><strong>Soundness:</strong> A prover cannot convince a verifier when <em>u /</em>∈ <em>L</em>.</p>

    <p class="text-gray-300"><strong>Zero-knowledge:</strong> The interaction should not reveal anything to the verifier except that <em>u</em> ∈ <em>L</em>. In particular, it should not reveal the prover's witness <em>w</em>.</p>

    <p class="text-gray-300">Our goal is to build an efficient argument system for the satisfiability of an arithmetic circuit, i.e., a circuit that consists of addition and multiplication gates over a finite field Z<em>p</em>. Moreover we want to base the security of this argument solely on the discrete logarithm assumption: this will provide both strong security guarantees and good efficiency since there exists no known attacks better than generic ones for well-chosen elliptic curve subgroups.</p>

    <p class="text-gray-300">The most efficient zero-knowledge arguments solely based on the discrete logarithm assumption are Groth's protocol based on linear algebra <a href="#page-36-0">[Gro09b]</a> and its variant by Seo <a href="#page-36-1">[Seo11]</a>. Both of these protocols have a communication complexity that is proportional to the square root of the circuit size. This square root complexity has since then appeared as a (perhaps fundamental) barrier for discrete logarithm-based arguments for circuit satisfiability.</p>

    <h2 id="sec-1" class="text-2xl font-bold"><strong>1.1 Our Contributions</strong></h2>

    <p class="text-gray-300">We provide an honest verifier zero-knowledge argument for arithmetic circuit satisfiability based on the discrete logarithm assumption that only requires a <em>logarithmic</em> communication complexity. Our argument has perfect completeness and perfect special honest verifier zero-knowledge. Soundness is computational and based on the discrete logarithm assumption. We require a logarithmic number of moves, and both the prover and verifier have linear computational complexity. The argument is therefore efficient on all parameters with the biggest improvement being in the communication complexity.</p>

    <p class="text-gray-300"><em>Improved Square Root Complexity Argument.</em> We start from the circuit satisfiability argument of Groth <a href="#page-36-0">[Gro09b]</a>, which requires 7 moves and has square root communication complexity in the <em>total</em> number of gates. In this argument the prover commits to all the wires using homomorphic multicommitments, verifies addition gates using the homomorphic properties, and uses a product argument to show that the multiplication gates are satisfied.</p>

    <p class="text-gray-300">We first improve Groth's argument into a 5 moves argument with square root communication complexity in the number of <em>multiplication gates</em> only. We achieve fewer moves compared to <a href="#page-36-0">[Gro09b]</a> by avoiding generic reductions to linear algebra statements. We remove the communication cost of the addition gates in the argument by providing a technique that can directly handle a set of Hadamard products and linear relations together. Another efficiency improvement is a subroutine to commit to a polynomial and later reveal its evaluation at an arbitrary point in a verifiable manner. In Section <a href="#page-10-0">3</a> we provide a protocol to perform this task, which has a square root communication complexity with respect to the degree of the polynomial, and which may be of independent interest.</p>

    <p class="text-gray-300"><em>Logarithmic Complexity Argument.</em> In spite of all these improvements, the above argument still requires a square root communication complexity with respect to multiplication gates. In the first move the prover commits to all circuit wires using 3<em>m</em> commitments to <em>n</em> elements each, where <em>mn</em> = <em>N</em> is a bound on the number of multiplication gates, and in the last move after receiving a challenge he opens one commitment that can be constructed from the previous ones and the challenge. By setting <em>m</em> ≈ <em>n</em> we get a minimal communication complexity of <em>O</em>( √ <em>N</em>).</p>

    <p class="text-gray-300">Our key idea to break this square root communication complexity barrier is to replace the last opening step in this protocol by an argument of knowledge of the opening values. Using specific properties of Pedersen multicommitments, namely homomorphic properties with respect to the keys, we rewrite this argument as an argument of knowledge of openings of two homomorphic commitments, satisfying an inner product relation. In Section <a href="#page-16-0">4</a> we provide an argument system for this problem, which only requires a logarithmic communication with respect to the vector sizes. The argument is built in a recursive way, reducing the size and complexity of the statement further in each recursion step. Using this inner product argument as a subroutine we obtain an arithmetic circuit satisfiability argument with logarithmic communication.</p>

    <p class="text-gray-300"><em>Implementation.</em> In Section <a href="#page-30-0">6</a> we report on an implementation of our arguments. To show the practicality of our results we compare the efficiency of our implementation to that of Pinocchio <a href="#page-36-2">[PHGR13]</a>. Pinocchio is a practical verifiable computation scheme allowing a constrained client to outsource computation of a function to a powerful worker and to efficiently verify the outcome of the function. It uses quadratic arithmetic programs, a generalisation of arithmetic circuits, and for some functions achieves verification that is faster than local computation. While we do not achieve comparably fast verification, we compare favourably in terms of prover computation, and do so under simpler assumptions.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6"><strong>1.2 Related Work</strong></h4>

    <p class="text-gray-300">Zero-knowledge proofs were invented by Goldwasser et al. <a href="#page-35-0">[GMR89]</a>. It is useful to distinguish between zero-knowledge <em>proofs</em>, with statistical soundness, and zero-knowledge <em>arguments</em> with computational soundness. In general proofs can only have computational zero-knowledge, while arguments may have perfect zero-knowledge. Goldreich et al. <a href="#page-36-3">[GMW91]</a> showed that all languages in NP have zero-knowledge proofs while Brassard et al. <a href="#page-34-0">[BCC88]</a> showed that all languages in NP have zero-knowledge arguments with perfect zero-knowledge.</p>

    <p class="text-gray-300">Gentry et al. <a href="#page-35-1">[GGI</a>&lt;sup&gt;+&lt;/sup&gt;14] used fully homomorphic encryption to construct zeroknowledge proofs where the communication complexity corresponds to the size of the witness. However, proofs cannot in general have communication that is smaller than the witness size unless surprising results about the complexity of solving SAT instances hold <a href="#page-35-2">[GH98,</a> <a href="#page-36-4">GVW02]</a>.</p>

    <p class="text-gray-300">Kilian <a href="#page-36-5">[Kil92]</a> showed that in contrast to zero-knowledge proofs, zero-knowledge arguments can have very low communication complexity. His construction relied on the PCP theorem though, and did not yield a practical scheme.</p>

    <p class="text-gray-300">Schnorr <a href="#page-36-6">[Sch91]</a> and Guillou and Quisquater <a href="#page-36-7">[GQ88]</a> gave early examples of practical zero-knowledge arguments for concrete number theoretic problems. Extending Schnorr's protocols, there have been many constructions of zeroknowledge arguments based on the discrete logarithm assumption. Cramer and Damg˚ard <a href="#page-35-3">[CD98]</a> gave a zero-knowledge argument for arithmetic circuit satisfiability, which has linear communication complexity.</p>

    <p class="text-gray-300">Currently the most efficient discrete logarithm based zero-knowledge arguments for arithmetic circuits are the ones by Groth <a href="#page-36-0">[Gro09b]</a> and Seo <a href="#page-36-1">[Seo11]</a>, which are constant move arguments with a communication proportional to the square root of the circuit size. Using pairing-based cryptography instead of just relying on the discrete logarithm assumption, Groth <a href="#page-36-8">[Gro09a]</a> extended these techniques to give a zero-knowledge argument with a cubic root communication complexity.</p>

    <p class="text-gray-300">There are recent works giving a logarithmic communication complexity for specific languages. Bayer and Groth <a href="#page-35-4">[BG13]</a> show that one can prove that a polynomial evaluated at a secret committed value gives a certain output with a logarithmic communication complexity and Groth and Kohlweiss <a href="#page-35-5">[GK14]</a> show that one can prove that one out of <em>N</em> commitments contain 0 with logarithmic communication complexity. These results are for very specific types of statements (with low circuit depth) and the techniques do not seem to generalize to arbitrary NP languages.</p>

    <p class="text-gray-300">An exciting line of research <a href="#page-36-9">[Gro10,</a> <a href="#page-36-10">Lip12,</a> <a href="#page-35-6">BCCT12,</a> <a href="#page-35-7">GGPR13,</a> <a href="#page-35-8">BCCT13,</a> <a href="#page-36-2">PHGR13,</a> <a href="#page-35-9">BCG</a>&lt;sup&gt;+&lt;/sup&gt;13, <a href="#page-35-10">BCTV14,</a> <a href="#page-35-5">GK14]</a> has developed many proposals for succinct non-interactive arguments (SNARGs) yielding pairing-based constructions where the arguments consist of a constant number of group elements. However, they all rely on a common reference string (with a special structure) and non-falsifiable knowledge extractor assumptions. In contrast, the arguments we develop here are based solely on the discrete logarithm assumption, and use a small common reference string which is independent of the circuit.</p>

    <p class="text-gray-300">Table <a href="#page-4-0">1</a> compares the most efficient previous zero-knowledge arguments based on the discrete logarithm assumption with our scheme, when allowing for 5 moves or a logarithmic number of moves. Using 5 moves, our scheme requires significantly less computation than <a href="#page-36-1">[Seo11]</a>. On the other hand when using a logarithmic number of moves and applying a reduction similar to <a href="#page-35-11">[BG12]</a>, our scheme dramatically improves the communication costs with respect to all previous work without incurring any significant overhead. We note that [BG12] uses the reduction to reduce computation whereas we use it to reduce communication.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Moves</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Commu</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">nication</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prove</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">er Complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verifier</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{Z}_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exp.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">mult.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exp.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">mult.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CD98]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5N + 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Gro09b]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">9\\sqrt{N}+4</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">7\\sqrt{N} + 6</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{6N}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(N\\log N\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{39\\sqrt{N}}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(N)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Gro09b]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\log N + 5</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\sqrt{N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">7\\sqrt{N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{6N}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(N)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{18\\sqrt{N}}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(N\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Seo11]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">30\\sqrt{N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">7\\sqrt{N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{6N}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(N\\log N\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{77\\sqrt{N}}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O\\left(N\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\sqrt{N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\sqrt{N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{6N}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3N\\log N</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{8\\sqrt{3N}}{\\log N}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(N)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\log N + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">4\\log N + 7</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\log N + 6</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(N)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(N)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;<strong>Table 1.</strong> Efficiency comparison between our arguments and the most efficient interactive zero-knowledge arguments relying on discrete logarithm. We express communication in number of group elements  <span class="math">\\mathbb{G}</span>  and field elements  <span class="math">\\mathbb{Z}_p</span>  and computation costs in number of exponentiations over  <span class="math">\\mathbb{G}</span>  and multiplications over  <span class="math">\\mathbb{Z}_p</span> . The efficiency displayed is for a circuit with N multiplication gates.</p>

    <p class="text-gray-300">As part of our construction we give a protocol for committing to a polynomial and later revealing an evaluation of the polynomial in a given point. Kate et al. [KZG10] have also provided protocols to commit to polynomials and then evaluate them at a given point in a verifiable way. Their protocols only require a constant number of commitments but security relies on pairing assumptions. Our polynomial commitment protocol has square root communication complexity but relies solely on the discrete logarithm assumption.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2 Preliminaries</h4>

    <p class="text-gray-300">We write y = A(x; r) when the algorithm A on input x and randomness r, outputs y. We write  <span class="math">y \\leftarrow A(x)</span>  for the process of picking randomness r at random and setting y = A(x; r). We also write  <span class="math">y \\leftarrow S</span>  for sampling y uniformly at random from the set S. We will assume one can sample uniformly at random from sets such as  <span class="math">\\mathbb{Z}_p</span>  and  <span class="math">\\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">Algorithms in our schemes receive a security parameter  <span class="math">\\lambda</span>  as input (sometimes implicitly) written in unary. The intuition is that the higher the security parameter, the lower the risk of the scheme being broken. Given two functions  <span class="math">f, g: \\mathbb{N} \\to [0,1]</span>  we write  <span class="math">f(\\lambda) \\approx g(\\lambda)</span>  when  <span class="math">|f(\\lambda) - g(\\lambda)| = \\lambda^{-\\omega(1)}</span> . We say that f is negligible when  <span class="math">f(\\lambda) \\approx 0</span>  and that f is overwhelming when  <span class="math">f(\\lambda) \\approx 1</span> .</p>

    <p class="text-gray-300">Throughout the paper we let  <span class="math">\\mathbb{G}</span>  be a group of prime order p. Let  <span class="math">g = (g_1, \\ldots, g_n) \\in \\mathbb{G}^n</span>  and  <span class="math">f = (f_1, \\ldots, f_n) \\in \\mathbb{Z}_p^n</span> . We write  <span class="math">g^f</span>  for the multi-exponentiation  <span class="math">g^f = \\prod_{i=1}^n g_i^{f_i}</span> . A multi-exponentiation of size n can be computed at a cost of roughly  <span class="math">\\frac{n}{\\log n}</span>  single group exponentiations using the multi-exponentiation techniques of [Lim00, Möl01, MR08].</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 The Discrete Logarithm Assumption</h4>

    <p class="text-gray-300">Let GGen be an algorithm that on input  <span class="math">1^{\\lambda}</span>  returns  <span class="math">(\\mathbb{G}, p, g)</span>  such that  <span class="math">\\mathbb{G}</span>  is the description of a finite cyclic group of prime order p, where  <span class="math">|p| = \\lambda</span> , and g is a generator of  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300"><strong>Definition 1 (Discrete Logarithm Assumption).</strong> The discrete logarithm assumption holds relative to GGen if for all non-uniform polynomial time adversaries A</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(\\mathbb{G},p,g)\\leftarrow \\mathrm{GGen}(1^{\\lambda}); h\\leftarrow \\mathbb{G}; a\\leftarrow \\mathcal{A}(\\mathbb{G},p,g,h): g^a=h\\right]\\approx 0</span>$</p>

    <p class="text-gray-300">In this definition, the value a is called the discrete logarithm of h in the basis g. Note that the discrete logarithm assumption is defined with respect to a particular group generator algorithm GGen. According to current state-of-the-art cryptanalytic techniques, to get a security level of  <span class="math">2^{-\\lambda}</span>  the group generator may for example return well-chosen elliptic curve groups where group elements can be represented with  <span class="math">O(\\lambda)</span>  bits or multiplicative subgroups of finite fields with a large characteristic where group elements can be represented with  <span class="math">O(\\lambda)</span>  bits. It is well-known that the discrete logarithm assumption is equivalent to the following assumption.</p>

    <p class="text-gray-300"><strong>Definition 2 (Discrete Logarithm Relation Assumption).</strong> For all  <span class="math">n \\geq 1</span>  and all non-uniform polynomial time adversaries A</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[ (\\mathbb{G}, p, g) \\leftarrow \\operatorname{GGen}(1^{\\lambda}); g_1, \\dots, g_n \\leftarrow \\mathbb{G}; : \\exists a_i \\neq 0 \\text{ and } g^{a_0} \\prod_{i=1}^n g_i^{a_i} = 1 \\right] \\approx 0</span>$</p>

    <p class="text-gray-300">We call such a product  <span class="math">g^{a_0} \\prod_{i=1}^n g_i^{a_i} = 1</span>  a non-trivial discrete logarithm relation.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.2 Pedersen Commitments</h4>

    <p class="text-gray-300">A non-interactive commitment scheme allows a sender to create a commitment to a secret value. She may later open the commitment and reveal the value in a verifiable manner. A commitment should be hiding, i.e., not reveal the secret value, and binding in the sense that a commitment cannot be opened to two different values.</p>

    <p class="text-gray-300">Formally, a non-interactive commitment scheme is a pair of probabilistic polynomial time algorithms (CGen, Com). The setup algorithm  <span class="math">ck \\leftarrow \\text{CGen}(1^{\\lambda})</span>  generates a commitment key ck. The commitment key specifies a message space  <span class="math">\\mathcal{M}_{ck}</span> , a randomness space  <span class="math">\\mathcal{R}_{ck}</span>  and a commitment space  <span class="math">\\mathcal{C}_{ck}</span> . The commitment algorithm combined with the commitment key specifies a function  <span class="math">\\text{Com}_{ck}</span> :  <span class="math">\\mathcal{M}_{ck} \\times \\mathcal{R}_{ck} \\to \\mathcal{C}_{ck}</span> . Given a message  <span class="math">m \\in \\mathcal{M}_{ck}</span>  the sender picks uniformly at random  <span class="math">r \\leftarrow \\mathcal{R}_{ck}</span>  and computes the commitment  <span class="math">c = \\text{Com}_{ck}(m; r)</span> .</p>

    <p class="text-gray-300"><strong>Definition 3 (Perfectly hiding).</strong> We say a non-interactive commitment scheme (CGen, Com) is perfectly hiding if a commitment does not reveal the committed</p>

    <p class="text-gray-300">value. For all non-uniform polynomial time stateful interactive adversaries A</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{l} ck \\leftarrow \\mathrm{CGen}(1^{\\lambda}); (m_0, m_1) \\leftarrow \\mathcal{A}(ck); \\\\ b \\leftarrow \\{0, 1\\}; c \\leftarrow \\mathrm{Com}_{ck}(m_b) \\end{array} \\right] = \\frac{1}{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">m_0, m_1 \\in \\mathcal{M}_{ck}</span></p>

    <p class="text-gray-300"><strong>Definition 4 (Binding).</strong> A non-interactive commitment scheme (CGen, Com) is computationally binding if a commitment can only be opened to one value. For all non-uniform polynomial time adversaries A</p>

    <p class="text-gray-300"><span class="math">$\\Pr \\begin{bmatrix} ck \\leftarrow \\operatorname{CGen}(1^{\\lambda}); \\\\ (m_0, r_0, m_1, r_1) \\leftarrow \\mathcal{A}(ck) \\end{bmatrix} : \\frac{\\operatorname{Com}_{ck}(m_0; r_0) = \\operatorname{Com}_{ck}(m_1; r_1)}{\\operatorname{and} \\ m_0 \\neq m_1} \\right] \\approx 0</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">m_0, m_1 \\in \\mathcal{M}_{ck}</span>  and  <span class="math">r_0, r_1 \\in \\mathcal{R}_{ck}</span></p>

    <p class="text-gray-300">We say a commitment scheme is homomorphic if for all valid keys ck the message, randomness and commitment spaces are abelian groups and for all messages  <span class="math">m_0, m_1 \\in \\mathcal{M}_{ck}</span>  and randomness  <span class="math">r_0, r_1 \\in \\mathcal{R}_{ck}</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Com}_{ck}(m_0; r_0) \\cdot \\operatorname{Com}_{ck}(m_1; r_1) = \\operatorname{Com}_{ck}(m_0 + m_1; r_0 + r_1).</span>$</p>

    <p class="text-gray-300">The most prominent example of a homomorphic perfectly hiding commitment scheme is the Pedersen commitment scheme. Pedersen commitments have the form  <span class="math">c = g^r h^m</span>  where g, h are group elements specified in the commitment key. The opening of a Pedersen commitment is  <span class="math">(m,r) \\in \\mathbb{Z}_p^2</span> , from which anybody can recompute the commitment c and verify it was a valid commitment. Since Pedersen commitments are random group elements, they are perfectly hiding. On the other hand, breaking the binding property of Pedersen commitments corresponds to breaking the discrete logarithm assumption.</p>

    <p class="text-gray-300">We will be using a variant of Pedersen commitments that allow us to commit to multiple values at once. The commitment key is  <span class="math">ck = (\\mathbb{G}, p, g, g_1, \\dots, g_n)</span>  and a commitment is of the form  <span class="math">c = g^r \\prod_{i=1}^n g_i^{m_i}</span> . We write  <span class="math">c = \\text{Com}_{ck}(m_1, \\dots, m_n; r)</span>  for this operation.</p>

    <p class="text-gray-300">With the Pedersen commitment scheme in mind, we will assume throughout the paper that the message space is  <span class="math">\\mathbb{Z}_p^n</span>  and the randomness space is  <span class="math">\\mathbb{Z}_p</span> . The constructions we have in Sections 3 and 5.1 require a perfectly hiding, homomorphic commitment scheme so we are not limited to using the Pedersen commitment scheme. However, in Sections 4 and 5.2, we will rely on specific properties of the Pedersen scheme and work directly on the group elements in the key.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">2.3 Zero-knowledge Arguments of Knowledge</h4>

    <p class="text-gray-300">Let R be a polynomial time decidable binary relation, i.e., a relation that defines a language in NP. We call w a witness for a statement u if  <span class="math">(u, w) \\in R</span> .</p>

    <p class="text-gray-300">In the arguments we consider a prover  <span class="math">\\mathcal{P}</span>  and a verifier  <span class="math">\\mathcal{V}</span> , both of which are probabilistic polynomial time interactive algorithms. The transcript produced by  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  when interacting on inputs s and t is denoted by  <span class="math">tr \\leftarrow \\langle \\mathcal{P}(s), \\mathcal{V}(t) \\rangle</span> . We write  <span class="math">\\langle \\mathcal{P}(s), \\mathcal{V}(t) \\rangle = b</span>  depending on whether the verifier rejects, b = 0, or accepts, b = 1.</p>

    <p class="text-gray-300"><strong>Definition 5 (Argument of knowledge).</strong> <em>The pair</em> (P<em>,</em> V) <em>is called an</em> argument of knowledge <em>for the relation R if we have perfect completeness and statistical witness-extended emulation as defined below.</em></p>

    <p class="text-gray-300"><strong>Definition 6 (Perfect completeness).</strong> (P<em>,</em> V) <em>has perfect completeness if for all non-uniform polynomial time adversaries</em> A</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(u, w) \\leftarrow \\mathcal{A}(1^{\\lambda}) : (u, w) \\notin R \\text{ or } \\langle \\mathcal{P}(u, w), \\mathcal{V}(u) \\rangle = 1\\right] = 1</span>$</p>

    <p class="text-gray-300">To define an argument of knowledge we follow Groth and Ishai <a href="#page-35-12">[GI08]</a> that borrowed the term witness-extended emulation from Lindell <a href="#page-36-15">[Lin03]</a>. Informally, their definition says that given an adversary that produces an acceptable argument with some probability, there exists an emulator that produces a similar argument with the same probability together with a witness <em>w</em>. Note that the emulator is allowed to rewind the prover and verifier's interaction to any previous move.</p>

    <p class="text-gray-300"><strong>Definition 7 (Statistical witness-extended emulation).</strong> (P<em>,</em> V) <em>has</em> statistical witness-extended emulation <em>if for all deterministic polynomial time</em> P ∗ <em>there exists an expected polynomial time emulator</em> E <em>such that for all interactive adversaries</em> A</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\text{Pr}\\left[(u,s) \\leftarrow \\mathcal{A}(1^{\\lambda}); tr \\leftarrow \\langle \\mathcal{P}^*(u,s), \\mathcal{V}(u) \\rangle : \\mathcal{A}(tr) = 1\\right] \\\\ &amp; \\approx &amp; \\text{Pr}\\left[\\frac{(u,s) \\leftarrow \\mathcal{A}(1^{\\lambda}); (tr,w) \\leftarrow \\mathcal{E}^{\\langle \\mathcal{P}^*(u,s), \\mathcal{V}(u) \\rangle}(u) :}{\\mathcal{A}(tr) = 1 \\text{ and if } tr \\text{ is accepting then } (u,w) \\in R\\right] \\end{split}</span>$</p>

    <p class="text-gray-300"><em>where the oracle called by</em> E hP&lt;sup&gt;∗&lt;/sup&gt; (<em>u,s</em>)<em>,</em>V(<em>u</em>)&lt;sup&gt;i&lt;/sup&gt; <em>permits rewinding to a specific point and resuming with fresh randomness for the verifier from this point onwards.</em></p>

    <p class="text-gray-300">In the definition, <em>s</em> can be interpreted as the state of P ∗ , including the randomness. So, whenever P ∗ is able to make a convincing argument when in state <em>s</em>, E can extract a witness. This is why we call it an argument of knowledge.</p>

    <p class="text-gray-300"><strong>Definition 8 (Public coin).</strong> <em>An argument</em> (P<em>,</em> V) <em>is called</em> public coin <em>if the verifier chooses his messages uniformly at random and independently of the messages sent by the prover, i.e., the challenges correspond to the verifier's randomness ρ.</em></p>

    <p class="text-gray-300">An argument is zero-knowledge if it does not leak information about the witness beyond what can be inferred from the truth of the statement. We will present arguments that have special honest verifier zero-knowledge in the sense that if the verifier's challenges are known in advance, then it is possible to simulate the entire argument without knowing the witness.</p>

    <p class="text-gray-300"><strong>Definition 9 (Perfect special honest verifier zero-knowledge).</strong> <em>A public coin argument</em> (P<em>,</em> V) <em>is called a</em> perfect special honest verifier zero knowledge (SHVZK) argument for R if there exists a probabilistic polynomial time simulator S such that for all interactive non-uniform polynomial time adversaries A</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(u, w, \\rho) \\leftarrow \\mathcal{A}(1^{\\lambda}); tr \\leftarrow \\langle \\mathcal{P}(u, w), \\mathcal{V}(u; \\rho) \\rangle : (u, w) \\in R \\text{ and } \\mathcal{A}(tr) = 1\\right]</span>$
<span class="math">$= \\Pr\\left[(u, w, \\rho) \\leftarrow \\mathcal{A}(1^{\\lambda}); tr \\leftarrow \\mathcal{S}(u, \\rho) : (u, w) \\in R \\text{ and } \\mathcal{A}(tr) = 1\\right]</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\rho</span>  is the public coin randomness used by the verifier.</p>

    <p class="text-gray-300"><strong>Full zero-knowledge.</strong> In real life applications special honest verifier zero-knowledge may not suffice since a malicious verifier may give non-random challenges. However, it is easy to convert an SHVZK argument into a full zero-knowledge argument secure against <em>arbitrary</em> verifiers in the common reference string model using standard techniques [Gro04, GMY06]. The conversion can be very efficient and only costs a small additive overhead.</p>

    <p class="text-gray-300">The Fiat-Shamir heuristic. The Fiat-Shamir transformation takes an interactive public coin argument and replaces the challenges with the output of a cryptographic hash function. The idea is that the hash function will produce random looking output and therefore be a suitable replacement for the verifier. The Fiat-Shamir heuristic yields a non-interactive zero-knowledge argument in the random oracle model [BR93].</p>

    <p class="text-gray-300">The transformation can be applied to our arguments to make them non-interactive at the cost of using the random oracle model in the security proofs. From an efficiency point of view this is especially useful for the arguments in Sections 4 and 5.2, reducing a logarithmic number of moves to a single one.</p>

    <p class="text-gray-300">A general forking lemma. Suppose that we have a  <span class="math">(2\\mu+1)</span> -move public-coin argument with  <span class="math">\\mu</span>  challenges,  <span class="math">x_1, \\ldots, x_{\\mu}</span>  in sequence. Let  <span class="math">n_i \\geq 1</span>  for  <span class="math">1 \\leq i \\leq \\mu</span> . Consider  <span class="math">\\prod_{i=1}^{\\mu} n_i</span>  accepting transcripts with challenges in the following tree format. The tree has depth  <span class="math">\\mu</span>  and  <span class="math">\\prod_{i=1}^{\\mu} n_i</span>  leaves. The root of the tree is labelled with the statement. Each node of depth  <span class="math">i &lt; \\mu</span>  has exactly  <span class="math">n_i</span>  children, each labelled with a distinct value for the ith challenge  <span class="math">x_i</span> .</p>

    <p class="text-gray-300">This can be referred to as an  <span class="math">(n_1,\\ldots,n_\\mu)</span> -tree of accepting transcripts. All of our arguments allow a witness to be extracted efficiently from an appropriate tree of accepting transcripts. This is a natural generalisation of special-soundness for Sigma-protocols, where  <span class="math">\\mu=1</span>  and n=2. For simplicity in the following lemma, we assume that the challenges are chosen uniformly from  <span class="math">\\mathbb{Z}_p</span>  where  <span class="math">|p|=\\lambda</span> , but any sufficiently large challenge space would suffice.</p>

    <p class="text-gray-300"><strong>Lemma 1 (Forking Lemma).</strong> Let  <span class="math">(\\mathcal{P}, \\mathcal{V})</span>  be a  <span class="math">(2\\mu+1)</span> -move, public coin interactive protocol. Let  <span class="math">\\chi</span>  be a witness extraction algorithm that always succeeds in extracting a witness from an  <span class="math">(n_1, \\ldots, n_{\\mu})</span> -tree of accepting transcripts in probabilistic polynomial time. Assume that  <span class="math">\\prod_{i=1}^{\\mu} n_i</span>  is bounded above by a polynomial in the security parameter  <span class="math">\\lambda</span> . Then  <span class="math">(\\mathcal{P}, \\mathcal{V})</span>  has witness-extended emulation.</p>

    <p class="text-gray-300">For simplicity in the following proof, we assume challenges are chosen uniformly from  <span class="math">\\mathbb{Z}_p</span>  where  <span class="math">|p| = \\lambda</span> , but any sufficiently large challenge space would suffice.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that for deterministic polynomial time  <span class="math">\\mathcal{P}^*</span>  there is a non-uniform polynomial time interactive adversary  <span class="math">\\mathcal{A}</span>  in the sense of witness-extended emulation, such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(u,s) \\leftarrow \\mathcal{A}(1^{\\lambda}); tr \\leftarrow \\langle \\mathcal{P}^*(u,s), \\mathcal{V}(u) \\rangle : \\mathcal{A}(tr) = 1\\right] = \\epsilon.</span>$</p>

    <p class="text-gray-300">Note that if  <span class="math">\\epsilon</span>  is negligible, then we do not need to extract a witness, since the emulator can simply fail every time and trivially achieve witness-extended emulation. Therefore, from now on, we assume that  <span class="math">\\epsilon</span>  is not negligible.</p>

    <p class="text-gray-300">We construct an expected polynomial time emulator  <span class="math">\\mathcal{E}</span> , which has access to a rewindable transcript oracle  <span class="math">\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle</span>  and produces a witness. This is done via recursive calls to tree-finders  <span class="math">\\mathcal{T}</span>  that deal with the protocol after the first few challenges are already fixed. The <em>i</em>th tree-finder takes the previous challenges and partial transcript given to it as input, picks random values for  <span class="math">x_{i+1}</span> , runs the prover on these values and hands the result to the next tree-finder. Each tree-finder may fail on the first value of  <span class="math">x_{i+1}</span> , ensuring that the whole process runs in expected polynomial time. With overwhelming probability, the emulator obtains an  <span class="math">(n_1, \\ldots, n_{\\mu})</span> -tree of transcripts and is then able to extract a witness, using the efficient algorithm  <span class="math">\\chi</span>  that exists by assumption.</p>

    <pre><code class="language-text"> \\begin{array}{l} \\mathcal{E}^{\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle}(u) \\to (tr, w) \\colon \\\\ - \\operatorname{Run} \\, \\mathcal{T}^{\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle}(1) \\to (tr, \\mathsf{tree}) \\end{array}
        - If tree = \\perp then return (tr, \\perp).
        - If tree is not a valid (n_1, \\ldots, n_n)-tree of transcripts (i.e. there are collisions
             in certain challenges) then return (tr, \\perp).
        - Else run w \\leftarrow \\chi(u, \\mathsf{tree}).
        - Return (tr, w)
For 1 \\le i \\le \\mu + 1: \\mathcal{T}^{\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle}(i) \\to (tr, \\mathsf{tree}):
        - \\text{ If } i = \\mu + 1
            - Obtain a complete protocol transcript from tr \\leftarrow \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle
            - Run \\mathcal{V}(tr) \\to b
            - If b = 0 then return (tr, \\perp).
            - If b = 1 then set tree = \\{tr\\} and return (tr, tree).
        - Run \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle up to and including move 2i+1.
- Run \\mathcal{T}^{\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle}(i+1) \\to (tr, \\mathsf{tree})
        - If tree = \\perp then return (tr, \\perp).
        - Set counter = 1
        - While counter &lt; n_i:
             - Rewind \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle back until just before move 2i.
            - Run \\mathcal{T}^{\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle}(i+1) \\to (tr&#x27;, \\mathsf{tree}&#x27;)
             - If tree&#x27; \\neq \\perp, append the tree&#x27; transcripts to tree, and increment counter.
        - Return (tr, tree)
</code></pre>

    <p class="text-gray-300">Fix  <span class="math">1 \\le i \\le \\mu</span> , and fix  <span class="math">x_1, \\ldots, x_{i-1}</span> . We say that  <span class="math">\\mathcal{T}(i)</span>  has failed if it returns  <span class="math">(tr, \\perp)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\epsilon&#x27;</span>  be the probability that the  <span class="math">\\mathcal{T}(i)</span>  fails for this choice of challenges, and let  <span class="math">\\epsilon&#x27;(x_i)</span>  be the probability that  <span class="math">\\mathcal{T}(i+1)</span>  fails for this choice of challenges continued with  <span class="math">x_i</span> . The <em>i</em>th tree-finder can fail only if the (i+1)th tree-finder fails the first time it is called. This implies that for uniformly random  <span class="math">x_i</span> , the probability that  <span class="math">\\mathcal{T}(i+1)</span>  fails is  <span class="math">\\epsilon&#x27; = \\sum_{x_i \\in \\mathbb{Z}_p} \\Pr[X = x_i] \\epsilon&#x27;(x_i)</span> .</p>

    <p class="text-gray-300">Therefore, the expected number of times that  <span class="math">\\mathcal{T}(i)</span>  runs  <span class="math">\\mathcal{T}(i+1)</span>  is  <span class="math">1+\\epsilon&#x27;\\frac{(n_i-1)}{\\epsilon&#x27;}=n_i</span> . The final tree-finder  <span class="math">\\mathcal{T}(k+1)</span>  merely checks whether the transcript is accepting or not. Hence, the total expected running time for  <span class="math">\\mathcal{T}(1)</span>  to be  <span class="math">\\prod_{i=1}^{\\mu} n_i</span>  multiplied by the time taken to check whether a transcript is accepting. We conclude that the emulator  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time.</p>

    <p class="text-gray-300">The first tree-finder  <span class="math">\\mathcal{T}(1)</span>  only outputs  <span class="math">(tr, \\perp)</span>  if the very first set of challenges generated by all of the emulators fails to produce an accepting transcript. This is exactly the probability that  <span class="math">\\mathcal{P}^*</span>  successfully produces an accepting transcript in one run.</p>

    <p class="text-gray-300">Given that we receive  <span class="math">\\prod_{i=1}^{\\mu} n_i</span>  accepting transcripts in tree, we now consider the probability that they do not form an  <span class="math">(n_1, \\ldots, n_{\\mu})</span> -tree. This occurs only when the  <span class="math">n_i</span>  values of challenge  <span class="math">x_i</span>  used by  <span class="math">\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle</span>  while in the loop controlled by counter are not distinct, or in other words, there is a collision between these values, for some i.</p>

    <p class="text-gray-300">By Markov's inequality, an algorithm whose expected running time is t will only run for longer than time T &gt; t with probability  <span class="math">\\frac{t}{T}</span> . Let t be the expected running time of  <span class="math">\\mathcal{E}</span> , which is bounded above by a polynomial in the security parameter. For easier analysis, we limit the actual running time of  <span class="math">\\mathcal{E}</span>  to T, whose value will be chosen later.</p>

    <p class="text-gray-300">When  <span class="math">\\mathcal{E}</span>  runs in time at most T, then at most T uniformly random public coin challenges were selected by  <span class="math">\\mathcal{V}</span>  in  <span class="math">\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle</span> . If there are no collisions between any of the public coins chosen, then there are certainly no collisions of the type which would prevent tree from being a  <span class="math">(n_1, \\ldots, n_{\\mu})</span> -tree of transcripts. The probability that there is a collision between T values sampled uniformly from  <span class="math">\\mathbb{Z}_p</span>  is at most  <span class="math">\\frac{T^2}{n}</span> .</p>

    <p class="text-gray-300">Now, we choose  <span class="math">T = \\sqrt[3]{p}</span> . The probability that tree fails to be an  <span class="math">(n_1, \\ldots, n_{\\mu})</span> -tree is at most  <span class="math">\\frac{t}{T} + \\frac{T^2}{p}</span>  which is now equal to  <span class="math">\\frac{t}{\\sqrt[3]{p}} + \\frac{1}{\\sqrt[3]{p}}</span> . This is negligible. Therefore, there is negligible probability of the tree-finding algorithms succeeding, yet  <span class="math">\\mathcal{E}</span>  failing to extract a witness. This proves the argument has statistical witness-extended emulation.</p>

    <p class="text-gray-300">In this section, we present a protocol to commit to a polynomial t(X) and later reveal the evaluation of t(X) at any point  <span class="math">x \\in \\mathbb{Z}_p^*</span>  together with a proof that enables a verifier to check that the evaluation is correct with respect to the committed t(X). We will consider Laurent polynomials  <span class="math">t(X) \\in \\mathbb{Z}_p[X, X^{-1}]</span>  i.e.</p>

    <p class="text-gray-300">polynomials in which we allow terms of negative degree. This protocol will be used as a subroutine for the arguments described in Sections 5.1 and 5.2.</p>

    <p class="text-gray-300">A simple solution for this problem would be to send commitments to coefficients of t(X) individually, from which the evaluation of t(X) at any particular point can be verified using the homomorphic properties. This solution requires d group elements to be sent, where d is the number of non-zero coefficients in t(X). As we shall show it is possible to reduce the communication costs to  <span class="math">O(\\sqrt{d})</span>  group elements, where  <span class="math">d = d_2 + d_1</span>  if  <span class="math">t(X) = \\sum_{k=-d_1}^{d_2} t_k X^k</span> . For clarity we first informally describe our protocol for a standard (not Lau-</p>

    <p class="text-gray-300">For clarity we first informally describe our protocol for a standard (not Laurent) polynomial  <span class="math">t(X) = \\sum_{k=0}^{d} t_k X^k</span> . We then extend this informal description to Laurent polynomials with zero constant term. We finally provide a formal description of the protocol and analyze its security and efficiency.</p>

    <p class="text-gray-300">Main idea for standard polynomials. Let  <span class="math">t(X) = \\sum_{k=0}^{d} t_k X^k</span>  be a polynomial with coefficients in  <span class="math">\\mathbb{Z}_p</span>  and assume d+1=mn. We can write  <span class="math">t(X)=\\sum_{i=0}^{m-1}\\sum_{j=0}^{n-1} t_{i,j}(X)X^{in+j}</span>  and arrange the coefficients in a  <span class="math">m\\times n</span>  matrix</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} t_{0,0} &amp; t_{0,1} &amp; \\cdots &amp; t_{0,n-1} \\\\ t_{1,0} &amp; t_{1,1} &amp; \\cdots &amp; t_{1,n-1} \\\\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ t_{m-1,0} &amp; t_{n-1,1} &amp; \\cdots &amp; t_{m-1,n-1} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">Now, t(X) can be evaluated by multiplying the matrix by row and column vectors.</p>

    <p class="text-gray-300"><span class="math">$t(X) = \\begin{pmatrix} 1 \\ X^n \\cdots X^{(m-1)n} \\end{pmatrix} \\begin{pmatrix} t_{0,0} &amp; t_{0,1} &amp; \\cdots &amp; t_{0,n-1} \\\\ t_{1,0} &amp; t_{1,1} &amp; \\cdots &amp; t_{1,n-1} \\\\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ t_{m-1,0} &amp; t_{n-1,1} \\cdots &amp; t_{m-1,n-1} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ X \\\\ \\vdots \\\\ X^{n-1} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">The idea behind the protocol is to commit to the rows of this matrix using commitments  <span class="math">T_0, \\ldots, T_{m-1}</span> . Later, when given an evaluation point  <span class="math">x \\in \\mathbb{Z}_p</span>  we can use the homomorphic property of the commitment scheme to compute the commitment  <span class="math">\\prod_{i=0}^{m-1} T_i^{x^{in}}</span>  to the vector</p>

    <p class="text-gray-300"><span class="math">$\\bar{t} = (1 \\ x^n \\cdots x^{(m-1)n}) \\begin{pmatrix} t_{0,0} &amp; t_{0,1} &amp; \\cdots &amp; t_{0,n-1} \\\\ t_{1,0} &amp; t_{1,1} &amp; \\cdots &amp; t_{1,n-1} \\\\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ t_{m-1,0} \\ t_{m-1,1} \\cdots &amp; t_{m-1,n-1} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">The prover opens this latter commitment and now it is easy to compute v=t(x) from  <span class="math">\\bar{t}</span>  and x.</p>

    <p class="text-gray-300">The problem with this straightforward solution is that it leaks partial information about the coefficients of t(X). We remedy this by inserting some blinding values  <span class="math">u_1, \\ldots, u_{n-1}</span>  to hide the weighted sum of the coefficients in each column.</p>

    <p class="text-gray-300">However, we make sure that the blinding values cancel each other out so that we still get the correct evaluation of the polynomial. More precisely, we commit to the rows of the following  <span class="math">(m+1) \\times n</span>  matrix</p>

    <p class="text-gray-300"><span class="math">$T = \\begin{pmatrix} t_{0,0} &amp; t_{0,1} - u_1 &amp; \\cdots &amp; t_{0,n-2} - u_{n-2} &amp; t_{0,n-1} - u_{n-1} \\\\ t_{1,0} &amp; t_{1,1} &amp; \\cdots &amp; t_{1,n-2} &amp; t_{1,n-1} \\\\ \\vdots &amp; \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ t_{m-1,0} &amp; t_{m-1,1} &amp; \\cdots &amp; t_{m-1,n-2} &amp; t_{m-1,n-1} \\\\ u_1 &amp; u_2 &amp; \\cdots &amp; u_{n-1} &amp; 0 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">with U being a commitment to the last row. This time</p>

    <p class="text-gray-300"><span class="math">$t(X) = \\begin{pmatrix} 1 \\ X^n \\cdots X^{(m-1)n} \\ X \\end{pmatrix} T \\begin{pmatrix} 1 \\ X \\ X^2 \\\\ \\vdots \\\\ X^{n-1} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">We now open  <span class="math">U^x \\prod_{i=0}^{m-1} T_i^{x^{in}}</span>  by revealing the vector</p>

    <p class="text-gray-300"><span class="math">$\\bar{t} = (1 x^n \\cdots x^{(m-1)n} x) T</span>$</p>

    <p class="text-gray-300">This still allows us to compute t(x), but due to the blinders we no longer leak information about the coefficients of t(X). In fact, each element of  <span class="math">\\bar{t}</span>  is uniformly random, conditional on their weighted sum being equal to t(x), which the prover intends for the verifier to learn anyway.</p>

    <p class="text-gray-300"><strong>Extension to Laurent polynomials.</strong> Let now t(X) be a Laurent polynomial  <span class="math">t(X) = \\sum_{i=-d_1}^{d_2} t_i X^i</span>  with constant term  <span class="math">t_0 = 0</span> . Let  <span class="math">m_1, m_2, n</span>  be positive integers such that  <span class="math">d_1 = nm_1</span>  and  <span class="math">d_2 = nm_2</span>  and write  <span class="math">t(X) = X^{-m_1n}t&#x27;(X) + Xt&#x27;&#x27;(X)</span>  for degree  <span class="math">d_1 - 1</span>  and  <span class="math">d_2 - 1</span>  polynomials  <span class="math">t&#x27;(X), t&#x27;&#x27;(X) \\in \\mathbb{Z}_p[X]</span> . We can write  <span class="math">t&#x27;(X) = \\sum_{i=0}^{m_1-1} \\sum_{j=0}^{n-1} t&#x27;_{i,j} X^{in+j}</span>  and  <span class="math">t&#x27;&#x27;(X) = \\sum_{i=0}^{m_2-1} \\sum_{j=0}^{n-1} t&#x27;&#x27;_{i,j} X^{in+j}</span> . We can arrange the coefficients of t'(X) and t''(X) in a  <span class="math">(m_1 + m_2) \\times n</span>  matrix</p>

    <p class="text-gray-300">We can arrange the coefficients of t'(X) and  <span class="math">\\overline{t&#x27;&#x27;(X)}</span>  in a  <span class="math">(m_1 + m_2) \\times n</span>  matrix T. We commit to both t'(X) and t''(X) simultaneously by committing to the rows of the matrix using commitments  <span class="math">T&#x27;_i</span>  and  <span class="math">T&#x27;&#x27;_i</span> . As when committing to polynomials we add blinders  <span class="math">u_1, \\ldots, u_{n-1}</span>  and make a commitment U to the additional last row arising from this.</p>

    <p class="text-gray-300"><span class="math">$T = \\begin{pmatrix} t&#x27;_{0,0} &amp; t&#x27;_{0,1} &amp; \\cdots &amp; t&#x27;_{0,n-1} \\\\ t&#x27;_{1,0} &amp; t&#x27;_{1,1} &amp; \\cdots &amp; t&#x27;_{1,n-1} \\\\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ t&#x27;_{m_1-1,0} &amp; t&#x27;_{m_1-1,1} &amp; \\cdots &amp; t&#x27;_{m_1-1,n-1} \\\\ t&#x27;&#x27;_{0,0} &amp; t&#x27;&#x27;_{0,1} - u_1 &amp; \\cdots &amp; t&#x27;&#x27;_{0,n-1} - u_{n-1} \\\\ t&#x27;&#x27;_{1,0} &amp; t&#x27;&#x27;_{1,1} &amp; \\cdots &amp; t&#x27;&#x27;_{1,n-1} \\\\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ t&#x27;&#x27;_{m_2-1,0} &amp; t&#x27;&#x27;_{m_2-1,1} &amp; \\cdots &amp; t&#x27;&#x27;_{m_2-1,n-1} \\\\ u_1 &amp; u_2 &amp; \\cdots &amp; 0 \\end{pmatrix} = \\begin{pmatrix} t&#x27;_0 \\\\ t&#x27;_1 \\\\ \\vdots \\\\ t&#x27;_{m_1-1} \\\\ t&#x27;&#x27;_0 \\\\ \\vdots \\\\ t&#x27;&#x27;_{m_2-1} \\\\ u \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">Define vectors</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{Z} = \\boldsymbol{Z}(X) = \\begin{pmatrix} X^{-m_1 n}, X^{-(m_1 - 1)n}, \\dots, X^{-n}, X, X^{n+1}, \\dots, X^{(m_2 - 1)n + 1}, X^2 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{X} = \\boldsymbol{X}(X) = \\begin{pmatrix} 1 \\\\ X \\\\ \\vdots \\\\ X^{n-1} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">and we have  <span class="math">t(X) = \\mathbf{Z}T\\mathbf{X}</span> .</p>

    <p class="text-gray-300">To evaluate at  <span class="math">x \\in \\mathbb{Z}_p^*</span>  we open  <span class="math">\\left(\\prod_{i=0}^{m_1-1} (T_i&#x27;)^{x^{(i-m_1)n}}\\right) \\left(\\prod_{i=0}^{m_2-1} (T_i&#x27;&#x27;)^{x^{in+1}}\\right) U^{x^2}</span>  to the vector  <span class="math">\\bar{\\boldsymbol{t}} = \\boldsymbol{Z}(x)T</span> . This allows us to compute t(x) as  <span class="math">\\bar{\\boldsymbol{t}}\\boldsymbol{X}(x)</span> . The blinders hide the weighted sums of each column as before, and now the verifier is able to compute t(x) without gaining additional information about its coefficients.</p>

    <p class="text-gray-300"><strong>Evaluation Protocol.</strong> Our protocol is made of the following three algorithms. For simplicity, we restrict our description to the case of Pedersen commitments, but all aspects of the construction and proof carry over in the general case.</p>

    <p class="text-gray-300">• PolyCommit <span class="math">(ck, m_1, m_2, n, t(X)) \\to (\\mathsf{pc}, \\mathsf{st})</span> : Take as input a commitment key ck and a Laurent polynomial  <span class="math">t(X) = \\sum_{i=-m_1 n}^{nm_2} t_i X^i</span>  with constant coefficient  <span class="math">t_0 = 0</span> . Pick blinders  <span class="math">u_1, \\ldots, u_{n-1} \\leftarrow \\mathbb{Z}_p</span>  and randomness  <span class="math">\\tau_u, \\tau&#x27;_0, \\ldots, \\tau&#x27;_{m_1-1}, \\tau&#x27;&#x27;_0, \\ldots, \\tau&#x27;&#x27;_{m_2-1} \\leftarrow \\mathbb{Z}_p</span> . Set  <span class="math">\\boldsymbol{\\tau} = \\left(\\tau&#x27;_0, \\ldots, \\tau&#x27;_{m_1-1}, \\tau&#x27;&#x27;_0, \\ldots, \\tau&#x27;&#x27;_{m_2-1}, \\tau_u\\right)</span> . Compute</p>

    <p class="text-gray-300"><span class="math">$T&#x27;_i = \\operatorname{Com}_{ck}(\\boldsymbol{t}&#x27;_i; \\tau&#x27;_i), \\qquad T&#x27;&#x27;_i = \\operatorname{Com}_{ck}(\\boldsymbol{t}&#x27;&#x27;_i; \\tau&#x27;&#x27;_i), \\qquad U = \\operatorname{Com}_{ck}(\\boldsymbol{u}; \\tau_u)</span>$</p>

    <p class="text-gray-300">Return a polynomial commitment  <span class="math">pc = (\\{T_i&#x27;\\}_{i=0}^{m_1-1}, \\{T_i&#x27;&#x27;\\}_{i=0}^{m_2-1}, U)</span>  and private information  <span class="math">st = (t(X), \\tau)</span> .</p>

    <p class="text-gray-300">• PolyEval(st, x)  <span class="math">\\rightarrow</span>  pe: Compute</p>

    <p class="text-gray-300"><span class="math">$\\bar{\\boldsymbol{t}} = \\boldsymbol{Z}(x)T, \\qquad \\bar{\\tau} = \\boldsymbol{Z}(x) \\cdot \\boldsymbol{\\tau}</span>$</p>

    <p class="text-gray-300">Return  <span class="math">pe = (\\bar{t}, \\bar{\\tau})</span> .</p>

    <p class="text-gray-300">• PolyVerify <span class="math">(ck, m_1, m_2, n, pc, pe, x) \\rightarrow v</span> : The verifier checks whether</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Com}_{ck}(\\bar{\\boldsymbol{t}};\\bar{\\tau}) = \\left(\\prod_{i=0}^{m_1-1} (T_i&#x27;)^{x^{(i-m_1)n}}\\right) \\left(\\prod_{i=0}^{m_2-1} (T_i&#x27;&#x27;)^{x^{in+1}}\\right) U^{x^2}</span>$</p>

    <p class="text-gray-300">If the check is satisfied the verifier returns  <span class="math">v=t(x)=\\bar{\\boldsymbol{t}}\\boldsymbol{X}(x).</span>  Otherwise, the verifier rejects pe as invalid with respect to pc and x and returns  <span class="math">v=\\bot</span> .</p>

    <p class="text-gray-300"><strong>Security Properties.</strong> We define three security properties for our protocol: completeness, <em>l</em>-special soundness, and special-honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">Later, the protocol is used as a sub-protocol inside our zero-knowledge arguments-of-knowledge. These properties will help us to prove the completeness, witness-extended emulation, and special honest verifier zero knowledge for the zero knowledge argument.</p>

    <p class="text-gray-300">The definition of completeness simply guarantees that if PolyCommit, PolyVerify are carried out honestly, then PolyVerify will accept and return a commitment to the evaluation of the polynomial.</p>

    <p class="text-gray-300"><strong>Definition 10 (Perfect Completeness).</strong> (PolyCommit, PolyEval, PolyVerify) has perfect completeness if for all non-uniform polynomial time adversaries  <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr \\begin{bmatrix} (ck, m_1, m_2, n, t(X), x) \\leftarrow \\mathcal{A}(1^{\\lambda}) \\\\ (\\mathsf{pc}, \\mathsf{st}) \\leftarrow \\operatorname{PolyCommit}(ck, m_1, m_2, n, t(X)) \\\\ \\mathsf{pe} \\leftarrow \\operatorname{PolyEval}(\\mathsf{st}, x) \\\\ v \\leftarrow \\operatorname{PolyVerify}(ck, m_1, m_2, n, \\mathsf{pc}, \\mathsf{pe}, x) \\end{bmatrix} = 1</span>$</p>

    <p class="text-gray-300">where ck is a key for a homomorphic commitment scheme, t(X) is a Laurent polynomial of degrees  <span class="math">d_1 = m_1 n, d_2 = m_2 n</span>  and  <span class="math">x \\in \\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">The definition of l-Special Soundness says that given l accepting evaluations for different evaluation points, but from the same commitment pc, then it is possible to extract either a valid Laurent polynomial t(X) with zero constant term that is consistent with the evaluations produced or a breach in the binding property of the commitment scheme. Furthermore, any other accepting evaluations for the same commitment will also be evaluations of t(X).</p>

    <p class="text-gray-300"><strong>Definition 11 (Statistical</strong> <em>l</em>-<strong>Special Soundness).</strong> (PolyCommit, PolyEval, PolyVerify) is statistically <em>l</em>-special sound if there exists a probabilistic polynomial time algorithm  <span class="math">\\chi</span>  that, given <em>l</em> accepting transcripts with the same commitment pc, either extracts the committed polynomial t(X), or extracts a break of the binding property of the underlying commitment scheme. For all adversaries A and all  <span class="math">L \\geq l</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr \\begin{bmatrix} ck \\leftarrow \\operatorname{CGen}(1^{\\lambda}) &amp; \\forall i: \\ v_i = \\mathbf{Z}(x_i)T\\mathbf{X}(x_i) \\\\ (m_1, m_2, n, \\operatorname{pc}, x_1, \\operatorname{pe}_1, \\dots, x_L, \\operatorname{pe}_L) \\leftarrow \\mathcal{A}(ck) &amp; \\text{or } \\exists j \\text{ s.t.} \\\\ \\operatorname{Parse} \\ \\operatorname{pe}_i = (\\bar{\\boldsymbol{t}}_i, \\bar{\\tau}_i) &amp; : \\operatorname{Com}_{ck}(\\bar{\\boldsymbol{t}}_j; \\bar{\\tau}_j) = \\\\ (T, \\boldsymbol{\\tau}) \\leftarrow \\chi(ck, m_1, m_2, n, \\operatorname{pc}, x_1, \\operatorname{pe}_1, \\dots, x_l, \\operatorname{pe}_l) &amp; \\operatorname{Com}_{ck}\\left(\\mathbf{Z}(x_j)T; \\mathbf{Z}(x_j)\\boldsymbol{\\tau}\\right), \\\\ v_i \\leftarrow \\operatorname{PolyVerify}(ck, m_1, m_2, n, \\operatorname{pc}, \\operatorname{pe}_i, x_i) &amp; \\text{where } \\bar{\\boldsymbol{t}}_j \\neq \\mathbf{Z}(x_j)T \\end{bmatrix} \\approx 1,</span>$</p>

    <p class="text-gray-300">where  <span class="math">x_1, \\ldots, x_l</span>  are distinct,  <span class="math">x_i \\in \\mathbb{Z}_p^*</span> ,  <span class="math">\\mathsf{pe}_i \\in \\mathbb{Z}_p^n \\times \\mathbb{Z}_p</span> ,  <span class="math">T \\in \\mathbb{Z}_p^{(m_1 + m_2) \\times n}</span> , and  <span class="math">\\tau \\in \\mathbb{Z}_p^{m_1 + m_2}</span> .</p>

    <p class="text-gray-300">Perfect special honest verifier zero-knowledge means that given any value v and evaluation point x, it is possible to simulate pc and pe, distributed exactly as in a real execution of the protocol where v was the evaluation of t(X) at x.</p>

    <p class="text-gray-300">that for all interactive non-uniform polynomial time adversaries A</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\text{Pr} \\begin{bmatrix} (ck, m_1, m_2, n, t(X), x) \\leftarrow \\mathcal{A}(1^{\\lambda}) \\\\ (\\mathsf{pc}, \\mathsf{st}) \\leftarrow &amp; \\text{PolyCommit}(ck, m_1, m_2, n, t(X)) : \\mathcal{A}(\\mathsf{pc}, \\mathsf{pe}) = 1 \\\\ \\mathsf{pe} \\leftarrow &amp; \\text{PolyEval}(\\mathsf{st}, x) \\\\ \\end{bmatrix} \\\\ &amp; = \\text{Pr} \\begin{bmatrix} (ck, m_1, m_2, n, t(X), x) \\leftarrow \\mathcal{A}(1^{\\lambda}) \\\\ (\\mathsf{pc}, \\mathsf{pe}) \\leftarrow \\mathcal{S}(ck, m_1, m_2, n, x, t(x)) : \\mathcal{A}(\\mathsf{pc}, \\mathsf{pe}) = 1 \\end{bmatrix} \\end{split}</span>$</p>

    <p class="text-gray-300">where ck is a key for a homomorphic commitment scheme, t(X) is a Laurent polynomial of degrees  <span class="math">d_1 = m_1 n, d_2 = m_2 n</span>  and  <span class="math">x \\in \\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;<strong>Theorem 1.</strong> The polynomial commitment protocol has perfect completeness, perfect special honest verifier zero-knowledge and  <span class="math">(m_1+m_2)n+1</span> -special soundness for extracting either a breach of the binding property of the commitment scheme or openings to the polynomial.</p>

    <p class="text-gray-300"><em>Proof.</em> Direct verification of the protocol shows that the verifier correctly obtains the evaluation of the committed polynomial t(X) at the point x.</p>

    <p class="text-gray-300">For special honest verifier zero-knowledge suppose we have an evaluation point x and an evaluation v. To simulate the polynomial evaluation we first pick random  <span class="math">\\bar{t}_2, \\ldots, \\bar{t}_n, \\bar{\\tau} \\leftarrow \\mathbb{Z}_p</span>  and  <span class="math">T&#x27;_0, \\ldots, T&#x27;_{m_1-1}, T&#x27;&#x27;_0, \\ldots, T&#x27;&#x27;_{m_2-1} \\leftarrow \\mathbb{G}</span> . Now,  <span class="math">\\bar{t}_1</span>  is computed as</p>

    <p class="text-gray-300"><span class="math">$\\bar{t}_1 = v - \\sum_{i=2}^n \\bar{t}_i x^{i-1}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">\\bar{\\boldsymbol{t}} = (\\bar{t}_1, \\dots, \\bar{t}_n)</span>  and compute</p>

    <p class="text-gray-300"><span class="math">$U = \\operatorname{Com}_{ck}(\\bar{t}x^{-2}; \\bar{\\tau}x^{-2}) \\left[ \\prod_{i=0}^{m_1 - 1} (T_i&#x27;)^{x^{(i-m_1)n}} \\right]^{x^{-2}} \\left[ \\prod_{i=0}^{m_2 - 1} (T_i&#x27;&#x27;)^{x^{in+1}} \\right]^{x^{-2}}</span>$</p>

    <p class="text-gray-300">This is a perfect simulation. Given x,v observe that both in the simulation and in the real execution we get uniformly random  <span class="math">\\bar{t}_2,\\ldots,\\bar{t}_n,\\bar{\\tau}\\in\\mathbb{Z}_p</span>  and  <span class="math">T&#x27;_0,\\ldots,T&#x27;_{m_1-1},T&#x27;&#x27;_0,\\ldots,T&#x27;&#x27;_{m_2-1}\\leftarrow\\mathbb{G}</span> . Now, conditioning on the values of x,v and the verification equations, U and  <span class="math">\\bar{t}_1</span>  are uniquely determined. Therefore, the simulation is perfect, and we have special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Finally, for special soundness note that if we have valid evaluations of  <span class="math">l=(m_1+m_2)n+2</span>  different challenges  <span class="math">x\\in\\mathbb{Z}_p^*</span>  the vectors  <span class="math">(x^{-m_1n},\\ldots,x^{m_2n-n+1})</span>  form the rows of a Vandermonde matrix multiplied by  <span class="math">x^{-m_1n}</span>  and we can obtain any unit vector  <span class="math">(0,\\ldots,1,\\ldots,0)</span>  by taking an appropriate linear combination of these vectors. By taking the correct linear combinations of the l verification equations</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Com}_{ck}(\\bar{\\boldsymbol{t}};\\bar{\\tau}) = \\left[\\prod_{i=0}^{m_1-1} (T_i&#x27;)^{x^{(i-m_1)n}}\\right] \\left[\\prod_{i=0}^{m_2-1} (T_i&#x27;&#x27;)^{x^{in+1}}\\right] U^{x^2}</span>$</p>

    <p class="text-gray-300">for these l different challenges, we can then extract an opening of any  <span class="math">T&#x27;_i = \\operatorname{Com}_{ck}(t&#x27;_i; \\tau&#x27;_i), T&#x27;&#x27;_i = \\operatorname{Com}_{ck}(t&#x27;&#x27;_i; \\tau&#x27;&#x27;_i)</span>  and  <span class="math">U = \\operatorname{Com}_{ck}(u; \\tau_u)</span> .</p>

    <p class="text-gray-300">This implies that whenever we have  <span class="math">L \\geq l</span>  different challenges  <span class="math">x \\in \\mathbb{Z}_p^*</span>  with valid evaluations we must either have  <span class="math">\\bar{\\boldsymbol{t}} = \\boldsymbol{Z}(x)T</span>  for each (x, pe) pair, where the rows of T are the extracted  <span class="math">\\boldsymbol{t}_i&#x27;</span>  and  <span class="math">\\boldsymbol{t}_i&#x27;&#x27;</span>  and  <span class="math">\\boldsymbol{u}</span> , or we could extract a violation of the binding property of the commitment scheme.</p>

    <p class="text-gray-300">In the first case where  <span class="math">\\bar{\\boldsymbol{t}} = \\boldsymbol{Z}(x)T</span> , for each pair,  <span class="math">\\chi</span>  sets  <span class="math">\\tau = (\\tau&#x27;_0, \\ldots, \\tau&#x27;_{m_1-1}, \\tau&#x27;&#x27;_0, \\ldots, \\tau&#x27;&#x27;_{m_2-1}, \\tau_u)</span> , and sets  <span class="math">S, \\boldsymbol{\\sigma}</span>  to be all zeroes. Since  <span class="math">\\bar{\\boldsymbol{t}} = \\boldsymbol{Z}(x)T</span> , it follows that  <span class="math">v_i = \\boldsymbol{Z}(x_i)T\\boldsymbol{X}(x_i)</span>  for each i.</p>

    <p class="text-gray-300">Alternatively, if  <span class="math">\\bar{\\boldsymbol{t}}_i \\neq \\boldsymbol{Z}(x_i)T</span>  for some  <span class="math">x_i</span>  and  <span class="math">\\mathsf{pe}_i = (\\bar{\\boldsymbol{t}}_i, \\bar{\\tau}_i)</span> , then since the verifier was accepting, we have  <span class="math">\\mathrm{Com}_{ck}(\\bar{\\boldsymbol{t}}_i; \\bar{\\tau}_i) = \\mathrm{Com}_{ck}(\\boldsymbol{Z}(x_i)T; \\boldsymbol{Z}(x_i)\\boldsymbol{\\tau})</span> , and this gives a violation of the binding property of the commitment scheme.</p>

    <p class="text-gray-300">Efficiency. We now discuss the efficiency of the above protocol when instantiated with the Pedersen multicommitment scheme. The outputs pc, pe of the polynomial commitment protocol have sizes of  <span class="math">m_1+m_2+1</span>  group elements and n+1 field elements respectively. The computational cost of computing pc is dominated by computing commitments  <span class="math">T_i&#x27;</span>  and  <span class="math">T_i&#x27;&#x27;</span> , corresponding to  <span class="math">m_1+m_2</span>  n-wide multiexponentiations. Using multi-exponentiation techniques as in [Lim00, Möl01, MR08], the total cost is roughly  <span class="math">\\frac{(m_1+m_2)n}{\\log n}</span>  group exponentiations. The main cost for computing pc is dominated by the  <span class="math">n(m_1+m_2)</span>  field multiplications required to compute ZT. The dominant cost in PolyVerify is to check the verification equation. This costs roughly  <span class="math">\\frac{m_1+m_2+n}{\\log (m_1+m_2+n)}</span>  group exponentiations.</p>

    <p class="text-gray-300">We will now give an inner product argument of knowledge of two vectors  <span class="math">\\boldsymbol{a}, \\boldsymbol{b} \\in \\mathbb{Z}_p^n</span>  such that  <span class="math">A = \\boldsymbol{g^a}</span> ,  <span class="math">B = \\boldsymbol{h^b}</span>  and  <span class="math">\\boldsymbol{a} \\cdot \\boldsymbol{b} = z</span> , given  <span class="math">z \\in \\mathbb{Z}_p</span> ,  <span class="math">A, B \\in \\mathbb{G}</span>  and  <span class="math">\\boldsymbol{g}, \\boldsymbol{h} \\in \\mathbb{G}^n</span> . The argument will be used later as a subroutine where zero-knowledge is not required, so the prover could in principle just reveal the witness  <span class="math">\\boldsymbol{a}, \\boldsymbol{b}</span>  to the verifier. In the following we show how to use interaction to reduce the communication from linear to logarithmic in n, the length of the vectors.</p>

    <p class="text-gray-300">The basic step in our inner product argument is a 2-move reduction to a smaller statement using techniques similar to [BG12]. It will suffice for the prover to reveal the witness for the smaller statement in order to convince the verifier about the validity of the original statement. In the full argument, prover and verifier recursively run the reduction to obtain increasingly smaller statements. The argument is then concluded with the prover revealing a witness for a very small statement. The outcome of this is a  <span class="math">O(\\log n)</span> -move argument with an overall communication of  <span class="math">O(\\log n)</span>  group and field elements. The inner product argument will be used in the next section to build a logarithmic size argument for circuit satisfiability.</p>

    <p class="text-gray-300">Due to the obvious relationship with Pedersen commitments, we will think of multi-exponentiations  <span class="math">g^a</span>  and  <span class="math">h^b</span>  as commitments with randomness set equal to zero, and to a, b as openings with respect to commitment keys g, h.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">4.1 Main Idea</h4>

    <p class="text-gray-300">We now describe the basic step in our argument. Consider the common input for both prover and verifier to be of the form  <span class="math">(\\mathbb{G}, p, \\boldsymbol{g}, A, \\boldsymbol{h}, B, z, m)</span>  where m divides n, the length of the vectors. For arbitrary n one can always reduce to the case where m|n by appending at most m-1 random group elements to  <span class="math">\\boldsymbol{g}</span>  and  <span class="math">\\boldsymbol{h}</span> .</p>

    <p class="text-gray-300">We split the bases for the multi-exponentiations into m sets  <span class="math">\\mathbf{g} = (\\mathbf{g}_1, \\dots, \\mathbf{g}_m)</span>  and  <span class="math">\\mathbf{h} = (\\mathbf{h}_1, \\dots, \\mathbf{h}_m)</span> , where each set has size  <span class="math">\\frac{n}{m}</span> . We want to prove knowledge of vectors  <span class="math">\\mathbf{a} = (\\mathbf{a}_1, \\dots, \\mathbf{a}_m)</span>  and  <span class="math">\\mathbf{b} = (\\mathbf{b}_1, \\dots, \\mathbf{b}_m)</span>  such that</p>

    <p class="text-gray-300"><span class="math">$A = \\boldsymbol{g}^{\\boldsymbol{a}} = \\prod_{i=1}^m \\boldsymbol{g}_i^{\\boldsymbol{a}_i} \\qquad B = \\boldsymbol{h}^{\\boldsymbol{b}} = \\prod_{i=1}^m \\boldsymbol{h}_i^{\\boldsymbol{b}_i} \\qquad \\boldsymbol{a} \\cdot \\boldsymbol{b} = \\sum_{i=1}^m \\boldsymbol{a}_i \\cdot \\boldsymbol{b}_i = z</span>$</p>

    <p class="text-gray-300">The key idea is for the prover to replace A with A', a commitment to a shorter vector  <span class="math">\\mathbf{a}&#x27; = \\sum_{i=1}^{m} \\mathbf{a}_i x^i</span> , given a random challenge  <span class="math">x \\leftarrow \\mathbb{Z}_p^*</span>  provided by the verifier. In the argument, the prover first computes and sends</p>

    <p class="text-gray-300"><span class="math">$A_k = \\prod_{i=\\max(1,1-k)}^{\\min(m,m-k)} \\boldsymbol{g}_i^{\\boldsymbol{a}_{i+k}} \\quad \\text{ for } k = 1-m,\\dots,m-1</span>$</p>

    <p class="text-gray-300">corresponding to the products over the diagonals of the following matrix</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{cccccccccccccccccccccccccccccccccccc</span>$</p>

    <p class="text-gray-300">Notice that  <span class="math">A_0 = A</span>  is already known to the verifier since it is part of the statement. The verifier now sends a random challenge  <span class="math">x \\leftarrow \\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">At this point, both the prover and the verifier can compute  <span class="math">\\mathbf{g}&#x27; := \\prod_{i=1}^m \\mathbf{g}_i^{x^{-i}}</span>  and  <span class="math">A&#x27; := \\prod_{k=1-m}^{m-1} A_k^{x^k}</span> . If the prover is honest then we have  <span class="math">A&#x27; = (\\mathbf{g}&#x27;)^{\\mathbf{a}&#x27;}</span> , namely A' is a commitment to  <span class="math">\\mathbf{a}&#x27;</span>  under the key  <span class="math">\\mathbf{g}&#x27;</span> . Furthermore, even if the prover is dishonest, we can show that if the prover can open A' with respect to the key  <span class="math">\\mathbf{g}&#x27;</span>  for 2m-1 different challenges, then we can extract opening  <span class="math">(\\mathbf{a}_1,\\ldots,\\mathbf{a}_m)</span>  corresponding to  <span class="math">A = \\prod_{i=1}^m \\mathbf{g}_i^{a_i}</span> .</p>

    <p class="text-gray-300">The same type of argument can be applied in parallel to B with the inverse challenge  <span class="math">x^{-1}</span>  giving us a sum of the form  <span class="math">\\mathbf{b}&#x27; = \\sum_{i=1}^m \\mathbf{b}_i x^{-i}</span>  and a new base  <span class="math">\\mathbf{h}&#x27; = \\prod_{i=1}^m \\mathbf{h}_i^{x^i}</span> .</p>

    <p class="text-gray-300">All that remains is to demonstrate that z is the constant term in the product  <span class="math">\\mathbf{a}&#x27; \\cdot \\mathbf{b}&#x27; = \\sum_{i=1}^{m} \\mathbf{a}_i x^i \\cdot \\sum_{j=1}^{m} \\mathbf{b}_j x^{-j}</span> . Similarly to A and B, the prover sends values</p>

    <p class="text-gray-300"><span class="math">$z_k = \\sum_{i=\\max(1,1-k)}^{\\min(m,m-k)} \\boldsymbol{a}_i \\cdot \\boldsymbol{b}_{i+k} \\quad \\text{for } k = 1-m,\\dots,m-1</span>$</p>

    <p class="text-gray-300">where  <span class="math">z_0 = z = \\sum_{i=1}^m \\boldsymbol{a}_i \\cdot \\boldsymbol{b}_i</span> , and shows that  <span class="math">z&#x27; := \\boldsymbol{a}&#x27; \\cdot \\boldsymbol{b}&#x27; = \\sum_{k=1-m}^{m-1} z_k x^{-k}</span> . To summarise, after the challenge x has been sent, both parties compute</p>

    <p class="text-gray-300">To summarise, after the challenge x has been sent, both parties compute g', A', h', B', z' and then run an argument for the knowledge of a', b' of length  <span class="math">\\frac{n}{m}</span> . Given  <span class="math">n = m_{\\mu}m_{\\mu-1}\\cdots m_1</span> , we recursively apply this reduction over the factors of n to obtain, after  <span class="math">\\mu-1</span>  iterations, vectors of length  <span class="math">m_1</span> . The prover concludes the argument by revealing a short witness associated with the last statement.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">4.2 Formal description</h4>

    <p class="text-gray-300">We now give a formal description of the argument of knowledge introduced above.</p>

    <p class="text-gray-300">Common input:  <span class="math">(\\mathbb{G}, p, \\boldsymbol{g}, A, \\boldsymbol{h}, B, z, m_{\\mu} = m, m_{\\mu-1} = m&#x27;, \\dots, m_1)</span>  such that  <span class="math">\\boldsymbol{g}, \\boldsymbol{h} \\in \\mathbb{G}^n, A, B \\in \\mathbb{G}</span>  and  <span class="math">n = \\prod_{i=1}^{\\mu} m_i</span> .</p>

    <p class="text-gray-300">Prover's witness:  <span class="math">(a_1, \\ldots, a_m, b_1, \\ldots, b_m)</span>  satisfying</p>

    <p class="text-gray-300"><span class="math">$A = \\prod_{i=1}^{m} \\boldsymbol{g}_{i}^{\\boldsymbol{a}_{i}}</span>$
<span class="math">B = \\prod_{i=1}^{m} \\boldsymbol{h}_{i}^{\\boldsymbol{b}_{i}}</span>   <span class="math">\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\boldsymbol{b}_{i} = z</span></p>

    <p class="text-gray-300">Argument if  <span class="math">\\mu = 1</span> :</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\to \\mathbf{V}</span> : Send  <span class="math">(a_1, \\dots, a_m, b_1, \\dots, b_m)</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\leftarrow \\mathbf{V}</span> : Accept if and only if</p>

    <p class="text-gray-300"><span class="math">$A = \\prod_{i=1}^{m} g_i^{a_i}</span>$
<span class="math">B = \\prod_{i=1}^{m} h_i^{b_i}</span>   <span class="math">\\sum_{i=1}^{m} a_i b_i = z</span></p>

    <p class="text-gray-300">Reduction if  <span class="math">\\mu \\neq 1</span> :</p>

    <p class="text-gray-300"><span class="math">P \\to V</span> : Send  <span class="math">A_{1-m}, B_{1-m}, z_{1-m}, \\dots, A_{m-1}, B_{m-1}, z_{m-1}</span>  where</p>

    <p class="text-gray-300"><span class="math">$A_k = \\prod_{i=\\max(1,1-k)}^{\\min(m,m-k)} \\boldsymbol{g}_i^{\\boldsymbol{a}_{i+k}} \\qquad B_k = \\prod_{i=\\max(1,1-k)}^{\\min(m,m-k)} \\boldsymbol{h}_i^{\\boldsymbol{b}_{i+k}} \\qquad z_k = \\sum_{i=\\max(1,1-k)}^{\\min(m,m-k)} \\boldsymbol{a}_i \\cdot \\boldsymbol{b}_{i+k}</span>$</p>

    <p class="text-gray-300">Observe  <span class="math">A_0 = A, B_0 = B, z_0 = z</span>  so they can be omitted from the message.  <span class="math">\\mathbf{P} \\leftarrow \\mathbf{V}</span> :  <span class="math">x \\leftarrow \\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">Both prover and verifier compute a reduced statement of the form</p>

    <p class="text-gray-300"><span class="math">$(\\mathbb{G}, p, \\mathbf{g}&#x27;, A&#x27;, \\mathbf{h}&#x27;, B&#x27;, z&#x27;, m_{\\mu-1}, \\dots, m_1)</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\bm{g}&#x27; &amp;= (\\bm{g}_1&#x27;, \\dots, \\bm{g}_{m&#x27;}&#x27;) = \\prod_{i=1}^m \\bm{g}_i^{x^{-i}} \\qquad A&#x27; = \\prod_{k=1-m}^{m-1} A_k^{x^k} \\ \\bm{h}&#x27; &amp;= (\\bm{h}_1&#x27;, \\dots, \\bm{h}_{m&#x27;}&#x27;) = \\prod_{i=1}^m \\bm{h}_i^{x^i} \\qquad B&#x27; = \\prod_{k=1-m}^{m-1} B_k^{x^{-k}} \\qquad z&#x27; = \\sum_{k=1-m}^{m-1} z_k x^{-k} \\end{aligned}</span>$</p>

    <p class="text-gray-300">The prover computes a new witness as  <span class="math">(\\mathbf{a}&#x27;_1, \\dots, \\mathbf{a}&#x27;_{m&#x27;}) = \\sum_{i=1}^m \\mathbf{a}_i x^i</span>  and  <span class="math">(\\mathbf{b}&#x27;_1, \\dots, \\mathbf{b}&#x27;_{m&#x27;}) = \\sum_{i=1}^m \\mathbf{b}_i x^{-i}</span> .</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Security Analysis.</h4>

    <p class="text-gray-300"><strong>Theorem 2.</strong> The argument has perfect completeness and statistical witness extended emulation for either extracting a non-trivial discrete logarithm relation or a valid witness.</p>

    <p class="text-gray-300"><em>Proof.</em> Perfect completeness can be verified directly. To prove witness-extended emulation we start by giving an extractor that either extracts a witness for the original statement or a non-trivial discrete logarithm relation.</p>

    <p class="text-gray-300">For  <span class="math">\\mu=1</span>  we have (perfect) witness-extended emulation since the prover reveals a witness and the verifier checks it.</p>

    <p class="text-gray-300">Before discussing extraction in the recursive step, note that if we get a non-trivial discrete logarithm relation for  <span class="math">g&#x27;_1,\\ldots,g&#x27;_{m&#x27;}</span>  then we also get a non-trivial discrete logarithm relation for  <span class="math">g_1,\\ldots,g_m</span> , since  <span class="math">x\\neq 0</span> . A similar argument applies to  <span class="math">h&#x27;_1,\\ldots,h&#x27;_{m&#x27;}</span>  and  <span class="math">h_1,\\ldots,h_m</span> .</p>

    <p class="text-gray-300">Now, assume we get witness a', b' such that</p>

    <p class="text-gray-300"><span class="math">$A&#x27; = \\prod_{k=1-m}^{m-1} A_k^{x^k} = \\left(\\prod_{i=1}^m \\boldsymbol{g}_i^{x^{-i}}\\right)^{\\boldsymbol{a}&#x27;} \\quad B&#x27; = \\prod_{k=1-m}^{m-1} B_k^{x^{-k}} = \\left(\\prod_{i=1}^m \\boldsymbol{h}_i^{x^i}\\right)^{\\boldsymbol{b}&#x27;} \\quad \\boldsymbol{a}&#x27; \\cdot \\boldsymbol{b}&#x27; = \\sum_{k=1-m}^{m-1} z_k x^{-k}</span>$</p>

    <p class="text-gray-300">for 2m-1 different challenges  <span class="math">x \\in \\mathbb{Z}_p^*</span> . We will show that they yield either a witness for the original statement, or a non-trivial discrete logarithm relation for either  <span class="math">g_1, \\ldots, g_m</span>  or  <span class="math">h_1, \\ldots, h_m</span> .</p>

    <p class="text-gray-300">Take 2m-1 different challenges  <span class="math">x \\in \\mathbb{Z}_p^*</span> . They form a shifted Vandermonde matrix with rows  <span class="math">(x^{1-m}, x^{2-m}, \\ldots, x^{m-1})</span> . By taking appropriate linear combinations of the vectors we can obtain any unit vector  <span class="math">(0, \\ldots, 0, 1, 0, \\ldots, 0)</span> . Taking the same linear combinations of the 2m-1 equations</p>

    <p class="text-gray-300"><span class="math">$\\prod_{k=1-m}^{m-1} A_k^{x^k} = \\left(\\prod_{i=1}^m \\boldsymbol{g}_i^{x^{-i}}\\right)^{\\boldsymbol{a}&#x27;} \\quad \\text{we get vectors } \\boldsymbol{a}_{k,i} \\text{ such that } \\quad A_k = \\prod_{i=1}^m \\boldsymbol{g}_i^{\\boldsymbol{a}_{k,i}}</span>$</p>

    <p class="text-gray-300">For each of the 2m-1 challenges, we now have  <span class="math">\\prod_{k=1-m}^{m-1} A_k^{x^k} = \\left(\\prod_{i=1}^m \\boldsymbol{g}_i^{x^{-i}}\\right)^{\\boldsymbol{a}&#x27;}</span> , which means that for all i we have</p>

    <p class="text-gray-300"><span class="math">$x^{-i}\\boldsymbol{a}&#x27; = \\sum_{k=1-m}^{m-1} \\boldsymbol{a}_{k,i} x^k</span>$</p>

    <p class="text-gray-300">unless we encounter a non-trivial discrete logarithm relation for  <span class="math">g_1,\\ldots,g_m</span> . This means that  <span class="math">\\mathbf{a}&#x27; = \\sum_{k=1-m}^{m-1} \\mathbf{a}_{k,i} x^{k+i}</span>  for all i, and in particular  <span class="math">\\sum_{k=1-m}^{m-1} \\mathbf{a}_{k,i} x^{k+i} = \\sum_{k=1-m}^{m-1} \\mathbf{a}_{k,1} x^{k+1} = \\sum_{k=1-m}^{m-1} \\mathbf{a}_{k,m} x^{k+m}</span> . Matching terms of degree outside  <span class="math">\\{1,\\ldots,m\\}</span>  reveals  <span class="math">\\mathbf{a}_{k,i} = 0</span>  for  <span class="math">k+i \\notin \\{1,\\ldots,m\\}</span> . Defining  <span class="math">\\mathbf{a}_i = \\mathbf{a}_{0,i}</span> , and matching terms of similar degree we get</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{a}_{k,i} = \\begin{cases} \\boldsymbol{a}_{k+i} &amp; \\text{if } k+i \\in \\{1,\\dots,m\\} \\\\ 0 &amp; \\text{otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">This means</p>

    <p class="text-gray-300"><span class="math">$a&#x27; = \\sum_{k=1-m}^{m-1} a_{k,1} x^{k+1} = \\sum_{k=0}^{m-1} a_{k+1} x^{k+1} = \\sum_{i=1}^{m} a_i x^i</span>$</p>

    <p class="text-gray-300">A similar analysis of  <span class="math">B_{1-m}, \\ldots, B_{m-1}</span>  and openings b' for 2m-1 different challenges  <span class="math">x^{-1} \\in \\mathbb{Z}_p^*</span>  gives us either a non-trivial discrete logarithm relation for  <span class="math">h_1, \\ldots, h_m</span>  or vectors  <span class="math">b_i</span>  such that  <span class="math">b&#x27; = \\sum_{i=1}^m b_i x^{-i}</span>  and  <span class="math">B = \\prod_{i=1}^m h_i^{b_i}</span> .</p>

    <p class="text-gray-300"><span class="math">h_1, \\ldots, h_m</span>  or vectors  <span class="math">\\boldsymbol{b}_i</span>  such that  <span class="math">\\boldsymbol{b}&#x27; = \\sum_{i=1}^m \\boldsymbol{b}_i x^{-i}</span>  and  <span class="math">B = \\prod_{i=1}^m \\boldsymbol{h}_i^{\\boldsymbol{b}_i}</span> . Finally, with  <span class="math">\\sum_{i=1}^m \\boldsymbol{a}_i x^i \\cdot \\sum_{j=1}^m \\boldsymbol{b}_j x^{-j} = \\sum_{k=1-m}^{m-1} z_k x^{-k}</span>  for 2m-1 different challenges we get  <span class="math">z = z_0 = \\sum_{i=1}^m \\boldsymbol{a}_i \\cdot \\boldsymbol{b}_i</span> .</p>

    <p class="text-gray-300">We can now apply the forking lemma to a tree of size  <span class="math">(2m_{\\mu} - 1)(2m_{\\mu-1} - 1)\\cdots(2m_2 - 1) \\leq n^2</span> , which is polynomial in  <span class="math">\\lambda</span> , to conclude that the argument has witness-extended emulation.</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> The recursive argument uses  <span class="math">2\\mu - 1</span>  moves. The communication cost of all steps sums up to  <span class="math">4\\sum_{i=2}^{\\mu}(m_i - 1)</span>  group elements and  <span class="math">2\\sum_{i=2}^{\\mu}(m_i - 1) + 2m_1</span>  field elements.</p>

    <p class="text-gray-300">At each iteration, the main cost for the prover is computing the  <span class="math">A_k</span>  and  <span class="math">B_k</span>  values, using less than  <span class="math">\\frac{4(m_\\mu^2 m_{\\mu-1} \\dots m_1)}{\\log (m_\\mu \\dots m_1)}</span>  group exponentiations via multi-exponentiation techniques, and the  <span class="math">z_k</span>  values using  <span class="math">m_\\mu^2 m_{\\mu-1} \\dots m_1</span>  field multiplications. The cost of computing the reduced statements is dominated by  <span class="math">\\frac{2(m_\\mu m_{\\mu-1} \\dots m_1)}{\\log m_\\mu}</span>  group exponentiations for both the prover and the verifier. In the case where  <span class="math">m_\\mu = \\dots = m_1 = m</span> , the verifier complexity is bounded above by  <span class="math">\\frac{2m^\\mu}{\\log m} \\frac{m}{m-1}</span>  group exponentiations. The prover complexity is bounded above by  <span class="math">\\frac{6m^{\\mu+1}}{\\log m} \\frac{m}{m-1}</span>  group exponentiations and  <span class="math">m^{\\mu+1} \\frac{m}{m-1}</span>  field multiplications.</p>

    <p class="text-gray-300"><strong>Zero-knowledge version.</strong> The above argument can be modified to become zero-knowledge. We leave the details to the reader as zero-knowledge is not needed for our use of this argument in the next section.</p>

    <p class="text-gray-300">In this section, we revisit zero knowledge arguments for the satisfiability of an arithmetic circuit under the discrete logarithm assumption. We will explain how</p>

    <p class="text-gray-300">to build an argument with square root communication complexity, and superior efficiency to the argument of <a href="#page-36-0">[Gro09b]</a>. We then observe that our new argument involves computing a large inner product, and can achieve as good as logarithmic communication complexity by using our recursive inner product argument.</p>

    <p class="text-gray-300">At a high level, we transform an arithmetic circuit into two kinds of equations. Multiplication gates are directly represented as equations of the form <em>a</em> · <em>b</em> = <em>c</em>, where <em>a, b, c</em> represent the left, right and output wires. We will arrange these values in matrix form producing a Hadamard matrix product. This process will lead to duplicate values, when a wire is the output of one multiplication gate and the input of another, or when it is used as input multiple times. We keep track of this by using a series of linear constraints. For example, if the output of the first multiplication gate is the right input of the second, we would write <em>c</em>&lt;sup&gt;1&lt;/sup&gt; − <em>b</em>&lt;sup&gt;2&lt;/sup&gt; = 0.</p>

    <p class="text-gray-300">We also add linear constraints representing the addition and multiplication by constant gates of the circuit. We then rewrite those equations so that the only wires that are referenced in the equations are those linked to (non-constant) multiplication gates. We describe this process in Appendix <a href="#page-33-0">A.</a></p>

    <p class="text-gray-300">Finally, we fold both the Hadamard matrix product and the linear constraints into a single polynomial equation, where a Laurent polynomial has 0 as its constant term, and use the construction of Section <a href="#page-10-0">3</a> to prove this. We can optionally integrate the inner product argument of Section <a href="#page-16-0">4</a> to reduce communication.</p>

    <p class="text-gray-300">Our technique improves on the efficiency of <a href="#page-36-0">[Gro09b]</a> by making three main changes, each resulting in efficiency improvements.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We do not need commitments to the input and output wires of addition gates. We handle addition gates with linear consistency equations thus yielding a significant performance improvement proportional to the number of addition gates. This parallels <a href="#page-35-7">[GGPR13]</a> who also manage to eliminate addition gates when constructing Quadratic Arithmetic Programs from circuits.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We avoid black-box reductions to zero-knowledge arguments for generic linear algebra statements and instead design an argument directly for arithmetic circuit satisfiability. As a result, our square-root argument has only 5 moves, while the argument from <a href="#page-36-0">[Gro09b]</a> requires 7 moves. We note that <a href="#page-36-1">[Seo11]</a> reduced the complexity of <a href="#page-36-0">[Gro09b]</a> to 5 moves as well, but at a significant computational overhead whereas we also reduce the computational cost.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We use our protocol from Section <a href="#page-10-0">3</a> to reduce the communication costs of a polynomial commitment.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">These improvements give us a square root communication complexity with respect to the number of multiplication gates in the circuit. This is because for a circuit with <em>N</em> = <em>mn</em> multiplication gates, the prover makes 3<em>m</em> commitments to wire values in his first move, and later provides an opening consisting of <em>n</em> field elements to a homomorphic combination of these commitments. Optimising the parameters by choosing <em>m</em> ≈ <em>n</em> ≈ √ <em>N</em> leads to square root complexity.</p>

    <p class="text-gray-300">In our square root complexity argument, the verifier uses the <em>n</em> field elements to check an inner product relation. Our key idea to reduce communication further is to use our inner product evaluation argument instead of sending these field elements. This allows for verification of the inner product, and also provides an argument of knowledge of the opening of the commitment. We no longer need to open a large commitment, leading to a drastic reduction in communication complexity depending on the settings for the inner product argument.</p>

    <p class="text-gray-300">Below we give a first informal exposition of our arguments, and follow with a formal description.</p>

    <p class="text-gray-300"><strong>Reduction of Circuit Satisfiability to a Hadamard Matrix Product and Linear Constraints.</strong> We consider an arithmetic circuit containing <em>N</em> = <em>mn</em> multiplication gates over a field Z<em>p</em>. Without loss of generality, we assume that the circuit has been pre-processed (see Appendix <a href="#page-33-0">A</a> for a way to do this) , so that the input and the output wires feed into and go out from multiplication gates only. We number the multiplication gates from 1 to <em>N</em> and we arrange the inputs and outputs of these gates into three <em>m</em> × <em>n</em> matrices <em>A, B</em> and <em>C</em> such that the (<em>i, j</em>) entries of the matrices correspond to the left input, right input and output of the same multiplication gate.</p>

    <p class="text-gray-300">As shown in Appendix <a href="#page-33-0">A,</a> anarithmetic circuit can be described as a system of equations in the entries of the above matrices. The multiplication gates define a set of <em>N</em> equations</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-1&quot;&gt;&lt;/span&gt;
<span class="math">$A \\circ B = C \\tag{1}</span>$</p>

    <p class="text-gray-300">where ◦ is the Hadamard (entry-wise) product. The circuit description also contains constraints on the wires between multiplication gates. Denoting the rows of the matrices <em>A, B, C</em> as</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{a}_i = (a_{i,1}, \\dots, a_{i,n})</span>$
<span class="math">\\mathbf{b}_i = (b_{i,1}, \\dots, b_{i,n})</span>   <span class="math">\\mathbf{c}_i = (c_{i,1}, \\dots, c_{i,n})</span>  for  <span class="math">i \\in \\{1, \\dots, m\\}</span></p>

    <p class="text-gray-300">these constraints can be expressed as <em>Q &lt;</em> 2<em>N</em> linear equations of inputs and outputs of multiplication gates of the form</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\boldsymbol{w}_{q,a,i} + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} \\cdot \\boldsymbol{w}_{q,b,i} + \\sum_{i=1}^{m} \\boldsymbol{c}_{i} \\cdot \\boldsymbol{w}_{q,c,i} = K_{q} \\quad \\text{ for } q \\in \\{1,\\dots,Q\\} \\quad (2)</span>$</p>

    <p class="text-gray-300">for constant vectors <em>wq,a,i, wq,b,i, wq,c,i</em> and scalars <em>Kq</em>.</p>

    <p class="text-gray-300">For example, suppose that the circuit contains a single addition gate, with <em>a</em>1<em>,</em>&lt;sup&gt;1&lt;/sup&gt; and <em>a</em>1<em>,</em>&lt;sup&gt;2&lt;/sup&gt; as inputs, and <em>b</em>1<em>,</em>&lt;sup&gt;1&lt;/sup&gt; as output. In this case, <em>Q</em> = 1 and we would set <em>w</em>1<em>,a,</em>&lt;sup&gt;1&lt;/sup&gt; = (1<em>,</em> 1<em>,</em> 0<em>, . . . ,</em> 0), <em>w</em>1<em>,b,</em>&lt;sup&gt;1&lt;/sup&gt; = (−1<em>,</em> 0<em>, . . . ,</em> 0), and all other <em>w</em> vectors would be set to <strong>0</strong>. Then <a href="#page-22-0">(2)</a> would simply read</p>

    <p class="text-gray-300"><span class="math">$a_{1,1} + a_{1,2} - b_{1,1} = 0</span>$</p>

    <p class="text-gray-300">to capture the constraint imposed by the addition gate.</p>

    <p class="text-gray-300">In total, to capture all multiplications and linear constraints, we have <em>N</em> + <em>Q</em> equations that the wires must satisfy in order for the circuit to be satisfiable.</p>

    <p class="text-gray-300"><strong>Reduction to a Single Polynomial Equation.</strong> Let <em>Y</em> be a formal indeterminate. We will reduce the <em>N</em> + <em>Q</em> equations above to a single polynomial equation</p>

    <p class="text-gray-300">in Y by embedding each equation into a distinct power of Y. In our argument we will then require the prover to prove that this single equation holds when replacing Y by a random challenge received from the verifier.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{Y}&#x27;</span>  denote the vector  <span class="math">(Y^m, \\dots, Y^{mn})</span>  and  <span class="math">\\mathbf{Y}</span>  denote  <span class="math">(Y, Y^2, \\dots, Y^m)</span> . Then, we can multiply (1) by  <span class="math">\\mathbf{Y}</span>  from the left and  <span class="math">\\mathbf{Y}&#x27;^T</span>  on the right to obtain  <span class="math">\\mathbf{Y}(A \\circ B)\\mathbf{Y&#x27;}^T = \\mathbf{Y}C\\mathbf{Y&#x27;}^T</span> , or equivalently</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^m Y^i(\\boldsymbol{a}_i \\circ \\boldsymbol{b}_i) \\cdot \\boldsymbol{Y}&#x27; = \\sum_{i=1}^m Y^i(\\boldsymbol{c}_i \\cdot \\boldsymbol{Y}&#x27;)</span>$</p>

    <p class="text-gray-300">Since  <span class="math">(a \\circ b) \\cdot Y&#x27; = a \\cdot (b \\circ Y&#x27;)</span> , we obtain the following expression</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{m} \\boldsymbol{a}_i \\cdot (\\boldsymbol{b}_i \\circ \\boldsymbol{Y}&#x27;) Y^i = \\left(\\sum_{i=1}^{m} \\boldsymbol{c}_i Y^i \\cdot \\boldsymbol{Y}&#x27;\\right)</span>$</p>

    <p class="text-gray-300">This is easily seen to be equivalent to (1), because  <span class="math">a_{i,j}b_{i,j}=c_{i,j}</span>  appears in the coefficients of  <span class="math">Y^{i+jm}</span> , and i+jm takes every value from m+1 to M=N+m exactly once.</p>

    <p class="text-gray-300">Moreover, the Q linear constraints on the wires in Eq. 2 are satisfied if and only if</p>

    <p class="text-gray-300"><span class="math">$\\sum_{q=1}^{Q} \\left( \\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\boldsymbol{w}_{q,a,i} + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} \\cdot \\boldsymbol{w}_{q,b,i} + \\sum_{i=1}^{m} \\boldsymbol{c}_{i} \\cdot \\boldsymbol{w}_{q,c,i} \\right) Y^{q} = \\sum_{q=1}^{Q} K_{q} Y^{q}</span>$</p>

    <p class="text-gray-300">since the qth constraint arises from comparing the coefficients of  <span class="math">Y^q</span> . Combining the two polynomial equations by adding them after multiplying the latter by  <span class="math">Y^M</span> , and swapping summations, we see that the circuit is satisfied if and only if</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot (\\boldsymbol{b}_{i} \\circ \\boldsymbol{Y}&#x27;) Y^{i}\\right) + \\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\left(\\sum_{q=1}^{Q} \\boldsymbol{w}_{q,a,i} Y^{M+q}\\right) + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} \\cdot \\left(\\sum_{q=1}^{Q} \\boldsymbol{w}_{q,b,i} Y^{M+q}\\right) + \\sum_{i=1}^{m} \\boldsymbol{c}_{i} \\cdot \\left(-Y^{i} \\boldsymbol{Y}&#x27; + \\sum_{q=1}^{Q} \\boldsymbol{w}_{q,c,i} Y^{M+q}\\right) = \\left(\\sum_{q=1}^{Q} K_{q} Y^{M+q}\\right)</span>$</p>

    <p class="text-gray-300">Let us define</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\boldsymbol{w}_{a,i}(Y) &amp;= \\sum_{q=1}^Q \\boldsymbol{w}_{q,a,i} Y^{M+q} &amp; \\boldsymbol{w}_{b,i}(Y) &amp;= \\sum_{q=1}^Q \\boldsymbol{w}_{q,b,i} Y^{M+q} \\ \\boldsymbol{w}_{c,i}(Y) &amp;= -Y^i \\boldsymbol{Y}&#x27; + \\sum_{q=1}^Q \\boldsymbol{w}_{q,c,i} Y^{M+q} &amp; K(Y) &amp;= \\sum_{q=1}^Q K_q Y^{M+q} \\end{aligned}</span>$</p>

    <p class="text-gray-300">Then the circuit is satisfied if and only if</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot (\\boldsymbol{b}_{i} \\circ \\boldsymbol{Y}&#x27;) Y^{i} + \\sum_{i=1}^{m} \\boldsymbol{a}_{i} \\cdot \\boldsymbol{w}_{a,i}(Y) + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} \\cdot \\boldsymbol{w}_{b,i}(Y) + \\sum_{i=1}^{m} \\boldsymbol{c}_{i} \\cdot \\boldsymbol{w}_{c,i}(Y) - K(Y) = 0</span>$
(3)</p>

    <p class="text-gray-300">In the argument, the prover will commit to  <span class="math">a_i, b_i</span>  and  <span class="math">c_i</span> . The verifier will then issue a random challenge  <span class="math">y \\leftarrow \\mathbb{Z}_p^*</span>  and the prover will convince the verifier that the committed values satisfy Eq. 3, evaluated on y. If the committed values do not satisfy the polynomial equation, the probability the equality holds for a random y is negligible, so the prover is unlikely to be able to convince the verifier.</p>

    <h2 id="sec-10" class="text-2xl font-bold">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;5.1 Square Root Communication Argument</h2>

    <p class="text-gray-300">In order to show that (3) is satisfied, we craft a special Laurent polynomial t(X) in a second formal indeterminate X, whose constant coefficient is exactly twice the left-hand side of (3). Therefore, this polynomial will have zero constant term if and only if (3) is satisfied. In our argument this is proved using the polynomial commitment protocol of Section 3. We define</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\boldsymbol{r}(X) := \\sum_{i=1}^m \\boldsymbol{a}_i y^i X^i + \\sum_{i=1}^m \\boldsymbol{b}_i X^{-i} + X^m \\sum_{i=1}^m \\boldsymbol{c}_i X^i + \\boldsymbol{d} X^{2m+1} \\\\ &amp; \\boldsymbol{s}(X) := \\sum_{i=1}^m \\boldsymbol{w}_{a,i}(y) y^{-i} X^{-i} + \\sum_{i=1}^m \\boldsymbol{w}_{b,i}(y) X^i + X^{-m} \\sum_{i=1}^m \\boldsymbol{w}_{c,i}(y) X^{-i} \\\\ &amp; \\boldsymbol{r}&#x27;(X) := \\boldsymbol{r}(X) \\circ \\boldsymbol{y}&#x27; + 2\\boldsymbol{s}(X) \\\\ &amp; \\boldsymbol{t}(X) := \\boldsymbol{r}(X) \\cdot \\boldsymbol{r}&#x27;(X) - 2K(y) \\end{split}</span>$</p>

    <p class="text-gray-300">Here y' is the vector Y' evaluated at y, and d is a blinding vector consisting of random scalars that the prover commits to in the first round. In the square root argument the prover will reveal r(x) for a randomly chosen challenge  <span class="math">x \\in \\mathbb{Z}_p^*</span> , and the blinding vector d ensures that we can reveal r(x) without leaking information about  <span class="math">a_i, b_i</span>  and  <span class="math">c_i</span> . We also observe that s(x) is efficiently computable from public information about the circuit and the challenges.</p>

    <p class="text-gray-300">We have designed these polynomials such that the constant term of  <span class="math">\\mathbf{r} \\cdot (\\mathbf{r} \\circ \\mathbf{y}&#x27;)</span>  is equal to  <span class="math">2 \\sum_{i=1}^{m} \\mathbf{a}_i \\cdot (\\mathbf{b}_i \\circ \\mathbf{y}&#x27;) y^i</span>  and the constant term of  <span class="math">\\mathbf{r} \\cdot \\mathbf{s}</span>  is equal to  <span class="math">\\sum_{i=1}^{m} \\mathbf{a}_i \\cdot \\mathbf{w}_{a,i}(y) + \\sum_{i=1}^{m} \\mathbf{b}_i \\cdot \\mathbf{w}_{b,i}(y) + \\sum_{i=1}^{m} \\mathbf{c}_i \\cdot \\mathbf{w}_{c,i}(y)</span> . We conclude that the constant term of t(X) is exactly twice the left-hand side of (3), and is therefore zero if and only if the circuit is satisfied.</p>

    <p class="text-gray-300">We are now in a position to describe an argument with square root communication complexity.</p>

    <p class="text-gray-300">The prover first commits to vectors  <span class="math">a_i, b_i, c_i</span>  and d and the verifier replies with a challenge  <span class="math">y \\leftarrow \\mathbb{Z}_p^*</span> . The prover computes t(X) and commits to it by using the algorithm PolyCommit defined in Section 3. Then, the verifier sends a random challenge  <span class="math">x \\leftarrow \\mathbb{Z}_p^*</span>  and the prover responds by revealing r(x) and blinded openings pe of t(X) obtained by running algorithm PolyEval as described in Section 3.</p>

    <p class="text-gray-300">The verifier first checks that r(x) is consistent with the previously sent commitments of  <span class="math">a_i, b_i, c_i</span>  and d using the homomorphic properties of the commitment scheme. She also computes s(x), r'(x) and K. Then, she computes v = t(x) using the PolyVerify algorithm of Section 3, and checks if  <span class="math">v = r(x) \\cdot r&#x27;(x) - 2K</span> . The verifier accepts the argument if both checks are satisfied.</p>

    <p class="text-gray-300">As described so far, the argument requires communicating O(m) group elements and O(n) field elements, so setting  <span class="math">m \\approx n</span>  leads to square root communication. The argument improves on [Gro09b, Seo11] by requiring only 5 moves without computational overhead and significantly reduces the computational complexity. However, breaking this ostensible square root communication barrier requires new ideas that we describe in the next section.</p>

    <h2 id="sec-11" class="text-2xl font-bold">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;5.2 Breaking the Square Root Barrier</h2>

    <p class="text-gray-300">The square root complexity argument described above was designed so that the verifier uses  <span class="math">\\mathbf{r} = \\mathbf{r}(x)</span>  to check the inner product  <span class="math">v = \\mathbf{r} \\cdot \\mathbf{r}&#x27; - 2K</span> , where v is the evaluation of a committed polynomial at x. Sending  <span class="math">\\mathbf{r}</span>  has a cost of n field elements. In order to break the square root barrier we try to avoid sending  <span class="math">\\mathbf{r}</span>  directly so that we can then let n be larger and m be smaller and thus globally lower the communication of the argument.</p>

    <p class="text-gray-300">Rather than sending r to the verifier, the prover could instead send commitments to r and r', and use our inner product argument to show that v + 2K was a correctly formed inner product. In fact, the prover does not even need to send commitments to r and r'! The verifier can compute a commitment to r(x) directly from  <span class="math">A_i, B_i, C_i</span>  and D, the commitments to  <span class="math">a_i, b_i, c_i</span>  and d which were previously used to check that r is correctly formed</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Com}_{ck}(\\boldsymbol{r};0) = \\operatorname{Com}_{ck}(0;-\\rho) \\left[ \\prod_{i=1}^m A_i^{x^i y^i} \\right] \\left[ \\prod_{i=1}^m B_i^{x^{-i}} \\right] \\left[ \\prod_{i=1}^m C_i^{x^{m+i}} \\right] D^{x^{2m+1}} = \\boldsymbol{g^r}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\rho</span>  is an appropriate randomness value, which is sent by the prover to the verifier, and the vector  <span class="math">\\mathbf{g} = (g_1, \\dots, g_n)</span>  for a given commitment key  <span class="math">ck = (\\mathbb{G}, p, g, g_1, \\dots, g_n)</span> .</p>

    <p class="text-gray-300">As for a commitment to r', we observe that the Pedersen commitment, besides its well-known homomorphic properties with respect to the message and the randomness, also has the useful property that it is homomorphic with respect to the commitment key. Specifically, let  <span class="math">\\mathbf{h} = (g_1^{y^{-m}}, \\ldots, g_n^{y^{-mn}})</span> , so that  <span class="math">\\mathbf{g}^r = \\mathbf{h}^{r \\circ y&#x27;}</span> . Multiplying  <span class="math">\\mathbf{g}^r</span>  by  <span class="math">\\mathbf{h}^{2s}</span> , the verifier obtains  <span class="math">\\mathrm{Com}_{ck&#x27;}(r&#x27;;0) = \\mathbf{h}^{r&#x27;}</span> , with respect to the new commitment key ck' which uses  <span class="math">\\mathbf{h}</span>  instead of  <span class="math">\\mathbf{g}</span> . We note that  <span class="math">\\mathbf{h}</span>  and  <span class="math">\\mathbf{s} = \\mathbf{s}(x)</span>  can be computed by the verifier.</p>

    <p class="text-gray-300">Now the prover and verifier can run the inner product argument with statement</p>

    <p class="text-gray-300"><span class="math">$(\\mathbb{G}, p, \\boldsymbol{g}, r, \\boldsymbol{h}, r&#x27;, v + 2K, m_{\\mu}, m_{\\mu-1}, \\dots, m_{1}) \\quad \\text{where}</span>$</p>

    <p class="text-gray-300"><span class="math">$ck = (\\mathbb{G}, p, g, \\boldsymbol{g}) \\qquad n = m_{\\mu} m_{\\mu-1} \\cdots m_{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{g} = (g_{1}, g_{2}, \\dots, g_{n}) \\qquad \\boldsymbol{h} = (g_{1}^{y^{-m}}, g_{2}^{y^{-2m}}, \\dots, g_{n}^{y^{-mn}})</span>$</p>

    <p class="text-gray-300"><span class="math">$R = \\operatorname{Com}_{ck}(0; -\\rho) \\left[ \\prod_{i=1}^{m} A_{i}^{x^{i}y^{i}} \\right] \\left[ \\prod_{i=1}^{m} B_{i}^{x^{-i}} \\right] \\left[ \\prod_{i=1}^{m} C_{i}^{x^{m+i}} \\right] D^{x^{2m+1}} = \\boldsymbol{g}^{\\boldsymbol{r}}</span>$</p>

    <p class="text-gray-300"><span class="math">$R&#x27; = R \\cdot \\boldsymbol{h}^{2s} = \\boldsymbol{h}^{\\boldsymbol{r}&#x27;}</span>$</p>

    <p class="text-gray-300">and the prover's witness is r, r'.</p>

    <p class="text-gray-300">The values of  <span class="math">m_{\\mu}, \\dots, m_1</span>  can be chosen according to the desired efficiency of the circuit satisfiability argument.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">5.3 Formal Description</h4>

    <p class="text-gray-300">We now give the formal description of the above arguments of knowledge for the satisfiability of an arithmetic circuit C. Both prover and verifier take the move parameter  <span class="math">\\mu</span>  as common input. For square root communication complexity, the inner product argument is not used and we set  <span class="math">\\mu=0</span> . For  <span class="math">\\mu&gt;0</span> , the common input includes the values  <span class="math">(m_{\\mu},\\ldots,m_1)</span>  used in the inner product argument. The description of the arithmetic circuit C is given as a number N of multiplication gates and the values  <span class="math">\\mathbf{w}_{q,a,i},\\mathbf{w}_{q,b,i},\\mathbf{w}_{q,c,i}</span> , which specify linear consistency constraints between the input and output values of the multiplication gates.</p>

    <p class="text-gray-300"><strong>Common Input:</strong>  <span class="math">(ck, C, N, m, n, m&#x27;_1, m&#x27;_2, n&#x27;, m_\\mu, \\dots, m_1, \\mu)</span>  where ck is a commitment key, C is the description of an arithmetic circuit with N = mn multiplication gates,  <span class="math">\\mu</span>  is the move parameter and  <span class="math">n = m_\\mu \\cdots m_1</span> . Parameters  <span class="math">(m&#x27;_1, m&#x27;_2, n&#x27;)</span>  are set to satisfy both  <span class="math">3m \\le m&#x27;_1 n&#x27;</span>  and  <span class="math">4m + 2 \\le m&#x27;_2 n&#x27;</span> .</p>

    <p class="text-gray-300"><strong>Prover's Witness:</strong> Satisfying assignments  <span class="math">a_i, b_i</span>  and  <span class="math">c_i</span>  to the wires of C. Argument:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\to \\mathbf{V}</span> : Pick randomness  <span class="math">\\alpha_1, \\beta_1, \\gamma_1, \\dots, \\alpha_m, \\beta_m, \\gamma_m, \\delta \\leftarrow \\mathbb{Z}_p</span>  and blinding vector  <span class="math">\\mathbf{d} \\leftarrow \\mathbb{Z}_p^n</span> . Compute for  <span class="math">i \\in \\{1, \\dots, m\\}</span></p>

    <p class="text-gray-300"><span class="math">$A_i = \\text{Com}(\\boldsymbol{a}_i; \\alpha_i)</span>$
<span class="math">B_i = \\text{Com}(\\boldsymbol{b}_i; \\beta_i)</span>   <span class="math">C_i = \\text{Com}(\\boldsymbol{c}_i; \\gamma_i)</span>   <span class="math">D = \\text{Com}(\\boldsymbol{d}; \\delta)</span> .</p>

    <p class="text-gray-300">Send to the verifier  <span class="math">A_1, B_1, C_1, \\ldots, A_m, B_m, C_m, D</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\leftarrow \\mathbf{V}: \\ y \\leftarrow \\mathbb{Z}_p^*.</span></p>

    <p class="text-gray-300">As argued before, the circuit determines vectors of polynomials  <span class="math">\\boldsymbol{w}_{a,i}(Y)</span> ,  <span class="math">\\boldsymbol{w}_{b,i}(Y)</span> ,  <span class="math">\\boldsymbol{w}_{c,i}(Y)</span>  and K(Y) such that C is satisfiable if and only if</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^m \\boldsymbol{a}_i \\cdot (\\boldsymbol{b}_i^T \\circ \\boldsymbol{Y}&#x27;) Y^i + \\sum_{i=1}^m \\boldsymbol{a}_i \\cdot \\boldsymbol{w}_{a,i}(Y) + \\sum_{i=1}^m \\boldsymbol{b}_i \\cdot \\boldsymbol{w}_{b,i}(Y) + \\sum_{i=1}^m \\boldsymbol{c}_i \\cdot \\boldsymbol{w}_{c,i}(Y) = K(Y)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{Y}&#x27; = (Y^m, \\dots, Y^{mn})</span> . Given y, both the prover and verifier can compute K = K(y),  <span class="math">\\mathbf{w}_{a,i} = \\mathbf{w}_{a,i}(y)</span> ,  <span class="math">\\mathbf{w}_{b,i} = \\mathbf{w}_{b,i}(y)</span>  and  <span class="math">\\mathbf{w}_{c,i} = \\mathbf{w}_{c,i}(y)</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\to \\mathbf{V}</span> : Compute Laurent polynomials r, s, r', which have vector coefficients, and Laurent polynomial t, in the indeterminate X</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\boldsymbol{r}(X) = \\sum_{i=1}^{m} \\boldsymbol{a}_{i} y^{i} X^{i} + \\sum_{i=1}^{m} \\boldsymbol{b}_{i} X^{-i} + X^{m} \\sum_{i=1}^{m} \\boldsymbol{c}_{i} X^{i} + \\boldsymbol{d} X^{2m+1} \\\\ &amp; \\boldsymbol{s}(X) = \\sum_{i=1}^{m} \\boldsymbol{w}_{a,i} y^{-i} X^{-i} + \\sum_{i=1}^{m} \\boldsymbol{w}_{b,i} X^{i} + X^{-m} \\sum_{i=1}^{m} \\boldsymbol{w}_{c,i} X^{-i} \\\\ &amp; \\boldsymbol{r}&#x27;(X) = \\boldsymbol{r}(X) \\circ \\boldsymbol{y}&#x27; + 2\\boldsymbol{s}(X) \\\\ &amp; \\boldsymbol{t}(X) = \\boldsymbol{r}(X) \\cdot \\boldsymbol{r}&#x27;(X) - 2K = \\sum_{k=-3m}^{4m+2} t_{k} X^{k} \\end{split}</span>$</p>

    <p class="text-gray-300">When the wires  <span class="math">a_i, b_i, c_i</span>  correspond to a satisfying assignment, the Laurent polynomial t(X) will have constant term  <span class="math">t_0 = 0</span> .</p>

    <p class="text-gray-300">Commit to t(X) by running</p>

    <p class="text-gray-300"><span class="math">$(pc, st) \\leftarrow PolyCommit(ck, m&#x27;_1, m&#x27;_2, n&#x27;, t(X))</span>$</p>

    <p class="text-gray-300">Send pc to the verifier.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\leftarrow \\mathbf{V}: \\ x \\leftarrow \\mathbb{Z}_p^*</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P} \\to \\mathbf{V}</span> : Compute PolyEval( <span class="math">\\mathsf{st}, x</span> )  <span class="math">\\to \\mathsf{pe}</span> , and</p>

    <p class="text-gray-300"><span class="math">$r = \\sum_{i=1}^{m} a_i x^i y^i + \\sum_{i=1}^{m} b_i x^{-i} + x^m \\sum_{i=1}^{m} c_i x^i + dx^{2m+1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\rho = \\sum_{i=1}^{m} \\alpha_i x^i y^i + \\sum_{i=1}^{m} \\beta_i x^{-i} + x^m \\sum_{i=1}^{m} \\gamma_i x^i + \\delta x^{2m+1}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\mu = 0</span> : the inner product argument is not used. The prover sends  <span class="math">(\\mathsf{pe}, r, \\rho)</span>  to the verifier.</li>
      <li>If  <span class="math">\\mu &gt; 0</span> : the inner product argument is used. The prover computes r' = r'(x) and sends  <span class="math">(pe, \\rho)</span>  to the verifier.</li>
    </ul>

    <p class="text-gray-300">Verification: First, the verifier computes</p>

    <p class="text-gray-300">PolyVerify
<span class="math">$(ck, m&#x27;_1, m&#x27;_2, n&#x27;, \\mathsf{pc}, \\mathsf{pe}, x) \\to v</span>$</p>

    <p class="text-gray-300">and rejects the argument if  <span class="math">v = \\bot</span> .</p>

    <p class="text-gray-300">• If  <span class="math">\\mu = 0</span> : the inner product argument is not used. The verifier computes  <span class="math">r&#x27; = r \\circ y&#x27; + 2s(x)</span> , and accepts only if</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp; \\boldsymbol{r} \\cdot \\boldsymbol{r}&#x27; - 2K &amp;= v \\\\ &amp; \\operatorname{Com}_{ck}(\\boldsymbol{r}; \\rho) = \\left[ \\prod_{i=1}^{m} A_i^{x^i y^i} \\right] \\left[ \\prod_{i=1}^{m} B_i^{x^{-i}} \\right] \\left[ \\prod_{i=1}^{m} C_i^{x^{m+i}} \\right] D^{x^{2m+1}} \\end{aligned}</span>$</p>

    <p class="text-gray-300"><span class="math">\\bullet</span>  If  <span class="math">\\mu&gt;0</span>  : prover and verifier run the inner product argument with common input</p>

    <p class="text-gray-300"><span class="math">$(\\mathbb{G}, p, \\mathbf{g}, R, \\mathbf{h}, R&#x27;, v + 2K, m_{\\mu}, m_{\\mu-1}, \\dots, m_1)</span>$
where</p>

    <p class="text-gray-300"><span class="math">$ck = (\\mathbb{G}, p, g, \\mathbf{g}) \\qquad n = m_{\\mu} m_{\\mu-1} \\cdots m_{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{g} = (g_{1}, g_{2}, \\dots, g_{n}) \\qquad \\mathbf{h} = (g_{1}^{y^{-m}}, g_{2}^{y^{-2m}}, \\dots, g_{n}^{y^{-mn}})</span>$</p>

    <p class="text-gray-300"><span class="math">$R = \\operatorname{Com}_{ck}(0; -\\rho) \\left[ \\prod_{i=1}^{m} A_{i}^{x^{i}y^{i}} \\right] \\left[ \\prod_{i=1}^{m} B_{i}^{x^{-i}} \\right] \\left[ \\prod_{i=1}^{m} C_{i}^{x^{m+i}} \\right] D^{x^{2m+1}} = \\mathbf{g}^{\\mathbf{r}}</span>$</p>

    <p class="text-gray-300"><span class="math">$R&#x27; = R \\cdot \\mathbf{h}^{2\\mathbf{s}(x)} = \\mathbf{h}^{\\mathbf{r}&#x27;}</span>$</p>

    <p class="text-gray-300">and the prover's witness is r and r'.</p>

    <p class="text-gray-300">The verifier accepts if the inner product argument is accepting.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Security Analysis.</h4>

    <p class="text-gray-300"><strong>Theorem 3.</strong> The argument for satisfiability of an arithmetic circuit has perfect completeness, perfect special honest verifier zero-knowledge and statistical witness-extended emulation for extracting either a breach of the binding property of the commitment scheme or a witness for the satisfiability of the circuit.</p>

    <p class="text-gray-300"><em>Proof.</em> Perfect completeness follows by inspection and using the fact that the polynomial commitment protocol and inner product argument also have perfect completeness.</p>

    <p class="text-gray-300">For perfect special honest verifier zero-knowledge we are given  <span class="math">y, x \\in \\mathbb{Z}_p^*</span> , which allows us to compute  <span class="math">\\boldsymbol{w}_{a,i}, \\boldsymbol{w}_{b,i}, \\boldsymbol{w}_{c,i}</span>  and K from the circuit. The simulator picks  <span class="math">\\boldsymbol{r} \\leftarrow \\mathbb{Z}_p^n</span>  and  <span class="math">\\rho \\leftarrow \\mathbb{Z}_p</span>  and random commitments  <span class="math">A_i, B_i</span>  and  <span class="math">C_i</span> . It computes</p>

    <p class="text-gray-300"><span class="math">$D = \\left[ \\prod_{i=1}^{m} A_i^{x^i y^i} B_i^{x^{-i}} C_i^{x^{m+i}} \\operatorname{Com}_{ck}(-\\boldsymbol{r}; -\\rho) \\right]^{-x^{-2m-1}} \\qquad v = \\boldsymbol{r} \\cdot \\boldsymbol{r}&#x27; - 2K</span>$</p>

    <p class="text-gray-300">and simulates pc and pe from the polynomial commitment protocol.</p>

    <p class="text-gray-300">To see that the simulated components have the same distribution as a real argument observe that since the commitment scheme is perfectly hiding the commitments  <span class="math">A_i, B_i</span>  and  <span class="math">C_i</span>  have the same distribution as in a real argument. Also, in both the simulation and a real argument  <span class="math">\\boldsymbol{r}</span>  and  <span class="math">\\rho</span>  are uniformly random. Given these values the commitment D is uniquely defined. Furthermore, since the polynomial commitment protocol is perfect special honest verifier zero-knowledge,  <span class="math">\\operatorname{pc}</span>  and  <span class="math">\\operatorname{pe}</span>  have the same distribution as in a real argument, conditioned on the value of v.</p>

    <p class="text-gray-300">When  <span class="math">\\mu &gt; 0</span>  we simply remove  <span class="math">\\boldsymbol{r}</span>  from the transcript and execute a fresh run of the inner product argument, given our knowledge of  <span class="math">\\boldsymbol{r}</span> .</p>

    <p class="text-gray-300">It remains to show that we have witness-extended emulation. We treat the cases  <span class="math">\\mu=0</span>  and  <span class="math">\\mu&gt;0</span>  separately.</p>

    <p class="text-gray-300">Square Root Argument. Assume that we have N+Q different challenges  <span class="math">y\\in\\mathbb{Z}_p^*</span>  for the same initial message, and for each of these challenges a further 7m+3 different challenges  <span class="math">x\\in\\mathbb{Z}_p^*</span>  for the same third message, all with valid answers. We begin by showing that from this information we either extract a satisfying assignment to the wires  <span class="math">a_i, b_i, c_i</span>  in the circuit, or encounter a breach of the binding property of the commitment scheme.</p>

    <p class="text-gray-300">Let us first consider a fixed initial transcript  <span class="math">(A_1,\\ldots,A_m,\\ldots,C_m,D,y,\\operatorname{pc})</span>  and suppose we have valid arguments with 3m+2 different values of x. Then the vectors  <span class="math">(x^{-m},\\ldots,x^{2m+1})</span>  form the rows of a shifted Vandermonde matrix and we can obtain any unit vector  <span class="math">(0,\\ldots,1,\\ldots,0)</span>  by taking an appropriate linear combination of these vectors. By taking the correct linear combinations of the 3m+2 verification equations  <span class="math">D^{x^{2m+1}}\\prod_{i=1}^m A_i^{x^iy^i}B_i^{x^{-i}}C_i^{x^{m+i}}=\\operatorname{Com}_{ck}(\\boldsymbol{r};\\rho)</span> , we can then extract openings to each  <span class="math">A_i,B_i</span>  and  <span class="math">C_i</span> , since  <span class="math">y\\in\\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">We have valid arguments for  <span class="math">(m&#x27;_1 + m&#x27;_2)n&#x27; + 1 = 7m + 3</span>  different challenges  <span class="math">x \\in \\mathbb{Z}_p^*</span> . By the proof of Theorem 1 this implies that there exists a Laurent</p>

    <p class="text-gray-300">polynomial  <span class="math">t(X) = \\sum_{i=-n&#x27;m&#x27;_1}^{n&#x27;m&#x27;_2} t_i x^i</span>  with constant term  <span class="math">t_0 = 0</span>  that is consistent with respect to all 3m + 2 evaluations of  <span class="math">\\mathbf{r}(X) \\cdot \\mathbf{r}&#x27;(X) - 2K</span> . This directly implies that Equation 3 holds for Y = y.</p>

    <p class="text-gray-300">Finally, suppose that this holds for N+Q different challenges  <span class="math">y\\in\\mathbb{Z}_p^*</span> . Then, we have equality of polynomials in Equation 3, since a non-zero polynomial of degree N+Q-1 cannot have N+Q roots. This means that the circuit is satisfied.</p>

    <p class="text-gray-300">Now we can apply the forking lemma to get witness-extended emulation, as the tree formed by the transcripts has size  <span class="math">(N+Q)\\cdot(7m+3)</span>  which is polynomial in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Inner Product Variant Assume that we have  <span class="math">(N+Q)\\cdot(7m+3)\\cdot(2m_{\\mu}-1)\\dots(2m_2-1)</span>  accepting transcripts for the same statement arranged in a tree as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The root is labeled with the statement.</li>
      <li>Each of the (N+Q) depth 1 nodes is labeled with a different challenge y and has 7m+3 children labeled x.</li>
      <li>The children are subtrees of size  <span class="math">(2m_{\\mu}-1)\\dots(2m_2-1)</span></li>
      <li>Each level has nodes labeled with the challenges  <span class="math">x_i</span>  used in the <em>i</em>-th move of the recursive argument, and of degree  <span class="math">2m_{\\mu-i+1}-1</span> .</li>
    </ul>

    <p class="text-gray-300">Given the above tree of transcripts, we are able to do a two-stage extraction: First, we invoke the witness-extended emulation of the recursive inner product argument. At this point, we either have a non-trivial discrete logarithm relation, in which case we are done, or we have an accepting  <span class="math">\\boldsymbol{r}</span>  for each y,x pair. In this case, we proceed with the second stage and repeat the extraction procedure for  <span class="math">\\mu=0</span>  to obtain either a witness for the original statement or a breach of the binding property of the commitment scheme.</p>

    <p class="text-gray-300">We now point out that the size of the tree will be  <span class="math">O(N \\cdot (2m)^{\\mu}) \\approx O(N^{2 + \\log_m 2})</span>  which is polynomial in the security parameter  <span class="math">\\lambda</span>  and invoke the forking lemma to complete the proof.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">Square Root Communication. When we set  <span class="math">\\mu=0</span> , the argument above has a communication cost of  <span class="math">m&#x27;_1+m&#x27;_2+2+1+3m</span>  commitments and n+n'+2 field elements. Setting  <span class="math">m\\approx\\sqrt{\\frac{N}{3}},\\ n\\approx\\sqrt{3N},\\ n&#x27;\\approx\\sqrt{7m},\\ m&#x27;_1\\approx3\\sqrt{\\frac{m}{7}}</span>  and  <span class="math">m&#x27;_2\\approx4\\sqrt{\\frac{m}{7}}</span>  we get a total communication complexity where the total number of group and field elements sent is as low as possible and approximately  <span class="math">2\\sqrt{N}</span>  each. The main computational cost for the prover is computing the initial commitments, corresponding to  <span class="math">\\frac{3mn}{\\log n}</span>  group exponentiations. The prover can compute t(X) using FFT-based techniques. Assuming that p is of a suitable form [Can89], the dominant number of multiplications for this process is  <span class="math">\\frac{3}{2}mn\\log m</span> . The main cost in the verification is computing s(X) given the description of the circuit which requires in the worst case Qn multiplications in  <span class="math">\\mathbb{Z}_p</span> , considering arbitrary fan-in</p>

    <p class="text-gray-300">addition gates. In case of O(N)-size circuits with fan-in 2 gates, computing s(X) requires O(N) multiplications. Evaluating s(x) requires 3N multiplications. The last verification equation costs roughly  <span class="math">\\frac{(n+3m)}{\\log n+3m}</span>  group exponentiations to the verifier.</p>

    <p class="text-gray-300"><span class="math">(\\mu+1)</span> -Root Communication. We can reduce communication by using  <span class="math">\\mu=O(1)</span>  iterations of the inner product argument. Choosing  <span class="math">m=N^{\\frac{1}{\\mu+1}}</span> ,  <span class="math">n=N^{\\frac{\\mu}{\\mu+1}}</span>  and  <span class="math">m_i=(\\frac{N}{m})^{\\frac{1}{\\mu}}</span>  will give us a communication complexity of  <span class="math">4\\mu N^{\\frac{1}{\\mu+1}}</span>  group elements and  <span class="math">2\\mu N^{\\frac{1}{\\mu+1}}</span>  field elements. The prover's complexity is dominated by  <span class="math">\\frac{6\\mu N}{\\log N}</span>  group exponentiations and fewer than  <span class="math">\\frac{3N}{2\\mu}\\log N</span>  field multiplications. The verifier's cost is dominated by  <span class="math">\\frac{2\\mu N}{\\log N}</span>  group exponentiations and O(N) field multiplications.</p>

    <p class="text-gray-300">Logarithmic Communication. By increasing the number of iteration of the inner product argument we can further reduce the communication complexity.</p>

    <p class="text-gray-300">To minimize the communication, we set  <span class="math">\\mu = \\log N - 1</span> ,  <span class="math">n = \\frac{N}{2}</span> ,  <span class="math">m = m_i = 2</span> ,  <span class="math">m&#x27;_1 = 2</span> ,  <span class="math">m&#x27;_2 = 3</span>  and n' = 4 in the above argument gives us  <span class="math">2 \\log N + 1</span>  moves. The total communication amounts to  <span class="math">4 \\log N + 7</span>  group elements and  <span class="math">2 \\log N + 6</span>  field elements. The prover computational cost is dominated by 12N group exponentiations, and O(N) multiplications in  <span class="math">\\mathbb{Z}_p</span> . The main verification cost is bounded by 4N group exponentiations and O(N) multiplications in  <span class="math">\\mathbb{Z}_p</span> .</p>

    <p class="text-gray-300">Alternatively, we can optimize the computation while maintaining logarithmic communication by setting  <span class="math">\\mu = \\log N - \\log \\log 2N</span> ,  <span class="math">m = \\log N</span> ,  <span class="math">n = \\frac{N}{\\log N}</span> ,  <span class="math">n&#x27; \\approx \\sqrt{7\\log N}</span> ,  <span class="math">m_1&#x27; \\approx 3\\sqrt{\\frac{\\log N}{7}}</span> ,  <span class="math">m_2&#x27; \\approx 4\\sqrt{\\frac{\\log N}{7}}</span> ,  <span class="math">m_i = 2</span>  for  <span class="math">1 \\le i \\le \\mu</span> . In this way we obtain a  <span class="math">2\\log N - 2\\log\\log N + 1</span>  moves argument. With respect to the previous settings, we now save  <span class="math">2\\log\\log N</span>  moves by starting the inner product argument with a smaller statement. The resulting communication is at most  <span class="math">7\\log N + \\sqrt{7\\log N}</span>  group elements and at most  <span class="math">2\\log N + \\sqrt{7\\log N}</span>  field elements. Thus, the prover computation is dominated by  <span class="math">\\frac{3N}{\\log N}</span>  group exponentiations and  <span class="math">11N\\log\\log N</span>  field multiplications. For the verifier, it is bounded from above by  <span class="math">\\frac{4N}{\\log N\\log\\log N}</span>  group exponentiations and O(N) field multiplications.</p>

    <p class="text-gray-300">To verify the practicality of our construction we produced a proof of concept implementation in Python using the NumPy [Oli06] package. The more costly operations are executed natively: we use Petlib [Dan15] to outsource elliptic curve operations to the OpenSSL library, and also use a small C++ program to calculate the polynomial multiplication producing t(X) using NTL [Sho01]. Our implementation is single-threaded, but the operations performed are easily parallelisable.</p>

    <p class="text-gray-300">Our implementation accepts the circuit description format used by Pinocchio [PHGR13], which it preprocesses to remove addition and multiplication by constant gates, encoding them as a constraint tableas in Appendix A. Pinocchio</p>

    <p class="text-gray-300">also supports split gates, taking as input a single arithmetic wire and producing a fixed number of binary wires as outputs, so the binary wires correspond to the binary representation of the arithmetic wire. We handle split gates by adding appropriate multiplication gates and constraints to ensure binary wires can only carry zeroes or ones, and that their values scaled by the appropriate powers of 2 sum up to the gate's input.</p>

    <p class="text-gray-300"><strong>Performance Comparison.</strong> We compared the performance of our implementation to that of Pinocchio [PHGR13] for a set of circuits produced by Pinocchio's toolchain. The circuits implement multiplication of a vector by a fixed matrix, multiplication of two matrices, evaluation of a multivariate polynomial, and other applications for which we refer to [PHGR13]. We used an i5-4690K running Pinocchio under Windows 10 and our software under Ubuntu 14.04 for the tests.</p>

    <p class="text-gray-300">We note here that Pinocchio operates in a pairing-based setting, using knowledge of exponent assumptions, whereas we operate in the discrete log setting. Even so, we feel the comparison is meaningful, as we are not aware of previous implementations of circuit-evaluation arguments in our setting.</p>

    <p class="text-gray-300">From the comparison in Table 2, it is clear that our implementation is extremely competitive in terms of prover computation, with the square root version outperforming Pinocchio by a factor larger than 10 for some applications. There is a significant amount of variance in terms of the speedups achieved. The worst cases are those where the number of constraints is high in comparison with the number of multiplication gates: the calculation of s(X) is performed entirely in Python and thus becomes the dominant term in the computation. We expect that in a fully compiled implementation, optimisation would prevent this issue.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">This work</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Pinocchio</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Square Root</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Logarithmic</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(Constant)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Application</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mult.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proof</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proof</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proof</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gates</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gen</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Prove</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gen</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Prove</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gen</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Prove</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">В</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">В</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">В</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">В</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">В</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">S</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">В</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Vector Matrix</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.07</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.38</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.03</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3872</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3552</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.023</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Product</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1440</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.76</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.06</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6464</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.67</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3744</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.93</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.5M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.53</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.035</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Matrix</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">347K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">618K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5792</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">97.9M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">167.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.201</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Product</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1343K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.2M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">187.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6496</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">170.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">374.8 \\mathrm{M}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">706.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.503</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Polynomial</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">203K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">88K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">383K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5440</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55.9M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">146.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Evaluation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">571K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">97.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">962 \\mathrm{K}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">164.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6272</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">156.8\\mathrm{M}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">422.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Image</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">86K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.6M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Matching</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">278K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">490\\mathrm{K}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5920</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">75.8M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">88.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Shortest</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">366K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">644K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5792</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">99.6M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">130.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.015</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Paths</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1400K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.2M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">169.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6496</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">177.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">381.4\\mathrm{M}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">523.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.026</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gas</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">144K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">271K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5440</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39.6M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simulation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">283K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">160 \\mathrm{K}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">503K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5920</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">77.7M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">103.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4992</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.5M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.007</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-31-0&quot;&gt;&lt;/span&gt;<strong>Table 2.</strong> Performance comparison between our implementation and Pinocchio. Pinocchio was set to use public verifiability and zero-knowledge.</p>

    <p class="text-gray-300">The logarithmic communication version is slower in comparison but still outperforms Pinocchio for most applications. The performance also becomes more even, as the constraints are irrelevant in the recursive part.</p>

    <p class="text-gray-300">Our verification times are much higher than Pinocchio's, which can often verify circuit evaluation faster than native execution of an equivalent program. As with the prover, some speedups can be gained by moving to a compiled language, but we would still not expect to match Pinocchio's performance; our verification cost would still be linear. Our proofs are considerably larger as well, especially for the square root version.</p>

    <p class="text-gray-300">Our key generation is simply a commitment key generation, and is not application-specific. Therefore, it can be easily amortised even across different circuits. For a circuit with N multiplication gates, the size of our commitment key is  <span class="math">\\sqrt{N}</span>  elements for the square root version and  <span class="math">\\frac{N}{\\log N}</span>  for the log version. In comparison, Pinocchio's key generation is bound to specific circuits and produces keys of size 8N. Thus, if the keys need to be communicated, our arguments are competitive in terms of total communication if the number of circuit evaluations is up to  <span class="math">\\sqrt{N}</span>  for the square root version, and up to  <span class="math">\\frac{N}{\\log N}</span>  for the log version.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-33-0&quot;&gt;&lt;/span&gt;A Arithmetic Circuits</h4>

    <p class="text-gray-300">Our satisfiability arguments consider arithmetic circuits described as a list of multiplication gates together with a set of linear consistency equations relating the inputs and outputs of the gates. In this section, we show how to reduce an arbitrary arithmetic circuit to this format.</p>

    <p class="text-gray-300">An arithmetic circuit over a field  <span class="math">\\mathbb{Z}_p</span>  and variables  <span class="math">(a_1, \\ldots, a_m)</span>  is a directed acyclic graph whose vertices are called gates. Gates of in-degree 0 are inputs to the circuit and labelled with some  <span class="math">a_i</span>  or a constant field element. All other gates are labelled + or  <span class="math">\\times</span> . We may consider fan-in 2 circuits, in which case all of the + and  <span class="math">\\times</span>  gates have in-degree 2, or arbitrary fan-in circuits.</p>

    <p class="text-gray-300">Arithmetic circuits can be described alternatively as a list of multiplication gates with a collection of linear consistency equations relating the inputs and outputs of the gates. Our zero-knowledge protocols for circuit satisfiability use circuits in this form. Any circuit described as an acyclic graph can be efficiently converted into the alternative description.</p>

    <p class="text-gray-300">We show how to remove addition and multiplication-by-constant gates from an arithmetic circuit A, and replace them with bilinear consistency equations on the inputs and outputs of the remaining gates, such that satisfiability of the equations is equivalent to satisfiability in the original circuit.</p>

    <p class="text-gray-300">Let B be the sub-circuit of A containing all wires and gates before a multiplication gate, with m input wires and n output wires. Label the m inputs of B with the unit vectors  <span class="math">\\mathbf{e}_i = (0, \\dots, 1, \\dots, 0)</span>  of length m. For every addition gate with inputs labelled as  <span class="math">\\mathbf{x}, \\mathbf{y}</span> , label the output wire as  <span class="math">\\mathbf{x} + \\mathbf{y}</span> . For every multiplication-by-constant gate with inputs  <span class="math">\\mathbf{x}</span>  and constant c label the output with  <span class="math">c\\mathbf{x}</span> . By proceeding inductively, the n outputs of B are now labelled with vectors of length m representing them as linear combinations of the inputs.</p>

    <p class="text-gray-300">This requires at most m|B| arithmetic operations. Note however that all outputs of B are linear combinations of the inputs, and that B can be written with n(2m-1) fan-in 2 gates in such a way that the consistency equations can be trivially read off from the circuit description. More specifically, a linear combination  <span class="math">\\sum_{i=1}^{m} a_i x_i</span>  can be produced using m multiplication-by-constant gates and m-1 addition gates to add the answers together.</p>

    <p class="text-gray-300">We can now remove the gates of B from A. We also remove any multiplication gates whose inputs are the inputs of the new circuit. Now we simply repeat the process of finding consistency equations until we have considered the whole of A. In Figure 1 there is an example of a circuit together and the corresponding consistency equations.</p>

    <p class="text-gray-300">The first (input) and final (output) sub-circuits require additional processing. We show how to do this for the output sub-circuit. The input sub-circuit is very similarly handled.</p>

    <p class="text-gray-300">Let B be the output sub-circuit. Write  <span class="math">(a_1, \\ldots, a_m) = \\mathbf{a}</span>  for the input wires of B and  <span class="math">(b_1, \\ldots, b_n) = \\mathbf{b}</span>  for the output wires. Without loss of generality, we may ignore variable output wires. By construction of B, each output  <span class="math">b_i</span>  is of the form  <span class="math">\\sum_{i=1}^{n} q_{ij}a_j + p_i</span> , with consistency equations obtained as above. We write</p>

    <p class="text-gray-300">    <img src="_page_34_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-1&quot;&gt;&lt;/span&gt;<strong>Fig. 1.</strong> A simple arithmetic circuit, and the corresponding consistency equations. The first sub-circuit contains the wires  <span class="math">a_1, b_1, c_1, a_2, b_2, c_2, a_3, a_3, c_3</span> . The second sub-circuit contains the wires  <span class="math">c_1, a_4, c_2, b_4, c_4, c_5, c_6</span> . The third sub-circuit B contains the wires  <span class="math">c_3, c_4, a_5, b_5, a_6</span> .</p>

    <p class="text-gray-300">this in terms of an  <span class="math">m \\times n</span>  matrix Q and a column vector  <span class="math">\\boldsymbol{p}</span>  of size m, namely</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{b} = Q\\boldsymbol{a} + \\boldsymbol{p}.</span>$</p>

    <p class="text-gray-300">Let r be the rank of Q. We convert Q into reduced row echelon form R, writing</p>

    <p class="text-gray-300"><span class="math">$b&#x27;&#x27; = Ra</span>$
.</p>

    <p class="text-gray-300">By the properties of reduced row echelon form, after relabelling the  <span class="math">a_i</span>  and permuting the columns of R to match, we have that  <span class="math">b_i&#x27;&#x27; = a_i + \\sum_{j=l+1}^m r_{ij}a_j</span>  for  <span class="math">1 \\leq i \\leq l</span> . Therefore, we may consider  <span class="math">a_{l+1}, \\ldots, a_m</span>  as free wires and express other  <span class="math">a_i</span>  as linear functions of these wires plus constants.</p>

    <p class="text-gray-300">Note that if  <span class="math">b_i&#x27;&#x27; \\neq 0</span>  for some i &gt; l, the circuit can never be satisfied anyway. However, assuming that our statement is a satisfiable circuit, with a witness consisting of satisfying wire values, this never occurs. Then the original circuit is satisfied if and only if the  <span class="math">a_i</span>  values satisfy the consistency equations.</p>

    <p class="text-gray-300">If Q is an  <span class="math">m \\times n</span>  matrix then it can be converted into reduced row echelon form using  <span class="math">O(\\max(m,n)mn)</span>  operations. It is trivial that  <span class="math">m \\leq 2 |B|</span>  and  <span class="math">n \\leq |B|</span> . This gives an upper bound of  <span class="math">O(|B|^3)</span>  computation for the output sub-circuit. Note that this is often a large over-estimate; this upper bound occurs for circuits of depth 1 where inputs feed into distinct gates. For circuits of large depth, where the same input is fed into several gates, the upper bound will definitely not be reached.</p>

    <p class="text-gray-300">The case of the input sub-circuit is very similar, except that we take the transpose of the matrix.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-0&quot;&gt;&lt;/span&gt;BCC88. Gilles Brassard, David Chaum, and Claude Crépeau. Minimum disclosure proofs of knowledge. <em>Journal of Computer and System Sciences</em>, 37(2):156–189, 1988.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-6&quot;&gt;&lt;/span&gt;BCCT12. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>Innovations in Theoretical Computer Science – ITCS 2012</em>, pages 326–349, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-8&quot;&gt;&lt;/span&gt;BCCT13. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In <em>Symposium on Theory of Computing Conference – TCC 2013</em>, pages 111–120, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-9&quot;&gt;&lt;/span&gt;BCG&lt;sup&gt;+&lt;/sup&gt;13. Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: verifying program executions succinctly and in Zero Knowledge. In <em>Advances in Cryptology – CRYPTO 2013</em>, pages 90–108, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-10&quot;&gt;&lt;/span&gt;BCTV14. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In <em>USENIX Security Symposium 2014</em>, pages 781–796, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-11&quot;&gt;&lt;/span&gt;BG12. Stephanie Bayer and Jens Groth. Efficient zero-knowledge argument for correctness of a shuffle. In <em>Advances in Cryptology – EUROCRYPT 2012</em>, pages 263–280, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-4&quot;&gt;&lt;/span&gt;BG13. Stephanie Bayer and Jens Groth. Zero-knowledge argument for polynomial evaluation with application to blacklists. In <em>Advances in Cryptology – EUROCRYPT 2013</em>, pages 646–663, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-13&quot;&gt;&lt;/span&gt;BR93. Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In <em>ACM conference on Computer and communications security – CCS 1993</em>, pages 62–73, 1993.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-14&quot;&gt;&lt;/span&gt;Can89. David G Cantor. On arithmetical algorithms over finite fields. <em>Journal of Combinatorial Theory, Series A</em>, 50(2):285–300, 1989.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-3&quot;&gt;&lt;/span&gt;CD98. Ronald Cramer and Ivan Damg˚ard. Zero-knowledge proofs for finite field arithmetic; or: Can zero-knowledge be for free? In <em>Advances in Cryptology – CRYPTO 1998</em>, pages 424–441, 1998.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-15&quot;&gt;&lt;/span&gt;Dan15. George Danezis. petlib: A python library that implements a number of privacy enhancing technologies (PETs), 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-1&quot;&gt;&lt;/span&gt;GGI&lt;sup&gt;+&lt;/sup&gt;14. Craig Gentry, Jens Groth, Yuval Ishai, Chris Peikert, Amit Sahai, and Adam Smith. Using fully homomorphic hybrid encryption to minimize non-interative zero-knowledge proofs. <em>Journal of Cryptology</em>, pages 1–24, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-7&quot;&gt;&lt;/span&gt;GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>Advances in Cryptology – EUROCRYPT 2013</em>, pages 626–645, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-2&quot;&gt;&lt;/span&gt;GH98. Oded Goldreich and Johan H˚astad. On the complexity of interactive proofs with bounded communication. <em>Information Processing Letters</em>, 67(4):205–214, 1998.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-12&quot;&gt;&lt;/span&gt;GI08. Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In <em>Advances in Cryptology – EUROCRYPT 2008</em>, pages 379–396. 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-5&quot;&gt;&lt;/span&gt;GK14. Jens Groth and Markulf Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In <em>Advances in Cryptology – EUROCRYPT 2015</em>, page 764, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-0&quot;&gt;&lt;/span&gt;GMR89. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proofs. <em>SIAM Journal on Computing</em>, 18(1):186–208, 1989.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-3&quot;&gt;&lt;/span&gt;GMW91. Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. <em>Journal of the ACM</em>, 38(3):691–729, 1991.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-17&quot;&gt;&lt;/span&gt;GMY06. Juan a. Garay, Philip MacKenzie, and Ke Yang. Strengthening zeroknowledge protocols using signatures. <em>Journal of Cryptology</em>, 19(2):169–209, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-7&quot;&gt;&lt;/span&gt;GQ88. Louis C. Guillou and Jean-Jacques Quisquater. A practical zero-knowledge protocol fitted to security microprocessor minimizing both trasmission and memory. In <em>Advances in Cryptology – EUROCRYPT 1998</em>, pages 123–128, 1988.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-16&quot;&gt;&lt;/span&gt;Gro04. Jens Groth. <em>Honest verifier zero-knowledge arguments applied</em>. PhD thesis, University of Aarhus, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-8&quot;&gt;&lt;/span&gt;Gro09a. Jens Groth. Efficient zero-knowledge arguments from two-tiered homomorphic commitments. In <em>Advances in Cryptology – ASIACRYPT 2009</em>, pages 431–448, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-0&quot;&gt;&lt;/span&gt;Gro09b. Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In <em>Advances in Cryptology – CRYPTO 2009</em>, pages 192–208, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-9&quot;&gt;&lt;/span&gt;Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In <em>Advances in Cryptology – ASIACRYPT 2010</em>, pages 321–340, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-4&quot;&gt;&lt;/span&gt;GVW02. Oded Goldreich, Salil P. Vadhan, and Avi Wigderson. On interactive proofs with a laconic prover. <em>Computational Complexity</em>, 11(1-2):1–53, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-5&quot;&gt;&lt;/span&gt;Kil92. Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In <em>Symposium on Theory of Computing Conference – TCC 1992</em>, pages 723–732, 1992.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-11&quot;&gt;&lt;/span&gt;KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In <em>Advances in Cryptology – ASIACRYPT 2010</em>, pages 177–194, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-12&quot;&gt;&lt;/span&gt;Lim00. Chae Hoon Lim. Efficient multi-exponentiation and application to batch verification of digital signatures, 2000. Manuscript available at http://dasan.sejong.ac.kr/∼chlim/pub/multi exp.ps.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-15&quot;&gt;&lt;/span&gt;Lin03. Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. <em>Journal of Cryptology</em>, 16(3):143–184, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-10&quot;&gt;&lt;/span&gt;Lip12. Helger Lipmaa. Progression-free sets and sublinear pairing-based noninteractive zero-knowledge arguments. In <em>Theory of Cryptography Conference – TCC 2012</em>, pages 169–189, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-13&quot;&gt;&lt;/span&gt;M¨ol01. Bodo M¨oller. Algorithms for multi-exponentiation. In <em>Selected Areas in Cryptography – SAC 2001</em>, pages 165–180. Springer, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-14&quot;&gt;&lt;/span&gt;MR08. Bodo M¨oller and Andy Rupp. Faster multi-exponentiation through caching: accelerating (EC) DSA signature verification. In <em>Security and Cryptography for Networks – SCN 2008</em>, pages 39–56. Springer, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-18&quot;&gt;&lt;/span&gt;Oli06. Travis E Oliphant. <em>A guide to NumPy</em>, volume 1. Trelgol Publishing USA, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-2&quot;&gt;&lt;/span&gt;PHGR13. Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In <em>IEEE Symposium on Security and Privacy</em>, pages 238–252, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-6&quot;&gt;&lt;/span&gt;Sch91. Claus-Peter Schnorr. Efficient signature generation by smart cards. <em>Journal of Cryptology</em>, 4(3):161–174, 1991.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-1&quot;&gt;&lt;/span&gt;Seo11. Jae Hong Seo. Round-efficient sub-linear zero-knowledge arguments for linear algebra. In <em>Public Key Cryptography – PKC 2011</em>, pages 387–402, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-19&quot;&gt;&lt;/span&gt;Sho01. Victor Shoup. NTL: A library for doing number theory, 2001.</p></li>
    </ul>

`;
---

<BaseLayout title="**Efficient Zero-Knowledge Arguments for Arithmetic Circuits... (2016/263)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/263
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="efficient-zero-knowledge-arguments-for-arithmetic-circuits-2016" />
  </article>
</BaseLayout>
