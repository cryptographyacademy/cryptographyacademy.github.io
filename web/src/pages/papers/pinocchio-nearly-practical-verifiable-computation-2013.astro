---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/279';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Pinocchio: Nearly Practical Verifiable Computation';
const AUTHORS_HTML = 'Bryan Parno Jon Howell *Microsoft Research*';

const CONTENT = `    <p class="text-gray-300">Bryan Parno Jon Howell <em>Microsoft Research</em></p>

    <p class="text-gray-300">Craig Gentry Mariana Raykova <em>IBM Research</em></p>

    <p class="text-gray-300">To instill greater confidence in computations outsourced to the cloud, clients should be able to <em>verify</em> the correctness of the results returned. To this end, we introduce Pinocchio, a built system for efficiently verifying general computations while relying only on cryptographic assumptions. With Pinocchio, the client creates a public evaluation key to describe her computation; this setup is proportional to evaluating the computation once. The worker then evaluates the computation on a particular input and uses the evaluation key to produce a proof of correctness. The proof is only 288 bytes, regardless of the computation performed or the size of the inputs and outputs. Anyone can use a public verification key to check the proof.</p>

    <p class="text-gray-300">Crucially, our evaluation on seven applications demonstrates that Pinocchio is efficient in practice too. Pinocchio's verification time is typically 10ms: 5-7 orders of magnitude less than previous work; indeed Pinocchio is the first general-purpose system to demonstrate verification cheaper than native execution (for some apps). Pinocchio also reduces the worker's proof effort by an additional 19-60×. As an additional feature, Pinocchio generalizes to zero-knowledge proofs at a negligible cost over the base protocol. Finally, to aid development, Pinocchio provides an end-to-end toolchain that compiles a subset of C into programs that implement the verifiable computation protocol.</p>

    <p class="text-gray-300">Since computational power is often asymmetric (particularly for mobile devices), a relatively weak client may wish to outsource computation to one or more powerful workers. Common examples include cloud or grid computing, as well as volunteer distributed computing <a href="#page-12-0">[1]</a>. In all of these settings, the client should be able to <em>verify</em> the results returned, to guard against malicious or malfunctioning workers. Even from a legitimate worker's perspective, verifiable results are beneficial, since they are likely to command a higher price. They also allow the worker to shed liability: any undesired outputs are provably the result of data the client supplied.</p>

    <p class="text-gray-300">Considerable systems and theory research has looked at the problem of verifying computation (§<a href="#page-11-0">6)</a>. However, most of this work has either been function specific, relied on assumptions we prefer to avoid, or simply failed to pass basic practicality requirements. Function specific solutions <a href="#page-12-1">[2–</a><a href="#page-12-2">6]</a> are often efficient, but only for a narrow class of computations. More general solutions often rely on assumptions that may not apply. For example, systems based on replication <a href="#page-12-0">[1,</a> <a href="#page-12-3">7,</a> <a href="#page-12-4">8]</a> assume uncorrelated failures, while those based on Trusted</p>

    <p class="text-gray-300">Computing <a href="#page-12-5">[9–</a><a href="#page-12-6">11]</a> or other secure hardware <a href="#page-12-7">[12–</a><a href="#page-12-8">15]</a> assume that physical protections cannot be defeated. Finally, the theory community has produced a number of beautiful, generalpurpose protocols <a href="#page-12-9">[16–</a><a href="#page-12-10">23]</a> that offer compelling asymptotics. In practice however, because they rely on complex Probabilistically Checkable Proofs (PCPs) <a href="#page-12-11">[17]</a> or fully-homomorphic encryption (FHE) <a href="#page-12-12">[24]</a>, the performance is unacceptable – verifying small instances would take hundreds to trillions of years (§<a href="#page-8-0">5.2)</a>. Very recent work <a href="#page-12-13">[25–</a><a href="#page-13-0">28]</a> has improved these protocols considerably, but efficiency is still problematic, and the protocols lack features like public verification.</p>

    <p class="text-gray-300">In contrast, we describe Pinocchio, a concrete system for efficiently verifying general computations while making only cryptographic assumptions. In particular, Pinocchio supports public verifiable computation <a href="#page-12-14">[22,</a> <a href="#page-13-1">29]</a>, which allows an untrusted worker to produce <em>signatures of computation</em>. Initially, the client chooses a function and generates a public evaluation key and a (small) public verification key. Given the evaluation key, a worker can choose an input (or verifiably use one provided by the client), compute the function, and produce a proof (or signature) to accompany the result. Anyone (not just the client) can then use the verification key to check the correctness of the worker's result for the specific input used. As an additional feature, Pinocchio supports zero-knowledge verifiable computation, in which the worker convinces the client that it knows an input with a particular property, without revealing any information about the input.</p>

    <p class="text-gray-300">Pinocchio's asymptotics are excellent: key setup and proof generation require cryptographic effort linear in the size of the original computation, and verification requires time linear in the size of the inputs and outputs. Even more surprising, Pinocchio's proof is constant sized, <em>regardless</em> of the computation performed. Crucially, our evaluation (§<a href="#page-8-1">5)</a> demonstrates that these asymptotics come with small constants, making Pinocchio close to practical for a variety of applications.</p>

    <p class="text-gray-300">Compared with previous work, Pinocchio improves verification time by 5-7 <em>orders of magnitude</em> and requires less than 10ms in most configurations, enabling it to beat native C execution for some apps. We also improve the worker's proof efforts by 19-60× relative to prior work. The resulting proof is tiny, 288 bytes (only slightly more than an RSA-2048 signature), regardless of the computation. Making a proof zeroknowledge is also cheap, adding negligible overhead (213<em>µ</em>s to key generation and 0.1% to proof generation).</p>

    <p class="text-gray-300">While these improvements are promising, additional progress is likely needed before the overhead reaches true practicality. However, even now, this overhead may be acceptable in scenarios that require high assurance, or that need the zero-knowledge properties Pinocchio supports.</p>

    <p class="text-gray-300">    <img src="_page_1_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;Figure 1: Overview of Pinocchio's Toolchain. <em>Pinocchio takes a high-level C program all the way through to a distributed set of executables that run the program in a verified fashion. It supports both arithmetic circuits, via Quadratic Arithmetic Programs (</em>§<em><a href="#page-2-0">2.2.1)</a>, and Boolean circuits via Quadratic Span Programs (</em>§<em><a href="#page-3-0">2.2.2)</a>.</em></p>

    <p class="text-gray-300">To achieve efficient verifiable computation, Pinocchio combines <em>quadratic programs</em>, a computational model introduced by Gennaro et al. <a href="#page-13-2">[30]</a>, with a series of theoretical refinements and systems engineering to produce an end-to-end toolchain for verifying computations. Specifically, via an improved protocol and proof technique, we slash the cost of key generation by 61%, and the cost of producing a proof by 64%. From a developer's perspective, Pinocchio provides a compiler that transforms C code into a circuit representation (we support both Boolean and arithmetic), converts the circuit into a quadratic program, and then generates programs to execute the cryptographic protocol (Fig. <a href="#page-1-0">1)</a>.</p>

    <p class="text-gray-300">Pinocchio's end-to-end toolchain, plus its support for both Boolean and arithmetic circuits, allows us to implement real applications that benefit from verification. In particular, we implement two forms of matrix multiplication, multivariate polynomial evaluation, image matching, all-pairs shortest paths, a lattice-gas scientific simulator, and SHA-1. We find (§<a href="#page-8-1">5)</a> that the first three apps translate efficiently into arithmetic circuits, and hence Pinocchio can verify their results faster than native execution of the same program. The latter four apps translate less efficiently, due to their reliance on inequality comparisons and bitwise operations, and yet they may still be useful for zero-knowledge applications.</p>

    <p class="text-gray-300">Contributions. In summary, this paper contributes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>An end-to-end system for efficiently verifying computation performed by one or more untrusted workers. This includes a compiler that converts C code into a format suitable for verification, as well as a suite of tools for running the actual protocol.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Theoretical and systems-level improvements that bring performance down by 5-7 orders of magnitude, and hence into the realm of plausibility.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>An evaluation on seven real C applications, showing verification faster than 32-bit native integer execution for some apps.</li>
    </ol></li>
    </ul>

    <h2 id="sec-1" class="text-2xl font-bold">&lt;span id=&quot;page-1-2&quot;&gt;&lt;/span&gt;2 Background</h2>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">2.1 Verifiable Computation (VC)</h4>

    <p class="text-gray-300">A public verifiable computation (VC) scheme allows a computationally limited client to outsource to a worker the evaluation of a function <em>F</em> on input <em>u</em>. The client can then verify the correctness of the returned result <em>F</em>(<em>u</em>) while performing less work than required for the function evaluation.</p>

    <p class="text-gray-300">More formally, we define public VC as follows, generalizing previous definitions <a href="#page-12-14">[22,</a> <a href="#page-13-1">29,</a> <a href="#page-13-2">30]</a>.</p>

    <p class="text-gray-300">Definition 1 (Public Verifiable Computation) <em>A public verifiable computation scheme V C consists of a set of three polynomial-time algorithms</em> (KeyGen,Compute,Verify) <em>defined as follows.</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(<em>EKF</em>,<em>VKF</em>) ← KeyGen(<em>F</em>,1 λ )<em>: The randomized key generation algorithm takes the function F to be outsourced and security parameter</em> λ<em>; it outputs a public evaluation key EKF, and a public verification key VKF.</em></li>
      <li>(<em>y</em>,π<em>y</em>) ← Compute(<em>EKF</em>,<em>u</em>)<em>: The deterministic worker algorithm uses the public evaluation key EK&lt;sup&gt;F&lt;/sup&gt; and input u. It outputs y</em> ← <em>F</em>(<em>u</em>) <em>and a proof</em> π<em>&lt;sup&gt;y&lt;/sup&gt; of y's correctness.</em></li>
      <li>{0,1} ← Verify(<em>VKF</em>,<em>u</em>, <em>y</em>,π<em>y</em>)<em>: Given the verification key VKF, the deterministic verification algorithm outputs 1 if F</em>(<em>u</em>) = <em>y, and 0 otherwise.</em></li>
    </ul>

    <p class="text-gray-300">Prior work gives formal definitions for correctness, security, and efficiency <a href="#page-13-2">[30]</a>, so we merely summarize:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Correctness For any function <em>F</em>, and any input <em>u</em> to <em>F</em>, if we run (<em>EKF</em>,<em>VKF</em>) ← KeyGen(<em>F</em>,1 λ ) and (<em>y</em>,π<em>y</em>) ← Compute(<em>EKF</em>,<em>u</em>), then we always get 1 = Verify(<em>VKF</em>,<em>u</em>, <em>y</em>,π<em>y</em>).</li>
      <li>Security For any function <em>F</em> and any probabilistic polynomial-time adversary <em>A</em>, Pr[(<em>u</em>ˆ, <em>y</em>ˆ,πˆ <em>&lt;sup&gt;y&lt;/sup&gt;</em>) ← <em>A</em>(<em>EKF</em>,<em>VKF</em>) : <em>F</em>(<em>u</em>ˆ) 6= <em>y</em>ˆ and 1 = Verify(<em>VKF</em>,<em>u</em>ˆ, <em>y</em>ˆ,πˆ <em>&lt;sup&gt;y&lt;/sup&gt;</em>)] ≤ negl(λ).</li>
      <li>Efficiency KeyGen is assumed to be a one-time operation whose cost is amortized over many calculations, but we require that Verify is cheaper than evaluating <em>F</em>.</li>
    </ul>

    <p class="text-gray-300">Several previous VC schemes <a href="#page-12-14">[22,</a> <a href="#page-12-10">23]</a> were not public, but rather <em>designated verifier</em>, meaning that the verification key <em>VK&lt;sup&gt;F&lt;/sup&gt;</em> must be kept secret. Indeed, in these schemes, even revealing the output of the verification function (i.e., whether or not the worker had been caught cheating) could lead to attacks on the system. A public VC scheme avoids such issues. Zero-Knowledge Verifiable Computation. We also consider an extended setting where the outsourced computation is a function, <em>F</em>(<em>u</em>,<em>w</em>), of two inputs: the client's input <em>u</em> and an auxiliary input <em>w</em> from the worker. A VC scheme is <em>zeroknowledge</em> if the client learns nothing about the worker's input beyond the output of the computation.<a href="#page-1-1">1</a></p>

    <p class="text-gray-300">Zero knowledge is relevant to practical scenarios where the worker's input is private. For example, to anonymously authenticate, the worker's input <em>w</em> might be a signature from a third party; the client's input <em>u</em> is the third party's public key, and the function <em>F</em>(<em>u</em>,<em>w</em>) validates the signature. The client learns that the worker holds a valid credential, but learns nothing about the credential itself. Another potential application is for privately aggregating sensitive data, for example, in the</p>

    <p class="text-gray-300">&lt;span id=&quot;page-1-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt;Such a scheme may also be referred to as a non-interactive zero knowledge (NIZK) proof <a href="#page-13-3">[31]</a>.</p>

    <p class="text-gray-300">Inputs
<span class="math">$\\begin{array}{c|ccccccccccccccccccccccccccccccccccc</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;Figure 2: Arithmetic Circuit and Equivalent QAP. Each wire value comes from, and all operations are performed over, a field  <span class="math">\\mathbb{F}</span> . The polynomials in the QAP are defined in terms of their evaluations at the two roots,  <span class="math">r_5</span>  and  <span class="math">r_6</span> . See text for details.</p>

    <p class="text-gray-300">context of smart-meter billing [32], where individual meter readings should be private to the client, but the utility needs to authenticate the aggregate amount owed.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2.2 Quadratic Programs</h4>

    <p class="text-gray-300">Gennaro, Gentry, Parno, and Raykova (GGPR) recently showed how to compactly encode computations as quadratic programs [30], so as to obtain efficient VC and zero-knowledge VC schemes. Specifically, they show how to convert any arithmetic circuit into a comparably sized Quadratic Arithmetic Program (QAP), and any Boolean circuit into a comparably sized Quadratic Span Program (QSP). We summarize these transformations.</p>

    <p class="text-gray-300">Standard results show that polynomially-sized circuits are equivalent (up to a logarithmic factor) to Turing machines that run in polynomial time [33], though of course the actual efficiency of computing via circuits versus on native hardware depends heavily on the application (e.g., an arithmetic circuit for matrix multiplication adds essentially no overhead, whereas a Boolean circuit for integer multiplication is less efficient than executing a single 32-bit assembly instruction).</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;2.2.1 Arithmetic Circuits and QAPs</h4>

    <p class="text-gray-300">An arithmetic circuit consists of wires that carry values from a field  <span class="math">\\mathbb{F}</span>  and connect to addition and multiplication gates – see Figure 2 for an example. We define a QAP, an encoding of such a circuit, as follows.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-2&quot;&gt;&lt;/span&gt;<strong>Definition 2 (Quadratic Arithmetic Program (QAP) [30])</strong> A QAP Q over field  <span class="math">\\mathbb{F}</span>  contains three sets of m+1 polynomials  <span class="math">\\mathcal{V} = \\{v_k(x)\\}, \\ \\mathcal{W} = \\{w_k(x)\\}, \\mathcal{Y} = \\{y_k(x)\\}, \\ for \\ k \\in \\{0...m\\}, \\ and a target polynomial &lt;math&gt;t(x)</span> . Suppose F is a function that takes as input n elements of  <span class="math">\\mathbb{F}</span>  and outputs n' elements, for a total of N = n + n' I/O elements. Then we say that Q computes F if:  <span class="math">(c_1, \\ldots, c_N) \\in \\mathbb{F}^N</span>  is a valid assignment of F's inputs and outputs, if and only if there exist coefficients  <span class="math">(c_{N+1}, \\ldots, c_m)</span>  such that t(x) divides p(x), where:</p>

    <p class="text-gray-300"><span class="math">$p(x) = \\left(v_0(x) + \\sum_{k=1}^m c_k \\cdot v_k(x)\\right) \\cdot \\left(w_0(x) + \\sum_{k=1}^m c_k \\cdot w_k(x)\\right)</span>$
<span class="math">$-\\left(y_0(x) + \\sum_{k=1}^m c_k \\cdot y_k(x)\\right).</span>$</p>

    <p class="text-gray-300">In other words, there must exist some polynomial h(x) such that  <span class="math">h(x) \\cdot t(x) = p(x)</span> . The size of Q is m, and the degree is the degree of t(x).</p>

    <p class="text-gray-300">Building a QAP Q for an arithmetic circuit C is fairly straightforward. We pick an arbitrary root  <span class="math">r_g \\in \\mathbb{F}</span>  for each multiplication gate g in C and define the target polynomial to be  <span class="math">t(x) = \\prod_{g} (x - r_g)</span> . We associate an index  <span class="math">k \\in [m] =</span>  <span class="math">\\{1...m\\}</span>  to each input of the circuit and to each output from a multiplication gate (the addition gates will be compressed into their contributions to the multiplication gates). Finally, we define the polynomials in  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{W}</span> , and  <span class="math">\\mathcal{Y}</span>  by letting the polynomials in  <span class="math">\\mathcal V</span>  encode the left input into each gate, the  <span class="math">\\mathcal W</span> encode the right input into each gate, and the  <span class="math">\\mathcal Y</span>  encode the outputs. For example,  <span class="math">v_k(r_g) = 1</span>  if the k-th wire is a left input to gate g, and  <span class="math">v_k(r_g) = 0</span>  otherwise. Similarly,  <span class="math">y_k(r_g) = 1</span>  if the k-th wire is the output of gate g, and  <span class="math">y_k(r_g) = 0</span>  otherwise. Thus, if we consider a particular gate g and its root  <span class="math">r_g</span> , Equation 1 simplifies to:  <span class="math">(\\sum_{k=1}^{m} c_k \\cdot v_k(r_g)) \\cdot (\\sum_{k=1}^{m} c_k \\cdot w_k(r_g)) =</span>  <span class="math">\\left(\\sum_{k\\in I_{left}} c_k\\right) \\cdot \\left(\\sum_{k\\in I_{right}} c_k\\right) = c_g y_k(r_g) = c_g</span> , which just says that the output value of the gate is equal to the product of its inputs, the very definition of a multiplication gate.</p>

    <p class="text-gray-300">In short, the divisibility check that t(x) divides p(x) decomposes into deg(t(x)) separate checks, one for each gate g and root  <span class="math">r_g</span>  of t(x), that  <span class="math">p(r_g) = 0</span> .</p>

    <p class="text-gray-300">Taking the circuit in Figure 2 as a concrete example, we build the equivalent QAP as follows. First, we select two roots,  <span class="math">r_5, r_6 \\in \\mathbb{F}</span>  to represent the two multiplication gates. Hence the QAP's degree is 2. We define six polynomials for each set  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{W}</span> , and  <span class="math">\\mathcal{Y}</span> , four for the input wires, and two for the outputs from the multiplication gates. Thus, the QAP's size is 6. We define these polynomials based on each wire's contributions to the multiplication gates. Specifically all of the  <span class="math">v_k(r_5) = 0</span> , except  <span class="math">v_3(r_5) = 1</span> , since the third input wire contributes to the left input of  <span class="math">c_5</span> 's multiplication gate. Similarly,  <span class="math">v_k(r_6) = 0</span> , except for  <span class="math">v_1(r_6) = v_2(r_6) = 1</span> , since the first two inputs both contribute to the left input of  <span class="math">c_6</span> 's gate. For  <span class="math">\\mathcal{W}</span> , we look at right inputs. Finally,  <span class="math">\\mathcal{Y}</span>  represents outputs; none of the input wires is an output, so  <span class="math">y_k(r_5) = y_k(r_6) = 0</span>  for  <span class="math">k \\in \\{1, ..., 4\\}</span> , and  <span class="math">y_5(r_5) = y_6(r_6) = 1</span> .</p>

    <p class="text-gray-300">Note the extreme sparsity of the polynomials in the example (in terms of evaluations of the polynomials). The VC protocol ( <span class="math">\\S 2.3</span> ) exploits this sparseness to achieve efficiency.</p>

    <p class="text-gray-300">The actual construction [30] is a bit more complex, as it handles addition and multiplication by constants. Nonetheless, GGPR show that for any arithmetic circuit with d multiplication gates and N I/O elements, one can construct an equivalent QAP with degree (the number of roots  <span class="math">r_g</span> ) d and size (number of polynomials in each set) d+N. Note that addition gates and multiplication-by-constant gates do not contribute to the size or degree of the QAP. Thus, these gates are essentially &quot;free&quot; in QAP-based VC schemes.</p>

    <p class="text-gray-300"><strong>Strong QAPs.</strong> In their QAP-based VC scheme, described below, GGPR unfortunately require a strong property from the QAP. Note that Definition 2 only considers the case where the</p>

    <p class="text-gray-300">same set of coefficients  <span class="math">c_i</span>  are applied to all three sets of polynomials. GGPR additionally require the if-and-only-if condition in Definition 2 to hold even when different coefficients  <span class="math">a_i</span> ,  <span class="math">b_i</span> ,  <span class="math">c_i</span>  are applied – i.e., when  <span class="math">p(x) = (\\sum_{k=1}^m c_k \\cdot v_k(x)) \\cdot (\\sum_{k=1}^m b_k \\cdot w_k(x)) - (\\sum_{k=1}^m a_k \\cdot y_k(x))</span> . They show how to convert any QAP into a <em>strong QAP</em> that satisfies this stronger condition. Unfortunately, this strengthening step increases the QAP's degree to 3d + 2N, more than <em>tripling</em> it. This in turn, more than triples the cost of key generation, the size of the evaluation key, and the worker's effort to produce a proof.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;2.2.2 Boolean Circuits and QSPs</h4>

    <p class="text-gray-300">Boolean circuits operate over bits, with bitwise gates for AND, OR, XOR, etc. GGPR propose Quadratic Span Programs (QSPs) as a custom encoding for Boolean circuits [30]. QSPs are superficially similar to QAPs, but because they only support Boolean wire values, they use only two sets of polynomials  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{W}</span> . The divisibility check is updated to consider  <span class="math">p(x) = (v_0(x) + \\sum_{k=1}^m c_k \\cdot v_k(x)) \\cdot (w_0(x) + \\sum_{k=1}^m c_k \\cdot w_k(x))</span> . Instead of the arithmetic circuit-based polynomial construction above, QSPs build a small set of polynomials for each Boolean gate. Specifically, each gate adds 9 roots and 12 polynomials to the overall QSP. Like QAPs, the QSPs require a strengthening step.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-3-1&quot;&gt;&lt;/span&gt;2.3 Building VC from Quadratic Programs</h3>

    <p class="text-gray-300">To construct a VC protocol from a quadratic program, the main idea is that each polynomial – e.g.,  <span class="math">v_k(x) \\in \\mathbb{F}</span>  – of the quadratic program is mapped to an element  <span class="math">g^{v_k(s)}</span>  in a bilinear group, where s is a secret value selected by the client, g is a generator of the group, and  <span class="math">\\mathbb{F}</span>  is the field of discrete logarithms of g. These group elements are given to the worker. For a given input, the worker evaluates the circuit directly to obtain the output and the values of the internal circuit wires. These values correspond to the coefficients  <span class="math">c_i</span> of the quadratic program. Thus, the VC worker can evaluate  <span class="math">v(s) = \\sum_{k \\in [m]} c_k \\cdot v_k(s)</span>  &quot;in the exponent&quot; to get  <span class="math">g^{v(s)}</span> ; it computes w(s) and y(s), in the exponent, similarly. Finally, the worker computes  <span class="math">h(x) = p(x)/t(x) = \\sum_{i=0}^{d} h_i \\cdot x^i</span> , and then uses the  <span class="math">h_i</span> , along with  <span class="math">g^{s^i}</span>  terms in the evaluation key, to compute  <span class="math">g^{h(s)}</span> . To oversimplify, the proof consists of  <span class="math">(g^{v(s)}, g^{w(s)}, g^{v(s)}, g^{h(s)})</span> . The verifier uses the bilinear map to check that p(s) = h(s)t(s). The actual protocol (Protocol 1) is a bit more complex, because additional machinery is needed to ensure that the worker incorporates the client's input u correctly, and that the worker indeed generates (say) v(s) in the exponent as some linear function of the  <span class="math">v_k(s)</span>  values.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-3-2&quot;&gt;&lt;/span&gt;Protocol 1 (Verifiable Computation from strong OAPs)</h4>

    <p class="text-gray-300">•  <span class="math">(EK_F, VK_F) \\leftarrow \\text{KeyGen}(F, 1^{\\lambda})</span> : Let F be a function with N input/output values from  <span class="math">\\mathbb{F}</span> . Convert F into an arithmetic circuit C; then build the corresponding  <span class="math">QAP \\ Q = (t(x), \\mathcal{V}, \\mathcal{W}, \\mathcal{Y})</span>  of size m and degree d. Let  <span class="math">I_{mid} = \\{N+1,...,m\\}</span> , i.e., the non-IO-related indices. Let e be a non-trivial bilinear map  <span class="math">[34] \\ e : G \\times G \\to G_T</span> , and let g be a generator of G.</p>

    <p class="text-gray-300">Choose  <span class="math">s, \\alpha, \\beta_{\\nu}, \\beta_{w}, \\beta_{y}, \\gamma \\stackrel{R}{\\leftarrow} \\mathbb{F}</span> . Construct the public evaluation key  <span class="math">EK_{F}</span>  as:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lll} (&amp; \\{g^{v_k(s)}\\}_{k \\in I_{mid}}, &amp; \\{g^{w_k(s)}\\}_{k \\in [m]}, &amp; \\{g^{y_k(s)}\\}_{k \\in [m]}, \\\\ &amp; \\{g^{\\alpha v_k(s)}\\}_{k \\in I_{mid}}, &amp; \\{g^{\\alpha w_k(s)}\\}_{k \\in [m]}, &amp; \\{g^{\\alpha y_k(s)}\\}_{k \\in [m]}, \\\\ &amp; \\{g^{\\beta v_k(s)}\\}_{k \\in I_{mid}}, &amp; \\{g^{\\beta w_k(s)}\\}_{k \\in [m]}, &amp; \\{g^{\\beta y_k(s)}\\}_{k \\in [m]}, \\\\ &amp; \\{g^{s^i}\\}_{i \\in [d]}, &amp; \\{g^{\\alpha s^i}\\}_{i \\in [d]}, &amp; \\end{array}</span>$</p>

    <p class="text-gray-300">The public verification key is:  <span class="math">VK_F = (g^1, g^\\alpha, g^\\gamma, g^{\\beta_\\nu \\gamma}, g^{\\beta_w \\gamma}, g^{\\beta_y \\gamma}, g^{t(s)}, \\{g^{\\nu_k(s)}\\}_{k \\in [N]}, g^{\\nu_0(s)}, g^{w_0(s)}, g^{y_0(s)}).</span></p>

    <p class="text-gray-300">•  <span class="math">(y, \\pi_y) \\leftarrow \\mathsf{Compute}(EK_F, u)</span> : On input u, the worker evaluates the circuit for F to obtain  <span class="math">y \\leftarrow F(u)</span> . As a result of the evaluation, he knows the values  <span class="math">\\{c_i\\}_{i \\in [m]}</span>  of the circuit's wires.</p>

    <p class="text-gray-300">He solves for h(x) (the polynomial such that  <span class="math">p(x) = h(x) \\cdot t(x)</span> ), and computes the proof  <span class="math">\\pi_y</span>  as:  <span class="math">(g^{v_{mid}(s)}, g^{w(s)}, g^{y(s)}, g^{h(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha w(s)}, g^{\\alpha y(s)}, g^{\\alpha h(s)}, g^{\\alpha h(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha w(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)}, g^{\\alpha v_{mid}(s)</span></p>

    <p class="text-gray-300">where  <span class="math">v_{mid}(x) = \\sum_{k \\in I_{mid}} c_k \\cdot v_k(x)</span> ,  <span class="math">v(x) = \\sum_{k \\in [m]} c_k \\cdot v_k(x)</span> ,  <span class="math">w(x) = \\sum_{k \\in [m]} c_k \\cdot w_k(x)</span> , and  <span class="math">y(x) = \\sum_{k \\in [m]} c_k \\cdot y_k(x)</span> . Since these are linear equations, he can compute them &quot;in the exponent&quot; using the material in the evaluation key, e.g.,  <span class="math">g^{v(s)} = g^{v_0(s)} \\cdot \\prod_{k \\in [m]} \\left( g^{v_k(s)} \\right)^{c_k}</span> .</p>

    <p class="text-gray-300">•  <span class="math">\\{0,1\\} \\leftarrow \\text{Verify}(VK_F, u, y, \\pi_y)</span> : To verify a proof, anyone with access to the verification key  <span class="math">VK_F</span>  can use the pairing function e to check that the  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  proof terms are correct (e.g., check that  <span class="math">e(g^{v_{mid}(s)}, g^{\\alpha}) = e(g^{\\alpha v_{mid}(s)}, g)</span> ). This requires 8 pairings for the  <span class="math">\\alpha</span>  terms, and 3 for the  <span class="math">\\beta</span>  term.</p>

    <p class="text-gray-300">Finally, the verifier can compute a term representing the I/O, u and y, by representing them as coefficients  <span class="math">c_1, \\ldots, c_N \\in \\mathbb{F}</span>  and computing, using elements from  <span class="math">VK_F</span> ,  <span class="math">g^{v_{io}(s)} = \\prod_{k \\in [N]} \\left( g^{v_k(s)} \\right)^{c_k}</span> .</p>

    <p class="text-gray-300">A final check (with 3 pairings) verifies the divisibility requirement, i.e., that  <span class="math">e(g^{v_0(s)} \\cdot g^{v_{io}} \\cdot g^{v(s)}, g^{w_0(s)} \\cdot g^{w_0(s)})/e(g^{y_0(s)} \\cdot g^{y(s)}, g) = e(g^{h(s)}, g^{t(s)}).</span></p>

    <p class="text-gray-300">In a designated verifier setting (where the verifier knows s,  <span class="math">\\alpha</span> , etc.), pairings are only needed for this last check, and the I/O term can be computed directly over  <span class="math">\\mathbb{F}</span> , rather than &quot;in the exponent&quot;.</p>

    <p class="text-gray-300">Regarding efficiency, GGPR [30] show that the one-time setup of KeyGen runs in time linear in the original circuit size, O(|C|). The worker performs O(|C|) cryptographic work, but he must also perform  <span class="math">O(|C|\\log^2|C|)</span>  non-cryptographic work to calculate h(x). To achieve this performance, the worker exploits the fact that the evaluation vectors  <span class="math">(v_k(r_1), \\ldots, v_k(r_d))</span>  are all very sparse (also for the w and y polynomials). The proof itself is constant size, with only 7 group elements for QSPs and 9 for QAPs, though the verifier's work is still linear, O(N), in the size of the inputs and outputs of the function.</p>

    <p class="text-gray-300">In terms of security, GGPR [30] show this VC scheme is sound under the d-PKE and q-PDH assumptions (see Appendix A), which are weak versions of assumptions in prior work [21, 35, 36]. The q-PDH assumption belongs to a class</p>

    <p class="text-gray-300">of cryptographic assumptions that do not lend themselves to efficient falsification [37], though some members have indeed been proven false [38]. Gentry and Wichs recently showed that assumptions from this class are likely to be inherent for efficient, non-interactive arguments for NP relations [39].</p>

    <p class="text-gray-300">Zero Knowledge. Making the VC scheme zero-knowledge is remarkably simple. One simply includes the target polynomial t(x) itself in the polynomial sets  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{W}</span> , and  <span class="math">\\mathcal{Y}</span> . This allows the worker to &quot;randomize&quot; its proof by adding  <span class="math">\\delta_{\\nu}t(s)</span> in the exponent to  <span class="math">v_{mid}(s)</span> ,  <span class="math">\\delta_w t(s)</span>  to w(s), and  <span class="math">\\delta_y t(s)</span>  to y(s)for random  <span class="math">\\delta_{\\nu}, \\delta_{w}, \\delta_{\\nu}</span> , and modifying the other elements of the proof accordingly. The modified value of p(x) remains divisible by t(x), but the randomization makes the scheme statistically zero-knowledge [30].</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8"><strong>Theoretical Refinements</strong></h3>

    <p class="text-gray-300">In this section, we improve Protocol 1 to significantly reduce key generation time, evaluation key size, and worker effort. We analyze our improvements empirically in §5.4.</p>

    <p class="text-gray-300">Our main optimization is that we construct a VC scheme that uses a regular OAP (as in Definition 2), rather than a strong QAP. Recall that GGPR show how to transform a regular QAP into a strong QAP, but the transformation more than triples the degree of the QAP. Consequently, when they plug their strong QAP into their VC construction, the strengthening step more than triples the key generation time, evaluation key size, and worker computation. We take a different approach that uses a regular QAP, and hence we do not need a strengthening step at all. Instead, we embed additional structure into our new VC proof that ensures that the worker uses the same linear combination to construct the v, w, and y terms of its proof.&lt;sup&gt;2&lt;/sup&gt; Surprisingly, this additional structure comes at no cost, and our VC scheme is actually less complicated than GGPR's! For example, we manage to shave the proof down from nine group elements to eight. Experiments ( <span class="math">\\S 5.4</span> ) show that these improvements indeed give substantial savings.</p>

    <p class="text-gray-300">We also remove the need for the worker to compute  <span class="math">g^{\\alpha h(s)}</span> , and hence the  <span class="math">g_{i \\in [d]}^{\\alpha s^i}</span>  terms from EK. Finally, we expand the expressivity and efficiency of the functions QAPs can compute by designing a number of custom circuit gates for specialized functions.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-4-2&quot;&gt;&lt;/span&gt;<strong>Our New VC Protocol</strong></h4>

    <p class="text-gray-300">Next we describe our more efficient VC scheme, with some remarks afterwards on some its properties.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-4-3&quot;&gt;&lt;/span&gt;Protocol 2 (Verifiable Computation from regular OAPs)</h4>

    <p class="text-gray-300">•  <span class="math">(EK_F, VK_F) \\leftarrow \\text{KeyGen}(F, 1^{\\lambda})</span> : Let F be a function with N input/output values from  <span class="math">\\mathbb{F}</span> . Convert F into an arithmetic circuit C; then build the corresponding</p>

    <p class="text-gray-300">QAP  <span class="math">Q = (t(x), \\mathcal{V}, \\mathcal{W}, \\mathcal{Y})</span>  of size m and degree d. Let  <span class="math">I_{mid} = \\{N+1,...,m\\}</span> , i.e., the non-IO-related indices. Let e be a non-trivial bilinear map [34]  <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> , and let g be a generator of G.</p>

    <p class="text-gray-300">Choose  <span class="math">r_v, r_w, s, \\alpha_v, \\alpha_w, \\alpha_v, \\beta, \\gamma \\stackrel{R}{\\leftarrow} \\mathbb{F}</span>  and set  <span class="math">r_v = r_v \\cdot r_w</span> ,  <span class="math">g_{v} = g^{r_{v}}, g_{w} = g^{r_{w}} \\text{ and } g_{v} = g^{r_{y}}.</span></p>

    <p class="text-gray-300">Construct the public evaluation key  <span class="math">EK_F</span>  as:</p>

    <p class="text-gray-300">Construct the public evaluation key
<span class="math">$EK_F</span>$
as:
<span class="math">$\\left( \\begin{array}{ccc} \\left\\{ g_{v}^{v_k(s)} \\right\\}_{k \\in I_{mid}}, &amp; \\left\\{ g_{w}^{w_k(s)} \\right\\}_{k \\in I_{mid}}, &amp; \\left\\{ g_{y}^{y_k(s)} \\right\\}_{k \\in I_{mid}}, \\\\ \\left\\{ g_{v}^{\\alpha_{v}v_k(s)} \\right\\}_{k \\in I_{mid}}, &amp; \\left\\{ g_{w}^{\\alpha_{w}w_k(s)} \\right\\}_{k \\in I_{mid}}, &amp; \\left\\{ g_{y}^{\\alpha_{y}y_k(s)} \\right\\}_{k \\in I_{mid}}, \\\\ \\left\\{ g_{v}^{s^i} \\right\\}_{i \\in [d]}, &amp; \\left\\{ g_{v}^{\\beta v_k(s)} g_{w}^{\\beta w_k(s)} g_{y}^{\\beta y_k(s)} \\right\\}_{k \\in I_{mid}}, \\\\ and the public verification key as:  </span>VK_F = \\left( g^1, g^{\\alpha_{v}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^{\\alpha_{w}}, g^<span class="math">$</span></p>

    <p class="text-gray-300">•  <span class="math">(y,\\pi_y) \\leftarrow \\mathsf{Compute}(EK_F,u)</span> : On input u, the worker evaluates the circuit for F to obtain  <span class="math">y \\leftarrow F(u)</span> ; he also learns the values  <span class="math">\\{c_i\\}_{i\\in[m]}</span>  of the circuit's wires. He solves for h(x) (the polynomial such that  <span class="math">p(x) = h(x) \\cdot t(x)</span> , and computes the proof  <span class="math">\\pi_v</span>  as:</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} g_{v}^{v_{mid}(s)}, &amp; g_{w}^{w_{mid}(s)}, &amp; g_{y}^{v_{mid}(s)}, &amp; g_{y}^{h_{mid}(s)}, \\\\ g_{v}^{\\alpha_{v_{v_{mid}}(s)}}, &amp; g_{w}^{\\alpha_{v_{w_{mid}}(s)}}, &amp; g_{y}^{\\alpha_{y_{w_{mid}}(s)}}, \\\\ g_{v}^{\\beta_{v_{mid}(s)}}g_{w}^{\\beta_{w_{mid}(s)}}g_{y}^{\\beta_{y_{mid}(s)}}g_{y}^{\\beta_{y_{mid}(s)}}, \\end{pmatrix},</span>$</p>

    <p class="text-gray-300">where  <span class="math">v_{mid}(x) = \\sum_{k \\in I_{mid}} c_k \\cdot v_k(x)</span> , and similarly for  <span class="math">w_{mid}(s)</span>  and  <span class="math">y_{mid}(s)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\{0,1\\} \\leftarrow \\mathsf{Verify}(VK_F, u, y, \\pi_v)</span> : The verification of an alleged proof with elements  <span class="math">g^{V_{mid}}</span> ,  <span class="math">g^{W_{mid}}</span> ,  <span class="math">g^{Y_{mid}}</span> ,  <span class="math">g^{H}</span> ,  <span class="math">g^{V&#x27;_{mid}}</span> ,  <span class="math">g^{W&#x27;_{mid}}</span> ,  <span class="math">g^{Y&#x27;_{mid}}</span> , and  <span class="math">g^Z</span>  uses the public verification key  <span class="math">VK_F</span> and the pairing function e for the following checks.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Divisibility check for the QAP: using elements from  <span class="math">VK_F</span>  compute  <span class="math">g_v^{v_{io}(s)} = \\prod_{k \\in [N]} \\left(g_v^{v_k(s)}\\right)^{c_k}</span>  (and similarly for  <span class="math">g_w^{w_{io}(s)}</span>  and  <span class="math">g_v^{y_{io}(s)}</span> ), and check:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$e(g_{v}^{v_{0}(s)}g_{v}^{v_{io}(s)}g_{v}^{V_{mid}},g_{w}^{w_{0}(s)}g_{w}^{w_{io}(s)}g_{w}^{W_{mid}}) =</span>$
(1)</p>

    <p class="text-gray-300"><span class="math">$e(g_y^{t(s)}, g^H)e(g_y^{y_0(s)}g_y^{y_{io}(s)}g_y^{Y_{mid}}, g).</span>$
(2)</p>

    <p class="text-gray-300">• Check that the linear combinations computed over V, W and Y are in their appropriate spans:</p>

    <p class="text-gray-300"><span class="math">$e(g_v^{V&#x27;_{mid}},g) = e(g_v^{V_{mid}},g^{\\alpha_v}), \\quad e(g_w^{W&#x27;_{mid}},g) = e(g_w^{W_{mid}},g^{\\alpha_w}),</span>$
<span class="math">e(g_v^{Y&#x27;_{mid}},g) = e(g_w^{Y_{mid}},g^{\\alpha_y}).</span></p>

    <p class="text-gray-300">• Check that the same coefficients were used in each of the linear combinations over V, W and  <span class="math">\\gamma</span> :</p>

    <p class="text-gray-300"><span class="math">$e(g^Z, g^{\\gamma}) = e(g_v^{V_{mid}} g_w^{W_{mid}} g_v^{Y_{mid}}, g^{\\beta \\gamma}).</span>$</p>

    <p class="text-gray-300">The correctness of the VC scheme follows from the properties of the QAP. Regarding security, we have the following:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-1&quot;&gt;&lt;/span&gt;<strong>Theorem 1</strong> Let d be an upper bound on the degree of the QAP used in the VC scheme, and let q = 4d + 4. The VC scheme is sound under the d-PKE, q-PDH and 2q-SDH assumptions (see Appendix A).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;2&lt;/sup&gt;Our proof contains a term that enforces this linear constraint without increasing the degree. GGPR's generic strengthening step checked the consistency of the linear combinations via additional multiplication gates, which increased the degree of the QAP.</p>

    <p class="text-gray-300">The proof of Theorem 1 is in Appendix B.</p>

    <p class="text-gray-300"><strong>Security Intuition.</strong> As intuition for why the VC scheme is sound, note that it seems hard for an adversary who does not know  <span class="math">\\alpha</span>  to construct any pair of group elements  <span class="math">h, h^{\\alpha}</span>  except in the obvious way: by taking pairs  <span class="math">(g_1, g_1^{\\alpha}), (g_2, g_2^{\\alpha}), \\dots</span> that he is given, and applying the same linear combination (in the exponent) to the left and right elements of the pairs. This hardness is formalized in the d-PKE assumption, a sort of &quot;knowledge-of-exponent&quot; assumption [40], that says that the adversary must &quot;know&quot; such a linear combination, in the sense that this linear combination can be extracted from him. Roughly, this means that, in the security proof, we can extract polynomials  <span class="math">V_{mid}(x)</span> ,  <span class="math">W_{mid}(x)</span> ,  <span class="math">Y_{mid}(x)</span>  such that  <span class="math">V_{mid}</span>  (from the proof) equals  <span class="math">V_{mid}(s)</span> ,  <span class="math">W_{mid} = W_{mid}(s)</span>  and  <span class="math">Y_{mid} = Y_{mid}(s)</span> , and that moreover these polynomials are in the linear spans of the  <span class="math">v_k(x)</span> 's,  <span class="math">w_k(x)</span> 's, and  <span class="math">y_k(x)</span> 's respectively. If the adversary manages to provide a proof of a false statement that verifies, then these polynomials must not actually correspond to a QAP solution. So, either p(x) is not actually divisible by t(x)(in this case we break 2<em>q</em>-SDH) or  <span class="math">V(x) = v_{io}(x) + V_{mid}(x)</span> , W(x) and Y(x) do not use the same linear combination (in this case we break q-PDH because in the proof we choose  <span class="math">\\beta</span> in a clever way).</p>

    <p class="text-gray-300"><strong>Zero Knowledge.</strong> We can apply GGPR's rerandomization technique [30] (§2.3) to provide zero-knowledge for our new verifiable computation construction. The worker chooses  <span class="math">\\delta_v, \\delta_w, \\delta_y \\overset{R}{\\leftarrow} \\mathbb{F}</span>  and in his proof, instead of the polynomials  <span class="math">v_{mid}(x), v(x), w(x)</span>  and y(x), he uses the following randomized versions  <span class="math">v_{mid}(x) + \\delta_v t(x), v(x) + \\delta_v t(x), w(x) + \\delta_w t(x)</span>  and  <span class="math">y(x) + \\delta_y t(x)</span> . In order to facilitate the randomization of the proof we add the following terms to the evaluation key:  <span class="math">g_v^{\\alpha_v t(s)}, g_w^{\\alpha_w t(s)}, g_y^{\\alpha_y t(s)}, g_v^{\\beta_t t(s)}, g_y^{\\beta_t t(s)}, g_y^{\\beta_t t(s)}</span> .</p>

    <p class="text-gray-300"><strong>Performance.</strong> Our main improvement is that our VC scheme only requires a regular QAP, rather than a strong QAP, which improves performance by more than a factor of 3. Moreover, the scheme itself is simpler, leading to fewer group elements in the keys and proof, fewer bilinear maps for Verify, etc.</p>

    <p class="text-gray-300">The scheme above assumes a symmetric bilinear map. In practice, for performance reasons, we use an asymmetric bilinear map  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  where  <span class="math">\\mathbb{G}_1</span>  is an elliptic curve group called the &quot;base&quot; curve, and  <span class="math">\\mathbb{G}_2</span>  is the &quot;twist&quot; curve. Operations over the base curve are about 3 times faster than over the twist curve (§5.1). Due to our optimizations, while the worker must compute the  <span class="math">g_w^{w(s)}</span>  term over the twist curve, all of the other proof terms can be over the base curve.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-5-1&quot;&gt;&lt;/span&gt;3.2 Expressive Circuit Constructions</h4>

    <p class="text-gray-300">The QAP that we use in our VC scheme is defined over  <span class="math">\\mathbb{F}_p</span> , where p is a large prime. We can, as explained above, derive a QAP over  <span class="math">\\mathbb{F}_p</span>  that efficiently computes any function F that can be expressed in terms of addition and multiplication modulo p. This provides no obvious way to express some operations, such as  <span class="math">a \\ge b</span>  using mod-p arithmetic. On the other hand, given a and b as bits, comparison is easy. Hence, one</p>

    <p class="text-gray-300">might infer that Boolean circuits are more general and thus QSPs superior to QAPs.</p>

    <p class="text-gray-300">However, we design an arithmetic <em>split gate</em> to translate an arithmetic wire  <span class="math">a \\in \\mathbb{F}_p</span> , known to be in  <span class="math">[0, 2^k - 1]</span> , into k binary output wires. Given such binary values, we can compute Boolean functions using arithmetic gates: NAND(a,b) = 1 - ab, AND(a,b) = ab, OR(a,b) = 1 - (1-a)(1-b). Each embedded Boolean gate costs only one multiply.</p>

    <p class="text-gray-300">Surprisingly, even though QSPs are &quot;designed for&quot; Boolean circuits, the arithmetic embedding gives a more efficient VC scheme. With a QSP, each gate increases the degree of t(x) by 9 and the QSP size by 12. Embedding introduces an expensive initial gate that constrains each input to  <span class="math">\\{0,1\\}</span> , but henceforth, each embedded gate preserves the  <span class="math">\\{0,1\\}</span>  invariant, adding only 1 to the degree and size of the QAP. &lt;sup&gt;3&lt;/sup&gt;</p>

    <p class="text-gray-300">Furthermore, the expression  <span class="math">\\sum_{i=1}^{k} 2^{i-1}a_i</span>  combines a bitwise representation of a back into a single wire. Because the sum consists of additions and multiplications by constants, recombination is free; it doesn't increase the size of the QAP.</p>

    <p class="text-gray-300">Below, we define <em>split</em> and other useful new gates as standalone QAPs which can be composed [30, Thm.11] with other gates.</p>

    <p class="text-gray-300"><strong>Split Gate.</strong> Given input  <span class="math">a \\in \\mathbb{F}_p</span>  known to be in  <span class="math">[0, 2^k - 1]</span> , the split gate outputs k wires holding the binary digits  <span class="math">a_1, \\ldots, a_k</span>  of a. Thus, the QAP ensures that  <span class="math">\\sum_{i=1}^k 2^{i-1}a_i = a</span> , and that each  <span class="math">a_i</span>  is either 0 or 1. For convenience, we number the output wires  <span class="math">1, \\ldots, k</span>  and the input wire k+1.</p>

    <p class="text-gray-300">In our mini-QAP, let  <span class="math">t(x) = (x - r) \\prod_{i=1}^{k} (x - r_i)</span>  where  <span class="math">r, r_1, \\dots, r_k</span>  are distinct roots. We set:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\begin{array}{lll} v_0(r)=0, &amp; v_i(r)=2^{i-1} &amp; \\text{for } 1\\leq i\\leq k, &amp; v_{k+1}(r)=0,\\\\ \\bullet &amp; w_0(r)=1, &amp; w_i(r)=0 &amp; \\text{for } 1\\leq i\\leq k, &amp; w_{k+1}(r)=0,\\\\ y_0(r)=0, &amp; y_i(r)=0 &amp; \\text{for } 1\\leq i\\leq k, &amp; y_{k+1}(r)=1; \\end{array}</span></li>
      <li>For  <span class="math">1 \\le j \\le k</span> :  <span class="math">v_j(r_j) = 1</span> ,  <span class="math">v_i(r_j) = 0</span>  for all  <span class="math">i \\ne j</span> ,  <span class="math">w_0(r_j) = 1</span> ,  <span class="math">w_j(r_j) = -1</span> ,  <span class="math">w_i(r_j) = 0</span>  for all  <span class="math">i \\ne 0, j</span> , and  <span class="math">y_i(r_j) = 0</span>  for all i.</li>
    </ul>

    <p class="text-gray-300">If  <span class="math">(v_0(x) + \\sum_{k=1}^m a_k \\cdot v_k(x)) \\cdot (w_0(x) + \\sum_{k=1}^m a_k \\cdot w_k(x)) - (y_0(x) + \\sum_{k=1}^m a_k \\cdot y_k(x))</span>  is divisible by t(x), it must evaluate to 0 at r, and therefore the first set of equations guarantee that  <span class="math">\\sum_{i=1}^k 2^{i-1}a_i - a = 0</span> . This guarantees that if all  <span class="math">a_1, \\ldots, a_k</span>  are binary, then they are the binary digits of a. The second set of equations guarantees that each  <span class="math">a_i</span>  is either 0 or 1. In particular, for each  <span class="math">1 \\le j \\le k</span> , the above polynomial evaluates to 0 at  <span class="math">r_j</span>  if and only if  <span class="math">a_j \\cdot (1 - a_j) = 0</span> .</p>

    <p class="text-gray-300"><strong>Equality-Assertion Gate.</strong> For some computations, we require the value on two circuit wires to be equal. For example, in many signature schemes, the verification function checks for equality between two values. Thus when we use signature verification as part of a larger computation, we want to guarantee that the computation succeeds only if the verification is successful.</p>

    <p class="text-gray-300">For such cases, we augment the QAP such that it forces two wires,  <span class="math">i_1</span>  and  <span class="math">i_2</span> , to have the same value. Let T(x),</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;3&lt;/sup&gt;QSPs still have smaller proofs, since they require only two sets of polynomials  <span class="math">(\\mathcal{V}, \\mathcal{W})</span>  vs. three  <span class="math">(\\mathcal{V}, \\mathcal{W}, \\mathcal{Y})</span> .</p>

    <p class="text-gray-300"><span class="math">\\{V_i(x)\\}_{i=1}^{k+1}, \\{W_i(x)\\}_{i=1}^{k+1}, \\{Y_i(x)\\}_{i=1}^{k+1}</span>  be the polynomials from the construction of the initial QAP.</p>

    <p class="text-gray-300">We construct an augmented QAP with polynomials t(x),  <span class="math">\\{v_i(x)\\}_{i=1}^{k+1}</span> ,  <span class="math">\\{w_i(x)\\}_{i=1}^{k+1}</span> ,  <span class="math">\\{y_i(x)\\}_{i=1}^{k+1}</span>  defined as follows. Set t(x) = T(x)(x-r) where r is different from the roots of T(x). For the rest of the polynomials we have:</p>

    <p class="text-gray-300">• Modulo T(x), the following hold for all  <span class="math">0 \\le j \\le k+1</span> :  <span class="math">v_j(x) = V_j(x), w_j(x) = W_j(x),</span>  and  <span class="math">y_j(x) = Y_j(x).</span> •  <span class="math">v_{i_1}(r) = 1, v_{i_2}(r) = -1, v_j(r) = 0</span>  for  <span class="math">j \\ne i_1, i_2,</span>  <span class="math">w_0(r) = 1, w_j(r) = 0</span>  for all  <span class="math">1 \\le j \\le k+1,</span></p>

    <p class="text-gray-300">By the first set of equations, our new QAP inherits all of the constraints of the initial QAP. The second set of equations ensures that the divisibility holds if and only if the values on wires  <span class="math">i_1</span>  and  <span class="math">i_2</span>  are equal.</p>

    <p class="text-gray-300"><span class="math">y_{j}(r) = 0</span>  for all  <span class="math">0 \\le j \\le k + 1</span> .</p>

    <p class="text-gray-300"><strong>Zero-Equality Gate.</strong> Another useful type of comparison functionality is checking whether a value is equal to zero, e.g.,  <span class="math">\\mathbf{Y} = (\\mathbf{X}! = \\mathbf{0})?\\mathbf{1}:\\mathbf{0}</span> . We use a prior observation [28] that this is equivalent to satisfying the following two constraints:  <span class="math">X \\cdot M - Y = 0</span>  and  <span class="math">(1 - Y) \\cdot X = 0</span>  for some value M. We construct the following QAP, which takes as input wire X (an input from the client) and a wire M, an input from the worker. The output wire will be Y. For distinct roots  <span class="math">r_1, r_2</span> , the mini-QAP has a target polynomial  <span class="math">t(x) = (x - r_1)(x - r_2)</span> , and the rest of the polynomials are defined as follows:</p>

    <pre><code class="language-text">\\begin{array}{llll} &amp; v_0(r_1)=0, &amp; v_1(r_1)=1, &amp; v_2(r_1)=0, &amp; v_3(r_1)=0;\\\\ \\bullet &amp; w_0(r_1)=0, &amp; w_1(r_1)=0, &amp; w_2(r_1)=1, &amp; w_3(r_1)=0;\\\\ &amp; y_0(r_1)=0, &amp; y_1(r_1)=0, &amp; y_2(r_1)=0, &amp; y_3(r_1)=1;\\\\ &amp; v_0(r_2)=1, &amp; v_1(r_2)=0, &amp; v_2(r_2)=0, &amp; v_3(r_2)=-1;\\\\ \\bullet &amp; w_0(r_2)=0, &amp; w_1(r_2)=1, &amp; w_2(r_2)=0, &amp; w_3(r_2)=0; \\end{array}
</code></pre>

    <p class="text-gray-300"><span class="math">y_0(r_2) = 0</span> ,  <span class="math">y_1(r_2) = 0</span> ,  <span class="math">y_2(r_2) = 0</span> ,  <span class="math">y_3(r_2) = 0</span> .</p>

    <p class="text-gray-300">The value X will be applied to be polynomials with subscript 1, M to subscript 2, and Y to subscript 3. The first set of equations provides that if t(x) divides  <span class="math">(v_0(x) + \\sum_{k=1}^m a_k \\cdot v_k(x)) \\cdot (w_0(x) + \\sum_{k=1}^m a_k \\cdot w_k(x)) - (y_0(x) + \\sum_{k=1}^m a_k \\cdot y_k(x))</span> , then  <span class="math">X \\cdot M - Y = 0</span> , and the second set of equations guarantees that  <span class="math">(1 - Y) \\cdot X = 0</span> .</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4 Implementation</h3>

    <p class="text-gray-300">We implemented a compiler that takes a subset of C to an equivalent arithmetic circuit (§4.1). Our verifiable computation suite then compiles the circuit representation to the equivalent QAP, and generates code to run the VC protocol, including key generation, proof computation, and proof verification (§4.2). The toolchain compiles a large collection of applications and runs them with verification (§4.3). Source code for the toolchain is available [41].</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;4.1 Compiler Toolchain</h4>

    <p class="text-gray-300">The applications described below (§4.3) and evaluated in §5 are each compiled using qcc, our C-to-arithmetic-expression compiler, a 3,525-line Python program [42]. They are also compiled with gcc to produce the Native timings in Figures 7 and 8. A unit test validates that the gcc and 32-bit qcc executables produce matching output on varying inputs.</p>

    <pre><code class="language-text">int mat[SIZE*SIZE] = { 0x12, ... };
struct In { int vector[SIZE]; };
struct Out { int result[SIZE]; };

void compute(struct In *input, struct Out *output) {
  int i, j, k, t;
  for (i=0; i&lt;SIZE; i+=1) {
    int t=0;
    for (k=0; k&lt;SIZE; k+=1) {
        t = t + mat-&gt;[i*SIZE+k] * input-&gt;vector[k];
    }
    output-&gt;result[i] = t;
  }
}
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;Figure 3: <strong>Fixed-Matrix Multiplication.</strong> The qcc compiler unrolls the loops and decodes the struct and array references to generate an arithmetic expression for Out in terms of In.</p>

    <p class="text-gray-300">The compiler understands a substantial subset of C, including global, function and block-scoped variables; arrays, structs, and pointers; function calls, conditionals, loops; and static initializers (Fig. 3). It also understands arithmetic and bitwise Boolean operators and preprocessor syntax. The program's entry point is a function</p>

    <pre><code class="language-text">void compute (struct In *in, struct Out *out) whose parameters identify the set of input and output values.
</code></pre>

    <p class="text-gray-300">Since the &quot;target machine&quot; (arithmetic circuits) supports only expressions, not mutable state and iteration, we restrict the C program's semantics accordingly. For example, pointers and array dereferences must be compile-time constants; otherwise, each dynamic reference would produce conditional expressions of size proportional to the addressable memory. Function calls are inlined, while preserving C variable scope and pointer semantics.</p>

    <p class="text-gray-300">Imperative conditionals compile to conditional expressions that encode the imperative side effects. Static conditions are collapsed at compile time. Similarly, loops with statically-evaluatable termination conditions are automatically unrolled completely. A loop with dynamic termination—depending on an input value—requires a pragma _unroll to inform the compiler how far it should unroll.</p>

    <p class="text-gray-300">The only scalar type presently supported is <strong>int</strong>; a compiler flag selects the integer size. The compiler inserts masking expressions to ensure that a <em>k</em>-bit int behaves exactly as the corresponding C type, including overflow. As described below, our arithmetic circuits operate over a 254-bit field; if the program's computation is known not to overflow 254 bits, the programmer can disable masking with a compiler flag. We plan to extend our compiler to support floating point values via standard techniques [28, 43].</p>

    <p class="text-gray-300">These features (and limitations) are similar to a parallel effort [44] to compile C for the purposes of secure multiparty computation, though they compile only to Boolean circuits. <strong>Details.</strong> The compiler front-end tracks scopes and variable values (as expressions), and unrolls imperative execution into a final program state that provides expressions for each output value. The intermediate language is a set of expressions of C-like operators, such as +, *, &lt;=, ?:, &amp;, and  <span class="math">^{\\circ}</span> .</p>

    <p class="text-gray-300">The compiler back-end expands each expression into the arithmetic gate language of mul, add, const-mul, wire-split, etc., eliminating common subexpressions. It carefully bounds the bit-width of each wire value:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>inputs have the compiler-specified int width;</li>
      <li>each constant has a known width (e.g.  <span class="math">13 = 1101_2</span>  has bit width 4);</li>
      <li>a bitwise op produces the <em>max</em> of its arguments' widths;</li>
      <li>add can produce max+1 bits (for a carry); and</li>
      <li>mul can produce  <span class="math">2 \\cdot max</span>  bits.</li>
    </ul>

    <p class="text-gray-300">When the width nears the available bits in the crypto field (254), the compiler generates a split operation to truncate the value back to the specified <strong>int</strong> width. Tracking bit width minimizes the cost of split gates.</p>

    <p class="text-gray-300">Signed numbers are handled just as they are in C: a 32-bit int is a twos-complement number with a sign bit at 1 &lt; &lt; 31. Each C expression value is treated either as an arithmetic scalar wire or a Boolean expansion, e.g. 32 wires in  <span class="math">\\{0,1\\}</span>  ( <span class="math">\\{3.2\\}</span> ). The format is translated only when values pass from one operator type to the other; for example, in  <span class="math">(a^b)^c + z</span> , the bitwise xor (^) operators manipulate bitwise Booleans, which are joined into a scalar for the addition +.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;4.2 Quadratic Programs and Cryptographic Protocol</h4>

    <p class="text-gray-300">The next pipeline stage accepts a Boolean or arithmetic circuit and builds a QSP or QAP (§2). Then, per §3.1, it compiles the quadratic program into a set of cryptographic routines for the client (key generation and verification) and the worker (computation and proof generation). For comparison, we also implement the original GGPR [30]; §5.4 shows that Pinocchio's enhancements reduce overhead by 18-64%.</p>

    <p class="text-gray-300">The key-generation routine runs at the client, with selectable public verification and zero-knowledge features (§5.3). The code transmits the evaluation key over the network to the worker; to save bandwidth, the program transmits as C and the worker compiles it locally.</p>

    <p class="text-gray-300">The computation routine runs at the server, collecting input from the client, using the evaluation key to produce the proof, and transmitting the proof back to the client (or, if desired, a different verifier). The verification routine uses the verification key and proof to determine if the worker cheated.</p>

    <p class="text-gray-300">Our cryptographic code is single-threaded, but each stage is embarrassingly parallel. Prior work [28] shows that standard techniques can parallelize work across cores, machines, or GPUs. For the cryptographic code, we use a high-speed elliptic curve library [45] with a 256-bit BN-curve [46] that provides 128 bits of security. The quadratic-program-construction and protocol-execution code is 10,832 lines of C and C++ [42].</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-7-1&quot;&gt;&lt;/span&gt;4.2.1 Optimizing Operations</h4>

    <p class="text-gray-300">We summarize some of the key optimizations we implemented, as well as lessons learned.</p>

    <p class="text-gray-300"><strong>Faster Exponentiation.</strong> Generating the evaluation key EK requires exponentiating the same base g to many different powers. We optimize this operation by adapting Pippenger's</p>

    <p class="text-gray-300">multi-exponentiation [47] algorithm for use with a single base. Essentially this means that we build a table of intermediate powers of g, allowing us to compute any particular exponent with only a few multiplications.</p>

    <p class="text-gray-300">In a similar vein, the worker's largest source of overhead is applying the coefficients from the circuit &quot;in the exponent&quot; to compute  <span class="math">g^{Y(s)}</span>  etc. Here Pippenger's algorithm is less directly useful, since the worker does a handful of such operations for a given work instance, but each operation involves hundreds of thousands of different bases, i.e., given  <span class="math">g_1, \\ldots, g_m</span> ,  <span class="math">e_1, \\ldots, e_m</span> , for very large m, the worker needs to compute  <span class="math">\\prod_i g_i^{e_i}</span> . To optimize this operation, we use a sliding-window technique to build a small table of powers for each pair of bases. For example, for the first two bases, with a window of size 1, we compute  <span class="math">\\{g_1^0g_2^0, g_1^0g_2^1, g_1^1g_2^0, g_1^1g_2^1\\}</span> . In this case, the table only requires one multiply to build. We can then consider the high order bit of both  <span class="math">e_1</span>  and  <span class="math">e_2</span> ; together these bits select one of four values in our table; we multiply that value into our accumulator and proceed to the next pair of bases. After all bases have been considered, we square the accumulator (to &quot;move&quot; the portion of the exponent we've computed into the next higher &quot;slot&quot;), and then repeat. In practice, these tables can save 3-4x, even counting the time to build the tables in the first place.</p>

    <p class="text-gray-300"><strong>Polynomial Asymptotics.</strong> To generate a proof, the worker must compute the polynomial h(x) such that  <span class="math">t(x) \\cdot h(x) = P(x)</span>  (§2). Since we store P(x) in terms of its evaluations at the roots of the quadratic program (recall Figure 2), the worker must first interpolate to find P(x) and then perform a polynomial division to arrive at h(x).</p>

    <p class="text-gray-300">Note that all of these computations take place in a normal field, whereas all of the worker's other steps involve cryptographic operations, which §5.1 shows are about three orders of magnitude more expensive.</p>

    <p class="text-gray-300">Thus, one might naïvely conclude, as we did, that simple polynomial algorithms, such as Lagrangian interpolation and &quot;high-school&quot; polynomial multiplication, suffice. However, we quickly discovered that the  <span class="math">O(n^2)</span>  behavior of these algorithms, at the scale required for verifiable computing, dwarfed the linear number of cryptographic operations (§5.1). Hence we implemented an FFT-based  <span class="math">O(n\\log n)</span>  polynomial multiplication library and used a polynomial interpolation algorithm [48] that builds a binary tree of polynomials, giving total time  <span class="math">O(n\\log^2 n)</span> . Even so optimized, solving for h(x) is the second largest source of worker overhead.</p>

    <p class="text-gray-300">Preparing for the Future; Learning from the Past. In our implementation and evaluation, we assume a worst case scenario in which the client decides, without any warning, to outsource a new function, and similarly that the worker only ever computes a single instance for a given client. In practice, neither scenario is plausible. When the client first installs Pinocchio, the program, could, in theory, build the single base exponent table discussed above. Further, it can choose a random <em>s</em> and begins computing powers of <em>s</em> in the background, since these are entirely independent of the computation.</p>

    <p class="text-gray-300">Similarly, if the worker performs more than a single computation for the client, he can hold onto the exponentiation tables he built for the first computation and save substantial time on subsequent computations. He can also save the polynomial tree used to accelerate the computation of <em>h</em>(<em>x</em>). None of these values have any secret information, so workers could potentially even share this information amongst themselves.</p>

    <p class="text-gray-300">Working With Elliptic Curves. Our BN curve is defined by the equation <em>y</em> &lt;sup&gt;2&lt;/sup&gt; = <em>x</em> &lt;sup&gt;3&lt;/sup&gt; + <em>b</em>, in that each group element <em>g&lt;sup&gt;i&lt;/sup&gt;</em> is a point (<em>x</em>, <em>y</em>) on the curve. To speed operations, while computing on elliptic curve points, we represent them in <em>projective</em> form, as three coordinates (<em>x</em>, <em>y</em>,<em>z</em>), which corresponds to the affine point (<em>x</em>/<em>z</em> 2 , <em>y</em>/<em>z</em> 3 ). This is analogous to representing a rational number as an integral numerator and denominator. Projective coordinates reduce EC operation costs by ∼60%. We save space in the cryptographic keys and proof by converting points back to affine form before storing or transmitting them. Furthermore, rather than store (<em>x</em>, <em>y</em>), we store <em>x</em> and a bit indicating which square root of <em>x</em> &lt;sup&gt;3&lt;/sup&gt; +<em>b</em> to use for <em>y</em>, reducing key and proof size by another 50%.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-8-3&quot;&gt;&lt;/span&gt;4.3 Applications</h4>

    <p class="text-gray-300">Pinocchio runs several applications; each can be instantiated with some static <em>parameters</em>, and then each instance can be executed with dynamic <em>inputs</em>.</p>

    <p class="text-gray-300"><em>Fixed Matrix</em> multiplies an <em>n</em> × <em>n</em> matrix parameter <em>M</em> by an <em>n</em>-length input vector <em>A</em>, and outputs the resulting <em>n</em>-length vector <em>M</em> · <em>A</em>. We choose five parameter settings that range from |<em>M</em>| = 200×200 to |<em>M</em>| = 1000×1000.</p>

    <p class="text-gray-300"><em>Two Matrices</em> has parameter <em>n</em>, takes as input two <em>n</em> × <em>n</em> matrices <em>M</em>&lt;sup&gt;1&lt;/sup&gt; and <em>M</em>2, and outputs the <em>n</em> × <em>n</em> matrix <em>M</em>&lt;sup&gt;1&lt;/sup&gt; · <em>M</em>2. Matrix operations are widely used, e.g., in collaborative filtering <a href="#page-13-22">[49]</a>. (|<em>M</em>| = 30×30 to |<em>M</em>| = 110×110)</p>

    <p class="text-gray-300"><em>MultiVar Poly</em> evaluates a <em>k</em>-variable, <em>m</em>-degree multivariate polynomial. The (<em>m</em> + 1) <em>k</em> coefficients are parameters, the <em>k</em> variables <em>x</em>1,..., <em>x&lt;sup&gt;k&lt;/sup&gt;</em> are the inputs, and the polynomial's scalar value is the output. (<em>k</em> = 5, <em>m</em> = 6, 16,807 coeff. to <em>k</em> = 5, <em>m</em> = 10; 644,170 coeff.)</p>

    <p class="text-gray-300"><em>Image Matching</em> is parameterized by an <em>i&lt;sup&gt;w&lt;/sup&gt;</em> ×<em>i&lt;sup&gt;h&lt;/sup&gt;</em> rectangular image and parameters <em>kw</em>, <em>kh</em>. It takes as input a <em>k&lt;sup&gt;w&lt;/sup&gt;</em> × <em>k&lt;sup&gt;h&lt;/sup&gt;</em> image kernel, and outputs the minimum difference and the point (<em>x</em>, <em>y</em>) in the image where it occurs. (<em>i&lt;sup&gt;w&lt;/sup&gt;</em> ×<em>i&lt;sup&gt;h&lt;/sup&gt;</em> = 25, <em>k&lt;sup&gt;w&lt;/sup&gt;</em> ×<em>k&lt;sup&gt;h&lt;/sup&gt;</em> = 9 to <em>i&lt;sup&gt;w&lt;/sup&gt;</em> ×<em>i&lt;sup&gt;h&lt;/sup&gt;</em> = 2025, <em>k&lt;sup&gt;w&lt;/sup&gt;</em> ×<em>k&lt;sup&gt;h&lt;/sup&gt;</em> = 9)</p>

    <p class="text-gray-300"><em>Shortest Paths</em>implements the Floyd-Warshall <em>O</em>(<em>n</em> 3 ) graph algorithm, useful for network routing and matrix inversion. Its parameter <em>n</em> specifies the number of vertices, its input is an <em>n</em>×<em>n</em> edge matrix, and its output is an <em>n</em>×<em>n</em> matrix of allpairs shortest paths. (<em>n</em> = 8, <em>e</em> = 64 to <em>n</em> = 24, <em>e</em> = 576)</p>

    <p class="text-gray-300"><em>LGCA</em> is a Lattice-Gas Cellular Automata implementation that converges to Navier-Stokes <a href="#page-13-23">[50]</a>. It has parameter <em>n</em>, the fluid lattice size, and <em>k</em>, the iteration count. It inputs one <em>n</em>-cell lattice and outputs another reflecting <em>k</em> steps. (<em>n</em> = 294, <em>k</em> = 5 to <em>n</em> = 294, <em>k</em> = 40)</p>

    <p class="text-gray-300"><em>SHA-1</em> has no parameters. Its input is a 13-word (416-bit) input string, and it outputs its 5-word (160-bit) SHA-1 hash.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Op</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Base Curve</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Twist Curve</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Fixed Base Exp (naive)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">318.5µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1221.4µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Fixed Base Exp (opt)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38.2µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">118.3µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multi Exp, 254-bit exp (naive)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">318.5µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1221.5µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multi Exp, 254-bit exp (opt)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">104.5µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">401.0µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multi Exp,&lt;br&gt;32-bit exp (opt)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.9µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56.8µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multi Exp,&lt;br&gt;1-bit exp (opt)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.5µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36.4µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compress</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.2µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2160.9µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Decompress</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27.0µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2168.3µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Pairing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.9ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Field Add</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50.2ns</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Field Mul</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">361.1ns</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-8-4&quot;&gt;&lt;/span&gt;Figure 4: Microbenchmarks. <em>Breakdown of the main sources of performance overhead in the larger protocol.</em> (<em>N</em> = 100,σ ≤ 1%)<em>.</em></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Degree</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1000</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poly Interp (naive)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.5ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">238.3ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">202013.1ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poly Interp (opt)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.1ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">331.1ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poly Mul (naive)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.6ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">799.7ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poly Mul (opt)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1ms</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-8-5&quot;&gt;&lt;/span&gt;Figure 5: Cost of Polynomial Operations. <em>Illustrates the importance of optimizing polynomial algorithms.</em> (<em>N</em> = 500,σ ≤ 5%)<em>.</em></p>

    <p class="text-gray-300">We experiment on a Lenovo X201 ThinkPad. We run on a single core of a 2.67 GHz Intel Core i7 with 8 GB of RAM. Pinocchio's results use QAPs, since theory (§<a href="#page-5-1">3.2)</a> and practice (§<a href="#page-11-2">5.5)</a> show they offer superior performance.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-8-2&quot;&gt;&lt;/span&gt;5.1 Microbenchmarks</h3>

    <p class="text-gray-300">We performed a series of microbenchmarks to quantify the basic cost units of our protocol (Fig. <a href="#page-8-4">4)</a>. Field operations are about three orders of magnitude cheaper than cryptographic exponentiations or multiplications. As §<a href="#page-4-1">3.1</a> explained, we use an asymmetric pairing function, meaning that some group elements live on a (relatively) cheap base curve, while others live on the &quot;twist&quot; curve. Operations on the latter are 3-4× as expensive, reinforcing the importance of our optimizations to the VC protocol to move as many operations as possible to the base curve. Ultimately, Pinocchio's protocol requires only the <em>W</em> polynomials to operate on the twist curve; all other operations take place on the base curve.</p>

    <p class="text-gray-300">Figures <a href="#page-8-4">4</a> and <a href="#page-8-5">5</a> also show the impact of the exponentiation and polynomial optimizations described in §<a href="#page-7-1">4.2.1,</a> which reduce costs by two to three orders of magnitude for polynomial operations, and factors of 3-10 for exponentiations.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;5.2 Comparison With Previous Work</h4>

    <p class="text-gray-300">Figure <a href="#page-9-2">6</a> plots Pinocchio's performance against that of previous general-purpose systems. We use the multiplication of two matrices as our test application since it has appeared in several prior papers <a href="#page-12-13">[25,</a> <a href="#page-13-24">27]</a>, though simpler, noncryptographic verification procedures exist <a href="#page-13-25">[51,</a> §7.1]. Since</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-2&quot;&gt;&lt;/span&gt;Figure 6: <strong>Performance Relative to Prior Schemes.</strong> Pinocchio reduces costs by orders of magnitude (note the log scale on the y-axis). We graph the time necessary to (a) verify and (b) produce a proof result for multiplying two NxN matrices.</p>

    <p class="text-gray-300">all of these prior schemes are designated verifier, we measure against Pinocchio's designated verifier mode.</p>

    <p class="text-gray-300">We compare against 1) a naïve version of a PCP-based scheme [52]; 2) GGP [22], an early scheme that defined verifiable computation, but which relies on fully-homomorphic-encryption (FHE); 3) Pepper [27], an optimized refinement of (1); and 4) Ginger [28], a further refinement of Pepper. See Section 6 for more details on these schemes and the trade-offs between them. Since most of these schemes are ridiculously impractical, we model, rather than measure, their performance. For GGP, we built a model of its performance based on the latest performance results for FHE [53], while for the others, we used previously published models [27, 28]. For Pinocchio, however, we use real numbers from our implementation.</p>

    <p class="text-gray-300">Figure 6 shows that Pinocchio continues the recent trend of reducing costs by orders of magnitude. Early PCP and FHE-based schemes are laughably impractical, taking hundreds to trillions of years to produce or verify a single proof. Pepper and Ginger have made huge improvements over prior work, but, as we discuss in more detail in §6, they do not offer public verification or zero knowledge.</p>

    <p class="text-gray-300">In addition to offering new properties, Pinocchio significantly improves performance and security. The systems shown in Figure 6 amortize setup work across many work instances, but the characteristics of the amortization differ. To reach a break-even point, where the client does less work verifying than performing the work locally, Pepper and Ginger must batch work instances, whereas GGP and Pinocchio must perform enough instances to amortize key setup costs. These approaches have very different effects on latency. A client cannot benefit from Pepper or Ginger until it has accumulated an entire batch of instances. In Pinocchio, key setup can be precomputed, and henceforth every instance (including the first one) enjoys a better-than-break-even latency. Figure 6 shows the minimum latency achievable by each system.</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_7.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;Figure 7: Cost of Verification Vs. Local. Verification must be cheaper than native execution for outsourcing to make sense, though for applications that want zero-knowledge, more expensive verification may be acceptable. All apps trend in the right direction, and three apps cross the plane where verification is cheaper than native. Error bars, often too small to see, represent 95% confidence intervals  <span class="math">(N = 50, \\sigma \\le 2\\%)</span> .</p>

    <p class="text-gray-300">Compared with Ginger, Pinocchio's verifier is  <span class="math">\\sim 120,000 \\times 17,000,000 \\times</span>  faster, and the worker is 19-60× faster. To improve performance, Ginger's parameters are chosen such that the probability that the adversary can successfully cheat can be as high as  <span class="math">\\frac{1}{2^{20}}</span>  [28, Figure 2], while in Pinocchio, the probability is roughly  <span class="math">\\frac{1}{128}</span> .</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-9-1&quot;&gt;&lt;/span&gt;5.3 End-to-End Application Performance</h4>

    <p class="text-gray-300">We measure Pinocchio's performance for the applications and parameter settings described in Section 4.3. All applications are written in C and compile to both QAPs and to native executables. We measure performance using 32-bit input values, so we can compare against the native C version. This obviously makes things more challenging for Pinocchio, since Pinocchio operates over a 254-bit field using multi-precision integers, whereas the local execution uses the CPU's native 32-bit operations.</p>

    <p class="text-gray-300">Figure 7 plots Pinocchio's verification time against the time to execute the same app natively; each line represents a parameterized app, and each point represents a particular parameter setting. Our key finding is that, for sufficiently large parameters, three apps cross the line where outsourcing makes sense; i.e., verifying the results of an outsourced computation is cheaper than local native execution. Note that the slope of each app's line is dictated by the size of the app parameters we experimented with (e.g., we reached larger parameters for fixed matrix than for two matrices).</p>

    <p class="text-gray-300">On the downside, the other three apps, while trending in the right direction, fail to cross the outsourcing threshold. The difference is that these three apps perform large numbers of inequality comparisons and/or bitwise operations. This makes our circuit-based representation less efficient relative</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-3&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;4&lt;/sup&gt; In contrast, Pinocchio's public verifier (not shown) enables a client to benefit from a third party's key setup work.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Mult</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">KeyGen Compute</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verify (ms)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Circuit Native EvalKey VerKey Proof</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">IO</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gates</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Pub (s)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(s)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Pub</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Priv</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(ms)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(ms)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(MB)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(KB)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(B)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Fixed Matrix, Medium</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,201</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">123.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Fixed Matrix, Large</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2,001</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">58.9 *10.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">337.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Two Matrices, Medium</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14,701</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">347,900</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">79.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">269.4 340.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">124.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">97.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">459.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Two Matrices, Large</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36,301 1,343,100</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">299.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1127.8 882.2 *15.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">509.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">374.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1134.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MultiVar Poly, Medium</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">203,428</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">246.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">93.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MultiVar Poly, Large</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">571,046</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">127.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">711.6 *12.7 *11.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">267.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">156.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Image Matching, Medium</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">86,345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Image Matching, Large</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">277,745</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">67.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">144.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">75.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Shortest Paths, Medium</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">513</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">366,089</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">85.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">198.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">99.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Shortest Paths, Large</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,153 1,400,493</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">317.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">850.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">69.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">381.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lattice Gas Sim, Medium</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">144,063</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">91.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lattice Gas Sim, Large</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">283,023</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">75.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">165.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">176.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">77.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23,785</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;Figure 8: Application Performance. <em>Pinocchio's performance for a sampling of the parameter settings (</em>§<em><a href="#page-8-3">4.3)</a>. All programs are compiled directly from C. Private</em> KeyGen <em>is always within 0.4% of public</em> KeyGen<em>, and so is omitted. Verification values in bold indicate verification is cheaper than computing the circuit locally; those with stars (\\</em>) indicate verification is cheaper than native execution.* (<em>N</em> = 50,σ ≤ 2%)<em>.</em></p>

    <p class="text-gray-300">to native, and hence on our current experimental platform, we cannot push the application parameter settings to the point where they would beat local execution. Nonetheless, these applications may still be useful in settings that require Pinocchio's zero-knowledge proofs.</p>

    <p class="text-gray-300">Fortunately, additional experiments show that enabling zero-knowledge proofs adds a negligible, fixed cost to key generation (213<em>µ</em>s), and re-randomizing a proof to make it zero-knowledge requires little effort (e.g., 300ms or 0.1% for the multivariate polynomial app).</p>

    <p class="text-gray-300">Figure <a href="#page-10-0">8</a> provides more details of Pinocchio's performance. For KeyGen, our experiments conservatively assume that the client does no precomputation in anticipation of outsourcing a function, and for Compute, we assume that the worker only does a single work instance before throwing away all of its state. As discussed in §<a href="#page-7-1">4.2.1,</a> in practice, we would take advantage of both precomputation and caching of previous work, which on average saves at least 43% of the effort for KeyGen and 16% of the effort for Compute.</p>

    <p class="text-gray-300">In Figure <a href="#page-10-0">8,</a> we see again that three apps (starred) beat native execution, including one in the public verifier setting (which requires more expensive operations per IO). The data also reinforces the point that using a circuit representation imposes a significant cost on image matching, shortest paths, and the lattice gas sim relative to native, suggesting a target for optimization. Relative to the circuit representation, Pinocchio's verification is cheap: both the public and the designated verifier &quot;win&quot; most of the time when compared to the circuit execution. Specifically, the designated verifier wins in 12 of 13 (92%) application settings. Public verification is more expensive, particularly for large IO, but still wins in 9 of 13 (69%) settings.</p>

    <p class="text-gray-300">Since Pinocchio offers public verification, some clients will benefit from the KeyGen work of others, and hence only care about the verification costs. For example, a cellphone carrier might perform the one-time KeyGen so that its customers can verify computations done by arbitrary workers.</p>

    <p class="text-gray-300">However, in other settings, e.g., a company outsourcing work to the cloud, the key generator and verifier may be the same entity, and will wish to amortize the cost of key generation via the savings from verification. Figure <a href="#page-10-0">8</a> shows that most apps have a low &quot;break even&quot; point vs. circuit execution: the median for the designated verifier is 555 instances and for public verifier is 500 instances,<a href="#page-10-1">5</a> both with a low of 5 instances for fixed matrix. Every instance afterwards is a net &quot;win&quot;, even for the key generator. The median break-even points are higher (70K and 605K) when compared against native execution, since the outsourcing margin is relatively small for the current parameter settings. Larger parameter settings, improved verification techniques, or comparing against a big integer library instead of native execution <a href="#page-13-24">[27,</a> <a href="#page-13-0">28]</a> would all bring these values down.</p>

    <p class="text-gray-300">Figure <a href="#page-10-0">8</a> holds more good news for Pinocchio: the keys it generates are reasonably sized, with the evaluation key (which describes the entire computation) typically requiring 10s or 100s of MB. The weak verifier's key (which grows linearly with the I/O) is typically only a few KB, and even at its largest, for two-matrix multiplication, it requires only slightly more than 1 MB. This suggests that the keys are quite portable and will not require excessive bandwidth to transmit.</p>

    <p class="text-gray-300">Finally, from the client's perspective, if the worker's efforts are free, then the worker's additional overhead of generating a proof is irrelevant, as long as it doesn't hurt response latency. Our results, combined with prior work on parallelization <a href="#page-13-0">[28]</a>, suggest that latency can be brought down to reasonable levels, given enough hardware. And indeed in high-assurance scenarios, scenarios where the client is incapable of performing the calculation itself (e.g., a power-limited device), or scenarios where the worker's resources are otherwise idle, the client may very well view the worker as &quot;free&quot;.</p>

    <p class="text-gray-300">However, in other scenarios, such as cloud computing, the worker's efforts are not free. Even here, however, Chen and</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;5&lt;/sup&gt;The public verifier's median is lower, since it wins on fewer app settings.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">GGPR [30]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">This Paper</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reduction</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KeyGen</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">108.7s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41.9s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Build table</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.8s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.9s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-2%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Encode powers of s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28.4s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.7s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Eval polys at s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.0s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.7s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Encode polys</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">67.2s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27.4s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compute</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">691.4s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">246.1s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Solve for h(x)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">252.3s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76.3s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">70%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Apply coefficients</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">391.1s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">154.7s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.2ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.6ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Process I/O</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">456.5µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">901.8µs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-98%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Crypto checks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.8ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.7ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Evaluation Key Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105.5MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55.9MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verification Key Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">640B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">640B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proof Size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">352B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18%</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-11-3&quot;&gt;&lt;/span&gt;Figure 9: Improving GGPR <a href="#page-13-2">[30]</a>. <em>Performance for the multivariate polynomial application. Pinocchio's high-level operations are 2.6x, 2.8x, and 1.3x faster than the original.</em> (<em>N</em> = 10,σ ≤ 2%)<em>.</em></p>

    <p class="text-gray-300">Sion estimate that the cost of cloud computing is about 60× cheaper than local computing for a small enterprise <a href="#page-13-28">[54]</a>. This provides an approximate upper-bound for the amount of extra work we should be willing to add to the worker's overhead. While we do not yet achieve this bound, we make substantial progress on reducing the worker's overhead, and the progress shown in Figure <a href="#page-9-2">6(</a>b) gives us hope.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;5.4 Impact of Our Optimizations</h3>

    <p class="text-gray-300">In Figure <a href="#page-11-3">9,</a> we break down Pinocchio's protocol overhead for the large multivariate polynomial example application, to better identify the major bottlenecks. For comparison, we also measure the performance of our implementation of GGPR's scheme <a href="#page-13-2">[30]</a>, using the same underlying cryptographic and polynomial libraries.</p>

    <p class="text-gray-300">The results indicate that our protocol improvements had a significant impact. KeyGen and Compute are more than twice as fast, and even verification is 24% faster. Of Pinocchio's remaining KeyGen overhead, the majority comes from encoding the evaluations of the QAP's polynomials in the generator's exponent. For Compute, the multi-exponentiation required to compute the QAP's polynomials in the exponent still dominate, but the overhead of solving for <em>h</em>(<em>x</em>) is nontrivial as well.</p>

    <p class="text-gray-300">Pinocchio also drastically reduces the size of the evaluation key and even manages to reduce the size of GGPR's already svelte 9 element proof to 8 elements.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-11-2&quot;&gt;&lt;/span&gt;5.5 QSPs versus QAPs</h3>

    <p class="text-gray-300">Finally, to confirm our theoretical prediction that QAPs would outperform QSPs (§<a href="#page-5-1">3.2)</a>, we compared the two on our SHA-1 application, which performs numerous bitwise operations, and hence should favor QSPs. The resulting QSP's size was 38.6× that of the QAP, and the degree was 55.5× as large. Not surprisingly, the QSP's KeyGen took 35.2× and Compute took 55.4× as long as those of the QAP; the verification times were comparable.</p>

    <p class="text-gray-300">Much of the prior work in this area focuses on verifying specific functions via auditing or special properties of the functions <a href="#page-12-1">[2</a><a href="#page-12-2">–6]</a>. Other systems rely on replication, and hence assume failures are uncorrelated <a href="#page-12-0">[1,</a> <a href="#page-12-3">7,</a> <a href="#page-12-4">8,</a> <a href="#page-13-29">55]</a>. A large body of work verifies computation by assuming the worker employs secure hardware <a href="#page-12-5">[9–</a><a href="#page-12-8">15]</a>.</p>

    <p class="text-gray-300">While the theory and cryptography community has long studied the problem of general-purpose proof systems <a href="#page-12-9">[16–</a> <a href="#page-12-10">23]</a>, until recently, this work was largely regarded as highly impractical, to the point where no one bothered to implement it. Much of this work <a href="#page-12-9">[16</a><a href="#page-12-16">–20,</a> <a href="#page-13-30">56]</a> relied on Probabilistically Checkable Proofs (PCPs), which offer impressive theoretical performance, but which can take trillions of years to verify in practice <a href="#page-13-24">[27]</a>. Other work <a href="#page-12-14">[22,</a> <a href="#page-12-10">23]</a> relies on fullyhomomorphic encryption (FHE) <a href="#page-12-12">[24]</a>, which, despite continuing advances <a href="#page-13-27">[53]</a>, remains highly impractical.</p>

    <p class="text-gray-300">Recently, security and systems researchers have started to develop techniques to make theoretical cryptographic protocols practical. Secure multiparty computation, for example, has seen tremendous progress <a href="#page-13-31">[57</a><a href="#page-13-32">–59]</a>. However, since the primary focus is on secrecy, not outsourcing, both parties typically perform work equal to evaluating the function.</p>

    <p class="text-gray-300">With regard to implementing verified computation, in the last year, two parallel efforts have emerged. One effort <a href="#page-12-13">[25,</a> <a href="#page-13-33">26]</a> builds on the interactive proofs of Goldwasser et al. <a href="#page-12-16">[20]</a> (GKR), which draw on many techniques from the PCP literature. They target a streaming setting where the client cannot store all of the data it wishes to compute over; the system currently requires the function computed to be highly parallelizable. On the plus side, it does not require cryptography, and it is secure against computationally unbounded adversaries.</p>

    <p class="text-gray-300">Setty et al. produced a line of PCP-based systems called Pepper <a href="#page-13-24">[27]</a> and Ginger <a href="#page-13-0">[28]</a>. They build on a particular type of PCP called a linear PCP <a href="#page-13-26">[52]</a>, in which the proof can be represented as a linear function. This allows the worker to use a linearly-homomorphic encryption scheme to create a commitment to its proof while relying only on standard cryptographic assumptions. Through a combination of theoretical and systems-level improvements, this work made tremendous progress in making PCP-based systems practical. Indeed, for applications that can tolerate large batch sizes, the amortized costs of verification can be quite low.</p>

    <p class="text-gray-300">A few downsides remain, however. Because the work builds on the Hadamard PCP <a href="#page-13-30">[56]</a>, the setup time, network overhead, and the prover's work are quadratic in the size of the original computation, unless the protocol is hand-tailored. To achieve efficiency, the verifier must outsource computations in batches, which means it cannot verify the results until the full batch returns. The scheme is designated verifier, meaning that third parties cannot verify the results of outsourced computations without sharing the client's secret key, and hence opening the possibility for fraud. The scheme also does not support zero-knowledge proofs.</p>

    <p class="text-gray-300">Concurrent work <a href="#page-13-34">[60]</a> also builds on the quadratic programs of Gennaro et al <a href="#page-13-2">[30]</a>. They observe that QAPs can be viewed as linear PCPs and hence can fit into Ginger's cryptographic framework <a href="#page-13-0">[28]</a>. Their work shows worker computation improvements similar to those of Pinocchio. Additional concurrent work <a href="#page-13-35">[61]</a> adapts previous GKR-based protocols <a href="#page-12-13">[25,</a> <a href="#page-13-33">26]</a> to the batching model and develops a compiler that chooses amongst three PCP-based backends. Both systems retain PCPs and Ginger's cryptographic protocol, so they rely on simpler cryptographic assumptions than Pinocchio, but they must still batch computations to obtain an efficient verifier. They also remain designated verifier and do not support zero-knowledge proofs.</p>

    <p class="text-gray-300">Previous systems either did not offer a compiler <a href="#page-12-13">[25–</a><a href="#page-13-24">27]</a>, or compiled from a subset of an academic language, SFDL <a href="#page-13-0">[28,</a> <a href="#page-13-34">60]</a>. In contrast, we compile from a subset of C, which should ease the development burden for verifying computation.</p>

    <p class="text-gray-300">Several systems provide compilers for zero-knowledge (ZK) proofs <a href="#page-13-36">[62</a><a href="#page-13-37">–64]</a>. Both the systems of Almeida et al. <a href="#page-13-36">[62]</a> and Meiklejohn et al. <a href="#page-13-38">[63]</a> adopt an approach based on Σprotocols <a href="#page-13-39">[65]</a>. The former provides functionality for proving knowledge in arbitrary groups, AND and OR compositions, and linear relations. The latter focuses on functionalities for cryptographic protocols, e.g., e-cash, blind signatures, or verifiable encryption. The compiler of Backes et al. <a href="#page-13-37">[64]</a> uses Groth-Sahai ZK proofs <a href="#page-13-40">[66]</a> and handles logical formulas. Rial and Danezis <a href="#page-13-4">[32]</a> propose a system for privacypreserving smart metering in which clients use a ZK protocol to prove correctness of the billing computation they perform on meter readings. In general, these systems are likely to exhibit better performance than Pinocchio for their particular subset of functionality, but they do not possess the same level of efficient generality.</p>

    <h2 id="sec-22" class="text-2xl font-bold">7 Conclusion and Future Work</h2>

    <p class="text-gray-300">We have presented Pinocchio, a system for public verifiable computing. Pinocchio uses quadratic programs, a new method for encoding computation, combined with a highly efficient cryptographic protocol to achieve both asymptotic and concrete efficiency. Pinocchio produces 288-byte proofs, regardless of the size of the computation, and the proofs can be verified rapidly, typically in tens of milliseconds, beating native execution in several cases. This represents five to seven <em>orders of magnitude</em> performance improvement over prior work. The worker also produces the proof 19-60× faster. Pinocchio even slashes the cost of its underlying protocol, cutting the cost of both key and proof generation by more than 60%. The end result is a natural cryptographic protocol for efficiently signing computations. Combined with a compiler for real C programs, Pinocchio brings verifiable computation much closer to practicality.</p>

    <p class="text-gray-300">Nonetheless gaps still remain. We hope that additional theoretic improvements, combined with efforts to expand our toolchain, e.g., to support floating point or parallel execution (via standard techniques <a href="#page-12-13">[25,</a> <a href="#page-13-0">28,</a> <a href="#page-13-16">43]</a>), will continue to advance us towards truly practical verifiable computing.</p>

    <h2 id="sec-23" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors gratefully thank: Peter Montgomery, Michael Naehrig, and Patrick Longa for assisting us with the cryptographic library used by Pinocchio; Chris Hawblitzel for his sage guidance on compiler development; Rosario Gennaro for valuable discussions; and the anonymous reviewers for their helpful comments. Mariana Raykova was supported by NSF Grant No. 1017660.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;[1] D. P. Anderson, J. Cobb, E. Korpela, M. Lebofsky, and D. Werthimer, &quot;SETI@Home: An experiment in public-resource computing,&quot; <em>Communications of the ACM</em>, vol. 45, no. 11, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;[2] F. Monrose, P. Wyckoff, and A. Rubin, &quot;Distributed execution with remote audit,&quot; in <em>Proc. of ISOC NDSS</em>, 1999.</p></li>
      <li><p class="text-gray-300">[3] P. Golle and S. G. Stubblebine, &quot;Secure distributed computing in a commercial environment,&quot; in <em>Proc. of Financial Cryptography</em>, 2002.</p></li>
      <li><p class="text-gray-300">[4] W. Du and M. T. Goodrich, &quot;Searching for high-value rare events with uncheatable grid computing,&quot; in <em>ACNS</em>, 2005.</p></li>
      <li><p class="text-gray-300">[5] P. Golle and I. Mironov, &quot;Uncheatable distributed computations,&quot; in <em>Proc. of CT-RSA</em>, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt;[6] R. Sion, &quot;Query execution assurance for outsourced databases,&quot; in <em>The Very Large Databases Conference (VLDB)</em>, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-3&quot;&gt;&lt;/span&gt;[7] M. Castro and B. Liskov, &quot;Practical Byzantine fault tolerance and proactive recovery,&quot; <em>ACM Trans. on Comp. Sys.</em>, vol. 20, no. 4, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-4&quot;&gt;&lt;/span&gt;[8] B. Carbunar and R. Sion, &quot;Uncheatable reputation for distributed computation markets,&quot; in <em>Financial Cryptography</em>, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-5&quot;&gt;&lt;/span&gt;[9] R. Sailer, X. Zhang, T. Jaeger, and L. van Doorn, &quot;Design and implementation of a TCG-based integrity measurement architecture,&quot; in <em>Proc. of the USENIX Security</em>, 2004.</p></li>
      <li><p class="text-gray-300">[10] L. Chen, R. Landfermann, H. Lohr, M. Rohe, A.-R. Sadeghi, and ¨ C. Stuble, &quot;A protocol for property-based attestation,&quot; in ¨ <em>Proc. of the ACM Workshop on Scalable Trusted Computing (STC)</em>, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-6&quot;&gt;&lt;/span&gt;[11] B. Parno, J. M. McCune, and A. Perrig, <em>Bootstrapping Trust in Modern Computers</em>. Springer, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-7&quot;&gt;&lt;/span&gt;[12] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. VanDoorn, and P. Khosla, &quot;Pioneer: Verifying integrity and guaranteeing execution of code on legacy platforms,&quot; in <em>Proc. of the ACM SOSP</em>, 2005.</p></li>
      <li><p class="text-gray-300">[13] R. B. Lee, P. Kwan, J. P. McGregor, J. Dwoskin, and Z. Wang, &quot;Architecture for protecting critical secrets in microprocessors,&quot; in <em>Proc. of the International Symposium on Computer Architecture (ISCA)</em>, 2005.</p></li>
      <li><p class="text-gray-300">[14] D. Lie, C. A. Thekkath, M. Mitchell, P. Lincoln, D. Boneh, J. C. Mitchell, and M. Horowitz, &quot;Architectural support for copy and tamper resistant software,&quot; in <em>Proc. of the ACM ASPLOS</em>, 2000.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-8&quot;&gt;&lt;/span&gt;[15] A.-R. Sadeghi, T. Schneider, and M. Winandy, &quot;Token-based cloud computing: secure outsourcing of data and arbitrary computations with lower latency,&quot; in <em>TRUST</em>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-9&quot;&gt;&lt;/span&gt;[16] S. Goldwasser, S. Micali, and C. Rackoff, &quot;The knowledge complexity of interactive proof systems,&quot; <em>SIAM J. Comput.</em>, vol. 18, no. 1, 1989.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-11&quot;&gt;&lt;/span&gt;[17] S. Arora and S. Safra, &quot;Probabilistic checking of proofs: A new characterization of NP,&quot; <em>J. ACM</em>, vol. 45, no. 1, pp. 70–122, 1998.</p></li>
      <li><p class="text-gray-300">[18] J. Kilian, &quot;A note on efficient zero-knowledge proofs and arguments (extended abstract),&quot; in <em>STOC</em>, 1992.</p></li>
      <li><p class="text-gray-300">[19] S. Micali, &quot;Computationally sound proofs,&quot; <em>SIAM J. Comput.</em>, vol. 30, no. 4, pp. 1253–1298, 2000. Extended abstract in FOCS '94.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-16&quot;&gt;&lt;/span&gt;[20] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum, &quot;Delegating computation: Interactive proofs for muggles,&quot; in <em>STOC</em>, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-15&quot;&gt;&lt;/span&gt;[21] J. Groth, &quot;Short pairing-based non-interactive zero-knowledge arguments,&quot; in <em>ASIACRYPT</em>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-14&quot;&gt;&lt;/span&gt;[22] R. Gennaro, C. Gentry, and B. Parno, &quot;Non-interactive verifiable computing: Outsourcing computation to untrusted workers,&quot; 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-10&quot;&gt;&lt;/span&gt;[23] K.-M. Chung, Y. T. Kalai, and S. P. Vadhan, &quot;Improved delegation of computation using fully homomorphic encryption,&quot; in <em>CRYPTO</em>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-12&quot;&gt;&lt;/span&gt;[24] C. Gentry, <em>A fully homomorphic encryption scheme</em>. PhD thesis, Stanford University, 2009. &lt;crypto.stanford.edu/craig&gt;.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-12-13&quot;&gt;&lt;/span&gt;[25] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pfister, &quot;Verifiable computation with massively parallel interactive proofs,&quot; in <em>USENIX HotCloud Workshop</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-33&quot;&gt;&lt;/span&gt;[26] G. Cormode, M. Mitzenmacher, and J. Thaler, &quot;Practical verified computation with streaming interactive proofs,&quot; in <em>ITCS</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-24&quot;&gt;&lt;/span&gt;[27] S. Setty, R. McPherson, A. J. Blumberg, and M. Walfish, &quot;Making argument systems for outsourced computation practical (sometimes),&quot; in Proceedings of the ISOC NDSS, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;[28] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish, &quot;Taking proof-based verified computation a few steps closer to practicality,&quot; in <em>Proc. of USENIX Security</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;[29] B. Parno, M. Raykova, and V. Vaikuntanathan, &quot;How to delegate and verify in public: Verifiable computation from attribute-based encryption,&quot; in <em>IACR Theory of Cryptography Conference (TCC)</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-2&quot;&gt;&lt;/span&gt;[30] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, &quot;Quadratic span programs and succinct NIZKs without PCPs,&quot; in <em>EUROCRYPT</em>, 2013. Originally published as Cryptology ePrint Archive, Report 2012/215.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-3&quot;&gt;&lt;/span&gt;[31] M. Blum, A. D. Santis, S. Micali, and G. Persiano, &quot;Noninteractive zero-knowledge,&quot; SIAM J. on Computing, vol. 20, no. 6, 1991.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-4&quot;&gt;&lt;/span&gt;[32] A. Rial and G. Danezis, &quot;Privacy-preserving smart metering,&quot; in <em>Proc.</em> of the ACM WPES, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-5&quot;&gt;&lt;/span&gt;[33] N. Pippenger and M. J. Fischer, &quot;Relations among complexity measures,&quot; J. ACM, vol. 26, no. 2, 1979.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-6&quot;&gt;&lt;/span&gt;[34] D. Boneh and M. Franklin, &quot;Identity-based encryption from the Weil pairing,&quot; <em>Proceedings of IACR CRYPTO</em>, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-8&quot;&gt;&lt;/span&gt;[35] D. Boneh, X. Boyen, and E.-J. Goh, &quot;Hierarchical identity based encryption with constant size ciphertext,&quot; in EUROCRYPT, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-9&quot;&gt;&lt;/span&gt;[36] D. Boneh, C. Gentry, and B. Waters, &quot;Collusion resistant broadcast encryption with short ciphertexts and private keys,&quot; in CRYPTO, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-10&quot;&gt;&lt;/span&gt;[37] M. Naor, &quot;On cryptographic assumptions and challenges,&quot; in <em>Proceedings of IACR CRYPTO</em>, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-11&quot;&gt;&lt;/span&gt;[38] M. Bellare and A. Palacio, &quot;The knowledge-of-exponent assumptions and 3-round zero-knowledge protocols,&quot; in CRYPTO, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-12&quot;&gt;&lt;/span&gt;[39] C. Gentry and D. Wichs, &quot;Separating succinct non-interactive arguments from all falsifiable assumptions,&quot; in STOC, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-13&quot;&gt;&lt;/span&gt;[40] I. Damgård, &quot;Towards practical public key systems secure against chosen ciphertext attacks,&quot; in IACR CRYPTO, 1991.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-14&quot;&gt;&lt;/span&gt;[41] &quot;Verifiable computation: Pinocchio.&quot; http://research.microsoft.com/verifcomp/, Mar. 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-15&quot;&gt;&lt;/span&gt;[42] D. A. Wheeler, &quot;SLOCCount.&quot; http://www.dwheeler.com/ sloccount/.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-16&quot;&gt;&lt;/span&gt;[43] M. Aliasgari, M. Blanton, Y. Zhang, and A. Steele, &quot;Secure computation on floating point numbers,&quot; in <em>Proc. of ISOC NDSS</em>, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-17&quot;&gt;&lt;/span&gt;[44] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith, &quot;Secure two-party computations in ANSI C,&quot; in <em>Proc. of ACM CCS</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-18&quot;&gt;&lt;/span&gt;[45] M. Naehrig, R. Niederhagen, and P. Schwabe, &quot;New software speed records for cryptographic pairings,&quot; in <em>Proc. of LATINCRYPT</em>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-19&quot;&gt;&lt;/span&gt;[46] P. S. L. M. Barreto and M. Naehrig, &quot;Pairing-friendly elliptic curves of prime order,&quot; in Selected Areas in Cryptography (SAC), 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-20&quot;&gt;&lt;/span&gt;[47] N. Pippenger, &quot;On the evaluation of powers and related problems (preliminary version),&quot; in <em>Proc. of FOCS</em>, 1976.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-21&quot;&gt;&lt;/span&gt;[48] A. Aho, J. Hopcroft, and J. Ulman, The Design and Analysis of Computer Algorithms. Addison-Wesley, 1974.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-22&quot;&gt;&lt;/span&gt;[49] G. Adomavicius and A. Tuzhilin, &quot;Toward the next generation of recommender systems: A survey of the state-of-the-art and possible extensions,&quot; <em>Trans. Knowledge and Data Engineering</em>, vol. 17, no. 6, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-23&quot;&gt;&lt;/span&gt;[50] D. A. Wolf-Gladrow, Lattice-Gas Cellular Automata and Lattice Boltzmann Models: An Introduction. Springer, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-25&quot;&gt;&lt;/span&gt;[51] R. Motwani and P. Raghavan, Randomized Algorithms. Cambridge University Press, 1995.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-26&quot;&gt;&lt;/span&gt;[52] Y. Ishai, E. Kushilevitz, and R. Ostrovsky, &quot;Efficient arguments without short PCPs,&quot; in <em>IEEE Conference on Computational Complexity</em>, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-27&quot;&gt;&lt;/span&gt;[53] C. Gentry, S. Halevi, and N. Smart, &quot;Homomorphic evaluation of the AES circuit,&quot; in <em>Proceedings of CRYPTO</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-28&quot;&gt;&lt;/span&gt;[54] Y. Chen and R. Sion, &quot;To cloud or not to cloud? Musings on costs and viability,&quot; in <em>Proc. of the ACM Symposium on Cloud Computing</em>, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-29&quot;&gt;&lt;/span&gt;[55] G. O. Karame, M. Strasser, and S. Capkun, &quot;Secure remote execution of sequential computations,&quot; in <em>Intl. Conf. on Information and Commu</em>nications Security, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-30&quot;&gt;&lt;/span&gt;[56] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy, &quot;Proof verification and the hardness of approximation problems,&quot; <em>J. ACM</em>, vol. 45, no. 3, 1998.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-31&quot;&gt;&lt;/span&gt;[57] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella, &quot;Fairplay—a secure twoparty computation system,&quot; in <em>Proc. of USENIX Security</em>, 2004.</p></li>
      <li><p class="text-gray-300">[58] Y. Huang, D. Evans, J. Katz, and L. Malka, &quot;Faster secure two-party computation using garbled circuits,&quot; in <em>USENIX Security</em>, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-32&quot;&gt;&lt;/span&gt;[59] B. Kreuter, abhi shelat, and C.-H. Shen, &quot;Billion-gate secure computation with malicious adversaries,&quot; in <em>Proc. of USENIX Security</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-34&quot;&gt;&lt;/span&gt;[60] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish, &quot;Resolving the conflict between generality and plausibility in verified computation,&quot; in <em>Proc. of the ACM European Conference on Computer Systems (EuroSys)</em>, Apr. 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-35&quot;&gt;&lt;/span&gt;[61] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish, &quot;A hybrid architecture for interactive verifiable computation,&quot; in <em>IEEE Symposium on Security</em> and Privacy, May 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-36&quot;&gt;&lt;/span&gt;[62] J. B. Almeida, E. Bangerter, M. Barbosa, S. Krenn, A.-R. Sadeghi, and T. Schneider, &quot;A certifying compiler for zero-knowledge proofs of knowledge based on σ-protocols,&quot; in <em>Proc. of ESORICS</em>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-38&quot;&gt;&lt;/span&gt;[63] S. Meiklejohn, C. C. Erway, A. Küpçü, T. Hinkle, and A. Lysyanskaya, &quot;ZKPDL: A language-based system for efficient zero-knowledge proofs and electronic cash,&quot; in <em>Proc. of USENIX</em>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-37&quot;&gt;&lt;/span&gt;[64] M. Backes, M. Maffe, and K. Pecina, &quot;Automated synthesis of privacypreserving distributed applications,&quot; in <em>Proc. of ISOC NDSS</em>, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-39&quot;&gt;&lt;/span&gt;[65] R. Cramer, I. Damgård, and B. Schoenmakers, &quot;Proofs of partial knowledge and simplified design of witness hiding protocols,&quot; in <em>Proc.</em> of CRYPTO, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-40&quot;&gt;&lt;/span&gt;[66] J. Groth and A. Sahai, &quot;Efficient non-interactive proof systems for bilinear groups,&quot; in <em>Proc. of EUROCRYPT</em>, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-41&quot;&gt;&lt;/span&gt;[67] D. Boneh and X. Boyen, &quot;Short signatures without random oracles,&quot; in EUROCRYPT, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-13-42&quot;&gt;&lt;/span&gt;[68] R. Gennaro, &quot;Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks.&quot; in CRYPTO, 2004.</p></li>
    </ul>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-13-7&quot;&gt;&lt;/span&gt;A Cryptographic Assumptions</h3>

    <p class="text-gray-300">We define the hardness assumptions that we use in the security proof of our optimized VC construction from Section 3.1. Suppose  <span class="math">(p, \\mathbb{G}, \\mathbb{G}_T, e) \\leftarrow \\mathcal{G}(1^{\\kappa})</span>  outputs a description of a cyclic bilinear group [34] of order p, a  <span class="math">\\kappa</span> -bit prime, where  <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span>  is the usual pairing (bilinear map) function. Below, let  <span class="math">\\kappa</span>  be a security parameter,  <span class="math">q = \\text{poly}(\\kappa)</span> , and let  <span class="math">\\mathcal{A}</span>  be a non-uniform probabilistic polynomial time adversary.</p>

    <p class="text-gray-300"><strong>Assumption 1</strong> (q-<strong>PDH [21]</strong>) The q-power Diffie-Hellman (q-PDH) assumption holds for G if for all A we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} Pr[ &amp; \\quad (p, \\mathbb{G}, \\mathbb{G}_T, e) \\leftarrow \\mathcal{G}(1^{\\kappa}) \\; ; \\; g \\leftarrow \\mathbb{G} \\backslash \\{1\\} \\; ; \\; s \\leftarrow \\mathbb{Z}_p^* \\; ; \\\\ &amp; \\quad \\sigma \\leftarrow (p, \\mathbb{G}, \\mathbb{G}_T, e, g, g^s, \\dots, g^{s^q}, g^{s^{q+2}}, \\dots, g^{s^{2q}}) \\; ; \\\\ &amp; \\quad y \\leftarrow \\mathcal{A}(\\sigma) \\; : \\; y = g^{s^{q+1}}] = \\mathtt{negl}(\\kappa). \\end{split}</span>$</p>

    <p class="text-gray-300"><strong>Assumption 2</strong> (<em>q</em>-<strong>PKE</strong> [21]) The <em>q</em>-power knowledge of exponent assumption holds for G if for all A there exists a non-uniform probabilistic polynomial time extractor  <span class="math">\\chi_A</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} Pr[ &amp; \\quad (p, \\mathbb{G}, \\mathbb{G}_T, e) \\leftarrow \\mathcal{G}(1^{\\kappa}) \\; ; \\; g \\leftarrow \\mathbb{G} \\backslash \\{1\\} \\; ; \\; \\alpha, s \\leftarrow \\mathbb{Z}_p^* \\; ; \\\\ &amp; \\quad \\sigma \\leftarrow (p, \\mathbb{G}, \\mathbb{G}_T, e, g, g^s, \\ldots, g^{s^q}, g^{\\alpha}, g^{\\alpha s}, \\ldots, g^{\\alpha s^q}) \\; ; \\\\ &amp; \\quad (c, \\hat{c} \\; ; \\; a_0, \\ldots, a_q) \\leftarrow (\\mathcal{A} \\parallel \\chi_{\\mathcal{A}})(\\sigma, z) \\; : \\\\ &amp; \\quad \\hat{c} = c^{\\alpha} \\wedge c \\neq \\prod_{i=0}^q g^{a_i s^i}] = \\mathtt{negl}(\\kappa) \\end{split}</span>$</p>

    <p class="text-gray-300">for any auxiliary information  <span class="math">z \\in \\{0,1\\}^{\\text{poly}(\\kappa)}</span>  that is generated independently of  <span class="math">\\alpha</span> . Note that  <span class="math">(y;z) \\leftarrow (\\mathcal{A} \\parallel \\chi_{\\mathcal{A}})(x)</span>  signifies that on input x,  <span class="math">\\mathcal{A}</span>  outputs y, and that  <span class="math">\\chi_{\\mathcal{A}}</span> , given the same input x and  <span class="math">\\mathcal{A}</span> 's random tape, produces z.</p>

    <p class="text-gray-300"><strong>Assumption 3</strong> (<em>q</em>-<strong>SDH</strong> [67, 68]) The Diffie-Hellman (q-SDH) assumption holds for G if for all A:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} Pr[ &amp; \\quad (p, \\mathbb{G}, \\mathbb{G}_T, e) \\leftarrow \\mathcal{G}(1^{\\kappa}) \\; ; \\; g \\leftarrow \\mathbb{G} \\backslash \\{1\\} \\; ; \\; s \\leftarrow \\mathbb{Z}_p^* \\; ; \\\\ &amp; \\quad \\sigma \\leftarrow (p, \\mathbb{G}, \\mathbb{G}_T, e, g, g^s, \\dots, g^{s^q}) \\; ; \\\\ &amp; \\quad y \\leftarrow \\mathcal{A}(\\sigma) \\; : \\; y = e(g, g)^{\\frac{1}{s+c}}, c \\in \\mathbb{Z}_p^*] = \\mathtt{negl}(\\kappa). \\end{split}</span>$</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;<strong>Security Proof for Our VC Scheme</strong></h3>

    <p class="text-gray-300">To prove Theorem 1, we assume there exists an adversary  <span class="math">\\mathcal{A}_{vc}</span> who returns a cheating proof, and we show how to construct an adversary  <span class="math">\\mathcal{B}</span>  that uses  <span class="math">\\mathcal{A}_{vc}</span>  and a d-PKE assumption knowledge extractor [21] to break either the q-PDH assumption [21] or the 2q-SDH assumption [67, 68], where q = 4d + 4. These assumptions are defined in Appendix A.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{B}</span>  be given a challenge  <span class="math">g, g^s, \\dots, g^{s^q}, g^{s^{q+2}}, \\dots, g^{s^{2q}}</span> . (This challenge can be interpreted as either a q-PDH instance, or a subset (missing  <span class="math">g^{sq+1}</span> ) of a 2<em>q</em>-SDH instance.)  <span class="math">\\mathcal{A}_{vc}</span>  generates a function f with N input/output wires that has a QAP  <span class="math">Q_f = (t(x), \\mathcal{V}, \\mathcal{W}, \\mathcal{Y})</span>  of size m and degree d. (So that this proof covers the zero-knowledge variant of the VC scheme, we include t(x) in each of the sets  <span class="math">\\mathcal{V}, \\mathcal{W}, \\mathcal{Y}</span> .) Let  <span class="math">I_{mid} = \\{N+1,...,m\\}</span> , i.e., the non-IO-related indices.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  provides evaluation and verification keys to  <span class="math">\\mathcal{A}_{vc}</span> , using</p>

    <p class="text-gray-300">the same structure as in Protocol 2:
<span class="math">$EK = \\left(\\begin{array}{cc} \\{g_{v}^{\\gamma_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{w}^{w_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{v}^{\\gamma_{k}(s)}\\}_{k \\in I_{mid}}, \\\\ \\{g_{v}^{\\alpha_{v} \\gamma_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{w}^{\\alpha_{w} w_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{y}^{\\alpha_{y} y_{k}(s)}\\}_{k \\in I_{mid}}, \\\\ \\{g_{v}^{\\alpha_{v} \\gamma_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{w}^{\\alpha_{w} w_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{v}^{\\alpha_{y} y_{k}(s)}\\}_{k \\in I_{mid}}, \\\\ \\{g_{v}^{s&#x27;}\\}_{i \\in [d]}, &amp; \\{g_{v}^{\\beta_{v} k(s)}g_{w}^{\\beta_{w} k(s)}g_{y}^{\\beta_{v} y_{k}(s)}\\}_{k \\in I_{mid}}, \\\\ VK_{F} = (g, g^{\\alpha_{v}}, g^{\\alpha_{w}}, g^{\\alpha_{y}}, g^{\\gamma}, g^{\\beta\\gamma}, \\{g_{v}^{\\gamma_{k}(s)}, g_{w}^{w_{k}(s)}, g_{y}^{\\gamma_{k}(s)}\\}_{k \\in \\{0\\} \\cup I_{io}}, \\\\ g_{y}^{t(s)}), &amp; \\text{where } r_{v}&#x27;, r_{w}&#x27;, \\alpha_{v}, \\alpha_{w}, \\text{ and } \\alpha_{y} \\text{ are chosen uniformly at random,} \\\\ r_{y}&#x27; = r_{v}&#x27;r_{w}&#x27;, g_{v} = g^{r_{v}&#x27;, s^{d+1}}, g_{w} = g^{r_{w}&#x27;, s^{2(d+1)}}, \\text{ and } g_{y} = g^{r_{y}&#x27;, s^{3(d+1)}}, \\\\ \\text{and the values } \\beta \\text{ and } \\gamma \\text{ are set as described next.}</span>$</p>

    <p class="text-gray-300">Regarding  <span class="math">\\beta</span> , write the final proof term with g as the base:  <span class="math">g_{\\nu}^{\\beta\\nu(s)}g_{w}^{\\beta w(s)}g_{\\nu}^{\\beta y(s)} = g^{\\beta(r&#x27;_{\\nu}s^{d+1}\\nu(s) + r&#x27;_{w}s^{2(d+1)}w(s) + r&#x27;_{y}s^{3(d+1)}y(s))}. \\quad (3)</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;That is, in the exponent,  <span class="math">\\beta</span>  is multiplied with a certain polynomial that is evaluated at s.  <span class="math">\\mathcal{B}</span>  also generates  <span class="math">\\beta</span>  as a polynomial evaluated at s. In particular, it sets  <span class="math">\\beta = s^{q-(4d+3)}\\beta_{poly}(s)</span> , where  <span class="math">\\beta_{poly}(x)</span>  is a polynomial of degree at most 3d + 3sampled uniformly at random such that  <span class="math">\\beta_{poly}(x) \\cdot (r&#x27;_{\\nu}v_k(x) +</span>  <span class="math">r&#x27;_{w}x^{d+1}w_{k}(x) + r&#x27;_{v}x^{2(d+1)}y_{k}(x)</span>  has a zero coefficient in front of  <span class="math">x^{3d+3}</span>  for all k. We know that such a polynomial  <span class="math">\\beta_{poly}(x)</span> exists by Lemma 10 of GGPR [30], which says (roughly) that, given a set of polynomials  <span class="math">\\{u_k(x) \\in \\mathbb{F}[x]\\}</span>  of degree at most D, then there exists a nonzero polynomial a(x) of degree D+1 such that all of the polynomials  <span class="math">a(x)u_k(x)</span>  have a nonzero coefficient for  <span class="math">x^{D+1}</span> , and moreover for any polynomial u(x) not in the linear span of  <span class="math">\\{u_k(x)\\}\\</span> , the coefficient of  <span class="math">x^{D+1}</span>  in a(x)u(x) is uniformly random in  <span class="math">\\mathbb{F}</span>  (when sampling a(x) uniformly subject to the above restriction). By inspection, when we now write out  <span class="math">\\beta</span>  in terms of s, we see that the exponent in Equation 3 has a zero in front of  <span class="math">s^{q+1}</span> , and also the powers of s only go up to degree  <span class="math">a + 3d + 3 \\le 2a</span> . Therefore,  <span class="math">\\mathcal{B}</span>  can efficiently generate the terms in the evaluation key that contain  <span class="math">\\beta</span>  using the elements given in his challenge.</p>

    <p class="text-gray-300">Regarding  <span class="math">\\gamma</span> ,  <span class="math">\\mathcal{B}</span>  generates  <span class="math">\\gamma&#x27;</span>  uniformly at random from  <span class="math">\\mathbb{F}</span>  and sets  <span class="math">\\gamma = \\gamma&#x27; s^{q+2}</span> .  <span class="math">\\mathcal{B}</span>  can generate  <span class="math">g^{\\gamma}</span>  efficiently from its challenge, since  <span class="math">g^{sq+2}</span>  is given. Also,  <span class="math">\\beta \\gamma =</span>  <span class="math">s^{q-(4d+3)}\\beta_{poly}(s)\\gamma s^{q+2}</span>  does not have a term  <span class="math">s^{q+1}</span>  and has degree at most  <span class="math">q-(4d+3)+(3d+3)+(q+2)\\leq 2q</span> , and so  <span class="math">\\mathcal{B}</span>  can generate  <span class="math">g^{\\beta\\gamma}</span>  from the elements in its challenge.</p>

    <p class="text-gray-300">Similarly none of the other elements in the CRS contains a term  <span class="math">s^{q+1}</span>  in the exponent, since all of the polynomials  <span class="math">v_k(x)</span> ,  <span class="math">w_k(x)</span>  and  <span class="math">y_k(x)</span>  are of degree d and  <span class="math">q \\ge 4d + 4</span> . Hence,  <span class="math">\\mathcal{B}</span>  can generate them using the terms from its challenge.</p>

    <p class="text-gray-300">Thus, the evaluation and verifications keys generated by  <span class="math">\\mathcal{B}</span> have a distribution statistically identical to the real scheme.</p>

    <p class="text-gray-300">Given  <span class="math">EK_F</span>  and  <span class="math">VK_F</span> ,  <span class="math">\\mathcal{A}_{vc}</span>  can run the Compute and Verify algorithms on its own. Let  <span class="math">g_v^{V_{mid}}</span> ,  <span class="math">g_w^{W_{mid}}</span> ,  <span class="math">g_y^{Y_{mid}}</span> ,  <span class="math">g_v^{H}</span> ,  <span class="math">g_v^{V&#x27;_{mid}}</span> ,  <span class="math">g_w^{W&#x27;_{mid}}</span> ,  <span class="math">g_y^{Y&#x27;_{mid}}</span> , and  <span class="math">g^Z</span>  be a cheating proof that  <span class="math">\\mathcal{A}_{vc}</span>  provides for the result of the computation of f with input and output  <span class="math">\\{c_k\\}_{k\\in[N]}</span> .</p>

    <p class="text-gray-300">Since the verification holds, we have that  <span class="math">(g_v^{V_{mid}})^{\\alpha_v} = g_{mid}^{V&#x27;_{mid}}</span> . We claim that  <span class="math">\\mathcal{B}</span>  can run the d-PKE extractor  <span class="math">\\chi_{\\mathcal{A}}</span>  to recover a polynomial  <span class="math">V_{mid}(x)</span>  of degree at most d such that  <span class="math">V_{mid} =</span>  <span class="math">V_{mid}(s)</span> . Though it may not be immediately recognizable as such, the parameters received by  <span class="math">\\mathcal{A}_{vc}</span>  are a valid input  <span class="math">(\\sigma, z)</span> for the d-PKE assumption. In particular, a valid input consists of  <span class="math">\\sigma = (\\{g_v^{s^i}\\}_{i \\in [0,d]}, \\{g_v^{\\alpha_v s^i}\\}_{i \\in [0,d]})</span>  and z, where the auxiliary information z is independent of  <span class="math">\\alpha_{\\nu}</span> , and the other terms in the CRS can be generated efficiently from  <span class="math">(\\sigma, z)</span> . The terms  <span class="math">\\{g_{\\nu}^{\\nu_k(s)}\\}\\</span>  can indeed be efficiently generated from  <span class="math">\\{g_{\\nu}^{s^l}\\}</span> , and the auxiliary information z that  <span class="math">\\mathcal{A}_{vc}</span>  receives is indeed independent of  <span class="math">\\alpha_v</span> . Therefore,  <span class="math">\\mathcal{B}</span>  can invoke the d-PKE extractor  <span class="math">\\chi_{\\mathcal{A}}</span>  to recover  <span class="math">V_{mid}(x)</span> , which must be a polynomial of degree at most d. Similarly,  <span class="math">\\mathcal{B}</span>  recovers  <span class="math">W_{mid}(x)</span>  and  <span class="math">Y_{mid}(x)</span>  such that  <span class="math">W_{mid} = W_{mid}(s)</span>  and  <span class="math">Y_{mid} = Y_{mid}(s)</span> . Then, it sets H(x) = <span class="math">((v_0(x)+V(x))(w_0(x)+W(x))-(y_0(x)+Y(x)))/t(x)</span> , where  <span class="math">V(x) = \\sum_{k \\in [N]} c_k v_k(x) + V_{mid}(x)</span>  (and similarly for W(x) and</p>

    <p class="text-gray-300">Since the proof verifies, but the statement is false (and therefore the extracted polynomials cannot actually be a QAP solution), there are two possible cases: (1) H(x) has a non-trivial denominator, or (2) The polynomial R(x) = <span class="math">r&#x27;_{v}x^{d+1}V_{mid}(x) + r&#x27;_{w}x^{2(d+1)}W_{mid}(x) + r&#x27;_{v}x^{3(d+1)}Y_{mid}(x)</span>  is not in the linear subspace, S, generated by the polynomials  <span class="math">\\{r_k(x) = r&#x27;_v x^{d+1} v_k(x) + r&#x27;_w x^{2(d+1)} w_k(x) + r&#x27;_y x^{3(d+1)} y_k(x)\\}_{k \\in I_{mid}}</span> .</p>

    <p class="text-gray-300">First, we show that these are the only two cases, if the proof verifies but the statement is false. We assume that neither case 1 nor case 2 holds; i.e., H(x) has no non-trivial denominator, and R(x) is in the linear subspace S. We will show that V(x), W(x), and Y(x) are a solution for the QAP; i.e., they can be written as linear combinations of  <span class="math">\\{v_k(x)_{k\\in[m]}\\}</span> ,  <span class="math">\\{w_k(x)_{k\\in[m]}\\}</span>  and  <span class="math">\\{y_k(x)_{k\\in[m]}\\}</span>  using the same coefficients, and  <span class="math">(v_0(x) + V(x))(w_0(x) + W(x)) - (y_0(x) + Y(x))</span>  is divisible by t(x).</p>

    <p class="text-gray-300">Since R(x) is in the subspace S, there exists a linear combination  <span class="math">\\{c_k\\}_{k\\in I_{mid}}</span>  such Thus, we can write R(x) as  <span class="math">R(x) = \\sum_{k \\in I_{mid}} c_k r_k(x).</span>  <span class="math">r&#x27;_{v}x^{d+1}V^{\\dagger}(x) + r&#x27;_{w}x^{2(d+1)}W^{\\dagger}(x) + r&#x27;_{v}x^{3(d+1)}Y^{\\dagger}(x)</span> , where  <span class="math">V^{\\dagger}(x) = \\sum_{k \\in I_{mid}} c_k v_k(x), \\quad W^{\\dagger}(x) = \\sum_{k \\in I_{mid}} c_k w_k(x), \\quad \\text{and}</span>  <span class="math">Y^{\\dagger}(x) = \\sum_{k \\in I_{mid}} c_k y_k(x).</span> Each of the polynomials  <span class="math">V^{\\dagger}(x), W^{\\dagger}(x), Y^{\\dagger}(x)</span>  has degree at most d because they are in the spans of  <span class="math">\\{v_k(x)_{k \\in I_{mid}}\\}</span> ,  <span class="math">\\{w_k(x)_{k \\in I_{mid}}\\}</span>  and  <span class="math">\\{y_k(x)_{k \\in I_{mid}}\\}</span> respectively. Since  <span class="math">V_{mid}(x)</span> ,  <span class="math">W_{mid}(x)</span>  and  <span class="math">Y_{mid}(x)</span>  also have degree d, and since the linear subspaces  <span class="math">\\{x^{d+1+i}|i \\in [0,d]\\}</span> ,  <span class="math">\\{x^{2(d+1)+i}|i \\in [0,d]\\}</span> , and  <span class="math">\\{x^{3(d+1)+i}|i \\in [0,d]\\}</span>  are disjoint (except at the origin), we conclude from R(x) = <span class="math">r&#x27;_{v}x^{d+1}V_{mid}(x) + r&#x27;_{w}x^{2(d+1)}W_{mid}(x) + r&#x27;_{y}x^{3(d+1)}Y_{mid}(x) =</span>  <span class="math">r&#x27;_{v}x^{d+1}V^{\\dagger}(x) + r&#x27;_{w}x^{2(d+1)}W^{\\dagger}(x) + r&#x27;_{v}x^{3(d+1)}Y^{\\dagger}(x)</span>  that we can write  <span class="math">V_{mid}(x) = V^{\\dagger}(x) = \\sum_{k \\in I_{mid}} c_k v_k(x), W_{mid}(x) =</span>  <span class="math">W^{\\dagger}(x) = \\sum_{k \\in I_{mid}} c_k w_k(x), Y_{mid}(x) = Y^{\\dagger}(x) = \\sum_{k \\in I_{mid}} c_k y_k(x).</span> Therefore,  <span class="math">V(x) = \\sum_{k \\in [N]} c_k v_k(x) + \\sum_{k \\in I_{mid}} c_k v_k(x),</span>   <span class="math">W(x) = \\sum_{k \\in [N]} c_k w_k(x) + \\sum_{k \\in I_{mid}} w_k v_k(x) \\text{ and } Y(x) = \\sum_{k \\in [N]} c_k y_k(x) + \\sum_{k \\in I_{mid}} c_k y_k(x).</span> Now we have that V(x), W(x), and Y(x) indeed can be written as the same linear combination  <span class="math">\\{c_k\\}_{k\\in[m]}</span>  of their polynomial sets, as required in a QAP. Since H(x) has no nontrivial denominator, it follows that t(x) evenly divides  <span class="math">(v_0(x) + V(x))(w_0(x) + W(x)) - (y_0(x) + Y(x))</span> . Hence V(x), W(x), and Y(x) constitute a QAP solution associated to the input/output  <span class="math">\\{c_k\\}_{k\\in[N]}</span> , and hence to a true statement, contradicting our initial assumption.</p>

    <p class="text-gray-300">Next we address the two cases from above. In Case 1, t(x) does not divide  <span class="math">p(x) := (v_0(x) + V(x))(w_0(x) + W(x)) - (y_0(x) + Y(x))</span> . Let (x - r) be a polynomial that divides t(x) but not p(x), and let T(x) = t(x)/(x - r). Let  <span class="math">d(x) = \\gcd(t(x), p(x))</span> . Since t(x) and p(x) have degrees at most d and 2d respectively,  <span class="math">\\mathcal{B}</span>  can use the extended Euclidean algorithm for polynomials to find polynomials a(x) and b(x) of degrees 2d - 1 and d - 1 respectively such that a(x)t(x) + b(x)p(x) = d(x). Set  <span class="math">A(x) = a(x) \\cdot (T(x)/d(x))</span>  and  <span class="math">B(x) = b(x) \\cdot (T(x)/d(x))</span> ; these polynomials have no denominator since d(x) divides T(x). Then A(x)t(x) + B(x)p(x) = T(x). Dividing by t(x), we have A(x) + B(x)H(x) = 1/(x - r). Since A(x) and B(x) have degree at most  <span class="math">2d - 1 \\le q</span> ,  <span class="math">\\mathcal{B}</span>  can use the terms in its challenge to compute  <span class="math">e(g^{A(s)}, g)e(g^{B(s)}, g^H) = e(g, g)^{1/(s - r)}</span> , and thus solve 2q-SDH.</p>

    <p class="text-gray-300">In Case 2, there does not exist  <span class="math">\\{c_k\\}_{k\\in I_{mid}}</span>  such that  <span class="math">V_{mid}(x)=\\sum_{k\\in I_{mid}}c_kv_k(x)</span> ,  <span class="math">W_{mid}(x)=\\sum_{k\\in I_{mid}}c_kw_k(x)</span>  and  <span class="math">Y_{mid}(x)=\\sum_{k\\in I_{mid}}c_ky_k(x)</span> . By Lemma 10 [30], we have that with high probability  <span class="math">x^{q-(4d+3)}\\beta_{poly}(x)\\cdot (r&#x27;_{\\nu}x^{d+1}v_k(x)+r&#x27;_{\\nu}x^{2(d+1)}w_k(x)+r&#x27;_{\\nu}x^{3(d+1)}y_k(x))</span>  has a non-zero coefficient for the term  <span class="math">x^{q+1}</span> . Now  <span class="math">\\mathcal B</span>  can use  <span class="math">g^Z=g^{s^{q-(4d+3)}\\beta_{poly}(s)(s^{d+1}V_{mid}(s)+s^{2(d+1)}W_{mid}(s)+s^{3(d+1)}Y_{mid}(s))}</span>  to subtract off all elements of the form  <span class="math">g^{s^j}</span>  where  <span class="math">j\\neq q+1</span>  and to obtain  <span class="math">g^{s^{q+1}}</span> . This breaks the q-PDH assumption.</p>

`;
---

<BaseLayout title="Pinocchio: Nearly Practical Verifiable Computation (2013/279)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/279
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="pinocchio-nearly-practical-verifiable-computation-2013" />
  </article>
</BaseLayout>
