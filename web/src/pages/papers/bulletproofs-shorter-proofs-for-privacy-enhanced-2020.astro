---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/735';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Bulletproofs+: Shorter Proofs for Privacy-Enhanced Distributed Ledger';
const AUTHORS_HTML = 'Heewon Chung, Kyoohyung Han, Chanyang Ju, Myungsun Kim, Jae Hong Seo';

const CONTENT = `    <p class="text-gray-300">Heewon Chung¹, Kyoohyung Han²*, Chanyang Ju¹, Myungsun Kim³, and Jae Hong Seo¹**</p>

    <p class="text-gray-300">¹ Department of Mathematics &amp; Research Institute for Natural Sciences, Hanyang University, Seoul 04763, Republic of Korea {heewonchung, chanyangju, jaehongseo}@hanyang.ac.kr ² Samsung SDS R&amp;D Center kh89.han@samsung.com ³ The University of Suwon msunkim@suwon.ac.kr</p>

    <p class="text-gray-300">Abstract. We present a new short zero-knowledge argument for the range proof and the arithmetic circuits without a trusted setup. In particular, the proof size of our protocol is the shortest of the category of proof systems with a trustless setup. More concretely, when proving a committed value is a positive integer less than 64 bits, except for negligible error in the 128-bit security parameter, the proof size is 576 byte long, which is of 85.7% size of the previous shortest one due to Bünz et al. (Bulletproofs, IEEE Security and Privacy 2018), while computational overheads in both proof generation and verification are comparable with those of Bulletproofs, respectively.</p>

    <p class="text-gray-300">Bulletproofs is established as one of important privacy enhancing technologies for distributed ledger, due to its trustless feature and short proof size. In particular, it has been implemented and optimized in various programming languages for practical usages by independent entities since it proposed. The essence of Bulletproofs is based on the logarithmic inner product argument with no zero-knowledge. In this paper, we revisit Bulletproofs from the viewpoint of the first sublinear zero-knowledge argument for linear algebra due to Groth (CRYPTO 2009) and then propose Bulletproofs+, an improved variety of Bulletproofs. The main ingredient of our proposal is the zero-knowledge weighted inner product argument (zk-WIP) to which we reduce both the range proof and the arithmetic circuit proof. The benefit of reducing to the zk-WIP is a minimal transmission cost during the reduction process. Note the zk-WIP has all nice features of the inner product argument such as an aggregating range proof and batch verification.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Distributed ledger is a database that is consensually shared and synchronized across multiple nodes without a trusted administrator. The blockchain is one type of distributed ledger, where database consists of linked blocks, called chain, and the cryptocurrency such as Bitcoin [58] is a representative application of the blockchain. The benefit of distributed ledger is that it is immutable and any independent observer can verify its validity without the aid of trusted third party. Transparency of natural realization of distributed ledger often causes an issue of data privacy since all information is public. For instance, all transaction details including the sender, the receiver, and the amount transferred are public in Bitcoin.</p>

    <p class="text-gray-300">Non-interactive zero-knowledge proofs (NIZK) enables the data owner to generate a proof for convincing observers of the validity of the data without disclosing it. Range proofs are a special NIZK for membership in a predetermined interval. That is, the prover first commits to a value using a commitment scheme and then prove that a committed value lies in a given interval. The range proof has broad applications that include blockchain-based cryptocurrencies in particular. For example, using a range proof, each transaction can be confidentially transferred without disclosing the amount transferred by including only a zero-knowledge proof validity of the transaction [56].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This work is done before this author joins Samsung SDS.</li>

    </ul>

    <p class="text-gray-300">** Corresponding author</p>

    <p class="text-gray-300">Due to distributed and transparent nature, short NIZK without a trusted setup is highly desired in the context of distributed ledger. <em>Bünz et al. [20]</em> proposed a short NIZK without a trusted setup, called Bulletproofs, on the basis of the techniques by <em>Bootle et al. [16]</em>. Bulletproofs provides the shortest proof size, which is indeed incomparably shorter than the other range proof systems, when a trusted setup is undesired. In fact, <em>[16]</em> achieves the first logarithmic communication complexity and Bulletproofs improves Bootle et al.’s protocol so that the proof size is reduced by a factor of 3 and the protocol is suitable for proving statements on committed values. <em>Hoffmann, Klooß, and Rupp [47]</em> improves Bulletproofs to efficiently cover more expressive relations than rank 1 constraint systems. Even though <em>[47]</em> presents more generic approach than Bulletproofs, it fails to reduce proof size in specific arguments such as range proofs. Recently, <em>Bünz, Fisch, and Szepieniec [21]</em> devise a novel polynomial commitment scheme based on the class group and propose the first succinct NIZK without trusted setup, called Supersonic, on the basis of their polynomial commitment scheme. Although Supersonic has a strength in both low verification costs and short proof size, it requires the proof size at least more than <span class="math">\\times</span> 6 of that of Bulletproofs for the 128-bit security level and the gap becomes larger when increasing the security level. Bulletproofs is established as one of important privacy enhancing technologies for distributed ledger, due to its trustless feature and short proof size. In particular, it has been implemented and optimized in various programming languages for practical usages by independent entities since it proposed: Java <em>[18]</em>, C <em>[63]</em>, C++ <em>[65]</em>, Rust <em>[57, 28]</em>, Go <em>[60]</em>, and Haskell <em>[49]</em>, to name a few.</p>

    <p class="text-gray-300">In this paper, we present Bulletproofs+, an improved variety of Bulletproofs, that has shorter proof size than Bulletproofs. That is, Bulletproofs+ achieves the shortest proof size in the category of NIZK without trusted setup. We compare the proof size of the range proof protocol of Bulletproofs+ with that of Bulletproofs in Table 1 for typical data types on a scale from 8-bit to 64-bit. As a result, the proof size of our range proof is <span class="math">\\times</span> <span class="math">0.8\\sim 0.857</span> of that of Bulletproofs. Note that computational overheads in both proof generation and verification in Bulletproofs+ are comparable with those of Bulletproofs, respectively. To achieve shorter proof size, we revisit Bulletproofs from the viewpoint of the first sublinear zero-knowledge argument for linear algebra due to Groth <em>[43]</em>. Bulletproofs employs the inner product argument without zero-knowledge as the essential ingredient. In <em>[43]</em> and Bulletproofs+, the main ingredient is the zero-knowledge weighted inner product argument (zk-WIP) to which we reduce both the range proof and the arithmetic circuit proof. The benefit of reducing to the zk-WIP is a minimal transmission cost during the reduction process, which makes the overall proof size of Bulletproofs+ smaller than that of Bulletproofs. Furthermore, like Bulletproofs, Bulletproofs+ also has additional extensions such as aggregating range proofs and batch verification.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Approach</h3>

    <p class="text-gray-300">Why Weighted Inner Product? The inner product argument based on a homomorphic commitment scheme such as a generalization of Pedersen commitment <em>[61, 43]</em> is employed, as a core building block, for more complicated relations such as linear algebra equations, range relation, and circuit satisfiability <em>[43, 16, 20]</em>. More precisely, Groth <em>[43]</em> proposed efficient reductions from the advanced arguments to the inner product argument and <em>Bootle et al. [16]</em> and <em>Bünz et al. [20]</em> improved Groth’s result in terms of the communication overhead by imposing more interactions between the prover and the verifier, which is not a big burden in the random oracle model <em>[9]</em> since it can be converted into the non-interactive argument through Fiat-Shamir heuristic <em>[31]</em> in the random oracle model.</p>

    <p class="text-gray-300">In fact, when Groth proposed the reduction from the advanced argument for linear algebra equations, he used the weighted inner product (WIP) argument as well as the inner product</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applicable Data Types</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[20]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">ratio*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">0.800</td>

            <td class="px-3 py-2 border-b border-gray-700">age</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">608</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">0.842</td>

            <td class="px-3 py-2 border-b border-gray-700">position, zip code</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">672</td>

            <td class="px-3 py-2 border-b border-gray-700">576</td>

            <td class="px-3 py-2 border-b border-gray-700">0.857</td>

            <td class="px-3 py-2 border-b border-gray-700">balance, transaction amount</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bulletproofs+/Bulletproofs ratio</li>

    </ul>

    <p class="text-gray-300">Table 1: Logarithmic Zero-Knowledge Range Proofs</p>

    <p class="text-gray-300">argument as ingredient protocols. For a constant vector  <span class="math">\\pmb{c} \\in \\mathbb{Z}_p^n</span> , the weighted inner product with respect to  <span class="math">\\pmb{c}</span> , denoted by  <span class="math">\\odot_{\\pmb{c}}</span> , is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\odot_ {\\boldsymbol {c}}: \\mathbb {Z} _ {p} ^ {n} \\times \\mathbb {Z} _ {p} ^ {n} \\rightarrow \\quad \\mathbb {Z} _ {p} \\\\ (\\boldsymbol {a}, \\boldsymbol {b}) \\quad \\mapsto \\langle \\boldsymbol {a}, (\\boldsymbol {c} \\circ \\boldsymbol {b}) \\rangle , \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where  <span class="math">\\langle \\cdot, \\cdot \\rangle</span>  denotes the standard inner product and  <span class="math">\\circ</span>  denotes the component-wise product (a.k.a. the Hadamard product).</p>

    <p class="text-gray-300">At the heart of the reductions to the weighted inner product argument is to batch several equations so that the communication overhead is reduced. For example, the Hadamard product equation between two vectors  <span class="math">\\pmb{a}</span>  and  <span class="math">\\pmb{b}</span> , denoted by  <span class="math">\\pmb{a} \\circ \\pmb{b} = \\pmb{c} \\in \\mathbb{Z}_p^n</span> , is a set of  <span class="math">n</span>  equations, and it can be converted, by imposing a random integer  <span class="math">y</span> , into an equation</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {a}, \\left(\\left(y, y ^ {2}, \\dots , y ^ {n}\\right) \\circ \\boldsymbol {b}\\right) \\rangle = \\langle \\boldsymbol {c}, \\left(y, y ^ {2}, \\dots , y ^ {n}\\right) \\rangle \\in \\mathbb {Z} _ {p}. \\tag {1}</span></div>

    <p class="text-gray-300">The prover can convince the verifier of the original Hadamard product equation  <span class="math">\\pmb{a} \\circ \\pmb{b} = \\pmb{c} \\in \\mathbb{Z}_p^n</span>  by convincing of Eq. (1) for randomly chosen  <span class="math">y</span> . The both hand sides of Eq. (1) can be directly considered as the weighted inner product with respect to the coefficient vector  <span class="math">(y, y^2, \\ldots, y^n)</span> . Therefore, an efficient proof protocol for the weighted inner product is necessary in this approach.</p>

    <p class="text-gray-300">Logarithmic Zero-Knowledge Argument for Weighted Inner Product. Groth [43] proposes a zero-knowledge argument for weighted inner product (zk-WIP) with linear communication overhead, which is an ingredient protocol for more advanced arguments for linear algebra equations. Subsequent works [16, 20] employ an inner product argument without zero-knowledge as an ingredient protocol but zero-knowledgeness for the advanced relations such as circuit satisfiability is achieved by the reduction to the inner product argument. Wahby et al. [71] presents a logarithmic zero-knowledge argument for inner product between a hidden vector and a public vector, which is distinct from (weighted) inner product between two hidden vectors in [43]. Hoffmann, Klooß, and Rupp [47] propose a zero-knowledge argument for inner product between two hidden vectors satisfying some constraints, which is called almost zero-knowledge proof protocol by the authors. In order to blind witness vectors, they use random vectors depending on the witness, which brings some constraint for the witness. To the best of our knowledge, there is no concrete construction for logarithmic WIP proof protocol with full zero-knowledge, where both input vectors of WIP are perfectly hidden.</p>

    <p class="text-gray-300">We begin with logarithmic inner product arguments [16, 20]. We find that at the heart of logarithmic inner product argument is the following equality as well as the bilinearity of the inner product. For the sake of simplicity, let  <span class="math">n</span>  be an even number  <span class="math">n = 2\\widehat{n}</span>  for some integer  <span class="math">\\widehat{n}</span>  and  <span class="math">\\pmb{a} = (\\pmb{a}_1, \\pmb{a}_2), \\pmb{b} = (\\pmb{b}_1, \\pmb{b}_2) \\in \\mathbb{Z}_p^{\\widehat{n}} \\times \\mathbb{Z}_p^{\\widehat{n}}</span> . Then, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {a}, \\boldsymbol {b} \\rangle = \\left\\langle \\boldsymbol {a} _ {1}, \\boldsymbol {b} _ {1} \\right\\rangle + \\left\\langle \\boldsymbol {a} _ {2}, \\boldsymbol {b} _ {2} \\right\\rangle . \\tag {2}</span></div>

    <p class="text-gray-300">hat is, an inner product can be represented by sum of two <em>half-length</em> inner products. This property is essential for reduction to a half-length inner product, which leads logarithmic communications. The WIP is also a bilinear map and satisfies the similar property to Eq. (2) when <span class="math">\\bm{c}</span> is the Vandermonde vector, e.g., <span class="math">\\bm{c}=(y,\\ldots,y^{n})\\in\\mathbb{Z}_{p}^{n}</span>.</p>

    <p class="text-gray-300"><span class="math">\\bm{a}\\odot_{(y,\\ldots,y^{n})}\\bm{b}=\\bm{a}_{1}\\odot_{(y,\\ldots,y^{\\widehat{n}})}\\bm{b}_{1}+(y^{\\widehat{n}}\\cdot\\bm{a}_{2})\\odot_{(y,\\ldots,y^{\\widehat{n}})}\\bm{b}_{2}.</span> (3)</p>

    <p class="text-gray-300">Let us give an intuition for logarithmic WIP argument w.r.t. <span class="math">(y,\\ldots,y^{n})\\in\\mathbb{Z}_{p}^{n}</span>. Suppose that the prover commits to vectors <span class="math">\\bm{a}_{1},\\bm{a}_{2},\\bm{b}_{1},\\bm{b}_{2}\\in\\mathbb{Z}_{p}^{\\widehat{n}}</span>, and integers <span class="math">c_{L}=\\bm{a}_{1}\\odot_{(y,\\ldots,y^{\\widehat{n}})}\\bm{b}_{2}</span>, <span class="math">c=\\bm{a}\\odot_{(y,\\ldots,y^{n})}\\bm{b}</span>, <span class="math">c_{R}=(y^{\\widehat{n}}\\cdot\\bm{a}_{2})\\odot_{(y,\\ldots,y^{\\widehat{n}})}\\bm{b}_{1}\\in\\mathbb{Z}_{p}</span> and the prover aims to convince of the relation <span class="math">c=\\bm{a}\\odot_{(y,\\ldots,y^{n})}\\bm{b}</span>. The bilinearity of the WIP and Eq. (3) guarantee that the following equation holds for a random challenge <span class="math">e</span>.</p>

    <p class="text-gray-300"><span class="math">(e\\bm{a}_{1}+e^{-1}y^{\\widehat{n}}\\bm{a}_{2})\\odot_{(y,\\ldots,y^{\\widehat{n}})}\\left(e\\bm{b}_{2}+e^{-1}\\bm{b}_{1}\\right)</span> (4) <span class="math">=e^{2}\\bm{a}_{1}\\odot_{(y,\\ldots,y^{\\widehat{n}})}\\bm{b}_{2}+\\bm{a}\\odot_{(y,\\ldots,y^{n})}\\bm{b}+e^{-2}(y^{\\widehat{n}}\\bm{a}_{2})\\odot_{(y,\\ldots,y^{\\widehat{n}})}\\bm{b}_{1}</span></p>

    <p class="text-gray-300">In our protocol, the verifier can calculate the commitments to <span class="math">(e\\bm{a}_{1}+e^{-1}y^{\\widehat{n}}\\bm{a}_{2})</span> and <span class="math">(e\\bm{b}_{2}+e^{-1}\\bm{b}_{1})</span>, inputs of WIP of the left-hand side in Eq. (4), with an aid of the prover. Let <span class="math">\\widehat{\\bm{c}}:=e^{2}c_{L}+c+e^{-2}c_{R}</span>. Then, the commitment to <span class="math">\\widehat{c}</span> can be publicly calculated using the homomorphic property of an underlying commitment scheme and it will be used as the result of WIP when taking <span class="math">(e\\bm{a}_{1}+e^{-1}y^{\\widehat{n}}\\bm{a}_{2})</span> and <span class="math">(e\\bm{b}_{2}+e^{-1}\\bm{b}_{1})</span> as input. Thus, the equality between Eq. (4) and <span class="math">\\widehat{c}</span> for randomly chosen <span class="math">e</span> guarantees the equality between each coefficient of power of <span class="math">e</span> of the right-hand side in Eq. (4) and that of <span class="math">\\widehat{c}</span>, so that we have <span class="math">c=\\bm{a}\\odot_{(y,\\ldots,y^{n})}\\bm{b}</span>. Therefore, a WIP proof w.r.t <span class="math">(y,\\ldots,y^{n})</span> between <span class="math">n</span>-dimension vectors is reduced to a WIP proof w.r.t <span class="math">(y,\\ldots,y^{\\widehat{n}})</span> between <span class="math">\\widehat{n}</span>-dimension vectors.</p>

    <p class="text-gray-300">The commitment to the hidden vector of length <span class="math">n</span>, which is input of the reduction, and each transmission sent by the prover during the reduction are blinded by random group elements chosen by the prover, so that the witness is perfectly hidden from the viewpoint of the verifier. Using the discrete logarithms of such random group elements, the prover updates the blinding factor in the commitment to the new hidden vector of length <span class="math">\\widehat{n}</span>, which is output of the reduction.</p>

    <p class="text-gray-300">Constant communication is sufficient for each reduction step and <span class="math">O(\\log_{2}(n))</span> number of rounds are sufficient for reducing to a dimension 1 WIP proof protocol. For the final step of zero-knowledge WIP proof protocol, we devise a variant of Schnorr protocol, which requires 2 group elements and 3 field elements. Therefore, the proposed zk-WIP protocol requires communication of <span class="math">2\\log_{2}(n)+5</span> field or group elements.</p>

    <p class="text-gray-300">One Round Reduction for Bulletproofs-like Protocols. Bünz et al. propose a short zero-knowledge argument called Bulletproofs, which includes an aggregate range proof protocol with logarithmic size in the witness size and an arithmetic circuit proof protocol with logarithmic size in the circuit size. Both aggregate range proof and arithmetic circuit proof protocols are built on their inner product proof protocol.</p>

    <p class="text-gray-300">We show that when our zk-WIP proof protocol is used as an ingredient protocol, one commit-and-challenge round is sufficient to reduce from the advanced protocols such as aggregate range proof and arithmetic circuit proof to the zk-WIP proof protocol. In particular, the prover sends only a group element in our reductions.</p>

    <p class="text-gray-300">Let us explain the idea of the reduction for our single range proof protocol. The prover’s goal is to convince the verifier that the witness <span class="math">v</span> belongs to an interval <span class="math">[0,2^{n}-1]</span>. The prover begins with committing to <span class="math">\\bm{a}_{L},\\bm{a}_{R}\\in\\mathbb{Z}_{p}^{n}</span> satisfying</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{L}-\\bm{a}_{R}=\\bm{1}^{n}\\in\\mathbb{Z}_{p}^{n}\\ \\wedge\\ \\bm{a}_{L}\\circ\\bm{a}_{R}=\\bm{0}\\in\\mathbb{Z}_{p}^{n}\\ \\wedge\\ \\langle\\bm{a}_{L},\\bm{2}^{n}\\rangle=v\\in\\mathbb{Z}_{p},</span> (5)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathbf{1}^{n}=(1,\\ldots,1)</span> is the vector filled with 1’s in all entries and <span class="math">\\mathbf{2}^{n}=(1,2,\\ldots,2^{n-1})</span> is the vector consisting of powers of 2. Eq. (5) is sufficient to convince the verifier. Next, the verifier sends a random challenge <span class="math">y\\in\\mathbb{Z}_{p}</span>. Then, <span class="math">2n+1</span> equations in Eq. (5) will be batched to a WIP equation. To this end, we put each term of left-hand sides in Eq. (5) into a coefficient of distinct monomial with variables <span class="math">y</span> and <span class="math">z</span> as follows.</p>

    <p class="text-gray-300"><span class="math">\\left(\\boldsymbol{a}_{L}-\\mathbf{1}^{n}\\cdot z\\right)\\odot_{(y,\\ldots,y^{n})}\\left(\\boldsymbol{a}_{R}+\\mathbf{2}^{n}\\circ(y^{n},y^{n-1},\\ldots,y)+\\mathbf{1}^{n}\\cdot z\\right)</span> <span class="math">=\\boldsymbol{a}_{L}\\odot_{(y,\\ldots,y^{n})}\\boldsymbol{a}_{R}+y^{n+1}\\langle\\boldsymbol{a}_{L},\\mathbf{2}^{n}\\rangle+z\\cdot(\\boldsymbol{a}_{L}-\\boldsymbol{a}_{R})\\odot_{(y,\\ldots,y^{n})}\\mathbf{1}^{n}-\\zeta(y,z)\\in\\mathbb{Z}_{p},</span></p>

    <p class="text-gray-300">where <span class="math">\\zeta(y,z)=y^{n+1}z\\langle\\mathbf{1}^{n},\\mathbf{2}^{n}\\rangle+z^{2}\\langle\\mathbf{1}^{n},\\overrightarrow{y}^{n}\\rangle</span> and <span class="math">\\overrightarrow{y}^{n}</span> indicates <span class="math">(y,\\ldots,y^{n})</span>. Each term of the right-hand sides in Eq. (5) is either constant or the witness <span class="math">v</span> and appeared as a coefficient of distinct monomial with variables <span class="math">y</span> and <span class="math">z</span> in</p>

    <p class="text-gray-300"><span class="math">0+y^{n+1}v+z\\mathbf{1}^{n}\\odot_{(y,\\ldots,y^{n})}\\mathbf{1}^{n}-\\zeta(y,z).</span> (6)</p>

    <p class="text-gray-300">Therefore, the remaining part of our range proof protocol is to run the zk-WIP protocol w.r.t. <span class="math">(y,\\ldots,y^{n})</span> that convinces</p>

    <p class="text-gray-300"><span class="math">\\left(\\boldsymbol{a}_{L}-\\mathbf{1}^{n}\\cdot z\\right)\\odot_{(y,\\ldots,y^{n})}\\left(\\boldsymbol{a}_{R}+\\mathbf{2}^{n}\\circ(y^{n},y^{n-1},\\ldots,y)+\\mathbf{1}^{n}\\cdot z\\right)</span> <span class="math">=y^{n+1}v+z\\mathbf{1}^{n}\\odot_{(y,\\ldots,y^{n})}\\mathbf{1}^{n}-\\zeta(y,z).</span> (7)</p>

    <p class="text-gray-300">By the homomorphic property of an underlying commitment scheme, the commitments to inputs and output of WIP in Eq. (7) can be publicly calculated from public parameters and the commitment sent by the prover at the beginning of our range protocol. Therefore, both the prover and the verifier can run the zk-WIP protocol. Similarly, aggregate range proof and arithmetic circuit proof protocols can be reduced to the zk-WIP proof protocol through one commit-and-challenge round.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Applications</h3>

    <p class="text-gray-300">Blockchain: Confidential Transactions, Smart Contracts, and More. Although Bitcoin <em>[58]</em> supports pseudonymity, it does not guarantee perfect privacy <em>[66, 3]</em>. To address confidentiality kkissue, Maxwell <em>[56]</em> proposed the concept of the confidential transaction, where every information except the validity is hidden, in the UTXO model. Here, the UTXO is an unspent transaction output and the UTXO model means that each transaction should fully spend the outputs of previously unspent transactions. A confidential transaction consists of commitments to a set of inputs and a set of outputs with Pedersen commitment scheme <em>[61]</em>. Although the homomorphic property of Pedersen commitment enables the verifier to check if the sum of inputs is equal to the sum of outputs, the verifier cannot verify if a sender has enough balance to involved amounts, and thus a sender should provide an additional evidence for this. The range proof exactly resolves this problem and thus essential in confidential transactions.</p>

    <p class="text-gray-300">Monero <em>[69, 74]</em> is one of well-known privacy-enhanced blockchain projects which employ confidential transactions in the UTXO model. Each transaction in the UTXO model has 2.5 outputs on average. The range proof should be attached for each output of transaction in Monero, so that on average 2.5 range proofs required for each transaction. The size of each transaction with two outputs has been reduced from 13kB to 2.5kB since Bulletproofs for aggregate range proof was integrated with Monero in 2018. Bulletproofs+ for aggregate range proof is 96 bytes smaller than Bulletproofs in 128-bit security, so that when applying Bulletproofs+ instead of Bulletproofs to Monero two output transaction can be further reduced and finally obtained 2.4 kB. Recently, each block of Monero contains 15 transactions on average and is generated per 2</p>

    <p class="text-gray-300">minutes so that 10,800 transactions are produced on a day. Therefore, Bulletproofs+ can save more than 1 MB for every day. In addition, our improved range proofs can impact on transactions per second (TPS) and a transaction fee which are major criteria for evaluating scalability since a node can handle more transaction as much as reduced size and it eases the burden to propagate a transaction. We can obtain a similar affect to the other privacy cryptocurrencies beside Monero, e.g., QuisQuis due to Fauzi et al. <em>[30]</em>. Compared to Monero, QuisQuis makes UTXO sets non-monotomic growing by introducing new notion, called updatable public keys, however, Bulletproofs still plays an essential role in QuisQuis. Thus Bulletproofs+ can also affect to QuisQuis by reducing the transaction size.</p>

    <p class="text-gray-300">Mimblewimble aims to resolve privacy and scalability problem in Bitcoin. Like Bitcoin, it was proposed by an anonymous named Jedusor <em>[51]</em> on Bitcoin IRC channel and Poelstra <em>[62]</em> released a revised version. In the last year, Fuchsbauer et al. <em>[33]</em> provided a provable-security analysis for Mimblewimble. In UTXO model, sums of input transaction values and output transaction values should be the same, apart from a transaction fee, and anyone can get a commitment to 0 from the valid transaction. Then, a sender signs a transaction under the commitment to 0 (as the public key) which implies that no money vanished and none was created. Through this, they simplify the structure of a confidential transaction, however, they still require sender’s balance check for the validity of the transaction and thus a range proof is indispensable. To resolve scalability issue, Mimblewimble only requires to store necessary transaction with cut-through while Bitcoin should store the entire transaction history, which implies the entire blockchain size is significantly reduced and it makes bootstrapping more faster. Grin <em>[40]</em> and Beam <em>[8]</em> are major implementations of Mimblewimble. For a million blocks, 10 million transactions (2 inputs, 2.5 outputs average) and 100,000 unspent outputs, UTXO size is nearly 520 MB and among them almost 517 MB is allocated to the range proofs <em>[40]</em>. UTXO size can be significantly reduced to about 90 MB (100 MB, respectively) with Bulletproofs+ (Bulletproofs, respectively).</p>

    <p class="text-gray-300">Besides a confidential transaction, there are several attempts to employ range proofs in smart contract. A confidential transaction is first proposed based on the UTXO model, however, a smart contract platform usually takes an account-based model. To construct a confidential transaction for the smart contract, it should support not only range proofs, but also statements on algebraically-encoded values to execute arbitrary smart contract securely. Zether <em>[19]</em> suggests a confidential transaction compatible with a smart contract platform, especially Ethereum <em>[72]</em>, called confidential transfers. Additionally, Findora <em>[32]</em> is also one of projects employing Bulletproofs on a smart contract. The main feature of <em>[32]</em> is supporting audits on a confidential transaction and it enables to prove more nuanced statements with selective disclosure. Both <em>[19]</em> and <em>[32]</em> support a confidential asset transfer and range proofs and arithmetic circuit proofs are necessary. Thus, Bulletproofs+ can enhance the efficiency of account-based model.</p>

    <p class="text-gray-300">Both the range proofs and the arithmetic circuit proofs can be used for confidential transaction between different assets to ensure that a balance for each asset is preserved, in zero-knowledge manner. Another popular cryptocurrency Stellar <em>[68]</em> proposed a project for this purpose and implemented a confidential asset protocol, called Cloak <em>[50, 67]</em>, using Bulletproofs. In <em>[50]</em>, a transaction consists of the number of asset transfers and to preserver the secrecy of the values, each transfer is blended by merging, shuffling, and splitting with other transfers in a transaction. Every function can be proven by Bulletproofs+ and thus the verifier can confirm correctness of the execution with smaller communication overhead than Bulletproofs.</p>

    <p class="text-gray-300">The sidechains also employs Bulletproofs to reflect sidechain’s transactions in the mainchain <em>[36]</em>. Each sidechain node should provide a signature on the transactions in the sidechains to convince the mainchain nodes and it is quite burden for mainchain nodes to verify all signatures as many as the number of sidechain nodes. For alleviating burden, Gazi, Kiayias and Zindros <em>[36]</em> employ multisignature and Merkle-tree hashing for verification key aggregation and</p>

    <p class="text-gray-300">Bulletproofs is used for further storage optimization. Since Bulletproofs+ can also support the membership proof and it can save more storage than Bulletproofs, our suggestion can further optimize their construction.</p>

    <p class="text-gray-300">Range Proofs. The range proof is an essential tool for resolving privacy issues in the digital financial technology including distributed ledger, e.g., <em>[59]</em>. Banks performs the process of identifying and verifying the identity of the client when opening an account. Due to regulations such as the anti-money laundering and know-your-customer, this process becomes mandatory and at the same time privacy issues cause. The zero-knowledge proofs enables to perform this process without disclosing the customer’s private information. Using the range proofs, the client can convince the banks of some relations on the age, the zip codes, and the GPS position without disclosing the actual information. For instance, the client can prove that the customer’s age is over the legal age and the zip codes and the GPS information are contained in specific ranges to validate the location where the customer stays.</p>

    <p class="text-gray-300">Verifiable Shuffles. Bulletproofs+ for the arithmetic circuit can be employed to reduce the proof size of applications beyond distributed ledgers. For example, it can be applied to the verifiable shuffle <em>[2, 41, 45, 7, 20]</em> that takes a list of committed values as input and outputs a permuted list along with the proof of correctness of permuted list. Although the verifiable shuffle is an important stand-alone protocol, it is also a good building block for many other applications like e-voting protocols <em>[34, 2]</em>, mix-net <em>[24]</em>, privacy-preserving advertisement delivery <em>[5]</em>, and solvency proofs <em>[27]</em>. In terms of the proof size, Bulletproofs has the most efficient scheme that increases the proof size logarithmically in the size of the input list. The shuffle can be implemented either by the sorting circuit using <span class="math">O(n\\log_{2}(n))</span> multiplications, where <span class="math">n</span> is the size of input list <em>[20]</em>, or by the permutation circuit and the multi-exponentiation circuits in <em>[7]</em>. Although Bulletproofs+ reduces only constant term (e.g., 96 bytes for the 128-bit security), for practically large <span class="math">n</span> (e.g., <span class="math">n&lt;2^{32}</span>) the improvement of Bulletproofs+ makes a meaningful difference like the range proof case due to logarithmic increasing speed of Bulletproofs’ proof size in <span class="math">n</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 Other Related Works</h3>

    <p class="text-gray-300">For better understanding and positioning out results, we give a brief survey about ZK arguments for range and arithmetic circuits.</p>

    <p class="text-gray-300">Range proofs. A tons of researches have been done into the range proof since Brickell et al. <em>[17]</em> presented the first proposal. The range proof plays an essential building block in lots of cryptographic applications: to name a few, anonymous credentials <em>[23]</em>, anonymous e-cash <em>[22]</em>, auction protocols <em>[53]</em>, e-voting <em>[42]</em>, privacy-preserving certificate transparency <em>[29]</em>.</p>

    <p class="text-gray-300">Lipmaa <em>[52]</em> presents a range proof protocol that relies on Lagrange’s four-square theorem (a.k.a., Bachet’s conjecture), which states that any positive integer can be written as a sum of four squares. Groth <em>[42]</em> improved Lipmaa’s proposal by exploiting Legendre’s three-square theorem, which states that a positive integer <span class="math">\\alpha</span> can be written as a sum of three squares if and only if <span class="math">\\alpha</span> is not of the form <span class="math">4^{n_{1}}(8n_{2}+7)</span> for <span class="math">n_{1},n_{2}\\in\\mathbb{Z}</span>. More recently, Couteau et al. <em>[26]</em> proposed a range proof solution based on a weaker assumption than the strong RSA assumption <em>[6]</em>. All these proposals rely on the the hardness of factoring large numbers, so that a trusted setup is required to generate the RSA modulus. .</p>

    <p class="text-gray-300">NIZK for Arithmetic Circuits. Zero-knowledge proof was first introduced as interactive protocol <em>[39]</em>. In many applications, prover and verifier may not be online at the same time or</p>

    <p class="text-gray-300">prover might want to preprocess multiple proofs. Blum et al.<em>[13]</em> introduced NIZK proofs in the common reference string model.</p>

    <p class="text-gray-300">In recent years, a lot of improvement on NIZK for the circuit satisfiability has been made <em>[37, 11, 44]</em>. SNARKs are arguments of knowledge that have succinct proofs and efficient verifiers. Even though SNARKs provides high performance that can meet practical requirements, SNARKs inherently and inevitably require a trusted setup to generate the structured reference string (SRS). In order to mitigate this problem, Groth et al. <em>[46]</em> and many subsequent works <em>[55, 35, 25, 73]</em> proposed proof systems relying on the SRS, where SRS is efficiently updatable. Nevertheless, these proof systems with the updatable SRS still requires at least one trusted setup at the beginning of the proof system.</p>

    <p class="text-gray-300">NIST has announced and prepared the transition to post-quantum secure cryptography in the near future <em>[64]</em>, and thus achieving post-quantum secure NIZKs with suitable performance is a desired goal as well. Toward this goal, several NIZK schemes have been proposed: ZK-Boo <em>[38]</em>, Ligero <em>[1]</em>, Aurora <em>[12]</em>, STARKs <em>[10]</em>, Virgo <em>[75]</em>, to name a few. Even though much improvements has been made in recent years, the performance of post-quantum secure NIZKs in specialized circuits (e.g. range proof) is hard to compete with NIZKs from classical assumptions such as RSA and discrete logarithms.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.4 Concurrent Works</h3>

    <p class="text-gray-300">There are two independent and concurrent works that improve Bulletproofs <em>[14, 4]</em>. Boneh, Fisch, Gabizon and Williamson <em>[14]</em> propose a simple range proof from hiding polynomial commitment scheme. To prove <span class="math">0\\leq v&lt;2^{n}</span> with zero-knowledge property, it requires two polynomials of degree <span class="math">n+1</span> and executing three polynomial evaluation protocols and the prover should transmit <span class="math">2\\cdot\\lceil\\log_{2}(n+2)\\rceil+2</span> elements in <span class="math">\\mathbb{G}</span> and <span class="math">5</span> elements in <span class="math">\\mathbb{Z}_{p}</span>. Definitely, its communication costs less than Bulletproofs, however, still requires at least one more element than our range proof. Moreover, since the construction is based on a polynomial commitment scheme which needs to choose a prime <span class="math">p</span> larger than <span class="math">n</span>, a prover can only claim the same interval once a polynomial commitment scheme is determined, otherwise a prover should renew the polynomial commitment scheme if the prover wants a new range. On the contrary, our range proof scheme supports an arbitrary <span class="math">n</span> and thus there is no restriction for a prover. Attema and Cramer <em>[4]</em> focus on reconciling Bulletproofs with theory of <span class="math">\\Sigma</span>-Protocols. A prover needs to prove quadratic equations for a range proof, however, <span class="math">\\Sigma</span>-Protocols are appropriate for proving arbitrary linear relations and thus Bulletproofs requires reinvention with the quadratic constraint and it may causes some technical difficulties. To resolve this issue, they employ an arithmetic secret sharing based technique which enables to linearize all non-linear statements, while preserving the same communication reduction. More precisely, a communication cost for their range proof is <span class="math">2\\cdot\\lceil\\log_{2}(2n+3)\\rceil</span> elements in <span class="math">\\mathbb{G}</span> and <span class="math">5</span> elements in <span class="math">\\mathbb{Z}_{p}</span> and thus Bulletproofs+ still remains as a transparent range proof with the smallest proof size.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.5 Organization</h3>

    <p class="text-gray-300">We provide definitions of assumptions, homomorphic commitment scheme, and zero-knowledge argument in Section 2. In Section 3, we present a main building block protocol, the zero-knowledge argument for weighted inner product without a trusted setup. We propose short zero-knowledge arguments for the range proof and the arbitrary arithmetic circuits in the subsequent sections, Section 4 and Section 5, respectively. Finally, we provide performance of proposed protocols for the concrete parameters in Section 6.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Preliminaries</p>

    <p class="text-gray-300">We begin with defining some basic notations to be used when defining the preliminary concepts in the following subsections. More specific notations that are useful for describing and analyzing the proposed proof systems are provided in Section 2.5. For any algorithm <span class="math">A</span>, <span class="math">y=A(x;r)</span> denotes that <span class="math">y</span> is the output of <span class="math">A</span> on input <span class="math">x</span> with randomness <span class="math">r</span>. When using uniform randomness, we use a shorten notation <span class="math">y\\leftarrow A(x)</span> meaning that randomness <span class="math">r</span> is chosen at random outside <span class="math">A</span> and we set <span class="math">y=A(x;r)</span>. For any set <span class="math">S</span>, <span class="math">x^{\\S}_{←}S</span> means uniform sampling of <span class="math">x</span> at random from <span class="math">S</span>. Throughout the paper, <span class="math">\\lambda</span> denotes the security parameter and it is written unary when it is used as the input of algorithms. For a function <span class="math">f:\\N\\to[0,1]</span>, we say that <span class="math">f</span> is negligible if <span class="math">f(\\lambda)=\\lambda^{-\\omega(1)}</span> and that <span class="math">f</span> is overwhelming when <span class="math">f(\\lambda)=1-\\lambda^{-\\omega(1)}.</span> <span class="math">negl(\\lambda)</span> denotes a negligible function.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Discrete Logarithm Assumption</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a group generation algorithm that takes the security parameter with the unary form <span class="math">1^{\\lambda}</span> and outputs a prime <span class="math">p</span> of <span class="math">\\lambda</span> bits, a cyclic group <span class="math">\\mathbb{G}</span> of order <span class="math">p</span>, and a generator <span class="math">g</span> of <span class="math">\\mathbb{G}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1 (Discrete Logarithm Assumption).</h6>

    <p class="text-gray-300">We say that the discrete logarithm assumption holds relative to <span class="math">\\mathcal{G}</span> if for all non-uniform polynomial-time adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">negl(\\lambda)</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[g^{x}=h\\ \\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\begin{array}[]{c}(\\mathbb{G},p,g)\\leftarrow\\mathcal{G}(1^{\\lambda});\\ h^{\\S}_{←}\\mathbb{G};\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">x\\leftarrow\\mathcal{A}(\\mathbb{G},p,g,h)\\end{array}\\right]<negl(\\lambda).$</p>

    <p class="text-gray-300">The discrete logarithm assumption can be generalized to the following equivalent assumption. When we mention the discrete logarithm assumption in the paper, it always means the discrete logarithm relation assumption.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2 (Discrete Logarithm Relation Assumption).</h6>

    <p class="text-gray-300">We say that the discrete logarithm relation assumption holds with respect to <span class="math">\\mathcal{G}</span> if for all <span class="math">n\\geq 1</span> and all non-uniform polynomial-time adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">negl(\\lambda)</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\exists a_{i}\\neq 0,i\\in[0,n]\\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\begin{array}[]{c}(\\mathbb{G},p,g_{0})\\leftarrow\\mathcal{G}(1^{\\lambda});\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">g_{1},...,g_{n}^{\\S}_{←}\\mathbb{G};\\\\ \\{a_{j}\\}_{j=0}^{n}\\leftarrow\\mathcal{A}(\\mathbb{G},p,\\{g_{l}\\}_{i=0}^{n})\\end{array}\\right]<negl(\\lambda).$</p>

    <p class="text-gray-300">If there exists <span class="math">a_{i}\\neq 0</span> for some <span class="math">i</span> while satisfying <span class="math">\\prod_{i=0}^{n}g_{i}^{a_{i}}=1</span>, then we call it is a non-trivial discrete logarithm relation.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.2 Homomorphic Commitments</h3>

    <p class="text-gray-300">A (non-interactive) commitment scheme consists of two algorithms <span class="math">\\mathsf{Gen}</span> and <span class="math">\\mathsf{Com}</span>. <span class="math">\\mathsf{Gen}</span> is called the key generation algorithm that takes the security parameter and outputs the commitment key <span class="math">\\mathsf{ck}</span>. The message space <span class="math">\\mathsf{M}_{\\mathsf{ck}}</span>, the randomness space <span class="math">\\mathsf{R}_{\\mathsf{ck}}</span>, and the commitment space <span class="math">\\mathsf{C}_{\\mathsf{ck}}</span> are specified in <span class="math">\\mathsf{ck}</span>. The commitment algorithm <span class="math">\\mathsf{Com}</span> combined with the commitment key <span class="math">\\mathsf{ck}</span> specifies a commitment function <span class="math">\\mathsf{Com}_{\\mathsf{ck}}:\\mathsf{M}_{\\mathsf{ck}}\\times\\mathsf{R}_{\\mathsf{ck}}\\to\\mathsf{C}_{\\mathsf{ck}}</span> that takes <span class="math">m\\in\\mathsf{M}_{\\mathsf{ck}}</span> and outputs a commitment <span class="math">\\mathsf{com}\\in\\mathsf{C}_{\\mathsf{ck}}</span> using randomness <span class="math">r\\in\\mathsf{R}_{\\mathsf{ck}}</span>. To commit to a message <span class="math">m\\in\\mathsf{M}_{\\mathsf{ck}}</span>, the sender selects <span class="math">r^{\\S}_{←}\\mathsf{R}</span> and computes the commitment <span class="math">\\mathsf{com}=\\mathsf{Com}_{\\mathsf{ck}}(m;r)</span>. We define several properties of the commitment scheme.</p>

    <p class="text-gray-300">Definition 3 (Homomorphic Commitments). A homomorphic commitment scheme is a (non-interactive) commitment scheme that has a homomorphic property such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m} \\left(m _ {1}; r _ {1}\\right) + _ {\\mathrm {C} _ {\\mathrm {c k}}} \\operatorname {C o m} \\left(m _ {2}; r _ {2}\\right) = \\operatorname {C o m} \\left(m _ {1} + _ {\\mathrm {M} _ {\\mathrm {c k}}} m _ {2}; r _ {1} + _ {\\mathrm {R} _ {\\mathrm {c k}}} r _ {2}\\right),</span></div>

    <p class="text-gray-300">for all  <span class="math">m_1, m_2 \\in \\mathsf{M}_{\\mathsf{ck}}</span>  and  <span class="math">r_1, r_2 \\in \\mathsf{R}_{\\mathsf{ck}}</span> , where  <span class="math">+_{\\mathsf{C}_{\\mathsf{ck}}}, +_{\\mathsf{M}_{\\mathsf{ck}}}</span>  and  <span class="math">+_{R_{\\mathsf{ck}}}</span>  define operations in  <span class="math">\\mathsf{C}_{\\mathsf{ck}}, \\mathsf{M}_{\\mathsf{ck}}</span>  and  <span class="math">\\mathsf{R}_{\\mathsf{ck}}</span> , respectively.</p>

    <p class="text-gray-300">Definition 4 (Hiding Commitments). A commitment scheme is hiding if for all non-uniform polynomial-time interactive adversaries  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">negl(\\lambda)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{2} - \\operatorname * {P r} \\left[ \\begin{array}{c} \\mathsf {c k} \\leftarrow \\mathsf {G e n} (1 ^ {\\lambda}); (m _ {0}, m _ {1}) \\leftarrow \\mathcal {A} (\\mathsf {c k}); \\\\ b ^ {\\prime} = b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad b \\stackrel {\\S} {\\leftarrow} \\{0, 1 \\} ; r \\stackrel {\\S} {\\leftarrow} \\mathsf {R} _ {\\mathsf {c k}}; \\\\ \\mathsf {c o m} = \\mathsf {C o m} (m _ {b}; r); b ^ {\\prime} \\stackrel {\\S} {\\leftarrow} \\mathcal {A} (\\mathsf {c o m}) \\end{array} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n e g l (\\lambda),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the probability goes over the randomness used in  <span class="math">\\mathcal{A}</span>  and Gen and the choice of  <span class="math">b</span>  and  <span class="math">r</span> . We say the scheme is perfectly hiding if  <span class="math">negl(\\lambda) = 0</span> .</p>

    <p class="text-gray-300">Definition 5 (Binding Commitments). A commitment scheme is binding if for all nonuniform polynomial-time interactive adversary  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">negl(\\lambda)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\mathsf {C o m} (m _ {0}; r _ {0}) &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {G e n} (1 ^ {\\lambda}); \\\\ = \\mathsf {C o m} (m _ {1}, r _ {1}) &amp;amp; (m _ {0}, m _ {1}, r _ {0}, r _ {1}) \\leftarrow \\mathcal {A} (\\mathsf {c k}) \\end{array} \\right] \\leq n e g l (\\lambda).</span></div>

    <p class="text-gray-300">where the probability goes over the randomness used in  <span class="math">\\mathcal{A}</span>  and Gen. We say the commitment scheme is perfectly binding if  <span class="math">negl(\\lambda) = 0</span> .</p>

    <p class="text-gray-300">In this paper, we will use a generalized Pedersen commitment scheme. We explain here how generalized Pedersen commitment implemented. Let  <span class="math">\\mathsf{M}_{\\mathsf{ck}} = \\mathbb{Z}_p^n</span> ,  <span class="math">\\mathsf{R}_{\\mathsf{ck}} = \\mathbb{Z}_p</span>  and  <span class="math">\\mathsf{C}_{\\mathsf{ck}} = \\mathbb{G}</span>  where  <span class="math">ck = (\\mathbb{G}, p, g, g_1, \\dots, g_n)</span>  and  <span class="math">g, g_i \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span>  for  <span class="math">i = 1, \\dots, n</span> . To commit to a message vector  <span class="math">\\boldsymbol{m} = (m_1, \\dots, m_n) \\in \\mathbb{Z}_p^n</span> , we compute  <span class="math">\\mathsf{Com}_{\\mathsf{ck}}(\\boldsymbol{m}; r) := g^r \\prod_{i=1}^{n} g_i^{m_i}</span>  where  <span class="math">r \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p</span> . The generalized Pedersen commitment scheme is perfectly hiding since  <span class="math">g</span>  is a generator of the cyclic group and thus the random blinding factor  <span class="math">g^r</span>  is uniformly distributed over the cyclic group. If the discrete logarithm assumption holds on  <span class="math">\\mathbb{G}</span> , then the Pedersen commitment scheme is computationally binding [61, 43]. An important fact is that the generalized Pedersen commitment is an homomorphic commitment, i.e., for all  <span class="math">\\boldsymbol{m}, \\boldsymbol{m}&#x27; \\in \\mathbb{Z}_p^n</span>  and  <span class="math">r, r&#x27; \\in \\mathbb{Z}_p</span> ,  <span class="math">\\mathsf{Com}_{\\mathsf{ck}}(\\boldsymbol{m}; r) \\cdot \\mathsf{Com}_{\\mathsf{ck}}(\\boldsymbol{m}&#x27;; r&#x27;) = \\mathsf{Com}_{\\mathsf{ck}}(\\boldsymbol{m} + \\boldsymbol{m}&#x27;; r + r&#x27;)</span>  holds.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2.3 Zero-Knowledge Arguments of Knowledge</h2>

    <p class="text-gray-300">We consider arguments consisting of three interactive probabilistic polynomial-time algorithms  <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  in the common random string model.  <span class="math">\\mathcal{K}</span>  is called the common reference string generator that takes the security parameter  <span class="math">1^{\\lambda}</span>  as input and outputs the common reference string  <span class="math">\\sigma</span> . In this paper, the common reference string is a public key for the generalized Pedersen commitment scheme, that is, uniformly chosen group elements.  <span class="math">{}^{5}\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  are called the prover and the verifier, respectively. For the sake of simplicity, in this paper, we do not explicitly describe  <span class="math">\\mathcal{K}</span>  but assume the common reference string is given as common input to both  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> . At the end</p>

    <p class="text-gray-300">5 The public key (or commitment key) of Pedersen commitment scheme can be chosen as a random string. Therefore, we are in the common random string model, and even in the plain model if we let the verifier chooses the random string.</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">of interaction, the verifier <span class="math">\\mathcal{V}</span> accepts (equivalently outputs 1) or rejects (equivalently outputs 0).</p>

    <p class="text-gray-300">We will prove that the proposed protocol, Bulletproofs+, is a zero-knowledge argument of knowledge. Informally, the goal of the prover in this protocol is to convince the verifier of knowledge of witness that guarantees some statement holds, without disclosing the witness. Due to space constraint, we provide the formal definition of zero-knowledge arguments of knowledge in Appendix A.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.4 Non-Interactive Argument without Trusted Setup in the Random Oracle Model</h3>

    <p class="text-gray-300">A protocol in the common random string model can be converted into a protocol without a trusted setup in the random oracle model <em>[9]</em>. In particular, if the common reference string consists of random group generators of a group <span class="math">\\mathbb{G}</span>, then we can use a hash function modeled as a random oracle to map from <span class="math">\\{0,1\\}^{<em>}</span> to <span class="math">\\mathbb{G}</span>, as in </em>[15]* and the common reference string is replaced by the output of the hash function from a small seed.</p>

    <p class="text-gray-300">The public coin argument (Definition 9) protocol can be converted into a non-interactive argument protocol in the random oracle model by replacing all random challenges chosen by the verifier with hash values of the transcript up to that point. That is, the Fiat-Shamir heuristic <em>[31]</em> is used in this conversion.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.5 Notation</h3>

    <p class="text-gray-300">Let <span class="math">p</span> denote a prime of length <span class="math">\\lambda</span>. In our protocol, we use several sets <span class="math">\\mathbb{G},\\mathbb{Z}_{p},\\mathbb{Z}_{p}^{<em>},\\mathbb{G}^{n},\\mathbb{Z}_{p}^{n}</span> and several binary operations over them. Let <span class="math">\\mathbb{G}</span> denote a group of order <span class="math">p</span>, <span class="math">\\mathbb{Z}_{p}</span> denote the ring of integers modulo <span class="math">p</span>, and <span class="math">\\mathbb{Z}_{p}^{</em>}</span> denote <span class="math">\\mathbb{Z}_{p}\\backslash\\{0\\}</span>. For a group <span class="math">\\mathbb{F}</span>, <span class="math">\\mathbb{F}^{n}</span> denotes the <span class="math">n</span>-dimensional product group, and hence it also denotes vector spaces of dimension <span class="math">n</span> over <span class="math">\\mathbb{F}</span>. <span class="math">\\mathbb{Z}_{p}^{n\\times m}</span> denotes the set of matrices with <span class="math">n</span> rows and <span class="math">m</span> columns over <span class="math">\\mathbb{Z}_{p}</span>. An element in cartesian product set <span class="math">\\mathbb{F}\\in\\{\\mathbb{G}^{n},\\mathbb{Z}_{p}^{n},\\mathbb{Z}_{p}^{n\\times m}\\}</span> is denoted by bold letters, i.e. <span class="math">\\bm{g}=(g_{1},...,g_{n})\\in\\mathbb{G}^{n}</span>, <span class="math">\\bm{a}=(a_{1},...,a_{n})\\in\\mathbb{Z}_{p}^{n}</span>, and <span class="math">\\bm{B}\\in\\mathbb{Z}_{p}^{n\\times m}</span>. We often consider a vector <span class="math">\\bm{a}</span> in <span class="math">\\mathbb{Z}_{p}^{n}</span> as a row matrix in <span class="math">\\mathbb{Z}_{p}^{1\\times n}</span> and its transpose vector, which is the corresponding column vector, is denoted by <span class="math">\\bm{a}^{\\top}</span>.</p>

    <p class="text-gray-300">We define notations for several binary operators among the above defined sets. For two vectors <span class="math">\\bm{a},\\bm{b}\\in\\mathbb{Z}_{p}^{n}</span>, the inner-product between <span class="math">\\bm{a}</span> and <span class="math">\\bm{b}</span> is defined as <span class="math">\\bm{a}\\cdot\\bm{b}^{\\top}=\\sum_{i=1}^{n}a_{i}\\cdot b_{i}\\in\\mathbb{Z}_{p}</span> and also denoted by <span class="math">\\langle\\bm{a},\\bm{b}\\rangle</span>. The component-wise multiplication (a.k.a the Hadamard product) between <span class="math">\\bm{a}</span> and <span class="math">\\bm{b}</span> is denoted by <span class="math">\\bm{a}\\circ\\bm{b}</span>, i.e., <span class="math">\\bm{a}\\circ\\bm{b}=(a_{1}\\cdot b_{1},\\ldots,a_{n}\\cdot b_{n})\\in\\mathbb{Z}_{p}^{n}</span>. For <span class="math">\\bm{a}\\in\\mathbb{Z}_{p}^{n}</span> and <span class="math">\\bm{g}\\in\\mathbb{G}^{n}</span>, the multi-exponentiation <span class="math">\\prod_{i=1}^{n}g_{i}^{a_{i}}\\in\\mathbb{G}</span> is denoted by <span class="math">\\bm{g^{a}}</span>. For a scalar <span class="math">c\\in\\mathbb{Z}_{p}</span> and a vector <span class="math">\\bm{a}\\in\\mathbb{Z}_{p}^{n}</span>, the scalar multiplication is denoted by <span class="math">c\\cdot\\bm{a}\\in\\mathbb{Z}_{p}^{n}</span>, i.e., <span class="math">c\\cdot\\bm{a}=(c\\cdot a_{1},\\ldots,c\\cdot a_{n})</span>.</p>

    <p class="text-gray-300">For an integer <span class="math">y\\in\\mathbb{Z}_{p}^{*}</span>, we use two vector notations <span class="math">\\overrightarrow{y}^{n}</span> and <span class="math">\\overleftarrow{y}^{n}</span> to denote <span class="math">(y,y^{2},\\ldots,y^{n})</span>, and <span class="math">(y^{n},y^{n-1},\\ldots,y^{1})</span>, respectively. In addition, we use two constant vectors <span class="math">(1,\\ldots,1),(1,2,\\ldots,2^{n-1})\\in\\mathbb{Z}_{p}^{n}</span>, denoted by <span class="math">\\bm{1}^{n}</span> and <span class="math">\\bm{2}^{n}</span>, respectively. Then, an interesting equality</p>

    <p class="text-gray-300"><span class="math">\\overrightarrow{y}^{n}\\circ\\overleftarrow{y}^{n}=y^{n+1}\\cdot\\bm{1}^{n}</span> (8)</p>

    <p class="text-gray-300">holds.</p>

    <p class="text-gray-300">For a ternary relation <span class="math">\\mathcal{R}</span>, we use the format <span class="math">\\{\\text{(Public Input;Witness)}:\\mathcal{R}\\}</span> to denote the relation <span class="math">\\mathcal{R}</span> using specific Public Input and Witness.</p>

    <h2 id="sec-15" class="text-2xl font-bold">3 Weighted Inner Product Argument</h2>

    <p class="text-gray-300">Groth <em>[43]</em> proposed the zero-knowledge argument for the weighted inner product (zk-WIP) and used it to build <em>square-root</em> zero-knowledge arguments for linear algebra equations. We propose</p>

    <p class="text-gray-300">an improved zk-WIP argument and use it to build short zero-knowledge arguments for range proofs and arithmetic circuits.</p>

    <p class="text-gray-300">For a constant vector <span class="math">\\bm{c}</span>, the weighted inner product (WIP) with respect to <span class="math">\\bm{c}</span> is defined as</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{rcl}\\odot_{\\bm{c}}:\\mathbb{Z}_{p}^{n}\\times\\mathbb{Z}_{p}^{n}&\\rightarrow&\\quad\\mathbb{Z}_{p}\\\\ (\\bm{a},\\bm{b})&\\mapsto\\langle\\bm{a},(\\bm{c}\\circ\\bm{b})\\rangle.\\end{array} \\]</p>

    <p class="text-gray-300">The most interesting special case is that <span class="math">\\bm{c}=\\overrightarrow{y}^{n}</span> for an integer <span class="math">y\\in\\mathbb{Z}_{p}^{<em>}</span>, which is also mainly used in </em>[43]*, since it has useful properties. We design arguments for range proofs and arithmetic circuits on the basis of the zk-WIP argument with respect to <span class="math">\\overrightarrow{y}^{n}</span>. For simplicity, we use the notation <span class="math">\\odot_{y}</span> instead of <span class="math">\\odot_{\\overrightarrow{y}^{n}}</span>. Note that if <span class="math">y=1</span>, then <span class="math">\\odot_{y}</span> is equivalent to the inner-product. Even after the map is defined with <span class="math">y&gt;1</span>, we can utilize it like the inner-product by computing <span class="math">\\bm{a}\\odot_{y}(\\bm{b}\\circ\\overleftarrow{y}^{n})</span>. One can verify that</p>

    <p class="text-gray-300"><span class="math">\\bm{a}\\odot_{y}(\\bm{b}\\circ\\overleftarrow{y}^{n})=y^{n+1}\\cdot\\langle\\bm{a},\\bm{b}\\rangle</span> (9)</p>

    <p class="text-gray-300">and we use this property in our protocols when we need to perform the inner product between <span class="math">\\bm{a}</span> and <span class="math">\\bm{b}</span> after fixing <span class="math">y&gt;1</span>.</p>

    <p class="text-gray-300">We propose a zero-knowledge argument for the WIP w.r.t. <span class="math">\\overrightarrow{y}^{n}</span> relation. In particular, we employ group-based homomorphic commitment schemes as a building block, so that the relation necessarily involves group elements. In addition, we use <em>compressed representation</em>, in the sense that the witness and the WIP result are committed together into a group element. More precisely, we propose a zero-knowledge proof system for the following relation:</p>

    <p class="text-gray-300"><span class="math">\\big{\\{}(\\bm{g},\\bm{h}\\in\\mathbb{G}^{n},g,h,P\\in\\mathbb{G};\\bm{a},\\bm{b}\\in\\mathbb{Z}_{p}^{n},\\alpha\\in\\mathbb{Z}_{p}):\\ P=\\bm{g}^{\\bm{a}}\\bm{h}^{\\bm{b}}g^{\\bm{a}\\odot_{y}\\bm{b}}h^{\\alpha}\\big{\\}}</span></p>

    <p class="text-gray-300">The WIP w.r.t <span class="math">\\overrightarrow{y}^{n}</span> as well as its simplest case, inner-product have an interesting property, which leads to logarithmic communication cost when combining with homomorphic commitment schemes. The WIP w.r.t <span class="math">\\overrightarrow{y}^{n}</span> can be replaced with a sum of two WIPs with half-lengths. When <span class="math">n</span> is an even number, say <span class="math">n=2\\widehat{n}</span>, let <span class="math">\\bm{a}=(\\bm{a}_{1},\\bm{a}_{2}),\\bm{b}=(\\bm{b}_{1},\\bm{b}_{2})\\in\\mathbb{Z}_{p}^{\\widehat{n}}\\times\\mathbb{Z}_{p}^{\\widehat{n}}</span>. Then, we have</p>

    <p class="text-gray-300"><span class="math">\\bm{a}\\odot_{y}\\bm{b}=\\bm{a}_{1}\\odot_{y}\\bm{b}_{1}+(y^{\\widehat{n}}\\cdot\\bm{a}_{2})\\odot_{y}\\bm{b}_{2}</span> (10)</p>

    <p class="text-gray-300">Roughly speaking, using the homomorphic property of homomorphic commitment scheme and Eq. (10), we can reduce from the zk-WIP w.r.t. <span class="math">\\overrightarrow{y}^{n}</span> to two zk-WIPs w.r.t. <span class="math">\\overrightarrow{y}^{\\widehat{n}}</span>. However, this reduction does not lead to the proof size diminution and we need to a more trick to batch two <span class="math">\\widehat{n}</span>-length arguments to an <span class="math">\\widehat{n}</span>-length argument. To ensure this end, we impose an additional round and use a random challenge given from the verifier, so that we obtain logarithmic communication cost in the length of vector <span class="math">n</span>. More precisely, the prover of the zk-WIP w.r.t. <span class="math">\\overrightarrow{y}^{n}</span> transmits <span class="math">2\\cdot\\lceil\\log_{2}(n)\\rceil+2</span> elements in <span class="math">\\mathbb{G}</span> and <span class="math">3</span> elements in <span class="math">\\mathbb{Z}_{p}</span>. Computational cost of both the prover and the verifier are linear in <span class="math">n</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.1 Zero-Knowledge Argument for WIP</h3>

    <p class="text-gray-300">We describe the zero-knowledge argument for WIP w.r.t. <span class="math">\\overrightarrow{y}^{n}</span>, denoted by <span class="math">\\mathsf{zk}\\text{-}\\mathsf{WIP}_{\\overrightarrow{y}^{n}}(\\bm{x};\\bm{y})</span>, where <span class="math">\\bm{x}</span> is the input of <span class="math">\\mathcal{V}</span> and <span class="math">(\\bm{x};\\bm{y})</span> is the input of <span class="math">\\mathcal{P}</span>. In the proposed protocol, the verifier starts with the public parameters including group generators <span class="math">\\bm{g}</span>, <span class="math">\\bm{h}\\in\\mathbb{G}^{n}</span>, <span class="math">g,h\\in\\mathbb{G}</span> as well as a commitment <span class="math">P=\\bm{g}^{\\bm{a}}\\bm{h}^{\\bm{b}}g^{c}h^{\\alpha}</span>, where <span class="math">\\bm{a},\\bm{b}</span>, and <span class="math">\\alpha</span> consist of witness satisfying <span class="math">c=\\bm{a}\\odot_{y}\\bm{b}</span>. The prover takes as input <span class="math">\\bm{g},\\bm{h},g,h,P</span> and <span class="math">\\bm{a},\\bm{b},\\alpha</span>.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Zero Knowledge Argument for WIP relation</p>

    <p class="text-gray-300">For the sake of simplicity, we assume that  <span class="math">n</span>  is a power of 2 and let  <span class="math">\\widehat{n} = n / 2</span> . When  <span class="math">n &amp;gt; 1</span> , the protocol  <span class="math">\\mathsf{zk - WIP}_{\\widehat{y}^n}(\\pmb {g},\\pmb {h},g,h,P;\\pmb {a},\\pmb {b},\\alpha)</span>  is a reduction from length-  <span class="math">n</span>  argument to  <span class="math">\\widehat{n}</span> -length</p>

    <p class="text-gray-300">argument. The prover chooses random integers <span class="math">d_{L},d_{R}\\overset{\\S}{\\leftarrow}\\mathbb{Z}_{p}</span>, computes</p>

    <p class="text-gray-300"><span class="math">c_{L}=</span> <span class="math">\\boldsymbol{a}_{1}\\ \\odot_{y}\\ \\boldsymbol{b}_{2}\\in\\mathbb{Z}_{p}</span> <span class="math">c_{R}=(y^{\\widehat{n}}\\cdot\\boldsymbol{a}_{2})\\odot_{y}\\boldsymbol{b}_{1}\\in\\mathbb{Z}_{p}</span> <span class="math">L=\\boldsymbol{g}_{2}^{(y^{-\\widehat{n}}\\cdot\\boldsymbol{a}_{1})}\\boldsymbol{h}_{1}^{\\boldsymbol{b}_{2}}g^{c_{L}}h^{d_{L}}\\in\\mathbb{G}</span> <span class="math">R=\\boldsymbol{g}_{1}^{(y^{\\widehat{n}}\\cdot\\boldsymbol{a}_{2})}\\boldsymbol{h}_{2}^{\\boldsymbol{b}_{1}}g^{c_{R}}h^{d_{R}}\\in\\mathbb{G},</span></p>

    <p class="text-gray-300">and sends <span class="math">L</span> and <span class="math">R</span> to the verifier. Next, the verifier sends a random challenge <span class="math">e</span> to the prover. Then, both the prover and the verifier compute</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\boldsymbol{g}}=\\boldsymbol{g}_{1}^{e^{-1}}\\circ\\boldsymbol{g}_{2}^{e\\cdot y^{-\\widehat{n}}}\\in\\mathbb{G}^{\\widehat{n}},\\ \\widehat{\\boldsymbol{h}}=\\boldsymbol{h}_{1}^{e}\\circ\\boldsymbol{h}_{2}^{e^{-1}}\\in\\mathbb{G}^{\\widehat{n}},\\ \\widehat{P}=L^{e^{2}}PR^{e^{-2}}\\in\\mathbb{G},</span></p>

    <p class="text-gray-300">and the prover additionally computes</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\boldsymbol{a}}=\\boldsymbol{a}_{1}\\cdot e+(\\boldsymbol{a}_{2}\\cdot y^{\\widehat{n}})\\cdot e^{-1}\\in\\mathbb{Z}_{p}^{\\widehat{n}},</span> <span class="math">\\widehat{\\boldsymbol{b}}=\\boldsymbol{b}_{1}\\cdot e^{-1}+\\boldsymbol{b}_{2}\\cdot e\\in\\mathbb{Z}_{p}^{\\widehat{n}},</span> <span class="math">\\widehat{\\alpha}=d_{L}\\cdot e^{2}+\\alpha+d_{R}\\cdot e^{-2}\\in\\mathbb{Z}_{p}.</span></p>

    <p class="text-gray-300">Then, the above <span class="math">\\widehat{n}</span>-length vectors <span class="math">\\widehat{\\boldsymbol{a}}</span> and <span class="math">\\widehat{\\boldsymbol{b}}</span> have a relation with <span class="math">c_{L},c_{R}</span>, and <span class="math">c</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\boldsymbol{a}}\\odot_{y}\\widehat{\\boldsymbol{b}}</span> <span class="math">=\\boldsymbol{a}_{1}\\odot_{y}\\boldsymbol{b}_{2}e^{2}+\\boldsymbol{a}_{1}\\odot_{y}\\boldsymbol{b}_{1}+(y^{n/2}\\cdot\\boldsymbol{a}_{2})\\odot_{y}\\boldsymbol{b}_{2}+y^{\\widehat{n}}\\boldsymbol{a}_{2}\\odot_{y}\\boldsymbol{b}_{1}e^{-2}</span> <span class="math">=c_{L}\\cdot e^{2}+c+c_{R}\\cdot e^{-2}</span></p>

    <p class="text-gray-300">Using this result, one can verify the following equality through a simple calculation.</p>

    <p class="text-gray-300"><span class="math">\\widehat{P}=L^{e^{2}}PR^{e^{-2}}=\\widehat{\\boldsymbol{g}}^{\\widehat{\\boldsymbol{a}}}\\boldsymbol{h}^{\\widehat{\\boldsymbol{b}}}g^{\\widehat{\\boldsymbol{a}}\\odot_{y}\\widehat{\\boldsymbol{b}}}h^{\\widehat{\\alpha}}</span></p>

    <p class="text-gray-300">Therefore, <span class="math">(\\widehat{\\boldsymbol{g}},\\widehat{\\boldsymbol{h}},g,h,\\widehat{P};\\widehat{\\boldsymbol{a}},\\widehat{\\boldsymbol{b}},\\widehat{\\alpha})</span> is composed of the same zk-WIP argument with a half length <span class="math">\\widehat{n}</span>, which is the desired reduction from an argument related to <span class="math">\\boldsymbol{a}</span> and <span class="math">\\boldsymbol{b}\\in\\mathbb{Z}_{p}^{n}</span> to an argument related to <span class="math">\\widehat{\\boldsymbol{a}}</span> and <span class="math">\\widehat{\\boldsymbol{b}}\\in\\mathbb{Z}_{p}^{\\widehat{n}}</span>. Here, the prover sends only two group elements for each reduction, so that totally it requires only logarithmic communication cost in <span class="math">n</span>.</p>

    <p class="text-gray-300">When <span class="math">n=1</span>, we design a variant of Schnorr protocol such that logarithms of input bases fulfill a specific quadratic relation, which yields both constant communication and computation costs.</p>

    <p class="text-gray-300">We provide the security statement for our zk-WIP protocol in Theorem 1 and its proof is relegated to Appendix C.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">y</span> be a constant in <span class="math">\\mathbb{Z}_{p}^{*}</span>. The zero-knowledge argument for WIP presented in Fig.1. has perfect completeness, perfect honest verifier zero-knowledge and computational witness-extended emulation.</p>

    <h2 id="sec-18" class="text-2xl font-bold">4 Range Proofs</h2>

    <p class="text-gray-300">This section describes our zero-knowledge argument protocols for single range proof in Section 4.1 and aggregate range proof in Section 4.2.</p>

    <p class="text-gray-300">4.1 Single Range Proof Protocol</p>

    <p class="text-gray-300">We consider the following group-based range relation such that witeness is committed using the Pedersen commitment scheme.</p>

    <p class="text-gray-300"><span class="math">\\left\\{(\\bm{g},\\bm{h}\\in\\mathbb{G}^{n},g,h,V\\in\\mathbb{G};v,\\gamma\\in\\mathbb{Z}_{p}):\\ V=g^{v}h^{\\gamma}\\wedge v\\in[0,2^{n}-1]\\right\\}</span></p>

    <p class="text-gray-300">Here, <span class="math">V</span> is a commitment to the witness <span class="math">v</span> that lies in an interval <span class="math">[0,2^{n}-1]</span>. <span class="math">\\bm{g}</span> and <span class="math">\\bm{h}</span> are vectors of generators of the group <span class="math">\\mathbb{G}</span>, but their usage is yet ambiguous in the above relation. In fact, those are parameters of the generalized Pedersen commitment scheme. <span class="math">v</span> can be represent as an <span class="math">n</span>-bit string <span class="math">\\bm{a}_{L}</span> and it will be committed using <span class="math">\\bm{g}</span> and <span class="math">\\bm{h}</span> in our range proof protocol. Then, the goal of the range protocol is to prove the knowledge of <span class="math">\\bm{a}_{L}</span> and an additional vector <span class="math">\\bm{a}_{R}</span> satisfying</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{R}=\\bm{a}_{L}-\\bm{1}^{n}\\ \\wedge\\ \\bm{a}_{L}\\circ\\bm{a}_{R}=\\bm{0}\\ \\wedge\\ \\langle\\bm{a}_{L},\\bm{2}^{n}\\rangle=v</span> (11)</p>

    <p class="text-gray-300">Eq. (11) consists of <span class="math">2n+1</span> equations. To handle multiple equations at once with sublinear manner in <span class="math">n</span>, we follow the technique dating back to Groth <em>[43]</em> such that it batches equations by computing inner-product with <span class="math">\\overrightarrow{y}^{n}</span> for a random challenge <span class="math">y</span> given from the verifier.</p>

    <p class="text-gray-300">Applying the batching technique, Eq. (11) becomes a product relation between three values, the witness <span class="math">\\bm{a}_{L},\\bm{a}_{R}</span> and the challenge <span class="math">y</span> used in batching technique. Bünz et al. <em>[20]</em> presented a proof system for the relations in Eq. (11) on the basis of their inner-product argument. Their inner-product protocol does not support the zero-knowledgeness property, so that the openings of the Pedersen commitments are revealed to the verifier. Hence, the reduction process should introduce exponentiation-level blinding factors to hide openings, which is rather cumbersome to handle, so that it requires several interactions and transmission of 5 elements in <span class="math">\\mathbb{Z}_{p}</span> and 2 group elements in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">Our zk-WIP protocol w.r.t. <span class="math">\\overrightarrow{y}^{n}</span> is a tailored protocol for proving a product relation between two hidden vectors <span class="math">\\bm{a}_{L}</span> and <span class="math">\\bm{a}_{R}</span> and the challenge <span class="math">\\overrightarrow{y}^{n}</span> with zero-knowledge. Consequently, we obtain an optimal reduction to zk-WIP protocol in the sense that the prover transmits only a group element in one move during the reduction phase.</p>

    <p class="text-gray-300">Let us explain our reduction to the WIP protocol. The prover begins with sending <span class="math">A=\\bm{g}^{\\bm{a}_{L}}\\bm{h}^{\\bm{a}_{R}}h^{\\alpha}\\in\\mathbb{G}</span> and the verifier returns random challenges <span class="math">y,z\\in\\mathbb{Z}_{p}</span>. Next, both the prover and the verifier can compute</p>

    <p class="text-gray-300"><span class="math">\\widehat{A}=A\\bm{g}^{-\\bm{1}^{n}z}\\bm{h}^{\\bm{2}^{n}\\circ\\overleftarrow{y}^{n}+\\bm{1}^{n}z}V^{y^{n+1}}g^{\\langle\\bm{1}^{n},\\overrightarrow{y}^{n}\\rangle z-\\langle\\bm{1}^{n},\\bm{2}^{n}\\rangle y^{n+1}z-\\langle\\bm{1}^{n},\\overrightarrow{y}^{n}\\rangle z^{2}}</span> (12)</p>

    <p class="text-gray-300">Here, all the exponents are combinations of the challenges <span class="math">y</span> and <span class="math">z</span>, so that <span class="math">\\widehat{A}</span> is publicly computable. Finally, both the prover and the verifier run the WIP argument w.r.t <span class="math">\\overrightarrow{y}^{n}</span> on input <span class="math">(\\bm{g},\\bm{h},g,h,\\widehat{A};\\widehat{\\bm{a}}_{L},\\widehat{\\bm{a}}_{R},\\widehat{\\alpha})</span>, where</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\bm{a}}_{L}</span> <span class="math">=\\bm{a}_{L}-\\bm{1}^{n}\\cdot z\\in\\mathbb{Z}_{p}^{n}</span> <span class="math">\\widehat{\\bm{a}}_{R}</span> <span class="math">=\\bm{a}_{R}+\\bm{2}^{n}\\circ\\overleftarrow{y}^{n}+\\bm{1}^{n}\\cdot z\\in\\mathbb{Z}_{p}^{n}</span> <span class="math">\\widehat{\\alpha}\\</span> <span class="math">=\\alpha+\\gamma\\cdot y^{n+1}\\in\\mathbb{Z}_{p}.</span></p>

    <p class="text-gray-300">One can easily check that the above defined <span class="math">\\widehat{\\bm{a}}_{L}</span>, <span class="math">\\widehat{\\bm{a}}_{R}</span>, and <span class="math">\\widehat{\\alpha}</span> are the exponents with the base <span class="math">\\bm{g}</span>, <span class="math">\\bm{h}</span>, and <span class="math">h</span> of <span class="math">\\widehat{A}</span>, respectively. See the proof of Theorem 2 for the completeness.</p>

    <p class="text-gray-300">Now, let us explain the intuition why the above reduction correctly works. Let <span class="math">\\beta</span> be the exponent with the base <span class="math">g</span> in <span class="math">A</span>, which is set to be 0 by the honest prover. Then, the WIP argument guarantees that the exponent with the base <span class="math">g</span> of <span class="math">\\widehat{A}</span>, which is defined as</p>

    <p class="text-gray-300"><span class="math">\\beta+vy^{n+1}+\\langle\\bm{1}^{n},\\overrightarrow{y}^{n}\\rangle z-\\langle\\bm{1}^{n},\\bm{2}^{n}\\rangle y^{n+1}z-\\langle\\bm{1}^{n},\\overrightarrow{y}^{n}\\rangle z^{2}</span> (13)</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: Zero Knowledge Argument for Range Proof  <span class="math">v \\in [0, 2^n - 1]</span></p>

    <p class="text-gray-300">by Eq. (12), is equal to  <span class="math">\\widehat{\\pmb{a}}_L\\odot_y\\widehat{\\pmb{a}}_R</span> . In fact, it can be written as</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">where the fourth equality holds due to Eq. (9). Then, since  <span class="math">\\pmb{a}_L</span> ,  <span class="math">\\pmb{a}_R</span> , and  <span class="math">v</span>  are committed to before seeing the challenges  <span class="math">y</span>  and  <span class="math">z</span> , we expect that each coefficient of distinct monomial in Eq. (13) is equal to the corresponding coefficient in Eq. (14). Therefore, Eq. (11) should satisfy.</p>

    <p class="text-gray-300">The full description of our range proof protocol is provided in Figure 2. The prover sends only one group element  <span class="math">A \\in \\mathbb{G}</span>  for this reduction to the WIP argument of length- <span class="math">n</span>  vectors. Totally, the prover in the aggregate range proof protocol transmits  <span class="math">2 \\cdot \\lceil \\log_2(n) \\rceil + 3</span>  elements in  <span class="math">\\mathbb{G}</span>  and 3 elements in  <span class="math">\\mathbb{Z}_p</span> . Computational cost of both the prover and the verifier is linear in  <span class="math">n</span> .</p>

    <p class="text-gray-300">We provide the security statement for our range proof protocol in Theorem 2 and its proof is relegated to Appendix D.</p>

    <p class="text-gray-300">Theorem 2. The zero-knowledge argument for range proof presented in Figure 2 has perfect completeness, perfect honest verifier zero-knowledge and computational witness extended emulation.</p>

    <p class="text-gray-300">We show that our range proof can be extended to support aggregate range proof as in [20]. That is, when the prover needs to perform  <span class="math">m &amp;gt; 1</span>  range proofs at the same time, the proof size</p>

    <p class="text-gray-300">increases only logarithmically in <span class="math">m</span>, so that we achieve the shortest proof size even in performing multiple range proofs. More precisely, we present a proof system for the following relation.</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} (\\boldsymbol {g}, \\boldsymbol {h} \\in \\mathbb {G} ^ {m \\cdot n}, g, h \\in \\mathbb {G}, \\boldsymbol {V} \\in \\mathbb {G} ^ {m}; \\boldsymbol {v}, \\boldsymbol {\\gamma} \\in \\mathbb {Z} _ {p} ^ {m}) \\\\ : V _ {j} = g ^ {v _ {j}} h ^ {\\gamma_ {j}} \\wedge v _ {j} \\in [ 0, 2 ^ {n} - 1 ] \\text { for } j \\in [ 1, m ] \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">For <span class="math">j \\in [1, m]</span>, let <span class="math">\\pmb{d}_j := (\\underbrace{0, \\dots, 0}_{(j-1) \\cdot n}, \\mathbf{2}^n, \\underbrace{0, \\dots, 0}_{(m-j) \\cdot n})</span>. The prover commits to <span class="math">\\pmb{a}_L \\in \\{0, 1\\}^{m \\cdot n}</span>, which is the concatenation of all of the bits for <span class="math">v_j</span>'s and satisfies <span class="math">\\langle \\pmb{a}_L, \\pmb{d}_j \\rangle = v_j</span> for all <span class="math">j \\in [1, m]</span>, and <span class="math">\\pmb{a}_R := \\pmb{a}_L - \\mathbf{1}^{mn}</span>. More precisely, the prover sends <span class="math">A = \\pmb{g}^{\\pmb{a}_L} \\pmb{h}^{\\pmb{a}_R} h^\\alpha \\in \\mathbb{G}</span>. Then, the prover's goal is to prove the knowledge of <span class="math">\\pmb{a}_L</span> and <span class="math">\\pmb{a}_R</span> satisfying following relations:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {a} _ {R} = \\boldsymbol {a} _ {L} - \\mathbf {1} ^ {n} \\wedge \\boldsymbol {a} _ {L} \\circ \\boldsymbol {a} _ {R} = \\mathbf {0} \\wedge \\langle \\boldsymbol {a} _ {L}, \\boldsymbol {d} _ {j} \\rangle = v _ {j} \\text { for all } j \\in [ 1, m ].</span></div>

    <p class="text-gray-300">Although the aggregate range proof requires more relations to convince the verifier than the single range proof, the batching technique used in the single range proof can be suitably extended. For the challenge <span class="math">z</span> given from the verifier, we let <span class="math">\\pmb{d} \\coloneqq \\sum_{j=1}^{m} z^{2j} \\cdot \\pmb{d}_j</span>, and then <span class="math">m</span> relations <span class="math">\\langle \\pmb{a}_L, \\pmb{d}_j \\rangle = v_j \\forall j \\in [1,m]</span> can be batched to a single relation <span class="math">\\langle \\pmb{a}_L, \\pmb{d} \\rangle = \\sum_{j=1}^{m} z^{2j} \\cdot v_j</span>. Here, we use even powers of <span class="math">z</span> since <span class="math">z</span> is already reserved for convincing the other equations. All the other parts of the protocol are essentially the same as the single range proof protocol.</p>

    <p class="text-gray-300">The full description of our aggregate range proof protocol is provided in Figure 3. The prover sends only one group element <span class="math">A \\in \\mathbb{G}</span> for this reduction to the zk-WIP argument of length-<span class="math">mn</span> vectors. Totally, the prover in the aggregate range proof protocol transmits <span class="math">2 \\cdot \\lceil \\log_2(m) + \\log_2(n) \\rceil + 3</span> elements in <span class="math">\\mathbb{G}</span> and 3 elements in <span class="math">\\mathbb{Z}_p</span>. Computational cost of both the prover and the verifier is linear in <span class="math">mn</span>.</p>

    <p class="text-gray-300">We provide the security statement for our aggregate range proof protocol in Theorem 3 and its proof is relegated to Appendix D.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> The zero-knowledge argument for range proof presented in Figure 3 has perfect completeness, perfect honest verifier zero-knowledge and computational witness extended emulation.</p>

    <p class="text-gray-300">As another application of the zk-WIP argument, we present a zero-knowledge proof system for arbitrary arithmetic circuits. Bootle et al. [16] presents a conversion from an arbitrary arithmetic circuit with <span class="math">n</span> multiplication gates into a certain relation containing a Hadamard-prodct with some linear constraints, which is formally described below. Bünz et al. [20] slightly generalizes the relation to include committed values as inputs to the arithmetic circuit, so that the converted relation contains the committed values as well. We present a zero-knowledge argument for the following relation, which is exactly the same as that in [20].</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{c} \\left(\\boldsymbol {g} _ {1}, \\boldsymbol {g} _ {2}, \\boldsymbol {h} _ {1}, \\boldsymbol {h} _ {2} \\in \\mathbb {G} ^ {n}, \\boldsymbol {V} \\in \\mathbb {G} ^ {m}, g, h \\in \\mathbb {G}, \\boldsymbol {W} _ {L}, \\boldsymbol {W} _ {R}, \\boldsymbol {W} _ {O} \\in \\mathbb {Z} _ {p} ^ {Q \\times n}, \\right. \\\\ \\quad \\boldsymbol {W} _ {V} \\in \\mathbb {Z} _ {p} ^ {Q \\times m}, \\boldsymbol {c} \\in \\mathbb {Z} _ {p} ^ {Q}, \\boldsymbol {a} _ {L}, \\boldsymbol {a} _ {R}, \\boldsymbol {a} _ {O} \\in \\mathbb {Z} _ {p} ^ {n}, \\boldsymbol {v}, \\boldsymbol {\\gamma} \\in \\mathbb {Z} _ {p} ^ {m} \\\\ \\quad V _ {j} = g ^ {v _ {j}} h ^ {\\gamma_ {j}} \\forall j \\in [ 1, m ] \\quad \\wedge \\quad \\boldsymbol {a} _ {L} \\circ \\boldsymbol {a} _ {R} = \\boldsymbol {a} _ {O} \\\\ : \\wedge \\boldsymbol {W} _ {L} \\cdot \\boldsymbol {a} _ {L} ^ {\\top} + \\boldsymbol {W} _ {R} \\cdot \\boldsymbol {a} _ {R} ^ {\\top} + \\boldsymbol {W} _ {O} \\cdot \\boldsymbol {a} _ {O} ^ {\\top} = \\boldsymbol {W} _ {V} \\cdot \\boldsymbol {v} ^ {\\top} + \\boldsymbol {c} ^ {\\top} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Here, we restrict <span class="math">\\pmb{W}_V \\in \\mathbb{Z}_p^{Q \\times m}</span> to be of rank <span class="math">m</span>, as in Bulletproofs [20].</p>

    <p class="text-gray-300">Like our range proof protocol, our goal for arithmetic circuit proof is to reduce to the zk-WIP argument and we show that one move with one group element (in terms of the prover) is sufficient</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 3: Zero Knowledge Argument for Aggregate Range Proof  <span class="math">v_{j} \\in [0,2^{n} - 1]</span>  for  <span class="math">j \\in [1,m]</span></p>

    <p class="text-gray-300">for our reduction. The whole description of our arithmetic circuit proof is given in Fig. 4. For a concise description, we introduce notation used in Fig. 4. For an integer  <span class="math">z \\in \\mathbb{Z}_p</span> ,  <span class="math">\\tilde{\\pmb{z}}^Q</span>  denotes a vector  <span class="math">(z,z^3,z^5,\\ldots ,z^{2Q - 1}) \\in \\mathbb{Z}_p^Q</span>  consisting of odd powers of  <span class="math">z</span> . For matrices  <span class="math">\\pmb{W} \\in \\mathbb{Z}_p^{Q\\times n}</span> ,  <span class="math">\\mathsf{T}_{\\pmb{W}}^{(y,z)}</span>  denotes  <span class="math">(y^{-1},y^{-2},\\dots,y^{-n}) \\circ (\\tilde{\\pmb{z}}^Q\\pmb{W})</span> . That is, when  <span class="math">y,z</span>  are challenges given from the verifier,  <span class="math">\\mathsf{T}_{\\pmb{W}}^{(y,z)}</span>  is a publicly computable value.</p>

    <p class="text-gray-300">First, the prover sends  <span class="math">A = \\pmb{g}_1^{\\pmb{a}_L}\\pmb{g}_2^{\\pmb{a}_O}\\pmb{h}_1^{\\pmb{a}_R}h^\\alpha</span>  that is a commitment to  <span class="math">\\pmb{a}_L,\\pmb{a}_O,\\pmb{a}_R</span> . Then, the prover's goal is to convince that  <span class="math">\\pmb{a}_L,\\pmb{a}_O,\\pmb{a}_R</span>  as well as  <span class="math">v_{j}</span> 's satisfy the following relations.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} V _ {j} = g ^ {v _ {j}} h ^ {\\gamma_ {j}} \\forall j \\in [ 1, m ] \\\\ \\wedge \\boldsymbol {a} _ {L} \\circ \\boldsymbol {a} _ {R} = \\boldsymbol {a} _ {O} \\\\ \\wedge \\boldsymbol {W} _ {L} \\cdot \\boldsymbol {a} _ {L} ^ {\\top} + \\boldsymbol {W} _ {R} \\cdot \\boldsymbol {a} _ {R} ^ {\\top} + \\boldsymbol {W} _ {O} \\cdot \\boldsymbol {a} _ {O} ^ {\\top} = \\boldsymbol {W} _ {V} \\cdot \\boldsymbol {v} ^ {\\top} + \\boldsymbol {c} ^ {\\top} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Next, both the prover and the verifier compute</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {A} = A \\mathbf {g} _ {1} ^ {\\mathbf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)}} \\mathbf {h} _ {1} ^ {\\mathbf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)}} \\mathbf {h} _ {2} ^ {y ^ {- n} \\left(\\mathbf {T} _ {\\boldsymbol {W} _ {O}} ^ {(y, z)} - \\mathbf {1} ^ {n}\\right)} \\mathbf {V} ^ {\\hat {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V}} g ^ {\\hat {\\boldsymbol {z}} ^ {Q} \\cdot \\boldsymbol {c} ^ {\\top} + \\mathbf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)} \\odot_ {y} \\mathbf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)}} \\tag {15}</span></div>

    <p class="text-gray-300">and run the protocol for the  <span class="math">\\mathbf{zk}</span> -WIP w.r.t.  <span class="math">\\vec{y}^{2n}</span>  on input  <span class="math">((\\pmb{g}_1, \\pmb{g}_2), (\\pmb{h}_1, \\pmb{h}_2), g, h, \\widehat{A}; \\widehat{\\pmb{a}}_L, \\widehat{\\pmb{a}}_R, \\widehat{\\alpha})</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {L} = \\left(\\boldsymbol {a} _ {L} + \\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)}, \\boldsymbol {a} _ {O}\\right) \\tag {16}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {R} = \\left(\\boldsymbol {a} _ {R} + \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)}, y ^ {- n} \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {O}} ^ {(y, z)} - \\mathbf {1} ^ {n}\\right)\\right) \\tag {17}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\alpha} = \\alpha + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {\\gamma} ^ {\\top}</span></div>

    <p class="text-gray-300"><span class="math">\\widehat{\\bm{a}}_{R}=\\widehat{\\bm{a}}_{L}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{L}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}+\\widehat{\\bm{a}}_{R}</span></p>

    <p class="text-gray-300">One can easily check that the above defined <span class="math">\\widehat{\\bm{a}}_{L}</span>, <span class="math">\\widehat{\\bm{a}}_{R}</span>, and <span class="math">\\widehat{\\alpha}</span> are the exponents with the base <span class="math">(\\bm{g}_{1},\\bm{g}_{2})</span>, <span class="math">(\\bm{h}_{1},\\bm{h}_{2})</span>, and <span class="math">h</span> of <span class="math">\\widehat{A}</span>, respectively. See the proof of Theorem 4 for the completeness.</p>

    <p class="text-gray-300">Now, let us explain the intuition why the above reduction correctly works. Let <span class="math">\\beta</span> be the exponent with the base <span class="math">g</span> in <span class="math">A</span>, which is set to be <span class="math">0</span> by the honest prover. Similarly, let <span class="math">\\bm{a}_{P}</span> be the exponent with base <span class="math">\\bm{h}_{2}</span> in <span class="math">A</span>, which is set to be <span class="math">\\bm{0}</span> by the honest prover. Then, the WIP argument guarantees that the exponent with the base <span class="math">g</span> of <span class="math">\\widehat{A}</span>, which is defined as</p>

    <p class="text-gray-300"><span class="math">\\beta+\\tilde{\\bm{z}}^{Q}\\bm{W}_{V}\\bm{v}^{\\top}+\\tilde{\\bm{z}}^{Q}\\cdot\\bm{c}^{\\top}+\\mathsf{T}_{\\bm{W}_{R}}^{(y,z)}\\odot_{y}\\mathsf{T}_{\\bm{W}_{L}}^{(y,z)}</span> (18)</p>

    <p class="text-gray-300">by Eq. (15), is equal to <span class="math">\\widehat{\\bm{a}}_{L}\\odot_{y}\\widehat{\\bm{a}}_{R}</span> and so is equal to</p>

    <p class="text-gray-300"><span class="math">(\\bm{a}_{L}+\\mathsf{T}_{\\bm{W}_{R}}^{(y,z)},\\ \\bm{a}_{O})\\odot_{y}\\left(\\bm{a}_{R}+\\mathsf{T}_{\\bm{W}_{L}}^{(y,z)},\\ \\bm{a}_{P}+y^{-n}(\\mathsf{T}_{\\bm{W}_{O}}^{(y,z)}-\\bm{1}^{n})\\right)</span> (19)</p>

    <p class="text-gray-300">by Eq. (16) and (17). <span class="math">\\bm{a}_{L}</span>, <span class="math">\\bm{a}_{R}</span>, and <span class="math">\\bm{v}</span> are committed to before disclosing the challenges <span class="math">y</span> and <span class="math">z</span>, so that we expect that each coefficient of distinct monomial in Eq. (18) is equal to the corresponding coefficient in Eq. (19). This enables to convince the verifier of several relations given in Eq. (11) at a time. For example, there is no <span class="math">y</span> only terms in Eq. (18), but <span class="math">\\bm{a}_{L}\\odot_{y}\\bm{a}_{R}+y^{n}\\cdot\\bm{a}_{O}\\odot_{y}\\bm{a}_{P}-\\bm{a}_{O}\\odot_{y}\\bm{1}^{n}</span> is <span class="math">y</span> only terms in Eq. (19), so that we have a relation</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{L}\\odot_{y}\\bm{a}_{R}+y^{n}\\cdot\\bm{a}_{O}\\odot_{y}\\bm{a}_{P}-\\bm{a}_{O}\\odot_{y}\\bm{1}^{n}=\\bm{0}</span></p>

    <p class="text-gray-300">and it implies the desired relation <span class="math">\\bm{a}_{L}\\circ\\bm{a}_{R}=\\bm{a}_{O}</span>. We relegate the detailed calculations for checking the soundness to the proof of Theorem 4.</p>

    <p class="text-gray-300">The full description of our arithmetic circuit proof protocol is provided in Figure 4. The prover sends only one group element <span class="math">A\\in\\mathbb{G}</span> for this reduction to the zk-WIP argument of length-<span class="math">2n</span> vectors. Totally, the prover of the aggregate range proof protocol transmits <span class="math">2\\cdot\\lceil\\log_{2}(n)\\rceil+5</span> elements in <span class="math">\\mathbb{G}</span> and <span class="math">3</span> elements in <span class="math">\\mathbb{Z}_{p}</span>. Computational cost of the prover and the verifier is linear in <span class="math">n</span>.</p>

    <p class="text-gray-300">We provide the security statement for our zero-knowledge proof protocol for arithmetic circuits in Theorem 4 and its proof is relegated to Appendix E.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">The zero-knowledge argument presented in Figure 4 has perfect completeness, perfect honest verifier zero-knowledge and computational witness extended emulation.</p>

    <h2 id="sec-22" class="text-2xl font-bold">6 Evaluation</h2>

    <p class="text-gray-300">In this section, we report our experimental results for our protocols discussed in the previous sections and present a comparison with Bulletproofs <em>[20]</em>.</p>

    <p class="text-gray-300">Experimental Setup. Except where noted, our experimental results were conducted on an Intel i5-9600K CPU @ 3.70GHz and 32GB DDR4 memory. For fair comparison with optimized implementation for Bulletproofs, our protocols are implemented in Rust using the curve25519-dalek library for ECC operations <em>[54]</em> and compared with the January 2020 git version of Bulletproofs implementation in by Valence et al. <em>[28]</em>, which is, to the best of our knowledge, one of the most optimized implementations for Bulletproofs. For more details, we use <span class="math">\\mathbb{F}_{p}=\\mathbb{F}_{2^{255}-19}</span> and point arithmetic in affine Niels coordinates and both implementations for Bulletproofs and Bulletproofs+ are expected to have 128-bit security <em>[48]</em>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">6.1 Practical Optimizations</h3>

    <p class="text-gray-300">We implement several optimizations to make producing and verifying the proofs in our protocols faster.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 4: Zero Knowledge Argument for Arithmetic Circuit</p>

    <p class="text-gray-300">Reduction to Single Multi-Exponentiation. Let  <span class="math">\\mathbf{g}</span>  and  <span class="math">\\mathfrak{h}</span>  be the generators used in the final round of the protocol and  <span class="math">e_i</span>  be the challenge from the  <span class="math">i</span> -th round. At the last round, the verifier should compute  <span class="math">\\mathbf{g}^{r&#x27; \\cdot e} \\mathbf{h}^{s&#x27; \\cdot e}</span> . To avoid computing  <span class="math">\\widehat{\\pmb{g}}</span>  and  <span class="math">\\widehat{\\pmb{h}}</span>  at every round, we rewrite these final generators  <span class="math">\\mathbf{g}, \\mathfrak{h}</span>  as the single multi-exponentiation, using recursion unrolling like [20]. This quite reduces computational overhead on the verifier side since a single multi-exponentiation can be done much faster than multiplying the results of individual exponentiations.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} = \\prod_ {i = 1} ^ {n} g _ {i} ^ {s _ {i}} \\in \\mathbb {G} \\text {a n d} \\mathfrak {h} = \\prod_ {i = 1} ^ {n} h _ {i} ^ {s _ {i} ^ {\\prime}} \\in \\mathbb {G},</span></div>

    <p class="text-gray-300">where  <span class="math">\\pmb{s} = (s_1, \\dots, s_n), \\pmb{s}&#x27; = (s_1&#x27;, \\dots, s_n&#x27;) \\in \\mathbb{Z}_p^n</span>  depend on only the challenges  <span class="math">(e_1, \\dots, e_{\\log_2(n)})</span> . The scalars  <span class="math">s_1, \\dots, s_n</span>  and  <span class="math">s_1&#x27;, \\dots, s_n&#x27;</span>  can be computed by the following simple calculations:</p>

    <div class="my-4 text-center"><span class="math-block">s _ {i} = (1 / y ^ {i - 1}) \\cdot \\prod_ {j = 1} ^ {\\log_ {2} (n)} e _ {j} ^ {b (i, j)} \\mathrm {a n d} s _ {i} ^ {\\prime} = \\prod_ {j = 1} ^ {\\log_ {2} (n)} e _ {j} ^ {- b (i, j)}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">b (i, j) = \\left\\{ \\begin{array}{l l} 1 &amp;amp; \\text {t h e} j \\text {- t h b i t o f} i - 1 \\text {i s} 1 \\\\ - 1 &amp;amp; \\text {o t h e r w i s e} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Then the entire verification check in zk-WIP argument protocol given in Figure 1 reduces to a single multi-exponentiation as follows:</p>

    <p class="text-gray-300"><span class="math">\\bm{g}^{r^{\\prime}e\\cdot\\bm{s}}\\bm{h}^{s^{\\prime}e\\cdot\\bm{s}^{\\prime}}g^{r^{\\prime}\\odot s^{\\prime}}h^{\\delta^{\\prime}}\\overset{?}{=}\\left(P\\cdot\\prod_{j=1}^{\\log_{2}(n)}L_{j}^{e_{j}^{2}}R_{j}^{e_{j}^{-2}}\\right)^{e^{2}}\\cdot A^{e}\\cdot B</span> <span class="math">=P^{e^{2}}\\cdot\\left(\\prod_{j=1}^{\\log_{2}(n)}L_{j}^{e^{2}\\cdot e_{j}^{2}}R_{j}^{e^{2}\\cdot e_{j}^{-2}}\\right)\\cdot A^{e}\\cdot B.</span></p>

    <p class="text-gray-300">Reuse in Scalars. As an additional optimization, our implementation uses the dynamic programming paradigm to reduce the number of exponentiations in <span class="math">\\mathbb{F}_{p}</span> that cover a large part of computing scalars. For example, consider an exponent of base <span class="math">g</span> while computing <span class="math">\\widehat{\\bm{A}}</span> in our range proof protocol (see Figure 2). We inductively obtain <span class="math">y^{i}</span> by multiplying <span class="math">y</span> by <span class="math">y^{i-1}</span> and this result will be reused in computing the last term of exponent of base <span class="math">g</span>. In consequence, we can get a resulting scalar for the <span class="math">g</span> only with <span class="math">n+5</span> multiplications in <span class="math">\\mathbb{F}_{p}</span> where we do not count the exponentiations of base 2 as <span class="math">2\\ll y</span>. We apply the same technique to the implementations of other argument protocols.</p>

    <p class="text-gray-300">Batch Verification. Batch verification technique in <em>[20]</em> is applicable to Bulletproofs+. Informally, batch verification collapses two independent exponentiations <span class="math">g^{a}\\overset{?}{=}1</span> and <span class="math">g^{b}\\overset{?}{=}1</span> into a single exponentiation <span class="math">g^{a\\cdot r+b}\\overset{?}{=}1</span> by picking a random value in <span class="math">\\mathbb{F}_{p}</span>. Similarly, in our WIP-based argument protocols, the verifier needs to test whether <span class="math">\\widehat{\\bm{A}}</span> is correctly computed and to invoke the WIP verifier with a reduced proof. Because the bases in both computations are equivalent, we can utilize batch verification technique so as to reduce CPU-times at the verifier as in Bulletproofs.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">6.2 Experimental Results</h3>

    <p class="text-gray-300">We implement our protocols with the above optimizations and in what follows, we present the results. The experimental results of range arguments are summarized in Table 2 for each of our metrics. We use three metrics: 1) the size of a proof in bytes; 2) the total CPU time at the prover in milliseconds, and 3) the total CPU time at the verifier. For this purpose, we use Rust’s benchmark tests that runs our benchmark a number of times and takes the average. When demonstrating CPU times, we omit the total number of iterations made by the test crate.</p>

    <p class="text-gray-300">Proof Size. As shown in the previous sections, the prover of Bulletproofs+ for range proof transmits <span class="math">2\\cdot\\lceil\\log_{2}(m)+\\log_{2}(n)\\rceil+6</span> field or group elements which is 3 elements smaller than that of Bulletproofs. In general, the prover of Bulletproofs+ for arbitrary arithmetic circuit sends <span class="math">2\\cdot\\lceil\\log_{2}(n)\\rceil+8</span> field or group elements which is 5 elements smaller than that of Bulletproofs. In our experimental parameter setting, Bulletproofs+ for range proof and arithmetic circuit proof always save 96 bytes and 160 bytes, respectively, compared with Bulletproofs, regardless of input size.</p>

    <p class="text-gray-300">Prover’s CPU time on Aggregate Range Proof. Table 2 and its graph on the prover’s time in Figure 5(a) show that a prover of Bulletproofs+ is slightly faster than that of Bulletproofs. When aggregating more proofs, the ratio between speeds tends to increase in our experimentation. For instance, in the case of range argument for a single 32-bit secret, our range argument protocol runs 9.7% faster than that of Bulletproofs; on the other hand, in the case of 64<span class="math">\\times</span>32-bit secrets our protocol runs 26.8% faster than that of Bulletproofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size (bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time (msec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time (msec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32x1</td>

            <td class="px-3 py-2 border-b border-gray-700">608</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">6.050174</td>

            <td class="px-3 py-2 border-b border-gray-700">5.939959</td>

            <td class="px-3 py-2 border-b border-gray-700">0.888529</td>

            <td class="px-3 py-2 border-b border-gray-700">0.905392</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32x8</td>

            <td class="px-3 py-2 border-b border-gray-700">800</td>

            <td class="px-3 py-2 border-b border-gray-700">704</td>

            <td class="px-3 py-2 border-b border-gray-700">48.539556</td>

            <td class="px-3 py-2 border-b border-gray-700">40.602728</td>

            <td class="px-3 py-2 border-b border-gray-700">4.514268</td>

            <td class="px-3 py-2 border-b border-gray-700">4.552336</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32x16</td>

            <td class="px-3 py-2 border-b border-gray-700">864</td>

            <td class="px-3 py-2 border-b border-gray-700">768</td>

            <td class="px-3 py-2 border-b border-gray-700">90.876456</td>

            <td class="px-3 py-2 border-b border-gray-700">78.086673</td>

            <td class="px-3 py-2 border-b border-gray-700">7.557350</td>

            <td class="px-3 py-2 border-b border-gray-700">8.136567</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32x32</td>

            <td class="px-3 py-2 border-b border-gray-700">928</td>

            <td class="px-3 py-2 border-b border-gray-700">832</td>

            <td class="px-3 py-2 border-b border-gray-700">181.853941</td>

            <td class="px-3 py-2 border-b border-gray-700">144.960432</td>

            <td class="px-3 py-2 border-b border-gray-700">13.477161</td>

            <td class="px-3 py-2 border-b border-gray-700">14.235688</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32x128</td>

            <td class="px-3 py-2 border-b border-gray-700">1,056</td>

            <td class="px-3 py-2 border-b border-gray-700">960</td>

            <td class="px-3 py-2 border-b border-gray-700">704.885309</td>

            <td class="px-3 py-2 border-b border-gray-700">588.255902</td>

            <td class="px-3 py-2 border-b border-gray-700">49.228749</td>

            <td class="px-3 py-2 border-b border-gray-700">52.147692</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64x1</td>

            <td class="px-3 py-2 border-b border-gray-700">672</td>

            <td class="px-3 py-2 border-b border-gray-700">576</td>

            <td class="px-3 py-2 border-b border-gray-700">11.820812</td>

            <td class="px-3 py-2 border-b border-gray-700">10.449486</td>

            <td class="px-3 py-2 border-b border-gray-700">1.518970</td>

            <td class="px-3 py-2 border-b border-gray-700">1.524615</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64x8</td>

            <td class="px-3 py-2 border-b border-gray-700">864</td>

            <td class="px-3 py-2 border-b border-gray-700">768</td>

            <td class="px-3 py-2 border-b border-gray-700">91.297399</td>

            <td class="px-3 py-2 border-b border-gray-700">77.096859</td>

            <td class="px-3 py-2 border-b border-gray-700">7.774852</td>

            <td class="px-3 py-2 border-b border-gray-700">8.060279</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64x32</td>

            <td class="px-3 py-2 border-b border-gray-700">992</td>

            <td class="px-3 py-2 border-b border-gray-700">896</td>

            <td class="px-3 py-2 border-b border-gray-700">349.924111</td>

            <td class="px-3 py-2 border-b border-gray-700">301.339810</td>

            <td class="px-3 py-2 border-b border-gray-700">25.211956</td>

            <td class="px-3 py-2 border-b border-gray-700">26.216368</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64x64</td>

            <td class="px-3 py-2 border-b border-gray-700">1056</td>

            <td class="px-3 py-2 border-b border-gray-700">960</td>

            <td class="px-3 py-2 border-b border-gray-700">691.087248</td>

            <td class="px-3 py-2 border-b border-gray-700">591.986488</td>

            <td class="px-3 py-2 border-b border-gray-700">49.274442</td>

            <td class="px-3 py-2 border-b border-gray-700">51.575539</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64x128</td>

            <td class="px-3 py-2 border-b border-gray-700">1,120</td>

            <td class="px-3 py-2 border-b border-gray-700">1,024</td>

            <td class="px-3 py-2 border-b border-gray-700">1,382.280920</td>

            <td class="px-3 py-2 border-b border-gray-700">1,158.273015</td>

            <td class="px-3 py-2 border-b border-gray-700">96.373233</td>

            <td class="px-3 py-2 border-b border-gray-700">101.762113</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Comparison summary of proof size and timing in aggregate range proofs with Bulletproofs</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (a) CPU-times for proving proofs (b) CPU-times for verifying proofs Fig. 5: Timing comparisons in aggregation range proofs with Bulletproofs</p>

    <p class="text-gray-300">Comparing our WIP prover with a prover in the inner product argument of Bulletproofs, our WIP prover has to perform more operations, exponentions for blinding factor, in order to achieve zero-knowledgeness. These computational overhead is insignificant compared to heavy multi-exponentiations performed in the two provers. The most influential computation is performed during the process of reduction from the aggregate range proof to ingredient protocols (WIP for ours and inner product for Bulletproofs). In fact, the benefit of using WIP is a simpler process in the reduction than the approach used in Bulletproofs. More precisely, Bulletproofs requires more multi-exponentiations in the reduction process, contrary to a single multi-exponentiation in Bulletproofs+.</p>

    <p class="text-gray-300">Verifier's CPU time on Aggregate Range Proof. Figure 5(b) shows that our proposal is comparable to Bulletproofs in terms of the verifier's computational cost. Both of the verification costs in Bulletproofs and Bulletproofs+ are dominated by a single multi-exponentiation. In fact, Bulletproofs+ requires a multi-exponentiation for computing  <span class="math">\\widetilde{A}</span>  during the resuction process. We note that  <span class="math">\\widetilde{A}</span>  is taken as input of the WIP protocol so that it eventually becomes a component in the multi-exponentiation performed in the WIP argument protocol. Thus, the verifier can delay the computation of  <span class="math">\\widetilde{A}</span>  and extend the technique for reduction to single multi-exponentiation in Section 6.1. Finally, we obtain a single multi-exponentiation.</p>

    <p class="text-gray-300">Further Results on Proof for Matrix Multiplication. Now we demonstrate the performance of Bulletproofs+ for the knowledge of two matrices whose product equals a public matrix. Matrix multiplication arguments are often used for benchmarks of proof systems [70, 71, 73]. We use Bulletproofs+ for arithmetic circuit in Figure 4. Table 3 shows a benchmark result on matrix multiplication with different sizes from  <span class="math">2 \\times 2</span>  to  <span class="math">8 \\times 8</span> . We will release our solution as an open-source implementation later.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time (msec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time (msec)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Size</td>

            <td class="px-3 py-2 border-b border-gray-700">2x2</td>

            <td class="px-3 py-2 border-b border-gray-700">3.283881</td>

            <td class="px-3 py-2 border-b border-gray-700">0.856449</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4x4</td>

            <td class="px-3 py-2 border-b border-gray-700">20.820100</td>

            <td class="px-3 py-2 border-b border-gray-700">4.961256</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8x8</td>

            <td class="px-3 py-2 border-b border-gray-700">157.151009</td>

            <td class="px-3 py-2 border-b border-gray-700">39.029444</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: CPU times in our matrix multiplication argument</p>

    <p class="text-gray-300">Acknowledgement. This work was supported by Institute for Information &amp; communications Technology Promotion (IITP) grant funded by the Korea government (MSIT) (No. 2016-6-00600, A Study on Functional Encryption: Construction, Security Analysis, and Implementation) and by the National Research Foundation of Korea(NRF) grant funded by the Korea government(MSIT) (No. 2020R1C1C1A01006968). Myungsun Kim was supported by the Institute for Information and Communication Technology Promotion (IITP) grant funded by the Korean government (MSIT) (2018-0-00251, Privacy-Preserving and Vulnerability Analysis for Smart Contract).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Proceedings of the 2017 ACM sigsac conference on computer and communications security, pages 2087-2104. Association for Computing Machinery, 2017.</li>

      <li>C. Andrew Neff. A verifiable secret shuffle and its application to e-voting. In Proceedings of the 8th ACM conference on Computer and Communications Security, pages 116-125. Association for Computing Machinery, 2001.</li>

      <li>E. Androulaki, G. Karame, M. Roeschlin, T. Scherer, and S. Capkun. Evaluating user privacy in bitcoin. In <em>Financial Cryptography and Data Security - FC 2013</em>, volume 7859 of Lecture Notes in Computer Science, 2013.</li>

      <li>T. Attema and R. Cramer. Compressed  <span class="math">\\sigma</span> -protocol theory and practical application to plug &amp; play secure algorithms. Cryptology ePrint Archive, Report 2020/152, 2020. https://eprint.iacr.org/2020/152.</li>

      <li>M. Backes, A. Kate, M. Maffei, and K. Pecina. Obliviad: Provably secure and practical online behavioral advertising. In 2012 IEEE Symposium on Security and Privacy, pages 257-271. IEEE, 2012.</li>

      <li>N. Barić and B. Pfitzmann. Collision-free accumulators and fail-stop signature schemes without trees. In EUROCRYPT '97, volume 9696 of LNCS, pages 480-494. Springer, 1997.</li>

      <li>S. Bayer and J. Groth. Efficient zero-knowledge argument for correctness of a shuffle. In EUROCRYPT 2012, volume 7237 of LNCS, pages 263-280. Springer, 2012.</li>

      <li>Beam. https://beam.mw.</li>

      <li>M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proceedings of the 1st ACM conference on Computer and communications security, pages 62-73. Association for Computing Machinery, 1993.</li>

      <li>E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable zero knowledge with no trusted setup. In Annual International Cryptology Conference, pages 701-732. Springer, 2019.</li>

      <li>E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. Snarks for c: Verifying program executions succinctly and in zero knowledge. In CRYPTO 2013, pages 90-108. Springer, 2013.</li>

      <li>E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for r1cs. In EUROCRYPT 2019, pages 103-128. Springer, 2019.</li>

      <li>M. Blum, P. Feldman, and S. Micali. Non-interactive zero-knowledge and its applications. In Proceedings of the twentieth annual ACM symposium on Theory of computing, pages 103-112. Association for Computing Machinery, 1988.</li>

    </ol>

    <p class="text-gray-300">14] D. Boneh, B. Fisch, A. Gabizon, and Z. Williamson. https://hackmd.io/@dabo/B1U4kx8XI.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the weil pairing. Journal of Cryptology, 17(4):297–319, 2004.</li>

      <li>[16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT 2006, LNCS, pages 327–357. Springer, 2016.</li>

      <li>[17] E. F. Brickell, D. Chaum, I. B. Damgård, and J. van de Graaf. Gradual and verifiable release of a secret. In CRYPTO’87, LNCS, pages 156–166. Springer, 1988.</li>

      <li>[18] B. Bünz. https://github.com/bbuenz/BulletProofLib.</li>

      <li>[19] B. Bünz, S. Agrawal, M. Zamani, and D. Boneh. Zether: Towards privacy in a smart contract world. Cryptology ePrint Archive, Report 2019/191, 2019. https://eprint.iacr.org/2019/191.</li>

      <li>[20] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In IEEE Symposium on Security and Privacy 2018, pages 315–334. IEEE, 2018.</li>

      <li>[21] B. Bünz, B. Fisch, and A. Szepieniec. Transparent snarks from dark compilers. In EUROCRYPT 2020, volume 12105 of LNCS, pages 677–706. Springer, 2020.</li>

      <li>[22] J. Camenisch, S. Hohenberger, and A. Lysyanskaya. Compact e-cash. In EUROCRYPT 2005, volume 3494 of LNCS, pages 302–321. Springer, 2005.</li>

      <li>[23] J. Camenisch and A. Lysyanskaya. An efficient system for non-transferable anonymous credentials with optional anonymity revocation. In EUROCRYPT 2001, volume 2045 of LNCS, pages 93–118. Springer, 2001.</li>

      <li>[24] D. Chaum. Blind signatures for untraceable payments. In Advances in cryptology, pages 199–203. Springer, 1983.</li>

      <li>[25] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. Marlin: Preprocessing zksnarks with universal and updatable srs. In EUROCRYPT 2020, volume 12105 of LNCS, pages 738–768. Springer, 2020.</li>

      <li>[26] G. Couteau, T. Peters, and D. Pointcheval. Removing the strong rsa assumption from arguments over the integers. In EUROCRYPT 2017, volume 10211 of LNCS, pages 321–350. Springer, 2017.</li>

      <li>[27] G. Dagher, B. Bünz, J. Bonneau, J. Clark, and D. Boneh. Provisions: Privacy-preserving proofs of solvency for bitcoin exchanges. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, pages 720–731. Association for Computing Machinery, 2015.</li>

      <li>[28] H. de Valence, C. Yun, and O. Andreev. A pure-rust implementation of Bulletproofs using ristretto, 2018. https://github.com/dalek-cryptography/Bulletproofs.</li>

      <li>[29] S. Eskandarian, E. Messeri, J. Bonneau, and D. Boneh. Certificate transparency with privacy. PoPETs, 2017(4):329–344, 2017.</li>

      <li>[30] P. Fauzi, S. Meiklejohn, R. Mercer, and C. Orlandi. Quisquis: A new design for anonymous cryptocurrencies. In ASIACRYPT 2019, volume 11921 of LNCS, pages 649–678. Springer, 2019.</li>

      <li>[31] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO 1986, volume 263 of LNCS, pages 186–194. Springer, 1987.</li>

      <li>[32] Findora. https://findora.org.</li>

      <li>[33] G. Fuchsbauer, M. Orrù, and Y. Seurin. Aggregate cash systems: A cryptographic investigation of mim-blewimble. In EUROCRYPT 2019, volume 11476 of LNCS, pages 657–689. Springer, 2019.</li>

      <li>[34] J. Furukawa and K. Sako. An efficient scheme for proving a shuffle. In CRYPTO 2001, pages 368–387. Springer, 2001.</li>

      <li>[35] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.pdf.</li>

      <li>[36] P. Gazi, A. Kiayias, and D. Zindros. Proof-of-stake sidechains. In 2019 IEEE Symposium on Security and Privacy, pages 139–156. IEEE, 2019.</li>

      <li>[37] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct nizks without pcps. In EUROCRYPT 2013, pages 626–645. Springer, 2013.</li>

      <li>[38] I. Giacomelli, J. Madsen, and G. Orlandi. Zkboo: Faster zero-knowledge for booean circuits. In USENIX Security Symposium 2016, pages 1069–1083. USENIX Association, 2016.</li>

      <li>[39] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on computing, 18:186–208, 1989.</li>

      <li>[40] Grin. https://grin.mw.</li>

      <li>[41] J. Groth. A verifiable secret shuffle of homomorphic encryptions. In PKC 2009, LNCS, pages 145–160. Springer, 2003.</li>

      <li>[42] J. Groth. Non-interactive zero-knowledge arguments for voting. In Applied Cryptography and Network Security, pages 467–482, 2005.</li>

      <li>[43] J. Groth. Linear algebra with sub-linear zero-knowledge arguments. In CRYPTO 2009, LNCS, pages 192–208. Springer, 2009.</li>

      <li>[44] J. Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT 2016, pages 305–326. Springer, 2016.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[45] J. Groth and Y. Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 379–396. Springer, 2008.</li>

      <li>[46] J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. Updatable and universal common reference strings with applications to zk-snarks. In Annual International Cryptology Conference, pages 698–728. Springer, 2018.</li>

      <li>[47] M. Hoffmann, M. Klooß, and A. Rupp. Efficient zero-knowledge arguments in the discrete log setting, revisited. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications, pages 2093–2110, 2019.</li>

      <li>[48] IEFT. Rfc 7748, 2016.</li>

      <li>[49] A. Inc. https://github.com/adjoint-io/bulletproofs.</li>

      <li>[50] Interstellar. https://interstellar.com.</li>

      <li>[51] T. E. Jedusor. Mimblewimble, 2016.</li>

      <li>[52] H. Lipmaa. On diophantine complexity and statistical zero-knowledge arguments. In ASIACRYPT 2003, volume 2894 of LNCS, pages 398–415. Springer, 2003.</li>

      <li>[53] H. Lipmaa, N. Asokan, and V. Niemi. Secure vickrey auctions without threshold trust. In Financial Cryptography, volume 2357 of LNCS, pages 87–101. Springer, 2003.</li>

      <li>[54] I. A. Lovecruft and H. de Valence. curve25519-dalek version 2.0.0, 2019. https://docs.rs/curve25519-dalek/2.0.0/curve25519_dalek/.</li>

      <li>[55] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications, pages 2111–2128. Association for Computing Machinery, 2019.</li>

      <li>[56] G. Maxwell. Confidential transactions, 2016. https://people.xiph.org/~greg/confidential_values.txt.</li>

      <li>[57] Mimblewimble. https://github.com/mimblewimble/rust-secp256k1-zkp.</li>

      <li>[58] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2009.</li>

      <li>[59] I. open-source projects. https://csrc.nist.gov/projects/post-quantum-cryptography.</li>

      <li>[60] I. open-source projects. https://github.com/ing-bank/zkrp/tree/master/bulletproofs.</li>

      <li>[61] T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In CRYPTO 1991, volume 576 of LNCS, pages 129–140. Springer, 1991.</li>

      <li>[62] A. Poelstra. Mimblewimble, 2016.</li>

      <li>[63] A. Poelstra, P. Wuille, and G. Maxwell. https://github.com/apoelstra/secp256k1-mw/tree/bulletproofs.</li>

      <li>[64] N. P. Q. C. Project. https://csrc.nist.gov/projects/post-quantum-cryptography.</li>

      <li>[65] T. M. Project. https://github.com/monero-project/monero/tree/master/src/ringct.</li>

      <li>[66] D. Ron and A. Shamir. Quantitative analysis of the full bitcoin transaction graph. In Financial Cryptography and Data Security - FC 2013, volume 7859 of Lecture Notes in Computer Science, 2013.</li>

      <li>[67] C. specification. https://github.com/stellar/slingshot/blob/main/spacesuit/spec.md.</li>

      <li>[68] Stellar. https://www.stellar.org.</li>

      <li>[69] S.-F. Sun, M. Au, J. Liu, and T. Yuen. Ringct 2.0: A compact accumulator-based (linkable ring signature) protocol for blockchain cryptocurrency monero. In ESORICS 2017, volume 10493 of LNCS, pages 456–474. Springer, 2017.</li>

      <li>[70] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In CRYTPO (2) 2013, volume 8043 of LNCS, pages 71–89. Springer, 2013.</li>

      <li>[71] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In IEEE Symposium on Security and Privacy 2018, pages 926–943. IEEE, 2018.</li>

      <li>[72] G. Wood. Ethereum: A secure decentralised generalised transaction ledger. Ethereum project yellow paper, 151:1–32, 2014.</li>

      <li>[73] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In CRYPTO (3) 2019, volume 11694 of LNCS, pages 733–764. Springer, 2019.</li>

      <li>[74] T. H. Yuen, S. feng Sun, J. K. Liu, M. H. Au, M. F. Esgin, Q. Zhang, and D. Gu. Ringct 3.0 for blockchain confidential transaction: Shorter size and stronger security. IACR Cryptology ePrint Archive, 2019:508, 2019.</li>

      <li>[75] J. Zhang, T. Xie, Y. Zhang, and D. Song. Transparent polynomial delegation and its applications to zero knowledge proof. Cryptology ePrint Archive, Report 2019/1482, 2019. https://eprint.iacr.org/2019/1482.</li>

    </ul>

    <p class="text-gray-300">A Zero-Knowledge Arguments</p>

    <p class="text-gray-300">We consider arguments consisting of three interactive probabilistic polynomial-time algorithms <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> in the common random string model. <span class="math">\\mathcal{K}</span> is called the common reference string generator that takes the security parameter <span class="math">1^{\\lambda}</span> as input and outputs the common reference string <span class="math">\\sigma</span>. In this paper, the common reference string is a public key for the (generalized) Pedersen commitment scheme, that is, uniformly chosen group elements. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> are called the prover and the verifier, respectively, and the transcript produced by <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> when interacting on inputs <span class="math">x</span> and <span class="math">y</span> is denoted by <span class="math">tr\\leftarrow\\langle\\mathcal{P}(x),\\mathcal{V}(y)\\rangle</span>. At the end of transcript, the verifier <span class="math">\\mathcal{V}</span> accepts (equivalently outputs 1) or rejects (equivalently outputs 0). To explicitly denote <span class="math">\\mathcal{V}</span>’s final output, we use the notation <span class="math">\\langle\\mathcal{P}(x),\\mathcal{V}(y)\\rangle=b</span>, where <span class="math">b=1</span> if <span class="math">\\mathcal{V}</span> accepts and <span class="math">b=0</span> if <span class="math">\\mathcal{V}</span> rejects.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}\\subset\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}\\times\\{0,1\\}^{*}</span> be a polynomial time verifiable ternary relation. Given the common reference string <span class="math">\\sigma</span>, we call <span class="math">w</span> a witness for a statement <span class="math">x</span> if <span class="math">(\\sigma,x,w)\\in\\mathcal{R}</span>. We define a corresponding reference string dependent language <span class="math">L_{\\sigma}</span> as the set of statements <span class="math">x</span> that has a witness <span class="math">w</span> such that <span class="math">(\\sigma,x,w)\\in\\mathcal{R}</span>. That is,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$L_{\\sigma}=\\{\\ x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\exists w\\ \\text{such that}\\ (\\sigma,x,w)\\in\\mathcal{R}\\ \\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and if <span class="math">\\sigma=\\emptyset</span>, then this is the same as the standard notion of an NP-languages.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 6 (Argument of Knowledge)</h6>

    <p class="text-gray-300">The triple <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> is called an <em>argument of knowledge</em> for relation <span class="math">\\mathcal{R}</span> if it satisfies Completeness and Witness-Extended Emulation as defined below.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 7 (Perfect Completeness)</h6>

    <p class="text-gray-300"><span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> has <em>perfect completeness</em> if for all non-uniform polynomial-time interactive adversaries <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\langle\\mathcal{P}(\\sigma,x,w),\\mathcal{V}(\\sigma,x)\\rangle=1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lor\\ (\\sigma,x,w)\\notin\\mathcal{R}\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\sigma\\leftarrow\\mathcal{K}(1^{\\lambda});\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(x,w)\\leftarrow\\mathcal{A}(\\sigma)\\end{array}\\left]\\begin{array}[]{c}=1.\\end{array} \\]</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 8 (Computational Witness-Extended Emulation)</h6>

    <p class="text-gray-300">We say that <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> has <em>witness-extended emulation</em> if for all deterministic polynomial prover <span class="math">\\mathcal{P}^{*}</span> if there exists an expected polynomial time emulator <span class="math">\\mathcal{E}</span> such that for all non-uniform polynomial time interactive adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">negl(\\lambda)</span> such that the gap between the following two probabilities is smaller than <span class="math">negl(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[\\mathcal{A}(tr)=1\\ \\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\begin{array}[]{c}\\sigma\\leftarrow\\mathcal{K}(1^{\\lambda});(x,s)\\leftarrow\\mathcal{A}(\\sigma);\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">tr\\leftarrow\\langle\\mathcal{P}^{*}(\\sigma,x,s),\\mathcal{V}(\\sigma,x)\\rangle\\end{array}\\right]\\text{ and }\\\\ \\Pr\\left[\\begin{array}[]{c}\\mathcal{A}(tr)=1\\ \\land\\\\ \\text{if <span class="math">tr</span> is accepting,}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{then}(\\sigma,x,w)\\in\\mathcal{R}\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\sigma\\leftarrow\\mathcal{K}(1^{\\lambda});(x,s)\\leftarrow\\mathcal{A}(\\sigma);\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(tr,w)\\leftarrow\\mathcal{E}^{\\langle\\mathcal{P}^{*}(\\sigma,x,s),\\mathcal{V}(\\sigma,x)\\rangle}(\\sigma,x)\\end{array}\\left]\\begin{array}[]{c},\\end{array} \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathcal{E}</span> has access to the oracle <span class="math">\\langle\\mathcal{P}^{*}(\\sigma,x,s),\\mathcal{V}(\\sigma,x)\\rangle</span> that permits rewinding to a specific round and rerunning with with <span class="math">\\mathcal{V}</span> using fresh randomness.</p>

    <p class="text-gray-300">In the definition of witness-extended emulation, the value <span class="math">s</span> can be regarded to be the state of <span class="math">\\mathcal{P}^{<em>}</span>, including the randomness. Therefore, whenever <span class="math">\\mathcal{P}^{</em>}</span> is able to make a convincing argument when in state <span class="math">s</span>, <span class="math">\\mathcal{E}</span> can extract a witness, and so we call an argument <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfying Def. 8 and Def. 7 argument of knowledge (of witness <span class="math">w</span>).</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Definition 9 (Public Coin). An argument  <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is called public coin if all verifier's challenges are chosen uniformly at random and independently of the prover's messages, i.e., the challenges correspond to the verifier's randomness.</p>

    <p class="text-gray-300">Definition 10 (Perfect Special Honest Verifier Zero-Knowledge). A public coin argument  <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is perfect special honest verifier zero-knowledge (SHVZK) for  <span class="math">\\mathcal{R}</span>  if there exists probabilistic polynomial time simulator  <span class="math">\\mathsf{S}</span>  such that for all non-uniform polynomial time interactive adversaries  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ \\begin{array}{l} \\mathcal {A} (t r) = 1 \\wedge \\\\ (\\sigma , x, w) \\in \\mathcal {R} \\end{array} \\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sigma \\leftarrow \\mathcal {K} (1 ^ {\\lambda}); (x, w, \\rho) \\leftarrow \\mathcal {A} (\\sigma); \\\\ t r \\leftarrow \\langle \\mathcal {P} (\\sigma , x, w), \\mathcal {V} (\\sigma , x; \\rho) \\rangle \\end{array} \\right] \\\\ = \\Pr \\left[ \\begin{array}{c c} \\mathcal {A} (t r) = 1 \\wedge &amp; \\sigma \\leftarrow \\mathcal {K} (1 ^ {\\lambda}); \\\\ (\\sigma , x, w) \\in \\mathcal {R} &amp; (x, w, \\rho) \\leftarrow \\mathcal {A} (\\sigma); \\\\ &amp; t r \\leftarrow \\mathsf {S} (x, \\rho) \\end{array} \\right], \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\rho</span>  is the public coin randomness used by  <span class="math">\\mathcal{V}</span> .</p>

    <p class="text-gray-300">Consider a public coin interactive argument system that has  <span class="math">(2m + 1)</span> -move between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> . We view some accepting transcripts used in the argument form a  <span class="math">(n_{1},\\dots,n_{m})</span> -tree and depict the tree has  <span class="math">(m + 1)</span> -depth and root of the tree is labelled with a statement. We label each node in depth  <span class="math">i</span>  as an message from prover  <span class="math">a_{ij}</span>  and each edge from the prover's message as a challenge from verifier  <span class="math">x_{ik}</span>  where the index  <span class="math">j</span>  and  <span class="math">k</span>  identify the values in the same depth  <span class="math">i \\in [1,m]</span> . Because each node in depth  <span class="math">i</span>  has  <span class="math">n_i</span>  branches, there are  <span class="math">\\prod_{i=1}^{m} n_i</span>  accepting transcripts and that correspond to paths from root(statement) to leave. For example, a  <span class="math">(2,2)</span> -tree of accepting transcripts for 5-move public coin interactive argument can be represented as in Fig. 6.</p>

    <p class="text-gray-300">We state the general forking lemma [16] that we will use for the security proof of Bulletproofs+.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 6: An example image of (2,2)-tree</p>

    <p class="text-gray-300">Lemma 1 (General Forking Lemma [16]). Let  <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  be a  <span class="math">(2m + 1)</span> -move, public coin interactive protocol. Let  <span class="math">\\chi</span>  be a witness extraction algorithm that succeeds with overwhelming probability in extracting a witness from an  <span class="math">(n_{1},\\ldots ,n_{m})</span> -tree of accepting transcripts in probabilistic polynomial time. Assume that  <span class="math">\\prod_{i = 1}^{m}n_{i}</span>  is bounded above by  <span class="math">\\mathrm{poly}(\\lambda)</span>  where  <span class="math">\\lambda</span>  is the security parameter. Then  <span class="math">(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span>  has computational witness-extended emulation.</p>

    <p class="text-gray-300">B.2 Supplementary Mathematics</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">f(X_{1},\\ldots,X_{\\ell})</span> be a multivariate polynomial in <span class="math">\\mathbb{Z}_{p}[X_{1},\\ldots,X_{\\ell}]</span> of degree at most <span class="math">d_{i}</span> in the variable <span class="math">X_{i}</span> for <span class="math">i\\in[1,\\ell]</span>. If we have sets <span class="math">S_{i}</span> of distinct integers <span class="math">x_{i,j_{i}}</span>’s for <span class="math">i\\in[1,\\ell]</span> and <span class="math">j_{i}\\in[1,d_{i}+1]</span> such that</p>

    <p class="text-gray-300"><span class="math">f(x_{1,j_{1}},\\ldots,x_{\\ell,j_{\\ell}})=0,</span></p>

    <p class="text-gray-300">then <span class="math">f</span> is identical to the zero polynomial.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the statement by using the mathematical induction in <span class="math">\\ell</span>. The case of <span class="math">\\ell=1</span> is trivial due to the polynomial interpolation. That is, we have degree plus one number of roots, so that <span class="math">f</span> must be the zero polynomial. Assume that the statement is true for <span class="math">\\ell=k-1</span> for some <span class="math">k\\geq 2</span>. When considering variables <span class="math">X_{1},\\ldots,X_{k-1}</span> as if constants, we can think of <span class="math">f</span> as a single variable polynomial in <span class="math">X_{k}</span>. That is, we can re-write <span class="math">f</span> as follows.</p>

    <p class="text-gray-300"><span class="math">f(X_{1},\\ldots,X_{k})=f_{0}+f_{1}\\cdot X_{k}+\\cdots+f_{d_{k}}\\cdot X_{k}^{d_{k}}</span></p>

    <p class="text-gray-300">for some <span class="math">f_{0},\\ldots,f_{d_{k}}\\in\\mathbb{Z}_{p}[X_{1},\\ldots,X_{k-1}]</span>. For each <span class="math">(s_{1},\\ldots,s_{k-1})\\in S_{1}\\times\\cdots\\times S_{k-1}</span>, <span class="math">f(s_{1},\\ldots,s_{k-1},X_{k})</span> is polynomial of degree at most <span class="math">d_{k}</span> and by the definition of <span class="math">f</span>, <span class="math">f(s_{1},\\ldots,s_{k-1},X_{k})</span> must be the zero polynomial since it has degree plus one roots. Hence, all coefficients of polynomial <span class="math">f(s_{1},\\ldots,s_{k-1},X_{k})</span> should be zero, equivalently, <span class="math">f_{i}(s_{1},\\ldots,s_{k-1})=0</span>. Since <span class="math">f_{i}(X_{1},\\ldots,X_{k-1})</span>’s are polynomials with <span class="math">k-1</span> variables and for all <span class="math">i</span>, <span class="math">f_{i}(X_{1},\\ldots,X_{k-1})</span> becomes zero at all points in <span class="math">S_{1}\\times\\cdots\\times S_{k-1}</span>, we can apply the induction hypothesis to all <span class="math">f_{i}</span>’s and obtain that all <span class="math">f_{i}(X_{1},\\ldots,X_{k-1})</span>’s are the zero polynomials. Since all coefficients are zeros, <span class="math">f(X_{1},\\ldots,X_{k})</span> is indeed the zero polynomial.</p>

    <p class="text-gray-300">By the mathematical induction, we conclude that the statement in the lemma is true for all <span class="math">\\ell\\geq 1</span>.</p>

    <p class="text-gray-300">By extending the above result, we can consider polynomials containing negative powers of degree at most <span class="math">\\bar{d}_{i}</span>, where <span class="math">i</span> is the index for the number of variables. In this case, we can derive a similar result by considering <span class="math">(\\bar{d}_{i}+d_{i})</span> distinct roots instead of <span class="math">d_{i}</span> distinct roots. The proof is straightforward. We can consider <span class="math">f(x)\\cdot\\prod_{i=1}^{\\ell}X_{i}^{\\bar{d}_{i}}</span>, which contains only positive powers of variables, and apply Lemma 2 to <span class="math">f(x)\\cdot\\prod_{i=1}^{\\ell}X_{i}^{\\bar{d}_{i}}</span>. As a result, we have <span class="math">f(x)\\cdot\\prod_{i=1}^{\\ell}X_{i}^{\\bar{d}_{i}}=0</span>, which means that all coefficients of <span class="math">f(x)\\cdot\\prod_{i=1}^{\\ell}X_{i}^{\\bar{d}_{i}}</span> are zeros, so that <span class="math">f(X)=0</span>.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">C Proof of Theorem 1</h3>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">(perfect completeness) We show that the WIP argument has perfect completeness. First, we assume that <span class="math">P=\\bm{g^{a}h^{b}}g^{a\\odot_{y}b}h^{\\alpha}</span> and show that the case <span class="math">n=1</span> satisfies the perfect completeness. That is, we show that the verification equation holds. It is sufficient to show that the corresponding four equations with bases <span class="math">\\bm{g},\\bm{h},g,h</span>, respectively, are holds.</p>

    <p class="text-gray-300"><span class="math">\\bm{a}e^{2}+re</span> <span class="math">=(\\bm{a}e+r)e=r^{\\prime}e\\in\\mathbb{Z}_{p}</span> <span class="math">\\bm{b}e^{2}+se</span> <span class="math">=(\\bm{b}e+s)e=s^{\\prime}e\\in\\mathbb{Z}_{p}</span> <span class="math">ay\\bm{b}e^{2}+(ry\\bm{b}+sy\\bm{a})e+rys</span> <span class="math">=(\\bm{b}e+s)(\\bm{a}ye+ry)=r^{\\prime}\\odot_{y}s^{\\prime}\\in\\mathbb{Z}_{p}</span> <span class="math">\\alpha e^{2}+\\delta e+\\eta</span> <span class="math">=\\delta^{\\prime}\\in\\mathbb{Z}_{p}</span></p>

    <p class="text-gray-300">From the above four equalities, the perfect completeness for the case <span class="math">n=1</span> is proven.</p>

    <p class="text-gray-300">Next, we move to the case <span class="math">n&gt;1</span>. For every end of recursive step, if the parameters <span class="math">(\\widehat{\\bm{g}},\\widehat{\\bm{h}},g,h,\\widehat{P};\\widehat{\\bm{a}},\\widehat{\\bm{b}},\\widehat{\\alpha})</span> that will be used for the next call satisfy the relation <span class="math">\\widehat{P}=\\widehat{\\bm{g}}^{\\widehat{\\bm{a}}}\\widehat{\\bm{h}}^{\\widehat{\\bm{b}}}g^{\\widehat{\\bm{a}}\\odot_{y}\\widehat{\\bm{b}}}h^{\\widehat{\\alpha}}</span></p>

    <p class="text-gray-300">when <span class="math">P = \\mathbf{g}^{\\mathbf{a}}\\mathbf{h}^{\\mathbf{b}}g^{\\mathbf{a}\\odot y\\mathbf{b}}h^{\\alpha}</span> then we can be sure that the protocol will drive to end up with a correct input for the last step of <span class="math">n = 1</span>. Therefore we show that if the input <span class="math">P</span> is of the form <span class="math">\\mathbf{g}^{\\mathbf{a}}\\mathbf{h}^{\\mathbf{b}}g^{\\mathbf{a}\\odot y\\mathbf{b}}h^{\\alpha}</span> and <span class="math">\\widehat{P},\\widehat{\\mathbf{g}},\\widehat{\\mathbf{h}},\\widehat{\\mathbf{a}},\\widehat{\\mathbf{b}}</span> are computed as the protocol, then <span class="math">\\widehat{P}</span> has the desired form <span class="math">\\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{a}}}\\widehat{\\mathbf{h}}^{\\widehat{\\mathbf{b}}}g^{\\widehat{\\mathbf{a}}\\odot y\\widehat{\\mathbf{b}}}h^{\\widehat{\\alpha}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">P, \\widehat{P}, \\widehat{\\mathbf{g}}, \\widehat{\\mathbf{h}}, \\widehat{\\mathbf{a}}, \\widehat{\\mathbf{b}}</span> be the form in the protocol description for the case <span class="math">n &amp;gt; 1</span>. If <span class="math">L</span> and <span class="math">R</span> are computed as the description of the protocol, then <span class="math">\\widehat{P}</span> is computed by <span class="math">\\widehat{P} = L^{e^2}PR^{e^{-2}}</span> and we can write <span class="math">\\widehat{P}</span> according to the corresponding bases.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{a}_1 + y^{\\widehat{n}} \\mathbf{a}_2 e^{-\\frac{\\alpha}{2}} (\\mathbf{a}_1 e + y^{\\widehat{n}} \\mathbf{a}_2 e^{-1}) e^{-1} = \\widehat{\\mathbf{a}} e^{-1} \\in \\mathbb{Z}_p \\\\ y^{-\\widehat{n}} \\mathbf{a}_1 e^2 + \\mathbf{a}_{\\overline{\\mathcal{F}}} (\\mathbf{a}_1 e + y^{\\widehat{n}} \\mathbf{a}_2 e^{-1}) e y^{-\\widehat{n}} = \\widehat{\\mathbf{a}} e y^{-\\widehat{n}} \\in \\mathbb{Z}_p \\\\ \\mathbf{b}_2 e^2 + \\mathbf{b}_{\\mathrm{F}} (\\mathbf{b}_2 e + \\mathbf{b}_1 e^{-1}) e = \\widehat{\\mathbf{b}} e \\in \\mathbb{Z}_p \\\\ \\mathbf{b}_2 + \\mathbf{b}_1 e^{-\\frac{\\alpha}{2}} (\\mathbf{b}_2 e + \\mathbf{b}_1 e^{-1}) e^{-1} = \\widehat{\\mathbf{b}} e^{-1} \\in \\mathbb{Z}_p \\\\ c_L e^2 + \\mathbf{a} \\odot_y \\mathbf{b} + c_R e^{-\\frac{1}{2}} \\mathbf{a}_1 \\odot_y \\mathbf{b}_2 e^2 + \\mathbf{a} \\odot_y \\mathbf{b} + y^{\\widehat{n}} \\mathbf{a}_2 \\odot_y \\mathbf{b}_1 e^{-2} \\in \\mathbb{Z}_p \\\\ d_L e^2 + \\alpha + d_R e^{-\\frac{2}{2}} \\widehat{\\alpha} \\in \\mathbb{Z}_p \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Furthermore, from the definition of <span class="math">\\widehat{\\mathbf{a}}</span> and <span class="math">\\widehat{\\mathbf{b}}</span>, we see that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat{\\mathbf{a}} \\odot_y \\widehat{\\mathbf{b}} \\\\ = (\\mathbf{a}_1 e + (\\mathbf{a}_2 y^{\\widehat{n}}) e^{-1}) \\odot_y (\\mathbf{b} e_{-1} + \\mathbf{b}_2 e) \\\\ = \\mathbf{a}_1 \\odot_y \\mathbf{b}_1 + \\mathbf{a}_1 \\odot_y \\mathbf{b}_2 e^2 + (y^{\\widehat{n}} \\mathbf{a}_2) \\odot_y \\mathbf{b}_1 e^{-2} + (y^{\\widehat{n}} \\mathbf{a}_2) \\odot_y \\mathbf{b}_2 \\\\ = \\mathbf{a}_1 \\odot_y \\mathbf{b}_2 e^2 + \\mathbf{a} \\odot_y \\mathbf{b} + (y^{\\widehat{n}} \\mathbf{a}_2) \\odot_y \\mathbf{b}_1 e^{-2} \\in \\mathbb{Z}_p, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">which is equal to the <span class="math">g</span>-base exponent of <span class="math">\\widehat{P}</span>. Using the above observation, we can easily check that the following holds.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat{P} = \\mathbf{g}_1^{\\widehat{\\mathbf{a}} e^{-1}} \\mathbf{g}_2^{\\widehat{\\mathbf{a}} e y^{-\\widehat{n}}} \\mathbf{h}_1^{\\widehat{\\mathbf{b}} e} \\mathbf{h}_2^{\\widehat{\\mathbf{b}} e^{-1}} g^{\\widehat{\\mathbf{a}} \\odot y \\widehat{\\mathbf{b}}} h^{\\widehat{\\alpha}} \\\\ = \\left(\\mathbf{g}_1^{e^{-1}} \\mathbf{g}_2^{e y^{-\\widehat{n}}}\\right)^{\\widehat{\\mathbf{a}}} \\left(\\mathbf{h}_1^{e} \\mathbf{h}_2^{e^{-1}}\\right)^{\\widehat{\\mathbf{b}}} g^{\\widehat{\\mathbf{a}} \\odot y \\widehat{\\mathbf{b}}} h^{\\widehat{\\alpha}} \\\\ = \\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{a}}} \\widehat{\\mathbf{h}}^{\\widehat{\\mathbf{b}}} g^{\\widehat{\\mathbf{a}} \\odot y \\widehat{\\mathbf{b}}} h^{\\widehat{\\alpha}} \\in \\mathbb{G} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This completes the proof of the perfect completeness.</p>

    <p class="text-gray-300">(perfect SHVZK) To prove the argument system is perfect special honest verifier zero-knowledge, we construct a simulator, given only the public input, it outputs a simulated transcript that is identical to the valid transcript produced by the prover and verifier in the real interaction.</p>

    <p class="text-gray-300">We first describe our simulator construction, and then analyze it. The simulator begins with taking the statement and the randomness <span class="math">\\rho</span> of the verifier as input. Using <span class="math">\\rho</span>, the simulator can generate all challenges whose distribution is identical to that of the real argument. We describe how the simulator generates a non-challenge part. For each <span class="math">n &amp;gt; 1</span>, the simulator chooses two random group elements and set those <span class="math">L_{n}, R_{n}</span>. For the case of <span class="math">n = 1</span>, the simulator chooses <span class="math">A_{s} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> and <span class="math">r_{s}&#x27;, s_{s}&#x27;, \\delta_{s}&#x27; \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_{p}</span> at random and computes</p>

    <div class="my-4 text-center"><span class="math-block">B_s = \\left(P^{e^2} A^e \\mathbf{g}^{-r_s&#x27; \\cdot e} \\mathbf{h}^{-s_s&#x27; \\cdot e} g^{-r_s&#x27; \\odot_y s_s&#x27;} h^{-\\delta_s&#x27;}\\right)^{-1} \\in \\mathbb{G}.</span></div>

    <p class="text-gray-300">Next, we analyze the distribution of the simulated transcript for the non-challenge part <span class="math">\\left(\\{(L_i,R_i)\\}_i,A_s,B_s,r_s&#x27;,s_s&#x27;,\\delta_s&#x27;\\right)</span>. In the protocol description, <span class="math">\\forall i</span>, <span class="math">(L_i,R_i)</span> distributes uniformly and independently due to blinding factors <span class="math">d_{L_i}</span> and <span class="math">d_{R_i}</span> and all <span class="math">(L_i,R_i)</span>'s contribute to generate <span class="math">P</span> used in the case <span class="math">n = 1</span>. The simulator generates uniformly <span class="math">(L_i,R_i)</span>'s at random, so that its'</p>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">distribution is identical to that of the real argument. From now, we analyze the distribution of  <span class="math">(A_s, B_s, r_s&#x27;, s_s&#x27;, \\delta_s&#x27;)</span>  for given  <span class="math">P</span>  in the case  <span class="math">n = 1</span> .</p>

    <p class="text-gray-300">Before analyzing the simulated transcript  <span class="math">(A_s, B_s, r_s&#x27;, s_s&#x27;, \\delta_s&#x27;)</span> , we first analyze the real transcript  <span class="math">(A, B, r&#x27;, s&#x27;, \\delta&#x27;)</span>  and then show two distributions are identical. For the sake of simplicity, we consider the non-challenge part of the transcript in the case  <span class="math">n = 1</span>  as a vector in  <span class="math">\\mathbb{Z}_p^5</span>  instead of  <span class="math">\\mathbb{G}^2 \\times \\mathbb{Z}_p^3</span> , by taking discrete logarithms with base  <span class="math">h</span>  for elements in the cyclic group  <span class="math">\\mathbb{G}</span>  of prime order. It does not mean we can find discrete logarithms, but we just analyze the distributions of group elements in the transcript. Let  <span class="math">\\zeta_g = \\log_h g</span> ,  <span class="math">\\zeta_h = \\log_h h</span> , and  <span class="math">\\zeta_g = \\log_h g</span> . Then, the non-challenge part in the real argument is as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c} \\log_ {h} A = \\big (r \\zeta_ {\\boldsymbol {g}} + s \\zeta_ {\\boldsymbol {h}} + (r \\odot_ {y} \\boldsymbol {b} + s \\odot_ {y} \\boldsymbol {a}) \\zeta_ {g} + \\delta \\big), \\\\ \\log_ {h} B = &amp;amp; (r \\odot_ {y} s) \\zeta_ {g} + \\eta , \\\\ r ^ {\\prime} = &amp;amp; r + \\boldsymbol {a} \\cdot e, \\\\ s ^ {\\prime} = &amp;amp; s + \\boldsymbol {b} \\cdot e, \\\\ \\delta^ {\\prime} = &amp;amp; \\eta + \\delta \\cdot e + \\alpha \\cdot e ^ {2}, \\end{array} \\right) \\in \\mathbb {Z} _ {p} ^ {5},</span></div>

    <p class="text-gray-300">where  <span class="math">r, s, \\delta, \\eta \\in \\mathbb{Z}_p</span>  are chosen at random by the real prover, and  <span class="math">\\pmb{a}, \\pmb{b}, \\alpha</span>  are witnesses of given  <span class="math">P</span>  in the case  <span class="math">n = 1</span> . Here, we focus on  <span class="math">(\\log_h A, r&#x27;, s&#x27;, \\delta&#x27;)</span>  and claim that it is uniformly distributed in  <span class="math">\\mathbb{Z}_p^4</span>  when  <span class="math">(r, s, \\delta, \\eta)</span>  is uniformly distributed in  <span class="math">\\mathbb{Z}_p^4</span> . To this end, it is sufficient to prove the following claim.</p>

    <p class="text-gray-300">Claim. There exists a one-to-one correspondence between  <span class="math">(r,s,\\delta ,\\eta)</span>  and  <span class="math">(\\log_hA,r&#x27;,s&#x27;,\\delta &#x27;)</span> . Proof. First, consider the following function mapping from  <span class="math">(r,s,\\delta ,\\eta)</span>  to  <span class="math">(\\log_hA,r&#x27;,s&#x27;,\\delta &#x27;)</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left( \\begin{array}{c c c} \\zeta_ {\\boldsymbol {g}} &amp;amp; \\zeta_ {\\boldsymbol {h}} &amp;amp; 1 0 \\\\ 1 &amp;amp; 0 &amp;amp; 0 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 0 \\\\ 0 &amp;amp; 0 &amp;amp; e 1 \\end{array} \\right) \\left( \\begin{array}{c} r \\\\ s \\\\ \\delta \\\\ \\eta \\end{array} \\right) + \\left( \\begin{array}{c} (r \\odot_ {y} \\boldsymbol {b} + s \\odot_ {y} \\boldsymbol {a}) \\zeta_ {g} \\\\ \\boldsymbol {a} \\cdot e \\\\ \\boldsymbol {b} \\cdot e \\\\ \\alpha \\cdot e ^ {2} \\end{array} \\right) \\\\ = \\left( \\begin{array}{c} r \\zeta_ {\\boldsymbol {g}} + s \\zeta_ {\\boldsymbol {h}} + (r \\odot_ {y} \\boldsymbol {b} + s \\odot_ {y} \\boldsymbol {a}) \\zeta_ {g} + \\delta \\\\ r + \\boldsymbol {a} \\cdot e \\\\ s + \\boldsymbol {b} \\cdot e \\\\ \\eta + \\delta \\cdot e + \\alpha \\cdot e ^ {2} \\end{array} \\right) = \\left( \\begin{array}{c} \\log_ {h} A \\\\ r ^ {\\prime} \\\\ s ^ {\\prime} \\\\ \\delta^ {\\prime} \\end{array} \\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Assume that we have another tuple  <span class="math">(\\tilde{r},\\tilde{s},\\tilde{\\delta},\\tilde{\\eta})</span>  whose image via the above function is also  <span class="math">(\\log_hA,r&#x27;,s&#x27;,\\delta &#x27;)</span> . Then, subtracting two function values we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left( \\begin{array}{c} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{array} \\right) = \\left( \\begin{array}{c c c} \\zeta_ {\\boldsymbol {g}} &amp;amp; \\zeta_ {\\boldsymbol {h}} &amp;amp; 1   0 \\\\ 1 &amp;amp; 0 &amp;amp; 0   0 \\\\ 0 &amp;amp; 1 &amp;amp; 0   0 \\\\ 0 &amp;amp; 0 &amp;amp; e   1 \\end{array} \\right) \\left( \\begin{array}{c} r - \\tilde {r} \\\\ s - \\tilde {s} \\\\ \\delta - \\tilde {\\delta} \\\\ \\eta - \\tilde {\\eta} \\end{array} \\right) \\\\ + \\left( \\begin{array}{c} (r \\odot_ {y} \\boldsymbol {b} + s \\odot_ {y} \\boldsymbol {a} - \\tilde {r} \\odot_ {y} \\boldsymbol {b} - \\tilde {s} \\odot_ {y} \\boldsymbol {a}) \\zeta_ {g} \\\\ 0 \\\\ 0 \\\\ 0 \\end{array} \\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">From two intermediate rows, we have  <span class="math">r - \\tilde{r} = 0</span>  and  <span class="math">s - \\tilde{s} = 0</span> , and then putting those two equalities into the above equation again, we obtain  <span class="math">\\delta - \\tilde{\\delta} = 0</span>  and  <span class="math">\\eta - \\tilde{\\eta} = 0</span> . This completes the one-to-one correspondence and so does the proof of the claim.</p>

    <p class="text-gray-300">In the generation of the real transcript  <span class="math">(\\log_h A, \\log_h B, r&#x27;, s&#x27;, \\delta&#x27;)</span> , only four random integer  <span class="math">r, s, \\delta</span> , and  <span class="math">\\eta</span>  are used. Therefore, the above result implies that the distribution of  <span class="math">(\\log_h A, \\log_h B, r&#x27;, s&#x27;, \\delta&#x27;)</span>  is identical to the distribution that  <span class="math">(\\log_h A, r&#x27;, s&#x27;, \\delta&#x27;)</span>  is uniformly distributed and  <span class="math">\\log_h B</span>  is</p>

    <p class="text-gray-300">uniquely defined by the others and the verification equation. In fact, the latter process is exactly same as the simulated transcript. Therefore, the simulated transcript is identical to that of the real transcript for given <span class="math">P</span> in the case <span class="math">n = 1</span>. Overall, we complete the proof of the perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">(witness-extended emulation) For witness extended emulation, we construct an expected polynomial time extractor <span class="math">\\chi</span> that extracts a witness using a <span class="math">poly(\\lambda)</span>-bounded tree of accepting transcripts, so that to meet the requirements of the general forking lemma. Consider the case <span class="math">n = 1</span>. At the first move, the prover sends <span class="math">A</span> and <span class="math">B</span> to verifier. By rewinding the oracle <span class="math">\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle</span> four times with five distinct challenges <span class="math">e_1, e_2, e_3, e_4</span>, and <span class="math">e_5</span> while using the same <span class="math">A</span> and <span class="math">B</span>, the extractor obtains five tuples <span class="math">(r_i&#x27;, s_i&#x27;, \\delta_i&#x27;)</span> satisfying the following verification equation.</p>

    <div class="my-4 text-center"><span class="math-block">P ^ {e _ {i} ^ {2}} A ^ {e _ {i}} B = \\boldsymbol {g} ^ {r _ {i} ^ {\\prime} \\cdot e _ {i}} \\boldsymbol {h} ^ {s _ {i} ^ {\\prime} \\cdot e _ {i}} g ^ {r _ {i} ^ {\\prime} \\odot_ {y} s _ {i} ^ {\\prime}} h ^ {\\delta_ {i} ^ {\\prime}} \\quad \\text{for } i = 1, \\dots , 4 \\tag {20}</span></div>

    <p class="text-gray-300">Using the first three challenges and the corresponding valid responses, we can interpret the exponents as a product of <span class="math">3 \\times 3</span> matrix with each row vectors <span class="math">(e_i^2, e_i, 1)</span> for <span class="math">i = 1, 2, 3</span> and are the Vandermonde matrix that is invertible in <span class="math">\\mathbb{Z}_p^{3 \\times 3}</span> since <span class="math">e_i</span>'s are distinct. The other exponents in the right hand side of Eq. (20) are public as well. Thus, from those three challenges and responses, we can obtain the exponents <span class="math">a_P, b_P, c_P, d_P, a_A, b_A, c_A, d_A, a_B, b_B, c_B, d_B</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">P = \\boldsymbol {g} ^ {a _ {P}} \\boldsymbol {h} ^ {b _ {P}} g ^ {c _ {P}} h ^ {d _ {P}},</span></div>

    <div class="my-4 text-center"><span class="math-block">A = \\boldsymbol {g} ^ {a _ {A}} \\boldsymbol {h} ^ {b _ {A}} g ^ {c _ {A}} h ^ {d _ {A}},</span></div>

    <div class="my-4 text-center"><span class="math-block">B = \\boldsymbol {g} ^ {a _ {B}} \\boldsymbol {h} ^ {b _ {B}} g ^ {c _ {B}} h ^ {d _ {B}}.</span></div>

    <p class="text-gray-300">Using the above three equations and the verification equation, we obtain for each <span class="math">e_i \\in \\{e_1, e_2, e_3, e_4, e_5\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {g} ^ {r _ {i} ^ {\\prime} e _ {i} - a _ {P} e _ {i} ^ {2} - a _ {A} e _ {i} - a _ {B}} \\boldsymbol {h} ^ {s _ {i} ^ {\\prime} e _ {i} - b _ {P} e _ {i} ^ {2} - b _ {A} e _ {i} - b _ {B}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cdot g ^ {r _ {i} ^ {\\prime} \\odot_ {y} s _ {i} ^ {\\prime} - c _ {P} e _ {i} ^ {2} - c _ {A} e _ {i} - c _ {B}} h ^ {\\delta_ {i} ^ {\\prime} - d _ {P} e _ {i} ^ {2} - d _ {A} e _ {i} - d _ {B}} = 1 _ {\\mathbb {G}}.</span></div>

    <p class="text-gray-300">Thus, under the discrete logarithm relation assumption, we have four equations of exponents according to the bases <span class="math">\\pmb{g}, \\pmb{h}, g, h</span>,</p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} ^ {\\prime} e _ {i} - a _ {P} e _ {i} ^ {2} - a _ {A} e _ {i} - a _ {B} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">s _ {i} ^ {\\prime} e _ {i} - b _ {P} e _ {i} ^ {2} - b _ {A} e _ {i} - b _ {B} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {i} ^ {\\prime} \\odot_ {y} s _ {i} ^ {\\prime} - c _ {P} e _ {i} ^ {2} - c _ {A} e _ {i} - c _ {B} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {i} ^ {\\prime} - d _ {P} e _ {i} ^ {2} - d _ {A} e _ {i} - d _ {B} = 0</span></div>

    <p class="text-gray-300">and, equivalently,</p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} ^ {\\prime} = a _ {P} e _ {i} + a _ {A} + a _ {B} e _ {i} ^ {- 1} \\tag {21}</span></div>

    <div class="my-4 text-center"><span class="math-block">s _ {i} ^ {\\prime} = b _ {P} e _ {i} + b _ {A} + b _ {B} e _ {i} ^ {- 1} \\tag {22}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {i} ^ {\\prime} \\odot_ {y} s _ {i} ^ {\\prime} = c _ {P} e _ {i} ^ {2} + c _ {A} e _ {i} + c _ {B} \\tag {23}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {i} ^ {\\prime} = d _ {P} e _ {i} ^ {2} + d _ {A} e _ {i} + d _ {B}.</span></div>

    <p class="text-gray-300">By eliminating <span class="math">r_i&#x27;</span> and <span class="math">s_i&#x27;</span> from Eq. (21), Eq. (22), and Eq. (23), we have for <span class="math">i \\in \\{1, \\dots, 5\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">a _ {P} \\odot_ {y} b _ {P} \\cdot e _ {i} ^ {2} + \\left(a _ {P} \\odot_ {y} b _ {A} + b _ {P} \\odot_ {y} a _ {A}\\right) \\cdot e _ {i}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left(a _ {P} \\odot_ {y} b _ {B} + b _ {P} \\odot_ {y} a _ {B} + a _ {A} \\odot_ {y} b _ {A}\\right) + \\left(a _ {A} \\odot_ {y} b _ {B} + b _ {A} \\odot_ {y} a _ {B}\\right) e _ {i} ^ {- 1}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a _ {B} \\odot_ {y} b _ {B} \\cdot e _ {i} ^ {- 2}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\gg e _ {P} e _ {i} ^ {2} + c _ {A} e _ {i} + c _ {B} \\in \\mathbb {Z} _ {p} \\tag {24}</span></div>

    <p class="text-gray-300">This equation can be considered as an inner-product with <span class="math">(e_{i}^{2},e_{i},1,e_{i}^{-1},e_{i}^{-2})</span> and constants vector. Since Eq. (24) holds for all five distinct challenges <span class="math">e_{i}\\in\\{e_{1},\\ldots,e_{5}\\}</span> and so <span class="math">(e_{i}^{2},e_{i},1,e_{i}^{-1},e_{i}^{-2})</span>’s are linearly independent, each coefficient in the left hand side of Eq. (24) must be equal to the corresponding coefficient in the right hand side of Eq. (24). As we intended, the extractor either extracts a witness <span class="math">(a_{P},b_{P})</span> satisfying <span class="math">a_{P}\\odot_{y}b_{P}=c_{P}</span>, or a discrete logarithm relation between the generators.</p>

    <p class="text-gray-300">Next, we move to the case <span class="math">n&gt;1</span>. We prove the case <span class="math">n&gt;1</span> recursively. That is, we construct an extractor <span class="math">\\chi_{2k}</span> for the case <span class="math">n=2k</span> using an extractor <span class="math">\\chi_{k}</span> and let <span class="math">\\chi_{1}</span> be the extractor <span class="math">\\chi</span> we constructed for the case <span class="math">n=1</span>. We start with input <span class="math">(\\bm{g},\\bm{h},g,h,P)</span> for the case <span class="math">n=2k</span>. Assume that we have the extractor <span class="math">\\chi_{k}</span> for the case <span class="math">n=k</span>. The extractor <span class="math">\\chi_{2k}</span> runs the prover to get <span class="math">L</span> and <span class="math">R</span>. At this point, the extractor <span class="math">\\chi_{2k}</span> rewinds the oracle four times, uses four distinct challenges <span class="math">e_{i}</span> for <span class="math">i=1,\\ldots,4</span>, and sets</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\bm{g}}_{i}=\\bm{g}_{1}^{e_{i}^{-1}}\\circ\\bm{g}_{2}^{e_{i}\\cdot y^{-k}},\\;\\widehat{\\bm{h}}_{i}=\\bm{h}_{1}^{e_{i}}\\circ\\bm{h}_{2}^{e^{-1}},\\;\\widehat{P}_{i}=L^{e_{i}^{2}}PR^{e_{i}^{-2}}\\in\\mathbb{G}\\text{ for }i=1,\\ldots,4.</span></p>

    <p class="text-gray-300">Then, for each <span class="math">i</span>, it feeds <span class="math">(\\widehat{\\bm{g}}_{i},\\widehat{\\bm{h}}_{i},g,h,\\widehat{P}_{i})</span> to <span class="math">\\chi_{k}</span> and obtain the corresponding witness <span class="math">\\widehat{\\bm{a}}_{i},\\widehat{\\bm{b}}_{i}</span> and <span class="math">\\widehat{\\alpha}</span> that satisfy</p>

    <p class="text-gray-300"><span class="math">L^{e_{i}^{2}}PR^{e_{i}^{-2}}</span> (25) <span class="math">=\\left(\\bm{g}_{1}^{e_{i}^{-1}}\\circ\\bm{g}_{2}^{e_{i}\\cdot y^{-k}}\\right)^{\\widehat{\\bm{a}}_{i}}\\left(\\bm{h}_{1}^{e_{i}}\\circ\\bm{h}_{2}^{e_{i}^{-1}}\\right)^{\\widehat{\\bm{b}}_{i}}g^{\\widehat{\\bm{a}}_{i}\\odot_{y}\\widehat{\\bm{b}}_{i}}h^{\\widehat{\\alpha}_{i}},\\;i\\in[1,4]</span></p>

    <p class="text-gray-300">For the first three challenges <span class="math">e_{1},e_{2},e_{3}</span>, <span class="math">(e_{i}^{2},1,e_{i}^{-2})</span>’s are linearly independent and so compose of a <span class="math">3\\times 3</span> invertible matrix in <span class="math">\\mathbb{Z}_{p}^{3\\times 3}</span>. We can see that all exponents are constants known to the extractor. Thus, by applying the elementary linear algebra in the public exponent of the first three equations of Eq. (25), we can find the exponents <span class="math">\\bm{a}_{P},\\bm{b}_{P},c_{P},d_{P}</span>, <span class="math">\\bm{a}_{L},\\bm{b}_{L},c_{L},d_{L}</span>, <span class="math">\\bm{a}_{R},\\bm{b}_{R},c_{R},d_{R}</span> satisfying</p>

    <p class="text-gray-300"><span class="math">P=</span> <span class="math">\\bm{g^{a}}_{P}\\bm{h^{b}}_{P}g^{c_{P}}h^{d_{P}}\\in\\mathbb{G},</span> <span class="math">L=</span> <span class="math">\\bm{g^{a}}_{L}\\bm{h^{b}}_{L}g^{c_{L}}h^{d_{L}}\\in\\mathbb{G},</span> <span class="math">R=</span> <span class="math">\\bm{g^{a}}_{R}\\bm{h^{b}}_{R}g^{c_{R}}h^{d_{R}}\\in\\mathbb{G}.</span></p>

    <p class="text-gray-300">From now, we prove that those exponents satisfy the desired relation <span class="math">c_{P}=\\bm{a}_{P}\\odot_{y}\\bm{b}_{P}</span>. Putting the above representations of <span class="math">P,L,R</span> into Eq. (25) for each <span class="math">i</span>, we have the following equations with bases <span class="math">\\bm{g},\\bm{h},g,h</span> under the discrete logarithm relation assumption.</p>

    <p class="text-gray-300"><span class="math">\\bm{g^{a}}_{L}e_{i}^{2}\\bm{g^{a}}_{P}\\bm{g^{a}}_{R}e_{i}^{-2}</span> <span class="math">=\\left(\\bm{g}_{1}^{e_{i}^{-1}}\\circ\\bm{g}_{2}^{e_{i}\\cdot y^{-k}}\\right)^{\\widehat{\\bm{a}}_{i}}</span> (26) <span class="math">\\bm{h^{b}}_{L}e_{i}^{2}\\bm{h^{b}}_{P}\\bm{h^{b}}_{R}e_{i}^{-2}</span> <span class="math">=\\left(\\bm{h}_{1}^{e_{i}}\\circ\\bm{h}_{2}^{e_{i}^{-1}}\\right)^{\\widehat{\\bm{b}}_{i}}</span> (27) <span class="math">g^{c_{L}e_{i}^{2}}g^{c_{P}}g^{c_{R}e_{i}^{-2}}</span> <span class="math">=g^{\\widehat{\\bm{a}}_{i}\\odot_{y}\\widehat{\\bm{b}}_{i}}</span> (28) <span class="math">h^{d_{L}e_{i}^{2}}h^{d_{P}}h^{d_{R}e_{i}^{-2}}</span> <span class="math">=h^{\\widehat{\\alpha}_{i}}</span></p>

    <p class="text-gray-300">That is, Eq. (25) is separated into the above four equations according to the bases <span class="math">\\bm{g},\\bm{h},g,h</span>. If we find exponents satisfying Eq. (25) but not the above four equations, it directly implies a non-trivial relation between the generators and so break the discrete logarithm assumption. We use the above four equations to prove <span class="math">\\bm{a}_{P}\\odot_{y}\\bm{b}_{P}=c_{P}</span>. To this end, we first find a relation between <span class="math">\\widehat{\\bm{a}}_{i}</span> and <span class="math">\\bm{a}_{P}</span> from Eq. (26), second find another relation between <span class="math">\\widehat{\\bm{b}}_{i}</span> and <span class="math">\\bm{b}_{P}</span> from Eq. (27), and then finally use Eq. (28) containing <span class="math">c_{P}</span>, <span class="math">\\widehat{\\bm{a}}_{i}</span>, <span class="math">\\widehat{\\bm{b}}_{i}</span> variables in order to show the desired relation between <span class="math">c_{P}</span>, <span class="math">\\bm{a}_{P}</span>, and <span class="math">\\bm{b}_{P}</span>.</p>

    <p class="text-gray-300">First, we show that relation between <span class="math">\\widehat{\\bm{a}}_{i}</span> and <span class="math">\\bm{a}_{P}</span> from Eq. (26). By the discrete logarithm assumption, it is infeasible to find relation between <span class="math">\\bm{g}_{1}</span> and <span class="math">\\bm{g}_{2}</span>, so that Eq. (26) induces two</p>

    <p class="text-gray-300">quations with the base <span class="math">\\bm{g}_{1}</span> and <span class="math">\\bm{g}_{2}</span>, which are equivalent to the following equations.</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{L,1}e_{i}^{2}+\\bm{a}_{P,1}+\\bm{a}_{R,1}e_{i}^{-2}=e_{i}^{-1}\\widehat{\\bm{a}}_{i}</span> <span class="math">\\bm{a}_{L,2}e_{i}^{2}+\\bm{a}_{P,2}+\\bm{a}_{R,2}e_{i}^{-2}=y^{-k}e_{i}\\widehat{\\bm{a}}_{i},</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{a}_{P}=(\\bm{a}_{P,1},\\bm{a}_{P,2}),\\bm{a}_{L}=(\\bm{a}_{L,1},\\bm{a}_{L,2}),\\bm{a}_{R}=(\\bm{a}_{R,1},\\bm{a}_{R,2})\\in\\mathbb{Z}_{p}^{k}\\times\\mathbb{Z}_{p}^{k}</span>. By eliminating <span class="math">\\widehat{\\bm{a}}_{i}</span> from the above two equations, we obtain</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{L,1}e_{i}^{3}+\\bm{a}_{P,1}e_{i}+\\bm{a}_{R,1}e_{i}^{-1}=\\bm{a}_{L,2}y^{k}e_{i}+\\bm{a}_{P,2}y^{k}e_{i}^{-1}+\\bm{a}_{R,2}y^{k}e_{i}^{-3}</span> (29)</p>

    <p class="text-gray-300">Eq. (29) holds for all four challenges <span class="math">e_{1},\\ldots,e_{4}</span> and there are four variable terms <span class="math">e_{i},e_{i}^{3},e_{i}^{-1},e_{i}^{-3}</span>. This implies that the following must holds.</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{L,1}=0\\in\\mathbb{Z}_{p}^{k},</span> <span class="math">\\bm{a}_{P,1}=\\bm{a}_{L,2}y^{k}\\in\\mathbb{Z}_{p}^{k},</span> <span class="math">\\bm{a}_{R,1}=\\bm{a}_{P,2}y^{k}\\in\\mathbb{Z}_{p}^{k},</span> <span class="math">\\bm{a}_{R,2}=0\\in\\mathbb{Z}_{p}^{k}.</span></p>

    <p class="text-gray-300">Using the above result with Eq. (26), we obtain that the exponent of the base <span class="math">\\bm{g}_{1}</span> in Eq. (26) is</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{P,1}+\\bm{a}_{P,2}y^{k}e_{i}^{-2}=e_{i}^{-1}\\widehat{\\bm{a}}_{i},</span></p>

    <p class="text-gray-300">so that we have a relation between <span class="math">\\widehat{\\bm{a}}_{i}</span> and <span class="math">\\bm{a}_{P}</span>,</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\bm{a}}_{i}=\\bm{a}_{P,1}e_{i}+\\bm{a}_{P,2}y^{k}e_{i}^{-1}.</span> (30)</p>

    <p class="text-gray-300">Second, we show that relation between <span class="math">\\widehat{\\bm{b}}_{i}</span> and <span class="math">\\bm{b}_{P}</span> from Eq. (27). Under the discrete logarithm assumption, we extract the exponent of the base <span class="math">\\bm{h}_{1}</span> and <span class="math">\\bm{h}_{2}</span> from Eq. (27).</p>

    <p class="text-gray-300"><span class="math">\\bm{b}_{L,1}e_{i}^{2}+\\bm{b}_{P,1}+\\bm{b}_{R,1}e_{i}^{-2}=e_{i}\\widehat{\\bm{b}}_{i}</span> <span class="math">\\bm{b}_{L,2}e_{i}^{2}+\\bm{b}_{P,2}+\\bm{b}_{R,2}e_{i}^{-2}=e_{i}^{-1}\\widehat{\\bm{b}}_{i}</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{b}_{P}=(\\bm{b}_{P,1},\\bm{b}_{P,2}),\\bm{b}_{L}=(\\bm{b}_{L,1},\\bm{b}_{L,2}),\\bm{b}_{R}=(\\bm{b}_{R,1},\\bm{b}_{R,2})\\in\\mathbb{Z}_{p}^{k}\\times\\mathbb{Z}_{p}^{k}</span>. By eliminating <span class="math">\\widehat{\\bm{b}}_{i}</span> from the above two equations, we obtain</p>

    <p class="text-gray-300"><span class="math">\\bm{b}_{L,1}\\cdot e_{i}+\\bm{b}_{P,1}\\cdot e_{i}^{-1}+\\bm{b}_{R,1}.e_{i}^{-3}=\\bm{b}_{L,2}y^{k}\\cdot e_{i}^{3}+\\bm{b}_{P,2}\\cdot e_{i}+\\bm{b}_{R,2}\\cdot e_{i}^{-1}</span> (31)</p>

    <p class="text-gray-300">Eq. (31) holds for all four challenges <span class="math">e_{1},\\ldots,e_{4}</span> and there are four variable terms <span class="math">e_{i},e_{i}^{3},e_{i}^{-1},e_{i}^{-3}</span>. This implies that the following must holds.</p>

    <p class="text-gray-300"><span class="math">\\bm{b}_{L,1}=\\bm{b}_{P,2}\\in\\mathbb{Z}_{p}^{k},</span> <span class="math">\\bm{b}_{P,1}=\\bm{b}_{R,2}\\in\\mathbb{Z}_{p}^{k},</span> <span class="math">\\bm{b}_{R,1}=0\\in\\mathbb{Z}_{p}^{k},</span> <span class="math">\\bm{b}_{L,2}=0\\in\\mathbb{Z}_{p}^{k}</span></p>

    <p class="text-gray-300">Using the above result with Eq. (27), we obtain that the exponent of the base <span class="math">\\bm{h}_{1}</span> in Eq. (27) is</p>

    <p class="text-gray-300"><span class="math">\\bm{b}_{P,2}e_{i}^{2}+\\bm{b}_{P,1}=e_{i}\\widehat{\\bm{b}}_{i},</span></p>

    <p class="text-gray-300">so that we have a relation between <span class="math">\\widehat{\\bm{b}}_{i}</span> and <span class="math">\\bm{b}_{P}</span>,</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\bm{b}}_{i}=\\bm{b}_{P,2}e_{i}+\\bm{b}_{P,1}e_{i}^{-1}</span> (32)</p>

    <p class="text-gray-300">Finally, we use Eq. (28) in order to show relation between <span class="math">c_{P}</span>, <span class="math">\\pmb{a}_{P}</span>, and <span class="math">\\pmb{b}_{P}</span>. Taking the WIP <span class="math">\\odot_{y}</span> on Eq. (30) and Eq. (32), we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\widehat {\\boldsymbol {a}} _ {i} \\odot_ {y} \\widehat {\\boldsymbol {b}} _ {i} \\\\ = (\\boldsymbol {a} _ {P, 1} \\odot_ {y} \\boldsymbol {b} _ {P, 2}) e _ {i} ^ {2} + (\\boldsymbol {a} _ {P, 1} \\odot_ {y} \\boldsymbol {b} _ {P, 1} + \\boldsymbol {a} _ {P, 2} \\odot_ {y} \\boldsymbol {b} _ {P, 2} \\cdot y ^ {k}) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(\\boldsymbol {a} _ {P, 2} \\odot_ {y} \\boldsymbol {b} _ {P, 1} \\cdot y ^ {k}) e _ {i} ^ {- 2} \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Combining this result with Eq. (28), we have</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\boldsymbol {a} _ {P, 1} \\odot_ {y} \\boldsymbol {b} _ {P, 2} - c _ {L}, \\boldsymbol {a} _ {P, 1} \\odot_ {y} \\boldsymbol {b} _ {P, 1} + \\boldsymbol {a} _ {P, 2} \\odot_ {y} \\boldsymbol {b} _ {P, 2} y ^ {k} - c _ {P}, \\boldsymbol {a} _ {P, 2} \\odot_ {y} \\boldsymbol {b} _ {P, 1} y ^ {k} - c _ {R}\\right) \\cdot \\left( \\begin{array}{c} e _ {i} ^ {2} \\\\ 1 \\\\ e _ {i} ^ {- 2} \\end{array} \\right) = 0</span></div>

    <p class="text-gray-300">The above equation holds for three distinct challenges <span class="math">e_1, \\ldots, e_3</span>. Since the vectors <span class="math">(e_i^2, 1, e_i^{-2})</span>'s are linear independent, this implies that the following must hold.</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {a} _ {P} \\odot_ {y} \\boldsymbol {b} _ {P} = \\boldsymbol {a} _ {P, 1} \\odot_ {y} \\boldsymbol {b} _ {P, 1} + \\boldsymbol {a} _ {P, 2} \\odot_ {y} \\boldsymbol {b} _ {P, 2} \\cdot y ^ {k} = c _ {P}</span></div>

    <p class="text-gray-300">For each recursive step, the extractor <span class="math">\\chi_{2k}</span> uses 4 transcripts and <span class="math">\\chi_{1}</span> uses 5 transcripts, so that the final extractor <span class="math">\\chi_{n}</span> uses <span class="math">5 \\cdot 4^{\\log_2(n)}</span> transcripts in total and this runs in expected polynomial time in <span class="math">\\lambda</span> since <span class="math">n</span> is polynomial in <span class="math">\\lambda</span>. Then, by the general forking lemma, we conclude that the proposed WIP argument system has computational witness extended emulation.</p>

    <h2 id="sec-35" class="text-2xl font-bold">D Proof of Theorem 2 and Theorem 3</h2>

    <p class="text-gray-300">Theorem 2 is a special case of Theorem 3. Thus, we omit its proof and refer to the proof of Theorem 3 given below.</p>

    <p class="text-gray-300"><strong>Proof.</strong> (perfect completeness) Since the proposed range proof argument runs the WIP argument as a subprotocol, we prove the perfect completeness by showing that if <span class="math">A = \\pmb{g}^{\\pmb{a}_L}\\pmb{h}^{\\pmb{a}_R}h^\\alpha</span> is correctly computed, then <span class="math">\\widehat{A}</span> satisfies the WIP relation such that</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {A} = \\boldsymbol {g} ^ {\\widehat {\\boldsymbol {a}} _ {L}} \\boldsymbol {h} ^ {\\widehat {\\boldsymbol {a}} _ {R}} g ^ {\\widehat {\\boldsymbol {a}} _ {L} \\odot_ {y} \\widehat {\\boldsymbol {a}} _ {R}} h ^ {\\widehat {\\alpha}} \\in \\mathbb {G} \\tag {33}</span></div>

    <p class="text-gray-300">From the computation</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {A} = A \\cdot \\boldsymbol {g} ^ {- \\mathbf {1} ^ {m n} \\cdot z} \\boldsymbol {h} ^ {\\boldsymbol {d} \\circ \\overleftarrow {y} ^ {m n} + \\mathbf {1} ^ {m n} \\cdot z} \\left(\\prod_ {j = 1} ^ {m} V _ {j} ^ {z ^ {2 j}}\\right) ^ {y ^ {m n + 1}} g ^ {\\langle \\mathbf {1} ^ {m n}, \\overrightarrow {y} ^ {m n} \\rangle \\cdot z - \\langle \\mathbf {1} ^ {m n}, \\boldsymbol {d} \\rangle \\cdot y ^ {m n + 1} z - \\langle \\mathbf {1} ^ {m n}, \\overrightarrow {y} ^ {m n} \\rangle \\cdot z ^ {2}},</span></div>

    <p class="text-gray-300">one can easily check the exponents of bases <span class="math">\\pmb{g}, \\pmb{h}</span> and <span class="math">h</span> are equal to <span class="math">\\widehat{\\pmb{a}}_L, \\widehat{\\pmb{a}}_L</span> and <span class="math">\\widehat{\\alpha}</span>, respectively. Only the thing that remains to confirm is whether the exponent of the base <span class="math">g</span> is equal to <span class="math">\\widehat{\\pmb{a}}_L \\odot_y \\widehat{\\pmb{a}}_R</span> that can be checked as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat {\\boldsymbol {a}} _ {L} \\odot_ {y} \\widehat {\\boldsymbol {a}} _ {R} \\\\ = \\left(\\boldsymbol {a} _ {L} - \\mathbf {1} ^ {m n} \\cdot z\\right) \\odot_ {y} \\left(\\boldsymbol {a} _ {R} + \\boldsymbol {d} \\circ \\overleftarrow {y} ^ {m n} + \\mathbf {1} ^ {m n} \\cdot z\\right) \\\\ = \\boldsymbol {a} _ {L} \\odot_ {y} \\boldsymbol {a} _ {R} + \\boldsymbol {a} _ {L} \\odot_ {y} (\\boldsymbol {d} \\circ \\overleftarrow {y} ^ {m n}) + \\boldsymbol {a} _ {L} \\odot_ {y} \\mathbf {1} ^ {m n} \\cdot z - \\mathbf {1} ^ {m n} \\odot_ {y} \\boldsymbol {a} _ {R} \\cdot z - \\mathbf {1} ^ {m n} \\odot_ {y} (\\boldsymbol {d} \\circ \\overleftarrow {y} ^ {m n}) \\cdot z - \\mathbf {1} ^ {m n} \\odot_ {y} \\mathbf {1} ^ {m n} \\cdot z ^ {2} \\\\ = \\left\\langle \\boldsymbol {a} _ {L}, \\boldsymbol {d} \\right\\rangle \\cdot y ^ {m n + 1} + \\left\\langle \\mathbf {1} ^ {m n}, \\overrightarrow {y} ^ {m n} \\right\\rangle \\cdot z - \\left\\langle \\mathbf {1} ^ {m n}, \\boldsymbol {d} \\right\\rangle \\cdot z \\cdot y ^ {m n + 1} - \\left\\langle \\mathbf {1} ^ {m n}, \\overrightarrow {y} ^ {m n} \\right\\rangle \\cdot z ^ {2} \\tag {34} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The first component in the far right hand side in Eq. (34) is equal to</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {a} _ {L}, \\sum_ {j = 1} ^ {m} z ^ {2 j} \\cdot \\boldsymbol {d} _ {j} \\rangle \\cdot y ^ {m n + 1} = \\sum_ {j = 1} ^ {m} z ^ {2 j} \\cdot \\langle \\boldsymbol {a} _ {L}, \\boldsymbol {d} _ {j} \\rangle \\cdot y ^ {m n + 1} = \\sum_ {j = 1} ^ {m} z ^ {2 j} \\cdot v _ {j} \\cdot y ^ {m n + 1},</span></div>

    <p class="text-gray-300">which is the <span class="math">g</span>-base exponent of <span class="math">\\left(\\prod_{j=1}^{m} V_{j}^{z^{2j}}\\right)^{y^{mn+1}}</span>. Then, Eq. (34) is exactly equal to the <span class="math">g</span>-base exponent of <span class="math">\\widetilde{A}</span>, so that Eq. (33) holds. Since Eq. (33) has the correct format of the bilinear argument, we can utilize the perfect completeness of the WIP argument, so that we conclude that the proposed aggregatable range proof argument has perfect completeness.</p>

    <p class="text-gray-300">(perfect SHVZK) For perfect special honest verifier zero-knowledge, we construct a simulator. The simulator samples <span class="math">A \\stackrel{\\</span>}{\\leftarrow} \\mathbb{G}<span class="math"> and sets the input of the WIP argument according to the description of the range protocol. Then, the simulator runs the simulator for the perfect SHVZK of the WIP argument as a subalgorithm. In the real transcript, </span>A<span class="math"> is uniformly distributed due to the blinding factor </span>\\alpha<span class="math">, and it, along with </span>y<span class="math"> and </span>z<span class="math">, contributes to define the input of the bilinear argument. In the simulated transcript, </span>A$ is also uniformly generated and for fixed input of the WIP argument, we have already proved that the simulator for the perfect SHVZK of the WIP argument can perfectly simulate the real transcript. Therefore, we conclude that the distribution of simulated transcript is identical to that of the real transcript.</p>

    <p class="text-gray-300">(witness-extended emulation) We prove that the proposed protocol has witness-extended emulation. To this end, we construct the extractor <span class="math">\\chi_{R}</span> that extracts a witness of the range proof argument by using <span class="math">3n + 3</span> distinct <span class="math">y</span> challenges and <span class="math">2m + 2</span> distinct <span class="math">z</span> challenges. In the proof, we first explain how the extractor extracts opening <span class="math">v_{j}</span>'s of the Pedersen commitments and next prove that it satisfies the desired relation <span class="math">v_{j} \\in [0, 2^{n} - 1]</span>.</p>

    <p class="text-gray-300">In order to extract openings of the Pedersen commitments, the extractor uses another extractor <span class="math">\\chi_{B}</span> for the bilinear arguments whose existence is already proved in the proof of Theorem 1. More precisely, after fixing the first message <span class="math">A</span> sent by the prover, <span class="math">\\chi_{R}</span> rewinds the prover by using one <span class="math">y</span> challenge and <span class="math">m + 1</span> distinct <span class="math">z</span> challenges, computes the corresponding <span class="math">\\widetilde{A}</span>, calls <span class="math">\\chi_{B}</span> by giving <span class="math">(\\pmb{g}, \\pmb{h}, g, h, \\widetilde{A})</span> as input, and then obtains the corresponding values <span class="math">\\widehat{\\pmb{a}}_{L}, \\widehat{\\pmb{a}}_{R}</span> and <span class="math">\\widehat{\\alpha}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\boldsymbol{g} \\widehat{\\boldsymbol{a}}_{L} \\boldsymbol{h} \\widehat{\\boldsymbol{a}}_{R} g \\widehat{\\boldsymbol{a}}_{L} \\odot_{y} \\widehat{\\boldsymbol{a}}_{R} h \\widehat{\\boldsymbol{\\alpha}} \\\\ = A \\cdot \\boldsymbol{g} ^ {- \\mathbf{1} ^ {m n} \\cdot z} \\boldsymbol{h} ^ {\\boldsymbol{d} \\triangleright \\overline{y} ^ {m n} + \\mathbf{1} ^ {m n} \\cdot z} \\left(\\prod_ {j = 1} ^ {m} V _ {j} ^ {z ^ {2 j}}\\right) ^ {y ^ {m n + 1}} g ^ {\\langle \\mathbf{1} ^ {m n}, \\overline{y} ^ {m n} \\rangle \\cdot z - \\langle \\mathbf{1} ^ {m n}, \\boldsymbol{d} \\rangle \\cdot y ^ {m n + 1} z - \\langle \\mathbf{1} ^ {m n}, \\overline{y} ^ {m n} \\rangle \\cdot z ^ {2}} \\tag {35} \\end{array}</span></div>

    <p class="text-gray-300">Here, <span class="math">\\chi_R</span> knows all exponents of both hand sides in Eq. (35) and so we can efficiently perform any linear operations among the exponents in Eq. (35). The tuple of exponents of <span class="math">A</span> and <span class="math">V_j</span>'s in Eq. (35) is the <span class="math">(m + 1)</span>-dimensional vector <span class="math">(1, y^{mn + 1}z^2, \\ldots, y^{mn + 1}z^{2m})</span>. We know that a set of vectors <span class="math">(1, z^2, \\ldots, z^{2m})</span> for <span class="math">m + 1</span> distinct <span class="math">z</span>'s is linearly independent since it composes the Vandermonde matrix with distinct rows. By multiplying the inverse of such the Vandermonde matrix to the exponents in Eq. (35), the extractor can compute <span class="math">A</span> and <span class="math">V_j^{y^{mn + 1}}</span>'s decompositions with base <span class="math">\\pmb{g}, \\pmb{h}, g</span> and <span class="math">h</span>, and so do <span class="math">V_j</span> for <span class="math">j = 1, \\ldots, m</span> by exponentiation with <span class="math">y^{-mn - 1}</span>. Therefore, now the extractor <span class="math">\\chi_R</span> has values <span class="math">\\pmb{a}_L, \\pmb{a}_R, \\alpha, \\beta, \\pmb{v}_L, \\pmb{v}_R, v_j</span>'s, and <span class="math">\\gamma_j</span>'s such that <span class="math">A = \\pmb{g}^{\\pmb{a}_L} \\pmb{h}^{\\pmb{a}_R} g^\\beta h^\\alpha</span> and <span class="math">V_j = \\pmb{g}^{\\pmb{v}_L} \\pmb{h}^{\\pmb{v}_R} g^{v_j} h^{\\gamma_j}</span> for <span class="math">j = 1, \\ldots, m</span>. In particular, we successfully extract <span class="math">v_j</span>'s for <span class="math">j = 1, \\ldots, m</span> opening of the Pedersen commitments.</p>

    <p class="text-gray-300">Next, we show that the extracted values <span class="math">\\pmb{a}_L, \\pmb{a}_R, \\pmb{v}_L, \\pmb{v}_R</span>, and <span class="math">v_j</span> for <span class="math">j = 1, \\dots, m</span> satisfy the desired relations <span class="math">v_j \\in [0, 2^n - 1]</span> for <span class="math">j = 1, \\dots, m</span> and <span class="math">\\pmb{v}_L = \\pmb{v}_R = \\mathbf{0}</span>. To this end, it is sufficient to show that these values satisfy five equations, <span class="math">\\pmb{a}_R = \\pmb{a}_L - \\mathbf{1}^{mn}</span>, <span class="math">\\pmb{a}_L \\circ \\pmb{a}_R = \\mathbf{0}</span>, <span class="math">\\langle \\pmb{a}_L, \\pmb{d}_j \\rangle = v_j</span> for <span class="math">j \\in [1, m]</span>, <span class="math">\\pmb{v}_L \\circ \\pmb{v}_R = \\mathbf{0}</span>, and <span class="math">\\pmb{v}_L + \\pmb{v}_R = \\mathbf{0}</span>. First, we consider Eq. (35). Although <span class="math">\\widehat{\\pmb{a}}_L, \\widehat{\\pmb{a}}_R, \\widehat{\\alpha}</span> are computed by using only the <span class="math">m + 1</span> challenges <span class="math">z_j</span>'s, these are fixed exponents for the commitment <span class="math">A</span> and public <span class="math">V_j</span> for <span class="math">j = 1, \\dots, m</span> regardless of challenges. That is, if we find a challenge pair that does not satisfy Eq. (35), then we directly obtain a non-trivial discrete logarithm relation between the <span class="math">2n + 2</span> generators <span class="math">\\pmb{g}, \\pmb{h}, g, h</span> of <span class="math">\\mathbb{G}</span>. If Eq. (35) holds for all challenge pairs <span class="math">(y, z)</span>, again</p>

    <p class="text-gray-300">under the discrete logarithm relation assumption, we can change Eq. (35) with the following four equations according to the bases  <span class="math">\\pmb{g},\\pmb{h},g</span>  , and  <span class="math">h</span></p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {L} = \\boldsymbol {a} _ {L} - \\mathbf {1} ^ {m n} \\cdot z + \\boldsymbol {v} _ {L} \\cdot y ^ {m n + 1} \\in \\mathbb {Z} _ {p} ^ {n}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {R} = \\boldsymbol {a} _ {R} + \\boldsymbol {d} \\circ \\overleftarrow {y} ^ {m n} + \\mathbf {1} ^ {m n} \\cdot z + \\boldsymbol {v} _ {R} \\cdot y ^ {m n + 1} \\in \\mathbb {Z} _ {p} ^ {n}, \\text { where } \\boldsymbol {d} = \\sum_ {j = 1} ^ {m} z ^ {2 j} \\cdot \\boldsymbol {d} _ {j}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {L} \\odot_ {y} \\widehat {\\boldsymbol {a}} _ {R} = \\beta + \\sum_ {j = 1} ^ {m} v _ {j} \\cdot z ^ {2 j} \\cdot y ^ {m n + 1} + \\langle \\mathbf {1} ^ {m n}, \\overrightarrow {y} ^ {m n} \\rangle \\cdot z - \\langle \\mathbf {1} ^ {m n}, \\boldsymbol {d} \\rangle \\cdot y ^ {m n + 1} z - \\langle \\mathbf {1} ^ {m n}, \\overrightarrow {y} ^ {m n} \\rangle \\cdot z ^ {2} \\in \\mathbb {Z} _ {p}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\alpha} = \\alpha + \\sum_ {j = 1} ^ {m} \\gamma_ {j} \\cdot z ^ {2 j} \\cdot y ^ {m n + 1} \\in \\mathbb {Z} _ {p}</span></div>

    <p class="text-gray-300">The right hand sides of the above equations can be considered as polynomials in variables  <span class="math">y</span>  and  <span class="math">z</span> . By eliminating  <span class="math">\\pmb{a}_L</span>  and  <span class="math">\\pmb{a}_R</span>  in the left hand sides of the first three equations, we obtain the following equation in  <span class="math">y</span>  and  <span class="math">z</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat {\\boldsymbol {a}} _ {L} \\odot_ {y} \\widehat {\\boldsymbol {a}} _ {R} \\\\ = \\underbrace {\\boldsymbol {a} _ {L} \\odot_ {y} \\boldsymbol {a} _ {R}} _ {y, \\dots , y ^ {m n} \\text { terms}} + \\underbrace {y ^ {m n + 1} \\cdot \\langle \\boldsymbol {a} _ {L} , \\boldsymbol {d} \\rangle} _ {y ^ {m n + 1} z ^ {2}, \\dots , y ^ {m n + 1} z ^ {2 m} \\text { terms}} + \\underbrace {z \\cdot \\boldsymbol {a} _ {L} \\odot_ {y} \\mathbf {1} ^ {m n}} _ {y z, \\dots , y ^ {m n} z \\text { terms}} + \\underbrace {y ^ {m n + 1} \\cdot \\boldsymbol {a} _ {L} \\odot_ {y} \\boldsymbol {v} _ {R}} _ {y ^ {m n + 2}, \\dots , y ^ {2 m n + 1} \\text { terms}} \\\\ - \\underbrace {z \\cdot \\mathbf {1} ^ {m n} \\odot_ {y} \\mathbf {a} _ {R}} _ {y z, \\dots , y ^ {m n} z \\text { terms}} - \\underbrace {y ^ {m n + 1} z \\cdot \\langle \\mathbf {1} ^ {m n} , \\mathbf {d} \\rangle} _ {y ^ {m n + 1} z ^ {2 + 1}, \\dots , y ^ {m n + 1} z ^ {2 m + 1} \\text { terms}} - \\underbrace {z ^ {2} \\cdot \\mathbf {1} ^ {m n} \\odot_ {y} \\mathbf {1} ^ {m n}} _ {y z ^ {2}, \\dots , y ^ {m n} z ^ {2} \\text { terms}} - \\underbrace {y ^ {m n + 1} z \\cdot \\mathbf {1} ^ {m n} \\odot_ {y} \\mathbf {v} _ {R}} _ {y ^ {m n + 2} z, \\dots , y ^ {2 m n + 1} z \\text { terms}} \\\\ + \\underbrace {y ^ {m n + 1} \\cdot \\boldsymbol {v} _ {L} \\odot_ {y} \\boldsymbol {a} _ {R}} _ {y ^ {m n + 2}, \\dots , y ^ {2 m n + 1} \\text { terms}} + \\underbrace {y ^ {2 m n + 2} \\cdot \\langle \\boldsymbol {v} _ {L} , \\boldsymbol {d} \\rangle} _ {y ^ {2 m n + 2} z ^ {2}, \\dots , y ^ {2 m n + 2} z ^ {2 m} \\text { terms}} + \\underbrace {y ^ {m n + 1} z \\cdot \\boldsymbol {v} _ {L} \\odot_ {y} \\mathbf {1} ^ {m n}} _ {y ^ {m n + 2} z, \\dots , y ^ {2 m n + 1} z \\text { terms}} + \\underbrace {y ^ {2 m n + 2} \\cdot \\boldsymbol {v} _ {L} \\odot_ {y} \\boldsymbol {v} _ {R}} _ {y ^ {2 m n + 3}, \\dots , y ^ {3 m n + 2} \\text { terms}} \\\\ = \\underbrace {\\beta} _ {\\text {constant term}} + \\underbrace {\\sum_ {j = 1} ^ {m} v _ {j} \\cdot z ^ {2 j} \\cdot y ^ {m n + 1}} _ {y ^ {m n + 1} z ^ {2}, \\dots , y ^ {m n + 1} z ^ {2 m} \\text { terms}} + \\underbrace {\\langle \\mathbf {1} ^ {m n} , \\overrightarrow {y} ^ {m n} \\rangle \\cdot z} _ {y z, \\dots , y ^ {m n} z \\text { terms}} \\\\ - \\underbrace {\\left\\langle \\mathbf {1} ^ {m n} , \\boldsymbol {d} \\right\\rangle \\cdot y ^ {m n + 1} z} _ {y ^ {m n + 1} z ^ {2 + 1}, \\dots , y ^ {m n + 1} z ^ {2 m + 1} \\text { terms}} - \\underbrace {\\left\\langle \\mathbf {1} ^ {m n} , \\overrightarrow {y} ^ {m n} \\right\\rangle \\cdot z ^ {2}} _ {y z ^ {2}, \\dots , y ^ {m n} z ^ {2} \\text { terms}} \\tag {36} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The above equation holds for all  <span class="math">y</span> ,  <span class="math">z</span>  challenges, which are  <span class="math">3n + 3</span>  distinct  <span class="math">y</span>  challenges and  <span class="math">2m + 2</span>  distinct  <span class="math">z</span>  challenges, and thus the following equations must hold. (See Lemma 2 in Appendix B.2 for a rigorous proof for this argument.)</p>

    <p class="text-gray-300">|  Variables in Eq. (36)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  y, ...,ymn  |</p>

    <p class="text-gray-300">|  ymn+1z2, ...,ymn+1z2m  |</p>

    <p class="text-gray-300">|  yz, ...,ymnz  |</p>

    <p class="text-gray-300">|  y2mn+3, ...,y3mn+2  |</p>

    <p class="text-gray-300">|  ymn+2z, ...,ymn+1z  |</p>

    <p class="text-gray-300">|  Left Hand Side  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  aL ⊙y aR  |</p>

    <p class="text-gray-300">|  ⟨aL, ∑j=1mznz2j dj⟩ymn+1  |</p>

    <p class="text-gray-300">|  z·aL ⊙y 1mn - z·1mn ⊙y aR  |</p>

    <p class="text-gray-300">|  y2mn+2 · vL ⊙y vR  |</p>

    <p class="text-gray-300">|  y2mn+1z · (vL ⊙y 1mn - 1mn ⊙y vR)  |</p>

    <p class="text-gray-300">|  Right Hand Side  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  = 0 ⇒ aL ∘ aR = 0  |</p>

    <p class="text-gray-300">|  = ∑j=1m vj·z2jymn+1 ⇒ ⟨aL, dj⟩ = vj∀j  |</p>

    <p class="text-gray-300">|  = ∑j=1m vj·z2jymn+1 ⇒ aL - aR = 1mn  |</p>

    <p class="text-gray-300">|  = 0 ⇒ vL ∘ vR = 0  |</p>

    <p class="text-gray-300">|  = 0 ⇒ vL - vR = 0  |</p>

    <p class="text-gray-300">Therefore, the extracted values  <span class="math">v_{j}</span>  and  <span class="math">\\gamma_{j}</span>  satisfy the desired relations  <span class="math">v_{j} \\in [0,2^{n} - 1]</span>  and  <span class="math">V_{j} = g^{v_{j}}h^{\\gamma_{j}}</span>  for all  <span class="math">j = 1,\\ldots ,m</span> .</p>

    <p class="text-gray-300">Finally, the extractor  <span class="math">\\chi_R</span>  runs the prover with  <span class="math">3n + 3</span>  distinct  <span class="math">y</span>  challenges and  <span class="math">2m + 2</span>  distinct  <span class="math">z</span>  challenges and also invokes  <span class="math">\\chi_B</span>  on each of the transcripts, so that in total  <span class="math">\\chi_R</span>  uses  <span class="math">(3n + 3) \\cdot (2m + 2) \\cdot (5 \\cdot 4^{\\log(n)})</span>  valid transcripts, which is polynomial in  <span class="math">\\lambda</span>  since both  <span class="math">n</span>  and  <span class="math">m</span></p>

    <p class="text-gray-300">are polynomial in <span class="math">\\lambda</span>. The extractor <span class="math">\\chi_R</span> rewinds the prover <span class="math">(3n + 3) \\cdot (2m + 2) \\cdot (5 \\cdot 4^{\\log(n)})</span> times, so that it runs in expected polynomial time in <span class="math">\\lambda</span>. Combining the result of the general forking lemma, we conclude that the proposed protocol has witness-extended emulation.</p>

    <h2 id="sec-36" class="text-2xl font-bold">E Proof of Theorem 4</h2>

    <p class="text-gray-300">For the readers who are not familiar with our notation <span class="math">\\mathsf{T}_{\\pmb{W}}^{(y,z)}</span>, we note that the equality</p>

    <div class="my-4 text-center"><span class="math-block">\\pmb{a} \\odot_{y} \\mathsf{T}_{\\pmb{W}}^{(y,z)} = \\tilde{\\pmb{z}}^Q \\pmb{W} \\pmb{a}^\\top \\text{ for any vector } \\pmb{a} \\in \\mathbb{Z}_p^n</span></div>

    <p class="text-gray-300">holds and is frequently used in the following proof.</p>

    <p class="text-gray-300"><strong>Proof. (perfect completeness)</strong> As in case of the range proof, the proposed arithmetic circuit argument uses the WIP argument. Since the WIP argument has the perfect completeness, for the perfect completeness, it is sufficient to prove the following equality holds.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat{A} = A \\mathbf{g}_1^{\\mathsf{T}_{W_R}^{(y,z)}} \\mathbf{h}_1^{\\mathsf{T}_{W_L}^{(y,z)}} \\mathbf{h}_2^{y^{-n} (\\mathsf{T}_{W_O}^{(y,z)} - \\mathbf{1}^n)} \\mathbf{V}^{\\tilde{\\mathbf{z}}^Q \\cdot \\mathbf{W}_V} g^{\\tilde{\\mathbf{z}}^Q \\cdot \\mathbf{c}^\\top + \\mathsf{T}_{W_R}^{(y,z)} \\odot_y \\mathsf{T}_{W_L}^{(y,z)}} \\\\ = \\boldsymbol{g}^{\\widehat{\\boldsymbol{a}}_L} \\boldsymbol{h}^{\\widehat{\\boldsymbol{a}}_R} g^{\\widehat{\\boldsymbol{a}}_L \\odot_y \\widehat{\\boldsymbol{a}}_R} h^{\\widehat{\\boldsymbol{\\alpha}}} \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">\\widehat{\\pmb{a}}_L = (\\widehat{\\pmb{a}}_{L,1},\\widehat{\\pmb{a}}_{L,2})</span> and <span class="math">\\widehat{\\pmb{a}}_R = (\\widehat{\\pmb{a}}_{R,1},\\widehat{\\pmb{a}}_{R,2})</span>, where <span class="math">\\widehat{\\pmb{a}}_{L,i},\\widehat{\\pmb{a}}_{R,i}\\in \\mathbb{Z}_p^n</span> for <span class="math">i = 1,2</span>. To avoid complex expression, we will check the equality base-by-base.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{(Exponent with } \\pmb{g}_1 \\text{ base)} \\quad \\widehat{\\pmb{a}}_{L,1} = \\pmb{a}_L + \\mathsf{T}_{\\pmb{W}_R}^{(y,z)} \\in \\mathbb{Z}_p^n \\\\ \\text{(Exponent with } \\pmb{g}_2 \\text{ base)} \\quad \\widehat{\\pmb{a}}_{L,2} = \\pmb{a}_O \\in \\mathbb{Z}_p^n \\\\ \\text{(Exponent with } \\pmb{h}_1 \\text{ base)} \\quad \\widehat{\\pmb{a}}_{R,1} = \\pmb{a}_R + \\mathsf{T}_{\\pmb{W}_L}^{(y,z)} \\in \\mathbb{Z}_p^n \\\\ \\text{(Exponent with } \\pmb{h}_2 \\text{ base)} \\quad \\widehat{\\pmb{a}}_{R,2} = y^{-n} (\\mathsf{T}_{\\pmb{W}_O}^{(y,z)} - \\mathbf{1}^n) \\in \\mathbb{Z}_p^n \\\\ \\text{(Exponent with } g \\text{ base)} \\quad \\widehat{\\pmb{a}}_L \\odot_y \\widehat{\\pmb{a}}_R = \\tilde{\\pmb{z}}^Q \\pmb{W}_V \\pmb{v}^\\top + \\tilde{\\pmb{z}}^Q \\pmb{c}^\\top + \\mathsf{T}_{\\pmb{W}_R}^{(y,z)} \\odot_y \\mathsf{T}_{\\pmb{W}_L}^{(y,z)} \\in \\mathbb{Z}_p \\\\ \\text{(Exponent with } h \\text{ base)} \\quad \\widehat{\\alpha} = \\alpha + \\tilde{\\pmb{z}}^Q \\pmb{W}_V \\pmb{\\gamma}^\\top \\in \\mathbb{Z}_p \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The bases of <span class="math">\\pmb{g}, \\pmb{h}</span> and <span class="math">h</span> can be checked directly from the definition of <span class="math">\\widehat{\\pmb{a}}_L, \\widehat{\\pmb{a}}_L</span> and <span class="math">\\widehat{\\alpha}</span>. For the equality of exponent of the base <span class="math">g</span>, we show the equality holds as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat{\\boldsymbol{a}}_L \\odot_y \\widehat{\\boldsymbol{a}}_R = (\\boldsymbol{a}_L + \\mathsf{T}_{\\boldsymbol{W}_R}^{(y,z)}, \\boldsymbol{a}_O) \\odot_y (\\boldsymbol{a}_R + \\mathsf{T}_{\\boldsymbol{W}_L}^{(y,z)}, y^{-n} (\\mathsf{T}_{\\boldsymbol{W}_O}^{(y,z)} - \\mathbf{1}^n)) \\\\ = (\\pmb{a}_L + \\mathsf{T}_{\\pmb{W}_R}^{(y,z)}) \\odot_y (\\pmb{a}_R + \\mathsf{T}_{\\pmb{W}_L}^{(y,z)}) + \\pmb{a}_O \\odot_y (\\mathsf{T}_{\\pmb{W}_O}^{(y,z)} - \\mathbf{1}^n) \\\\ = \\pmb{a}_L \\odot_y \\pmb{a}_R + \\pmb{a}_L \\odot_y \\mathsf{T}_{\\pmb{W}_L}^{(y,z)} + \\mathsf{T}_{\\pmb{W}_R}^{(y,z)} \\odot_y \\pmb{a}_R + \\mathsf{T}_{\\pmb{W}_R}^{(y,z)} \\odot_y \\mathsf{T}_{\\pmb{W}_L}^{(y,z)} + \\pmb{a}_O \\odot_y \\mathsf{T}_{\\pmb{W}_O}^{(y,z)} - \\pmb{a}_O \\odot_y \\mathbf{1}^n \\\\ = \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_L \\boldsymbol{a}_L^\\top + \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_R \\boldsymbol{a}_R^\\top + \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_O \\boldsymbol{a}_O^\\top + \\mathsf{T}_{\\boldsymbol{W}_R}^{(y,z)} \\odot_y \\mathsf{T}_{\\boldsymbol{W}_L}^{(y,z)} \\\\ = \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_V \\boldsymbol{v}^\\top + \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{c}^\\top + \\mathsf{T}_{\\boldsymbol{W}_R}^{(y,z)} \\odot_y \\mathsf{T}_{\\boldsymbol{W}_L}^{(y,z)} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This completes the proof of the perfect completeness.</p>

    <p class="text-gray-300">(perfect SHVZK) For the perfect SHVZK of the proposed protocol, we construct a simulator. The simulator samples <span class="math">A \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> and sets the input of the WIP argument according to the description of the range protocol. Then, the simulator runs the simulator for the perfect SHVZK of the WIP argument given in the proof of Theorem 1.</p>

    <p class="text-gray-300">In the real transcript, <span class="math">A</span> is uniformly distributed due to the blinding factor <span class="math">\\alpha</span>, and it, along with <span class="math">y</span> and <span class="math">z</span>, contributes to define the input of the bilinear argument. In the simulated transcript, <span class="math">A</span> is also uniformly generated and for fixed input of the WIP argument, we have already</p>

    <p class="text-gray-300">proved that the simulator for the perfect SHVZK of the WIP argument can perfectly simulate the real transcript in the proof of Theorem 1. Therefore, we conclude that the distribution of simulated transcript is identical to that of the real transcript.</p>

    <p class="text-gray-300">(witness-extended emulation) We prove that the proposed protocol has witness-extended emulation. The overall strategy is almost same as that of the proof of Theorem 3. We construct the extractor  <span class="math">\\chi_C</span>  that extracts a witness of the proposed argument by using  <span class="math">3n + 1</span>  distinct  <span class="math">y</span>  challenges and  <span class="math">4Q - 1</span>  distinct  <span class="math">z</span>  challenges. In the proof, we first explain how the emulator extracts opening  <span class="math">v_j</span> 's of the Pedersen commitments and next prove that it satisfies the desired relations  <span class="math">\\pmb{a}_L \\circ \\pmb{a}_R = \\pmb{a}_O</span>  and  <span class="math">\\pmb{W}_L \\cdot \\pmb{a}_L^\\top + \\pmb{W}_R \\cdot \\pmb{a}_R^\\top + \\pmb{W}_O \\cdot \\pmb{a}_O^\\top = \\pmb{W}_V \\cdot \\pmb{v}^\\top + \\pmb{c}</span></p>

    <p class="text-gray-300">In order to extract openings of the Pedersen commitments, the extractor uses another extractor  <span class="math">\\chi_B</span>  for the bilinear arguments whose existence is already proved in the proof of Theorem 1. More precisely, after fixing the first message  <span class="math">A</span>  sent by the prover,  <span class="math">\\chi_C</span>  rewinds the prover by using one  <span class="math">y</span>  challenge and  <span class="math">2Q</span>  distinct  <span class="math">z</span>  challenges, computes the corresponding  <span class="math">\\widehat{A}</span> , calls  <span class="math">\\chi_B</span>  by giving  <span class="math">((\\pmb{g}_1,\\pmb{g}_2),(\\pmb{h}_1,\\pmb{h}_2),g,h,\\widehat{A})</span>  as input, and then obtains the corresponding values  <span class="math">\\widehat{\\pmb{a}}_L,\\widehat{\\pmb{a}}_R</span> , and  <span class="math">\\widehat{\\alpha}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\boldsymbol {g} _ {1}, \\boldsymbol {g} _ {2}\\right) ^ {\\widehat {\\boldsymbol {a}} _ {L}} \\left(\\boldsymbol {h} _ {1}, \\boldsymbol {h} _ {2}\\right) ^ {\\widehat {\\boldsymbol {a}} _ {R}} g ^ {\\widehat {\\boldsymbol {a}} _ {L} \\odot_ {y} \\widehat {\\boldsymbol {a}} _ {R}} h ^ {\\widehat {\\alpha}} = A \\boldsymbol {g} _ {1} ^ {\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(p, z)}} \\boldsymbol {h} _ {1} ^ {\\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(p, z)}} \\boldsymbol {h} _ {2} ^ {y ^ {- n} \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {O}} ^ {(p, z)} - \\mathbf {1} ^ {n}\\right)} \\boldsymbol {V} ^ {\\hat {\\boldsymbol {z}} ^ {Q} \\cdot \\boldsymbol {W} _ {V}} g ^ {\\hat {\\boldsymbol {z}} ^ {Q} \\cdot \\boldsymbol {c} ^ {\\top} + \\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(p, z)} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(p, z)}}. \\tag {37}</span></div>

    <p class="text-gray-300">Here,  <span class="math">\\chi_C</span>  knows all exponents of both hand sides in Eq. (37) and so we can efficiently perform linear operations on the exponents of Eq. (37). The tuple of exponents of  <span class="math">A</span>  and  <span class="math">V_j</span> 's in Eq. (37) is the  <span class="math">(m + 1)</span> -dimensional vector  <span class="math">(1, \\hat{\\pmb{z}}_i^Q \\cdot \\pmb{W}_V) \\in \\mathbb{Z}_p^{m + 1}</span>  for  <span class="math">2Q</span>  distinct  <span class="math">z</span> 's. One can easily find  <span class="math">(m + 1)z</span>  challenges such that for such  <span class="math">z</span> 's the set of vectors  <span class="math">(1, \\hat{\\pmb{z}}_i^Q \\cdot \\pmb{W}_V)</span>  is linearly independent. More precisely, first we can always efficiently find  <span class="math">(Q + 1)z</span>  challenges such that  <span class="math">(1, \\hat{\\pmb{z}}^Q) = (1, z, z^3, \\ldots, z^{2Q - 1})</span> 's  <span class="math">\\in \\mathbb{Z}_p^{Q + 1}</span>  are linearly independent. Consider the following equality.</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c} 1 &amp;amp; \\hat {\\boldsymbol {z}} _ {1} ^ {Q} \\\\ 1 &amp;amp; \\hat {\\boldsymbol {z}} _ {2} ^ {Q} \\\\ \\vdots &amp;amp; \\vdots \\\\ 1 &amp;amp; \\hat {\\boldsymbol {z}} _ {Q + 1} ^ {Q} \\end{array} \\right) _ {\\in \\mathbb {Z} _ {p} ^ {(Q + 1) \\times (Q + 1)}} \\cdot \\left( \\begin{array}{c c c} 1 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ 0 &amp;amp; &amp;amp; &amp;amp; \\\\ \\vdots &amp;amp; &amp;amp; W _ {V} \\\\ 0 &amp;amp; &amp;amp; &amp;amp; \\end{array} \\right) _ {\\in \\mathbb {Z} _ {p} ^ {(Q + 1) \\times (m + 1)}} = \\left( \\begin{array}{c c} 1 &amp;amp; \\hat {\\boldsymbol {z}} _ {1} ^ {Q} \\cdot \\boldsymbol {W} _ {V} \\\\ 1 &amp;amp; \\hat {\\boldsymbol {z}} _ {2} ^ {Q} \\cdot \\boldsymbol {W} _ {V} \\\\ \\vdots &amp;amp; \\vdots \\\\ 1 &amp;amp; \\hat {\\boldsymbol {z}} _ {Q + 1} ^ {Q} \\cdot \\boldsymbol {W} _ {V} \\end{array} \\right) _ {\\in \\mathbb {Z} _ {p} ^ {(Q + 1) \\times (m + 1)}}</span></div>

    <p class="text-gray-300">Since  <span class="math">\\mathbf{W}_{\\mathbf{V}}</span>  is of rank  <span class="math">m + 1</span> , we know that the matrix in the left hand side is of rank  <span class="math">m + 1</span> . Thus, the remaining part of algorithm is to find  <span class="math">(m + 1)</span>  linearly independent rows from the matrix, so that we have linearly independent  <span class="math">(m + 1)</span>  vectors  <span class="math">(1, \\hat{\\mathbf{z}}_i^Q \\cdot \\mathbf{W}_{\\mathbf{V}})</span> 's. Now, using this linear independence and elementary linear algebra,  <span class="math">\\chi_C</span>  can extract values  <span class="math">\\mathbf{a}_L, \\mathbf{a}_O, \\mathbf{a}_R, \\mathbf{a}_P \\in \\mathbb{Z}_p^n, \\alpha, \\beta \\in \\mathbb{Z}_p, \\mathbf{B}_g, \\mathbf{B}_h \\in \\mathbb{Z}_p^{m \\times 2n}, \\mathbf{v}, \\gamma \\in \\mathbb{Z}_p^m</span>  satisfying  <span class="math">A = g_1^{\\mathbf{a}_L} g_2^{\\mathbf{a}_O} h_1^{\\mathbf{a}_R} h_2^{\\mathbf{a}_P} g^\\beta h^\\alpha \\in \\mathbb{G}</span>  and  <span class="math">\\mathbf{V} = g^{\\mathbf{B}_g} h^{\\mathbf{B}_h} g^{\\mathbf{v}} h^\\gamma \\in \\mathbb{G}^m</span> . Note that although we used  <span class="math">2Q</span>  challenges in order to find these exponents of  <span class="math">A</span>  and  <span class="math">\\mathbf{V}</span> , these values are fixed regardless of used challenges if the discrete logarithm is computationally infeasible.</p>

    <p class="text-gray-300">From the above result, we know that  <span class="math">\\pmb{v}</span>  is the opening of  <span class="math">\\pmb{V}</span>  with base  <span class="math">\\pmb{g}</span> . Now, we show that the desired circuit relations satisfy. That is, the extracted values  <span class="math">\\pmb{v},\\pmb{a}_L,\\pmb{a}_R</span> ,  <span class="math">\\pmb{a}_O</span>  satisfy  <span class="math">\\pmb{a}_L\\circ \\pmb{a}_R = \\pmb{a}_O</span>  and  <span class="math">\\pmb{W}_{L}\\pmb{a}_{L}^{\\top} + \\pmb{W}_{R}\\pmb{a}_{R}^{\\top} + \\pmb{W}_{O}\\pmb{a}_{O}^{\\top} = \\pmb{W}_{V}\\pmb{v}^{\\top} + \\pmb{c}^{\\top}</span> . For all challenge pairs  <span class="math">(y,z)</span> , those satisfy Eq. (37) and we will use this equation in our analysis. Since it is computationally infeasible to find a non-trivial relation between the generators  <span class="math">\\pmb{g} = (\\pmb{g}_1,\\pmb{g}_2)</span> ,  <span class="math">\\pmb{h} = (h_1,h_2)</span> ,  <span class="math">g,h</span>  under the discrete logarithm relation assumption, we can change Eq. (37) with the following</p>

    <p class="text-gray-300">four equations according to bases <span class="math">\\pmb{g},\\pmb{h},g,h</span></p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {L} = \\left(\\boldsymbol {a} _ {L}, \\boldsymbol {a} _ {O}\\right) + \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)}, \\boldsymbol {0}\\right) + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {g}} \\in \\mathbb {Z} _ {p} ^ {2 n}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {R} = \\left(\\boldsymbol {a} _ {R}, \\boldsymbol {a} _ {P}\\right) + \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)}, y ^ {- n} \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {O}} ^ {(y, z)} - \\boldsymbol {1} ^ {n}\\right)\\right) + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}} \\in \\mathbb {Z} _ {p} ^ {2 n}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\boldsymbol {a}} _ {L} \\odot_ {y} \\widehat {\\boldsymbol {a}} _ {R} = \\beta + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {v} ^ {\\top} + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {c} ^ {\\top} + \\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)} \\in \\mathbb {Z} _ {p}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\alpha} = \\alpha + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {\\gamma} ^ {\\top} \\in \\mathbb {Z} _ {p}</span></div>

    <p class="text-gray-300">Removing <span class="math">\\widehat{\\pmb{a}}_L</span> and <span class="math">\\widehat{\\pmb{a}}_R</span> from the first three equations, we obtain</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\boldsymbol {a} _ {L} \\odot_ {y} \\boldsymbol {a} _ {R} + y ^ {n} \\cdot \\boldsymbol {a} _ {O} \\odot_ {y} \\boldsymbol {a} _ {P} + \\boldsymbol {a} _ {L} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)} + \\boldsymbol {a} _ {O} \\odot_ {y} \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {O}} ^ {(y, z)} - \\boldsymbol {1} ^ {n}\\right) + \\left(\\boldsymbol {a} _ {L}, \\boldsymbol {a} _ {O}\\right) \\odot_ {y} \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)} \\odot_ {y} \\boldsymbol {a} _ {R} + \\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)} + \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)}, \\boldsymbol {0}\\right) \\odot_ {y} \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}} \\\\</li>

      <li>\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {g}} \\odot_ {y} \\left(\\left(\\boldsymbol {a} _ {R}, \\boldsymbol {a} _ {P}\\right) + \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)}, y ^ {- n} \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {O}} ^ {(y, z)} - \\boldsymbol {1} ^ {n}\\right)\\right) + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}}\\right) \\\\</li>

    </ul>

    <p class="text-gray-300">= \\beta + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {v} ^ {\\top} + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {c} ^ {\\top} + \\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)}. \\end{array} $$</p>

    <p class="text-gray-300">Using the bilinearity and the property of <span class="math">\\mathsf{T}^{(y,z)}</span>, we can further simplify the equality as follows.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\boldsymbol {a} _ {L} \\odot_ {y} \\boldsymbol {a} _ {R} + y ^ {n} \\cdot \\boldsymbol {a} _ {O} \\odot_ {y} \\boldsymbol {a} _ {P} + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {L} \\boldsymbol {a} _ {L} ^ {\\top} + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {O} \\boldsymbol {a} _ {O} ^ {\\top} - \\boldsymbol {a} _ {O} \\odot_ {y} \\boldsymbol {1} ^ {n} + (\\boldsymbol {a} _ {L}, \\boldsymbol {a} _ {O}) \\odot_ {y} \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {R} \\boldsymbol {a} _ {R} ^ {\\top} + \\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)} + (\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y, z)}, \\boldsymbol {0}) \\odot_ {y} \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}} \\\\</li>

      <li>\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {g}} \\odot_ {y} \\left(\\left(\\boldsymbol {a} _ {R}, \\boldsymbol {a} _ {P}\\right) + \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y, z)}, y ^ {- n} \\left(\\mathsf {T} _ {\\boldsymbol {W} _ {O}} ^ {(y, z)} - \\boldsymbol {1} ^ {n}\\right)\\right) + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}}\\right) \\\\</li>

    </ul>

    <p class="text-gray-300">= \\underbrace {\\boldsymbol {a} _ {L} \\odot_ {y} \\boldsymbol {a} _ {R} + y ^ {n} \\cdot \\boldsymbol {a} _ {O} \\odot_ {y} \\boldsymbol {a} _ {P} - \\boldsymbol {a} _ {O} \\odot_ {y} \\boldsymbol {1} ^ {n}} _ {y, \\dots , y ^ {2 n} \\text{ terms}} + \\underbrace {\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {L} \\boldsymbol {a} _ {L} ^ {\\top} + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {O} \\boldsymbol {a} _ {O} ^ {\\top} + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {R} \\boldsymbol {a} _ {R} ^ {\\top}} _ {z, z ^ {3}, \\dots , z ^ {2 Q - 1} \\text{ terms}} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\underbrace {\\left(\\boldsymbol {a} _ {L} , \\boldsymbol {a} _ {O}\\right) \\odot_ {y} \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {h}} _ {(y, \\dots , y ^ {2 n}) \\times (z, z ^ {3}, \\dots , z ^ {2 Q - 1}) \\text{ terms}} + \\underbrace {\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y , z)} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y , z)}} _ {(y ^ {- 1}, \\dots , y ^ {- n}) \\times (z ^ {2}, z ^ {4}, \\dots , z ^ {4 Q - 2}) \\text{ terms}} + \\underbrace {\\left(\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y , z)} , \\boldsymbol {0}\\right) \\odot_ {y} \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {h}} _ {z ^ {2}, z ^ {4}, \\dots , z ^ {4 Q - 2} \\text{ terms}} \\\\</li>

      <li>\\underbrace {\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {g}} \\odot_ {y} (\\boldsymbol {a} _ {R} , \\boldsymbol {a} _ {P})} _ {(y, \\dots , y ^ {2 n}) \\times (z, z ^ {3}, \\dots , z ^ {2 Q - 1}) \\text{ terms}} + \\underbrace {\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {g}} \\odot_ {y} (\\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y , z)} , y ^ {- n} (\\mathsf {T} _ {\\boldsymbol {W} _ {O}} ^ {(y , z)} - \\boldsymbol {1} ^ {n}))} _ {z ^ {2}, z ^ {4}, \\dots , z ^ {4 Q - 2} \\&amp; (y, \\dots , y ^ {n}) \\times (z, z ^ {3}, \\dots , z ^ {2 Q - 1}) \\text{ terms}} + \\underbrace {\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {g}} \\odot_ {y} \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {B} _ {\\boldsymbol {h}}} _ {(y, \\dots , y ^ {2 n}) \\times (z ^ {2}, z ^ {4}, \\dots , z ^ {4 Q - 2}) \\text{ terms}} \\\\</li>

    </ul>

    <p class="text-gray-300">= \\underbrace {\\beta} _ {\\text{constant terms}} + \\underbrace {\\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {W} _ {V} \\boldsymbol {v} ^ {\\top} + \\tilde {\\boldsymbol {z}} ^ {Q} \\boldsymbol {c} ^ {\\top}} _ {z, z ^ {3}, \\dots , z ^ {2 Q - 1} \\text{ terms}} + \\underbrace {\\mathsf {T} _ {\\boldsymbol {W} _ {R}} ^ {(y , z)} \\odot_ {y} \\mathsf {T} _ {\\boldsymbol {W} _ {L}} ^ {(y , z)}} _ {(y ^ {- 1}, \\dots , y ^ {- n}) \\times (z ^ {2}, z ^ {4}, \\dots , z ^ {4 Q - 2}) \\text{ terms}} \\tag {38} \\end{array} $$</p>

    <p class="text-gray-300">The above equation holds for all <span class="math">y</span>, <span class="math">z</span> challenges, which are <span class="math">3n + 1</span> distinct <span class="math">y</span> challenges and <span class="math">4Q - 1</span> distinct <span class="math">z</span> challenges, and thus the following equations must hold. (See Lemma 2 and the explanation below Lemma 2 in Appendix B.2 for a rigorous proof for this argument.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Variables in Eq. (38)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Left Hand Side</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Right Hand Side</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y, ..., y2n terms</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\boldsymbol{a}_L \\odot_y \\boldsymbol{a}_R + y^n \\cdot \\boldsymbol{a}_O \\odot_y \\boldsymbol{a}_P - \\boldsymbol{a}_O \\odot_y \\boldsymbol{1}^n =</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\boldsymbol{0}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z, z3, ..., z2Q-1 terms</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_L \\boldsymbol{a}_L^\\top + \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_O \\boldsymbol{a}_O^\\top + \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_R \\boldsymbol{a}_R^\\top = \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{W}_V \\boldsymbol{v}^\\top + \\tilde{\\boldsymbol{z}}^Q \\boldsymbol{c}^\\top</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\Rightarrow \\boxed{\\boldsymbol{a}_L \\circ \\boldsymbol{a}_R = \\boldsymbol{a}_O}</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, the extracted values <span class="math">\\pmb{a}_L, \\pmb{a}_R, \\pmb{a}_O, \\pmb{v}</span>, and <span class="math">\\pmb{\\gamma}</span> satisfy the desired relations <span class="math">\\pmb{a}_L \\circ \\pmb{a}_R = \\pmb{a}_O</span> and <span class="math">\\pmb{W}_L \\pmb{a}_L^\\top + \\pmb{W}_O \\pmb{a}_O^\\top + \\pmb{W}_R \\pmb{a}_R^\\top = \\pmb{W}_V \\pmb{v}^\\top + \\pmb{c}^\\top</span>.</p>

    <p class="text-gray-300">Finally, the extractor <span class="math">\\chi_C</span> runs the prover with <span class="math">3n + 1</span> distinct <span class="math">y</span> challenges and <span class="math">4Q - 1</span> distinct <span class="math">z</span> challenges and also invokes <span class="math">\\chi_B</span> on each of the transcripts, so that in total <span class="math">\\chi_C</span> uses</p>

    <p class="text-gray-300">39</p>

    <p class="text-gray-300"><span class="math">(3n+1)\\cdot(4Q-1)\\cdot(5\\cdot 4^{\\log(n)})</span> valid transcripts, which is polynomial in <span class="math">\\lambda</span> since both <span class="math">n</span> and <span class="math">Q</span> are polynomial in <span class="math">\\lambda</span>. The extractor <span class="math">\\chi_{R}</span> rewinds the prover <span class="math">(3n+1)\\cdot(4Q-1)\\cdot(5\\cdot 4^{\\log(n)})</span> times, so that it runs in expected polynomial time in <span class="math">\\lambda</span>. Combining the result of the general forking lemma, we conclude that the proposed protocol has witness-extended emulation.</p>`;
---

<BaseLayout title="Bulletproofs+: Shorter Proofs for Privacy-Enhanced Distribut... (2020/735)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/735
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
