---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/691';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Weak Fiat-Shamir Attacks on Modern Proof Systems';
const AUTHORS_HTML = 'Quang Dao, Jim Miller, Opal Wright, Paul Grubbs';

const CONTENT = `    <p class="text-gray-300">Quang Dao [ Carnegie Mellon University ] Jim Miller [ Trail of Bits ] Opal Wright [ Trail of Bits ] Paul Grubbs [ University of Michigan ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">A flurry of excitement amongst researchers and practitioners has produced modern proof systems built using novel technical ideas and seeing rapid deployment, especially in cryptocurrencies. Most of these modern proof systems use the Fiat-Shamir (F-S) transformation, a seminal method of removing interaction from a protocol with a public-coin verifier. Some prior work has shown that incorrectly applying F-S (i.e., using the so-called “weak” F-S transformation) can lead to breaks of classic protocols like Schnorr’s discrete log proof; however, little is known about the risks of applying F-S incorrectly for modern proof systems seeing deployment today.</p>

    <p class="text-gray-300">In this paper, we fill this knowledge gap via a broad theoretical and practical study of F-S in implementations of modern proof systems. We perform a survey of open-source implementations and find 36 weak F-S implementations affecting 12 different proof systems. For four of these—Bulletproofs, Plonk, Spartan, and Wesolowski’s VDF—we develop novel knowledge soundness attacks accompanied by rigorous proofs of their efficacy. We perform case studies of applications that use vulnerable implementations, and demonstrate that a weak F-S vulnerability could have led to the creation of unlimited currency in a private blockchain protocol. Finally, we discuss possible mitigations and takeaways for academics and practitioners.</p>

    <h2 id="sec-3" class="text-2xl font-bold">I Introduction</h2>

    <p class="text-gray-300">Proof systems—cryptographic protocols in which a prover convinces a verifier of the truth of some public statement—have seen an explosion of interest from academic researchers and practitioners. The resulting modern constructions, in particular those enjoying an additional zero-knowledge property, are being widely deployed in blockchain and cryptocurrency settings <em>[5, 26, 55, 66, 68, 77, 80, 84, 94]</em>. A critical security property shared by all proof systems is soundness—roughly, this guarantees a prover can only convince a verifier of the truth of actually true statements. Applications like cryptocurrencies rely on soundness to, e.g., prevent attackers from creating money out of thin air.</p>

    <p class="text-gray-300">Most proof systems used in practice are non-interactive: they consist of a single message from the prover to the verifier. Though built using novel and varied technical tools, most modern non-interactive proof systems share a common design pattern: first, build and analyze an interactive protocol where the verifier’s messages consist solely of random values (i.e., it is public-coin), then compile it to a non-interactive protocol using the Fiat-Shamir (F-S) transformation <em>[35]</em>. The transformation works by replacing the public-coin verifier with a hash function: each verifier challenge is derived by the prover by hashing the transcript of the prover’s messages thus far. A standard result <em>[76]</em> shows that if done correctly, this transformation preserves security if the hash function is modelled as a random oracle <em>[9]</em>.</p>

    <p class="text-gray-300">Unfortunately, it is surprisingly easy to implement F-S incorrectly. An important subtlety, which is not often discussed, is whether it is necessary to include public information, such as the statement, in the transcript. The version of the transformation where the public information is not hashed is usually called weak F-S; if the public information is hashed, this is usually called strong F-S (or simply F-S). (See Figure 1 for an example of the differences for Schnorr’s discrete log proof.) Intuitively, hashing public information ensures that the proof depends on the public information, preventing a malicious prover from adaptively choosing it during, or even after, generating a proof. Prior work has shown that many classic proof systems, such as Schnorr <em>[79]</em> and Chaum-Pedersen <em>[25]</em>, cannot be adaptively sound if weak F-S is used; further, this lack of adaptive soundness breaks applications that use these proof systems. For example, an adaptive soundness attack on Chaum-Pedersen was shown to compromise the voting protocols Helios <em>[13]</em> and sVote <em>[46]</em>.</p>

    <p class="text-gray-300">Despite these important prior works, little is known about the risks of weak F-S for the modern proof systems being used in practice today. This gap in our knowledge is serious for at least two reasons. First, modern proof systems are built using newer and arguably more complex technical tools than classic schemes, meaning prior attacks do not easily translate. Second, since more proof systems are being deployed than ever before, the potential attack surface is much larger, and the consequences of attacks could be more severe. Thus, it is crucial to understand whether vulnerable code exists and how it could be exploited.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our contributions.</h4>

    <p class="text-gray-300">In this paper, we fill this gap with a broad study of the risks of weak F-S in modern proof systems. Our main contributions are fourfold: first, we perform an extensive survey of over 75 open-source proof system implementations that use F-S, uncovering 36 weak F-S implementations across 12 different proof systems. Second, for four of the proof systems with at least one weak F-S implementation, we construct, analyze, and implement novel knowledge soundness attacks. Third, we perform case studies of how these proof systems are used in applications, to understand whether our weak F-S attacks would have led to breaks of real systems. One case study shows that it would have been possible to create unlimited money in the Dusk Network testnet <em>[92]</em>.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Example weak Fiat-Shamir attack against Schnorr proofs for relation  <span class="math">\\{((\\mathbb{G},g),X;x)\\mid X = g^x\\}</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">Finally, we explore the landscape of mitigations, identifying design criteria and studying how proposals would apply to Merlin, a widely-used Rust library for implementing F-S.</p>

    <p class="text-gray-300">Example of F-S for Schnorr. Before describing our contributions in more detail, we will explain the basics of applying F-S to the classic Schnorr protocol. The left-hand side of Figure 1 describes the three moves of the interactive protocol for proving knowledge of the discrete log  <span class="math">x</span>  of an element  <span class="math">X</span>  in a prime-order group  <span class="math">\\mathbb{G}</span>  with generator  <span class="math">g</span> . For Schnorr, the group description and generator are examples of public parameters that define the set of provable statements. The group element  <span class="math">X</span>  is the public input about which the prover is generating a proof, and the value  <span class="math">x</span>  is the witness the prover wishes to hide.</p>

    <p class="text-gray-300">The middle box of Figure 1 depicts the two ways of applying F-S to Schnorr. In weak F-S, only the prover's first message  <span class="math">A</span>  is hashed. In strong F-S, the hash additionally includes the public parameters and public input. Finally, the right box of the figure depicts the adaptive attack (due to [13]) that is possible if weak F-S is used: by computing the public input  <span class="math">X</span>  as a function of a randomly-generated proof, a malicious prover can convince a verifier without knowing the witness. Intuitively, strong F-S prevents this because the public input  <span class="math">X</span>  affects the derived challenge  <span class="math">c</span> .</p>

    <p class="text-gray-300">Implementation survey. Table I summarizes our implementation survey of GitHub repositories containing implementations of proof systems. We used a combination of manual search and automated dependency checking to find the repositories. Overall, we identified at least 75 repositories that attempted to implement a non-interactive proof system using F-S. Of those, 36 used weak F-S. (For space reasons, our table lists only the 54 repos of the 12 proof systems that had at least one weak F-S implementation.) After a preliminary public disclosure [65] of some of our results, many repositories were fixed and are marked as such. The main takeaway of our survey is that misuses of F-S are very widespread, and that even production-quality code written by experts—who in some cases are the creators of the proof system—implemented weak F-S. Interestingly, we found several repositories that made even more severe mistakes in implementing F-S; Section VIII contains further discussion of these cases. We followed re</p>

    <p class="text-gray-300">sponsible disclosure best practices in informing all repository owners about the vulnerabilities.</p>

    <p class="text-gray-300">New attacks. For four proof systems with at least one vulnerable implementation—Bulletproofs [22], Plonk [37], Spartan [82], and Wesolowski's VDF [90]—we show that using weak F-S leads to attacks on their soundness when the prover can choose the public inputs adaptively, as a function of the proof. Importantly, our results do not invalidate the security proofs for these schemes—when given explicitly, soundness proofs for non-interactive, weak F-S variants of these protocols provide only non-adaptive security.</p>

    <p class="text-gray-300">In Section IV, we show an attack on the (adaptive) knowledge soundness of the Bulletproofs aggregate range proof, which would allow crafting Pedersen commitments to values that lie outside the specific range with high probability. In Sections V and VI, we give our attacks on Plonk and Spartan, two proofs systems that prove NP-complete constraint satisfaction problems and are built using the recent polynomial interactive oracle proofs (IOPs) paradigm [23], [27]. Both work by having the malicious prover choose one of the public inputs to the constraint system as a function of the proof; the public input is chosen to ensure the verification equation—in both cases, a polynomial identity—holds. Finally, in Section VII we give our attack on Wesolowski's VDF. Our attack allows a malicious prover to craft a proof  <span class="math">\\pi</span>  for a small delay parameter  <span class="math">t</span> , then compute a much larger parameter  <span class="math">T \\gg t</span>  for which  <span class="math">\\pi</span>  is valid. Thus, the prover can claim to have done  <span class="math">T</span>  sequential squarings while having done only  <span class="math">t</span> . We implement our attacks for Bulletproofs, Plonk, and Wesolowski's VDF, and experimentally verify that forged proofs can be generated quickly: for example, our Bulletproofs attack can generate a forged range proof with 32-bit range in 86 milliseconds.</p>

    <p class="text-gray-300">Aside from the attacks themselves, an important novelty of our work is that we rigorously prove all four attacks break a well-specified soundness property of the proof system. For Bulletproofs, Plonk, and Spartan, we prove our attacks violate adaptive knowledge soundness via a meta-reduction argument: roughly, we prove that if an extractor exists for our malicious prover, this extractor could be used to break a cryptographic hardness assumption like discrete log. This technique is similar to the one used in prior work [13], but applying it here</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof System</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Codebase</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weak F-S?</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs [22]</td>

            <td class="px-3 py-2 border-b border-gray-700">bp-go [87]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">bulletproof-js [2]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">simple-bulletproof-js [83]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">BulletproofSwift [20]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">python-bulletproofs [78]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">adjoint-bulletproofs [3]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">zkSen [98]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">incognito-chain [51]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">encoins-bulletproofs [33]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ZenGo-X [96]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">zkrp [52]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ckb-zkp [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">bulletproofsrb [21]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">monero [68]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">dalek-bulletproofs [29]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">secp256k1-zkp [75]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">bulletproofs-ocaml [74]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">tari-project [85]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Litecoin [59]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Grin [44]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs variant [40]</td>

            <td class="px-3 py-2 border-b border-gray-700">dalek-bulletproofs [29]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">cpp-lwevss [60]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sonic [61]</td>

            <td class="px-3 py-2 border-b border-gray-700">ebfull-sonic [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">lx-sonic [58]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">iohk-sonic [53]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">adjoint-sonic [4]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Schnorr [79]</td>

            <td class="px-3 py-2 border-b border-gray-700">noknow-python [7]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof System</td>

            <td class="px-3 py-2 border-b border-gray-700">Codebase</td>

            <td class="px-3 py-2 border-b border-gray-700">Weak F-S?</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonk [37]</td>

            <td class="px-3 py-2 border-b border-gray-700">anoma-plonkup [6]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">gnark [17]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">dusk-network [31]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">snarkjs [50]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ZK-Garage [97]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">plonky [67]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ckb-zkp [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">halo2 [93]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">o1-labs [71]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">jellyfish [34]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">matter-labs [62]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">aztec-connect [8]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Wesolowski's VDF [90]</td>

            <td class="px-3 py-2 border-b border-gray-700">0xProject [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Chia [69]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Harmony [47]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">POA Network [70]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">IOTA Ledger [54]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">master-thesis-ELTE [48]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax [89]</td>

            <td class="px-3 py-2 border-b border-gray-700">ckb-zkp [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">hyraxZK [49]</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan [82]</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan [64]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ckb-zkp [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Libra [91]</td>

            <td class="px-3 py-2 border-b border-gray-700">ckb-zkp [81]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown [43]</td>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown [19]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova [57]</td>

            <td class="px-3 py-2 border-b border-gray-700">Nova [63]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Gemini [16]</td>

            <td class="px-3 py-2 border-b border-gray-700">arkworks-gemini [38]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Girault [42]</td>

            <td class="px-3 py-2 border-b border-gray-700">zk-paillier [95]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓♦</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE I: Implementations surveyed. We include every proof system with at least one vulnerable implementation, and survey all implementations for each one (except classic protocols like Schnorr and Girault).  <span class="math">\\spadesuit =</span>  has been fixed as of May 15, 2023.</p>

    <p class="text-gray-300">requires new technical ideas; e.g., for Plonk and Spartan, a trivial extractor may exist for an "easy" constraint system. Our proofs for Plonk and Spartan show that knowledge soundness breaks as soon as the relation satisfies a slight strengthening of worst-case hardness; our analysis here may be of independent interest.</p>

    <p class="text-gray-300">Application case studies. Dozen of implementations of the four proof systems we examined are vulnerable to these attacks, at least in theory. However, this does not necessarily mean the applications that use them are broken by these attacks—it could be that external application constraints prevent exploiting weak F-S. To answer this question, we next look at the applications that use vulnerable proof systems. Here our findings are more mixed. While we identified one application that is unambiguously broken by a weak F-S attack—we show in Section V-C that it would have been possible to create unlimited money in the Dusk Network testnet—our other attacks do not appear to break applications. For Spartan, we were not able to identify any vulnerable applications. For Bulletproofs, the implementations we found that were actually used in real applications were not vulnerable. Nevertheless, we give a "counterfactual" case study of the Mimblewimble protocol [55] to determine if our weak F-S attack could have led to an application break; we find that creating unlimited money would have been possible. For Wesolowski's VDF, constraints on the size of the delay parameter prevent our</p>

    <p class="text-gray-300">malicious proofs from breaking some applications, like the Chia blockchain, but we found at least one case (the 0x VDF verifier smart contract) where no constraints exist.</p>

    <p class="text-gray-300">Mitigations. Finally, in Section IX we discuss how to mitigate weak F-S attacks. We explore creating tools that can detect weak F-S vulnerabilities in existing code, and also study how existing tools, such as the Merlin library for F-S [28], could be modified to make them harder to misuse. (Several vulnerable implementations we found used Merlin.) To detect weak F-S implementations, we describe how information-flow analysis could be used to ensure variables in common between the prover and verifier are hashed in the transcript. To make it harder to implement F-S incorrectly, we suggest modifying the Merlin API to force programmers to initialize protocol transcripts with public inputs, or to specify all F-S inputs and challenges upon initialization of the transcript. These approaches have some drawbacks, which we discuss in Section IX-A. We leave an implementation and evaluation of these tools to future work.</p>

    <p class="text-gray-300">This paper extends and generalizes our preliminary results, which were posted in a series of blog posts [65]. Compared to the blog posts, we perform a more comprehensive implementation survey which uncover more vulnerable implementations, give attacks for two more proof systems (Spartan and</p>

    <p class="text-gray-300">Wesolowski's VDF), provide rigorous proofs that our attacks break security, and give new case studies of practical impacts.</p>

    <p class="text-gray-300">Our work is about the Fiat-Shamir transformation, originally given in [35]. Our work also applies to variants of the transformation for multi-round protocols, such as the BCS transformation of [11]. We did not study protocols that use quantum variants of F-S, such as the Unruh's transformation [86]; our attacks should extend to these, but we leave the details to future work. Our attacks do not apply to proof systems that use only structured reference strings for non-interactivity, such as Groth16 [45].</p>

    <p class="text-gray-300">Our work is indebted to the seminal paper on weak F-S by Bernhard et al. [13], which highlighted this issue and gave attacks against Schnorr and Chaum-Pedersen. A key followup to [13] that uncovered other weak F-S attacks on similar sigma protocols, that also break voting systems, is [46]. As discussed above, our work examines weak F-S in the context of proof systems built in the last decade or so, which use new and very different building blocks from older schemes: these include non-constant-round interactive protocols, such as Bulletproofs. We use a similar meta-reduction technique to [13] for analyzing our attacks, though heavily modified to account for the proof systems' ability to prove more complex (even NP-complete) relations.</p>

    <p class="text-gray-300">Our work shows that the four non-interactive proof systems we studied are not sound in an adaptive setting. There has been some work finding different kinds of soundness bugs in proof systems; these bugs are caused by faulty proofs and apply even in the non-adaptive soundness setting. For example, [36] found a soundness bug in the BCTV SNARK construction, and [72] found a soundness bug in vnTinyRAM. Our attacks do not stem from faulty proofs, but rather from a gap between what the proofs guarantee and the security that applications require.</p>

    <p class="text-gray-300">We denote the security parameter by  <span class="math">\\lambda</span> , and a negligible function in  <span class="math">\\lambda</span>  by  <span class="math">\\mathrm{negl}(\\lambda)</span> . Our relations, cryptographic objects, and adversaries all depend on  <span class="math">\\lambda</span> ; we often omit this dependency. We use game-based security definitions [10]; here a game  <span class="math">\\mathsf{G}_{\\mathsf{S}_1,\\ldots ,\\mathsf{S}_m}^{\\mathcal{A}_1,\\ldots ,\\mathcal{A}_n}</span>  denotes a run of parties  <span class="math">\\mathcal{A}_1,\\dots ,\\mathcal{A}_n</span>  on a pre-specified set of procedures given by  <span class="math">\\mathsf{S}_1,\\ldots ,\\mathsf{S}_m</span> , returning a bit  <span class="math">b\\in \\{0,1\\}</span> . We denote by  <span class="math">\\operatorname*{Pr}\\left[\\mathsf{G}_{\\mathsf{S}_1,\\ldots ,\\mathsf{S}_m}^{\\mathcal{A}_1,\\ldots ,\\mathcal{A}_n}\\right]</span>  the probability, over the random coins used by all parties and the game itself, that the game's output is 1.</p>

    <p class="text-gray-300">We denote by  <span class="math">\\mathbb{G}</span>  a group, either of prime order  <span class="math">p</span>  or of unknown order,  <span class="math">\\mathbb{F}</span>  a finite field of prime order  <span class="math">p</span> , and use  <span class="math">x \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>  to denote uniformly sampling an element in  <span class="math">\\mathbb{F}</span> . We denote vectors by boldface  <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span> , the inner product of two vectors  <span class="math">\\mathbf{x}, \\mathbf{y} \\in \\mathbb{F}^n</span>  by  <span class="math">\\langle \\mathbf{x}, \\mathbf{y} \\rangle</span> , the element-wise product by  <span class="math">\\mathbf{x} \\circ \\mathbf{y}</span> , subvectors by  <span class="math">\\mathbf{x}_{[i:j]} = (x_i, x_{i+1}, \\ldots, x_j)</span> , vector subscripts by  <span class="math">\\mathbf{x_a} = (x_{a_1}, \\ldots, x_{a_m})</span>  where  <span class="math">\\mathbf{a} \\in [n]^m</span> , and multi-exponentiation between  <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span>  and  <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span>  by  <span class="math">\\mathbf{g^x}</span> . For  <span class="math">y \\in \\mathbb{F}</span> , we denote  <span class="math">\\mathbf{y}^n = (1, y, \\ldots, y^{n-1})</span> . We write</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 2: Games for Discrete Log</p>

    <p class="text-gray-300"><span class="math">p(X) \\in \\mathbb{F}^{&amp;lt;d}[X]</span>  to denote a (univariate) polynomial of degree less than  <span class="math">d</span> , and  <span class="math">p(X) \\in \\mathbb{F}[\\mu]</span>  to denote a multilinear polynomial in  <span class="math">\\mu</span>  variables.</p>

    <p class="text-gray-300">Lagrange basis. Given a finite field  <span class="math">\\mathbb{F}</span>  and a subgroup  <span class="math">H = \\langle \\omega \\rangle</span>  of order  <span class="math">n</span> , for every  <span class="math">i \\in [n]</span>  we can define the Lagrange polynomial  <span class="math">\\mathsf{L}_i(X)</span>  to be the unique polynomial of degree  <span class="math">n - 1</span>  that satisfies  <span class="math">\\mathsf{L}_i(\\omega^i) = 1</span>  and  <span class="math">\\mathsf{L}_i(\\omega^j) = 0</span>  for  <span class="math">j \\neq i</span> . For any vector  <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span> , there exists a unique polynomial  <span class="math">\\mathsf{p}(X)</span>  of degree at most  <span class="math">n - 1</span>  that satisfies  <span class="math">\\mathsf{p}(\\omega^i) = \\mathbf{x}_i</span> ; we have the identity  <span class="math">\\mathsf{p}(X) = \\sum_{i=1}^{n} \\mathbf{x}_i \\cdot \\mathsf{L}_i(X)</span> .</p>

    <p class="text-gray-300">Multilinear extension. Given  <span class="math">g: \\{0,1\\}^{\\mu} \\to \\mathbb{F}</span> , we define</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {g} \\left(X _ {1}, \\dots , X _ {\\mu}\\right) \\in \\mathbb {F} \\left[ X _ {1}, \\dots , X _ {\\mu} \\right]</span></div>

    <p class="text-gray-300">to be the unique multilinear polynomial with evaluation  <span class="math">\\widetilde{g}(y) = g(y)</span>  for all  <span class="math">y \\in \\{0,1\\}^{\\mu}</span> , called the multilinear extension of  <span class="math">g</span> . We have the identity</p>

    <div class="my-4 text-center"><span class="math-block">g \\left(X _ {1}, \\dots , X _ {\\mu}\\right) = \\sum_ {y \\in \\{0, 1 \\} ^ {\\mu}} g (y) \\cdot \\widetilde {\\operatorname {e q}} (X, y),</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {e q} (X, Y) = \\prod_ {i = 1} ^ {\\mu} \\left(X _ {i} \\cdot Y _ {i} + (1 - X _ {i}) \\cdot (1 - Y _ {i})\\right).</span></div>

    <p class="text-gray-300">Here  <span class="math">\\widetilde{\\mathrm{eq}}(X, Y)</span>  is the analogue of the Lagrange basis in the multilinear setting; we have  <span class="math">\\mathrm{eq}(x, x) = 1</span>  and  <span class="math">\\mathrm{eq}(x, y) = 0</span>  if  <span class="math">x \\neq y</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G}</span>  be a prime-order group (depending on  <span class="math">\\lambda</span> ), with generator  <span class="math">g</span>  and scalar field  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Definition 1: We say that the discrete log (DL) assumption holds for  <span class="math">\\mathbb{G}</span>  if for all PPT adversaries  <span class="math">\\mathcal{A}</span> , the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathbb {G}} ^ {\\mathrm {D L}} (\\mathcal {A}) := \\Pr \\left[ \\mathrm {D L} _ {\\mathbb {G}} ^ {\\mathcal {A}} (\\lambda) \\right].</span></div>

    <p class="text-gray-300">We say that the discrete log relation (DL-REL) assumption holds for  <span class="math">\\mathbb{G}</span>  if for all PPT adversaries  <span class="math">\\mathcal{A}</span>  and all  <span class="math">n\\in \\mathbb{N}</span> , the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathbb {G}, n} ^ {\\mathrm {D L - R E L}} (\\mathcal {A}) := \\Pr \\left[ \\mathrm {D L - R E L} _ {\\mathbb {G}, n} ^ {\\mathcal {A}} (\\lambda) \\right].</span></div>

    <p class="text-gray-300">The two discrete log assumptions are tightly related [41].</p>

    <p class="text-gray-300">Lemma 1: For every PPT adversary  <span class="math">\\mathcal{A}</span>  against DL-REL, there exists a PPT adversary  <span class="math">\\mathcal{B}</span>  against DL, nearly as efficient</p>

    <p class="text-gray-300">as  <span class="math">\\mathcal{A}</span> , such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {A d v} _ {\\mathbb {G}, n} ^ {\\mathrm {D L - R E L}} (\\mathcal {A}) \\leq \\mathbf {A d v} _ {\\mathbb {G}} ^ {\\mathrm {D L}} (\\mathcal {B}) + \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">An interactive argument for an NP relation  <span class="math">\\mathcal{R}</span>  is a tuple of PPT algorithms  <span class="math">\\Pi = (\\mathrm{Setup},\\mathcal{P},\\mathcal{V})</span> . Here  <span class="math">\\mathrm{Setup}(1^{\\lambda})\\to \\mathsf{pp}</span>  produces public parameters  <span class="math">\\mathsf{pp}</span>  given a security parameter  <span class="math">1^{\\lambda}</span> , and  <span class="math">\\langle \\mathcal{P}(w),\\mathcal{V}\\rangle (\\mathsf{pp},x)\\to \\{0,1\\}</span>  is an interactive protocol whereby the prover  <span class="math">\\mathcal{P}</span> , holding a witness  <span class="math">w</span> , interacts with the verifier  <span class="math">\\mathcal{V}</span>  on common input  <span class="math">(\\mathsf{pp},x)</span>  to convince  <span class="math">\\mathcal{V}</span>  that  <span class="math">(x,w)\\in \\mathcal{R}</span> . At the end,  <span class="math">\\mathcal{V}</span>  outputs a bit to accept or reject the proof.</p>

    <p class="text-gray-300">We require that interactive arguments satisfy completeness and knowledge soundness. Completeness states that for every  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>  and  <span class="math">(x, w) \\in \\mathcal{R}</span> , we have  <span class="math">\\langle \\mathcal{P}(w), \\mathcal{V} \\rangle(\\mathsf{pp}, x) \\to 1</span> . Knowledge soundness states that there exists an expected polynomial time extractor  <span class="math">\\mathcal{E}</span>  such that for any stateful PPT adversary  <span class="math">\\mathcal{P}^<em></span> , the probability that  <span class="math">\\mathcal{P}^</em></span>  manages to convince  <span class="math">\\mathcal{V}</span>  on an input  <span class="math">x</span>  chosen by  <span class="math">\\mathcal{P}^<em></span> , yet  <span class="math">\\mathcal{E}</span>  cannot find a witness  <span class="math">w</span>  for  <span class="math">x</span> , is negligible. Here  <span class="math">\\mathcal{E}</span>  gets black-box access to each of the next-message functions of  <span class="math">\\mathcal{P}^</em></span>  in the interactive protocol.</p>

    <p class="text-gray-300">The interactive arguments we consider are public-coin, meaning that in each round the verifier  <span class="math">\\mathcal{V}</span>  samples its message uniformly at random from some challenge space. Such protocols have a  <span class="math">(r + 1)</span> -round format where  <span class="math">\\mathcal{P}</span>  sends the first and last messages. In particular, the transcript is of the form  <span class="math">(a_{1},c_{1},\\ldots ,a_{r},c_{r},a_{r + 1})</span> , where  <span class="math">(a_{1},\\ldots ,a_{r + 1})</span>  are messages sent by  <span class="math">\\mathcal{P}</span>  and  <span class="math">(c_{1},\\ldots ,c_{r})</span>  are challenges sent by  <span class="math">\\mathcal{V}</span> .</p>

    <p class="text-gray-300">The Fiat-Shamir transformation (see Section II-E) is often used to compile public-coin interactive arguments into their non-interactive versions in the random oracle model (ROM) [9]. We denote the random oracle by  <span class="math">\\mathsf{H}:\\{0,1\\}^{<em>}\\to \\{0,1\\}^{</em>}</span> .</p>

    <p class="text-gray-300">Definition 2: A non-interactive argument of knowledge (NARK) in the ROM for a NP relation  <span class="math">\\mathcal{R}</span>  is a tuple of PPT algorithms  <span class="math">\\Pi = (\\mathrm{Setup},\\mathcal{P},\\mathcal{V})</span> , with  <span class="math">\\mathcal{P},\\mathcal{V}</span>  having black-box access to a random oracle  <span class="math">\\mathsf{H}</span> , with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda})\\to \\mathsf{pp}</span>  : generates the public parameters for  <span class="math">\\mathcal{R}</span></li>

      <li><span class="math">\\mathcal{P}^{\\mathsf{H}}(\\mathsf{pp},x,w)\\to \\pi</span>  : generates a proof,</li>

      <li><span class="math">\\mathcal{V}^{\\mathsf{H}}(\\mathsf{pp},x,\\pi)\\to \\{0,1\\}</span>  : checks whether a proof  <span class="math">\\pi</span>  is valid with respect to pp and input  <span class="math">x</span> .</li>

    </ul>

    <p class="text-gray-300">We require NARKs to satisfy the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every  <span class="math">(x, w) \\in \\mathcal{R}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {V} ^ {\\mathsf {H}} (\\mathsf {p p}, x, \\pi) = 1: \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\pi \\leftarrow \\mathcal {P} ^ {\\mathsf {H}} (\\mathsf {p p}, x, w) \\end{array} \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness. For every PPT adversary  <span class="math">\\mathcal{P}^*</span> , there exists an extractor  <span class="math">\\mathcal{E}</span>  running in expected polynomial time such that the following probability is  <span class="math">\\mathrm{negl}(\\lambda)</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {A d v} _ {\\Pi , \\mathcal {R}} ^ {\\mathsf {K S}} (\\mathcal {E}, \\mathcal {P} ^ {*}) := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\mathsf {K S} _ {0, \\Pi} ^ {\\mathcal {P} ^ {<em>}} (\\lambda) ] - \\Pr [ \\mathsf {K S} _ {1, \\Pi , \\mathcal {R}} ^ {\\mathcal {E}, \\mathcal {P} ^ {</em>}} (\\lambda) ] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The KS games are defined in Figure 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game KS P*,0,Π(λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game KS E, P*,1,Π, R(λ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp← Setup(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">pp← Setup(1λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(x,π)← (P*)H(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">(x,π)← (P*)H(pp)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b← VH(pp, x, π)</td>

            <td class="px-3 py-2 border-b border-gray-700">b← VH(pp, x, π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return b</td>

            <td class="px-3 py-2 border-b border-gray-700">w← E(P*, pp, x, π)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | return b ∧ (x, w) ∈ R  |</p>

    <p class="text-gray-300">Fig. 3: Knowledge soundness security games. Here the extractor  <span class="math">\\mathcal{E}</span>  is given the description of  <span class="math">\\mathcal{P}^<em></span> ; in particular, it may rewind  <span class="math">\\mathcal{P}^</em></span>  and reprogram the random oracle  <span class="math">\\mathsf{H}</span> .</p>

    <p class="text-gray-300">We note that our knowledge soundness definition is both non-black-box, where the extractor may depend on (the code of) the malicious prover  <span class="math">\\mathcal{P}^<em></span> , and adaptive, meaning the malicious prover  <span class="math">\\mathcal{P}^</em></span>  can choose the pair  <span class="math">(x,\\pi)</span>  at the same time. The adaptive strengthening is often necessary in practice, as evidenced by our case studies (e.g., see Section IV-C). We also discuss the situation where  <span class="math">\\mathcal{P}^*</span>  may also influence the public parameters pp in Section VIII. On the other hand, non-black-box extraction is a weaker extractability requirement [24] <span class="math">^1</span> , including extracting using non-falsifiable knowledge assumptions [12], [39], [45], [73]. Looking ahead, our results for Plonk and Spartan ruling out non-black-box extraction for "sufficiently hard" relations will also rule out black-box extraction.</p>

    <p class="text-gray-300">We define both variants (weak and strong) of the Fiat-Shamir transformation.</p>

    <p class="text-gray-300">Definition 3: Let  <span class="math">\\Pi = (\\mathrm{Setup},\\mathcal{P},\\mathcal{V})</span>  be a public-coin interactive argument with transcript of the form  <span class="math">\\operatorname{tr} = (a_1,c_1,\\ldots ,a_r,c_r,a_{r + 1})</span> . The strong Fiat-Shamir transformation turns  <span class="math">\\Pi</span>  into a non-interactive argument  <span class="math">\\Pi_{\\mathrm{sFS}}</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}_{\\mathrm{sFS}}(1^{\\lambda})</span>  is the same as  <span class="math">\\operatorname{Setup}(1^{\\lambda})</span> ,</li>

      <li>the prover  <span class="math">\\mathcal{P}_{\\mathrm{sFS}}</span> , on input  <span class="math">(\\mathsf{pp},x,w)</span> , invokes  <span class="math">\\mathcal{P}(\\mathsf{pp},x,w)</span>  and instead of asking the verifier for challenge  <span class="math">c_{i}</span>  in round  <span class="math">i</span> , queries the random oracle to get</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">c _ {i} \\leftarrow \\mathsf {H} (\\mathsf {p p}, x, a _ {1}, \\dots , a _ {i}) \\quad \\forall i = 1, \\dots , r.</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{sFS}}</span>  then outputs the proof  <span class="math">\\pi = (a_{1},\\dots ,a_{r},a_{r + 1})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the verifier  <span class="math">\\mathcal{V}_{\\mathrm{sFS}}</span> , on input  <span class="math">(\\mathsf{pp},x,\\pi)</span> , derives challenges  <span class="math">c_{i}</span>  by querying the random oracle as above, then runs  <span class="math">\\mathcal{V}(\\mathsf{pp},x)</span>  on transcript  <span class="math">(a_{1},c_{1},\\ldots ,a_{r},c_{r},a_{r + 1})</span>  and outputs what  <span class="math">\\mathcal{V}</span>  outputs.</li>

    </ul>

    <p class="text-gray-300">The weak Fiat-Shamir transformation is similar, except that we omit the public parameters  <span class="math">\\mathsf{pp}</span>  and the input  <span class="math">x</span>  from the hash, so that</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = \\mathsf {H} (a _ {1}, \\dots , a _ {i}) \\quad \\forall i = 1, \\dots , r.</span></div>

    <p class="text-gray-300">We denote the weak Fiat-Shamir transformed argument by  <span class="math">\\Pi_{\\mathrm{wFS}} = (\\mathrm{Setup},\\mathcal{P}_{\\mathrm{wFS}},\\mathcal{V}_{\\mathrm{wFS}})</span></p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">III-F Polynomial Interactive Oracle Proofs</h3>

    <p class="text-gray-300">We describe the formalism of polynomial IOPs <em>[23, 27]</em> that underlies Plonk and Spartan.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Polynomial IOP.</h4>

    <p class="text-gray-300">A (public-coin) polynomial IOP for a NP relation <span class="math">\\mathcal{R}</span> (depending on a field <span class="math">\\mathbb{F}</span>) is a tuple of PPT algorithms <span class="math">(\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> with the following protocol format. In the preprocessing phase, the indexer <span class="math">\\mathcal{I}(\\mathbb{F},\\mathcal{R})</span> outputs a list of preprocessed polynomial oracles <span class="math">\\mathbb{i}</span>. In the interaction phase, the prover <span class="math">\\mathcal{P}</span> is given <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})</span> and the verifier <span class="math">\\mathcal{V}</span> is given <span class="math">(\\mathbb{i},\\mathbb{x})</span>. In each round <span class="math">i</span>, <span class="math">\\mathcal{P}</span> sends a list of polynomial oracles <span class="math">\\mathbb{p}_{i}</span>, and <span class="math">\\mathcal{V}</span> responds with a random challenge <span class="math">c_{i}</span>. In the query phase, <span class="math">\\mathcal{V}</span> may query any of the polynomial oracle <span class="math">\\mathbb{p}</span>, obtained as part of <span class="math">\\mathbb{i}</span> or <span class="math">\\mathbb{p}_{i}</span> for some round <span class="math">i</span>, at any evaluation point <span class="math">z</span> to get the corresponding evaluation <span class="math">\\mathbb{p}(z)</span>. <span class="math">\\mathcal{V}</span> then outputs accept or reject. Completeness and knowledge soundness for polynomial IOPs are defined similarly to interactive arguments; see <em>[27]</em> for full definitions.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Polynomial Commitment Scheme.</h4>

    <p class="text-gray-300">A polynomial commitment scheme (PC) is a tuple of PPT algorithms <span class="math">\\mathsf{PC}=(\\mathsf{Setup},\\mathsf{Commit})</span> and an interactive argument <span class="math">\\mathsf{Open}</span> with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},\\mu,D)\\to\\mathsf{pp}</span> : sets up public parameters <span class="math">\\mathsf{pp}</span> given number of variables <span class="math">\\mu</span> and maximum individual degree <span class="math">D</span>,</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{pp},\\mathsf{p};\\omega)\\to[\\mathsf{p}]</span> : outputs a commitment <span class="math">[\\mathsf{p}]</span> to a polynomial <span class="math">\\mathsf{p}\\in\\mathbb{F}^{\\leq D}[X_{1},\\ldots,X_{\\mu}]</span>, using randomness <span class="math">\\omega</span>,</li>

      <li><span class="math">\\mathsf{Open}:=\\langle\\mathcal{P}_{\\mathsf{PC}}(\\mathsf{p},\\omega),\\mathcal{V}_{\\mathsf{PC}}\\rangle(\\mathsf{pp},[\\mathsf{p}],x,v)\\to\\{0,1\\}</span> is a public-coin interactive argument for the relation <span class="math">\\mathsf{p}(x)=v</span> and <span class="math">[\\mathsf{p}]=\\mathsf{Commit}(\\mathsf{pp},\\mathsf{p};\\omega)</span>.</li>

    </ul>

    <p class="text-gray-300">We consider two types of PCs in our paper, one for univariate polynomials (<span class="math">\\mu=1</span>) and one for multilinear polynomials (<span class="math">D=1</span>). We define completeness and knowledge soundness of PC to be the corresponding property for <span class="math">\\mathsf{Open}</span>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Compiling to non-interactive arguments.</h4>

    <p class="text-gray-300">Any polynomial IOP can be composed with any polynomial commitment scheme <span class="math">\\mathsf{PC}</span> to form a public-coin interactive argument <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span>, which can then be turned non-interactive via Fiat-Shamir. The former step is done as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{Setup}(1^{\\lambda}):\\text{runs PC}.\\mathsf{Setup}(1^{\\lambda})\\to\\mathsf{pp}_{\\mathsf{PC}}</span>, <span class="math">\\mathcal{I}(\\mathbb{F},\\mathcal{R})\\to\\mathbb{i}</span>, and <span class="math">\\mathsf{PC}.\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{PC}},\\mathbb{i})\\to[\\mathbb{i}]</span> for all <span class="math">\\mathbb{i}\\in\\mathbb{i}</span>. Outputs $\\mathsf{pp}=(\\mathsf{pp}_{\\mathsf{PC}},([\\mathbb{i}])_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathbb{i}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\langle\\mathcal{P}(\\mathbb{w}),\\mathcal{V}\\rangle(\\mathsf{pp},\\mathbb{x}):</span> emulate the interaction phase of the polynomial IOP, with <span class="math">\\mathcal{P}</span> sending a polynomial commitment <span class="math">[\\mathsf{p}]</span> instead of an oracle for each polynomial <span class="math">\\mathsf{p}</span>. <span class="math">\\mathcal{P},\\mathcal{V}</span> then emulate the query phase, with each query <span class="math">v\\leftarrow\\mathsf{p}(z)</span> replaced by <span class="math">\\mathcal{P}</span> sending the evaluation <span class="math">v</span>, followed by an execution of <span class="math">\\mathsf{PC}.\\mathsf{Open}</span> to prove that <span class="math">v=\\mathsf{p}(z)</span>.</li>

    </ul>

    <h2 id="sec-16" class="text-2xl font-bold">III Attack Overview</h2>

    <p class="text-gray-300">In this section, we give a common template for our attacks against weak Fiat-Shamir transformations, with the attack on Schnorr (see Figure 1) as an explicit example. In the following sections, we will use this template to instantiate attacks against Bulletproofs, Plonk, Spartan, and Wesolowski’s VDF. Since the details vary greatly between each proof system, we urge the reader to cross-reference the template here with the details of each attack.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, we identify the part of the public statement that is not included in the Fiat-Shamir transformation (e.g., certain public parameters or public inputs to a circuit). For Schnorr, this includes the public input <span class="math">X</span>.</li>

      <li>We then identify the verification step that relies on these public values. For Schnorr, the check is <span class="math">g^{z}\\stackrel{{\\scriptstyle s}}{{=}}A\\cdot X^{c}</span>.</li>

      <li>We select arbitrary witness values and randomness for proof generation, then use them to compute all intermediate proof values. For Schnorr, we sample random <span class="math">A\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{G}</span> and <span class="math">z\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span>.</li>

      <li>Finally, we use the intermediate values from step 3 to solve for the public value that will always pass the verification step from step 2. For Schnorr, we set <span class="math">X=(g^{z}/A)^{1/c}</span>.</li>

    </ol>

    <p class="text-gray-300">We leave to future work the task of using this template to instantate attacks against other proof systems, especially the ones appearing in Table I for which we did not give attacks in this paper.</p>

    <h2 id="sec-17" class="text-2xl font-bold">IV Bulletproofs</h2>

    <p class="text-gray-300">In this section, we describe an attack that is possible when the Bulletproofs aggregate range proof protocol (<span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{ARP}</span>) <em>[22]</em> is instantiated with weak Fiat-Shamir and consider the practical impacts of such an attack on MimbleWimble <em>[55]</em>.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">IV-A Protocol Description</h3>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Aggregate range proof relation.</h4>

    <p class="text-gray-300">In an aggregate range proof, the public input is a vector of commitments <span class="math">\\mathbf{V}=(V_{i})_{i\\in[m]}</span>, and the prover’s task is to show that <span class="math">V_{i}</span> is a commitment of a value <span class="math">v_{i}</span> belonging to small range <span class="math">[0,2^{n}-1]</span>. Formally, we consider the relation</p>

    <p class="text-gray-300">\\[ \\mathcal{R}_{\\mathsf{BP}.\\mathsf{ARP}}=\\left\\{\\begin{array}[]{c}\\left((m,n,\\mathbf{g},\\mathbf{h},g,h,u),\\mathbf{V},(\\mathbf{v},\\bm{\\gamma})\\right):\\\\ V_{j}=g^{v_{j}}h^{\\gamma_{j}}\\ \\wedge\\ v_{j}\\in[0,2^{n}-1]\\ \\forall j\\in[1,m]\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">Here <span class="math">m,n</span> are powers of <span class="math">2</span>, and <span class="math">\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{m\\cdot n}</span>, <span class="math">g,h,u\\in\\mathbb{G}</span> are generators with unknown discrete log relations.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Converting to inner product argument.</h4>

    <p class="text-gray-300">To prove <span class="math">v_{i}\\in[0,2^{n}-1]</span> for all <span class="math">i\\in[m]</span>, the prover will commit to the bit decomposition <span class="math">\\mathbf{a}_{L}</span> of <span class="math">v_{1},\\ldots,v_{m}</span> and prove that: (1) <span class="math">\\mathbf{a}_{L}\\circ\\mathbf{a}_{R}=0</span> where <span class="math">\\mathbf{a}_{R}=\\mathbf{a}_{L}-\\mathbf{1}^{m\\cdot n}</span>, and (2) <span class="math">\\langle(\\mathbf{a}_{L})_{[(i-1)n,in-1]},\\mathbf{2}^{n}\\rangle=v_{i}</span> for all <span class="math">i\\in[m]</span>. To achieve zero-knowledge, the prover also samples blinding vectors <span class="math">\\mathbf{s}_{L},\\mathbf{s}_{R}\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}^{m\\cdot n}</span> and computes two vector polynomials <span class="math">\\ell(X),r(X)\\in\\mathbb{F}^{m\\cdot n}[X]</span>, which encodes all checks above into a single inner product claim. Finally, the inner product claim is proved using the Bulletproofs’ inner product argument <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{IPA}</span>.</p>

    <p class="text-gray-300">We describe the protocol <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{ARP}</span> in Figure 5, which uses the <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{IPA}</span> subprotocol in Figure 4. The single range proof protocol <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{RP}</span> is a special case of <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{ARP}</span> when <span class="math">m=1</span>.</p>

    <p class="text-gray-300">Inner Product Relation. Given a power of two  <span class="math">n = 2^k</span>  and vectors of group elements  <span class="math">\\mathbf{g},\\mathbf{h}\\in \\mathbb{G}^n</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {I P A}} = \\left\\{\\left(\\left(n, \\mathbf {g}, \\mathbf {h}, u\\right), P, (\\mathbf {a}, \\mathbf {b})\\right) \\mid P = \\mathbf {g} ^ {\\mathbf {a}} \\mathbf {h} ^ {\\mathbf {b}} u ^ {\\langle \\mathbf {a}, \\mathbf {b} \\rangle} \\right\\}.</span></div>

    <p class="text-gray-300">Interaction Phase. Set  <span class="math">n_0 \\gets n, \\mathbf{g}^{(0)} \\gets \\mathbf{g}, \\mathbf{h}^{(0)} \\gets \\mathbf{h}</span> ,  <span class="math">P^{(0)} \\gets P, \\mathbf{a}^{(0)} \\gets \\mathbf{a}, \\mathbf{b}^{(0)} \\gets \\mathbf{b}</span> .</p>

    <p class="text-gray-300">For  <span class="math">i = 1,\\dots ,k</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">n_i \\gets n_{i-1}/2</span> ,  <span class="math">c_L \\gets \\langle \\mathbf{a}_{[:n_i]}^{(i)}, \\mathbf{b}_{[n_i:]}^{(i)} \\rangle</span> ,  <span class="math">c_R \\gets \\langle \\mathbf{a}_{[n_i:]}^{(i)}, \\mathbf{b}_{[:n_i]}^{(i)} \\rangle</span> , and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">L _ {i} \\leftarrow \\left(\\mathbf {g} _ {[ n _ {i}: ]} ^ {(i - 1)}\\right) ^ {\\mathbf {a} _ {[ n _ {i} ]} ^ {(i)}} \\left(\\mathbf {h} _ {[ n _ {i} ]} ^ {(i - 1)}\\right) ^ {\\mathbf {b} _ {[ n _ {i}: ]} ^ {(i)}} u ^ {c _ {L}},</span></div>

    <div class="my-4 text-center"><span class="math-block">R _ {i} \\leftarrow \\left(\\mathbf {g} _ {[: n _ {i} ]} ^ {(i - 1)}\\right) ^ {\\mathbf {a} _ {[ n _ {i}: ]} ^ {(i)}} \\left(\\mathbf {h} _ {[ n _ {i}: ]} ^ {(i - 1)}\\right) ^ {\\mathbf {b} _ {[ : n _ {i} ]} ^ {(i)}} u ^ {c _ {R}}.</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  sends  <span class="math">L_{i},R_{i}</span>  to  <span class="math">\\nu</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends challenge  <span class="math">x_{i} \\stackrel{\\S}{\\leftarrow} \\mathbb{F}^{*}</span> .</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>  both compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} ^ {(i)} \\leftarrow \\left(\\mathbf {g} _ {[: n _ {i} ]} ^ {(i - 1)}\\right) ^ {x _ {i} ^ {- 1}} \\circ \\left(\\mathbf {g} _ {[ n _ {i}: ]} ^ {(i - 1)}\\right) ^ {x _ {i}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {h} ^ {(i)} \\leftarrow \\left(\\mathbf {h} _ {[: n _ {i} ]} ^ {(i - 1)}\\right) ^ {x _ {i}} \\circ \\left(\\mathbf {h} _ {[ n _ {i}: ]} ^ {(i - 1)}\\right) ^ {x _ {i} ^ {- 1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">P ^ {(i)} \\leftarrow L _ {i} ^ {x _ {i} ^ {2}} P ^ {(i - 1)} R _ {i} ^ {x _ {i} ^ {- 2}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">\\mathbf{a}^{(i)}\\gets \\mathbf{a}_{[:n_i]}^{(i - 1)}\\cdot x_i^{-1} + \\mathbf{a}_{[n_i:]}^{(i - 1)}\\cdot x_i</span>  and  <span class="math">\\mathbf{b}^{(i)}\\gets \\mathbf{b}_{[:n_i]}^{(i - 1)}\\cdot x_i + \\mathbf{b}_{[n_i:]}^{(i - 1)}\\cdot x_i^{-1}.</span></li>

    </ol>

    <p class="text-gray-300">After  <span class="math">k</span>  rounds,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathbf{a}^{(k)},\\mathbf{b}^{(k)}</span>  to  <span class="math">\\nu</span></p>

    <p class="text-gray-300">Verification.  <span class="math">\\mathcal{V}</span>  checks whether</p>

    <div class="my-4 text-center"><span class="math-block">P ^ {(k)} \\stackrel {?} {=} \\left(\\mathbf {g} ^ {(k)}\\right) ^ {\\mathbf {a} ^ {(k)}} \\left(\\mathbf {h} ^ {(k)}\\right) ^ {\\mathbf {b} ^ {(k)}} u ^ {\\mathbf {a} ^ {(k)} \\cdot \\mathbf {b} ^ {(k)}}.</span></div>

    <p class="text-gray-300">Fig. 4: Bulletproofs' Inner Product Argument BP-IPA</p>

    <p class="text-gray-300">When BP-ARP is instantiated with a weak Fiat-Shamir transformation, the challenges are derived without hashing the commitments  <span class="math">\\mathbf{V}</span> . In this case, we describe an attack against BP-ARPwFS in Figure 6. Our attack differs from an honest prover's algorithm in two ways—first, we sample  <span class="math">t_1, t_2, \\tau_x</span>  uniformly at random, and second, we choose  <span class="math">v_i, \\gamma_i</span>  for  <span class="math">i \\in [m]</span>  after computing the proof  <span class="math">\\pi</span> . Our attack extends to the single (i.e. non-aggregate) range proof as well.</p>

    <p class="text-gray-300">Correctness and performance. We show that our attack produces accepting proofs. Recall from Figure 5 that the verifier for BP-ARPwFS checks the following: (1) whether  <span class="math">\\pi_{\\mathrm{BP - IPA}}</span>  is accepting, and (2) whether</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {\\hat {t}} h ^ {\\tau_ {x}} = \\mathbf {V} ^ {\\left(z ^ {2}, \\dots , z ^ {m + 1}\\right)} \\cdot g ^ {\\delta (y, z)} \\cdot T _ {1} ^ {x} \\cdot T _ {2} ^ {x ^ {2}} \\tag {2}</span></div>

    <p class="text-gray-300">Since our attack uses a valid witness  <span class="math">(\\mathbf{l},\\mathbf{r})</span>  to generate  <span class="math">\\pi_{\\mathrm{BP - IPA}}</span> , this proof will be accepted by the verifier. Our choice of  <span class="math">v_{i},\\gamma_{i}</span>  for  <span class="math">i\\in [m]</span>  in step 8 of our attack then ensures that Equation 2 holds as well.</p>

    <p class="text-gray-300">We implemented our attack in about 100 lines of Go, and verified that our forged proofs are accepted by zkrp [52].</p>

    <p class="text-gray-300">Public Parameters.  <span class="math">(m,n,\\mathbf{g},\\mathbf{h},g,h,u)</span></p>

    <p class="text-gray-300">Public Input.  <span class="math">(V_{i})_{i\\in [m]}</span>  Witness.  <span class="math">(v_{i},\\gamma_{i})_{i\\in [m]}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  samples  <span class="math">\\alpha, \\rho \\stackrel{\\S}{\\leftarrow} \\mathbb{F}, \\mathbf{s}_L, \\mathbf{s}_R \\stackrel{\\S}{\\leftarrow} \\mathbb{F}^{m \\cdot n}</span>  and computes  <span class="math">\\mathbf{a}_L \\in \\{0, 1\\}^{m \\cdot n}</span>  such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\langle (\\mathbf {a} _ {L}) _ {[ (j - 1) n, j n - 1 ]}, \\mathbf {2} ^ {n} \\rangle = v _ {j} \\forall j \\in [ 1, m ],</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} _ {R} = \\mathbf {a} _ {L} - \\mathbf {1} ^ {m \\cdot n},</span></div>

    <div class="my-4 text-center"><span class="math-block">A = h ^ {\\alpha} \\mathbf {g} ^ {\\mathbf {a} _ {L}} \\mathbf {h} ^ {\\mathbf {a} _ {R}}, \\quad S = h ^ {\\rho} \\mathbf {g} ^ {\\mathbf {a} _ {L}} \\mathbf {h} ^ {\\mathbf {a} _ {R}}.</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  sends  <span class="math">A, S</span>  to  <span class="math">\\nu</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends challenges  <span class="math">y,z\\stackrel {\\S}{\\leftarrow}\\mathbb{F}^{*}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  samples  <span class="math">\\tau_{1},\\tau_{2}\\stackrel {\\S}{\\leftarrow}\\mathbb{F}</span>  and computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\ell (X) = \\left(\\mathbf {a} _ {L} - z \\cdot \\mathbf {1} ^ {m \\cdot n}\\right) + \\mathbf {s} _ {L} \\cdot X,</span></div>

    <div class="my-4 text-center"><span class="math-block">r (X) = \\mathbf {y} ^ {m \\cdot n} \\circ (\\mathbf {a} _ {R} + z \\cdot \\mathbf {1} ^ {m \\cdot n} + \\mathbf {s} _ {R} \\cdot X)</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sum_ {j = 1} ^ {m} z ^ {j + 1} \\cdot \\left(\\mathbf {0} ^ {(j - 1) n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {2} ^ {n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {0} ^ {(m - j) n}\\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">t (X) = \\langle \\ell (X), r (X) \\rangle = t _ {0} + t _ {1} \\cdot X + t _ {2} \\cdot X ^ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {1} = g ^ {\\prime 1} h ^ {\\tau_ {1}}, \\quad T _ {2} = g ^ {\\prime 2} h ^ {\\tau_ {2}}.</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  sends  <span class="math">T_{1}, T_{2}</span>  to  <span class="math">\\nu</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends challenge  <span class="math">x\\stackrel {\\S}{\\leftarrow}\\mathbb{F}^{*}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {l} = \\ell (x), \\quad \\mathbf {r} = r (x), \\quad \\hat {t} = \\langle \\mathbf {l}, \\mathbf {r} \\rangle , \\quad \\mu = \\alpha + \\rho \\cdot x,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {x} = \\tau_ {2} \\cdot x ^ {2} + \\tau_ {1} \\cdot x + \\sum_ {j = 1} ^ {m} z ^ {j + 1} \\cdot \\gamma_ {j}.</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  sends  <span class="math">\\hat{t}, \\tau_x, \\mu</span>  to  <span class="math">\\mathcal{V}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends challenge  <span class="math">w\\stackrel {\\S}{\\leftarrow}\\mathbb{F}^{*}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>  both compute  <span class="math">\\mathbf{h}^{\\prime} = \\mathbf{h}^{\\mathbf{y}^{-m\\cdot n}}</span> <span class="math">u^{\\prime} = u^{w}</span>  , and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">P ^ {\\prime} = h ^ {- \\mu} \\cdot A \\cdot S ^ {x} \\cdot \\mathbf {g} ^ {- z \\cdot \\mathbf {1} ^ {m \\cdot n}} \\cdot (\\mathbf {h} ^ {\\prime}) ^ {z \\cdot \\mathbf {y} ^ {m \\cdot n}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cdot \\prod_ {j = 1} ^ {m} (\\mathbf {h} ^ {\\prime}) _ {[ (j - 1) n, j n - 1 ]} ^ {z ^ {j + 1} \\cdot \\mathbf {2} ^ {n}} (u ^ {\\prime}) ^ {\\hat {t}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>  engage in BP-IPA for the triple  <span class="math">((m\\cdot n,\\mathbf{g},\\mathbf{h}^{\\prime},u^{\\prime}),P^{\\prime},(\\mathbf{l},\\mathbf{r}))</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  rejects if BP-IPA fails.</li>

      <li><span class="math">\\mathcal{V}</span>  computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\delta (y, z) = (z - z ^ {2}) \\cdot \\langle \\mathbf {1} ^ {m \\cdot n}, \\mathbf {y} ^ {m \\cdot n} \\rangle - \\sum_ {j = 1} ^ {m} z ^ {j + 2} \\cdot \\langle \\mathbf {1} ^ {n}, \\mathbf {2} ^ {n} \\rangle ,</span></div>

    <div class="my-4 text-center"><span class="math-block">R = \\mathbf {V} ^ {z ^ {2} \\cdot \\mathbf {z} ^ {m}} \\cdot g ^ {\\delta (y, z)} \\cdot T _ {1} ^ {x} \\cdot T _ {2} ^ {x ^ {2}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  checks whether  <span class="math">g^{\\hat{t}}h^{\\tau_x}\\stackrel {\\mathcal{I}}{=}R</span></li>

    </ol>

    <p class="text-gray-300">Fig. 5: Bulletproofs' Aggregate Range Proof BP-ARP</p>

    <p class="text-gray-300">We benchmarked forged proof generation on an Intel Core i9 running at  <span class="math">2.4\\mathrm{GHz}</span>  with 16 GB of RAM. Our implementation was able to generate single range proofs (i.e.  <span class="math">m = 1</span> ) for 8-bit ranges in about 23.9 milliseconds, for 16-bit ranges in 44.7 milliseconds, and for 32-bit ranges in 86.0 milliseconds. Due to limitations of the zkrp library, larger ranges could not be tested.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize empty proof  <span class="math">\\pi = \\epsilon</span></li>

      <li>Sample  <span class="math">\\mathbf{a}_L \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^n</span> ,  <span class="math">\\alpha, \\rho \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> ,  <span class="math">\\mathbf{s}_L, \\mathbf{s}_R \\stackrel{\\S}{\\leftarrow} \\mathbb{F}^n</span> , and compute  <span class="math">\\mathbf{a}_R = \\mathbf{a}_L - \\mathbf{1}^n</span> ,  <span class="math">A \\gets h^\\alpha \\mathbf{g}^{\\mathbf{a}_L} \\mathbf{h}^{\\mathbf{a}_R}</span> ,  <span class="math">S \\gets h^\\rho \\mathbf{g}^{\\mathbf{s}_L} \\mathbf{h}^{\\mathbf{s}_R}</span> .</li>

    </ol>

    <p class="text-gray-300">Append  <span class="math">A, S</span>  to  <span class="math">\\pi</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query challenges  <span class="math">y, z \\gets \\mathsf{H}(\\pi)</span> .</li>

      <li>Sample  <span class="math">t_1, t_2 \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> ,  <span class="math">\\tau_1, \\tau_2 \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>  and compute  <span class="math">T_1 \\gets g^{t_1} h^{\\tau_1}</span> ,  <span class="math">T_2 \\gets g^{t_2} h^{\\tau_2}</span> .</li>

    </ol>

    <p class="text-gray-300">Append  <span class="math">T_{1}, T_{2}</span>  to  <span class="math">\\pi</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query challenge  <span class="math">x \\gets \\mathsf{H}(\\pi)</span> .</li>

      <li>Compute  <span class="math">\\mathbf{l}\\gets (\\mathbf{a}_L - z\\cdot \\mathbf{1}^n) + \\mathbf{s}_L\\cdot x,</span> <span class="math">\\mathbf{r}\\gets \\mathbf{y}^n\\circ (\\mathbf{a}_R + z\\cdot \\mathbf{1}^n +\\mathbf{s}_R\\cdot x) + z^2\\cdot \\mathbf{2}^n,</span> <span class="math">\\hat{t} = \\langle \\mathbf{l},\\mathbf{r}\\rangle ,\\qquad \\mu \\gets \\alpha +\\rho \\cdot x.</span></li>

    </ol>

    <p class="text-gray-300">Sample  <span class="math">\\tau_{x}\\stackrel {\\S}{\\leftarrow}\\mathbb{F}</span>  and append  <span class="math">\\hat{t},\\tau_x,\\mu</span>  to  <span class="math">\\pi</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query challenge  <span class="math">w\\gets \\mathsf{H}(\\pi)</span></li>

      <li>Compute  <span class="math">\\mathbf{h}&#x27;</span> ,  <span class="math">u&#x27;</span> ,  <span class="math">P&#x27;</span>  as in Figure 5, and a proof  <span class="math">\\pi_{\\mathrm{BP - IPA}}</span>  for the statement  <span class="math">P&#x27; = \\mathbf{g}^{\\mathrm{I}}(\\mathbf{h}&#x27;)^{\\mathbf{r}}(u&#x27;)^{\\hat{t}}</span> . Append  <span class="math">\\pi_{\\mathrm{BP - IPA}}</span>  to  <span class="math">\\pi</span> .</li>

      <li>Choose  <span class="math">v_{1}, \\ldots, v_{m}, \\gamma_{1}, \\ldots, \\gamma_{m} \\in \\mathbb{F}</span>  such that  <span class="math">v_{1}z^{2} + \\dots + v_{m}z^{m+1} = \\hat{t} - t_{1} \\cdot x - t_{2} \\cdot x^{2} - \\delta(y, z)</span> , (1)</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\gamma_{1}z^{2} + \\dots + \\gamma_{m}z^{m+1} = \\tau_{x} - \\tau_{2} \\cdot x^{2} - \\tau_{1} \\cdot x</span> . Set  <span class="math">V_{i} = g^{v_{i}}h^{\\gamma_{i}}</span>  for all  <span class="math">i \\in [m]</span>  and  <span class="math">\\mathbf{V} = (V_{i})_{i \\in [m]}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">(\\mathbf{V},\\pi)</span> .</li>

    </ol>

    <p class="text-gray-300">Fig. 6: Weak Fiat-Shamir Attack Against BP-ARPwFS</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Provable insecurity. We show that  <span class="math">\\mathsf{BP - ARP}_{\\mathsf{wFS}}</span>  is not knowledge sound if the discrete log relation assumption holds in the underlying group, and if  $2^{n} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is negligible. (Note that this is usually the case in practice, with typical parameters of  </span>n \\leq 64<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{256}<span class="math"> .) The intuition is that at least one of the values  </span>v_{i}<span class="math">  computed by the malicious prover falls outside the range  </span>[0, 2^{n} - 1]$  with overwhelming probability. Hence no efficient extractor could recover values in the range consistent with the commitments, since that would lead to a non-trivial discrete log relation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 4: Assume  <span class="math">\\mathbb{G}</span>  satisfies DL-REL, and that  $2^{n} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)<span class="math"> . Then  </span>\\mathrm{BP - ARP}_{\\mathrm{wFS}}$  is not knowledge sound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof: Denote by  <span class="math">\\mathcal{P}^<em></span>  the weak Fiat-Shamir malicious prover described in Figure 6, with the following specification for step 8:  <span class="math">\\mathcal{P}^</em></span>  chooses  <span class="math">v_{2},\\ldots ,v_{m}</span>  uniformly at random, then sets  <span class="math">v_{1}</span>  to satisfy Equation 1. Since  <span class="math">\\mathcal{P}^<em></span>  always outputs accepting proofs, we have  <span class="math">\\operatorname</em>{Pr}\\left[\\mathsf{KS}_{0,\\mathsf{BP - ARP}_{\\mathsf{wFS}}}^{\\mathcal{P}^*}\\right] = 1</span> . We will show that for every extractor  <span class="math">\\mathcal{E}</span> , there exists an adversary  <span class="math">\\mathcal{A}</span> , nearly as efficient as  <span class="math">\\mathcal{E}</span> , against DL-REL such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathsf {K S} _ {1, \\mathsf {B P - A R P} _ {\\mathsf {w F S}}, \\mathcal {R}} ^ {\\mathcal {E}, \\mathcal {P} ^ {*}} \\right] \\leq \\mathbf {A d v} _ {\\mathbb {G}, 2} ^ {\\mathsf {D L - R E L}} (\\mathcal {A}) + \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Thus, if DL-REL holds in  <span class="math">\\mathbb{G}</span> , then  <span class="math">\\mathcal{E}</span>  has a negligible chance of outputting a valid witness, and thus BP-ARP <span class="math">_{\\mathrm{wFS}}</span>  cannot be knowledge sound against  <span class="math">\\mathcal{P}^*</span> . Before we describe  <span class="math">\\mathcal{A}</span> , we note</p>

    <p class="text-gray-300">the following fact about the distribution of  <span class="math">v_{1}</span> . By construction,  <span class="math">\\mathcal{P}^*</span>  chooses  <span class="math">v_{1}</span>  to be the unique value such that</p>

    <div class="my-4 text-center"><span class="math-block">v _ {1} = z ^ {- 2} \\cdot (\\hat {t} - t _ {1} \\cdot x - t _ {2} \\cdot x ^ {2} - \\delta (y, z)) - v _ {2} z - \\dots - v _ {m} z ^ {m - 1}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  <span class="math">t_1, t_2, v_2, \\ldots, v_m</span>  are sampled uniformly at random, it follows that  <span class="math">v_1</span>  is uniformly distributed. Since  $2^n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)<span class="math"> , we have  </span>v_1 \\in [0, 2^n - 1]<span class="math">  with negligible probability. The adversary  </span>\\mathcal{A}<span class="math">  now works as follows: first, it receives generators  </span>g, h \\stackrel{\\S}{\\leftarrow} \\mathbb{G}<span class="math">  in the DL-REL game.  </span>\\mathcal{A}<span class="math">  then samples extra random generators  </span>\\mathbf{g}, \\mathbf{h}, u<span class="math">  and sets up the game  </span>\\mathsf{KS}_{1,\\mathsf{BP - ARP}_{\\mathsf{wFS}},\\mathcal{R}}^{\\mathcal{E},\\mathcal{P}^<em>}<span class="math">  with  </span>\\mathsf{pp} = (m,n,\\mathbf{g},\\mathbf{h},g,h,u)<span class="math"> .  </span>\\mathcal{A}<span class="math">  runs  </span>\\mathcal{P}^</em><span class="math">  once to produce  </span>(\\mathbf{V},\\pi)<span class="math"> , then gives  </span>\\mathcal{E}<span class="math">  the description of  </span>\\mathcal{P}^*<span class="math">  along with  </span>(\\mathbf{V},\\pi)<span class="math"> . When  </span>\\mathcal{E}<span class="math">  returns a witness  </span>(v_i', \\gamma_i')_{i \\in [m]}<span class="math"> ,  </span>\\mathcal{A}<span class="math">  returns  </span>(v_1 - v_1', \\gamma_1 - \\gamma_1')<span class="math">  in the DL-REL game. If  </span>\\mathcal{E}<span class="math">  outputs a valid witness, we have a discrete log relation  </span>g^{v_1}h^{\\gamma_1} = V_1 = g^{v_1'}h^{\\gamma_1'}<span class="math">  with  </span>v_1' \\in [0, 2^n - 1]<span class="math"> . As mentioned above, we know that  </span>v_1 \\in [0, 2^n - 1]<span class="math">  with negligible probability; as long as that does not happen,  </span>\\mathcal{A}<span class="math">  wins whenever  </span>\\mathcal{E}$  outputs a valid witness. This concludes our proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We surveyed 20 implementations of Bulletproofs and 2 implementations of a Bulletproofs variant [40] to determine if they were vulnerable to a weak Fiat-Shamir attack. Of the 22 codebases surveyed, we found 14 of them to be vulnerable. Of these 14 vulnerable implementations, 7 of them appear to be more experimental implementations, describing themselves as "university projects" or "proofs of concept." 5 of the vulnerable implementations, which have now been fixed, were developed by organizations, seemingly with the intent of being used. We believe it is likely that this high fraction of vulnerable implementations is the result of a typo (which has been fixed) in the original Bulletproofs paper, which specified a weak Fiat-Shamir implementation. Most of the 7 non-vulnerable implementations, on the other hand, were audited and maintained by organizations with the intent of using them in production.</p>

    <p class="text-gray-300">Attacking applications that use weak Fiat-Shamir. To understand how our attack on the soundness of Bulletproofs could lead to attacks on applications that use vulnerable implementations, we surveyed the applications that use the Bulletproofs implementations in our repositories. The two main applications represented are both privacy-preserving payments protocols: Monero [68] and MimbleWimble [55]. Fortunately, it appears that the Bulletproofs repositories used by these applications implement strong Fiat-Shamir transformations, so no concrete applications are vulnerable.</p>

    <p class="text-gray-300">Because we want to understand how future applications could be broken by weak Fiat-Shamir transformations, though, we believe it is useful to perform a counterfactual case study:</p>

    <p class="text-gray-300">what if an implementation of the MimbleWimble protocol had used a vulnerable Bulletproofs implementation?</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">MimbleWimble background.</h4>

    <p class="text-gray-300">MimbleWimble <em>[55]</em> is a cryptocurrency protocol that uses Bulletproofs to achieve confidential transactions. Coins are represented as Pedersen commitments to a value <span class="math">v</span> and blinding factor <span class="math">r</span>. Coins are spent by transactions consisting of input coins <span class="math">\\{C_{\\text{in},1},...,C_{\\text{in},n}\\}</span>, output coins <span class="math">\\{C_{\\text{out},1},...,C_{\\text{out},m}\\}</span>, a value <span class="math">S</span>, and a “transaction kernel” consisting of different types of validity proofs. The number of input and output coins is limited in some cases to small values like 20 and 30, respectively, though Litecoin’s implementation <em>[59]</em> could potentially allow hundreds of output coins. Among these proofs is a range proof that the value of each input and output coin is in a specified range small enough to ensure the sums <span class="math">\\sum_{i=1}^{n}v_{\\text{in},i}</span> and <span class="math">\\sum_{i=1}^{m}v_{\\text{out},i}</span> do not overflow modulo the group order <span class="math">p</span>. (A typical choice for <span class="math">p</span> will be roughly 256 bits.) To be a valid transaction, the equation</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{n}v_{in,i}-\\sum_{i=1}^{m}v_{out,i}=S\\mod p</span> (3)</p>

    <p class="text-gray-300">must be satisfied. An important additional constraint is that the public supply value <span class="math">S</span> is relatively small — e.g., in Litecoin <em>[59]</em>, they must be in the range <span class="math">[0,2^{64}]</span>.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Attacking MimbleWimble.</h4>

    <p class="text-gray-300">Ordinarily, the range proofs prevent the committed coin values from being large enough to overflow mod <span class="math">p</span>; however, our attack allows one to compute valid range proofs for commitments to uniformly random elements of <span class="math">\\mathbb{Z}_{p}</span> (which are highly likely to be outside the range). Thus, to craft a valid transaction that forges money, an attacker need only construct output coins with values that satisfy Equation 3. The difficulty of doing this depends on whether the protocol uses the aggregate range proof for all coins, or a single range proof for each coin.</p>

    <p class="text-gray-300">In the case where each output coin has its own range proof—and therefore each value can be chosen independently of all others—we can express this as a generalized birthday problem <em>[88]</em> with as many lists as there are output coins. For simplicity, assume the attacker uses 30 output coins. In expectation, as soon as each list has <span class="math">2^{\\lceil\\log p\\rceil/30}\\approx 2^{9}</span> elements, a solution will exist, but may be difficult to compute efficiently. By applying the <span class="math">k</span>-sum algorithm of <em>[88]</em> for <span class="math">k=30</span>, we can compute a solution in time roughly <span class="math">2^{43}</span> after computing roughly <span class="math">2^{43}</span> forged proofs for each of the 30 coins. (For simplicity, we ignore other choices an attacker could make, such as choosing <span class="math">S</span> or some of the input coins, that might make the attack less expensive.)</p>

    <p class="text-gray-300">Our attack relies on being able to choose each output coin’s value independently of all others. If MimbleWimble used the Bulletproofs aggregate range proof protocol, our generalized birthday attack would not obviously translate, since the last step of the weak Fiat-Shamir forgery would choose all 30 output coins at the same time. Surprisingly, we show that an even easier attack is possible against MimbleWimble if an aggregate range proof is used. (See Figure 6, which shows our attack against BP-ARP instantiated with a weak Fiat-Shamir transformation.) Note in the figure that in the last step, the public input <span class="math">\\mathbf{V}</span> is chosen by solving linear equations for the values and blinding factors. Adding in Equation 3 as another linear constraint on the values, we only have two constraints and 30 variables. Thus, the attacker can freely choose the values of 28 of the output coins, and must only set the last two so that the forged proof is valid and the balance equation holds. This attack is very fast, needing only to solve a small linear system in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">In both cases, once the attacker has crafted a valid transaction with forged output coins, they have created funds out of thin air by overflowing the balance equation. To spend newly-created coins whose values are outside the allowed range, the attacker would need to craft another weak F-S proof that overflows the balance equation again.</p>

    <h2 id="sec-27" class="text-2xl font-bold">V Plonk</h2>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">V-A Protocol Description</h3>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Constraint system.</h4>

    <p class="text-gray-300">Plonk handles fan-in two arithmetic circuits with unlimited fan-out. For such a circuit with <span class="math">n</span> gates and <span class="math">m</span> wires, we define a constraint system <span class="math">\\mathcal{C}=(\\mathcal{V},\\mathcal{Q})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}=(\\mathbf{a},\\mathbf{b},\\mathbf{c})\\in\\left([m]^{n}\\right)^{3}</span> consists of the left, right, and output sequence.</li>

      <li><span class="math">\\mathcal{Q}=(\\mathbf{q_{L}},\\mathbf{q_{R}},\\mathbf{q_{O}},\\mathbf{q_{M}},\\mathbf{q_{C}})\\in\\left(\\mathbb{F}^{n}\\right)^{5}</span> consists of selector vectors.</li>

    </ul>

    <p class="text-gray-300">Here <span class="math">\\mathbb{F}</span> is a finite field containing a subgroup <span class="math">H=\\langle\\omega\\rangle</span> of order <span class="math">n</span>. An assignment of values to wires <span class="math">\\mathbf{x}\\in\\mathbb{F}^{m}</span> satisfies <span class="math">\\mathcal{C}</span> if</p>

    <p class="text-gray-300"><span class="math">\\mathbf{q_{L}}\\circ\\mathbf{x_{a}}+\\mathbf{q_{R}}\\circ\\mathbf{x_{b}}+\\mathbf{q_{O}}\\circ\\mathbf{x_{c}}+\\mathbf{q_{M}}\\circ\\mathbf{x_{a}}\\circ\\mathbf{x_{b}}+\\mathbf{q_{C}}=\\mathbf{0}.</span></p>

    <p class="text-gray-300">To define a relation <span class="math">\\mathcal{R}</span> based on <span class="math">\\mathcal{C}</span>, we set a subset <span class="math">\\{1,\\ldots,\\ell\\}</span> of the wires to be public inputs <span class="math">\\mathsf{Pl}</span> and the rest to be the witness. The constraint system is set up so that the first <span class="math">\\ell</span> constraints are of the form <span class="math">\\mathbf{x_{a_{i}}}-\\mathsf{Pl}_{i}=0</span>, where <span class="math">\\mathbf{a}_{i}=i</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Converting to polynomial constraints.</h4>

    <p class="text-gray-300">Plonk proves the satisfiability of its constraint system by reducing to certain polynomial identities. We encode vectors into polynomials in the Lagrange basis, i.e. we define <span class="math">\\mathsf{q_{Y}}(X)=\\sum_{i=1}^{n}(\\mathbf{q_{Y}}),\\mathsf{L}_{i}(X)</span> for <span class="math">\\mathbf{Y}\\in\\{\\mathbf{\\hat{L}},\\mathbf{R},\\mathbf{O},\\mathbf{M},\\mathbf{C}\\}</span>. The public input and witness are encoded into three polynomials <span class="math">\\mathsf{p}(X)=\\sum_{i=1}^{n}\\mathbf{x_{p}},\\mathsf{L}_{i}(X)</span> for <span class="math">\\mathsf{p}\\in\\{\\mathsf{a},\\mathsf{b},\\mathsf{c}\\}</span>. Circuit satisfiability then reduces to checking that <span class="math">\\mathsf{eq}(X)</span> vanishes on <span class="math">H</span>, where</p>

    <p class="text-gray-300"><span class="math">\\mathsf{eq}(X)</span> <span class="math">=\\mathsf{a}(X)\\mathsf{b}(X)\\mathsf{q_{M}}(X)+\\mathsf{a}(X)\\mathsf{q_{L}}(X)+\\mathsf{b}(X)\\mathsf{q_{R}}(X)</span> <span class="math">\\qquad+\\mathsf{c}(X)\\mathsf{q_{O}}(X)+\\mathsf{Pl}(X)+\\mathsf{q_{C}}(X).</span></p>

    <p class="text-gray-300">We also need to check the consistency of the wiring. <em>[37]</em> defines a permutation <span class="math">\\sigma:[3n]\\rightarrow[3n]</span> that encodes this consistency check, converts it into polynomial constraints by letting the prover send a polynomial <span class="math">\\mathsf{z}(X)</span>, and then checks that the following holds over <span class="math">H</span>: (1) <span class="math">(\\mathsf{z}(X)-1)\\mathsf{L_{1}}(X)=0</span> and (2) <span class="math">\\mathsf{per}(X)=0</span>, where</p>

    <p class="text-gray-300"><span class="math">\\mathsf{per}(X)</span> <span class="math">=(\\mathsf{a}(X)+\\beta X+\\gamma)(\\mathsf{b}(X)+\\beta k_{1}X+\\gamma)</span> <span class="math">\\qquad(\\mathsf{c}(X)+\\beta k_{2}X+\\gamma)\\mathsf{z}(X)\\ -\\ (\\mathsf{a}(X)+\\beta\\mathsf{S}_{\\sigma 1}(X)+\\gamma)</span> <span class="math">\\qquad(\\mathsf{b}(X)+\\beta\\mathsf{S}_{\\sigma 2}(X)+\\gamma)(\\mathsf{c}(X)+\\beta\\mathsf{S}_{\\sigma 3}(X)+\\gamma)\\mathsf{z}(\\omega X).</span></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 7: The Plonk Polynomial IOP</p>

    <p class="text-gray-300">Here  <span class="math">\\mathsf{S}_{\\sigma j}(X)</span>  are uniquely defined based on  <span class="math">\\sigma</span>  for  <span class="math">j \\in \\{1,2,3\\}</span> ,  <span class="math">k_{1}, k_{2}</span>  are chosen such that  <span class="math">H \\neq k_{1}H \\neq k_{2}H</span> , and  <span class="math">\\beta, \\gamma</span>  are the verifier's challenges. The three vanishing claims over  <span class="math">H</span>  can be batched together with a challenge  <span class="math">\\alpha</span> , and by the prover sending a quotient polynomial  <span class="math">\\mathfrak{t}(X)</span>  satisfying</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {e q} (X) + \\alpha \\cdot \\mathsf {p e r} (X) + \\alpha^ {2} \\cdot (\\mathsf {z} (X) - 1) \\mathsf {L} _ {1} (X) = \\mathsf {Z} _ {\\mathsf {H}} (X) \\mathsf {t} (X), \\tag {4}</span></div>

    <p class="text-gray-300">where  <span class="math">Z_{\\mathsf{H}}(X) = \\prod_{h\\in H}(X - h)</span></p>

    <p class="text-gray-300">The Plonk polynomial IOP. We now describe Plonk as a polynomial IOP; see Figure 7 for the full protocol. By a slight abuse of notation, we use Plonk (and later Spartan) to refer to both the polynomial IOP and the interactive argument obtained after instantiating with a polynomial commitment scheme; the usage will be clear from context. The preprocessed polynomials consist of the selector polynomials  <span class="math">\\mathsf{q}_{\\mathsf{Y}}(X)</span>  for  <span class="math">\\mathsf{Y} \\in \\{\\mathsf{L}, \\mathsf{R}, \\mathsf{O}, \\mathsf{M}, \\mathsf{C}\\}</span> , and the polynomials  <span class="math">\\mathsf{S}_{\\sigma j}(X)</span>  for  <span class="math">j \\in \\{1,2,3\\}</span> . In the first round, the prover  <span class="math">\\mathcal{P}</span>  sends polynomials  <span class="math">\\mathsf{a}(X)</span> ,  <span class="math">\\mathsf{b}(X)</span> ,  <span class="math">\\mathsf{c}(X)</span>  encoding the public input and witness. The verifier  <span class="math">\\mathcal{V}</span>  responds with challenges  <span class="math">\\beta, \\gamma \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>  used in the permutation argument. In the second round,  <span class="math">\\mathcal{P}</span>  sends the permutation polynomial  <span class="math">\\mathsf{z}(X)</span> , and  <span class="math">\\mathcal{V}</span>  responds with challenge  <span class="math">\\alpha \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>  used in batching the polynomial checks. In the third round,  <span class="math">\\mathcal{P}</span>  sends the quotient polynomial  <span class="math">\\mathsf{t}(X)</span> , broken down into three parts  <span class="math">\\mathsf{t}_{\\mathsf{lo}}(X)</span> ,  <span class="math">\\mathsf{t}_{\\mathsf{mid}}(X)</span> ,  <span class="math">\\mathsf{t}_{\\mathsf{hi}}(X)</span>  of small degree to be compatible with the polynomial commitment scheme. (To achieve zero-knowledge, all the polynomials sent here by  <span class="math">\\mathcal{P}</span>  are blinded.) In the query phase,  <span class="math">\\mathcal{V}</span>  samples an evaluation point  <span class="math">\\mathfrak{z} \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> , then checks the polynomial identity (4) at  <span class="math">\\mathfrak{z}</span>  by querying all polynomials sent by  <span class="math">\\mathcal{P}</span>  at that point.</p>

    <p class="text-gray-300">Our exposition differs from [37], which described Plonk with certain optimizations specific to the KZG polynomial commitment scheme [56]. This does not affect the applicability of our attack, as discussed next.</p>

    <h2 id="sec-31" class="text-2xl font-bold">B. Attack Explanation</h2>

    <p class="text-gray-300">We consider the weak Fiat-Shamir variant  <span class="math">\\mathsf{Plonk}_{\\mathsf{wFS}}</span> , which is the non-interactive argument obtained by applying the transformation in Section II-F to the Plonk polynomial IOP. Our attack is presented in Figure 8; there, we assume that Plonk is instantiated with a polynomial commitment scheme supporting polynomials of degree up to  <span class="math">n + 5</span> , and denote by  <span class="math">[\\mathsf{p}]</span>  the commitment to a polynomial  <span class="math">\\mathsf{p}(X)</span> . Since the public input  <span class="math">\\mathsf{PI}</span>  is not bound to the challenges, our cheating prover will do the following: (1) in the first three rounds, send commitments to arbitrarily chosen polynomials, (2) provide a proof of correct evaluations for all polynomials at the challenge point, and (3) set the public input  <span class="math">\\mathsf{PI}</span>  to satisfy the verifier's check.</p>

    <p class="text-gray-300">Specializing our attack to [37]. The Plonk protocol in [37] leverages the homomorphic property of KZG to make the following optimizations. First, the prover only needs to send evaluations  <span class="math">(\\mathsf{a}(\\mathfrak{z}),\\mathsf{b}(\\mathfrak{z}),\\mathsf{c}(\\mathfrak{z}),\\mathsf{S}_{\\sigma 1}(\\mathfrak{z}),\\mathsf{S}_{\\sigma 2}(\\mathfrak{z}),\\mathsf{z}(\\omega \\mathfrak{z}))</span>  and the verifier will homomorphically compute a commitment to the linearized polynomial  <span class="math">\\mathsf{r}(X)</span> . Instead of checking that Equation 4 holds at  <span class="math">\\mathfrak{z}</span> , the verifier only needs to check  <span class="math">\\mathsf{r}(\\mathfrak{z}) = 0</span> . Second, the evaluation checks can be batched together with challenges  <span class="math">u,v\\stackrel {\\S}{\\leftarrow}\\mathbb{F}</span> . Our attack easily specializes to these optimizations, with the only change in step 7. In that step, the malicious prover will compute evaluations  <span class="math">(\\mathsf{a}(\\mathfrak{z}),\\mathsf{b}(\\mathfrak{z}),\\mathsf{c}(\\mathfrak{z}),\\mathsf{S}_{\\sigma 1}(\\mathfrak{z}),\\mathsf{S}_{\\sigma 2}(\\mathfrak{z}),\\mathsf{z}(\\omega \\mathfrak{z}))</span>  and append them to  <span class="math">\\pi</span> , query challenge  <span class="math">v\\gets \\mathsf{H}(\\pi)</span> , then compute a batched proof of correct evaluations and append it to  <span class="math">\\pi</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize empty proof  <span class="math">\\pi = \\epsilon</span> . Compute preprocessed polynomials  <span class="math">q_{Y}(X)</span>  for  <span class="math">Y \\in \\{L, R, O, M, C\\}</span>  and  <span class="math">S_{\\sigma j}(X)</span>  for  <span class="math">j \\in \\{1, 2, 3\\}</span> . Compute their commitments  <span class="math">\\{[q_{Y}]\\}</span> ,  <span class="math">\\{[S_{\\sigma j}]\\}</span>  and append them to pp.</li>

      <li>Choose arbitrary polynomials  <span class="math">a(X), b(X), c(X) \\in \\mathbb{F}^{&amp;lt;n}[X]</span> . Compute  <span class="math">[a], [b], [c]</span>  and append them to  <span class="math">\\pi</span> .</li>

      <li>Query challenges  <span class="math">\\beta, \\gamma \\gets H(\\pi)</span> .</li>

      <li>Choose an arbitrary polynomial  <span class="math">z(X) \\in \\mathbb{F}^{&amp;lt;n}[X]</span> . Compute  <span class="math">[z]</span>  and append it to  <span class="math">\\pi</span> .</li>

      <li>Query challenge  <span class="math">\\alpha \\gets H(\\pi)</span> .</li>

      <li>Choose arbitrary polynomials  <span class="math">t_{lo}(X), t_{mid}(X) \\in \\mathbb{F}^{&amp;lt;n}[X]</span>  and  <span class="math">t_{lo}(X) \\in \\mathbb{F}^{&amp;lt;n+5}[X]</span> . Compute  <span class="math">[t_{lo}]</span> ,  <span class="math">[t_{mi}]</span> ,  <span class="math">[t_{lo}]</span>  and append them to  <span class="math">\\pi</span> .</li>

      <li>Query challenge  <span class="math">j \\gets H(\\pi)</span> .</li>

      <li>Compute evaluations at  <span class="math">j</span>  of polynomials  <span class="math">\\{q_{Y}(X)\\}_{Y \\in \\{L, R, O, M, C\\}}</span> ,  <span class="math">\\{S_{\\sigma j}(X)\\}_{j \\in [3]}</span> ,  <span class="math">a(X)</span> ,  <span class="math">b(X)</span> ,  <span class="math">c(X)</span> ,  <span class="math">z(X)</span> ,  <span class="math">z(\\omega X)</span> ,  <span class="math">t_{lo}(X)</span> ,  <span class="math">t_{mid}(X)</span> ,  <span class="math">t_{lo}(X)</span> , along with proofs of correct evaluations. Append evaluations and their proofs to  <span class="math">\\pi</span> .</li>

      <li>Set the public input  <span class="math">PI \\in \\mathbb{F}^{\\ell}</span>  to satisfy the equation</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 1} ^ {\\ell} \\mathrm {P I} _ {i} \\cdot \\mathrm {L} _ {i} (\\mathrm {j}) = \\mathrm {Z} _ {\\mathrm {H}} (\\mathrm {j}) \\left(\\mathrm {t} _ {\\mathrm {l o}} (\\mathrm {j}) + \\mathrm {j} ^ {n} \\mathrm {t} _ {\\mathrm {m i d}} (\\mathrm {j}) + \\mathrm {j} ^ {2 n} \\mathrm {t} _ {\\mathrm {l o}} (\\mathrm {j})\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\mathrm {e q} ^ {\\prime} (\\mathrm {j}) - \\alpha \\cdot \\operatorname {p e r} (\\mathrm {j}) - \\alpha^ {2} \\cdot (\\mathrm {z} (\\mathrm {j}) - 1) \\mathrm {L} _ {1} (\\mathrm {j}), \\tag {5}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {e q} ^ {\\prime} (\\mathbf {j}) = \\mathbf {a} (\\mathbf {j}) \\mathbf {b} (\\mathbf {j}) \\mathbf {q} _ {M} (\\mathbf {j}) + \\mathbf {a} (\\mathbf {j}) \\mathbf {q} _ {L} (\\mathbf {j}) + \\mathbf {b} (\\mathbf {j}) \\mathbf {q} _ {R} (\\mathbf {j}) \\\\ + \\mathbf {c} (\\mathbf {j}) \\mathbf {q} _ {G} (\\mathbf {j}) + \\mathbf {q} _ {C} (\\mathbf {j}). \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">(\\mathsf{PI},\\pi)</span> .</li>

    </ol>

    <p class="text-gray-300">Fig. 8: Weak Fiat-Shamir Attack Against  <span class="math">\\mathsf{Plonk}_{\\mathsf{wFS}}</span></p>

    <p class="text-gray-300">Efficiency. Asymptotically, our attack runs in time  <span class="math">O(n)</span> , which is faster than the  <span class="math">O(n \\log n)</span>  time of generating honest proofs due to the use of FFTs. When  <span class="math">\\ell \\geq 2</span> , given a proof generated according to our attack, one can reuse the same proof for different choices of PI as long as PI is chosen to satisfy Equation 5.</p>

    <p class="text-gray-300">We implemented our attack in 300 lines of JavaScript and verified our proofs are accepted by snarkjs. We benchmarked the forged proof generation on the same machine as our Bulletproofs attack in Section IV. Our implementation was able to generate proofs for constraint systems of size 256 in 5167 milliseconds and for constraint systems of size 2048 in 8057 milliseconds.</p>

    <p class="text-gray-300">Provable insecurity. We show that our attack breaks the knowledge soundness of  <span class="math">\\mathrm{Plonk}_{\\mathrm{wFS}}</span> , assuming the Plonk relation  <span class="math">\\mathcal{R}</span>  satisfies a variant of worst-case hardness.</p>

    <p class="text-gray-300">Definition 5: A relation  <span class="math">\\mathcal{R} \\subseteq \\mathbb{F}^{\\ell} \\times \\mathbb{F}^{n}</span>  satisfies all-but-one (worst-case) hardness (ABO-H) if there exists  <span class="math">i \\in [\\ell]</span>  and  <span class="math">\\mathsf{PI}[\\hat{i}] \\in \\mathbb{F}^{\\ell-1}</span>  such that for all PPT adversaries  <span class="math">\\mathcal{A}</span> , the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {R}} ^ {\\mathrm {A B O - H}} (\\mathcal {A}) := \\Pr \\left[ (\\mathrm {P I}, w) \\in \\mathcal {R} \\mid (\\mathrm {P I} _ {i}, w) \\leftarrow \\mathcal {A} (\\mathrm {P I} [ \\hat {i} ]) \\right].</span></div>

    <p class="text-gray-300">Here  <span class="math">\\mathsf{PI}[\\hat{i}]</span>  denotes the public input without the  <span class="math">i</span> th entry.</p>

    <p class="text-gray-300">We briefly comment on the strength of this hardness notion.</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{R}</span>  is not hard in the worst case, any proof system for  <span class="math">\\mathcal{R}</span>  trivially satisfies knowledge soundness, since there exists a PPT extractor  <span class="math">\\mathcal{E}</span>  that brute forces the witness from any public input. Therefore, worst-case hardness is a necessary assumption; our notion is slightly stronger than the worst-case hardness for  <span class="math">\\mathcal{R}</span>  by requiring that for some  <span class="math">i\\in [\\ell ]</span>  , worst-case hardness holds for a related relation  <span class="math">\\mathcal{R}_i</span>  that puts  <span class="math">\\mathsf{PI}_i</span>  as part of the witness instead of the public input. We expect ABO-H to hold for many relations in practice, such as the relation for the pre-image of a hash.</p>

    <p class="text-gray-300">Theorem 6: Assume the Plonk relation  <span class="math">\\mathcal{R}</span>  satisfies ABO-H. Then  <span class="math">\\mathrm{Plonk}_{\\mathrm{wFS}}</span>  is not knowledge sound.</p>

    <p class="text-gray-300">The intuition for the proof is as follows. Note that for any  <span class="math">i \\in [\\ell]</span>  and  <span class="math">x \\in \\mathbb{F}^{\\ell-1}</span> , the malicious prover in our attack can construct an accepting proof with  <span class="math">\\mathsf{PI}[\\hat{i}] = x</span> . Thus, an extractor would have to find a witness for that choice of  <span class="math">\\mathsf{PI}[\\hat{i}]</span> , which breaks the ABO-H property of  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Proof: Assume that the Plonk relation  <span class="math">\\mathcal{R}</span>  satisfies ABO-H, and let  <span class="math">i\\in [\\ell ]</span> <span class="math">x\\in \\mathbb{F}^{\\ell -1}</span>  be the hard instance for  <span class="math">\\mathcal{R}</span> . Denote by  <span class="math">\\mathcal{P}^<em></span>  the malicious prover for the attack described in Figure 8, with the following specification for step 8:  <span class="math">\\mathcal{P}^</em></span>  sets  <span class="math">\\mathsf{PI}[\\hat{i} ] = x</span> , then computes the unique value of  <span class="math">\\mathsf{PI}_i</span>  that satisfies Equation 5. We will show that for every extractor  <span class="math">\\mathcal{E}</span> , there exists an adversary  <span class="math">\\mathcal{A}</span> , nearly as efficient as  <span class="math">\\mathcal{E}</span> , against ABO-H of  <span class="math">\\mathcal{R}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathsf {K S} _ {1, \\mathsf {P l o n k} _ {\\mathsf {w F S}}, \\mathcal {R}} ^ {\\mathcal {E}, \\mathcal {P} ^ {*}} \\right] \\leq \\mathbf {A d v} _ {\\mathcal {R}} ^ {\\mathsf {A B O - H}} (\\mathcal {A}).</span></div>

    <p class="text-gray-300">Similar to the above proof, this will imply that  <span class="math">\\mathrm{Plonk}_{\\mathrm{wFS}}</span>  is not knowledge sound. The adversary  <span class="math">\\mathcal{A}</span>  works as follows.  <span class="math">\\mathcal{A}</span>  receives  <span class="math">x</span>  from the ABO-H game.  <span class="math">\\mathcal{A}</span>  then computes the public paramters pp (which includes the preprocessed polynomial commitments), and runs  <span class="math">\\mathcal{P}^<em></span>  once to get a pair  <span class="math">(\\mathsf{PI},\\pi)</span>  with  <span class="math">\\mathsf{PI}[\\hat{i} ] = x</span> . It then sends  <span class="math">(\\mathcal{P}^{</em>},\\mathsf{pp},\\mathsf{PI},\\pi)</span>  to  <span class="math">\\mathcal{E}</span> , and once  <span class="math">\\mathcal{E}</span>  returns a witness  <span class="math">w</span> ,  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">(\\mathsf{PI},w)</span> . We can easily see that if game  <span class="math">\\mathsf{KS}_{1,\\mathrm{Plonk}_{\\mathrm{wFS}},\\mathcal{R}}^{\\mathcal{E},\\mathcal{P}^*}</span>  outputs 1, then  <span class="math">\\mathcal{E}</span>  outputs a valid witness; hence,  <span class="math">\\mathcal{A}</span>  wins the ABO-H game as well.</p>

    <p class="text-gray-300">Affected implementations. We surveyed 12 implementations of Plonk to determine if they were vulnerable to an attack against their Fiat-Shamir transformations. Of the 12 implementations surveyed, we found 5 to be vulnerable, 4 of which have now been fixed. To understand how our attack on the soundness of Plonk could impact applications using vulnerable implementations, we investigate the application of one of the vulnerable implementations we found: Dusk Network. We selected Dusk because it is a nontrivial application of Plonk for which we found a vulnerable implementation, and it's fairly well-documented. The Dusk Network protocol is currently in its Daylight Testnet launch with a full deployment of the protocol on the roadmap for the near future.</p>

    <p class="text-gray-300">Dusk Network background. Dusk Network is a privacy-preserving distributed ledger protocol [32]. It uses a UTXO-based transaction model called Phoenix, which works over "notes" stored on the ledger. (We will explain only the details</p>

    <p class="text-gray-300">relevant for our attack.) For simplicity, we can think of each note as being a commitment to a value. A transaction is defined by a set of input notes  <span class="math">(\\mathrm{in}_1,\\dots ,\\mathrm{in}_m)</span> , a set of (newly-created) output notes  <span class="math">(\\mathrm{out}_1,\\dots ,\\mathrm{out}_n)</span> , and a zero-knowledge proof of correctness  <span class="math">\\pi</span>  generated using Plonk. To spend each input note, the payer must reveal its nullifier—a random, unique identifier of an input that prevents double-spending, but does not reveal the input itself. In Dusk, the nullifier is computed as a hash of the note's index in the Merkle tree and the opening of its commitment.</p>

    <p class="text-gray-300">The transaction circuit (described in more detail in [30], §3) takes as public inputs the Merkle root, the output notes, and the nullifiers of the input notes. It takes as private input the input notes, their openings, their Merkle paths, and the openings of the output notes. It verifies that each nullifier corresponds to a valid input note, each input note has a valid path to the Merkle root, the output commitment is well-formed, and that the sums of the values of the inputs and outputs are equal.</p>

    <p class="text-gray-300">Attacking Dusk Network. Our attack on  <span class="math">\\mathrm{Plonk}_{\\mathrm{wFS}}</span>  's weak Fiat-Shamir transformation lets us obtain a satisfying proof for an arbitrary witness by setting the public input to be a specific value that will satisfy the verifier's check. Notably, our attack actually allows for an attacker to set all but one of the public inputs to arbitrary values; the last public input must be set to the (unique) value that causes the verifier's check to pass. To use our attack against Dusk, then, we must make sure that there is some public input that can be set arbitrarily and is not checked elsewhere in the protocol. We observe that the nullifier is a natural choice for this—its only external constraint is a check that it has not been used by any previous transaction; further, by design it is a random-looking value.</p>

    <p class="text-gray-300">Thus, an attacker can use our attack to create verifying transactions that do not satisfy the circuit's constraints. One clear way to exploit this is to steal funds from the Dusk Network: an attacker can create a transaction that spends one input and sends outputs with arbitrarily large values to themselves. Because the output coins can be chosen freely, the attacker can ensure the output notes are well-formed and can be later traded for other coins.</p>

    <p class="text-gray-300">Constraint system. Spartan proves the satisfiability of rank-one constraint systems (R1CS). A R1CS relation is defined by a tuple  <span class="math">(\\mathbb{F},A,B,C,m,n,\\ell)</span>  where  <span class="math">A,B,C\\in \\mathbb{F}^{m\\times m}</span>  are matrices, each with at most  <span class="math">n = \\Omega (m)</span>  non-zero entries, and  <span class="math">m\\geq \\ell +1</span>  . Given a R1CS public input  <span class="math">\\mathsf{PI}\\in \\mathbb{F}^{\\ell}</span>  , a R1CS witness is a vector  <span class="math">w\\in \\mathbb{F}^{m - \\ell -1}</span>  such that if  <span class="math">Z = (\\mathsf{PI},1,w)</span>  then  <span class="math">(A\\cdot Z)\\circ (B\\cdot Z) = C\\cdot Z</span>  . Spartan also requires that  <span class="math">m = 2^{\\mu}</span>  is a power of two, and  <span class="math">\\ell = m / 2 - 1</span></p>

    <p class="text-gray-300">Converting to polynomial constraints. We interpret the matrices  <span class="math">A, B, C</span>  as functions from  <span class="math">\\{0,1\\}^{\\mu} \\times \\{0,1\\}^{\\mu}</span>  to  <span class="math">\\mathbb{F}</span> , and similarly  <span class="math">Z: \\{0,1\\}^{\\mu} \\to \\mathbb{F}</span> , by writing the indices as their</p>

    <p class="text-gray-300">Protocol Notation.</p>

    <div class="my-4 text-center"><span class="math-block">e \\leftarrow \\langle \\mathcal {P} _ {\\mathrm {S C}} (p), \\mathcal {V} _ {\\mathrm {S C}} (r) \\rangle (\\mu , d, T),</span></div>

    <p class="text-gray-300">where  <span class="math">p\\in \\mathbb{F}^{\\leq d}[X_1,\\ldots ,X_\\mu ]</span>  satisfies  <span class="math">\\sum_{x\\in \\{0,1\\}^{\\mu}}g(x) = T</span>  , and  <span class="math">r = (r_1,\\dots ,r_\\mu)\\in \\mathbb{F}^\\mu</span>  is  <span class="math">\\nu_{\\mathrm{SC}}</span>  's randomness.</p>

    <p class="text-gray-300">Interaction Phase. For  <span class="math">i = 1,\\dots ,\\mu</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">p _ {i} (X) = \\sum_ {x _ {i + 1}, \\dots , x _ {\\mu} \\in \\{0, 1 \\}} p \\left(r _ {1}, \\dots , r _ {i - 1}, X, x _ {i + 1}, \\dots , x _ {\\mu}\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends  <span class="math">r_i\\stackrel {\\S}{\\leftarrow}\\mathbb{F}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  checks that  <span class="math">p_1(0) + p_1(1) = T</span></li>

      <li><span class="math">\\mathcal{V}</span>  checks that  <span class="math">p_i(0) + p_i(1) = p_{i - 1}(r_{i - 1})</span>  for  <span class="math">2\\leq i\\leq \\mu</span></li>

    </ol>

    <p class="text-gray-300">Output.  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{V}</span>  outputs  <span class="math">e = p_{\\mu}(r_{\\mu})</span>  supposedly equal to  <span class="math">p(r_1, \\ldots, r_\\mu)</span> .</p>

    <p class="text-gray-300">Fig. 9: The Sumcheck Protocol</p>

    <p class="text-gray-300">Preprocessed Polynomials. Multilinear extensions  <span class="math">\\widetilde{A}(X,Y)</span> ,  <span class="math">\\widetilde{B}(X,Y)</span> ,  <span class="math">\\widetilde{C}(X,Y)</span>  of R1CS matrices  <span class="math">A, B, C \\in \\mathbb{F}^{m \\times m}</span> .</p>

    <p class="text-gray-300">Public Input.  <span class="math">\\mathsf{PI}\\in \\mathbb{F}^{m / 2 - 1}</span>  . Witness.  <span class="math">w\\in \\mathbb{F}^{m / 2}</span></p>

    <p class="text-gray-300">Interaction Phase. Let  <span class="math">\\mu = \\log m</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  sends the multilinear extension  <span class="math">\\widetilde{w}</span>  of the witness  <span class="math">w</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  sends challenge  <span class="math">\\tau \\stackrel{\\S}{\\leftarrow} \\mathbb{F}^{\\mu}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  engage in a sumcheck protocol for</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e _ {x} \\leftarrow \\langle \\mathcal {P} _ {\\mathrm {S C}} \\left(\\mathcal {G} _ {\\mathrm {P I}, \\tau}\\right), \\mathcal {V} _ {\\mathrm {S C}} \\left(r _ {x}\\right) \\rangle (\\mu , 3, 0),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{G}_{\\mathrm{PI},\\tau}(X)</span>  is defined as in Equation 6.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">v_{A} = \\overline{A} (r_{x})</span> <span class="math">v_{B} = \\overline{B} (r_{x})</span> <span class="math">v_{C} = \\overline{C} (r_{x})</span>  and sends  <span class="math">(v_{A},v_{B},v_{C})</span>  to  <span class="math">\\nu</span></li>

      <li><span class="math">\\mathcal{V}</span>  sends challenges  <span class="math">r_A, r_B, r_C \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  engage in another sumcheck protocol for</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e _ {y} \\leftarrow \\langle \\mathcal {P} _ {\\mathrm {S C}} \\left(\\mathcal {H} _ {r _ {x}}\\right), \\mathcal {V} _ {\\mathrm {S C}} \\left(r _ {y}\\right) \\rangle (\\mu , 2, T),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{H}_{r_x}(Y)</span>  and  <span class="math">T</span>  are defined as in Equation 7.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reject if either of the sumcheck instances fail.</li>

      <li>Check that  <span class="math">e_x \\stackrel{?}{=} (v_A \\cdot v_B - v_C) \\cdot \\widetilde{eq}(r_x, \\tau)</span> .</li>

      <li>Query  <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C}</span>  at  <span class="math">(r_x,r_y)</span>  and receive evaluations  <span class="math">v_{1},v_{2},v_{3}</span>  respectively.</li>

      <li>Query  <span class="math">\\widetilde{w}</span>  at  <span class="math">(r_y)_{[1:]}</span>  and receive evaluation  <span class="math">v_w</span> .</li>

      <li>Check that  <span class="math">e_y \\stackrel{?}{=} (r_A \\cdot v_1 + r_B \\cdot v_2 + r_C \\cdot v_3) \\cdot v_Z</span> , where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">v _ {Z} = \\left(\\left(r _ {y}\\right) _ {0} \\cdot \\widetilde {\\left(\\mathrm {P I} , 1\\right)} \\left(\\left(r _ {y}\\right) _ {[ 1: ]}\\right) + \\left(1 - \\left(r _ {y}\\right) _ {0}\\right) \\cdot v _ {w}\\right).</span></div>

    <p class="text-gray-300">Fig. 10: The Spartan Polynomial IOP</p>

    <p class="text-gray-300">binary representation. We then consider the multilinear extensions  <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C},\\widetilde{Z}</span>  of these functions, and define the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {F} _ {\\mathrm {P I}} (X) = \\overline {{A}} (X) \\cdot \\overline {{B}} (X) - \\overline {{C}} (X),</span></div>

    <p class="text-gray-300">where  <span class="math">\\overline{M} (X) = \\sum_{y\\leftarrow \\{0,1\\} ^\\mu}\\widetilde{M} (X,y)\\cdot \\widetilde{Z} (y)</span>  for</p>

    <p class="text-gray-300"><span class="math">M\\in\\{A,B,C\\}</span>. Note that <span class="math">\\mathcal{F}_{\\mathsf{PI}}(X)</span> vanishes on <span class="math">\\{0,1\\}^{\\mu}</span> if and only if <span class="math">Z</span> satisfies the R1CS relation. We turn this vanishing condition into a sumcheck instance by defining <span class="math">\\mathcal{G}_{\\mathsf{PI},\\tau}(X)=\\mathcal{F}_{\\mathsf{PI}}(X)\\cdot\\widetilde{\\mathsf{eq}}(X,\\tau)</span> for a random <span class="math">\\tau\\in\\mathbb{F}^{\\mu}</span>, supplied by the verifier. The goal is then to prove that</p>

    <p class="text-gray-300"><span class="math">\\sum_{x\\in\\{0,1\\}^{\\mu}}\\mathcal{G}_{\\mathsf{PI},\\tau}(x)=0.</span> (6)</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">The Spartan polynomial IOP.</h4>

    <p class="text-gray-300">We describe the full protocol in Figure 10, which uses the sumcheck protocol described in Figure 9. The preprocessed polynomials consist of the multilinear extensions <span class="math">\\widetilde{A}(X,Y),\\widetilde{B}(X,Y),\\widetilde{C}(X,Y)</span> of the R1CS matrices <span class="math">A,B,C</span>. In the first round, the prover <span class="math">\\mathcal{P}</span> sends the multilinear extension <span class="math">\\widetilde{w}</span>, and <span class="math">\\mathcal{V}</span> sends challenge <span class="math">\\tau\\xleftarrow{\\S}\\mathbb{F}^{\\mu}</span>. Both parties then engage in a sumcheck protocol to prove Equation 6; after this <span class="math">\\mathcal{V}</span> receives an evaluation <span class="math">e_{x}</span> supposedly equal to <span class="math">\\mathcal{G}_{\\mathsf{PI},\\tau}(r_{x})</span>, where <span class="math">r_{x}</span> is <span class="math">\\mathcal{V}</span>’s randomness during the run of sumcheck. Since <span class="math">\\mathcal{V}</span> cannot evaluate this itself, both parties engage in another run of sumcheck. <span class="math">\\mathcal{P}</span> sends three values <span class="math">v_{A},v_{B},v_{C}</span> supposedly equal to <span class="math">\\overline{A}(r_{x})</span>, <span class="math">\\overline{B}(r_{x})</span>, <span class="math">\\overline{C}(r_{x})</span> respectively, and <span class="math">\\mathcal{V}</span> checks that</p>

    <p class="text-gray-300"><span class="math">e_{x}=(v_{A}\\cdot v_{B}-v_{C})\\cdot\\widetilde{\\mathsf{eq}}(r_{x},\\tau).</span></p>

    <p class="text-gray-300">Next, <span class="math">\\mathcal{V}</span> responds with three challenges <span class="math">r_{A},r_{B},r_{C}\\xleftarrow{\\S}\\mathbb{F}</span> to batch three sumcheck instances into one. The second sumcheck instance is then</p>

    <p class="text-gray-300"><span class="math">\\sum_{y\\in\\{0,1\\}^{\\mu}}\\mathcal{H}_{r_{x}}(y)=T,</span> (7)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}_{r_{x}}(Y)=\\left(r_{A}\\widetilde{A}(r_{x},Y)+r_{B}\\widetilde{B}(r_{x},Y)+r_{C}\\widetilde{C}(r_{x},Y)\\right)\\widetilde{Z}(Y),</span> <span class="math">T=r_{A}\\cdot v_{A}+r_{B}\\cdot v_{B}+r_{C}\\cdot v_{C}.</span></p>

    <p class="text-gray-300">After running sumcheck on Equation 7, <span class="math">\\mathcal{V}</span> receives an evaluation <span class="math">e_{y}</span> supposedly equal to <span class="math">(r_{A}\\widetilde{A}(r_{x},r_{y})+r_{B}\\widetilde{B}(r_{x},r_{y})+r_{C}\\widetilde{C}(r_{x},r_{y}))\\widetilde{Z}(r_{y})</span>, for <span class="math">\\mathcal{V}</span>’s randomness <span class="math">r_{y}</span> during the run of sumcheck. <span class="math">\\mathcal{V}</span> now queries <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C}</span> at <span class="math">(r_{x},r_{y})</span> for evaluations <span class="math">v_{1},v_{2},v_{3}</span>, and <span class="math">\\widetilde{w}</span> at <span class="math">(r_{y})_{[1:]}</span> for evaluation <span class="math">v_{w}</span>, and checks that</p>

    <p class="text-gray-300"><span class="math">e_{y}=(r_{A}\\cdot v_{1}+r_{B}\\cdot v_{2}+r_{C}\\cdot v_{3})\\cdot v_{Z},</span> (8)</p>

    <p class="text-gray-300">where <span class="math">v_{Z}=\\left((r_{y})_{0}\\cdot\\widetilde{(\\mathsf{PI},1)}((r_{y})_{[1:]})+(1-(r_{y})_{0})\\cdot v_{w}\\right)</span>. <span class="math">\\mathcal{V}</span> also performs checks for each sumcheck instance and rejects the results if either of the instances rejects them.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">III-B Attack Explanation</h3>

    <p class="text-gray-300">Figure 11 gives an attack against <span class="math">\\mathsf{Spartan}_{\\mathsf{wFS}}</span>, which is the non-interactive argument obtained by applying the transformation in Section II-F to the <span class="math">\\mathsf{Spartan}</span> polynomial IOP described in Figure 10. The attack is similar to the one against <span class="math">\\mathsf{Plonk}_{\\mathsf{wFS}}</span>: first, the malicious prover <span class="math">\\mathcal{P}^{<em>}</span> chooses polynomials (including witnesses) that will satisfy all verification equations except Equation 8. Then, to finish <span class="math">\\mathcal{P}^{</em>}</span> crafts <span class="math">\\mathsf{PI}</span> according to Equation 9 so as to satisfy this final check.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute commitments <span class="math">[\\widetilde{A}],[\\widetilde{B}],[\\widetilde{C}]</span> and append them to <span class="math">\\mathsf{pp}</span>. Initialize empty proof <span class="math">\\pi=\\epsilon</span>.</li>

      <li>Choose arbitrary multilinear polynomial <span class="math">\\widetilde{w}\\in\\mathbb{F}[\\mu]</span>, compute <span class="math">[w]</span> and append it to <span class="math">\\pi</span>.</li>

      <li>Query challenge <span class="math">\\tau\\leftarrow\\mathsf{H}(\\pi)</span>.</li>

      <li>For each of the two sumcheck instances:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In each round <span class="math">i\\in[\\mu]</span>, sample an arbitrary polynomial <span class="math">\\mathsf{p}_{i}(X)</span> of appropriate degree that satisfies</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{p}_{i}(0)+\\mathsf{p}_{i}(1)=\\mathsf{p}_{i-1}(r_{i-1}).</span></p>

    <p class="text-gray-300">Compute <span class="math">[\\mathsf{p}_{i}]</span> and append it to <span class="math">\\pi</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query challenge <span class="math">r_{i}\\leftarrow\\mathsf{H}(\\pi)</span>.</li>

      <li>Between the two sumchecks, choose arbitrary <span class="math">v_{A},v_{B},v_{C}\\in\\mathbb{F}</span> such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">e_{x}=(v_{A}\\cdot v_{B}-v_{C})\\cdot\\widetilde{\\mathsf{eq}}(r_{x},\\tau).</span></p>

    <p class="text-gray-300">Query challenges <span class="math">r_{A},r_{B},r_{C}\\leftarrow\\mathsf{H}(\\pi)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute evaluations <span class="math">v_{1}=\\widetilde{A}(r_{x},r_{y})</span>, <span class="math">v_{2}=\\widetilde{B}(r_{x},r_{y})</span>, <span class="math">v_{3}=\\widetilde{C}(r_{x},r_{y})</span>, <span class="math">v_{w}=\\widetilde{w}((r_{y})_{[1:]})</span> and valid proofs of openings. Append evaluations and opening proofs to <span class="math">\\pi</span>.</li>

      <li>Set the public input <span class="math">\\mathsf{PI}\\in\\mathbb{F}^{\\ell}</span> to satisfy the equation</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\widetilde{(\\mathsf{PI},1)}((r_{y})_{[1:]})=(r_{y})_{0}^{-1}\\cdot(v_{Z}-(1-(r_{y})_{0})\\cdot v_{w})\\,,</span> (9)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">v_{Z}=e_{y}\\cdot(r_{A}\\cdot v_{1}+r_{B}\\cdot v_{2}+r_{C}\\cdot v_{3})^{-1}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\mathsf{PI},\\pi)</span>.</li>

    </ol>

    <p class="text-gray-300">Figure 11: Weak Fiat-Shamir Attack Against <span class="math">\\mathsf{Spartan}_{\\mathsf{wFS}}</span></p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Provable insecurity.</h4>

    <p class="text-gray-300">Our attack against <span class="math">\\mathsf{Spartan}_{\\mathsf{wFS}}</span> satisfies the same properties as with our attack on <span class="math">\\mathsf{Plonk}_{\\mathsf{wFS}}</span>—namely that a malicious prover can arbitrarily choose all entries of <span class="math">\\mathsf{PI}</span> except one. Thus, we can prove that our attack breaks the knowledge soundness of <span class="math">\\mathsf{Spartan}_{\\mathsf{wFS}}</span> assuming the same ABO-H property of the R1CS relation <span class="math">\\mathcal{R}</span>. The proof is similar to that of Theorem 6.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 7</h6>

    <p class="text-gray-300">Assume the R1CS relation <span class="math">\\mathcal{R}</span> satisfies ABO-H. Then <span class="math">\\mathsf{Spartan}_{\\mathsf{wFS}}</span> is not knowledge sound.</p>

    <p class="text-gray-300">Proof: Assume that the R1CS relation <span class="math">\\mathcal{R}</span> satisfies ABO-H, and let <span class="math">i\\in[\\ell]</span>, <span class="math">x\\in\\mathbb{F}^{\\ell-1}</span> be the hard instance for <span class="math">\\mathcal{R}</span>. Denote by <span class="math">\\mathcal{P}^{<em>}</span> the malicious prover for the attack described in Figure 11, with the following specification for step 8: <span class="math">\\mathcal{P}^{</em>}</span> sets <span class="math">\\mathsf{PI}[\\overset{\\rightharpoonup}{i}]=x</span>, then computes the unique value of <span class="math">\\mathsf{PI}_{i}</span> that satisfies Equation 9. Note that <span class="math">\\mathcal{P}^{*}</span> can do this since we can write</p>

    <p class="text-gray-300"><span class="math">\\widetilde{(\\mathsf{PI},1)}(r)</span> <span class="math">=\\sum_{y\\in\\{0,1\\}^{\\mu-1}}(\\mathsf{PI},1)(y)\\cdot\\widetilde{\\mathsf{eq}}(r,y)</span> <span class="math">=\\sum_{k=1}^{m/2-2}\\mathsf{PI}_{k}\\cdot\\widetilde{\\mathsf{eq}}(r,\\mathsf{bin}(k))+\\widetilde{\\mathsf{eq}}(r,\\mathsf{bin}(m/2-1)).</span></p>

    <p class="text-gray-300">Here we denote <span class="math">r=(r_{y})_{[1:]}</span>, and <span class="math">\\mathsf{bin}(k)</span> is the binary representation of <span class="math">k</span>. Since this is a linear equation in terms of <span class="math">\\mathsf{PI}_{k}</span>’s, to solve <span class="math">\\widetilde{(\\mathsf{PI},1)}(r)=v</span> for any value <span class="math">v</span>, we can fix all but one entry <span class="math">\\mathsf{PI}[\\overset{\\rightharpoonup}{i}]</span> and find a unique solution for the remaining entry <span class="math">\\mathsf{PI}_{i}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda})</span> : Generate a finite abelian group  <span class="math">\\mathbb{G}</span>  of unknown order. Pick an efficiently computable hash functions  <span class="math">\\mathsf{H}_{\\mathbb{G}}: \\{0,1\\}^{*} \\to \\mathbb{G}</span>  to be modeled as a random oracle. Return  <span class="math">\\mathsf{pp} = (\\mathbb{G}, \\mathsf{H}_{\\mathbb{G}})</span> .</li>

      <li>Eval(pp, T, x):</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">y \\gets \\mathsf{H}_{\\mathbb{G}}(x)^{2^T}</span>  by repeated squaring.</li>

      <li>Compute  <span class="math">\\pi \\gets \\mathcal{P}_{\\mathrm{FS}}(\\mathsf{pp},T,x,y)</span>  as the F-S transformed prover of the interactive argument VDF.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify  <span class="math">(\\mathsf{pp}, T, x, y, \\pi)</span> : Return the result of the F-S verifier  <span class="math">\\mathcal{V}_{\\mathrm{FS}}(\\mathsf{pp}, x, y, \\pi)</span> .</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {V D F}} = \\left\\{\\left(\\mathrm {p p}, (T, x, y), \\emptyset\\right) \\mid y = \\mathrm {H} _ {\\mathbb {G}} (x) ^ {2 ^ {T}} \\right\\}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends to  <span class="math">\\mathcal{P}</span>  a  <span class="math">2\\lambda</span> -bit prime  <span class="math">\\ell</span>  uniformly at random.</li>

      <li>Let  <span class="math">g = \\mathsf{H}_{\\mathbb{G}}(x)</span> .  <span class="math">\\mathcal{P}</span>  computes  <span class="math">\\pi = g^{\\lfloor 2^T / \\ell \\rfloor}</span>  and sends  <span class="math">\\pi</span>  to  <span class="math">\\mathcal{V}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  computes  <span class="math">r = 2^T \\mod \\ell</span>  and accepts if and only if  <span class="math">\\pi^\\ell \\cdot g^r = y</span> .</li>

    </ol>

    <p class="text-gray-300">Fig. 12: Wesolowski's verifiable delay function. The Fiat-Shamir transformed argument is described in prose below.</p>

    <p class="text-gray-300">We now show that for every extractor  <span class="math">\\mathcal{E}</span> , there exists an adversary  <span class="math">\\mathcal{A}</span> , nearly as efficient as  <span class="math">\\mathcal{E}</span> , against ABO-H of  <span class="math">\\mathcal{R}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathsf {K S} _ {1, \\text {S p a r t a n} _ {\\mathrm {w F S}}, \\mathcal {R}} ^ {\\mathcal {E}, \\mathcal {P} ^ {*}} \\right] \\leq \\mathbf {A d v} _ {\\mathcal {R}} ^ {\\mathsf {A B O - H}} (\\mathcal {A}).</span></div>

    <p class="text-gray-300">Similar to the above proof, this will imply that  <span class="math">\\mathsf{Spartan}_{\\mathsf{wFS}}</span>  is not knowledge sound. The adversary  <span class="math">\\mathcal{A}</span>  receives  <span class="math">x</span>  from the ABO-H game, then computes  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>  and  <span class="math">(\\mathsf{PI}, \\pi) \\gets \\mathcal{P}^{<em>}(\\mathsf{pp})</span>  such that  <span class="math">\\mathsf{PI}[\\hat{i}] = x</span> . It then sends  <span class="math">(\\mathcal{P}^{</em>}, \\mathsf{pp}, \\mathsf{PI}, \\pi)</span>  to  <span class="math">\\mathcal{E}</span> , and when  <span class="math">\\mathcal{E}</span>  outputs  <span class="math">w</span> ,  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">(\\mathsf{PI}, w)</span> . We can see that if the game  <span class="math">\\mathsf{KS}_{1,\\mathsf{Spartan}_{\\mathsf{wFS}},\\mathcal{R}}^{\\mathcal{E},\\mathcal{P}^{*}}</span>  returns 1, then  <span class="math">\\mathcal{E}</span>  finds a valid witness  <span class="math">w</span> ; thus,  <span class="math">\\mathcal{A}</span>  wins in the ABO-H game. This proves the inequality.</p>

    <p class="text-gray-300">We found two implementations of Spartan; both were vulnerable to this attack but were fixed following an initial public disclosure of our results. Interestingly, the reference implementations of two follow-ups to Spartan, Brakedown [43] and Nova [57], were also vulnerable. Our attack has no impact on applications—as far as we know, no applications currently use Spartan (or related protocols) in production. Still, our attack gives firm evidence that future applications of Spartan should use strong F-S.</p>

    <p class="text-gray-300">We describe an attack against a weak Fiat-Shamir transformation in a verifiable delay function (VDF) [14] constructed by Wesolowski [90]. In Section VII-C, we discuss how our attack affects the security of vulnerable implementations in practice.</p>

    <p class="text-gray-300">Verifiable delay functions. A VDF is a function whose output is only known after a certain time delay, and additionally comes with a proof of correct evaluation. Formally, it is a tuple of three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda})\\to \\mathsf{pp}</span>  outputs public parameters,</li>

      <li>Eval  <span class="math">(\\mathsf{pp}, T, x) \\to (y, \\pi)</span>  evaluates the VDF with time delay  <span class="math">T</span>  on input  <span class="math">x</span> , returning output  <span class="math">y</span>  along with a proof  <span class="math">\\pi</span> . Eval is required to generate  <span class="math">y</span>  deterministically,</li>

      <li>Verify  <span class="math">(\\mathsf{pp}, T, x, y, \\pi)</span>  verifies the proof.</li>

    </ul>

    <p class="text-gray-300">VDFs are required to satisfy completeness, soundness, and sequentiality; for full definitions see e.g. [14], [15], [90]. We note one significant departure of our syntax from the syntax of previous works: we allow the time delay  <span class="math">T</span>  to be an input to the Eval algorithm, instead of  <span class="math">T</span>  being determined ahead of time as a parameter to Setup. We also consider an adaptive soundness notion for VDF, i.e. given  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span> , an attacker cannot output  <span class="math">(T,x,y,\\pi)</span>  with  <span class="math">y \\neq \\mathsf{Eval}(\\mathsf{pp},T,x)</span>  that would make Verify accept the proof; previous works did not allow an attacker to choose the delay parameter. We believe that our modeling choices are closer to practice, as many applications (see Section VII-C) do afford attackers such capabilities.</p>

    <p class="text-gray-300">We describe the interactive argument of [90] in Figure 12. The argument uses a function  <span class="math">\\mathsf{H}_{\\mathbb{G}}</span>  that hashes bit strings into the group  <span class="math">\\mathbb{G}</span> . Let  <span class="math">g = \\mathsf{H}_{\\mathbb{G}}(x)</span> . To convince the verifier it has computed  <span class="math">y</span>  that equals  <span class="math">g^{2^T}</span> , the prover (implicitly) begins by sending  <span class="math">y</span>  to the verifier. Then, the verifier samples a random prime  <span class="math">\\ell</span>  of  <span class="math">2\\lambda</span>  bits, where  <span class="math">\\lambda</span>  is the security parameter, and sends  <span class="math">\\ell</span>  to the prover. The prover replies with the value  <span class="math">\\pi = g^{\\lfloor 2^T / \\ell \\rfloor}</span> ; finally, the verifier computes the residue  <span class="math">r = 2^T \\mod \\ell</span>  and accepts if  <span class="math">\\pi^\\ell g^r = y</span> . Applying the Fiat-Shamir transformation to this argument entails deriving  <span class="math">\\ell</span>  by hashing the prover's first message with a hash function  <span class="math">\\mathsf{H}_{\\mathrm{prime}}</span>  that outputs  <span class="math">2\\lambda</span> -bit primes. The paper specifies the exact transformation to be used as  <span class="math">\\ell = H_{\\mathrm{prime}}(g, y)</span> . We call the resulting non-interactive argument VDFwFS.</p>

    <p class="text-gray-300">We observe that the paper [90] specified a F-S transformation that leaves out several parameters, such as the time delay  <span class="math">T</span>  and the group description  <span class="math">\\mathbb{G}</span> ; thus, the paper is recommending weak F-S. This allows us to break the adaptive soundness of the VDF (defined above); our attack is presented in Figure 13. In our attack, the malicious prover first computes a legitimate proof for a small time delay  <span class="math">t</span> . Then, because this proof does not depend on  <span class="math">t</span> , the prover will choose a much larger delay  <span class="math">T</span>  that leads to the verifier computing the same  <span class="math">r</span>  value in the last step. The proof will still verify for the larger delay  <span class="math">T</span> , though the prover only did  <span class="math">t</span>  sequential squarings. By our choice of  <span class="math">T</span> , with high probability we will have  <span class="math">y \\neq \\mathsf{H}_{\\mathbb{G}}(x)^{2^T}</span> ; otherwise, we know that  <span class="math">\\mathsf{H}_{\\mathbb{G}}(x)^{2^T - 2^t} = 1</span> , which allows us to deduce the group order of  <span class="math">\\mathbb{G}</span> , breaking the low order assumption (as stated in [15]). We summarize with the following theorem.</p>

    <p class="text-gray-300">Theorem 8:  <span class="math">\\mathsf{VDF}_{\\mathsf{wFS}}</span>  does not satisfy adaptive soundness.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick a small time delay <span class="math">t</span>. For an arbitrary <span class="math">x\\leftarrow\\{0,1\\}^{*}</span>, compute <span class="math">y=g^{2^{\\ell}}</span> where <span class="math">g=\\mathsf{H}_{\\mathbb{G}}(x)</span>.</li>

      <li>Compute the proof <span class="math">\\pi\\leftarrow\\mathcal{P}_{\\mathsf{FS}}(\\mathsf{pp},T,x,y)</span>, which in particular is equal to <span class="math">\\pi=g^{\\lfloor 2^{t}/\\ell\\rfloor}</span> where <span class="math">\\ell=\\mathsf{H}_{\\mathsf{prime}}(g,y)</span>.</li>

      <li>Pick a large <span class="math">T</span> such that <span class="math">2^{T}\\equiv 2^{t}\\mod\\ell</span>. In particular, we can pick <span class="math">T=t+\\ell-1</span>. More generally, we can pick <span class="math">T=t+o</span> where <span class="math">o</span> is the order of <span class="math">2</span> modulo <span class="math">\\ell</span>.</li>

      <li>Output <span class="math">((T,x,y),\\pi)</span>.</li>

    </ol>

    <p class="text-gray-300">Fig. 13: Weak Fiat-Shamir Attack Against <span class="math">\\mathsf{VDF}_{\\mathsf{wFS}}</span></p>

    <p class="text-gray-300">Note that we are not claiming the soundness result in <em>[90]</em> is incorrect, merely that it implicitly assumes the delay parameter is fixed.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">VII-C Practical Impacts</h3>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">Affected implementations.</h4>

    <p class="text-gray-300">To assess the practical impacts of our attack against the VDF’s weak Fiat-Shamir Transformation, we first checked if any implementations use weak F-S. We found that every implementation of Wesolowski’s VDF we checked implemented weak F-S. We suspect this is because the paper <em>[90]</em> explicitly recommends weak F-S.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">On the adaptivity of attackers in choosing <span class="math">T</span>.</h4>

    <p class="text-gray-300">Next, we looked at the applications that use vulnerable implementations. We found that the dominant use of VDFs in practice are in cryptocurrency protocols for some kind of proof of work—for example, the Chia protocol uses VDFs to let miners prove they have reserved some amount of storage space for some amount of time. These protocols allow the delay to change dynamically, depending on the state of the chain; thus, an attacker could still (in principle) influence the chosen delay.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Further constraints in practice.</h4>

    <p class="text-gray-300">Our attack is theoretically possible, but turns out not to affect most implementations because of a small, but consequential, implementation choice: the data type used for the delay parameter <span class="math">T</span> is often much too small to fit a delay parameter chosen by our malicious prover. For example, in Chia, the delay parameter is a 64-bit integer, but our malicious prover’s delay parameter will be roughly 256 bits, unless 2 has small order modulo the challenge prime <span class="math">\\ell</span>. We suspect that this happens with very small probability; assuming the order of 2 modulo <span class="math">\\ell</span> is uniformly distributed, the probability of choosing <span class="math">\\ell</span> that gives such a small order is about <span class="math">2^{-192}</span>.</p>

    <p class="text-gray-300">Nevertheless, for implementation choices that allow the time delay to be up to 256 bits, our attack is realizable. Such is the case for two VDF verifiers written in Solidity and Python <em>[1]</em>: Solidity’s default integer type is 256 bits, and Python does not have a priori bounds on its integers. We developed a proof-of-concept exploit for those verifiers; forged proof generation takes less than a second.</p>

    <p class="text-gray-300">In summary, our attack only leads to a latent vulnerability for applications where the delay parameter <span class="math">T</span> is constrained to be much smaller than the challenge prime <span class="math">\\ell</span>. An interesting question for future work is whether it is possible to prove adaptive soundness for <span class="math">\\mathsf{VDF}_{\\mathsf{wFS}}</span> when this condition is enforced. Still, we believe strong F-S (i.e., hashing all public information, including the delay parameter and the group description) is the right choice for implementations.</p>

    <h2 id="sec-50" class="text-2xl font-bold">VIII Discussion</h2>

    <p class="text-gray-300">In this section, we discuss some general points related to our attacks. We discuss whether our attacks could be detected, document other kinds of broken F-S implementations we found, and study one case in more detail.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Detection of weak F-S attacks.</h4>

    <p class="text-gray-300">Understanding how detectable our attacks are in practice requires answering two related questions. First, do forged public inputs have the same distribution as real ones? And second, do our proofs have the same distribution as honestly-generated ones?</p>

    <p class="text-gray-300">Our attacks rely on choosing part of the public inputs as a function of the proof; thus, the public inputs output by our attacks do not necessarily have the same distribution as real ones. For Bulletproofs, the public input is a perfectly hiding commitment in both the real case and for our forger. The public inputs of our Wesolowski attack seem easily detectable, since actually performing <span class="math">\\approx 2^{256}</span> squarings in an RSA group—as our forged proofs show the prover did—would be virtually impossible. For Plonk and Spartan, only one public input is chosen as a function of the proof and the other public inputs; intuitively, this input looks like a uniformly random field element. Reasoning about whether this is detectable is difficult, since it is highly contextual.</p>

    <p class="text-gray-300">The proofs output by our attacks have the same distribution as honest ones in some cases, but not others: e.g., our forged Plonk proofs consist of hiding commitments to polynomials and their evaluations; the hiding property guarantees the distribution is the same as an honest prover. In contrast, though, our attack on Wesolowski’s VDF outputs proofs that are distinguishable from honest ones, since they prove false statements—any party that computes the real VDF output can tell our claimed value is not correct.</p>

    <p class="text-gray-300">In cases where our public inputs and forged proofs have the right distribution, any detection of attacks against weak F-S will have to rely on outside heuristics; for instance, monitoring the public supply in, e.g. MimbleWimble, could help detect if funds are being stolen through such an attack. Determining who is responsible for the attack would likely be more difficult.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Other misuses of Fiat-Shamir.</h4>

    <p class="text-gray-300">Our implementation survey uncovered other kinds of F-S mistakes:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Not including one (or more) of the prover’s messages in the hash computation.</li>

      <li>Initializing a new transcript when invoking the prover/verifier for a subprotocol.</li>

      <li>Not including all public parameters (e.g., R1CS matrices or group generators) in the hash computation.</li>

    </ol>

    <p class="text-gray-300">Case 2 can be thought of as a special case of case 1; by initalizing a new transcript, one effectively excludes the prover’s messages from earlier in the protocol. Both cases 1</p>

    <p class="text-gray-300">and 2 trivially lead to soundness attacks, even in the non-adaptive case.</p>

    <p class="text-gray-300">For case 3, the impact is going to depend on whether the public parameters are fixed, or could be attacker-chosen in some cases. Some public parameters, like generators for cyclic groups, are nearly always hard-coded and so may not need to be hashed. However, a public parameter that could be attacker-chosen is the circuit/R1CS representation for a proof system like Plonk or Spartan. If the verifier accepts arbitary circuits from a prover, and this circuit is not included in the Fiat-Shamir computation, then this can be abused. We wish to highlight this as a case deserving further study, since in many emerging applications of proof systems (such as private smart contract platforms like Aleo <em>[5]</em>), user-specified circuits that represent arbitrary programs are a feature of the application.</p>

    <h2 id="sec-53" class="text-2xl font-bold">IX Mitigating Weak F-S</h2>

    <p class="text-gray-300">In this section, we suggest how academic researchers can clarify the evident confusion about the correct use of F-S. We also suggest designs for tools that can detect weak F-S implementations programmatically, and make it easier to implement F-S correctly.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">Suggestions for researchers.</h3>

    <p class="text-gray-300">In reading recent papers about proof systems that use F-S, we noticed a clear pattern that may explain why confusion is so widespread. Most papers present and analyze the interactive version of the protocol, then state that F-S can be used to make the protocol non-interactive, but without specifying how this should be done, or giving too little information. An example is simply stating the “transcript” should be hashed, without saying what the transcript includes.</p>

    <p class="text-gray-300">We suggest that, to minimize misconceptions and possibilities for error, researchers who present new protocols as interactive should be very precise about the way F-S should be applied to render their protocol non-interactive. Ideally, this includes explicitly identifying the public parameters, inputs, and prover messages that should be hashed, and specifying how to hash them.</p>

    <p class="text-gray-300">This is not a perfect solution, since misunderstandings exist even amongst researchers: the few papers that attempt to be prescriptive about the exact transformation sometimes even state it incorrectly. For example, the original versions of both the Bulletproofs and Wesolowski’s VDF papers explicitly recommend weak F-S. (We notified the authors; the Bulletproofs paper has since been updated.)</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">IX-A Automated Tooling</h3>

    <p class="text-gray-300">We explore some programmatic solutions that can either detect the incorrect use of the Fiat-Shamir transformation, or help the programmer in implementing the transformation correctly.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">Criteria.</h3>

    <p class="text-gray-300">We identify four key criteria to evaluate our tooling proposals, as well as any existing tooling for Fiat-Shamir, in the context of reducing weak F-S vulnerabilities.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: for detection, the tool should have a low error rate, and for implementation, the tool should result in correct implementations of Fiat-Shamir,</li>

      <li>Simplicity: the tool should be easy to use, requiring minimal modification to the pracitioner’s workflow,</li>

      <li>Misuse-resistance: it should be difficult to use the tool in incorrect or unintended ways,</li>

      <li>Efficiency: the tool should add negligible overhead to the runtime of the proof system.</li>

    </ol>

    <p class="text-gray-300">For existing tooling, we are aware of the Merlin library <em>[28]</em> that implements a Transcript object with two operations: one for adding messages and one for deriving challenges. The library provides support for domain separation, message framing, and protocol composition; it has been used in many proof system libraries written in Rust. However, despite its intentional design, Merlin does not enforce the correct use of Fiat-Shamir, and indeed many of the weak Fiat-Shamir implementations we found used Merlin.</p>

    <p class="text-gray-300">We present a few different ideas for discouraging and detecting incorrect Fiat-Shamir usage. First, Merlin could be extended to have an explicit function for adding in the public statement to the transcript. If the user does not call this function, Merlin can raise a warning alerting the user to a potential weak F-S attack. Although this would not automatically prevent incorrect instances of Fiat-Shamir, we believe it would reduce the likelihood of users missing these public values, which were the most common implementation mistake we found.</p>

    <p class="text-gray-300">In addition to the above measure for discouraging misuse, we’ve also begun implementing an extension to Merlin that requires developers to specify all Fiat-Shamir inputs and challenges when the transcript is initialized. Generating challenges without providing all the required inputs will result in an error, alerting developers to potential weak Fiat-Shamir transformations. Additionally, explicitly listing the Fiat-Shamir inputs and challenges encourages developers to carefully consider Fiat-Shamir requirements.</p>

    <p class="text-gray-300">For detection, we can utilize information flow analyses to determine which objects flow to both the proof and verification result (either directly or indirectly). We can compare these objects to those passed to the transcript. If there is a mismatch, then it is likely that Fiat-Shamir is implemented incorrectly. Since the tool acts as a plug-in during testing, it adds zero overhead (efficiency), and ideally only requires few changes to be integrated (simplicity and misuse-resistance). However, this approach suffers from a false negative rate, as it would not be able to check whether two objects are equal, even though they might be computed differently, i.e. the prover computes a proof element, while the verifier receives such a proof element. Detecting when these values are missing from the Fiat-Shamir computation would require dynamic equality checking on values shared between the prover and the verifier. Even though this approach would reduce the false negative rate, it would increase the false positive rate, as many of these shared values will not be required for Fiat-Shamir.</p>

    <h2 id="sec-57" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors thank Trail of Bits, Ian Smith, Riad Wahby, Fraser Brown, and the anonymous reviewers at IEEE S&P</p>

    <p class="text-gray-300">2023 for their helpful comments and suggestions. This research was supported by DARPA under Agreement No. HR00112020022. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the United States Government or DARPA.</p>

    <h2 id="sec-58" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] 0x Project. A solidity implementation of a vdf verifier contract. https://github.com/0xProject/VDF, 2022.</li>

      <li>[2] J. Abfalter. bulletproofs-js. https://github.com/jafalter/bulletproof-js, 2022.</li>

      <li>[3] Adjoint Inc. Adjoint bulletproofs. https://github.com/sdiehl/bulletproofs, 2022.</li>

      <li>[4] Adjoint Inc. Sonic implementation. https://github.com/adjoint-io/sonic, 2022.</li>

      <li>[5] Aleo. https://www.aleo.org/, 2022.</li>

      <li>[6] Anoma. Proof system with plonkup back-end proving arguments. https://github.com/anoma/plonkup/, 2022.</li>

      <li>[7] A. Archer. Zero-knowledge proof implementation for passwords and other secrets. https://github.com/GoodiesHQ/noknow-python, 2022.</li>

      <li>[8] Aztec Protocol. aztec connect repository. https://github.com/AztecProtocol/aztec-connect, 2022.</li>

      <li>[9] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In D. E. Denning, R. Pyle, R. Ganesan, R. S. Sandhu, and V. Ashby, editors, ACM CCS 93, pages 62–73. ACM Press, Nov. 1993.</li>

      <li>[10] M. Bellare and P. Rogaway. The security of triple encryption and a framework for code-based game-playing proofs. In S. Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409–426. Springer, Heidelberg, May / June 2006.</li>

      <li>[11] E. Ben-Sasson, A. Chiesa, and N. Spooner. Interactive oracle proofs. In M. Hirt and A. D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, Oct. / Nov. 2016.</li>

      <li>[12] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In K. Fu and J. Jung, editors, USENIX Security 2014, pages 781–796. USENIX Association, Aug. 2014.</li>

      <li>[13] D. Bernhard, O. Pereira, and B. Warinschi. How not to prove yourself: Pitfalls of the Fiat-Shamir heuristic and applications to Helios. In X. Wang and K. Sako, editors, ASIACRYPT 2012, volume 7658 of LNCS, pages 626–643. Springer, Heidelberg, Dec. 2012.</li>

      <li>[14] D. Boneh, J. Bonneau, B. Bünz, and B. Fisch. Verifiable delay functions. In H. Shacham and A. Boldyreva, editors, CRYPTO 2018, Part I, volume 10991 of LNCS, pages 757–788. Springer, Heidelberg, Aug. 2018.</li>

      <li>[15] D. Boneh, B. Bünz, and B. Fisch. A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.iacr.org/2018/712.</li>

      <li>[16] J. Bootle, A. Chiesa, Y. Hu, and M. Orrù. Gemini: Elastic SNARKs for diverse environments. In O. Dunkelman and S. Dziembowski, editors, EUROCRYPT 2022, Part II, volume 13276 of LNCS, pages 427–457. Springer, Heidelberg, May / June 2022.</li>

      <li>[17] G. Botzel, T. Piellard, Y. E. Housni, I. Kubjas, and A. Tabaie. Consensys/gnark: v0.6.4, Feb. 2022.</li>

      <li>[18] S. Bowe. Sonic. https://github.com/ebfull/sonic, 2022.</li>

      <li>[19] Brakedown reference implementation. https://github.com/conroi/Spartan/tree/brakedown, 2022.</li>

      <li>[20] Bulletproof range proof implementation in pure swift. https://github.com/shamatar/BulletproofSwift, 2022.</li>

      <li>[21] A ruby implementation of bulletproofs. https://github.com/azuchi/bulletproofsrb/, 2023.</li>

      <li>[22] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>[23] B. Bünz, B. Fisch, and A. Szepieniec. Transparent SNARKs from DARK compilers. In A. Canteaut and Y. Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Heidelberg, May 2020.</li>

      <li>[24] M. Campanelli, C. Ganesh, H. Khoshakhlagh, and J. Siim. Impossibilities in succinct arguments: Black-box extraction and more. Cryptology ePrint Archive, Report 2022/638, 2022. https://eprint.iacr.org/2022/638.</li>

      <li>[25] D. Chaum and T. P. Pedersen. Wallet databases with observers. In E. F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 89–105. Springer, Heidelberg, Aug. 1993.</li>

      <li>[26] Chia network. https://www.chia.net/, 2022.</li>

      <li>[27] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In A. Canteaut and Y. Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768. Springer, Heidelberg, May 2020.</li>

      <li>[28] H. de Valence. Merlin: composable proof transcripts for public-coin arguments of knowledge. https://merlin.cool/, 2022.</li>

      <li>[29] H. de Valence, C. Yun, and O. Andreev. A pure-rust implementation of bulletproofs using ristretto. https://github.com/dalek-cryptography/bulletproofs, 2022.</li>

      <li>[30] Dusk genesis circuits. https://github.com/dusk-network/rusk/blob/master/circuits/transfer/doc/dusk-genesis-circuits.pdf, 2022.</li>

      <li>[31] Pure rust implementation of the plonk zkproof system done by the dusk-network team. https://github.com/dusk-network/plonk, 2022.</li>

      <li>[32] The dusk network whitepaper, version 2.0.0. https://dusk.network/uploads/dusk-whitepaper.pdf, 2019.</li>

      <li>[33] Encoins bulletproofs. https://github.com/encryptedcoins/encoins-bulletproofs, 2023.</li>

      <li>[34] Espresso Systems. A rust implementation of the plonk zkp system and extensions. https://github.com/EspressoSystems/jellyfish, 2022.</li>

      <li>[35] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. In A. M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, Aug. 1987.</li>

      <li>[36] A. Gabizon. On the security of the BCTV pinocchio zk-SNARK variant. Cryptology ePrint Archive, Report 2019/119, 2019. https://eprint.iacr.org/2019/119.</li>

      <li>[37] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[38] An elastic proof system based on arkworks. https://github.com/arkworks-rs/gemini, 2022.</li>

      <li>[39] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In T. Johansson and P. Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</li>

      <li>[40] C. Gentry, S. Halevi, and V. Lyubashevsky. Practical non-interactive publicly verifiable secret sharing with thousands of parties. In O. Dunkelman and S. Dziembowski, editors, EUROCRYPT 2022, Part I, volume 13275 of LNCS, pages 458–487. Springer, Heidelberg, May / June 2022.</li>

      <li>[41] A. Ghoshal and S. Tessaro. Tight state-restoration soundness in the algebraic group model. In T. Malkin and C. Peikert, editors, CRYPTO 2021, Part III, volume 12827 of LNCS, pages 64–93, Virtual Event, Aug. 2021. Springer, Heidelberg.</li>

      <li>[42] M. Girault. Self-certified public keys. In D. W. Davies, editor, EUROCRYPT’91, volume 547 of LNCS, pages 490–497. Springer, Heidelberg, Apr. 1991.</li>

      <li>[43] A. Golovnev, J. Lee, S. Setty, J. Thaler, and R. S. Wahby. Brakedown: Linear-time and post-quantum SNARKs for R1CS. Cryptology ePrint Archive, Report 2021/1043, 2021. https://eprint.iacr.org/2021/1043.</li>

      <li>[44] Grin. https://github.com/mimblewimble/grin, 2022.</li>

      <li>[45] J. Groth. On the size of pairing-based non-interactive arguments. In M. Fischlin and J.-S. Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</li>

      <li>[46] T. Haines, S. J. Lewis, O. Pereira, and V. Teague. How not to prove your election outcome. In 2020 IEEE Symposium on Security and Privacy, pages 644–660. IEEE Computer Society Press, May 2020.</li>

      <li>[47] Harmony. The first go implementation of verifiable delay function (VDF). https://github.com/harmony-one/vdf, 2022.</li>

      <li>[48] D. Hosszejni. Verifiable delay function as part of a master thesis. https://github.com/hdarjus/master-thesis-ELTE, 2022.</li>

      <li>[49] Hyrax reference implementation. https://github.com/hyraxZK/hyraxZK, 2022.</li>

      <li>[50] iden3. zksnark implementation in javascript &amp; WASM. https://github.com/iden3/snarkjs, 2022.</li>

      <li>[51] Incognito chain. https://incognito.org/, 2023.</li>

      <li>[52] ING Bank. Reusable library for creating and verifying zero-knowledge range proofs and set membership proofs. https://web.archive.org/web/20201111215751/https://github.com/ing-bank/zkrp, 2022.</li>

      <li>[53] IOHK. Sonic protocol. https://github.com/input-output-hk/sonic, 2022.</li>

    </ul>

    <p class="text-gray-300">[54] IOTA Ledger. Implementation of verifiable delay function. https://github.com/lotaledger/vdf, 2022.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[55] T. E. Jedusor. Mimblewimble. https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.txt, 2016.</li>

      <li>[56] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In M. Abe, editor, <em>ASIACRYPT 2010</em>, volume 6477 of <em>LNCS</em>, pages 177–194. Springer, Heidelberg, Dec. 2010.</li>

      <li>[57] A. Kothapalli, S. Setty, and I. Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. In Y. Dodis and T. Shrimpton, editors, <em>CRYPTO 2022, Part IV</em>, volume 13510 of <em>LNCS</em>, pages 359–388. Springer, Heidelberg, Aug. 2022.</li>

      <li>[58] LayerX. Sonic implementation in rust. https://github.com/LayerXcom/lx-sonic, 2022.</li>

      <li>[59] Litecoin. https://github.com/ltc-mweb/litecoin, 2022.</li>

      <li>[60] C++ implementation of vss using lwe encryption and proofs. https://github.com/shaib/cpp-lwevss, 2021.</li>

      <li>[61] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In L. Cavallaro, J. Kinder, X. Wang, and J. Katz, editors, <em>ACM CCS 2019</em>, pages 2111–2128. ACM Press, Nov. 2019.</li>

      <li>[62] Matter Labs. Bellman zksnark library for community with ethereum’s bn256 support. https://github.com/matter-labs/bellman, 2022.</li>

      <li>[63] Microsoft. Nova: Recursive snarks without trusted setup. https://github.com/microsoft/Nova, 2022.</li>

      <li>[64] Microsoft. Spartan: High-speed zksnarks without trusted setup. https://github.com/microsoft/Spartan, 2022.</li>

      <li>[65] J. Miller. Coordinated disclosure of vulnerabilities affecting girault, bulletproofs, and plonk. https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs-and-plonk/, 2022.</li>

      <li>[66] Mina protocol. https://minaprotocol.com/, 2022.</li>

      <li>[67] Mir Protocol. Recursive snarks based on plonk and halo. https://github.com/mir-protocol/plonky, 2022.</li>

      <li>[68] Monero: the secure, private, untraceable cryptocurrency. https://github.com/monero-project/monero, 2022.</li>

      <li>[69] C. Network. Chia VDF utilities. https://github.com/Chia-Network/chiavdf, 2022.</li>

      <li>[70] P. Network. An implementation of verifiable delay functions in rust. https://github.com/poanetwork/vdf, 2022.</li>

      <li>[71] O(1) Labs. The proof systems used by mina. https://github.com/o1-labs/proof-systems, 2022.</li>

      <li>[72] B. Parno. A note on the unsoundness of vnTinyRAM’s SNARK. Cryptology ePrint Archive, Report 2015/437, 2015. https://eprint.iacr.org/2015/437.</li>

      <li>[73] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In <em>2013 IEEE Symposium on Security and Privacy</em>, pages 238–252. IEEE Computer Society Press, May 2013.</li>

      <li>[74] J. Pascoal and S. M. de Sousa. Bulletproofs-Ocaml. https://gitlab.com/releaselab/bulletproofs-ocaml/, 2022.</li>

      <li>[75] A. Poelstra. https://github.com/apoelstra/secp256k1-zkp/tree/bulletproofs, 2022.</li>

      <li>[76] D. Pointcheval and J. Stern. Security arguments for digital signatures and blind signatures. <em>Journal of Cryptology</em>, 13(3):361–396, June 2000.</li>

      <li>[77] Polygon. https://polygon.technology/, 2022.</li>

      <li>[78] Python3 implementation of bulletproofs. https://github.com/wborgeaud/python-bulletproofs, 2022.</li>

      <li>[79] C.-P. Schnorr. Efficient identification and signatures for smart cards. In G. Brassard, editor, <em>CRYPTO’89</em>, volume 435 of <em>LNCS</em>, pages 239–252. Springer, Heidelberg, Aug. 1990.</li>

      <li>[80] Scroll. https://scroll.io/, 2022.</li>

      <li>[81] SECBIT Labs. Zero knowledge proofs toolkit for CKB. https://github.com/sec-bit/ckb-zkp, 2022.</li>

      <li>[82] S. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In D. Micciancio and T. Ristenpart, editors, <em>CRYPTO 2020, Part III</em>, volume 12172 of <em>LNCS</em>, pages 704–737. Springer, Heidelberg, Aug. 2020.</li>

      <li>[83] O. Shlomovits. Javascript code for one-round single bulletproof. https://github.com/omershlo/simple-bulletproof-js, 2022.</li>

      <li>[84] Starkware. https://starkware.co/, 2022.</li>

      <li>[85] Tari bulletproofs+. https://github.com/tari-project/bulletproofs-plus, 2023.</li>

      <li>[86] D. Unruh. Non-interactive zero-knowledge proofs in the quantum random oracle model. In E. Oswald and M. Fischlin, editors, <em>EUROCRYPT 2015, Part II</em>, volume 9057 of <em>LNCS</em>, pages 755–784. Springer, Heidelberg, Apr. 2015.</li>

      <li>[87] W. Vasquez. Bulletproofs implementation in Go. https://github.com/wrv/bp-go, 2022.</li>

      <li>[88] D. Wagner. A generalized birthday problem. In M. Yung, editor, <em>CRYPTO 2002</em>, volume 2442 of <em>LNCS</em>, pages 288–303. Springer, Heidelberg, Aug. 2002.</li>

      <li>[89] R. S. Wahby, I. Tzialla, a. shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In <em>2018 IEEE Symposium on Security and Privacy</em>, pages 926–943. IEEE Computer Society Press, May 2018.</li>

      <li>[90] B. Wesolowski. Efficient verifiable delay functions. In Y. Ishai and V. Rijmen, editors, <em>EUROCRYPT 2019, Part III</em>, volume 11478 of <em>LNCS</em>, pages 379–407. Springer, Heidelberg, May 2019.</li>

      <li>[91] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In A. Boldyreva and D. Micciancio, editors, <em>CRYPTO 2019, Part III</em>, volume 11694 of <em>LNCS</em>, pages 733–764. Springer, Heidelberg, Aug. 2019.</li>

      <li>[92] Dusk network. https://dusk.network/, 2022.</li>

      <li>[93] ZCash. halo2. https://github.com/zcash/halo2, 2022.</li>

      <li>[94] Zcash. https://z.cash/, 2022.</li>

      <li>[95] ZenGo-X. A collection of paillier cryptosystem zero knowledge proofs. https://github.com/ZenGo-X/zk-paillier, 2022.</li>

      <li>[96] Zengo x bulletproofs. https://github.com/ZenGo-X/bulletproofs, 2023.</li>

      <li>[97] ZK Garage. A pure rust plonk implementation using arkworks as a backend. https://github.com/ZK-Garage/plonk, 2022.</li>

      <li>[98] Implementation of bulletproof for zk spl token. https://github.com/DescartesNetwork/zkSen, 2023.</li>

    </ul>`;
---

<BaseLayout title="Weak Fiat-Shamir Attacks on Modern Proof Systems (2023/691)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/691
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
