---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/762';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Verifiable Computing for Approximate Computation';
const AUTHORS_HTML = 'Shuo Chen, Jung Hee Cheon, Dongwoo Kim, Daejun Park';

const CONTENT = `    <p class="text-gray-300">Shuo Chen Microsoft Research shuochen@microsoft.com</p>

    <p class="text-gray-300">Jung Hee Cheon Seoul National University jhcheon@snu.ac.kr</p>

    <p class="text-gray-300">Dongwoo Kim Seoul National University dwkim606@snu.ac.kr</p>

    <p class="text-gray-300">Daejun Park Runtime Verification, Inc. daejunpark@gmail.com</p>

    <p class="text-gray-300">Abstract—Verifiable computing (VC) is a complexity-theoretic method to secure the integrity of computations. The need is increasing as more computations are outsourced to untrusted parties, e.g., cloud platforms. Existing techniques, however, only deal with exact computations, without the capability of rounding (e.g., “<span class="math">1.11 \\times 2.22 = 2.4642</span>” is verifiable, but “<span class="math">1.11 \\times 2.22</span> rounds-to <span class="math">2.46</span>” is not). Hence, in a long sequence of calculations (e.g., multiplications), the number of digits of the result keeps increasing and will quickly exceed the precision limit of the underlying system. Because of this limitation, VC is currently missing the opportunity in the whole AI space where approximate computations are unavoidable.</p>

    <p class="text-gray-300">In pursuit of the vision of verifiable AI computing, a solution to support the rounding operation is necessary. In this paper, we present an efficient verifiable computing scheme to achieve it. The main idea is to reduce the rounding operation into an efficient arithmetic circuit representation, and reuse the machinery of the Goldwasser, Kalai, and Rothblum's protocol (also known as the GRK protocol), the state-of-the-art interactive proof protocol. Specifically, we shift the algebraic structure from a field to a ring to better deal with the notion of "digits", and generalize the original GKR protocol over a ring. Then, we reduce the rounding operation to a low-degree polynomial in a ring, and present a novel, optimal circuit construction of an arbitrary polynomial to transform the rounding polynomial to an optimal arithmetic circuit representation. Moreover, we further optimize the proof generation cost for rounding by employing a Galois ring. We provide experimental results that show the efficiency of our scheme for approximate computations. For example, our implementation performed two orders of magnitude better than the existing GKR protocol for a nested <span class="math">128 \\times 128</span> matrix multiplication of depth 12 on the 16-bit fixed-point arithmetic.</p>

    <h2 id="sec-2" class="text-2xl font-bold">I. INTRODUCTION</h2>

    <p class="text-gray-300">Verifiable computing (VC) [4], [34], [25], [23] aims to ensure the integrity of computations performed by an untrusted party. In the cloud computing era, as more computationally heavy tasks are delegated to the cloud, VC is considered by the research community as a very compelling solution for proving their security.</p>

    <p class="text-gray-300">The existing literature has demonstrated the feasibility of several basic primitives, such as addition, multiplication, comparisons [52], set operations [31], and key-value store retrieval [43]. Using these primitives, VC was shown feasible for a number of tasks, including matrix multiplication [18], [39], [45], certain SQL-like queries [59], and state-machine updates [13]. A fundamental commonality of the above techniques is that they only deal with exact computations. For example, they can assert that <span class="math">1.11 \\times 2.22 = 2.4642</span> is verifiable, but <span class="math">1.11 \\times 2.22 \\simeq 2.46</span> is not, although <span class="math">\\lfloor 1.11 \\times 2.22 \\rfloor_2 = 2.46</span> (where <span class="math">\\lfloor \\cdot \\rfloor_2</span> denotes rounding to two decimal places). Being</p>

    <p class="text-gray-300">incapable of approximate computations, i.e., not being able to drop insignificant digits, VC is currently missing the opportunity in the whole AI space, as we discuss next.</p>

    <p class="text-gray-300"><strong>Motivation.</strong> This paper is motivated by our vision about verifiable AI computation. Specifically, consider a deep neural network (DNN) training task: it is a computation that takes a set of samples, and produces an output model represented as one or more matrices. The computation often takes hours or even days. Should the training set be poisoned or the training machine(s) be compromised, the output model would have potentially devastating hidden behaviors. Unlike programming bugs or malicious code, compromised AI models are extremely difficult to detect, because the models are nothing but some matrices. However, if verifiable AI computation is achieved, we will be able to trust a model by only trusting the fundamental mathematics, not any other factors such as human operators, program, or platform doing the training.</p>

    <p class="text-gray-300">AI computations are many orders of magnitude heavier and involve more challenging operations than the aforementioned primitives in the VC literature, so it could be a long journey to fully realize the vision. Specifically, DNN training processes mainly consist of an overwhelmingly large amount of computing matrix multiplication and a relatively small amount of computing various non-linear functions such as ReLU, max-pooling, and softmax, where all the operations are performed using approximate arithmetic such as fixed-point or floating-point arithmetic. Here the following fundamental operations are required for DNN training computations: (1) approximate arithmetic, (2) comparison (for ReLU and max-pooling), and (3) natural exponentiation <span class="math">e^x</span> (for softmax and sigmoid). While the comparison operation was shown to be feasible in [52], and <span class="math">e^x</span> can be approximated as a (piecewise) polynomial¹, approximate arithmetic is not supported in existing VC schemes (e.g., acknowledged in [52], [46]), to the best of our knowledge.²</p>

    <p class="text-gray-300"><strong>Fixed precision and rounding.</strong> A DNN training often involves hundreds of thousands nested multiplications. Since the exact multiplication doubly increases the number of significant digits, the rounding operation is essential to allow the computation to be performed within a fixed precision. As</p>

    <p class="text-gray-300">¹In particular, it is a well-known practice to use an input normalization for <span class="math">e^x</span> [51] to avoid overflow when computing softmax or sigmoid, in which case <span class="math">x \\leq 0</span>, and thus a (piecewise) polynomial approximation of <span class="math">e^x</span> for <span class="math">x \\leq 0</span> can provide a sufficient precision since <span class="math">e^x</span> is converging in the negative domain.</p>

    <p class="text-gray-300">²Although the technique used for comparison [52] has a potential to be used for rounding, their approach inherently introduces a significant overhead which is not involved in our approach. See Section IX for more details.</p>

    <p class="text-gray-300">mentioned earlier, the traditional VC only deals with exact computations, and the underlying algebraic structure is a finite field. It is worth noting that, when the exact multiplication is replaced by the rounded multiplication, the structure is no longer a field. (Recall that, for a structure to be a field, every nonzero element would need to have a multiplicative inverse. However, the rounded multiplication is a many-to-one mapping, thus some elements do not have an inverse.) This presents a need for a substantial re-thinking about existing theories and re-targeting them to the new problem.</p>

    <p class="text-gray-300">In this paper, we present a verifiable computing scheme that supports rounding efficiently. We base our scheme on a so-called GKR protocol, a state-of-the-art interactive proof protocol originally proposed by Goldwasser, Kalai, and Rothblum <em>[25]</em>, and improved by <em>[18, 47, 54, 58]</em>. In particular, we consider interactive proofs instead of non-interactive arguments such as SNARKs <em>[24, 8, 10]</em>, since interactive proofs have the advantage of admitting much better performance in generating proofs (roughly <span class="math">\\textgreater</span>1000<span class="math">\\times</span> faster <em>[10, 47]</em>) than noninteractive arguments that rely on expensive cryptographic operations. Note that the proof generation cost is a dominating factor in the overall complexity of VC, and for practical purpose, it is critical to reduce the cost to deal with a heavy computation workload such as DNN training.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Our contributions.</h4>

    <p class="text-gray-300">In pursuit of the vision of verifiable AI, finding a solution to support rounding is an unavoidable effort. It demands a paradigm shift for VC, because it requires re-thinking the underlying algebraic structure, existing techniques, and results from other areas. We have made contributions in these aspects:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Extending the underlying algebraic structure to a ring.</em> We explained above that the existing theorems need to be adapted to handle approximate computations. More technically, when VC is performed on exact computations, the notion of “digit” is not needed, so the underlying algebraic structure is simply a finite field <span class="math">\\mathbb{Z}_{p}</span>, where <span class="math">p</span> is a prime number. (Note that <span class="math">\\mathbb{Z}_{p}</span> represents the integer set from 0 to <span class="math">p-1</span>, and all operations are performed with modulo <span class="math">p</span>.) To support approximate computations, we need the notion of “digit”, since it is essential in the rounding operation. We shift the algebraic structure to a finite ring <span class="math">\\mathbb{Z}_{p^{e}}</span>, which is used to represent <span class="math">e</span> digits, each from 0 to <span class="math">p-1</span>. Although <span class="math">\\mathbb{Z}_{p^{e}}</span> is a ring, not a field (since <span class="math">p^{e}</span> is not a prime), we found that the GKR protocol, originally defined over a finite field, can be generalized over a finite ring (Section IV).</li>

      <li><em>Reducing the rounding operation to an efficient combination of the plain ring operations.</em> With the <span class="math">\\mathbb{Z}_{p^{e}}</span> structure, the rounding operation becomes the operation of removing the lowest digit. Interestingly, we were able to relate our need to a recent study <em>[16]</em> in the homomorphic encryption area. The study was oriented to improving performance of a homomorphic encryption scheme, but we found that its core idea can be utilized for our purpose. Specifically, it allows us to construct an efficient (low-degree) polynomial that performs the rounding operation. This in turn allows us to represent the rounding operation as a combination of the plain ring operations (e.g., addition and multiplication), which can be easily admitted by our generalized GKR protocol over a ring mentioned earlier.</li>

      <li><em>Optimal circuit construction for arbitrary polynomial.</em> In the GKR protocol (as well as our generalized one), a computation of interest needs to be represented in the form of an arithmetic circuit, and the performance of the protocol could be largely affected by the structure of a circuit. Now that we have the aforementioned rounding polynomial, it is important to carefully construct a circuit of the polynomial to achieve good performance. To this end, we devised a novel, optimal circuit construction of an <em>arbitrary</em> polynomial for the GKR protocol. A constructed circuit is regular with depth <span class="math">O(\\log d)</span> and size <span class="math">O(d)</span> where <span class="math">d</span> is the degree of the polynomial. The circuit construction is optimal in that the proof generation complexity is linear in <span class="math">d</span>. Moreover, the complexity for proof generation becomes even <em>sublinear</em> in case that the same polynomial is evaluated on multiple inputs (Section VI-B), while the previously best known result is linear <em>[58]</em>. Such a single-polynomial-multiple-inputs computation is common in data-parallel computing as well as DNN training (e.g., the activation function of each layer is pointwisely applied to a weight vector/matrix). Note that our circuit construction is general, admitting an arbitrary polynomial, and thus can be used in other contexts, e.g., computing (a polynomial approximation of) the activation function in DNN training.</li>

      <li><em>Optimization of proof generation cost for rounding.</em> Consider an approximate computation on <span class="math">\\mathbb{Z}_{p^{e}}</span>. The underlying ring <span class="math">\\mathbb{Z}_{p^{e}}</span> can be replaced by another ring <span class="math">\\mathbb{Z}_{q^{de}}</span> with a much smaller prime <span class="math">q\\simeq\\sqrt[q]{p}</span>, via base conversion, that is, converting numbers in the base-<span class="math">p</span> system to the corresponding numbers in the base-<span class="math">q</span> system. Here the advantage of employing <span class="math">\\mathbb{Z}_{q^{de}}</span> is that the size of the rounding polynomial in <span class="math">\\mathbb{Z}_{q^{de}}</span> is much smaller than that of <span class="math">\\mathbb{Z}_{p^{e}}</span>, which in turn significantly reduces the proof generation cost for rounding. However, employing <span class="math">\\mathbb{Z}_{q^{de}}</span> leads to sacrificing the soundness of the protocol. To mitigate this dilemma, we proposed a technique that allows us to employ <span class="math">\\mathbb{Z}_{q^{de}}</span> without compromising the soundness, by exploiting an interesting property of a Galois ring (Section VII). However, there is a cost overhead when employing a Galois ring, since the operations on</li>

    </ol>

    <p class="text-gray-300">a Galois ring become more expensive as its dimension increases. Thus, having a too small prime <span class="math">q</span> may offset the aforementioned cost benefit. Nevertheless, one can find an optimal <span class="math">q</span> given a set of parameters, and our experiment showed that two orders of magnitude performance improvement can be made by finding such a sweet spot (Section VIII).</p>

    <p class="text-gray-300">These techniques lay the foundation for theoretical feasibility of verifiable approximate computations. In particular, our approach provides a desirable asymptotic complexity. For each rounding layer, the proof generation cost is <em>linear</em>, and the verification cost is <em>logarithmic</em> in the number of rounding gates in the layer. Moreover, we conducted experiments to quantify the performance of verifiable rounding operations. In a moderate laptop, for <span class="math">2^{12}</span> number of <span class="math">16</span>-bit rounding operations, the proof generation took a second, while the proof verification took less than a millisecond. Also, considering that matrix multiplication dominates (constituting <span class="math">\\sim</span>90% of) DNN training workloads <em>[57]</em>, we experimented with our scheme on matrix multiplication. Given a nested <span class="math">128\\times 128</span> matrix multiplication of depth 12 over fixed-point numbers with <span class="math">16</span>-bits below the decimal point, our refinement took 3 minutes to generate a proof for each matrix multiplication, while the original GKR protocol took 2.5 hours for the same task. The gap between the two will increase exponentially as the depth of multiplication increases, while the depth often increases to hundreds of thousands in real DNN training.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Other applications of individual results.</h4>

    <p class="text-gray-300">While we have initially developed various technical results (i.e., the generalized GKR protocol over a ring, the optimization via a Galois ring, and the optimal circuit construction) for the sole purpose of realizing an efficiently verifiable rounding operation, each individual result turns out to have its own applications as well. We will further discuss about this in Section X.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Roadmap.</h4>

    <p class="text-gray-300">The rest of the paper is organized as follows. Section II provides the preliminaries of our work. The overview of our approach is described in Section III. Section IV to Section VII explain our approach in details. Experimental results are analyzed in Section VIII. We present related work in Section IX and conclude in Section X.</p>

    <h2 id="sec-6" class="text-2xl font-bold">II Preliminaries</h2>

    <p class="text-gray-300">In this section, we review a number of basic concepts about verifiable computing (VC). In a VC scenario, a customer delegates a computation to an untrusted platform, and wants to be assured that the computational result is correct. The untrusted platform is called the Prover <span class="math">\\mathcal{P}</span>, and the customer is called the Verifier <span class="math">\\mathcal{V}</span>. As a motivating scenario of our work, <span class="math">\\mathcal{V}</span> submits a DNN training job to <span class="math">\\mathcal{P}</span>, which may take days to run. The goal of VC is to give <span class="math">\\mathcal{V}</span> the ability to quickly verify the correctness of the computational result provided by <span class="math">\\mathcal{P}</span>, without re-running the same job by <span class="math">\\mathcal{V}</span> itself.</p>

    <p class="text-gray-300">Next, we delve a little deeper into the type of VC we discuss in this paper, the interactive proof protocol.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">II-A Interactive Proof Protocol</h3>

    <p class="text-gray-300">We start with a definition of the interactive proof protocol for a function <span class="math">f</span> as follows.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">(Interactive Proof Protocol for <span class="math">f</span> <em>[18, 47]</em>) Consider a prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span> who wishes to compute a function <span class="math">f:X\\rightarrow Y</span>. For an input <span class="math">x\\in X</span> chosen by <span class="math">\\mathcal{V}</span>, <span class="math">\\mathcal{P}</span> gives the claimed output <span class="math">y</span> to <span class="math">\\mathcal{V}</span>. Then, they exchange a sequence of messages and <span class="math">\\mathcal{V}</span> accepts or rejects.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Completeness</em>. For all inputs <span class="math">x\\in X</span>, if <span class="math">\\mathcal{P}</span> follows the protocol and <span class="math">y=f(x)</span>, <span class="math">\\Pr[\\mathcal{V}\\text{ accepts}]=1</span>.</li>

      <li><em><span class="math">\\delta</span>-Soundness</em>. For all inputs <span class="math">x\\in X</span>, if <span class="math">y\\neq f(x)</span>, <span class="math">\\Pr[\\mathcal{V}\\text{ accepts}]&lt;\\delta</span>.</li>

    </ul>

    <p class="text-gray-300">We will call <span class="math">\\delta</span> the soundness probability bound. If <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> exchange <span class="math">r</span> messages, we say the protocol has <span class="math">\\lceil r/2\\rceil</span> rounds.</p>

    <p class="text-gray-300">The GKR protocol is an interactive proof protocol for the evaluation of a layered arithmetic circuit over a finite field <span class="math">\\mathbb{F}</span> where the circuit is composed of addition and multiplication gates (over <span class="math">\\mathbb{F}</span>) of fan-in 2.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">II-B Schwartz-Zippel Lemma</h3>

    <p class="text-gray-300">We first recall the Schwartz-Zipple lemma, the Sum-Check protocol, and the Multilinear Extension which constitute the GKR protocol.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Lemma 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Schwartz-Zippel <em>[41]</em>) Let <span class="math">\\mathbb{F}</span> be a field, and <span class="math">f:\\mathbb{F}^{n}\\rightarrow\\mathbb{F}</span> be an <span class="math">n</span>-variate nonzero polynomial of total degree (the sum of degrees of each variable) <span class="math">D</span>. Then on any finite set <span class="math">A\\subseteq\\mathbb{F}</span> with $D\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\Pr_{\\vec{x}\\leftarrow A^{m}}[f(\\vec{x})=0]\\leq\\frac{D}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the lemma implies that two different polynomials can coincide at only tiny fractions of points. It contributes to soundness of the following sum-check protocol and thus the GKR protocol.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">II-C Sum-Check Protocol</h3>

    <p class="text-gray-300">The Sum-Check protocol <em>[32]</em> is an interactive proof protocol for a specific summation function <span class="math">S(f)</span> over a field <span class="math">\\mathbb{F}</span> as follows.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Sum-Check Protocol <em>[32]</em>) Let <span class="math">\\mathbb{F}</span> be a finite field. Let <span class="math">f:\\mathbb{F}^{n}\\rightarrow\\mathbb{F}</span> be an <span class="math">n</span>-variate polynomial of degree at most $d<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in each variable. The Sum-Check protocol is an interactive proof protocol with soundness </span>\\frac{\\text{nd}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ for the function:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">S(f):=\\sum_{x_{1}\\in\\{0,1\\}}\\sum_{x_{2}\\in\\{0,1\\}}\\cdots\\sum_{x_{n}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{n}).</span></p>

    <p class="text-gray-300">Protocol description: the protocol proceeds in <span class="math">n</span> rounds. In the first round, <span class="math">\\mathcal{P}</span> sends the value <span class="math">S(f)</span>, and a polynomial</p>

    <p class="text-gray-300"><span class="math">f_{1}(t):=\\sum_{(x_{2},x_{3},\\ldots,x_{n})\\in\\{0,1\\}^{n-1}}f(t,x_{2},x_{3}\\ldots,x_{n}).</span></p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">II-</h3>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks if <span class="math">f_{1}(0)+f_{1}(1)=S(f)</span>, and rejects otherwise. In the <span class="math">i</span>-th (<span class="math">2\\leq i\\leq n</span>) round, <span class="math">\\mathcal{V}</span> chooses <span class="math">r_{i-1}</span> randomly from <span class="math">\\mathbb{F}</span>, and sends it to <span class="math">\\mathcal{P}</span>. In response, <span class="math">\\mathcal{P}</span> sends a polynomial</p>

    <p class="text-gray-300"><span class="math">f_{i}(t):=\\sum_{(x_{i+1},\\ldots,x_{n})\\in\\{0,1\\}^{n-i}}f(r_{1},\\ldots,r_{i-1},t,x_{i+1},\\ldots,x_{n}).</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> checks if <span class="math">f_{i-1}(r_{i-1})=f_{i}(0)+f_{i}(1)</span>, and rejects otherwise. After the final <span class="math">n</span>-th round, <span class="math">\\mathcal{V}</span> accepts if <span class="math">f_{n}(r_{n})=f(r_{1},r_{2},\\ldots,r_{n})</span> for a random element <span class="math">r_{n}\\in\\mathbb{F}</span>, and rejects otherwise.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For soundness condition, see Appendix B1. ∎</p>

    <p class="text-gray-300">Note that the soundness of sum-check protocol is based on Schwartz-Zippel lemma (Lemma 1); if dishonest <span class="math">\\mathcal{P}^{\\prime}</span> sent wrong value <span class="math">S^{\\prime}(f)\\neq S(f)</span>, he must send a polynomial <span class="math">f_{1}^{\\prime}(t)\\neq f_{1}(t)</span> resulting in <span class="math">f_{1}^{\\prime}(r_{1})\\neq f_{1}(r_{1})</span> with high probability. Repeatedly, the lemma forces <span class="math">\\mathcal{P}^{\\prime}</span> to send polynomials <span class="math">f_{i}^{\\prime}(t)\\neq f_{i}(t)</span> and to be rejected (at the final round) with high probability.</p>

    <p class="text-gray-300">Note that the sum-check protocol enable <span class="math">\\mathcal{V}</span> to reduce the verification task on <span class="math">S(f)</span> to that on the evaluation of <span class="math">f</span> on one random point. It is the core functionality of sum-check in the GKR protocol.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">II-D Multilinear Extension (MLE)</h3>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">(Multilinear Extension <em>[18]</em>) Given a function <span class="math">V:\\{0,1\\}^{n}\\rightarrow\\mathbb{F}</span>, there exists a unique multilinear polynomial<em><span class="math">\\tilde{V}(x):\\mathbb{F}^{n}\\rightarrow\\mathbb{F}</span> </em>extending<em> <span class="math">V</span>, i.e., <span class="math">\\tilde{V}(x)=V(x)</span> for all <span class="math">x\\in\\{0,1\\}^{n}</span>. We call <span class="math">\\tilde{V}</span> the </em>multilinear extension* (MLE) of <span class="math">V</span> over <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">The existence of multilinear extension <span class="math">\\tilde{V}</span> is guaranteed from the following construction.</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}(x_{1},x_{2},\\ldots,x_{n}):=\\sum_{b\\in\\{0,1\\}^{n}}V(b)\\cdot\\prod_{i=1}^{n}[(1-b_{i})(1-x_{i})+b_{i}x_{i}].</span></p>

    <p class="text-gray-300">The uniqueness of multilinear extension is also straightforward, see Appendix B2. In GKR protocol, the output of each layer in the circuit give rise to the unique multilinear extension.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">II-E GKR Protocol</h3>

    <p class="text-gray-300">Now we describe the GKR protocol which is an interactive proof protocol for the evaluation of a layered arithmetic circuit over a finite field <span class="math">\\mathbb{F}</span>.<em>[vii]</em> We only give an overview of the protocol, and a detailed description can be found in <em>[25, 48]</em> or in Section IV-B.</p>

    <p class="text-gray-300">Overview. Assume we are given a layered arithmetic circuit (over <span class="math">\\mathbb{F}</span>) of depth <span class="math">d</span>, of size <span class="math">S</span>, and of fan-in 2. Each layer is composed of gates outputing addition or multiplication of two inputs. The layers are numbered in a way that output layer is <span class="math">0</span>, input layer is <span class="math">d</span>, and gates of <span class="math">i</span>-th layer take as input the output of gates in <span class="math">i+1</span>-th layer. Let <span class="math">S_{i}</span> denotes the size of <span class="math">i</span>-th layer, and assume it is a power of 2, i.e., <span class="math">S_{i}=2^{s_{i}}</span> for simplicity. We can number each gate of <span class="math">i</span>-th layer with a binary string in <span class="math">\\{0,1\\}^{s_{i}}</span>, and it defines a function <span class="math">V_{i}:\\{0,1\\}^{s_{i}}\\rightarrow\\mathbb{F}</span> relating the given binary string to output of the corresponding gate. Let <span class="math">\\tilde{V_{i}}</span> be the MLE of <span class="math">V_{i}</span>, then there exists an interesting relation between MLEs defined from adjacent layers as follows <em>[49]</em>:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(z)=\\sum_{(\\omega_{1},\\omega_{2})\\in\\{0,1\\}^{2s_{i+1}}}</span> <span class="math">[a\\tilde{d}d_{i}(z,\\omega_{1},\\omega_{2})(\\tilde{V}_{i+1}(\\omega_{1})+\\tilde{V}_{i+1}(\\omega_{2})</span> <span class="math">+\\tilde{mult}_{i}(z,\\omega_{1},\\omega_{2})(\\tilde{V}_{i+1}(\\omega_{1})\\tilde{V}_{i+1}(\\omega_{2}))]</span> (1)</p>

    <p class="text-gray-300">where <span class="math">\\tilde{a\\tilde{d}d_{i}}</span> (or <span class="math">\\tilde{mult}_{i}</span>) is a MLE of a function which is <span class="math">1</span> only if the input binary strings indicate an addition (or multiplication) gate and its corresponding two gates providing inputs, and <span class="math">0</span> otherwise. We call <span class="math">\\tilde{a\\tilde{d}d_{i}}</span> (and <span class="math">\\tilde{mult}_{i}</span>) as wiring predicates <em>[18]</em>.</p>

    <p class="text-gray-300">Now, the GKR protocol proceeds in layer by layer starting from the output layer. <span class="math">\\mathcal{V}</span> having an output of the circuit, gets a claim <span class="math">\\tilde{V}_{0}(z_{0})=v_{0}</span> evaluating <span class="math">\\tilde{V_{0}}</span> on random point <span class="math">z_{0}</span>. Then, she reduces the claim to <span class="math">\\tilde{V}_{1}(z_{1})=v_{1}</span> executing the sum-check protocol on the relation of MLEs we described. Continuing this process layer by layer, she finally gets a claim that <span class="math">\\tilde{V_{d}}(z_{d})=v_{d}</span>, and checks if it is correct evaluating <span class="math">\\tilde{V_{0}}</span> defined with her inputs.</p>

    <p class="text-gray-300">Computational complexity. The computational complexity of <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> in the number of operations over <span class="math">\\mathbb{F}</span>, and the communication cost <span class="math">\\mathcal{C}</span> in the number of elements of <span class="math">\\mathbb{F}</span> are as follows <em>[18, 47, 52]</em>:<em>[viii]</em></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}:O(S\\log S),\\quad\\mathcal{V}:O(n+d\\log S),\\quad\\mathcal{C}:O(d\\log S)</span> (2)</p>

    <p class="text-gray-300">where <span class="math">n</span> is the number of input and output values. Here the prover’s cost can be further reduced to <span class="math">O(S)</span> in the latest variant of the GKR protocol <em>[58, Section 3]</em>, to which our technique is still applicable.</p>

    <p class="text-gray-300">We note that the prover’s cost can be broken down into the circuit evaluation cost and the proof generation cost. They are asymptotically the same in general, but later we will show certain circuits for which the proof generation cost is smaller than the circuit evaluation cost (Section VI).</p>

    <h2 id="sec-18" class="text-2xl font-bold">III Overview of Our Approach and Result</h2>

    <p class="text-gray-300">This section provides an overview of the technical details of our approach and result. The goal of this work is to present an extended GKR protocol that efficiently admits the rounding operation. The idea is to reduce the rounding operation into an efficient circuit representation, and reuse the machinery of the GKR protocol on it. Specifically, we consider an approximate arithmetic circuit over a ring <span class="math">\\mathbb{Z}_{p^{e}}=\\mathbb{Z}/p^{e}\\mathbb{Z}</span> (i.e., integers in a base <span class="math">p</span> system of <span class="math">e</span> digits), where <span class="math">p</span> is a prime and <span class="math">e&gt;1</span>, and the (floor) rounding operation, <span class="math">x\\mapsto\\lfloor x/p\\rfloor</span>. (Note that the proper rounding, <span class="math">\\lfloor x/p\\rceil</span>, can be represented using the floor rounding, i.e., <span class="math">\\lfloor x/p\\rceil=\\lfloor(x+\\frac{p-1}{2})/p\\rfloor</span>.) Below we explain each of our main technical developments.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">III-</h3>

    <p class="text-gray-300">Efficient circuit representation of rounding operation (Sections VI and V). We present an efficient circuit representation of the rounding operation over the base <span class="math">p</span> system. At first, we employ the lowest digit removal polynomial <em>[16]</em>, <span class="math">\\mathsf{ldr}</span>, that we borrowed from the literature of the homomorphic encryption area. The polynomial <span class="math">\\mathsf{ldr}</span> sets the least significant digit to zero, i.e., <span class="math">\\mathsf{ldr}:x\\mapsto\\left\\lfloor x/p\\right\\rfloor\\cdot p</span>, and thus we can have the floor rounding operation by <span class="math">\\mathsf{ldr}(x)/p</span>. We exploit the fact that <span class="math">\\mathsf{ldr}</span> is the lowest degree polynomial whose degree is <span class="math">&lt;ep</span>, <span class="math">\\mathsf{ldr}(x)</span>="" <span class="math">\\mathsf{ldr}</span>="" <span class="math">\\mathsf{ldr}(x)</span>,="" <span class="math">\\mathsf{ldr}(x_{1},\\cdots,x_{n})\\mapsto=&quot;&quot; </span>\\mathsf{ldr}(x_{1},\\cdots,x_{n})\\mapsto a_{1}x_{1}+\\cdots+a_{n}x_{n}<span class="math">,=&quot;&quot; </span>e="" <span class="math">n</span>="" <span class="math">p^{e}</span>="" <span class="math">q</span>,="" <span class="math">q</span>,="" <span class="math">q^{d}\\simeq=&quot;&quot; </span>q^{d}\\simeq="" <span class="math">q^{d}\\simeq=&quot;&quot; </span>q^{d}\\simeq="" <span class="math">q^{d}\\simeq=&quot;&quot; </span>q^{d}\\simeq="" <span class="math">q^{d}\\simeq=&quot;&quot; </span>x<span class="math">=&quot;&quot; </span>x_{1},\\cdots,x_{n})\\mapsto="" <span class="math">x_{n}</span>="" ($\\mathsf{ldr}(x_{1},\\cdots,x_{n})\\mapsto="" (section="" (section="" (section.="" (section.1),="" (section.2),="" (section.3),="" (section.4).="" (section.5),="" (section.6),="" (section.7),="" (section.8),="" (section.9)="" (section.10).="" (section.11).="" (section.12)="" (section.13)="" (section.14)="" (section.15)="" (section.16)="" (section.17)="" (section.18)="" (section.19)="" (section.20)="" (section.21)="" (section.22)="" (section.23)="" (section.24)="" (section.25)="" (section.26)="" (section.27)="" (section.28)="" (section.29)="" (section.30)="" (section.31)="" (section.32)="" (section.33)="" (section.34)="" (section.35)="" (section.36)="" (section.37)="" (section.38)="" (section.4)="" (section.5)="" (section.6)="" (section.7)="" (section.8)="" (section.9)="" (section.10)="" ,="" 1),="" 10.="" 11.="" 12.="" 13.="" 14.="" 15.="" 16.="" 17.="" 18.="" 20.="" 20.="" 21.="" 22.="" 23.="" 24.="" 25.="" 26.="" 27.="" 28.="" 3.="" 4.="" 4.1)="" 4.2)="" 4.3)="" 4.4)="" 4.5)="" 4.6)="" 4.7)="" 4.8)="" 4.9)="" 5.="" a="" a.="" a.1)="" a.2)="" a.3)="" a.4)="" a.5)="" a.6)="" a.7)="" a.8)="" a.9)="" a.10)="" a.11)="" a.12)="" a.13)="" a.14)="" a.15)="" a.16)="" a.17)="" a.18)="" a.19)="" a.20)="" a.3)="" a.4)="" a.5)="" a.6)="" a.7)="" a.8)="" a.9)="" a.10)="" a.11)="" a.12)="" a.13)="" a.14)="" a.15)="" a.16)="" a.17)="" a.18)="" a.20)="" a.3)="" a.4)="" a.5)="" a.6)="" a.7)="" a.8)="" a.10)="" a.11)="" a.12)=""</p>

    <p class="text-gray-300">A Schwartz-Zippel Lemma and Sum-Check Protocol Over a Ring</p>

    <p class="text-gray-300">Since the original GKR protocol is based on the Schwartz-Zippel lemma (Lemma 1), the starting point of generalization is also the lemma. Here we exploit more generalized form given by Bishnoi et al. <em>[12]</em> as follows.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Generalized Schwartz-Zippel <em>[12]</em>) Let <span class="math">R</span> be a ring, and <span class="math">f:R^{n}\\rightarrow R</span> be an <span class="math">n</span>-variate nonzero polynomial of total degree (the sum of degrees of each variable) <span class="math">D</span> over <span class="math">R</span>. Let <span class="math">A\\subseteq R</span> be a finite set with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq D<span class="math"> such that </span>\\forall x\\neq y\\in A<span class="math">, </span>x-y\\in R<span class="math"> is not a zero divisor. Then, </span>\\Pr_{\\vec{x}\\leftarrow A^{n}}[f(\\vec{x})=0]\\leq\\frac{D}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. We will call </span>A$ a <em>sampling set</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Appendix B.3 ∎</p>

    <p class="text-gray-300">This lemma guarantees that the identity check of a polynomial over <span class="math">R</span> can be done similarly as in a field if we sample the random points from a sampling set <span class="math">A\\subseteq R</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Example 1.</h6>

    <p class="text-gray-300">Let <span class="math">R=\\mathbb{Z}_{p^{e}}</span> for an odd prime <span class="math">p</span>, and <span class="math">A=\\{0,1,2,\\ldots,p-2,p-1\\}</span>. Then, <span class="math">A</span> is the sampling set of Lemma 3, since <span class="math">\\forall x\\neq y\\in A,\\;\\;x-y\\in\\{-(p-1),\\ldots,-1,1,\\ldots,p-1\\}</span> is not a zero divisor. Note that zero divisors of <span class="math">R</span> are exactly the nonzero multiples of <span class="math">p</span>. The set <span class="math">A</span> is maximal in that <span class="math">a\\in A</span> implies <span class="math">a+np\\notin A</span> for any nonzero integer <span class="math">n</span>.</p>

    <p class="text-gray-300">Now we can naturally extend the Sum-Check protocol (Theorem 1) over <span class="math">R</span>, only restricting the random points chosen by <span class="math">\\mathcal{V}</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Generalized Sum-Check Protocol) Let <span class="math">R</span> be a ring, <span class="math">f:R^{n}\\rightarrow R</span> be an <span class="math">n</span>-variate polynomial of degree at most <span class="math">d</span> in each variable. Let <span class="math">A\\subseteq R</span> be a <em>sampling set</em> of Lemma 3 such that $d<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then, the Generalized Sum-Check protocol where </span>\\mathcal{V}<span class="math"> chooses each random point </span>r_{i}<span class="math"> from </span>A<span class="math">, is an interactive proof protocol with soundness </span>\\frac{nd}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ for the function:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">S(f):=\\sum_{x_{1}\\in\\{0,1\\}}\\sum_{x_{2}\\in\\{0,1\\}}\\cdots\\sum_{x_{n}\\in\\{0,1\\}}f(x_{1},x_{2},\\ldots,x_{n}).</span></p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Appendix B.4. ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the soundness probability is $\\frac{nd}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> in contrast to </span>\\frac{nd}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ in Theorem 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 1 (Additional condition for efficient specification of <span class="math">f_{i}(t)</span>).</h6>

    <p class="text-gray-300">In the <span class="math">i</span>-th round of the Sum-Check protocol, (honest) <span class="math">\\mathcal{P}</span> should provide</p>

    <p class="text-gray-300"><span class="math">f_{i}(t):=\\sum_{(x_{i+1},\\ldots,x_{n})\\in\\{0,1\\}^{n-i}}f(r_{1},\\ldots,r_{i-1},t,x_{i+1},\\ldots,x_{n})</span></p>

    <p class="text-gray-300">to <span class="math">\\mathcal{V}</span>. While the <span class="math">f_{i}(t)</span> is specified by evaluations of it on <span class="math">\\text{deg}_{i}f+1</span> distinct points from <span class="math">A</span>, we need more condition on that distinct points for Lagrange interpolation to be available; the distinct points must satisfy the condition that all of their differences have inverses in <span class="math">R</span>. It is a stronger condition than that of <span class="math">A</span>. Note that, in all specific rings we use in this paper, the sampling set <span class="math">A</span> also satisfies that stronger condition.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Example 2.</h6>

    <p class="text-gray-300">Let <span class="math">R=\\mathbb{Z}_{p^{e}}</span> for an odd prime <span class="math">p</span>, and <span class="math">A=\\{0,1,2,\\ldots,p-2,p-1\\}</span> as Example 1. Then, <span class="math">A</span> also satisfies the stronger condition mentioned above, i.e., <span class="math">\\forall x\\neq y\\in A</span>, <span class="math">x-y</span> has a multiplicative inverse in <span class="math">R</span>. It follows from the fact that all elements of <span class="math">R=\\mathbb{Z}_{p^{e}}</span> other than multiples of <span class="math">p</span> have a multiplicative inverse in <span class="math">R=\\mathbb{Z}_{p^{e}}^{\\text{xi}}</span>.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">V-B GKR Protocol Over a Ring</h3>

    <p class="text-gray-300">Now we present a generalized GKR protocol over <span class="math">R</span>. We can see that the original GKR protocol can be applied to an arithmetic circuit over <span class="math">R</span> by restricting random points required in the protocol to the sampling set <span class="math">A</span> of Lemma 3. Below we clarify and validate the modification made in each step of the protocol.</p>

    <p class="text-gray-300">Multilinear extension & initial step. We first need to ensure that the existence and uniqueness (Lemma 2) of Multilinear Extension (MLE) <span class="math">\\tilde{V}:R^{n}\\rightarrow R</span> extending a function <span class="math">V:\\{0,1\\}^{n}\\rightarrow R</span>. It follows from the fact that the proof of Lemma 2 is valid in <span class="math">R</span> since it exploits only the properties (i.e., commutativity and distributivity of addition and multiplication, and existence of the multiplicative inverse <span class="math">1</span>) that hold in <span class="math">R</span> as well. At the initial step, <span class="math">\\mathcal{V}</span> reduces the task of checking output values to that of checking <span class="math">\\tilde{V}_{0}(z_{0})=v_{0}</span> where <span class="math">\\tilde{V}_{0}</span> is a MLE of the output values. In the original protocol, the reduction is valid by Lemma 1. In the generalized protocol, the reduction is valid by Lemma 3, provided that <span class="math">\\mathcal{V}</span> samples the random point <span class="math">z_{0}</span> from the set <span class="math">A</span> of Lemma 3.</p>

    <p class="text-gray-300">Applying Sum-Check protocol. We already have shown that the Sum-Check protocol is valid in <span class="math">R</span> as well by Theorem 2. Therefore, reducing the task of checking <span class="math">\\tilde{V}_{i}(z_{i})=v_{i}</span> to that of checking both <span class="math">\\tilde{V}_{i+1}(\\omega_{1}^{<em>})=v_{i+1,1}</span> and <span class="math">\\tilde{V}_{i+1}(\\omega_{2}^{</em>})=v_{i+1,2}</span> can be done using the generalized Sum-Check protocol. Note that <span class="math">\\mathcal{V}</span> samples each random points from the set <span class="math">A</span> in the generalized Sum-Check protocol.</p>

    <p class="text-gray-300">Reduction to verification at a single point & final step. Reducing the task of checking both <span class="math">\\tilde{V}_{i+1}(\\omega_{1}^{<em>})=v_{i+1,1}</span> and <span class="math">\\tilde{V}_{i+1}(\\omega_{2}^{</em>})=v_{i+1,2}</span> to that of checking <span class="math">\\tilde{V}_{i+1}(z_{i+1})=v_{i+1}</span> requires the generalized Schwartz-Zippel lemma (Lemma 3), and <span class="math">\\mathcal{V}</span> must evaluate the polynomial <span class="math">h(t):=\\tilde{V}_{i+1}(l(t))</span> on <span class="math">t_{i+1}</span> that is randomly sampled from the set <span class="math">A</span>, to compute <span class="math">\\tilde{V}_{i+1}(z_{i+1})=h(t_{i+1})</span>. Finally, <span class="math">\\mathcal{V}</span> having <span class="math">\\tilde{V}_{d}(z_{d})=v_{d}</span> checks if it is correct by evaluating the MLE <span class="math">\\tilde{V}_{d}</span> of the input values on <span class="math">z_{d}</span> by herself.</p>

    <p class="text-gray-300">Complexity & soundness. Note that the computational cost of the generalized protocol is the same with that of the original protocol (Equation 2) except that the cost is measured by the number of operations or elements of <span class="math">R</span> instead of <span class="math">\\mathbb{F}</span>. The cost reduction techniques <em>[18, 52, 47, 58]</em> proposed in refinements of GKR protocol are also applicable if <span class="math">R</span> satisfies the additional condition introduced in Remark 1.</p>

    <p class="text-gray-300">Soundness of the generalized GKR protocol follows from that of the generalized Sum-Check protocol. Hence, it has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the same soundness with the original one except that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is substituted by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (see following Theorem 3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(GKR protocol over R) Let <span class="math">R</span> be a finite ring, and <span class="math">C</span> be an arithmetic circuit of size <span class="math">S</span>, depth <span class="math">d</span>, with <span class="math">m</span> outputs over <span class="math">R</span>. Let <span class="math">A</span> be the sampling set of <span class="math">R</span> in Lemma 3. The generalized GKR protocol described above is an interactive proof protocol for the evaluation of <span class="math">C</span> with soundness $(7d\\log S+\\log m)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. The complexity of the generalized GKR protocol is the same with that of the original protocol described in Section II-E.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-29" class="text-2xl font-bold">V Verifiable Rounding Operation</h2>

    <p class="text-gray-300">In this section, we explain how to support the rounding operation on top of the generalized GKR protocol described in Section IV. As explained in Section I, we consider an approximate arithmetic circuit over a ring <span class="math">\\mathbb{Z}_{p^{e}}</span> (i.e., integers in the base-<span class="math">p</span> system) where <span class="math">p</span> is a prime and <span class="math">e&gt;1</span>, and the rounding gate that performs the (floor) rounding: <span class="math">x\\mapsto\\lfloor x/p\\rfloor</span> Like closely related previous work <em>[25, 18, 47]</em>, we assume that the given circuit is layered. For the simplicity of the presentation, we also assume that the given circuit is structured to have rounding layers each of which consists solely of rounding gates, while the other layers have only addition and multiplication gates.</p>

    <p class="text-gray-300">The idea is to replace each rounding gate with a combination of plain arithmetic gates, and use our generalized GKR protocol over <span class="math">\\mathbb{Z}_{p^{e}}</span>. Specifically, we employ a low-degree polynomial <span class="math">\\textsf{ldr}(x)</span> such that <span class="math">\\lfloor x/p\\rfloor=\\textsf{ldr}(x)/p</span>, where <span class="math">\\textsf{ldr}(x)</span> can be represented as a circuit over addition and multiplication gates. (Later, in Section VI, we will provide an optimal circuit construction for arbitrary polynomials including <span class="math">\\textsf{ldr}(x)</span>.) Then, the rounding gate can be replaced with the circuit of <span class="math">\\textsf{ldr}(x)</span> followed by a division-by-<span class="math">p</span> gate, <span class="math">x\\mapsto x/p</span>. Below we will explain what is the polynomial <span class="math">\\textsf{ldr}(x)</span>, and how to verify the division-by-<span class="math">p</span> gate in our generalized GKR protocol.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">V-A Lowest-Digit-Removal Polynomial Over <span class="math">\\mathbb{Z}_{p^{e}}</span></h3>

    <p class="text-gray-300">Chen and Han <em>[16]</em> recently showed the existence of a polynomial over <span class="math">\\mathbb{Z}_{p^{e}}</span> that sets the input’s lowest-digit to zero. They also provided an exact construction of such polynomial.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">(Lowest-digit-removal polynomial <em>[16]</em>) Let <span class="math">p</span> be a prime and <span class="math">e\\geq 1</span> be a positive integer. Then there exists a polynomial <span class="math">\\textsf{ldr}(x)</span> of degree at most <span class="math">(e-1)(p-1)+1</span> such that for every integer <span class="math">0\\leq x&lt;p^{e}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\textsf{ldr}(x)\\equiv x-(x\\bmod p)\\mod p^{e},</span></p>

    <p class="text-gray-300">where <span class="math">(x\\bmod p)\\in\\{0,1,\\ldots,p-1\\}</span>.</p>

    <p class="text-gray-300">Note that the degree of <span class="math">\\textsf{ldr}(x)</span> is small: roughly logarithmic in the size of <span class="math">\\mathbb{Z}_{p^{e}}</span>. It provides us an efficient representation of rounding as a combination of additions and multiplications.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Example 3.</h6>

    <p class="text-gray-300">(<em>[16]</em>) For <span class="math">e=2</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\textsf{ldr}(x)=-x(x-1)\\cdots(x-p+1)</span></p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">V-B Verification of Division-by-<span class="math">p</span> Layer</h3>

    <p class="text-gray-300">As mentioned earlier, the rounding operation (<span class="math">t\\mapsto\\lfloor t/p\\rfloor</span>) can be represented as <span class="math">t\\mapsto\\textsf{ldr}(t)/p</span>. Here the problem is that division is not admitted in an arithmetic circuit over a ring (thus not in the generalized GKR protocol over a ring) in general. However, in <span class="math">\\textsf{ldr}(x)/p</span>, the division is always well-defined, since the result of <span class="math">\\textsf{ldr}(x)</span> is guaranteed to be a multiple of <span class="math">p</span>, where <span class="math">p</span> is constant. Also, as mentioned earlier, the given circuit is assumed to have a separate rounding layer that consists solely of rounding gates. Thus, the reduced circuit will have a separate division-by-<span class="math">p</span> layer that also consists solely of the division-by-<span class="math">p</span> gates, and we have the following equation:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i}(z)=\\tilde{V}_{i+1}(z)/p</span> (3)</p>

    <p class="text-gray-300">where <span class="math">\\tilde{V}_{i}</span> (and <span class="math">\\tilde{V}_{i+1}</span>) denotes the MLE of outputs (and inputs, resp.) of the division-by-<span class="math">p</span> layer. Now, in the generalized GKR protocol, the verifier verifies the outputs of the division-by-<span class="math">p</span> layer by reducing the verification task of <span class="math">\\tilde{V}_{i}(r)=v</span>, to the verification task of <span class="math">\\tilde{V}_{i+1}(r)=pv</span>. This reduction enjoys the perfect soundness, since for <span class="math">\\tilde{V}_{i}^{\\prime}(r)\\neq\\tilde{V}_{i}(r)</span>, we have <span class="math">\\tilde{V}_{i+1}(r)=p\\tilde{V}_{i}(r)\\neq p\\tilde{V^{\\prime}}_{i}(r)=\\tilde{V^{\\prime}}_{i+1}(r)\\pmod{p^{e}}</span>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Remark 2 (Modulus change at division-by-<span class="math">p</span> layer).</h6>

    <p class="text-gray-300">Note that the codomain of <span class="math">\\tilde{V}_{i}</span> is <span class="math">\\mathbb{Z}_{p^{e-1}}</span>, while the codomain of <span class="math">\\tilde{V}_{i+1}</span> is <span class="math">\\mathbb{Z}_{p^{e}}</span>. That is, the outputs of each rounding layer should be regarded as an element of <span class="math">\\mathbb{Z}_{p^{e-1}}</span> while the inputs are elements of <span class="math">\\mathbb{Z}_{p^{e}}</span>. This is because <span class="math">t=ap+b\\in\\mathbb{Z}_{p^{e}}</span> represents <span class="math">(ap+b)+np^{e}\\in\\mathbb{Z}</span> for some <span class="math">n\\in\\mathbb{Z}</span> where <span class="math">0\\leq b&lt;p</span>, while <span class="math">\\lfloor t/p\\rfloor\\equiv a+np^{e-1}\\in\\mathbb{Z}</span> is represented by <span class="math">a\\in\\mathbb{Z}_{p^{e-1}}</span>.</p>

    <h2 id="sec-35" class="text-2xl font-bold">VI Optimal Circuit Construction of Polynomial</h2>

    <p class="text-gray-300">In this section, we present a novel, optimal circuit construction of an arbitrary polynomial for the GKR protocol. The circuit has an optimal depth, and is regular so that a prover (and a verifier) enjoys an optimal cost (and high efficiency) when proving (and verifying) the circuit via the GKR protocol. It has an additional advantage when applied to the parallel evaluation of the same polynomial on multiple inputs, in which case, once a prover has evaluated the circuit, the proof generation cost becomes sublinear in the size of the circuit (i.e., the proof generation is much faster than even the circuit evaluation!), which is better than the previously best known results <em>[54, 58]</em>.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">VI-A Overview of Our Circuit Construction</h3>

    <p class="text-gray-300">Our circuit construction is inspired by the Paterson-Stockmeyer algorithm <em>[40]</em> evaluating a polynomial <span class="math">g(t)</span> of degree <span class="math">N</span> in <span class="math">O(\\sqrt{N})</span> non-constant multiplications. Specifically, for a given polynomial <span class="math">g(t)=\\sum_{i=0}^{N}a_{i}t^{i}</span>, our circuit is constructed to first compute <span class="math">\\sqrt{N}</span> sub-polynomials <span class="math">g_{k}</span>’s (for <span class="math">1\\leq k\\leq\\sqrt{N}</span>) where <span class="math">g_{k}(t)=\\sum_{j=1}^{\\sqrt{N}}a_{j+\\sqrt{N}(k-1)}t^{j}</span>, and then</p>

    <p class="text-gray-300">compute  <span class="math">a_0 + \\sum_{k=1}^{\\sqrt{N}} g_k(t) \\cdot t^{\\sqrt{N}(k-1)}</span> , which gives  <span class="math">g(t)</span> . For example, for a polynomial  <span class="math">g(t) = a_0 + a_1 t + \\dots + a_{16} t^{16}</span>  of degree 16, the constructed circuit (as shown in Figure 1) computes the polynomial as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} a _ {0} + \\left(\\left(a _ {1} t + \\dots + a _ {4} t ^ {4}\\right) + \\left(a _ {5} t + \\dots + a _ {8} t ^ {4}\\right) \\cdot t ^ {4}\\right) \\\\ + \\left(\\left(a _ {9} t + \\dots + a _ {1 2} t ^ {4}\\right) + \\left(a _ {1 3} t + \\dots + a _ {1 6} t ^ {4}\\right) \\cdot t ^ {4}\\right) \\cdot t ^ {8} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Here we note two properties of the above evaluation method that contributes to our optimal circuit construction. First, not all powers of  <span class="math">t</span>  are needed, but only, for example,  <span class="math">t</span> ,  <span class="math">t^2</span> ,  <span class="math">t^3</span> ,  <span class="math">t^4</span> , and  <span class="math">t^8</span>  are. In general, only  <span class="math">(\\sqrt{N} + \\log \\sqrt{N})</span>  powers of  <span class="math">t</span> , that is,  <span class="math">t</span> ,  <span class="math">t^2</span> , ...,  <span class="math">t^{\\sqrt{N}}</span> ,  <span class="math">t^{2\\sqrt{N}}</span> ,  <span class="math">t^{4\\sqrt{N}}</span> ,  <span class="math">t^{8\\sqrt{N}}</span> , ...,  <span class="math">t^{N/2}</span> , are needed to compute  <span class="math">g(t)</span>  in the above evaluation method. Also, every sub-polynomial  <span class="math">g_k</span>  is computed using the same small subset of powers of  <span class="math">t</span> , that is,  <span class="math">t</span> ,  <span class="math">t^2</span> , ...,  <span class="math">t^{\\sqrt{N}}</span> . These properties contribute to reducing the circuit size, and increasing the circuit regularity.</p>

    <p class="text-gray-300">Now we describe certain observations that led us to our circuit construction. The first observation is that the GKR protocol admits any efficiently computable gate with fan-in  <span class="math">&amp;gt;2</span>  without affecting the asymptotic complexity of the protocol, as long as the fan-in is constant. Also, the GKR protocol can admit a layer that solely consists of the linear-sum gates,  <span class="math">\\vec{x} \\mapsto \\sum a_{i}x_{i}</span> , at no cost overhead, by exploiting its nice evaluation structure, even if its fan-in is not constant (see Appendix A for more details). These observations give us more flexibility in constructing a circuit, and we utilize the linear-sum gate for the evaluation of  <span class="math">g_{k}</span> 's, and the fused multiply-add gate,  <span class="math">(x,y,z) \\mapsto xy + z</span> , for the summation of  <span class="math">g_{k}</span> 's. This yields a circuit of width  <span class="math">2\\sqrt{N}</span>  and depth  <span class="math">(3 + \\log N)</span>  with a regular wiring pattern.</p>

    <p class="text-gray-300">Figure 1 shows our circuit construction of a single polynomial  <span class="math">g(t)</span> . The circuit is composed of four parts. The first part referred to as polygen, consisting of  <span class="math">\\log \\sqrt{N}</span>  layers with multiplication gates, takes as input  <span class="math">t</span>  and computes its powers,  <span class="math">t, t^2, \\dots, t^{\\sqrt{N}}</span> . The second part referred to as eval, consisting of a single layer over the linear-sum gates, computes the sub-polynomials  <span class="math">g_k(t)</span> 's. The third part referred to as unify, consisting of  <span class="math">\\log \\sqrt{N}</span>  layers over the fused multiply-add gates, computes the summation of the sub-polynomials,  <span class="math">g(t) - a_0</span> . Note that the unify part also computes the square-powers,  <span class="math">t^{2\\sqrt{N}}</span> ,  <span class="math">t^{4\\sqrt{N}}</span> ,  <span class="math">t^{8\\sqrt{N}}</span> ,  <span class="math">\\dots</span> ,  <span class="math">t^{N/2}</span>  by the side of the main computation, where the same multiply-add gate is used along with introducing dummy gates, to achieve a regular wiring pattern. The last part referred to as extract, consisting of a single layer of a constant-addition gate, computes the final result  <span class="math">g(t)</span> . More details and a precise definition of our circuit construction are provided in Appendix A.</p>

    <p class="text-gray-300">In case that multiple inputs need to be evaluated on the same polynomial, our circuit construction simply puts multiple copies of the same circuit shown in Figure 1 side-by-side. This yields a circuit that has a larger width  <span class="math">O(M\\sqrt{N})</span>  but the same depth  <span class="math">O(\\log N)</span> , where  <span class="math">M</span>  is the number of inputs.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Our circuit construction of a polynomial of degree 16,  <span class="math">g(t) = \\sum_{i=0}^{16} a_i t^i</span> . The value of each gate denotes the output of the gate, where  <span class="math">g_k = \\sum_{j=1}^{4} a_{j+4(k-1)} t^j</span> . The green arrow denotes the linear-sum gate wiring. The gates computing zero are dummy gates that are added to achieve a regular wiring pattern and thus admit an optimal prover and an efficient verifier. The presence of the dummy gates does not affect the asymptotic cost.</p>

    <p class="text-gray-300">Let us consider the case of multiple inputs being evaluated on the same polynomial. The following lemma shows the complexity of the GKR protocol (precisely, the variants [47] or [58, Section 3]) on our circuit construction for such a case. (The complexity for the single-input case is an instance of that of the single-polynomial-multiple-inputs case.)</p>

    <p class="text-gray-300">Lemma 5 (Complexity of Protocol on Our Circuit Construction). Let  <span class="math">C</span>  be a circuit generated by our construction for the case of  <span class="math">M</span>  inputs being evaluated on the same polynomial of degree  <span class="math">N</span> . Then, the complexity of the GKR protocol on  <span class="math">C</span>  is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Circuit evaluation:  <span class="math">O(MN)</span></li>

      <li>Proof generation:  <span class="math">O(M\\sqrt{N} + N)</span></li>

      <li>Verification:  <span class="math">O(M + \\log N \\log MN)</span></li>

      <li>Communication:  <span class="math">O(\\log N \\log MN)</span></li>

      <li>Soundness:  <span class="math">O((\\log N \\log MN) / A)</span></li>

    </ul>

    <p class="text-gray-300">where  <span class="math">A</span>  is the size of the sampling set, and the verification cost excludes the offline precomputation cost  <span class="math">O(N)</span> . The complexity for the single input case is simply the one having  <span class="math">M = 1</span>  in the above.</p>

    <p class="text-gray-300">Proof. Appendix B5, and Appendix B6.</p>

    <p class="text-gray-300">Here we note that our proof generation cost is better than the previously best known result. Specifically, let  <span class="math">C</span>  be the circuit described in Lemma 5, and  <span class="math">C&#x27;</span>  be a circuit that is equivalent to  <span class="math">C</span>  with the same size  <span class="math">O(MN)</span>  and the same depth  <span class="math">O(\\log N)</span> , but is constructed in a standard way (i.e., computing all the powers of  <span class="math">t</span>  using the exponentiation-by-squaring method, computing all the monomials, and adding</p>

    <p class="text-gray-300">all the monomials in a binary tree fashion). Then, the proof generation cost of Giraffe [54] and Libra [58] on  <span class="math">C&#x27;</span>  are  <span class="math">O(MN + N\\log N)</span>  and  <span class="math">O(MN)</span> , respectively, while ours is  <span class="math">O(M\\sqrt{N} + N)</span> . Their other costs (i.e., circuit evaluation, verification, and communication) on  <span class="math">C&#x27;</span>  are the same with ours.</p>

    <p class="text-gray-300">In this section, we present an optimization technique that can significantly reduce the prover's cost for the rounding layers described in Section V.</p>

    <p class="text-gray-300">A Galois ring  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span>  over  <span class="math">\\mathbb{Z}_{p^e}</span>  for a monic irreducible polynomial  <span class="math">f(t)\\in \\mathbb{Z}_p[t]</span>  is a natural generalization of the Galois field  <span class="math">\\mathrm{GF}(p^n)</span>  over a finite field  <span class="math">\\mathbb{F}_p</span> . The representation of elements and operations in  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span>  is similar to that of  <span class="math">GF(p^{n})</span>  modulo the difference between  <span class="math">\\mathbb{Z}_{p^e}</span>  and  <span class="math">\\mathbb{F}_p</span> . Let  <span class="math">d</span>  be the degree of  <span class="math">f(t) = t^{d} + f_{d - 1}t^{d - 1} + \\ldots +f_{0}</span> , where  <span class="math">f_{i}\\in \\mathbb{Z}_{p}</span> . Then, the dimension of  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span>  is  <span class="math">d</span> , and each element is represented as a  <span class="math">d</span> -dimensional tuple in  <span class="math">\\mathbb{Z}_{p^e}^d</span>  whose standard basis corresponds to  <span class="math">1,t,t^{2},\\dots ,t^{d - 1}</span> . Thus, the addition corresponds to the component-wise addition in  <span class="math">\\mathbb{Z}_{p^e}^d</span> , and the multiplication by an element  <span class="math">a = (a_0,a_1,\\dots a_{d - 1})</span>  corresponds to the matrix multiplication by its corresponding matrix according to the multiplication rule  <span class="math">t\\cdot (a_0,a_1,\\dots ,a_{d - 1}) = (0,a_0,a_1,\\dots ,a_{d - 2}) - a_{d - 1}\\cdot (f_0,f_1,\\dots ,f_{d - 1})</span> .</p>

    <p class="text-gray-300">A nice property of the Galois ring  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span>  is that every nonzero element whose coefficients are in  <span class="math">\\{-p - 1), \\ldots, -1, 0, 1, \\ldots, p - 1\\}</span>  is invertible, which leads to the following theorem.</p>

    <p class="text-gray-300">Theorem 4. [33] Let  <span class="math">p</span>  be an odd prime,  <span class="math">e</span>  be a positive integer, and  <span class="math">R</span>  be a Galois ring  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span>  of dimension  <span class="math">d</span> . Then, all nonzero elements in  <span class="math">\\{a_0 + a_1t + \\ldots + a_{d-1}t^{d-1} \\mid a_i \\in [-(p-1), p-1] \\cap \\mathbb{Z}\\} \\subseteq R</span> , are invertible (hence are not zero-divisors) in  <span class="math">R</span> . Therefore, the subset  <span class="math">A = \\{a_0 + a_1t + \\ldots + a_{d-1}t^{d-1} \\mid a_i \\in [0, p-1] \\cap \\mathbb{Z}\\} \\subseteq R</span>  is a valid sampling set for the generalized Schwartz-Zippel lemma (Lemma 3) as well as the generalized GKR protocol (Theorem 3).</p>

    <p class="text-gray-300">Note that the cardinality of the sampling set  <span class="math">A</span>  in Theorem 4 is  <span class="math">p^d \\gg p</span> , which is maximal.[xx] Moreover,  <span class="math">A</span>  satisfies the additional condition of Remark 1.</p>

    <p class="text-gray-300">Irreducible Polynomial in  <span class="math">\\mathbb{Z}_p[t]</span> . To construct a Galois ring  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span> , we need an irreducible polynomial in  <span class="math">\\mathbb{Z}_p[t]</span> . Indeed, there exist many irreducible polynomials  <span class="math">f(t) \\in \\mathbb{Z}_p[t]</span>  for any degree  <span class="math">d</span> , but a sparse polynomial (where most of its coefficients are zero) is desired for the efficiency of multiplication in  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span> . Below we provide examples of such a sparse irreducible polynomial. (More irreducible polynomials can be systemically found. See Appendix B7.)</p>

    <p class="text-gray-300">xxA set containing more than  <span class="math">p^d</span>  elements has distinct elements  <span class="math">x</span>  and  <span class="math">y</span>  such that  <span class="math">x - y = (n_0p, n_1p, \\ldots, n_{d-1}p) \\in \\mathbb{Z}_{p^e}[t] / (f(t))</span>  by the Pigeonhole principle where  <span class="math">n_i</span> 's are integers, and  <span class="math">(n_0p, n_1p, \\ldots, n_{d-1}p)</span>  is a zero-divisor.</p>

    <p class="text-gray-300">Lemma 6. Let  <span class="math">p</span>  be a prime number. All of the following polynomials are irreducible in  <span class="math">\\mathbb{Z}_p</span> :</p>

    <p class="text-gray-300">(i)  <span class="math">\\Phi_4(x) = x^2 + 1</span>  when  <span class="math">p \\equiv 3 \\mod 4</span> . (ii)  <span class="math">\\Phi_5(x) = x^4 +x^3 +x^2 +x + 1</span>  when  <span class="math">p\\equiv \\pm 2</span>  mod 5. (iii)  <span class="math">\\Phi_9(x) = x^6 +x^3 +1</span>  when  <span class="math">p\\equiv 2</span>  or 5 mod 9. (iv)  <span class="math">x^3 - a</span>  for some  <span class="math">a</span>  when  <span class="math">p \\equiv 1 \\mod 3</span> . (v)  <span class="math">x^4 - 2</span>  when  <span class="math">p \\equiv 5 \\mod 8</span> . (vi)  <span class="math">x^4 - 3</span>  when  <span class="math">p \\equiv 5 \\mod 12</span> .</p>

    <p class="text-gray-300">Proof. Appendix B7</p>

    <p class="text-gray-300">Now we explain how to optimize the prover's cost for the rounding layers. Let  <span class="math">C_p</span>  be a given approximate arithmetic circuit over  <span class="math">\\mathbb{Z}_{p^e}</span> , and  <span class="math">q</span>  be a prime such that  <span class="math">p \\simeq q^d</span> . First, we convert  <span class="math">C_p</span>  to an approximately equivalent circuit  <span class="math">C_q</span>  over  <span class="math">\\mathbb{Z}_{q^{de}}</span> , by the base-  <span class="math">p</span> -to-base-  <span class="math">q</span>  conversion, where each base-  <span class="math">p</span>  rounding gate  <span class="math">(x \\mapsto \\lfloor x / p \\rfloor)</span>  in  <span class="math">C_p</span>  is replaced with  <span class="math">d</span> -consecutive base-  <span class="math">q</span>  rounding gates  <span class="math">(x \\mapsto \\lfloor x / q \\rfloor)</span>  in  <span class="math">C_q</span> . Then, we apply the generalized GKR protocol over a Galois ring  <span class="math">\\mathbb{Z}_{q^{de}}[t] / (f(t))</span>  where  <span class="math">f(t)</span>  is a monic irreducible polynomial of degree  <span class="math">d</span> . Here, we employ the sampling set given in Theorem 4, whose cardinality is  <span class="math">q^d \\simeq p</span> , which affects the soundness. Moreover, in the process of the protocol, we have the circuit evaluation to be performed over  <span class="math">\\mathbb{Z}_{q^{de}}</span> , and the proof generation and the verification to be conducted over  <span class="math">\\mathbb{Z}_{q^{de}}[t] / (f(t))</span> . This is valid, since  <span class="math">\\mathbb{Z}_{q^{de}}[t] / (f(t))</span>  naturally embeds  <span class="math">\\mathbb{Z}_{q^{de}}</span>  as constant terms.</p>

    <p class="text-gray-300">Now we analyze the complexity of the protocol for a rounding layer that consists of  <span class="math">r</span>  rounding gates. First, note that the degree of the rounding polynomial (ldr) of  <span class="math">C_p</span>  is  <span class="math">ep</span> , while that of  <span class="math">C_q</span>  is  <span class="math">deq \\simeq de\\sqrt[d]{p}</span> , which is much smaller than  <span class="math">ep</span>  for some  <span class="math">d</span> . On the other hand, the cost of the individual addition (and multiplication) operation in  <span class="math">\\mathbb{Z}_{q^{de}}[t] / (f(t))</span>  is  <span class="math">G(d)</span>  (and  <span class="math">O(d^2)</span> , resp.) times larger than that of  <span class="math">\\mathbb{Z}_{p^e}</span> . Based on these facts and Lemma 5, the complexity of the unoptimized protocol on  <span class="math">C_p</span>  and the optimized protocol on  <span class="math">C_q</span>  can be summarized as follows (the two are equivalent when  <span class="math">d = 1</span> ):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cq</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Circuit eval.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(epr)</td>

            <td class="px-3 py-2 border-b border-gray-700">2d2e√2pr</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof gen.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(epr)</td>

            <td class="px-3 py-2 border-b border-gray-700">32d4e√2p+70d3√de√2pr</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verification</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2epr)</td>

            <td class="px-3 py-2 border-b border-gray-700">d3(log de√2p)(log de√2pr10)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Soundness</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2epr/p)</td>

            <td class="px-3 py-2 border-b border-gray-700">d(log de√2p)(log de√2pr6)/4p</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here the optimization problem is to find  <span class="math">d</span>  such that the costs for  <span class="math">C_q</span>  are minimized. In particular, given  <span class="math">p</span> , the term  <span class="math">d^4\\sqrt[d]{p}</span>  is minimized to  <span class="math">((\\mathbf{e}\\ln p) / 4)^4</span> , which is much smaller than  <span class="math">p</span> , when  <span class="math">d = (\\ln p) / 4</span> , where  <span class="math">\\mathbf{e}</span>  is Euler's number. In Section VIII, we will present an experimental result where two orders of magnitude cost reduction was made by finding a proper  <span class="math">d</span> .</p>

    <p class="text-gray-300">We present experimental results that quantify the efficiency of our scheme. Specifically, we conducted experiments that show how efficiently our scheme supports rounding, and how</p>

    <p class="text-gray-300">effective the optimization technique is. Also, to show the importance of rounding, we compare our scheme (with rounding) to the original GKR protocol (without rounding) on deeply nested matrix multiplications. We consider matrix multiplication since it is a well-experimented subject considered by all of the existing GKR protocol variants, making it easier to compare with them. More importantly, matrix multiplication constitutes about  <span class="math">90\\%</span>  of DNN training workloads [57].</p>

    <p class="text-gray-300">We implemented our generalized GKR protocol <span class="math">^{\\mathrm{xvi}}</span>  over a ring  <span class="math">R = Z_{p^e}[t] / (f(t))</span>  where  <span class="math">f(t)</span>  is a monic irreducible polynomial over  <span class="math">\\mathbb{Z}_{p^e}</span> . The modulo operations of  <span class="math">\\mathbb{Z}_{p^e}</span>  are implemented using the Montgomery modular multiplication [38]. The code is written in C++11 using the GMP library, and compiled with the LLVM GCC compiler 9.1.0 (with -O3). All the experiments were performed on a laptop machine with Intel Core i5 CPU running MacOS (64-bit) at 2.9GHz processor and 8GB memory. Throughout this section, we report the verification cost excluding the cost of evaluating MLE of input/output layers, since they are not involved in verifying rounding layers placed in the middle of a circuit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To show the effectiveness of the optimization technique described in Section VII, we instantiated our scheme with different Galois rings and compared their performance. Specifically, given an original ring,  <span class="math">R_{1} = \\mathbb{Z}_{(65537)^{7}}</span> , we took two Galois rings,  <span class="math">R_{2} = \\mathbb{Z}_{(271)^{14}}[t] / (x^{2} + 1)</span>  and  <span class="math">R_{3} = \\mathbb{Z}_{(17)^{28}}[t] / (x^{4} - 3)</span> , where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\simeq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\simeq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\simeq 2^{112}<span class="math"> . Then, we instantiated our optimized protocol (Section VII) with the three different rings, and experimented with them for a rounding layer that consists of  </span>2^{14}$  rounding gates, where each rounding gate performs, roughly speaking, the 16-bit rounding, i.e., truncating the least-significant 16 bits.[xvii]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2 shows the performance of the protocol over the different rings. The circuit evaluation cost drastically decreases as the dimension of a Galois ring increases. This is because the size of the rounding circuit for  <span class="math">R_{3}</span>  is much smaller than that of  <span class="math">R_{1}</span> , since the size depends on  <span class="math">ep</span> . However, the proof generation cost is not the case, since the cost of individual ring operations quadratically increases as the dimension of a Galois ring increases, thus it offsets the benefit of a smaller rounding circuit when the dimension is too high. In our experimental setup, the protocol over  <span class="math">R_{2}</span>  of dimension two performed best in generating proofs. On the other hand, the verification cost increases as the dimension of a Galois ring increases, since the verification cost logarithmically depends on the rounding circuit size, thus the benefit of a smaller rounding circuit is insignificant, but the cost of individual ring operations dominates. In general, the optimal dimension varies depending</p>

    <p class="text-gray-300">xviSpecifically, the generalization was made on top of Thaler's variant [47], since we considered Thaler's variant to compare ours to the original GKR protocol as explained in Section VIII-D.</p>

    <p class="text-gray-300">xviiMore precisely, each rounding gate takes as input  <span class="math">x</span>  , and outputs  <span class="math">\\lfloor x / 65537\\rfloor</span> <span class="math">\\lfloor x / (271^2)\\rfloor</span>  , and  <span class="math">\\lfloor x / (17^4)\\rfloor</span>  , respectively, for each  <span class="math">R_{1}</span> <span class="math">R_{2}</span>  and  <span class="math">R_{3}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(t)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λs</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R1</td>

            <td class="px-3 py-2 border-b border-gray-700">65537</td>

            <td class="px-3 py-2 border-b border-gray-700">~16</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.020</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R2</td>

            <td class="px-3 py-2 border-b border-gray-700">271</td>

            <td class="px-3 py-2 border-b border-gray-700">~8</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">x2+1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R3</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">~4</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">x4-3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.007</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) Galois ring structures  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) Performance of protocol over different Galois rings</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2: Performance of our protocol over different Galois rings  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span> , for a rounding layer consisting of  <span class="math">2^{14}</span>  gates. The table describes three different rings  <span class="math">R_{1} = \\mathbb{Z}_{(65537)^{7}}</span> ,  <span class="math">R_{2} = \\mathbb{Z}_{(271)^{14}}[t] / (x^{2} + 1)</span>  and  <span class="math">R_{3} = \\mathbb{Z}_{(17)^{28}}[t] / (x^{4} - 3)</span> , where  <span class="math">d</span>  denotes the dimension of a Galois ring, and  <span class="math">\\lambda_{s}</span>  denotes the soundness probability bound of the protocol over the ring. Each rounding gate performs  <span class="math">x \\mapsto \\lfloor x / (p^d) \\rfloor</span> , i.e., roughly the 16-bit rounding.</p>

    <p class="text-gray-300">on the set of parameters of the protocol and the characteristics of computation of interest. Also, we note that the circuit evaluation cost does not involve the cost overhead of individual operations of a Galois ring, since the circuit evaluation is performed over a base ring  <span class="math">\\mathbb{Z}_{p^e}</span>  instead of its Galois ring  <span class="math">\\mathbb{Z}_{p^e}[t] / (f(t))</span> , as mentioned in Section VII. This is why the proof generation cost is bigger than the circuit evaluation cost when the dimension is greater than one, although our optimal circuit construction offers the proof generation cost that is asymptotically smaller than the circuit evaluation cost, as described in Section VI-B.</p>

    <p class="text-gray-300">To quantify the efficiency of our scheme for rounding, we applied our scheme for a single rounding layer that consists of multiple rounding gates. Specifically, we consider our generalized GKR protocol over  <span class="math">R_{2} = \\mathbb{Z}_{(271)^{14}}[t] / (x^{2} + 1)</span> , and the rounding operation  <span class="math">x\\mapsto \\lfloor x / (271^2)\\rfloor</span> , roughly the 16-bit rounding. Figure 3 shows the performance of our protocol for a rounding layer of various sizes, from  <span class="math">2^{8}</span>  to  <span class="math">2^{19}</span> . As described in Section VI-B, the cost of circuit evaluation and proof generation is linear in the number of rounding gates, while the cost of verification and communication is logarithmic in the number of rounding gates. We also note that the verification becomes even faster than the native evaluation (i.e., performing</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 3: Performance of our protocol for a rounding layer of various sizes. The protocol is over  <span class="math">R_{2} = \\mathbb{Z}_{(271)^{14}}[t] / (x^{2} + 1)</span> , and the rounding operation is  <span class="math">x \\mapsto \\lfloor x / (271^2) \\rfloor</span> , roughly the 16-bit rounding.</p>

    <p class="text-gray-300">the rounding operation directly in the native processor, without going through the arithmetic circuit) when the number of rounding gates is more than  <span class="math">2^{18}</span> .</p>

    <p class="text-gray-300">Now we compare our protocol (that supports rounding) to the original GKR protocol (that does not support rounding) on deeply nested matrix multiplications. The most important value of rounding is that it controls the number of digits within the limit of the underlying system, which is especially necessary for AI computations. This is the most fundamental advancement of our approach, compared to the original GKR. Moreover, in order to understand the end-to-end performance of our approach, we conducted a performance comparison with the original GKR as follows.</p>

    <p class="text-gray-300">We considered the Thaler [48]'s implementation for the original GKR protocol since it shows the best performance for matrix multiplication among other variants (e.g., [54], [58]). To be a fair comparison, we modified the Thaler's implementation to employ the same GMP library we used in our protocol implementation.[xviii]</p>

    <p class="text-gray-300">Moreover, we consider a nested multiplication of depth  <span class="math">n</span> ,  <span class="math">(\\dots ((M^2)^2)^2 \\dots)^2 = M^{2^n}</span> , where  <span class="math">M</span>  is a  <span class="math">128 \\times 128</span>  matrix whose elements are fixed-point numbers with 16 fractional bits (i.e., 16 bits below the decimal point), and no overflow occurs during the computation.[xix]</p>

    <p class="text-gray-300">In the original GKR protocol (over a finite field  <span class="math">\\mathbb{Z}_q</span> ) that does not support rounding, the above nested multiplication over the fixed-point numbers is represented as the integer-scaled nested multiplication, i.e.,  <span class="math">(\\dots (((2^{16}M)^2)^2)^2\\dots)^2 = (2^{16})^{2^n}M^{2^n}</span> . This means that the prime  <span class="math">q</span>  must be taken to be larger than  <span class="math">(2^{16})^{2^n}</span> , that is, the bit-size of field elements (in</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 4: Performance comparison of ours to Thaler [47]'s on a single  <span class="math">128 \\times 128</span>  matrix multiplication (over fixed-point numbers with 16 fractional bits) in the context of different multiplication depths. The domain of each protocol is chosen to be large enough to admit a given multiplication depth. That is, our protocol is over  <span class="math">\\mathbb{Z}_{(271)^e}[t] / (t^3 + 2)</span> , where  <span class="math">e = 14, 18, 22</span> , and 26, respectively. Thaler's is over  <span class="math">\\mathbb{Z}_q</span> , where  <span class="math">q = (2^{1279} - 1)</span> ,  <span class="math">(2^{4253} - 1)</span> ,  <span class="math">(2^{19937} - 1)</span> , and  <span class="math">(2^{86243} - 1)</span> , respectively. The performance of Thaler's on the multiplicative depth 12 is extrapolated.</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_q</span>  ) exponentially grows in the multiplication depth  <span class="math">n</span> . In our protocol (over a ring  <span class="math">\\mathbb{Z}_{p^e}</span> ), however, the nested multiplication is represented as the integer-scaled nested multiplication with rounding, i.e.,  <span class="math">\\lfloor (\\dots \\lfloor (\\lfloor (2^{16}M)^2\\rfloor)^2\\rfloor)^2\\rfloor \\dots)^2\\rfloor \\simeq 2^{16}M^{2^n}</span> , where  <span class="math">\\lfloor \\cdot \\rfloor</span>  denotes  <span class="math">x\\mapsto \\lfloor x / (2^{16})\\rfloor</span> . Thus  <span class="math">p^e</span>  can be only larger than  <span class="math">2^{16}\\cdot 2^{16n}</span>  (the additional term  <span class="math">2^{16n}</span>  is due to the modulus change by rounding as described in Remark 2). That is, the bit-size of ring elements (in  <span class="math">\\mathbb{Z}_{p^e}</span> ) is linear in the multiplication depth.</p>

    <p class="text-gray-300">In our experiment, we considered nested matrix multiplications of depth  <span class="math">n = 6, 8, 10</span> , and 12. Depending on the multiplication depth, we took different sized fields or rings. That is, for the original GKR protocol over  <span class="math">\\mathbb{Z}_q</span> , we took the smallest Mersenne prime  <span class="math">q &amp;gt; (2^{16})^{2^n}</span> , i.e.,  <span class="math">(2^{1279} - 1)</span> ,  <span class="math">(2^{4253} - 1)</span> ,  <span class="math">(2^{19937} - 1)</span> , and  <span class="math">(2^{86243} - 1)</span> , respectively, while for our protocol over  <span class="math">\\mathbb{Z}_{p^e}[t] / (t^3 + 2)</span> , we took  <span class="math">p = 271 \\simeq 2^8</span>  and the smallest  <span class="math">e</span>  such that  <span class="math">p^e &amp;gt; 2^{16(n + 1)}</span> , i.e.,  <span class="math">p^e = 271^{14}</span> ,  <span class="math">271^{18}</span> ,  <span class="math">271^{22}</span> , and  <span class="math">271^{26}</span> , respectively, for each multiplication depth  <span class="math">n = 6, 8, 10</span> , and 12.</p>

    <p class="text-gray-300">In Figure 4, we compare the performance of our protocol to that of Thaler's on nested matrix multiplication of different depths. To highlight the net effect of rounding, we report the cost for a single matrix multiplication in the context of different multiplication depths. That is, the cost for the entire nested multiplication is the one in Figure 4 multiplied by the number of matrix multiplications.</p>

    <p class="text-gray-300">Figure 4 shows that the cost of Thaler's exponentially increases in the multiplication depth, while ours is linear in the depth. When the multiplication depth is small (e.g., depth 6), the cost of our protocol could be bigger than Thaler's, due to</p>

    <p class="text-gray-300">the overhead of rounding. However, when the multiplication depth is greater than a certain amount (e.g., depth 8), ours is much better than Thaler’s (e.g., two orders of magnitude better when depth is 12), and the difference will be exponential as the depth increases. This experimental result confirms that it is critical to support the rounding operation for verifiable computing of an approximate arithmetic circuit with a large multiplication depth.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">I-E Discussion</h3>

    <p class="text-gray-300">We want to note that there is still room for improvement of our implementation, since in this work, we have mainly focused on the proof-of-concept evaluation of our approach. In particular, the implementation of the individual operations of a Galois ring can be further improved. While those operations are sequentially executed in our current implementation, they can be easily broken down into multiple independent subroutines, being suitable for parallelization <em>[17, 21]</em> or hardware acceleration. This optimization will drastically reduce the overhead of increasing the dimension of a Galois ring, which in turn will allow us to employ a much smaller prime <span class="math">p</span>, further improving the overall performance of the protocol.</p>

    <p class="text-gray-300">On the other hand, the soundness probability of our protocol in Figure 4 is set to <span class="math">2^{-14}</span>, which is not high, but sufficient in certain contexts. Moreover, it can be quickly improved by simply running <span class="math">n</span> parallel pairs of the prover and the verifier, which yields <span class="math">(2^{-14})^{n}</span> soundness, without affecting the throughput performance. For example, running only four prover-verifier pairs in parallel will achieve <span class="math">2^{-56}&lt;10^{-16}</span> soundness, which is similar to the soundness probability (<span class="math">2^{-45}</span> to <span class="math">2^{-20}</span> <em>[48, 46]</em>) of existing verifiable computing scheme experiments.</p>

    <h2 id="sec-47" class="text-2xl font-bold">IX Related Work</h2>

    <p class="text-gray-300">The problem of delegating computation with securing integrity has been extensively studied in both theory and practice perspectives. Here we mainly focus on the general-purpose protocols and systems that aim to be practical.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">IX-A Interactive Proofs: GKR Protocol and Refinements</h3>

    <p class="text-gray-300">Goldwasser, Kalai, and Rothblum <em>[25]</em> proposed an interactive proof protocol (also known as GKR protocol) that runs in polynomial time. For a layered arithmetic circuit of size <span class="math">S</span> and depth <span class="math">d</span>, the prover of their protocol runs in time <span class="math">\\text{poly}(S)</span>, and the verifier runs in time <span class="math">\\text{poly}(d,\\log S)</span>.</p>

    <p class="text-gray-300">Several refinements of the GKR protocol have been proposed to improve the cost of the protocol, especially the prover’s cost. Cormode, Mitzenmacher, and Thaler <em>[18]</em> presented a refinement of the GKR porotocol (hereafter, CMT) that allows the prover to run in <span class="math">O(S\\log S)</span>. Thaler <em>[47]</em> further improved the protocol, which allows the prover to run in <span class="math">O(S)</span> for a circuit with a “sufficiently” regular wiring pattern. Subsequently, it has been shown that the prover’s cost can be reduced when a circuit is composed of many parallel copies of subcircuits. Specifically, the prover’s cost is reduced to <span class="math">O(S\\log S_{c})</span> in <em>[48, 59]</em>, and further reduced to <span class="math">O(S+S_{c}\\log S_{c})</span> in <em>[54]</em>, where <span class="math">S_{c}</span> is the size of a subcircuit. Recently, Xie <em>et al.</em> <em>[58]</em> proposed a refinement that allows the prover to run in <span class="math">O(S)</span> for an arbitrary circuit. Although being asymptotically equivalent, Thaler’s refinement <em>[47]</em> still performs better than Xie <em>et al.</em>’s <em>[58]</em> for a regular circuit.</p>

    <p class="text-gray-300">On the other hand, substantial efforts have been made to support more operations than the plain field arithmetic. Vu <em>et al.</em> <em>[52]</em> proposed an extension of CMT that supports inequalities by augmenting a circuit with additional verification logic and auxiliary inputs to be fed by the prover. However, their approach suffers from a significant overhead of the verifier due to the irregularity of their augmented circuit, which needs to be amortized by batching verifications (i.e., verifying the same circuit against many different inputs at the same time) for practical purposes. Zhang <em>et al.</em> <em>[59]</em> improved this by combining CMT with a verifiable polynomial delegation scheme, and showed that an arithmetic circuit with auxiliary inputs can be efficiently verified.</p>

    <p class="text-gray-300">There are other lines of refinement work such as supporting “streaming” verifiers <em>[15, 19]</em> that run in a limited space; employing hardware accelerators such as ASICs and GPUs <em>[53, 54, 50]</em>; and supporting zero-knowledge proofs <em>[56, 58]</em>.</p>

    <p class="text-gray-300">Note that, however, no existing interactive proof systems support a verifiable rounding operation, to the best of our knowledge, which is critical to deal with an approximate arithmetic circuit with a large depth.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">IX-B Arguments: Non-Interactiveness and Zero-Knowledge</h3>

    <p class="text-gray-300">Argument systems are different from interactive proofs in that they are secure only against <em>computationally bounded</em> dishonest provers. Employing cryptographic primitives, they can provide versatile properties such as non-interactiveness, public verifiability, and zero-knowledge proofs. However, the use of expensive cryptographic primitives incurs a significant overhead to the prover’s cost.</p>

    <p class="text-gray-300">There have been substantial efforts <em>[30, 34, 11, 7]</em> of developing argument systems based on probabilistically checkable proofs (PCPs) <em>[3, 2]</em>, especially ones called “short” PCPs. Although being asymptotically similar to their counterparts (that we will explain below), the PCP-based arguments involve large constants, being too expensive to be practical.</p>

    <p class="text-gray-300">On the other hand, there have been much efforts on developing argument systems without using the short PCPs. Setty <em>et al.</em> <em>[45, 46, 44]</em> proposed argument systems based on linear PCPs <em>[29]</em>, where their systems were shown to achieve a practical performance in the batch verification setting. Gennaro *et</p>

    <p class="text-gray-300">al. <em>[24]</em> introduced quadratic arithmetic programs (QAPs), a novel efficient encoding of computations, and proposed a zero-knowledge non-interactive argument system (zkSNARK). Much of improvements have been proposed <em>[39, 8, 10, 27]</em>, but these argument systems suffer from a trusted setup cost that needs to be amortized to be practically efficient. The trusted setup issue, however, has been largely addressed in recent work <em>[5, 9, 14, 56, 1, 42]</em>.</p>

    <p class="text-gray-300">There also has been substantial work <em>[6, 8, 10, 13, 55]</em> to extend the coverage of verifiable computing to a more generalized form of computations. Essentially, they developed a “compiler” that translates C-like programs (with e.g., memory accesses and control flows) into corresponding arithmetic circuits. However, their approaches often do not efficiently scale, due to the blowup in the size of generated circuits. On the other hand, <em>[46, 44]</em> presented an encoding of rational numbers in a finite field, but still did not support rounding, suffering from the same problem (i.e., the exponential blowup of the field size) with the integer scaling method described in Section VIII.</p>

    <h2 id="sec-50" class="text-2xl font-bold">X Concluding Remarks</h2>

    <p class="text-gray-300">We presented a verifiable computing scheme that supports rounding which is essential for approximate computations. Based on the (latest variant of) GKR protocol that is most efficient in generating proofs among existing verifiable computing protocols, our scheme consists of the following elements: generalization of the GKR protocol over a ring, reduction of the rounding operation to a low-degree polynomial in a ring, optimal circuit construction of arbitrary polynomials, and optimization of proof generation for rounding via a Galois ring. We implemented our scheme, and presented experimental results that show the efficiency of our scheme for approximate computations. For example, ours performed two orders of magnitude better than the existing GKR protocol for a nested matrix multiplication of depth 12 on the 16-bit fixed-point arithmetic.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Application to Verifiable AI.</h4>

    <p class="text-gray-300">We believe that this work is an important step toward the vision of verifiable AI computations. Specifically, the DNN training iterates the forward and backward passes over the sequence of layers, where each layer computation (in both forward and backward passes) consists of matrix multiplication and nonlinear function application on approximate arithmetic. Without the ability of rounding, the number of digits of the computation results will keep increasing and exceed the limit. Thus the existing VC approaches are not capable in the AI space. Our approach gives a theoretical feasibility for these computations. In addition, it also sheds light on the real-world performance – as shown in Section VIII, matrix multiplication on the fixed-point arithmetic can be efficiently supported by our scheme.</p>

    <p class="text-gray-300">Among the nonlinear functions, the ReLU and maxpooling functions can be represented in an (approximate) arithmetic circuit by using the comparison operation <em>[52, 59]</em>. The sigmoid and tanh functions were shown to be effectively approximated as a polynomial <em>[28]</em> with achieving a sufficient accuracy, while such a polynomial can be efficiently represented in a circuit by using our optimal circuit construction. The softmax function requires to compute the natural exponentiation function <span class="math">e^{x}</span>, which can be also approximated as a polynomial for <span class="math">x\\leq 0</span>, using the input normalization <em>[51]</em>, as mentioned in Section I.</p>

    <p class="text-gray-300">Moreover, multiple iterations can be “squashed” <em>[54]</em> into a wide and shallow circuit by laying identical subcircuits of a single iteration side by side. This squashing can drastically reduce the depth of a circuit, which can significantly improve the protocol’s performance <em>[48, 54]</em> at the cost of communication overheads. Finally, the protocol performance can be further improved by using hardware accelerators such as GPUs <em>[50, 48]</em> and ASICs <em>[53, 54]</em>.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Other applications of individual results.</h4>

    <p class="text-gray-300">As mentioned in the introduction, the individual technical results that we developed for the verifiable rounding operation have their own applications as well. First, our generalized GKR protocol can be used in other settings where rounding is not necessarily involved. For example, a ring <span class="math">\\mathbb{Z}_{p^{e}}</span> has a nice property that addition and multiplication on <span class="math">\\mathbb{Z}_{p^{e}}</span> are equivalent to that of the <span class="math">e</span>-bit machine integer arithmetic when <span class="math">p=2</span>, including the “wrapping-around” behavior in case of overflow (e.g., “<span class="math">4+4\\equiv 0</span>” in both <span class="math">Z_{2^{3}}</span> and the 3-bit (unsigned) machine integer arithmetic). Thanks to this property, for certain computations that inherently require the modular arithmetic (e.g., ones in cryptography implementations), one can construct arithmetic circuits of such computations at no extra cost. Note that to admit such computations with the original GKR protocol, one needs to additionally develop a circuit representation of the modulo reduction, i.e., <span class="math">x\\mapsto x\\bmod 2^{e}</span>, which incurs additional overheads in protocol performance due to the circuit size blowup.</p>

    <p class="text-gray-300">On the other hand, our optimal circuit construction is applicable to the original GKR protocol (and its variants) as well, since it is not specific to the underlying algebraic structure. That is, when a given computation involves evaluation of certain polynomials, our circuit construction scheme can be used to optimize the protocol performance.</p>

    <h2 id="sec-53" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam, “Ligero: Lightweight sublinear arguments without a trusted setup,” in <em>Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</em>, ser. CCS ’17, 2017, pp. 2087–2104.</li>

      <li>[2] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy, “Proof verification and the hardness of approximation problems,” <em>J. ACM</em>, vol. 45, no. 3, pp. 501–555, 1998.</li>

      <li>[3] S. Arora and S. Safra, “Probabilistic checking of proofs: A new characterization of np,” <em>J. ACM</em>, vol. 45, no. 1, pp. 70–122, 1998.</li>

    </ul>

    <p class="text-gray-300">[4] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy, “Checking computations in polylogarithmic time,” in <em>Proceedings of the twenty-third annual ACM symposium on Theory of computing</em>. ACM, 1991, pp. 21–32.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[5] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev, “Scalable, transparent, and post-quantum secure computational integrity,” Cryptology ePrint Archive, Report 2018/046, 2018.</li>

      <li>[6] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer, “Fast reductions from rams to delegatable succinct constraint satisfaction problems,” in <em>Proceedings of the 4th conference on Innovations in Theoretical Computer Science</em>. ACM, 2013, pp. 401–414.</li>

      <li>[7] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer, “On the concrete efficiency of probabilistically-checkable proofs,” in <em>Proceedings of the Forty-fifth Annual ACM Symposium on Theory of Computing</em>, ser. STOC ’13, 2013, pp. 585–594.</li>

      <li>[8] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza, “Snarks for c: Verifying program executions succinctly and in zero knowledge,” in <em>Advances in Cryptology–CRYPTO 2013</em>. Springer, 2013, pp. 90–108.</li>

      <li>[9] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward, “Aurora: Transparent succinct arguments for r1cs,” Cryptology ePrint Archive, Report 2018/828, 2018.</li>

      <li>[10] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Succinct non-interactive zero knowledge for a von neumann architecture.” in <em>USENIX Security Symposium</em>, 2014, pp. 781–796.</li>

      <li>[11] E. Ben-Sasson and M. Sudan, “Short pcps with polylog query complexity,” <em>SIAM J. Comput.</em>, vol. 38, no. 2, pp. 551–607, 2008.</li>

      <li>[12] A. Bishnoi, P. L. Clark, A. Potukuchi, and J. R. Schmitt, “On zeros of a polynomial in a finite grid,” <em>Combinatorics, Probability and Computing</em>, vol. 27, no. 3, pp. 310–333, 2018.</li>

      <li>[13] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Walfish, “Verifying computations with state,” in <em>Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles</em>. ACM, 2013, pp. 341–357.</li>

      <li>[14] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell, “Bulletproofs: Short proofs for confidential transactions and more,” in <em>2018 IEEE Symposium on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco, California, USA</em>, 2018, pp. 315–334.</li>

      <li>[15] A. Chakrabarti, G. Cormode, and A. Mcgregor, “Annotations in data streams,” in <em>International Colloquium on Automata, Languages, and Programming</em>. Springer, 2009, pp. 222–234.</li>

      <li>[16] H. Chen and K. Han, “Homomorphic lower digits removal and improved FHE bootstrapping,” in <em>Advances in Cryptology – EUROCRYPT 2018</em>, 2018, pp. 315–337.</li>

      <li>[17] J. W. Cooley and J. W. Tukey, “An algorithm for the machine calculation of complex fourier series,” <em>Mathematics of computation</em>, vol. 19, no. 90, pp. 297–301, 1965.</li>

      <li>[18] G. Cormode, M. Mitzenmacher, and J. Thaler, “Practical verified computation with streaming interactive proofs,” in <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>. ACM, 2012, pp. 90–112.</li>

      <li>[19] G. Cormode, J. Thaler, and K. Yi, “Verifying computations with streaming interactive proofs,” <em>Proceedings of the VLDB Endowment</em>, vol. 5, no. 1, pp. 25–36, 2011.</li>

      <li>[20] E. Driver, P. A. Leonard, and K. S. Williams, “Irreducible quartic polynomials with factorizations modulo p,” <em>The American Mathematical Monthly</em>, vol. 112, no. 10, pp. 876–890, 2005.</li>

      <li>[21] F. Franchetti, M. Puschel, Y. Voronenko, S. Chellappa, and J. M. Moura, “Discrete fourier transform on multicore,” <em>IEEE Signal Processing Magazine</em>, vol. 26, no. 6, pp. 90–102, 2009.</li>

      <li>[22] P. Garret, “Abstract algebra,” http://www-users.math.umn.edu/~garrett/m/algebra/notes/Whole.pdf, 2007, pp. 100–102.</li>

      <li>[23] R. Gennaro, C. Gentry, and B. Parno, “Non-interactive verifiable computing: Outsourcing computation to untrusted workers,” in <em>Annual Cryptology Conference</em>. Springer, 2010, pp. 465–482.</li>

      <li>[24] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, “Quadratic span programs and succinct nizks without pcps,” in <em>Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. Springer, 2013, pp. 626–645.</li>

      <li>[25] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum, “Delegating computation: interactive proofs for muggles,” in <em>Proceedings of the fortieth annual ACM symposium on Theory of computing</em>. ACM, 2008, pp. 113–122.</li>

      <li>[26] J. Gray and C. van Ingen, “Empirical measurements of disk failure rates and error rates,” <em>CoRR</em>, vol. abs/cs/0701166, 2007.</li>

      <li>[27] J. Groth, “On the size of pairing-based non-interactive arguments,” in <em>Proceedings, Part II, of the 35th Annual International Conference on Advances in Cryptology — EUROCRYPT 2016 - Volume 9666</em>, 2016, pp. 305–326.</li>

      <li>[28] E. Hesamifard, H. Takabi, and M. Ghasemi, “Cryptodl: Deep neural networks over encrypted data,” <em>CoRR</em>, vol. abs/1711.05189, 2017.</li>

      <li>[29] Y. Ishai, E. Kushilevitz, and R. Ostrovsky, “Efficient arguments without short pcps,” in <em>Computational Complexity, 2007. CCC’07. Twenty-Second Annual IEEE Conference on</em>. IEEE, 2007, pp. 278–291.</li>

      <li>[30] J. Kilian, “A note on efficient zero-knowledge proofs and arguments (extended abstract),” in <em>Proceedings of the Twenty-fourth Annual ACM Symposium on Theory of Computing</em>, ser. STOC ’92, 1992, pp. 723–732.</li>

      <li>[31] A. E. Kosha, D. Papadopoulos, C. Papamanthou, M. F. Sayed, E. Shi, and N. Triandopoulos, “Trueset: Faster verifiable set computations,” in <em>Proceedings of the 23rd USENIX Conference on Security Symposium</em>, ser. SEC’14. Berkeley, CA, USA: USENIX Association, 2014, pp. 765–780.</li>

      <li>[32] C. Lund, L. Fortnow, H. Karloff, and N. Nisan, “Algebraic methods for interactive proof systems,” <em>Journal of the ACM (JACM)</em>, vol. 39, no. 4, pp. 859–868, 1992.</li>

      <li>[33] B. R. McDonald, <em>Finite rings with identity</em>. Marcel Dekker Incorporated, 1974, vol. 28.</li>

      <li>[34] S. Micali, “Cs proofs,” in <em>Foundations of Computer Science, 1994 Proceedings., 35th Annual Symposium on</em>. IEEE, 1994, pp. 436–453.</li>

      <li>[35] D. Micciancio, “Lattice-based cryptography,” <em>Encyclopedia of Cryptography and Security</em>, pp. 713–715, 2011.</li>

      <li>[36] D. Micciancio and C. Peikert, “Trapdoors for lattices: Simpler, tighter, faster, smaller,” in <em>Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. Springer, 2012, pp. 700–718.</li>

      <li>[37] J. S. Milne, “Fields and galois theory (v4. 60),” <em>order</em>, vol. 3, p. 138, 2018.</li>

      <li>[38] P. L. Montgomery, “Modular multiplication without trial division,” <em>Mathematics of computation</em>, vol. 44, no. 170, pp. 519–521, 1985.</li>

      <li>[39] B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio: Nearly practical verifiable computation,” in <em>2013 IEEE Symposium on Security and Privacy</em>. IEEE, 2013, pp. 238–252.</li>

      <li>[40] M. S. Paterson and L. J. Stockmeyer, “On the number of nonscalar multiplications necessary to evaluate polynomials,” <em>SIAM Journal on Computing</em>, vol. 2, no. 1, pp. 60–66, 1973.</li>

      <li>[41] J. T. Schwartz, “Fast probabilistic algorithms for verification of polynomial identities,” <em>Journal of the ACM (JACM)</em>, vol. 27, no. 4, pp. 701–717, 1980.</li>

      <li>[42] S. Setty, “Spartan: Efficient and general-purpose zksnarks without trusted setup,” Cryptology ePrint Archive, Report 2019/550, 2019.</li>

      <li>[43] S. Setty, S. Angel, T. Gupta, and J. Lee, “Proving the correct execution of concurrent services in zero-knowledge,” in <em>Proceedings of the 12th USENIX Conference on Operating Systems Design and Implementation</em>, ser. OSDI’18. Berkeley, CA, USA: USENIX Association, 2018, pp. 339–356.</li>

      <li>[44] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish, “Resolving the conflict between generality and plausibility in verified computation,” in <em>Proceedings of the 8th ACM European Conference on Computer Systems</em>. ACM, 2013, pp. 71–84.</li>

      <li>[45] S. T. Setty, R. McPherson, A. J. Blumberg, and M. Walfish, “Making argument systems for outsourced computation practical (sometimes).” in <em>NDSS</em>, vol. 1, no. 9, 2012, p. 17.</li>

      <li>[46] S. T. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish, “Taking proof-based verified computation a few steps closer to practicality.” in <em>USENIX Security Symposium</em>, 2012, pp. 253–268.</li>

      <li>[47] J. Thaler, “Time-optimal interactive proofs for circuit evaluation,” in <em>Advances in Cryptology–CRYPTO 2013</em>. Springer, 2013, pp. 71–89.</li>

      <li>[48] J. Thaler, “Time-optimal interactive proofs for circuit evaluation,” <em>arXiv preprint arXiv:1304.3812</em>, 2013.</li>

      <li>[49] J. Thaler, “A note on the gkr protocol,” 2015.</li>

      <li>[50] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pfister, “Verifiable computation with massively parallel interactive proofs,” <em>arXiv preprint arXiv:1202.1350</em>, 2012.</li>

      <li>[51] T. Vieira, “Exp-normalize trick,” https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/.</li>

      <li>[52] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish, “A hybrid architecture for interactive verifiable computation,” in <em>Security and Privacy (SP), 2013 IEEE Symposium on</em>. IEEE, 2013, pp. 223–237.</li>

    </ul>

    <p class="text-gray-300">[53] R. S. Wahby, M. Howald, S. Garg, A. Shelat, and M. Walfish, “Verifiable asics,” in <em>Security and Privacy (SP), 2016 IEEE Symposium on</em>. IEEE, 2016, pp. 759–778.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[54] R. S. Wahby, Y. Ji, A. J. Blumberg, A. Shelat, J. Thaler, M. Walfish, and T. Wies, “Full accounting for verifiable outsourcing,” in <em>Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</em>. ACM, 2017, pp. 2071–2086.</li>

      <li>[55] R. S. Wahby, S. T. Setty, Z. Ren, A. J. Blumberg, and M. Walfish, “Efficient ram and control flow in verifiable outsourced computation.” in <em>NDSS</em>, 2015.</li>

      <li>[56] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish, “Doubly-efficient zksnarks without trusted setup,” in <em>2018 IEEE Symposium on Security and Privacy (SP)</em>. IEEE, 2018, pp. 926–943.</li>

      <li>[57] P. Warden, “Why GEMM is at the heart of deep learning,” https://petewarden.com/2015/04/20/.</li>

      <li>[58] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song, “Libra: Succinct zero-knowledge proofs with optimal prover computation,” Cryptology ePrint Archive, Report 2019/317, 2019.</li>

      <li>[59] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou, “vsql: Verifying arbitrary sql queries over dynamic outsourced databases,” in <em>2017 IEEE Symposium on Security and Privacy (SP)</em>. IEEE, 2017, pp. 863–880.</li>

    </ul>

    <h2 id="sec-54" class="text-2xl font-bold">Appendix A A. Circuit Representation for Verifiable Polynomial Delegation.</h2>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">Notation</h3>

    <p class="text-gray-300">Assume we are given a polynomial <span class="math">g</span> over a finite ring <span class="math">\\mathbb{Z}_{p^{e}}</span>. (Our representation is also valid with a polynomial over a finite field <span class="math">\\mathbb{F}</span>.) Let us fix <span class="math">N=2^{2n}</span> to denote the smallest power of four such that <span class="math">N\\geq\\deg(g)</span>. Let us index each layer where the input layer is indexed by 0. Let us also index each gate in a layer where the left-most gate is indexed by 0, and the index value is represented in the binary form. We write <span class="math">\\tilde{V}_{i}</span> to denote the MLE of the output values of the <span class="math">i^{\\mathrm{th}}</span> layer as usual. For the simplicity of the presentation, we assume that the number of inputs denoted by <span class="math">M=2^{m}</span> is a power of two, in multi-input case. We write <span class="math">\\beta_{s}(x,y):\\mathbb{Z}_{p^{e}}^{s}\\times\\mathbb{Z}_{p^{e}}^{s}\\rightarrow\\mathbb{Z}_{p^{e}}</span> to denote the MLE of <span class="math">B_{s}(x,y):\\{0,1\\}^{s}\\times\\{0,1\\}^{s}\\rightarrow\\{0,1\\}</span> where <span class="math">B_{s}(x,y)</span> is the comparison function that returns 1 if <span class="math">x=y</span>, and 0 otherwise. We write <span class="math">\\vec{1}_{s}=(1,1,\\ldots,1)\\in\\{0,1\\}^{s}</span>, and <span class="math">\\chi_{s}(x):=B_{s}(x,\\vec{1}_{s}):\\{0,1\\}^{s}\\rightarrow\\{0,1\\}</span>. We omit <span class="math">s</span> when it is obvious.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">Description</h3>

    <p class="text-gray-300">Now we present the circuit representation for the polynomial <span class="math">g(t)=\\sum_{i=0}^{N}a_{i}t^{i}</span>. The circuit is composed of four parts, each of which is called <em>polygen</em>, <em>eval</em>, <em>unify</em>, and <em>extract</em>, respectively, as illustrated in Figure 1. We note that, as we will explain below, the <em>eval</em> and <em>unify</em> layers consist of two sub-circuits placed in parallel, where the left-hand side sub-circuit computes the sub-polynomials <span class="math">g_{i}</span> and <span class="math">g_{i,j}</span>, while the right-hand side one computes the power terms <span class="math">t^{i}</span>. Although the two sub-circuits compute different types of values, we design them to have the identical wiring pattern by introducing the dummy gates (i.e., the gates computing zero), so that the overall circuit becomes <em>regular</em>, allowing the verifier to be efficient. Here, the dummy gates affect only the width of the circuit, not the depth, and thus their effect on the verifier’s cost is negligible, i.e., asymptotically zero, as the verifier’s cost is logarithmically proportional to the circuit width. We first describe the single-input case (Figure 1).</p>

    <p class="text-gray-300">The <em>polygen</em> part corresponds to the sub-circuit between the layers 1 and <span class="math">n</span>, where for each <span class="math">i^{\\mathrm{th}}</span> layer, the input values are <span class="math">\\{t^{j}\\}_{j=1}^{2^{i-1}}</span>, and the output values are <span class="math">\\{t^{j}\\}_{j=1}^{2^{i}}</span>. Now we have the following relation between <span class="math">\\tilde{V}_{i+1}</span> and <span class="math">\\tilde{V}_{i}</span> (for <span class="math">0\\leq i&lt;n</span>) as follows.</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i+1}(z)=\\tilde{V}_{i}(z_{-0})[(1-z_{0})+z_{0}\\tilde{V}_{i}(\\vec{1})]</span></p>

    <p class="text-gray-300">where <span class="math">z=(z_{0},z_{1},\\ldots z_{i})</span>, <span class="math">z_{-0}=(z_{1},z_{2},\\ldots z_{i})</span>, <span class="math">\\vec{1}=(1,1,\\ldots,1)</span>, and <span class="math">\\tilde{V}_{0}=t</span>. The validity of this equation is derived from the fact that both sides of the equation are MLEs in <span class="math">z</span> agreeing on <span class="math">\\{0,1\\}^{i+1}</span>, and the uniqueness of MLE (Lemma 2) that holds for an arbitrary ring (Section IV-B). Recall that the gate index value is represented in a bit vector, e.g., <span class="math">\\tilde{V}_{2}(0,0)=t</span>, <span class="math">\\tilde{V}_{2}(0,1)=t^{2}</span>, <span class="math">\\tilde{V}_{2}(1,0)=t^{3}</span>, and <span class="math">\\tilde{V}_{2}(1,1)=t^{4}</span> denote the output value of the first, the second, the third, and the fourth gate of the second layer, respectively, as shown in Figure 1.</p>

    <p class="text-gray-300">The <em>eval</em> layer, i.e., the <span class="math">(n+1)^{\\mathrm{th}}</span> layer, produces <span class="math">2\\sqrt{N}</span> output values which consists of <span class="math">g_{1}(t),\\cdots,g_{\\sqrt{N}}(t),0,0,\\cdots,0,t^{\\sqrt{N}}</span>, from the input values <span class="math">\\{t^{j}\\}_{j=1}^{\\sqrt{N}}</span>. Each <span class="math">g_{k}</span> (for <span class="math">1\\leq k\\leq n</span>) is a polynomial of degree at most <span class="math">\\sqrt{N}</span>, defined by <span class="math">g_{k}(t)=\\sum_{j=1}^{\\sqrt{N}}a_{j+\\sqrt{N}(k-1)}t^{j}</span>. The zeros are the outputs of dummy gates as explained earlier. Now we have the following relation between the two MLEs.</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{n+1}(z)=\\sum_{q\\in\\{0,1\\}^{n}}\\alpha(z,q)\\cdot\\tilde{V}_{n}(q)\\;\\;\\text{where}\\;z=(z_{0},z_{1},\\ldots,z_{n}),</span> \\[ \\alpha(z,q):=\\text{MLE of }\\begin{cases}a_{[(x,y)]},&\\text{if }z_{0}=0\\\\ \\chi_{2n},&\\text{if }z_{0}=1\\end{cases} \\]</p>

    <p class="text-gray-300">where <span class="math">[v]</span> denotes the integer value represented by the binary vector <span class="math">v</span>, e.g., <span class="math">[(1,1,0,1)]=13</span>.</p>

    <p class="text-gray-300">The <em>unify</em> part follows the <em>eval</em> layer, corresponding to a sub-circuit of depth <span class="math">\\log\\sqrt{N}</span> from the <span class="math">(n+2)^{\\mathrm{th}}</span> layer to the <span class="math">(2n+1)^{\\mathrm{th}}</span> layer, as shown in Figure 1. Each layer of the <em>unify</em> part takes as input, <span class="math">g_{1}(t),\\ldots,g_{i}(t),0,\\ldots,0,t^{j}</span>, and produces <span class="math">g_{1,2}(t),\\ldots,g_{i-1,i}(t),0,\\ldots,0,t^{2j}</span>, where <span class="math">g_{k,k+1}=g_{k}+g_{k+1}t^{j}</span>. The final layer of the <em>unify</em> part will produce <span class="math">(g(t)-a_{0})</span> and <span class="math">t^{N}</span>. Now we have the following relation between two adjacent MLEs.</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{i+1}(z)=\\tilde{V}_{i}(z,0)+\\tilde{V}_{i}(z,1)\\cdot\\tilde{V}_{i}(1,1,\\ldots,1)</span></p>

    <p class="text-gray-300">where <span class="math">z=(z_{0},z_{1},\\ldots,z_{2n-i})</span>.</p>

    <p class="text-gray-300">Note that the above equation makes no distinction between the two sub-circuits, i.e., one that computes <span class="math">g_{1,2}(t),\\ldots,g_{i-1,i}(t)</span> and another that computes <span class="math">0,\\ldots,t^{2j}</span>, which significantly reduces the prover’s cost that otherwise would have been very large. This is achieved by introducing the dummy gates that compute zero, as explained earlier.</p>

    <p class="text-gray-300">Finally, the <em>extract</em> layer, i.e., the <span class="math">(2n+2)^{\\mathrm{th}}</span> layer, takes two inputs <span class="math">(g(t)-a_{0})</span> and <span class="math">t^{N}</span>, and simply returns <span class="math">g(t)</span> by adding the constant <span class="math">a_{0}</span> to the first input. The relation is as follows:</p>

    <p class="text-gray-300"><span class="math">\\tilde{V}_{2n+2}=\\tilde{V}_{2n+1}(0)+a_{0}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each polygen layer,  <span class="math">\\tilde{V}_i(w,z):\\mathbb{Z}_{p^e}^m\\times \\mathbb{Z}_{p^e}^i\\to \\mathbb{Z}_{p^e}</span> <span class="math">(0\\leq i\\leq n - 1)</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} _ {i + 1} (w, z) = \\sum_ {q \\in \\{0, 1 \\} ^ {m}} \\beta (w, q) \\tilde {V} _ {i} (q, z _ {- 0}) [ (1 - z _ {0}) + z _ {0} \\tilde {V} _ {i} (q, \\vec {1} _ {i}) ]</span></div>

    <p class="text-gray-300">where  <span class="math">z = (z_0, z_1, \\ldots, z_i) \\in \\mathbb{Z}_{p^e}^{i+1}</span> , and  <span class="math">z_{-0} = (z_1, z_2, \\ldots, z_i) \\in \\mathbb{Z}_{p^e}^i</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the eval layer,  <span class="math">\\tilde{V}_{n + 1}(w,z):\\mathbb{Z}_{p^e}^m\\times \\mathbb{Z}_{p^e}^{n + 1}\\to \\mathbb{Z}_{p^e}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} _ {n + 1} (w, z) = \\sum_ {q \\in \\{0, 1 \\} ^ {n}} \\alpha (z, q) \\cdot \\tilde {V} _ {n} (w, q)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each unify layer,  <span class="math">\\tilde{V}_{j+1}(w,z): \\mathbb{Z}_{p^e}^m \\times \\mathbb{Z}_{p^e}^{2n+1-j} \\to \\mathbb{Z}_{p^e}</span>  ( <span class="math">n + 1 \\leq j \\leq 2n</span> ),</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} _ {j + 1} (w, z) = \\sum_ {q \\in \\{0, 1 \\} ^ {m}} \\beta (w, q) [ \\tilde {V} _ {j} (q, z, 0) + \\tilde {V} _ {j} (q, z, 1) \\cdot \\tilde {V} _ {j} (q, \\vec {1} _ {2 n + 2 - j}) ]</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the extract layer,  <span class="math">\\tilde{V}_{2n + 2}(w):\\mathbb{Z}_{p^e}^m\\to \\mathbb{Z}_{p^e}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} _ {2 n + 2} (w) = \\tilde {V} _ {2 n + 1} (w, 0) + a _ {0}</span></div>

    <p class="text-gray-300">Fig. 5: Construction of (sub-)circuit representation of a polynomial evaluation that consists of  <span class="math">M = 2^{m}</span>  inputs. Here we consider operations over  <span class="math">\\mathbb{Z}_{p^e}</span> , and the polynomial in the form of  <span class="math">g(t) = \\sum_{i=0}^{N} a_i t^i</span>  for the smallest  <span class="math">N = 2^{2n} \\geq \\deg(g)</span> . We write  <span class="math">\\vec{1}_k = (1, \\ldots, 1) \\in \\mathbb{Z}_{p^e}^k</span> , and  <span class="math">\\alpha(z, q) : \\mathbb{Z}_{p^e}^{n+1} \\times \\mathbb{Z}_{p^e}^n \\to \\mathbb{Z}_{p^e}</span>  to denote the MLE of a boolean hypercube function  <span class="math">A(x) : \\{0, 1\\}^{2n+1} \\to \\mathbb{Z}_{p^e}</span>  that represents  <span class="math">(a_1, \\ldots, a_N, 0, \\ldots, 0, 1) \\in \\mathbb{Z}_{p^e}^{2N}</span> . For example,  <span class="math">A(0, 0, \\ldots, 0) = a_1</span> ,  <span class="math">A(0, 1, \\ldots, 1) = a_N</span> , and  <span class="math">A(1, 1, \\ldots, 1) = 1</span> . We also write  <span class="math">\\beta(w, p) : \\mathbb{Z}_{p^e}^m \\times \\mathbb{Z}_{p^e}^m \\to \\mathbb{Z}_{p^e}</span>  to denote the MLE of a comparison function  <span class="math">B(x, y) : \\{0, 1\\}^m \\times \\{0, 1\\}^m \\to \\{0, 1\\}</span>  where  <span class="math">B(x, y)</span>  returns 1 if  <span class="math">x = y</span> , and 0 otherwise.</p>

    <p class="text-gray-300">The multi-input case with  <span class="math">M = 2^{m}</span>  number of inputs follows naturally from single-input case described so far (see Figure 5).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. (Sketch) Completeness directly follows from the protocol description. The main idea for showing soundness can be summarized as follows (See [25] or [32] for the full proof). Assume that a (dishonest)  <span class="math">\\mathcal{P}&#x27;</span>  sends an incorrect result  <span class="math">S(f)&#x27; \\neq S(f)</span>  to  <span class="math">\\mathcal{V}</span> . Let us distinguish the values claimed by  <span class="math">\\mathcal{P}&#x27;</span>  from the values which would be claimed by an honest  <span class="math">\\mathcal{P}</span>  by adding the prime (') symbol. Then  <span class="math">f_1(t)&#x27; \\neq f_1(t)</span> . Otherwise,  <span class="math">\\mathcal{V}</span>  will reject immediately by checking if  <span class="math">S(f)&#x27; = f_1(0)&#x27; + f_1(1)&#x27;</span> . When  <span class="math">\\mathcal{V}</span>  chooses a random  <span class="math">r_1</span>  from  <span class="math">\\mathbb{F}</span> , by the Schwartz-Zippel lemma (Lemma 1),  <span class="math">f_1(r_1)&#x27; \\neq f_1(r_1)</span>  with the high probability  $(1 - \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">  since  </span>f_1(t)<span class="math">  is a polynomial of degree at most  </span>d<span class="math"> . If  </span>f_1(r_1)' \\neq f_1(r_1)<span class="math"> ,  </span>\\mathcal{P}'<span class="math">  must send  </span>f_2(t)' \\neq f_2(t)<span class="math">  because of the same reasoning as before. Continuing this,  </span>\\mathcal{P}'<span class="math">  must send  </span>f_n(t)' \\neq f_n(t) = f(r_1, \\ldots, r_{n-1}, t)<span class="math"> , and will be rejected with the high probability by  </span>\\mathcal{V}<span class="math">  who finally checks if  </span>f_n(r_n)' = f(r_1, \\ldots, r_n)<span class="math">  for a randomly chosen  </span>r_n<span class="math">  in  </span>\\mathbb{F}<span class="math"> . The soundness probability bound is derived from the probability  </span>1 - (1 - \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^n$  that at least one of the above high probability events does not occur during the protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Uniqueness follows from the observation that any multilinear polynomial  <span class="math">\\tilde{V}(x_1, x_2, \\ldots, x_n)</span>  can be represented</p>

    <p class="text-gray-300">by  <span class="math">\\sum_{b\\in \\{0,1\\} ^n}C(b)x_b</span>  , where  <span class="math">x_{b}\\coloneqq \\Pi_{i\\in I}x_{i}</span>  with  <span class="math">I\\coloneqq \\{i\\mid b_i = 1\\}</span>  , and  <span class="math">C(b)\\in \\mathbb{F}</span>  is a coefficient corresponding to each monomial  <span class="math">x_{b}</span>  . Then,  <span class="math">C(b)</span>  is uniquely determined by  <span class="math">\\tilde{V} (b)</span>  's for  <span class="math">b\\in \\{0,1\\} ^n</span>  . Specifically, for a zero vector  <span class="math">\\vec{0},C(\\vec{0}) = \\tilde{V} (\\vec{0})</span>  For an elementary vector  <span class="math">e_i</span>  whose  <span class="math">i</span>  -th component is 1 and all others are 0,  <span class="math">C(e_i) = \\tilde{V} (e_i) - C(\\vec{0})</span>  . For a vector  <span class="math">e_{i,j}\\in \\{0,1\\} ^n</span> <span class="math">(i\\neq j)</span>  whose  <span class="math">i</span>  -th and  <span class="math">j</span>  -th components are 1 and all others are 0,  <span class="math">C(e_{i,j}) = \\tilde{V} (e_{i,j}) - C(e_i) - C(e_j) - C(\\vec{0})</span>  Continuing this process with increasing the weight of each vector  <span class="math">b\\in \\{0,1\\} ^n</span>  , we can see that every  <span class="math">C(b)</span>  is uniquely determined by  <span class="math">\\tilde{V} (b)</span>  for  <span class="math">b\\in \\{0,1\\} ^n</span></p>

    <p class="text-gray-300">Proof. It follows from the induction on the number of variables  <span class="math">n</span>  as the original Schwartz-Zippel lemma (Lemma 1), provided that it holds in the single variable case. Let  <span class="math">a_1 \\in A</span>  be a root of  <span class="math">f(t)</span> . By the division algorithm with a monic polynomial  <span class="math">(t - a_1)</span> ,  <span class="math">f(t) = (t - a_1)f_1(t)</span>  and the degree of  <span class="math">f_1(t)</span>  is less than that of  <span class="math">f(t)</span> . Note that another root, if exists,  <span class="math">a_2 \\in A</span>  ( <span class="math">a_2 \\neq a_1</span> ) must be a root of  <span class="math">f_1(t)</span>  since  <span class="math">(a_2 - a_1)</span>  is not a zero divisor and  <span class="math">f(a_2) = 0</span> . Then, the division algorithm with a monic polynomial  <span class="math">(t - a_2)</span>  on  <span class="math">f_1(t)</span>  gives  <span class="math">f(t) = (t - a_1)(t - a_2)f_2(t)</span>  and the degree of  <span class="math">f_2(t)</span>  is less than that of  <span class="math">f_1(t)</span> . Continuing this process, we conclude that  <span class="math">f(t)</span>  cannot have more roots in  <span class="math">A</span>  than the degree of  <span class="math">f(t)</span> .</p>

    <p class="text-gray-300">Proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof is almost the same as that of the original Sum-Check protocol. The generalized Schwartz-Zippel lemma (Lemma 3) implies that any two distinct univariate polynomials of degree <span class="math">\\leq d</span> over <span class="math">R</span> agree on at most <span class="math">d</span> points among <span class="math">A</span>. Following the proof of the original Sum-Check protocol (Theorem 1), the soundness probability of the generalized Sum-Check protocol is bounded by $\\frac{nd}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">V-B5 Proof of Lemma 5 (Prover Cost)</h4>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The circuit representation is composed of four parts; <em>polygen</em>, <em>eval</em>, <em>unify</em>, <em>extract</em>, and <em>division</em> as described before, and the depth is <span class="math">2n+3=O(\\log N)</span>. We first estimate the cost of <span class="math">\\mathcal{P}</span> for evaluating the circuit. It is simply <span class="math">M</span> times of the cost for evaluating the circuit of single rounding gate, and we only estimate the single case (Fig.1). The i-th layer in <em>polygen</em> requires <span class="math">2^{i-1}</span> multiplications resulting in <span class="math">O(2^{n})</span> total for <em>polygen</em> part. The <em>eval</em> layer requires <span class="math">O(2^{n}\\cdot 2^{n+1})=O(2^{2n})</span> operations, since evaluating each <span class="math">f_{i}(t)</span> given <span class="math">\\{t^{j}\\}_{j=1}^{2^{n}}</span> requires <span class="math">O(2^{n})</span> operations. The j-th layer in <em>unify</em> requires <span class="math">2^{2n+3-j}</span> operations resulting in <span class="math">O(2^{n})</span> total for <em>unify</em> part. Since <em>extract</em> and <em>division</em> part is of negligible cost, the total cost for evaluation is <span class="math">O(2^{n}+2^{2n}+2^{n})=O(N)</span>, resulting in <span class="math">O(NM)</span> for <span class="math">M</span> rounding gates.</p>

    <p class="text-gray-300">Now we estimate the cost of <span class="math">\\mathcal{P}</span> for proving the evaluation given all output of gates in the circuit. We assume Thaler <em>[48]</em>’s Reusing Work reducing <span class="math">\\mathcal{P}</span>’s cost for evaluating all <span class="math">\\beta_{m}(w,p)</span>, <span class="math">\\tilde{V}(q)</span>, and <span class="math">\\alpha(r)</span> values required for sum-check to be only <span class="math">O(2^{m})</span>, <span class="math">O(2^{s})</span>, and <span class="math">O(2^{t})</span> respectively, where <span class="math">m</span>, <span class="math">s</span>, and <span class="math">t</span> are the number of variables constituting <span class="math">p</span>, <span class="math">q</span>, and <span class="math">r</span>, respectively^{xxv}. Thus, for estimation of the cost, it suffices to count the number of variables appear in summands of the relation of MLEs in multi rounding case (Figure 5).</p>

    <p class="text-gray-300">In <em>polygen</em> part, reducing from <span class="math">\\tilde{V}_{i+1}</span> to <span class="math">\\tilde{V}_{i}</span> requires <span class="math">O(2^{m}+2^{m+i})</span> cost for sum-check, and additional <span class="math">O(i\\cdot 2^{i})</span> cost for reducing to single point, resulting in total <span class="math">O(2^{m+n}+n\\cdot 2^{n})</span> cost. In <em>eval</em> layer, sum-check requires <span class="math">O(2^{2n+1}+2^{m+n})</span> cost. In <em>unify</em> part, reducing from <span class="math">\\tilde{V}_{j+1}</span> to <span class="math">\\tilde{V}_{j}</span> requires <span class="math">O(2^{m}+2^{m+2n+2-j})</span> cost for sum-check, and additional <span class="math">O((2n+2-j)\\cdot 2^{2n+2-j})</span> cost for reducing to single point^{xxvi}, resulting in total <span class="math">O(2^{m+n}+n\\cdot 2^{n})</span> cost. The <em>extract</em> and <em>division</em> layer doesn’t affect <span class="math">\\mathcal{P}</span>’s cost since it does not require sum-check. Overall, the cost of proving is <span class="math">O(2^{m+n}+2^{2n}+2^{m+n}+n\\cdot 2^{n})</span> which is <span class="math">O(\\sqrt{N}M+N)</span>. ∎</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">V-B6 Proof of Lemma 5 (Verifier Cost)</h4>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that <span class="math">\\alpha(z,q)</span> can be precomputed in cost <span class="math">O(N)</span>, using memoization <em>[52]</em>, and will not be considered in the following estimation. Each <span class="math">\\beta_{m}</span> can be evaluated in cost <span class="math">O(m)</span> due to its simple form <em>[48, Section 4.3.1]</em>, without affecting the asymptotic cost of <span class="math">\\mathcal{V}</span>. Also, as the original GKR protocol, <span class="math">\\mathcal{V}</span>’s cost for the initial and final step is <span class="math">O(M\\log M)</span>, since there are <span class="math">O(M)</span> input and output.</p>

    <p class="text-gray-300">Now, we can estimate the cost of <span class="math">\\mathcal{V}</span> based on that in the sum-check (Theorem 1). Recall that in sum-check, the cost of <span class="math">\\mathcal{V}</span> depends on the number of variables managed by summation. In <em>polygen</em> layers, reducing from <span class="math">\\tilde{V}_{i+1}</span> to <span class="math">\\tilde{V}_{i}</span> requires <span class="math">\\mathcal{V}</span> to perform <span class="math">O(m)</span> operations for sum-check, and <span class="math">O(i)</span> for reducing to single point. Therefore, the cost for <em>polygen</em> layers is <span class="math">O(mn+n^{2})</span>. In <em>eval</em> layer, <span class="math">O(n)</span> cost is required. In <em>unify</em> layers, reducing from <span class="math">\\tilde{V}_{j+1}</span> to <span class="math">\\tilde{V}_{j}</span> requires <span class="math">\\mathcal{V}</span> to perform <span class="math">O(m)</span> operations for sum-check, <span class="math">O(2n+2-j)</span> for reducing to single point, resulting in <span class="math">O(mn+n^{2})</span> cost total. Since the cost for <em>extract</em> and <em>division</em> layers are negligible, the total cost of <span class="math">\\mathcal{V}</span> without initial and final step is <span class="math">O(mn+n^{2})=O(\\log N\\log MN)</span>. The bound of soundness probability and communication cost can be estimated similarly. ∎</p>

    <h4 id="sec-66" class="text-lg font-semibold mt-6">V-B7 Proof of Lemma 6</h4>

    <p class="text-gray-300">We exploit following Lemma whose proof can be found in <em>[37]</em>.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300"><em>[37, Lemma 5.9]</em> An <span class="math">n</span>-th cyclotomic polynomial <span class="math">\\Phi_{n}</span> of degree <span class="math">\\varphi(n)</span> is irreducible if and only if <span class="math">p</span> is a primitive root modulo <span class="math">n</span> (i.e., <span class="math">p</span> does not divide <span class="math">n</span>), and its multiplicative order modulo <span class="math">n</span> is <span class="math">\\varphi(n)</span>, where <span class="math">\\varphi</span> is the Euler’s totient function.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proof of Lemma 6.</h6>

    <p class="text-gray-300">(i), (ii), (iii) directly follows from the above lemma and the fact that each prime <span class="math">p</span> is a primitive root modulo <span class="math">4,5</span>, or <span class="math">9</span>, respectively.</p>

    <p class="text-gray-300">More algebraic proof can be found in <em>[22]</em>.</p>

    <p class="text-gray-300">For (iv), note that if <span class="math">x^{3}-a</span> is reducible, it has monic factor and <span class="math">x^{3}-a</span> has a solution in <span class="math">\\mathbb{Z}_{p}</span>. We show that there exists an <span class="math">a</span> such that <span class="math">x^{3}-a</span> has no solution in <span class="math">\\mathbb{Z}_{p}</span> which is equivalent to the claim that the function <span class="math">t\\to t^{3}:\\mathbb{Z}_{p}\\to\\mathbb{Z}_{p}</span> is not injective. Note that the multiplicative group <span class="math">\\mathbb{Z}_{p}^{\\times}</span> of <span class="math">\\mathbb{Z}_{p}</span> has order <span class="math">p-1</span>, and the order is multiple of <span class="math">3</span> when <span class="math">p\\equiv 1\\mod 3</span>. Now, by Sylow theorem, there exists a group of order <span class="math">3</span> in <span class="math">\\mathbb{Z}_{p}^{\\times}</span>, and there exists at least <span class="math">3</span> elements in <span class="math">\\mathbb{Z}_{p}</span> whose cube is <span class="math">1</span>. Therefore, the claim follows.</p>

    <p class="text-gray-300">(v), (vi) follows from general irreducibility results on quartic polynomials <em>[20, Theorem 3.(iv)]</em>.</p>

    <p class="text-gray-300">Note that above Lemma 7 implies that we can find many irreducible cyclotomic polynomials (with few non-zero coefficients) of higher degree, if needed. ∎</p>`;
---

<BaseLayout title="Verifiable Computing for Approximate Computation (2019/762)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/762
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
