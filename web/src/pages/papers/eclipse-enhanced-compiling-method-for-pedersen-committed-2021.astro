---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/934';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'ECLIPSE: Enhanced Compiling method for Pedersen-committed zkSNARK Engines';
const AUTHORS_HTML = 'Diego F.  Aranha, Emil Madsen Bennedsen, Matteo Campanelli, Chaya Ganesh, Claudio Orlandi, Akira Takahashi';

const CONTENT = `    <p class="text-gray-300">ECLIPSE: Enhanced Compiling method for Pedersen-committed zkSNARK Engines\\*</p>

    <p class="text-gray-300">Diego F. Aranha<span class="math">^{1}</span>, Emil Madsen Bennedsen<span class="math">^{2}</span>, Matteo Campanelli<span class="math">^{1}</span>, Chaya Ganesh<span class="math">^{3}</span>, Claudio Orlandi<span class="math">^{1}</span>, and Akira Takahashi<span class="math">^{1}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Aarhus University, Aarhus, Denmark {dfaranha, matteo, orlandi, takahashi}@cs.au.dk</p>

    <p class="text-gray-300"><span class="math">^{2}</span> Concordium, Denmark masik7@gmail.com</p>

    <p class="text-gray-300"><span class="math">^{3}</span> Indian Institute of Science, India chaya@iisc.ac.in</p>

    <p class="text-gray-300">September 16, 2021</p>

    <p class="text-gray-300">Abstract. We advance the state-of-the art for zero-knowledge commit-and-prove SNARKs (CP-SNARKs). CP-SNARKs are an important class of SNARKs which, using commitments as “glue”, allow to efficiently combine proof systems—e.g., general-purpose SNARKs (an efficient way to prove statements about circuits) and <span class="math">\\Sigma</span>-protocols (an efficient way to prove statements about group operations). Thus, CP-SNARKs allow to efficiently provide zero-knowledge proofs for composite statements such as <span class="math">h = H(g^x)</span> for some hash-function <span class="math">H</span>.</p>

    <p class="text-gray-300">Our main contribution is providing the first construction of CP-SNARKs where the proof size is succinct in the number of commitments.</p>

    <p class="text-gray-300">We achieve our result by providing a general technique to compile Algebraic Holographic Proofs (AHP) (an underlying abstraction used in many modern SNARKs) with special “decomposition” properties into an efficient CP-SNARK. We then show that some of the most efficient AHP constructions—Marlin, PLONK, and Sonic—satisfy our compilation requirements.</p>

    <p class="text-gray-300">Our resulting SNARKs achieve universal and updatable reference strings, which are highly desirable features as they greatly reduce the trust needed in the SNARK setup phase.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Research supported by: the Concordium Blockchain Research Center, Aarhus University, Denmark; the Carlsberg Foundation under the Semper Ardens Research Project CF18-112 (BCM); the European Research Council (ERC) under the European Unions’s Horizon 2020 research and innovation programme under grant agreement No 803096 (SPEC);</li>

    </ul>

    <p class="text-gray-300">1 Introduction 3 1.1 Applications 3 1.2 Our Contributions 4 1.3 Technical Overview 5 1.4 Related Work 6</p>

    <p class="text-gray-300">2 Preliminaries 8 2.1 Indexed relations 8 2.2 Zero-knowledge Arguments of Knowledge with preprocessing 8 2.3 Algebraic Holographic Proofs 9 2.4 Polynomial Commitment 10</p>

    <p class="text-gray-300">3 AHP-to-CP-SNARK compiler 11 3.1 Additional Preliminaries for Compiler 11 3.2 Additional properties for AHP 12 3.3 Our compiler 13</p>

    <p class="text-gray-300">4 Compressed <span class="math">\\Sigma</span>-protocol for Equality 16 4.1 AmComEq: Amortization of <span class="math">\\ell</span> commitment equality proofs 16 4.2 CompAmComEq: Recursive compression 19</p>

    <p class="text-gray-300">5 Instantiation with PLONK 20 5.1 PLONK AHP 20 5.2 CP-PLONK 20</p>

    <p class="text-gray-300">6 Instantiation with Marlin 22 6.1 Marlin AHP 22 6.2 CP-Marlin 23</p>

    <p class="text-gray-300">7 Instantiation with Sonic 24 7.1 Sonic AHP 25 7.2 CP-Sonic 27</p>

    <p class="text-gray-300">A Additional Materials on Compressed <span class="math">\\Sigma</span>-protocol Theory 32 A.1 <span class="math">\\Sigma</span>-Protocols and Pedersen Vector Commitment 32 A.2 ComEq: Proving equality of two Pedersen vector commitments 32 A.3 AmComEq: as a result of [ACF20] 33</p>

    <p class="text-gray-300">B PLONK Preliminaries 33 B.1 PLONK constraint systems 33 B.2 Lagrange basis 34 B.3 Checking gate-by-gate constraints 34 B.4 Checking copy constraints 35 B.5 Putting together 35 B.6 Extended Permutation Argument 36 B.7 PLONK AHP 37 B.8 Adding zero-knowledge 37</p>

    <p class="text-gray-300">C Marlin Preliminaries 38 C.1 Univariate sumcheck [BCR⁺¹⁹] 38 C.2 R1CS Constraint System 38 C.3 Marlin AHP 38</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge (ZK) proofs and argument systems (ZK) <em>[x10]</em> are one of the most fascinating concepts in modern cryptography, as they allow proving that a statement is valid without revealing any additional information as to why said statement is true. Even further, Succinct Non-interactive AR-guments of Knowledge (zk-SNARKs), allow to do so in such a way that the size of the proof and the work the verifier needs to perform in order to check the proof is sublinear in the size of the statement. Today, zk-SNARKs are a fundamental building block in complex cryptographic systems such as e.g., Zcash <em>[BCG^{+}14]</em>, where succinct zero-knowledge proofs are used to provide integrity while maintaining privacy. In such applications, it is crucial that the verification time is minimal (as every user in the system has to perform the verification) and that the proofs are short and non-interactive (as they need to be posted on the Blockchain).</p>

    <p class="text-gray-300">In this work we focus on commit-and-prove SNARKs (CP-SNARKs) (introduced in <em>[x7]</em>).</p>

    <p class="text-gray-300">This is an important family of SNARKs in which the witness is committed using Pedersen commitments (the de-facto lingua franca of commitments). The presence of these commitments allow to “glue” together different proof systems. An important application of CP-SNARKs is proving composite statements using the most efficient tool for each part of the statement. Such modularity of the CP proof system enhances interoperability with other protocols specialized for efficiently proving certain algebraic relations: consider a composite computation that naturally presents different components, like an arithmetic circuit for a hash function, and algebraic representation for group exponentiation. A general-purpose zero-knowledge proof system for such a computation requires a single homogeneous representation, thus incurring a high cost in performance. Ideally, one would like to take advantage of the nuances of a computation and choose the best proof system for each component of the computation, e.g., SNARKs for an arithmetic circuit and <span class="math">\\Sigma</span>-protocol for an algebraic relation. One of the simplest examples of such a statement is proving knowledge of the secret key corresponding to a Bitcoin address e.g., proving knowledge of some <span class="math">x</span> such that <span class="math">y=H(g^{x})</span> (without revealing <span class="math">g^{x}</span>).</p>

    <p class="text-gray-300">There are many other practical scenarios where the CP extension is useful, including, but not limited to, anonymous credentials <em>[x9, x11, x2]</em>, verifiable encryption <em>[x16]</em>, proof stitching <em>[CFH^{+}15, x17, WTs^{+}18, x26]</em>, and e-voting <em>[x16]</em>. Given these various potential applications, a working group focused on CP-ZK has recently been launched as part of the ZKProof Standards <em>[BCF^{+}21]</em>.</p>

    <p class="text-gray-300">Unfortunately, existing CP-SNARKs are not truly “succinct” since their proof size scales linearly with the number of commitments containing the witness. In this work, we fill this gap in the literature and provide the first truly succinct CP-SNARK.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Applications</h3>

    <p class="text-gray-300">To further motivate the need for succinct CP-SNARKs, we now provide some example applications. In all these applications, the commitments to (subset of) the witness are part of the public statement and, in practice, often exist prior to the time we prove properties on them. Motivated by this, we do not count the commitments as part of the proof size in this work.</p>

    <p class="text-gray-300">We denote by <span class="math">\\ell</span> the number of individual commitments containing the witness.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Anonymous and Delegated Credentials. Consider the application of making digital certificates anonymous: one would like to prove knowledge of a message <span class="math">m</span> and a signature <span class="math">\\sigma</span>, where <span class="math">\\sigma</span> is a valid signature on message <span class="math">m</span> with respect to some public verification key. The main challenge is that the statement being considered is a composite statement containing both Boolean (hash function) and algebraic (group operations) components, since the message is hashed before being signed. Efficient NIZK for composite statements that use a zk-SNARK for the circuit part and <span class="math">\\Sigma</span>-protocols for the algebraic would yield a proof system that is more efficient for the prover.</li>

    </ol>

    <p class="text-gray-300">Consider now the setting of “delegated credentials”. Each citizen or member of an organization can have associated a bundle of properties (credentials), e.g., credit and employment history or digital certificates issued by governments. We assume these properties are fingerprinted through a (compressing) commitment and that each of these users delegates the storage of these properties to a service. Every time the user needs to prove a statement on these credentials with respect to the public commitment, it can issue an order to the service. Instead of providing a single proof per user, a service can wait to accumulate <span class="math">\\ell</span> orders and provide a single proof for all of them. If the resulting proof is succinct in <span class="math">\\ell</span>, then this batching technique results in important savings. Note here that in this application it would not be feasible to commit to the credentials of all users in a single (vector)</p>

    <p class="text-gray-300">commitment, because the <span class="math">\\ell</span> commitments to the credentials already exist and each single user should be able to verify that on their own.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Blockchains. CP-SNARKs are useful in many Blockchain applications like confidential transactions <em>[x13]</em> where range proofs are required on committed values, and in systems balancing privacy and accountability <em>[DGK^{+}21]</em> where credentials are proven on committed values.</li>

    </ol>

    <p class="text-gray-300">An example Blockchain application where <span class="math">\\ell&gt;1</span> and succinct CP-SNARKs are desirable is proof of solvency. In privacy-preserving proof of solvency <em>[x1]</em>, the number of commitments <span class="math">\\ell</span> is typically large. This is because in proof of liabilities, each customer has to check that their own balance has been included in the total liabilities published by the exchange. This is done by having the exchange send the decommitment information to each customer privately. Thus, in this application too, using a single (vector) commitment is not a feasible solution. Since each customer’s balance is private, there must be as many commitments as the number of customers instead of one vector commitment to all balances.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Machine Learning. Another example of an application that benefits from succinct CP-SNARKs is verifying integrity of Machine Learning (ML) models. Similar settings have been considered, for example, in <em>[WZC^{+}18]</em>. A hospital owns sensitive patient data, and one wishes to construct a model by running a training algorithm on this sensitive data. The hospital does not wish to and/or legally cannot release the data; making it a challenge to check the integrity of the model. One way to do this is to have the hospital use a zkSNARK to prove that the model is the output obtained by training it on the sensitive data and that public commitments indeed open to the same sensitive data.</li>

    </ol>

    <p class="text-gray-300">In practice, ML algorithms are run on data held by different entities (hospitals in the example above), and each of the <span class="math">\\ell</span> entities publishes a commitment to their sensitive data. Thus succinct CP-SNARKs provide efficiency benefits also in this case.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Our Contributions</h3>

    <p class="text-gray-300">In this work we present the first CP-SNARKs whose proof size is succinct in the number of commitments to the witness. To do so, we combine state-of-the-art SNARKs with state-of-the-art <span class="math">\\Sigma</span>-protocols, inheriting several important properties of the underlying tools which we use.</p>

    <p class="text-gray-300">An important property of our resulting proof system is that it has universal, updatable and linear-size reference string: Since we are interested in practically efficient and succinct proof systems, our starting points are preprocessing SNARKs, in which some form of trusted setup (in the form of a structured reference string or SRS) is required. If the trusted setup is compromised, it becomes possible to break the soundness property of the proof system. However, using SNARKs with universal and updatable setup (as introduced in <em>[GKM^{+}18]</em>) the trust in the setup phase can be reduced to a minimum, as this allows participants to dynamically update the SRS was proposed. Even though this does not completely remove the problem of trusted setup, the security now depends on at least one honest party deleting the contributed randomness. Moreover, the SRS is universal in the sense that it allows to prove statements about all circuits of some bounded size (as opposed to earlier systems in which a different SRS was needed for each circuit, thus increasing the need for trusted setups). Furthermore, the size of the setup will be linear in the size (or upper bound of) the circuit to be proven.</p>

    <p class="text-gray-300">From a technical point of view, our contributions can be summarized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compiler from AHP to CP-SNARK. In Sec. 3 we present a compiler that takes an AHP (Algebraic Holographic Proof, the information-theoretic protocol underlying many existing zkSNARKs) and compiles it into a CP-SNARK. Our compiler is similar in spirit to compilers of <em>[x2, CHM^{+}20, CFF^{+}20]</em> that convert information-theoretic protocols to succinct arguments, but it naturally allows efficient CP extensions because of our “decompose–and–link” paradigm outlined in Sec. 1.3. The main technical challenge in building this compiler is that existing SNARK constructions employ different ways to encode the witness into a polynomial, even though the underlying information-theoretic objects can be described in the language of AHP. This makes it hard to identify how to generically & succinctly link committed values to only a small fraction of the large witness vector used in SNARK. Yet, we are able to abstract out a set of basic properties that AHPs and commitment schemes should satisfy, in order to apply the same paradigm. Thanks to our abstract approach, one does not need to</li>

    </ul>

    <p class="text-gray-300">examine the entire machinery of the AHP protocol; instead, it is sufficient to look at a few polynomials present in the AHP, check if they satisfy the properties required by our compiler theorem, and then focus on designing a sub-protocol performing a minimum set of tasks for “linking”. We believe that our techniques are general enough to extend to future AHPs and commitment schemes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Concrete instantiations. We then apply our compiler to the AHPs of Marlin, PLONK and Sonic to obtain concrete CP-SNARKs. This immediately allows us to prove that the inputs (and/or outputs) used in the zk-SNARK for an arithmetic circuit/Rank 1 constraint system statement are the same as the values inside an algebraic (Pedersen) commitment. This helps to hide intermediate outputs of a composite statement by committing to it, thus allowing switching between the algebraic (<span class="math">\\Sigma</span>-protocols) and arithmetic (zk-SNARK) worlds. In order to make the argument for the composite statement succinct, we use recent advances in compressed <span class="math">\\Sigma</span>-protocol theory. We cast the statement about consistency with Pedersen commitments as statements about knowledge of pre-image of group homomorphisms. This allows us to apply the compression technique of <em>[x1]</em> that achieves logarithmic communication for the canonical <span class="math">\\Sigma</span>-protocol and the amortization technique that proves many statements efficiently. Thus, our linking protocol that needs to prove <span class="math">\\ell</span> statements, where each statement is about equality of vectors of size <span class="math">d</span>, achieves communication complexity <span class="math">O(\\log(\\ell d))</span>, so the overall proof (the size of the SNARK together with the size of the linking proof) is still succinct.</li>

    </ul>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.3 Technical Overview</h3>

    <p class="text-gray-300">Most recent constructions of updatable SRS zkSNARKs <em>[x2, CHM^{+}20, x11]</em> follow a modular approach where an information-theoretic protocol is constructed in an abstract model like Probabilistically Checkable Proof (PCP), linear PCP, Interactive Oracle Proof (IOP) etc., and then the information-theoretic protocol is compiled via a cryptographic compiler to obtain an argument system. While several abstractions for this information-theoretic parts exist, it is folklore among researchers in this community that these formalizations are to some extent equivalent. In this paper, we rely on the formalization of (public-coin) <em>Algebraic Holographic Proofs (AHP)</em> of <em>[CHM^{+}20]</em> and we cast the other SNARKs (PLONK <em>[x11]</em> and Sonic <em>[x20]</em>) in the same language.</p>

    <p class="text-gray-300">Plain AHP-to-SNARK framework. In an AHP the prover P takes a statement x and a witness vector <span class="math">\\mathbf{w}=(w_{1},\\ldots,w_{n})</span> as inputs and sends some <em>oracle polynomials</em> to the verifier V in each round, who responds with a random challenge. In the query phase, V can query an oracle polynomial <span class="math">p</span> with an <em>evaluation point</em> <span class="math">z</span> to obtain <span class="math">v=p(z)</span>. V can iterate this process for several different polynomials and evaluation points. Finally, V outputs a decision bit indicating “accept” or “reject”, based on the result of the evaluation queries.</p>

    <p class="text-gray-300">An AHP can be turned into an argument system by replacing the oracles and the query phase with a <em>polynomial commitment scheme (PCS)</em>. As proposed by <em>[x17]</em>, PCS can be succinctly instantiated by using the discrete log-based encoding of polynomial: <span class="math">\\mathsf{PC.Com}_{\\mathsf{ck}}(p(X)):=g^{p_{0}+p_{1}\\chi+\\ldots p_{n-1}\\chi^{n-1}}</span> with a commitment key <span class="math">\\mathsf{ck}=(g,g^{\\chi},\\ldots,g^{\\chi^{n-1}})</span>. Then upon receiving an evaluation point <span class="math">z</span>, the prover responds with an <em>evaluation proof</em> to convince the verifier that evaluation <span class="math">v=p(z)</span> is done correctly.</p>

    <p class="text-gray-300">Witness-carrying polynomials and CP extension. Typically, one or few oracles sent by an AHP prover are <em>witness-carrying polynomials (WCP)</em> <em>[CFF^{+}20]</em>, meaning that they encode the entire witness vector <span class="math">\\mathbf{w}</span>. For ease of exposition, we assume the AHP has a single WCP <span class="math">w(X)</span> here, but our abstract compiler works for AHP with multiple WCP as well. The encoding/decoding method differs depending on the protocol. For example, Sonic employs a simple <em>coefficient</em> encoding, therefore, decoding works by mapping the coefficients to a witness vector, i.e., <span class="math">w(X):=\\sum_{i}w_{i}</span>; PLONK and Marlin use <em>interpolation</em>, and decoding works by evaluating WCP on some prescribed set, i.e., <span class="math">w(X):=\\sum_{i}w_{i}\\cdot L_{i}(X)</span>, where <span class="math">(L_{i}(X))_{i\\in[n]}</span> are the Lagrange polynomials associated with some set <span class="math">\\mathbb{H}</span> of size <span class="math">n</span>.</p>

    <p class="text-gray-300">In our CP scenario, we additionally consider a commitment scheme AC for Auxiliary Commitments. They are “auxiliary” in the sense that they are used as auxiliary inputs to parts of the witness, and in some applications, these commitments already exist. For example, if a subvector of witness <span class="math">(w_{i})_{i\\in I_{\\mathsf{com}}}</span> with <span class="math">I_{\\mathsf{com}}\\subset[n]</span> is committed in advance via vector Pedersen commitment, an argument system additionally takes <span class="math">\\hat{c}=\\mathsf{AC.Com}_{\\mathsf{ack}}((w_{i})_{i\\in I_{\\mathsf{com}}};r)\\coloneqq H^{r}\\prod_{i\\in I_{\\mathsf{com}}}G_{i}^{w_{i}}</span> as part of the statement, where <span class="math">\\mathsf{ack}\\coloneqq H^{r}\\prod_{i\\in I_{\\mathsf{com}}}G_{i}^{w_{i}}</span></p>

    <p class="text-gray-300"><span class="math">(G_{i})_{i\\in I_{\\text{com}}},H)</span>. The goal of CP extension is to guarantee consistency between what is committed to via PC and AC. To this end, it should suffice to provide a sub-protocol for relation</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}:=\\left\\{((c,\\hat{c}),(\\mathbf{w},r))\\,:\\,c=\\prod_{i=1}^{n}g_{i}^{w_{i}}\\,\\,\\wedge\\,\\,\\hat{c}=H^{r}\\prod_{i\\in I_{\\text{com}}}G_{i}^{w_{i}}\\,\\right\\}.</span></p>

    <p class="text-gray-300">where <span class="math">g_{i}=g^{\\chi^{i-1}}</span> or <span class="math">g_{i}=g^{L_{i}(\\chi)}</span>, depending on how the AHP under consideration encodes the witness into WCP.</p>

    <p class="text-gray-300">A naïve approach would be to describe an arithmetic circuit for <span class="math">\\mathcal{R}</span> and invoke another instance of SNARK. However, if the committing function of AC involves certain algebraic operations, e.g., group exponentiation or elliptic curve scalar multiplications as required in the Pedersen commitment, it would be very costly for the prover to express them in a circuit. This is where a <span class="math">\\Sigma</span>-protocol comes into play.</p>

    <p class="text-gray-300">Decomposing WCP and linking with <span class="math">\\Sigma</span>-protocol. A simple <span class="math">\\Sigma</span>-protocol can be used for proving equality of Pedersen-committed messages. However, because naïve instantiation of such a protocol for <span class="math">\\mathcal{R}</span> inevitably proves knowledge of the <em>entire vector</em> <span class="math">\\mathbf{w}</span>, it would incur <span class="math">O(n)</span> proof size and verification time, losing succinctness. Although it is possible to apply the compressed <span class="math">\\Sigma</span>-protocol theory <em>[x1]</em> to achieve <span class="math">O(\\log(n))</span> proof size, if logarithmic proof size is acceptable, one could instead use Bulletproofs, which supports CP extensions with the Pedersen commitment by construction and already achieves <span class="math">O(\\log(n))</span> proof size.</p>

    <p class="text-gray-300">In fact, proving <span class="math">\\mathcal{R}</span> turns out to be quite wasteful, since at the end of the day we only care about a small fraction of <span class="math">\\mathbf{w}</span> that are committed beforehand. We circumvent the issue by additively <em>decomposing</em> the WCP <span class="math">w(X)</span> into two parts <span class="math">w_{\\text{com}}(X)</span> and <span class="math">w_{\\text{mid}}(X)</span>, such that <span class="math">w(X)=w_{\\text{com}}(X)+w_{\\text{mid}}(X)</span>, <span class="math">w_{\\text{com}}(X)</span> encodes the committed part of the witness <span class="math">(w_{i})_{i\\in I_{\\text{com}}}</span>, and <span class="math">w_{\\text{mid}}(X)</span> contains the rest. In Sec. 3.2 we formally define this intuition. Accordingly, assuming <em>additively homomorphic</em> PCS (satisfied by KZG), one can also decompose a polynomial commitment <span class="math">c</span> into <span class="math">c_{\\text{com}}</span> and <span class="math">c_{\\text{mid}}</span> such that <span class="math">c=c_{\\text{com}}+c_{\\text{mid}}=\\text{PC.Com}_{\\text{ck}}(w_{\\text{mid}})+\\text{PC.Com}_{\\text{ck}}(w_{\\text{com}})</span>. Now we only need to <em>link</em> <span class="math">c_{\\text{com}}</span> and <span class="math">\\hat{c}</span>; it suffices to cast <span class="math">c_{\\text{com}}</span> to the <span class="math">\\Sigma</span>-protocol for relation</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}^{\\prime}:=\\left\\{((c_{\\text{com}},\\hat{c}),(\\mathbf{w},r)\\,:\\,c=\\prod_{i\\in I_{\\text{com}}}g_{i}^{w_{i}}\\,\\,\\wedge\\,\\,\\hat{c}=H^{r}\\prod_{i\\in I_{\\text{com}}}G_{i}^{w_{i}}\\,\\right\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which only incurs $O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{\\text{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$ proof size and verification time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proving “non-overlapping” decomposition. The above idea needs additional care in order to preserve knowledge soundness since it is not guaranteed that a cheating prover honestly decomposes WCP. For example, what if a prover crafted <span class="math">\\hat{w}_{\\text{mid}}(X)</span> such that it decodes to <span class="math">\\hat{w}_{\\text{mid},i}</span> for some <span class="math">i\\in I_{\\text{com}}</span>? In that case, the knowledge extractor for SNARK outputs <span class="math">\\hat{w}_{i}=\\hat{w}_{\\text{com},i}+\\hat{w}_{\\text{mid},i}</span> as one of the witness vector elements, whereas the <span class="math">\\Sigma</span>-protocol only proves that <span class="math">\\hat{c}</span> contains <span class="math">\\hat{w}_{\\text{com},i}</span>. This breaks consistency between the value in <span class="math">\\hat{c}</span> and the actual witness used in SNARK. To fix this issue, we require a prover to show the decomposed WCPs are “non-overlapping”, meaning that <span class="math">w_{\\text{mid}}(X)</span> <em>only</em> maps to <span class="math">(w_{i})_{i\\notin I_{\\text{com}}}</span>. In Sec. 5, 6, and 7, we present different ways to instantiate this additional check: for Sonic it amounts to perform a degree bound check for <span class="math">w_{\\text{mid}}(X)</span>, while for PLONK and Marlin it suffices to verify <span class="math">w_{\\text{mid}}(X)</span> vanishes on certain evaluation points.</p>

    <p class="text-gray-300">Compressing and aggregating many equality proofs. So far we have only considered a single auxiliary commitment <span class="math">\\hat{c}</span>. But clearly, as described earlier, we are interested in the case where the number <span class="math">\\ell</span> of commitments is large and we want our proof to be succinct in <span class="math">\\ell</span>. Naïvely, the above ideas can easily be generalized by invoking <span class="math">\\ell</span> instances of the equality proof for <span class="math">\\mathcal{R}^{\\prime}</span> with statement <span class="math">(c_{\\text{com}},\\hat{c}_{k})</span> for <span class="math">k\\in[\\ell]</span>. This in turn would incur in a multiplicative factor of <span class="math">O(\\ell)</span> overhead in the proof size. In Sec. 4 we show how to amortize <span class="math">\\ell</span> different protocol instances to achieve <span class="math">O(\\log(\\ell d))</span> proof size by adapting the amortization technique from <em>[x2]</em>, where <span class="math">d</span> is a dimension of the vector committed to in each <span class="math">\\hat{c}_{k}</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.4 Related Work</h3>

    <p class="text-gray-300"><span class="math">\\Sigma</span>-protocols are proof systems that are efficient for proving algebraic statements about discrete logarithms, roots, or polynomial relationships among values <em>[x23, x10, x7, x3]</em>. They yield short proof sizes, require a constant number of public-key operations, and do not impose trusted setup requirements. Moreover, they can be made non-interactive using the efficient Fiat-Shamir transformation <em>[x11]</em>.</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove (time)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (time)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log(ℓ·d))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n+ℓ·d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ·d)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lunar [CFF+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n+ℓ·d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LegoUAC [CFQ19]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓlog2(n))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)+ℓ·O(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓlog2(n))</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Efficiency comparison among CP-SNARK constructions with universal and updatable SRS. Proving time expresses group operations. The first line refers to our compiler applied to AHPs with suitable decomposition properties (See Sec. 3). In the above we denote by  <span class="math">n</span>  the number of constraints in an R1CS system,by  <span class="math">\\ell</span>  the number of input commitments and by  <span class="math">d</span>  the size of each committed vectors. (The same asymptotics apply also to other constraints systems with slight variations though. For example, they apply to the AHPs in PLONK if  <span class="math">n</span>  above refers to the total number of gates).</p>

    <p class="text-gray-300">Recent work on compressed  <span class="math">\\Sigma</span> -protocol theory [AC20] is a strengthening of  <span class="math">\\Sigma</span> -protocols that compress the communication complexity from linear to logarithmic. The underlying pivot of the compressed protocol is a standard  <span class="math">\\Sigma</span> -protocol for opening linear forms on Pedersen vector commitments, i.e., a  <span class="math">\\Sigma</span> -protocol for proving that a committed vector  <span class="math">\\mathbf{x}</span>  satisfies  <span class="math">L(\\mathbf{x}) = y</span>  for a public scalar  <span class="math">y</span>  and public linear form  <span class="math">L</span> .</p>

    <p class="text-gray-300">The seminal paper of [GGPR13] proposed a pairing-based zk-SNARK for general NP statements based on the NP complete language of Quadratic Span Programs (QSP) for Boolean circuits and Quadratic Arithmetic Programs (QAP) for arithmetic circuits. This built on previous works of [IKO07, Gro10, Lip12] and led to several follow ups  <span class="math">\\mathrm{[BCI^{+}13}</span> , PHGR13,  <span class="math">\\mathrm{BCG^{+}13}</span> , Lip13, BCTV14, Gro16] which have proofs that are very short and have fast verification time.</p>

    <p class="text-gray-300">The first zk-SNARK with an updatable SRS was introduced by  <span class="math">\\mathrm{[GKM^{+}18]}</span> . However, here the size of this universal updatable SRS is quadratic in the number of multiplication gates of the circuit representing the statement. In [MBKM19], the authors construct Sonic, the first zkSNARK that is universal and updatable with a linear-sized SRS. A different solution to SNARKs with universal and updatable SRS is to use a secure multi-party computation protocol (MPC) to conduct the setup [BGM17], and as long as at least one party is honest, the setup remains secure.</p>

    <p class="text-gray-300">Although several works on general-purpose CP-ZK exist in the literature, such as Geppetto  <span class="math">\\left[\\mathrm{CFH}^{+}15\\right]</span> , Cinderella [DFKP16], and [Lip16], there are few examples of efficient zero-knowledge proof systems for composite statements like those we consider in this paper. The first paper in this important line of work [CGM16] presents a zero-knowledge proof that can be used to prove that  <span class="math">F(x) = 1</span>  given a Pedersen commitment to  <span class="math">x</span> , where  <span class="math">F</span>  is represented as a Boolean circuit. They provide an efficient way of combining the garbled-circuit based proof of [JKO13] for circuit-based statements with  <span class="math">\\Sigma</span> -protocols for algebraic parts. However, this is inherently interactive which is inherited from the interactivity of [JKO13] where the verifier uses private coins. In  <span class="math">\\left[\\mathrm{BHH}^{+}19\\right]</span> , the authors show how to extend the MPC-in-the-head techniques of ZKBoo [GMO16] and ZKB++  <span class="math">\\left[\\mathrm{CDG}^{+}17\\right]</span>  to allow algebraic statements on Pedersen commitments. While allowing for non-interactive proofs via the Fiat-Shamir transform, this approach results in larger proof sizes. In [AGM18], protocols combining zk-SNARKs with  <span class="math">\\Sigma</span> -protocols are presented. This overcomes the disadvantage of interactivity, and also gives a system suitable for applications that require short proofs. Not only does their approach lead to more efficient anonymous credentials than Cinderella, but it also found new applications to the blockchain, such as proof-of-solvency. Our approach achieves better asymptotic efficiency as well as further generality compared to [AGM18], which relies on naive  <span class="math">\\Sigma</span> -protocols and a specific QAP-based SNARK construction with non-updatable SRS.</p>

    <p class="text-gray-300">Bulletproofs  <span class="math">\\left[\\mathrm{BBB}^{+}18\\right]</span>  can be used to prove statements on algebraically committed inputs, and can be made non-interactive using Fiat-Shamir. Even though proof sizes scale logarithmically, unfortunately, the verification time scales linearly with the size of the circuit.</p>

    <p class="text-gray-300">The works most closely related to ours are LegoSNARK and Lunar. LegoSNARK [CFQ19] is a framework for CP-SNARKs that gives general composition tools to build new CP-SNARKs from proof gadgets in a modular way. The construction LegoUAC in [CFQ19] is a CP-SNARK with a universal and updatable SRS. Lunar  <span class="math">\\left[\\mathrm{CFF}^{+}20\\right]</span>  obtains CP-SNARKs with a universal and updatable SRS and presents proof systems for "linking" committed inputs to the polynomial commitments used in AHP-based arguments. Table 1 shows the efficiency comparison between our work, Lunar and LegoUAC. Note that Lunar constructions and ECLIPSE outperform each other in different settings.</p>

    <p class="text-gray-300">8</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. For positive integers <span class="math">a</span> and <span class="math">b</span> such that <span class="math">a &amp;lt; b</span> we use the integer interval notation <span class="math">[a, b]</span> to denote <span class="math">\\{a, a + 1, \\ldots, b\\}</span>; we use <span class="math">[b]</span> as shorthand for <span class="math">[1, b]</span>. A finite field is denoted by <span class="math">\\mathbb{F}</span>. We denote by <span class="math">\\kappa</span> a security parameter. When we explicitly specify the random tape <span class="math">\\rho</span> for a randomized algorithm <span class="math">\\mathcal{A}</span>, then we write <span class="math">a \\gets \\mathcal{A}(\\mathrm{srs}; \\rho)</span> to indicate that <span class="math">\\mathcal{A}</span> outputs <span class="math">a</span> given input <span class="math">\\mathrm{srs}</span> and random tape <span class="math">\\rho</span>. For a pair of randomized algorithms <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>, we often use the handy notation $(a; x) \\gets (\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{\\mathcal{A}})(\\mathrm{srs})<span class="math"> which denotes that </span>\\mathcal{A}<span class="math"> outputs </span>a<span class="math"> on input </span>\\mathrm{srs}<span class="math">, and </span>\\mathcal{E}_{\\mathcal{A}}<span class="math"> outputs </span>x<span class="math"> given the same input </span>\\mathrm{srs}<span class="math">, and </span>\\mathcal{A}<span class="math">&#x27;s random tape. We denote by </span>\\operatorname*{Pr}\\left[A : B\\right]<span class="math"> the conditional probability of an event </span>A<span class="math"> under the condition </span>B<span class="math">. Throughout, </span>\\mathbb{G}<span class="math"> denotes an Abelian group of prime order </span>q<span class="math">. For vectors of generators </span>\\pmb{g} = (g_1, \\dots, g_d) \\in \\mathbb{G}^d<span class="math"> and exponents </span>\\mathbf{x} = (x_1, \\dots, x_d) \\in \\mathbb{Z}_q^d<span class="math"> we often write </span>\\pmb{g}^{\\mathbf{x}} := \\prod_{i=1}^{d} g_i^{x_i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-7" class="text-2xl font-bold">2.1 Indexed relations</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 1 (Indexed relation [CHM⁺20]).</strong> An indexed relation <span class="math">\\mathcal{R}</span> is a set of triples <span class="math">(\\mathrm{i},\\mathrm{x},\\mathrm{w})</span> where <span class="math">\\mathrm{i}</span> is the index, <span class="math">\\mathbf{x}</span> is the instance, and <span class="math">\\mathbf{w}</span> is the witness; the corresponding indexed language <span class="math">\\mathcal{L}(\\mathcal{R})</span> is the set of pairs <span class="math">(\\mathrm{i},\\mathrm{x})</span> for which there exists a witness <span class="math">\\mathbf{w}</span> such that <span class="math">(\\mathrm{i},\\mathrm{x},\\mathrm{w}) \\in \\mathcal{R}</span>. Given a size bound <span class="math">\\mathbb{N} \\in \\mathbb{N}</span>, we denote by <span class="math">\\mathcal{R}_{\\mathbb{N}}</span> the restriction of <span class="math">\\mathcal{R}</span> to triples <span class="math">(\\mathrm{i},\\mathrm{x},\\mathrm{w}) \\in \\mathcal{R}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathbb{N}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 Zero-knowledge Arguments of Knowledge with preprocessing</h2>

    <p class="text-gray-300">A zero-knowledge proof (or argument)<span class="math">^8</span> for <span class="math">\\mathcal{L}</span> allows a prover <span class="math">P</span> to convince a verifier <span class="math">V</span> that <span class="math">x \\in \\mathcal{L}</span> for a common input <span class="math">x</span> without revealing <span class="math">w</span>. A proof of knowledge captures not only the truth of a statement <span class="math">x \\in \\mathcal{L}</span>, but also that the prover is in "possession" of a witness <span class="math">w</span>.</p>

    <p class="text-gray-300"><strong>Definition 2 (Preprocessing Argument with Universal SRS [CHM⁺20]).</strong> A Preprocessing Argument with Universal SRS is a tuple <span class="math">\\mathsf{ARG} = (\\mathcal{S},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> of four algorithms. <span class="math">\\mathcal{S}</span> is a probabilistic polynomial-time setup algorithm that given a bound <span class="math">\\mathbb{N} \\in \\mathbb{N}</span> samples a structured reference string <span class="math">\\mathsf{srs}</span> supporting indices of size up to <span class="math">\\mathbb{N}</span>. The indexer algorithm <span class="math">\\mathcal{I}</span> is deterministic and, given oracle access to <span class="math">\\mathsf{srs}</span> produces a proving index key and a verifier index key, used respectively by <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>. The latter two are probabilistic polynomial-time interactive algorithms.</p>

    <p class="text-gray-300"><strong>Completeness</strong> For all size bounds <span class="math">\\mathbb{N} \\in \\mathbb{N}</span> and efficient <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left( \\begin{array}{l l} (\\mathrm{i}, \\mathrm{x}, \\mathrm{w}) \\notin \\mathcal{R}_{\\mathbb{N}} \\lor &amp;amp; \\operatorname{srs} \\leftarrow \\mathcal{S}(1^{\\kappa}, \\mathbb{N}) \\\\ \\langle \\mathcal{P}(\\mathrm{ipk}, \\mathrm{x}, \\mathrm{w}), \\mathcal{V}(\\mathrm{ivk}, \\mathrm{x}) \\rangle = 1 &amp;amp; : \\quad (\\mathrm{i}, \\mathrm{x}, \\mathrm{w}) \\leftarrow \\mathcal{A}(\\mathrm{srs}) \\\\ &amp;amp; \\quad (\\mathrm{ipk}, \\mathrm{ivk}) \\leftarrow \\mathcal{I}^{\\mathrm{srs}}(\\mathrm{i}) \\end{array} \\right) = 1</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Succinctness</strong> We call the argument succinct if the communication complexity between prover and verifier is bounded by $\\mathsf{poly}(\\kappa) \\cdot \\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Knowledge Soundness</strong> For every <span class="math">\\mathbb{N} \\in \\mathbb{N}</span> and efficient adversary <span class="math">\\tilde{\\mathcal{P}} = (\\tilde{\\mathcal{P}}_1, \\tilde{\\mathcal{P}}_2)</span> there exists an efficient extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left( \\begin{array}{l l} &amp;amp; \\operatorname{srs} \\leftarrow \\mathcal{S}(1^{\\kappa}, \\mathbb{N}) \\\\ (\\mathrm{i}, \\mathrm{x}, \\mathrm{w}) \\notin \\mathcal{R}_{\\mathbb{N}} \\land &amp;amp; (\\mathrm{i}, \\mathrm{x}, \\mathrm{st}) \\leftarrow \\tilde{\\mathcal{P}}_1(\\mathrm{srs}) \\\\ \\langle \\tilde{\\mathcal{P}}_2(\\mathrm{st}), \\mathcal{V}(\\mathrm{ivk}, \\mathrm{x}) \\rangle = 1 &amp;amp; \\quad \\mathrm{w} \\leftarrow \\mathcal{E}(\\mathrm{srs}) \\\\ &amp;amp; \\quad (\\mathrm{ipk}, \\mathrm{ivk}) \\leftarrow \\mathcal{I}^{\\mathrm{srs}}(\\mathrm{i}) \\end{array} \\right) = \\operatorname{negl}(\\lambda)</span></div>

    <p class="text-gray-300">Above we assumed the extractor takes in input the same random tape as the malicious prover.</p>

    <p class="text-gray-300"><strong>Perfect Zero-Knowledge</strong> There exists an efficient simulator <span class="math">\\mathsf{Sim} = (\\mathsf{Setup}, \\mathsf{Prove})</span> such that for every efficient adversary <span class="math">\\tilde{\\mathcal{V}} = (\\tilde{\\mathcal{V}}_1, \\tilde{\\mathcal{V}}_2)</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left( \\begin{array}{l l} (\\mathrm{i}, \\mathrm{x}, \\mathrm{w}) \\in \\mathcal{R}_{\\mathbb{N}} \\land &amp;amp; \\operatorname{srs} \\leftarrow \\mathcal{S}(1^{\\kappa}, \\mathbb{N}) \\\\ \\langle \\mathcal{P}(\\mathrm{ipk}, \\mathrm{x}, \\mathrm{w}), \\tilde{\\mathcal{V}}_2(\\mathrm{st}) \\rangle = 1 &amp;amp; : \\quad (\\mathrm{i}, \\mathrm{x}, \\mathrm{w}, \\mathrm{st}) \\leftarrow \\tilde{\\mathcal{V}}_1(\\mathrm{srs}) \\\\ &amp;amp; \\quad (\\mathrm{ipk}, \\mathrm{ivk}) \\leftarrow \\mathcal{I}^{\\mathrm{srs}}(\\mathrm{i}) \\end{array} \\right) =</span></div>

    <p class="text-gray-300"><span class="math">\\Pr\\left(\\begin{matrix}(\\mathsf{i},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}_{\\mathsf{N}}\\wedge&amp;\\text{(\\sf srs},\\mathsf{trap})\\leftarrow\\mathsf{Sim.Setup}(1^{\\kappa},\\mathsf{N})\\\\ \\big{\\langle}\\mathsf{Sim.Prove}\\left(\\mathsf{trap},\\mathsf{i},\\mathsf{x}\\right),\\tilde{\\mathcal{V}}_{2}\\left(\\mathsf{st}\\right)\\big{\\rangle}=1&amp;\\text{(\\mathsf{i},\\mathsf{x},\\mathsf{w},\\mathsf{st})\\leftarrow\\tilde{\\mathcal{V}}_{1}(\\mathsf{srs})}\\end{matrix}\\right)</span></p>

    <p class="text-gray-300">We have the following two optional requirements on the arguments defined above. We say that an argument is public-coin if all the messages from the verifier are uniformly random strings of a bounded length. We say it is updatable if there exists an update algorithm that can be run by anyone at any time and to update the SRS. This algorithm guarantees security as long as at least one of the (sequential) updates have been carried out honestly.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.3 Algebraic Holographic Proofs</h3>

    <p class="text-gray-300">Below we recall the definition of AHP from Marlin.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3 (AHP <em>[CHM^{+}20]</em>).</h6>

    <p class="text-gray-300">An <em>Algebraic Holographic Proofs (AHP)</em> over a field family <span class="math">\\mathcal{F}</span> for an indexed relation <span class="math">\\mathcal{R}</span> is specified by a tuple</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AHP}=(\\mathsf{k},\\mathsf{s},\\mathsf{d},\\mathsf{I},\\mathsf{P},\\mathsf{V})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{k},\\mathsf{s},\\mathsf{d}:\\{0,1\\}^{<em>}\\rightarrow\\mathbb{N}</span> are polynomial-time computable functions and <span class="math">\\mathsf{I},\\mathsf{P},\\mathsf{V}</span> are three algorithms known as the </em>indexer, prover<em>, and </em>verifier*. The parameter <span class="math">\\mathsf{k}</span> specifies the number of interaction rounds, <span class="math">\\mathsf{s}</span> specifies the number of polynomials in each round, and <span class="math">\\mathsf{d}</span> specifies degree bounds on these polynomials. The protocol proceeds as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Offline phase The indexer <span class="math">\\mathsf{I}</span> receives as input a field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and index <span class="math">\\mathsf{i}</span> for <span class="math">\\mathcal{R}</span>, and outputs <span class="math">\\mathsf{s}(0)</span> polynomials <span class="math">p_{0,1},\\ldots,p_{0,s(0)}\\in\\mathbb{F}[X]</span> of degrees at most $\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,1),\\ldots,\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,\\mathsf{s}(0))<span class="math"> respectively. Note that the offline phase does not depend on any particular instance or witness, and merely considers the task of encoding the given index </span>\\mathsf{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query phase Let <span class="math">\\mathbf{p}=(p_{i,j})_{i\\in[\\mathsf{k}],j\\in[\\mathsf{s}(i)]}</span> be a vector consisting of all polynomials sent by the prover <span class="math">\\mathsf{P}</span>. The verifier may query any of the polynomials it has received any number of times. Concretely, <span class="math">\\mathsf{V}</span> executes a subroutine <span class="math">\\mathsf{Q}_{\\mathsf{V}}</span> that receives <span class="math">(\\mathbb{F},\\mathsf{x};\\rho_{1},\\ldots,\\rho_{\\mathsf{k}+1})</span> and outputs a query set <span class="math">Q</span> consisting of tuples <span class="math">((i,j),z)</span> to be interpreted as “query <span class="math">p_{i,j}</span> at <span class="math">z\\in\\mathbb{F}</span>”. We denote a vector consisting of query answers <span class="math">\\mathbf{p}(Q)</span>.</li>

      <li>Decision phase The verifier outputs “accept” or “reject” based on the answers to the queries (and the verifier’s randomness). Concretely, <span class="math">\\mathsf{V}</span> executes a subroutine <span class="math">\\mathsf{D}_{\\mathsf{V}}</span> that receives <span class="math">(\\mathbb{F},\\mathsf{x},\\mathbf{p}(Q);\\rho_{1},\\ldots,\\rho_{\\mathsf{k}+1})</span> as input, and outputs the decision bit.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The function <span class="math">\\mathsf{d}</span> determines which provers to consider for the completeness and soundness properties of the proof system. In more detail, we say that a (possibly malicious) prover <span class="math">\\hat{\\mathsf{P}}</span> is <em>admissible</em> for AHP if, on every interaction with the verifier <span class="math">\\mathsf{V}</span>, it holds that for every round <span class="math">i\\in[\\mathsf{k}]</span> and oracle index <span class="math">j\\in[s(i)]</span> we have $\\deg(p_{i,j})\\leq\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)<span class="math">. The honest prover </span>\\mathsf{P}$ is required to be admissible under this definition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We require an AHP to satisfy completeness, (knowledge) soundness and zero-knowledge as defined below.</p>

    <p class="text-gray-300">Completeness. An AHP is complete if for all <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and any <span class="math">(\\mathsf{i},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, the checks returned by <span class="math">\\mathsf{V}^{\\mathsf{I}(\\mathbb{F},\\mathsf{i})}(\\mathbb{F},\\mathsf{x})</span> after interacting with (honest) <span class="math">\\mathsf{P}(\\mathbb{F},\\mathsf{i},\\mathsf{x},\\mathsf{w})</span> are always satisfied.</p>

    <p class="text-gray-300">Soundness. An AHP is <span class="math">\\epsilon</span>-sound if for every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, relation-instance tuple <span class="math">(\\mathsf{i},\\mathsf{x})\\not\\in L_{\\mathcal{R}}</span> and prover <span class="math">\\mathsf{P}^{<em>}</span> we have <span class="math">\\Pr[\\langle\\mathsf{P}^{</em>},\\mathsf{V}^{\\mathsf{I}(\\mathbb{F},\\mathsf{i})}(\\mathbb{F},\\mathsf{x})\\rangle=1]\\leq\\epsilon</span>.</p>

    <p class="text-gray-300">Knowledge Soundness. An AHP is <span class="math">\\epsilon</span>-knowledge-sound if there exists a polynomial-time knowledge extractor <span class="math">\\mathcal{E}</span> such that for any prover <span class="math">\\mathsf{P}^{*}</span>, field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, relation <span class="math">\\mathsf{i}</span>, instance <span class="math">\\mathsf{x}</span> and auxiliary input <span class="math">z</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(\\mathsf{i},\\mathsf{x},\\mathsf{w})\\!\\in\\mathcal{R}:\\mathsf{w}\\leftarrow\\mathcal{E}^{\\mathsf{P}^{<em>}}(\\mathbb{F},\\mathsf{i},\\mathsf{x},z)\\right]\\geq\\Pr[\\langle\\mathsf{P}^{</em>}(\\mathbb{F},\\mathsf{i},\\mathsf{x},z),\\mathsf{V}^{\\mathsf{I}(\\mathbb{F},\\mathsf{i})}(\\mathbb{F},\\mathsf{x})\\rangle\\!=\\!1]-\\epsilon</span></p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{E}</span>  has oracle access to  <span class="math">\\mathsf{P}^<em></span> , i.e., it can query the next message function of  <span class="math">\\mathsf{P}^</em></span>  (and rewind it) and obtain all the messages and polynomials returned by it.</p>

    <p class="text-gray-300">Zero-Knowledge. The property of  <span class="math">(\\mathsf{b},\\mathsf{C})</span>  -Zero-Knowledge for AHPs models the existence of a simulator that can interact with a malicious verifier and can effectively simulate under two conditions: there is a bound  <span class="math">\\mathsf{b}</span>  on the number of evaluation queries asked by the verifier; these queries need to satisfy an admissible test modelled a circuit C. We say an AHP is zero-knowledge for some bound  <span class="math">\\mathsf{b} = \\mathsf{poly}(\\lambda)</span>  and some efficient checker circuit C. We refer the reader to Section 4 in  <span class="math">[\\mathrm{CHM}^{+}20]</span>  for formal details.</p>

    <p class="text-gray-300">Public coins and non-adaptive queries. In the remainder of this work, we only consider AHPs that are public coin and non-adaptive: the messages of the verifier are random elements and its checks are independent of the prover's messages.</p>

    <p class="text-gray-300">Generalization to multivariate polynomials. Even though the above formalization is tailored to univariate polynomial oracles, it is straightforward to generalize it to support multivariate, Laurent polynomials  <span class="math">p_{i,j} \\in \\mathbb{F}[X_1, X_1^{-1}, \\ldots, X_m, X_m^{-1}]</span> . In that case, a query set  <span class="math">Q</span>  consists of  <span class="math">((i,j), (z_1, \\ldots, z_m))</span>  and is to be interpreted as "query  <span class="math">p_{i,j}</span>  at  <span class="math">(z_1, \\ldots, z_m) \\in \\mathbb{F}^{m}</span> ". Likewise, the polynomial commitment scheme definition can also be adapted to support multivariate polynomials as inputs. Our Theorem 1 in the next section holds under this generalization because the proof does not rely on whether polynomials are univariate or not. This is analogous to the compiler theorem of [CHM+20]. However, because the generalization is only required for Sonic presented in Appendix 7, and PLONK and Marlin only deal with univariate polynomials, we focus on the univariate version in the main body for ease of exposition.</p>

    <p class="text-gray-300">Polynomial commitment schemes were introduced by Kate-Zaverucha-Goldberg [KZG10]. Below we recall the definition of standard polynomial commitment scheme. The definition is taken verbatim from Section 6.1 of  <span class="math">\\mathrm{[CHM^{+}20]}</span></p>

    <p class="text-gray-300">Definition 4 (Polynomial Commitment Scheme). A polynomial commitment scheme (PCS) over a field family  <span class="math">\\mathcal{F}</span>  is a tuple  <span class="math">\\mathsf{PC} = (\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Com},\\mathsf{Open},\\mathsf{Check})</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(1^{\\kappa}, D) \\to \\mathfrak{pp}</span> . On input a security parameter  <span class="math">\\kappa</span> , and a maximum degree bound  <span class="math">D \\in \\mathbb{N}</span> , Setup samples public parameters  <span class="math">\\mathfrak{pp}</span> . The parameters contain the description of a finite field  <span class="math">\\mathbb{F} \\in \\mathcal{F}</span> .</li>

      <li><span class="math">\\mathsf{Trim}^{\\mathsf{pp}}(1^{\\kappa},\\mathbf{d})\\to (\\mathsf{ck},\\mathsf{rk})</span> . Given oracle access to public parameters  <span class="math">\\mathfrak{pp}</span> , and on input a security parameter  <span class="math">\\kappa</span> , and degree bounds  <span class="math">\\mathbf{d}</span> , Trim deterministically computes a key pair  <span class="math">(\\mathsf{ck},\\mathsf{rk})</span>  that is specialized to  <span class="math">\\mathbf{d}</span> .</li>

      <li><span class="math">\\mathsf{Com}_{\\mathsf{ck}}(\\mathbf{p},\\mathbf{d};\\boldsymbol {\\omega})\\to \\mathbf{c}</span> . On input ck, univariate polynomials  <span class="math">\\mathbf{p} = (p_i)_{i = 1}^n</span>  over the field  <span class="math">\\mathbb{F}</span>  with  <span class="math">\\deg (p_i)\\leq d_i\\leq D</span> , Com outputs commitments  <span class="math">\\mathbf{c} = (c_i)_{i = 1}^n</span>  to the polynomials  <span class="math">\\mathbf{p}</span> . The randomness  <span class="math">\\boldsymbol{\\omega}</span>  is used if the commitments  <span class="math">\\mathbf{c}</span>  are hiding.</li>

      <li><span class="math">\\mathsf{Open}_{\\mathsf{ck}}(\\mathbf{p},\\mathbf{d},Q,\\xi ;\\boldsymbol {\\omega})\\to \\pi</span>  . On input ck, univariate polynomials  <span class="math">\\mathbf{p}</span>  , degree bounds  <span class="math">\\mathbf{d}</span>  , a query set  <span class="math">Q</span>  consisting of  <span class="math">(i,z)\\in [n]\\times \\mathbb{F}</span>  , and opening challenge  <span class="math">\\xi</span>  , Open outputs an evaluation proof  <span class="math">\\pi</span>  . The randomness must equal the one previously used in Com.</li>

      <li><span class="math">\\operatorname{Check}_{\\mathsf{rk}}(\\mathbf{c}, \\mathbf{d}, Q, \\mathbf{v}, \\pi, \\xi) \\in \\{0, 1\\}</span> . On input  <span class="math">\\mathsf{rk}</span> , commitments  <span class="math">\\mathbf{c}</span> , degree bounds  <span class="math">\\mathbf{d}</span> , query set  <span class="math">Q</span> , alleged evaluations  <span class="math">\\mathbf{v} = (v_{(i,z)})_{(i,z) \\in Q}</span> , evaluation proof  <span class="math">\\pi</span> , and opening challenge  <span class="math">\\xi</span> , Check outputs 1 iff  <span class="math">\\pi</span>  attests that, for every  <span class="math">(i,z) \\in Q</span> , the polynomial  <span class="math">p_i</span>  evaluates to  <span class="math">v_{(i,z)}</span>  at  <span class="math">z</span> .</li>

    </ul>

    <p class="text-gray-300">We recall a set of basic properties that the KZG scheme [KZG10] and its variants described in Marlin and Sonic already satisfy.</p>

    <p class="text-gray-300">Completeness. For every maximum degree bound  <span class="math">D \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\kappa}, D) \\\\ &amp;amp; (\\mathbf {p}, \\mathbf {d}, Q, \\xi , \\boldsymbol {\\omega}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\deg (\\mathbf {p}) \\leq \\mathbf {d} \\leq D &amp;amp; (\\mathsf {c k}, \\mathsf {r k}) \\leftarrow \\mathsf {T r i m} ^ {\\mathsf {p p}} (1 ^ {\\kappa}, \\mathbf {d}) \\\\ \\Longrightarrow \\mathsf {C h e c k} _ {\\mathsf {r k}} (\\mathbf {c}, \\mathbf {d}, Q, \\mathbf {v}, \\pi , \\xi): &amp;amp; \\mathbf {c} \\leftarrow \\mathsf {C o m} (\\mathsf {c k}, \\mathbf {p}, \\mathbf {d}; \\boldsymbol {\\omega}) \\\\ &amp;amp; \\mathbf {v} \\leftarrow \\mathbf {p} (Q) \\\\ &amp;amp; \\pi \\leftarrow \\mathsf {O p e n} (\\mathsf {c k}, \\mathbf {p}, \\mathbf {d}, Q, \\xi ; \\boldsymbol {\\omega}) \\end{array} \\right) = 1</span></div>

    <p class="text-gray-300">Homomorphism. A PC is additively homomorphic if for every <span class="math">D \\in \\mathbb{N}</span>, every <span class="math">\\mathbf{d}</span> such that <span class="math">d_i \\leq D</span>, every query set <span class="math">Q</span>, every opening challenge <span class="math">\\xi</span>, every <span class="math">\\mathbf{p}_1, \\mathbf{p}_2, \\omega_1, \\omega_2</span> that are consistent with the degree bound <span class="math">\\mathbf{d}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\kappa}, D); \\\\ \\mathbf{c}_1 + \\mathbf{c}_2 = \\mathsf{Com}_{\\mathsf{ck}}(\\mathbf{p}_1 + \\mathbf{p}_2, \\mathbf{d}; \\boldsymbol{\\omega}_1 + \\boldsymbol{\\omega}_2) : &amp;amp; (\\mathsf{ck}, \\mathsf{rk}) = \\mathsf{Trim}^{\\mathsf{pp}}(1^{\\kappa}, \\mathbf{d}) \\\\ &amp;amp; \\mathbf{c}_1 = \\mathsf{Com}_{\\mathsf{ck}}(\\mathbf{p}_1, \\mathbf{d}; \\boldsymbol{\\omega}_1) \\\\ &amp;amp; \\mathbf{c}_2 = \\mathsf{Com}_{\\mathsf{ck}}(\\mathbf{p}_2, \\mathbf{d}; \\boldsymbol{\\omega}_2) \\end{array} \\right] = 1</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinctness. We require the commitments and the evaluation proofs to be of size independent of the degree of the polynomials, that is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n \\cdot \\mathrm{poly}(\\lambda),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathrm{poly}(\\lambda),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{rk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n \\cdot \\mathrm{poly}(\\lambda)<span class="math">. We also require the verifier Check to run in time </span>(n +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)n \\cdot \\mathrm{poly}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Extractability. From any adversary that can satisfactorily prove evaluations <span class="math">\\mathbf{v}</span> and degree bounds <span class="math">\\mathbf{d}</span> over polynomial commitments <span class="math">\\mathbf{c}</span> we should be able to extract: (i) polynomials <span class="math">\\mathbf{p}</span> consistent with the proofs, (ii) randomness <span class="math">\\boldsymbol{\\omega}</span> through which <span class="math">\\mathbf{c}</span> opens to <span class="math">\\mathbf{p}</span>. The complete formal definition is quite involved; we refer the reader to [CHM+20, Definition 6.2] for details.</p>

    <p class="text-gray-300">Polynomial Binding. We require that it is infeasible for any adversary to open the same commitment to two different polynomials. Formally, for every maximum degree bound <span class="math">D \\in \\mathbb{N}</span>, security parameter <span class="math">\\kappa</span> and efficient adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( \\begin{array}{c c} \\mathbf{p}_1 \\neq \\mathbf{p}_2 &amp;amp; \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\kappa}, D) \\\\ \\wedge \\mathbf{c} = \\mathsf{Com}(\\mathsf{ck}, \\mathbf{p}_1, \\mathbf{d}; \\boldsymbol{\\omega}_1) : &amp;amp; (\\mathbf{c}, \\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{d}, \\boldsymbol{\\omega}_1, \\boldsymbol{\\omega}_2) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ \\wedge \\mathbf{c} = \\mathsf{Com}(\\mathsf{ck}, \\mathbf{p}_2, \\mathbf{d}; \\boldsymbol{\\omega}_2) &amp;amp; (\\mathsf{ck}, \\mathsf{rk}) \\leftarrow \\mathsf{Trim}^{\\mathsf{pp}}(1^{\\kappa}, \\mathbf{d}) \\end{array} \\right) \\leq \\mathsf{negl}(\\kappa)</span></div>

    <p class="text-gray-300">Hiding. We require the existence of a stateful simulator <span class="math">\\mathsf{Sim} = (\\mathsf{Sim}. \\mathsf{Setup}, \\mathsf{Sim}. \\mathsf{Commit}, \\mathsf{Sim}. \\mathsf{Open})</span> such that an adversary cannot distinguish whether it is interacting with an honest execution or a simulated one. We refer the reader to [CHM+20] for the full definition.</p>

    <p class="text-gray-300">2.4.1 The KZG scheme. Below we recall the polynomial commitment scheme due to Kate-Zaverucha-Goldberg [KZG10], denoted by <span class="math">\\mathsf{PC}_{\\mathsf{KZG}}</span>. The scheme is proven extractable under the strong Diffie-Hellman (SDH) assumption in the algebraic group model (AGM) [FKL18], polynomial binding under the discrete-log assumption, and perfectly hiding [CHM+20, KZG10]. For simplicity we omit challenge <span class="math">\\xi</span> used for batch opening as well as the Trim function, and set <span class="math">\\mathsf{ck} = \\mathsf{rk} = \\mathsf{pp}</span>. See Appendix B of [CHM+20] for details of such optimization techniques.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\kappa}, D) \\to (g, g^{\\chi}, \\ldots, g^{\\chi^{D}}, g, g^{\\gamma \\chi}, \\ldots, g^{\\gamma \\chi^{D}}, h^{\\chi})</span> where it determines a bilinear group public parameters <span class="math">(q, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, g, h)</span>, with <span class="math">g \\in \\mathbb{G}_1</span> and <span class="math">\\chi, \\gamma \\in \\mathbb{F}</span> are randomly chosen. We denote exponentiation in <span class="math">\\mathbb{G}_i</span> by <span class="math">[\\cdot]_i</span>.</li>

      <li><span class="math">\\mathsf{Com}_{\\mathsf{ck}}(p, D; \\omega) \\to [p(\\chi) + \\gamma \\omega(\\chi)]_1</span>, where <span class="math">\\omega \\in \\mathbb{F}_{\\leq D}[X]</span> is a random masking polynomial.</li>

      <li><span class="math">\\mathsf{Open}_{\\mathsf{ck}}(p, D, z; \\omega)</span> computes <span class="math">W(X) = \\frac{p(X) - p(z)}{X - z}</span>, <span class="math">\\bar{W}(X) = \\frac{\\omega(X) - \\omega(z)}{X - z}</span>, <span class="math">\\Pi := [W(\\chi) + \\gamma \\bar{W}(\\chi)]_1</span>, <span class="math">\\bar{v} := \\bar{W}(z)</span> and outputs <span class="math">\\pi := (\\Pi, \\bar{v})</span>.</li>

      <li><span class="math">\\mathsf{Check}_{\\mathsf{rk}}(c, D, z, v, \\pi)</span> checks <span class="math">e(\\Pi, [\\chi]_2 / [z]_2) \\stackrel{?}{=} e(C / ([v]_1 \\cdot [\\gamma \\bar{v}]_1), h)</span>.</li>

    </ul>

    <p class="text-gray-300">In this section, we present our general compiler that turns AHPs to commit-and-prove zkSNARKs.</p>

    <p class="text-gray-300">Auxiliary Commitment Scheme AC We will assume a commitment scheme AC for Auxiliary Commitments. They are "auxiliary" in the sense that they are used as auxiliary inputs to parts of the witness. We assume AC to satisfy the standard properties of (computational) binding and (computational or otherwise) hiding. As we explicitly support a vector <span class="math">\\mathbf{x} \\in \\mathbb{F}^d</span> as committed message, the definition is specialized for a vector commitment scheme. Specifically we assume <span class="math">\\mathsf{AC} = (\\mathsf{Gen}, \\mathsf{Com})</span> such that <span class="math">\\mathsf{AC}. \\mathsf{Gen}(1^\\lambda, d) \\to \\mathsf{ack}</span> is a randomized algorithm returning a commitment key <span class="math">\\mathsf{ack}</span> for messages of dimension <span class="math">d \\in \\mathbb{N}</span>, where <span class="math">d \\in \\mathsf{poly}(\\lambda)</span>, and <span class="math">\\mathsf{AC}. \\mathsf{Com}_{\\mathsf{ack}}(\\mathbf{x}; r)</span> is a committing algorithm returning a commitment <span class="math">\\hat{c}</span> on input <span class="math">\\mathbf{x} \\in \\mathbb{F}^d</span></p>

    <p class="text-gray-300">for some randomness <span class="math">r</span>. In our concrete instantiations, we use the Pedersen vector commitment scheme (Appendix A.1) as AC.</p>

    <p class="text-gray-300">Commit-and-Prove Relation Our goal is to construct a general compiler that turns AHP for <span class="math">\\mathcal{R}</span> into ARG for the relation over commitments <span class="math">\\mathcal{R}_{\\text{com}}</span>. Throughout we assume an indexed relation where the witness can be represented as a vector in <span class="math">\\mathbb{F}^{n}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 5 (Commit-and-prove relation).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be an indexed relation, AC a commitment scheme as defined above and ack an auxiliary commitment key in the range of AC.Gen. We define the corresponding <em>commit-and-prove relation</em></p>

    <p class="text-gray-300">\\[ \\mathcal{R}_{\\text{com}}=\\left\\{\\begin{array}[]{c}(\\mathsf{i},\\mathsf{x},(\\mathsf{w}_{i})_{i\\in[n]})\\in\\mathcal{R}\\ \\wedge\\\\ ((\\mathsf{i},n,\\ell,d,I_{\\text{com}},(I_{k})_{k\\in[\\ell]},{\\mathsf{a}ck}),\\\\ (\\mathsf{x},(\\hat{c}_{k})_{k\\in[\\ell]}),((\\mathsf{w}_{i})_{i\\in[n]},(r_{k})_{k\\in[\\ell]}))\\ \\ :\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non-overlapping: Let  <span class="math">\\mathsf{w} = \\mathsf{WitExt}((p_{i,j}(X))_{(i,j)\\in W})</span> ,  <span class="math">\\mathsf{w}^{(1)} = \\mathsf{WitExt}((p_{i,j}^{(1)}(X))_{(i,j)\\in W})</span> , and  <span class="math">\\mathsf{w}^{(2)} = \\mathsf{WitExt}((p_{i,j}^{(2)}(X))_{(i,j)\\in W})</span> . Then</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf {w} _ {i}) _ {i \\in I} = (\\mathsf {w} _ {i} ^ {(1)}) _ {i \\in I} \\qquad (\\mathsf {w} _ {i}) _ {i \\notin I} = (\\mathsf {w} _ {i} ^ {(2)}) _ {i \\notin I} \\qquad (\\mathsf {w} _ {i} ^ {(1)}) _ {i \\notin I} = (0) \\qquad (\\mathsf {w} _ {i} ^ {(2)}) _ {i \\in I} = (0)</span></div>

    <p class="text-gray-300">Remark 2. If the above decomposition function is invoked on WCPs, one can observe that witness extraction/decoding is also additively homomorphic on such honest inputs, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {W i t E x t} \\left(\\left(p _ {i, j} (X)\\right) _ {(i, j) \\in W}\\right) = \\operatorname {W i t E x t} \\left(\\left(p _ {i, j} ^ {(1)} (X)\\right) _ {(i, j) \\in W} + \\left(p _ {i, j} ^ {(2)} (X)\\right) _ {(i, j) \\in W}\\right) \\\\ = \\operatorname {W i t E x t} \\left(\\left(p _ {i, j} ^ {(1)} (X)\\right) _ {(i, j) \\in W}\\right) + \\operatorname {W i t E x t} \\left(\\left(p _ {i, j} ^ {(2)} (X)\\right) _ {(i, j) \\in W}\\right). \\\\ \\end{array}</span></div>

    <h2 id="sec-15" class="text-2xl font-bold">3.3 Our compiler</h2>

    <p class="text-gray-300">In order to prove the relation  <span class="math">\\mathcal{R}_{\\mathrm{com}}</span>  above, our compiler will use a commit-and-prove NIZKAoK subprotocol for following relation. Although the abstract relation  <span class="math">\\mathcal{R}_{\\mathrm{1nk}}</span>  looks cumbersome for the sake of generality, the actual instantiation of  <span class="math">\\mathsf{CP}_{\\mathrm{1nk}}</span>  will be rather simple: it can be achieved by "linking" committed witness sub-vectors and proving "non-overlapping" decomposition as outlined in 1.3. See Figs. 4, 5 and 7 for concrete examples.</p>

    <p class="text-gray-300"><strong>Definition 10 (Commitment-linking relation).</strong> Fix an AHP with  <span class="math">W</span> -straight-line extractor and witness carrying polynomials, a polynomial commitment scheme PC, and an auxiliary commitment scheme AC. We define the linking relation</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\mathrm {1 n k}} = \\left\\{ \\begin{array}{c c} &amp; I _ {\\mathrm {c o m}} \\subset [ n ] \\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I _ {\\mathrm {c o m}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell d \\wedge \\\\ ((n, \\ell , d, I _ {\\mathrm {c o m}}, (I _ {k}) _ {k \\in [ \\ell ]}, \\mathrm {c k}, \\mathrm {a c k}), &amp; I _ {\\mathrm {c o m}} = \\bigcup_ {k \\in [ \\ell ]} I _ {k} \\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I _ {k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d \\wedge \\\\ ((\\tilde {c} _ {k}) _ {k \\in [ \\ell ]}, \\mathbf {v}, Q, &amp; c _ {i, j} ^ {\\mathrm {c o m}} = \\mathsf {P C}. \\mathsf {C o m} _ {\\mathrm {c k}} (p _ {i, j} ^ {\\mathrm {c o m}} (X), \\mathsf {d} (\\mathrm {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j); \\omega_ {i, j} ^ {\\mathrm {c o m}}) \\wedge \\\\ (c _ {i, j} ^ {\\mathrm {c o m}} (X), c _ {i, j} ^ {\\mathrm {m i d}} (X)) _ {(i, j) \\in W}), &amp; c _ {i, j} ^ {\\mathrm {m i d}} = \\mathsf {P C}. \\mathsf {C o m} _ {\\mathrm {c k}} (p _ {i, j} ^ {\\mathrm {m i d}} (X), \\mathsf {d} (\\mathrm {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j); \\omega_ {i, j} ^ {\\mathrm {m i d}}) \\wedge \\\\ ((p _ {i, j} ^ {\\mathrm {c o m}} (X), p _ {i, j} ^ {\\mathrm {m i d}} (X)) _ {(i, j) \\in W}, &amp; \\tilde {c} _ {k} = \\mathsf {A C}. \\mathsf {C o m} _ {\\mathrm {a c k}} ((\\mathsf {w} _ {i}) _ {i \\in I _ {k}}; r _ {k}) \\text{ where} \\\\ (\\omega_ {i, j} ^ {\\mathrm {c o m}} (X), \\omega_ {i, j} ^ {\\mathrm {m i d}} (X)) _ {(i, j) \\in W}, &amp; \\mathsf {w} = \\mathsf {W i t E x t} ((p _ {i, j} ^ {\\mathrm {c o m}} (X) + p _ {i, j} ^ {\\mathrm {m i d}} (X)) _ {(i, j) \\in W}) \\wedge \\\\ (r _ {k}) _ {k \\in [ \\ell ]})) &amp; v _ {((i, j), z)} = p _ {i, j} ^ {\\mathrm {c o m}} (z) + p _ {i, j} ^ {\\mathrm {c o m}} (z) \\\\ &amp; \\text{for all } ((i, j), z) \\in Q \\text{ such that } (i, j) \\in W \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Remark 3.</strong> On a high-level the relation guarantees "the prover knows polynomials committed via PC, such that their sum correctly decodes to the partial witnesses committed via AC". Although the correctness of polynomial evaluation (i.e., the condition " <span class="math">v_{((i,j),z)} = p_{i,j}^{\\mathrm{com}}(z) + p_{i,j}^{\\mathrm{com}}(z)</span> ) is also part of  <span class="math">\\mathcal{R}_{1\\mathrm{nk}}</span> , we remark that this is redundant since it is to be proven by the opening algorithm of PC outside  <span class="math">\\mathsf{CP}_{1\\mathrm{nk}}</span>  anyway. Looking ahead, security proof of our compiler indeed holds even without showing such a condition within  <span class="math">\\mathsf{CP}_{1\\mathrm{nk}}</span> . We rather include this for the ease of proving knowledge soundness of  <span class="math">\\mathsf{CP}_{1\\mathrm{nk}}</span> ; in concrete instantiations, an extractor of  <span class="math">\\mathsf{CP}_{1\\mathrm{nk}}</span>  typically needs to extract what is committed to  <span class="math">c_{i,j}^{\\mathrm{mid}}</span>  by internally invoking an extractor of PC, which however is only guaranteed to succeed if the evaluation proof is valid. Hence, by letting  <span class="math">\\mathsf{CP}_{1\\mathrm{nk}}</span>  take care of evaluation proof by default we can easily make such an argument go through. In later sections our  <span class="math">\\mathsf{CP}_{1\\mathrm{nk}}</span>  for Sonic takes advantage of this generalization, while the ones for PLONK and Marlin don't since they create a special evaluation proof independent of the AHP query phase.</p>

    <p class="text-gray-300"><strong>Intuition about the compiler.</strong> The compiler in Figure 1 is close to those in Marlin [CHM+20], Lunar [CFF+20] and DARK [BFS20]. One important difference is the use of polynomial decomposition where the prover will commit separately to each of the "parts" of the WCPs. This separate commitment will allow efficiently proving the commitment-linking relation.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let  <span class="math">\\mathcal{F}</span>  be a field family and  <span class="math">\\mathcal{R}</span>  be an indexed relation. Consider the following components:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AHP = (k, s, d, l, P, V) is a knowledge sound AHP for  <span class="math">\\mathcal{R}</span>  with  <span class="math">W</span> -straight-line unique extractor, and with a decomposition function Decomp for witness-carrying polynomials  <span class="math">(p_{i,j}(X))_{(i,j)\\in W}</span> ;</li>

      <li>PC = (Setup, Com, Open, Check) is an additively homomorphic polynomial commitment over  <span class="math">\\mathcal{F}</span>  with binding and extractability;</li>

      <li><span class="math">\\mathsf{CP}_{1\\mathsf{nk}} = (\\mathcal{I}_{1\\mathsf{nk}},\\mathcal{P}_{1\\mathsf{nk}},\\mathcal{V}_{1\\mathsf{nk}})</span>  is (preprocessing) non-interactive argument of knowledge for  <span class="math">\\mathcal{R}_{1\\mathsf{nk}}</span>  (Definition 10)</li>

    </ul>

    <p class="text-gray-300">Then the construction of <span class="math">\\mathsf{ARG}=(\\mathcal{S},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> in Fig. 1 is a preprocessing argument system for the relation <span class="math">\\mathcal{R}_{\\mathsf{com}}</span>. Moreover, if witness-carrying polynomials are disjoint and <span class="math">I_{\\mathsf{com}}\\subset I_{i^{<em>},j^{</em>}}</span> for some <span class="math">(i^{<em>},j^{</em>})\\in W</span>, then the above claim holds even if <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> shows a variant of <span class="math">\\mathcal{R}_{\\mathsf{1nk}}</span> such that all “<span class="math">(i,j)\\in W</span>” are replaced by <span class="math">(i^{<em>},j^{</em>})</span> and <span class="math">\\mathsf{WitExt}</span> is replaced by <span class="math">\\mathsf{WitExt}_{i^{<em>},j^{</em>}}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{PC}</span> is hiding, <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> is zero-knowledge, and <span class="math">\\mathsf{AHP}</span> is zero-knowledge as defined in Definition 3, then <span class="math">\\mathsf{ARG}</span> is also zero-knowledge.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">While in the description of our compiler we generically commit all polynomials with the same type of polynomial commitments, our instantiations use some ad-hoc tweaks. In particular, we commit to the witness carrying polynomials using a special version of KZG (see for example the input format of commitments in Figure 4) different than the one we use for the rest of the oracle polynomials. Note that this is a standard optimization trick already used in previous works, e.g., <em>[CHM^{+}20]</em>,<em>[x10]</em>,<em>[x16]</em>, and we are still able to satisfy the security requirements of the general compiler this way.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness. It follows from properties of the Decomp function, uniqueness of extraction, and homomorphism of <span class="math">\\mathsf{PC}</span>. Concretely, since <span class="math">\\mathsf{PC}</span> is homomorphic and decomposition of polynomials is additive and degree-preserving, it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">c_{i,j}^{\\mathsf{com}}+c_{i,j}^{\\mathsf{mid}}</span> $=\\mathsf{PC.Com}_{\\mathsf{ck}}(p_{i,j}^{\\mathsf{com}}(X)+p_{i,j}^{\\mathsf{mid}}(X),\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j);\\omega_{i,j}^{\\mathsf{com}}+\\omega_{i,j}^{\\mathsf{mid}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence <span class="math">\\mathcal{V}</span> always accepts evaluation of <span class="math">p_{i,j}(X)</span> during <span class="math">\\mathsf{PC.Check}_{\\mathsf{rk}}</span>. Moreover, due to uniqueness of extraction and properties of <span class="math">\\mathsf{Decomp}</span>, if the instance-witness pair is in <span class="math">\\mathcal{R}_{\\mathsf{com}}</span> then we have that the inputs to <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> prover satisfy relation <span class="math">\\mathcal{R}_{\\mathsf{1nk}}</span>. In particular,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{WitExt}((p_{i,j}^{\\mathsf{com}}(X)+p_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W})=\\mathsf{WitExt}((p_{i,j}(X))_{(i,j)\\in W})=\\mathsf{w}.</span></p>

    <p class="text-gray-300">Knowledge soundness. It follows from homomorphism and binding of <span class="math">\\mathsf{PC}</span>, knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> and <span class="math">W</span>-straight-line extractability of <span class="math">\\mathsf{AHP}</span>. Our goal is to extract a pair of witness <span class="math">((\\mathsf{w}_{i})_{i\\in[n]},(r_{k})_{k\\in[\\ell]})</span> that satisfies relation <span class="math">\\mathcal{R}_{\\mathsf{com}}</span>, given index <span class="math">(\\mathsf{i},m,\\ell,d,I_{\\mathsf{com}},(I_{k})_{k\\in[\\ell]},\\mathsf{ack})</span> and statement <span class="math">(\\mathsf{x},(\\tilde{c}_{k})_{k\\in[\\ell]})</span>. Namely, <span class="math">(\\mathsf{w}_{i})_{i\\in[n]}</span> such that <span class="math">(\\mathsf{i},\\mathsf{x},(\\mathsf{w}_{i})_{i\\in[n]})\\in\\mathcal{R}</span> and randomness <span class="math">r_{k}</span> for commitment <span class="math">\\tilde{c}_{k}</span> such that its opening is consistent with <span class="math">(\\mathsf{w}_{i})_{i\\in I_{k}}</span>. At the high-level the extractor <span class="math">\\mathcal{E}_{\\mathsf{ARG}}</span> works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extract the polynomials from the polynomial commitments sent at each round through the extractor for the polynomial commitments;</li>

      <li>From these, for each <span class="math">(i,j)\\in W</span> reconstruct the witness-carrying polynomials as <span class="math">\\tilde{p}_{i,j}(X)</span>;</li>

      <li>On the other hand, extract auxiliary commitment randomness <span class="math">(\\tilde{r}_{k})_{k\\in[\\ell]}</span> as well as decomposed witness-carrying polynomials <span class="math">(p_{i,j}^{\\mathsf{com}}(X),p_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W}</span> such that <span class="math">p_{i,j}(X)=p_{i,j}^{\\mathsf{com}}(X)+p_{i,j}^{\\mathsf{mid}}(X)</span>, by invoking the linking extractor.</li>

      <li>Extract witness <span class="math">(\\hat{\\mathsf{w}}_{i})_{i\\in[n]}</span> from the <span class="math">W</span>-straight-line extractor as <span class="math">\\mathsf{WitExt}(\\tilde{p}_{i,j}(X))_{(i,j)\\in W}</span>;</li>

      <li>Return <span class="math">((\\hat{\\mathsf{w}}_{i})_{i\\in[n]},(\\tilde{r}_{k})_{k\\in[\\ell]})</span>.</li>

    </ol>

    <p class="text-gray-300">A more detailed version of the proof follows.</p>

    <p class="text-gray-300">Suppose that <span class="math">\\tilde{\\mathcal{P}}</span> convinces <span class="math">\\mathcal{V}</span> of <span class="math">\\mathsf{ARG}</span> with non-negligible probability. Assuming the existence of extractors <span class="math">\\mathcal{E}_{\\mathsf{PC}}</span> for <span class="math">\\mathsf{PC}</span> and <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> for <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span>, we show the existence of another extractor <span class="math">\\mathcal{E}_{\\mathsf{ARG}}</span> that outputs a valid witness <span class="math">\\hat{\\mathsf{w}}</span> for <span class="math">\\mathcal{R}_{\\mathsf{com}}</span> with non-negligible probability, given access to <span class="math">\\tilde{\\mathcal{P}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First we construct an adversary <span class="math">\\mathcal{A}_{\\mathsf{PC}}</span> against the extractability game for <span class="math">\\mathsf{PC}</span>. The <span class="math">\\mathcal{A}_{\\mathsf{PC}}</span> receives <span class="math">\\mathsf{ck}</span> and random coins as input, and internally invokes <span class="math">\\tilde{\\mathcal{P}}</span> to obtain a set of commitments <span class="math">(\\tilde{c}_{i,j})_{i\\in[\\mathsf{k}],j\\in[\\mathsf{s}(i)]}</span>, where for <span class="math">(i,j)\\in W</span> it holds that <span class="math">\\tilde{c}_{i,j}=\\tilde{c}_{i,j}^{\\mathsf{com}}+\\tilde{c}_{i,j}^{\\mathsf{mid}}</span>.</li>

      <li>We then invoke an extractor <span class="math">\\mathcal{E}_{\\mathsf{PC}}</span> who, given the same input as that of <span class="math">\\mathcal{A}_{\\mathsf{PC}}</span>, outputs a set of polynomials <span class="math">\\tilde{\\mathbf{p}}:=(\\tilde{p}_{i,j})_{i\\in[\\mathsf{k}],j\\in[\\mathsf{s}(i)]}</span>. If the cheating prover <span class="math">\\tilde{\\mathcal{P}}</span> convinces the <span class="math">\\mathsf{ARG}</span> verifier <span class="math">\\mathcal{V}</span>, then the evaluation proof <span class="math">\\tilde{\\pi}_{\\mathsf{Eval}}</span> is valid w.r.t. the alleged evaluations <span class="math">\\hat{\\mathbf{v}}:=(\\tilde{v}_{i,j})_{i\\in[\\mathsf{k}],j\\in[\\mathsf{s}(i)]}</span>. Hence if <span class="math">\\mathcal{E}_{\\mathsf{PC}}</span> fails to extract polynomials (i.e., <span class="math">\\tilde{\\mathbf{p}}(Q)\\neq\\hat{\\mathbf{v}}</span>), then <span class="math">\\mathcal{A}_{\\mathsf{PC}}</span> wins the extractability game, which, however, happens with negligible probability under our assumption. So below we assume that with overwhelming probability <span class="math">\\tilde{\\mathbf{p}}(Q)=\\hat{\\mathbf{v}}</span>.</li>

      <li>Second we construct another adversary <span class="math">\\mathcal{A}_{\\mathsf{1nk}}</span> against the knowledge soundness game for <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span>. The <span class="math">\\mathcal{A}_{\\mathsf{1nk}}</span> receives a statement for <span class="math">\\mathcal{R}_{\\mathsf{1nk}}</span> and random coins as input, and internally invokes <span class="math">\\hat{\\mathcal{P}}</span> to obtain a linking proof <span class="math">\\tilde{\\pi}_{\\mathsf{1nk}}</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We then invoke another extractor <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> who, given the same input as that of <span class="math">\\mathcal{A}_{\\mathsf{1nk}}</span>, outputs the corresponding witness <span class="math">((\\vec{p}_{i,j}^{\\mathsf{com}}(X),\\vec{p}_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W},(\\tilde{\\omega}_{i,j}^{\\mathsf{com}}(X),\\tilde{\\omega}_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W},(\\tilde{r}_{k})_{k\\in[\\ell]})</span>. If the cheating prover <span class="math">\\tilde{\\mathcal{P}}</span> convinces the <span class="math">\\mathsf{ARG}</span> verifier <span class="math">\\mathcal{V}</span>, then linking proof <span class="math">\\tilde{\\pi}_{\\mathsf{1nk}}</span> is valid w.r.t. the commitments <span class="math">(\\hat{c}_{k})_{k\\in[\\ell]}</span> and <span class="math">(\\tilde{c}_{i,j}^{\\mathsf{com}}(X),\\tilde{c}_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W}</span>. Hence if <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> fails to extract the witness, then <span class="math">\\mathcal{A}_{\\mathsf{1nk}}</span> wins the knowledge soundness game, which, however, happens with negligible probability under our assumption.</li>

      <li>Now we construct a cheating prover <span class="math">\\tilde{\\mathsf{P}}</span> for <span class="math">\\mathsf{AHP}</span>. The <span class="math">\\tilde{\\mathsf{P}}</span> internally invokes <span class="math">\\mathcal{E}_{\\mathsf{PC}}</span> and <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> to obtain <span class="math">\\tilde{\\mathbf{p}}</span> and <span class="math">((\\vec{p}_{i,j}^{\\mathsf{com}}(X),\\vec{p}_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W},(\\tilde{\\omega}_{i,j}^{\\mathsf{com}}(X),\\tilde{\\omega}_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W},(\\tilde{r}_{k})_{k\\in[\\ell]})</span>. The polynomials of the latter satisfy relation <span class="math">\\mathcal{R}_{\\mathsf{1nk}}</span>, i.e.,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\tilde{c}_{i,j}^{\\mathsf{com}}</span> $=\\mathsf{PC.Com}_{\\mathsf{ck}}(\\vec{p}_{i,j}^{\\mathsf{com}}(X),\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j);\\tilde{\\omega}_{i,j}^{\\mathsf{com}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Due to the homomorphic property of <span class="math">\\mathsf{PC}</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\tilde{c}_{i,j}^{\\mathsf{com}}+\\tilde{c}_{i,j}^{\\mathsf{mid}}=\\mathsf{PC.Com}_{\\mathsf{ck}}(\\vec{p}_{i,j}^{\\mathsf{com}}(X)+\\vec{p}_{i,j}^{\\mathsf{mid}}(X),\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j);\\tilde{\\omega}_{i,j}^{\\mathsf{com}}+\\tilde{\\omega}_{i,j}^{\\mathsf{mid}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\tilde{p}_{i,j}^{\\mathsf{com}}(X)+\\vec{p}_{i,j}^{\\mathsf{mid}}(X)\\neq\\tilde{p}_{i,j}(X)</span> for some <span class="math">(i,j)\\in W</span> (recall that the latter was extracted by <span class="math">\\mathcal{E}_{\\mathsf{PC}}</span>), then <span class="math">\\tilde{\\mathsf{P}}</span> aborts, which only happens with negligible probability as the ability to find such polynomials breaks binding of <span class="math">\\mathsf{PC}</span> w.r.t. <span class="math">\\tilde{c}_{i,j}^{\\mathsf{com}}+\\tilde{c}_{i,j}^{\\mathsf{mid}}</span>. Hence we may assume that <span class="math">\\tilde{p}_{i,j}^{\\mathsf{com}}(X)+\\vec{p}_{i,j}^{\\mathsf{mid}}(X)=\\tilde{p}_{i,j}(X)</span>. In that case, note that <span class="math">\\mathcal{R}_{\\mathsf{1nk}}</span> relation also guarantees for every <span class="math">k\\in[\\ell]</span></p>

    <p class="text-gray-300"><span class="math">\\hat{c}_{k}=\\mathsf{AC.Com}_{\\mathsf{ack}}((\\hat{\\mathsf{w}}_{i})_{i\\in I_{k}};\\tilde{r}_{k})</span></p>

    <p class="text-gray-300">where <span class="math">\\hat{\\mathsf{w}}=\\mathsf{WitExt}((\\vec{p}_{i,j}^{\\mathsf{com}}(X)+\\vec{p}_{i,j}^{\\mathsf{mid}}(X))_{(i,j)\\in W})=\\mathsf{WitExt}((\\tilde{p}_{i,j}(X))_{(i,j)\\in W})</span>.</p>

    <p class="text-gray-300">To sum up, as long as (1) <span class="math">\\mathcal{E}_{\\mathsf{PC}}</span> is successful, i.e., <span class="math">\\tilde{\\mathsf{P}}</span> outputs polynomials <span class="math">\\tilde{\\mathbf{p}}</span> which form correct opening to <span class="math">\\tilde{\\mathbf{c}}</span>, (2) <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> is successful, i.e., <span class="math">\\tilde{\\mathsf{P}}</span> internally obtains polynomials satisfying <span class="math">\\mathcal{R}_{\\mathsf{1nk}}</span>, and (3) witness-carrying polynomials extracted by <span class="math">\\mathcal{E}_{\\mathsf{PC}}</span> and <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> are identical, it holds that <span class="math">\\mathsf{V}</span> accepts whenever <span class="math">\\mathcal{V}</span> accepts. This indicates that <span class="math">\\tilde{\\mathsf{P}}</span> convinces <span class="math">\\mathsf{V}</span> with non-negligible probability if <span class="math">\\tilde{\\mathcal{P}}</span> convinces <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">We finally let <span class="math">\\mathcal{E}_{\\mathsf{ARG}}</span> invoke the <span class="math">W</span>-straight-line extractor <span class="math">\\mathsf{WitExt}</span> of <span class="math">\\mathsf{AHP}</span> on witness-carrying polynomials <span class="math">(\\tilde{p}_{i,j}(X))_{(i,j)\\in W}</span> outputted by <span class="math">\\tilde{\\mathsf{P}}</span>. By definition of the extractor <span class="math">(\\hat{\\mathsf{w}}_{i})_{i\\in[n]}=\\mathsf{WitExt}((\\tilde{p}_{i,j}(X))_{(i,j)\\in W})</span> satisfies <span class="math">(\\mathsf{i},\\mathsf{x},(\\hat{\\mathsf{w}}_{i})_{i\\in[n]})\\in\\mathcal{R}</span>. Moreover, the committed part of witness <span class="math">(\\hat{\\mathsf{w}}_{i})_{i\\in I_{k}}</span> is guaranteed to form correct opening to <span class="math">\\hat{c}_{k}</span> with extracted randomness <span class="math">\\tilde{r}_{k}</span>, thanks to the linking relation <span class="math">\\mathcal{R}_{\\mathsf{1nk}}</span>. This implies that a pair of extracted witness <span class="math">((\\hat{\\mathsf{w}}_{i})_{i\\in[n]},(\\tilde{r}_{k})_{k\\in[\\ell]})</span> satisfies <span class="math">\\mathcal{R}_{\\mathsf{com}}</span>.</p>

    <p class="text-gray-300">We argue a special case where witness carrying-polynomials are disjoint. In that case, we assume <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> only guarantees that <span class="math">(\\hat{\\mathsf{w}}_{i})_{i\\in I_{i^{<em>},j^{</em>}}}=\\mathsf{WitExt}_{i^{<em>},j^{</em>}}(\\tilde{p}_{i^{<em>},j^{</em>}})</span> are consistent with auxiliary commitments. This still retains knowledge soundness, since when <span class="math">\\mathsf{WitExt}</span> is invoked on all extracted witness-carrying polynomials at the end of <span class="math">\\mathcal{E}_{\\mathsf{ARG}}</span>, we know that <span class="math">\\mathsf{WitExt}</span> invokes <span class="math">\\mathsf{WitExt}_{i,j}</span> independently on each <span class="math">\\tilde{p}_{i,j}</span> to obtain <span class="math">(\\hat{\\mathsf{w}}_{i})_{i\\in I_{i,j}}</span> and index sets <span class="math">I_{i,j}</span> are disjoint.</p>

    <p class="text-gray-300">Zero knowledge. Our proof closely follows that of the compiler in <em>[CHM^{+}20]</em> (Theorem 8.4). We provide an overview and we stress when our proof diverges from theirs.</p>

    <p class="text-gray-300">We construct a simulator <span class="math">\\mathsf{Sim}_{\\mathsf{ARG}}</span> by using the simulators <span class="math">\\mathsf{Sim}_{\\mathsf{PC}}</span> from the polynomial commitment (hiding property), the zero-knowledge simulator <span class="math">\\mathsf{Sim}_{\\mathsf{1nk}}</span> of <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> and the zero-knowledge simulator <span class="math">\\mathsf{Sim}_{\\mathsf{AHP}}</span> of <span class="math">\\mathsf{AHP}</span>.</p>

    <p class="text-gray-300">Below we require that <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> is zero-knowledge with simulator <span class="math">\\mathsf{Sim}_{\\mathsf{1nk}}</span>. Zero-knowledge for non-interactive proof systems is standard and is a straightforward extension of the one we define for interactive-arguments (see for example <em>[x10]</em>).</p>

    <p class="text-gray-300">Consider a (stateful) malicious verifier <span class="math">\\hat{V}</span>. After receiving the srs it outputs a tuple (indexer, statement, witness):</p>

    <p class="text-gray-300"><span class="math">((\\mathsf{i},m,\\ell,d,I_{\\mathsf{com}},(I_{k})_{k\\in[\\ell]},\\mathsf{ack}),(\\mathsf{x},(\\hat{c}_{k})_{k\\in[\\ell]}),((\\mathsf{w}_{i})_{i\\in[n]},(r_{k})_{k\\in[\\ell]})).</span></p>

    <p class="text-gray-300">During the online (proving) stage the input of <span class="math">\\mathsf{Sim}_{\\mathsf{ARG}}</span> consists of the statement <span class="math">((\\mathsf{i},m,\\ell,d,I_{\\mathsf{com}},(I_{k})_{k\\in[\\ell]},\\mathsf{ack}),(\\mathsf{x},(\\hat{c}_{k})_{k\\in[\\ell]}))</span> as well as the following elements computed by the setup simulator:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the integer <span class="math">D</span> computed as in the protocol setup for size bound <span class="math">N</span>;</li>

      <li>the output of <span class="math">\\mathsf{Sim}_{\\mathsf{PC}}</span>.Setup (to obtain simulated parameters for polynomial commitment)</li>

      <li>the output of <span class="math">\\mathsf{Sim}_{\\mathsf{1nk}}</span>.Setup (to obtain simulated parameters for <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span>)</li>

    </ul>

    <p class="text-gray-300">For each round <span class="math">i\\in[k]</span>, the simulator:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>receives challenge <span class="math">\\rho_{i}</span> from the verifier and forwards it to the AHP simulator <span class="math">\\mathsf{Sim}_{\\mathsf{AHP}}(\\mathsf{x})</span>.</li>

      <li>samples commitment randomness and use <span class="math">\\mathsf{Sim}_{\\mathsf{PC}}</span> to simulate all the commitments to oracle polynomials in that round. This step is the same for both branches of Step 3 in the Online Phase of Figure 1 (both witness-carrying polynomials and not).</li>

      <li>sends commitments to verifier.</li>

    </ul>

    <p class="text-gray-300">After the online phase the simulator runs <span class="math">\\mathsf{Sim}_{\\mathsf{1nk}}</span> and sends the output to the verifier. Then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>after receiving <span class="math">\\rho_{k+1}</span> from the verifier, it runs the (honest) query algorithm to obtain a list of polynomials queries <span class="math">Q</span> from the transcript;</li>

      <li>checks that they are admissible using the checker circuit <span class="math">\\mathsf{C}</span> (see definition of AHP zero-knowledge in Definition 3)</li>

      <li>obtains simulated evaluations. In order to do this, it can run the indexer on input <span class="math">\\mathsf{i}</span> to actually obtain polynomials <span class="math">p_{0,j}</span>-s.For the evaluation points of the online phase, it forwards the query list <span class="math">Q</span> to <span class="math">\\mathsf{Sim}_{\\mathsf{AHP}}</span>.</li>

    </ul>

    <p class="text-gray-300">Finally <span class="math">\\mathsf{Sim}_{\\mathsf{ARG}}</span> simulates the evaluation proofs as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It receives an opening challenge <span class="math">\\xi</span></li>

      <li>it simulates the evaluation proofs for polynomials through <span class="math">\\mathsf{Sim}_{\\mathsf{PC}}</span></li>

    </ul>

    <p class="text-gray-300">We now argue this simulated view is indistinguishable from that of a malicious verifier. Recall from definition of zero-knowledge for AHPs that the <span class="math">\\mathsf{Sim}_{\\mathsf{AHP}}</span> can produce an indistinguishable transcript whenever the protocol carries out at most <span class="math">\\mathsf{b}</span> queries that are admissible (i.e., they satisfy checker circuit <span class="math">\\mathsf{C}</span>). Since this is the case for our protocol we can invoke this property. It is then straightforward to argue that <span class="math">\\mathsf{Sim}_{\\mathsf{PC}}</span> leaks nothing more about these evaluations because of the hiding property of the polynomial commitments. Invoking the zero-knowledge property of <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> completes the proof. ∎</p>

    <h2 id="sec-18" class="text-2xl font-bold">4 Compressed <span class="math">\\Sigma</span>-protocol for Equality</h2>

    <p class="text-gray-300">We describe how to construct an efficient protocol proving equality of committed vectors, following the framework due to <em>Attema and Cramer [20]</em> and <em>Attema, Cramer and Fehr [2]</em>. This allows us to instantiate <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> with proof size of only <span class="math">O(\\log(\\ell d))</span> when <span class="math">\\ell</span> Pedersen commitments are received as inputs.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.1 AmComEq: Amortization of <span class="math">\\ell</span> commitment equality proofs</h3>

    <p class="text-gray-300">In our application, we would like to show equality of vectors within a single commitment containing vector of size <span class="math">\\ell d</span> (corresponding to a polynomial commitment) and <span class="math">\\ell</span> chunks of vector of size <span class="math">d</span> in multiple Pedersen commitments. Concretely, our goal is to give an efficient protocol for relation</p>

    <p class="text-gray-300">\\[ \\mathcal{R}_{\\mathsf{AmComEq}}=\\left\\{\\begin{array}[]{lcl}((\\bm{g},\\mathbf{h},\\mathbf{G},\\mathbf{H},d,d^{\\prime},d^{\\prime\\prime},\\ell),&C=\\bm{g}^{\\mathbf{w}}\\mathbf{h}^{\\bm{\\alpha}},\\hat{C}_{i}=\\mathbf{G}^{\\mathbf{w}_{i}}\\mathbf{H}^{\\bm{\\beta}_{i}},\\\\ (C,\\hat{C}_{1},\\ldots,\\hat{C}_{\\ell}),&:\\quad&\\bm{g}\\in\\mathbb{G}^{\\ell d},\\mathbf{G}\\in\\mathbb{G}^{d},\\mathbf{h}\\in\\mathbb{G}^{d^{\\prime}},\\mathbf{H}\\in\\mathbb{G}^{d^{\\prime\\prime}},\\\\ (\\mathbf{w},\\bm{\\alpha},\\bm{\\beta}_{1},\\ldots,\\bm{\\beta}_{\\ell}))&\\quad&\\mathbf{w}_{i}\\in\\mathbb{Z}_{q}^{d},\\bm{\\alpha}\\in\\mathbb{Z}_{q}^{d^{\\prime}},\\bm{\\beta}_{i}\\in\\mathbb{Z}_{q}^{d^{\\prime\\prime}},\\mathbf{w}=[\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{\\ell}]\\end{array}\\right\\} \\] (1)</p>

    <p class="text-gray-300">where we assume <span class="math">d^{\\prime}</span> and <span class="math">d^{\\prime\\prime}</span> are small constants (for concrete instantiations in later sections, we only need <span class="math">d^{\\prime}\\leq 4</span> and <span class="math">d^{\\prime\\prime}=1</span>). Our starting point is a naïve <span class="math">\\mathsf{ComEq}</span> <span class="math">\\Sigma</span>-protocol proving equality of vectors committed in two Pedersen commitments, with proof size of <span class="math">O(d)</span> (see Appendix A). To avoid invoking <span class="math">\\mathsf{ComEq}</span> individually for many commitments we first amortize the statements. The main idea of amortization is to introduce additional challenge <span class="math">x\\in\\mathbb{Z}_{q}</span> and use it to take a random linear combination in the exponent. A similar idea has appeared in many contexts, e.g., amortization of many range proofs in Bulletproofs <em>[BBB+18]</em> and batch verification of EdDSA signatures. Note that the protocol below can be seen as a verifier-optimized version of the technique described by <em>Attema–Cramer–Fehr [2, §3.4]</em>. For completeness, in Fig. 9 we include a version derived by invoking their amortization of multiple group homomorphisms in a black-box way. The advantage of our <span class="math">\\mathsf{AmComEq}</span> over Fig. 9 is that it allows to save <span class="math">\\ell</span> group exponentiations on verifier’s side (i.e., computation of <span class="math">\\bar{\\mathbf{H}}</span>), by letting the prover precompute amortization of commitment randomness <span class="math">\\bm{\\beta}_{i}</span>. However, the proof sizes are identical.</p>

    <p class="text-gray-300">Note also that the protocol is 4-round where the first message is a challenge, which does not really fit into the format of standard Fiat–Shamir transform <em>[10]</em>. However, one can easily make it applicable by either introducing additional round where the prover first sends a dummy randomness, or let them send <span class="math">A</span> before receiving challenge <span class="math">x</span></p>

    <p class="text-gray-300">Setup  <span class="math">S(1^<em>, N, d)</span> . The setup  <span class="math">S</span>  on input a security parameter  <span class="math">\\kappa \\in \\mathbb{N}</span>  and size bound  <span class="math">N \\in \\mathbb{N}</span> , uses  <span class="math">N</span>  to compute a maximum degree bound  <span class="math">D</span> , samples  <span class="math">\\mathsf{pp} \\gets \\mathsf{PC}.Setup(1^</em>, D)</span> , samples  <span class="math">\\mathsf{ack} \\gets \\mathsf{AC}.Setup(1^*, d)</span> , and then outputs  <span class="math">\\mathsf{srs} := (\\mathsf{pp}, \\mathsf{ack})</span> . The integer  <span class="math">D</span>  is computed to be the maximum degree bound in AHP for indices of size  <span class="math">N</span> . In other words,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D := \\max  \\left\\{\\mathsf {d} (\\mathsf {N}, i, j)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i \\in \\{0, 1, \\dots , \\mathsf {k} (\\mathsf {N}) \\}, j \\in \\{1, \\dots , \\mathsf {s} (i) \\} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Indexer  <span class="math">\\mathcal{I}^{\\mathrm{sr}}(\\mathrm{i},I_{\\mathrm{com}},(I_k)_{k\\in [\\ell ]})</span>  . The indexer  <span class="math">\\mathcal{I}</span>  upon input i, commitment index sets  <span class="math">I_{\\mathrm{com}}</span> <span class="math">(I_{k})_{k\\in [\\ell ]}</span>  and given oracle access to srs, deduces the field  <span class="math">\\mathbb{F}\\in \\mathcal{F}</span>  contained in srs  <span class="math">= (\\mathsf{pp},\\mathsf{ack})</span>  , runs the AHP indexer I on  <span class="math">(\\mathbb{F},\\mathrm{i})</span>  to obtain s(0) polynomials  <span class="math">(p_{0,j})_{j = 1}^{\\mathrm{s(0)}}\\in \\mathbb{F}[X]</span>  of degrees at most  $(\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,j))_{j = 1}^{\\mathrm{s(0)}}<span class="math">  . Then it proceeds by computing (ck,rk) := PC.Trim  </span>{}^{\\mathrm{sp}}(\\mathbf{d})<span class="math">  , where  </span>\\mathbf{d} = (\\mathbf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j))_{i\\in [\\mathbf{k}],j\\in [\\mathbf{s}(i)]}<span class="math">  and generating (de-randomized) commitments to index polynomials  </span>(c_{0,j})_{j = 1}^{\\mathrm{s(0)}} = \\mathsf{PC.Com}_{\\mathrm{ck}}((p_{0,j})_{j = 1}^{\\mathrm{s(0)}})<span class="math">  . It also invokes the indexer of CPink:  </span>(\\mathrm{ipk}_{\\mathrm{ink}},\\mathrm{ivk}_{\\mathrm{ink}})\\gets \\mathcal{I}_{\\mathrm{ink}}^{\\mathrm{sr}}(I_{\\mathrm{com}},(I_k)_{k\\in [\\ell ]})<span class="math">  . The indexer outputs ipk := (ck,i,(p0,j)  </span>^{\\mathrm{s(0)}}_{j = 1}<span class="math"> </span>(c_{0,j})_{j = 1}^{\\mathrm{s(0)}}<span class="math">  , ipk ink) and ivk := (rk,(c0,j)  </span>^{\\mathrm{s(0)}}_{j = 1}$  , ivk ink).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Input. The ARG prover  <span class="math">\\mathcal{P}</span>  receives  <span class="math">(\\mathsf{ipk},(\\mathsf{x},(\\hat{c}_k)_{k\\in [\\ell ]}),((\\mathsf{w}_i)_{i\\in [\\kappa ]},(r_k)_{k\\in [\\ell ]}))</span>  and the verifier  <span class="math">\\nu</span>  receives (ivk,  <span class="math">(\\mathbf{x},(\\hat{c}_k)_{k\\in [\\ell ]}))</span></p>

    <p class="text-gray-300">Online phase. For every round  <span class="math">i \\in [\\mathbf{k}]</span> ,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run the  <span class="math">i</span> -th round of interaction between the AHP prover  <span class="math">\\mathsf{P}(\\mathbb{F}, \\mathrm{i}, \\mathbf{x}, \\mathbf{w})</span>  and verifier  <span class="math">\\mathsf{V}(\\mathbb{F}, \\mathbf{x})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  receives random challenge  <span class="math">\\rho_{i} \\in \\mathbb{F}</span>  from  <span class="math">\\mathsf{V}</span> , and forwards it to  <span class="math">\\mathcal{P}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.  <span class="math">\\mathcal{P}</span>  forwards  <span class="math">\\rho_{i}</span>  to  <span class="math">\\mathsf{P}</span> , which replies with polynomials  <span class="math">p_{i,1},\\ldots ,p_{i,\\mathsf{s}(i)}\\in \\mathbb{F}[X]</span>  with  $\\deg (p_{i,j})\\leq \\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes and outputs commitments as follows.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">i = \\mathsf{k}_{\\mathsf{w}}</span>  (i.e. witness-committing round), then  <span class="math">\\mathcal{P}</span>  first decomposes witness-carrying polynomials as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(p _ {i, j} ^ {\\mathrm {c o m}} (X), p _ {i, j} ^ {\\mathrm {m i d}} (X)) _ {(i, j) \\in W} := \\operatorname {D e c o m p} ((p _ {i, j} (X)) _ {(i, j) \\in W}, I _ {\\mathrm {c o m}})</span></div>

    <p class="text-gray-300">such that  <span class="math">p_{i,j}(X) = p_{i,j}^{\\mathrm{com}}(X) + p_{i,j}^{\\mathrm{mid}}(X)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every  <span class="math">(i,j) \\in W</span> ,  <span class="math">\\mathcal{P}</span>  sends</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {i, j} ^ {\\mathrm {c o m}} := \\mathsf {P C}. \\mathsf {C o m} _ {\\mathrm {c k}} (p _ {i, j} ^ {\\mathrm {c o m}} (X), \\mathsf {d} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j); \\omega_ {i, j} ^ {\\mathrm {c o m}})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {i, j} ^ {\\mathrm {m i d}} := \\mathsf {P C}. \\mathsf {C o m} _ {\\mathrm {c k}} (p _ {i, j} ^ {\\mathrm {m i d}} (X), \\mathsf {d} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j); \\omega_ {i, j} ^ {\\mathrm {m i d}})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">to  <span class="math">\\mathcal{V}</span> , where  <span class="math">\\omega_{i,j}^{\\mathrm{com}}</span>  and  <span class="math">\\omega_{i,j}^{\\mathrm{mid}}</span>  are uniformly sampled masking polynomials according to the polynomial commitment scheme.  <span class="math">\\mathcal{P}</span>  lets  <span class="math">\\omega_{i,j} := \\omega_{i,j}^{\\mathrm{com}} + \\omega_{i,j}^{\\mathrm{mid}}</span> .  <span class="math">\\mathcal{V}</span>  computes  <span class="math">c_{i,j} := c_{i,j}^{\\mathrm{com}} + c_{i,j}^{\\mathrm{mid}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every  <span class="math">(i,j) \\notin W</span> ,  <span class="math">\\mathcal{P}</span>  sends</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {i, j} := \\mathsf {P C}. \\mathsf {C o m} _ {\\mathsf {c k}} (p _ {i, j} (X), \\mathsf {d} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j); \\omega_ {i, j})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">to  <span class="math">\\mathcal{V}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">After  <span class="math">\\mathbf{k}</span>  rounds of interaction,  <span class="math">\\mathcal{V}</span>  obtains an additional challenge  <span class="math">\\rho_{\\mathbf{k} + 1}\\in \\mathbb{F}^*</span>  from the AHP verifier  <span class="math">\\mathbf{V}</span> , used in the next phase. Let  <span class="math">\\mathbf{c}\\coloneqq (c_{i,j})_{i\\in [\\mathbf{k}],j\\in [\\mathbf{s}(i)]}</span> ,  <span class="math">\\mathbf{p}\\coloneqq (p_{i,j})_{i\\in [\\mathbf{k}],j\\in [\\mathbf{s}(i)]}</span> ,  <span class="math">\\boldsymbol {\\omega}\\coloneqq (\\omega_{i,j})_{i\\in [\\mathbf{k}],j\\in [\\mathbf{s}(i)]}</span>  and  $\\mathbf{d}\\coloneqq (\\mathbf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j))_{i\\in [\\mathbf{k}],j\\in [\\mathbf{s}(i)]}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends  <span class="math">\\rho_{\\mathbf{k} + 1}\\in \\mathbb{F}^*</span>  that represents randomness for the query phase of  <span class="math">\\mathsf{V}(\\mathbb{F},\\mathsf{x})</span>  to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  uses the query algorithm of  <span class="math">\\mathsf{V}</span>  to compute the query set  <span class="math">Q\\coloneqq \\mathsf{Q}_{\\mathsf{V}}(\\mathbb{F},\\mathsf{x};\\rho_1,\\ldots ,\\rho_{\\mathsf{k}},\\rho_{\\mathsf{k} + 1})</span></li>

      <li><span class="math">\\mathcal{P}</span>  replies with answers  <span class="math">\\mathbf{v} \\coloneqq \\mathbf{p}(Q)</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  samples and sends an opening challenge  <span class="math">\\xi \\in \\mathbb{F}</span>  to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  replies with an evaluation proof to demonstrate correctness of all claimed evaluations.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\text {E v a l}} := \\mathrm {P C}. \\operatorname {O p e n} _ {\\mathrm {c k}} (\\mathbf {p}, \\mathbf {d}, Q, \\xi ; \\omega)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {P} _ {\\text {l a k}} \\left(\\operatorname {i p k} _ {\\text {l a k}}, \\left(\\left(\\hat {c} _ {k}\\right) _ {k \\in [ \\ell ]}, \\mathbf {v}, Q, \\left(c _ {i, j} ^ {\\text {c o m}} (X), c _ {i, j} ^ {\\text {m i d}} (X)\\right) _ {(i, j) \\in W}\\right), \\left(\\left(p _ {i, j} ^ {\\text {c o m}} (X), p _ {i, j} ^ {\\text {m i d}} (X)\\right) _ {(i, j) \\in W}, \\left(\\omega_ {i, j} ^ {\\text {c o m}} (X), \\omega_ {i, j} ^ {\\text {m i d}} (X)\\right) _ {(i, j) \\in W}, \\left(r _ {k}\\right) _ {k \\in [ \\ell ]}\\right)\\right)</span></div>

    <p class="text-gray-300">to obtain and send linking proof  <span class="math">\\pi_{\\mathrm{1kk}}</span></p>

    <p class="text-gray-300">Decision phase.  <span class="math">\\mathcal{V}</span>  accepts if and only if the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the decision algorithm of  <span class="math">\\mathsf{V}</span>  accepts the answers, i.e.,  <span class="math">\\mathsf{D}_{\\mathsf{V}}(\\mathbb{F},\\mathsf{x},\\mathsf{v},\\rho_1,\\ldots ,\\rho_{\\mathsf{k}},\\rho_{\\mathsf{k} + 1}) = 1</span></li>

      <li>the alleged answers pass the test, i.e., PC.Check  <span class="math">\\mathbf{A}(\\mathbf{c},\\mathbf{d},Q,\\mathbf{v},\\pi_{\\mathrm{Eval}},\\xi) = 1</span></li>

      <li>the alleged linking proof is verified, i.e.,  <span class="math">\\mathcal{V}_{\\mathrm{1kk}}(i\\nu k_{\\mathrm{1kk}},((\\hat{c}_k)_{k\\in [\\ell ]},\\mathbf{v},Q,(c_{i,j}^{\\mathrm{com}}(X),c_{i,j}^{\\mathrm{mid}}(X))_{(i,j)\\in W}),\\pi_{\\mathrm{1kk}}) = 1;</span></li>

    </ul>

    <p class="text-gray-300">Fig.1. Compiler from AHP to Interactive AoK for  <span class="math">\\mathcal{R}_{\\mathrm{com}}</span> . The differences with the Marlin compiler are marked in red.</p>

    <p class="text-gray-300">Protocol AmComEq</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends random challenge  <span class="math">x\\in \\mathbb{Z}_q</span>  . Both parties compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathbf {G}} = \\left[ \\mathbf {G}, \\mathbf {G} ^ {x}, \\dots , \\mathbf {G} ^ {x ^ {\\ell - 1}} \\right] \\in \\mathbb {G} ^ {\\ell d}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  samples random  <span class="math">\\mathbf{r} \\in \\mathbb{Z}_q^{\\ell d}</span> ,  <span class="math">\\pmb{\\delta} \\in \\mathbb{Z}_q^{d&#x27;}</span> ,  <span class="math">\\pmb{\\gamma} \\in \\mathbb{Z}_q^{d&#x27;&#x27;}</span> , and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A = \\boldsymbol {g} ^ {\\mathbf {r}} \\mathbf {h} ^ {\\boldsymbol {\\delta}} \\quad \\tilde {A} = \\tilde {\\mathbf {G}} ^ {\\mathbf {r}} \\mathbf {H} ^ {\\gamma}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends random challenge  <span class="math">e\\in \\mathbb{Z}_q</span></li>

      <li><span class="math">\\mathcal{P}</span>  sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {z} = \\mathbf {r} + e \\mathbf {w}, \\quad \\boldsymbol {\\omega} = \\boldsymbol {\\delta} + e \\boldsymbol {\\alpha}, \\quad \\boldsymbol {\\Omega} = \\boldsymbol {\\gamma} + e \\sum_ {i = 1} ^ {\\ell} \\beta_ {i} x ^ {i - 1}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  checks</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {g} ^ {\\mathbf {z}} \\mathbf {h} ^ {\\omega} \\stackrel {?} {=} A C ^ {e}, \\quad \\tilde {\\mathbf {G}} ^ {\\mathbf {z}} \\mathbf {H} ^ {\\Omega} \\stackrel {?} {=} \\tilde {A} \\prod_ {i = 1} ^ {\\ell} (\\hat {C} _ {i} ^ {x ^ {i - 1}}) ^ {e}</span></div>

    <p class="text-gray-300">Fig. 2. Four-move protocol for amortized equality of many vector Pedersen commitments.</p>

    <p class="text-gray-300">Theorem 2. AmComEq is a four-move protocol for the relation  <span class="math">\\mathcal{R}_{\\mathrm{AmComEq}}</span> . It is perfectly complete, computationally  <span class="math">(\\ell, 2)</span> -special sound if finding non-trivial discrete-log relation for the generators  <span class="math">[g, h]</span>  is hard, and special HVZK. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> : 2 elements of  <span class="math">\\mathbb{G}</span>  and  <span class="math">\\ell d + d&#x27; + d&#x27;&#x27;</span>  elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> : 2 elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

    </ul>

    <p class="text-gray-300">Proof. Completeness. It follows by inspection.</p>

    <p class="text-gray-300"><span class="math">(\\ell, 2)</span> -special soundness. For every execution  <span class="math">j \\in [\\ell]</span> , we fix the first challenge  <span class="math">x_j</span> . Given two accepting transcripts  <span class="math">(x_j, A_j, \\tilde{A}_j, e_j, \\mathbf{z}_j, \\boldsymbol{\\omega}_j, \\boldsymbol{\\Omega}_j)</span>  and  <span class="math">(x_j, A_j, \\tilde{A}_j, e&#x27;_j, \\mathbf{z}_j&#x27;, \\boldsymbol{\\omega}_j&#x27;, \\boldsymbol{\\Omega}_j&#x27;)</span>  for the same  <span class="math">x_j</span>  but with distinct  <span class="math">e_j</span>  and  <span class="math">e&#x27;_j</span> , we extract valid witness w.r.t.  <span class="math">C</span>  from the first verification condition  <span class="math">\\boldsymbol{g}^{\\mathbf{z}_j} \\mathbf{h}^{\\boldsymbol{\\omega}_j} = A_j C^{e_j}</span>  and  <span class="math">\\boldsymbol{g}^{\\mathbf{z}_j&#x27;} \\mathbf{h}^{\\boldsymbol{\\omega}_j&#x27;} = A_j C^{e&#x27;_j}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathbf {w}} _ {j} = \\left(\\mathbf {z} _ {j} - \\mathbf {z} _ {j} ^ {\\prime}\\right) / \\left(e _ {j} - e _ {j} ^ {\\prime}\\right), \\quad \\tilde {\\boldsymbol {\\alpha}} _ {j} = \\left(\\boldsymbol {\\omega} _ {j} - \\boldsymbol {\\omega} _ {j} ^ {\\prime}\\right) / \\left(e _ {j} - e _ {j} ^ {\\prime}\\right)</span></div>

    <p class="text-gray-300">such that  <span class="math">C = \\pmb{g}^{\\tilde{\\mathbf{w}}_j}\\mathbf{h}^{\\tilde{\\alpha}_j}</span> . For some distinct execution paths, one may extract different witnesses. However, if there's any pair of such witnesses, one is able to find a non-trivial discrete-log relation for the vector  <span class="math">[g,\\mathbf{h}]</span> . Hence under the assumption stated in the theorem it is guaranteed that for every execution path  <span class="math">j\\in [\\ell]</span>  the same witness is extracted with overwhelming probability, i.e.,  <span class="math">(\\tilde{\\mathbf{w}},\\tilde{\\boldsymbol{\\alpha}}) = (\\tilde{\\mathbf{w}}_1,\\tilde{\\boldsymbol{\\alpha}}_1) = \\ldots = (\\tilde{\\mathbf{w}}_\\ell ,\\tilde{\\boldsymbol{\\alpha}}_\\ell)</span> .</p>

    <p class="text-gray-300">Now we show that each  <span class="math">i</span> -th slot of  <span class="math">\\tilde{\\mathbf{w}} = [\\tilde{\\mathbf{w}}_1, \\dots, \\tilde{\\mathbf{w}}_\\ell]</span>  corresponds to what is committed in  <span class="math">\\hat{C}_i</span> . First, we get a value in the form of  <span class="math">(\\Omega_j - \\Omega_j&#x27;) / (e_j - e_j&#x27;)</span>  from  <span class="math">j</span> -th execution path for  <span class="math">j \\in [\\ell]</span> . Thus we can extract  <span class="math">(\\tilde{\\beta}_i)_{i \\in [\\ell]}</span>  such that  <span class="math">(\\Omega_j - \\Omega_j&#x27;) / (e_j - e_j&#x27;) = \\sum_{i=1}^{\\ell} \\tilde{\\beta}_i x_j^{i-1}</span>  as these equations uniquely define a degree- <span class="math">\\ell</span>  polynomial  <span class="math">\\beta(X) = \\sum_{i=1}^{\\ell} \\tilde{\\beta}_i X^{i-1}</span> . From the second verification condition, we get in total  <span class="math">\\ell</span>  equations of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {i = 1} ^ {\\ell} \\hat {C} _ {i} ^ {x _ {j} ^ {i - 1}} = \\tilde {\\mathbf {G}} ^ {\\left(\\mathbf {z} _ {j} - \\mathbf {z} _ {j} ^ {\\prime}\\right) / \\left(e _ {j} - e _ {j} ^ {\\prime}\\right)} \\mathbf {H} ^ {\\left(\\boldsymbol {\\Omega} _ {j} - \\boldsymbol {\\Omega} _ {j} ^ {\\prime}\\right) / \\left(e _ {j} - e _ {j} ^ {\\prime}\\right)} = \\mathbf {G} ^ {\\sum_ {i = 1} ^ {\\ell} \\tilde {\\mathbf {w}} _ {i} x _ {j} ^ {i - 1}} \\mathbf {H} ^ {\\sum_ {i = 1} ^ {\\ell} \\tilde {\\boldsymbol {\\beta}} _ {i} x _ {j} ^ {i - 1}}. \\tag {2}</span></div>

    <p class="text-gray-300">for every  <span class="math">j \\in [\\ell]</span> . Let us rewrite  <span class="math">\\mathbf{G} = G^{s_1} \\ldots G^{s_d}</span> ,  <span class="math">\\mathbf{H} = G^{t_1} \\ldots G^{t_{d&#x27;&#x27;}}</span>  and  <span class="math">\\hat{C}_i = G^{u_i}</span>  using some arbitrary generator  <span class="math">G \\in \\mathbb{G}</span> . Then Eq. (2) can be rewritten as follows.</p>

    <div class="my-4 text-center"><span class="math-block">G ^ {\\sum_ {i = 1} ^ {\\ell} u _ {i} x _ {j} ^ {i - 1}} = G ^ {\\sum_ {i = 1} ^ {\\ell} \\left(s _ {1} \\tilde {\\mathbf {w}} _ {i, 1} + \\dots + s _ {d} \\tilde {\\mathbf {w}} _ {i, d} + t _ {1} \\tilde {\\boldsymbol {\\beta}} _ {i, 1} + \\dots + t _ {d ^ {\\prime \\prime}} \\tilde {\\boldsymbol {\\beta}} _ {i, d ^ {\\prime \\prime}}\\right) x _ {j} ^ {i - 1}}. \\tag {3}</span></div>

    <p class="text-gray-300">Protocol CompDLEq</p>

    <p class="text-gray-300">Let  <span class="math">\\pmb{g} = [\\pmb{g}_L, \\pmb{g}_R]</span> ,  <span class="math">\\mathbf{G} = [\\mathbf{G}_L, \\mathbf{G}_R]</span> ,  <span class="math">\\mathbf{z} = [\\mathbf{z}_L, \\mathbf{z}_R]</span>  where each sub-vector is of dimension  <span class="math">d/2</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  sends shifted commitments</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">L = \\boldsymbol {g} _ {R} ^ {\\mathbf {z} _ {L}}, \\quad R = \\boldsymbol {g} _ {L} ^ {\\mathbf {z} _ {R}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat {L} = \\mathbf {G} _ {R} ^ {\\mathbf {z} _ {L}}, \\quad \\hat {R} = \\mathbf {G} _ {L} ^ {\\mathbf {z} _ {R}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends random challenge  <span class="math">c\\in \\mathbb{Z}_q</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {z} ^ {\\prime} = \\mathbf {z} _ {L} + c \\mathbf {z} _ {R}</span></div>

    <p class="text-gray-300">and both parties compute</p>

    <div class="my-4 text-center"><span class="math-block">Y ^ {\\prime} = L Y ^ {c} R ^ {c ^ {2}}, \\quad \\hat {Y} ^ {\\prime} = \\hat {L} \\hat {Y} ^ {c} \\hat {R} ^ {c ^ {2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {g} ^ {\\prime} = \\boldsymbol {g} _ {L} ^ {c} \\odot \\boldsymbol {g} _ {R}, \\quad \\mathbf {G} ^ {\\prime} = \\mathbf {G} _ {L} ^ {c} \\odot \\mathbf {G} _ {R}.</span></div>

    <p class="text-gray-300">If  <span class="math">d &amp;gt; 2</span>  then they invoke CompDLEq for the next instance</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\boldsymbol {g} ^ {\\prime}, \\mathbf {G} ^ {\\prime}, d / 2\\right), \\left(Y ^ {\\prime}, \\hat {Y} ^ {\\prime}\\right), \\mathbf {z} ^ {\\prime}\\right).</span></div>

    <p class="text-gray-300">Otherwise,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathbf{z}&#x27;</span>  and  <span class="math">\\mathcal{V}</span>  checks that</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {g} ^ {\\prime \\mathbf {z} ^ {\\prime}} \\stackrel {*} {=} Y ^ {\\prime}, \\quad \\mathbf {G} ^ {\\prime \\mathbf {z} ^ {\\prime}} \\stackrel {*} {=} \\hat {Y} ^ {\\prime}.</span></div>

    <p class="text-gray-300">Fig. 3. Compressed  <span class="math">\\Sigma</span> -protocol for equality of vector discrete logs</p>

    <p class="text-gray-300">As  <span class="math">x_{j}</span>  for  <span class="math">j \\in [\\ell]</span>  are distinct with each other, we have  <span class="math">\\ell</span>  evaluations for the polynomial  <span class="math">u(X) = \\sum_{i=1}^{\\ell} u_{i} X^{i-1}</span> . Hence  <span class="math">u(X)</span>  can be uniquely determined as</p>

    <div class="my-4 text-center"><span class="math-block">u (X) = \\sum_ {i = 1} ^ {\\ell} \\left(s _ {1} \\tilde {\\mathbf {w}} _ {i, 1} + \\dots + s _ {d} \\tilde {\\mathbf {w}} _ {i, d} + t _ {1} \\tilde {\\boldsymbol {\\beta}} _ {i, 1} + \\dots + t _ {d ^ {\\prime \\prime}} \\tilde {\\boldsymbol {\\beta}} _ {i, d ^ {\\prime \\prime}}\\right) X ^ {i - 1} \\mod q. \\tag {4}</span></div>

    <p class="text-gray-300">Recalling that  <span class="math">\\hat{C}_i = G^{u_i}</span> , we get</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {C} _ {i} = G ^ {\\left(s _ {1} \\tilde {\\mathbf {w}} _ {i, 1} + \\dots + s _ {d} \\tilde {\\mathbf {w}} _ {i, d} + t _ {1} \\tilde {\\boldsymbol {\\beta}} _ {i, 1} + \\dots + t _ {d ^ {\\prime \\prime}} \\tilde {\\boldsymbol {\\beta}} _ {i, d ^ {\\prime \\prime}}\\right)} = \\mathbf {G} ^ {\\tilde {\\mathbf {w}} _ {i}} \\mathbf {H} ^ {\\tilde {\\boldsymbol {\\beta}} _ {i}}. \\tag {5}</span></div>

    <p class="text-gray-300">Hence we conclude that every  <span class="math">\\hat{C}_i</span>  indeed contains the witness  <span class="math">(\\tilde{\\mathbf{w}}_i,\\tilde{\\boldsymbol{\\beta}}_i)</span> .</p>

    <p class="text-gray-300">Special HVZK. Given challenge  <span class="math">x</span>  and  <span class="math">e</span> , the simulator samples random  <span class="math">\\mathbf{z} \\in \\mathbb{Z}_q^{\\ell d}</span> ,  <span class="math">\\boldsymbol{\\omega} \\in \\mathbb{Z}_q^{d&#x27;}</span> ,  <span class="math">\\boldsymbol{\\Omega} \\in \\mathbb{Z}_q^{d&#x27;&#x27;}</span> , and then the other messages can be perfectly simulated as follows.</p>

    <div class="my-4 text-center"><span class="math-block">A := \\boldsymbol {g} ^ {\\mathbf {z}} \\mathbf {h} ^ {\\boldsymbol {\\omega}} C ^ {- e}, \\quad \\hat {A} := \\tilde {\\mathbf {G}} ^ {\\mathbf {z}} \\mathbf {H} ^ {\\boldsymbol {\\Omega}} \\prod_ {i = 1} ^ {\\ell} (\\hat {C} _ {i} ^ {x ^ {i - 1}}) ^ {- e}</span></div>

    <h2 id="sec-23" class="text-2xl font-bold">4.2 CompAmComEq: Recursive compression</h2>

    <p class="text-gray-300">The major drawback of AmComEq is that its proof size is still linear in the vector dimension  <span class="math">\\ell d</span> , due to the response vector  <span class="math">\\mathbf{z} \\in \\mathbb{Z}_q^{\\ell d}</span> . Notice however that once the rest of transcript  <span class="math">x, A, \\hat{A}, e, \\boldsymbol{\\omega}, \\boldsymbol{\\Omega}</span>  is fixed, it should be sufficient to prove knowledge of  <span class="math">\\mathbf{z}</span>  such that  <span class="math">\\boldsymbol{g}^{\\mathbf{z}} = Y \\coloneqq AC^{e}\\mathbf{h}^{-\\boldsymbol{\\omega}}</span>  and  <span class="math">\\tilde{\\mathbf{G}}^{\\mathbf{z}} = \\hat{Y} \\coloneqq \\hat{A}\\prod_{i=1}^{\\ell}(\\hat{C}_{i}^{x^{i-1}})^{e}\\mathbf{H}^{-\\boldsymbol{\\Omega}}</span> , instead of sending  <span class="math">\\mathbf{z}</span> . This is where the compressed  <span class="math">\\Sigma</span> -protocol theory [AC20, ACF20, ACR20, ACK21] comes into play. That is, the last move of AmComEq can invoke another protocol CompDLEq of proof size  <span class="math">O(\\log(\\ell d))</span> , for the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {D L E q}} = \\left\\{\\left(\\left(\\boldsymbol {g}, \\tilde {\\mathbf {G}}, \\ell d\\right), (Y, \\hat {Y}), \\mathbf {z}\\right): Y = \\boldsymbol {g} ^ {\\mathbf {z}}, \\hat {Y} = \\tilde {\\mathbf {G}} ^ {\\mathbf {z}} \\right\\}. \\tag {6}</span></div>

    <p class="text-gray-300">The protocol CompDLEq for  <span class="math">\\mathcal{R}_{\\mathrm{DLEq}}</span>  is described in Fig. 3. From [AC20, Theorem 2] we immediately get the following result.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300"><span class="math">\\mathsf{CompDLEq}</span> is a <span class="math">(2\\mu+1)</span>-move protocol for the relation <span class="math">\\mathcal{R}_{\\mathsf{DLEq}}</span>, where <span class="math">\\mu=\\lceil\\log_{2}(\\ell d)\\rceil-1</span>. It is perfectly complete and unconditionally <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound, where <span class="math">k_{i}=3</span> for all <span class="math">i\\in[1,\\mu]</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">4\\lceil\\log_{2}(\\ell d)\\rceil-4</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">2</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\lceil\\log_{2}(\\ell d)\\rceil-1</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-25" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{CompAmComEq}</span> be a protocol identical to <span class="math">\\mathsf{AmComEq}</span>, except that its last move is replaced by <span class="math">\\mathsf{CompDLEq}</span>. <span class="math">\\mathsf{CompAmComEq}</span> is a <span class="math">(2\\mu+4)</span>-move protocol for the relation <span class="math">\\mathcal{R}_{\\mathsf{AmComEq}}</span>, where <span class="math">\\mu=\\lceil\\log_{2}(\\ell d)\\rceil-1</span>. It is perfectly complete and computationally <span class="math">(\\ell,2,k_{1},\\ldots,k_{\\mu})</span>-special sound if finding non-trivial discrete-log relation for the generators <span class="math">[\\boldsymbol{g},\\mathbf{h}]</span> is hard, where <span class="math">k_{i}=3</span> for all <span class="math">i\\in[1,\\mu]</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">4\\lceil\\log_{2}(\\ell d)\\rceil-2</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">2+d^{\\prime}+d^{\\prime\\prime}</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\lceil\\log_{2}(\\ell d)\\rceil+1</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h2 id="sec-26" class="text-2xl font-bold">5 Instantiation with PLONK</h2>

    <p class="text-gray-300">In this section we apply our ECLIPSE compiler to PLONK. We first go over the essential part of the PLONK protocol, using the language of AHP. More detailed preliminaries are provided in Appendix B.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">5.1 PLONK AHP</h3>

    <p class="text-gray-300">We consider an arithmetic circuit with fan-in two over <span class="math">\\mathbb{F}</span>, consisting of <span class="math">n</span> gates. The PLONK AHP essentially proves knowledge of left, right and output wire values for every gate <span class="math">i\\in[n]</span> in the circuit, such that they are also consistent with the constraints determined by the circuit topology. The per-gate constraints are specified by <em>selector vectors</em> <span class="math">\\mathbf{q}_{L},\\mathbf{q}_{R},\\mathbf{q}_{O},\\mathbf{q}_{M},\\mathbf{q}_{C}\\in\\mathbb{F}^{n}</span>. We call <span class="math">\\mathcal{C}=(n,m,\\mathbf{L},\\mathbf{R},\\mathbf{O},\\mathbf{q}_{L},\\mathbf{q}_{R},\\mathbf{q}_{O},\\mathbf{q}_{M},\\mathbf{q}_{C})</span> <em>constraint systems</em>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span> relies on a multiplicative subgroup <span class="math">\\mathbb{H}=\\left\\{\\zeta,\\zeta^{2},\\ldots,\\zeta^{n}\\right\\}\\subset\\mathbb{F}^{<em>}</span> generated by an <span class="math">n</span>th primitive root of unity <span class="math">\\zeta\\in\\mathbb{F}^{</em>}</span>. It follows that an associated vanishing polynomial <span class="math">v_{\\mathbb{H}}(X)=X^{n}-1</span> splits completely in <span class="math">\\mathbb{F}[X]</span>, i.e., <span class="math">X^{n}-1=\\prod_{i=1}^{n}(X-\\zeta^{i})</span>. Then we have the corresponding Lagrange basis <span class="math">L_{i}(X)\\in\\mathbb{F}_{&lt;n}[X]</span> for <span class="math">i\\in[n]</span> such that <span class="math">L_{i}(\\zeta^{i})=1</span> and <span class="math">L_{i}(\\zeta^{j})=0</span> for <span class="math">j\\neq i</span>.</p>

    <p class="text-gray-300">During the first round of <span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span> (Fig. 11), the prover sends the following WCPs encoding both statement and witness <span class="math">((\\mathsf{w}_{i})_{i\\in[l]},(\\mathsf{w}_{i})_{i\\in[l+1,3n]})</span>:</p>

    <p class="text-gray-300"><span class="math">f_{L}(X)=\\sum_{i\\in[n]}\\mathsf{w}_{i}L_{i}(X)\\qquad\\qquad f_{R}(X)=\\sum_{i\\in[n]}\\mathsf{w}_{n+i}L_{i}(X)\\qquad\\qquad f_{O}(X)=\\sum_{i\\in[n]}\\mathsf{w}_{2n+i}L_{i}(X)</span> (7)</p>

    <p class="text-gray-300">To achieve zero-knowledge these polynomials are masked by polynomials <span class="math">(\\rho_{L,1}X+\\rho_{L,2})v_{\\mathbb{H}}(X)</span>, <span class="math">(\\rho_{R,1}X+\\rho_{R,2})v_{\\mathbb{H}}(X)</span> and <span class="math">(\\rho_{O,1}X+\\rho_{O,2})v_{\\mathbb{H}}(X)</span> where each coefficient is randomly sampled by the AHP prover.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.2 CP-PLONK</h3>

    <p class="text-gray-300">Our goal is to turn <span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span> into CP-PLONK with our compiler. We first describe a commit-and-prove variant of relation <span class="math">\\mathcal{R}^{\\prime}_{\\mathsf{PLONK}}</span>. The auxiliary commitment scheme <span class="math">\\mathsf{AC}</span> is instantiated with vector Pedersen commitment and its key <span class="math">\\mathsf{ack}</span> consists of randomly chosen generators of <span class="math">\\mathbb{G}</span> with unknown relative discrete logarithms: <span class="math">\\mathbf{G}=(G_{1},\\ldots,G_{d})</span> and <span class="math">H</span>.</p>

    <p class="text-gray-300">We assume without loss of generality that every committed witness <span class="math">(\\mathsf{w}_{i})_{i\\in I_{\\mathsf{com}}}</span> is left input to gate <span class="math">i</span>. Then we use the following disjoint witness index sets: <span class="math">I_{\\mathsf{pub}}=[l],I_{\\mathsf{com}}=[l+1,l+\\ell d],I_{\\mathsf{mid}}=[l+\\ell d+1,n]</span>, assuming that <span class="math">\\mathsf{w}_{l+1},\\ldots,\\mathsf{w}_{l+\\ell d}</span> are <span class="math">\\ell d</span> witness values committed in advance. Moreover, every <span class="math">d</span> values are batched into a single commitment, that is, every vector compound of <span class="math">d</span> wires <span class="math">\\mathsf{w}_{i}</span>, for <span class="math">i\\in I_{k}=[l+1+d(k-1),l+dk]</span>, is committed to in the <span class="math">k</span>th auxiliary commitment <span class="math">\\hat{C}_{k}=\\mathbf{G}^{(\\mathsf{w}_{i})_{i\\in I_{k}}}H^{r_{k}}</span> for <span class="math">k\\in[\\ell]</span>. Then we have <span class="math">I_{\\mathsf{com}}=\\bigcup_{k\\in[\\ell]}I_{k}</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 11 (CP-PLONK indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathsf{CP-PLONK}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">((\\mathbb{F},n,m,l,\\mathbf{q}_{L},\\mathbf{q}_{R},\\mathbf{q}_{O},\\mathbf{q}_{M},\\mathbf{q}_{C},\\sigma,\\mathcal{T}_{\\mathcal{C}},I_{\\mathsf{com}},(I_{k})_{k\\in[\\ell]},\\mathsf{ack}),((\\mathsf{w}_{i})_{i\\in[l]},(\\hat{C}_{k})_{k\\in[\\ell]}),((\\mathsf{w}_{i})_{i\\in[l+1,3n]},(r_{k})_{k\\in[\\ell]}))</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">such that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ n ]: \\quad w _ {i} = w _ {\\sigma (i)}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ l ]: \\quad (\\mathbf {q} _ {L}) _ {i} \\cdot \\mathbf {w} _ {i} + (\\mathbf {q} _ {R}) _ {i} \\cdot \\mathbf {w} _ {n + i} + (\\mathbf {q} _ {O}) _ {i} \\cdot \\mathbf {w} _ {2 n + i} + (\\mathbf {q} _ {M}) _ {i} \\mathbf {w} _ {i} \\mathbf {w} _ {n + i} + (\\mathbf {q} _ {C}) _ {i} - \\mathbf {w} _ {i} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ l + 1, n ]: \\quad (\\mathbf {q} _ {L}) _ {i} \\cdot \\mathbf {w} _ {i} + (\\mathbf {q} _ {R}) _ {i} \\cdot \\mathbf {w} _ {n + i} + (\\mathbf {q} _ {O}) _ {i} \\cdot \\mathbf {w} _ {2 n + i} + (\\mathbf {q} _ {M}) _ {i} \\mathbf {w} _ {i} \\mathbf {w} _ {n + i} + (\\mathbf {q} _ {C}) _ {i} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in [ \\ell ]: \\quad \\hat {C} _ {k} = \\mathbf {G} ^ {\\left(\\mathbf {w} _ {i}\\right) _ {i \\in I _ {k}}} H ^ {r _ {k}}</span></div>

    <p class="text-gray-300">5.2.1 Applying our compiler We show that <span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span> as well as the polynomial commitment scheme meets the requirements of Theorem 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decomp takes <span class="math">\\mathsf{n}_{\\mathsf{w}} = 3</span> masked WCPs <span class="math">(f_{L}, f_{R}, f_{O})</span> and <span class="math">I_{\\mathsf{com}} \\subset [n]</span>, parses <span class="math">f_{L}</span> as <span class="math">\\sum_{i \\in [n]} \\mathsf{w}_{i} L_{i}(X) + (\\rho_{1} X + \\rho_{2}) v_{\\mathbb{H}}(X)</span>, and decompose them as follows.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f _ {L, \\operatorname {c o m}} (X) := \\sum_ {i \\in I _ {\\operatorname {c o m}}} \\mathbf {w} _ {i} L _ {i} (X) + \\left(\\lambda_ {\\operatorname {c o m}, 1} X + \\lambda_ {\\operatorname {c o m}, 2}\\right) v _ {\\mathbb {H}} (X) \\quad f _ {R, \\operatorname {c o m}} (X) := 0 \\quad f _ {O, \\operatorname {c o m}} (X) := 0</span></div>

    <div class="my-4 text-center"><span class="math-block">f _ {L, \\operatorname {m i d}} (X) := \\sum_ {i \\in [ n ] \\backslash I _ {\\operatorname {c o m}}} \\mathbf {w} _ {i} L _ {i} (X) + \\left(\\lambda_ {\\operatorname {m i d}, 1} X + \\lambda_ {\\operatorname {m i d}, 2}\\right) v _ {\\mathbb {H}} (X) \\quad f _ {R, \\operatorname {m i d}} (X) := f _ {R} (X) \\quad f _ {O, \\operatorname {m i d}} (X) := f _ {O} (X)</span></div>

    <p class="text-gray-300">where <span class="math">\\lambda_{\\mathrm{com},i}</span>'s are randomly chosen and <span class="math">\\lambda_{\\mathrm{mid},i} \\coloneqq \\rho_i - \\lambda_{\\mathrm{com},i}</span>. Clearly, the decomposition is additive, degree-preserving, and non-overlapping.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>WitExt takes WCPs <span class="math">(f_{L}, f_{R}, f_{O})</span> and uniquely extracts witness vectors for every <span class="math">i \\in [n]</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {w} _ {i} = f _ {L} \\left(\\zeta^ {i}\\right) \\quad \\mathsf {w} _ {n + i} = f _ {R} \\left(\\zeta^ {i}\\right) \\quad \\mathsf {w} _ {2 n + i} = f _ {O} \\left(\\zeta^ {i}\\right)</span></div>

    <p class="text-gray-300">As it's independently extracting witness values within disjoint index sets <span class="math">I_{L} = [n]</span>, <span class="math">I_{R} = [n + 1,2n]</span>, and <span class="math">I_{O} = [2n + 1,3n]</span>, respectively, we have that <span class="math">f_{L}</span>, <span class="math">f_{R}</span> and <span class="math">f_{O}</span> are disjoint (see Definition 7).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As PLONK retains zero-knowledge by masking WCPs, but without hiding commitment<span class="math">^9</span>, we use derandomized version of <span class="math">\\mathsf{PC}_{\\mathsf{KZG}}.\\mathsf{Com}_{\\mathsf{ck}}</span> (see Sect. 2.4.1) that takes polynomial <span class="math">f \\in \\mathbb{F}_{\\leq D}[X]</span> and outputs <span class="math">[f(\\chi)]_1</span>. Hence the polynomial commitment key is <span class="math">\\mathsf{ck} = \\mathsf{pp} = (g, g^{\\chi}, \\ldots, g^{\\chi^{D}})</span>. Clearly, this is an additively homomorphic commitment scheme. Its binding and extractability were formally shown in Appendix B-D of [CHM+20]. As mentioned in [GWC19] and from how WitExt works, the knowledge soundness of PLONK holds only by enforcing degree bound to the maximum degree <span class="math">D</span> for committed polynomials so the plain KZG construction should suffice for compiling <span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span>.</li>

    </ul>

    <p class="text-gray-300">We now define a suitable commitment-linking protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> in Fig. 4. Since WCPs are disjoint it is enough to provide linking w.r.t. a polynomial <span class="math">f_{L}</span>. The main idea is to (1) prove consistency between <span class="math">f_{L,\\mathsf{com}}</span> and auxiliary commitments <span class="math">\\hat{C}_k</span> with the <span class="math">\\mathsf{AmComEq}</span> protocol from previous section, and (2) force the prover to show <span class="math">f_{\\mathsf{mid}}</span> vanishes at all points in <span class="math">\\mathbb{H}_{\\mathsf{com}} = \\{\\zeta^i\\}_{i\\in I_{\\mathsf{com}}}</span>. The latter is in particular crucial for WitExt to successfully output a witness vector consistent with auxiliary commitments, even after taking the sum of <span class="math">f_{L,\\mathsf{com}}</span> and <span class="math">f_{L,\\mathsf{mid}}</span>. This step only incurs constant overhead in the evaluation proof thanks to the batch evaluation technique proposed in [BDFG20]. On the other hand, the consistency between <span class="math">f_{\\mathsf{com}}</span> and <span class="math">\\ell</span> vector Pedersen commitments <span class="math">\\hat{C}_k = \\mathbf{G}^{(\\mathsf{w}_i)_{i\\in I_k}}H^{r_k}</span> for <span class="math">k\\in [\\ell ]</span> are handled by CompAmComEq protocol (see Sect. 4).</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Assuming extractability of <span class="math">\\mathsf{PC}_{\\mathsf{KZG}}</span> and argument of knowledge of CompAmComEq, the protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> (Fig. 4) is an argument of knowledge. Assuming zero knowledge of Fiat-Shamir-transformed CompAmComEq, the protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> is zero-knowledge in the SRS model.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Knowledge soundness First, the extractor <span class="math">\\mathcal{E}_{\\mathrm{1nk}}</span> obtains <span class="math">f_{L,\\mathrm{mid}}(X)\\in \\mathbb{F}_{&amp;lt; D}[X]</span> such that <span class="math">[f_{L,\\mathrm{mid}}(\\chi)]_1 = C_{L,\\mathrm{mid}}</span> and <span class="math">f_{L,\\mathrm{mid}}(\\zeta^i) = 0</span> for <span class="math">i\\in I_{\\mathrm{com}}</span>, by internally invoking an extractor <span class="math">\\mathcal{E}_{\\mathrm{KZG}}</span>, which succeeds with overwhelming probability as long as a malicious prover <span class="math">\\mathcal{P}_{\\mathrm{1nk}}</span> convinces the verifier.</p>

    <p class="text-gray-300">Second, <span class="math">\\mathcal{E}_{\\mathrm{1nk}}</span> invokes an extractor <span class="math">\\mathcal{E}_{\\mathrm{ComEq}}</span> for the CompAmComEq protocol, which outputs <span class="math">(\\mathsf{w}_i)_{i\\in I_{\\mathrm{com}}}</span> and <span class="math">(r_k)_{k\\in [\\ell ]}</span> such that <span class="math">\\hat{C}_k = \\mathsf{AC.Com}_{\\mathsf{ack}}((\\mathsf{w}_i)_{i\\in I_k};r_k)</span> for <span class="math">k\\in [\\ell ]</span>, and <span class="math">C_{L,\\mathrm{com}} = [\\sum_{i\\in I_{\\mathrm{com}}}\\mathsf{w}_iL_i(\\chi) + (\\lambda_{\\mathrm{com},1}\\chi + \\lambda_{\\mathrm{com},2})v_{\\mathbb{H}}(\\chi)]_1</span>. So we obtain <span class="math">f_{L,\\mathrm{com}}(X) = \\sum_{i\\in I_{\\mathrm{com}}}\\mathsf{w}_iL_i(X) + (\\lambda_{\\mathrm{com},1}X + \\lambda_{\\mathrm{com},2})v_{\\mathbb{H}}(X)</span>.</p>

    <p class="text-gray-300">9 More formally, if the underlying AHP is <span class="math">(\\mathsf{b} + 1,\\mathsf{C})</span>-zero knowledge, where <span class="math">\\mathsf{b}</span> is the maximum number of queries made by the verifier to polynomials, one can retain ZK of the resulting SNARK by compiling AHP via PCS with somewhat hiding security, a weaker notion of hiding [CFF+20]. Because the deterministic KZG is already somewhat hiding and every WCP in <span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span> is queried once, it suffices to add <span class="math">v_{\\mathbb{H}}</span> multiplied by a masking polynomial of degree 1 to tolerate 2 openings (i.e., one evaluation and one commitment).</p>

    <p class="text-gray-300">Indexing  <span class="math">\\mathcal{I}_{\\mathrm{isk}}^{\\mathrm{ex}}(I_{\\mathrm{com}},(I_k)_{k\\in [l]})</span>  precomputes  <span class="math">[v_{\\mathbb{H}_{\\mathrm{com}}}(\\chi)]_2</span>  such that  <span class="math">v_{\\mathbb{H}_{\\mathrm{com}}}(X) = \\prod_{a\\in \\mathbb{H}_{\\mathrm{com}}} (X - a)</span>  and  <span class="math">\\mathbb{H}_{\\mathrm{com}} = \\{\\zeta^i : i \\in I_{\\mathrm{com}}\\} \\subset \\mathbb{H}</span> , obtains generators  <span class="math">g_i := [L_i(\\chi)]_1</span>  for  <span class="math">i \\in I_{\\mathrm{com}}</span> ,  <span class="math">g := (g_i)_{i \\in I_{\\mathrm{com}}}</span> ,  <span class="math">h_1 = [\\chi v_{\\mathbb{H}}(\\chi)]_1</span> ,  <span class="math">h_2 = [v_{\\mathbb{H}}(\\chi)]_1</span> ,  <span class="math">\\mathbf{G}</span>  and  <span class="math">H</span>  by accessing  <span class="math">\\mathbf{trs}</span> . It outputs  <span class="math">(\\mathrm{ipk}_{\\mathrm{isk}}, \\mathrm{ivk}_{\\mathrm{isk}})</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ipk}_{\\mathsf{isk}} = (\\mathsf{pp},v_{\\mathbb{H}_{\\mathsf{com}}}(X),\\pmb {g},h_1,h_2,\\mathbf{G},H)</span>  and  <span class="math">\\mathsf{ivk}_{\\mathsf{isk}} = ([v_{\\mathbb{H}_{\\mathsf{com}}}(\\chi)]_2,\\pmb {g},h_1,h_2,\\mathbf{G},H).</span></p>

    <p class="text-gray-300">Input.  <span class="math">\\mathcal{P}_{\\mathrm{isk}}</span>  (resp.  <span class="math">V_{\\mathrm{isk}}</span> ) receives  <span class="math">\\mathsf{ipk}_{\\mathrm{isk}}</span>  (resp.  <span class="math">\\mathsf{ivk}_{\\mathrm{isk}}</span> ). The statement  <span class="math">((\\hat{C}_k)_{k\\in [l]},(C_{L,\\mathrm{com}},C_{L,\\mathrm{mid}}))</span>  is a common input. The  <span class="math">\\mathcal{P}_{\\mathrm{isk}}</span>  has as input witness  <span class="math">(f_{L,\\mathrm{com}}(X),f_{L,\\mathrm{mid}}(X),(r_k)_{k\\in [l]})</span>  such that  <span class="math">\\hat{C}_k = \\mathbf{G}^{(\\mathsf{w}_i)_{i\\in I_k}}H^{r_k}</span> ,  <span class="math">C_{L,\\mathrm{com}} = [f_{L,\\mathrm{com}}(\\chi)]_1</span> ,  <span class="math">C_{L,\\mathrm{mid}} = [f_{L,\\mathrm{mid}}(\\chi)]_1</span> ,  <span class="math">f_{L,\\mathrm{com}}(X) = \\sum_{i\\in I_{\\mathrm{com}}}\\mathsf{w}_iL_i(X) + (\\lambda_{\\mathrm{com},1}X + \\lambda_{\\mathrm{com},2})v_{\\mathbb{H}}(X)</span> , and  <span class="math">f_{L,\\mathrm{mid}}(X) = \\sum_{i\\in [n]\\setminus I_{\\mathrm{com}}}\\mathsf{w}_iL_i(X) + (\\lambda_{\\mathrm{mid},1}X + \\lambda_{\\mathrm{mid},2})v_{\\mathbb{H}}(X)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a proof  <span class="math">\\pi_{\\mathrm{ComEq}}</span>  of the following statement.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\text {C o m p A m C o m E q}: \\mathsf {P K} \\left\\{\\left(\\left(\\mathsf {w} _ {i}\\right) _ {i \\in I _ {\\mathrm {c o m}}}, \\left(r _ {k}\\right) _ {k \\in [ l ]}, \\lambda_ {\\mathrm {c o m}, 1}, \\lambda_ {\\mathrm {c o m}, 2}\\right): \\begin{array}{c} \\hat {C} _ {k} = \\mathbf {G} ^ {\\left(\\mathsf {w} _ {i}\\right) _ {i \\in I _ {k}}} H ^ {r _ {k}} / _ {\\mathrm {i}} \\\\ C _ {L, \\mathrm {c o m}} = \\boldsymbol {g} ^ {\\left(\\mathsf {w} _ {i}\\right) _ {i \\in I _ {\\mathrm {c o m}}}} h _ {1} ^ {\\lambda_ {\\mathrm {c o m}}, 1} h _ {2} ^ {\\lambda_ {\\mathrm {c o m}}, 2} \\end{array} \\right\\}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute evaluation proof  <span class="math">W(X) = \\frac{f_{L,\\mathrm{mid}}(X)}{v_{\\mathbb{H}_{\\mathrm{com}}}(X)}</span>  and  <span class="math">\\varPi:=[W(\\chi)]_1</span> . Output  <span class="math">\\pi_{\\mathrm{isk}} = (\\varPi, \\pi_{\\mathrm{ComEq}})</span> .</li>

    </ul>

    <p class="text-gray-300">Verify. Given  <span class="math">\\pi_{\\mathrm{isk}}</span> , verify  <span class="math">\\pi_{\\mathrm{ComEq}}</span>  and check that  <span class="math">f_{L,\\mathrm{mid}}</span>  vanishes on  <span class="math">\\mathbb{H}_{\\mathrm{com}}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(C _ {L, \\text {m i d}}, h\\right) \\stackrel {*} {=} e (\\Pi , [ v _ {\\mathbb {H} _ {\\text {c o m}}} (\\chi) ] _ {2}).</span></div>

    <p class="text-gray-300">Fig. 4. Commitment-linking protocol for PLONK</p>

    <p class="text-gray-300">Let  <span class="math">f_{L}(X) \\coloneqq f_{L,\\mathrm{com}}(X) + f_{L,\\mathrm{mid}}(X)</span> . Due to the 0-evaluation proof output by  <span class="math">\\mathcal{P}_{\\mathrm{isk}}</span> , it holds that  <span class="math">f_{L}(X)</span>  and  <span class="math">f_{L,\\mathrm{com}}(X)</span>  agree on  <span class="math">\\mathbb{H}_{\\mathrm{com}}</span> , i.e.,  <span class="math">f_{L}(\\zeta^{i}) = f_{L,\\mathrm{com}}(\\zeta^{i}) + f_{L,\\mathrm{mid}}(\\zeta^{i}) = f_{L,\\mathrm{com}}(\\zeta^{i}) = \\mathsf{w}_{i}</span>  for each  <span class="math">i \\in I_{\\mathrm{com}}</span>  (recall that the term  <span class="math">(\\lambda_{\\mathrm{com},1}X + \\lambda_{\\mathrm{com},2})v_{\\mathbb{H}}(X)</span>  vanishes anyway). Hence if WitExt is invoked on  <span class="math">f_{L}</span>  it does extract witness  <span class="math">(\\mathsf{w}_i)_{i \\in I_{\\mathrm{com}}}</span>  consistent with  <span class="math">(\\hat{C}_k)_{k \\in [\\ell]}</span> , which is guaranteed by  <span class="math">\\mathcal{E}_{\\mathrm{ComEq}}</span> .</p>

    <p class="text-gray-300">Zero-knowledge To simulate  <span class="math">\\pi_{\\mathrm{ComEq}}</span>  we simply invoke the zero-knowledge simulator for CompAmComEq made non-interactive with Fiat-Shamir [FS87]. To simulate the evaluation proof  <span class="math">\\varPi</span>  the simulator uses the trapdoor  <span class="math">\\chi</span>  used for generating the commitment key to compute  <span class="math">\\varPi:=C_{L,\\mathrm{mid}}^{1/v_{\\mathbb{H}_{\\mathrm{com}}}(\\chi)}</span> .</p>

    <p class="text-gray-300">In this section we apply our compiler to Marlin. As in the previous section, we first identify WCPs and how it encodes the witness vector in AHP. More detailed preliminaries are provided in Appendix C.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notations For a finite field  <span class="math">\\mathbb{F}</span>  and a subset  <span class="math">\\mathbb{S} \\subseteq \\mathbb{F}</span> , we denote by  <span class="math">v_{\\mathbb{S}}(X)</span>  the vanishing polynomial of  <span class="math">\\mathbb{S}</span>  that is the unique non-zero monic polynomial of degree at most  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  that is zero everywhere on  </span>\\mathbb{S}<span class="math"> . We denote by  </span>\\mathbb{F}^{\\mathbb{S}}<span class="math">  the set of vectors indexed by elements in a finite set  </span>\\mathbb{S}<span class="math"> . For a function  </span>f: \\mathbb{S} \\to \\mathbb{F}<span class="math"> , we denote by  </span>\\hat{f}<span class="math"> , the univariate polynomial over  </span>\\mathbb{F}<span class="math">  with degree less than  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  that agrees with  </span>f<span class="math"> , that is,  </span>\\hat{f}(a) = f(a)<span class="math">  for all  </span>a \\in \\mathbb{S}<span class="math"> . In particular, the polynomial  </span>\\hat{f}$  can be expressed as a linear combination</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\hat {f} (X) = \\sum_ {a \\in \\mathbb {S}} f (a) \\cdot L _ {a, \\mathbb {S}} (X)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\{L_{a,\\mathbb{S}}(X)\\}_{a\\in \\mathbb{S}}</span>  are the Lagrange basis polynomials of degree less than  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  such that  </span>L_{a,\\mathbb{S}}(a) = 1<span class="math">  and  </span>L_{a,\\mathbb{S}}(a^{\\prime}) = 1<span class="math">  for  </span>a^\\prime \\in \\mathbb{S}\\setminus \\{a\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraint systems Unlike PLONK, Marlin's AHP is for R1CS (Rank-1 constraint satisfiability) indexed relation defined by the set of tuples  <span class="math">(\\mathrm{i},\\mathrm{x},\\mathrm{w}) = ((\\mathbb{F},\\mathbb{H},\\mathbb{K},A,B,C),x,w)</span> , where  <span class="math">\\mathbb{F}</span>  is a finite field,  <span class="math">\\mathbb{H}</span>  and  <span class="math">\\mathbb{K}</span>  are subsets of  <span class="math">\\mathbb{F}</span> , such that  $n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>m =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>A,B,C<span class="math">  are  </span>\\mathbb{H} \\times \\mathbb{H}<span class="math">  matrices over  </span>\\mathbb{F}<span class="math">  with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\max \\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> , and  </span>z := (x,w)<span class="math">  is a vector in  </span>\\mathbb{F}^{\\mathbb{H}}<span class="math">  such that  </span>Az \\circ Bz = Cz$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Following  <span class="math">\\left[\\mathrm{CHM}^{+}20\\right]</span> , we assume efficiently computable bijections  <span class="math">\\phi_{\\mathbb{H}}: \\mathbb{H} \\to [n]</span>  and  <span class="math">\\phi_{\\mathbb{K}}: \\mathbb{K} \\to [m]</span> , and denote the first  <span class="math">l</span>  elements in  <span class="math">\\mathbb{H}</span>  and the remaining elements, via sets  <span class="math">\\mathbb{H}[\\leq l] := \\{a \\in \\mathbb{H}: 1 \\leq \\phi_{\\mathbb{H}}(a) \\leq l\\}</span>  and  <span class="math">\\mathbb{H}[&amp;gt;l] := \\{a \\in \\mathbb{H}: l &amp;lt; \\phi_{\\mathbb{H}}(a) \\leq n\\}</span>  respectively. We then denote the first part of the vector  <span class="math">z</span>  as the public component  <span class="math">x \\in \\mathbb{F}^{\\mathbb{H}[\\leq l]}</span>  and the second part as witness component  <span class="math">w \\in \\mathbb{F}^{\\mathbb{H}[&amp;gt;l]}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AHP}_{\\mathsf{Marlin}}</span> (Fig. 12), the prover <span class="math">\\mathsf{P}</span> receives as input the instance <span class="math">x\\in\\mathbb{F}^{\\mathbb{H}[\\leq l]}</span>, a witness <span class="math">w\\in\\mathbb{F}^{\\mathbb{H}[&gt;l]}</span>. The verifier <span class="math">\\mathsf{V}</span> receives as input <span class="math">x</span>, and obtains oracle access to the nine polynomials output at the end of the preprocessing phase.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{x}(X)\\in\\mathbb{F}_{&lt;l}[X]</span> and <span class="math">\\hat{w}(X)\\in\\mathbb{F}_{\\leq n-l}[X]</span> be polynomials that agree with the instance <span class="math">x</span> on <span class="math">\\mathbb{H}[\\leq l]</span>, and with the shifted witness on <span class="math">\\mathbb{H}[&gt;l]</span> respectively. Concretely, these polynomials are defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\hat{x}(X)</span> <span class="math">:=\\sum_{a\\in\\mathbb{H}[\\leq l]}x(a)\\cdot L_{a,\\mathbb{H}[\\leq l]}(X)</span> <span class="math">\\hat{w}(X)</span> <span class="math">:=\\sum_{a\\in\\mathbb{H}[&gt;l]}\\bigg{(}\\frac{w(a)-\\hat{x}(a)}{v_{\\mathbb{H}[\\leq l]}(a)}\\bigg{)}\\cdot L_{a,\\mathbb{H}[&gt;l]}(X)+\\rho\\cdot v_{\\mathbb{H}[&gt;l]}(X)</span></p>

    <p class="text-gray-300">where the second term of <span class="math">\\hat{w}</span> is added to retain zero-knowledge when the number of evaluation queries to <span class="math">\\hat{w}</span> is <span class="math">1</span> (which is the case in <span class="math">\\mathsf{Marlin}</span> AHP) and <span class="math">\\rho</span> is sampled uniformly at random from <span class="math">\\mathbb{F}</span>. Let <span class="math">z\\coloneqq(x,w)</span> denote the full assignment. Then the polynomial <span class="math">\\hat{z}(X):=\\hat{w}(X)\\cdot v_{\\mathbb{H}[\\leq l]}(X)+\\hat{x}(X)</span> agrees with <span class="math">z</span> on <span class="math">\\mathbb{H}</span>.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">6.2 CP-Marlin</h3>

    <p class="text-gray-300">We now turn <span class="math">\\mathsf{AHP}_{\\mathsf{Marlin}}</span> into CP-Marlin by applying our compiler. We begin by giving a commit-and-prove relation for R1CS.</p>

    <p class="text-gray-300">Relation for CP-Marlin. We define an extended relation to accommodate consistency of partial witness wire values and commitment. For convenience we define the following subsets: <span class="math">\\mathbb{H}_{\\mathsf{pub}}:=\\mathbb{H}[\\leq l],\\mathbb{H}_{\\mathsf{com}}:=\\mathbb{H}[&gt;l,\\leq l+d\\ell],\\mathbb{H}_{\\mathsf{mid}}:=\\mathbb{H}[&gt;l+d\\ell]</span>, assuming that <span class="math">w(a)</span> for <span class="math">a\\in\\mathbb{H}_{\\mathsf{com}}</span> are <span class="math">d\\ell</span> values committed to in advance. Moreover, every <span class="math">d</span> values are batched into a single commitment, that is, every vector compound of <span class="math">d</span> wires <span class="math">w(a)</span>, for <span class="math">a\\in\\mathbb{H}_{\\mathsf{com},k}=\\mathbb{H}[&gt;l+d(k-1),\\leq l+dk]</span>, is committed to in the <span class="math">k</span>th auxiliary commitment <span class="math">\\hat{C}_{k}=\\mathbf{G}^{(w(a))_{a\\in\\mathbb{H}_{\\mathsf{com},k}}}H^{r_{k}}</span> for <span class="math">k\\in[\\ell]</span>. Then we have <span class="math">\\mathbb{H}_{\\mathsf{com}}=\\bigcup_{k\\in[\\ell]}\\mathbb{H}_{\\mathsf{com},k}</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 12 (CP-Marlin indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathsf{CP}\\text{-}\\mathsf{Marlin}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{i},\\mathsf{x},\\mathsf{w})=\\big{(}(\\mathbb{F},\\mathbb{H},\\mathbb{K},n,m,l,\\ell,d,A,B,C),(x,(\\hat{C}_{k})_{k\\in[\\ell]}),(w,(r_{k})_{k\\in[\\ell]})\\big{)}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">\\mathbb{H}</span> and <span class="math">\\mathbb{K}</span> are subsets of <span class="math">\\mathbb{F}</span>, such that $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>A,B,C<span class="math"> are </span>\\mathbb{H}\\times\\mathbb{H}<span class="math"> matrices over </span>\\mathbb{F}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\max\\left\\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}<span class="math">, and </span>z:=(x,w)<span class="math"> is a vector in </span>\\mathbb{F}^{\\mathbb{H}}$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">Az\\circ Bz=Cz\\text{ and }\\forall k\\in[\\ell],\\hat{C}_{k}=\\mathsf{AC.Commit}_{\\mathsf{ack}}((w(a))_{a\\in\\mathbb{H}_{\\mathsf{com},k}};r_{k})</span></p>

    <p class="text-gray-300">Applying our compiler. We now show that <span class="math">\\mathsf{AHP}_{\\mathsf{Marlin}}</span> and the polynomial commitment scheme <span class="math">\\mathsf{PC}_{\\mathsf{KZG}}</span> <em>[x10]</em> meet the requirements of Theorem 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Unique witness extraction: <span class="math">\\mathsf{WitExt}</span> takes <span class="math">\\hat{w}(X)</span>, evaluates <span class="math">\\hat{w}(X)</span> on every <span class="math">a\\in\\mathbb{H}[&gt;l]</span>, multiplies the results by <span class="math">v_{\\mathbb{H}[\\leq l]}(a)</span>, and add <span class="math">\\hat{x}(a)</span> to constructs a vector of values <span class="math">w\\in\\mathbb{F}^{\\mathbb{H}[&gt;l]}</span>. It is easy to see that <span class="math">\\mathsf{WitExt}</span> satisfies unique extraction (Definition 8).</li>

      <li>Decomposable WCP: <span class="math">\\mathsf{Decomp}</span> takes <span class="math">\\hat{w}(X)</span> and <span class="math">\\mathbb{H}_{\\mathsf{com}}</span>, and outputs <span class="math">\\hat{w}_{\\mathsf{com}}</span> and <span class="math">\\hat{w}_{\\mathsf{mid}}</span> of degree at most <span class="math">n-l</span> as follows:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\hat{w}_{\\mathsf{com}}(X)</span> <span class="math">:=\\sum_{a\\in\\mathbb{H}_{\\mathsf{com}}}\\bigg{(}\\frac{w(a)-\\hat{x}(a)}{v_{\\mathbb{H}[\\leq l]}(a)}\\bigg{)}\\cdot L_{a,\\mathbb{H}[&gt;l]}(X)+\\lambda_{\\mathsf{com}}\\cdot v_{\\mathbb{H}[&gt;l]}(X)</span> <span class="math">\\hat{w}_{\\mathsf{mid}}(X)</span> <span class="math">:=\\sum_{a\\in\\mathbb{H}_{\\mathsf{mid}}}\\bigg{(}\\frac{w(a)-\\hat{x}(a)}{v_{\\mathbb{H}[\\leq l]}(a)}\\bigg{)}\\cdot L_{a,\\mathbb{H}[&gt;l]}(X)+\\lambda_{\\mathsf{mid}}\\cdot v_{\\mathbb{H}[&gt;l]}(X)</span></p>

    <p class="text-gray-300">where <span class="math">\\lambda_{\\mathsf{com}}</span> was sampled from <span class="math">\\mathbb{F}</span> uniformly at random and <span class="math">\\lambda_{\\mathsf{mid}}:=\\rho-\\lambda_{\\mathsf{com}}</span>. Clearly, the decomposition is additive, degree-preserving and non-overlapping.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Marlin}</span> compiles <span class="math">\\mathsf{AHP}_{\\mathsf{Marlin}}</span> using the plain <span class="math">\\mathsf{KZG}</span> polynomial commitment except that degrees of hiding polynomials are minimized. That is, to commit to the WCP <span class="math">\\mathsf{PC}_{\\mathsf{KZG.Com}_{\\mathsf{ck}}}</span> takes <span class="math">\\hat{w}(X)</span> and <span class="math">\\omega(X):=\\omega_{0}+\\omega_{1}X</span> as input and outputs <span class="math">[\\hat{w}(\\chi)+\\gamma\\omega(\\chi)]_{1}</span>, where <span class="math">\\omega_{0},\\omega_{1}\\in\\mathbb{F}</span> are randomly sampled masking coefficients. As mentioned in §9.2 of <em>[CHM^{+}20]</em> and as it’s clear from how <span class="math">\\mathsf{WitExt}</span> works, the knowledge soundness of <span class="math">\\mathsf{Marlin}</span> holds only by enforcing degree bound to the maximum degree <span class="math">D</span> for committed polynomials. In order to construct our commitment-linking protocol for <span class="math">\\mathsf{Marlin}</span>, we modify how hiding is achieved. Specifically, we now mask the two decomposed WCPs</li>

    </ul>

    <p class="text-gray-300">independently as follows: commitment to <span class="math">\\hat{w}_{\\mathsf{com}}(X)</span> is masked by a random polynomial <span class="math">\\omega_{\\mathsf{com}}(X):=\\omega_{\\mathsf{com},0}+\\omega_{\\mathsf{com},1}X</span> and <span class="math">\\hat{w}_{\\mathsf{mid}}(X)</span> is masked by a random polynomial <span class="math">\\omega_{\\mathsf{mid}}(X)</span> that vanishes on <span class="math">\\mathbb{H}_{\\mathsf{com}}</span>; <span class="math">\\omega_{\\mathsf{mid}}(X):=(\\omega_{\\mathsf{mid},0}+\\omega_{\\mathsf{mid},1}X)v_{\\mathbb{H}_{\\mathsf{com}}}(X)</span>. Note that, for <span class="math">\\hat{w}_{\\mathsf{mid}}</span>, we do not apply Marlin’s optimization of minimising the degree.</p>

    <p class="text-gray-300">Following PLONK and Lunar, one may alternatively compile <span class="math">\\mathsf{AHP}_{\\mathsf{Marlin}}</span> with the deterministic KZG by increasing the degree of masking factor to 1 (i.e., <span class="math">\\rho_{1}X+\\rho_{2}</span>) to hide one evaluation and the commitment. In this way, decomposition of WCPs as well as <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> can be done as in CP-PLONK and the number of SRS elements does not grow due to the CP extension.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Fig. 5 we present a suitable commitment-linking protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span>. The key idea is to have the prover commit to an encoding of the assignment in subsets <span class="math">\\mathbb{H}_{\\mathsf{com}}</span> and <span class="math">\\mathbb{H}_{\\mathsf{mid}}</span> into separate polynomials, and then show that <span class="math">\\hat{w}_{\\mathsf{mid}}(X)</span> vanishes at <span class="math">\\mathbb{H}_{\\mathsf{com}}</span>, together with the consistency of <span class="math">\\hat{w}_{\\mathsf{com}}(X)</span> with vector Pedersen commitments <span class="math">\\hat{C}_{k}=\\mathbf{G}^{(w(a))_{a\\in\\mathbb{H}_{\\mathsf{com},k}}}H^{r_{k}}</span> for <span class="math">k\\in[\\ell]</span> via <span class="math">\\mathsf{CompAmComEq}</span> protocol (see Sect. 4). We assume that <span class="math">\\mathbb{H}_{\\mathsf{com}}=\\bigcup_{k\\in[\\ell]}\\mathbb{H}_{\\mathsf{com},k}</span>, <span class="math">\\mathbb{H}_{\\mathsf{com},k}</span>’s are disjoint with each other and of same cardinality $d=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}_{\\mathsf{com},k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Assuming extractability of <span class="math">\\mathsf{PC}_{\\mathsf{KZG}}</span> and argument of knowledge of <span class="math">\\mathsf{CompAmComEq}</span>, the protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> (Fig. 5) is an argument of knowledge. Assuming zero knowledge of Fiat–Shamir-transformed <span class="math">\\mathsf{CompAmComEq}</span>, the protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> is zero-knowledge in the SRS model.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Knowledge soundness First, the extractor <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> obtains <span class="math">\\hat{w}_{\\mathsf{mid}}(X)</span> and <span class="math">\\omega_{\\mathsf{mid}}(X)</span> such that <span class="math">C_{\\mathsf{mid}}=\\mathsf{PC}_{\\mathsf{KZG}}.\\mathsf{Com}_{\\mathsf{ck}}(\\hat{w}_{\\mathsf{mid}};\\omega_{\\mathsf{mid}})</span> and <span class="math">\\hat{w}_{\\mathsf{mid}}(a)=0</span> for <span class="math">a\\in\\mathbb{H}_{\\mathsf{com}}</span>, by internally invoking an extractor <span class="math">\\mathcal{E}_{\\mathsf{KZG}}</span>, which succeeds with overwhelming probability as long as a malicious prover <span class="math">\\mathcal{P}_{\\mathsf{1nk}}</span> convinces the verifier.</p>

    <p class="text-gray-300">Second, <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> invokes an extractor <span class="math">\\mathcal{E}_{\\mathsf{ComEq}}</span> for the <span class="math">\\mathsf{CompAmComEq}</span> protocol, which outputs <span class="math">(w(a))_{a\\in\\mathbb{H}_{\\mathsf{com}}}</span>, <span class="math">(r_{k})_{k\\in[\\ell]}</span>, <span class="math">\\lambda_{\\mathsf{com}}</span>, <span class="math">\\omega_{\\mathsf{com},0}</span> and <span class="math">\\omega_{\\mathsf{com},1}</span> such that <span class="math">\\hat{C}_{k}=\\mathsf{AC.Commit}_{\\mathsf{ack}}((w(a))_{a\\in\\mathbb{H}_{\\mathsf{com}}};r_{k})</span> for <span class="math">k\\in[\\ell]</span>, and</p>

    <p class="text-gray-300"><span class="math">\\bar{C}_{\\mathsf{com}}=[\\sum_{a\\in\\mathbb{H}_{\\mathsf{com}}}(L_{a,\\mathbb{H}[&gt;l]}(\\chi)/v_{\\mathbb{H}[\\leq l]}(a))\\cdot w(a)+\\lambda_{\\mathsf{com}}\\cdot v_{\\mathbb{H}[&gt;l]}(\\chi)+\\gamma\\cdot(\\omega_{\\mathsf{com},0}+\\omega_{\\mathsf{com},1}\\chi)]_{1}.</span></p>

    <p class="text-gray-300">Since <span class="math">\\bar{C}_{\\mathsf{com}}=C_{\\mathsf{com}}\\cdot[\\sum_{a\\in\\mathbb{H}_{\\mathsf{com}}}(L_{a,\\mathbb{H}[&gt;l]}(\\chi)/v_{\\mathbb{H}[\\leq l]}(a))\\hat{x}(a)]_{1}</span>, it also holds that</p>

    <p class="text-gray-300"><span class="math">C_{\\mathsf{com}}=[\\sum_{a\\in\\mathbb{H}_{\\mathsf{com}}}(L_{a,\\mathbb{H}[&gt;l]}(\\chi)/v_{\\mathbb{H}[\\leq l]}(a))\\cdot(w(a)-\\hat{x}(a))+\\lambda_{\\mathsf{com}}\\cdot v_{\\mathbb{H}[&gt;l]}(\\chi)+\\gamma\\cdot(\\omega_{\\mathsf{com},0}+\\omega_{\\mathsf{com},1}\\chi)]_{1}.</span></p>

    <p class="text-gray-300">So we obtain <span class="math">\\hat{w}_{\\mathsf{com}}(X)=\\sum_{a\\in\\mathbb{H}_{\\mathsf{com}}}\\left(\\frac{w(a)-\\hat{x}(a)}{v_{\\mathbb{H}[\\leq l]}(a)}\\right)\\cdot L_{a,\\mathbb{H}[&gt;l]}(X)+\\lambda_{\\mathsf{com}}\\cdot v_{\\mathbb{H}[&gt;l]}(X)</span> and <span class="math">\\omega_{\\mathsf{com}}(X)=\\omega_{\\mathsf{com},0}+\\omega_{\\mathsf{com},1}X</span> such that <span class="math">C_{\\mathsf{com}}=\\mathsf{PC}_{\\mathsf{KZG}}.\\mathsf{Com}_{\\mathsf{ck}}(\\hat{w}_{\\mathsf{com}};\\omega_{\\mathsf{com}})</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{w}(X):=\\hat{w}_{\\mathsf{com}}(X)+\\hat{w}_{\\mathsf{mid}}(X)</span>. Due to the <span class="math">0</span>-evaluation proof output by <span class="math">\\mathcal{P}_{\\mathsf{1nk}}</span>, it holds that <span class="math">\\hat{w}(X)</span> and <span class="math">\\hat{w}_{\\mathsf{com}}(X)</span> agree on <span class="math">\\mathbb{H}_{\\mathsf{com}}</span>, i.e., <span class="math">\\hat{w}(a)=\\hat{w}_{\\mathsf{com}}(a)</span> for each <span class="math">a\\in\\mathbb{H}_{\\mathsf{com}}</span> (recall that the term <span class="math">\\lambda_{\\mathsf{com}}\\cdot v_{\\mathbb{H}<a href="X">&gt;l</a>}</span> vanishes anyway). Hence if <span class="math">\\mathsf{WitExt}</span> is invoked on <span class="math">\\hat{w}(X)</span> it does extract witness <span class="math">(w(a))_{a\\in\\mathbb{H}_{\\mathsf{com}}}</span> consistent with <span class="math">(\\hat{C}_{k})_{k\\in[\\ell]}</span>, which is guaranteed by <span class="math">\\mathcal{E}_{\\mathsf{ComEq}}</span>.</p>

    <p class="text-gray-300">Zero-knowledge To simulate <span class="math">\\pi_{\\mathsf{ComEq}}</span> we simply invoke the zero-knowledge simulator for <span class="math">\\mathsf{CompAmComEq}</span> made non-interactive with Fiat–Shamir <em>[x10]</em>. To simulate the evaluation proof <span class="math">\\Pi</span> the simulator uses the trapdoor <span class="math">\\chi</span> used for generating the commitment key to compute <span class="math">\\Pi:=C_{\\mathsf{mid}}^{1/v_{\\mathbb{H}_{\\mathsf{com}}}(\\chi)}</span>.</p>

    <h2 id="sec-38" class="text-2xl font-bold">7 Instantiation with Sonic</h2>

    <p class="text-gray-300">While the proving time of Marlin is an entire order of magnitude better than Sonic, and Marlin’s verifier requires fewer pairings and fewer exponentiations, for applications that use batched verifications, Sonic remains the state-of-the-art. Applications like cryptocurrency transactions take advantage of batching where each verifier is not just given a single proof but many proofs of the same statement. This optimization works in the <em>helped</em> scenario, where an untrusted third party can aggregate such proofs in a single batch for faster verification.</p>

    <p class="text-gray-300">Sonic is a zk-SNARK system in the universal SRS setting that can be used to prove any statement represented as an arithmetic circuit. While Sonic was orginally not presented in the language of AHPs, it was later recharacterized as a polynomial IOP by Bünz, Fisch and Szepieniec, which is essentially equivalent to the AHP framework <em>[x3, §1.2]</em>. To frame the underlying information theoretic protocol of Sonic as AHP, we can consider bivariate, Laurent polynomial generalization mentioned in Sec. 2.3.</p>

    <p class="text-gray-300">The construction in Sonic relies on a special construction of polynomial commitments (a modifiation of KZG) that forces the prover to commit to a Laurent polynomial with no constant term. Since knowledge soundness of Sonic was proven in the <em>algebraic group model (AGM)</em> <em>[x11]</em>, the security proof for our <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> also relies on AGM.</p>

    <p class="text-gray-300">Indexing  <span class="math">\\mathcal{I}_{\\mathrm{link}}^{\\mathrm{pr}}(I_{\\mathrm{som}}, (I_k)_{k \\in [\\ell]})</span>  precomputes  <span class="math">[\\upsilon_{\\mathbb{H}_{\\mathrm{som}}}(\\chi)]_2</span>  such that  <span class="math">\\upsilon_{\\mathbb{H}_{\\mathrm{som}}}(X) = \\prod_{a \\in \\mathbb{H}_{\\mathrm{som}}} (X - a)</span> , obtains generators  <span class="math">g_a := [L_{a, \\mathbb{H}[&amp;gt;l]}(\\chi) / \\upsilon_{\\mathbb{H}[\\leq l]}(a)]_1</span>  for  <span class="math">a \\in \\mathbb{H}_{\\mathrm{som}}</span> ,  <span class="math">\\pmb{g} := (g_a)_{a \\in \\mathbb{H}_{\\mathrm{som}}}</span> ,  <span class="math">h_1 := [\\upsilon_{\\mathbb{H}[&amp;gt;l]}(\\chi)]_1</span> ,  <span class="math">h_2 := [\\gamma]_1</span> ,  <span class="math">h_3 := [\\gamma \\chi]_1</span> ,  <span class="math">\\mathbf{G}</span>  and  <span class="math">H</span>  by accessing srs. It outputs  <span class="math">(\\mathrm{ipk}_{\\mathrm{link}}, \\mathrm{ivk}_{\\mathrm{link}})</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ipk}_{\\mathsf{link}} = (\\mathsf{pp},\\upsilon_{\\mathbb{H}_{\\mathsf{som}}}(X),\\pmb {g},h_1,h_2,h_3,\\mathbf{G},H)</span>  and  <span class="math">\\mathsf{ivk}_{\\mathsf{link}} = ([\\upsilon_{\\mathbb{H}_{\\mathsf{som}}}(\\chi)]_2,\\pmb {g},h_1,h_2,h_3,\\mathbf{G},H).</span></p>

    <p class="text-gray-300">Input.  <span class="math">\\mathcal{P}_{\\mathrm{link}}</span>  (resp.  <span class="math">\\mathcal{V}_{\\mathrm{link}}</span> ) receives  <span class="math">\\mathsf{ipk}_{\\mathsf{link}}</span>  (resp.  <span class="math">\\mathsf{ivk}_{\\mathsf{link}}</span> ). The statement  <span class="math">((\\hat{C}_k)_{k\\in [\\ell]},(C_{\\mathrm{som}},C_{\\mathrm{mid}}))</span>  is a common input. The  <span class="math">\\mathcal{P}_{\\mathrm{link}}</span>  has as input witness  <span class="math">(\\hat{w}_{\\mathrm{som}}(X),\\hat{w}_{\\mathrm{mid}}(X),(r_k)_{k\\in [\\ell]})</span>  such that  <span class="math">\\hat{C}_k = \\mathbf{G}^{(w(a))_a\\in \\mathbb{H}_{\\mathrm{som}},\\lambda}H^{r_k}</span> ,  <span class="math">C_{\\mathrm{som}} = [\\hat{w}_{\\mathrm{som}}(\\chi) + \\gamma \\omega_{\\mathrm{som}}(\\chi)]_1</span> ,  <span class="math">C_{\\mathrm{mid}} = [\\hat{w}_{\\mathrm{mid}}(\\chi) + \\gamma \\omega_{\\mathrm{mid}}(\\chi)]_1</span> , and</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {w} _ {\\mathrm {s o m}} (X) = \\sum_ {a \\in \\mathbb {H} _ {\\mathrm {s o m}}} \\left(\\frac {w (a) - \\hat {x} (a)}{v _ {\\mathbb {H} [ \\leq l ]} (a)}\\right) \\cdot L _ {a, \\mathbb {H} [ &amp;gt; l ]} (X) + \\lambda_ {\\mathrm {s o m}} \\cdot v _ {\\mathbb {H} [ &amp;gt; l ]} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat {w} _ {\\mathrm {m i d}} (X) = \\sum_ {a \\in \\mathbb {H} _ {\\mathrm {m i d}}} \\left(\\frac {w (a) - \\hat {x} (a)}{v _ {\\mathbb {H} [ \\leq l ]} (a)}\\right) \\cdot L _ {a, \\mathbb {H} [ &amp;gt; l ]} (X) + \\lambda_ {\\mathrm {m i d}} \\cdot v _ {\\mathbb {H} [ &amp;gt; l ]} (X)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a proof  <span class="math">\\pi_{\\mathrm{ComEq}}</span>  of the following statement where  <span class="math">\\hat{C}_{\\mathrm{som}} := C_{\\mathrm{som}} \\cdot g^{(x(a))_a \\in \\mathbb{H}_{\\mathrm{som}}}</span> .</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {P K} \\left\\{ \\begin{array}{c} ((w (a)) _ {a \\in \\mathbb {H} _ {\\mathrm {s o m}}}, (r _ {k}) _ {k \\in [ \\ell ]}, \\quad \\hat {C} _ {k} = \\mathbf {G} ^ {(w (a)) _ {a \\in \\mathbb {H} _ {\\mathrm {s o m}}, k}} H ^ {r _ {k}} \\\\ \\lambda_ {\\mathrm {s o m}}, \\omega_ {\\mathrm {s o m}, 0}, \\omega_ {\\mathrm {s o m}, 1}) \\quad \\wedge \\hat {C} _ {\\mathrm {s o m}} = \\boldsymbol {g} ^ {(w (a)) _ {a} \\in \\mathbb {H} _ {\\mathrm {s o m}}} h _ {1} ^ {\\lambda_ {\\mathrm {s o m}}} h _ {2} ^ {\\omega_ {\\mathrm {s o m}, 0}} h _ {3} ^ {\\omega_ {\\mathrm {s o m}, 1}} \\end{array} \\right\\}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute evaluation proof  <span class="math">\\varPi=[W_1+\\gamma W_2(\\chi)]_1</span> , where  <span class="math">W_{1}(X) = \\frac{\\omega_{\\mathrm{mid}}(X)}{\\upsilon_{\\mathbb{H}_{\\mathrm{som}}}(X)}</span> ,  <span class="math">W_{2}(X) = \\frac{\\upsilon_{\\mathrm{mid}}(X)}{\\upsilon_{\\mathbb{H}_{\\mathrm{som}}}(X)}</span> . Set  <span class="math">\\pi_{\\mathrm{link}} = (\\varPi, \\pi_{\\mathrm{ComEq}})</span> . Note that since  <span class="math">\\omega_{\\mathrm{mid}}(X)</span>  vanishes on  <span class="math">\\mathbb{H}_{\\mathrm{som}}</span> , is divisible by  <span class="math">\\upsilon_{\\mathbb{H}_{\\mathrm{som}}}</span> , and therefore  <span class="math">W_{2}</span>  is a polynomial.</li>

    </ul>

    <p class="text-gray-300">Verify. Given  <span class="math">\\pi_{\\mathrm{link}}</span> , verify  <span class="math">\\pi_{\\mathrm{ComEq}}</span> , and check that  <span class="math">\\hat{w}_{\\mathrm{mid}}</span>  vanishes on  <span class="math">\\mathbb{H}_{\\mathrm{som}}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(C _ {\\text {m i d}}, h\\right) \\stackrel {?} {=} e \\left(\\Pi , \\left[ v _ {\\mathbb {H} _ {\\text {s o m}}} (\\chi) \\right] _ {2}\\right).</span></div>

    <p class="text-gray-300">Fig. 5. Commitment-linking protocol for Marlin</p>

    <p class="text-gray-300">We first describe the system of constraints used by Sonic. The vectors  <span class="math">\\mathbf{a},\\mathbf{b},\\mathbf{c}</span>  of length  <span class="math">n</span> , represent left inputs, right inputs and outputs respectively of the multiplication gates.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} \\odot \\mathbf {b} = \\mathbf {c}</span></div>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{u}_q, \\mathbf{v}_q, \\mathbf{w}_q \\in \\mathbb{F}^n</span>  be fixed vectors for the  <span class="math">q</span> th linear constraint with instance values  <span class="math">k_q \\in \\mathbb{F}</span> . There are  <span class="math">Q</span>  linear constraints of the form,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} \\cdot \\mathbf {u} _ {q} + \\mathbf {b} \\cdot \\mathbf {v} _ {q} + \\mathbf {c} \\cdot \\mathbf {w} _ {q} = k _ {q}</span></div>

    <p class="text-gray-300">The  <span class="math">n</span>  multiplication constraints are compressed into one equation by introducing the formal indeterminate  <span class="math">Y</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 1} ^ {n} \\left(a _ {i} b _ {i} - c _ {i}\\right) Y ^ {i} = 0 \\quad \\sum_ {i = 1} ^ {n} \\left(a _ {i} b _ {i} - c _ {i}\\right) Y ^ {- i} = 0</span></div>

    <p class="text-gray-300">The  <span class="math">Q</span>  linear constraints are compressed,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {q = 1} ^ {Q} (\\mathbf {a} \\cdot \\mathbf {u} _ {q} + \\mathbf {b} \\cdot \\mathbf {v} _ {q} + \\mathbf {c} \\cdot \\mathbf {w} _ {q} - k _ {q}) Y ^ {q + n} = 0</span></div>

    <p class="text-gray-300">Define polynomials</p>

    <div class="my-4 text-center"><span class="math-block">u _ {i} (Y) = \\sum_ {q = 1} ^ {Q} Y ^ {q + n} u _ {q, i} \\quad v _ {i} (Y) = \\sum_ {q = 1} ^ {Q} Y ^ {q + n} v _ {q, i}</span></div>

    <div class="my-4 text-center"><span class="math-block">w _ {i} (Y) = - Y ^ {i} - Y ^ {- i} + \\sum_ {q = 1} ^ {Q} Y ^ {q + n} w _ {q, i} \\quad k (Y) = \\sum_ {q = 1} ^ {Q} Y ^ {q + n} k _ {q}</span></div>

    <p class="text-gray-300">Combining the multiplicative and linear constraints,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}\\cdot\\mathbf{u}(Y)+\\mathbf{b}\\cdot\\mathbf{v}(Y)+\\mathbf{c}\\cdot\\mathbf{w}(Y)+\\sum_{i=1}^{n}a_{i}b_{i}(Y^{i}+Y^{-i})-k(Y)=0</span> (8)</p>

    <p class="text-gray-300">The above holds at all points if the constraint system is satisfied. If the constraint system is not satisfied, the above will fail to hold with high probability for a large enough field. Now, the left hand side of the above is embedded into the constant term of a polynomial <span class="math">t(X,Y)</span> in another indeterminate <span class="math">X</span>. A polynomial <span class="math">r(X,Y)</span> is designed such that <span class="math">r(X,Y)=r(XY,1)</span></p>

    <p class="text-gray-300"><span class="math">r(X,Y)=\\sum_{i=1}^{n}(a_{i}X^{i}Y^{i}+b_{i}X^{-i}Y^{-i}+c_{i}X^{-n-i}Y^{-n-i})</span> (9) <span class="math">s(X,Y)=\\sum_{i=1}^{n}\\left(u_{i}(Y)X^{-i}+v_{i}(Y)X^{i}+w_{i}(Y)X^{i+n}\\right)</span> (10) <span class="math">t(X,Y)=r(X,1)(r(X,Y)+s(X,Y))-k(Y)</span> (11)</p>

    <p class="text-gray-300">Note that the coefficient of <span class="math">X^{0}</span> in <span class="math">t(X,Y)</span> coincides with the left hand side of 8. We are now set out to define the Sonic indexed relation.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 13 (Sonic indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\text{\\text{Sonic}}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">((\\mathbb{F},n,Q,(\\mathbf{u}_{q})_{q\\in[Q]},(\\mathbf{v}_{q})_{q\\in[Q]},(\\mathbf{w}_{q})_{q\\in[Q]}),(k_{q})_{q\\in[Q]},(\\mathbf{a},\\mathbf{b},\\mathbf{c}))</span></p>

    <p class="text-gray-300">such that</p>

    <p class="text-gray-300"><span class="math">\\forall q\\in[Q]:\\quad</span> <span class="math">\\mathbf{a}\\cdot\\mathbf{u}_{q}+\\mathbf{b}\\cdot\\mathbf{v}_{q}+\\mathbf{c}\\cdot\\mathbf{w}_{q}=k_{q}</span> <span class="math">\\mathbf{a}\\odot\\mathbf{b}=\\mathbf{c}</span></p>

    <p class="text-gray-300">As mentioned above checking 8 is equivalent to checking whether an instance is in <span class="math">\\mathcal{R}_{\\text{\\text{Sonic}}}</span>. To verify 8 Sonic implicitly relies on Lemma 3. In Fig. 6 we also present the underlying AHP of Sonic for <span class="math">\\mathcal{R}_{\\text{\\text{Sonic}}}</span>, where the verifier <span class="math">\\mathsf{V}</span> essentially checks the second point of the following lemma.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">The following two properties hold.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">r(X,Y),s(X,Y)</span> and <span class="math">t(X,Y)</span> be given as above. If 8 holds, then the constant term of <span class="math">t(X,Y)</span> w.r.t. <span class="math">X</span> is zero.</li>

      <li>Let <span class="math">s(X,Y)</span> be given as above and suppose that <span class="math">r(X,Y)</span> is a Laurent polynomial of the form <span class="math">r(X,Y)=\\sum_{-D}^{n}r_{i}X^{i}Y^{i}</span>. If the constant term w.r.t. <span class="math">X</span> of</li>

    </ol>

    <p class="text-gray-300"><span class="math">r(X,1)(r(X,Y)+s(X,Y))-k(Y)</span></p>

    <p class="text-gray-300">is zero, then 8 holds for <span class="math">\\mathbf{a}=(r_{i})_{i=1}^{n}</span>, <span class="math">\\mathbf{b}=(r_{-i})_{i=1}^{n}</span> and <span class="math">\\mathbf{c}=(r_{-i-n})_{i=1}^{n}</span>.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For the first statement, we notice that it follows directly from the fact the constant term w.r.t. <span class="math">X</span> of <span class="math">t(X,Y)</span> is exactly the left hand side of 8. For the second statement, let <span class="math">r(X,Y)=\\sum_{-D}^{n}r_{i}X^{i}Y^{i}</span> with <span class="math">r_{i}\\in\\mathbb{F}</span>. Now, we notice that</p>

    <p class="text-gray-300"><span class="math">r(X,1)(r(X,Y)+s(X,Y))-k(Y)=</span> <span class="math">\\left(r_{0}+\\sum_{i=1}^{n}(r_{i}X^{i}+r_{-i}X^{-i}+r_{-i-n}X^{-i-n})+\\sum_{i=2n+1}^{D}r_{-i}X^{-i}\\right)</span> <span class="math">\\cdot\\left(r_{0}+\\sum_{i=1}^{n}\\left(r_{i}(XY)^{i}+r_{-i}(XY)^{-i}+r_{-i-n}(XY)^{-i-n}\\right)\\right.</span> <span class="math">+\\sum_{i=2n+1}^{D}r_{-i}(XY)^{-i}</span> <span class="math">\\left.+\\sum_{i=1}^{n}\\left(u_{i}(Y)X^{-i}+v_{i}(Y)X^{i}+w_{i}(Y)X^{i+n}\\right)\\right)-k(Y).</span></p>

    <p class="text-gray-300">Offline phase. The indexer I receives as input  <span class="math">\\mathbb{F} \\in \\mathcal{F}</span>  and  <span class="math">\\mathrm{i} = (\\mathbb{F}, n, Q, (\\mathbf{u}_q)_{q \\in [Q]}, (\\mathbf{v}_q)_{q \\in [Q]}, (\\mathbf{w}_q)_{q \\in [Q]})</span> , and computes the polynomial oracle  <span class="math">s(X, Y)</span>  as described in the text.</p>

    <p class="text-gray-300">Input.  <span class="math">\\mathsf{P}</span>  receives  <span class="math">(\\mathbb{F},\\mathrm{i},(k_q)_{q\\in [Q]},(\\mathbf{a},\\mathbf{b},\\mathbf{c}))</span>  and  <span class="math">\\mathsf{V}</span>  receives  <span class="math">(\\mathbb{F},(k_q)_{q\\in [Q]})</span>  and oracle access to the polynomials output by  <span class="math">\\mathsf{I}(\\mathbb{F},\\mathrm{i})</span> .</p>

    <p class="text-gray-300">Online phase: first round.  <span class="math">\\mathsf{P}</span>  computes  <span class="math">r(X,Y)</span>  and  <span class="math">t(X,Y)</span>  as described in Eq. (11). Mask  <span class="math">r(X,Y)</span>  as  <span class="math">r(X,Y) := r(X,Y) + \\sum_{i=1}^{n} c_{n+i} X^{-2n-i} Y^{-2n-i}</span>  with random  <span class="math">c_{n+i} \\in \\mathbb{F}</span>  and send an oracle polynomial  <span class="math">r(X,1)</span>  to  <span class="math">\\mathsf{V}</span> .</p>

    <p class="text-gray-300">Online phase: second round. Upon receiving challenges  <span class="math">y \\in \\mathbb{F}</span>  from the V, P sends an oracle polynomial  <span class="math">t(X,y)</span>  to V.</p>

    <p class="text-gray-300">Query phase. V queries online oracles  <span class="math">r(X,1)</span>  and  <span class="math">t(X,y)</span>  with a random query point  <span class="math">z \\in \\mathbb{F}</span> . Moreover, it makes additional queries to  <span class="math">r(X,1)</span>  with  <span class="math">yz</span>  and to  <span class="math">s(X,Y)</span>  with  <span class="math">(z,y)</span> .</p>

    <p class="text-gray-300">Decision phase. V first computes an instance polynomial  <span class="math">k(Y)</span>  as described in the text. Then V checks that</p>

    <div class="my-4 text-center"><span class="math-block">t (z, y) \\stackrel {+} {=} r (z, 1) (r (y z, 1) + s (z, y)) - k (y).</span></div>

    <p class="text-gray-300">Fig. 6. AHP for  <span class="math">\\mathcal{R}_{\\mathrm{Sonic}}</span></p>

    <p class="text-gray-300">From the above we see that the constant term w.r.t.  <span class="math">X</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">r _ {0} ^ {2} + \\sum_ {i = 1} ^ {n} r _ {i} r _ {- i} (Y ^ {i} + Y ^ {- i}) + \\sum_ {i = 1} ^ {n} r _ {i} u _ {i} (Y) + \\sum_ {i = 1} ^ {n} r _ {- i} v _ {i} (Y) + \\sum_ {i = 1} ^ {n} r _ {- i - n} w _ {i} (Y) - k (Y),</span></div>

    <p class="text-gray-300">which can only be zero if  <span class="math">r_0 = 0</span> . It therefore follows as wanted that if the constant term w.r.t.  <span class="math">X</span>  of  <span class="math">r(X,1)(r(X,Y) + s(X,Y)) - k(Y)</span>  is zero, then Eq. (8) holds for  <span class="math">\\mathbf{a} = (r_i)_{i=1}^n</span> ,  <span class="math">\\mathbf{b} = (r_{-i})_{i=1}^n</span>  and  <span class="math">\\mathbf{c} = (r_{-i-n})_{i=1}^n</span> .</p>

    <h2 id="sec-46" class="text-2xl font-bold">7.2 CP-Sonic</h2>

    <p class="text-gray-300">Our goal is to turn  <span class="math">\\mathsf{AHP}_{\\mathsf{Sonic}}</span>  into CP-Sonic with our compiler. We first describe a commit-and-prove variant of relation  <span class="math">\\mathcal{R}_{\\mathsf{Sonic}}</span> . We assume without loss of generality that every committed witness is left input to gate  <span class="math">i</span> , i.e.,  <span class="math">(a_{i})_{i\\in I_{\\mathrm{com}}}</span>  is the committed witness whereas  <span class="math">((a_{i})_{i\\notin I_{\\mathrm{com}}}, \\mathbf{b}, \\mathbf{c})</span>  is the non-committed part. Then we use the following disjoint witness index sets:  <span class="math">I_{\\mathrm{com}} = [n - \\ell d + 1, n]</span> ,  <span class="math">I_{\\mathrm{mid}} = [1, n - \\ell d]</span> , assuming that  <span class="math">a_{n - \\ell d + 1}, \\ldots, a_{n}</span>  are  <span class="math">\\ell d</span>  witness values committed in advance. Moreover, suppose every vector compound of  <span class="math">d</span>  values  <span class="math">(a_{i})_{i\\in I_{k}}</span> , where  <span class="math">I_{k} = [n - dk + 1, n - d(k - 1)]</span> , is committed into  <span class="math">k</span> th auxiliary commitment  <span class="math">\\hat{C}_k</span>  for  <span class="math">k\\in [\\ell]</span> . Then we have  <span class="math">I_{\\mathrm{com}} = \\bigcup_{k\\in [\\ell]}I_k</span> .</p>

    <p class="text-gray-300"><strong>Definition 14 (CP-Sonic indexed relation).</strong> The indexed relation  <span class="math">\\mathcal{R}_{\\mathsf{CP - Sonic}}</span>  is the set of all triples</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\mathbb {F}, n, Q, \\left(\\mathbf {u} _ {q}\\right) _ {q \\in [ Q ]}, \\left(\\mathbf {v} _ {q}\\right) _ {q \\in [ Q ]}, \\left(\\mathbf {w} _ {q}\\right) _ {q \\in [ Q ]}, I _ {\\text {c o m}}, \\left(I _ {k}\\right) _ {k \\in [ \\ell ]}, \\text {a c k}\\right), \\left(\\left(k _ {q}\\right) _ {q \\in [ Q ]}, \\left(C _ {k}\\right) _ {k \\in [ \\ell ]}\\right), \\left(\\mathbf {a}, \\mathbf {b}, \\mathbf {c}, \\left(r _ {k}\\right) _ {k \\in [ \\ell ]}\\right)\\right)</span></div>

    <p class="text-gray-300">such that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall q \\in [ Q ]: \\mathbf {a} \\cdot \\mathbf {u} _ {q} + \\mathbf {b} \\cdot \\mathbf {v} _ {q} + \\mathbf {c} \\cdot \\mathbf {w} _ {q} = k _ {q}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} \\odot \\mathbf {b} = \\mathbf {c}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in [ \\ell ]: \\hat {C} _ {k} = \\mathsf {A C}. \\mathsf {C o m} _ {\\mathsf {a c k}} ((a _ {i}) _ {i \\in I _ {k}}; r _ {k})</span></div>

    <p class="text-gray-300"><strong>7.2.1 Applying our compiler</strong> We show that  <span class="math">\\mathsf{AHP}_{\\mathsf{Sonic}}</span>  as well as the polynomial commitment scheme meets the requirements of Theorem 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decomp takes  <span class="math">\\mathsf{n}_{\\mathsf{w}} = 1</span>  (masked) witness-carrying polynomial  <span class="math">r(X) \\coloneqq r(X,1)</span>  and  <span class="math">I_{\\mathsf{com}} \\subset [n]</span> , parses  <span class="math">r(X)</span>  as  <span class="math">\\sum_{i=1}^{n}(a_iX^i + b_iX^{-i} + c_iX^{-n-i}) + \\sum_{i=1}^{4}c_{n+i}X^{-2n-i}</span> , and decompose them as follows.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">r _ {\\mathsf {c o m}} (X) := \\sum_ {i \\in I _ {\\mathsf {c o m}}} a _ {i} X ^ {i} + \\sum_ {i = 1} ^ {4} \\rho_ {n + i} X ^ {- 2 n - i}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {\\mathsf {m i d}} (X) := \\sum_ {i \\in I _ {\\mathsf {m i d}}} a _ {i} X ^ {i} + \\sum_ {i = 1} ^ {n} (b _ {i} X ^ {- i} + c _ {i} X ^ {- n - i}) + \\sum_ {i = 1} ^ {4} \\lambda_ {n + i} X ^ {- 2 n - i}</span></div>

    <p class="text-gray-300">where  <span class="math">\\rho_{n + i}</span>  was randomly chosen and  <span class="math">\\lambda_{n + i} \\coloneqq c_{n + i} - \\rho_{n + i}</span>  for  <span class="math">i = 1,2,3,4</span> . Clearly, the decomposition is additive, degree-preserving (in the sense that separate Laurent polynomials do not exceed the prescribed degree range), and non-overlapping.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>WitExt takes a witness-carrying polynomial <span class="math">r(X)=\\sum_{-D}^{n}r_{i}X^{i}</span> and uniquely extracts witness vectors <span class="math">(\\mathbf{a},\\mathbf{b},\\mathbf{c})</span> such that <span class="math">a_{i}:=r_{i}</span>, <span class="math">b_{i}:=r_{-i}</span> and <span class="math">c_{i}:=r_{-n-i}</span> for every <span class="math">i\\in[n]</span>.</li>

      <li>Sonic uses a variant of the KZG scheme optimized for Laurent polynomials with a 0 constant term. Concretely, PC_{Sonic}.Com takes as input</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{ck}=([\\chi^{-D}]_{1},\\ldots,[\\chi^{D}]_{1},[\\alpha\\chi^{-D}]_{1},\\ldots,[\\alpha\\chi^{-1}]_{1},[\\alpha\\chi]_{1},\\ldots,[\\alpha\\chi^{D}]_{1},[\\chi^{-D}]_{2},\\ldots,[\\chi^{D}]_{2},[\\alpha\\chi^{-D}]_{2},\\ldots,[\\alpha\\chi^{D}]_{2}),</span></p>

    <p class="text-gray-300">a polynomial <span class="math">f(X)\\in\\mathbb{F}[X,X^{-1}]</span>, and the degree bound <span class="math">\\mathsf{d}\\leq D</span>, and then outputs <span class="math">[\\alpha\\chi^{D-\\mathsf{d}}f(\\chi)]_{1}</span>. Clearly, this is an additively homomorphic commitment scheme. In the AGM its evaluation binding and extractability were formally proved under the <span class="math">2D</span>-DLOG assumption (see Theorem 6.3 of <em>[x10]</em>). The plain binding for a fixed degree bound can be also shown just as in the KZG scheme. Unlike PLONK, Sonic must enforce a precise degree bound <span class="math">n</span> on the witness-carrying polynomial <span class="math">r(X)</span> to achieve knowledge soundness. Our commit-and-prove variant should thus enforce the same bound on both <span class="math">r_{\\mathsf{com}}(X)</span> and <span class="math">r_{\\mathsf{mid}}(X)</span>. Finally, Sonic retains zero-knowledge by masking witness-carrying polynomial, instead of hiding commitment. Hence commitment randomness is empty for all commitments. To sum up, the compiled protocol involves the following commitments to decomposed witness-carrying polynomials.</p>

    <p class="text-gray-300"><span class="math">C_{\\mathsf{com}}</span> <span class="math">=[\\alpha\\chi^{D-n}r_{\\mathsf{com}}(\\chi)]_{1}</span> <span class="math">C_{\\mathsf{mid}}</span> <span class="math">=[\\alpha\\chi^{D-n}r_{\\mathsf{mid}}(\\chi)]_{1}</span></p>

    <p class="text-gray-300">We now present a suitable commitment-linking protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> in Fig. 7. The high-level idea is to (1) prove consistency between <span class="math">r_{\\mathsf{com}}(X)</span> and auxiliary commitments <span class="math">\\hat{C}_{k}</span> with the AmComEq protocol, and (2) force the prover to show <span class="math">r_{\\mathsf{mid}}(X)</span> has degree bounded by <span class="math">n-\\ell d</span>. The latter is in particular crucial for WitExt to successfully output a witness vector consistent with auxiliary commitments, even after taking the sum of <span class="math">r_{\\mathsf{com}}(X)</span> and <span class="math">r_{\\mathsf{mid}}(X)</span>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Assuming hardness of the <span class="math">2D</span>-DLOG problem, extractability of <span class="math">\\mathsf{PC}_{\\mathsf{Sonic}}</span> and argument of knowledge of CompAmComEq, the protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> (Fig. 7) is an argument of knowledge in the algebraic group model <em>[x5]</em>. Assuming zero knowledge of Fiat–Shamir-transformed CompAmComEq, the protocol <span class="math">\\mathsf{CP}_{\\mathsf{1nk}}</span> is zero-knowledge in the SRS model.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Knowledge soundness First, the extractor <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> obtains <span class="math">r(X)\\in\\mathbb{F}[X,X^{-1}]</span> of degree at most <span class="math">n</span> such that <span class="math">[\\alpha\\chi^{D-n}r(\\chi)]_{1}=C_{\\mathsf{com}}\\cdot C_{\\mathsf{mid}}</span> and <span class="math">r(z)=v</span>, by internally invoking an extractor for <span class="math">\\mathsf{PC}_{\\mathsf{Sonic}}</span>, which succeeds with overwhelming probability as long as a malicious prover <span class="math">\\mathcal{P}_{\\mathsf{1nk}}^{*}</span> convinces the verifier.</p>

    <p class="text-gray-300">Second, <span class="math">\\mathcal{E}_{\\mathsf{1nk}}</span> invokes an extractor <span class="math">\\mathcal{E}_{\\mathsf{ComEq}}</span> for the CompAmComEq protocol, which outputs <span class="math">(a_{i})_{i\\in I_{\\mathsf{com}}}</span> and <span class="math">(r_{k})_{k\\in[\\ell]}</span> such that <span class="math">\\hat{C}_{k}=\\mathsf{AC}.{\\mathsf{Com}}_{\\mathsf{ack}}((a_{i})_{i\\in I_{k}};r_{k})</span> for <span class="math">k\\in[\\ell]</span>, and <span class="math">C_{\\mathsf{com}}=[\\alpha(\\sum_{i\\in I_{\\mathsf{com}}}a_{i}\\chi^{D-n+i}+\\sum_{i\\in[1,4]}\\rho_{n+i}\\chi^{D-3n-i})]_{1}</span>. So we have extracted <span class="math">r_{\\mathsf{com}}(X)=\\sum_{i\\in I_{\\mathsf{com}}}a_{i}X^{i}+\\sum_{i\\in[1,4]}\\rho_{n+i}X^{-2n-i}</span> such that <span class="math">C_{\\mathsf{com}}=\\mathsf{PC}_{\\mathsf{Sonic}}.{\\mathsf{Com}}_{\\mathsf{ck}}(r_{\\mathsf{com}}(X),n)</span>.</p>

    <p class="text-gray-300">Let <span class="math">r_{\\mathsf{mid}}(X):=r(X)-r_{\\mathsf{com}}(X)</span>. Due to the homomorphism of committing function it holds that <span class="math">C_{\\mathsf{mid}}=C\\cdot C_{\\mathsf{com}}^{-1}=\\mathsf{PC}_{\\mathsf{Sonic}}.{\\mathsf{Com}}_{\\mathsf{ck}}(r_{\\mathsf{mid}}(X),n)=[\\alpha\\chi^{D-n}r_{\\mathsf{mid}}(\\chi)]_{1}</span>. Due to the second pairing check we also have that <span class="math">C_{\\mathsf{mid}}^{\\prime}=(C_{\\mathsf{mid}})^{\\chi^{\\ell d}}=[\\alpha\\chi^{D-n+\\ell d}r_{\\mathsf{mid}}(\\chi)]_{1}</span>.</p>

    <p class="text-gray-300">On the other hand, when an algebraic adversary <span class="math">\\mathcal{P}_{\\mathsf{1nk}}^{<em>}</span> outputs <span class="math">C_{\\mathsf{mid}}^{\\prime}</span> it is accompanied by the representation <span class="math">f_{\\chi}(X)+X_{\\alpha}f_{\\alpha}(X)</span> such that <span class="math">C_{\\mathsf{mid}}^{\\prime}=[f_{\\chi}(\\chi)+\\alpha f_{\\alpha}(\\chi)]_{1}</span>, <span class="math">f_{\\chi}(X)</span> has non-zero terms between degree <span class="math">-D</span> and <span class="math">D</span>, and <span class="math">f_{\\alpha}(X)</span> has non-zero terms between degree <span class="math">-D</span> and <span class="math">D</span> except for the constant term. If <span class="math">f_{\\chi}(X)+X_{\\alpha}f_{\\alpha}(X)\\neq X_{\\alpha}X^{D-n+\\ell d}r_{\\mathsf{mid}}(X)</span> we have two distinct representations of <span class="math">C_{\\mathsf{mid}}^{\\prime}</span>, from which one can find <span class="math">\\chi</span> solving the <span class="math">2D</span>-DLOG problem, as in a proof of Theorem 6.3 of </em>[x10]*. Hence we may assume that <span class="math">f_{\\chi}(X)=0</span> and <span class="math">f_{\\alpha}(X)=X^{D-n+\\ell d}r_{\\mathsf{mid}}(X)</span>, implying that <span class="math">r_{\\mathsf{mid}}(X)</span> has degree bounded by <span class="math">n-\\ell d</span>.</p>

    <p class="text-gray-300">Now the committed part of coefficients of <span class="math">r(X)</span> corresponds to extracted <span class="math">r_{\\mathsf{com}}(X)</span>. Hence if WitExt is invoked on <span class="math">r(X)</span> it does extract witness <span class="math">(a_{i})_{i\\in I_{\\mathsf{com}}}</span> consistent with <span class="math">(\\hat{C}_{k})_{k\\in[\\ell]}</span>, which is guaranteed by <span class="math">\\mathcal{E}_{\\mathsf{ComEq}}</span>.</p>

    <p class="text-gray-300">Zero-knowledge To simulate <span class="math">\\pi_{\\mathsf{ComEq}}</span> we simply invoke the zero-knowledge simulator for CompAmComEq made non-interactive with Fiat–Shamir <em>[x7]</em>. To simulate the evaluation proof <span class="math">\\Pi</span> the simulator uses the trapdoor <span class="math">\\alpha</span> and <span class="math">\\chi</span> used for generating the commitment key to compute <span class="math">\\Pi:=\\left((C_{\\mathsf{com}}\\cdot C_{\\mathsf{mid}})^{\\frac{1}{\\alpha\\chi-D+n}}\\cdot[-v]_{1}\\right)^{\\frac{1}{\\chi-\\epsilon}}</span>. To simulate <span class="math">C_{\\mathsf{mid}}^{\\prime}</span> we compute <span class="math">C_{\\mathsf{mid}}^{\\prime}:=C_{\\mathsf{mid}}^{\\chi^{\\ell d}}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Protocol  <span class="math">\\mathsf{CP}_{\\mathsf{lak}}</span>  for Sonic</p>

    <p class="text-gray-300">Indexing  <span class="math">\\mathcal{I}_{\\mathrm{lak}}^{\\mathrm{ex}}(I_{\\mathrm{com}},(I_k)_{k\\in [\\ell ]})</span>  obtains generators  <span class="math">g_{i}\\coloneqq [\\alpha \\chi^{D - n + i}]</span>  for  <span class="math">i\\in I_{\\mathrm{com}}</span> <span class="math">g\\coloneqq (g_i)_{i\\in I_{\\mathrm{com}}}</span> <span class="math">h_i\\coloneqq [\\alpha \\chi^{D - 3n - i}]</span>  for  <span class="math">i\\in [1,4]</span> <span class="math">\\mathbf{h}\\coloneqq (h_i)_{i\\in [1,4]}</span>  , G and  <span class="math">H</span>  by accessing srs. It outputs  <span class="math">(\\mathrm{ipk}_{\\mathrm{lak}},\\mathrm{ivk}_{\\mathrm{lak}})</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ipk}_{\\mathsf{lak}} = (\\mathsf{pp},\\pmb {g},\\mathbf{h},\\mathbf{G},H)</span>  and  <span class="math">\\mathsf{ivk}_{\\mathsf{lak}} = ([\\alpha ]_2,[\\alpha \\chi ]_2,[\\chi^{-D + n - \\ell d}]_2,[\\chi^{\\ell d}]_2,\\pmb {g},\\mathbf{h},\\mathbf{G},H).</span></p>

    <p class="text-gray-300">Input.  <span class="math">\\mathcal{P}_{\\mathrm{lak}}</span>  (resp.  <span class="math">\\nu_{\\mathrm{lak}}</span> ) receives  <span class="math">\\mathsf{ipk}_{\\mathrm{lak}}</span>  (resp.  <span class="math">\\mathsf{ivk}_{\\mathrm{lak}}</span> ). The statement  <span class="math">((\\hat{C}_k)_{k\\in [\\ell ]},(C_{\\mathrm{com}},C_{\\mathrm{mid}}),z,v)</span>  is a common input. The  <span class="math">\\mathcal{P}_{\\mathrm{lak}}</span>  has as input witness  <span class="math">(r_{\\mathrm{com}}(X),r_{\\mathrm{mid}}(X),(r_k)_{k\\in [\\ell ]})</span>  such that</p>

    <p class="text-gray-300"><span class="math">r_{\\mathrm{com}}(X) = \\sum_{i\\in I_{\\mathrm{com}}}a_iX^i +\\sum_{i = 1}^4\\rho_{n + i}X^{-2n - i}\\qquad r_{\\mathrm{mid}}(X) = \\sum_{i\\in I_{\\mathrm{com}}}a_iX^i +\\sum_{i = 1}^n (b_iX^{-i} + c_iX^{-n - i}) + \\sum_{i = 1}^4\\lambda_{n + i}X^{-2n - i}</span></p>

    <p class="text-gray-300"><span class="math">\\hat{C}_k = \\mathbf{G}^{(\\alpha_i)_{i\\in I_k}}H^{r_k}</span> <span class="math">C_{\\mathrm{com}} = [\\alpha \\chi^{D - n}r_{\\mathrm{com}}(\\chi)]_1</span> <span class="math">C_{\\mathrm{mid}} = [\\alpha \\chi^{D - n}r_{\\mathrm{mid}}(\\chi)]_1</span> <span class="math">v = r_{\\mathrm{com}}(z) + r_{\\mathrm{mid}}(z)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a proof  <span class="math">\\pi_{\\mathrm{ComEq}}</span>  of the following statement.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\text {C o m p A m C o m E q}: \\mathsf {P K} \\left\\{\\left((a _ {i}) _ {i \\in I _ {\\text {c o m}}}, (r _ {k}) _ {k \\in [ \\ell ]}, (\\rho_ {n + i}) _ {i \\in [ 1, 4 ]}\\right): \\begin{array}{c} \\hat {C} _ {k} = \\mathbf {G} ^ {(\\alpha_ {i}) _ {i \\in I _ {k}}} H ^ {r _ {k}} \\wedge \\\\ C _ {\\text {c o m}} = \\boldsymbol {g} ^ {(\\alpha_ {i}) _ {i \\in I _ {\\text {c o m}}}} \\mathbf {h} ^ {(\\rho_ {n + i}) _ {i \\in [ 1, 4 ]}} \\end{array} \\right\\}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">r(X) \\coloneqq r_{\\mathrm{com}}(X) + r_{\\mathrm{mid}}(X)</span> . Compute evaluation proof as follows.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">W (X) = \\frac {r (X) - v}{X - z} \\quad \\Pi = [ W (\\chi) ] _ {1}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a shifted commitment as follows.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C _ {\\mathrm {m i d}} ^ {\\prime} := \\left[ \\alpha \\chi^ {D - n + \\ell d} r _ {\\mathrm {m i d}} (\\chi) \\right] _ {1} = \\mathsf {P C} _ {\\mathrm {S o n i c}}. \\mathsf {C o m} _ {\\mathrm {i k}} (r _ {\\mathrm {m i d}} (X), n - \\ell d)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\pi_{\\mathrm{lak}} \\coloneqq (\\pi_{\\mathrm{ComEq}}, \\Pi, C_{\\mathrm{mid}}&#x27;)</span> .</li>

    </ul>

    <p class="text-gray-300">Verify. Given  <span class="math">\\pi_{\\mathrm{lak}}</span> , verify  <span class="math">\\pi_{\\mathrm{ComEq}}</span> , check evaluation proof:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\Pi , [ \\alpha \\chi ] _ {2}\\right) \\cdot e \\left([ v ] _ {1} \\cdot \\Pi^ {- z}, [ \\alpha ] _ {2}\\right) \\stackrel {?} {=} e \\left(C _ {\\text {c o m}} \\cdot C _ {\\text {m i d}}, [ \\chi^ {- D + n - \\ell d} ] _ {2}\\right)</span></div>

    <p class="text-gray-300">and check  <span class="math">r_{\\mathrm{mid}}(X)</span>  has degree at most  <span class="math">n - \\ell d</span></p>

    <div class="my-4 text-center"><span class="math-block">e \\left(C _ {\\text {m i d}}, [ \\chi^ {\\ell d} ] _ {2}\\right) \\stackrel {?} {=} e \\left(C _ {\\text {m i d}} ^ {\\prime}, h\\right)</span></div>

    <p class="text-gray-300">Fig. 7. Commitment-linking protocol for Sonic</p>

    <p class="text-gray-300">AC20. T. Attema and R. Cramer. Compressed  <span class="math">\\Sigma</span> -protocol theory and practical application to plug &amp; play secure algorithms. In CRYPTO 2020, Part III, vol. 12172 of LNCS, pp. 513-543. Springer, Heidelberg, 2020. ACF20. T. Attema, R. Cramer, and S. Fehr. Compressing proofs of  <span class="math">k</span> -out-of- <span class="math">n</span>  partial knowledge. Cryptology ePrint Archive, Report 2020/753, 2020. https://eprint.iacr.org/2020/753. ACK21. T. Attema, R. Cramer, and L. Kohl. A compressed  <span class="math">\\sigma</span> -protocol theory for lattices. Cryptology ePrint Archive, Report 2021/307, 2021. https://eprint.iacr.org/2021/307. ACR20. T. Attema, R. Cramer, and M. Rambaud. Compressed  <span class="math">\\sigma</span> -protocols for bilinear group arithmetic circuits and applications. Cryptology ePrint Archive, Report 2020/1447, 2020. https://eprint.iacr.org/2020/1447. AGM18. S. Agrawal, C. Ganesh, and P. Mohassel. Non-interactive zero-knowledge proofs for composite statements. In CRYPTO 2018, Part III, vol. 10993 of LNCS, pp. 643-673. Springer, Heidelberg, 2018. <span class="math">\\mathrm{BBB}^{+}18</span>  B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pp. 315-334. IEEE Computer Society Press, 2018. <span class="math">\\mathrm{BCF}^{+}21</span>  D. Benarroch, M. Campanelli, D. Fiore, J. Kim, J. Lee, H. Oh, and A. Querol. Proposal: Commit-and-prove zero-knowledge proof systems and extensions. 4th ZKProof Workshop, 2021. https://docs.zkproof.org/pages/standards/accepted-workshop4/proposal-commit.pdf. <span class="math">\\mathrm{BCG}^{+}13</span>  E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In CRYPTO 2013, Part II, vol. 8043 of LNCS, pp. 90-108. Springer, Heidelberg, 2013. <span class="math">\\mathrm{BCG}^{+}14</span>  E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pp. 459-474. IEEE Computer Society Press, 2014.</p>

    <p class="text-gray-300">BCI^{+}13. N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In TCC 2013, vol. 7785 of LNCS, pp. 315–333. Springer, Heidelberg, 2013. BCR^{+}19. E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS. In EUROCRYPT 2019, Part I, vol. 11476 of LNCS, pp. 103–128. Springer, Heidelberg, 2019. BCTV14. E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In USENIX Security 2014, pp. 781–796. USENIX Association, 2014. BDFG20. D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive, Report 2020/081, 2020. https://eprint.iacr.org/2020/081. BFS20. B. Bünz, B. Fisch, and A. Szepieniec. Transparent SNARKs from DARK compilers. In EUROCRYPT 2020, Part I, vol. 12105 of LNCS, pp. 677–706. Springer, Heidelberg, 2020. BGM17. S. Bowe, A. Gabizon, and I. Miers. Scalable multi-party computation for zk-SNARK parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. https://eprint.iacr.org/2017/1050. BHH^{+}19. M. Backes, L. Hanzlik, A. Herzberg, A. Kate, and I. Pryvalov. Efficient non-interactive zero-knowledge proofs in cross-domains without trusted setup. In PKC 2019, Part I, vol. 11442 of LNCS, pp. 286–313. Springer, Heidelberg, 2019. CDG^{+}17. M. Chase, D. Derler, S. Goldfeder, C. Orlandi, S. Ramacher, C. Rechberger, D. Slamanig, and G. Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In ACM CCS 2017, pp. 1825–1842. ACM Press, 2017. CDS94. R. Cramer, I. Damgård, and B. Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In CRYPTO’94, vol. 839 of LNCS, pp. 174–187. Springer, Heidelberg, 1994. CFF^{+}20. M. Campanelli, A. Faonio, D. Fiore, A. Querol, and H. Rodríguez. Lunar: a toolbox for more efficient universal and updatable zksnarks and commit-and-prove extensions. Cryptology ePrint Archive, Report 2020/1069, 2020. https://eprint.iacr.org/2020/1069. CFH^{+}15. C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter, M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile verifiable computation. In 2015 IEEE Symposium on Security and Privacy, pp. 253–270. IEEE Computer Society Press, 2015. CFQ19. M. Campanelli, D. Fiore, and A. Querol. LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In ACM CCS 2019, pp. 2075–2092. ACM Press, 2019. CGM16. M. Chase, C. Ganesh, and P. Mohassel. Efficient zero-knowledge proof of algebraic and non-algebraic statements with applications to privacy preserving credentials. In CRYPTO 2016, Part III, vol. 9816 of LNCS, pp. 499–530. Springer, Heidelberg, 2016. CHA21. M. Campanelli and M. Hall-Andersen. Veksel: Simple, efficient, anonymous payments with large anonymity sets from well-studied assumptions. Cryptology ePrint Archive, Report 2020/1069, 2021. https://eprint.iacr.org/2021/327. CHM^{+}20. A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In EUROCRYPT 2020, Part I, vol. 12105 of LNCS, pp. 738–768. Springer, Heidelberg, 2020. CS97. J. Camenisch and M. Stadler. Efficient group signature schemes for large groups (extended abstract). In CRYPTO’97, vol. 1294 of LNCS, pp. 410–424. Springer, Heidelberg, 1997. DFKP16. A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, and B. Parno. Cinderella: Turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation. In 2016 IEEE Symposium on Security and Privacy, pp. 235–254. IEEE Computer Society Press, 2016. DGK^{+}21. I. Damgård, C. Ganesh, H. Khoshakhlagh, C. Orlandi, and L. Siniscalchi. Balancing privacy and accountability in blockchain identity management. In CT-RSA 2021, vol. 12704 of LNCS, pp. 552–576. Springer, Heidelberg, 2021. FKL18. G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applications. In CRYPTO 2018, Part II, vol. 10992 of LNCS, pp. 33–62. Springer, Heidelberg, 2018. FS87. A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO’86, vol. 263 of LNCS, pp. 186–194. Springer, Heidelberg, 1987. GGPR13. R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In EUROCRYPT 2013, vol. 7881 of LNCS, pp. 626–645. Springer, Heidelberg, 2013. GKM^{+}18. J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. Updatable and universal common reference strings with applications to zk-SNARKs. In CRYPTO 2018, Part III, vol. 10993 of LNCS, pp. 698–728. Springer, Heidelberg, 2018. GMO16. I. Giacomelli, J. Madsen, and C. Orlandi. ZKBoo: Faster zero-knowledge for Boolean circuits. In USENIX Security 2016, pp. 1069–1083. USENIX Association, 2016. GMR85. S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In 17th ACM STOC, pp. 291–304. ACM Press, 1985. GQ88. L. C. Guillou and J.-J. Quisquater. A practical zero-knowledge protocol fitted to security microprocessor minimizing both trasmission and memory. In EUROCRYPT’88, vol. 330 of LNCS, pp. 123–128. Springer, Heidelberg, 1988.</p>

    <p class="text-gray-300">Gro10. J. Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT 2010, vol. 6477 of LNCS, pp. 321–340. Springer, Heidelberg, 2010.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Gro16. J. Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT 2016, Part II, vol. 9666 of LNCS, pp. 305–326. Springer, Heidelberg, 2016.</li>

      <li>GWC19. A. Gabizon, Z. J. Williamson, and O. Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>IKO07. Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Efficient arguments without short pcps. In Twenty-Second Annual IEEE Conference on Computational Complexity (CCC’07), pp. 278–291. IEEE, 2007.</li>

      <li>JKO13. M. Jawurek, F. Kerschbaum, and C. Orlandi. Zero-knowledge using garbled circuits: how to prove non-algebraic statements efficiently. In ACM CCS 2013, pp. 955–966. ACM Press, 2013.</li>

      <li>jub17. What is Jubjub? https://z.cash/technology/jubjub, 2017. [Online; accessed 14-September-2021].</li>

      <li>KPV19. A. Kattis, K. Panarin, and A. Vlasov. Redshift: Transparent snarks from list polynomial commitment iops. Cryptology ePrint Archive, Report 2019/1400, 2019. https://eprint.iacr.org/2019/1400.</li>

      <li>KZG10. A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In ASIACRYPT 2010, vol. 6477 of LNCS, pp. 177–194. Springer, Heidelberg, 2010.</li>

      <li>KZM^{+}15. A. Kosba, Z. Zhao, A. Miller, Y. Qian, H. Chan, C. Papamanthou, R. Pass, a. shelat, and E. Shi. How to use SNARKs in universally composable protocols. Cryptology ePrint Archive, Report 2015/1093, 2015. https://eprint.iacr.org/2015/1093.</li>

      <li>LCKO19. J. Lee, J. Choi, J. Kim, and H. Oh. Saver: Snark-friendly, additively-homomorphic, and verifiable encryption and decryption with rerandomization. Cryptology ePrint Archive, Report 2019/1270, 2019. https://eprint.iacr.org/2019/1270.</li>

      <li>Lip12. H. Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In TCC 2012, vol. 7194 of LNCS, pp. 169–189. Springer, Heidelberg, 2012.</li>

      <li>Lip13. H. Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. In ASIACRYPT 2013, Part I, vol. 8269 of LNCS, pp. 41–60. Springer, Heidelberg, 2013.</li>

      <li>Lip16. H. Lipmaa. Prover-efficient commit-and-prove zero-knowledge SNARKs. In AFRICACRYPT 16, vol. 9646 of LNCS, pp. 185–206. Springer, Heidelberg, 2016.</li>

      <li>Max15. G. Maxwell. Confidential transactions. URL: https://people. xiph. org/greg/confidential values. txt, 2015.</li>

      <li>MBKM19. M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In ACM CCS 2019, pp. 2111–2128. ACM Press, 2019.</li>

      <li>Ped92. T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In CRYPTO’91, vol. 576 of LNCS, pp. 129–140. Springer, Heidelberg, 1992.</li>

      <li>PHGR13. B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pp. 238–252. IEEE Computer Society Press, 2013.</li>

      <li>Sch90. C.-P. Schnorr. Efficient identification and signatures for smart cards. In CRYPTO’89, vol. 435 of LNCS, pp. 239–252. Springer, Heidelberg, 1990.</li>

      <li>Set20. S. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In CRYPTO 2020, Part III, vol. 12172 of LNCS, pp. 704–737. Springer, Heidelberg, 2020.</li>

      <li>WTs^{+}18. R. S. Wahby, I. Tzialla, a. shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pp. 926–943. IEEE Computer Society Press, 2018.</li>

      <li>WZC^{+}18. H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica. DIZK: A distributed zero knowledge proof system. In USENIX Security 2018, pp. 675–692. USENIX Association, 2018.</li>

    </ul>

    <p class="text-gray-300">A Additional Materials on Compressed <span class="math">\\Sigma</span>-protocol Theory</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">A.1 <span class="math">\\Sigma</span>-Protocols and Pedersen Vector Commitment</h3>

    <p class="text-gray-300"><span class="math">\\Sigma</span>-protocols are interactive proof systems consisting of three rounds. In a <span class="math">\\Sigma</span>-protocol, the prover sends a message <span class="math">a</span>, the verifier replies with a random bit string <span class="math">c</span>, and the prover responds with <span class="math">z</span>. The verifier decides to accept or reject based on the transcript <span class="math">(a,c,z)</span>. A <span class="math">\\Sigma</span>-protocol can be efficiently compiled into a non-interactive zero-knowledge proof of knowledge (in the random oracle model) through the Fiat-Shamir transform <em>[x10]</em>. Throughout the paper, we use the Pedersen commitment scheme <em>[x23]</em> as the algebraic commitment, which gives unconditional hiding and computational binding properties based on the hardness of computing the discrete logarithm in a group <span class="math">\\mathbb{G}</span> of prime order <span class="math">q</span>. Given two random generators <span class="math">G,H\\in\\mathbb{G}</span> such that <span class="math">\\log_{G}H</span> is unknown, a value <span class="math">x\\in\\mathbb{Z}_{q}</span> is committed to by choosing <span class="math">r</span> randomly from <span class="math">\\mathbb{Z}_{q}</span>, and computing <span class="math">G^{x}H^{r}</span>. We write <span class="math">\\mathsf{Com}_{q}(x;r)</span> to denote a Pedersen commitment to <span class="math">x</span> with randomness <span class="math">r</span> in a group of order <span class="math">q</span>, and omit the subscript when the group is clear. A Pedersen commitment to a vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{d}</span> is computed as <span class="math">\\mathsf{Com}(\\mathbf{x};r)=\\mathbf{G}^{\\mathbf{x}}H^{r}=(\\prod_{i=1}^{d}G_{i}^{x_{i}})H^{r}</span> where <span class="math">\\mathbf{G}=(G_{1},\\ldots,G_{d})</span> and <span class="math">H</span> are randomly chosen generators with unknown relative discrete logarithms.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">A.2 ComEq: Proving equality of two Pedersen vector commitments</h3>

    <p class="text-gray-300">In this section, we first define a naïve ComEq protocol proving equality of vectors committed in two Pedersen commitments, with proof size of <span class="math">O(d)</span>. Our goal is to give a protocol for the relation</p>

    <p class="text-gray-300">$\\mathcal{R}_{\\mathsf{ComEq}}=\\left\\{((\\bm{g},\\mathbf{h},\\mathbf{G},\\mathbf{H},d,d^{\\prime},d^{\\prime\\prime}),(C,\\hat{C}),(\\mathbf{w},\\bm{\\alpha},\\bm{\\beta}))\\ :\\ \\ \\ \\ C=\\bm{g}^{\\mathbf{w}}\\mathbf{h}^{\\bm{\\alpha}},\\hat{C}=\\mathbf{G}^{\\mathbf{w}}\\mathbf{H}^{\\bm{\\beta}},\\bm{g},\\mathbf{G}\\in\\mathbb{G}^{d},\\mathbf{w}\\in\\mathbb{Z}_{q}^{d}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\</p>

    <p class="text-gray-300">Let CompComEq be a protocol identical to ComEq, except that its last move is replaced by the compression mechanism CompDLEq (Fig. 3). Then we obtain the following.</p>

    <p class="text-gray-300">Corollary 2. CompComEq is a <span class="math">(2\\mu + 3)</span>-move protocol for the relation <span class="math">\\mathcal{R}_{\\mathrm{ComEq}}</span>, where <span class="math">\\mu = \\lceil \\log_2(d) \\rceil - 1</span>. It is perfectly complete and unconditionally <span class="math">(2, k_1, \\ldots, k_\\mu)</span>-special sound, where <span class="math">k_i = 3</span> for all <span class="math">i \\in [1, \\mu]</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">4\\lceil \\log_2(d)\\rceil - 2</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">2 + d&#x27; + d&#x27;&#x27;</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\lceil \\log_2(d) \\rceil</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <h2 id="sec-53" class="text-2xl font-bold">A.3 AmComEq' as a result of [ACF20]</h2>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">Protocol AmComEq'</h3>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> sends random challenge <span class="math">x\\in \\mathbb{Z}_q</span>. Both parties compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tilde{\\mathbf{G}} = \\left[ \\mathbf{G}, \\mathbf{G}^x, \\dots, \\mathbf{G}^{x^{\\ell - 1}} \\right] \\in \\mathbb{G}^{td} \\\\ \\tilde{\\mathbf{H}} = \\left[ \\mathbf{H}, \\mathbf{H}^x, \\dots, \\mathbf{H}^{x^{\\ell - 1}} \\right] \\in \\mathbb{G}^{td&#x27;&#x27;}. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> samples random <span class="math">\\mathbf{r} \\in \\mathbb{Z}_q^{td}</span>, <span class="math">\\boldsymbol{\\delta} \\in \\mathbb{Z}_q^{d&#x27;}</span>, <span class="math">\\boldsymbol{\\gamma} \\in \\mathbb{Z}_q^{td&#x27;&#x27;}</span>, and sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} A = \\boldsymbol{g}^x \\mathbf{h}^{\\boldsymbol{\\delta}} \\\\ \\tilde{A} = \\tilde{\\mathbf{G}}^x \\tilde{\\mathbf{H}}^{\\boldsymbol{\\gamma}} \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> sends random challenge <span class="math">e\\in \\mathbb{Z}_q</span></li>

      <li><span class="math">\\mathcal{P}</span> sends</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{z} = \\mathbf{r} + e \\mathbf{w}, \\quad \\boldsymbol{\\omega} = \\boldsymbol{\\delta} + e \\boldsymbol{\\alpha}, \\quad \\boldsymbol{\\Omega} = \\boldsymbol{\\gamma} + e \\boldsymbol{\\beta}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> checks</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{g}^x \\mathbf{h}^{\\boldsymbol{\\omega}} \\stackrel{?}{=} AC^e, \\quad \\tilde{\\mathbf{G}}^x \\tilde{\\mathbf{H}}^{\\boldsymbol{\\Omega}} \\stackrel{?}{=} \\tilde{A} \\prod_{i=1}^{l} (\\hat{C}_i^{x^{i-1}})^e</span></div>

    <p class="text-gray-300">Fig. 9. Four-move protocol for amortized equality of many vector Pedersen commitments</p>

    <h2 id="sec-55" class="text-2xl font-bold">B PLONK Preliminaries</h2>

    <p class="text-gray-300">Conventions. We use <span class="math">i</span> as an index for gate and <span class="math">j</span> for wire.</p>

    <h2 id="sec-56" class="text-2xl font-bold">B.1 PLONK constraint systems.</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We consider a fan-in two arithmetic circuit over <span class="math">\\mathbb{F}</span>, consisting of <span class="math">n</span> gates and <span class="math">m</span> wires. The vector <span class="math">\\mathbf{w} \\in \\mathbb{F}^m</span> consists of assigned wire values. The index vector $\\mathbf{v} = \\mathbf{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{O} \\in [m]^{3n}<span class="math"> represents the indices of wires for each gate: concretely, for each </span>i \\in [n]<span class="math">, </span>\\mathbf{L}_i<span class="math"> represents left, </span>\\mathbf{R}_i<span class="math"> represents right, and </span>\\mathbf{O}_i<span class="math"> represents output wire of gate </span>j<span class="math">, respectively. For example, the left input wire value of </span>i<span class="math">-th gate is obtained by </span>w_{\\mathbf{L}_i}<span class="math">. The per-gate constraints are specified by selector vectors </span>\\mathbf{q}_L, \\mathbf{q}_R, \\mathbf{q}_O, \\mathbf{q}_M, \\mathbf{q}_C \\in \\mathbb{F}^n<span class="math">. We call </span>\\mathcal{C} = (n, m, \\mathbf{L}, \\mathbf{R}, \\mathbf{O}, \\mathbf{q}_L, \\mathbf{q}_R, \\mathbf{q}_O, \\mathbf{q}_M, \\mathbf{q}_C)<span class="math"> constraint systems. We say that </span>\\mathbf{w} \\in \\mathbb{F}^m<span class="math"> satisfies the constraint systems </span>\\mathcal{C}<span class="math"> if for each gate </span>i \\in [n]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf{q}_L\\right)_i \\cdot w_{\\mathbf{L}_i} + \\left(\\mathbf{q}_R\\right)_i \\cdot w_{\\mathbf{R}_i} + \\left(\\mathbf{q}_O\\right)_i \\cdot w_{\\mathbf{O}_i} + \\left(\\mathbf{q}_M\\right)_i \\cdot w_{\\mathbf{L}_i} w_{\\mathbf{R}_i} + \\left(\\mathbf{q}_C\\right)_i = 0. \\tag{14}</span></div>

    <p class="text-gray-300">For the wire values <span class="math">\\mathbf{w} \\in \\mathbb{F}^m</span>, we call <span class="math">(w_j)_{j \\in [l]}</span> public input and <span class="math">(w_j)_{j \\in [l+1,m]}</span> private input, respectively. We say <span class="math">\\mathcal{C}</span> is prepared for <span class="math">l</span> public inputs if for each <span class="math">i \\in [l]</span> we define <span class="math">\\mathbf{L}_i = i</span>, <span class="math">(\\mathbf{q}_L)_i = 1</span>, <span class="math">(\\mathbf{q}_R)_i = (\\mathbf{q}_M)_i =</span></p>

    <p class="text-gray-300">33</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{q}_{R})_{i}=(\\mathbf{q}_{C})_{i}=0</span>, i.e., each gate <span class="math">i\\in[l]</span> is dedicated for the input wire <span class="math">j=i\\in[l]</span> of <span class="math">\\mathbf{w}</span>. Then the constraint for an input gate <span class="math">i\\in[l]</span> can be satisfied by subtracting <span class="math">w_{j}</span> from the above equation. Accordingly, we can define relation wrt <span class="math">\\mathcal{C}</span>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 15 (PLONK indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\text{PLONK}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">((\\mathbb{F},n,m,l,\\mathbf{L},\\mathbf{R},\\mathbf{O},\\mathbf{q}_{L},\\mathbf{q}_{R},\\mathbf{q}_{O},\\mathbf{q}_{M},\\mathbf{q}_{C}),(w_{j})_{j\\in[l]},(w_{j})_{j\\in[l+1,m]})</span></p>

    <p class="text-gray-300">such that</p>

    <p class="text-gray-300"><span class="math">\\forall i\\in[l],(\\mathbf{q}_{L})_{i}\\cdot w_{\\mathbf{L}_{i}}+(\\mathbf{q}_{R})_{i}\\cdot w_{\\mathbf{R}_{i}}+(\\mathbf{q}_{O})_{i}\\cdot w_{\\mathbf{O}_{i}}+(\\mathbf{q}_{M})_{i}\\cdot w_{\\mathbf{L}_{i}}w_{\\mathbf{R}_{i}}+(\\mathbf{q}_{C})_{i}-w_{i}=0</span> <span class="math">\\forall i\\in[l+1,n],(\\mathbf{q}_{L})_{i}\\cdot w_{\\mathbf{L}_{i}}+(\\mathbf{q}_{R})_{i}\\cdot w_{\\mathbf{R}_{i}}+(\\mathbf{q}_{O})_{i}\\cdot w_{\\mathbf{O}_{i}}+(\\mathbf{q}_{M})_{i}\\cdot w_{\\mathbf{L}_{i}}w_{\\mathbf{R}_{i}}+(\\mathbf{q}_{C})_{i}=0</span></p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">B.2 Lagrange basis.</h3>

    <p class="text-gray-300">Let <span class="math">q</span> be a characteristic of <span class="math">\\mathbb{F}</span> and <span class="math">n</span> be such that <span class="math">q=1\\mod n</span>. Then <span class="math">\\mathbb{F}^{<em>}</span> contains a multiplicative subgroup <span class="math">\\mathbb{H}=\\left\\{\\zeta,\\zeta^{2},\\ldots,\\zeta^{n}\\right\\}</span> generated by an <span class="math">n</span>th primitive root of unity <span class="math">\\zeta\\in\\mathbb{F}^{</em>}</span>. It follows that an associated vanishing polynomial <span class="math">v_{\\mathbb{H}}(X)=X^{n}-1</span> splits completely in <span class="math">\\mathbb{F}[X]</span>, i.e., <span class="math">X^{n}-1=\\prod_{i=1}^{n}(X-\\zeta^{i})</span>. In PLONK the Lagrange basis <span class="math">L_{x}(X)</span> for <span class="math">x\\in\\mathbb{H}</span> is defined as follows.</p>

    <p class="text-gray-300"><span class="math">L_{x}(X)\\coloneqq\\frac{c_{x}(X^{n}-1)}{X-x}</span></p>

    <p class="text-gray-300">By definition it is easy to check that <span class="math">L_{x}(y)=0</span> for all <span class="math">y\\in\\mathbb{H}\\setminus\\{x\\}</span>. We show <span class="math">L_{x}(x)=1</span> so that <span class="math">L_{x}(X)</span> is indeed a Lagrange basis. First, due to the Euclidean division of polynomials <span class="math">X^{n}-1</span> can be rewritten as</p>

    <p class="text-gray-300"><span class="math">X^{n}-1=(X-x)\\cdot\\left(\\sum_{i=0}^{n-1}x^{i}X^{n-1-i}\\right)+(x^{n}-1).</span></p>

    <p class="text-gray-300">As <span class="math">x</span> has order <span class="math">n</span> the remainder <span class="math">x^{n}-1</span> vanishes. Therefore, we get</p>

    <p class="text-gray-300"><span class="math">L_{x}(X)=c_{x}\\cdot\\left(\\sum_{i=0}^{n-1}x^{i}X^{n-1-i}\\right).</span></p>

    <p class="text-gray-300">Defining <span class="math">c_{x}=(nx^{n-1})^{-1}</span> we have <span class="math">L_{x}(x)=1</span>. In what follows we write <span class="math">L_{i}(X)\\coloneqq L_{x}(X)</span> for <span class="math">x=\\zeta^{i}</span>.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">B.3 Checking gate-by-gate constraints.</h3>

    <p class="text-gray-300">When working over a multiplicative subgroup <span class="math">\\mathbb{H}\\subset\\mathbb{F}^{*}</span>, the selector vectors define polynomials in <span class="math">\\mathbb{F}_{&lt;n}[X]</span> via interpolation:</p>

    <p class="text-gray-300"><span class="math">q_{L}(X)</span> <span class="math">=\\sum_{i\\in[n]}(\\mathbf{q}_{L})_{i}\\cdot L_{i}(X)\\qquad q_{R}(X)=\\sum_{i\\in[n]}(\\mathbf{q}_{R})_{i}\\cdot L_{i}(X)\\qquad q_{O}(X)=\\sum_{i\\in[n]}(\\mathbf{q}_{O})_{i}\\cdot L_{i}(X)</span> (15) <span class="math">q_{M}(X)</span> <span class="math">=\\sum_{i\\in[n]}(\\mathbf{q}_{M})_{i}\\cdot L_{i}(X)\\qquad q_{C}(X)=\\sum_{i\\in[n]}(\\mathbf{q}_{C})_{i}\\cdot L_{i}(X)</span> (16)</p>

    <p class="text-gray-300">So <span class="math">q_{L}(\\zeta^{i})=(\\mathbf{q}_{L})_{i},q_{R}(\\zeta^{i})=(\\mathbf{q}_{R})_{i}</span> and so on. Let us define the following polynomials.</p>

    <p class="text-gray-300"><span class="math">f_{\\text{pub}}(X)=\\sum_{i\\in[l]}-w_{i}L_{i}(X)\\quad f_{L}(X)=\\sum_{i\\in[n]}w_{\\mathbf{L}_{i}}L_{i}(X)\\quad f_{R}(X)=\\sum_{i\\in[n]}w_{\\mathbf{R}_{i}}L_{i}(X)\\quad f_{O}(X)=\\sum_{i\\in[n]}w_{\\mathbf{O}_{i}}L_{i}(X)</span> (17)</p>

    <p class="text-gray-300">Then the gate-by-gate constraint of Eq. 14 can be checked if the polynomial</p>

    <p class="text-gray-300"><span class="math">F_{\\mathcal{C}}(X)\\coloneqq q_{L}(X)f_{L}(X)+q_{R}f_{R}(X)+q_{O}(X)f_{O}(X)+q_{M}(X)f_{L}(X)f_{R}(X)+q_{C}(X)+f_{\\text{pub}}(X)</span> (18)</p>

    <p class="text-gray-300">vanishes at <span class="math">\\zeta^{i}</span> for all <span class="math">i\\in[n]</span>.</p>

    <p class="text-gray-300">B.4 Checking copy constraints.</p>

    <p class="text-gray-300">Notice that the above ranged polynomial evaluations are only individually checking constraint for each gate, but do not care about how different gates are associated with each other. To define a relation equivalent to <span class="math">\\mathcal{R}_{\\mathsf{PLONK}}</span>, we need to enforce the <em>copy constraints</em> on evaluations of witness polynomials <span class="math">f_{L},f_{R},f_{O}</span>. Let us first define two useful notions.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 16 (Extended permutation across multiple polynomials).</h6>

    <p class="text-gray-300">Let <span class="math">f_{1},\\ldots,f_{c},h_{1},\\ldots,h_{c}\\in\\mathbb{F}[X]</span> and <span class="math">\\sigma:[cn]\\to[cn]</span> be a permutation. Define the sequences of polynomial evaluations <span class="math">f_{(1)},\\ldots,f_{(cn)},h_{(1)},\\ldots h_{(cn)}</span> over <span class="math">\\mathbb{H}=\\{\\zeta,\\ldots,\\zeta^{n}\\}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">f_{((j-1)n+i)}\\coloneqq f_{j}(\\zeta^{i})\\text{ and }h_{((j-1)n+i)}\\coloneqq h_{j}(\\zeta^{i})</span></p>

    <p class="text-gray-300">for each <span class="math">i\\in[n]</span> and <span class="math">j\\in[c]</span>. Then we write <span class="math">(h_{1},\\ldots,h_{c})=\\sigma(f_{1},\\ldots,f_{c})</span> if <span class="math">h_{(i)}=f_{(\\sigma(i))}</span> for all <span class="math">i\\in[cn]</span>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 17 (Copy-satisfy).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{T}=\\{T_{1},\\ldots,T_{m}\\}</span> be a partition of <span class="math">[cn]</span>. We say that <span class="math">f_{1},\\ldots,f_{c}\\in\\mathbb{F}[X]</span> <em>copy-satisfy</em> <span class="math">\\mathcal{T}</span> if <span class="math">f_{(i)}=f_{(i^{\\prime})}</span> for all distinct pairs <span class="math">i,i^{\\prime}\\in T_{j}</span> and for all <span class="math">j\\in[m]</span>.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Lemma 5 (<em>[x10]**[x11]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{T}=\\{T_{1},\\ldots,T_{m}\\}</span> be a partition of <span class="math">[cn]</span>. Suppose a permutation <span class="math">\\sigma:[cn]\\to[cn]</span> is defined such that its restriction $\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{T_{j}}<span class="math"> contains a cycle going over all elements in </span>T_{j}<span class="math"> for all </span>j\\in[m]<span class="math">. Then </span>f_{1},\\ldots,f_{c}\\in\\mathbb{F}[X]<span class="math"> <em>copy-satisfy</em> </span>\\mathcal{T}<span class="math"> if and only if </span>(f_{1},\\ldots,f_{c})=\\sigma(f_{1},\\ldots,f_{c})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a concrete instantiation of <span class="math">\\mathsf{PLONK}</span>, we set <span class="math">c=3</span> and consider an extended permutation across <span class="math">f_{1}=f_{L},f_{2}=f_{R},</span> and <span class="math">f_{3}=f_{O}</span>. Let <span class="math">\\mathcal{T}_{\\mathcal{C}}=\\{T_{1},\\ldots,T_{m}\\}</span> be a partition of <span class="math">[3n]</span> such that <span class="math">T_{j}=\\big{\\{}i\\in[3n]:\\ \\mathbf{v}_{i}=j\\,\\big{\\}}</span>, i.e., a set <span class="math">T_{j}</span> contains positions in $\\mathbf{v}\\coloneqq\\mathbf{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{O}\\in[m]^{3n}<span class="math"> that point to </span>w_{j}<span class="math">. Then, by defining a permutation </span>\\sigma:[3n]\\to[3n]<span class="math"> such that it satisfies a condition for Lemma 5, it suffices to provide some <em>permutation argument</em> that proves </span>(f_{L},f_{R},f_{O})=\\sigma(f_{L},f_{R},f_{O})<span class="math">, in order to show </span>(f_{L},f_{R},f_{O})<span class="math"> copy-satisfy </span>\\mathcal{T}_{\\mathcal{C}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">B.5 Putting together.</h3>

    <p class="text-gray-300">We are now set out to define an alternative formulation of the indexed relation <span class="math">\\mathcal{R}_{\\mathsf{PLONK}}</span>, which is in fact the one used by the resulting protocol of <em>[x11]</em>. Let <span class="math">f_{L},f_{R},f_{O}</span> be polynomials as defined above and let us define a slightly redundant form of statement and witness. Namely, we define <span class="math">((\\mathsf{w}_{i})_{i\\in[l]},(\\mathsf{w}_{i})_{i\\in[l+1,3n]})</span> such that</p>

    <p class="text-gray-300"><span class="math">f_{\\mathsf{pub}}(X)</span> <span class="math">=\\sum_{i\\in[l]}-\\mathsf{w}_{i}L_{i}(X)</span> (19) <span class="math">f_{L}(X)</span> <span class="math">=\\sum_{i\\in[n]}\\mathsf{w}_{i}L_{i}(X)</span> (20) <span class="math">f_{R}(X)</span> <span class="math">=\\sum_{i\\in[n]}\\mathsf{w}_{n+i}L_{i}(X)</span> (21) <span class="math">f_{O}(X)</span> <span class="math">=\\sum_{i\\in[n]}\\mathsf{w}_{2n+i}L_{i}(X)</span> (22)</p>

    <p class="text-gray-300">so <span class="math">\\mathsf{w}_{i}=f_{L}(\\zeta^{i})</span>, <span class="math">\\mathsf{w}_{n+i}=f_{R}(\\zeta^{i})</span>, and <span class="math">\\mathsf{w}_{2n+i}=f_{O}(\\zeta^{i})</span>.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Definition 18 (PLONK indexed relation (alternative formulation)).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}^{\\prime}_{\\mathsf{PLONK}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">((\\mathbb{F},n,m,l,\\mathbf{q}_{L},\\mathbf{q}_{R},\\mathbf{q}_{O},\\mathbf{q}_{M},\\mathbf{q}_{C},\\sigma,\\mathcal{T}_{\\mathcal{C}}),(\\mathsf{w}_{i})_{i\\in[l]},(\\mathsf{w}_{i})_{i\\in[l+1,3n]})</span></p>

    <p class="text-gray-300">such that</p>

    <p class="text-gray-300"><span class="math">\\forall i\\in[n]</span> <span class="math">:\\quad</span> <span class="math">\\mathsf{w}_{i}=\\mathsf{w}_{\\sigma(i)}</span> <span class="math">\\forall i\\in[l]</span> <span class="math">:\\quad</span> <span class="math">(\\mathbf{q}_{L})_{i}\\cdot\\mathsf{w}_{i}+(\\mathbf{q}_{R})_{i}\\cdot\\mathsf{w}_{n+i}+(\\mathbf{q}_{O})_{i}\\cdot\\mathsf{w}_{2n+i}+(\\mathbf{q}_{M})_{i}\\mathsf{w}_{i}\\mathsf{w}_{n+i}+(\\mathbf{q}_{C})_{i}-\\mathsf{w}_{i}=0</span> <span class="math">\\forall i\\in[l+1,n]</span> <span class="math">:\\quad</span> <span class="math">(\\mathbf{q}_{L})_{i}\\cdot\\mathsf{w}_{i}+(\\mathbf{q}_{R})_{i}\\cdot\\mathsf{w}_{n+i}+(\\mathbf{q}_{O})_{i}\\cdot\\mathsf{w}_{2n+i}+(\\mathbf{q}_{M})_{i}\\mathsf{w}_{i}\\mathsf{w}_{n+i}+(\\mathbf{q}_{C})_{i}=0</span></p>

    <p class="text-gray-300">By construction, given an instance of <span class="math">\\mathcal{R}_{\\mathsf{PLONK}}</span> one can clearly define constraint systems <span class="math">\\mathcal{C}</span> as well as <span class="math">(\\mathsf{i}^{\\prime},\\mathsf{x}^{\\prime},\\mathsf{w}^{\\prime})\\in\\mathcal{R}^{\\prime}_{\\mathsf{PLONK}}</span>. It turns out that the converse is also true. We sketch how to efficiently construct a tuple <span class="math">(\\mathsf{i},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}_{\\mathsf{PLONK}}</span>, given <span class="math">(\\mathsf{i}^{\\prime},\\mathsf{x}^{\\prime},\\mathsf{w}^{\\prime})\\in\\mathcal{R}^{\\prime}_{\\mathsf{PLONK}}</span>.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From <span class="math">\\mathbf{i}&#x27;</span> we can clearly determine the constraint systems <span class="math">\\mathcal{C} = (n,m,\\mathbf{L},\\mathbf{R},\\mathbf{O},\\mathbf{q}_L,\\mathbf{q}_R,\\mathbf{q}_O,\\mathbf{q}_M,\\mathbf{q}_C)</span> as well as <span class="math">\\mathrm{i} = (\\mathbb{F},l,\\mathcal{C})</span>. Since <span class="math">\\mathbf{w}_i = \\mathbf{w}_{\\sigma(i)}</span> holds and due to the way <span class="math">\\sigma : [3n] \\to [3n]</span> is defined (i.e., such that its restriction $\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{T_j}<span class="math"> contains a cycle going over all elements in </span>T_j<span class="math"> for all </span>j \\in [m]<span class="math">), we have that </span>\\mathbf{w}_i = \\mathbf{w}_{i'}<span class="math"> for all distinct pairs </span>i, i' \\in T_j<span class="math"> and for each </span>j \\in [m]<span class="math">. Now for each </span>j \\in [m]<span class="math"> we define </span>w_j = \\mathbf{w}_i<span class="math"> for some </span>i \\in T_j<span class="math">. Recall that, by construction of </span>\\mathcal{T}_{\\mathcal{C}}<span class="math">, for each </span>j \\in [m]<span class="math"> we also have </span>j = \\mathbf{v}_i = \\mathbf{v}_{i'}<span class="math"> for each </span>i, i' \\in T_j<span class="math">, where </span>\\mathbf{v} = \\mathbf{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{O} \\in [m]^{3n}<span class="math">. So overall </span>w_j = w_{\\mathbf{v}_i} = \\mathbf{w}_i = w_{\\mathbf{v}_{i'}} = \\mathbf{w}_{i'}$. This indicates that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {q} _ {L}\\right) _ {i} \\cdot w _ {\\mathbf {v} _ {i}} + \\left(\\mathbf {q} _ {R}\\right) _ {i} \\cdot w _ {\\mathbf {v} _ {n + i}} + \\left(\\mathbf {q} _ {O}\\right) _ {i} \\cdot w _ {\\mathbf {v} _ {2 n + i}} + \\left(\\mathbf {q} _ {M}\\right) _ {i} w _ {\\mathbf {v} _ {i}} w _ {\\mathbf {v} _ {n + i}} + \\left(\\mathbf {q} _ {C}\\right) _ {i} - w _ {i} = 0 \\text{ for } i \\in [ l ]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {q} _ {L}\\right) _ {i} \\cdot w _ {\\mathbf {v} _ {i}} + \\left(\\mathbf {q} _ {R}\\right) _ {i} \\cdot w _ {\\mathbf {v} _ {n + i}} + \\left(\\mathbf {q} _ {O}\\right) _ {i} \\cdot w _ {\\mathbf {v} _ {2 n + i}} + \\left(\\mathbf {q} _ {M}\\right) _ {i} w _ {\\mathbf {v} _ {i}} w _ {\\mathbf {v} _ {n + i}} + \\left(\\mathbf {q} _ {C}\\right) _ {i} = 0 \\text{ for } i \\in [ l + 1, n ]</span></div>

    <p class="text-gray-300">or in other words,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {q} _ {L}\\right) _ {i} \\cdot w _ {\\mathbf {L} _ {i}} + \\left(\\mathbf {q} _ {R}\\right) _ {i} \\cdot w _ {\\mathbf {R} _ {i}} + \\left(\\mathbf {q} _ {O}\\right) _ {i} \\cdot w _ {\\mathbf {O} _ {i}} + \\left(\\mathbf {q} _ {M}\\right) _ {i} w _ {\\mathbf {L} _ {i}} w _ {\\mathbf {R} _ {i}} + \\left(\\mathbf {q} _ {C}\\right) _ {i} - w _ {i} = 0 \\text{ for } i \\in [ l ]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {q} _ {L}\\right) _ {i} \\cdot w _ {\\mathbf {L} _ {i}} + \\left(\\mathbf {q} _ {R}\\right) _ {i} \\cdot w _ {\\mathbf {R} _ {i}} + \\left(\\mathbf {q} _ {O}\\right) _ {i} \\cdot w _ {\\mathbf {O} _ {i}} + \\left(\\mathbf {q} _ {M}\\right) _ {i} w _ {\\mathbf {L} _ {i}} w _ {\\mathbf {R} _ {i}} + \\left(\\mathbf {q} _ {C}\\right) _ {i} = 0 \\text{ for } i \\in [ l + 1, n ]</span></div>

    <p class="text-gray-300">implying <span class="math">(\\mathrm{i},(w_j)_{j\\in [l]},(w_j)_{j\\in [l + 1,m]})\\in \\mathcal{R}_{\\mathrm{PLONK}}</span></p>

    <h2 id="sec-65" class="text-2xl font-bold">B.6 Extended Permutation Argument</h2>

    <p class="text-gray-300">To prove <span class="math">(f_{L}, f_{R}, f_{O}) = \\sigma(f_{L}, f_{R}, f_{O})</span>, PLONK invokes an extended permutation argument subprotocol, which we recall in Fig. 10 in the form of AHP. Due to Lemma 5.3 of [GWC19], for any <span class="math">f_{L}, f_{R}, f_{O} \\in \\mathbb{F}_{&amp;lt;D}</span> and any permutation <span class="math">\\sigma : [3n] \\to [3n]</span> such that <span class="math">D \\geq n</span>, if <span class="math">(f_{L}, f_{R}, f_{O}) \\neq \\sigma(f_{L}, f_{R}, f_{O})</span> then for any unbounded prover <span class="math">\\mathsf{P}</span>, the probability that <span class="math">\\mathsf{V}</span> accepts in the above protocol is negligible in the security parameter.</p>

    <h2 id="sec-66" class="text-2xl font-bold">Protocol <span class="math">\\mathsf{AHP}_{\\mathsf{PermArg}}</span></h2>

    <p class="text-gray-300"><strong>Offline phase.</strong> The indexer <span class="math">\\mathsf{I}</span> receives as input <span class="math">\\mathbb{F} \\in \\mathcal{F}</span> and <span class="math">\\mathrm{i} = (\\mathbb{F}, n, m, l, \\mathbf{L}, \\mathbf{R}, \\mathbf{O}, \\mathbf{q}_L, \\mathbf{q}_R, \\mathbf{q}_O, \\mathbf{q}_M, \\mathbf{q}_C)</span>, and computes the permutation <span class="math">\\sigma : [3n] \\to [3n]</span>. Then <span class="math">\\mathsf{I}</span> generates the preprocessed polynomial oracles.</p>

    <div class="my-4 text-center"><span class="math-block">S _ {L, \\mathrm {I D}} = \\sum_ {i \\in [ n ]} i \\cdot L _ {i} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {L, \\sigma} = \\sum_ {i \\in [ n ]} \\sigma (i) \\cdot L _ {i} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {R, \\mathrm {I D}} = \\sum_ {i \\in [ n ]} (n + i) \\cdot L _ {i} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {R, \\sigma} = \\sum_ {i \\in [ n ]} \\sigma (n + i) \\cdot L _ {i} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {O, \\mathrm {I D}} = \\sum_ {i \\in [ n ]} (2 n + i) \\cdot L _ {i} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {O, \\sigma} = \\sum_ {i \\in [ n ]} \\sigma (2 n + i) \\cdot L _ {i} (X)</span></div>

    <p class="text-gray-300"><strong>Input.</strong> Polynomial oracles <span class="math">f_{L}, f_{R}, f_{O} \\in \\mathbb{F}_{&amp;lt;n}[X]</span>.</p>

    <p class="text-gray-300"><strong>Online phase.</strong> Upon receiving random challenges <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span> from <span class="math">\\mathsf{V}</span>, <span class="math">\\mathsf{P}</span> computes</p>

    <div class="my-4 text-center"><span class="math-block">h _ {L, \\mathrm {I D}} = f _ {L} + \\beta \\cdot S _ {L, \\mathrm {I D}} + \\gamma</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {L, \\sigma} = f _ {L} + \\beta \\cdot S _ {L, \\sigma} + \\gamma \\tag {23}</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {R, \\mathrm {I D}} = f _ {R} + \\beta \\cdot S _ {R, \\mathrm {I D}} + \\gamma</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {R, \\sigma} = f _ {R} + \\beta \\cdot S _ {R, \\sigma} + \\gamma \\tag {24}</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {O, \\mathrm {I D}} = f _ {O} + \\beta \\cdot S _ {O, \\mathrm {I D}} + \\gamma</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {O, \\sigma} = f _ {O} + \\beta \\cdot S _ {O, \\sigma} + \\gamma \\tag {25}</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {\\mathrm {I D}} = h _ {L, \\mathrm {I D}} \\cdot h _ {R, \\mathrm {I D}} \\cdot h _ {O, \\mathrm {I D}}</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {\\sigma} = h _ {L, \\sigma} \\cdot h _ {R, \\sigma} \\cdot h _ {O, \\sigma} \\tag {26}</span></div>

    <p class="text-gray-300">Then <span class="math">\\mathsf{P}</span> sends a permutation polynomial oracle:</p>

    <div class="my-4 text-center"><span class="math-block">s (X) = L _ {1} (X) + \\sum_ {i \\in [ 2, n ]} \\left(L _ {i} (X) \\cdot \\prod_ {1 \\leq j &amp;lt; i} \\frac {h _ {\\mathrm {I D}} \\left(\\zeta^ {j}\\right)}{h _ {\\sigma} \\left(\\zeta^ {j}\\right)}\\right). \\tag {27}</span></div>

    <p class="text-gray-300"><strong>Query phase.</strong> <span class="math">\\mathsf{V}</span> queries all offline and online oracles with all points in <span class="math">a\\in \\mathbb{H}</span>.</p>

    <p class="text-gray-300"><strong>Online phase.</strong> <span class="math">\\mathsf{V}</span> checks that the following polynomials vanish on <span class="math">\\mathbb{H}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">F _ {1} (X) = h _ {\\mathrm {I D}} (X) s (X) - h _ {\\sigma} (X) s (\\zeta X)</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {2} (X) = L _ {1} (X) (s (X) - 1)</span></div>

    <p class="text-gray-300">Fig. 10. Permutation argument subprotocol for <span class="math">(f_{L}, f_{R}, f_{O}) = \\sigma(f_{L}, f_{R}, f_{O})</span></p>

    <p class="text-gray-300">Offline phase. The indexer I receives as input  <span class="math">\\mathbb{F} \\in \\mathcal{F}</span>  and  <span class="math">\\mathrm{i} = (\\mathbb{F}, n, m, l, \\mathbf{q}_L, \\mathbf{q}_R, \\mathbf{q}_O, \\mathbf{q}_M, \\mathbf{q}_C, \\sigma, \\mathcal{T}_{\\mathcal{C}})</span> , and computes the following polynomial oracles as described in the text: selector polynomials  <span class="math">(q_L, q_R, q_O, q_M, q_C)</span> ; preprocessed polynomials for permutation argument  <span class="math">(S_{L,\\mathrm{ID}}, S_{R,\\mathrm{ID}}, S_{O,\\mathrm{ID}}, S_{L,\\sigma}, S_{R,\\sigma}, S_{O,\\sigma})</span> ; vanishing polynomial of  <span class="math">\\mathbb{H}</span> ,  <span class="math">v_{\\mathbb{H}}(X) = X^n - 1</span> .</p>

    <p class="text-gray-300">Input. P receives  <span class="math">(\\mathbb{F},\\mathrm{i},(\\mathsf{w}_i)_{i\\in [l]},(\\mathsf{w}_i)_{i\\in [l + 1,3n]})</span>  and V receives  <span class="math">(\\mathbb{F},(\\mathsf{w}_i)_{i\\in [l]})</span>  and oracle access to the polynomials output by I(F,i).</p>

    <p class="text-gray-300">Online phase: first round. P computes  <span class="math">f_{\\mathrm{pub}}(X), f_L(X), f_R(X), f_O(X)</span>  as described in Eq. (7) and sends  <span class="math">(f_L(X), f_R(X), f_O(X))</span>  to V.</p>

    <p class="text-gray-300">Online phase: second round. Upon receiving challenges  <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span>  from the V, P computes  <span class="math">h_{\\mathrm{ID}}(X), h_{\\sigma}(X)</span>  and a permutation polynomial  <span class="math">s(X)</span>  as described in Eqs. (26) and (27). Then P sends an oracle polynomial  <span class="math">s(X)</span>  to V.</p>

    <p class="text-gray-300">Online phase: third round. Upon receiving challenge  <span class="math">\\alpha \\in \\mathbb{F}</span>  from the V, P computes</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {\\mathcal {C}} (X) = q _ {L} (X) f _ {L} (X) + q _ {R} (X) f _ {R} (X) + q _ {O} (X) f _ {O} (X) \\\\ + q _ {M} (X) f _ {L} (X) f _ {R} (X) + q _ {C} (X) + f _ {\\mathrm {p u b}} (X) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {1} (X) = h _ {\\mathrm {I D}} (X) s (X) - h _ {\\sigma} (X) s (\\zeta X)</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {2} (X) = L _ {1} (X) (s (X) - 1)</span></div>

    <div class="my-4 text-center"><span class="math-block">T (X) = \\frac {F _ {\\mathcal {C}} (X) + F _ {1} (X) \\cdot \\alpha + F _ {2} (X) \\cdot \\alpha^ {2}}{v _ {\\mathbb {H}} (X)}</span></div>

    <p class="text-gray-300">and sends an oracle polynomial  <span class="math">T(X)</span>  to  <span class="math">\\mathsf{V}</span> .</p>

    <p class="text-gray-300">Query phase. V queries online oracles  <span class="math">(f_{L}(X), f_{R}(X), f_{O}(X), s(X), T(X))</span>  and all offline oracles with a random query point  <span class="math">z \\in \\mathbb{F}</span> . Moreover, it makes an additional query to the permutation polynomial  <span class="math">s(X)</span>  with  <span class="math">\\zeta z</span> .</p>

    <p class="text-gray-300">Decision phase. V first computes  <span class="math">f_{\\mathrm{pub}}(X)</span>  as described in the text. Then V constructs  <span class="math">F_{\\mathcal{C}}(z)</span>  (see (18)),  <span class="math">F_{1}(z)</span>  and  <span class="math">F_{2}(z)</span>  based on the outputs of polynomial oracles. It then checks that  <span class="math">(F_{\\mathcal{C}}(z) + F_{1}(z) \\cdot \\alpha + F_{2}(z) \\cdot \\alpha^{2}) = T(z) \\cdot v_{\\mathbb{H}}(z)</span> .</p>

    <p class="text-gray-300">Fig. 11. AHP for  <span class="math">\\mathcal{R}_{\\mathrm{PLONK}}^{\\prime}</span></p>

    <p class="text-gray-300">Fig. 11 describes the underlying  <span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span>  implicit in the final AoK protocol of PLONK. Recall that the goal of PLONK is to verify (1) gate-by-gate constraints by checking  <span class="math">F_{\\mathcal{C}}(X)</span>  vanishes on  <span class="math">\\mathbb{H}</span> , and (2) copy constraints by checking  <span class="math">(f_L, f_R, f_O) = \\sigma(f_L, f_R, f_O)</span> , as described in  <span class="math">\\mathcal{R}_{\\mathsf{PLONK}}&#x27;</span>  of Appendix B.5. Due to the permutation argument from Fig. 10 the second part amounts to checking that polynomials  <span class="math">F_1(X)</span>  and  <span class="math">F_2(X)</span>  vanish on  <span class="math">\\mathbb{H}</span> . A naive way to achieve these would be to let the verifier query polynomial oracles with every point in  <span class="math">\\mathbb{H}</span> , which of course incurs  <span class="math">O(n)</span>  query complexity on verifier's side. This can be circumvented by replacing queries with divisibility check by vanishing polynomial  <span class="math">v_{\\mathbb{H}}(X) = X^n - 1 = \\prod_{i \\in [n]} (X - \\zeta^i)</span> , and by taking random challenge  <span class="math">\\alpha</span>  to batch polynomials  <span class="math">F_{\\mathcal{C}}, F_1</span> , and  <span class="math">F_2</span>  to be divided. From Lemma 4.5 and 4.7 of [GWC19] the  <span class="math">\\mathsf{AHP}_{\\mathsf{PLONK}}</span>  has knowledge soundness. <span class="math">^{10}</span></p>

    <p class="text-gray-300">To achieve ZK the polynomials  <span class="math">f_{L}, f_{R}, f_{O}, s</span>  carrying witness in Fig. 11 have to be slightly adjusted; since these are evaluated at a single point the prover adds random extra terms that lie outside of the degree bounds of the original polynomials. Concretely, now  <span class="math">\\mathsf{P}</span>  commits to</p>

    <div class="my-4 text-center"><span class="math-block">f _ {L} ^ {\\prime} (X) = f _ {L} (X) + (b _ {1} X + b _ {2}) v _ {\\mathbb {H}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">f _ {R} ^ {\\prime} (X) = f _ {R} (X) + (b _ {3} X + b _ {4}) v _ {\\mathbb {H}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">f _ {O} ^ {\\prime} (X) = f _ {O} (X) + (b _ {5} X + b _ {6}) v _ {\\mathbb {H}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">s ^ {\\prime} (X) = s (X) + \\left(b _ {7} X ^ {2} + b _ {8} X + b _ {9}\\right) v _ {\\mathbb {H}} (X)</span></div>

    <p class="text-gray-300">where the so-called masking terms  <span class="math">b_{i}</span>  are randomly chosen from  <span class="math">\\mathbb{F}</span> . The reason why three masking terms are required for  <span class="math">s(X)</span>  is to hide the commitment, and the evaluations at two points  <span class="math">z</span>  and  <span class="math">\\zeta z</span> . Note that this change doesn't affect the correctness, since the additional terms are guaranteed to be divisible by  <span class="math">v_{\\mathbb{H}}(X)</span> . In a similar fashion, the Marlin AHP in the next section can be also made zero-knowledge.</p>

    <p class="text-gray-300">C Marlin Preliminaries</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notations For a finite field <span class="math">\\mathbb{F}</span> and a subset <span class="math">\\mathbb{S}\\subseteq\\mathbb{F}</span>, we denote by <span class="math">v_{\\mathbb{S}}(X)</span> the vanishing polynomial of <span class="math">\\mathbb{S}</span> that is the unique non-zero monic polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero everywhere on </span>\\mathbb{S}<span class="math">. For a matrix </span>M\\in\\mathbb{F}^{n\\times n}<span class="math"> we denote the number of its nonzero entries by </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For two vectors </span>u<span class="math"> and </span>v<span class="math">, we denote by </span>u\\circ v<span class="math"> their Hadamard (component-wise) product. Following <em>[CHM+20]</em>, we denote by </span>\\mathbb{F}^{\\mathbb{S}}<span class="math"> the set of vectors indexed by elements in a finite set </span>\\mathbb{S}<span class="math">. For a function </span>f:\\mathbb{S}\\to\\mathbb{F}<span class="math">, we denote by </span>\\hat{f}<span class="math">, the univariate polynomial over </span>\\mathbb{F}<span class="math"> with degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that agrees with </span>f<span class="math">, that is, </span>\\hat{f}(a)=f(a)<span class="math"> for all </span>a\\in\\mathbb{S}<span class="math">. In particular, the polynomial </span>\\hat{f}$ can be expressed as a linear combination</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{f}(X)=\\sum_{a\\in\\mathbb{S}}f(a)\\cdot L_{a,\\mathbb{S}}(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\left\\{L_{a,\\mathbb{S}}(X)\\right\\}_{a\\in\\mathbb{S}}</span> are the Lagrange basis polynomials of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>L_{a,\\mathbb{S}}(a)=1<span class="math"> and </span>L_{a,\\mathbb{S}}(a^{\\prime})=1<span class="math"> for </span>a^{\\prime}\\in\\mathbb{S}\\setminus\\{a\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For an <span class="math">n\\times n</span> matrix <span class="math">M</span> with rows/columns indexed by elements of <span class="math">\\mathbb{S}</span>, we denote by <span class="math">\\hat{M}(X,Y)</span>, the polynomial of individual degree less than <span class="math">n</span> such that <span class="math">\\hat{M}(s,t)</span> is the <span class="math">(s,t)</span>th entry of <span class="math">M</span> for all <span class="math">s,t\\in\\mathbb{S}</span>.</p>

    <p class="text-gray-300">Define the bivariate polynomial <span class="math">u_{\\mathbb{S}}(X,Y)</span></p>

    <p class="text-gray-300"><span class="math">u_{\\mathbb{S}}(X,Y)\\coloneqq\\frac{v_{\\mathbb{S}}(X)-v_{\\mathbb{S}}(Y)}{X-Y}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">such that $u_{\\mathbb{S}}(X,X)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> is the formal derivative of the vanishing polynomial </span>v_{\\mathbb{S}}(X)<span class="math">. We have that </span>u_{\\mathbb{S}}(X,Y)<span class="math"> vanishes on the square </span>\\mathbb{S}\\times\\mathbb{S}<span class="math">, except on the diagonal. It takes </span>u_{\\mathbb{S}}(a,a)_{a\\in\\mathbb{S}}$ on the diagonal.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">C.1 Univariate sumcheck <em>[BCR+19]</em>.</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a multiplicative subgroup <span class="math">\\mathbb{S}</span> of <span class="math">\\mathbb{F}</span>, a polynomial <span class="math">f(X)</span> sums to <span class="math">\\sigma</span> over <span class="math">\\mathbb{S}</span> if and only if <span class="math">f(X)</span> can be written as $h(X)v_{\\mathbb{S}}(X)+Xg(X)+\\sigma/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for some </span>h(X)<span class="math"> and </span>g(X)<span class="math"> where the degree of </span>\\deg(g)<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">C.2 R1CS Constraint System</h3>

    <h6 id="sec-72" class="text-base font-medium mt-4">Definition 19 (R1CS indexed relation).</h6>

    <p class="text-gray-300">R1CS (Rank-1 constraint satisfiability) indexed relation is the set of tuples</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{i},\\mathsf{x},\\mathsf{w})=\\left((\\mathbb{F},\\mathbb{H},\\mathbb{K},A,B,C),x,w\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">\\mathbb{H}</span> and <span class="math">\\mathbb{K}</span> are subsets of <span class="math">\\mathbb{F}</span>, such that $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>A,B,C<span class="math"> are </span>\\mathbb{H}\\times\\mathbb{H}<span class="math"> matrices over </span>\\mathbb{F}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\max\\left\\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}<span class="math">, and </span>z:=(x,w)<span class="math"> is a vector in </span>\\mathbb{F}^{\\mathbb{H}}<span class="math"> such that </span>Az\\circ Bz=Cz$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Just like PLONK, we assume <span class="math">\\mathbb{H}</span> and <span class="math">\\mathbb{K}</span> are multiplicative subgroups of <span class="math">\\mathbb{F}</span>. We assume efficiently computable bijections <span class="math">\\phi_{\\mathbb{H}}:\\mathbb{H}\\to[n]</span> and <span class="math">\\phi_{\\mathbb{K}}:\\mathbb{K}\\to[m]</span>, and denote the first <span class="math">l</span> elements in <span class="math">\\mathbb{H}</span> and the remaining elements, via sets <span class="math">\\mathbb{H}[\\leq l]\\coloneqq\\left\\{a\\in\\mathbb{H}:\\;1\\leq\\phi_{\\mathbb{H}}(a)\\leq l\\right\\}</span> and <span class="math">\\mathbb{H}[&gt;l]\\coloneqq\\left\\{a\\in\\mathbb{H}:\\;l&lt;\\phi_{\\mathbb{H}}(a)\\leq n\\right\\}</span> respectively. We then denote the first part of the vector <span class="math">z</span> as the public component <span class="math">x\\in\\mathbb{F}^{\\mathbb{H}[\\leq l]}</span> and the second part as witness component <span class="math">w\\in\\mathbb{F}^{\\mathbb{H}[&gt;l]}</span>.</p>

    <h3 id="sec-73" class="text-xl font-semibold mt-8">C.3 Marlin AHP</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now introduce the Marlin AHP, formally described in Fig. 12. In the preprocessing phase, the indexer <span class="math">\\mathsf{I}</span> is given as input a field <span class="math">\\mathbb{F}</span>, subsets <span class="math">\\mathbb{H},\\mathbb{K}</span> of <span class="math">\\mathbb{F}</span>, and matrices <span class="math">A,B,C\\in\\mathbb{F}^{\\mathbb{H}\\times\\mathbb{H}}</span> representing the R1CS instance. The output of the preprocessing phase is three univariate polynomials <span class="math">\\{\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}\\}</span> of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for each matrix </span>M\\in\\{A,B,C\\}<span class="math">, such that the following polynomial is a low-degree extension of </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{M}(X,Y)\\coloneqq\\sum_{k\\in\\mathbb{K}}u_{\\mathbb{H}}(X,\\mathsf{row}_{M}(k))u_{\\mathbb{H}}(Y,\\mathsf{col}_{M}(k))\\mathsf{val}_{M}(k)</span></p>

    <p class="text-gray-300">The three polynomials <span class="math">\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}</span> are the unique low-degree extensions of the functions <span class="math">\\mathsf{row}_{M},\\mathsf{col}_{M},\\mathsf{val}_{M}:K\\to\\mathbb{F}</span> that denote the row index, column index and value of the non-zero entries of the matrix <span class="math">M</span> respectively. Let <span class="math">\\hat{M}(X,Y)</span> be the unique low-degree extension of <span class="math">M</span> that agrees with the matrix <span class="math">M</span> everywhere</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Offline phase. The indexer  <span class="math">\\mathsf{I}</span>  is given as input a field  <span class="math">\\mathbb{F} \\in \\mathcal{F}</span> , subsets  <span class="math">\\mathbb{H}, \\mathbb{K}</span>  of  <span class="math">\\mathbb{F}</span> , and matrices  <span class="math">A, B, C \\in \\mathbb{F}^{n \\times n}</span>  representing the R1CS instance, and outputs three univariate polynomial oracles  <span class="math">\\{\\mathsf{row}_M, \\mathsf{col}_M, \\mathsf{val}_M\\}</span>  of degree less than  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  for each matrix  </span>M \\in A, B, C<span class="math"> , such that the following polynomial is a low-degree extension of  </span>M$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {M} (X, Y) := \\sum_ {k \\in \\mathbb {K}} u _ {\\mathbb {H}} (X, \\operatorname {r o w} _ {M} (k)) u _ {\\mathbb {H}} (Y, \\operatorname {c o l} _ {M} (k)) \\operatorname {v a l} _ {M} (k)</span></div>

    <p class="text-gray-300">Input.  <span class="math">\\mathsf{P}</span>  receives  <span class="math">(\\mathbb{F},\\mathbb{H},\\mathbb{K},A,B,C,\\mathrm{i},x,w)</span> , and  <span class="math">\\mathsf{V}</span>  receives  <span class="math">(\\mathbb{F},\\mathbb{H},\\mathbb{K},x)</span>  and oracle access to the nine polynomials output by  <span class="math">\\mathsf{l}(\\mathbb{F},\\mathsf{i})</span> .</p>

    <p class="text-gray-300">Online phase: first round.  <span class="math">\\mathsf{P}</span>  sends the oracle polynomials  <span class="math">\\hat{w}(X) \\in \\mathbb{F}_{\\leq n-1}[X], h_0(X), \\hat{z}_A(X), \\hat{z}_B(X), \\hat{z}_C(X) \\in \\mathbb{F}_{\\leq n}[X]</span> . It samples a random  <span class="math">s(X) \\in \\mathbb{F}_{&amp;lt;2n}[X]</span>  and sends polynomial oracle  <span class="math">s(X)</span>  together with  <span class="math">\\sigma_1 \\in \\mathbb{F}</span>  where  <span class="math">\\sigma_1 := \\sum_{a \\in \\mathbb{R}} s(a)</span> , and  <span class="math">\\hat{z}_A(X) \\hat{z}_B(X) - \\hat{z}_C(X) = h_0(X) v_{\\mathbb{H}}(X)</span> .</p>

    <p class="text-gray-300">Online phase: second round. Upon receiving challenges  <span class="math">\\alpha, \\eta_A, \\eta_B, \\eta_C \\in \\mathbb{F}</span>  from  <span class="math">\\mathsf{V}</span> ,  <span class="math">\\mathsf{P}</span>  sends oracle polynomials  <span class="math">g_1(X) \\in \\mathbb{F}_{&amp;lt;n-1}[X]</span> ,  <span class="math">h_1(X) \\in \\mathbb{F}_{&amp;lt;n}[X]</span>  to  <span class="math">\\mathsf{V}</span> , where</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s (X) + u _ {\\mathbb {H}} (\\alpha , X) \\left(\\sum_ {M \\in \\{A, B, C \\}} \\eta_ {M} \\hat {z} _ {M} (X)\\right) - \\left(\\sum_ {M \\in \\{A, B, C \\}} \\eta_ {M} r _ {M} (\\alpha , X)\\right) \\hat {z} (X) = h _ {1} (X) v _ {\\mathbb {H}} (X) + X g _ {1} (X) + \\sigma_ {1} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {H}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Online phase: third round. Upon receiving challenge  <span class="math">\\beta_{1} \\in \\mathbb{F}</span>  from the V, P sends oracle polynomials  <span class="math">g_{2}(X), h_{2}(X) \\in \\mathbb{F}_{&amp;lt;n-1}[X]</span>  and  <span class="math">\\sigma_{2} \\in \\mathbb{F}</span>  to V, where  <span class="math">\\sigma_{2} := \\sum_{k \\in \\mathbb{R}} u_{\\mathbb{H}}(\\alpha, k) \\sum_{M \\in \\{A, B, C\\}} \\eta_{M} \\tilde{M}(k, \\beta_{1})</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u _ {\\mathbb {H}} (\\alpha , X) \\sum_ {M \\in \\{A, B, C \\}} \\eta_ {M} \\tilde {M} (X, \\beta_ {1}) = h _ {2} (X) v _ {\\mathbb {H}} (X) + X g _ {2} (X) + \\sigma_ {2} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {H}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Online phase: fourth round. Upon receiving challenge  <span class="math">\\beta_{2} \\in \\mathbb{F}</span>  from the V, P sends oracle polynomials  <span class="math">g_{3}(X) \\in \\mathbb{F}_{&amp;lt;m-1}[X]</span> ,  <span class="math">h_{3}(X) \\in \\mathbb{F}_{&amp;lt;6m-6}[X]</span>  and  <span class="math">\\sigma_{3} \\in \\mathbb{F}</span>  to V, where where  <span class="math">\\sigma_{3} := \\sum_{k \\in \\mathbb{K}} \\sum_{M \\in \\{A, B, C\\}} \\eta_{M} \\frac{v_{\\mathbb{H}}(\\beta_{2}) v_{\\mathbb{H}}(\\beta_{1}) \\hat{\\mathsf{val}}_{M}(k)}{(\\beta_{2} - \\mathsf{row}_{M}(k)) (\\beta_{1} - \\hat{\\mathsf{col}}_{M}(k))}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h _ {3} (X) v _ {\\mathbb {H}} (X) = a (X) - b (X) \\left(X g _ {3} (X) + \\sigma_ {3} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">a (X) = \\sum_ {M \\in \\{A, B, C \\}} \\eta_ {M} v _ {\\mathbb {H}} (\\beta_ {2}) v _ {\\mathbb {H}} (\\beta_ {1}) \\hat {\\mathsf {v a l}} _ {M} (X) \\prod_ {L \\in \\{A, B, C \\} \\setminus \\{M \\}} (\\beta_ {2} - \\mathsf {r o w} _ {L} (X)) (\\beta_ {1} - \\hat {\\mathsf {c o l}} _ {L} (X))</span></div>

    <div class="my-4 text-center"><span class="math-block">b (X) = \\prod_ {M \\in \\{A, B, C \\}} \\left(\\beta_ {2} - \\operatorname {r o w} _ {M} (X)\\right) \\left(\\beta_ {1} - \\operatorname {c o l} _ {M} (X)\\right)</span></div>

    <p class="text-gray-300">Query phase. V queries the oracles  <span class="math">\\hat{w}(X), \\hat{z}_A(X), \\hat{z}_B(X), \\hat{z}_C(X), h_0(X), s(X), h_1(X), g_1(X)</span>  at  <span class="math">\\beta_1</span> ;  <span class="math">h_2(X), g_2(X)</span>  at  <span class="math">\\beta_2</span> ;  <span class="math">h_3(X), g_3(X)</span>  and all offline oracles  <span class="math">\\{\\mathsf{row}_M, \\mathsf{col}_M, \\mathsf{val}_M\\}</span>  for each  <span class="math">M \\in A, B, C</span>  at a random query point  <span class="math">\\beta_3 \\in \\mathbb{F}</span> .</p>

    <p class="text-gray-300">Decision phase. V accepts if the following tests pass:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $h_3(\\beta_3)v_{\\mathbb{K}}(\\beta_3) = a(\\beta_3) - b(\\beta_3)(\\beta_3g_3(\\beta_3) + \\sigma_3 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-  $s(\\beta_1) + u_{\\mathbb{H}}(\\alpha, \\beta_1) \\left( \\sum_M \\eta_M \\hat{z}_M(\\beta_1) \\right) - \\sigma_2 \\hat{z}(\\beta_1) = h_1(\\beta_1) v_{\\mathbb{H}}(\\beta_1) + \\beta_1 g_1(\\beta_1) + \\sigma_1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{H}</td>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{z}_A(\\beta_1)\\hat{z}_B(\\beta_1) - \\hat{z}_C(\\beta_1) = h_0(\\beta_1)v_{\\mathbb{H}}(\\beta_1)</span></li>

    </ul>

    <p class="text-gray-300">Fig.12. AHP for  <span class="math">\\mathcal{R}_{R1CS}</span></p>

    <p class="text-gray-300">on the domain <span class="math">\\mathbb{H}\\times\\mathbb{H}</span>. The prover <span class="math">\\mathsf{P}</span> receives as input the instance <span class="math">x\\in\\mathbb{F}^{\\mathbb{H}[\\leq l]}</span>, a witness <span class="math">w\\in\\mathbb{F}^{\\mathbb{H}[&gt;l]}</span>. The verifier <span class="math">\\mathsf{V}</span> receives as input <span class="math">x</span>, and obtains oracle access to the nine polynomials output at the end of the preprocessing phase.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{x}(X)\\in\\mathbb{F}_{&lt;l}[X]</span> and <span class="math">\\hat{w}(X)\\in\\mathbb{F}_{\\leq n-l}[X]</span> be polynomials that agree with the instance <span class="math">x</span> on <span class="math">\\mathbb{H}[\\leq l]</span>, and with the shifted witness on <span class="math">\\mathbb{H}[&gt;l]</span> respectively. Concretely, these polynomials are defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\hat{x}(X)</span> <span class="math">:=\\sum_{a\\in\\mathbb{H}[\\leq l]}x(a)\\cdot L_{a,\\mathbb{H}[\\leq l]}(X)</span> <span class="math">\\hat{w}(X)</span> <span class="math">:=\\sum_{a\\in\\mathbb{H}[&gt;l]}\\bigg{(}\\frac{w(a)-\\hat{x}(a)}{v_{\\mathbb{H}[\\leq l]}(a)}\\bigg{)}\\cdot L_{a,\\mathbb{H}[&gt;l]}(X)+\\rho\\cdot v_{\\mathbb{H}[&gt;l]}(X)</span></p>

    <p class="text-gray-300">where the second term of <span class="math">\\hat{w}</span> is added to retain zero-knowledge when the number of evaluation queries to <span class="math">\\hat{w}</span> is <span class="math">1</span> (which is the case in Marlin AHP) and <span class="math">\\rho</span> is sampled uniformly at random from <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Let <span class="math">z\\coloneqq(x,w)</span> denote the full assignment. Then the polynomial</p>

    <p class="text-gray-300"><span class="math">\\hat{z}(X):=\\hat{w}(X)\\cdot v_{\\mathbb{H}[\\leq l]}(X)+\\hat{x}(X)</span></p>

    <p class="text-gray-300">agrees with <span class="math">z</span> on <span class="math">\\mathbb{H}</span>. The prover computes the linear combinations <span class="math">z_{A}\\coloneqq Az,z_{B}\\coloneqq Bz,z_{C}\\coloneqq Cz</span>, and sets polynomials <span class="math">\\hat{z}_{A}(X),\\hat{z}_{B}(X),\\hat{z}_{C}(X)\\in\\mathbb{F}_{\\leq n}[X]</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}</span> needs to prove that <span class="math">z_{A},z_{B},z_{C}</span> are obtained as the specified linear combinations of <span class="math">z</span>, and that <span class="math">z_{A}\\circ z_{B}=z_{C}</span>. <span class="math">\\mathsf{P}</span> sends the polynomial <span class="math">h_{0}(X)</span> such that <span class="math">\\hat{z}_{A}(X)\\hat{z}_{B}(X)-\\hat{z}_{C}(X)=h_{0}(X)v_{\\mathbb{H}}(X)</span>, a random <span class="math">s(X)\\in\\mathbb{F}_{&lt;2n}[X]</span> together with its sum over <span class="math">\\mathbb{H}</span>, <span class="math">\\sigma_{1}\\coloneqq\\sum_{a\\in\\mathbb{H}}s(a)</span>. <span class="math">\\mathsf{V}</span> samples <span class="math">\\alpha,\\eta_{A},\\eta_{B},\\eta_{C}</span> randomly from <span class="math">\\mathbb{F}</span> and send them to the prover. <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> engage in a univariate sumcheck protocol to prove that the polynomial <span class="math">q_{1}(X)</span> defined below sums to <span class="math">\\sigma_{1}</span> on <span class="math">H</span>.</p>

    <p class="text-gray-300"><span class="math">q_{1}(X)\\coloneqq s(X)+u_{\\mathbb{H}}(\\alpha,X)\\bigg{(}\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\hat{z}_{M}(X)\\bigg{)}-\\bigg{(}\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}r_{M}(\\alpha,X)\\bigg{)}\\hat{z}(X)</span></p>

    <p class="text-gray-300">where <span class="math">r_{M}(X,Y)\\coloneqq\\sum_{a\\in\\mathbb{H}}u_{\\mathbb{H}}(X,a)\\hat{M}(a,Y)</span>. This is done via three sequential sumchecks.</p>`;
---

<BaseLayout title="ECLIPSE: Enhanced Compiling method for Pedersen-committed zk... (2021/934)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/934
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
