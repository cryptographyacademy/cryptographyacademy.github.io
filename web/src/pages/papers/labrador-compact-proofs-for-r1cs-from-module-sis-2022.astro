---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1341';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'LaBRADOR: Compact Proofs for R1CS from Module-SIS';
const AUTHORS_HTML = 'Ward Beullens, Gregor Seiler';

const CONTENT = `    <p class="text-gray-300">Ward Beullens and Gregor Seiler</p>

    <p class="text-gray-300">IBM Research Europe</p>

    <p class="text-gray-300">Abstract. The most compact quantum-safe proof systems for large circuits are PCP-type systems such as Ligero, Aurora, and Shockwave, that only use weak cryptographic assumptions, namely hash functions modeled as random oracles. One would expect that by allowing for stronger assumptions, such as the hardness of Module-SIS, it should be possible to design more compact proof systems. But alas, despite considerable progress in lattice-based proofs, no such proof system was known so far. We rectify this situation by introducing a Lattice-Based Recursively Amortized Demonstration Of R1CS (LaBRADOR), with more compact proof sizes than known hash-based proof systems, both asymptotically and concretely for all relevant circuit sizes. LaBRADOR proves knowledge of a solution for an R1CS mod <span class="math">2^{64} + 1</span> with <span class="math">2^{20}</span> constraints, with a proof size of only 58 KB, an order of magnitude more compact than previous quantum-safe proofs.</p>

    <p class="text-gray-300">A (publicly-verifiable) system for proving arbitrary binary or arithmetic circuits is a very versatile cryptographic tool that is useful for the construction of many advanced protocols, e.g. in the areas of privacy-preserving cryptography, blockchain systems, and outsourced computation. The presentation of circuit satisfaction problems as rank-one constraint systems (R1CS) provides a convenient abstraction that simplifies proof systems and their comparison. The proof size is often of central importance because the proof needs to be transmitted over a network or stored on a blockchain.</p>

    <p class="text-gray-300">Since many classical cryptographic algorithms will become insecure when large fault-tolerant quantum computers are built, it is important to develop efficient quantum-safe alternatives. Lattice-based cryptography has been very successful at providing quantum-safe basic primitives such as encryption and signature schemes. Lattice-based primitives offer practical output sizes and execution runtimes that are often faster than their classical counterparts, which makes them suitable as drop-in replacements for the classical algorithms. The same can not yet be said for more advanced protocols, and in particular lattice-based proof systems. The (plausibly) quantum-safe proof systems with the most compact proof</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This work is supported by the EU H2020 ERC Project 101002845 PLAZA. Ward Beullens holds Junior Post-Doctoral fellowship 1S95620N from the Research Foundation Flanders (FWO).</li>

    </ul>

    <p class="text-gray-300">sizes for moderate to large statements are hash-based PCP-type systems such as Ligero <em>[x1]</em>, Aurora <em>[BCR^{+}19]</em>, and Brakedown <em>[GLS^{+}21]</em>. Their proof sizes scale sublinearly or even poly-logarithmically with the witness size. There are several lattice-based sublinear-size proof systems <em>[BBC^{+}18, x1, ACL^{+}22]</em> but, even though they rely on much stronger cryptographic assumptions, they are only somewhat practical at best, and can still not compete with the concretely small proof size of the poly-logarithmic PCP-type systems.</p>

    <p class="text-gray-300">Nevertheless, there has been steady progress in practical lattice-based zero-knowledge proof systems, e.g. <em>[x10, x2, x11, x12]</em>. The proof sizes of these systems scale linearly with the witness size, so even though they are efficient for proving small statements, they become inefficient for proving larger statements. The concrete proof size for proving a representative reference statement has been reduced from 3.8 MB in 2017 to 14 KB in 2022 <em>[x17]</em>. This has been achieved with a combination of (1) adapting techniques from non-lattice systems to the lattice setting; (2) finding ways around the unique lattice complications surrounding the requirement that certain vectors have to be short both in the honest execution as well as in the extraction from a prover algorithm; (3) developing new ways to exploit the algebraic structure of (cyclotomic) polynomial rings; and (4) optimizing the techniques and parameters in the resulting huge design space. The somewhat practical sublinear-size proof system from <em>[x20]</em> leverages and improves the insights and techniques developed for linear-size systems, in combination with new techniques that allowed for sublinear scaling.</p>

    <p class="text-gray-300">Contributions. This work introduces a Lattice-Based Recursively Amortized Demonstration Of R1CS (LaBRADOR). LaBRADOR is the first lattice-based proof system that closes the proof-size gap with PCP-type systems and, in fact, improves upon them by a large margin. LaBRADOR builds upon and improves the set of techniques for practical lattice-based proof systems, and uses recursion to achieve very compact proof sizes. For the range of R1CS sizes that is relevant in practice, the proof size is dominated by the cost of the last step of the recursion, which is independent of the size of the R1CS instance. This means the proof size is almost constant in this range. Asymptotically, for R1CS with <span class="math">n</span> constraints, LaBRADOR achieves a proof size of <span class="math">O(\\log n)</span>, which is still a quadratic improvement over the best hash-based PCP-systems such as Aurora, whose proof size is <span class="math">\\Theta(\\log^{2}n)</span>. The LaBRADOR prover and verifier runtime is dominated by <span class="math">O(n)</span> modular multiplications with a modulus <span class="math">q</span> of size <span class="math">O(\\log n)</span> (since <span class="math">q</span> must be bigger than the witness norm; in practice we use a single-precision <span class="math">q\\approx 2^{32}</span> for all our examples).</p>

    <p class="text-gray-300">Concrete sizes. The concrete proof sizes for our protocol are very compact. To prove knowledge of a solution for an R1CS modulo <span class="math">2^{64}+1</span> with a number of constraints ranging from <span class="math">2^{10}</span> to <span class="math">2^{20}</span>, our proof size varies from 47 KB to 58 KB, which is much better than existing post-quantum approaches, especially at the high end of this range. Figure 1 compares our proof sizes with those of Aurora <em>[BCR^{+}19]</em> and Ligero <em>[x1]</em>, obtained by running the open source</p>

    <p class="text-gray-300">libiop implementation, for a field with 64 bits, zero-knowledge disabled, and a soundness error of  <span class="math">2^{-125}</span> , configured to provide provable security. We also compare to Brakedown and Shockwave, using the numbers in  <span class="math">\\mathrm{[GLS^{+}21]}</span> , for a field size of 256 bits and  <span class="math">2^{-128}</span>  soundness error. We remark that one can run Aurora with certain heuristics to significantly improve the proof size at the expense of provable security. Our proof sizes are still smaller than those of optimistic versions of Aurora. Our proof sizes are more than two and three orders of magnitude more compact than those of [NS22] and k-R-ISIS  <span class="math">\\mathrm{[ACL^{+}22]}</span>  respectively. But unlike our work, the proofs from k-R-ISIS have the advantage that the verification time is sublinear in  <span class="math">n</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. Proof sizes of LaBRADOR compared to other SNARKs, for R1CS with a number of constraints varying from  <span class="math">2^{10}</span>  to  <span class="math">2^{20}</span> . The data can be found in Table 1.</p>

    <p class="text-gray-300">Zero-Knowledge Property. The zero-knowledge property is not crucial for sublinear-size proof systems and there are interesting applications for proof systems without zero-knowledge when the proof size is concretely smaller than the witness size. Moreover, achieving zero-knowledge can simply be done by designing a simple linear-sized shim protocol that masks the input witness. The shim can then be composed with our non-zero-knowledge proof system such that the composition is still zero-knowledge and the proof size not much larger than from our system alone. For these reasons we disregard the zero-knowledge property in this work. In all our comparisons to other proof systems we always use the variants that are also not zero-knowledge.</p>

    <p class="text-gray-300">1.1 Technical overview.</p>

    <p class="text-gray-300">Dot product constraints. Our main result is a compact proof of knowledge of a short solution <span class="math">\\vec{\\mathbf{s}}=\\vec{\\mathbf{s}}_{1},\\ldots,\\vec{\\mathbf{s}}_{r}\\in\\mathcal{R}_{q}^{n\\times r}</span> for a system of arbitrarily many dot product constraints, i.e. constraints of the form</p>

    <p class="text-gray-300"><span class="math">f(\\vec{\\mathbf{s}})=\\sum_{1\\leq i,j\\leq r}\\mathbf{a}_{ij}\\langle\\vec{\\mathbf{s}}_{i},\\vec{\\mathbf{s}}_{j}\\rangle+\\sum_{i=1}^{r}\\langle\\vec{\\boldsymbol{\\varphi}}_{i},\\vec{\\mathbf{s}}_{i}\\rangle+\\mathbf{b}=0\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{a}_{ij},\\mathbf{b}\\in\\mathcal{R}_{q}=\\mathbb{Z}_{q}[X]/(X^{d}+1)</span> and <span class="math">\\vec{\\boldsymbol{\\varphi}}_{i}\\in\\mathcal{R}_{q}^{n}</span>. We also allow for dot product constraints where we only require that the constant term of <span class="math">f(\\vec{\\mathbf{s}})</span> is zero. In Section 6 we show that these dot product constraint systems are at least as powerful as R1CSs because proving knowledge of a solution for an R1CS reduces efficiently to proving knowledge of a short solution to a related dot product constraint system.</p>

    <p class="text-gray-300">Recursive composition. Inspired by bulletproof-style arguments <em>[BCC^{+}16, BBB^{+}18]</em>, we want to design a proof of knowledge of a short solution <span class="math">\\vec{\\mathbf{s}}^{(0)}</span> for a dot product constraint system <span class="math">\\mathcal{F}^{(0)}</span>, such that the proof consists of a short part <span class="math">\\pi^{(1)}</span>, and a potentially larger part <span class="math">\\vec{\\mathbf{s}}^{(1)}</span>, where the proof is valid if <span class="math">\\vec{\\mathbf{s}}^{(1)}</span> is itself a short solution to a new dot product constraint system <span class="math">\\mathcal{F}^{(1)}</span>, which can be deduced from <span class="math">\\mathcal{F}^{(0)}</span> and <span class="math">\\pi^{(1)}</span>. We also want that <span class="math">\\vec{\\mathbf{s}}^{(1)}</span> is more compact than the original solution <span class="math">\\vec{\\mathbf{s}}^{(0)}</span>. If we have such a proof system we can recursively apply it to get very compact proofs: we iteratively use the proof system on input <span class="math">(\\mathcal{F}^{(i)},\\vec{\\mathbf{s}}^{(i)})</span> to produce the next proof <span class="math">(\\pi^{(i+1)},\\vec{\\mathbf{s}}^{(i+1)})</span>, where <span class="math">\\vec{\\mathbf{s}}^{(i+1)}</span> is a short solution for some system <span class="math">\\mathcal{F}^{(i+1)}</span>. We do this until we reach some <span class="math">\\vec{\\mathbf{s}}^{I}</span> that is short enough so that it can be sent to the verifier, along with all the short proof pieces <span class="math">\\pi^{(1)},\\ldots,\\pi^{(I)}</span>. The verifier then recomputes <span class="math">\\mathcal{F}^{(I)}</span> from <span class="math">\\mathcal{F}^{(0)}</span> and <span class="math">\\pi^{(1)},\\ldots,\\pi^{(I)}</span>, and only verifies that <span class="math">\\vec{\\mathbf{s}}^{(i+1)}</span> is a short solution to <span class="math">\\mathcal{F}^{I}</span>. We prove (with some generality) that this kind of composition preserves soundness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Amortization. Much like the work of Nguyen and Seiler <em>[x20]</em>, we achieve a sublinear proof size by splitting up the witness in multiple parts <span class="math">\\vec{\\mathbf{s}}=\\vec{\\mathbf{s}}_{1},\\ldots,\\vec{\\mathbf{s}}_{r}</span> (potentially splitting into more parts than in the dot product constraint system we are trying to prove), sending commitments <span class="math">\\vec{\\mathbf{t}}_{i}=\\mathbf{A}\\vec{\\mathbf{s}}_{i}</span> for each of the parts and doing an amortized proof of knowledge of openings. To do the amortized proof, the verifier chooses some challenges <span class="math">\\mathbf{c}_{i}</span>, and the prover sends <span class="math">\\vec{\\mathbf{z}}=\\sum\\mathbf{c}_{i}\\vec{\\mathbf{s}}_{i}</span>. The verifier checks that <span class="math">\\vec{\\mathbf{z}}</span> has small <span class="math">\\ell_{2}</span>-norm, and that and that <span class="math">\\mathbf{A}\\vec{\\mathbf{z}}=\\sum_{i}\\mathbf{c}_{i}\\vec{\\mathbf{t}}_{i}</span>. At the cost of sending <span class="math">O(r^{2})</span> so-called garbage terms and doing some checks, we can augment the proof to also prove that the openings to the <span class="math">\\vec{\\mathbf{t}}_{i}</span> commitments satisfy the dot-product relations. Since the <span class="math">r</span> parts of <span class="math">\\vec{\\mathbf{s}}^{(i)}</span> are folded into <span class="math">\\vec{\\mathbf{z}}</span>, the witness gets shorter by a factor <span class="math">r^{\\prime}</span>, although the size of the coefficients goes up by a factor <span class="math">\\sqrt{r\\tau}</span>, where <span class="math">\\tau</span> is the <span class="math">\\ell_{2}</span>-norm of challenges <span class="math">\\{\\mathbf{c}_{i}\\}_{i\\in[r]}</span>. To prevent the coefficients from growing indefinitely, we decompose <span class="math">\\vec{\\mathbf{z}}=\\vec{\\mathbf{z}}_{0}+b\\vec{\\mathbf{z}}_{1}</span> and set $\\vec{\\mathbf{s}}^{(i+1)}=\\vec{\\mathbf{z}}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{z}}_{1}$ instead.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proving smallness. The amortized proof proves knowledge of an opening of the commitment that satisfies the dot product constraint system, but it does not</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">yet prove that the solution has small <span class="math">\\ell_{2}</span>-norm. To do this, we use an improved version of the modular Johnson-Lindenstrauss lemma of <em>[x10]</em>. This lemma essentially says that random linear projections preserve the <span class="math">\\ell_{2}</span>-norm quite well (up to some scaling factor). This means that instead of checking the <span class="math">\\ell_{2}</span>-norm of <span class="math">\\vec{\\mathbf{s}}</span> directly, we can let the verifier choose a random projection <span class="math">\\Pi:\\mathbb{Z}_{q}^{dn}\\to\\mathbb{Z}_{q}^{256}</span>, drawn from a certain distribution <span class="math">D</span>. The prover then sends <span class="math">p=\\Pi\\vec{\\mathbf{s}}\\mod q</span> to the verifier and proves that <span class="math">p</span> was computed correctly. With our distribution the <span class="math">\\ell_{2}</span>-norm of <span class="math">\\Pi\\vec{\\mathbf{s}}\\mod q</span> is larger than $\\sqrt{30}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{s}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> with overwhelming probability, and smaller than </span>\\sqrt{128}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{s}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> with probability close to </span>1/2<span class="math">. So if </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> is small, then </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{s}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> must have been small as well. The gap between the </span>\\ell_{2}<span class="math">-norm that is proven, and the </span>\\ell_{2}<span class="math">-norm of the real witness is only a factor </span>\\sqrt{128/30}\\approx 2.07<span class="math">. Proving that </span>p<span class="math"> was computed correctly comes for free because </span>p=\\Pi\\vec{\\mathbf{s}}\\mod q<span class="math"> is just </span>256$ additional (constant terms of) dot product constraints, which we can simply add to the list of constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Outer commitments. So far, the <span class="math">i</span>-th iteration of the base protocol reduces the size of the witness by roughly a factor <span class="math">r^{(i)}/2</span>, but it requires communicating a proof <span class="math">\\pi^{(i)}</span> that consists of the <span class="math">r^{(i)}</span> Ajtai commitments <span class="math">\\vec{\\mathbf{t}}_{i}</span> and <span class="math">O(r^{\\prime 2})</span> garbage terms, so a priori we cannot use large <span class="math">r^{(i)}</span> without blowing up the proof size. An important optimization is that instead of sending the commitments <span class="math">\\vec{\\mathbf{t}}_{i}</span> and the garbage terms, the prover just sends a short commitment <span class="math">\\vec{\\mathbf{u}}_{1}</span> to the <span class="math">\\vec{\\mathbf{t}}_{i}</span> and a subset of the garbage terms, and later in the protocol a second short commitment <span class="math">\\vec{\\mathbf{u}}_{2}</span> to the remaining garbage terms. Then we just include <span class="math">\\vec{\\mathbf{t}}_{i}</span> and the garbage terms in <span class="math">\\vec{\\mathbf{s}}^{(i+1)}</span>. We call the <span class="math">\\vec{\\mathbf{u}}_{i}</span> the outer commitment, and the <span class="math">\\vec{\\mathbf{t}}_{i}</span> the inner commitments. This optimization allows us to move material from <span class="math">\\pi^{(i+1)}</span> to <span class="math">\\vec{\\mathbf{s}}^{(i+1)}</span>, which is very beneficial for the proof size of the overall protocol because all the material in <span class="math">\\vec{\\mathbf{s}}^{(i+1)}</span> will be shrunk in the subsequent iterations. This optimization allows us to pick a much larger <span class="math">r^{\\prime(i)}</span>. Asymptotically, $r^{\\prime(i)}=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{s}}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/3})<span class="math"> is optimal, which means that the size of the witness goes from </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{s}}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{s}}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2/3})<span class="math"> with each iteration of the protocol. Therefore, we need only </span>O(\\log\\log n)$ iterations of the base protocol. In practice, using 6 or 7 iterations gives the best results.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-3" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Notation. Let <span class="math">q</span> be a modulus, and let <span class="math">\\mathbb{Z}_{q}</span> be the ring of integers mod <span class="math">q</span>. We denote by <span class="math">\\vec{a}\\in\\mathbb{Z}_{q}^{m}</span> a vector of length <span class="math">m</span>, and by <span class="math">a_{i}\\in\\mathbb{Z}_{q}</span> the <span class="math">i</span>-th entry of <span class="math">\\vec{a}</span>. We denote matrices <span class="math">A\\in\\mathbb{Z}_{q}^{m\\times n}</span> by capital letters. Let <span class="math">d</span> be a power of two, and let <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}_{q}</span> be the rings <span class="math">\\mathbb{Z}[X]/(X^{d}+1)</span> and <span class="math">\\mathbb{Z}_{q}[X]/(X^{d}+1)</span> respectively, where <span class="math">q,d</span> are such that <span class="math">X^{d}+1</span> splits in two irreducible factors mod <span class="math">q</span>. We denote elements of <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}_{q}</span> by boldface letters such as <span class="math">\\mathbf{f}</span>, and vectors of ring elements by <span class="math">\\vec{\\mathbf{a}}</span>. If <span class="math">\\mathbf{f}=a_{0}+a_{1}X+\\cdots+a_{n-1}X^{n-1}\\in R_{n}</span>, then we denote by <span class="math">\\mathsf{ct}\\left(\\mathbf{f}\\right)</span> the constant term of <span class="math">\\mathbf{f}</span>, i.e., <span class="math">\\mathsf{ct}\\left(\\mathbf{f}\\right)=a_{0}</span>. If <span class="math">\\vec{\\mathbf{a}}\\in\\mathcal{R}_{q}^{n}</span> is a vector of ring elements then we denote the <span class="math">i</span>-th entry of <span class="math">\\vec{\\mathbf{a}}</span> by <span class="math">\\mathbf{a}_{i}\\in\\mathcal{R}</span>, and we denote by <span class="math">\\vec{s}\\in\\mathbb{Z}_{q}^{dn}</span> (lowercase) the vector obtained by concatenating the coefficients of all the entries of <span class="math">\\vec{\\mathbf{s}}</span>. We denote matrices <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{m\\times n}</span> by boldface capital letters. If <span class="math">\\vec{\\mathbf{a}}\\in\\mathcal{R}_{q}^{n_{a}}</span> and <span class="math">\\vec{\\mathbf{b}}\\in\\mathcal{R}_{q}^{n_{b}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">are vectors, we denote by $\\vec{\\mathbf{a}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{b}}\\in\\mathcal{R}_{q}^{n_{a}+n_{b}}<span class="math"> the vector obtained by concatenating </span>\\vec{\\mathbf{a}}<span class="math"> and </span>\\vec{\\mathbf{b}}<span class="math">. We denote the set of integers </span>\\{1,\\dots,k\\}<span class="math"> by </span>[k]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For an interactive protocol <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> between two algorithms <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> we write <span class="math">\\langle\\mathcal{P}(a),\\mathcal{V}(b)\\rangle</span> to denote the random variable describing the output of <span class="math">\\mathcal{V}</span> after jointly running <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> where <span class="math">\\mathcal{P}</span> is given <span class="math">a</span> as input and <span class="math">\\mathcal{V}</span> is given <span class="math">b</span> as input.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Challenge Space.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout the paper we let <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> be a challenge space, such that <span class="math">\\mathbf{c}_{1}-\\mathbf{c}_{2}</span> is invertible for any pair of distinct <span class="math">\\mathbf{c}_{1},\\mathbf{c}_{2}</span> in <span class="math">\\mathcal{C}</span>, and such that $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq\\tau<span class="math"> and </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}\\leq T<span class="math"> for all </span>\\mathbf{c}\\in\\mathcal{C}<span class="math">, for some constants </span>\\tau,T\\in\\mathbb{R}$, where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}=\\sup_{\\mathbf{r}\\in\\mathcal{R}}\\frac{\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c}\\mathbf{r}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}{\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{r}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is the operator norm of <span class="math">\\mathbf{c}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our concrete instantiations we use the ring <span class="math">\\mathcal{R}=\\mathbb{Z}_{q}[X]/(X^{64}+1)</span>, and as challenges we use ring elements with 23 zero coefficients, 31 coefficient that are <span class="math">\\pm 1</span>, and 10 coefficients that are <span class="math">\\pm 2</span>. There are more than <span class="math">2^{128}</span> such elements. All these polynomials have <span class="math">l_{2}</span>-norm 71 and we use rejection sampling to restrict to challenges with operator norm at most 15. (On average we need to sample roughly 6 elements before we sample an element <span class="math">\\mathbf{c}</span> with operator $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}<15$.) Differences of distinct challenges are invertible according to <em>[x18, Corollary 1.2]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Weak Commitment Openings.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the analysis of our protocols, we need the notion of a weak commitment opening stemming from <em>[x1, Section 4]</em>. Given an Ajtai commitment <span class="math">\\vec{\\bm{t}}=\\bm{A}\\vec{\\bm{s}}\\in\\mathcal{R}_{q}^{\\kappa}</span>, a weak opening of norm <span class="math">\\beta</span> is a vector <span class="math">\\vec{\\bm{s}}^{<em>}</span> together with a challenge difference <span class="math">\\bar{\\bm{c}}\\in\\mathcal{C}-\\mathcal{C}</span> such that <span class="math">\\vec{\\bm{t}}=\\bm{A}\\vec{\\bm{s}}^{</em>}</span> and $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\bm{c}}\\vec{\\bm{s}}^{*}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math">. The commitment </span>\\vec{\\bm{t}}<span class="math"> is binding for weak openings of norm </span>\\beta<span class="math"> if Module-SIS is hard for rank </span>\\kappa<span class="math"> and norm </span>4T\\beta<span class="math">. If Module-SIS is hard for norm </span>2\\beta<span class="math">, then the commitment is binding for weak openings with the same challenge difference </span>\\bar{\\bm{c}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">The Conjugation Automorphism <span class="math">\\sigma_{-1}</span>.</h4>

    <p class="text-gray-300">For proving dot products <span class="math">\\langle\\vec{a},\\vec{b}\\rangle</span> between coefficient vectors <span class="math">\\vec{a},\\vec{b}\\in\\mathbb{Z}_{q}^{nd}</span> corresponding to polynomial vectors <span class="math">\\vec{\\bm{a}},\\vec{\\bm{b}}\\in\\mathcal{R}_{q}^{n}</span>, we use the observation that <span class="math">\\langle\\vec{a},\\vec{b}\\rangle=\\mathsf{ct}\\left(\\langle\\sigma_{-1}(\\vec{\\bm{a}}),\\vec{\\bm{b}}\\rangle\\right)</span> for the automorphism <span class="math">\\sigma_{-1}\\in\\mathsf{Aut}(\\mathcal{R}_{q})</span> defined by <span class="math">\\sigma_{-1}(X)=X^{-1}</span> that corresponds to <span class="math">-1</span> under <span class="math">\\mathsf{Aut}(\\mathcal{R}_{q})\\cong\\mathbb{Z}_{2d}^{\\times}</span>. This was introduced in <em>[x16]</em>, and the constant coefficient as a handle on dot products in <em>[x10]</em>.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Composing proofs of knowledge</h2>

    <p class="text-gray-300">In this section, we define proofs-of-knowledge and proof-of-knowledge reductions, and we prove that composing proof-of-knowledge reductions preserves soundness.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 3.1 (multi-round public-coin interactive proofs).</h6>

    <p class="text-gray-300">A public-coin interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> is a protocol between a prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span>, where the prover takes as input <span class="math">(x,w)</span>, and the verifier gets <span class="math">x</span> as input. The prover and verifier take turns sending messages, and the prover sends the last message. Finally the verifier outputs <span class="math">V(x,c_{1},\\ldots,c_{k},z_{1},\\ldots,z_{k^{\\prime}})\\in\\{\\texttt{accept},\\texttt{reject}\\}</span>, where <span class="math">V</span> is a verification predicate, <span class="math">z_{1},\\ldots,z_{k^{\\prime}}</span> are the messages sent by the prover, and <span class="math">c_{1},\\ldots,c_{k}</span> are the messages sent by the verifier. Moreover, the verifier chooses its <span class="math">i</span>-th message <span class="math">c_{i}</span> uniformly at random from some challenge set <span class="math">\\mathcal{C}_{i}</span> for all <span class="math">i\\in[k]</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 3.2 (completeness).</h6>

    <p class="text-gray-300">We say that an interactive protocol <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> is a complete proof of knowledge for relation <span class="math">R</span> with failure probability <span class="math">\\epsilon</span> if for all <span class="math">(x,w)\\in R</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle\\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle=\\texttt{accept}]\\geq 1-\\epsilon\\,.</span></p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3.3 (knowledge soundness).</h6>

    <p class="text-gray-300">We say that an interactive protocol <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> is a knowledge-sound proof of knowledge for a relation <span class="math">R</span> with soundness error <span class="math">\\kappa</span> if there exists an oracle algorithm <span class="math">\\mathcal{E}</span> (called the extractor), that runs in expected polynomial time such that for all <span class="math">(x,w)\\in R</span>, and all provers <span class="math">\\mathcal{P}^{*}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[(x,w^{\\prime})\\in R\\mid w^{\\prime}\\leftarrow\\mathcal{E}^{\\mathcal{P}^{<em>}}(x)]\\geq\\epsilon(\\mathcal{P}^{</em>},x)-\\kappa\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon(\\mathcal{P}^{<em>},x)</span> is the success probability of the prover <span class="math">\\mathcal{P}^{</em>}</span> for the statement <span class="math">x</span>, which is defined as</p>

    <p class="text-gray-300"><span class="math">\\epsilon(\\mathcal{P}^{<em>},x)=\\Pr[\\langle\\mathcal{P}^{</em>}(),\\mathcal{V}(x)\\rangle=\\texttt{accept}]\\,.</span></p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 3.4.</h6>

    <p class="text-gray-300">Note that it makes sense for a proof system to be complete with regards to a relation <span class="math">R</span>, and knowledge-sound for a different relation <span class="math">R^{\\prime}</span> (usually <span class="math">R\\subset R^{\\prime}</span>). This is often the case for efficient lattice-based proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An alternative definition for knowledge soundness says that there is an extractor which outputs a witness with probability 1, but which is allowed to run in expected time $O(\\text{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/(\\epsilon(\\mathcal{P}^{<em>},x)-\\kappa))$. Bellare and Goldreich showed that both definitions are equivalent for NP relations </em>[x1]<em>, so we will use both definitions interchangeably. It is well known (see, e.g., </em>[x1]* for a proof) that to prove knowledge soundness it suffices to construct an extractor for deterministic provers.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 3.5 (proof-of-knowledge reduction).</h6>

    <p class="text-gray-300">We say a proof of knowledge <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> for a relation <span class="math">R_{1}</span> is a reduction from <span class="math">R_{1}</span> to <span class="math">R_{2}</span> if the verification predicate of <span class="math">\\mathcal{V}</span> “factors through <span class="math">R_{2}</span>”, by which we mean that :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The last message sent by <span class="math">\\mathcal{P}</span> is a tuple <span class="math">(z^{\\prime}_{k},w_{2})</span>, and</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists an efficient algorithm <span class="math">\\tilde{\\mathcal{V}}</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> accepts the transcript <span class="math">(x_{1},c_{1},\\ldots,c_{k},z_{1},\\ldots,z_{k^{\\prime}},w_{2})</span> <span class="math">\\Longleftrightarrow</span> <span class="math">(\\tilde{\\mathcal{V}}(x_{1},c_{1},\\ldots,c_{k},z_{1},\\ldots,z_{k^{\\prime}}),w_{2})\\in R_{2}</span></p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3.6 (Composition of reductions).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{12}=(\\mathcal{P}_{12},\\mathcal{V}_{12})</span> be a proof-of-knowledge reduction from <span class="math">R_{1}</span> to <span class="math">R_{2}</span> and let <span class="math">\\Pi_{2}=(\\mathcal{P}_{2},\\mathcal{V}_{2})</span> be a proof of knowledge for <span class="math">R_{2}</span>. We define the composition <span class="math">\\Pi_{2}\\circ\\Pi_{12}</span> as the interactive protocol <span class="math">(\\mathcal{P},\\mathcal{V})</span>, where <span class="math">\\mathcal{P}(x_{1},w_{1})</span> and <span class="math">\\mathcal{V}(x_{1})</span> run <span class="math">\\mathcal{P}_{12}(x_{1},w_{1})</span> and <span class="math">\\mathcal{V}_{12}(x_{1})</span>, except that instead of sending <span class="math">w_{2}</span> and letting the verifier check that <span class="math">(x_{2},w_{2})\\in R_{2}</span> for the new statement <span class="math">x_{2}\\leftarrow\\tilde{\\mathcal{V}}(x_{1},c_{1},\\ldots,c_{k},z_{1},\\ldots,z_{k^{\\prime}})</span>, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run <span class="math">\\mathcal{P}_{2}(x_{2},w_{2})</span> and <span class="math">\\mathcal{V}_{2}(x_{2})</span>. The composed verifier <span class="math">\\mathcal{V}(x_{1})</span> accepts if and only if <span class="math">\\mathcal{V}_{2}(x_{2})</span> accepts.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 3.7 (Composition preserves knowledge soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{12}</span> and <span class="math">\\Pi_{2}</span> be proof systems as in Definition 3.6. If <span class="math">\\Pi_{12}</span> and <span class="math">\\Pi_{2}</span> are knowledge sound with soundness error <span class="math">\\kappa_{12}</span> and <span class="math">\\kappa_{2}</span> respectively, then their composition <span class="math">\\Pi_{2}\\circ\\Pi_{12}</span> is a knowledge-sound proof of <span class="math">R_{1}</span> with soundness error <span class="math">\\kappa_{12}+\\kappa_{2}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}_{12}</span> and <span class="math">\\mathcal{E}_{2}</span> be extractors for <span class="math">\\Pi_{12}</span> and <span class="math">\\Pi_{2}</span> respectively. The idea of the proof is that we first use <span class="math">\\mathcal{E}_{2}</span> to construct a prover <span class="math">\\mathcal{P}_{12}^{<em>}</span> for the reduction <span class="math">\\Pi_{12}</span>, and then we extract a witness from <span class="math">\\mathcal{P}_{12}^{</em>}</span> using <span class="math">\\mathcal{E}_{12}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}_{1}^{<em>}</span> be a prover for <span class="math">\\Pi_{2}\\circ\\Pi_{12}</span>. We define a prover <span class="math">\\mathcal{P}_{12}^{</em>}</span> for <span class="math">\\Pi_{12}</span>, that makes use of rewindable oracle access to <span class="math">\\mathcal{P}_{1}^{<em>}</span>, as follows. First, <span class="math">\\mathcal{P}_{12}^{</em>}</span> runs <span class="math">\\mathcal{P}_{1}^{<em>}</span>, outputs what <span class="math">\\mathcal{P}</span> outputs, and forwards the challenges from <span class="math">\\mathcal{V}_{12}</span> to <span class="math">\\mathcal{P}_{1}^{</em>}</span>, until <span class="math">\\mathcal{P}_{1}^{<em>}</span> outputs <span class="math">z_{k^{\\prime}}</span>. Now <span class="math">\\mathcal{P}_{12}^{</em>}</span> will try to use <span class="math">\\mathcal{E}_{2}</span> to come up with a witness <span class="math">w_{2}</span> such that <span class="math">(x_{2},w_{2})\\in R_{2}</span>, where <span class="math">x_{2}=\\tilde{\\mathcal{V}}(x_{1},c_{1},\\ldots,c_{k},z_{1},\\ldots,z_{k^{\\prime}})</span>. But first, <span class="math">\\mathcal{P}_{12}^{<em>}</span> continues running <span class="math">\\mathcal{P}_{13}^{</em>}</span> by simulating an honest verifier <span class="math">\\mathcal{V}_{2}(x_{2})</span>. If the simulated verifier outputs reject, then <span class="math">\\mathcal{P}_{12}^{<em>}</span> aborts. (This step is to control the running time of <span class="math">\\Pi_{12}</span>) Otherwise, if the simulated verifier outputs accept, then <span class="math">\\mathcal{P}_{12}^{</em>}</span> repeatedly rewinds <span class="math">\\mathcal{P}_{1}^{<em>}</span> to the point after it sent <span class="math">z_{k^{\\prime}}</span>, and runs the extractor <span class="math">\\mathcal{E}_{2}(x_{2})</span> with access to <span class="math">\\mathcal{P}_{1}^{</em>}</span>, which acts as a <span class="math">\\Pi_{23}</span>-prover. If the extractor <span class="math">\\mathcal{E}_{2}</span> succeeds and outputs a valid <span class="math">w_{2}</span> such that <span class="math">(x_{2},w_{2})\\in R_{2}</span>, then <span class="math">\\mathcal{P}_{12}^{<em>}</span> outputs this <span class="math">w_{2}</span> and <span class="math">\\mathcal{V}_{1}(x_{1})</span> will accept. After each failed extraction attempt <span class="math">\\mathcal{P}_{12}^{</em>}</span> aborts with probability <span class="math">\\kappa_{2}</span>, otherwise it continues rewinding <span class="math">\\mathcal{P}_{13}^{*}</span> and running <span class="math">\\mathcal{E}_{23}</span>.</p>

    <p class="text-gray-300">We now argue that this prover <span class="math">\\mathcal{P}_{12}^{<em>}</span> has an expected polynomial running time. Fix some randomness <span class="math">r=(r_{1},r_{2})\\in\\{0,1\\}^{\\mathbb{N}}\\times\\{0,1\\}^{\\mathbb{N}}</span>, we denote by <span class="math">\\epsilon</span> the success probability of <span class="math">\\mathcal{P}_{13}</span> when <span class="math">\\mathcal{P}_{1}</span>’s randomness is fixed to <span class="math">r_{1}</span> and when <span class="math">\\mathcal{V}_{12}</span>’s randomness is fixed to <span class="math">r_{2}</span>. Similarly, we define <span class="math">s</span> as the success probability of <span class="math">\\mathcal{E}_{12}</span> of extracting from <span class="math">\\mathcal{P}_{1}</span> conditional on <span class="math">r_{1}</span> and <span class="math">r_{2}</span> being used. If <span class="math">\\mathcal{E}_{12}</span> is an extractor with soundness error <span class="math">\\kappa_{2}</span> then we have <span class="math">s\\geq\\epsilon-\\kappa_{2}</span>. Conditional on the randomness <span class="math">r</span>, if the prover succeeds on the first attempt (which happens with probability <span class="math">\\epsilon</span>), then <span class="math">\\mathcal{P}_{12}^{</em>}</span> starts running <span class="math">\\mathcal{E}_{2}</span>, otherwise it does not run <span class="math">\\mathcal{E}_{2}</span> at all. Therefore, the expected number of extraction attempts is <span class="math">\\epsilon</span> times the inverse of the probability</p>

    <p class="text-gray-300">that the process stops, which is</p>

    <p class="text-gray-300"><span class="math">\\frac{\\epsilon}{s+(1-s)\\kappa_{2}}\\,.</span></p>

    <p class="text-gray-300">Suppose <span class="math">\\epsilon\\leq 2\\kappa_{2}</span>, then</p>

    <p class="text-gray-300"><span class="math">\\frac{\\epsilon}{s+(1-s)\\kappa_{2}}\\leq\\frac{\\epsilon}{\\kappa_{2}}\\leq 2\\,.</span></p>

    <p class="text-gray-300">Otherwise, if <span class="math">\\epsilon\\geq 2\\kappa_{2}</span>, then we have</p>

    <p class="text-gray-300"><span class="math">\\frac{\\epsilon}{s+(1-s)\\kappa_{2}}\\leq\\frac{\\epsilon}{s}\\leq\\frac{\\epsilon}{\\epsilon-\\kappa_{2}}\\leq\\frac{2\\kappa_{2}}{2\\kappa_{2}-\\kappa_{2}}=2.</span></p>

    <p class="text-gray-300">For any fixed choice of randomness <span class="math">r</span> and challenges <span class="math">c</span>, the expected number of extraction attempts is bounded by <span class="math">2</span>, which means that the expected number of extraction attempts over all <span class="math">r</span> and <span class="math">c</span> must also be bounded by <span class="math">2</span>, so <span class="math">\\mathcal{P}_{12}^{*}</span> runs in expected polynomial time.</p>

    <p class="text-gray-300">Now we argue that <span class="math">\\mathcal{P}_{12}^{<em>}</span> has success probability at least <span class="math">\\epsilon(\\mathcal{P}_{1}^{</em>},x_{1})-\\kappa_{2}</span>. Again, we fix randomness <span class="math">r</span>. The prover <span class="math">\\mathcal{P}_{12}^{*}</span> starts running the extractor with probability <span class="math">\\epsilon</span>, and if it starts then the probability that <span class="math">\\mathcal{E}_{23}</span> eventually succeeds is exactly</p>

    <p class="text-gray-300"><span class="math">\\frac{s}{s+(1-s)\\kappa_{2}}\\,.</span></p>

    <p class="text-gray-300">Therefore the success probability of <span class="math">\\mathcal{P}_{12}^{*}</span> conditioned on <span class="math">r</span> being used is</p>

    <p class="text-gray-300"><span class="math">\\frac{\\epsilon s}{s+(1-s)\\kappa_{2}}\\geq\\frac{\\epsilon s}{s+\\kappa_{2}}=\\epsilon\\left(1-\\frac{\\kappa_{2}}{s+\\kappa_{2}}\\right)\\geq\\epsilon\\left(1-\\frac{\\kappa_{2}}{\\epsilon}\\right)=\\epsilon-\\kappa_{2}\\,,</span></p>

    <p class="text-gray-300">where we used that <span class="math">s\\geq\\epsilon-\\kappa_{2}</span>. For any fixed choice of randomness <span class="math">r</span> the success probability of <span class="math">\\mathcal{P}_{12}^{<em>}</span> is at least the success probability of <span class="math">\\mathcal{P}_{13}^{</em>}-\\kappa_{2}</span>, so by taking the average over all <span class="math">r</span> we get <span class="math">\\epsilon(\\mathcal{P}_{12}^{<em>},x_{1})\\geq\\epsilon(\\mathcal{P}_{1}^{</em>},x_{1})-\\kappa_{2}</span>.</p>

    <p class="text-gray-300">Now there is an extractor for <span class="math">\\Pi_{2}\\circ\\Pi_{12}</span> that just runs <span class="math">\\mathcal{E}_{12}</span> on the prover <span class="math">\\mathcal{P}_{12}^{<em>}</span>. This extractor runs in expected polynomial time, and outputs a witness for <span class="math">x_{1}\\in R_{1}</span> with probability <span class="math">\\epsilon(\\mathcal{P}_{12}^{</em>},x_{1})-\\kappa_{12}\\geq\\epsilon(\\mathcal{P}_{1}^{*},x_{1})-\\kappa_{12}-\\kappa_{2}</span>. ∎</p>

    <h2 id="sec-16" class="text-2xl font-bold">4 Modular Johnson-Lindenstrauss Lemma</h2>

    <p class="text-gray-300">In our proof system, we need to prove knowledge of a long vector <span class="math">\\vec{w}\\in\\mathbb{Z}^{d}</span> with small <span class="math">\\ell_{2}</span>-norm. Revealing the entire vector so that the verifier can check that it has small <span class="math">\\ell_{2}</span>-norm would be very costly, so we rely on a version of the Johnson-Lindenstrauss lemma to reduce the dimensionality. The intuition is that random linear projections almost preserve the <span class="math">\\ell_{2}</span>-norm. So, instead of revealing <span class="math">\\vec{w}</span> we let the verifier sample a random linear map <span class="math">\\Pi:\\mathbb{Z}^{d}\\to\\mathbb{Z}^{256}</span>, where the entries of <span class="math">\\Pi</span> are independent and equal to <span class="math">-1,0</span>, or <span class="math">1</span> with probabilities <span class="math">1/4</span>, <span class="math">1/2</span>, and <span class="math">1/4</span> respectively. The prover then only reveals <span class="math">\\Pi\\vec{w}</span>, which is much more compact than the long vector <span class="math">\\vec{w}</span>. One can check that the average of <span class="math">\\left\\lVert\\Pi\\vec{w}\\right\\rVert_{2}</span> is <span class="math">\\sqrt{128}\\left\\lVert\\vec{w}\\right\\rVert_{2}</span>, and Gentry, Halevi, and Lyubashevsky argue that regardless of the vector <span class="math">\\vec{w}</span>, with overwhelming probability, the <span class="math">\\ell_{2}</span>-norm cannot be much higher or lower <em>[x10]</em>.</p>

    <p class="text-gray-300">Lemma 4.1 (Corollary 3.2, [GHL21]). Let <span class="math">\\mathbb{C}</span> be a distribution on <span class="math">\\{-1,0,1\\}</span> with <span class="math">\\operatorname<em>{Pr}[\\mathbb{C} = 0] = 1/2</span>, and <span class="math">\\operatorname</em>{Pr}[\\mathbb{C} = 1] = \\operatorname*{Pr}[\\mathbb{C} = -1] = 1/4</span>, then for every vector <span class="math">\\vec{w} \\in \\mathbb{Z}^d</span> we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname*{Pr}_{\\vec{\\pi} \\leftarrow \\mathbb{C}^d} [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{\\pi}, \\vec{w} \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; 9.5\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2] \\lesssim 2^{-141}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname*{Pr}_{\\Pi \\leftarrow \\mathbb{C}^{256\\times d}} [\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi \\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &lt; \\sqrt{30}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2] \\lesssim 2^{-128}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname*{Pr}_{\\Pi \\leftarrow \\mathbb{C}^{256\\times d}} [\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi \\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &gt; \\sqrt{337}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2] \\lesssim 2^{-128}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, the prover can send <span class="math">\\Pi \\vec{w}</span>, and prove that it is computed correctly. Then, if the verifier sees that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi \\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{30} b<span class="math"> for some bound </span>b<span class="math">, then he is convinced that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math"> is at most </span>b<span class="math">. One caveat is that the prover only proves that </span>\\Pi \\vec{w}<span class="math"> is correct mod </span>q<span class="math">, which might mess up the soundness because </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi \\vec{w} \\mod q\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math"> could be smaller than </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi \\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math">. Gentry, Halevi, and Lyubashevsky prove that, despite the potential reduction mod </span>q<span class="math">, the proof strategy is still sound, on the condition that </span>b &lt; q / 45d<span class="math">. They use a 256-bit prime </span>q<span class="math">, so this restriction is not a problem for them. However, for efficiency reasons we want to use a small modulus </span>q<span class="math"> (e.g. </span>q \\approx 2^{32}<span class="math">), so we strengthen their result to only require </span>b &lt; q / 125$ instead. We believe this lemma could be useful for future works in lattice-based proof systems. Its proof relies on the Berry-Esseen Theorem [Ber41, Ess42], and is given in Appendix A.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 4.2 (strengthening of Corollary 3.3, [GHL21]). Let <span class="math">q \\in \\mathbb{N}</span>, and let <span class="math">\\mathbb{C}</span> be the distribution from lemma 4.1, then for every vector <span class="math">\\vec{w} \\in [\\pm q/2]^d</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\geq b<span class="math"> for some bound </span>b \\leq q/125$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname*{Pr}_{\\Pi \\leftarrow \\mathbb{C}^{256\\times d}} \\left[ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi \\vec{w} \\mod q\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &lt; \\sqrt{30} b \\right] \\lesssim 2^{-128}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-18" class="text-2xl font-bold">5.1 Principal Relation</h2>

    <p class="text-gray-300">We define the principal relation <span class="math">R</span> for our proof system. The relation is parameterized by a rank <span class="math">n \\geq 1</span>, a multiplicity <span class="math">r \\geq 1</span>, and a norm bound <span class="math">\\beta &amp;gt; 0</span>. It consists of short solutions to dot product constraints over <span class="math">\\mathcal{R}_q</span> that can be proven efficiently with lattice techniques. Concretely, a statement consists of a family <span class="math">\\mathcal{F} = (f^{(k)} \\mid k = 1, \\ldots, K)</span> of quadratic dot product functions <span class="math">f \\colon \\mathcal{R}_q^n \\times \\dots \\times \\mathcal{R}_q^n \\to \\mathcal{R}_q</span> (<span class="math">r</span> times) of the form</p>

    <div class="my-4 text-center"><span class="math-block">f(\\vec{\\mathbf{s}}_1, \\dots, \\vec{\\mathbf{s}}_r) = \\sum_{i,j=1}^{r} \\mathbf{a}_{ij} \\langle \\vec{\\mathbf{s}}_i, \\vec{\\mathbf{s}}_j \\rangle + \\sum_{i=1}^{r} \\langle \\vec{\\mathbf{z}}_i, \\vec{\\mathbf{s}}_i \\rangle - \\mathbf{b},</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{a}_{i,j}, \\mathbf{b} \\in \\mathcal{R}_q</span> and <span class="math">\\vec{\\mathbf{z}}_i \\in \\mathcal{R}_q^n</span>. The matrix <span class="math">(\\mathbf{a}_{ij})</span> can be assumed to be symmetric without loss of generality, i.e. <span class="math">\\mathbf{a}_{ij} = \\mathbf{a}_{ji}</span>. Sometimes we are only interested</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in the constant polynomial coefficient of a function <span class="math">f</span>. For such a function all the higher coefficients of the polynomial <span class="math">\\pmb{b}</span> are irrelevant so we do not include them in the statement. This saves space, especially when there are many such functions. We collect these functions in a second family <span class="math">\\mathcal{F}&#x27; = (f&#x27;^{(l)} \\mid l = 1, \\dots, L)</span> in a statement for the relation <span class="math">\\mathcal{R}</span>. Now, a witness consists of <span class="math">r</span> vectors <span class="math">\\vec{s}_1, \\ldots, \\vec{s}_r \\in \\mathcal{R}_q^n</span> such that <span class="math">f(\\vec{s}_1, \\ldots, \\vec{s}_r) = \\mathbf{0}</span> for all <span class="math">f \\in \\mathcal{F}</span>, <span class="math">\\operatorname{ct}(f&#x27;(\\vec{s}_1, \\ldots, \\vec{s}_r)) = 0</span> for all <span class="math">f&#x27; \\in \\mathcal{F}&#x27;</span>, and $\\sum_{i=1}^{r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{s}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2^2 \\leq \\beta^2$. In symbols,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} = \\left\\{ \\begin{array}{c c} &amp; f (\\vec {s} _ {1}, \\ldots , \\vec {s} _ {r}) = \\mathbf {0} \\quad \\forall f \\in \\mathcal {F}, \\\\ (\\left(\\mathcal {F}, \\mathcal {F} ^ {\\prime}, \\beta\\right), (\\vec {s} _ {1}, \\ldots , \\vec {s} _ {r})) &amp; \\left(\\mathcal {F} ^ {\\prime}, \\beta\\right) = 0 \\quad \\forall f ^ {\\prime} \\in \\mathcal {F} ^ {\\prime}, \\\\ &amp; \\sum_ {i = 1} ^ {r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {s} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} ^ {2} \\leq \\beta^ {2} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We reduce R1CS to this relation <span class="math">R</span> in Section 6. In this section, we construct an interactive proof for <span class="math">\\mathcal{R}</span> with very compact proof sizes. Our proof introduces a small amount of slack, which means that it does not exactly prove knowledge of a solution with norm bound <span class="math">\\beta</span>, but only a solution with a norm bound that is slightly bigger, approximately by a factor of two. This does not pose a problem for our reduction from R1CS.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5.2 Main Protocol</h2>

    <p class="text-gray-300">Our main protocol is an interactive proof for the principal relation <span class="math">R</span> that works by committing to the witness vectors, replacing the norm statement with a Johnson-Lindenstrauss projection, aggregating the dot product functions, and amortizing over the witness vectors.</p>

    <p class="text-gray-300"><strong>Committing.</strong> In the first step of the protocol the prover commits to the vectors <span class="math">\\vec{s}_i</span> by computing Ajtai commitments</p>

    <div class="my-4 text-center"><span class="math-block">\\vec {t} _ {i} = \\boldsymbol {A} \\vec {s} _ {i} \\in \\mathcal {R} _ {q} ^ {\\kappa}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{s}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta$ but the commitments must tolerate some slack. Especially because they need to be binding with respect to weak openings extracted from an amortized opening. We handle this in the security analysis of the protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Sending all the <span class="math">\\vec{t}_i</span> would be costly. Therefore the prover again commits to them in a single Ajtai commitment <span class="math">\\vec{u}_1</span> and only sends <span class="math">\\vec{u}_1</span>. This allows to only send the <span class="math">\\vec{t}_i</span> as part of the prover's last message and thus push the <span class="math">\\vec{t}_i</span> to the target relation of the protocol, which can be proven recursively with little cost. The <span class="math">\\vec{t}_i</span> have coefficients that are arbitrary modulo <span class="math">q</span>. So they need to be decomposed into <span class="math">t_1 \\geq 2</span> parts with respect to a small base <span class="math">b_1</span> before committing. That is, one writes <span class="math">\\vec{t}_i = \\vec{t}_i^{(0)} + \\vec{t}_i^{(1)}b_1 + \\dots +\\vec{t}_i^{(t_1 - 1)}b_1^{t_1 - 1}</span> where centered representatives</p>

    <p class="text-gray-300">11</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">modulo <span class="math">b_{1}</span> are used, i.e. $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{t}}^{(k)}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq b_{1}/2<span class="math">. Now let </span>\\vec{\\bm{t}}\\in\\mathcal{R}_{q}^{rt_{1}\\kappa}<span class="math"> be a concatenation of all the decomposition parts </span>\\vec{\\bm{t}}^{(k)}_{i}$. Then we get the Ajtai commitment</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\vec{\\bm{u}}_{1}=\\bm{B}\\vec{\\bm{t}}\\in\\mathcal{R}_{q}^{\\kappa_{1}}\\,,\\;\\;\\;\\text{with}\\;\\;\\;\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{t}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\gamma_{1}\\,.$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\vec{\\bm{u}}_{1}</span> is an <em>outer</em> commitment, and <span class="math">\\vec{\\bm{t}}_{i}</span>, <span class="math">i=1,\\ldots,r</span>, are the <em>inner</em> commitments. The decomposition parameters <span class="math">t_{1},b_{1}</span> and the norm bound <span class="math">\\gamma_{1}</span> are discussed in Subsection 5.4.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Projecting.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, the norm statement in the relation <span class="math">R</span> can be replaced by a Johnson-Lindenstrauss projection. So the verifier sends random matrices <span class="math">\\Pi_{i}\\in\\{-1,0,1\\}^{256\\times nd}</span> for <span class="math">i=1,\\ldots,r</span>. Then the prover sends the projection <span class="math">\\vec{p}=\\sum_{i=1}^{r}\\Pi_{i}\\vec{s}_{i}</span>. The verifier checks that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{p}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{128}\\beta<span class="math">. This is true with probability </span>1/2<span class="math">, but the prover can request projection matrices until it is the case. Moreover, it implies with overwhelming probability that </span>\\sum_{i=1}^{r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{s}}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq(128/30)\\beta^{2}<span class="math">. Here the slack of a factor of </span>\\sqrt{128/30}\\approx 2<span class="math"> is introduced. For proving correct projection, we write </span>\\vec{p}=\\sum_{i}\\Pi_{i}\\vec{s}_{i}<span class="math"> as dot product constraints on the polynomial vectors </span>\\vec{\\bm{s}}_{i}<span class="math">. Let </span>\\vec{\\pi}^{(j)}_{i}<span class="math"> be the </span>j<span class="math">th row of </span>\\Pi_{i}<span class="math"> for </span>j=1,\\ldots,256<span class="math">. Then for each </span>j=1,\\ldots,256$ define the dot product function</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{r}\\langle\\sigma_{-1}(\\vec{\\bm{\\pi}}^{(j)}_{i}),\\vec{\\bm{s}}_{i}\\rangle-p_{j}\\,.</span></p>

    <p class="text-gray-300">These functions do not vanish in <span class="math">\\mathcal{R}_{q}</span> but have zero constant coefficients. So they are of the form of the functions in the family <span class="math">\\mathcal{F}^{\\prime}</span>.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Aggregating.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the first aggregation step, the above functions for proving the JL projection and the functions in <span class="math">\\mathcal{F}^{\\prime}</span> are aggregated to only <span class="math">\\lceil 128/\\log q\\rceil</span> functions with zero constant coefficients by linear combining all functions with uniformly random challenges from <span class="math">\\mathbb{Z}_{q}</span>. This preserves the zero constant coefficients. So the verifier sends <span class="math">\\vec{\\psi}^{(k)}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}(\\mathbb{Z}_{q})^{L}<span class="math"> and </span>\\vec{\\omega}^{(k)}\\in(\\mathbb{Z}_{q})^{256}<span class="math"> for </span>k=1,\\ldots,\\lceil 128/\\log q\\rceil<span class="math">, where </span>L=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{F}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. The prover computes</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f^{\\prime\\prime(k)}(\\vec{\\bm{s}}_{1},\\ldots,\\vec{\\bm{s}}_{r})</span> <span class="math">=\\sum_{l=1}^{L}\\psi_{l}^{(k)}f^{\\prime(l)}(\\vec{\\bm{s}}_{1},\\ldots,\\vec{\\bm{s}}_{r})+\\sum_{j=1}^{256}\\omega_{j}^{(k)}(\\langle\\sigma_{-1}(\\vec{\\bm{\\pi}}^{(j)}_{i}),\\vec{\\bm{s}}_{i}\\rangle-p_{j})</span> <span class="math">=\\sum_{i,j=1}^{r}\\bm{\\alpha}^{\\prime\\prime(k)}\\langle\\vec{\\bm{s}}_{i},\\vec{\\bm{s}}_{j}\\rangle+\\sum_{i=1}^{r}\\langle\\vec{\\bm{\\varphi}}_{i}^{\\prime\\prime(k)},\\vec{\\bm{s}}_{i}\\rangle-b_{0}^{\\prime\\prime(k)}\\,,</span></p>

    <p class="text-gray-300">where <span class="math">b_{0}^{\\prime\\prime(k)}=\\sum_{l}\\psi_{l}^{(k)}b_{0}^{\\prime(l)}+\\langle\\vec{\\omega}^{(k)},\\vec{p}\\rangle</span>. Then the prover extends these integers to full polynomials <span class="math">\\bm{b}^{\\prime\\prime(k)}</span> so that the new functions <span class="math">f^{\\prime\\prime(k)}</span> become completely vanishing and of the same type as the functions in <span class="math">\\mathcal{F}</span>. The prover sends the <span class="math">\\bm{b}^{\\prime\\prime(k)}</span> and the verifier checks that their constant coefficients are correct.</p>

    <p class="text-gray-300">In the second step, we aggregate all functions in <span class="math">\\mathcal{F}</span> together with the new functions. The verifier sends <span class="math">K+\\lceil 128/\\log q\\rceil</span> random challenge polynomials <span class="math">\\vec{\\bm{\\alpha}}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathcal{R}_{q}^{K}$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and <span class="math">\\vec{\\beta} \\leftarrow \\mathcal{R}_q^{\\lceil 128 / \\log q \\rceil}</span>, where $K =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Then, define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} F(\\vec{s}_1, \\dots, \\vec{s}_r) &amp;amp;= \\sum_{k=1}^{K} \\boldsymbol{\\alpha}_k f^{(k)}(\\vec{s}_1, \\dots, \\vec{s}_r) + \\sum_{k=1}^{\\lceil 128 / \\log q \\rceil} \\boldsymbol{\\beta}_k f&#x27;&#x27;(k) \\\\ &amp;amp;= \\sum_{i,j=1}^{r} \\boldsymbol{a}_{ij} \\langle \\vec{s}_i, \\vec{s}_j \\rangle + \\sum_{i=1}^{r} \\langle \\vec{\\varphi}_i, \\vec{s}_i \\rangle - \\boldsymbol{b}. \\end{aligned}</span></div>

    <p class="text-gray-300">Amortizing. Finally, we amortize over the <span class="math">\\vec{s}_i</span>. This means that instead of opening the individual inner commitments <span class="math">\\vec{t}_i</span> by sending all the <span class="math">\\vec{s}_i</span>, the prover opens a random linear-combination <span class="math">\\vec{z} = c_1 \\vec{t}_1 + \\cdots + c_r \\vec{t}_r</span> with challenge polynomials <span class="math">c_i \\in \\mathcal{C} \\subset \\mathcal{R}_q</span> chosen by the verifier. The verifier checks that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{A} \\vec{z} = \\sum_{i=1}^{r} \\boldsymbol{c}_i \\vec{t}_i \\in \\mathcal{R}_q^{\\kappa} \\quad \\text{and} \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\gamma. \\tag{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The aggregated dot product constraint <span class="math">F(\\vec{s}_1, \\ldots, \\vec{s}_r) = \\mathbf{0}</span> is proven probabilistically using the amortized opening <span class="math">\\vec{z}</span>. This works by proving</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\vec{z}, \\vec{z} \\rangle = \\sum_{i,j=1}^{r} \\boldsymbol{g}_{ij} \\boldsymbol{c}_i \\boldsymbol{c}_j, \\quad \\sum_{i=1}^{r} \\langle \\vec{\\varphi}_i, \\vec{z} \\rangle \\boldsymbol{c}_i = \\sum_{i,j=1}^{r} \\boldsymbol{h}_{ij} \\boldsymbol{c}_i \\boldsymbol{c}_j, \\tag{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i,j=1}^{r} \\boldsymbol{a}_{ij} \\boldsymbol{g}_{ij} + \\sum_{i=1}^{r} \\boldsymbol{h}_{ii} - \\boldsymbol{b} = \\mathbf{0},</span></div>

    <p class="text-gray-300">where <span class="math">\\vec{\\varphi}_i \\in \\mathcal{R}_q^n</span> are vectors independent of the challenges <span class="math">\\boldsymbol{c}_i</span>, and the <span class="math">\\boldsymbol{g}_{ij}, \\boldsymbol{h}_{ij}</span> are garbage polynomials that are also independent of the <span class="math">\\boldsymbol{c}_i</span>. If <span class="math">\\boldsymbol{z} = \\boldsymbol{c}_1 \\vec{s}_1 + \\cdots + \\boldsymbol{c}_r \\vec{s}_r</span>, then these equations together imply with low soundness error that</p>

    <div class="my-4 text-center"><span class="math-block">F(\\vec{s}_1, \\dots, \\vec{s}_r) = \\sum_{i,j=1}^{r} \\boldsymbol{a}_{ij} \\langle \\vec{s}_i, \\vec{s}_j \\rangle + \\sum_{i=1}^{r} \\langle \\vec{\\varphi}_i, \\vec{s}_i \\rangle - \\boldsymbol{b} = \\mathbf{0}.</span></div>

    <p class="text-gray-300">Moreover, the garbage matrices <span class="math">(\\boldsymbol{g}_{ij})</span> and <span class="math">(\\boldsymbol{h}_{ij})</span> can be assumed to be symmetric.</p>

    <p class="text-gray-300">This strategy is implemented in the protocol in the following way. The prover computes the garbage polynomials</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{g}_{ij} = \\langle \\vec{s}_i, \\vec{s}_j \\rangle \\quad \\text{and} \\quad \\boldsymbol{h}_{ij} = \\frac{1}{2} \\left( \\langle \\vec{\\varphi}_i, \\vec{s}_j \\rangle + \\langle \\vec{\\varphi}_j, \\vec{s}_i \\rangle \\right)</span></div>

    <p class="text-gray-300">for <span class="math">i, j = 1, \\ldots, r</span>. Then, similarly to the inner commitments <span class="math">\\vec{t}_i</span>, the prover does not directly send the garbage polynomials but produces an outer commitment to them. Here the <span class="math">\\boldsymbol{h}_{ij}</span> are again arbitrary modulo <span class="math">q</span> and hence will be decomposed into <span class="math">t_1</span> parts modulo <span class="math">b_1</span>. On the other hand, the remaining garbage polynomials <span class="math">\\boldsymbol{g}_{ij}</span> are short modulo <span class="math">q</span>. Nevertheless, they are decomposed into <span class="math">t_2 \\geq 2</span> parts</p>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">with respect to a base <span class="math">b_{2}</span> to reduce their width further. Let <span class="math">\\vec{\\bm{g}}\\in\\mathcal{R}_{q}^{t_{2}(r^{2}+r)/2}</span> and <span class="math">\\vec{\\bm{h}}\\in\\mathcal{R}_{q}^{t_{1}(r^{2}+r)/2}</span> be vectors containing all the decomposition parts of all the garbage polynomials. Then the second outer commitment is given by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\vec{\\bm{u}}_{2}=\\bm{C}\\vec{\\bm{g}}+\\bm{D}\\vec{\\bm{h}}\\in\\mathcal{R}_{q}^{\\kappa_{2}}\\quad\\text{with}\\quad\\sqrt{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{g}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{h}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}\\leq\\gamma_{2}.$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that the garbage polynomials <span class="math">\\bm{g}_{ij}</span> are independent of all challenges, not just the <span class="math">\\bm{c}_{i}</span>. Therefore the prover can compute them already at the very beginning of the protocol and include them in the first outer commitment <span class="math">\\vec{\\bm{u}}_{1}</span>. This change allows for a slightly better security proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, the verifier sends the <span class="math">r</span> challenge polynomials <span class="math">\\bm{c}_{1},\\ldots,\\bm{c}_{r}\\stackrel{{\\scriptstyle\\underline{\\mathbf{8}}}}{{{\\leftarrow}}}\\mathcal{C}</span>, and the prover replies with the amortized opening <span class="math">\\vec{\\bm{z}}=\\bm{c}_{1}\\vec{\\bm{s}}_{1}+\\cdots+\\bm{c}_{r}\\vec{\\bm{s}}_{r}</span> and the outer commitment openings <span class="math">\\vec{\\bm{t}},\\vec{\\bm{g}},\\vec{\\bm{h}}</span>. The amortized opening is such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{z}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\gamma$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Verifying.</h4>

    <p class="text-gray-300">The verifier checks that <span class="math">\\vec{\\bm{z}}</span> is an amortized opening with challenges <span class="math">\\bm{c}_{i}</span> for the inner commitments defined by <span class="math">\\vec{\\bm{t}}</span>, and that <span class="math">\\vec{\\bm{t}}</span> and <span class="math">\\vec{\\bm{g}},\\vec{\\bm{h}}</span> are openings for the outer commitments. That is, he checks (1),(2),(4). Moreover, the verifier checks the dot product equations (3) where the vectors <span class="math">\\vec{\\bm{\\varphi}}_{i}</span>, matrix <span class="math">(\\bm{a}_{ij})</span>, and polynomial <span class="math">\\bm{b}</span> are those defining the aggregated function <span class="math">F</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.3 Recursion and Decomposition</h3>

    <p class="text-gray-300">The target relation of our main protocol is almost another instance of the dot product constraint relation <span class="math">R</span>. Indeed, the witness as given by the last prover message consists of four vectors <span class="math">\\vec{\\bm{z}}</span>, <span class="math">\\vec{\\bm{t}}</span>, <span class="math">\\vec{\\bm{g}}</span>, <span class="math">\\vec{\\bm{h}}</span> that must only fulfill equations of dot product type and norm checks in (1),(2),(3),(4). The only difference is that there are three separate norm checks instead of a single global one. But those checks only serve to ensure that the outer and inner commitments are binding. So, when we consolidate the three checks into</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{z}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{t}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{g}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{h}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq\\gamma^{2}+\\gamma_{1}^{2}+\\gamma_{2}^{2},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">we obtain a protocol that is sound for a suitable choice of the commitment ranks <span class="math">\\kappa</span>, <span class="math">\\kappa_{1}</span> and <span class="math">\\kappa_{2}</span>, and whose target relation is exactly another instance of <span class="math">R</span>. A different approach would be to generalize <span class="math">\\mathcal{R}</span> by allowing several norm checks, which could be handled in the protocol with several parallel Johnson-Lindenstrauss projections.</p>

    <p class="text-gray-300">It now follows that the protocol can be recursed to further reduce the proof size. See Section 3 for details and specifically Lemma 3.7 for how this affects the soundness error. The protocol relies on amortization to achieve small proof sizes, so before directly recursing the protocol on the target relation we first decrease the rank and increase the multiplicity by decomposing the witness vectors and rewriting the target relation using the decomposed vectors. We also reduce the width of the masked opening <span class="math">\\vec{\\bm{z}}</span> and decompose it into two additive parts by reducing modulo a base <span class="math">b</span></p>

    <p class="text-gray-300">We start by slightly simplifying the target relation. Notice that all Equations (1)-(4) except the norm checks are linear in the witness vectors <span class="math">\\vec{\\pmb{t}},\\vec{\\pmb{g}},\\vec{\\pmb{h}}</span>. So we may concatenate</p>

    <p class="text-gray-300"><span class="math">\\vec{\\pmb{v}}=\\vec{\\pmb{t}}\\parallel\\vec{\\pmb{g}}\\parallel\\vec{\\pmb{h}}\\in\\mathcal{R}_{q}^{m}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then we can write all equations as linear dot product equations in the single vector <span class="math">\\vec{\\pmb{v}}\\in\\mathcal{R}_{q}^{m}</span>, where <span class="math">m=rt_{1}\\kappa+(t_{1}+t_{2})(r^{2}+r)/2</span>. The global norm check becomes $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\pmb{z}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\pmb{v}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq\\gamma^{2}+\\gamma_{1}^{2}+\\gamma_{2}^{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Decomposing the witness. If we would naively recurse our proof protocol and repeatedly fold the witness, then the coefficients of <span class="math">\\vec{\\mathbf{z}}</span> would quickly blow up. Therefore, we decompose <span class="math">\\vec{\\mathbf{z}}</span> into 2 additive parts by reducing the coefficients of <span class="math">\\vec{\\mathbf{z}}</span> modulo a base <span class="math">b\\geq 2</span>; that is, we write <span class="math">\\vec{\\mathbf{z}}=\\vec{\\mathbf{z}}^{(0)}+b\\vec{\\mathbf{z}}^{(1)}</span> with centered representatives modulo <span class="math">b</span>. The quadratic dot product <span class="math">\\langle\\vec{\\mathbf{z}},\\vec{\\mathbf{z}}\\rangle</span> in Equation (3) transforms to <span class="math">\\langle\\vec{\\mathbf{z}}^{(0)},\\vec{\\mathbf{z}}^{(0)}\\rangle+2b\\langle\\vec{\\mathbf{z}}^{(1)},\\vec{\\mathbf{z}}^{(0)}\\rangle+b^{2}\\langle\\vec{\\mathbf{z}}^{(1)},\\vec{\\mathbf{z}}^{(1)}\\rangle</span>. There is no need to decompose <span class="math">\\vec{\\mathbf{v}}</span> since its width is controlled in the preceding execution of the protocol. So the reduction of <span class="math">\\vec{\\mathbf{z}}</span> can be anticipated and the decomposition bases <span class="math">b_{1}</span> and <span class="math">b_{2}</span> chosen such that <span class="math">b\\approx b_{1}\\approx b_{2}</span>. The final norm check we will use is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{z}}^{(0)}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{z}}^{(1)}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{v}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq\\frac{2}{b^{2}}\\gamma^{2}+\\gamma_{1}^{2}+\\gamma_{2}^{2}=(\\beta^{\\prime})^{2}.$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This implies $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{z}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{z}}^{(0)}+b\\vec{\\mathbf{z}}^{(1)}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(1+b)\\beta^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, to prepare for the next iteration of our protocol, we write the vectors <span class="math">\\vec{\\mathbf{z}}^{(0)},\\vec{\\mathbf{z}}^{(1)}\\in\\mathcal{R}_{q}^{n}</span> as a concatenation of <span class="math">\\nu\\geq 1</span> vectors <span class="math">\\vec{\\mathbf{s}}_{i}^{\\prime}\\in\\mathcal{R}_{q}^{\\lceil n/\\nu\\rceil}</span>, i.e., <span class="math">\\vec{\\mathbf{z}}^{(0)}=\\vec{\\mathbf{s}}_{1}^{\\prime}\\parallel\\cdots\\parallel\\vec{\\mathbf{s}}_{\\nu}^{\\prime}</span>, <span class="math">\\vec{\\mathbf{z}}^{(1)}=\\vec{\\mathbf{s}}_{\\nu+1}^{\\prime}\\parallel\\cdots\\parallel\\vec{\\mathbf{s}}_{2\\nu}^{\\prime}</span>, and similarly we write <span class="math">\\vec{\\mathbf{v}}=\\vec{\\mathbf{s}}_{2\\nu+1}^{\\prime}\\parallel\\cdots\\parallel\\vec{\\mathbf{s}}_{2\\nu+\\mu}^{\\prime}</span> as a concatenation of <span class="math">\\mu</span> vectors <span class="math">\\vec{\\mathbf{s}}_{i}^{\\prime}\\in\\mathcal{R}_{q}^{\\lceil m/\\mu\\rceil}</span>. We then zero-pad all <span class="math">\\vec{\\mathbf{s}}_{i}^{\\prime}</span> to have length <span class="math">n^{\\prime}=\\max\\left\\{\\lceil n/\\nu\\rceil,\\lceil m/\\mu\\rceil\\right\\}</span>. To avoid padding too much, we choose the parameters such that <span class="math">\\frac{n}{\\nu}\\approx\\frac{m}{\\mu}</span>. So, we now have <span class="math">r^{\\prime}=2\\nu+\\mu</span> vectors <span class="math">\\vec{\\mathbf{s}}_{i}^{\\prime}</span> of rank <span class="math">n^{\\prime}</span>.</p>

    <p class="text-gray-300">Now, observe that the final verification equations are the norm check (5), and <span class="math">\\kappa+\\kappa_{1}+\\kappa_{2}+3</span> dot product constraints, i.e., equations that can be written in the form,</p>

    <p class="text-gray-300"><span class="math">g^{(k)}(\\vec{\\mathbf{s}}_{1},\\ldots,\\vec{\\mathbf{s}}_{r^{\\prime}})=\\sum_{i,j=1}^{r^{\\prime}}\\bm{a}_{ij}^{(k)}\\langle\\vec{\\mathbf{s}}_{i},\\vec{\\mathbf{s}}_{j}\\rangle+\\sum_{i=1}^{r^{\\prime}}\\langle\\vec{\\bm{\\varphi}}_{i}^{(k)},\\vec{\\mathbf{s}}_{i}\\rangle-\\bm{b}^{(k)}=\\bm{0}</span> (6)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for <span class="math">k=1,\\ldots,\\kappa+\\kappa_{1}+\\kappa_{2}+3=K^{\\prime}</span>. The matrices <span class="math">(\\bm{a}_{ij}^{(k)})</span> are symmetric and tridiagonal, i.e. <span class="math">\\bm{a}_{ij}=\\bm{a}_{ji}</span>, and <span class="math">\\bm{a}_{ij}=0</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i-j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>1<span class="math">. Furthermore, </span>\\bm{a}_{ij}^{(k)}=\\bm{0}<span class="math"> unless </span>i,j\\leq 2\\nu$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">\\mathcal{G}=\\{g^{(k)}\\mid k=1,\\ldots,K^{\\prime}\\}</span> be the new family of dot product constraints. Then the verifier accepts if and only $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{p}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\sqrt{128}\\beta<span class="math">, </span>b_{0}^{\\prime\\prime(k)}<span class="math"> is correct, and </span>((\\mathcal{G},\\{\\},\\beta^{\\prime}),(\\vec{\\mathbf{s}}_{i}^{\\prime})_{i\\in[r^{\\prime}]})<span class="math"> is in </span>R<span class="math"> with parameters </span>n^{\\prime},r^{\\prime},\\beta^{\\prime}$, so we can indeed compose the protocol with itself recursively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have now finished the description of our protocol. It is completely presented in Figure 2, which includes the consolidated norm statement (5) from this section.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">5.4 Norm Bounds and Decomposition Parameters</h3>

    <p class="text-gray-300">We now study the norm bound <span class="math">\\beta^{\\prime}</span> of the target relation that is derived from the bounds <span class="math">\\gamma,\\gamma_{1},\\gamma_{2}</span> on <span class="math">\\vec{z}</span>, <span class="math">\\vec{t}\\parallel\\vec{g}</span> and <span class="math">\\vec{h}</span>, respectively. The bounds <span class="math">\\gamma_{1}</span> and <span class="math">\\gamma_{2}</span> are in turn derived from the decomposition parameters. The goal of the analysis is to choose bounds that are as small as possible while still being feasible in the honest execution of the protocol. Our analysis is heuristic, rather than worst-case, whenever this is allowed by the security proof. Although we have observed experimentally that our heuristics are highly accurate, it could happen that during an execution of the protocol some quantities are larger than predicted by our analysis. This does not affect the soundness of our proof and only potentially affects the proof size or prover runtime. For security, we need that the commitments are binding with respect to the lengths of the vectors that actually appear in an execution of the protocol. If the vectors turn out longer than expected the prover needs to either restart the protocol until the vectors are short enough, or increase the commitment parameters dynamically to ensure the commitments are binding.</p>

    <p class="text-gray-300">Assume that the <span class="math">\\mathbb{Z}_{q}</span>-coefficients of the vectors <span class="math">\\vec{s}_{i}</span> have standard deviation <span class="math">\\mathfrak{s}=\\beta/\\sqrt{rnd}</span>. Then each <span class="math">\\mathbb{Z}_{q}</span>-coefficient of <span class="math">\\vec{z}</span> is the sum of <span class="math">rd</span> coefficients from the <span class="math">\\vec{s}_{i}</span>, each multiplied with a challenge coefficient. The sum of the coefficients of a challenge polynomial has variance <span class="math">\\tau</span>. So we can model the coefficients of <span class="math">\\vec{z}=\\sum_{i}\\mathbf{c}_{i}\\vec{s}_{i}</span> as Gaussian with standard deviation <span class="math">\\mathfrak{s}\\sqrt{r\\tau}</span>.</p>

    <p class="text-gray-300">Before the next recursion level the vector <span class="math">\\vec{z}</span> is usually decomposed into two parts by reducing it modulo a base <span class="math">b</span>. The coefficients of the low part are uniformly random modulo <span class="math">b</span> and hence have standard deviation essentially <span class="math">b/\\sqrt{12}</span>. The coefficients of the high part are still Gaussian with standard deviation <span class="math">\\mathfrak{s}\\sqrt{r\\tau}/b</span>. If</p>

    <p class="text-gray-300"><span class="math">b=\\left\\lfloor\\sqrt{\\sqrt{12r\\tau}\\mathfrak{s}}\\;\\right\\rfloor,</span></p>

    <p class="text-gray-300">then the low and high coefficients have about the same standard deviation <span class="math">\\mathfrak{s}^{\\prime}=b/\\sqrt{12}\\approx\\mathfrak{s}\\sqrt{r\\tau}/b</span>. This determines how the inner commitments and garbage matrices are decomposed at the current level for producing the outer commitments. Indeed, as already explained, the coefficients of <span class="math">\\vec{t},\\vec{g},\\vec{h}</span> should all have standard deviation similar to <span class="math">\\mathfrak{s}^{\\prime}</span> since together with the parts of <span class="math">\\vec{z}</span> they are going to form the new <span class="math">\\vec{s}_{i}</span>. Recall that in the uniformly random case of <span class="math">\\vec{t}</span> and <span class="math">\\vec{h}</span>, one wants to decompose into <span class="math">t_{1}\\geq 2</span> parts. The minimal base for this is <span class="math">b_{1}=\\lceil q^{1/t_{1}}\\rceil</span>. We want <span class="math">b_{1}\\approx b</span>, and therefore set</p>

    <p class="text-gray-300"><span class="math">t_{1}=\\left\\lfloor\\frac{\\log q}{\\log b}\\right\\rceil.</span></p>

    <p class="text-gray-300">In the Gaussian case of <span class="math">\\vec{g}</span> we first need to analyze the standard deviation of the garbage polynomials <span class="math">\\boldsymbol{g}_{ij}=\\langle\\vec{s}_{i},\\vec{s}_{j}\\rangle</span>. For <span class="math">i\\neq j</span>, each <span class="math">\\mathbb{Z}_{q}</span>-coefficient of <span class="math">\\boldsymbol{g}_{ij}</span> is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier V</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s1, ..., sr ∈ Rnq, ∑i=1r</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">s_i</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2≤ β2</td>

            <td class="px-3 py-2 border-b border-gray-700">φi(k), ai(k), b(k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b(k) = ∑i,j=1r ai(k) ⟨s_i, s_j⟩ + ∑i=1r ⟨φi(k), s_i⟩, k ∈ [K]</td>

            <td class="px-3 py-2 border-b border-gray-700">φi(l), ai(l), b0(l)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  b'(l) = ∑i,j=1r ai(l) ⟨s_i, s_j⟩ + ∑i=1r ⟨φi(l), s_i⟩, l ∈ [L] |   |</p>

    <p class="text-gray-300">|  t_i = A s_i = t_i^{(0)} + ... + t_i^{(t_1-1)} b_1^{t_1-1} |   |</p>

    <p class="text-gray-300">|  g_{ij} = ⟨s_i, s_j⟩ = g_{ij}^{(0)} + ... + g_{ij}^{(t_2-1)} b_2^{t_2-1} |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1 = ∑i=1r ∑k=0t_1-1B_{ik} t_i^{(k)} + ∑i≤j∑k=0t_2-1C_{ijk} g_{ij}^{(k)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">a''(k) = ∑l=1L ψ_l^{(k)} a''(l)</td>

            <td class="px-3 py-2 border-b border-gray-700">ψ(k), ω(k) ω(k) ∈ (Z_q)256</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  φi''(k) = ∑l=1L ψ_l^{(k)} φ_i''(l) + ∑j=1256 ω_j^{(k)} σ_{-1} (π_i^{(j)}) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b''(k) = ∑i,j=1r a''(k) ⟨s_i, s_j⟩ + ∑i=1r ⟨φi''(k), s_i⟩</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b''(k) b0''(k) = ⟨ω(k), p⟩</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  h_{ij} = 1/2 (⟨φ_i, s_j⟩ + ⟨φ_j, s_i⟩) |   |</p>

    <p class="text-gray-300">|  = h_{ij}^{(0)} + ... + h_{ij}^{(t_1-1)} b_1^{t_1-1} |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_2 = ∑i≤j∑k=0t_1-1D_{ijk} h_{ij}^{(k)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 2. Our main Protocol. The common reference string consists of the commitment matrices  <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{\\kappa \\times n}</span> ,  <span class="math">\\mathbf{B}_{ik} \\in \\mathcal{R}_q^{\\kappa_1 \\times \\kappa}</span>  for  <span class="math">1 \\leq i \\leq r</span> ,  <span class="math">0 \\leq k \\leq t_1 - 1</span> ,  <span class="math">\\mathbf{C}_{ijk} \\in \\mathcal{R}_q^{\\kappa_2 \\times 1}</span>  for  <span class="math">1 \\leq i \\leq j \\leq r</span> ,  <span class="math">0 \\leq k \\leq t_2 - 1</span> , and  <span class="math">\\mathbf{D}_{ijk} \\in \\mathcal{R}_q^{\\kappa_2 \\times 1}</span>  for  <span class="math">1 \\leq i \\leq j \\leq r</span> ,  <span class="math">0 \\leq k \\leq t_1 - 1</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 3. Verification algorithm for Figure 2. The algorithm checks that the last prover message is a witness for the target relation, which is an instance of the principal relation from Subsection 5.1. In particular, the algorithm uses the consolidated norm check in Line 14 as discussed in Subsection 5.3. The other checks in Lines 15-20 are of dot product type.</p>

    <p class="text-gray-300">the sum of <span class="math">nd</span> products of two coefficients with standard deviation <span class="math">\\mathfrak{s}</span>. Therefore, we model the coefficients of <span class="math">\\vec{\\bm{g}}_{ij}</span> as Gaussian with standard deviation <span class="math">\\sqrt{nd}\\mathfrak{s}^{2}</span>. On the other hand, for <span class="math">i=j</span>, each coefficient is essentially twice the sum of <span class="math">nd/2</span> products of two coefficients with standard deviation <span class="math">\\mathfrak{s}</span>. Hence, in this case, we model the coefficients as Gaussian with standard deviation <span class="math">\\sqrt{2nd}\\mathfrak{s}^{2}</span>. If they are decomposed into <span class="math">t_{2}</span> parts modulo <span class="math">b_{2}</span>, then the <span class="math">t_{2}-1</span> low parts are uniform with standard deviation <span class="math">b_{2}/\\sqrt{12}</span> and the high part is Gaussian with standard deviation <span class="math">\\sqrt{2nd}\\mathfrak{s}^{2}/b_{2}^{t_{2}-1}</span>. So we want <span class="math">b_{2}=\\left\\lfloor(\\sqrt{24nd}\\mathfrak{s}^{2})^{1/t_{2}}\\right\\rfloor</span>. We also want <span class="math">b_{2}\\approx b</span> and thus</p>

    <p class="text-gray-300"><span class="math">t_{2}=\\left\\lfloor\\frac{\\log(\\sqrt{24nd}\\mathfrak{s}^{2})}{\\log b}\\right\\rfloor.</span></p>

    <p class="text-gray-300">Now we turn to the norms. The coefficients of <span class="math">\\vec{\\bm{z}}</span> are not independent but we found experimentally that the <span class="math">\\ell_{2}</span>-norm is nonetheless around <span class="math">\\mathfrak{s}\\sqrt{r\\tau nd}=\\beta\\sqrt{\\tau}</span>. The same holds for the other vectors <span class="math">\\vec{\\bm{t}}</span> and <span class="math">\\vec{\\bm{g}}\\parallel\\vec{\\bm{h}}</span>. We therefore use the following norm bounds</p>

    <p class="text-gray-300"><span class="math">\\gamma</span> <span class="math">=\\beta\\sqrt{\\tau},</span> <span class="math">\\gamma_{1}</span> <span class="math">=\\sqrt{\\frac{b_{1}^{2}t_{1}}{12}r\\kappa d+\\frac{b_{2}^{2}t_{2}}{12}\\frac{r^{2}+r}{2}d},</span> <span class="math">\\gamma_{2}</span> <span class="math">=\\sqrt{\\frac{b_{1}^{2}t_{1}}{12}\\frac{r^{2}+r}{2}d},</span> <span class="math">\\beta^{\\prime}</span> <span class="math">=\\sqrt{\\frac{2}{b^{2}}\\gamma^{2}+\\gamma_{1}^{2}+\\gamma_{2}^{2}}.</span></p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.5 Security Analysis</h3>

    <p class="text-gray-300">For the completeness of the protocol in Figure 2, one can observe as usual that the verification equations defining the target relation are fulfilled in an honest execution of the protocol. The norm check is also satisfied according to our heuristic analysis from Subsection 5.4. The more interesting part is proving the knowledge soundness of our protocol, under the assumed hardness of Module-SIS. Our result is given in Theorem 5.1, and the proof can be found in Appendix B.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> be the challenge space <span class="math">\\mathcal{C}\\subset\\mathcal{R}_{q}</span> from Section 2 consisting of polynomials with <span class="math">\\ell_{2}</span>-norm <span class="math">\\tau</span> and operator norm <span class="math">T</span>. Suppose that Module-SIS is hard for rank <span class="math">\\kappa_{1}=\\kappa_{2}</span> and norm <span class="math">2\\beta^{\\prime}</span>, and also hard for rank <span class="math">\\kappa</span> and norm <span class="math">\\max(8T(b+1)\\beta^{\\prime},2(b+1)\\beta^{\\prime}+4T\\sqrt{128/30}\\beta)</span>. Further suppose that <span class="math">\\beta\\leq\\sqrt{30/128}q/125</span>. Then the protocol in Figure 2 is a knowledge-sound proof for relation <span class="math">R</span> with soundness error <span class="math">\\varepsilon_{0}=2^{-125}</span> and norm slack <span class="math">\\sqrt{128/30}\\approx 2</span>, i.e. the extractor is only guaranteed to output a witness with norm at most <span class="math">\\sqrt{128/30}\\beta</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 5.2.</h6>

    <p class="text-gray-300">The norm bounds for the hardness of Module-SIS in the Theorem are relative to the norm bound <span class="math">\\beta^{\\prime}</span> in the target relation, i.e. a bound on the</p>

    <p class="text-gray-300">vectors revealed by the prover in his last message. If the protocol is recursed so that the verifier can not directly check the norm, but instead only gets a proof for it with slack <span class="math">\\sqrt{128/30}</span>, then the bounds for the Module-SIS hardness must also be increased by this factor.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.6 No Outer Commitments and Fewer Garbage Polynomials</h3>

    <p class="text-gray-300">In the last level of the recursion, there is no point in producing the outer commitments as their openings are going to be sent at the end of the protocol. Moreover, not committing to the garbage polynomials allows us to use interaction as in <em>[x20]</em> to reduce the number of garbage polynomials. We now explain this modification for the garbage polynomials <span class="math">\\bm{h}_{ij}</span> in the verification equation <span class="math">\\sum_{i}\\langle\\bm{\\vec{\\varphi}}_{i},\\bm{\\vec{z}}\\rangle\\bm{c}_{i}=\\sum_{i,j}\\bm{h}_{ij}\\bm{c}_{i}\\bm{c}_{j}</span>. The <span class="math">r</span> challenges <span class="math">\\bm{c}_{i}</span> are spread out over <span class="math">2r</span> rounds where the prover and verifier alternate between sending garbage polynomials and challenges. In this way the garbage polynomials in the <span class="math">(2i-1)</span>th round can depend on the challenges <span class="math">\\bm{c}_{1},\\ldots,\\bm{c}_{i-1}</span>. This in turn allows us to combine many of the previous garbage polynomials in a single polynomial if it is not necessary to separate between them. In round <span class="math">2i-1</span>, <span class="math">i\\geq 1</span>, the prover sends</p>

    <p class="text-gray-300"><span class="math">\\bm{h}_{2i-1}</span> <span class="math">=\\sum_{1\\leq j&lt;i}\\left(\\langle\\bm{\\vec{\\varphi}}_{j},\\bm{\\vec{s}}_{i}\\rangle+\\langle\\bm{\\vec{\\varphi}}_{i},\\bm{\\vec{s}}_{j}\\rangle\\right)\\bm{c}_{j},</span> <span class="math">\\bm{h}_{2i}</span> <span class="math">=\\langle\\bm{\\vec{\\varphi}}_{i},\\bm{\\vec{s}}_{i}\\rangle.</span></p>

    <p class="text-gray-300">The verifier sends the <span class="math">i</span>th challenge <span class="math">\\bm{c}_{i}</span> in round <span class="math">2i</span>. The verification equation becomes</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{r}\\langle\\bm{\\vec{\\varphi}}_{i},\\bm{\\vec{z}}\\rangle\\bm{c}_{i}=\\sum_{i=1}^{r}\\left(\\bm{h}_{2i-1}\\bm{c}_{i}+\\bm{h}_{2i}\\bm{c}_{i}^{2}\\right).</span></p>

    <p class="text-gray-300">So there are merely <span class="math">2r-1</span> (non-zero) garbage polynomials instead of <span class="math">(r^{2}+r)/2</span> before. This still proves <span class="math">\\bm{h}_{2i}=\\langle\\bm{\\vec{\\varphi}}_{i},\\bm{\\vec{\\varphi}}_{i}\\rangle</span> with soundness error <span class="math">2r/2^{128}</span>. The verifier is only interested in these diagonal terms as only those are needed for the verification equation <span class="math">\\sum_{i,j}\\bm{a}_{ij}\\bm{g}_{ij}+\\sum_{i}\\bm{h}_{2i}=\\bm{b}</span>. The prover can not use later garbage terms to correct any error since in the verification equation the garbage terms are being multiplied by random challenges not known when he needs to send the the garbage terms. Any potential correction gets distorted by the random challenges. See <em>[x20, Lemma 2]</em> for a formal treatment. The same technique can be applied to the other challenge polynomials <span class="math">\\bm{g}_{ij}</span>. In the last iteration of the main protocol the target relation of the previous iteration of the main protocol is proven. The corresponding instance of the principal relation <span class="math">R</span> has multiplicity <span class="math">r=\\nu+\\mu</span> because we choose not to decompose <span class="math">\\bm{\\vec{z}}</span> before the last round of the protocol. Therefore, the only nonzero <span class="math">\\bm{a}_{ij}</span> in all dot product functions have <span class="math">i=j\\leq\\nu</span>. Indeed, the only quadratic function is for proving <span class="math">\\langle\\bm{\\vec{z}},\\bm{\\vec{z}}\\rangle=\\sum_{i,j}\\bm{g}_{ij}\\bm{c}_{i}\\bm{c}_{j}</span> from the previous iteration of the main protocol. Hence, the verifier is only interested in the <span class="math">\\bm{g}_{ii}</span> for <span class="math">i=1,\\ldots,\\nu</span>. By reordering the challenges in the protocol we can now use the verification equation</p>

    <p class="text-gray-300"><span class="math">\\langle\\bm{\\vec{z}},\\bm{\\vec{z}}\\rangle=\\bm{g}_{0}+\\sum_{i=1}^{\\nu}(\\bm{g}_{2i-1}\\bm{c}_{i}+\\bm{g}_{2i}\\bm{c}_{i}^{2})</span></p>

    <p class="text-gray-300">with only <span class="math">2\\nu + 1</span> garbage terms.</p>

    <h2 id="sec-29" class="text-2xl font-bold">5.7 Proof Size</h2>

    <p class="text-gray-300">The size of the non-interactive variant (via Fiat-Shamir) of the main protocol is given by the size of the outer commitments <span class="math">\\vec{u}_1, \\vec{u}_2</span>, the Johnson-Lindenstrauss projection <span class="math">\\vec{p}</span>, and the <span class="math">\\lceil 128 / \\log q \\rceil</span> polynomials <span class="math">\\pmb{b}^{\\prime \\prime(k)}</span> for proving the partial functions <span class="math">\\mathcal{F}&#x27;</span> and the JL projection. For computing the size of <span class="math">\\vec{p}</span> we model the vector as Gaussian distributed with standard deviation <span class="math">\\beta \\sqrt{1/2}</span>. Then using standard tail bounds we assume that each coefficient can be encoded using <span class="math">\\log(12\\beta/\\sqrt{2})</span> bits. Alternatively, one can directly compute the entropy of the Gaussian coefficients. The last prover message only needs to be counted once for the last iteration of the protocol. The challenges can all be expanded from short 128-bit seeds. So, this yields the following proof size in bits:</p>

    <div class="my-4 text-center"><span class="math-block">\\underbrace{(\\kappa_1 + \\kappa_2)d\\log q}_{\\text{Outer commitments}} + \\underbrace{256\\log(12\\beta/\\sqrt{2})}_{\\text{JL projection}} + \\underbrace{\\left\\lceil \\frac{128}{\\log q} \\right\\rceil d\\log q}_{\\text{JL proof}} + \\underbrace{4 \\cdot 128}_{\\text{Challenges}}.</span></div>

    <p class="text-gray-300">The last prover message consisting of masked opening <span class="math">\\vec{z}</span>, inner commitments <span class="math">\\vec{t}_i</span>, and garbage polynomials <span class="math">g_{ij}</span>, <span class="math">h_{ij}</span> has size</p>

    <div class="my-4 text-center"><span class="math-block">\\underbrace{nd\\log\\left(12\\beta\\sqrt{\\tau/nd}\\right)}_{\\vec{z}} + \\underbrace{r\\kappa d\\log q}_{\\vec{t}_i} + \\underbrace{\\frac{r^2 + r}{2}d\\log\\left(12\\sqrt{2/(r^2nd)}\\beta^2\\right)}_{\\vec{g}_{ij}} + \\underbrace{\\frac{r^2 + r}{2}d\\log q}_{\\vec{h}_{ij}}.</span></div>

    <p class="text-gray-300">Optimizing the Recursion Strategy. As explained, for small proof sizes we want to recurse the protocol several times. Essentially until the size of the last prover message is not anymore bigger than an optimal proof for it. The central goal of the recursion is to reduce the witness rank <span class="math">n</span>. This is achieved in each recursion level by the decomposition of the masked opening <span class="math">\\vec{z}</span> into <span class="math">\\nu</span> parts in the construction of the target relation for the next level, c.f. Subsection 5.3. Here it is important to find a good trade-off between a small <span class="math">\\nu</span> that does not reduce the rank by much and hence results in more recursion levels, and a large <span class="math">\\nu</span> that results in a large number of garbage polynomials in the next level. Recall that there are <span class="math">r^2 + r</span> garbage polynomials in the next level for <span class="math">r = 2\\nu + \\mu</span>. The garbage polynomials (and inner commitments) are expanded so that they become approximately as wide as the (reduced) masked opening. So the vectors <span class="math">\\vec{z}^{(0)} \\parallel \\vec{z}^{(1)}</span> and <span class="math">\\vec{v} = \\vec{t} \\parallel \\vec{g} \\parallel \\vec{h}</span> of rank <span class="math">2n</span> and <span class="math">m</span>, respectively, are similarly wide. Then the amortization at the next level is as effective as possible. But there is only one global norm check for the two vectors so we also want their norm to be similar; that is, <span class="math">2n \\approx m</span>. We choose <span class="math">\\nu</span> at each level such that this is the case.</p>

    <h2 id="sec-30" class="text-2xl font-bold">6 Proving R1CS.</h2>

    <p class="text-gray-300">In this section, we show how to reduce rank-1 constraint systems to our dot product constraint systems.</p>

    <p class="text-gray-300">Definition 6.1 (rank-1 constraint system (R1CS).). A rank-1 constraint system of <span class="math">k</span> constraints in <span class="math">n</span> variables consists of three matrices <span class="math">\\mathcal{A},\\mathcal{B},\\mathcal{C} \\in \\mathbb{Z}_N^{k\\times n}</span> modulo an integer <span class="math">N</span>. We say a vector <span class="math">\\vec{w} \\in \\mathbb{Z}_N^n</span> satisfies the system if <span class="math">\\mathcal{A}\\vec{w} \\circ \\mathcal{B}\\vec{w} = \\mathcal{C}\\vec{w}</span>, where <span class="math">\\circ</span> denotes the component-wise product, i.e. <span class="math">(\\vec{a} \\circ \\vec{b})_i = a_i b_i</span>. This defines the R1CS relation mod <span class="math">N</span> as follows</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{R1CS} = \\left\\{ \\begin{array}{c c c} \\left(\\left(\\mathcal{A}, \\mathcal{B}, \\mathcal{C}\\right), (\\vec{w}) \\right) &amp; \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathcal{A}, \\mathcal{B}, \\mathcal{C} \\in \\mathbb{Z}_N^{k \\times n} \\\\ \\vec{w} \\in \\mathbb{Z}_N^n \\\\ \\mathcal{A}\\vec{w} \\circ \\mathcal{B}\\vec{w} = \\mathcal{C}\\vec{w} \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-31" class="text-2xl font-bold">Binary R1CS.</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first give an efficient reduction from <span class="math">R_{R1CS}</span> to <span class="math">R</span>, for binary <span class="math">R1CS</span> (i.e., <span class="math">N = 2</span>). We can compose this reduction with our proof system from section 5 to efficiently prove binary <span class="math">R1CS</span>. Padding with zeros if necessary, we can assume that the number of constraints and the number of variables are multiples of <span class="math">d</span>, the dimension of <span class="math">\\mathcal{R}</span>. The reduction works as follows. The prover sends a commitment $\\vec{\\mathbf{t}} = A(\\vec{\\mathbf{a}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{b}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{c}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}})<span class="math">, where </span>\\vec{w}<span class="math"> is the R1CS witness, and </span>\\vec{a} = \\mathcal{A}\\vec{w}, \\vec{b} = \\mathcal{B}\\vec{w}, \\vec{c} = \\mathcal{C}\\vec{w}<span class="math">. Then we prove knowledge of an opening </span>(\\vec{\\mathbf{a}},\\vec{\\mathbf{b}},\\vec{\\mathbf{c}},\\vec{\\mathbf{w}})<span class="math"> to the commitment </span>\\vec{\\mathbf{t}}<span class="math">, such that indeed </span>\\vec{a} = \\mathcal{A}\\vec{w} \\mod 2, \\vec{b} = \\mathcal{B}\\vec{w} \\mod 2, \\vec{c} = \\mathcal{C}\\vec{w} \\mod 2<span class="math">, such that the coefficients of </span>\\vec{\\mathbf{a}},\\vec{\\mathbf{b}},\\vec{\\mathbf{c}},\\vec{\\mathbf{w}}<span class="math"> are binary, and such that </span>\\vec{a} \\circ \\vec{b} = \\vec{c}$. These are proven as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- To prove that the coefficients of <span class="math">\\vec{\\mathbf{a}}</span> are binary, the prover proves knowledge of <span class="math">\\hat{\\vec{\\mathbf{a}}}</span> such that <span class="math">\\hat{\\vec{\\mathbf{a}}} = \\sigma_{-1}(\\vec{\\mathbf{a}})</span>, and such that the constant term of <span class="math">\\langle \\vec{\\mathbf{a}},\\hat{\\vec{\\mathbf{a}}} -\\mathbf{1}\\rangle</span> is zero. This constant term is equal to <span class="math">\\sum_{i}\\vec{\\mathbf{a}}_{i}(\\vec{\\mathbf{a}}_{i} - 1)\\mod q</span>. The prover also proves that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{a}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{a}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{b}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{b}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{c}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{c}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{w}}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2} &lt; \\sqrt{q}<span class="math">, which implies that </span>\\sum_{i}\\vec{\\mathbf{a}}_{i}(\\vec{\\mathbf{a}}_{i} - 1)<span class="math"> is zero over the integers, meaning that </span>\\vec{\\mathbf{a}}<span class="math"> indeed has binary coefficients. This follows from </span>\\sum_{i}a_{i}(a_{i} - 1)\\leq 2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{a}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{a}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{a}}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2} &lt; q<span class="math">. If </span>n + 3k &lt; 15q / 128<span class="math"> the </span>l_{2}<span class="math">-norm of </span>\\vec{\\mathbf{a}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{a}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{b}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{b}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{c}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{c}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\vec{\\mathbf{w}}}<span class="math"> is smaller than </span>\\sqrt{q}<span class="math"> by at least the slack factor </span>\\sqrt{128 / 30}<span class="math">, so we can prove this with the main protocol of Section 5. The main protocol also supports supports </span>\\mathbb{Z}_q<span class="math">-linear equations such as </span>\\hat{\\vec{\\mathbf{a}}} = \\sigma_{-1}(\\vec{\\mathbf{a}})<span class="math">, constant terms of inner-product relations over </span>\\mathcal{R}_q<span class="math"> such as </span>\\langle \\vec{\\mathbf{a}},\\hat{\\vec{\\mathbf{a}}} -\\mathbf{a}\\rangle<span class="math">. Proving that the coefficients of </span>\\vec{\\mathbf{b}},\\vec{\\mathbf{c}}<span class="math">, and </span>\\vec{\\mathbf{w}}$ are binary is handled in the same way.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To prove that <span class="math">\\vec{a} \\circ \\vec{b} = \\vec{c}</span>, we use the observation that for integers <span class="math">a, b, c \\in \\{0,1\\}</span> we have <span class="math">ab = c</span> if and only if <span class="math">a + b - 2c \\in \\{0,1\\}</span>. A similar observation was used in [GOS12]. So the prover just has to prove that <span class="math">\\vec{a} + \\vec{b} - 2\\vec{c}</span> has binary coefficients, which he does by proving that the constant term of <span class="math">\\langle \\vec{\\mathbf{a}} + \\vec{\\mathbf{b}} - 2\\vec{\\mathbf{c}}, \\hat{\\vec{\\mathbf{a}}} + \\hat{\\vec{\\mathbf{b}}} - 2\\hat{\\vec{\\mathbf{c}}} - \\mathbf{1} \\rangle</span> is zero mod <span class="math">q</span>, which implies it is zero over the integers, because <span class="math">\\sum_{i}(a_{i} + b_{i} - 2c_{i})(a_{i} + b_{i} - 2c_{i} - 1) \\leq 6k &amp;lt; q</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rather than proving the <span class="math">3k</span> linear relations <span class="math">\\vec{a}&#x27; = \\mathcal{A}\\vec{w}&#x27;, \\vec{b}&#x27; = \\mathcal{B}\\vec{w}&#x27;, \\vec{c}&#x27; = \\mathcal{C}\\vec{w}&#x27;</span> modulo 2 separately, we use the usual technique of first combining them into fewer relations. To do this, the verifier chooses, <span class="math">l \\mathbb{F}_2</span>-linear combinations of</li>

    </ul>

    <p class="text-gray-300">the equations at random, and then the prover proves that only these <span class="math">l</span> equations are satisfied. This results in a soundness error of <span class="math">2^{-l}</span>. Concretely, the verifier sends <span class="math">\\{\\vec{\\alpha}_i,\\vec{\\beta}_i,\\vec{\\gamma}_i\\}_{i\\in [l]}</span>, the binary coefficients of the <span class="math">l</span> linear combinations. The prover and the verifier both compute</p>

    <div class="my-4 text-center"><span class="math-block">\\vec {\\delta} _ {i} = \\operatorname {L i f t} \\left(\\alpha_ {i} \\mathcal {A} ^ {\\mathsf {T}} + \\beta_ {i} \\mathcal {B} ^ {\\mathsf {T}} + \\gamma_ {i} \\mathcal {C} ^ {\\mathsf {T}} \\mod 2\\right) \\in \\mathbb {Z} _ {q} ^ {d n}</span></div>

    <p class="text-gray-300">such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\langle \\alpha_ {i}, \\vec {\\mathbf {a}} - \\mathcal {A} \\vec {\\mathbf {w}} \\rangle + \\langle \\beta_ {i}, \\vec {\\mathbf {b}} - \\mathcal {B} \\vec {\\mathbf {w}} \\rangle + \\langle \\gamma_ {i}, \\vec {\\mathbf {c}} - \\mathcal {C} \\vec {\\mathbf {w}} \\rangle \\\\ = \\langle \\alpha_ {i}, \\vec {\\mathbf {a}} \\rangle + \\langle \\beta_ {i}, \\vec {\\mathbf {b}} \\rangle + \\langle \\gamma_ {i}, \\vec {\\mathbf {c}} \\rangle - \\langle \\delta_ {i}, \\vec {\\mathbf {w}} \\rangle \\mod 2 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The prover responds with <span class="math">g_{i} = \\langle \\alpha_{i},\\vec{\\mathbf{a}}\\rangle +\\langle \\beta_{i},\\vec{\\mathbf{b}}\\rangle +\\langle \\gamma_{i},\\vec{\\mathbf{c}}\\rangle -\\langle \\delta_{i},\\vec{\\mathbf{w}}\\rangle \\in \\mathbb{Z}_{q}</span> for all <span class="math">i</span> in <span class="math">[l]</span>. Note that there cannot be an overflow mod <span class="math">q</span>, if we assume <span class="math">n + 3k &amp;lt; q</span>, and we prove that <span class="math">\\vec{a},\\vec{b},\\vec{c},\\vec{w}</span> have binary coefficients. The verifier checks that the <span class="math">g_{i}</span> are indeed 0 mod 2. Then it is proven that the <span class="math">g_{i}</span> are computed correctly mod <span class="math">q</span>, which can be delegated to the protocol of Section 5 because these are a small number of <span class="math">\\mathbb{Z}_q</span>-linear equations on the coefficient vectors of the witness.</p>

    <p class="text-gray-300">The full protocol is given in Figure 4, where with some abuse of notation we define two sets of inner product functions over <span class="math">\\mathcal{R}_q</span>. (where <span class="math">\\mathbb{Z}_q</span>-linear functions <span class="math">f</span> should be interpreted as the unique <span class="math">\\mathcal{R}_q</span>-linear function <span class="math">f&#x27;</span> such that <span class="math">\\operatorname{ct}(f&#x27;) = f</span>.)</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathcal {F} _ {1} = \\{A (\\vec {\\mathbf {a}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {b}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {c}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {w}}) - \\vec {\\mathbf {t}} \\} \\\\ \\mathcal {F} _ {2} = \\{\\tilde {\\vec {\\mathbf {a}}} = \\sigma_ {- 1} (\\vec {\\mathbf {a}}), \\quad \\tilde {\\vec {\\mathbf {b}}} = \\sigma_ {- 1} (\\vec {\\mathbf {b}}), \\quad \\tilde {\\vec {\\mathbf {c}}} = \\sigma_ {- 1} (\\vec {\\mathbf {c}}), \\quad \\tilde {\\vec {\\mathbf {w}}} = \\sigma_ {- 1} (\\vec {\\mathbf {w}}), \\\\ \\langle \\vec {\\mathbf {a}}, \\tilde {\\vec {\\mathbf {a}}} - \\mathbf {1} _ {\\mathbf {k} / \\mathbf {d}} \\rangle , \\quad \\langle \\tilde {\\mathbf {b}}, \\quad \\tilde {\\tilde {\\mathbf {b}}} - \\mathbf {1} _ {\\mathbf {k} / \\mathbf {d}} \\rangle , \\\\ \\langle \\vec {\\mathbf {c}}, \\tilde {\\vec {\\mathbf {c}}} - \\mathbf {1} _ {\\mathbf {k} / \\mathbf {d}} \\rangle , \\quad \\langle \\tilde {\\mathbf {w}}, \\tilde {\\tilde {\\mathbf {w}}} - \\mathbf {1} _ {\\mathbf {n} / \\mathbf {d}} \\rangle , \\\\ \\langle \\vec {\\mathbf {a}} + \\vec {\\mathbf {b}} - 2 \\vec {\\mathbf {c}}, \\tilde {\\vec {\\mathbf {a}}} + \\tilde {\\vec {\\mathbf {b}}} - 2 \\tilde {\\vec {\\mathbf {c}}} - \\mathbf {1} \\rangle \\} \\\\ \\cup \\left\\{\\left\\langle \\alpha_ {i}, \\vec {a} \\right\\rangle + \\left\\langle \\beta_ {i}, \\vec {b} \\right\\rangle + \\left\\langle \\gamma_ {i}, \\vec {c} \\right\\rangle - \\left\\langle \\delta_ {i}, \\vec {w} \\right\\rangle - g _ {i} \\right\\} _ {i \\in [ \\lambda ]}. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Theorem 6.2. If <span class="math">n + 3k &amp;lt; q</span> and <span class="math">6k &amp;lt; q</span>, then the proof of knowledge reduction of Figure 4 is computationally knowledge-sound with soundness error <span class="math">2^{-l}</span>, under the assumption that <span class="math">\\mathsf{MSIS}_{m,2n + 6k}</span> is hard with an <span class="math">l_{\\infty}</span>-norm bound of 1. Moreover, if <span class="math">n + 3k &amp;lt; 15q / 128</span>, then there is enough slack to compose the reduction with the main protocol of Section 5.</p>

    <h2 id="sec-32" class="text-2xl font-bold">R1CS modulo <span class="math">2^{d} + 1</span></h2>

    <p class="text-gray-300">We now give a way to prove knowledge of a witness for an R1CS instance modulo <span class="math">2^{d} + 1</span>. We use the ring morphism of evaluating at <span class="math">X = 2</span></p>

    <div class="my-4 text-center"><span class="math-block">\\varphi : \\mathcal {R} \\rightarrow \\mathbb {Z} _ {2 ^ {d} + 1}: \\sum_ {i = 0} ^ {d - 1} a _ {i} X ^ {i} \\mapsto \\sum_ {i = 0} ^ {d - 1} a _ {i} 2 ^ {i} \\mod 2 ^ {d} + 1.</span></div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 4. Proof of knowledge reduction from binary R1CS to  <span class="math">R</span> .</p>

    <p class="text-gray-300">Using the non-adjacent form [Rei60], we can encode each element <span class="math">a \\in \\mathbb{Z}_{2^d + 1}</span> as an element <span class="math">Enc(a) \\in \\mathcal{R}_q</span> with coefficients in <span class="math">\\{-1, 0, 1\\}</span> and with <span class="math">l_2</span>-norm at most <span class="math">\\sqrt{d/2}</span>, such that <span class="math">\\varphi(\\mathrm{Lift}(Enc(a))) = a</span>. We then have <span class="math">\\varphi(\\mathrm{Lift}(Enc(a)Enc(b))) = ab \\mod 2^d + 1</span>, as long as no overflow mod <span class="math">q</span> happens in the multiplication of the encodings.</p>

    <p class="text-gray-300">In our proof system for R1CS mod <span class="math">2^d + 1</span>, the prover commits to small encodings of <span class="math">\\mathcal{A}\\vec{w}, \\mathcal{B}\\vec{w}, \\mathcal{C}\\vec{w}</span>, and <span class="math">\\vec{w}</span> in <span class="math">\\mathcal{R}_q</span>, and proves knowledge of an opening with <span class="math">l_2</span>-norm <span class="math">&amp;lt; \\beta</span> (where <span class="math">\\beta</span> is small enough to ensure the commitment is binding under MSIS) that encodes <span class="math">\\vec{a}, \\vec{b}, \\vec{c}, \\vec{w} \\in \\mathbb{Z}_{2^d + 1}</span> that is well-formed (meaning that <span class="math">\\vec{a} = \\mathcal{A}\\vec{w}</span>, etc.), and which additionally satisfies the quadratic constraints <span class="math">\\vec{a} \\circ \\vec{b} = \\vec{c}</span>. The strategy to prove the quadratic constraints is to let the verifier send <span class="math">l</span> challenge vectors <span class="math">\\varphi_i \\in \\mathbb{Z}_{d^2 + 1}^k</span>, and let the prover prove that <span class="math">\\langle \\varphi_i, \\vec{a} \\circ \\vec{b} - \\vec{c} \\rangle = 0</span> for all <span class="math">i \\in [l]</span>. This has soundness error <span class="math">p^{-l}</span>, where <span class="math">p</span> is the smallest prime factor of <span class="math">2^d + 1</span>. For example, the smallest prime factor of <span class="math">2^{64} + 1</span> is 18 bits long, so we can choose <span class="math">l = \\lceil 128 / 18 \\rceil = 8</span> to get a negligible soundness error <span class="math">^1</span>. To prove <span class="math">\\langle \\varphi_i, \\vec{a} \\circ \\vec{b} - \\vec{c} \\rangle = 0 \\mod 2^d + 1</span>, the prover computes <span class="math">\\vec{d}_i = \\varphi_i \\circ \\vec{a}</span> for all <span class="math">i \\in [l]</span> and commits to small encoding of these in <span class="math">\\mathcal{R}_q</span>. Then the prover proves knowledge of a short opening that encodes <span class="math">\\vec{d}_i</span> such that <span class="math">\\varphi_i \\circ \\vec{\\mathbf{a}} = \\vec{d}_i</span>, and <span class="math">\\langle \\vec{d}_i, \\mathcal{B}\\vec{w} \\rangle = \\langle \\varphi_i, \\mathcal{C}\\vec{w} \\rangle</span>.</p>

    <p class="text-gray-300">The relations <span class="math">\\mathcal{A}\\vec{w} - \\vec{a} = 0, \\mathcal{B}\\vec{w} - \\vec{b} = 0, \\mathcal{C}\\vec{w} - \\vec{c} = 0, \\varphi_i \\circ \\vec{a} - \\vec{d}_i = 0, \\langle \\vec{d}_i, \\vec{b} \\rangle - \\langle \\varphi_i, \\vec{c} \\rangle = 0 \\mod X - 2</span> are all linear relations or dot product relations. We let the verifier send <span class="math">l</span> sets of challenges in <span class="math">\\mathbb{Z}_{2^d + 1}</span> to aggregate the equations into <span class="math">l</span> linear combinations. This aggregation step also has a soundness error of <span class="math">p^{-l}</span>, where <span class="math">p</span> is the largest prime factor of <span class="math">2^d + 1</span>. Concretely, the verifier sends a challenge vectors <span class="math">c^{(i)} = (\\alpha^{(i)}, \\beta^{(i)}, \\gamma^{(i)}, \\delta_1^{(i)}, \\ldots, \\delta_l^{(i)}) \\in \\mathbb{Z}_{2^d + 1}^{k \\times l + 3}</span>, which defines the <span class="math">l</span> linear combinations</p>

    <p class="text-gray-300">$$ \\begin{array}{l} f_i(\\vec{a}, \\vec{b}, \\vec{c}, \\vec{w}, \\{\\vec{d}_i\\}) := \\langle \\alpha^{(i)}, \\mathcal{A}\\vec{w} - \\vec{a} \\rangle + \\langle \\beta^{(i)}, \\mathcal{B}\\vec{w} - \\vec{b} \\rangle + \\langle \\gamma^{(i)}, \\mathcal{C}\\vec{w} - \\vec{c} \\rangle \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\langle \\vec{d}_i, \\vec{b} \\rangle - \\langle \\varphi_i, \\vec{c} \\rangle + \\sum_{j=1}^{l} \\langle \\delta_j^{(i)}, \\varphi_i \\circ \\vec{a} - \\vec{d}_i \\rangle.</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Let <span class="math">\\vec{\\mathbf{a}}, \\vec{\\mathbf{b}}, \\vec{\\mathbf{c}}, \\vec{\\mathbf{w}}</span> and the <span class="math">\\vec{\\mathbf{d}}_i</span> be the short encodings of <span class="math">\\vec{a}, \\vec{b}, \\vec{c}, \\vec{w}</span> and the <span class="math">\\vec{d}_i</span> respectively, and let <span class="math">\\tilde{f}_i(\\vec{\\mathbf{a}}, \\vec{\\mathbf{b}}, \\vec{\\mathbf{c}}, \\vec{\\mathbf{w}}, \\{\\vec{\\mathbf{d}}_i\\})</span> be the dot product function over <span class="math">\\mathcal{R}_q</span> obtained by replacing all the coefficients of <span class="math">f_i(\\vec{a}, \\vec{b}, \\vec{c}, \\{\\vec{d}_i\\})</span> by short encodings in <span class="math">\\mathcal{R}_q</span>. The prover computes <span class="math">\\mathbf{g}_i = \\tilde{f}_i(\\vec{\\mathbf{a}}, \\vec{\\mathbf{b}}, \\vec{\\mathbf{c}}, \\vec{\\mathbf{w}}, \\{\\vec{\\mathbf{d}}_i\\})</span> for all <span class="math">i \\in [l]</span> over the ring <span class="math">\\mathcal{R}_q</span> (where we are guaranteed no overflows mod <span class="math">q</span> occur if <span class="math">\\sqrt{(n + (3 + l)k)} d\\beta + \\beta^2/2 &amp;lt; q</span>), sends the <span class="math">\\mathbf{g}_i</span> to the verifier, and proves that they are computed correctly using our main protocol. The verifier checks that the main proof was valid and that the <span class="math">\\mathbf{g}_i</span> are indeed zero mod <span class="math">X - 2</span>. The protocol is displayed in Figure 5.</p>

    <p class="text-gray-300">Theorem 6.3. Let <span class="math">\\beta \\in \\mathbb{R}</span> such that <span class="math">\\sqrt{(n + (3 + l)k)d/2}\\beta + \\beta^2/2 &amp;lt; q</span>, then the protocol from Figure 5 is a computationally sound proof of knowledge with</p>

    <p class="text-gray-300">1 In 1855, Thomas Clausens mentioned in a letter to Gauss that he managed to factorize <span class="math">2^{64} + 1</span> into its prime factors 274177 and 67280421310721, adding that the latter was probably the largest prime number known at the moment [Bie64].</p>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">soundness error  <span class="math">2p^{-l}</span> , where  <span class="math">p</span>  is the smallest prime factor of  <span class="math">2^d + 1</span> , under the assumption that  <span class="math">\\mathsf{MSIS}_{m,n+3k}</span>  and  <span class="math">\\mathsf{MSIS}_{md,lk}</span>  are hard with an  <span class="math">l_2</span> -norm bound of  <span class="math">\\beta</span> . If  <span class="math">(n + (3 + l)k)d &amp;lt; 0.3q</span> , then we can put  <span class="math">\\beta = \\sqrt{128/30}\\sqrt{(n + (3 + l)k)d/2}</span>  to have enough slack to compose the proof with the main protocol from Section 5.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 5. Proof of knowledge reduction from R1CS mod  <span class="math">2^{d} + 1</span>  to  <span class="math">R</span> .</p>

    <p class="text-gray-300">The binary R1CS is useful to prove 'binary' constraints, such as proving the correct computation of a cryptographic hash function, integer comparison, range proofs, and table lookups in small tables. On the other hand, the R1CS mod</p>

    <p class="text-gray-300"><span class="math">2^{d}+1</span> is more suitable for proving arithmetic constraints, such as integer addition and multiplication. Many applications require proving a mix of both kinds of constraints. For example, proving knowledge of a valid Dilithium signature, requires proving a lot of arithmetic modulo <span class="math">q=8380417</span>, which would be expensive to express as a binary circuit, but also <span class="math">\\ell_{2}</span>-norm checks and hashing to a set of fixed-weight challenges, which is more difficult to express as an arithmetic circuit.</p>

    <p class="text-gray-300">Luckily, it is possible to combine our proofs for binary R1CSs and R1CSs modulo <span class="math">2^{d}+1</span>. Let <span class="math">\\vec{w}\\in\\{0,1\\}^{dn}</span> be a binary witness that satisfies a binary R1CS instance <span class="math">\\mathcal{A}_{\\mathsf{bin}},\\mathcal{B}_{\\mathsf{bin}},\\mathcal{C}_{\\mathsf{bin}}\\in\\{0,1\\}^{k\\times dn}</span>, and that simultaneously encodes a witness <span class="math">\\vec{\\mathbf{w}}\\in\\mathbb{Z}_{2^{d}+1}^{n}</span> for an R1CS instance <span class="math">\\mathcal{A}_{\\mathsf{arith}},\\mathcal{B}_{\\mathsf{arith}},\\mathcal{C}_{\\mathsf{arith}}\\in\\mathbb{Z}_{2^{d}+1}^{k\\times n}</span>. The prover then sends an Ajtai commitment <span class="math">\\vec{\\mathbf{t}}</span> to <span class="math">\\mathcal{A}_{\\mathsf{bin}}\\vec{w},\\mathcal{B}_{\\mathsf{bin}}\\vec{w},\\mathcal{C}_{\\mathsf{bin}}\\vec{w},Enc(\\mathcal{A}_{\\mathsf{arith}}\\vec{\\mathbf{w}}),Enc(\\mathcal{B}_{\\mathsf{arith}}\\vec{\\mathbf{w}}),Enc(\\mathcal{C}_{\\mathsf{arith}}\\vec{\\mathbf{w}})</span>, and <span class="math">\\vec{w}</span> and runs the two proofs in parallel. Both the proof of the binary R1CS and the proof of the R1CS mod <span class="math">2^{d}+1</span> reduce to an instance of our dot product constraint relation <span class="math">R</span>. The prover then proves both instances with a single execution of our main protocol for <span class="math">R</span>.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">6.1 Proof Sizes of Our Protocol for R1CS</h3>

    <p class="text-gray-300">We now compute proof sizes for R1CS using the protocol from Section 6 followed by several recursive iterations of the main protocol from Section 5 where the last execution uses the variant without outer commitments and fewer garbage polynomials. The amortized opening <span class="math">\\vec{\\mathbf{z}}</span> is always reduced in width (<span class="math">b\\geq 2</span>) except in the second to last execution. This minimizes the number of garbage terms going to be sent in the very last execution. We use the ring <span class="math">\\mathbb{Z}_{q}[X]/(X^{d}+1)</span> with degree <span class="math">d=64</span> and modulus <span class="math">q\\approx 2^{32}</span> splitting into two prime ideals of degree <span class="math">d/2</span>, and the challenge space <span class="math">\\mathcal{C}\\subset\\mathcal{R}_{q}</span> from Section 2 consisting of challenges with <span class="math">\\ell_{2}</span>-norm <span class="math">\\tau</span> and operator norm <span class="math">T</span>. The commitment ranks <span class="math">\\kappa</span>, <span class="math">\\kappa_{1}</span> and <span class="math">\\kappa_{2}</span> are computed in each level so that Module-SIS meets our desired security level of 128 bits for the norm bounds in Theorem 5.1. More precisely, we estimate the hardness of Module-SIS using the Core-SVP methodology <em>[x1]</em> with the BDGL sieve <em>[x3]</em>. The various other system parameters are computed as described in Section 5. Table 1 contains the proof sizes of the comparison of our proof of R1CS mod <span class="math">2^{64}+1</span> with other SNARKs in the literature, as discussed in the introduction and displayed in Figure 1. Table 2 contains the proof sizes for binary R1CS with the number of constraints <span class="math">k</span> varying between <span class="math">2^{20}</span> and <span class="math">2^{25}</span>, and <span class="math">n=k</span>. Table 3 contains the (relation) parameters in each level of recursion of the main protocol for the case of proving binary R1CS with <span class="math">2^{25}</span> constraints.</p>

    <h2 id="sec-35" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Martin R. Albrecht, Valerio Cini, Russell W. F. Lai, Giulio Malavolta, and Sri Aravinda Krishnan Thyagarajan. Lattice-based snarks: Publicly verifiable, preprocessing, and recursively composable. IACR Cryptol. ePrint Arch., page 941, 2022.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof system</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown</td>

            <td class="px-3 py-2 border-b border-gray-700">1279</td>

            <td class="px-3 py-2 border-b border-gray-700">1597</td>

            <td class="px-3 py-2 border-b border-gray-700">1974</td>

            <td class="px-3 py-2 border-b border-gray-700">2200</td>

            <td class="px-3 py-2 border-b border-gray-700">2710</td>

            <td class="px-3 py-2 border-b border-gray-700">3165</td>

            <td class="px-3 py-2 border-b border-gray-700">3926</td>

            <td class="px-3 py-2 border-b border-gray-700">4824</td>

            <td class="px-3 py-2 border-b border-gray-700">6122</td>

            <td class="px-3 py-2 border-b border-gray-700">7899</td>

            <td class="px-3 py-2 border-b border-gray-700">10230</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">235</td>

            <td class="px-3 py-2 border-b border-gray-700">278</td>

            <td class="px-3 py-2 border-b border-gray-700">323</td>

            <td class="px-3 py-2 border-b border-gray-700">376</td>

            <td class="px-3 py-2 border-b border-gray-700">420</td>

            <td class="px-3 py-2 border-b border-gray-700">461</td>

            <td class="px-3 py-2 border-b border-gray-700">519</td>

            <td class="px-3 py-2 border-b border-gray-700">664</td>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">766</td>

            <td class="px-3 py-2 border-b border-gray-700">831</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

            <td class="px-3 py-2 border-b border-gray-700">180</td>

            <td class="px-3 py-2 border-b border-gray-700">299</td>

            <td class="px-3 py-2 border-b border-gray-700">364</td>

            <td class="px-3 py-2 border-b border-gray-700">615</td>

            <td class="px-3 py-2 border-b border-gray-700">721</td>

            <td class="px-3 py-2 border-b border-gray-700">1239</td>

            <td class="px-3 py-2 border-b border-gray-700">1415</td>

            <td class="px-3 py-2 border-b border-gray-700">2461</td>

            <td class="px-3 py-2 border-b border-gray-700">2797</td>

            <td class="px-3 py-2 border-b border-gray-700">4905</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Shockwave</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">122</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">284</td>

            <td class="px-3 py-2 border-b border-gray-700">386</td>

            <td class="px-3 py-2 border-b border-gray-700">523</td>

            <td class="px-3 py-2 border-b border-gray-700">721</td>

            <td class="px-3 py-2 border-b border-gray-700">990</td>

            <td class="px-3 py-2 border-b border-gray-700">1384</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LaBRADOR</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Proof sizes in kilobytes for R1CS with a varying number of constraints.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">No. of constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">224</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">225</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size</td>

            <td class="px-3 py-2 border-b border-gray-700">49.02</td>

            <td class="px-3 py-2 border-b border-gray-700">49.37</td>

            <td class="px-3 py-2 border-b border-gray-700">51.47</td>

            <td class="px-3 py-2 border-b border-gray-700">51.6</td>

            <td class="px-3 py-2 border-b border-gray-700">52.7</td>

            <td class="px-3 py-2 border-b border-gray-700">53.84</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Proof sizes in kilobytes for binary R1CS with a varying number of constraints.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Level</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">length n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">multiplicity r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">witness size (KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">output size (KB)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R1CS → R</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4096.00</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">37450</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">32768.00</td>

            <td class="px-3 py-2 border-b border-gray-700">3.98</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4780</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">5107.27</td>

            <td class="px-3 py-2 border-b border-gray-700">3.99</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1231</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">712.99</td>

            <td class="px-3 py-2 border-b border-gray-700">3.52</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">616</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">196.10</td>

            <td class="px-3 py-2 border-b border-gray-700">3.37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">326</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">85.49</td>

            <td class="px-3 py-2 border-b border-gray-700">3.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">326</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">55.84</td>

            <td class="px-3 py-2 border-b border-gray-700">4.22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">41.20</td>

            <td class="px-3 py-2 border-b border-gray-700">30.91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">53.84</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Relation parameters and proof sizes for the recursive executions of the main protocol in the proof of binary R1CS with  <span class="math">k = 2^{25}</span>  constraints.</p>

    <p class="text-gray-300">ADPS16. Erdem Alkim, Léo Ducas, Thomas Pöppelmann, and Peter Schwabe. Post-quantum key exchange - A new hope. In USENIX Security Symposium, pages 327–343. USENIX Association, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AF [21] Thomas Attema and Serge Fehr. Parallel repetition of <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-sound multi-round interactive proofs. Cryptology ePrint Archive, Paper 2021/1259, 2021. https://eprint.iacr.org/2021/1259.</li>

      <li>AHIV [17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkita-subramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In CCS, pages 2087–2104. ACM, 2017.</li>

      <li>ALS [20] Thomas Attema, Vadim Lyubashevsky, and Gregor Seiler. Practical product proofs for lattice commitments. In CRYPTO (2), volume 12171 of Lecture Notes in Computer Science, pages 470–499. Springer, 2020.</li>

      <li>BBB^{+} [18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society, 2018.</li>

      <li>BBC^{+} [18] Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits. In CRYPTO (2), volume 10992 of Lecture Notes in Computer Science, pages 669–699. Springer, 2018.</li>

      <li>BCC^{+} [16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT (2), volume 9666 of Lecture Notes in Computer Science, pages 327–357. Springer, 2016.</li>

      <li>BCR^{+} [19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In EUROCRYPT (1), volume 11476 of Lecture Notes in Computer Science, pages 103–128. Springer, 2019.</li>

      <li>BDGL [16] Anja Becker, Léo Ducas, Nicolas Gama, and Thijs Laarhoven. New directions in nearest neighbor searching with applications to lattice sieving. In SODA, pages 10–24. SIAM, 2016.</li>

      <li>Ber [41] Andrew C Berry. The accuracy of the gaussian approximation to the sum of independent variates. Transactions of the american mathematical society, 49(1):122–136, 1941.</li>

      <li>BG [92] Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In CRYPTO, volume 740 of Lecture Notes in Computer Science, pages 390–420. Springer, 1992.</li>

      <li>Bie [64] Kurt-R. Biermann. Thomas clausen, mathematiker und astronom. 1964(216):159–198, 1964.</li>

      <li>BLNS [20] Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. A non-pcp approach to succinct quantum-safe zero-knowledge. In CRYPTO (2), volume 12171 of Lecture Notes in Computer Science, pages 441–469. Springer, 2020.</li>

      <li>ENS [20] Muhammed F. Esgin, Ngoc Khanh Nguyen, and Gregor Seiler. Practical exact proofs from lattices: New techniques to exploit fully-splitting rings. In ASIACRYPT (2), volume 12492 of Lecture Notes in Computer Science, pages 259–288. Springer, 2020.</li>

      <li>ESLL [19] Muhammed F. Esgin, Ron Steinfeld, Joseph K. Liu, and Dongxi Liu. Lattice-based zero-knowledge proofs: New techniques for shorter and faster constructions and applications. In CRYPTO (1), volume 11692 of Lecture Notes in Computer Science, pages 115–146. Springer, 2019.</li>

    </ul>

    <p class="text-gray-300">Ess42. Carl-Gustav Esseen. On the liapunoff limit of error in the theory of probability. Arkiv för Matematik, Astronomi och Fysik., 28:1–19, 1942. GHL21. Craig Gentry, Shai Halevi, and Vadim Lyubashevsky. Practical noninteractive publicly verifiable secret sharing with thousands of parties. IACR Cryptol. ePrint Arch., page 1397, 2021. GLS^{+}21. Alexander Golovnev, Jonathan Lee, Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Brakedown: Linear-time and post-quantum snarks for R1CS. IACR Cryptol. ePrint Arch., page 1043, 2021. GOS12. Jens Groth, Rafail Ostrovsky, and Amit Sahai. New techniques for noninteractive zero-knowledge. Journal of the ACM (JACM), 59(3):1–35, 2012. KS10. V Yu Korolev and Irina G Shevtsova. On the upper bound for the absolute constant in the berry–esseen inequality. Theory of Probability & Its Applications, 54(4):638–658, 2010. LNP22. Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Maxime Plançon. Lattice-based zero-knowledge proofs and applications: Shorter, simpler, and more general. IACR Cryptol. ePrint Arch., page 284, 2022. LS18. Vadim Lyubashevsky and Gregor Seiler. Short, invertible elements in partially splitting cyclotomic rings and applications to lattice-based zero-knowledge proofs. In EUROCRYPT (1), volume 10820 of Lecture Notes in Computer Science, pages 204–224. Springer, 2018. NS22. Ngoc Khanh Nguyen and Gregor Seiler. Practical sublinear proofs for R1CS from lattices. IACR Cryptol. ePrint Arch., page 1048, 2022. Rei60. George W. Reitwiesner. Binary arithmetic. Adv. Comput., 1:231–308, 1960.</p>

    <h2 id="sec-36" class="text-2xl font-bold">Appendix A Proof of Lemma 4.2</h2>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We give a proof by cases:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 1: $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<q/10<span class="math">. If </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi\\vec{w}\\mod q\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<\\sqrt{30}b<span class="math"> then either </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi\\vec{w}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<\\sqrt{30}b<span class="math">, which happens with probability at most </span>2^{-128}<span class="math"> by lemma 4.1, or there is a row </span>\\vec{\\pi}_{i}<span class="math"> of </span>\\Pi<span class="math">, such that </span>\\langle\\vec{\\pi}_{i},\\vec{w}\\rangle\\in[kq-\\sqrt{30}b,kq+\\sqrt{30}b]<span class="math"> for a non-zero integer </span>k<span class="math">. Since </span>\\sqrt{30}b<\\sqrt{30}q/125<0.05q<span class="math">, this means that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\vec{\\pi}_{i},\\vec{w}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>0.95q<span class="math">. However, by lemma 4.1, we have for each </span>i<span class="math"> that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\vec{\\pi}_{i},\\vec{w}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>0.95q<span class="math"> with probability at most </span>2^{-141}<span class="math">. So, by a union bound over all the 256 rows of </span>\\Pi$ we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\Pi\\leftarrow\\mathsf{C}^{256\\times d}}\\left[\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi\\vec{w}\\mod q\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq\\sqrt{30}b\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 2: $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\geq q/60<span class="math">. Let </span>i<span class="math"> be an index such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq q/60<span class="math">, and let </span>\\vec{\\pi}<span class="math"> be a row of </span>P<span class="math">. Fix all the entries of </span>\\vec{\\pi}<span class="math"> except the </span>i<span class="math">-th entry, if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\vec{\\pi},\\vec{w}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q/120<span class="math">, with </span>\\pi_{i}=0<span class="math">, then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\vec{\\pi},\\vec{w}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>q/120<span class="math"> for </span>\\pi_{i}=1<span class="math"> and </span>\\pi_{i}=-1<span class="math">, so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\vec{\\pi},\\vec{w}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q/120<span class="math"> with probability at most </span>1/2<span class="math">. Since </span>\\sum_{i=0}^{29}\\binom{256}{i}<2^{128}<span class="math">, we have that the probability that 29 or fewer entries of </span>\\Pi\\vec{w}<span class="math"> are larger than </span>q/120<span class="math"> is less than </span>2^{-128}<span class="math">. Since </span>\\sqrt{30}b<\\sqrt{29}q/120$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{\\Pi\\leftarrow\\mathsf{C}^{256\\times d}}\\left[\\Pi\\vec{w}&lt;\\sqrt{30}b\\right]&lt;\\Pr_{\\Pi\\leftarrow\\mathsf{C}^{256\\times d}}\\left[\\Pi\\vec{w}&lt;\\sqrt{29}q/120\\right]&lt;2^{-128}\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 3: $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\geq q / 10<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; q / 60<span class="math">. In this case, there exists a vector </span>\\vec{v} \\in [-q / 2, q / 2]^d<span class="math"> with </span>q / 11 \\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &lt; q / 10<span class="math">, and </span>v_i = w_i<span class="math"> or </span>v_i = 0<span class="math"> for all </span>i \\in [d]<span class="math">. Such a </span>\\vec{v}<span class="math"> can be constructed, starting from </span>\\vec{v} = \\vec{w}<span class="math">, and repeatedly setting entries of </span>\\vec{v}<span class="math"> to zero, until </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &lt; q / 10<span class="math">. Setting a single entry to zero reduces </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2^2<span class="math"> by at most </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^2 &lt; q^2 / 60^2<span class="math">, so the final </span>\\vec{v}$ satisfies</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q / 11 \\leq \\sqrt{q^2 / 10^2 - q^2 / 60^2} \\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &lt; q / 10.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have that <span class="math">\\langle \\vec{\\pi},\\vec{w}\\rangle = \\langle \\vec{\\pi},\\vec{v}\\rangle +\\langle \\vec{\\pi},\\vec{w} -\\vec{v}\\rangle</span>, and <span class="math">\\langle \\vec{\\pi},\\vec{v}\\rangle</span> is independent of <span class="math">\\langle \\vec{\\pi},\\vec{w} -\\vec{v}\\rangle</span>, because <span class="math">\\vec{v}</span> and <span class="math">\\vec{w} -\\vec{v}</span> have disjoint support. Now we argue that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{\\pi},\\vec{w}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\sqrt{30} b<span class="math"> with a fairly large probability. The intuition is that, since </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; 11 / 60\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math"> the </span>l_{2}<span class="math">-norm of </span>\\vec{v}<span class="math"> is not concentrated too much in a few entries, so intuitively </span>\\langle \\vec{p},\\vec{v}\\rangle<span class="math"> is the sum of many small independent variables, and its distribution should therefore be close to a normal distribution. We can formalize this with the Berry-Esseen Theorem (with the constant 0.52 from [KS10]), which says that if </span>X = X_{1} + \\dots +X_{k}<span class="math"> is a sum of independent variables with zero mean, variances </span>\\mathbb{E}[X_i^2 ] = \\sigma_i^2 &gt;0<span class="math">, and third moments </span>\\mathbb{E}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3 ] = \\rho_i<span class="math">, and if </span>Y<span class="math"> is a random variable following a normal distribution with zero mean and variance </span>\\sum_{i}\\sigma_{i}^{2}$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sup_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ X \\leq x ] - \\Pr [ Y \\leq x ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 0.52 \\frac {\\max_{i = 1}^{k} \\rho_{i} / \\sigma_{i}^{2}}{\\sqrt {\\sum_{i} \\sigma_{i}^{2}}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We apply the Berry-Esseen Theorem to <span class="math">\\langle \\vec{\\pi},\\vec{v}\\rangle = \\sum_{i = 1}^{d}\\pi_{i}v_{i}</span>. The <span class="math">i</span>-th summand has variance <span class="math">v_{i}^{2} / 2</span> and third moment $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{3} / 2<span class="math">, so we have </span>\\max_{i = 1}^{k}\\rho_{i} / \\sigma_{i}^{2} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> and the sum of the variances is </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2^2 /2$. So we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sup_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\langle \\vec{\\pi}, \\vec{v} \\rangle \\leq x ] - \\Pr [ Y \\leq x ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 0.52 \\sqrt{2} \\frac {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2} \\leq 0.52 \\sqrt{2} \\frac{q}{60} \\frac{11}{q} &lt; 0.15,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">Y</span> follows a normal distribution with standard deviation $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 / \\sqrt{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix any value <span class="math">a \\in [-q/2, q/2]</span>. We will upper bound the probability that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{\\pi}, \\vec{w} \\rangle \\bmod q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\sqrt{30} b<span class="math">, conditioned on </span>\\langle \\vec{\\pi}, \\vec{w} - \\vec{v} \\rangle = a \\bmod q<span class="math">. We can only have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{\\pi}, \\vec{w} \\rangle \\bmod q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\sqrt{30} b<span class="math"> if either </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{\\pi}, \\vec{v} \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; q/2<span class="math"> (which happens with probability at most </span>2^{-141}<span class="math"> by lemma 4.1), or if </span>\\langle \\vec{\\pi}, \\vec{v} \\rangle \\in G$, where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G = \\left\\{x \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x + a \\mod q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\sqrt{30} b \\right\\} \\cap \\left[ -q/2, q/2 \\right].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This <span class="math">G</span> has measure <span class="math">2\\sqrt{30}b &amp;lt; 2\\sqrt{30}q / 125</span>, so since the width of <span class="math">Y</span> is at least <span class="math">q / 11</span>, the probability that <span class="math">Y</span> falls in <span class="math">G</span> is at most <span class="math">\\frac{11\\cdot 2\\sqrt{30}q}{\\sqrt{2\\cdot 3.14}q125} &amp;lt; 0.39</span>. Either <span class="math">G</span> or <span class="math">[-q/2, q/2] \\setminus G</span> is an interval, so it follows from the Berry-Esseen theorem that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{\\pi}, \\vec{v} \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in G<span class="math"> with probability at most </span>0.39 + 2\\cdot 0.15$. Therefore</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\Pi \\leftarrow \\mathbb{C}^{256\\times d}} \\left[ \\Pi \\vec{w} &amp;lt; \\sqrt{30} b \\right] &amp;lt; (0.69 + 2^{-141})^{256} &amp;lt; 2^{-137}.</span></div>

    <p class="text-gray-300">31</p>

    <p class="text-gray-300">B Proof of Theorem 5.1</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}^{*}</span> be a deterministic prover for the protocol with success probability <span class="math">\\varepsilon&gt;\\varepsilon_{0}</span>. First, notice that the prover always sends the same outer commitment <span class="math">\\vec{\\bm{u}}_{1}</span> in its first message. So the inner commitments <span class="math">\\vec{\\bm{t}}_{i}</span> and garbage matrix <span class="math">(\\bm{g}_{ij})</span> from the last message must be the same in all accepting transcripts since they are an opening of norm at most <span class="math">\\beta^{\\prime}</span> for the commitment <span class="math">\\vec{\\bm{u}}_{1}</span>, which is binding under the assumed hardness of Module-SIS for rank <span class="math">\\kappa_{1}</span> and bound <span class="math">2\\beta^{\\prime}</span>. Similarly, the garbage matrix <span class="math">(\\bm{h}_{ij})</span> must be the same in all accepting transcripts that coincide in the upper challenges <span class="math">\\Pi_{i}</span>, <span class="math">\\vec{\\psi}^{(k)},\\vec{\\omega}^{(k)}</span>, <span class="math">\\vec{\\bm{\\alpha}},\\vec{\\bm{\\beta}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The extractor first runs <span class="math">\\mathcal{P}^{<em>}</span> repeatedly with freshly sampled challenges in each run until it hits an accepting transcript. This takes expected time <span class="math">1/\\varepsilon</span>. As a result the inner commitments <span class="math">\\vec{\\bm{t}}_{i}</span> are known. Then weak openings <span class="math">\\vec{\\bm{s}}_{i}^{</em>}</span> of norms <span class="math">2(b+1)\\beta^{\\prime}</span> to the inner commitments are extracted in the usual way for amortized proofs <em>[x21, Section 4]</em>. For each <span class="math">i=1,\\ldots,r</span>, the extractor samples a first random accepting transcript by running the prover repeatedly with all challenges freshly sampled in each run. With probability <span class="math">1/2</span> this first transcript is such that the challenges <span class="math">\\bm{c}_{j}</span> for <span class="math">j\\neq i</span> define a heavy row for <span class="math">\\bm{c}_{i}</span>. So in this case, the prover’s success probability is at least <span class="math">\\varepsilon/2&gt;2^{-128}</span> when it is run with <span class="math">\\bm{c}_{i}</span> freshly sampled, but <span class="math">\\bm{c}_{j}</span> for <span class="math">j\\neq i</span> fixed to the values in the first transcript. Then the extractor finds a second accepting transcript that differs in <span class="math">\\bm{c}_{i}</span> but not in the <span class="math">\\bm{c}_{j}</span> in expected time at most <span class="math">1/(\\varepsilon/2-2^{-128})</span>. From the two accepting transcripts with <span class="math">i</span>-th challenges <span class="math">\\bm{c}_{i}</span> and <span class="math">\\bm{c}_{i}^{\\prime}</span>, and amortized openings <span class="math">\\vec{\\bm{z}}</span> and <span class="math">\\vec{\\bm{z}}^{\\prime}</span>, the extractor can compute the weak opening <span class="math">\\vec{\\bm{s}}_{i}^{*}=(\\vec{\\bm{z}}-\\vec{\\bm{z}}^{\\prime})/\\bar{\\bm{c}}_{i}</span> for <span class="math">\\vec{\\bm{t}}_{i}</span> where <span class="math">\\bar{\\bm{c}}_{i}=\\bm{c}_{i}-\\bm{c}_{i}^{\\prime}</span>. We have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\bm{c}}_{i}\\vec{\\bm{s}}_{i}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2(b+1)\\beta^{\\prime}<span class="math"> so the weak opening is of norm </span>2(b+1)\\beta^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It remains to prove that the <span class="math">\\vec{\\bm{s}}_{i}^{<em>}</span> must fulfill the norm bound (with slack) and the dot product functions in the statement. We start with the norm and derive an upper bound on the success probability of <span class="math">\\mathcal{P}^{</em>}</span> under the assumption that the norm is too big; that is, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{s}}_{1}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\cdots+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\bm{s}}_{r}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}>(128/30)\\beta^{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this situation, according to Lemma 4.2, the probability that a random transcript is accepting and the vector <span class="math">\\vec{p}</span> is the correct projection of the <span class="math">\\vec{\\bm{s}}_{i}^{*}</span> is at most <span class="math">2^{-128}</span> since the verifier checks that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{p}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{128}\\beta<span class="math">. Otherwise, consider the event where a transcript is accepting but </span>\\vec{p}\\neq\\sum_{i=1}^{r}\\Pi_{i}\\vec{s}_{i}^{<em>}<span class="math">, i.e. </span>p_{j_{0}}\\neq\\sum_{i}\\langle\\vec{s}_{i}^{(j_{0})},\\vec{s}_{i}^{</em>}\\rangle<span class="math"> for some </span>j_{0}<span class="math">. The probability for this event and that all the polynomials </span>\\bm{b}^{\\prime\\prime(k)}<span class="math"> are honestly computed is at most </span>q^{-\\lceil 128/\\log q\\rceil}\\leq 2^{-128}$. By honestly computed we mean</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\bm{b}^{\\prime\\prime(k)}=\\sum_{i,j=1}^{r}\\bm{a}_{ij}^{\\prime\\prime(k)}\\bm{g}_{ij}+\\sum_{i=1}^{r}\\langle\\vec{\\bm{\\varphi}}_{i}^{\\prime\\prime(k)},\\vec{\\bm{s}}_{i}^{*}\\rangle</span></p>

    <p class="text-gray-300">for all <span class="math">k=1,\\ldots,\\lceil 128/\\log q\\rceil</span>. The reason for the low probability is that the verifier checks the constant coefficients of the <span class="math">\\bm{b}^{\\prime\\prime(k)}</span>. More precisely, the corresponding verification equations contain the additive and independently uniformly random</p>

    <p class="text-gray-300">terms</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{ct}\\left(\\sum_{i=1}^{r} \\langle \\omega_{j_0}^{(k)} \\sigma_{-1}(\\vec{\\pi}_i^{(j_0)}), \\vec{s}_i^* \\rangle\\right) - \\omega_{j_0}^{(k)} p_{j_0} = \\omega_{j_0}^{(k)} \\left(\\sum_{i=1}^{r} \\langle \\vec{\\pi}_i^{(j_0)}, \\vec{s}_i^* \\rangle - p_{j_0}\\right).</span></div>

    <p class="text-gray-300">Here we have used that the garbage polynomials <span class="math">\\pmb{g}_{ij}</span> are independent of the challenges <span class="math">\\omega_{j_0}^{(k)}</span>. Indeed, as explained, the <span class="math">\\pmb{g}_{ij}</span> are the same in all accepting transcripts. Next, consider accepting transcripts where the <span class="math">\\pmb{b}^{\\prime \\prime (k)}</span> are maliciously computed, say <span class="math">\\pmb{b}^{\\prime \\prime (k_0)}</span> is malicious for a <span class="math">k_{0}</span>. The probability for this in conjunction with the equation</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\sum_{i,j=1}^{r} \\boldsymbol{a}_{ij} \\boldsymbol{g}_{ij} + \\sum_{i=1}^{r} \\langle \\vec{\\varphi}_i, \\vec{s}_i^* \\rangle - \\boldsymbol{b} \\\\ &amp;amp; = \\sum_{k=1}^{K} \\boldsymbol{\\alpha}_k \\left( \\sum_{i,j=1}^{r} \\boldsymbol{a}_{ij}^{(k)} \\boldsymbol{g}_{ij} + \\sum_{i=1}^{r} \\langle \\vec{\\varphi}_i^{(k)}, \\vec{s}_i^* \\rangle - \\boldsymbol{b}^{(k)} \\right) \\\\ &amp;amp; \\quad + \\sum_{k=1}^{\\left\\lceil \\frac{128}{168.9} \\right\\rceil} \\beta_k \\left( \\sum_{i,j=1}^{r} \\boldsymbol{a}_{ij}^{\\prime \\prime (k)} \\boldsymbol{g}_{ij} + \\sum_{i=1}^{r} \\langle \\vec{\\varphi}_i^{\\prime \\prime (k)}, \\vec{s}_i^* \\rangle - \\boldsymbol{b}^{\\prime \\prime (k)} \\right) = \\mathbf{0} \\end{aligned}</span></div>

    <p class="text-gray-300">is at most <span class="math">q^{-d/2}</span> because the equation contains the additive independently uniformly random term</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{\\beta}_{k_0} \\left( \\sum_{j,j=1}^{r} \\boldsymbol{a}_{ij}^{\\prime \\prime (k_0)} \\boldsymbol{g}_{ij} + \\sum_{i=1}^{r} \\langle \\vec{\\varphi}_i^{\\prime \\prime (k_0)}), \\vec{s}_i^* \\rangle - \\boldsymbol{b}^{\\prime \\prime (k_0)} \\right).</span></div>

    <p class="text-gray-300">In particular, this term is independently uniformly random modulo one of the two prime divisors of degree <span class="math">d/2</span> of <span class="math">(q)</span>. Now, if the equation does not hold in an accepting transcript, there must be some <span class="math">i_0</span> such that <span class="math">\\pmb{h}_{i_0i_0} \\neq \\langle \\vec{\\varphi}_{i_0}, \\vec{s}_{i_0}^<em> \\rangle</span> since the verifier checks the above equation with <span class="math">\\langle \\vec{\\varphi}_i, \\vec{s}_i^</em> \\rangle</span> replaced by <span class="math">\\pmb{h}_{ii}</span>. We then write <span class="math">\\vec{z} = \\vec{y} + \\pmb{c}_{i_0} \\vec{s}_{i_0}^*</span>. Now, <span class="math">\\vec{y}</span> is a weak opening of norm <span class="math">4T(b + 1)\\beta&#x27;</span> for <span class="math">\\sum_{i \\neq i_0} \\pmb{c}_i \\vec{t}_i</span> of rank <span class="math">\\kappa</span>. The prover is bound to <span class="math">\\vec{y}</span> for all accepting transcripts whose challenges differ only in <span class="math">\\pmb{c}_{i_0}</span> since a different <span class="math">\\vec{y}&#x27;</span> would still be a weak opening for the same challenge difference <span class="math">\\bar{\\pmb{c}}_{i_0}</span>. So, <span class="math">\\vec{z}</span> must be of the same form in all accepting transcripts whose challenges differ only in <span class="math">\\pmb{c}_{i_0}</span>. Substituting this expression for <span class="math">\\vec{z}</span> into the verification equations gives</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\sum_{\\substack{1\\leq i\\leq r\\\\ i\\neq i_{0}}}\\langle \\vec{\\varphi}_{i},\\vec{y}\\rangle \\boldsymbol{c}_{i} + \\left( \\langle \\vec{\\varphi}_{i_{0}},\\vec{y}\\rangle +\\sum_{\\substack{1\\leq i\\leq r\\\\ i\\neq i_{0}}}\\langle \\vec{\\varphi}_{i},\\vec{s}_{i_{0}}^{*}\\rangle \\boldsymbol{c}_{i} \\right)\\boldsymbol{c}_{i_{0}} + \\langle \\vec{\\varphi}_{i_{0}},\\vec{s}_{i_{0}}^{*}\\rangle \\boldsymbol{c}_{i_{0}}^{2} \\\\ &amp;amp; = \\sum_{\\substack{1\\leq i,j\\leq r\\\\ i,j\\neq i_{0}}}\\boldsymbol{h}_{ij}\\boldsymbol{c}_{i}\\boldsymbol{c}_{j} + \\sum_{\\substack{1\\leq i\\leq r\\\\ i\\neq i_{0}}} (\\boldsymbol{h}_{ii_{0}} + \\boldsymbol{h}_{i_{0}i})\\boldsymbol{c}_{i}\\boldsymbol{c}_{i_{0}} + \\boldsymbol{h}_{i_{0}i_{0}}\\boldsymbol{c}_{i_{0}}^{2}. \\end{aligned}</span></div>

    <p class="text-gray-300">This is a quadratic non-zero polynomial in <span class="math">\\pmb{c}_{i_0}</span> whose coefficients are independent of <span class="math">\\pmb{c}_{i_0}</span>. So it can only be zero with probability at most <span class="math">2 \\cdot 2^{-128}</span>. Since this holds for all accepting transcripts where some <span class="math">\\pmb{h}_{ii}</span> is malicious we see that this can only happen with probability at most <span class="math">2 \\cdot 2^{-128}</span>. Finally, adding probabilities shows that the prover can only produce an accepting transcript with probability at most</p>

    <div class="my-4 text-center"><span class="math-block">2^{-128} + q^{-\\lceil 128 / \\log q \\rceil} + q^{-d/2} + 2 \\cdot 2^{-128} &amp;lt; 2^{-125} = \\varepsilon_0.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This is in contradiction to <span class="math">\\varepsilon &amp;gt; \\varepsilon_0</span> and hence the norm bound $\\sum_{i=1}^{r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{s}_i^*\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 \\leq (128/30)\\beta^2$ must hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, we turn to the dot product functions. We have already proven that with probability at least <span class="math">1 - 2^{-127}</span>, accepting transcripts must be such that <span class="math">\\pmb{h}_{ii} = \\langle \\vec{\\pmb{\\varphi}}_i, \\vec{s}_i^<em> \\rangle</span> for all <span class="math">i</span>. We now show that <span class="math">\\pmb{g}_{ij} = \\langle \\vec{s}_i^</em>, \\vec{s}_j^<em> \\rangle</span> for all <span class="math">i, j</span>. Recall that the <span class="math">\\pmb{g}_{ij}</span> are deterministic in that they are the same in all accepting transcripts. Suppose that <span class="math">\\pmb{g}_{i_0j_0} \\neq \\langle \\vec{s}_{i_0}^</em>, \\vec{s}_{j_0}^<em> \\rangle</span> for some <span class="math">i_0, j_0</span>. The argument for <span class="math">i_0 = j_0</span> follows almost exactly as for <span class="math">\\pmb{h}_{i_0i_0}</span>. So we handle the case <span class="math">i_0 \\neq j_0</span>. Then, for an arbitrary accepting transcript we define <span class="math">\\vec{\\pmb{y}}</span> such that <span class="math">\\vec{z} = \\vec{\\pmb{y}} + \\pmb{c}_{i_0} \\vec{s}_{i_0}^</em> + \\pmb{c}_{j_0} \\vec{s}_{j_0}^*</span>. Here <span class="math">\\vec{\\pmb{y}}</span> is a (strong) opening of norm <span class="math">(b + 1)\\beta&#x27; + 2T\\sqrt{128/30}\\beta</span> for <span class="math">\\sum_{i \\notin \\{i_0, j_0\\}} \\pmb{c}_i \\vec{t}_i</span>. So the prover is bound to <span class="math">\\vec{\\pmb{y}}</span> in all accepting transcripts that have the same challenges <span class="math">\\pmb{c}_i</span>, <span class="math">i \\notin \\{i_0, j_0\\}</span>. In these transcripts, we get from the verification equations that</p>

    <p class="text-gray-300">$$ \\begin{aligned} \\langle \\vec{y}, \\vec{y} \\rangle + 2 \\langle \\vec{y}, \\vec{s}_{i_0}^<em> \\rangle \\pmb{c}_{i_0} + 2 \\langle \\vec{y}, \\vec{s}_{j_0}^</em> \\rangle \\pmb{c}_{j_0} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2 \\langle \\vec{s}_{i_0}^<em>, \\vec{s}_{j_0}^</em> \\rangle \\pmb{c}_{i_0} \\pmb{c}_{j_0} + \\langle \\vec{s}_{i_0}^<em>, \\vec{s}_{i_0}^</em> \\rangle \\pmb{c}_{i_0}^2 + \\langle \\vec{s}_{j_0}^<em>, \\vec{s}_{j_0}^</em> \\rangle \\pmb{c}_{j_0}^2 \\\\</li>

    </ul>

    <p class="text-gray-300">= \\sum_{i, j \\notin \\{i_0, j_0\\}} \\pmb{g}_{ij} \\pmb{c}_i \\pmb{c}_j + \\sum_{i \\notin \\{i_0, j_0\\}} 2 \\pmb{g}_{ii_0} \\pmb{c}_i \\pmb{c}_{i_0} + \\sum_{i \\notin \\{i_0, j_0\\}} 2 \\pmb{g}_{ij_0} \\pmb{c}_i \\pmb{c}_{j_0} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2 \\pmb{g}_{i_0j_0} \\pmb{c}_{i_0} \\pmb{c}_{j_0} + \\pmb{g}_{i_0i_0} \\pmb{c}_{i_0}^2 + \\pmb{g}_{j_0j_0} \\pmb{c}_{j_0}^2.</li>

    </ul>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">This quadratic non-zero bivariate polynomial in <span class="math">\\pmb{c}_{i_0}</span> and <span class="math">\\pmb{c}_{j_0}</span> can only evaluate to zero with probability <span class="math">2 \\cdot 2^{-128}</span>. Since <span class="math">\\varepsilon &amp;gt; 2^{-127}</span> this can not be. Now, suppose that some of the functions <span class="math">f^{(k)}</span> do not evaluate to zero or that some of the functions <span class="math">f&#x27;^{(l)}</span> do not have zero constant coefficients. Then the aggregated function <span class="math">F</span> only evaluates to zero with probability at most <span class="math">q^{-d/2}</span> over the challenges <span class="math">\\alpha_k, \\beta_l</span>. Otherwise, we must have that <span class="math">\\pmb{h}_{ii}</span> is malicious for some <span class="math">i</span>, which only happens with probability <span class="math">2^{-127}</span>. Together, we see that the prover can only win with probability at most <span class="math">q^{-d/2} + 2^{-127} &amp;lt; \\varepsilon_0</span>. This is again a contradiction and therefore the functions do hold.</p>

    <p class="text-gray-300">34</p>`;
---

<BaseLayout title="LaBRADOR: Compact Proofs for R1CS from Module-SIS (2022/1341)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1341
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
