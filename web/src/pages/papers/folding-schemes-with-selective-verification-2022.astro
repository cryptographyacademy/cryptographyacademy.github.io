---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1576';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Folding Schemes with Selective Verification';
const AUTHORS_HTML = 'Carla Ràfols, Alexandros Zacharakis';

const CONTENT = `    <p class="text-gray-300">Folding Schemes with Selective Verification\\*</p>

    <p class="text-gray-300">Carla Råfols¹ and Alexandros Zacharakis²</p>

    <p class="text-gray-300">¹ Pompeu Fabra University, Barcelona, Spain, carla.rafols@upf.edu ² Toposware Inc., alexandros.zacharakis@toposware.com</p>

    <p class="text-gray-300">Abstract. In settings such as delegation of computation where a prover is doing computation as a service for many verifiers, it is important to amortize the prover's costs without increasing those of the verifier. We introduce folding schemes with selective verification. Such a scheme allows a prover to aggregate <span class="math">m</span> NP statements <span class="math">x_{i} \\in \\mathcal{L}</span> in a single statement <span class="math">x \\in \\mathcal{L}</span>. Knowledge of a witness for <span class="math">x</span> implies knowledge of witnesses for all <span class="math">m</span> statements. Furthermore, each statement can be individually verified by asserting the validity of the aggregated statement and an individual proof <span class="math">\\pi_{i}</span> with size sublinear in the number of aggregated statements. In particular, verification of statement <span class="math">x_{i}</span> does not require reading (or even knowing) all the statements aggregated. We demonstrate natural folding schemes for various languages: inner product relations, vector and polynomial commitment openings and relaxed R1CS of NOVA. All these constructions incur a minimal overhead for the prover, comparable to simply reading the statements.</p>

    <p class="text-gray-300">Keywords: Folding · Aggregation · Delegation of computation · SNARKs · Vector commitments · Verifiable databases.</p>

    <p class="text-gray-300">Succinct non-interactive arguments of knowledge (SNARKs) have been proven an invaluable tool in the last decade, both in theoretical as well as practical terms. Such constructions allow a prover to convince a verifier that some NP relation is satisfied in a way such that communication and (in some cases) verification time are sublinear in the size of the NP witness. They can also be adapted to satisfy the zero-knowledge property, which guarantees that no information about the NP witness is leaked through the proof.</p>

    <p class="text-gray-300">While the first real-world application of SNARKs [2] aimed at preserving the privacy of the prover, the potential of this primitive for improving scalability in many applications is increasingly recognized, for example roll-up architectures or the Filecoin network. In these applications, where the size of the computations is really large, the efficiency of the prover is the main bottleneck. Therefore, improving prover's efficiency is an active area of research, trying to reduce prover</p>

    <p class="text-gray-300">\\* This work has been partially funded by Protocol Labs Research Grant PL-RGP1-2021-048.</p>

    <p class="text-gray-300">overhead <em>[5, 6, 20]</em> or memory requirements <em>[8]</em> or building hardware accelerators for the provers, to name a few approaches.</p>

    <p class="text-gray-300">Despite the many improvements achieved and those that for sure will come after the considerable research effort we have seen in reducing this cost, SNARK proofs will remain expensive for the prover. Also, it is natural to envisage a scenario where these proofs are outsourced to some powerful entity, in the spirit of secure delegation of computation <em>[17]</em>, where an untrusted prover performs computations as a service to several “muggles”, or computationally weak verifiers. In this scenario, the prover is providing a service to many verifiers and also has their data (i.e. there are no privacy requirements). The current overhead of the prover is crucial in this scenario. The efficiency of the prover is essential in this scenario, as it will seriously hinder scalability, and also the cost of the prover will be directly reflected in the cost of the service. On the other hand, using some kind of batching or recursive proof composition in this setting seems unsatisfactory, as each verifier does not necessarily want to know all the other statements that are being verified and incur the additional costs that this represents.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">The aim of this work is to mitigate the necessity of large computational resources for the prover in applications where he provides services to many clients. Instead of trying to improve the efficiency of SNARK constructions, we take a different approach: we amortize the proving cost across multiple proofs of independent and unrelated statements. This means that, when having to make <span class="math">M</span> computations of different statements, instead of producing <span class="math">M</span> separate SNARK proofs for each, the prover “collapses” all these statements into a single statement in a verifiable way and only produces a proof for the latter using a SNARK. This is a novel application of <em>folding schemes</em> <em>[19]</em>, originally introduced to improve recursive proof composition. The guarantee we get is that if the proof for the aggregated statement verifies, then all statements are correct.</p>

    <p class="text-gray-300">Additionally, since the ultimate goal is to be able to prove unrelated statements, possibly coming from different parties, we augment aggregation with a local property we call <em>selective verification</em>. This property captures that a small proof <span class="math">\\pi_{i}</span> -which importantly, is sublinear in the number of aggregated statements- is evidence that a statement <span class="math">x_{i}</span> was considered in the construction of the final aggregated statement and, thus, a proof for the latter along with <span class="math">\\pi_{i}</span> stands as a proof for the validity of <span class="math">x_{i}</span>. Note that it is not necessary to even know the statements used in aggregation to assert the validity of <span class="math">x_{i}</span>.</p>

    <p class="text-gray-300">A crucial requirement for efficiency is that aggregation of <span class="math">M</span> statements is more efficient than producing <span class="math">M</span> SNARK proofs. We demonstrate this by considering natural aggregation schemes for various relations through simple public coin protocols and the Fiat-Shamir transform. Specifically, we consider (1) inner product relations of committed values, (2) vector commitment openings, (3) knowledge of openings of polynomial commitments at the same point, and (4) the relaxed R1CS relation of NOVA <em>[19]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">All the constructions are extremely efficient for the prover, who during folding does work comparable to reading the statements/witnesses (modulo a linear number of hash function computations needed to derive the non-interactive challenge of the Fiat-Shamir transform). Verification incurs a small overhead since now the verifier also needs to check, apart from the SNARK proof, that the statement in question is indeed “contained” in the aggregated statement. This is dominated by <span class="math">\\log M</span> hash function computations where <span class="math">M</span> is the number of aggregated statements. This seems a good compromise since the verifier benefits from the reduced costs of the service as well.</p>

    <p class="text-gray-300">Nevertheless, there are several other advantages in the construction for the verifier. First, the same techniques used for folding can be used “locally” by the verifier to aggregate many statements into a single statement <span class="math">x_{i}</span> which will then be aggregated with other independent queries from other verifiers. Therefore, the additional cost of each verifier can be amortized when the verifier makes multiple queries. Second, since all verifiers need to assert the validity of the same folded statement, one could explore the possibility of distributing this task, incentivizing a few randomly chosen verifiers to check the aggregated statement. As long as one is honest, a cheating prover will be identified. If a verifier does not validate the proof himself, it can still query it in the future to the prover (along with other statements of interest that it locally aggregates) instead of simply relying on other parties. Thus, the verification cost can be fine-tuned on large scale systems without compromising security.</p>

    <p class="text-gray-300">Our techniques are quite general. In particular, (1) we show a generic way to augment every non-interactive 2-folding scheme to a non-interactive <span class="math">M</span>-scheme using combinatorial techniques, (2) show this construction achieves selective verification, and (3) we do not rely on some specific SNARK construction.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Applications</h3>

    <p class="text-gray-300">As we have discussed, selective verification can improve efficiency on applications with a single server serving multiple clients in a trustless way. It allows us to amortize the server’s costs across multiple queries from clients, while only incurring a small overhead for the clients. We discuss two applications in more detail.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Delegation of computation as a service.</h5>

    <p class="text-gray-300">For delegation of computation in a trustless setting, one would normally resort to a SNARK, especially in cases where interaction is prohibitive. We discuss how to use folding schemes to mitigate the problem of prover’s costs.</p>

    <p class="text-gray-300">We will consider two cases: (1) each party needs to perform arbitrary computations, and (2) all parties are interested in doing the same computation on different inputs. Especially in the latter case, we can significantly reduce the costs of the prover through folding schemes with selective verification.</p>

    <p class="text-gray-300">For case (1), many SNARKs are constructed by separately considering some information-theoretic part and a cryptographic primitive. Two main approaches are known: (i) using interactive oracle proofs <em>[1]</em> and vector commitments <em>[14]</em></p>

    <p class="text-gray-300">and (ii) using algebraic <em>[15]</em> or polynomial <em>[13]</em> holographic proofs and polynomial commitments <em>[18]</em>. In the former, the prover and verifier, after interacting, reduce the validity of the claim to the opening of some commitments to vectors at some random indices, while in the latter the validity of the statement is reduced to opening some polynomial commitments in random values. The interaction can be removed through the Fiat-Shamir transform.</p>

    <p class="text-gray-300">In either case, we can use the folding constructions of the previous section to amortize the cost of the latter step: inner product arguments for the former and polynomial commitment for the latter. Specifically, with each computational query, the prover computes all the commitments that are part of the SNARK but it refrains for the time from computing the opening of (the vector or polynomial) commitment. After multiple interactions with different verifiers, it folds all the (vector or polynomial) commitments to a single one and opens the latter at some random indices or points respectively. The randomness can be derived by hashing the folded statement. Each verifier can now assert the folding proof as well as some evidence sent by the server asserting the inclusion of her statement. To be concrete, for example in Plonk <em>[16]</em>, the prover will compute round until round 3 for each different statement. Then, it will wait to open the polynomial commitments until it has the transcripts of many other protocols until round 3. Using a technique presented by Turel et al. in <em>[22]</em>, the prover will then create a Merkle tree of hashes of the transcript, to derive an opening point that is a hash of all involved transcripts. Then, the prover will send all the openings that each verifier needs to verify its statement (including an opening of the linearization polynomial <span class="math">r(X)</span>), together with a proof that all the commitments corresponding to these openings have been folded into a single commitment value, and a proof of correct opening of this commitment.</p>

    <p class="text-gray-300">In case (2), where all parties are interested in performing the same computation on different inputs, one could use the NOVA approach. Specifically, the computation is encoded as a relaxed R1CS statement and the various instances of this statement are aggregated using the NOVA folding scheme compiled to support selective verification. As we discussed, a folding of this type of statements is very efficient. This is in constrast to the previous case, since the SNARK information theoretic part (which needs to be in fact executed for each query to the proving server) is in fact costly for the prover. Considering the case of a single</p>

    <p class="text-gray-300">computation allows us to completely remove the need for this part and directly fold statements, which is not much costlier than simply reading the statements.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Verifiable Databases</h4>

    <p class="text-gray-300">In a verifiable database, a client outsources the storage of a database to a server in a trustless way. Specifically, the client only holds a small digest of the database and can query/modify the database in a verifiable way through communication with the prover. Such a construction can be built using vector commitments. The database is encoded as a vector and the client only needs to hold the (constant size) commitment to the database. A query to the database can be answered verifiably by asking the server to open the commitment to the desired locations. Furthermore, if the underlying commitment scheme is homomorphic (for example the Pedersen commitment), updating the database is efficient since one just needs to homomorphically update the digest by removing the old values and adding the new ones.</p>

    <p class="text-gray-300">Consider the case where a server outsources storage to various clients. Naively implementing this would require that it sends an (expensive to produce) proof of opening for every query of every client to its database. Using a folding scheme with selective verification (for example the inner product language construction) can naturally minimize this cost.</p>

    <p class="text-gray-300">In particular, each query to the server is answered without any verifiability guarantee; the clients simply get their responses and perform their updates acting in good faith. However, periodically, the server folds all the claims from all the clients using the folding scheme and publishes a single statement and individualized proofs for each client to convince about the validity of all statements of one period. Due to the efficiency of the folding scheme, the amortized cost for this is much less than proving each claim individually.</p>

    <p class="text-gray-300">An interesting feature of the described mechanism is that it can be used to any algebraic commitment (i.e. any Pedersen type) commitment, in particular, they can be used in DLOG groups without pairings. In this setting, to open a vector to many positions, the cost of the verifier is linear in the size of the commitment. Our solution allows amortizing the prover cost in this setting without much overhead to the verifier, which is critical in this setting where individual verification is already quite expensive.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <p class="text-gray-300">The techniques in this work are inspired by a recent line of work on <em>proof composition techniques</em>, namely <em>[9, 12, 11, 4]</em>. In general, these techniques consider the notion of proof aggregation, namely, how to derive a single proof <span class="math">\\pi</span> that asserts the validity of two or more proofs. The motivation for this line of work is twofold. First, amortizing the cost of the (inefficient) verification of folding technique based constructions <em>[7, 10]</em> and second, to construct proof carrying data <em>[3]</em> and incrementally verifiable computation <em>[21]</em>.</p>

    <p class="text-gray-300">Our work differs in that (1) the main goal is to amortize the proving cost and (2) we consider the notion of aggregating unrelated statements, that is, one should assert the validity of statement without even knowing the other</p>

    <p class="text-gray-300">statements considered during aggregation. NOVA <em>[19]</em> is closer to our work in that it directly considers aggregating statements instead of proofs, in an attempt to minimize the proving cost.</p>

    <p class="text-gray-300">Perhaps closest to our work is <em>[22]</em>. There, they use a tree like structure similar to ours in order to derive the same Fiat-Shamir challenge across multiple parallel executions of an inner product argument protocol <em>[10]</em> with different parties. In particular, the protocol transcripts are committed in a Merkle tree so that each party can assert that its transcript was considered in the production of the challenge. We consider statement aggregation instead of executing multiple proofs in parallel which is conceptually different and more efficient.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Definitions</h2>

    <p class="text-gray-300">In this section we recall the definition of <em>folding schemes</em> for NP relations introduced in NOVA <em>[19]</em>. On a high level, given an NP language <span class="math">\\mathcal{L}</span> and the corresponding NP relation <span class="math">\\mathcal{R}</span>, a folding scheme allows a prover and a verifier to reduce the validity of 2 or more statements of the form <span class="math">x_{i}\\in\\mathcal{L}</span> to a single statement <span class="math">x\\in\\mathcal{L}</span>. The resulting statement is of the same form, so it can be further aggregated. A prover knowing witnesses <span class="math">w_{i}</span> s.t. <span class="math">(x_{i},w_{i})\\in\\mathcal{R}</span> for all the statements also obtains a witness <span class="math">w</span> for the folded statement <span class="math">x</span>.</p>

    <p class="text-gray-300">A folding scheme takes to the extreme <em>proof composition techniques</em> used to construct PCD <em>[3]</em> and IVC <em>[21]</em>. The core idea of these techniques is to incrementally prove statements that assert that (1) a computation step is performed correctly and (2) there exists a proof that asserts that the input of the computation in this step is correct. Using generic constructions, however, is extremely inefficient.</p>

    <p class="text-gray-300">To alleviate this, a recent line of work <em>[9, 12, 11, 4]</em> follows a different approach: they defer an expensive part of proof verification of the aforementioned proof and aggregate it with deferred parts from other steps. At any point, the verifier can perform this expensive part and assert that all steps of the computation are correct. Importantly, the aggregation part is cheap and the deferred part does not grow with the number of computational steps proven. Therefore, the expensive part is performed once for an arbitrarily large number of steps.</p>

    <p class="text-gray-300">NOVA takes this approach to the extreme in the following sense: <em>it defers the verification of the statement itself</em>. More concretely, the statement asserting the correctness of the first <span class="math">i-1</span> steps is encoded as a statement <span class="math">X\\in\\mathcal{L}</span> for some language and the correctness of the <span class="math">i</span>-th step as <span class="math">x\\in\\mathcal{L}</span> for the <em>same</em> language. The two statements are then “folded” to a new statement <span class="math">X^{*}\\in\\mathcal{L}</span>, correctness of which implies correctness of both statements. Since all statements are of the same form, the process can be repeated for an arbitrary number of steps and it is enough to prove the final statement to assert correctness of all steps.</p>

    <p class="text-gray-300">Assuming the existence of such a mechanism to fold statements, one can then encode in a circuit the verification process of this folding and construct an IVC scheme. Importantly, the folding verification is cheap, achieving very low recursion overheads.</p>

    <p class="text-gray-300">In our work, we consider using similar techniques, albeit for a different goal: aggregating statements to reduce the amortized proving cost of proving many different statements. That is, instead of encoding the folding verification as a circuit and build IVC, we directly use the folding scheme to allow a prover to prove the validity of a bunch of <span class="math">M</span> different statements using only a single proof by means of aggregation. Additionally, we present a mechanism, <em>selective verification</em> that allows a verifier to assert the correctness of one of the <span class="math">M</span> statements efficiently: it needs to know neither all the <span class="math">M</span> aggregated statements nor the entire proof of aggregation (which grows linearly in <span class="math">M</span>). It simply needs the proof of the final statement and a proof that is sublinear in <span class="math">M</span>.</p>

    <p class="text-gray-300">Taking into account that producing proofs is a computationally intense task, this allows much better amortized proving time with little overhead for verification. Indeed, <em>[19]</em> introduces a folding scheme construction that captures all NP computations and allows very fast statement aggregation.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Folding Schemes</h3>

    <p class="text-gray-300">We next present the formal definition of a folding scheme. The notion is essentially the same as presented in <em>[19]</em> with two modifications: we only consider a non-interactive definition, namely the prover simply presents a proof of correct folding to the verifier, and we consider a definition that allows aggregating <span class="math">M</span> statements instead of <span class="math">2</span> as it is discussed in NOVA. Looking ahead, our concrete instantiations will be folding schemes for <span class="math">2</span> statements that are then bootstrapped to folding schemes of <span class="math">M</span> statements using a generic bootstrapping compiler.</p>

    <p class="text-gray-300">The formalization of a folding scheme is quite natural. Given a number of instance/witness pairs <span class="math">(x_{i},w_{i})</span> that satisfy some NP relation, there exists a folding algorithm that outputs a new instance/witness pair <span class="math">(x,w)</span> that also satisfies the NP relation, along with some evidence <span class="math">\\pi</span> that the new instance <span class="math">x</span> is indeed a "folded" statement derived from the statements <span class="math">x_{i}</span>. One can think of the folded statement as encoding all statements of interest. The properties required are:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>completeness</em>, stating that if we aggregate instance-witness pairs <span class="math">(x_{i},w_{i})</span> satisfying the NP relation, then (1) folding results in an instance-witness pair also satisfying the relation and (2) the folding proof is accepted;</li>

      <li><em>knowledge soundness</em>, stating that if after correct aggregation the proving party knows a witness for the resulting statement, then it should also know witnesses for all statements <span class="math">(x_{i},w_{i})</span> that were considered during aggregation.</li>

    </ol>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1 (Folding scheme)</h6>

    <p class="text-gray-300">Let <span class="math">\\lambda\\in\\mathbb{N}</span> be a security parameter and <span class="math">\\mathcal{L}_{\\mathsf{pp}}</span> be an NP language parametrized by some parameters <span class="math">\\mathsf{pp}(\\lambda)</span> depending on <span class="math">\\lambda</span> and <span class="math">\\mathcal{R}_{\\mathsf{pp}}</span> the corresponding relation. Finally, let <span class="math">M=\\mathsf{poly}(\\lambda)</span>. An <span class="math">M</span>-folding scheme <span class="math">\\mathsf{FS}</span> for the language family <span class="math">\\mathcal{L}=\\{\\mathcal{L}_{\\mathsf{pp}}\\}_{\\mathsf{pp}\\in\\{0,1\\}^{*}}</span> is a tuple of an algorithms <span class="math">\\mathsf{FS}=(\\mathsf{Fold},\\mathsf{FoldVrfy})</span> such that for all <span class="math">\\mathsf{pp}=\\mathsf{pp}(\\lambda)</span> and <span class="math">m\\leq M</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x,w,\\pi)\\leftarrow\\mathsf{Fold}\\left(\\mathsf{pp},x_{1},w_{1},\\ldots,x_{m},w_{m}\\right)</span>: takes as input the parameters <span class="math">\\mathsf{pp}</span>, and <span class="math">m</span> instance-witness pairs <span class="math">(x_{i},w_{i})\\in\\mathcal{L}_{\\mathsf{pp}}</span> and outputs a new instance-witness pair <span class="math">(x,w)\\in\\mathcal{R}_{\\mathsf{pp}}</span> and a proof of correct folding <span class="math">\\pi</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">0/1 \\leftarrow \\text{FoldVrfy}(\\mathsf{pp}, x_1, \\ldots, x_m, x, \\pi)</span>: takes as input the parameters <span class="math">\\mathsf{pp}</span>, <span class="math">m</span> instances <span class="math">x_i</span>, an aggregated statement <span class="math">x</span> and a proof of correct folding <span class="math">\\pi</span> and outputs a bit indicating whether folding was done correctly or not,</li>

    </ul>

    <p class="text-gray-300">that satisfies the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness</strong>: for all <span class="math">m \\leq M</span>, all <span class="math">\\mathsf{pp} = \\mathsf{pp}(\\lambda)</span> and all (even computationally unbounded) algorithms <span class="math">\\mathcal{A}</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c} \\{q _ {1}, \\ldots , q _ {m} \\} \\subseteq \\mathcal {R} _ {\\mathsf {p p}} \\wedge \\\\ ((x, w) \\notin \\mathcal {R} _ {\\mathsf {p p}} \\lor b = 0) \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (x _ {1}, w _ {1}), \\ldots , (x _ {m}, w _ {m}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ q _ {1} = (x _ {1}, w _ {1}), \\ldots , q _ {m} = (x _ {m}, w _ {m}) \\\\ (x, w, \\pi) \\leftarrow \\mathsf {F o l d} (\\mathsf {p p}, \\mathbf {q}) \\\\ b \\leftarrow \\mathsf {F o l d V r f y} (\\mathsf {p p}, \\mathbf {x}, x, \\pi) \\end{array} \\right. \\right] \\leq \\mathsf {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Knowledge soundness</strong>: for all <span class="math">m \\leq M</span> and all <span class="math">\\mathsf{pp} = \\mathsf{pp}(\\lambda)</span> there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that for all PPT algorithms <span class="math">\\mathcal{A}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c} (x, w) \\in \\mathcal {R} _ {\\mathsf {p p}} \\wedge \\\\ b = 1 \\wedge \\\\ \\exists 1 \\leq i \\leq m \\text{ s.t. } (x _ {i}, w _ {i}) \\notin \\mathcal {R} _ {\\mathsf {p p}} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathbf {x}, x, w, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\mathbf {w} \\leftarrow \\mathcal {E} ^ {\\mathcal {A}} (\\mathsf {p p}) \\\\ b \\leftarrow \\mathsf {F o l d V r f y} (\\mathsf {p p}, \\mathbf {x}, x, \\pi) \\end{array} \\right. \\right] \\leq \\mathsf {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In Sec. 4 we present 2-folding schemes for various relations: inner product relations of committed values, vector and polynomial commitment openings and the relaxed R1CS relation of [19]. We derive the constructions by means of public coin protocols that we compile to a non-interactive variant through the Fiat-Shamir heuristic.</p>

    <p class="text-gray-300"><strong>Remark 1.</strong> We emphasize that after folding the statements, the corresponding witnesses are not needed. In particular, the witnesses are only used to construct the witness for the final folded statement and then they can be safely deleted. Indeed, to assert the validity of all statements, it is enough to (1) present the proof of correct folding and (2) convince about the validity of the folded statement. The latter can be done using only the folded statement/witness pair, for example with a SNARK. Put it differently, while the folded statements "encodes" all the aggregated statements by means of a folding proof, it is also -in some sense- independent of them after the folding has taken place.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.2 Folding Schemes with Selective Verification</h2>

    <p class="text-gray-300">As we discuss in the introduction, the main goal of this work to allow to reduce the resources used in "as a service" scenarios: a prover needs to serve multiple verifiers in a trustless way. A characteristic example is a prover that verifiably outsources its computational resources to verifiers who need to perform arbitrary computations.</p>

    <p class="text-gray-300">We emphasize that this is a different goal from NOVA [19] and related works, which aim to achieve proof composition and construct IVC schemes. In our case, there are natural additional properties one would want to achieve. Perhaps the most natural is to allow verifying single statements that are "encoded" in the</p>

    <p class="text-gray-300">folded statements without the need to know or even care about the validity of the rest of the statements. Let us elaborate on this.</p>

    <p class="text-gray-300">Consider the case where a prover wants to serve <span class="math">m</span> statements for <span class="math">m</span> different parties. Simple folding is indeed a means to that goal: the prover needs to convince for the validity of a single statement to convince all verifiers about the validity of all <span class="math">m</span> statements. Nevertheless, it is still inefficient in terms of verification. The inefficiency stems from the fact that in order to verify correct folding, all the statements need to be considered as part of the proof of correct aggregation.</p>

    <p class="text-gray-300">While this is natural in cases where a single verifier is interested in many statements, it can be prohibitive in scenarios where multiple verifiers are interested in the validity of different statements: first, the verifiers need to know each others’ queries to the prover to assert validity of the folded statement, and second, the verification cost scales linearly with the total number of statements considered.</p>

    <p class="text-gray-300">In this section, we mitigate this issue by considering a stronger notion of folding schemes that allows to assert that a single statement was considered during aggregation of multiple statements -and hence knowledge of a witness of the latter implies knowledge of the witness of the former, without the need to know all the statements involved. Importantly, verification of inclusion of a single statement to the folded statement is <em>sublinear</em> in the total number of statements involved. We call this stronger notion folding with <em>selective verification</em>.</p>

    <p class="text-gray-300">We require (and later achieve) a strong version of this notion: one can derive a proof of inclusion of a single statement to a folded statement <em>only by knowing the aggregated statements and the proof of correct folding</em>. In particular, creation of such a proof does not require any witness information on the statements and can be performed by parties different than the prover. Looking ahead, our bootstrapping construction achieves this property by simply handing <em>parts</em> of the folding proof corresponding to each statement, each being sublinear (logarithmic) in the total size of the folding proof.</p>

    <p class="text-gray-300">We next define the stronger notion of a folding scheme that supports <em>selective verification</em>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2 (Folding scheme with selective verification)</h6>

    <p class="text-gray-300">Let <span class="math">\\lambda\\in\\mathbb{N}</span> be a security parameter and <span class="math">\\mathcal{L}_{\\mathsf{pp}}</span> be an NP language parametrized by some parameters <span class="math">\\mathsf{pp}(\\lambda)</span> depending on <span class="math">\\lambda</span> and <span class="math">\\mathcal{R}_{\\mathsf{pp}}</span> the corresponding relation. Finally, let <span class="math">M=\\mathsf{poly}(\\lambda)</span> and let <span class="math">\\mathsf{FS}=(\\mathsf{Fold},\\mathsf{FoldVrfy})</span> be an <span class="math">M</span>-folding scheme for <span class="math">\\mathcal{L}=\\{\\mathcal{L}_{\\mathsf{pp}}\\}_{\\mathsf{pp}\\in\\{0,1\\}^{<em>}}</span>. <span class="math">\\mathsf{FS}</span> has </em>selective verification* if there exists a pair of algorithms <span class="math">(\\mathsf{SelPrv},\\mathsf{SelVrfy})</span> such that for all <span class="math">m\\leq M</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\pi_{1},\\ldots,\\pi_{m})\\leftarrow\\mathsf{SelPrv}(\\mathsf{pp},x_{1},\\ldots,x_{m},x,\\pi)</span>: takes as input the parameters <span class="math">\\mathsf{pp}</span>, <span class="math">m</span> instances <span class="math">x_{1},\\ldots,x_{m}</span>, a folded instance <span class="math">x</span> and a folding proof <span class="math">\\pi</span> and outputs <span class="math">m</span> proofs <span class="math">\\pi_{1},\\ldots,\\pi_{m}</span>,</li>

      <li><span class="math">0/1\\leftarrow\\mathsf{SelVrfy}(\\mathsf{pp},x,i,x_{i},\\pi_{i})</span>: takes as input the parameters <span class="math">\\mathsf{pp}</span>, a folded statement <span class="math">x</span>, a position <span class="math">i\\in\\{1,\\ldots,m\\}</span>, a statement <span class="math">x_{i}</span> and a proof <span class="math">\\pi_{i}</span> and outputs a bit indicating if <span class="math">x_{i}</span> was aggregated (among other statements) to <span class="math">x</span></li>

    </ul>

    <p class="text-gray-300">that satisfies the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Selective completeness: for all <span class="math">m \\leq M</span>, all <span class="math">\\mathsf{pp} = \\mathsf{pp}(\\lambda)</span> and all (even computationally unbounded) algorithms <span class="math">\\mathcal{A}</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\{q _ {1}, \\ldots , q _ {m} \\} \\subseteq \\mathcal {R} _ {\\mathsf {p p}} \\wedge &amp;amp; x _ {1}, w _ {1}, \\ldots , x _ {m}, w _ {m} \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\exists i \\in \\{1, \\ldots , m \\}: &amp;amp; q _ {1} = (x _ {1}, w _ {1}), \\ldots , q _ {m} = (x _ {m}, w _ {m}) \\\\ b _ {i} = 0 &amp;amp; (x, w, \\pi) \\leftarrow \\mathsf {F o l d} (\\mathsf {p p}, \\mathbf {q}) \\\\ &amp;amp; (\\pi_ {1}, \\ldots , \\pi_ {m}) \\leftarrow \\mathsf {S e l P r v} (\\mathsf {p p}, \\mathbf {x}, x, \\pi) \\\\ &amp;amp; b _ {i} \\leftarrow \\mathsf {S e l V r f y} (\\mathsf {p p}, x, i, x _ {i}, \\pi_ {i}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Selective knowledge soundness: for all <span class="math">m \\leq M = \\mathrm{poly}(\\lambda)</span> and all <span class="math">\\mathsf{pp} = \\mathsf{pp}(\\lambda)</span> there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that for all PPT algorithms <span class="math">\\mathcal{A}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c} \\mathsf {S e l V r f y} (\\mathsf {p p}, x, i, x _ {i}, \\pi_ {i}) = 1 \\wedge \\\\ (x, w) \\in \\mathcal {R} _ {\\mathsf {p p}} \\wedge (x _ {i}, w _ {i}) \\notin \\mathcal {R} _ {\\mathsf {p p}} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (i, x _ {i}, \\pi_ {i}, x, w) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ w _ {i} \\leftarrow \\mathcal {E} ^ {\\mathcal {A}} (\\mathsf {p p}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Efficiency: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= o(m \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, namely, the proof size should be asymptotically smaller than the total size of folded statements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The definition captures that if (1) the prover knows a valid witness <span class="math">w</span> for the folded statement <span class="math">x</span> and (2) the <span class="math">i</span>-th proof verifies, then it should be the case that the prover knows witness <span class="math">w_i</span> such that <span class="math">(x_i, w_i) \\in \\mathcal{R}_{\\mathfrak{pp}}</span>. Note that from the perspective of a party asserting the validity of <span class="math">x_i</span>, it is not necessary to know the other statements considered in the construction of <span class="math">x</span>. Furthermore, the other statements need not be honestly generated; even if the adversary samples them, knowledge of the witness of the <span class="math">i</span>-th statement is still guaranteed.</p>

    <p class="text-gray-300">The efficiency condition rules out trivial constructions. Without it, one could set the proof of statement <span class="math">i</span> to be simply the set of all aggregated statements along with a proof of correct folding. The verifier would then simply need to check that one of the statements corresponds to the one that is of interest to her. The interesting part of the definition is to achieve the same goal with sublinear communication.</p>

    <p class="text-gray-300">Finally, note that we do not require the extractor to be able to extract all <span class="math">m</span> statements that would "explain" the folded statement <span class="math">x</span>; rather, we ask that given a witness for the folded statement and a valid proof, we can extract a witness only for the <span class="math">i</span>-th statement. This is exactly what one would want for selective verification since ultimately, this is a local property: we want to ensure that some statement is correct without caring how we end up with the folded statement; the latter is simply a means to verify correctness of the statement of interest.</p>

    <p class="text-gray-300">In this section we show how to bootstrap any 2-folding scheme to an <span class="math">M</span>-folding scheme for any polynomial <span class="math">M</span>. Additionally, the bootstrapped construction satisfies the stronger notion of selective verifiability. Thus, to construct a selectively</p>

    <p class="text-gray-300">verifiable folding scheme, it is enough to construct a simple 2-folding scheme – which as we shall see is a relatively simple task using <span class="math">\\Sigma</span>-protocol techniques– and simply applying the bootstrapping compiler.</p>

    <p class="text-gray-300">The crucial observation to bootstrapping is that statement aggregation is by definition “incremental”. The fact that the folded statement is of the same form as the folded ones directly implies that we can further fold the former with a new statement. A simple argument shows the final statement “encodes” all three statements and a single proof for it along with the two folding proofs is convincing for the validity of all. The process can be repeated an arbitrary amount of times.</p>

    <p class="text-gray-300">To achieve the additional property of selective verifiability we only rely on combinatorial properties: instead of incrementally aggregating statements, we arrange them in a <em>statement tree</em>. Thus, the fact that a single statement is “encoded” in the final folded statement only depends on a small amount of statements: the ones that consist the path from the leaf (statement we want a proof for) to the root (folded statement). Thus, the corresponding proof is sublinear in the number of statements, consisting of the folding proofs for the statements in this path.</p>

    <p class="text-gray-300">We next present the bootstrapping construction and then we show that it also achieves the stronger notion of selective verifiability.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.1 Construction</h3>

    <p class="text-gray-300">Our construction allows to derive an <span class="math">M</span>-folding scheme from any 2-folding scheme.</p>

    <p class="text-gray-300">Roughly, to aggregate <span class="math">M=2^{k}</span> (w.l.o.g.) statements, we create a <em>statement aggregation tree</em> as follows. We build a tree by putting the statements on the leaves of the tree and we fold each pair of them resulting in <span class="math">2^{k-1}</span> statements of the same form. Then we proceed recursively until we are left with a single statement.</p>

    <p class="text-gray-300">To prove that the folded statement encodes all the statements, we give a proof <span class="math">\\pi</span> consisting of all the 2-folding proofs we made along the way to derive the root of the tree.</p>

    <p class="text-gray-300">It is easy to see that the construction satisfies knowledge soundness. Consider the final 2-folding proving that the root is the folded statement of its two children. Given a valid witness for the folded statement and a proof of correct aggregation, we can extract witnesses for its two children –guaranteed by the knowledge soundness of the base 2-folding scheme.</p>

    <p class="text-gray-300">We emphasize that our construction is incremental as well: the final statement –having the same form as the folded statement– can be furthered aggregated if needed.</p>

    <p class="text-gray-300">5 The bootstrapping construction can in fact bootstrap any m -folding scheme for m \\geq 2 . We only present the m = 2 case for ease of presentation. All constructions in this work are derived from 2-folding schemes but one could in fact consider m &gt; 2 to improve concrete efficiency.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Demonstration of the process of deriving the folding tree. We assume we fold  <span class="math">2^{k}</span>  statements (the leaves of the tree). We index with the position of the node in the tree in binary and we use superscript for the level of the node in the tree. A node  <span class="math">x_{\\mathbf{b}}^{(l)}</span>  is computed as the (non-interactive) folding of  <span class="math">x_{\\mathbf{b0}}^{(l - 1)}</span>  and  <span class="math">x_{\\mathbf{b1}}^{(l - 1)}</span>  using the underlying scheme FS. The aggregation proof consists of all the folding proof performed.</p>

    <p class="text-gray-300">We give a pictorial representation of the construction in Fig. 1 and present the bootstrapping construction in Fig. 2. Next we show that the resulting construction is an  <span class="math">M</span> -folding scheme for any polynomial size  <span class="math">m</span> .</p>

    <p class="text-gray-300">Theorem 1. Let FS be a 2-folding scheme for a language family  <span class="math">\\mathcal{L}</span>  with corresponding relations  <span class="math">\\mathcal{R}</span> . Then, for any constant constant  <span class="math">k \\in \\mathbb{N}</span> , construction BootstrapFS of Fig. 2 is a  <span class="math">2^k</span> -folding scheme for the same language family.</p>

    <p class="text-gray-300">Proof. Completeness follows directly by straightforward calculations and the completeness of BootstrapFS. We next show that BootstrapFS satisfies knowledge soundness.</p>

    <p class="text-gray-300">Let  <span class="math">m = 2^k</span> ,  <span class="math">x_1, \\ldots, x_m</span>  be statements and  <span class="math">w</span>  a witness for the folded statement  <span class="math">x</span>  output by an adversary  <span class="math">\\mathcal{A}</span> . We construct an extractor  <span class="math">\\mathcal{E}</span>  that extracts the witnesses  <span class="math">w_1, \\ldots, w_m</span>  given a witness for the folded statement  <span class="math">w</span>  and a valid folding proof  <span class="math">\\pi</span> , that uses as a black box the extractor  <span class="math">\\mathcal{E}&#x27;</span>  for FS guaranteed to exist by knowledge soundness of FS.</p>

    <p class="text-gray-300">Consider the binary tree defined by the honest BootstrapFS.FoldVrfy algorithm: the leaves are defined in the first level by the statements, that is, we label each leaf with  <span class="math">(x_{1}^{(k)},\\bot),(x_{2}^{(k)},\\bot),\\ldots ,(x_{m}^{(k)},\\bot)</span>  where  <span class="math">x_{j}^{(k)} = x_{j}</span>  and for each pair of statements folded, we define a parent node connected to each of them labeled by the folded statement and the proof of correct folding. Note that verification passes, if</p>

    <p class="text-gray-300">BootstrapFS.Fold(pp,  <span class="math">q_{1} = (x_{1},w_{1}),\\ldots ,q_{m} = (x_{m},w_{m})</span>  ..</p>

    <p class="text-gray-300">Denote  <span class="math">m = 2^k</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">k = 0</span>  then output  <span class="math">q_{1}, \\pi_{1} = \\bot</span> , otherwise group the  <span class="math">2^{k}</span>  statements to 2 groups of  <span class="math">2^{k - 1}</span>  elements each and denote them  <span class="math">\\mathbf{q}_1, \\mathbf{q}_2</span></li>

      <li>Recursively compute:</li>

    </ul>

    <p class="text-gray-300"><span class="math">(\\tilde{q}_1 = (\\tilde{x}_1,\\tilde{w}_1),\\tilde{\\pi}_1)\\gets \\mathsf{BootstrapFS.Fold}(\\mathsf{pp},\\mathbf{q}_1)</span> <span class="math">(\\tilde{q}_2 = (\\tilde{x}_2,\\tilde{w}_2),\\tilde{\\pi}_2)\\gets \\mathsf{BootstrapFS.Fold}(\\mathsf{pp},\\mathbf{q}_2)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(q = (x, w), \\pi^{*}) \\gets \\mathsf{FS.Fold}(\\mathsf{pp}, \\tilde{q}_{1}, \\tilde{q}_{2})</span></li>

      <li>output  <span class="math">q, \\pi = (\\pi_1, \\pi_2, \\tilde{x}_1, \\tilde{x}_2, \\pi^*)</span></li>

    </ul>

    <p class="text-gray-300">BootstrapFS.FoldVrfy(pp,  <span class="math">x_{1},\\ldots ,x_{m},x,\\pi)</span></p>

    <p class="text-gray-300">Denote  <span class="math">m = 2^k</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">k = 0</span>  then output 1 iff  <span class="math">x = x_{1}</span> , otherwise</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>group the  <span class="math">2^{k}</span>  statements to 2 groups of  <span class="math">2^{k - 1}</span>  elements each and denote them  <span class="math">\\mathbf{x}_1, \\mathbf{x}_2</span></li>

      <li>parse the proof as  <span class="math">\\pi = (\\pi_1, \\pi_2, \\tilde{x}_1, \\tilde{x}_2, \\pi^*)</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>recursively compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">b_{1}\\gets \\mathsf{BootstrapFS.FoldVrfy}(\\mathsf{pp},\\mathbf{x}_{1},\\tilde{x}_{1},\\tilde{\\pi}_{1})</span> <span class="math">b_{2}\\gets \\mathsf{BootstrapFS.FoldVrfy}(\\mathsf{pp},\\mathbf{x}_{2},\\tilde{x}_{2},\\tilde{\\pi}_{2})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\mathsf{FS.FoldVrfy}(\\mathsf{pp},\\tilde{x}_1,\\tilde{x}_2,x,\\pi^*)</span></li>

      <li>output  <span class="math">b \\wedge b_1 \\wedge b_2</span></li>

    </ul>

    <p class="text-gray-300">Fig. 2: Bootstrapping construction BootstrapFS for deriving an  <span class="math">m</span> -folding scheme from a 2-folding scheme FS. We assume (w.l.o.g.) that the number of initial statements is  <span class="math">2^k</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for any node labeled  <span class="math">(x_{j}^{(i - 1)},\\pi_{j}^{(i - 1)})</span>  with child nodes  <span class="math">(x_{2j - 1}^{(i)},\\cdot),(x_{2j}^{(i)},\\cdot)</span>  verification passes, namely, FS.FoldVrfy(pp,  <span class="math">x_{2j - 1}^{(i)},x_{2j}^{(i)},x_{j}^{(i - 1)},\\pi_{j}^{(i - 1)}) = 1</span></li>

      <li>the root node is labeled with  <span class="math">(x,\\cdot)</span></li>

    </ol>

    <p class="text-gray-300">We next show that for all such adversaries  <span class="math">\\mathcal{A}</span> , there exists a family of extractors  <span class="math">\\mathcal{E}_j^i</span>  for  <span class="math">0 \\leq i \\leq k-1</span> ,  <span class="math">1 \\leq j \\leq 2^i</span>  such that given as input a derived tree for some statements  <span class="math">x_1, \\ldots, x_m</span> ,  <span class="math">\\mathcal{E}_j^{(i)}</span>  extracts valid witnesses  <span class="math">w_{2j-1}^{(i+1)}, w_{2j}^{(i+1)}</span>  for the statements  <span class="math">x_{2j-1}^{(i+1)}, x_{2j}^{(i+1)}</span>  that are the children nodes of  <span class="math">x_j^{(i)}</span>  in the derived tree. The construction is recursive. We denote  <span class="math">\\mathcal{E}^{(*)}</span>  the trivial extractor that given the witness for the root node (output by the adversary  <span class="math">\\mathcal{A}</span> ), it simply outputs it.</p>

    <p class="text-gray-300">Base case:  <span class="math">\\mathcal{E}_1^{(0)}</span>  runs  <span class="math">\\mathcal{E}^{(*)}</span>  to get the witness  <span class="math">w_1^{(0)}</span>  for the root. It then queries the derived tree and constructs the adversary  <span class="math">\\mathcal{A}_1^{(0)}</span>  that outputs  <span class="math">x_1^{(1)}, x_2^{(1)}</span> , folded statement-witness pair  <span class="math">x_1^{(0)}, w_1^{(0)}</span>  and proof  <span class="math">\\pi_1^{(0)}</span>  which is part of the label of the root node. Finally, it invokes  <span class="math">\\mathcal{E}&#x27;</span>  with access to  <span class="math">\\mathcal{A}_1^{(0)}</span>  to derive witnesses  <span class="math">w_1^{(1)}, w_2^{(1)}</span>  for the statements  <span class="math">x_1^{(1)}, x_2^{(1)}</span> .</p>

    <p class="text-gray-300">Recursive case: Now, let  <span class="math">i \\geq 1</span>  and consider any  <span class="math">j</span>  with  <span class="math">1 \\leq j \\leq 2^i</span> . We construct an extractor  <span class="math">\\mathcal{E}_j^{(i)}</span>  assuming the existence of an extractor for a level closer to the root node. Let  <span class="math">(x_{p(j)}^{(i-1)}, \\cdot)</span>  denote the label of the parent node of</p>

    <p class="text-gray-300">the node labeled with <span class="math">(x_{j}^{(i)},\\pi_{j}^{(i)})</span> and let <span class="math">(x_{2j-1}^{(i+1)},\\cdot),(x_{2j}^{(i+1)},\\cdot)</span> be the labels of the children of <span class="math">x_{j}^{(i)}</span>. Now, we construct <span class="math">\\mathcal{A}_{j}^{(i)}</span> that has hardcoded the binary tree and works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It invokes the extractor <span class="math">\\mathcal{E}_{p(j)}^{(i-1)}</span> corresponding to statement <span class="math">x_{p(j)}^{(i-1)}</span> to get a witness <span class="math">w_{j}^{(i)}</span> for <span class="math">x_{j}^{(i)}</span> (and all its siblings which it ignores).</li>

      <li>It then constructs an adversary <span class="math">\\mathcal{A}_{j}^{(i)}</span> that outputs <span class="math">x_{2j-1}^{(i+1)},x_{2j}^{(i+1)}</span>, the folded statement-witness pair <span class="math">x_{j}^{(i)},w_{j}^{(i)}</span> and the proof of correct folding <span class="math">\\pi_{j}^{(i)}</span> contained in the node label.</li>

      <li>Finally, it invokes the extractor <span class="math">\\mathcal{E}^{\\prime}</span> of FS with access to <span class="math">\\mathcal{A}_{j}^{(i)}</span> and gets witnesses <span class="math">w_{2j-1}^{(i+1)},w_{2j}^{(i+1)}</span>.</li>

      <li>It outputs witnesses <span class="math">w_{2j-1}^{(i+1)},w_{2j}^{(i+1)}</span>.</li>

    </ul>

    <p class="text-gray-300">We are now ready to construct the extractor <span class="math">\\mathcal{E}</span>. <span class="math">\\mathcal{E}</span> queries <span class="math">\\mathcal{A}</span> to get statements <span class="math">x_{1},\\ldots,x_{m}</span>, a folded statement-witness pair <span class="math">(x_{1}^{(0)},w_{1}^{(0)})</span> and a proof of correct folding <span class="math">\\pi</span>. It then uses the proof and the statements to construct the tree, queries the extractors <span class="math">\\mathcal{E}_{1}^{(k-1)},\\ldots,\\mathcal{E}_{m/2}^{(k-1)}</span> -each of which outputs 2 witnesses for 2 leaf nodes- and concatenates their outputs.</p>

    <p class="text-gray-300">Let’s now consider the running time and the probability of success of the extractor <span class="math">\\mathcal{E}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the running time, let <span class="math">t(\\lambda)</span> be the running time of <span class="math">\\mathcal{E}^{\\prime}</span> and denote <span class="math">t_{i}(\\lambda)</span> the running time of an extractor on level <span class="math">i</span> (note that all these extractors are identical). By construction, we have that <span class="math">t_{i}(\\lambda)=t_{i-1}(\\lambda)+t(\\lambda)</span> and $t_{0}(\\lambda)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, namely the time to output the folded witness </span>w<span class="math">. This recurrence relation corresponds to </span>t_{i}(\\lambda)=i\\cdot t(\\lambda)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Finally, the running time of the extractor </span>\\mathcal{E}$ is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">t_{\\mathcal{E}}(\\lambda,k)</span> <span class="math">=t_{\\textsf{BootstrapFS}}(\\lambda,k)+2^{k-1}t_{k-1}(\\lambda)=</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$=t_{\\textsf{BootstrapFS}}(\\lambda,k)+2^{k-1}(k-1)\\cdot t(\\lambda)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">t_{\\textsf{BootstrapFS}}(k)</span> is the time of BootstrapFS.FoldVrfy algorithm for folding <span class="math">m=2^{k}</span> statements (equivalently the time needed to construct the statement tree). This corresponds to a quasilinear overhead <span class="math">m\\log m</span> for the time of the extractor <span class="math">\\mathcal{E}</span>, which is polynomial for any number of polynomial statements.</p>

    <p class="text-gray-300">We next show that the advantage of <span class="math">\\mathcal{E}</span> is polynomially related to that of <span class="math">\\mathcal{E}^{\\prime}</span>. We denote with <span class="math">p^{\\prime}</span> the probability that extractor <span class="math">\\mathcal{E}^{\\prime}</span> succeeds in outputting the witnesses in FS conditioned on <span class="math">\\mathcal{A}</span> outputting a valid witness for the folded statement and a verifying proof, namely,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ p^{\\prime}=\\Pr\\left[\\left.\\left\\{(x_{1},w_{1}),(x_{2},w_{2})\\right\\}\\subseteq\\mathcal{R}_{\\mathsf{pp}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(x_{1},x_{2},x,w,\\pi)\\leftarrow\\mathcal{A}(\\mathsf{pp})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(w_{1},w_{2})\\leftarrow\\mathcal{E}^{\\prime\\mathcal{A}}(\\mathsf{pp})\\\\ \\textsf{FoldVrfy}\\left(\\mathsf{pp},x_{1},x_{2},x,\\pi\\right)=1\\\\ (x,w)\\in\\mathcal{R}_{\\mathsf{pp}}\\end{array}\\right]\\end{array} \\]</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Claim.</h6>

    <p class="text-gray-300">Consider any adversary <span class="math">\\mathcal{A}</span> against BootstrapFS and the folding tree derived by its output. Fix <span class="math">i,j</span> such that <span class="math">0\\leq i\\leq k-1</span> and <span class="math">1\\leq j\\leq 2^{i}</span> and consider</p>

    <p class="text-gray-300">the tree node <span class="math">(x_{j}^{(i)},\\pi_{j}^{(i)})</span> and let <span class="math">(x_{2j-1}^{(i+1)},\\cdot),(x_{2j}^{(i+1)},\\cdot)</span> be its children. Let <span class="math">W_{i}</span> be the event that the extractor <span class="math">\\mathcal{E}_{j}^{(i)}</span> outputs a valid witness for all the children nodes of <span class="math">x_{j}^{(i)}</span>, that is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$W_{i}=\\bigg{\\{}\\left\\{(x_{2j-1}^{(i+1)},w_{2j-1}^{(i+1)}),(x_{2j}^{(i+1)},w_{2j}^{(i+1)})\\right\\}\\subseteq\\mathcal{R}_{\\mathsf{pp}}\\bigg{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\begin{matrix}(x_{1},\\ldots,x_{m},x,w,\\pi)\\leftarrow\\mathcal{A}(\\mathsf{pp})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(w_{2j-1}^{(i+1)},w_{2j}^{(i+1)})\\leftarrow\\mathcal{E}_{j}^{(i)}\\,\\mathcal{A}(\\mathsf{pp})\\end{matrix}\\bigg{\\}}$</p>

    <p class="text-gray-300">Then <span class="math">\\Pr[W_{i}]\\geq p^{\\prime}\\Pr[W_{i-1}]</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We have <span class="math">\\Pr[W_{i}]\\geq\\Pr[W_{i}\\mid W_{i-1}]\\Pr[W_{i-1}]</span>. Now, the probability of <span class="math">W_{i}</span> conditioned on <span class="math">W_{i-1}</span> is the probability that an extractor on the <span class="math">i</span>-th level succeeds conditioned on the probability that the extractor on level <span class="math">i-1</span> succeeds. If the extractor of the parent node succeeds, then its output contains a valid statement/witness <span class="math">x_{j}^{(i)},w_{j}^{(i)}</span> and therefore <span class="math">\\mathcal{A}_{j}^{(i)}</span> outputs a valid folded witness by construction. Thus, the probability of this event is exactly <span class="math">p^{\\prime}</span>.</p>

    <p class="text-gray-300"><span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">Solving the recurrence relation gives that <span class="math">\\Pr[W_{k-1}]\\geq p^{\\prime k-2}\\Pr[W_{1}]</span>. Now, <span class="math">\\Pr[W_{1}]</span> is the probability that the extractor associated with the root node outputs valid witnesses assuming that <span class="math">\\mathcal{A}</span> outputs a valid witness for the (final) folded statement. This means that, conditioned on <span class="math">\\mathcal{A}</span> outputting a valid witness, <span class="math">\\Pr[W_{k-1}]\\geq p^{\\prime k-1}</span>.</p>

    <p class="text-gray-300">Finally, consider the probability that <span class="math">\\mathcal{E}</span> succeeds conditioned on <span class="math">\\mathcal{A}</span> outputting a valid witness. This events happens if all extractors in level <span class="math">k-1</span> succeed. So, the probability that <span class="math">\\mathcal{E}</span> fails is bounded by <span class="math">\\frac{m}{2}(1-p^{\\prime k-1})=2^{k-1}(1-p^{\\prime k-1})</span>. Noting that</p>

    <p class="text-gray-300"><span class="math">1-{p^{\\prime}}^{k-1}=(1-p^{\\prime})({p^{\\prime}}^{k-2}+\\cdots+1)\\leq(1-p^{\\prime})(k-1)</span></p>

    <p class="text-gray-300">we get for any adversaries <span class="math">\\mathcal{A},\\mathcal{A}^{\\prime}</span> against knowledge soundness of <span class="math">\\mathsf{BootstrapFS}</span> and <span class="math">\\mathsf{FS}</span> respectively, <span class="math">\\mathsf{Adv}_{\\mathcal{A}}(\\lambda,k)\\leq(k-1)2^{k-1}\\mathsf{Adv}_{\\mathcal{A}^{\\prime}}(\\lambda)</span> ∎</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">As noted in Remark 1, after performing a folding and computing a witness for the folded statement, there is no need to store the witnesses for the initial statements any more. We note that this is the case for the compiled construction as well. In particular, in applications where the statements to be aggregated are “streamed” the prover can be implemented to perform the folding by storing only three witness at any time. This can drastically reduce the memory requirements for aggregation.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">NOVA and similar related work inherently rely on heuristic arguments for security. In particular, to construct IVC schemes, it is inherent in the techniques used in these works that one needs to encode the folding/proof aggregation in a circuit and prove statements about it. Since aggregation relies on the random oracle, one needs to instantiate it using a hash function and prove statements about it. Thus, we need to make the heuristic argument that the hash function instantiation is secure. In contrast, our application does not involve encoding the folding argument in a circuit and proving statements about it. Therefore, our construction does not need to rely on such heuristic arguments. In particular, our construction is secure in the random oracle model.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 3: Demonstration of the process of deriving the folding tree. We assume we fold  <span class="math">2^{k}</span>  statements (the leaves of the tree). We index with the position of the node in the tree in binary and we use superscript for the level of the node in the tree. A node  <span class="math">x_{\\mathbf{b}}^{(l)}</span>  is computed as the (non-interactive) folding of  <span class="math">x_{\\mathbf{b0}}^{(l - 1)}</span>  and  <span class="math">x_{\\mathbf{b1}}^{(l - 1)}</span>  using the underlying scheme FS. Bold edges denote the path the verification follows and rectangles the statements the prover presents to the verifier of statement  <span class="math">i</span> .</p>

    <p class="text-gray-300">Our bootstrapping construction also satisfies the stronger notion of selective verifiability without further modifications. This follows by the tree structure employed: proving inclusion of a single statement needs only to consider the foldings occurring from the root node (final statement) to the leaf corresponding to the statement in consideration. This is similar to how tree-based vector commitment schemes (e.g. Merkle trees) work.</p>

    <p class="text-gray-300">A crucial observation is that if we have a statement of the form  <span class="math">x_{1} \\in \\mathcal{L}</span>  and we are presented with a different statement  <span class="math">x_{2} \\in \\mathcal{L}</span> , after folding these to a third statement  <span class="math">x \\in \\mathcal{L}</span> , knowledge of a witness for the latter ensures knowledge for both statements (in particular the first which is of interest to us) even if the second is selected adversarially. This means that from the perspective of a verifier interested in a specific statement, it is not important what other statements are considered or how they are sampled as long as they correctly end up to the claimed aggregated statement.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first demonstrate how a statement "inclusion" proof works in Fig. 3. Next, we formally present the algorithms that lead to selective verifiability of the bootstrapped construction in Fig. 4. The resulting protocol achieves selective verifiability with proof size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathcal{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot k)<span class="math">  when folding  </span>m = 2^k$  statements. This means we can aggregate polynomially many statements while each statement can be verified with a proof that is logarithmic in the number of statements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An important observation, as far as efficiency is concerned, is that the proofs themselves are folded statements with their corresponding proofs, and thus yield little overhead to produce/verify –assuming the underlying folding scheme is concretely efficient. Essentially, the prover has to perform  <span class="math">\\mathcal{O}(2^k)</span>  number of foldings and simply save the intermediate results in the process to be able to present as evidence later. As we will see in the next section, folding itself can be extremely efficient for many languages of interest. In some cases, the overhead induced by folding for the prover is comparable to the time needed to simply read the statements. This can lead to significant improvements compared to -for example-producing a SNARK proof for each statement.</p>

    <p class="text-gray-300">We next show that the bootstrapped construction equipped with the additional algorithms presented in Fig. 4 achieves the stronger notion of selective verifiability. The proof is essentially identical to that of Thm. 1; the only difference is that we simply focus on a small part of the implicit tree which we construct using the elements contained in the proof for a single statement.</p>

    <p class="text-gray-300">BootstrapFS.SelPrv(pp,  <span class="math">x_{1},\\ldots ,x_{m},x,\\pi</span>  ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the input  <span class="math">(\\mathbf{x},x,\\pi)</span>  as a tree where</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x_{1}^{(k)},\\bot),\\ldots ,(x_{m}^{(k)},\\bot)</span>  are the leaves</li>

      <li>For each pair of nodes  <span class="math">x_{L} = (x_{2j - 1}^{(\\ell)},\\bot)</span> ,  <span class="math">x_{R} = (x_{2j}^{(\\ell)},\\bot)</span>  add the node  <span class="math">(x_{F},\\pi_{F}) = (x_{j}^{(\\ell -1)},\\pi_{j}^{(\\ell -1)})</span>  where  <span class="math">\\pi_F</span>  is a proof of correctness of the folding of  <span class="math">x_{L},x_{R}</span>  to  <span class="math">x_{F}</span> , namely:</li>

    </ul>

    <p class="text-gray-300">FS.FoldVrfy(pp,  <span class="math">x_{L},x_{R},x_{F},\\pi_{F}) = 1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">1 \\leq j \\leq m</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>set  <span class="math">\\pi_j \\coloneqq ()</span></li>

      <li>Let  <span class="math">j = b_{k} \\cdots b_{1}</span>  in binary notation</li>

      <li>For  <span class="math">1 \\leq \\ell \\leq k</span> :</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\pi_j \\coloneqq \\left(\\pi_j, \\left(x_{b_k \\cdots b_{k-\\ell+2}}^{(0)}, x_{b_k \\cdots b_{k-\\ell+2}}^{(0)}, \\pi_{b_k \\cdots b_{k-\\ell+2}}^{(0)}\\right)\\right)</span></p>

    <p class="text-gray-300">Output  <span class="math">\\pi_1,\\ldots ,\\pi_m</span></p>

    <p class="text-gray-300">BootstrapFS.SelVrfy(pp,  <span class="math">x,j,x_{j},\\pi_{j}</span>  ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">j = b_{k} \\cdots b_{1}</span>  in binary notation.</li>

      <li>Set  <span class="math">x_{1}^{(0)} = x</span></li>

      <li>Parse  <span class="math">\\pi_j = \\left((x_0^{(1)}, x_1^{(1)}, \\pi_1^{(0)}), \\ldots, (x_{b_k \\cdots b_2 0}^{(k)}, x_{b_k \\cdots b_2 1}^{(k)}, \\pi_{b_k \\cdots b_2}^{(k-1)})\\right)</span></li>

      <li>For  <span class="math">1 \\leq \\ell \\leq k</span></li>

    </ul>

    <p class="text-gray-300">Set  <span class="math">x_{L} = x_{b_{k}\\dots b_{k - \\ell +20}}^{(\\ell)},x_{R} = x_{b_{k}\\dots b_{k - \\ell +21}}^{(\\ell)},</span></p>

    <p class="text-gray-300">Set  <span class="math">x_{F} = x_{b_{k}\\dots b_{k - \\ell +2}}^{(\\ell -1)}</span> <span class="math">\\pi_F = \\pi_{b_k\\dots b_k - \\ell +2}^{(\\ell -1)}</span> <span class="math">b_{\\ell}\\coloneqq \\mathsf{FS.FoldVrfy}(\\mathsf{pp},x_L,x_R,x_F,\\pi_F)</span></p>

    <p class="text-gray-300">Output  <span class="math">b_{1}\\wedge \\dots \\wedge b_{\\ell}\\wedge (x_{j} = x_{b_{k}\\dots b_{1}}^{(k)})</span></p>

    <p class="text-gray-300">Fig. 4: The SelPrv, SelVrfy that make construction BootstrapFS achieve selective verification. We again assume (w.l.o.g.) that the number of initial statements is  <span class="math">m = 2^k</span>  for some fixed constant  <span class="math">k</span> .</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{FS}</span> be a <span class="math">2</span>-aggregation scheme for a language family <span class="math">\\mathcal{L}</span> with corresponding relations <span class="math">\\mathcal{R}</span> Then, for any constant <span class="math">k</span> construction <span class="math">\\mathsf{BootstrapFS}</span> of Fig. 2 satisfies selective verification through the algorithms of Fig. 4</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume (w.l.o.g.) that <span class="math">m=2^{k}</span>. Selective completeness follows directly by straightforward calculations and the completeness of <span class="math">\\mathsf{BootstrapFS}</span>. Efficiency follows by the fact that a proof of inclusion of statement <span class="math">i</span> contains <span class="math">\\mathcal{O}(\\log m)</span> statements of <span class="math">\\mathcal{L}_{\\mathsf{pp}}</span> and proofs of correct folding, which are polynomially related to the size of the statement. We next show that <span class="math">\\mathsf{BootstrapFS}</span> satisfies selective knowledge soundness.</p>

    <p class="text-gray-300">To simplify matters, we define the notion of the <em>derived <span class="math">\\ell</span>-th sub-tree</em> defined by the proof, a statement <span class="math">x_{\\ell}</span> and the folded statement. Concretely, we consider the sub-tree defined by the proof for the <span class="math">\\ell</span>-th statement <span class="math">\\pi_{\\ell}</span>: it contains the part of the statement tree defined from the root to the leaf node <span class="math">(x_{\\ell},\\bot)</span> along with all the sibling nodes in the path.</p>

    <p class="text-gray-300">Now let <span class="math">(\\ell,x_{\\ell},\\pi,x)</span> and the derived sub-tree defined by these values. As in the previous proof, we construct recursively a series of extractors, one for each <span class="math">i</span> with <span class="math">0\\leq i\\leq k-1</span>.</p>

    <p class="text-gray-300">Base case: For <span class="math">i=0</span>, <span class="math">\\mathcal{E}_{0}^{(1)}</span> runs <span class="math">\\mathcal{E}^{(*)}</span> to get the witness <span class="math">w_{1}^{(0)}</span> for the root. It then queries the derived sub-tree and constructs the adversary <span class="math">\\mathcal{A}_{1}^{(0)}</span> that outputs <span class="math">x_{1}^{(1)},x_{2}^{(1)},x_{1}^{(0)},w_{1}^{(0)},\\pi_{0}^{(1)}</span>. Finally, it invokes <span class="math">\\mathcal{E}^{\\prime}</span> with access to <span class="math">\\mathcal{A}_{1}^{(1)}</span> to get corresponding witnesses <span class="math">w_{1}^{(1)},w_{2}^{(1)}</span>.</p>

    <p class="text-gray-300">Recursive case: Let <span class="math">x^{(1)},\\ldots,x^{(k)}</span> be the statements contained in path from the root of the derived sub-tree to the leaf labeled with <span class="math">(x_{i},\\bot)</span> and let <span class="math">(x_{1}^{(i+1)},\\cdot)</span>, <span class="math">(x_{2}^{(i+1)},\\cdot)</span> be the labels of the children of <span class="math">x^{(i)}</span>. Now, we construct <span class="math">\\mathcal{A}^{(i)}</span> that has hardcoded the derived sub-tree and works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It invokes the extractor <span class="math">\\mathcal{E}^{(i-1)}</span> corresponding to the parent statement <span class="math">x^{(i-1)}</span> to get a witness <span class="math">w^{(i)}</span> for statement <span class="math">x^{(i)}</span> (and all its siblings which it ignores).</li>

      <li>It then constructs an adversary <span class="math">\\mathcal{A}^{(i)}</span> that outputs <span class="math">x_{1}^{(i+1)},x_{2}^{(i+1)},x^{(i)},w^{(i)}</span> and the proof <span class="math">\\pi^{(i)}</span>.</li>

      <li>Finally, it invokes the extractor <span class="math">\\mathcal{E}^{\\prime}</span> of <span class="math">\\mathsf{FS}</span> with access to <span class="math">\\mathcal{A}^{(i)}</span> and gets witnesses <span class="math">w_{1}^{(i+1)},w_{2}^{(i+1)}</span> which it then outputs.</li>

    </ul>

    <p class="text-gray-300">We then construct the extractor <span class="math">\\mathcal{E}</span>. <span class="math">\\mathcal{E}</span> queries <span class="math">\\mathcal{A}</span> to get <span class="math">\\ell,x_{\\ell},x,\\pi</span> and a witness for the folded statement <span class="math">w_{1}^{(1)}</span>. Then it simply queries <span class="math">\\mathcal{E}^{(k-1)}</span> and outputs the witness corresponding to <span class="math">x_{\\ell}</span>.</p>

    <p class="text-gray-300">Working as in the proof of Thm. 1, we can deduce that the running time of the extractor is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$t_{\\mathcal{E}}(\\lambda,k)=t_{\\mathsf{SelVrfy}}(\\lambda,k)+(k-1)\\cdot t(\\lambda)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">t_{\\mathsf{SelVrfy}}(\\lambda,k)</span> is the time of <span class="math">\\mathsf{BootstrapFS.SelVrfy}</span> algorithm and <span class="math">t(\\lambda)</span> is the time of the extractor <span class="math">\\mathcal{E}^{\\prime}</span> of <span class="math">\\mathsf{FS}</span>.</p>

    <p class="text-gray-300">Finally, for the success probability of the extractor, it is enough to note that the proof verifies if the final folded statement computed during verification</p>

    <p class="text-gray-300">is the same as the claimed statement by the adversary <span class="math">\\mathcal{A}</span>, which means it is accompanied by a valid witness in the case of successful adversaries. Working as in the proof of Thm. 1 we get that for any adversaries <span class="math">\\mathcal{A},\\mathcal{A}^{\\prime}</span> against selective knowledge soundness of <span class="math">\\mathsf{BootstrapFS}</span> and knowledge soundness of <span class="math">\\mathsf{FS}</span> respectively,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}(\\lambda,k)\\leq(k-1)\\mathsf{Adv}_{\\mathcal{A}^{\\prime}}(\\lambda)</span></p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-21" class="text-2xl font-bold">4 Folding Schemes from Interactive Public Coin Protocols</h2>

    <p class="text-gray-300">In this section we present folding schemes for various relations. We present four constructions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a folding scheme for the language of inner product relations of committed values under algebraic commitments,</li>

      <li>a folding scheme for the language of openings of algebraic vector commitments,</li>

      <li>a folding scheme for the language of openings of polynomial commitments at the same point.</li>

    </ol>

    <p class="text-gray-300">We also recall the 2-folding scheme construction of NOVA <em>[19]</em> that allows to fold arbitrary (variants of) R1CS relations that capture general compuatation.</p>

    <p class="text-gray-300">All the constructions are derived through simple public coin protocols. Thus, they can be compiled to non-interactive folding schemes through the Fiat-Shamir transform. Selective verifiability can then be achieved by means of the bootstrapping construction of Fig. 2,4. In all constructions we assume a base folding scheme for folding <span class="math">m=2</span> statements.</p>

    <p class="text-gray-300">We emphasize that the folding overhead for all constructions is low. The prover is dominated by field operations and the verifier by group operations (constant for each 2-folding). Both need to also perform hash computations in the non-interactive version of the protocols. Nevertheless, since we do not need to encode the folding as a circuit and prove statements about it –as is done by previous works– we can instantiate the construction with any hash function instead of “SNARK friendly” ones. Thus, the overhead for hashing is insignificant.</p>

    <p class="text-gray-300">We start by introducing some notation for groups.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Notation.</h4>

    <p class="text-gray-300">We use additive notation for groups. Let <span class="math">\\mathsf{gk}</span> be the description of a group sampled by some group generation algorithm, <span class="math">\\mathsf{gk}\\leftarrow\\mathcal{G}(1^{\\lambda})</span>. Let <span class="math">\\mathcal{P}</span> be a fixed generator of the group described in <span class="math">\\mathsf{gk}</span>. We denote with <span class="math">[x]</span> the element <span class="math">x\\mathcal{P}</span>. We naturally extend this notation to vectors of elements. With this notation, a Pedersen commitment key is denoted as <span class="math">[\\mathbf{r}]\\in\\mathbb{G}^{n}</span> and a commitment to <span class="math">\\mathbf{x}\\in\\mathbb{F}^{n}</span> as <span class="math">[c]=[\\mathbf{r}]^{\\top}\\mathbf{x}</span>. We recall that the binding property states that it is computationally infeasible to find <span class="math">\\mathbf{x}\\neq\\mathbf{x}^{\\prime}</span> such that <span class="math">[\\mathbf{r}]^{\\top}\\mathbf{x}=[\\mathbf{r}]^{\\top}\\mathbf{x}^{\\prime}</span> given a uniformly distributed commitment key <span class="math">[\\mathbf{r}]</span>.</p>

    <p class="text-gray-300">20</p>

    <h2 id="sec-23" class="text-2xl font-bold">4.1 Folding Scheme for Inner Product Relation of Committed Values</h2>

    <p class="text-gray-300">Consider a language family <span class="math">\\mathcal{L}</span> containing languages parametrized by a group key <span class="math">\\mathbf{gk}</span> and two Pedersen commitment keys <span class="math">[\\mathbf{r}], [\\mathbf{s}] \\in \\mathbb{G}^n</span>, each consisting of <span class="math">n</span> uniformly distributed group elements<span class="math">^7</span>.</p>

    <p class="text-gray-300">The NP language is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_{\\mathbf{gk}, [\\mathbf{r}], [\\mathbf{s}]} = \\left\\{ \\left[ [c], [d], z \\right] \\mid \\exists \\mathbf{a}, \\mathbf{b} \\text{ s.t. } [c] = [\\mathbf{r}]^\\top \\mathbf{a}, [d] = [\\mathbf{s}]^\\top \\mathbf{b} \\text{ and } z = \\mathbf{a}^\\top \\mathbf{b} \\right\\}</span></div>

    <p class="text-gray-300">and let <span class="math">\\mathcal{R}_{\\mathbf{gk}, [\\mathbf{r}], [\\mathbf{s}]}</span> be the corresponding NP relation. We show how to fold two statements of this form to a single statement. The construction is similar with the folding technique of Bootle et. al. [7]. Let</p>

    <div class="my-4 text-center"><span class="math-block">q_1 = \\left( \\left[ [c_1], [d_1], z_1 \\right], \\left( \\mathbf{a}_1, \\mathbf{b}_1 \\right) \\right), \\quad q_2 = \\left( \\left[ [c_2], [d_2], z_2 \\right], \\left( \\mathbf{a}_2, \\mathbf{b}_2 \\right) \\right),</span></div>

    <p class="text-gray-300">such that (supposedly) <span class="math">q_1, q_2 \\in \\mathcal{R}_{\\mathbf{gk}, [\\mathbf{r}], [\\mathbf{s}]}</span>. The strategy to fold the statements is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathcal{P}</span> first sends "cross-term values" <span class="math">z_{1,2} = \\mathbf{a}_1^\\top \\mathbf{b}_2</span> and <span class="math">z_{2,1} = \\mathbf{a}_2^\\top \\mathbf{b}_1</span>.</li>

      <li>The verifier <span class="math">\\mathcal{V}</span> then sends a random challenge <span class="math">\\chi \\in \\mathbb{F}</span>.</li>

      <li>The prover and verifier construct the new statement <span class="math">([c], [d], z)</span> as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">[c] = [c_1] + \\chi [c_2], \\quad [d] = [d_1] + \\chi^2 [d_2], \\quad z = z_1 + \\chi z_{2,1} + \\chi^2 z_{1,2} + \\chi^3 z_2</span></div>

    <p class="text-gray-300">and the prover sets the new witness to <span class="math">\\mathbf{a} = \\mathbf{a}_1 + \\chi \\mathbf{a}_2</span>, <span class="math">\\mathbf{b} = \\mathbf{b}_1 + \\chi^2 \\mathbf{b}_2</span>.</p>

    <p class="text-gray-300">It is easy to assert that the new witness pair satisfies the NP relation as long as the two initial statements do. Intuitively, this satisfies soundness since (1) a prover being able to open a commitment of the form <span class="math">[\\alpha] + \\chi [\\beta]</span> for a random <span class="math">\\chi</span> should in fact know openings for the combined commitments since they are defined before the challenge <span class="math">\\chi</span> and (2) the "mixed" inner products <span class="math">z_{1,2}, z_{2,1}</span> are defined before the challenge <span class="math">\\chi</span> is known, which means that one could treat the resulting relation as a polynomial relation on a formal variable <span class="math">X</span>, that is <span class="math">\\mathbf{a}(X)^\\top \\mathbf{b}(X) = z(X)</span>. If this relation holds formally, then it is to assert that both <span class="math">\\mathbf{a}_1^\\top \\mathbf{b}_1 = z_1</span> and <span class="math">\\mathbf{a}_2^\\top \\mathbf{b}_2 = z_2</span> hold. The challenge essentially is a randomized test on this relation.</p>

    <p class="text-gray-300">We define the protocol formally in Fig. 5. Next, we show that (1) an honest prover always outputs a valid statement-witness pair, and (2) given an adversary that outputs a valid witness after the execution of the protocol for the folded statement, we can extract witnesses for the two statements <span class="math">x_1, x_2</span>. Note, that if this holds, the Fiat-Shamir compiled construction directly yields a non-interactive 2-folding scheme, where the proof is simply the pair of elements <span class="math">z_{1,2}, z_{2,1}</span> sent from the prover to the verifier.</p>

    <p class="text-gray-300"><span class="math">^7</span> The construction works for the generalized Pedersen commitment scheme, namely keys that are sampled from distributions other than the uniform one. The only requirement is that the distribution satisfies some hardness assumption that guarantees the commitment scheme is binding.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 5: Public coin protocol for folding statements for the language of inner product of openings of committed values.</p>

    <p class="text-gray-300">Theorem 3. Consider construction of fig. 5. Then the following conditions hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The resulting statement-witness pair defined after the end of the protocol satisfies the NP relation  <span class="math">\\mathcal{R}_{\\mathrm{gk},[\\mathbf{r}],[\\mathbf{s}]}</span>  and</li>

      <li>The protocol satisfies special-soundness, namely, given four accepting executions for distinct verifier challenges, we can extract witnesses  <span class="math">w_{1}, w_{2}</span>  for the initial statements  <span class="math">x_{1}, x_{2}</span>  except with negligible probability.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We simply need to verify the NP relation is satisfied. First, we check that the openings of the commitments are valid. We have</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {r} ] ^ {\\top} (\\mathbf {a} _ {1} + \\chi \\mathbf {a} _ {2}) = [ \\mathbf {r} ] ^ {\\top} \\mathbf {a} _ {1} + \\chi [ \\mathbf {r} ] ^ {\\top} \\mathbf {a} _ {2} = [ c _ {1} ] + \\chi [ c _ {2} ] = [ c ]</span></div>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {s} ] ^ {\\top} (\\mathbf {b} _ {1} + \\chi^ {2} \\mathbf {b} _ {2}) = [ \\mathbf {s} ] ^ {\\top} \\mathbf {b} _ {1} + \\chi^ {2} [ \\mathbf {s} ] ^ {\\top} \\mathbf {b} _ {2} = [ d _ {1} ] + \\chi^ {2} [ d _ {2} ] = [ d ]</span></div>

    <p class="text-gray-300">Finally, we assert that the inner product is correct. We have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {a} ^ {\\top} \\mathbf {b} = \\left(\\mathbf {a} _ {1} + \\chi \\mathbf {a} _ {2}\\right) ^ {\\top} \\left(\\mathbf {b} _ {1} + \\chi^ {2} \\mathbf {b} _ {2}\\right) \\\\ = \\mathbf {a} _ {1} ^ {\\top} \\mathbf {b} _ {1} + \\chi^ {2} \\mathbf {a} _ {1} ^ {\\top} \\mathbf {b} _ {2} + \\chi \\mathbf {a} _ {2} ^ {\\top} \\mathbf {b} _ {1} + \\chi^ {3} \\mathbf {a} _ {2} ^ {\\top} \\mathbf {b} _ {2} \\\\ = z _ {1} + \\chi^ {2} z _ {1, 2} + \\chi z _ {2, 1} + \\chi^ {3} z _ {2} = z \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assume we have four accepting executions of the interactive protocol with different challenges  <span class="math">\\chi_1, \\chi_2, \\chi_3, \\chi_4</span> . First we show that using any two transcripts we can extract valid openings for the commitments  <span class="math">[c_1], [d_1], [c_2], [d_2]</span> . We first focus on the commitments  <span class="math">[c_1], [c_2]</span> . After successful execution with</li>

    </ol>

    <p class="text-gray-300">challenges <span class="math">\\chi_{i},\\chi_{j}</span>, we have two openings <span class="math">\\mathbf{a}^{(i)}</span>, <span class="math">\\mathbf{a}^{(j)}</span> for commitments <span class="math">[c^{(i)}]=[c_{1}]+\\chi_{i}[c_{2}]</span> and <span class="math">[c^{(j)}]=[c_{1}]+\\chi_{j}[c_{2}]</span> respectively. This means that</p>

    <p class="text-gray-300"><span class="math">[c_{1}]+\\chi_{i}[c_{2}]=\\left[\\mathbf{r}\\right]^{\\top}\\mathbf{a}^{(i)},\\qquad[c_{1}]+\\chi_{j}[c_{2}]=\\left[\\mathbf{r}\\right]^{\\top}\\mathbf{a}^{(j)}</span></p>

    <p class="text-gray-300">Denote with <span class="math">\\mathbf{X}_{i,j}</span> the matrix whose first row is <span class="math">(1,\\chi_{i})</span> and second row is <span class="math">(1,\\chi_{j})</span> and note that this matrix is invertible for <span class="math">\\chi_{i}\\neq\\chi_{j}</span>. We can write the above system of equations as</p>

    <p class="text-gray-300">\\[ \\mathbf{X}_{i,j}\\begin{bmatrix}c_{1}\\\\ c_{2}\\end{bmatrix}=\\left[\\mathbf{r}\\right]^{\\top}\\begin{pmatrix}\\mathbf{a}^{(i)}\\\\ \\mathbf{a}^{(j)}\\end{pmatrix} \\]</p>

    <p class="text-gray-300">Denoting <span class="math">\\mathbf{X}_{i,j}^{-1}</span> the inverse of <span class="math">\\mathbf{X}_{i,j}</span> we get</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}c_{1}\\\\ c_{2}\\end{bmatrix}=\\left[\\mathbf{r}\\right]^{\\top}\\mathbf{X}_{i,j}^{-1}\\begin{pmatrix}\\mathbf{a}^{(i)}\\\\ \\mathbf{a}^{(j)}\\end{pmatrix} \\]</p>

    <p class="text-gray-300">so we indeed extract openings for the two commitments. Furthermore, note for any pair <span class="math">i\\neq j</span> with <span class="math">i,j\\in\\{1,2,3,4\\}</span> we extract the same openings <span class="math">\\mathbf{a}_{1},\\mathbf{a}_{2}</span> except with negligible probability, otherwise we break the binding property of the commitment scheme. Similarly, we extract openings <span class="math">\\mathbf{b}_{1},\\mathbf{b}_{2}</span> for the commitments <span class="math">[d_{1}],[d_{2}]</span>. Now, since we have an accepting witness for each of the four executions the following equations hold:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}^{(i)\\top}\\mathbf{b}^{(i)}=z_{1}+\\chi_{i}^{2}z_{1,2}+\\chi_{i}z_{2,1}+\\chi_{i}^{3}z_{2},\\qquad 1\\leq i\\leq 4</span></p>

    <p class="text-gray-300">Assuming that no breaking of the binding property has happened, each opening <span class="math">\\mathbf{a}^{(i)}</span> can be written as <span class="math">\\mathbf{a}^{(i)}=\\mathbf{a}_{1}+\\chi_{i}\\mathbf{a}_{2}</span> for the same <span class="math">\\mathbf{a}_{1},\\mathbf{a}_{2}</span> and similarly for the <span class="math">[d_{1}],[d_{2}]</span> commitments. We can now rewrite the above equations as</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathbf{a}_{1}+\\chi_{i}\\mathbf{a}_{2}\\right)^{\\top}(\\mathbf{b}_{1}+\\chi_{i}^{2}\\mathbf{b}_{2})=z_{1}+\\chi_{i}^{2}z_{1,2}+\\chi_{i}z_{2,1}+\\chi_{i}^{3}z_{2}</span></p>

    <p class="text-gray-300">or equivalently</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{1}{}^{\\top}\\mathbf{b}_{1}+\\chi_{i}\\mathbf{a}_{2}{}^{\\top}\\mathbf{b}_{1}+\\chi_{i}^{2}\\mathbf{a}_{1}{}^{\\top}\\mathbf{b}_{2}+\\chi_{i}^{3}{}^{\\top}\\mathbf{a}_{2}{}^{\\top}\\mathbf{b}_{2}=z_{1}+\\chi_{i}^{2}z_{1,2}+\\chi_{i}z_{2,1}+\\chi_{i}^{3}z_{2}</span></p>

    <p class="text-gray-300">Viewing this as a polynomial equation of degree <span class="math">3</span> and noting it is satisfied for <span class="math">4</span> distinct points, it should hold as a polynomial identity, therefore <span class="math">\\mathbf{a}_{1}{}^{\\top}\\mathbf{b}_{1}=z_{1}</span> and <span class="math">\\mathbf{a}_{2}{}^{\\top}\\mathbf{b}_{2}=z_{2}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">The work of the prover consists of a <em>linear number of field operations</em>, specifically, combining the two witness with the random challenge of the verifier <span class="math">\\chi</span> and computing the cross term inner products <span class="math">z_{1,2}</span> and <span class="math">z_{2,1}</span>. The verifier performs a constant number of operations in the field and group to derive the new statement. In the context of non-interactive folding with selective verification, folding <span class="math">M</span> statements of size <span class="math">n</span> consists of <span class="math">\\mathcal{O}(Mn)</span> field operations and <span class="math">\\mathcal{O}(M)</span> hash computations for the prover and <span class="math">\\mathcal{O}(\\log M)</span> field and group operations and hash computations for the verifier.</p>

    <p class="text-gray-300">4.2 Folding Scheme for Algebraic Vector Commitment Openings</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A vector commitment <em>[14]</em> allows a prover to succinctly commit to a vector <span class="math">\\mathbf{a}\\in\\mathbb{F}^{n}</span> and later verifiably open a subset <span class="math">S\\subseteq\\{1,\\ldots,n\\}</span> of the positions of the committed vector. We construct a folding scheme for the language of openings of algebraic vector commitments. Here, algebraic means that (1) the commitment key consists of a vector group elements and (2) the commitment algorithm is the inner product of the key with the committed vector given as elements in the field. In what follows, we denote with $\\mathbf{a}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}<span class="math"> the subvector of </span>\\mathbf{a}<span class="math"> defined by the set </span>S\\subseteq\\{1,\\ldots,n\\}$ More concretely, we consider the language</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{L}_{\\mathbf{gk},[\\mathbf{r}]}=\\left\\{([c],S,\\mathbf{a}_{S})\\mid\\exists\\mathbf{a}\\text{ s.t. }[c]=[\\mathbf{r}]^{\\top}\\mathbf{a}\\text{ and }\\mathbf{a}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}=\\mathbf{a}_{S}\\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our strategy for constructing a folding scheme for this relation is to reduce it to an inner product. That is, we first show that the language above can be interactively reduced to an inner product statement, and then we can use the folding scheme of the previous section for inner product relations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the reduction, we first note that the validity of an <span class="math">S</span>-subopening can be expressed as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> inner products: for each </span>s\\in S<span class="math"> we need to assert that </span>\\mathbf{a}^{\\top}\\mathbf{e}_{n,s}=a_{s}<span class="math">, where </span>\\mathbf{e}_{n,s}<span class="math"> is the </span>n<span class="math">-dimensional vector which is </span>0<span class="math"> everywhere except the </span>s<span class="math">-th condition. These </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ statements can be compressed to a single inner product by taking a sufficiently random linear combination of the equations. This is a well-known technique that reduces many inner products to a single “twisted” instance, as in <em>[7]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">That is, consider a vector <span class="math">\\mathbf{b}</span> that is <span class="math">b_{i}=0</span> for all <span class="math">i\\in\\{1,\\ldots,n\\}\\setminus S</span> and takes some different power of a challenge <span class="math">\\chi</span> in the rest of the positions, for some random element <span class="math">\\chi\\in\\mathbb{F}</span>. Then, with overwhelming probability the relation <span class="math">\\mathbf{a}^{\\top}\\mathbf{b}=\\mathbf{a}_{S}^{\\top}\\mathbf{b}</span> holds if and only if all the relations hold.</p>

    <p class="text-gray-300">We can now express the above as an instance of an inner product relation. Let <span class="math">[c]</span> be some committed value and <span class="math">\\mathbf{a}_{S}</span> a claimed opening at positions <span class="math">S</span>. The verifier reduces this claim to an inner product by doing the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- It samples <span class="math">\\chi\\leftarrow\\mathbb{F}</span> and constructs the vector $\\mathbf{b}=(1,\\chi,\\ldots,\\chi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It computes the inner product <span class="math">z=\\mathbf{a}_{S}^{\\top}\\mathbf{b}</span>.</li>

      <li>It sends <span class="math">\\chi</span> to the prover and asks to prove the IP statement <span class="math">([c],[d],z)</span></li>

    </ul>

    <p class="text-gray-300">A simple application of the Schwartz-Zippel lemma is enough to assert that <span class="math">([c],[d],z)</span> is a valid inner product statement if and only if the <span class="math">S</span> opening of <span class="math">[c]</span> is <span class="math">\\mathbf{a}_{S}</span> (except with negligible probability).</p>

    <p class="text-gray-300">We present the interactive reduction of VC opening to inner product in Fig. 6. After applying the reduction we can simply fold the reduced statement with other IP statements.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Consider construction of Fig. 6.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The resulting statement-witness pair defined after the end of the protocol satisfies the inner product NP relation <span class="math">\\mathcal{R}_{\\mathbf{gk},[\\mathbf{r}],[\\mathbf{r}]}</span>, and</li>

    </ol>

    <p class="text-gray-300"><span class="math">x = ([c],S,\\mathbf{a}_S),w = \\mathbf{a}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P: q = (x, w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V: x</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">x← F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b = (1, x, ..., x</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">b = (1, x, ..., x</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">-1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[d] = [r</td>

            <td class="px-3 py-2 border-b border-gray-700">S]T b</td>

            <td class="px-3 py-2 border-b border-gray-700">[d] = [r</td>

            <td class="px-3 py-2 border-b border-gray-700">S]T b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z = aS T b</td>

            <td class="px-3 py-2 border-b border-gray-700">z = aS T b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w' = a, b</td>

            <td class="px-3 py-2 border-b border-gray-700">x' = ([c], [d], z)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 6: Public coin protocol for interactively reducing a VC opening claim to an inner product claim.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. The protocol satisfies special-soundness, namely, given  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  valid statement-witness pairs after distinct verifier challenges, we can extract a valid witness  </span>w<span class="math">  for the initial statement  </span>x$  except with negligible probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\mathbf{b}&#x27;</span>  be the vector that agrees with  <span class="math">b</span>  on  <span class="math">S</span>  and is zero everywhere in  <span class="math">\\{1, \\ldots, n\\} \\setminus S</span>  and note this corresponds to an opening of  <span class="math">[d]</span> . We have</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">z = \\mathbf {a} ^ {\\top} \\mathbf {b} ^ {\\prime} = \\sum_ {i = 1} ^ {n} a _ {i} b _ {i} ^ {\\prime} = \\sum_ {s \\in S} a _ {s} b _ {s} ^ {\\prime} = \\sum_ {s \\in S} a _ {s} b _ {s} = \\mathbf {a} _ {S} ^ {\\top} \\mathbf {b}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. After each execution, we get a valid opening  <span class="math">\\mathbf{a}</span>  for  <span class="math">[c]</span> . All these openings should be the same except with negligible probability, otherwise we break the binding property of the vector commitment. We next show that  $\\mathbf{a}_S = \\mathbf{a}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}<span class="math"> . Since each inner product is valid, the following relation is satisfied for each execution  </span>\\mathbf{a}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}\\mathbf{b} = \\mathbf{a}_S\\mathbf{b}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Equivalently, we have  $(\\mathbf{a}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} - \\mathbf{a}_S)^\\top \\mathbf{b} = 0<span class="math"> . Next, note that, since each  </span>\\mathbf{b}<span class="math">  encodes monomials of degree bounded by  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">  derived from some field element  </span>\\chi<span class="math"> , this corresponds to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  polynomial relations of the form  </span>p(\\chi) = 0<span class="math"> . Since  </span>p<span class="math"> &#x27;s degree is bounded by  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">  and it has  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  roots, it should be the case that  </span>p<span class="math">  is identically zero, which means that  </span>(\\mathbf{a}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} = \\mathbf{a}_S)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The only efficiency overhead for both the prover and the verifier is to compute the values  <span class="math">[d], z</span>  each needing  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  field and group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A polynomial commitment scheme [18] is a primitive that allows a prover to succinctly commit to a polynomial and later open it at an arbitrary point. Our</p>

    <p class="text-gray-300">next construction allows to fold statements about openings of polynomial commitments at the same point  <span class="math">v</span> . We assume a linearly homomorphic polynomial commitment, namely if  <span class="math">[c], [d]</span>  are commitments to  <span class="math">p(X), q(X)</span> , then  <span class="math">\\alpha[c] + \\beta[d]</span>  is a commitment to  <span class="math">\\alpha p(X) + \\beta q(X)</span> . The language is parameterized by parameters and a key for a polynomial commitment scheme  <span class="math">\\mathsf{pp}, \\mathsf{ck}</span>  as well as an opening point  <span class="math">v \\in \\mathbb{F}</span> . We assume that all polynomials are of a fixed degree  <span class="math">d</span> ; generalizing this to achieve any degree  <span class="math">d \\leq D</span>  for some bound  <span class="math">D</span>  and hiding commitments is also possible. Formally, the language is defined as</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathsf{pp},\\mathsf{ck},v} = \\left\\{[c],y\\mid \\exists p(X)\\in \\mathbb{F}^{\\leq d}[X]\\text{s.t.} [c] = \\mathsf{Com}_{\\mathsf{pp},\\mathsf{ck}}(p(X))\\text{and} p(v) = y\\right\\}</span></p>

    <p class="text-gray-300">The construction follows simple techniques of [11]. We combine the two polynomial commitments with a random challenge from the verifier. We present the construction in Fig. 7. We present a theorem capturing the properties of the protocol next.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 7: Public coin protocol for folding statements for the openings of polynomial commitments.</p>

    <p class="text-gray-300">Theorem 5. Consider construction of Fig. 7. Then the following conditions hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The resulting statement-witness pair defined after the end of the protocol satisfies the NP relation  <span class="math">\\mathcal{R}_{\\mathrm{pp,ck},v}</span> , and</li>

      <li>The protocol satisfies special-soundness, namely, given two accepting executions for distinct verifier challenges, we can extract witnesses  <span class="math">w_{1}, w_{2}</span>  for the initial statements  <span class="math">x_{1}, x_{2}</span>  except with negligible probability.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This follows directly by the homomorphic properties of the commitment scheme.</li>

      <li>For special soundness, it is enough to note that given  <span class="math">d + 1</span>  valid transcripts for different challenges, we can solve a linear system of equations of the form  <span class="math">p^{(i)}(X) = p_1(X) + \\chi_i p_2(X)</span>  to get coefficients for polynomials  <span class="math">p_1(X), p_2(X)</span>  that are valid openings for  <span class="math">[c_1], [c_2]</span>  respectively. Additionally, consider any</li>

    </ol>

    <p class="text-gray-300">pair of these equations and note that if the final statement is valid, then <span class="math">p^{(i)}(v) = y^{(i)}</span> for two distinct <span class="math">i</span>. This means that <span class="math">p_1(v) + \\chi_i p_2(v) = y^{(i)} = y_1 + \\chi_i y_2</span>. This system admits a unique solution, namely, <span class="math">p_1(v) = y_1</span> and <span class="math">p_2(v) = y_2</span>.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">Efficiency. In this construction, the proof of correct folding is trivial: the challenge <span class="math">\\chi</span> fully defines the aggregated statement and witness pair. The work of the prover and verifier consists of a linear number of field operations and a constant number of group operations, respectively. In the context of non-interactive folding with selective verification, aggregating <span class="math">M</span> statements of size <span class="math">n</span> is dominated by <span class="math">\\mathcal{O}(Md)</span> field operations and <span class="math">\\mathcal{O}(M)</span> hash computations for the prover and <span class="math">\\mathcal{O}(\\log M)</span> group operations and hash computations for the verifier.</p>

    <h2 id="sec-30" class="text-2xl font-bold">4.4 Folding Scheme for Committed Relaxed R1CS</h2>

    <p class="text-gray-300">NOVA [19] introduces a generalization the R1CS characterization of NP, called relaxed R1CS which is amenable to folding, that is, there exists an efficient folding scheme for this language. Roughly, given three <span class="math">m \\times m</span> matrices <span class="math">\\mathbf{A}, \\mathbf{B}, \\mathbf{C}</span>, the relaxed R1CS language parameterized by these matrices and a natural number <span class="math">n &amp;lt; m</span> is defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_{\\mathbf{A}, \\mathbf{B}, \\mathbf{C}}^{\\text{relaxed}} = \\left\\{(\\mathbf{x}, u, \\mathbf{e}) \\in \\mathbb{F}^n \\times \\mathbb{F} \\times \\mathbb{F}^m \\mid \\exists \\mathbf{w} \\in \\mathbb{F}^{m-n} \\text{ s.t.} \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{z} = \\begin{pmatrix} \\mathbf{x} \\\\ u \\\\ \\mathbf{w} \\end{pmatrix} \\wedge \\mathbf{A} \\mathbf{z} \\circ \\mathbf{B} \\mathbf{z} = u \\mathbf{C} \\mathbf{z} + \\mathbf{e} \\Big\\}</span></div>

    <p class="text-gray-300">It is easy to see that this language indeed captures <span class="math">NP</span>: we can just consider instances with <span class="math">u = 1</span> and <span class="math">\\mathbf{e} = \\mathbf{0}</span>. These extra terms are introduced so as to be able to fold two statements to a single statement without changing the language structure. They then modify the language to be compatible with commit and prove techniques. In what follows we denote with <span class="math">\\mathcal{C}</span> the commitment space for an additively homomorphic commitment scheme<span class="math">^8</span>. One can simply consider the (generalized) Pedersen commitment scheme.</p>

    <p class="text-gray-300">The new relation, denoted Committed Relaxed R1CS is described next:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathcal{L}_{\\mathrm{ck}_1,\\mathrm{ck}_2,\\mathbf{A},\\mathbf{B},\\mathbf{C}}^{\\mathrm{c-relaxed}} &amp;amp;= \\left\\{(\\mathbf{x}, u, [e], [w]) \\in \\mathbb{F}^n \\times \\mathbb{F} \\times \\mathcal{C}^2 \\mid \\exists (\\mathbf{w}, \\mathbf{e}) \\in \\mathbb{F}^{m-n} \\times \\mathbb{F}^m \\text{ s.t.} \\right. \\\\ &amp;amp;\\quad [w] = \\operatorname{Com}_{\\mathrm{ck}_1}(\\mathsf{pp}, \\mathbf{w}) \\wedge [e] = \\operatorname{Com}_{\\mathrm{ck}_2}(\\mathsf{pp}, \\mathbf{e}) \\wedge \\\\ &amp;amp;\\quad \\left. \\left((\\mathbf{x}, u, \\mathbf{e}), \\mathbf{w}\\right) \\in \\mathcal{R}_{\\mathbf{A}, \\mathbf{B}, \\mathbf{C}}^{\\text{relaxed}} \\right\\} \\end{aligned}</span></div>

    <p class="text-gray-300">We recall NOVA's 2-folding scheme for the latter relation in Fig. 8.</p>

    <p class="text-gray-300">Since this construction (when made non-interactive by means of the Fiat-Shamir transform) is a 2-folding scheme, we can directly apply the bootstrapping</p>

    <p class="text-gray-300"><span class="math">^8</span> We omit the blinding factor for the commitment schemes for the sake of simplicity.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 8: Public coin protocol for folding statements for the openings of polynomial commitments.</p>

    <p class="text-gray-300">construction that allows us to achieve selective verification. The limitation of the constructions stems from the fact that the two initial instances have to describe the same computation.</p>

    <p class="text-gray-300">We state the fact that there exists a non-interactive folding scheme for this language. We refer the reader to [19, Sec. 5] for the underlying details.</p>

    <p class="text-gray-300">Theorem 6. There exists a non-interactive 2-folding scheme for the family of languages of committed relaxed R1CS. The prover's computation is dominated by  <span class="math">\\mathcal{O}(m)</span>  field operations and the verifier's work is dominated by  <span class="math">\\mathcal{O}(\\ell)</span>  field operations and a constant number of group and field operations. Both prover and verifier also need to perform a hash function computation.</p>

    <p class="text-gray-300">This corresponds to [19, Construction 3] and is obtained by applying the Fiat-Shamir transform to the interactive folding scheme [19, Construction 2].</p>

    <p class="text-gray-300">Efficiency. There is a minimal overhead for the prover, who -apart from a linear number in hash computations- does little more work than reading the witnesses: almost all of its work consists of field operations. The verifier performs a logarithmic number of hash computations and group operations. It additionally needs to do  <span class="math">n \\log M</span>  field operations, where  <span class="math">M</span>  is the total number of folded statements. The latter part can be reduced to  <span class="math">\\log M</span>  group operations if one considers a variation of the language where the part of the statement  <span class="math">x</span>  is succinctly committed as well.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: TCC 2016-B, Part II. Ed. by Martin Hirt and Adam D. Smith. Vol. 9986. LNCS. Springer, Heidelberg, 2016, pp. 31–60. doi: 10.1007/978-3-662-53644-5_2.</li>

      <li>[2] Eli Ben-Sasson et al. “Zerocash: Decentralized Anonymous Payments from Bitcoin”. In: 2014 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2014, pp. 459–474. doi: 10.1109/SP.2014.36.</li>

      <li>[3] Nir Bitansky et al. “Recursive composition and bootstrapping for SNARKS and proof-carrying data”. In: 45th ACM STOC. Ed. by Dan Boneh, Tim Roughgarden, and Joan Feigenbaum. ACM Press, June 2013, pp. 111–120. doi: 10.1145/2488608.2488623.</li>

      <li>[4] Dan Boneh et al. “Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 649–680. doi: 10.1007/978-3-030-84242-0_23.</li>

      <li>[5] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. “Linear-Time Arguments with Sublinear Verification from Tensor Codes”. In: TCC 2020, Part II. Ed. by Rafael Pass and Krzysztof Pietrzak. Vol. 12551. LNCS. Springer, Heidelberg, Nov. 2020, pp. 19–46. doi: 10.1007/978-3-030-64378-2_2.</li>

      <li>[6] Jonathan Bootle, Alessandro Chiesa, and Siqi Liu. “Zero-Knowledge Succinct Arguments with a Linear-Time Prover”. In: IACR Cryptol. ePrint Arch. (2020), p. 1527. url: https://eprint.iacr.org/2020/1527.</li>

      <li>[7] Jonathan Bootle et al. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: EUROCRYPT 2016, Part II. Ed. by Marc Fischlin and Jean-Sébastien Coron. Vol. 9666. LNCS. Springer, Heidelberg, May 2016, pp. 327–357. doi: 10.1007/978-3-662-49896-5_12.</li>

      <li>[8] Jonathan Bootle et al. “Gemini: Elastic SNARKs for Diverse Environments”. In: IACR Cryptol. ePrint Arch. (2022), p. 420. url: https://eprint.iacr.org/2022/420.</li>

      <li>[9] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. https://eprint.iacr.org/2019/1021. 2019.</li>

      <li>[10] Benedikt Bünz et al. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: 2018 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2018, pp. 315–334. doi: 10.1109/SP.2018.00020.</li>

      <li>[11] Benedikt Bünz et al. “Proof-Carrying Data Without Succinct Arguments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 681–710. doi: 10.1007/978-3-030-84242-0_24.</li>

      <li>[12] Benedikt Bünz et al. “Recursive Proof Composition from Accumulation Schemes”. In: TCC 2020, Part II. Ed. by Rafael Pass and Krzysztof Pietrzak.</li>

    </ul>

    <p class="text-gray-300">Vol. 12551. LNCS. Springer, Heidelberg, Nov. 2020, pp. 1–18. doi: 10.1007/978-3-030-64378-2_1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[13] Matteo Campanelli et al. Lunar: a Toolbox for More Efficient Universal and Updatable zkSNARKs and Commit-and-Prove Extensions. Cryptology ePrint Archive, Report 2020/1069. https://eprint.iacr.org/2020/1069. 2020.</li>

      <li>[14] Dario Catalano and Dario Fiore. “Vector Commitments and Their Applications”. In: PKC 2013. Ed. by Kaoru Kurosawa and Goichiro Hanaoka. Vol. 7778. LNCS. Springer, Heidelberg, 2013, pp. 55–72. doi: 10.1007/978-3-642-36362-7_5.</li>

      <li>[15] Alessandro Chiesa et al. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: EUROCRYPT 2020, Part I. Ed. by Anne Canteaut and Yuval Ishai. Vol. 12105. LNCS. Springer, Heidelberg, May 2020, pp. 738–768. doi: 10.1007/978-3-030-45721-1_26.</li>

      <li>[16] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive, Report 2019/953. https://eprint.iacr.org/2019/953. 2019.</li>

      <li>[17] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating computation: interactive proofs for muggles”. In: 40th ACM STOC. Ed. by Richard E. Ladner and Cynthia Dwork. ACM Press, May 2008, pp. 113–122. doi: 10.1145/1374376.1374396.</li>

      <li>[18] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: ASIACRYPT 2010. Ed. by Masayuki Abe. Vol. 6477. LNCS. Springer, Heidelberg, Dec. 2010, pp. 177–194. doi: 10.1007/978-3-642-17373-8_11.</li>

      <li>[19] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: CRYPTO 2022. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13510. Lecture Notes in Computer Science. Springer, 2022, pp. 359–388. doi: 10.1007/978-3-031-15985-5\\_13. url: https://doi.org/10.1007/978-3-031-15985-5\\_13.</li>

      <li>[20] Noga Ron-Zewi and Ron Rothblum. “Proving as Fast as Computing: Succinct Arguments with Constant Prover Overhead”. In: Electron. Colloquium Comput. Complex. (2021), p. 180. url: https://eccc.weizmann.ac.il/report/2021/180.</li>

      <li>[21] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: TCC 2008. Ed. by Ran Canetti. Vol. 4948. LNCS. Springer, Heidelberg, Mar. 2008, pp. 1–18. doi: 10.1007/978-3-540-78524-8_1.</li>

      <li>[22] Thomas Yurek et al. hbACSS: How to Robustly Share Many Secrets. Cryptology ePrint Archive, Report 2021/159. https://eprint.iacr.org/2021/159. 2021.</li>

    </ul>`;
---

<BaseLayout title="Folding Schemes with Selective Verification (2022/1576)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1576
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
