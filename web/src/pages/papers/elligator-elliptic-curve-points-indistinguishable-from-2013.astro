---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/325';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Elligator: Elliptic-curve points indistinguishable from uniform random strings';
const AUTHORS_HTML = 'Daniel J.  Bernstein, Mike Hamburg, Anna Krasnova, Tanja Lange';

const CONTENT = `    <p class="text-gray-300">Daniel J. Bernstein<span class="math">^{1,4}</span> djb@cr.yp.to</p>

    <p class="text-gray-300">Mike Hamburg<span class="math">^{2}</span> mhamburg@cryptography.com</p>

    <p class="text-gray-300">Anna Krasnova<span class="math">^{3}</span> anna@mechanical-mind.org</p>

    <p class="text-gray-300">Tanja Lange<span class="math">^{4}</span> tanja@hyperelliptic.org</p>

    <p class="text-gray-300"><span class="math">^{1}</span>Department of Computer Science, University of Illinois at Chicago, USA <span class="math">^{2}</span>Cryptography Research, a division of Rambus, USA <span class="math">^{3}</span>Privacy &amp; Identity lab, Institute for Computing and Information Sciences, Radboud University Nijmegen, The Netherlands <span class="math">^{4}</span>Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands</p>

    <h2 id="sec-2" class="text-2xl font-bold">ABSTRACT</h2>

    <p class="text-gray-300">Censorship-circumvention tools are in an arms race against censors. The censors study all traffic passing into and out of their controlled sphere, and try to disable censorship-circumvention tools without completely shutting down the Internet. Tools aim to shape their traffic patterns to match unblocked programs, so that simple traffic profiling cannot identify the tools within a reasonable number of traces; the censors respond by deploying firewalls with increasingly sophisticated deep-packet inspection.</p>

    <p class="text-gray-300">Cryptography hides patterns in user data but does not evade censorship if the censor can recognize patterns in the cryptography itself. In particular, elliptic-curve cryptography often transmits points on known elliptic curves, and those points are easily distinguishable from uniform random strings of bits.</p>

    <p class="text-gray-300">This paper introduces high-security high-speed elliptic-curve systems in which elliptic-curve points are encoded so as to be indistinguishable from uniform random strings. At a lower level, this paper introduces a new bijection between strings and about half of all curve points; this bijection is applicable to every odd-characteristic elliptic curve with a point of order 2, except for curves of <span class="math">j</span>-invariant 1728. This paper also presents guidelines to construct, and two examples of, secure curves suitable for these encodings.</p>

    <h2 id="sec-3" class="text-2xl font-bold">Categories and Subject Descriptors</h2>

    <p class="text-gray-300">E.3 [Data encryption]: Public key cryptosystems</p>

    <h2 id="sec-4" class="text-2xl font-bold">Keywords</h2>

    <p class="text-gray-300">Censorship circumvention; elliptic curves; injective maps</p>

    <h2 id="sec-5" class="text-2xl font-bold">1. INTRODUCTION</h2>

    <p class="text-gray-300">Elliptic-curve cryptography (ECC) is arguably the most important tool in modern public-key cryptography. It provides public-key encryption, signatures, non-interactive key exchange, and many higher-level security features. It offers an attractive combination of high security, high speed, and (often critical for deployment) small space consumption.</p>

    <p class="text-gray-300">However, for applications in censorship circumvention, ECC has a security problem. ECC protocols naturally send elliptic-curve points in the clear as long-term public keys, ephemeral public keys, ciphertext prefixes, challenges, etc. These points, even in compressed form, are obvious: they are easy to distinguish from uniform random strings.</p>

    <p class="text-gray-300">There have been some ad-hoc workarounds for this problem, notably for ElGamal ciphertext prefixes, using a curve-or-twist technique introduced by Möller (see below). But each new ECC-based protocol faces the same problem. Protocol designers unaware of the issue continue building protocols that are trivially visible to attackers. Designers requiring keys and ciphertexts to be indistinguishable from uniform are forced to modify those protocols, hoping that the modifications do not compromise other forms of security.</p>

    <p class="text-gray-300">The main goal of this paper is to eliminate this problem. The solution presented here works for a wide range of elliptic-curve protocols, essentially every protocol in which the transmitted curve points are generated at random. There is no longer any need for, e.g., ad-hoc handling of ciphertext prefixes; this paper's technique works for all of the types of elliptic-curve points mentioned above.</p>

    <h2 id="sec-6" class="text-2xl font-bold">1.1 Distinguishers</h2>

    <p class="text-gray-300">We use the standard NIST P-256 elliptic curve as an example to illustrate the difficulties. A public key on the NIST P-256 elliptic curve is a pair <span class="math">(x,y)</span> of integers satisfying the equation <span class="math">y^{2} = x^{3} - 3x + b</span> modulo the prime <span class="math">2^{256} - 2^{224} + 2^{192} + 2^{96} - 1</span>, where <span class="math">b</span> is a standard constant. There are at least three obvious ways for an attacker to distinguish this public key from a uniform random string:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Least severe: Normally <span class="math">x</span> and <span class="math">y</span> are represented as integers between 0 and <span class="math">2^{256} - 2^{224} + 2^{192} + 2^{96} - 2</span> inclusive, encoded as 256-bit strings. If the attacker sees a 256-bit string representing an integer larger than <span class="math">2^{256} - 2^{224} + 2^{192} + 2^{96} - 2</span> then the attacker knows that the string is not a valid value of <span class="math">x</span> or of <span class="math">y</span>. If the attacker sees a user sending a series of (e.g.) <span class="math">2^{35}</span> 256-bit strings, and the largest string is close to <span class="math">2^{256} - 2^{224}</span>, then the attacker is reasonably confident that the user is sending curve points. See Section 2.6 for details.</li>

    </ul>

    <p class="text-gray-300">One can dismiss this attack as being too slow to be of interest, but we prefer more robust cryptographic</p>

    <p class="text-gray-300">Public domain. This work was supported by the National Science Foundation under grant 1018836, by the Netherlands Organisation for Scientific Research (NWO) under grants 639.073.005 and 040.09.003, by the National Science Council of Taiwan under NSC 101-2915-I-001-019, by the European Commission under Contract ICT-2007-216676 ECRYPT II, and by SIDN.nl (http://www.sidn.nl/). Part of this work was done while Bernstein, Krasnova, and Lange visited Academia Sinica; they wish to thank Bo-Yin Yang for his hospitality. Permanent ID of this document: 711e2f8601805e06e5fbb3c5953dd5d1. Date: 2013.08.28.</p>

    <p class="text-gray-300">CCS'13, November 4-8, 2013, Berlin, Germany.</p>

    <p class="text-gray-300">ACM 978-1-4503-2477-9/13/11. http://dx.doi.org/10.1145/2508859.2516734.</p>

    <p class="text-gray-300">primitives that maintain security with heavy use. The user can cover all integers between 0 and <span class="math">2^{256}-1</span> by randomizing the representations of small integers <span class="math">x</span> and <span class="math">y</span>, but this adds very little security: the attacker easily collects statistics showing that some integers appear half as often as others.</p>

    <p class="text-gray-300">A secure solution is to randomly represent <span class="math">x</span> and <span class="math">y</span> as integers between 0 and, e.g., <span class="math">2^{320}-1</span>. Another secure solution, with smaller keys, is to switch to an elliptic curve using a prime much closer to a power of 2, such as NIST P-224 (prime <span class="math">2^{224}-2^{96}+1</span>, lower security level) or Bernstein’s Curve25519 from <em>[6]</em> (prime <span class="math">2^{255}-19</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>More severe: The attacker simply checks the curve equation. If a 512-bit string has the form <span class="math">(x,y)</span> where <span class="math">y^{2}=x^{3}-3x+b</span> modulo this prime then the attacker is confident that the user is sending a public key.</li>

    </ul>

    <p class="text-gray-300">Many ECC systems save space by compressing <span class="math">y</span> to one (random-looking) bit: the sign in <span class="math">\\pm\\sqrt{x^{3}-3x+b}</span>. Some ECC systems save space by eliminating <span class="math">y</span> entirely. The cost for the legitimate user of computing a square root is almost always outweighed by the benefit of reducing keys to half size. Both of these mechanisms have the side effect of stopping this attack.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Most severe: The attacker checks whether <span class="math">x^{3}-3x+b</span> is a square modulo this prime. This has chance <span class="math">1/2</span> of occurring for a uniform random string, but if it occurs repeatedly then the attacker is reasonably confident that the user is sending public keys.</li>

    </ul>

    <p class="text-gray-300">The third attack is difficult to stop. Our solution requires a quite drastic change in how curve points are represented as strings; this representation is the main topic of this paper.</p>

    <p class="text-gray-300">Our solution is not limited to public keys: it also protects other randomly generated elliptic-curve points, such as the points appearing in ciphertexts in elliptic-curve versions of the ElGamal encryption system and points appearing in signature systems. See Section 2.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.2 Previous work</h3>

    <p class="text-gray-300">Several years ago, in <em>[40]</em>, Möller proposed a variant of the ElGamal encryption system that provides indistinguishability for ciphertexts as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alice’s public key is a pair <span class="math">(aP,a^{\\prime}P^{\\prime})</span> where <span class="math">a</span> and <span class="math">a^{\\prime}</span> are secret integers, <span class="math">P</span> is a standard base point on an elliptic curve <span class="math">E(\\mathbf{F}_{2^{n}})</span> over some binary field <span class="math">\\mathbf{F}_{2^{n}}</span>, and <span class="math">P^{\\prime}</span> is a standard base point on a nontrivial quadratic twist <span class="math">E^{\\prime}(\\mathbf{F}_{2^{n}})</span> of the same curve.</li>

      <li>To encrypt a message <span class="math">m</span> using public key <span class="math">(aP,a^{\\prime}P^{\\prime})</span>, Bob chooses a random integer <span class="math">b</span>, chooses randomly between <span class="math">aP</span> and <span class="math">a^{\\prime}P^{\\prime}</span>, sends the <span class="math">x</span>-coordinate of <span class="math">bP</span> or <span class="math">bP^{\\prime}</span> respectively, hashes <span class="math">b(aP)</span> or <span class="math">b(a^{\\prime}P^{\\prime})</span> respectively to obtain a secret key, and sends an encryption of <span class="math">m</span> using this secret key.</li>

      <li>Alice recovers <span class="math">bP</span> or <span class="math">bP^{\\prime}</span> from the <span class="math">x</span>-coordinate. Alice multiplies <span class="math">bP</span> or <span class="math">bP^{\\prime}</span> by <span class="math">a</span> or <span class="math">a^{\\prime}</span> to obtain <span class="math">abP</span> or <span class="math">a^{\\prime}bP^{\\prime}</span>, hashes it to obtain the same secret key, and decrypts the message. Möller requires Alice to perform tests to decide whether the input is on <span class="math">E</span> or on <span class="math">E^{\\prime}</span> and to recover the whole point <span class="math">bP</span> or <span class="math">bP^{\\prime}</span>. We comment that the “Montgomery ladder” handles both cases together if <span class="math">a^{\\prime}</span> is chosen as <span class="math">a</span>. (For Montgomery-ladder background see <em>[41]</em>, <em>[16]</em>, and, for the binary case, <em>[39]</em>.) This eliminates the need for such tests and offers efficient curve arithmetic.</li>

    </ul>

    <p class="text-gray-300">The idea in Möller’s proposal is that each element of <span class="math">\\mathbf{F}_{2^{n}}</span> is a valid <span class="math">x</span>-coordinate on <span class="math">E</span> or its twist. The <span class="math">x</span>-coordinate sent here can therefore be any element of <span class="math">\\mathbf{F}_{2^{n}}</span>, and in fact the distribution of the <span class="math">x</span>-coordinates is indistinguishable from the uniform distribution of <span class="math">n</span>-bit strings. Möller slightly adjusts the choices so that the distribution is exactly uniform.</p>

    <p class="text-gray-300">Young and Yung present in <em>[49]</em> a modified version of Möller’s twist idea to achieve DDH security in the standard model. In their version Alice’s public key consists of <span class="math">M</span> points on each curve; Bob picks one of the curves and computes shared secrets with all <span class="math">M</span> points on that curve. The shared key of length <span class="math">M</span> is derived taking just one bit per DH shared secret.</p>

    <p class="text-gray-300">Our approach encodes points on a <em>single</em> curve as strings indistinguishable from uniform random strings. This has several obvious advantages over Möller’s system. We obtain indistinguishability not just for ciphertexts but also for public keys. Möller’s system has double-length public keys, while our public keys have minimal length. Möller’s approach is limited to ElGamal encryption, while our approach handles a much wider range of ECC systems; see Section 2. Möller needs cryptographic security not just for <span class="math">E</span> but also for <span class="math">E^{\\prime}</span>; in our system twist security is not required, although we still suggest it as a desirable feature (see Section 4). Since our proposal does not need to work with twists, achieving solutions in the standard model can be done simply using the standard methods.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.3 Application context</h3>

    <p class="text-gray-300">Möller’s curve-or-twist approach is used in StegoTorus <em>[47]</em>. StegoTorus is an extension to Tor <em>[19]</em> for censorship circumvention. It makes Tor traffic resemble Skype, general HTTPS traffic, etc. and relies on secure communication with a StegoTorus server. Establishing a link with this server requires deriving temporary key material using the public key of the server. This key material is used to encrypt communication of a subsequent ephemeral DH key exchange. StegoTorus uses Möller’s example parameters over <span class="math">\\mathbf{F}_{2^{163}}</span>.</p>

    <p class="text-gray-300">For comparison, typical ECC protocols carry out a DH key exchange in the clear; see, e.g., the ntor example below. StegoTorus needs to encrypt its key exchange because the points sent in the key exchange are easily distinguishable from uniform random data. This encryption adds the outer Möller layer, doubling the space used for the initial communication. This also slows down the client, slows down the server, doubles the size of server public keys (one point on the curve, one point on the twist), and requires implementations to handle computations on two curves.</p>

    <p class="text-gray-300">We eliminate all of these issues by solving the underlying problem, namely the point distinguishability. The points that we send in a DH key exchange are indistinguishable from uniform random strings. See Sections 2, 3, and 5.</p>

    <p class="text-gray-300">Telex <em>[48]</em> is another censorship-circumvention tool. Telex messages pose as regular TLS messages to random uncensored sites; the only difference is that the nonce field contains a cryptographic value instead of a random value. The public key of the Telex server is a pair of points <span class="math">(aP,aP^{\\prime})</span>, with <span class="math">P</span> on an elliptic curve <span class="math">E(\\mathbf{F}_{q})</span> and <span class="math">P^{\\prime}</span> on a nontrivial quadratic twist. Telex servers use deep-packet inspection on all traffic passing through them and identify Telex messages by check</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ing whether the nonce field interpreted as $\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta<span class="math"> satisfies the following conditions. Interpret </span>\\alpha<span class="math"> as the </span>x<span class="math">-coordinate of a point </span>R<span class="math"> on </span>E<span class="math"> or </span>E^{\\prime}<span class="math"> and compute </span>aR<span class="math"> on the appropriate curve. Identify the message as a Telex message if </span>\\beta<span class="math"> matches a salted hash of </span>aR$, and route it according to some other, encrypted information.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The use of curves in Telex follows Möller’s proposal except for the choice of finite field and the choice of equal secrets. The proposed parameters have <span class="math">q=2^{168}-2^{8}-1</span> so that the distribution of values in <span class="math">\\mathbf{F}_{q}</span> is indistinguishable from that of length-168 strings. The attempted decryption performs a complete point recovery from <span class="math">x</span> and uses standard Weierstrass-curve arithmetic to compute the scalar multiplications. We comment again that the “Montgomery ladder” is more efficient, handling both cases together. We also comment that the system could use somewhat larger finite fields, gaining security, without reducing the 56-bit hash size and without going beyond the standard TLS 224-bit nonce size: servers would allow only points <span class="math">R</span> with a fixed number of implicit trailing zeros, and clients would repeatedly generate points until meeting that condition.</p>

    <p class="text-gray-300">This paper’s solution to the point-distinguishability problem would not save bandwidth for Telex connections but would still simplify implementations, removing any need to handle the twist, and would reduce public keys to half size, potentially a useful feature for small clients keeping track of many different Telex servers.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a third protocol we consider ntor <em>[30]</em>, a handshake protocol proposed for Tor achieving anonymity and one-way authentication with forward secrecy. This protocol assumes that Tor relays have public keys on an elliptic curve. The following is a simplified version of the ntor protocol, skipping certificates and saved session states, but presenting all parts relevant to the choice of curve group and representation. To extend a Tor circuit to a relay with public key <span class="math">B=bP</span> a client picks a random value <span class="math">x</span>, computes <span class="math">X=xP</span>, and sends <span class="math">X</span> to the server. The server picks a random <span class="math">y</span>, computes <span class="math">Y=yP</span>, computes two secret keys as $k^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k=H(yX,bX,B,X,Y)<span class="math"> for some hash function </span>H<span class="math">, computes </span>t_{B}=\\mathrm{MAC}_{k^{\\prime}}(B,X,Y)<span class="math"> (an authenticator under key </span>k^{\\prime}<span class="math">), and sends </span>Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_{B}<span class="math"> to the client. The client computes </span>\\bar{k}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{k}=H(xY,xB,B,X,Y)<span class="math"> and verifies that </span>t_{B}=\\mathrm{MAC}_{\\bar{k}^{\\prime}}(B,X,Y)<span class="math">. If the verification is successful, the client is convinced that it is communicating with the correct server: nobody other than the client and the relay could compute </span>xB=bX<span class="math">. Both sides can use </span>k=\\bar{k}$ for transmitting encrypted messages.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Tor currently uses SSL links to superencrypt its traffic. However, one can easily imagine ntor being steganographically encoded inside a cover channel, with the goal of circumventing censorship, on top of the original goals of anonymity, one-way authentication, and forward secrecy. This raises the question of how the curve points can be hidden. Using a pair of points <span class="math">xP,xP^{\\prime}</span> in place of <span class="math">X</span> does not work: it is even easier to distinguish from uniform than a single point. Möller’s curve-or-twist approach, using a pair of points in place of the server’s long-term key <span class="math">B</span>, also does not work: the client is free to pick <span class="math">X</span> on the curve or the twist, but the server is then forced to pick <span class="math">Y</span> on the same curve as <span class="math">X</span>, and this is something visible to a censor.</p>

    <p class="text-gray-300">Our solution applies straightforwardly to this protocol. It does not need twists; it ensures that the encodings of points on a single curve are uniformly distributed. More generally, our solution can be used to encode as many points as desired during one session or across sessions.</p>

    <p class="text-gray-300">Our solution is also useful for several earlier applications: password-authenticated key exchange <em>[13]</em>, ID-based encryption <em>[12]</em>, pseudorandom-number generation <em>[35, 36]</em>, and kleptography <em>[49]</em>. Note that <em>[49]</em> includes a treatment of covert channels and steganography, predating both Stego-Torus and Telex.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.4 Mapping strings to elliptic-curve points</h3>

    <p class="text-gray-300">Shallue and van de Woestijne at ANTS 2006 <em>[45]</em> gave a positive answer to the following question in pure algorithmic number theory: there is, provably, a (very easy) probabilistic polynomial-time algorithm that, given any elliptic curve <span class="math">E</span> over any sufficiently large finite field <span class="math">\\mathbf{F}_{q}</span>, constructs a nonzero element of the group <span class="math">E(\\mathbf{F}_{q})</span>; is there, provably, a deterministic polynomial-time algorithm for the same task? Shallue and van de Woestijne did more than construct a single point: they built a function <span class="math">\\phi:\\mathbf{F}_{q}\\rightarrow E(\\mathbf{F}_{q})</span> such that each element of <span class="math">E(\\mathbf{F}_{q})</span> has at most <span class="math">C</span> preimages, for a particular constant <span class="math">C</span>; and they built a deterministic polynomial-time algorithm that computes <span class="math">\\phi(t)</span> given <span class="math">q</span>, <span class="math">E</span>, and <span class="math">t</span>. Trying <span class="math">C+1</span> elements of <span class="math">\\mathbf{F}_{q}</span> produces a nonzero element of <span class="math">E(\\mathbf{F}_{q})</span>.</p>

    <p class="text-gray-300">Some cryptographic protocols rely on hashing strings to curve points. For example, in the Boneh–Franklin identity-based encryption scheme <em>[12]</em>, public keys are points on pairing-friendly curves, and a user with identity <span class="math">i</span> has public key <span class="math">H(i)</span>. Boneh and Franklin constructed a suitable function <span class="math">H</span> for certain supersingular curves. Icart at Crypto 2009 <em>[32]</em> pointed out that the Shallue–van de Woestijne function <span class="math">\\phi</span> produced suitable functions <span class="math">H</span> for any elliptic curve, allowing the Boneh–Franklin system to be adapted to much more efficient non-supersingular (but still pairing-friendly) curves. Icart and subsequent authors explored various replacements <span class="math">\\phi</span> for the Shallue–van de Woestijne function; see <em>[32]</em>, <em>[15]</em>, <em>[26]</em>, <em>[25]</em>, <em>[20]</em>, <em>[27]</em>, <em>[23]</em>, and <em>[21]</em>.</p>

    <p class="text-gray-300">The reader should be wondering why one cannot simply define <span class="math">\\phi(t)</span> by trying consecutive field elements <span class="math">x</span> starting from <span class="math">t</span> (for example, trying <span class="math">x=t</span>, <span class="math">x=t+1</span>, <span class="math">x=t+2</span>, etc. in the prime-field case) until finding a curve point <span class="math">(x,y)</span>. The answer for Shallue and van de Woestijne is that this is not proven to take polynomial time. On the other hand, there is overwhelming evidence for the conjecture that this takes polynomial time, and in cryptography there is no harm in making such a conjecture; cryptography is built on a foundation of conjectures that are much easier to question, such as the conjecture that there is no fast ECDL algorithm. This simple function from <span class="math">\\mathbf{F}_{q}</span> to <span class="math">E(\\mathbf{F}_{q})</span> is exactly what is used in many papers on identity-based cryptography.</p>

    <p class="text-gray-300">The real objection to this algorithm is that it does not take constant time. In many applications the time leaks secret information. One can compute the same function for almost all inputs in constant time by choosing an upper bound <span class="math">C</span> on the number of consecutive field elements required with very high probability, say <span class="math">C=100</span>, and then always testing exactly <span class="math">C</span> values of <span class="math">x</span>; but testing <span class="math">C</span> times for squares turns out to be a performance bottleneck.</p>

    <p class="text-gray-300">It should be obvious that any of the functions <span class="math">\\phi</span> mentioned above allows a public key <span class="math">\\phi(t)\\in E(\\mathbf{F}_{q})</span> to be represented as an element <span class="math">t\\in\\mathbf{F}_{q}</span>, using a computation of <span class="math">Q\\mapsto\\{t:\\phi(t)=Q\\}</span> to encode a point and a computation of <span class="math">t\\mapsto\\phi(t)</span> to decode a point. However, this approach raises several important performance issues for key generation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The usual key-generation method produces a uniform random curve point by scalar multiplication, but there is no reason to think that this curve point can be expressed in the form <span class="math">\\phi(t)</span>. If it cannot then the user must try again, generating a new key.</li>

      <li>Even worse, to generate a <em>uniform</em> distribution of elements <span class="math">t\\in\\mathbf{F}_{q}</span> the user must generate a uniform random curve point <span class="math">Q</span>, compute the number <span class="math">k=\\#\\{t:\\phi(t)=Q\\}</span> of preimages of the point, restart with probability <span class="math">1-k/C</span>, and finally select a uniform random preimage of the point. (This is what statisticians call “rejection sampling”; more advanced sampling methods are inapplicable since there is no way to generate a uniform random curve point with a specified value of <span class="math">k</span>.) The average number of points generated is then <span class="math">C\\#E(\\mathbf{F}_{q})/q\\approx C</span>. Applications that need real-time guarantees must budget for even more than <span class="math">C</span>.</li>

      <li>Each of these <span class="math">C</span> points takes time for not just a computation of <span class="math">Q</span> but also a computation of <span class="math">\\{t:\\phi(t)=Q\\}</span>. This is the main bottleneck if <span class="math">\\phi</span> is slow to invert.</li>

    </ul>

    <p class="text-gray-300">In many protocols, ephemeral ECC keys are generated for every protocol run, and these computations can easily dominate the overall protocol performance. Of course, even in protocols where key generation is rare, each use of <span class="math">t</span> incurs the cost of computing <span class="math">\\phi(t)</span>.</p>

    <p class="text-gray-300">We propose two ways to minimize these performance problems: Elligator 1 and Elligator 2. Elligator 1 takes an encoding function <span class="math">\\phi</span> that is implicit in the very recent paper <em>[23]</em> by Fouque, Joux, and Tibouchi. This function, in the cases we consider, maps <span class="math">\\{0,1,2,3,\\ldots,(q-1)/2\\}</span> <em>injectively</em> to <span class="math">E(\\mathbf{F}_{q})</span>; see Theorem 4. Since the number of points on <span class="math">E</span> over <span class="math">\\mathbf{F}_{q}</span> is about <span class="math">q</span> we have to try only about 2 points on average before finding a point of the form <span class="math">\\phi(t)</span>, and we do not need to randomize the preimage <span class="math">t</span>. Not every elliptic curve is suitable for this function, but the curve requirements for Elligator 1 are compatible with state-of-the-art criteria for curve security and curve performance.</p>

    <p class="text-gray-300">Fouque, Joux, and Tibouchi suggested that injectivity would be useful for a naive form of ElGamal encryption in which a message <span class="math">m</span> is encoded injectively as an elliptic-curve point and then simply added to <span class="math">abP</span>. We highlight the new anti-censorship application, namely encoding <em>points</em> as <em>strings</em> rather than encoding strings as points; we drastically simplify the definition of this function, while accelerating its forward and inverse computation; and we introduce a high-security high-speed elliptic curve that supports the function. See Section 4 for the curve, Section 3 for the function, and Section 2 for the cryptographic applications.</p>

    <p class="text-gray-300">Elligator 2 introduces a new injective map <span class="math">\\psi</span> to elliptic curves. Elligator 2 has similar performance characteristics to Elligator 1. The main advantage of Elligator 2 is that it applies to more curves: in fact, every odd-characteristic elliptic curve that has a point of order 2, except for curves of <span class="math">j</span>-invariant 1728. See Section 5 for this new map.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Elliptic-Curve Protocols</h2>

    <p class="text-gray-300">This section presents various elliptic-curve protocols in which public keys, ciphertexts, etc. are indistinguishable from uniform random strings. These protocols include all of the fundamental ECC constructions: static and ephemeral key exchange, encryption, and signatures.</p>

    <p class="text-gray-300">The prerequisite for all of these protocols is an injective map <span class="math">\\iota</span> from a set of strings <span class="math">S\\subseteq\\{0,1\\}^{b}</span> to an elliptic-curve group <span class="math">E(\\mathbf{F}_{q})</span>. We require <span class="math">\\#S</span> to be very close to <span class="math">2^{b}</span>, so that a uniform random element of <span class="math">S</span> is indistinguishable from a uniform random <span class="math">b</span>-bit string; see Section 2.6. We have two different methods to construct <span class="math">\\iota</span> and <span class="math">S</span>, as mentioned above; see Sections 3 and 5.</p>

    <p class="text-gray-300">The idea, as explained in Section 1, is for each string <span class="math">\\tau\\in S</span> to represent the curve point <span class="math">\\iota(\\tau)</span>, i.e., for the point <span class="math">\\iota(\\tau)</span> to be encoded as the string <span class="math">\\tau</span>. A uniform random element of <span class="math">\\iota(S)</span>, encoded in this way, is indistinguishable from a uniform random <span class="math">b</span>-bit string. We do not require <span class="math">\\iota(S)</span> to be all of <span class="math">E(\\mathbf{F}_{q})</span>; our protocols compensate for this by repeatedly generating curve points until finding elements of <span class="math">\\iota(S)</span>. For our constructions <span class="math">\\#\\iota(S)</span> is about <span class="math">(1/2)\\#E(\\mathbf{F}_{q})</span>, requiring only about 2 repetitions on average, as mentioned in Section 1.</p>

    <p class="text-gray-300">Our primary objective in this section is to illustrate how easily <span class="math">\\iota</span> can be used to systematically hide elliptic-curve points in a wide range of protocols. We do not mean to suggest that all of these protocols are being used in contexts where they need to be hidden from censors; but there is no obvious dividing line between protocols that would be useful for those contexts and protocols that would not.</p>

    <p class="text-gray-300">Consider, for example, static ECDH public keys. A static public key might be distributed openly, as part of a cryptographic software package, in which case it does not add any new risk of censorship; changing the encoding of the public key does nothing to hide the package from a censor. On the other hand, if a client already has all necessary cryptographic software, and a server broadcasts a series of static public keys by encoding those keys inside otherwise innocent web pages or other cover traffic, then indistinguishability from uniform is exactly the tool needed to defend those public keys against a censor with an accurate model of the cover traffic. A censored Tor client should be able to see frequent updates of public keys for Tor bridges, for example; see <em>[1]</em> for a detailed discussion of the speed at which various governments detect and suppress access to Tor bridges.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Notation and domain parameters</h3>

    <p class="text-gray-300">To simplify the protocol statements we assume that the elliptic-curve group <span class="math">E(\\mathbf{F}_{q})</span> is cyclic: specifically, that it is generated by a standard base point <span class="math">P</span> of order <span class="math">n</span>. In the case that <span class="math">n</span> is not prime (for example, <span class="math">n</span> is 4 times a prime in Section 4) we do <em>not</em> restrict points to a prime-order subgroup: any proper subgroup is trivially distinguishable from the full group. For non-cyclic groups the protocols would have to be modified to handle multiple generators.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H</span> denote a hash function, and let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote concatenation of strings. Symmetric authenticated encryption of a message </span>M<span class="math"> using a secret key </span>k<span class="math"> is denoted as </span>c=\\mathrm{Enc}_{k}(m)<span class="math">, decryption as </span>m=\\mathrm{Dec}_{k}(c)$. A standard security requirement for symmetric encryption is that the ciphertexts are indistinguishable from uniform (see, e.g., <em>[3]</em>); one can, for example, safely use AES in counter mode. For authentication there is a split in the literature between authenticators aiming at the “PRF” property, which guarantees indistinguishability, and authenticators aiming merely at the “MAC” property, which guarantees unforgeability but does not guarantee indistinguishability; we require the PRF property. See <em>[44]</em> for a unified security notion for authenticated encryption that guarantees indistinguishability from uniform random bit strings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2.2 Long-term Diffie–Hellman keys</p>

    <p class="text-gray-300">Each user <span class="math">U</span> sets up a public key:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">U</span> generates a random integer <span class="math">u</span>.</li>

      <li><span class="math">U</span> computes <span class="math">P_{U}=uP</span>. If <span class="math">P_{U}\\notin\\iota(S)</span> then <span class="math">U</span> repeats from step 1.</li>

      <li><span class="math">U</span> publishes <span class="math">\\iota^{-1}(P_{U})=\\tau_{U}</span> and keeps <span class="math">u</span> secret.</li>

    </ol>

    <p class="text-gray-300">The encoding <span class="math">\\tau_{U}</span> of the public key is a string which can be broadcast; it is indistinguishable from a random string.</p>

    <p class="text-gray-300">Without further communication users Alice and Bob can compute a shared secret from their public strings <span class="math">\\tau_{A}</span> and <span class="math">\\tau_{B}</span>. Alice can compute this key as follows and then use it to authenticate and encrypt a message to Bob:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alice computes <span class="math">\\iota(\\tau_{B})=P_{B}</span>.</li>

      <li>Alice computes <span class="math">k=H(u_{A}P_{B})</span>.</li>

    </ol>

    <p class="text-gray-300">Upon receiving an encrypted message from Alice, Bob can likewise compute the same shared secret and then decrypt the message and verify the authenticator:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bob computes <span class="math">\\iota(\\tau_{A})=P_{A}</span>.</li>

      <li>Bob computes <span class="math">k=H(u_{B}P_{A})</span>.</li>

    </ol>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 ElGamal encryption</h3>

    <p class="text-gray-300">Assume <span class="math">u_{B}</span> and <span class="math">P_{B}=u_{B}P</span> is a static key pair of Bob and that Bob has published <span class="math">\\tau_{B}=\\iota^{-1}(P_{B})</span>. Alice wants to send Bob a message <span class="math">M</span>. To encrypt the message she performs the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>She generates a random integer <span class="math">r</span>.</li>

      <li>She computes the point <span class="math">R=rP</span>. If <span class="math">R\\notin\\iota(S)</span> she repeats from step 1.</li>

      <li>She computes <span class="math">\\iota^{-1}(R)=\\tau_{R}</span>.</li>

      <li>She computes <span class="math">P_{B}=\\iota(\\tau_{B})</span>.</li>

      <li>She computes the shared key value <span class="math">k=H(rP_{B})</span>.</li>

      <li>She encrypts message <span class="math">m</span> using key <span class="math">k</span>: <span class="math">c=\\text{Enc}_{k}(m)</span>.</li>

      <li>She sends the tuple <span class="math">(\\tau_{R},c)</span> as an encryption of <span class="math">m</span>.</li>

    </ol>

    <p class="text-gray-300">To decrypt the received message, Bob:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>computes <span class="math">\\iota(\\tau_{R})=R</span>,</li>

      <li>computes the same shared key value: <span class="math">k=H(u_{B}R)</span>, and</li>

      <li>decrypts the message: <span class="math">m=\\text{Dec}_{k}(c)</span>.</li>

    </ol>

    <p class="text-gray-300">ElGamal encryption also appears in <em>[23]</em> as an application of an injective map between strings and curve points, but our application is completely different from the application in <em>[23]</em>. There is a critical difference in the underlying encryption methods: we use symmetric cryptography to encrypt the message <span class="math">m</span> using a key derived from <span class="math">rP_{B}</span>, whereas <em>[23]</em> adds <span class="math">rP_{B}</span> to a curve point <span class="math">M</span> that represents <span class="math">m</span>. This is exactly where <em>[23]</em> uses an injective map, namely to encode the string <span class="math">m</span> as a curve point <span class="math">M</span>. Note, however, that this also (1) prevents <em>[23]</em> from encrypting long messages and (2) allows malleability, in violation of the basic security standards for public-key encryption. We instead use the standard “KEM/DEM” structure to provide secure public-key encryption, and as a consequence do not need to encode strings as curve points. We use an injective map for a completely different reason: we encode curve points as strings, preventing those points from being recognized by censors.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.4 Short-term Diffie–Hellman keys</h3>

    <p class="text-gray-300">In this protocol, Alice and Bob agree on a shared secret without using long-term keys. This protocol is important as a way to provide forward secrecy. Of course, this provides no authentication, but authentication can be added as a subsequent layer.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alice and Bob generate short-term keys as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a random integer <span class="math">r</span>.</li>

      <li>Compute point <span class="math">R=rP</span>. If <span class="math">R\\notin\\iota(S)</span> repeat from step 1a.</li>

      <li>Alice sends <span class="math">\\mu_{A}=\\iota^{-1}(R_{A})</span> to Bob; Bob sends <span class="math">\\mu_{B}=\\iota^{-1}(R_{B})</span> to Alice.</li>

      <li>Alice decodes <span class="math">R_{B}=\\iota(\\mu_{B})</span>; Bob decodes <span class="math">R_{A}=\\iota(\\mu_{A})</span>.</li>

      <li>Alice computes the shared key value <span class="math">k=H(r_{A}R_{B})</span>; Bob computes the same <span class="math">k</span> as <span class="math">H(r_{B}R_{A})</span>.</li>

    </ol>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.5 Schnorr signatures</h3>

    <p class="text-gray-300">Assume that <span class="math">u_{B}</span> and <span class="math">P_{B}=u_{B}P</span> are respectively private and public keys of Bob, where <span class="math">P_{B}\\in\\iota(S)</span> and Bob has published <span class="math">\\tau_{B}=\\iota^{-1}(P_{B})</span>. To sign a message <span class="math">m</span>, Bob performs the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose a random integer <span class="math">r</span>.</li>

      <li>Compute <span class="math">R=rP</span>. If <span class="math">R\\notin\\iota(S)</span>, repeat from step 1.</li>

      <li>Compute <span class="math">\\tau=\\iota^{-1}(R)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Compute $h=H(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">s=r+hu_{B}\\pmod{n}</span>.</li>

      <li>The signature is the tuple <span class="math">\\psi=(\\tau,s)</span>.</li>

    </ol>

    <p class="text-gray-300">The integer <span class="math">s</span> must be encoded so as to be indistinguishable from uniform; see Section 2.6.</p>

    <p class="text-gray-300">To verify the signature <span class="math">(\\tau,s)</span>, Alice performs the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">P_{B}=\\iota(\\tau_{B})</span>.</li>

      <li>Compute <span class="math">R=\\iota(\\tau)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Compute $h=H(\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compare <span class="math">R+hP_{B}</span> and <span class="math">sP</span>. If they are equal, accept. Otherwise, reject.</li>

    </ol>

    <p class="text-gray-300">Schnorr’s original signature system actually sent <span class="math">(h,s)</span>. We follow “EdDSA” from <em>[8]</em> in sending an encoding of <span class="math">(R,s)</span>; security is the same, since one can reconstruct <span class="math">(h,s)</span> from <span class="math">(R,s)</span> and vice versa. The advantage of <span class="math">(R,s)</span> is that it allows batching, making signature verification about twice as fast, as explained in <em>[8]</em>. Our use of <span class="math">\\iota</span> makes this signature indistinguishable from a uniform random string.</p>

    <p class="text-gray-300">We also follow EdDSA in including the public key <span class="math">\\tau_{B}</span> in the hash. Robert Ransom has pointed out that if the public key is omitted from the hash then an attacker who does not know it can calculate it by first computing <span class="math">h</span> and then computing <span class="math">(sP-R)/h</span>, and as a consequence can see that two signatures come from the same public key. Ransom has also suggested a different way of hiding signatures from someone who does not know <span class="math">\\tau_{B}</span>: namely, encrypting the signatures with a secret-key cipher keyed by a hash of <span class="math">\\tau_{B}</span>. Of course, indistinguishability is unachievable against an attacker who <em>does</em> know <span class="math">\\tau_{B}</span>: the attacker can simply verify the signature.</p>

    <p class="text-gray-300">We encode <span class="math">R</span> as <span class="math">\\tau</span> both for transmission and for input to <span class="math">H</span>. We could safely switch to a different encoding for input to <span class="math">H</span>. In particular, we could use the same encoding used in EdDSA. This would make our signatures compatible with EdDSA signatures: anyone could convert an EdDSA signature into a signature of our form and vice versa.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.6 Detecting differences from uniform</h3>

    <p class="text-gray-300">These protocols transmit uniform random elements of <span class="math">S</span>. Usually <span class="math">S</span> is not the set of <em>all</em> <span class="math">b</span>-bit strings, so uniform random elements of <span class="math">S</span> are not exactly uniform random <span class="math">b</span>-bit</p>

    <p class="text-gray-300">strings. This is not a security problem if <span class="math">\\#S</span> is very close to <span class="math">2^{k}</span>; we now analyze quantitatively what “very close” means.</p>

    <p class="text-gray-300">Consider a channel that normally sends <span class="math">k</span> independent uniform random <span class="math">b</span>-bit strings. A user modifies the channel to instead transmit <span class="math">k</span> independent uniform random elements of <span class="math">S</span>. The censor’s goal is to take action against the modified channel without taking action against the original channel.</p>

    <p class="text-gray-300">The obvious strategy for the censor is to take action if and only if all of the <span class="math">b</span>-bit strings are elements of <span class="math">S</span>. This has no false negatives, but it produces a false positive whenever <span class="math">k</span> independent uniform random <span class="math">b</span>-bit strings happen to all be elements of <span class="math">S</span>. If <span class="math">\\#S=2^{b}-\\delta</span> then a false positive occurs with probability <span class="math">(\\#S/2^{b})^{k}=(1-\\delta/2^{b})^{k}\\approx\\exp(-k\\delta/2^{b})</span>. This strategy maximizes the difference in action probability between the original and modified channels; hence <span class="math">S^{k}</span> is indistinguishable from <span class="math">(\\{0,1\\}^{b})^{k}</span> when <span class="math">k\\delta/2^{b}</span> is small.</p>

    <p class="text-gray-300">Consider, for example, the NIST P-256 set <span class="math">S=\\{0,1,2,\\ldots,2^{256}-2^{224}+2^{192}+2^{96}-2\\}</span>, with <span class="math">b=256</span>. Here <span class="math">\\delta\\approx 2^{224}</span>. If the censor sees <span class="math">k=2^{35}</span> sessions then <span class="math">k\\delta/2^{b}\\approx 8</span> so the censor will take action for the original channel with probability only about <span class="math">\\exp(-8)\\approx 0.000335</span>. This may be an acceptable level of collateral damage.</p>

    <p class="text-gray-300">As a second example illustrating the importance of the ratio <span class="math">k\\delta/2^{b}</span>, consider a set <span class="math">S</span> of size <span class="math">2^{256}-\\delta</span> where <span class="math">\\delta\\leq 2^{160}</span>. This time a censor seeing <span class="math">k\\leq 2^{64}</span> sessions has <span class="math">k\\delta/2^{b}\\leq 2^{-32}</span> so the probability is larger than <span class="math">0.99999999</span>; i.e., the censor will take action against practically every channel.</p>

    <p class="text-gray-300">The encodings that we consider for elements of <span class="math">E(\\mathbf{F}_{q})</span> typically have <span class="math">\\#S=(q+1)/2</span>. In each of our recommended examples, <span class="math">\\#S</span> is between <span class="math">2^{b}-2^{b/2}</span> and <span class="math">2^{b}</span>, so <span class="math">k\\delta/2^{b}\\leq k/2^{b/2}</span>. The probability difference is therefore negligible until <span class="math">k</span>, the number of strings transmitted, grows to a noticeable fraction of <span class="math">2^{b/2}</span>. This cannot be a concern when <span class="math">E(\\mathbf{F}_{q})</span> is chosen to resist standard discrete-logarithm attacks: those attacks take time only about <span class="math">2^{b/2}</span>.</p>

    <p class="text-gray-300">We also encode integers modulo <span class="math">n=\\#E(\\mathbf{F}_{q})</span> as strings in Section 2.5. By Hasse’s theorem, <span class="math">n</span> is within <span class="math">2\\sqrt{q}</span> of <span class="math">q+1</span>, so if <span class="math">q</span> is very close to <span class="math">2^{b+1}</span> then <span class="math">n</span> is also forced to be very close to <span class="math">2^{b+1}</span>. Note that taking <span class="math">q</span> slightly below <span class="math">2^{b+1}</span> does not force <span class="math">n</span> to be below <span class="math">2^{b+1}</span>; for <span class="math">n&gt;2^{b+1}</span> we still use a <span class="math">(b+1)</span>-bit encoding, restarting the protocol in Section 2.5 in the extremely unlikely case that an integer is <span class="math">2^{b+1}</span> or larger.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.7 Active attacks</h3>

    <p class="text-gray-300">Censors can try replacing random-looking strings by other strings (possibly strings outside <span class="math">S</span>) to see whether this has any visible effect. Presumably this replacement will disrupt communication, but protocol designers and implementors must take care to ensure that this replacement does not allow the censor to detect communication.</p>

    <p class="text-gray-300">We briefly point out an attack against the password-authenticated key-exchange protocol of <em>[13]</em>; this attack is not in the censorship context, but it illustrates both the value of avoiding twists and the difficulty of protecting against active attacks. In the protocol of <em>[13]</em>, Alice sends an encryption (using a shared password as a secret key) of either a point on a curve or a point on the twist of the curve; indistinguishability is important here for the ciphertext to avoid leaking information. Bob sends back two points, one on the curve and one on the twist; information is carried by the point on the same curve used by Alice, while the other point is random. Our attack is to actively rerandomize one of the two points sent by Bob. If this point is on the same curve then Alice aborts; if this point is not on the same curve then Alice does not notice and communication continues. This information leak allows the attacker to exclude half of all possible passwords, and repeating the attack allows the attacker to quickly find the right password.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3 Elligator 1: The Injective Map</h2>

    <p class="text-gray-300">Section 2 needs an injective map <span class="math">\\iota</span> from a large set <span class="math">S</span> of strings to <span class="math">E(\\mathbf{F}_{q})</span>. Elligator 1 is one choice of <span class="math">\\iota</span>; Elligator 2, introduced in Section 5, is another choice of <span class="math">\\iota</span>. This section presents the mathematical details of Elligator 1: the construction of <span class="math">\\iota</span>, how to compute <span class="math">\\iota</span>, how to test whether a curve point is in the image of <span class="math">\\iota</span>, and how to invert <span class="math">\\iota</span> on curve points in the image. To help the reader visualize the mathematical structure of <span class="math">\\iota</span> we include a picture as Figure 1.</p>

    <p class="text-gray-300">We impose certain requirements on <span class="math">q</span> and <span class="math">E</span> for Elligator 1: we consider only primes <span class="math">q</span>; we require <span class="math">q</span> to be congruent to 3 modulo 4; we require <span class="math">E</span> to be a complete Edwards curve; and we impose an extra algebraic requirement (<span class="math">c=2/s^{2}</span> in Theorem 1) that allows only half of all complete Edwards curves. Approximately 1/16 of all isomorphism classes of elliptic curves over all finite fields satisfy these requirements. (Asymptotically 100% of all finite fields, ordered by size, are prime fields; 50% of those primes are congruent to 3 modulo 4; 25% of elliptic curves over those fields are complete Edwards curves; 50% of those satisfy the extra algebraic requirement.) See Section 4 for specific choices of <span class="math">q</span> and <span class="math">E</span>.</p>

    <p class="text-gray-300">The heart of <span class="math">\\iota</span> is a function <span class="math">\\phi:\\mathbf{F}_{q}\\rightarrow E(\\mathbf{F}_{q})</span> defined in Theorem 1 and Definition 2. This function satisfies <span class="math">\\phi(t)=\\phi(-t)</span> for each <span class="math">t\\in\\mathbf{F}_{q}</span> but has no other collisions (see Theorem 3), so its restriction to <span class="math">\\{0,1,2,\\ldots,(q-1)/2\\}</span> is injective. Theorem 4 simply defines <span class="math">S</span> as <span class="math">\\{0,1,2,\\ldots,(q-1)/2\\}</span> represented in little-endian form as <span class="math">b</span>-bit strings, where <span class="math">b=\\lfloor\\log_{2}q\\rfloor</span>, and defines <span class="math">\\iota</span> as the corresponding representation of <span class="math">\\phi</span>. For indistinguishability we add the requirement that <span class="math">(q+1)/2</span> be extremely close to <span class="math">2^{b}</span>.</p>

    <p class="text-gray-300">As mentioned in Section 1, this function <span class="math">\\phi</span> was introduced by Fouque, Joux, and Tibouchi in <em>[23]</em>. Our main contributions in this section are a much more concise definition of <span class="math">\\phi</span>; much more direct proofs of the relevant properties of <span class="math">\\phi</span>; a simple method to invert <span class="math">\\phi</span>; and a simple test for whether a curve point is in the image of <span class="math">\\phi</span>.</p>

    <p class="text-gray-300">The function <span class="math">-\\phi</span> has the same useful properties as <span class="math">\\phi</span>. Our choice of sign is not the same as the choice in <em>[23]</em>: in the notation below, the ratio is <span class="math">\\chi(c)</span>, i.e., <span class="math">\\chi(2)</span>. This choice of sign slightly simplifies our formulas for the forward and inverse maps, although it is not the main simplification compared to <em>[23]</em>. We also comment that <span class="math">\\phi(t)=-\\phi(1/t)</span> for <span class="math">t\\neq 0</span>.</p>

    <p class="text-gray-300">Computing <span class="math">\\iota</span> in a sensible way is almost as fast as traditional point decompression, not a serious bottleneck compared to scalar multiplication. Inverting <span class="math">\\iota</span> is slightly slower, but testing whether a curve point is in the image of <span class="math">\\iota</span> is very fast. See Section 3.5 for further performance analysis.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1 Squares, square roots, and <span class="math">\\chi</span></h3>

    <p class="text-gray-300">Fix a prime power <span class="math">q\\equiv 3\\pmod{4}</span>. In defining <span class="math">\\iota</span> we consider only primes <span class="math">q</span> for simplicity (so that <span class="math">0,1,2,\\ldots,(q-1)/2</span> are distinct field elements) but our <span class="math">\\phi</span> theorems also apply to prime powers.</p>

    <p class="text-gray-300">Define <span class="math">\\chi:\\mathbf{F}_{q}\\rightarrow\\mathbf{F}_{q}</span> by <span class="math">\\chi(a)=a^{(q-1)/2}</span>. If <span class="math">a</span> is a non-zero square then <span class="math">\\chi(a)=1</span>; if <span class="math">a</span> is a non-square then <span class="math">\\chi(a)=-1</span>; if <span class="math">a=0</span> then <span class="math">\\chi(a)=0</span>. Note that <span class="math">(q-1)/2</span> is odd since <span class="math">q\\equiv 3\\pmod{4}</span>, so <span class="math">\\chi(-1)=-1</span>, so <span class="math">-1</span> is not a square. More</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The structure of our encoding function  <span class="math">\\iota^{-1}</span> , a bijection from a large subset of  <span class="math">E(\\mathbf{F}_q)</span>  to a large set  <span class="math">S</span>  of  <span class="math">b</span> -bit strings. The elliptic curve  <span class="math">E</span>  is required to be a complete Edwards curve, shown on the left together with a sample element  <span class="math">P = (x,y)</span>  of  <span class="math">E(\\mathbf{F}_q)</span> . A sample  <span class="math">b</span> -bit output is shown on the right. See Theorems 1, 3, and 4 and Definition 2 for further details regarding the function in the middle.</p>

    <p class="text-gray-300">generally,  <span class="math">\\chi (\\chi (a)) = \\chi (a)</span> . There are several easy ways to manipulate  <span class="math">\\chi</span>  arguments: for example,  <span class="math">\\chi (ab) = \\chi (a)\\chi (b)</span> ,  <span class="math">\\chi (1 / a) = \\chi (a) = 1 / \\chi (a)</span>  if  <span class="math">a\\neq 0</span> , and  <span class="math">\\chi (a^2) = 1</span>  if  <span class="math">a\\neq 0</span> .</p>

    <p class="text-gray-300">If  <span class="math">a</span>  is a square then  <span class="math">a^{(q + 1) / 4}</span>  is a square root of  <span class="math">a</span> : its square is  <span class="math">a^{(q + 1) / 2} = \\chi(a)a = a</span> . More precisely,  <span class="math">a^{(q + 1) / 4}</span>  is the principal square root of  <span class="math">a</span> : the unique square root that is a square. Any square root  <span class="math">b</span>  of  <span class="math">a</span>  satisfies  <span class="math">b = \\chi(b)a^{(q + 1) / 4}</span> .</p>

    <p class="text-gray-300">The function  <span class="math">\\chi</span>  is called a quadratic character. See [38] for further background on finite fields.</p>

    <p class="text-gray-300">THEOREM 1. Let  <span class="math">q</span>  be a prime power congruent to 3 modulo 4. Let  <span class="math">s</span>  be a nonzero element of  <span class="math">\\mathbf{F}_q</span>  with  <span class="math">(s^2 - 2)(s^2 + 2) \\neq 0</span> . Define  <span class="math">c = 2 / s^2</span> . Then  <span class="math">c(c - 1)(c + 1) \\neq 0</span> .</p>

    <p class="text-gray-300">Define  <span class="math">r = c + 1 / c</span>  and  <span class="math">d = -(c + 1)^2 / (c - 1)^2</span> . Then  <span class="math">r \\neq 0</span> , and  <span class="math">d</span>  is not a square.</p>

    <p class="text-gray-300">The following elements of  <span class="math">\\mathbf{F}_q</span>  are defined for each  <span class="math">t\\in \\mathbf{F}_q\\setminus \\{\\pm 1\\}</span></p>

    <p class="text-gray-300"><span class="math">u = (1 - t) / (1 + t),</span></p>

    <p class="text-gray-300"><span class="math">v = u^{5} + (r^{2} - 2)u^{3} + u,</span></p>

    <p class="text-gray-300"><span class="math">X = \\chi (v)u</span></p>

    <p class="text-gray-300"><span class="math">Y = (\\chi (v)v)^{(q + 1) / 4}\\chi (v)\\chi \\bigl (u^2 +1 / c^2\\bigr),</span></p>

    <p class="text-gray-300"><span class="math">x = (c - 1)sX(1 + X) / Y,</span></p>

    <p class="text-gray-300"><span class="math">y = (rX - (1 + X)^2) / (rX + (1 + X)^2).</span></p>

    <p class="text-gray-300">Furthermore  <span class="math">x^{2} + y^{2} = 1 + dx^{2}y^{2}</span> ;  <span class="math">uvXYx(y + 1) \\neq 0</span> ; and  <span class="math">Y^{2} = X^{5} + (r^{2} - 2)X^{3} + X</span> .</p>

    <p class="text-gray-300">PROOF.  <span class="math">c(c - 1)(c + 1) \\neq 0</span> : By definition  <span class="math">c = 2 / s^2</span>  so  <span class="math">c \\neq 0</span> . By hypothesis  <span class="math">s^2 \\neq 2</span>  and  <span class="math">s^2 \\neq -2</span>  so  <span class="math">c \\neq 1</span>  and  <span class="math">c \\neq -1</span> .</p>

    <p class="text-gray-300"><span class="math">r \\neq 0</span> : If  <span class="math">r = 0</span>  then  <span class="math">c = -1 / c</span>  so  <span class="math">c^2 = -1</span> , contradiction.</p>

    <p class="text-gray-300"><span class="math">d</span>  is not a square: Otherwise  <span class="math">-1 = d(c - 1)^2 / (c + 1)^2</span>  is a square, contradiction.</p>

    <p class="text-gray-300"><span class="math">u</span>  is defined and  <span class="math">u \\neq 0</span> : By hypothesis  <span class="math">1 + t \\neq 0</span>  and  <span class="math">1 - t \\neq 0</span> .</p>

    <p class="text-gray-300"><span class="math">v \\neq 0</span> :  <span class="math">r^2 - 2 = c^2 + 1 / c^2</span>  so  <span class="math">v = u(u^2 + c^2)(u^2 + 1 / c^2)</span> . If  <span class="math">v = 0</span>  then there are three possibilities:  <span class="math">u = 0</span> , contradiction; or  <span class="math">u^2 + c^2 = 0</span>  so  <span class="math">-1 = (u / c)^2</span> , contradiction; or  <span class="math">u^2 + 1 / c^2 = 0</span>  so  <span class="math">-1 = (uc)^2</span> , contradiction.</p>

    <p class="text-gray-300"><span class="math">XY \\neq 0</span> , so  <span class="math">x</span>  is defined: As above  <span class="math">u^2 + 1/c^2 \\neq 0</span>  so all factors in  <span class="math">X</span>  and  <span class="math">Y</span>  are nonzero.</p>

    <p class="text-gray-300"><span class="math">1 + X \\neq 0</span> , so  <span class="math">x \\neq 0</span> : If  <span class="math">X = -1</span>  then  <span class="math">u = -\\chi(v)</span>  so  <span class="math">v = -\\chi(v)(1 + r^2 - 2 + 1) = -\\chi(v)r^2</span>  so  <span class="math">\\chi(v) = -\\chi(v)</span> , contradiction.</p>

    <p class="text-gray-300"><span class="math">(X,Y)</span>  satisfies  <span class="math">Y^{2} = X^{5} + (r^{2} - 2)X^{3} + X</span> :  <span class="math">X = \\chi(v)u</span>  so  <span class="math">X^{5} + (r^{2} - 2)X^{3} + X = \\chi(v)(u^{5} + (r^{2} - 2)u^{3} + u) =</span></p>

    <p class="text-gray-300"><span class="math">\\chi (v)v</span>  . Also  <span class="math">\\chi (v)v</span>  is a square so  <span class="math">(\\chi (v)v)^{(q + 1) / 2} = \\chi (v)v</span>  so  <span class="math">Y^{2} = \\chi (v)v</span></p>

    <p class="text-gray-300"><span class="math">rX + (1 + X)^2 \\neq 0</span> , so  <span class="math">y</span>  is defined: If  <span class="math">rX = -(1 + X)^2</span>  then  <span class="math">(r^2 + 4r)X^2 = X^4 - 2X^2 + 1</span>  so</p>

    <p class="text-gray-300"><span class="math">Y^{2} = X(X^{4} + (r^{2} - 2)X^{2} + 1) = X^{3}(2r^{2} + 4r)</span></p>

    <p class="text-gray-300"><span class="math">= rX\\cdot X^{2}(2r + 4) = -(1 + X)^{2}X^{2}(s + 2 / s)^{2}</span></p>

    <p class="text-gray-300">so  <span class="math">-1</span>  is a square, contradiction.</p>

    <p class="text-gray-300"><span class="math">y + 1 \\neq 0</span> : If  <span class="math">y = -1</span>  then  <span class="math">(rX - (1 + X)^2) / (rX + (1 + X)^2) = -1</span>  so  <span class="math">rX - (1 + X)^2 = -(rX + (1 + X)^2)</span>  so  <span class="math">rX = 0</span> , contradiction.</p>

    <p class="text-gray-300"><span class="math">x^{2} + y^{2} = 1 + dx^{2}y^{2}</span> : First  <span class="math">(c - 1)^{2}s^{2} = (c - 1)^{2}(2 / c) = 2(r - 2)</span>  so</p>

    <p class="text-gray-300"><span class="math">Y^{2}(1 - x^{2}) = Y^{2} - (c - 1)^{2}s^{2}X^{2}(1 + X)^{2}</span></p>

    <p class="text-gray-300"><span class="math">= X^{5} + (r^{2} - 2)X^{3} + X - 2(r - 2)X^{2}(1 + X)^{2}</span></p>

    <p class="text-gray-300"><span class="math">= X(rX - (1 + X)^{2})^{2}</span></p>

    <p class="text-gray-300">Similarly  <span class="math">-d = (c + 2 + 1 / c) / (c - 2 + 1 / c) = (r + 2) / (r - 2)</span>  so  <span class="math">-d(c - 1)^{2}s^{2} = 2(r + 2)</span>  so</p>

    <p class="text-gray-300"><span class="math">Y^{2}(1 - dx^{2}) = Y^{2} - d(c - 1)^{2}s^{2}X^{2}(1 + X)^{2}</span></p>

    <p class="text-gray-300"><span class="math">= X^{5} + (r^{2} - 2)X^{3} + X + 2(r + 2)X^{2}(1 + X)^{2}</span></p>

    <p class="text-gray-300"><span class="math">= X(rX + (1 + X)^{2})^{2}</span></p>

    <p class="text-gray-300">Note that  <span class="math">Y^{2}(1 - dx^{2}) \\neq 0</span> , and divide:  <span class="math">(1 - x^{2}) / (1 - dx^{2}) = (rX - (1 + X)^{2})^{2} / (rX + (1 + X)^{2})^{2} = y^{2}</span> ; i.e.,  <span class="math">x^{2} + y^{2} = 1 + dx^{2}y^{2}</span> .</p>

    <p class="text-gray-300">DEFINITION 2. In the situation of Theorem 1, the decoding function for the complete Edwards curve  <span class="math">E: x^2 + y^2 = 1 + dx^2y^2</span>  is the function  <span class="math">\\phi: \\mathbf{F}_q \\to E(\\mathbf{F}_q)</span>  defined as follows:  <span class="math">\\phi(\\pm 1) = (0,1)</span> ; if  <span class="math">t \\notin \\{\\pm 1\\}</span>  then  <span class="math">\\phi(t) = (x,y)</span> .</p>

    <p class="text-gray-300">THEOREM 3. In the situation of Definition 2:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">t \\in \\mathbf{F}_q</span>  then the set of preimages of  <span class="math">\\phi(t)</span>  under  <span class="math">\\phi</span>  is  <span class="math">\\{t, -t\\}</span> .</li>

      <li><span class="math">\\phi (\\mathbf{F}_q)</span>  is the set of  <span class="math">(x,y)\\in E(\\mathbf{F}_q)</span>  such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">y + 1\\neq 0;</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(1 + \\eta r)^2 - 1</span>  is a square, where  <span class="math">\\eta = \\frac{y - 1}{2(y + 1)}</span> ; and</li>

      <li>if  <span class="math">\\eta r = -2</span>  then  <span class="math">x = 2s(c - 1)\\chi (c) / r</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">(x,y)\\in \\phi (\\mathbf{F}_q)</span>  then the following elements  <span class="math">\\bar{X},z,\\bar{u},\\bar{t}</span>  of  <span class="math">\\mathbf{F}_q</span>  are defined and  <span class="math">\\phi (\\bar{t}) = (x,y)</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\bar{X} = -(1 + \\eta r) + ((1 + \\eta r)^2 - 1)^{(q + 1) / 4},</span></p>

    <p class="text-gray-300"><span class="math">z = \\chi \\big((c - 1)s\\bar{X} (1 + \\bar{X})x(\\bar{X}^2 +1 / c^2)\\big),</span></p>

    <p class="text-gray-300"><span class="math">\\bar{u} = z\\bar{X},</span></p>

    <p class="text-gray-300"><span class="math">\\bar{t} = (1 - \\bar{u}) / (1 + \\bar{u}).</span></p>

    <p class="text-gray-300">Proof. Statement 1 of the theorem has two parts: a forward statement  <span class="math">\\phi(t) = \\phi(-t)</span> , and a reverse statement that there are no other preimages. Statement 2 also has two parts: a forward statement that any  <span class="math">(x, y) \\in \\phi(\\mathbf{F}_q)</span>  satisfies certain conditions, and a reverse statement that any element of  <span class="math">E(\\mathbf{F}_q)</span>  satisfying those conditions is in  <span class="math">\\phi(\\mathbf{F}_q)</span> . We organize the proof as (A) forward 1; (B) 3, forward 2, and reverse 1; (C) reverse 2.</p>

    <p class="text-gray-300">A. Fix  <span class="math">t \\in \\mathbf{F}_q</span> . We now show that  <span class="math">\\phi(t) = \\phi(-t)</span> . This is the forward part of statement 1 in the theorem.</p>

    <p class="text-gray-300">If <span class="math">t\\in\\{\\pm 1\\}</span> then <span class="math">\\phi(t)=(0,1)=\\phi(-t)</span> by definition. Assume from now on that <span class="math">t\\notin\\{\\pm 1\\}</span>.</p>

    <p class="text-gray-300">Define <span class="math">u,v,X,Y,x,y</span> from <span class="math">t</span> as in Theorem 1. Then <span class="math">\\phi(t)=(x,y)</span> by definition.</p>

    <p class="text-gray-300">Put <span class="math">t^{\\prime}=-t</span>, and define <span class="math">u^{\\prime},v^{\\prime},X^{\\prime},Y^{\\prime},x^{\\prime},y^{\\prime}</span> the same way from <span class="math">t^{\\prime}</span>. Then <span class="math">\\phi(t^{\\prime})=(x^{\\prime},y^{\\prime})</span>. The proof strategy is to compare successively <span class="math">u^{\\prime}</span> to <span class="math">u</span>, <span class="math">v^{\\prime}</span> to <span class="math">v</span>, etc., concluding that <span class="math">x^{\\prime}=x</span> and <span class="math">y^{\\prime}=y</span>.</p>

    <p class="text-gray-300"><span class="math">\\mbox{\\boldmath</span>u<span class="math">}^{\\prime}=(1-t^{\\prime})/(1+t^{\\prime})=(1+t)/(1-t)=1/u</span>.</p>

    <p class="text-gray-300"><span class="math">\\mbox{\\boldmath</span>v<span class="math">}^{\\prime}=u^{\\prime 5}+(r^{2}-2)u^{\\prime 3}+u^{\\prime}=\\frac{1}{u^{5}}+(r^{2}-2)\\frac{1}{u^{3}}+\\frac{1}{u}</span>, so <span class="math">v^{\\prime}u^{6}=u+(r^{2}-2)u^{3}+u^{5}=v</span>; i.e., <span class="math">v^{\\prime}=v/u^{6}</span>. Note that <span class="math">\\chi(v^{\\prime})=\\chi(v)</span> since <span class="math">\\chi(u^{6})=1</span>.</p>

    <p class="text-gray-300"><span class="math">\\mbox{\\boldmath</span>X<span class="math">}^{\\prime}=\\chi(v^{\\prime})u^{\\prime}=\\chi(v)/u=1/(\\chi(v)u)=1/X</span> since <span class="math">\\chi(v)=1/\\chi(v)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mbox{\\boldmath</span>y<span class="math">}^{\\prime}=\\frac{rX^{\\prime}-(1+X^{\\prime})^{2}}{rX^{\\prime}+(1+X^{\\prime})^{2}}=\\frac{r\\frac{1}{X}-(1+\\frac{1}{X})^{2}}{r\\frac{1}{X}+(1+\\frac{1}{X})^{2}}=\\frac{rX-(X+1)^{2}}{rX+(X+1)^{2}}=y</span>.</p>

    <p class="text-gray-300"><span class="math">\\mbox{\\boldmath</span>Y<span class="math">}^{\\prime}=\\left(\\chi(v^{\\prime})v^{\\prime}\\right)^{(q+1)/4}\\chi(v^{\\prime})\\chi\\big{(}u^{\\prime 2}+1/c^{2}\\big{)}</span>. This takes the most work; the first and third factors each need careful analyses. The second factor is easy: <span class="math">\\chi(v^{\\prime})=\\chi(v)</span> as above.</p>

    <p class="text-gray-300">First factor: <span class="math">\\chi(v^{\\prime})v^{\\prime}=\\chi(v)v/u^{6}</span>. Note that the product <span class="math">\\chi(u)u^{3}</span> is a square and is therefore the principal square root of <span class="math">u^{6}</span>; i.e., <span class="math">(u^{6})^{(q+1)/4}=\\chi(u)u^{3}</span>. Hence <span class="math">(\\chi(v^{\\prime})v^{\\prime})^{(q+1)/4}=(\\chi(v)v/u^{6})^{(q+1)/4}=(\\chi(v)v)^{(q+1)/4}\\chi(u)/u^{3}</span>.</p>

    <p class="text-gray-300">Third factor: Recall that <span class="math">v=u(u^{2}+c^{2})(u^{2}+1/c^{2})</span> and that <span class="math">\\chi(a)=\\chi(ab^{2})</span> for any <span class="math">b\\neq 0</span>. Thus</p>

    <p class="text-gray-300"><span class="math">\\chi\\big{(}u^{\\prime 2}+1/c^{2}\\big{)}</span> <span class="math">=\\chi\\big{(}c^{2}u^{4}(u^{\\prime 2}+1/c^{2})(u^{2}+1/c^{2})^{2}\\big{)}</span> <span class="math">=\\chi\\big{(}u^{2}(c^{2}+u^{2})(u^{2}+1/c^{2})^{2}\\big{)}</span> <span class="math">=\\chi\\big{(}uv(u^{2}+1/c^{2})\\big{)}.</span></p>

    <p class="text-gray-300">Now multiply to obtain <span class="math">Y^{\\prime}=Y\\chi(u)\\chi(uv)/u^{3}=Y/(\\chi(v)u)^{3}=Y/X^{3}</span>. Finally</p>

    <p class="text-gray-300"><span class="math">\\mbox{\\boldmath</span>x<span class="math">}^{\\prime}</span> <span class="math">=(c-1)sX^{\\prime}(1+X^{\\prime})/Y^{\\prime}=(c-1)s\\frac{1}{X}\\left(1+\\frac{1}{X}\\right)\\Bigg{/}\\frac{Y}{X^{3}}</span> <span class="math">=(c-1)sX(1+X)/Y=x.</span></p>

    <p class="text-gray-300">Hence <span class="math">\\phi(-t)=(x^{\\prime},y^{\\prime})=(x,y)=\\phi(t)</span> as claimed.</p>

    <p class="text-gray-300">B. Fix <span class="math">t\\in{\\bf F}_{q}</span>, and define <span class="math">(x,y)=\\phi(t)</span>. We show that <span class="math">\\bar{X},z,\\bar{u},\\bar{t}</span> in the theorem are defined and that <span class="math">\\bar{t}\\in\\{t,-t\\}</span>, so <span class="math">\\phi(\\bar{t})=(x,y)</span>; this is statement 3 in the theorem. We also show the forward part of statement 2: namely, <span class="math">y+1\\neq 0</span>; <span class="math">(1+\\eta r)^{2}-1</span> is a square, where <span class="math">\\eta=(y-1)/(2(y+1))</span>; and if <span class="math">\\eta r=-2</span> then <span class="math">x=2s(c-1)\\chi(c)/r</span>. We also show the reverse part of statement 1: there are no preimages of <span class="math">\\phi(t)</span> other than <span class="math">t</span> and <span class="math">-t</span>.</p>

    <p class="text-gray-300">The definition of <span class="math">\\phi</span> has two cases: if <span class="math">t\\in\\{1,-1\\}</span> then <span class="math">(x,y)=(0,1)</span>; if <span class="math">t\\notin\\{1,-1\\}</span> then <span class="math">u,v,X,Y,x,y</span> are defined in Theorem 1. Note that in the second case <span class="math">x\\neq 0</span> by Theorem 1, so in particular <span class="math">t</span> is not a preimage of <span class="math">(0,1)</span>.</p>

    <p class="text-gray-300">In the first case <span class="math">y+1=2\\neq 0</span>; <span class="math">\\eta=0</span>; <span class="math">(1+\\eta r)^{2}-1=0</span> is a square; <span class="math">\\bar{X}=-1</span>; <span class="math">z=0</span>; <span class="math">\\bar{u}=0</span>; and <span class="math">\\bar{t}=1\\in\\{t,-t\\}</span>. As noted above, <span class="math">1</span> and <span class="math">-1</span> are the only preimages of <span class="math">(0,1)</span>.</p>

    <p class="text-gray-300">What remains is the second case. Here <span class="math">y+1\\neq 0</span> by Theorem 1. The equation <span class="math">y=(rX-(1+X)^{2})/(rX+(1+X)^{2})</span> implies <span class="math">X^{2}+(2+r(y-1)/(y+1))X+1=0</span>, i.e., <span class="math">X^{2}+2(1+\\eta r)X+1=0</span>. Note that this forces the discriminant <span class="math">4(1+\\eta r)^{2}-4</span> to be a square; i.e., <span class="math">(1+\\eta r)^{2}-1</span> is a square. Divide by <span class="math">X</span> to see that <span class="math">X+1/X=-2(1+\\eta r)</span>.</p>

    <p class="text-gray-300">If <span class="math">\\eta r=-2</span> then <span class="math">(X-1)^{2}=0</span> so <span class="math">X=1</span> so <span class="math">u\\in\\{\\pm 1\\}</span>; the case <span class="math">u=-1</span> forces <span class="math">1-t=-(1+t)</span>, contradiction, so <span class="math">u=1</span> and <span class="math">t=0</span>; so <span class="math">v=r^{2}</span>, so <span class="math">Y=(r^{2})^{(q+1)/4}\\chi(1+1/c^{2})=\\chi(r)r\\chi(r/c)=r\\chi(c)</span>, so <span class="math">x=2(c-1)s\\chi(c)/r</span> as claimed; also note for future reference that <span class="math">y=(r-4)/(r+4)</span>, i.e., <span class="math">\\phi(0)=(2(c-1)s\\chi(c)/r,(r-4)/(r+4))</span>.</p>

    <p class="text-gray-300">Define <span class="math">t^{\\prime}=-t</span>, and define <span class="math">u^{\\prime},v^{\\prime},X^{\\prime},Y^{\\prime},x^{\\prime},y^{\\prime}</span> as in Part A of this proof. Then <span class="math">X^{\\prime}=1/X</span>, so <span class="math">X+X^{\\prime}=-2(1+\\eta r)</span>.</p>

    <p class="text-gray-300">By construction <span class="math">1+\\eta r+\\bar{X}</span> is a square root of <span class="math">(1+\\eta r)^{2}-1</span>; i.e., <span class="math">\\bar{X}^{2}+2(1+\\eta r)\\bar{X}+1=0</span>. Now <span class="math">(\\bar{X}-X)(\\bar{X}-X^{\\prime})=\\bar{X}^{2}-(X+X^{\\prime})\\bar{X}+XX^{\\prime}=\\bar{X}^{2}+2(1+\\eta r)\\bar{X}+1=0</span> so <span class="math">\\bar{X}=X</span> or <span class="math">\\bar{X}=X^{\\prime}</span>. This forces <span class="math">\\bar{u}=u</span> or <span class="math">\\bar{u}=u^{\\prime}</span>, since the definition of <span class="math">z</span> turns out to match <span class="math">\\chi(v)</span> and <span class="math">\\chi(v^{\\prime})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\bar{X}=X</span> then <span class="math">(c-1)s\\bar{X}(1+\\bar{X})=xY</span> so <span class="math">z=\\chi\\big{(}x^{2}Y(X^{2}+1/c^{2})\\big{)}=\\chi(Y)\\chi\\big{(}X^{2}+1/c^{2}\\big{)}</span>. Note that <span class="math">(\\chi(v)v)^{(q+1)/4}</span> is a square and <span class="math">\\chi\\big{(}u^{2}+1/c^{2}\\big{)}=\\chi\\big{(}X^{2}+1/c^{2}\\big{)}</span>, so <span class="math">\\chi(Y)=\\chi(v)\\chi(X^{2}+1/c^{2})</span>, so <span class="math">z=\\chi(v)</span>, so <span class="math">\\bar{u}=\\chi(v)X=u</span>, so <span class="math">\\bar{t}=t</span>.</li>

      <li>If <span class="math">\\bar{X}=X^{\\prime}</span> then similarly <span class="math">z=\\chi(v^{\\prime})</span>, <span class="math">\\bar{u}=u^{\\prime}</span>, and <span class="math">\\bar{t}=t^{\\prime}=-t</span>.</li>

    </ul>

    <p class="text-gray-300">To summarize, <span class="math">\\bar{t}\\in\\{t,-t\\}</span>, so <span class="math">\\phi(\\bar{t})=(x,y)</span>.</p>

    <p class="text-gray-300">The same logic also shows that there are no preimages <span class="math">p</span> of <span class="math">(x,y)</span> except for <span class="math">t</span> and <span class="math">-t</span>. Indeed, if <span class="math">(x,y)=\\phi(p)</span> then substituting <span class="math">p</span> for <span class="math">t</span> in the same proof shows that <span class="math">\\bar{t}\\in\\{p,-p\\}</span>, so <span class="math">p\\in\\{\\bar{t},-\\bar{t}\\}=\\{t,-t\\}</span>.</p>

    <p class="text-gray-300">C. Fix <span class="math">(x,y)\\in E({\\bf F}_{q})</span>. Assume that <span class="math">y+1\\neq 0</span>; that <span class="math">(1+\\eta r)^{2}-1</span> is a square, where <span class="math">\\eta=(y-1)/(2(y+1))</span>; and that if <span class="math">\\eta r=-2</span> then <span class="math">x=2s(c-1)\\chi(c)/r</span>. We now show that <span class="math">(x,y)\\in\\phi({\\bf F}_{q})</span>. This is the reverse part of statement 2 of the theorem.</p>

    <p class="text-gray-300">If <span class="math">x=0</span> then <span class="math">(x,y)=(0,\\pm 1)</span> from the curve equation; but <span class="math">y+1\\neq 0</span>, so <span class="math">(x,y)=(0,1)=\\phi(1)\\in\\phi({\\bf F}_{q})</span> as claimed. Assume from now on that <span class="math">x\\neq 0</span>.</p>

    <p class="text-gray-300">If <span class="math">y=1</span> then <span class="math">x=0</span> from the curve equation, contradiction. Hence <span class="math">y\\neq 1</span>; i.e., <span class="math">\\eta\\neq 0</span>.</p>

    <p class="text-gray-300">Define <span class="math">X=-(1+\\eta r)+((1+\\eta r)^{2}-1)^{(q+1)/4}</span>. As above <span class="math">1+\\eta r+X</span> is a square root of <span class="math">(1+\\eta r)^{2}-1</span>, so <span class="math">X^{2}+2(1+\\eta r)X+1=0</span>. This quadratic equation has several consequences. First, <span class="math">X\\neq 0</span>. Second, <span class="math">rX+(1+X)^{2}\\neq 0</span>: otherwise subtract to see that <span class="math">(1-2\\eta)rX=0</span>, so <span class="math">1=2\\eta</span>, so <span class="math">y-1=y+1</span>, contradiction. Third, <span class="math">X\\neq-1</span>: otherwise <span class="math">\\eta=0</span>, contradiction. Fourth, <span class="math">y=(rX-(1+X)^{2})/(rX+(1+X)^{2})</span>.</p>

    <p class="text-gray-300">If <span class="math">X=1</span> then <span class="math">y=(r-4)/(r+4)</span>; also <span class="math">\\eta r=-2</span> so by assumption <span class="math">x=2s(c-1)\\chi(c)/r</span> so <span class="math">(x,y)=\\phi(0)\\in\\phi({\\bf F}_{q})</span>. Assume from now on that <span class="math">X\\neq 1</span>.</p>

    <p class="text-gray-300">Observe that</p>

    <p class="text-gray-300"><span class="math">(rX+(1+X)^{2})^{2}(1-y^{2})</span></p>

    <p class="text-gray-300"><span class="math">=(rX+(1+X)^{2})^{2}-(rX-(1+X)^{2})^{2}</span></p>

    <p class="text-gray-300"><span class="math">=4rX(1+X)^{2}.</span></p>

    <p class="text-gray-300">Recall that <span class="math">-d=(r+2)/(r-2)</span> and similarly observe that</p>

    <p class="text-gray-300"><span class="math">(rX+(1+X)^{2})^{2}(1-dy^{2})</span></p>

    <p class="text-gray-300"><span class="math">=(rX+(1+X)^{2})^{2}+\\frac{r+2}{r-2}(rX-(1+X)^{2})^{2}</span></p>

    <p class="text-gray-300"><span class="math">=(2r/(r-2))(X^{4}+(r^{2}-2)X^{2}+1).</span></p>

    <p class="text-gray-300">Note that <span class="math">1-dy^{2}\\neq 0</span> since <span class="math">d</span> is not a square. Divide:</p>

    <p class="text-gray-300"><span class="math">x^{2}=\\frac{1-y^{2}}{1-dy^{2}}=\\frac{2(r-2)X^{2}(1+X)^{2}}{X^{5}+(r^{2}-2)X^{3}+X}.</span></p>

    <p class="text-gray-300">Define <span class="math">Y=(c-1)sX(1+X)/x</span>. Then</p>

    <p class="text-gray-300"><span class="math">Y^{2}</span> <span class="math">=(c-1)^{2}s^{2}X^{2}(1+X)^{2}/x^{2}</span></p>

    <p class="text-gray-300"><span class="math">=2(r-2)X^{2}(1+X)^{2}/x^{2}</span></p>

    <p class="text-gray-300"><span class="math">=X^{5}+(r^{2}-2)X^{3}+X.</span></p>

    <p class="text-gray-300">Define <span class="math">z=\\chi\\big{(}Y(X^{2}+1/c^{2})\\big{)}</span>. Both <span class="math">Y</span> and <span class="math">X^{2}+1/c^{2}</span> are nonzero, so <span class="math">z\\in\\{\\pm 1\\}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Define <span class="math">u = zX</span>. Then <span class="math">u \\in \\{\\pm X\\}</span>. Note that <span class="math">u \\neq -1</span>, since <span class="math">X \\notin \\{\\pm 1\\}</span>.</p>

    <p class="text-gray-300">Define <span class="math">v = u^5 + (r^2 - 2)u^3 + u</span>. Then <span class="math">v = z(X^5 + (r^2 - 2)X^3 + X) = zY^2</span>, so <span class="math">\\chi(v) = \\chi(z) = z</span>. Hence <span class="math">X = \\chi(v)u</span> and <span class="math">Y^2 = \\chi(v)v</span>. Furthermore <span class="math">\\chi(v) = z = \\chi\\big(Y(X^2 + 1/c^2)\\big) = \\chi\\big(Y(u^2 + 1/c^2)\\big)</span>, so <span class="math">\\chi(Y) = \\chi(v)\\chi\\big(u^2 + 1/c^2\\big)</span>, so <span class="math">Y = (\\chi(v)v)^{(q+1)/4}\\chi(v)\\chi\\big(u^2 + 1/c^2\\big)</span>.</p>

    <p class="text-gray-300">Finally define <span class="math">t = (1 - u) / (1 + u)</span>. Then <span class="math">t \\notin \\{\\pm 1\\}</span> and <span class="math">u = (1 - t) / (1 + t)</span>. The formulas for <span class="math">u, v, X, Y, x, y</span> in Theorem 1 are all satisfied, so <span class="math">(x, y) = \\phi(t) \\in \\phi(\\mathbf{F}_q)</span> as claimed.</p>

    <h2 id="sec-21" class="text-2xl font-bold">3.4 Encoding as strings</h2>

    <p class="text-gray-300">THEOREM 4. In the situation of Definition 2, assume that <span class="math">q</span> is prime, and define <span class="math">b = \\lfloor \\log_2 q \\rfloor</span>. Define <span class="math">\\sigma : \\{0,1\\}^b \\to \\mathbf{F}_q</span> by <span class="math">\\sigma(\\tau_0, \\tau_1, \\ldots, \\tau_{b-1}) = \\sum_i \\tau_i 2^i</span>. Define <span class="math">S = \\sigma^{-1}(\\{0,1,2,\\ldots,(q-1)/2\\})</span>. Define <span class="math">\\iota : S \\to E(\\mathbf{F}_q)</span> as follows: <span class="math">\\iota(\\tau) = \\phi(\\sigma(\\tau))</span>. Then <span class="math">\\#S = (q+1)/2</span>; <span class="math">\\iota</span> is an injective map from <span class="math">S</span> to <span class="math">E(\\mathbf{F}_q)</span>; and <span class="math">\\iota(S) = \\phi(\\mathbf{F}_q)</span>.</p>

    <p class="text-gray-300">PROOF. First <span class="math">2^b \\leq q</span> so the integers <span class="math">0, 1, \\ldots, 2^b - 1</span> are distinct in <span class="math">\\mathbf{F}_q</span>; hence <span class="math">\\sigma</span> is injective. Furthermore <span class="math">2^b &amp;gt; q/2</span> so <span class="math">\\{0, 1, \\ldots, (q-1)/2\\}</span> is a subset of <span class="math">\\{0, 1, \\ldots, 2^b - 1\\}</span>; hence each of <span class="math">0, 1, \\ldots, (q-1)/2</span> has a preimage under <span class="math">\\sigma</span>, and <span class="math">S</span> has exactly <span class="math">(q+1)/2</span> elements.</p>

    <p class="text-gray-300">If <span class="math">\\iota(\\tau) = \\iota(\\tau&#x27;)</span> then <span class="math">\\phi(\\sigma(\\tau)) = \\phi(\\sigma(\\tau&#x27;))</span>, so <span class="math">\\sigma(\\tau) = \\pm \\sigma(\\tau&#x27;)</span> by Theorem 3; but <span class="math">\\sigma(\\tau)</span> and <span class="math">\\sigma(\\tau&#x27;)</span> are both in <span class="math">\\{0,1,\\ldots,(q-1)/2\\}</span>, so <span class="math">\\sigma(\\tau) = \\sigma(\\tau&#x27;)</span>, so <span class="math">\\tau = \\tau&#x27;</span>. Hence <span class="math">\\iota</span> is injective.</p>

    <p class="text-gray-300">Each element of <span class="math">\\iota(S)</span> has the form <span class="math">\\phi(\\sigma(\\tau))</span> and is therefore in <span class="math">\\phi(\\mathbf{F}_q)</span>. Conversely, if <span class="math">P \\in \\phi(\\mathbf{F}_q)</span> then <span class="math">P = \\phi(t)</span> for some <span class="math">t \\in \\mathbf{F}_q</span>, so also <span class="math">P = \\phi(-t)</span> by Theorem 3. At least one of <span class="math">t, -t</span> is in <span class="math">\\{0,1,\\ldots,(q-1)/2\\}</span>, i.e., in <span class="math">\\sigma(S)</span>, so <span class="math">P</span> is in <span class="math">\\phi(\\sigma(S)) = \\iota(S)</span>.</p>

    <h2 id="sec-22" class="text-2xl font-bold">3.5 Performance analysis</h2>

    <p class="text-gray-300">The definitions of <span class="math">u, v, X, Y, x, y</span> in Theorem 1 involve divisions by <span class="math">1 + t</span>, <span class="math">c</span>, <span class="math">Y</span>, and <span class="math">rX + (1 + X)^2</span>. The reciprocal of <span class="math">c</span> is trivially precomputed, and the other divisions are easily replaced by a few multiplications: one simply stores field elements as fractions, i.e., works in projective coordinates. There are several easy ways to reduce the number of multiplications: for example, factor <span class="math">u^5 + (r^2 - 2)u^3 + u</span> as <span class="math">u(u^2 + c^2)(u^2 + 1/c^2)</span>, and reuse <span class="math">u^2 + 1/c^2</span> in computing <span class="math">Y</span>.</p>

    <p class="text-gray-300">The main bottlenecks are then the following exponentiations: computing <span class="math">\\chi(v)</span> (used repeatedly); computing <span class="math">\\chi\\big(u^2 + 1/c^2\\big)</span>; computing <span class="math">(\\chi(v)v)^{(q+1)/4}</span>, the principal square root of <span class="math">\\chi(v)v</span>; and computing a final division if the output <span class="math">(x, y)</span> is needed in affine coordinates instead of projective coordinates. The only essential exponentiation is for the square-root computation: the <span class="math">\\chi</span> computations and division can use Euclid's algorithm (blinded to protect against timing attacks) rather than exponentiation.</p>

    <p class="text-gray-300">Similar comments apply to inverting <span class="math">\\phi</span> (or <span class="math">\\iota</span>). There is one essential exponentiation, the square-root computation to obtain <span class="math">\\bar{X}</span> in Theorem 3. There are also two exponentiations that can be replaced by Euclidean computations: one <span class="math">\\chi</span> computation to obtain <span class="math">z</span>, and one division to obtain the final output <span class="math">\\bar{t}</span>. Fractions eliminate the initial division by <span class="math">2(y + 1)</span>, but fractions cannot be used for <span class="math">\\bar{t}</span>, since the goal is to obtain the unique string representing <span class="math">\\bar{t}</span>.</p>

    <p class="text-gray-300">It is easier to test, given <span class="math">(x,y)\\in \\mathbf{F}_q\\times \\mathbf{F}_q</span>, whether <span class="math">(x,y)\\in \\phi (\\mathbf{F}_q)</span> (i.e., whether <span class="math">(x,y)\\in \\iota (S)</span>) without inverting <span class="math">\\phi</span>. One first checks <span class="math">x^{2} + y^{2} = 1 + dx^{2}y^{2}</span> to verify <span class="math">(x,y)\\in E(\\mathbf{F}_q)</span>, if this is not already known. Then, by</p>

    <p class="text-gray-300">Theorem 3, <span class="math">(x,y)\\in \\phi (\\mathbf{F}_q)</span> if and only if the following three conditions are satisfied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">y + 1 \\neq 0</span>;</li>

      <li><span class="math">(1 + \\eta r)^2 - 1</span> is a square, where <span class="math">\\eta = (y - 1) / (2(y + 1))</span>; i.e., <span class="math">r(y - 1)(r(y - 1) + 4(y + 1))</span> is a square;</li>

      <li>if <span class="math">\\eta r = -2</span> (equivalently, if <span class="math">r(y - 1) = -4(y + 1)</span>) then <span class="math">x = 2s(c - 1)\\chi(c) / r</span>.</li>

    </ul>

    <p class="text-gray-300">This requires a few multiplications and one <span class="math">\\chi</span> computation.</p>

    <h2 id="sec-23" class="text-2xl font-bold">4. CONSTRUCTION OF A SUITABLE ELLIPTIC CURVE FOR ELLIGATOR 1</h2>

    <p class="text-gray-300">This section introduces a new high-security high-speed elliptic curve, called Curve1174, that supports the injective map presented in Section 3. In particular, this section specifies Curve1174; presents the criteria that we used to construct Curve1174; and analyzes the extent to which various previous curves meet the same criteria.</p>

    <p class="text-gray-300">Curve1174 illustrates state-of-the-art criteria for choosing elliptic curves. It is compatible with Elligator 1, and is also compatible with the new map Elligator 2 introduced in the next section. It is even more concisely expressible than the existing Curve25519 curve.</p>

    <p class="text-gray-300">We do not mean to suggest that users of Curve25519 are required to switch to Curve1174 to take advantage of this paper. Curve25519 is fully compatible with Elligator 2.</p>

    <h2 id="sec-24" class="text-2xl font-bold">4.1 The curve</h2>

    <p class="text-gray-300">Curve1174 is the Edwards curve <span class="math">x^{2} + y^{2} = 1 - 1174x^{2}y^{2}</span> over the field <span class="math">\\mathbf{F}_q</span>, where <span class="math">q</span> is the prime number <span class="math">2^{251} - 9</span>. The coefficient -1174 is a non-square in <span class="math">\\mathbf{F}_q</span>, so Curve1174 is a complete Edwards curve by [9, Theorem 3.3]: the sum of any two points <span class="math">(x_{1},y_{1})</span> and <span class="math">(x_{2},y_{2})</span> in Curve1174 <span class="math">(\\mathbf{F}_q)</span> is</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {x _ {1} y _ {2} + y _ {1} x _ {2}}{1 - 1 1 7 4 x _ {1} x _ {2} y _ {1} y _ {2}}, \\frac {y _ {1} y _ {2} - x _ {1} x _ {2}}{1 + 1 1 7 4 x _ {1} x _ {2} y _ {1} y _ {2}}\\right),</span></div>

    <p class="text-gray-300">with no divisions by 0 and no exceptional cases. The neutral element of the curve is <span class="math">(0,1)</span>.</p>

    <p class="text-gray-300">To see that we have the desired injective map, note that <span class="math">q</span> is congruent to 3 modulo 4; define <span class="math">s</span> as the element</p>

    <p class="text-gray-300">18064941211227179925228040535007972296</p>

    <p class="text-gray-300">48438766985538871240722010849934886421</p>

    <p class="text-gray-300">of <span class="math">\\mathbf{F}_q</span> (split onto two lines here for readability); define <span class="math">c = 2 / s^2</span>; and define <span class="math">d = -(c + 1)^2 /(c - 1)^2</span>. Then <span class="math">d = -1174</span>. The Edwards curve in Theorem 1 and Definition 2, for this choice of <span class="math">(q,s)</span>, is exactly Curve1174.</p>

    <p class="text-gray-300">Curve1174 is birationally equivalent to the Montgomery curve <span class="math">(4 / 1175)V^{2} = U^{3} + (4 / 1175 - 2)U^{2} + U</span> by [9, Theorem 3.2]. The leading coefficient <span class="math">4 / 1175</span> is a non-square in <span class="math">\\mathbf{F}_q</span>, so <span class="math">V^2 = U^3 +(4 / 1175 - 2)U^2 +U</span> is a nontrivial quadratic twist of this curve. The Sage computer-algebra system [46] counts points on this curve in under 10 seconds on a laptop using the following script:</p>

    <p class="text-gray-300">q=2^251-9</p>

    <p class="text-gray-300">E=EllipticCurve(GF(q), [0, 4/1175-2, 0, 1, 0])</p>

    <p class="text-gray-300">print E.trace_of_frobenius()</p>

    <p class="text-gray-300">The number of points on the twist is thus <span class="math">q + 1 + t</span>, and the number of points on Curve1174 is <span class="math">q + 1 - t</span>, where <span class="math">t = 45330879683285730139092453152713398836</span>. These integers</p>

    <p class="text-gray-300"><span class="math">q+1+t,q+1-t</span> have the form <span class="math">4p_{0},4p_{1}</span> respectively, where <span class="math">p_{0}</span> and <span class="math">p_{1}</span> are primes close to <span class="math">2^{249}</span>. Generic methods to compute a discrete logarithm on Curve1174 or its twist take approximately <span class="math">\\sqrt{\\pi 2^{247}}\\approx 2^{124.3}</span> group operations on average.</p>

    <p class="text-gray-300">The point <span class="math">(U,V)=(4,19225777642111670230408712442205514783403012708409058383774613284963344096)</span> on the Montgomery curve <span class="math">(4/1175)V^{2}=U^{3}+(4/1175-2)U^{2}+U</span> has order <span class="math">4p_{1}</span>. The corresponding point on Curve1174 is <span class="math">(x,y)=(4/V,3/5)</span>.</p>

    <p class="text-gray-300">Curve1174 and its twist do not have any structure allowing fast pairings or other special approaches to computing discrete logarithms. The primes <span class="math">p_{0}</span> and <span class="math">p_{1}</span> do not equal the field characteristic <span class="math">q</span>. The order of <span class="math">q</span> modulo <span class="math">p_{0}</span> is not small: it is <span class="math">(p_{0}-1)/2</span>. The order of <span class="math">q</span> modulo <span class="math">p_{1}</span> is not small: it is <span class="math">p_{1}-1</span>. The endomorphism ring of Curve1174 has a large discriminant: up to squares this discriminant equals <span class="math">t^{2}-4q</span>, which is divisible once by the prime <span class="math">161567415114024992333870349255799</span>, so the discriminant must be a multiple of this prime.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">4.2 Design criteria</h3>

    <p class="text-gray-300">We consider only prime fields. Bernstein, citing subfield attacks from <em>[28]</em> and <em>[18]</em>, wrote in <em>[6]</em> that prime fields “have the virtue of minimizing the number of security concerns for elliptic-curve cryptography”; see <em>[22]</em> and <em>[43]</em> for recent developments of the attack strategy from <em>[18]</em>. Similarly, the Brainpool standard <em>[14]</em> and NSA’s Suite B standards <em>[37]</em> require prime fields. There is general agreement that prime fields are the safe, conservative choice for ECC. Prime fields also perform very well across a wide range of processors; the current ECC speed records on high-end Intel processors take advantage of special Intel support for binary fields (see <em>[42]</em>), but most CPUs do not have any comparable support.</p>

    <p class="text-gray-300">We consider only primes <span class="math">q</span> congruent to 3 modulo 4. This is required for the injective map <span class="math">\\phi</span>. These primes also have the well-known benefit of allowing very simple square-root computations; most other primes allow square-root computations at similar speed but with more complicated methods.</p>

    <p class="text-gray-300">We consider only complete Edwards curves, i.e., curves <span class="math">x^{2}+y^{2}=1+dx^{2}y^{2}</span> where <span class="math">d</span> is not a square. This is required for the injective map. About 25% of all elliptic curves over <span class="math">\\mathbf{F}_{q}</span> are expressible as complete Edwards curves, as mentioned in <em>[9, Abstract]</em> and experimentally verified in <em>[7, Section 4]</em>. Complete Edwards curves also have the advantages of being extremely fast and of allowing a single addition formula with no exceptions. Complete Edwards curves are also expressible as Montgomery curves supporting very fast and uniform Montgomery-ladder computations.</p>

    <p class="text-gray-300">To protect against generic discrete-logarithm algorithms we impose the standard requirement of a large prime dividing the number of curve points. This forces <span class="math">q</span> to be even larger, where the gap accounts for the cofactor: the number of curve points divided by this prime. To minimize the performance problems of a large <span class="math">q</span> we consider only Edwards curves with minimal cofactor, namely 4. The number of curve points is 4 times a prime for slightly below 1% of all choices of <span class="math">d</span>, for the size of <span class="math">q</span> that we consider below.</p>

    <p class="text-gray-300">We also impose the requirement of “twist security”: a large prime dividing the number of points on the quadratic twist of the curve. This prevents “twist attacks” against protocols that use the “Montgomery ladder” without checking that incoming points are on the curve; this defense was proposed by Bernstein in <em>[5, page 23]</em> and <em>[4]</em>. For <span class="math">q\\equiv 3\\pmod{4}</span> roughly <span class="math">1/10000</span> of all choices of <span class="math">d</span> have the number of points on the curve and the number of points on the twist each being 4 times a prime.</p>

    <p class="text-gray-300">We require <span class="math">d</span> to have the form <span class="math">-(c+1)^{2}/(c-1)^{2}</span> with <span class="math">c=2/s^{2}</span>. This is required for the injective map, and covers about half of all non-squares <span class="math">d</span> for <span class="math">q\\equiv 3\\pmod{4}</span>.</p>

    <p class="text-gray-300">For standard performance reasons we take <span class="math">q</span> very close to, but not above, a power of 2. The primes <span class="math">q\\equiv 3\\pmod{4}</span> within 32 of <span class="math">2^{c}</span> for <span class="math">200\\leq c\\leq 300</span> are <span class="math">2^{206}-5</span>, <span class="math">2^{212}-29</span>, <span class="math">2^{226}-5</span>, <span class="math">2^{243}-9</span>, <span class="math">2^{251}-9</span>, and <span class="math">2^{285}-9</span>. Note that these fields ensure that <span class="math">\\sigma^{-1}</span> covers nearly all of <span class="math">\\{0,1,\\ldots,2^{b}-1\\}</span> giving a very close to uniform distribution of the encoding function. We focus on the last two of these primes as providing quantitatively safe security levels, and choose <span class="math">2^{251}-9</span> as being obviously faster.</p>

    <p class="text-gray-300">Some curve operations involve multiplications by <span class="math">d</span>. To speed up these multiplications we take the smallest possible <span class="math">d</span> in absolute value, subject to the other requirements. The choice <span class="math">d=-1174</span> for <span class="math">q=2^{251}-9</span> is smaller than expected.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.3 Previous curves over prime fields</h3>

    <p class="text-gray-300">There is a long history of specific elliptic curves being designed to meet various security and performance criteria. For example, almost fifteen years ago the IEEE P1363 standard <em>[33, Sections A.9–A.12]</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>specified curves <span class="math">y^{2}=x^{3}-3x+b</span> to “provide the fastest arithmetic on elliptic curves”;</li>

      <li>imposed various further conditions upon these curves, with the security goal of making discrete logarithms difficult to compute; and</li>

      <li>specified a procedure to generate “verifiably pseudo-random” curves meeting these conditions.</li>

    </ul>

    <p class="text-gray-300">NIST’s standard curves P-192, P-224, P-256, P-384, and P-521 were generated as follows: five particular prime fields were chosen with the goal of maximizing performance; the IEEE P1363 procedure was used to generate one curve over each of those fields.</p>

    <p class="text-gray-300">Subsequent research developed new security and performance criteria for curves over prime fields: twist security, Montgomery compatibility, Edwards compatibility, and completeness. The NIST curves, unsurprisingly, flunk these criteria: choosing cofactor 1 for <span class="math">y^{2}=x^{3}-3x+b</span> is incompatible with both Montgomery and Edwards, and one cannot expect twist security if it is not demanded in advance. Newer curves meet all of these criteria: for example, Curve25519 was explicitly designed for twist security and Montgomery compatibility, and was shown in <em>[9]</em> to also be expressible as a complete Edwards curve.</p>

    <p class="text-gray-300">These extra criteria do not improve discrete-logarithm security, but they do improve real-world security. They allow the simplest implementations to be correct implementations, whereas for other curves the simplest implementations that seem to work actually have hidden flaws that compromise security. See, e.g., <em>[11, Section 4.1]</em>, <em>[34]</em>, and <em>[24]</em>.</p>

    <p class="text-gray-300">We are imposing a new security condition to support censorship circumvention: namely, an efficient way to encode a large fraction of all curve points as strings indistinguishable from uniform random strings. The generality of Elligator 1 makes it easy to imagine how this security condition could be accidentally met by previously generated curves:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The advantages of complete Edwards curves have been well known for five years.</li>

      <li>The advantages of Montgomery curves have been well known for even longer. A random Montgomery curve has a good chance of being expressible as a complete Edwards curve; see <em>[7, Section 4]</em>.</li>

      <li>All complete Edwards curves over <span class="math">\\mathbf{F}_{q}</span> for <span class="math">q\\equiv 3\\pmod{4}</span> meet the new security condition. Half of these curves are within the streamlined case expressed by Theorem 1.</li>

    </ul>

    <p class="text-gray-300">Given the amount of speed optimization of Curve25519 (see <em>[6]</em>, <em>[29]</em>, <em>[17]</em>, <em>[8]</em>, and <em>[10]</em>) and the wide deployment of Curve25519 in several applications (see, e.g., <em>[2]</em>) one of our initial goals for this paper was to show that Curve25519 meets this security condition. However, Elligator 1 is clearly limited to <span class="math">q\\equiv 3\\pmod{4}</span>, while Curve25519 is defined over <span class="math">\\mathbf{F}_{q}</span> with <span class="math">q\\equiv 1\\pmod{4}</span>. We provide two different solutions for this problem: Elligator 2 (see Section 5) and Curve1174.</p>

    <p class="text-gray-300">We would expect serious implementations of Curve1174 to be competitive in speed with Curve25519. Curve1174 has some small advantages: for example, <span class="math">2^{251}-9</span> is closer to a power of 2 than <span class="math">2^{255}-19</span> is; 1174 is considerably smaller than 486662; and square roots modulo <span class="math">2^{251}-9</span> are slightly easier than square roots modulo <span class="math">2^{255}-19</span>. On the other hand, Curve25519 also has a small advantage: it is expressible in “<span class="math">-1</span>-twisted Edwards form”, allowing the speedup explained in <em>[31]</em>. Obviously applications already using Curve25519 should not switch away from it, but for new applications it is not clear which curve is better.</p>

    <h2 id="sec-28" class="text-2xl font-bold">5 Elligator 2: Handling generic curves with a point of order 2</h2>

    <p class="text-gray-300">This section introduces a new injective map <span class="math">\\psi</span> to any elliptic curve of the form <span class="math">y^{2}=x^{3}+Ax^{2}+Bx</span> with <span class="math">AB(A^{2}-4B)\\neq 0</span> over any odd finite field, i.e., any finite field of odd characteristic. We emphasize that the characteristic is not required to be 3 modulo 4. This curve shape includes all Montgomery curves <span class="math">y^{2}=x^{3}+Ax^{2}+x</span> except <span class="math">y^{2}=x^{3}+x</span>, and in particular it includes Curve25519.</p>

    <p class="text-gray-300">Any curve of this form has a point <span class="math">(0,0)</span> of order 2. Conversely, over any odd finite field, almost every elliptic curve having a point of order 2 can be written in this form. Indeed, an elliptic curve over an odd finite field can always be written as <span class="math">y^{2}=u^{3}+a_{2}u^{2}+a_{4}u+a_{6}</span>; a point of order 2 on this curve must have the form <span class="math">(r,0)</span> where <span class="math">r^{3}+a_{2}r^{2}+a_{4}r+a_{6}=0</span>; substituting <span class="math">u=x+r</span> produces the curve <span class="math">y^{2}=x^{3}+Ax^{2}+Bx</span> where <span class="math">A=a_{2}+3r</span> and <span class="math">B=a_{4}+2a_{2}r+3r^{2}</span>. This curve must have <span class="math">B(A^{2}-4B)\\neq 0</span> since it is elliptic. The only exceptional case is <span class="math">A=0</span>, i.e., curves whose <span class="math">j</span>-invariant equals 1728; this section assumes <span class="math">A\\neq 0</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.1 Squares</h3>

    <p class="text-gray-300">Fix an odd prime power <span class="math">q</span>. As in Section 3.1 we define <span class="math">\\chi:\\mathbf{F}_{q}\\rightarrow\\mathbf{F}_{q}</span> by <span class="math">\\chi(a)=a^{(q-1)/2}</span>, and we have <span class="math">\\chi(a)</span> equal to 1, <span class="math">-1</span>, or 0 when <span class="math">a</span> is, respectively, a non-zero square, a non-square, or zero.</p>

    <p class="text-gray-300">The definition of Elligator 2 is parametrized by a square-root function for <span class="math">\\mathbf{F}_{q}</span>: a function <span class="math">\\sqrt{\\;}:\\mathbf{F}_{q}^{2}\\rightarrow\\mathbf{F}_{q}</span> such that <span class="math">\\sqrt{a^{2}}\\in\\{a,-a\\}</span> for each <span class="math">a\\in\\mathbf{F}_{q}</span>, where <span class="math">\\mathbf{F}_{q}^{2}</span> means <span class="math">\\left\\{a^{2}:a\\in\\mathbf{F}_{q}\\right\\}</span>. Note that a square-root function <span class="math">\\sqrt{\\;}</span> is completely described by its image <span class="math">\\sqrt{\\mathbf{F}_{q}^{2}}</span>.</p>

    <p class="text-gray-300">For <span class="math">q\\equiv 3\\pmod{4}</span> one can take the principal square root as a square-root function, i.e., take <span class="math">\\sqrt{\\mathbf{F}_{q}^{2}}=\\mathbf{F}_{q}^{2}</span>, as in Section 3.1; but the concept of principal square roots does not generalize to <span class="math">q\\equiv 1\\pmod{4}</span>. For any odd prime <span class="math">q</span> one can take <span class="math">\\sqrt{\\mathbf{F}_{q}^{2}}=\\{0,1,\\ldots,(q-1)/2\\}</span>. Other choices sometimes have computational benefits.</p>

    <p class="text-gray-300">The definition of Elligator 2 is also parametrized by a non-square <span class="math">u\\in\\mathbf{F}_{q}</span>. If <span class="math">q\\equiv 3\\pmod{4}</span> then one can take <span class="math">u=-1</span>. If <span class="math">q\\equiv 5\\pmod{8}</span> then one can take <span class="math">u=2</span>. Finding a non-square is an easy computation in general since about half of the elements of <span class="math">\\mathbf{F}_{q}</span> are non-squares. For efficiency it is desirable to choose <span class="math">u</span> to be small, or otherwise to choose <span class="math">u</span> to speed up multiplications by <span class="math">u</span>.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">5.2 The map</h3>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">q</span> be an odd prime power. Let <span class="math">A,B</span> be elements of <span class="math">\\mathbf{F}_{q}</span> such that <span class="math">AB(A^{2}-4B)\\neq 0</span>. Let <span class="math">u</span> be a non-square in <span class="math">\\mathbf{F}_{q}</span>. Let <span class="math">\\sqrt{\\;}</span> be a square-root function for <span class="math">\\mathbf{F}_{q}</span>. Define <span class="math">R</span> as the set</p>

    <p class="text-gray-300"><span class="math">\\left\\{r\\in\\mathbf{F}_{q}:1+ur^{2}\\neq 0,\\;A^{2}ur^{2}\\neq B(1+ur^{2})^{2}\\right\\}.</span></p>

    <p class="text-gray-300">The following elements of <span class="math">\\mathbf{F}_{q}</span> are defined for each nonzero <span class="math">r\\in R</span>:</p>

    <p class="text-gray-300"><span class="math">v=-A/(1+ur^{2}),</span> <span class="math">\\epsilon=\\chi(v^{3}+Av^{2}+Bv),</span> <span class="math">x=\\epsilon v-(1-\\epsilon)A/2,</span> <span class="math">y=-\\epsilon\\sqrt{x^{3}+Ax^{2}+Bx}.</span></p>

    <p class="text-gray-300">Furthermore <span class="math">v\\epsilon xy\\neq 0</span> and <span class="math">y^{2}=x^{3}+Ax^{2}+Bx</span>.</p>

    <p class="text-gray-300">If <span class="math">q\\equiv 1\\pmod{4}</span> and <span class="math">A^{2}-4B</span> is a non-square in <span class="math">\\mathbf{F}_{q}</span> then <span class="math">R=\\mathbf{F}_{q}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">\\boldsymbol{v}</span> is defined and <span class="math">\\boldsymbol{v\\neq 0}</span>: By hypothesis <span class="math">A\\neq 0</span> and <span class="math">1+ur^{2}\\neq 0</span>.</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{v^{3}+Av^{2}+Bv\\neq 0}</span> and <span class="math">\\boldsymbol{\\epsilon\\neq 0}</span>: Note that <span class="math">v+var^{2}=-A</span> so <span class="math">v^{2}+Av=v(v+A)=v(-var^{2})</span>. If <span class="math">v^{2}+Av+B=0</span> then <span class="math">v^{2}ur^{2}=B</span> so, using the definition of <span class="math">v</span>, <span class="math">A^{2}ur^{2}=B(1+ur^{2})^{2}</span>, contradicting the definition of <span class="math">R</span>. Hence <span class="math">v^{2}+Av+B\\neq 0</span>, so <span class="math">v^{3}+Av^{2}+Bv\\neq 0</span>, so <span class="math">\\epsilon\\neq 0</span>.</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{x^{3}+Ax^{2}+Bx}</span> is a nonzero square and <span class="math">\\boldsymbol{x\\neq 0}</span>: There are two cases. First case: <span class="math">\\epsilon=1</span>, i.e., <span class="math">v^{3}+Av^{2}+Bv</span> is a nonzero square. Then <span class="math">x=v</span> so <span class="math">x^{3}+Ax^{2}+Bx</span> is a nonzero square; and <span class="math">x\\neq 0</span> since <span class="math">v\\neq 0</span>.</p>

    <p class="text-gray-300">Second case: <span class="math">\\epsilon=-1</span>, i.e., <span class="math">v^{3}+Av^{2}+Bv</span> is a non-square. Then <span class="math">x=-v-A=var^{2}</span>. All factors <span class="math">v,u,r^{2}</span> here are nonzero so <span class="math">x\\neq 0</span>; note also that <span class="math">\\chi(x)=\\chi(v)\\chi(u)=-\\chi(v)</span>. Furthermore <span class="math">x(x+A)=(-v-A)(-v)=v(v+A)</span> so <span class="math">x^{2}+Ax+B=v^{2}+Av+B</span> so <span class="math">\\chi(x^{3}+Ax^{2}+Bx)=-\\chi(v^{3}+Av^{2}+Bv)=-\\epsilon=1</span> so <span class="math">x^{3}+Ax^{2}+Bx</span> is a nonzero square.</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{y}</span> is defined, <span class="math">\\boldsymbol{y^{2}=x^{3}+Ax^{2}+Bx}</span>, and <span class="math">\\boldsymbol{y\\neq 0}</span>: <span class="math">x^{3}+Ax^{2}+Bx</span> is a nonzero square so <span class="math">\\sqrt{x^{3}+Ax^{2}+Bx}</span> is defined; all factors in <span class="math">y=-\\epsilon\\sqrt{x^{3}+Ax^{2}+Bx}</span> are nonzero, and <span class="math">y^{2}=x^{3}+Ax^{2}+Bx</span>.</p>

    <p class="text-gray-300">If <span class="math">\\boldsymbol{q\\equiv 1\\pmod{4}}</span> and <span class="math">\\boldsymbol{A^{2}-4B}</span> is a non-square then <span class="math">\\boldsymbol{R}=\\mathbf{F_{q}}</span>: Fix <span class="math">r\\in\\mathbf{F}_{q}</span>, and write <span class="math">s=ur^{2}</span>. Then <span class="math">\\chi(s)\\in\\{0,-1\\}</span> while <span class="math">\\chi(\\pm 1)=1</span> so <span class="math">s\\neq\\pm 1</span>. In particular <span class="math">1+ur^{2}\\neq 0</span>.</p>

    <p class="text-gray-300">Suppose that <span class="math">A^{2}s=B(1+s)^{2}</span>. Subtract <span class="math">4Bs</span> to obtain <span class="math">(A^{2}-4B)s=B(1-s)^{2}</span>. Multiply to obtain <span class="math">(A^{2}-4B)A^{2}s^{2}=B^{2}(1+s)^{2}(1-s)^{2}</span>. By hypothesis <span class="math">\\chi(A^{2}-4B)=-1</span> so <span class="math">\\chi((A^{2}-4B)A^{2}s^{2})\\in\\{-1,0\\}</span>, while all of <span class="math">B,1+s,1-s</span> are nonzero so <span class="math">\\chi(B^{2}(1+s)^{2}(1-s)^{2})=1</span>, contradiction. Consequently <span class="math">A^{2}ur^{2}\\neq B(1+ur^{2})^{2}</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Definition 6. In the situation of Theorem 5, the decoding function for the Weierstrass curve <span class="math">E: y^2 = x^3 + Ax^2 + Bx</span> is the function <span class="math">\\psi: R \\to E(\\mathbf{F}_q)</span> defined as follows: <span class="math">\\psi(0) = (0, 0)</span>; if <span class="math">r \\neq 0</span> then <span class="math">\\psi(r) = (x, y)</span>.</p>

    <p class="text-gray-300">With more work one can extend the definition of <span class="math">\\psi</span> to cover elements of <span class="math">\\mathbf{F}_q</span> outside <span class="math">R</span>. For example, if <span class="math">A^2 - 4B</span> is a square then one can map any square roots in <span class="math">\\mathbf{F}_q</span> of <span class="math">(A^2 - 2B \\pm A\\sqrt{A^2 - 4B}) / (2uB)</span> to <span class="math">((-A \\pm \\sqrt{A^2 - 4B}) / 2, 0)</span>. However, our main interest is in the case <span class="math">R = \\mathbf{F}_q</span>, and then this extra work is unnecessary.</p>

    <h2 id="sec-33" class="text-2xl font-bold">5.3 Inverting the map</h2>

    <p class="text-gray-300">THEOREM 7. In the situation of Definition 6:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">r \\in R</span> then the set of preimages of <span class="math">\\psi(r)</span> under <span class="math">\\psi</span> is <span class="math">\\{r, -r\\}</span>.</li>

      <li><span class="math">\\psi(R)</span> is the set of <span class="math">(x,y) \\in E(\\mathbf{F}_q)</span> such that</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x \\neq -A</span>,</li>

      <li>if <span class="math">y = 0</span> then <span class="math">x = 0</span>, and</li>

      <li><span class="math">-ux(x + A)</span> is a square in <span class="math">\\mathbf{F}_q</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(x,y) \\in \\psi(R)</span> then the following element <span class="math">\\bar{r}</span> of <span class="math">R</span> is defined and <span class="math">\\psi(\\bar{r}) = (x,y)</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\bar {r} = \\left\\{ \\begin{array}{l l} \\sqrt {- x / ((x + A) u)} &amp;amp; \\text{if } y \\in \\sqrt {\\mathbf {F} _ {q} ^ {2}}; \\\\ \\sqrt {- (x + A) / (u x)} &amp;amp; \\text{if } y \\notin \\sqrt {\\mathbf {F} _ {q} ^ {2}}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">PROOF. 1. If <span class="math">r = 0</span> then <span class="math">r = -r</span> so <span class="math">\\psi(r) = \\psi(-r)</span>. If <span class="math">r \\neq 0</span> then Theorem 5 defines <span class="math">\\psi(r)</span> purely in terms of <span class="math">r^2</span> so <span class="math">\\psi(r) = \\psi(-r)</span>.</p>

    <p class="text-gray-300">Conversely, assume that <span class="math">\\psi(r) = \\psi(r&#x27;)</span>; our goal is to show that <span class="math">r&#x27; \\in \\{r, -r\\}</span>. If <span class="math">r = 0</span> then <span class="math">\\psi(r) = (0,0)</span>, and otherwise <span class="math">\\psi(r)</span> has nonzero coordinates by Theorem 5; hence <span class="math">r = 0</span> if and only if <span class="math">r&#x27; = 0</span>. The only remaining case is that <span class="math">r \\neq 0</span> and <span class="math">r&#x27; \\neq 0</span>.</p>

    <p class="text-gray-300">Define <span class="math">v&#x27;, \\epsilon&#x27;, x&#x27;, y&#x27;</span> from <span class="math">r&#x27;</span> as in Theorem 5. Then <span class="math">(x&#x27;, y&#x27;) = \\psi(r&#x27;) = \\psi(r) = (x, y)</span>. Furthermore <span class="math">y = -\\epsilon \\sqrt{x^3 + Ax^2 + Bx}</span> and <span class="math">y&#x27; = -\\epsilon&#x27; \\sqrt{(x&#x27;)^3 + A(x&#x27;)^2 + B(x&#x27;)}</span> so <span class="math">\\epsilon&#x27; = \\epsilon</span> since <span class="math">\\sqrt{}</span> is a function. Next <span class="math">x = \\epsilon v - (1 - \\epsilon)A/2</span> and <span class="math">x&#x27; = \\epsilon&#x27; v&#x27; - (1 - \\epsilon&#x27;)A/2</span> so <span class="math">v&#x27; = v</span>. Finally <span class="math">1 + u r^2 = 1 + u(r&#x27;)^2</span> so <span class="math">r&#x27; \\in \\{r, -r\\}</span> as claimed.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fix <span class="math">r \\in R</span>, and write <span class="math">(x, y) = \\psi(r)</span>. If <span class="math">r = 0</span> then <span class="math">(x, y) = (0, 0)</span> so <span class="math">x = 0</span>; <span class="math">x \\neq -A</span>; and <span class="math">-ux(x + A) = 0</span> is a square. If <span class="math">r \\neq 0</span> then <span class="math">(x, y)</span> is defined in Theorem 5, and there are two cases. The first case is that <span class="math">\\epsilon = 1</span>; then <span class="math">x = v \\neq -A</span> since <span class="math">u r^2 \\neq 0</span>. The second case is that <span class="math">\\epsilon = -1</span>; then <span class="math">x = -v - A \\neq -A</span> since <span class="math">v \\neq 0</span>. In both cases <span class="math">y \\neq 0</span> by Theorem 5, and <span class="math">-ux(x + A) = -uv(v + A) = -uv(-v u r^2) = u^2 v^2 r^2</span>, which is a square.</li>

    </ol>

    <p class="text-gray-300">Conversely, assume that <span class="math">(x,y) \\in E(\\mathbf{F}_q)</span>, that <span class="math">x \\neq -A</span>, then if <span class="math">y = 0</span> then <span class="math">x = 0</span>, and that <span class="math">-ux(x + A)</span> is a square. Our goal is to show that <span class="math">(x,y) \\in \\psi(R)</span>. We will in fact show more: <span class="math">(x,y) = \\psi(\\bar{r})</span> where <span class="math">\\bar{r}</span> is defined as in the third part of the theorem statement.</p>

    <p class="text-gray-300">If <span class="math">y = 0</span> then <span class="math">x = 0</span> by assumption. Furthermore <span class="math">y = \\sqrt{0} \\in \\sqrt{\\mathbf{F}_q^2}</span> and <span class="math">-x / ((x + A)u) = 0</span> so <span class="math">\\bar{r}</span> is defined as 0. Hence <span class="math">(x,y) = (0,0) = \\psi(0) = \\psi(\\bar{r})</span> as claimed.</p>

    <p class="text-gray-300">Assume from now on that <span class="math">y \\neq 0</span>. The curve equation then implies that <span class="math">x \\neq 0</span>. Now <span class="math">(x + A)u</span> and <span class="math">ux</span> are both nonzero, and both <span class="math">-x / ((x + A)u)</span> and <span class="math">-(x + A) / (ux)</span> are squares, so <span class="math">\\bar{r}</span> is defined and nonzero. We will see below that <span class="math">1 + u\\bar{r}^2 \\neq 0</span></p>

    <p class="text-gray-300">and <span class="math">A^2 u\\bar{r}^2 \\neq B(1 + u\\bar{r}^2)^2</span>, so <span class="math">\\bar{r} \\in R</span>. Define <span class="math">\\bar{v}, \\bar{\\epsilon}, \\bar{x}, \\bar{y}</span> as in Theorem 5.</p>

    <p class="text-gray-300">If <span class="math">y \\in \\sqrt{\\mathbf{F}_q^2}</span> then <span class="math">\\bar{r}^2 = -x / ((x + A)u)</span> so <span class="math">1 + u\\bar{r}^2 = A / (x + A)</span> so <span class="math">\\bar{v} = -x - A</span> so <span class="math">\\chi(\\bar{v}) = \\chi(-x - A) = \\chi(ux) = -\\chi(x)</span>. Next <span class="math">\\bar{v}^2 + A\\bar{v} + B = x^2 + Ax + B</span> so <span class="math">\\bar{\\epsilon} = \\chi(\\bar{v}^3 + A\\bar{v}^2 + B\\bar{v}) = -\\chi(x^3 + Ax^2 + Bx) = -1</span>. Consequently <span class="math">\\bar{x} = -\\bar{v} - A = x</span> and <span class="math">\\bar{y} = -\\bar{\\epsilon}\\sqrt{x^3 + Ax^2 + Bx} = \\sqrt{x^3 + Ax^2 + Bx} = y</span>.</p>

    <p class="text-gray-300">The remaining case is that <span class="math">y \\notin \\sqrt{\\mathbf{F}_q^2}</span>, i.e., <span class="math">y = -\\sqrt{x^3 + Ax^2 + Bx}</span>. Then <span class="math">x^2 = -(x + A) / (ux)</span> so <span class="math">1 + u\\bar{r}^2 = -A / x</span> so <span class="math">\\bar{v} = x</span>. Now <span class="math">\\bar{v}^3 + A\\bar{v}^2 + B\\bar{v} = x^3 + Ax^2 + Bx</span> so <span class="math">\\bar{\\epsilon} = 1</span>. Consequently <span class="math">\\bar{x} = \\bar{v} = x</span> and <span class="math">\\bar{y} = -\\bar{\\epsilon}\\sqrt{x^3 + Ax^2 + Bx} = -\\sqrt{x^3 + Ax^2 + Bx} = y</span>.</p>

    <p class="text-gray-300">In both cases we have <span class="math">\\bar{v}^2 + A\\bar{v} + B = x^2 + Ax + B \\neq 0</span> so <span class="math">A^2 u \\bar{r}^2 \\neq B(1 + u \\bar{r}^2)^2</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fix <span class="math">(x,y) \\in \\psi(R)</span>. We showed above that <span class="math">x \\neq -A</span>; that if <span class="math">y = 0</span> then <span class="math">x = 0</span>; and that <span class="math">-ux(x + A)</span> is a square. We also showed that under these conditions <span class="math">\\bar{r}</span> is defined and <span class="math">\\psi(\\bar{r}) = (x,y)</span>.</li>

    </ol>

    <h2 id="sec-34" class="text-2xl font-bold">5.4 Encoding as strings</h2>

    <p class="text-gray-300">THEOREM 8. In the situation of Definition 6, assume that <span class="math">q</span> is prime, that <span class="math">q \\equiv 1 \\pmod{4}</span>, and that <span class="math">A^2 - 4B</span> is not a square in <span class="math">\\mathbf{F}_q</span>. Define <span class="math">b = \\lfloor \\log_2 q \\rfloor</span>. Define <span class="math">\\sigma : \\{0,1\\}^b \\to \\mathbf{F}_q</span> by <span class="math">\\sigma(\\rho_0, \\rho_1, \\ldots, \\rho_{b-1}) = \\sum_l \\rho_i 2^i</span>. Define <span class="math">S = \\sigma^{-1}(\\{0,1,2,\\ldots, (q-1)/2\\})</span>. Define <span class="math">\\iota : S \\to E(\\mathbf{F}_q)</span> as follows: <span class="math">\\iota(\\rho) = \\psi(\\sigma(\\rho))</span>. Then <span class="math">\\#S = (q+1)/2</span>; <span class="math">\\iota</span> is an injective map from <span class="math">S</span> to <span class="math">E(\\mathbf{F}_q)</span>; and <span class="math">\\iota(S) = \\psi(\\mathbf{F}_q)</span>.</p>

    <p class="text-gray-300">PROOF. Note that <span class="math">R = \\mathbf{F}_q</span> by Theorem 5; i.e., <span class="math">\\psi</span> is defined on all of <span class="math">\\mathbf{F}_q</span>. The rest of the proof is identical to the proof of Theorem 4 with <span class="math">\\phi</span> replaced by <span class="math">\\psi</span>, <span class="math">\\tau</span> replaced by <span class="math">\\rho</span>, Theorem 1 replaced by Theorem 5, and Theorem 3 replaced by Theorem 7.</p>

    <h2 id="sec-35" class="text-2xl font-bold">5.5 Application of <span class="math">\\psi</span> to Curve25519</h2>

    <p class="text-gray-300">Curve25519 is the curve <span class="math">y^2 = x^3 + Ax^2 + Bx</span> over <span class="math">\\mathbf{F}_q</span> with <span class="math">q = 2^{255} - 19</span>, <span class="math">A = 486662</span>, and <span class="math">B = 1</span>. Here <span class="math">q \\equiv 1 \\pmod{4}</span> and <span class="math">A^2 - 4B</span> is a non-square in <span class="math">\\mathbf{F}_q</span>, so <span class="math">R = \\mathbf{F}_q</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We take <span class="math">u = 2</span>. We copy from [8] the following standard efficiently computable square-root function for <span class="math">\\mathbf{F}_q</span>. Given a square <span class="math">a \\in \\mathbf{F}_q</span> compute <span class="math">b = a^{(q + 3) / 8}</span>; note that <span class="math">q \\equiv 5 \\pmod{8}</span>, so <span class="math">(q + 3) / 8</span> is an integer. Then <span class="math">b^4 = a^2</span>, i.e., <span class="math">b^2 \\in \\{a, -a\\}</span>. Define <span class="math">\\sqrt{a}</span> as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> if </span>b^2 = a<span class="math"> and as </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\sqrt{-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> otherwise. Here </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> means </span>b<span class="math"> if </span>b \\in \\{0, 1, \\ldots, (q - 1) / 2\\}<span class="math">, otherwise </span>-b$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Computing <span class="math">\\iota</span> takes 1 square-root computation, 1 inversion, 1 computation of <span class="math">\\chi</span>, and a few multiplications. Note that the inversion and the square-root computation can be combined into one exponentiation, as in [8]. The computation of <span class="math">\\chi</span> can also be combined into the square-root computation as follows. First compute a power of <span class="math">v^3 + Av^2 + Bv</span> as above, obtaining a square root of <span class="math">v^3 + Av^2 + Bv</span> if <span class="math">v^3 + Av^2 + Bv</span> is a square. If the square of this power turns out to match <span class="math">v^3 + Av^2 + Bv</span> then <span class="math">\\epsilon = 1</span> and <span class="math">x = v</span>. Otherwise <span class="math">\\epsilon = -1</span>, <span class="math">x = v u r^2</span>, and <span class="math">x^3 + Ax^2 + Bx = u r^2 (v^3 + Av^2 + Bv)</span>; multiply the previous power by <span class="math">r</span> and by a precomputed power of <span class="math">u</span> to obtain a square root of <span class="math">x^3 + Ax^2 + Bx</span>.</p>

    <p class="text-gray-300">Similar comments apply to computing the inverse map. Checking for <span class="math">P \\in \\iota(S)</span> takes 1 squaring and a computation of <span class="math">\\chi</span> to obtain <span class="math">\\chi((x + A/2)^2 - A^2/4) = \\chi(x(x + A))</span>.</p>

    <p class="text-gray-300">This map and its inverse seem simplest to describe in Weierstrass coordinates, but maps to and from Edwards form, and other curve shapes, are also easily obtained.</p>

    <h2 id="sec-36" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Apfelbaum, J., and Dingledine, R. How governments have tried to block Tor, 2011. http://ftp.ccc.de/congress/28C3/mp4-h264-HQ/28c3-4800-en-how_governments_have_tried_to_block_tor_h264.mp4.</li>

      <li>[2] Apple. iOS security, 2012. http://images.apple.com/iphone/business/docs/iOS_Security_Oct12.pdf.</li>

      <li>[3] Bellaire, M., Desai, A., Jokipi, E., and Rogaway, P. A concrete security treatment of symmetric encryption. In FOCS (1997), IEEE Computer Society, pp. 394–403.</li>

      <li>[4] Bernstein, D. J. Current consensus on ECC, 2001. https://groups.google.com/forum/message/raw?msg=sci.crypt/mu_paShEUSw/m491pFnNbtAJ.</li>

      <li>[5] Bernstein, D. J. A software implementation of NIST P-224, 2001. http://cr.yp.to/talks.html#2001.10.29.</li>

      <li>[6] Bernstein, D. J. Curve25519: New Diffie-Hellman speed records. In Public Key Cryptography (2006), M. Yung, Y. Dodis, A. Kiayias, and T. Malkin, Eds., vol. 3958 of LNCS, Springer, pp. 207–228.</li>

      <li>[7] Bernstein, D. J., Birkner, P., Joye, M., Lange, T., and Peters, C. Twisted Edwards curves. In AFRICACRYPT (2008), S. Vaudenay, Ed., vol. 5023 of LNCS, Springer, pp. 389–405.</li>

      <li>[8] Bernstein, D. J., Duif, N., Lange, T., Schwabe, P., and Yang, B.-Y. High-speed high-security signatures. J. Cryptographic Engineering 2, 2 (2012), 77–89.</li>

      <li>[9] Bernstein, D. J., and Lange, T. Faster addition and doubling on elliptic curves. In ASIACRYPT (2007), K. Kurosawa, Ed., vol. 4833 of LNCS, Springer, pp. 29–50.</li>

      <li>[10] Bernstein, D. J., and Schwabe, P. NEON crypto. In CHES (2012), E. Prouff and P. Schaumont, Eds., vol. 7428 of LNCS, Springer, pp. 320–339.</li>

      <li>[11] Biehl, I., Meyer, B., and Müller, V. Differential fault attacks on elliptic curve cryptosystems. In CRYPTO (2000), M. Bellare, Ed., vol. 1880 of LNCS, Springer, pp. 131–146.</li>

      <li>[12] Boneh, D., and Franklin, M. K. Identity-based encryption from the Weil pairing. In CRYPTO (2001), J. Kilian, Ed., vol. 2139 of LNCS, Springer, pp. 213–229.</li>

      <li>[13] Boyd, C., Montague, P., and Nguyen, K. Q. Elliptic curve based password authenticated key exchange protocols. In ACISP (2001), V. Varadharajan and Y. Mu, Eds., vol. 2119 of LNCS, Springer, pp. 487–501.</li>

      <li>[14] Brainpool. ECC Brainpool standard curves and curve generation, v. 1.0, 2005. http://www.ecc-brainpool.org/download/Domain-parameters.pdf.</li>

      <li>[15] Brier, E., Cobon, J.-S., Icart, T., Madore, D., Randriam, H., and Tibouchi, M. Efficient indifferentiable hashing into ordinary elliptic curves. In CRYPTO (2010), T. Rabin, Ed., vol. 6223 of LNCS, Springer, pp. 237–254.</li>

      <li>[16] Brier, E., and Joye, M. Weierstraß elliptic curves and side-channel attacks. In Public Key Cryptography (2002), D. Naccache and P. Paillier, Eds., vol. 2274 of LNCS, Springer, pp. 335–345.</li>

      <li>[17] Costigan, N., and Schwabe, P. Fast elliptic-curve cryptography on the Cell Broadband Engine. In AFRICACRYPT (2009), B. Preneel, Ed., vol. 5580 of LNCS, Springer, pp. 368–385.</li>

      <li>[18] Diem, C. The GHS attack in odd characteristic. J. Ramanujan Mathematical Society 18 (2003), 1–32.</li>

      <li>[19] Dingledine, R., Mathewson, N., and Syverson, P. F. Tor: The second-generation onion router. In USENIX Security Symposium (2004), USENIX, pp. 303–320.</li>

      <li>[20] Farashahi, R. R. Hashing into Hessian curves. In AFRICACRYPT (2011), A. Nitaj and D. Pointcheval, Eds., vol. 6737 of LNCS, Springer, pp. 278–289.</li>

      <li>[21] Farashahi, R. R., Fouque, P.-A., Shparlinski, I., Tibouchi, M., and Voloch, J. F. Indifferentiable deterministic hashing to elliptic and hyperelliptic curves. Math. Comput. 82, 281 (2013).</li>

      <li>[22] Faugère, J.-C., Perret, L., Petit, C., and Renault, G. Improving the complexity of index calculus algorithms in elliptic curves over binary fields. In EUROCRYPT (2012), D. Pointcheval and T. Johansson, Eds., vol. 7237 of LNCS, Springer, pp. 27–44.</li>

      <li>[23] Fouque, P.-A., Joux, A., and Tibouchi, M. Injective encodings to elliptic curves. In ACISP (2013), C. Boyd and L. Simpson, Eds., vol. 7959 of LNCS, Springer, pp. 203–218.</li>

      <li>[24] Fouque, P.-A., Lercier, R., Réal, D., and Valette, F. Fault attack on elliptic curve Montgomery ladder implementation. In FDTC (2008), L. Breveglieri, S. Gueron, I. Koren, D. Naccache, and J.-P. Seifert, Eds., IEEE Computer Society, pp. 92–98.</li>

      <li>[25] Fouque, P.-A., and Tibouchi, M. Deterministic encoding and hashing to odd hyperelliptic curves. In Pairing (2010), M. Joye, A. Miyaji, and A. Otsuka, Eds., vol. 6487 of LNCS, Springer, pp. 265–277.</li>

      <li>[26] Fouque, P.-A., and Tibouchi, M. Estimating the size of the image of deterministic hash functions to elliptic curves. In LATINCRYPT (2010), M. Abdalla and P. S. L. M. Barreto, Eds., vol. 6212 of LNCS, Springer, pp. 81–91.</li>

      <li>[27] Fouque, P.-A., and Tibouchi, M. Indifferentiable hashing to Barreto-Naehrig curves. In LATINCRYPT (2012), A. Hevia and G. Neven, Eds., vol. 7533 of LNCS, Springer, pp. 1–17.</li>

      <li>[28] Frey, G. How to disguise an elliptic curve (Weil descent), 1998. http://www.cacr.math.uwaterloo.ca/conferences/1998/ecc98/slides.html.</li>

      <li>[29] Gaudry, P., and Thomé, E. The mpFq library and implementing curve-based key exchanges. In SPEED: software performance enhancement for encryption and decryption (2007), pp. 49–64.</li>

      <li>[30] Goldberg, I., Stebila, D., and Ustaoglu, B. Anonymity and one-way authentication in key exchange protocols. Des. Codes Cryptography 67, 2 (2013), 245–269.</li>

      <li>[31] Hink, H., Wong, K. K.-H., Carter, G., and Dawson, E. Twisted Edwards curves revisited. In ASIACRYPT (2008), J. Pieprzyk, Ed., vol. 5350 of LNCS, Springer, pp. 326–343.</li>

      <li>[32] Icart, T. How to hash into elliptic curves. In CRYPTO (2009), S. Halevi, Ed., vol. 5677 of LNCS, Springer, pp. 303–316.</li>

      <li>[33] Institute of Electrical and Electronics Engineers. P1363 Draft Standard Specifications for Public Key Cryptography. IEEE, 1999.</li>

      <li>[34] Izu, T., and Takagi, T. Exceptional procedure attack on elliptic curve cryptosystems. In Public Key Cryptography (2003), Y. Desmedt, Ed., vol. 2567 of LNCS, Springer, pp. 224–239.</li>

      <li>[35] Kaliski Jr., B. S. A pseudo-random bit generator based on elliptic logarithms. In CRYPTO (1986), A. M. Odlyzko, Ed., vol. 263 of LNCS, Springer, pp. 84–103.</li>

      <li>[36] Kaliski Jr., B. S. Elliptic Curves and Cryptography: A Pseudorandom Bit Generator and Other Tools. PhD thesis, MIT, 1988. MIT/LCS/TR-411.</li>

      <li>[37] Law, L. E., and Solinas, J. A. Suite B cryptographic suites for IPsec, 2011. https://tools.ietf.org/html/rfc6379.</li>

      <li>[38] Lidl, R., and Niederreiter, H. Finite Fields. Encyclopedia of Mathematics and its Applications. Cambridge University Press, 1997.</li>

      <li>[39] López, J., and Dahab, R. Fast multiplication on elliptic curves over GF(2^{60}) without precomputation. In CHES (1999), Ç. K. Koç and C. Paar, Eds., vol. 1717 of LNCS, Springer, pp. 316–327.</li>

      <li>[40] Möller, B. A public-key encryption scheme with pseudo-random ciphertexts. In Computer Security—ESORICS 2004, P. Samarati, P. Ryan, D. Gollmann, and R. Molva, Eds., vol. 3193 of LNCS. Springer Berlin Heidelberg, 2004, pp. 335–351.</li>

      <li>[41] Montgomery, P. L. Speeding the Pollard and elliptic curve methods of factorization. Math. Comp. 48, 177 (1987), 243–264.</li>

      <li>[42] Oliveira, T., López, J., Aranha, D. F., and Rodríguez-Henríquez, F. Lambda coordinates for binary elliptic curves. In CHES (2013), G. Bertoni and J.-S. Coron, Eds., vol. 8086 of LNCS, Springer, pp. 311–330.</li>

      <li>[43] Petit, C., and Quisquater, J.-J. On polynomial systems arising from a Weil descent. In ASIACRYPT (2012), X. Wang and K. Sako, Eds., vol. 7658 of LNCS, Springer, pp. 451–466.</li>

      <li>[44] Rogaway, P., and Shirington, T. A provable-security treatment of the key-wrap problem. In EUROCRYPT (2006), S. Vaudenay, Ed., vol. 4004 of LNCS, Springer, pp. 373–390.</li>

      <li>[45] Shallue, A., and van de Woestijne, C. Construction of rational points on elliptic curves over finite fields. In ANTS (2006), F. Hess, S. Pauli, and M. E. Pohst, Eds., vol. 4076 of LNCS, Springer, pp. 510–524.</li>

      <li>[46] Stein, W., et al. Sage Mathematics Software (Version 2.9). The Sage Development Team, 2013. http://www.sagemath.org.</li>

      <li>[47] Weinberg, Z., Wang, J., Yegneswaran, V., Briesemeister, L., Chaung, S., Wang, F., and Boneh, D. StegoTorus: a camouflage proxy for the Tor anonymity system. In ACM Conference on Computer and Communications Security (2012), T. Yu, G. Danezis, and V. D. Gligor, Eds., ACM, pp. 109–120.</li>

      <li>[48] Wustrow, E., Wolchok, S., Goldberg, I., and Halderman, J. A. Telex: Anticensorship in the network infrastructure. In USENIX Security Symposium (2011), USENIX Association.</li>

      <li>[49] Young, A. L., and Yung, M. Kleptography from standard assumptions and applications. In SCN (2010), J. A. Garay and R. D. Prisco, Eds., vol. 6280 of LNCS, Springer, pp. 271–290.</li>

    </ul>`;
---

<BaseLayout title="Elligator: Elliptic-curve points indistinguishable from unif... (2013/325)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/325
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
