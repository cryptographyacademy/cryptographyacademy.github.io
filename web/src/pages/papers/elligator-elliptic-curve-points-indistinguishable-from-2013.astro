---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/325';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Elligator: Elliptic-curve points indistinguishable from uniform random strings';
const AUTHORS_HTML = 'Daniel J.  Bernstein, Mike Hamburg, Anna Krasnova, Tanja Lange';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Censorship-circumvention tools are in an arms race against censors.
The censors study all traffic passing into and out of
their controlled sphere,
and try to disable censorship-circumvention tools
without completely shutting down the Internet.
Tools aim to shape their traffic patterns to match unblocked programs,
so that simple traffic profiling
cannot identify the tools within a reasonable number of traces;
the censors respond by deploying firewalls
with increasingly sophisticated deep-packet inspection.

Cryptography hides patterns in user data
but does not evade censorship
if the censor can recognize patterns in the cryptography itself.
In particular,
elliptic-curve cryptography
often transmits points on known elliptic curves,
and those points are easily distinguishable from uniform random strings of bits.

This paper introduces high-security high-speed elliptic-curve systems
in which elliptic-curve points are encoded so as to be indistinguishable
from uniform random strings.
At a lower level,
this paper introduces a new bijection
between strings and about half of all curve points;
this bijection is applicable to every odd-characteristic
elliptic curve with a point of order 2,
except for curves of j-invariant 1728.
This paper also presents guidelines to construct, and two examples of,
secure curves suitable for these encodings.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Censorship circumvention &middot; elliptic curves &middot; injective maps &middot; indistinguishable public keys</p>
    </section>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 ElGamal encryption</h3>

    <p class="text-gray-300">Assume u<sup>B</sup> and P<sup>B</sup> = uBP is a static key pair of Bob and that Bob has published &tau;<sup>B</sup> = &iota; &minus;1 (PB). Alice wants to send Bob a message M. To encrypt the message she performs the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>She generates a random integer r.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>She computes the point R = rP. If R /&isin; &iota;(S) she repeats from step 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>She computes &iota; &minus;1 (R) = &tau;R.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>She computes P<sup>B</sup> = &iota;(&tau;B).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>She computes the shared key value k = H(rPB).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>She encrypts message m using key k: c = Enck(m).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>She sends the tuple (&tau;R, c) as an encryption of m.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">To decrypt the received message, Bob:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>computes &iota;(&tau;R) = R,</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>computes the same shared key value: k = H(uBR), and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>decrypts the message: m = Deck(c).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">ElGamal encryption also appears in [23] as an application of an injective map between strings and curve points, but our application is completely different from the application in [23]. There is a critical difference in the underlying encryption methods: we use symmetric cryptography to encrypt the message m using a key derived from rPB, whereas [23] adds rP<sup>B</sup> to a curve point M that represents m. This is exactly where [23] uses an injective map, namely to encode the string m as a curve point M. Note, however, that this also (1) prevents [23] from encrypting long messages and (2) allows malleability, in violation of the basic security standards for public-key encryption. We instead use the standard &quot;KEM/DEM&quot; structure to provide secure publickey encryption, and as a consequence do not need to encode strings as curve points. We use an injective map for a completely different reason: we encode curve points as strings, preventing those points from being recognized by censors.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Short-term Diffie&ndash;Hellman keys</h3>

    <p class="text-gray-300">In this protocol, Alice and Bob agree on a shared secret without using long-term keys. This protocol is important as a way to provide forward secrecy. Of course, this provides no authentication, but authentication can be added as a subsequent layer.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Alice and Bob generate short-term keys as follows:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Generate a random integer r.</li>
      <li>(b) Compute point R = rP. If R /&isin; &iota;(S) repeat from step 1a.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Alice sends &micro;<sup>A</sup> = &iota; &minus;1 (RA) to Bob; Bob sends &micro;<sup>B</sup> = &iota; &minus;1 (RB) to Alice.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Alice decodes R<sup>B</sup> = &iota;(&micro;B); Bob decodes R<sup>A</sup> = &iota;(&micro;A).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Alice computes the shared key value k = H(rARB); Bob computes the same k as H(rBRA).</li>
    </ol></li>
    </ul>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Schnorr signatures</h3>

    <p class="text-gray-300">Assume that u<sup>B</sup> and P<sup>B</sup> = uBP are respectively private and public keys of Bob, where P<sup>B</sup> &isin; &iota;(S) and Bob has published &tau;<sup>B</sup> = &iota; &minus;1 (PB). To sign a message m, Bob performs the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose a random integer r.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute R = rP. If R /&isin; &iota;(S), repeat from step 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute &tau; = &iota; &minus;1 (R).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute h = H(&tau; ||&tau;B||m).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute s = r + hu<sup>B</sup> (mod n).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The signature is the tuple &psi; = (&tau;, s).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The integer s must be encoded so as to be indistinguishable from uniform; see Section 2.6.</p>

    <p class="text-gray-300">To verify the signature (&tau;, s), Alice performs the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute P<sup>B</sup> = &iota;(&tau;B).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute R = &iota;(&tau; ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute h = H(&tau; ||&tau;B||m).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compare R + hP<sup>B</sup> and sP. If they are equal, accept. Otherwise, reject.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Schnorr's original signature system actually sent (h, s). We follow &quot;EdDSA&quot; from [8] in sending an encoding of (R, s); security is the same, since one can reconstruct (h, s) from (R, s) and vice versa. The advantage of (R, s) is that it allows batching, making signature verification about twice as fast, as explained in [8]. Our use of &iota; makes this signature indistinguishable from a uniform random string.</p>

    <p class="text-gray-300">We also follow EdDSA in including the public key &tau;<sup>B</sup> in the hash. Robert Ransom has pointed out that if the public key is omitted from the hash then an attacker who does not know it can calculate it by first computing h and then computing (sP &minus; R)/h, and as a consequence can see that two signatures come from the same public key. Ransom has also suggested a different way of hiding signatures from someone who does not know &tau;B: namely, encrypting the signatures with a secret-key cipher keyed by a hash of &tau;B. Of course, indistinguishability is unachievable against an attacker who does know &tau;B: the attacker can simply verify the signature.</p>

    <p class="text-gray-300">We encode R as &tau; both for transmission and for input to H. We could safely switch to a different encoding for input to H. In particular, we could use the same encoding used in EdDSA. This would make our signatures compatible with EdDSA signatures: anyone could convert an EdDSA signature into a signature of our form and vice versa.</p>

      <h3 id="sec-2.6" class="text-xl font-semibold mt-8">2.6 Detecting differences from uniform</h3>

    <p class="text-gray-300">These protocols transmit uniform random elements of S. Usually S is not the set of all b-bit strings, so uniform random elements of S are not exactly uniform random b-bit strings. This is not a security problem if #S is very close to 2 b ; we now analyze quantitatively what &quot;very close&quot; means.</p>

    <p class="text-gray-300">Consider a channel that normally sends k independent uniform random b-bit strings. A user modifies the channel to instead transmit k independent uniform random elements of S. The censor's goal is to take action against the modified channel without taking action against the original channel.</p>

    <p class="text-gray-300">The obvious strategy for the censor is to take action if and only if all of the b-bit strings are elements of S. This has no false negatives, but it produces a false positive whenever k independent uniform random b-bit strings happen to all be elements of S. If #S = 2<sup>b</sup> &minus; &delta; then a false positive occurs with probability (#S/2 b ) <sup>k</sup> = (1 &minus; &delta;/2 b ) <sup>k</sup> &asymp; exp(&minus;k&delta;/2 b ). This strategy maximizes the difference in action probability between the original and modified channels; hence S k is indistinguishable from ({0, 1} b ) <sup>k</sup> when k&delta;/2 b is small.</p>

    <p class="text-gray-300">Consider, for example, the NIST P-256 set S = 0, 1, 2, . . . , 2 <sup>256</sup> &minus; 2 <sup>224</sup> + 2<sup>192</sup> + 2<sup>96</sup> &minus; 2 , with b = 256. Here &delta; &asymp; 2 <sup>224</sup>. If the censor sees k = 2<sup>35</sup> sessions then k&delta;/2 <sup>b</sup> &asymp; 8 so the censor will take action for the original channel with probability only about exp(&minus;8) &asymp; 0.000335. This may be an acceptable level of collateral damage.</p>

    <p class="text-gray-300">As a second example illustrating the importance of the ratio k&delta;/2 b , consider a set S of size 2<sup>256</sup> &minus; &delta; where &delta; &le; 2 160 . This time a censor seeing k &le; 2 <sup>64</sup> sessions has k&delta;/2 <sup>b</sup> &le; 2 &minus;32 so the probability is larger than 0.99999999; i.e., the censor will take action against practically every channel.</p>

    <p class="text-gray-300">The encodings that we consider for elements of E(Fq) typically have #S = (q + 1)/2. In each of our recommended examples, #S is between 2<sup>b</sup>&minus;2 b/2 and 2<sup>b</sup> , so k&delta;/2 <sup>b</sup> &le; k/2 b/2 . The probability difference is therefore negligible until k, the number of strings transmitted, grows to a noticeable fraction of 2b/<sup>2</sup> . This cannot be a concern when E(Fq) is chosen to resist standard discrete-logarithm attacks: those attacks take time only about 2b/<sup>2</sup> .</p>

    <p class="text-gray-300">We also encode integers modulo n = #E(Fq) as strings in Section 2.5. By Hasse's theorem, <sup>n</sup> is within 2&radic;<sup>q</sup> of <sup>q</sup>+ 1, so if q is very close to 2<sup>b</sup>+1 then n is also forced to be very close to 2<sup>b</sup>+1. Note that taking q slightly below 2<sup>b</sup>+1 does not force n to be below 2<sup>b</sup>+1; for n &gt; 2 <sup>b</sup>+1 we still use a (b+ 1)-bit encoding, restarting the protocol in Section 2.5 in the extremely unlikely case that an integer is 2<sup>b</sup>+1 or larger.</p>

    <p class="text-gray-300">Censors can try replacing random-looking strings by other strings (possibly strings outside S) to see whether this has any visible effect. Presumably this replacement will disrupt communication, but protocol designers and implementors must take care to ensure that this replacement does not allow the censor to detect communication.</p>

    <p class="text-gray-300">We briefly point out an attack against the passwordauthenticated key-exchange protocol of [13]; this attack is not in the censorship context, but it illustrates both the value of avoiding twists and the difficulty of protecting against active attacks. In the protocol of [13], Alice sends an encryption (using a shared password as a secret key) of either a point on a curve or a point on the twist of the curve; indistinguishability is important here for the ciphertext to avoid leaking information. Bob sends back two points, one on the curve and one on the twist; information is carried by the point on the same curve used by Alice, while the other point is random. Our attack is to actively rerandomize one of the two points sent by Bob. If this point is on the same curve then Alice aborts; if this point is not on the same curve then Alice does not notice and communication continues. This information leak allows the attacker to exclude half of all possible passwords, and repeating the attack allows the attacker to quickly find the right password.</p>

    <p class="text-gray-300">Section 2 needs an injective map &iota; from a large set S of strings to E(Fq). Elligator 1 is one choice of &iota;; Elligator 2, introduced in Section 5, is another choice of &iota;. This section presents the mathematical details of Elligator 1: the construction of &iota;, how to compute &iota;, how to test whether a curve point is in the image of &iota;, and how to invert &iota; on curve points in the image. To help the reader visualize the mathematical structure of &iota; we include a picture as Figure 1.</p>

    <p class="text-gray-300">We impose certain requirements on q and E for Elligator 1: we consider only primes q; we require q to be congruent to 3 modulo 4; we require E to be a complete Edwards curve; and we impose an extra algebraic requirement (c = 2/s<sup>2</sup> in Theorem 1) that allows only half of all complete Edwards curves. Approximately 1/16 of all isomorphism classes of elliptic curves over all finite fields satisfy these requirements. (Asymptotically 100% of all finite fields, ordered by size, are prime fields; 50% of those primes are congruent to 3 modulo 4; 25% of elliptic curves over those fields are complete Edwards curves; 50% of those satisfy the extra algebraic requirement.) See Section 4 for specific choices of q and E.</p>

    <p class="text-gray-300">The heart of &iota; is a function &phi; : F<sup>q</sup> &rarr; E(Fq) defined in Theorem 1 and Definition 2. This function satisfies &phi;(t) = &phi;(&minus;t) for each t &isin; F<sup>q</sup> but has no other collisions (see Theorem 3), so its restriction to {0, 1, 2, . . . ,(q &minus; 1)/2} is injective. Theorem 4 simply defines S as {0, 1, 2, . . . ,(q &minus; 1)/2} represented in little-endian form as b-bit strings, where b = blog<sup>2</sup> qc, and defines &iota; as the corresponding representation of &phi;. For indistinguishability we add the requirement that (q + 1)/2 be extremely close to 2<sup>b</sup> .</p>

    <p class="text-gray-300">As mentioned in Section 1, this function &phi; was introduced by Fouque, Joux, and Tibouchi in [23]. Our main contributions in this section are a much more concise definition of &phi;; much more direct proofs of the relevant properties of &phi;; a simple method to invert &phi;; and a simple test for whether a curve point is in the image of &phi;.</p>

    <p class="text-gray-300">The function &minus;&phi; has the same useful properties as &phi;. Our choice of sign is not the same as the choice in [23]: in the notation below, the ratio is &chi;(c), i.e., &chi;(2). This choice of sign slightly simplifies our formulas for the forward and inverse maps, although it is not the main simplification compared to [23]. We also comment that &phi;(t) = &minus;&phi;(1/t) for t 6= 0.</p>

    <p class="text-gray-300">Computing &iota; in a sensible way is almost as fast as traditional point decompression, not a serious bottleneck compared to scalar multiplication. Inverting &iota; is slightly slower, but testing whether a curve point is in the image of &iota; is very fast. See Section 3.5 for further performance analysis.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Squares, square roots, and &chi;</h3>

    <p class="text-gray-300">Fix a prime power q &equiv; 3 (mod 4). In defining &iota; we consider only primes q for simplicity (so that 0, 1, 2, . . . ,(q&minus;1)/2 are distinct field elements) but our &phi; theorems also apply to prime powers.</p>

    <p class="text-gray-300">Define &chi; : F<sup>q</sup> &rarr; F<sup>q</sup> by &chi;(a) = a (q&minus;1)/2 . If a is a non-zero square then &chi;(a) = 1; if a is a non-square then &chi;(a) = &minus;1; if a = 0 then &chi;(a) = 0. Note that (q &minus; 1)/2 is odd since q &equiv; 3 (mod 4), so &chi;(&minus;1) = &minus;1, so &minus;1 is not a square. More</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: The structure of our encoding function &iota; &minus;1 , a bijection from a large subset of E(Fq) to a large set S of b-bit strings. The elliptic curve E is required to be a complete Edwards curve, shown on the left together with a sample element P = (x, y) of E(Fq). A sample b-bit output is shown on the right. See Theorems 1, 3, and 4 and Definition 2 for further details regarding the function in the middle.</p>

    <p class="text-gray-300">generally, &chi;(&chi;(a)) = &chi;(a). There are several easy ways to manipulate &chi; arguments: for example, &chi;(ab) = &chi;(a)&chi;(b), &chi;(1/a) = &chi;(a) = 1/&chi;(a) if a 6= 0, and &chi;(a 2 ) = 1 if a 6= 0.</p>

    <p class="text-gray-300">If a is a square then a (q+1)/4 is a square root of a: its square is a (q+1)/<sup>2</sup> = &chi;(a)a = a. More precisely, a (q+1)/4 is the principal square root of a: the unique square root that is a square. Any square root b of a satisfies b = &chi;(b)a (q+1)/4 .</p>

    <p class="text-gray-300">The function &chi; is called a quadratic character. See [38] for further background on finite fields.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 The map</h3>

    <p class="text-gray-300">Theorem 1. Let q be a prime power congruent to 3 modulo 4. Let s be a nonzero element of F<sup>q</sup> with (s <sup>2</sup>&minus;2)(s <sup>2</sup>+2) 6= 0. Define c = 2/s<sup>2</sup> . Then c(c &minus; 1)(c + 1) 6= 0.</p>

    <p class="text-gray-300">Define r = c + 1/c and d = &minus;(c + 1)<sup>2</sup> /(c &minus; 1)<sup>2</sup> . Then r 6= 0, and d is not a square.</p>

    <p class="text-gray-300">The following elements of F<sup>q</sup> are defined for each t &isin; F<sup>q</sup> \\ {&plusmn;1}:</p>

    <p class="text-gray-300"><span class="math">$u = (1 - t)/(1 + t),</span>$</p>

    <p class="text-gray-300"><span class="math">$v = u^{5} + (r^{2} - 2)u^{3} + u,</span>$</p>

    <p class="text-gray-300"><span class="math">$X = \\chi(v)u,</span>$</p>

    <p class="text-gray-300"><span class="math">$Y = (\\chi(v)v)^{(q+1)/4}\\chi(v)\\chi(u^{2} + 1/c^{2}),</span>$</p>

    <p class="text-gray-300"><span class="math">$x = (c - 1)sX(1 + X)/Y,</span>$</p>

    <p class="text-gray-300"><span class="math">$y = (rX - (1 + X)^{2})/(rX + (1 + X)^{2})</span>$</p>

    <p class="text-gray-300">Furthermore x <sup>2</sup> + y <sup>2</sup> = 1 + dx<sup>2</sup> y 2 ; uvXY x(y + 1) 6= 0; and Y <sup>2</sup> = X <sup>5</sup> + (r <sup>2</sup> &minus; 2)X <sup>3</sup> + X.</p>

    <p class="text-gray-300">).</p>

    <p class="text-gray-300">Proof. c(c &minus; 1)(c + 1) 6= 0: By definition c = 2/s<sup>2</sup> so c 6= 0. By hypothesis s 2 6= 2 and s 2 6= &minus;2 so c 6= 1 and c 6= &minus;1.</p>

    <p class="text-gray-300">r 6= 0: If r = 0 then c = &minus;1/c so c <sup>2</sup> = &minus;1, contradiction. d is not a square: Otherwise &minus;1 = d(c &minus; 1)<sup>2</sup> /(c + 1)<sup>2</sup> is a square, contradiction.</p>

    <p class="text-gray-300">u is defined and u 6= 0: By hypothesis 1 + t 6= 0 and 1 &minus; t 6= 0.</p>

    <p class="text-gray-300">v 6= 0: r <sup>2</sup> &minus;2 = c <sup>2</sup> + 1/c<sup>2</sup> so v = u(u <sup>2</sup> +c 2 )(u <sup>2</sup> + 1/c<sup>2</sup> ). If v = 0 then there are three possibilities: u = 0, contradiction; or u <sup>2</sup>+c <sup>2</sup> = 0 so &minus;1 = (u/c) 2 , contradiction; or u <sup>2</sup>+1/c<sup>2</sup> = 0 so &minus;1 = (uc) 2 , contradiction.</p>

    <p class="text-gray-300">XY 6= 0, so x is defined: As above u <sup>2</sup> + 1/c<sup>2</sup> 6= 0 so all factors in X and Y are nonzero.</p>

    <p class="text-gray-300">1 + X 6= 0, so x 6= 0: If X = &minus;1 then u = &minus;&chi;(v) so v = &minus;&chi;(v)(1 + r <sup>2</sup> &minus; 2 + 1) = &minus;&chi;(v)r 2 so &chi;(v) = &minus;&chi;(v), contradiction.</p>

    <p class="text-gray-300">(X, Y ) satisfies Y <sup>2</sup> = X<sup>5</sup> + (r <sup>2</sup> &minus; 2)X<sup>3</sup> + X: X = &chi;(v)u so X <sup>5</sup> + (r <sup>2</sup> &minus;2)X <sup>3</sup> +X = &chi;(v)(u <sup>5</sup> + (r <sup>2</sup> &minus;2)u <sup>3</sup> +u) = &chi;(v)v. Also &chi;(v)v is a square so (&chi;(v)v) (q+1)/<sup>2</sup> = &chi;(v)v so Y <sup>2</sup> = &chi;(v)v.</p>

    <p class="text-gray-300">rX+(1+X) <sup>2</sup> 6= 0, so y is defined: If rX = &minus;(1+X) 2 then (r <sup>2</sup> + 4r)X <sup>2</sup> = X <sup>4</sup> &minus; 2X <sup>2</sup> + 1 so</p>

    <p class="text-gray-300"><span class="math">$Y^{2} = X(X^{4} + (r^{2} - 2)X^{2} + 1) = X^{3}(2r^{2} + 4r)</span>$
<span class="math">$= rX \\cdot X^{2}(2r + 4) = -(1 + X)^{2}X^{2}(s + 2/s)^{2}</span>$</p>

    <p class="text-gray-300">so &minus;1 is a square, contradiction.</p>

    <p class="text-gray-300">y + 1 6= 0: If y = &minus;1 then (rX &minus; (1 + X) 2 )/(rX + (1 + X) 2 ) = &minus;1 so rX &minus;(1+X) <sup>2</sup> = &minus;(rX + (1+X) 2 ) so rX = 0, contradiction.</p>

    <p class="text-gray-300">x <sup>2</sup> + y <sup>2</sup> = 1 + dx<sup>2</sup>y 2 : First (c &minus;1)<sup>2</sup> s <sup>2</sup> = (c &minus;1)<sup>2</sup> (2/c) = 2(r &minus; 2) so</p>

    <p class="text-gray-300"><span class="math">$Y^{2}(1-x^{2}) = Y^{2} - (c-1)^{2}s^{2}X^{2}(1+X)^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$= X^{5} + (r^{2}-2)X^{3} + X - 2(r-2)X^{2}(1+X)^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$= X(rX - (1+X)^{2})^{2}.</span>$</p>

    <p class="text-gray-300">Similarly &minus;d = (c + 2 + 1/c)/(c &minus; 2 + 1/c) = (r + 2)/(r &minus; 2) so &minus;d(c &minus; 1)<sup>2</sup> s <sup>2</sup> = 2(r + 2) so</p>

    <p class="text-gray-300"><span class="math">$Y^{2}(1 - dx^{2}) = Y^{2} - d(c - 1)^{2}s^{2}X^{2}(1 + X)^{2}</span>$
<span class="math">$= X^{5} + (r^{2} - 2)X^{3} + X + 2(r + 2)X^{2}(1 + X)^{2}</span>$
<span class="math">$= X(rX + (1 + X)^{2})^{2}.</span>$</p>

    <p class="text-gray-300">Note that Y 2 (1&minus;dx<sup>2</sup> ) 6= 0, and divide: (1&minus;x 2 )/(1&minus;dx<sup>2</sup> ) = (rX &minus; (1 + X) 2 ) 2 /(rX + (1 + X) 2 ) <sup>2</sup> = y 2 ; i.e., x <sup>2</sup> + y <sup>2</sup> = 1 + dx<sup>2</sup> y 2 .</p>

    <p class="text-gray-300">Definition 2. In the situation of Theorem 1, the decoding function for the complete Edwards curve E : x <sup>2</sup> +y <sup>2</sup> = 1 +dx<sup>2</sup> y 2 is the function &phi; : F<sup>q</sup> &rarr; E(Fq) defined as follows: &phi;(&plusmn;1) = (0, 1); if t /&isin; {&plusmn;1} then &phi;(t) = (x, y).</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Inverting the map</h3>

    <p class="text-gray-300">Theorem 3. In the situation of Definition 2:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If t &isin; F<sup>q</sup> then the set of preimages of &phi;(t) under &phi; is {t, &minus;t}.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&phi;(Fq) is the set of (x, y) &isin; E(Fq) such that</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>y + 1 6= 0;</li>
      <li>(1+&eta;r) <sup>2</sup> &minus;1 is a square, where &eta; = y &minus; 1 2(<sup>y</sup> + 1); and</li>
      <li>if &eta;r = &minus;2 then x = 2s(c &minus; 1)&chi;(c)/r.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If (x, y) &isin; &phi;(Fq) then the following elements X, z, &macr; u, &macr; t&macr; of F<sup>q</sup> are defined and &phi;(t&macr;) = (x, y):</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\bar{X} &amp;= -(1 + \\eta r) + ((1 + \\eta r)^2 - 1)^{(q+1)/4}, \\\\ z &amp;= \\chi \\left( (c - 1) s \\bar{X} (1 + \\bar{X}) x (\\bar{X}^2 + 1/c^2) \\right), \\\\ \\bar{u} &amp;= z \\bar{X}, \\\\ \\bar{t} &amp;= (1 - \\bar{u})/(1 + \\bar{u}). \\end{split}</span>$</p>

    <p class="text-gray-300">Proof. Statement 1 of the theorem has two parts: a forward statement &phi;(t) = &phi;(&minus;t), and a reverse statement that there are no other preimages. Statement 2 also has two parts: a forward statement that any (x, y) &isin; &phi;(Fq) satisfies certain conditions, and a reverse statement that any element of E(Fq) satisfying those conditions is in &phi;(Fq). We organize the proof as (A) forward 1; (B) 3, forward 2, and reverse 1; (C) reverse 2.</p>

    <p class="text-gray-300">A. Fix t &isin; Fq. We now show that &phi;(t) = &phi;(&minus;t). This is the forward part of statement 1 in the theorem.</p>

    <p class="text-gray-300">If  <span class="math">t \\in \\{\\pm 1\\}</span>  then  <span class="math">\\phi(t) = (0,1) = \\phi(-t)</span>  by definition. Assume from now on that  <span class="math">t \\notin \\{\\pm 1\\}</span> .</p>

    <p class="text-gray-300">Define u, v, X, Y, x, y from t as in Theorem 1. Then  <span class="math">\\phi(t) = (x, y)</span>  by definition.</p>

    <p class="text-gray-300">Put t' = -t, and define u', v', X', Y', x', y' the same way from t'. Then  <span class="math">\\phi(t&#x27;) = (x&#x27;, y&#x27;)</span> . The proof strategy is to compare successively u' to u, v' to v, etc., concluding that x' = x and y' = y.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u&#x27;} = \\frac{(1-t&#x27;)}{(1+t&#x27;)} = \\frac{(1+t)}{(1-t)} = \\frac{1}{u}.</span>   <span class="math">\\mathbf{v&#x27;} = \\frac{u&#x27;^5}{(1+t&#x27;)^5} + \\frac{1}{(r^2-2)u&#x27;^3} + \\frac{1}{u&#x27;} = \\frac{1}{u^5} + \\frac{1}{(r^2-2)\\frac{1}{u^3}} + \\frac{1}{u}, \\text{ so }</span>   <span class="math">v&#x27;u^6 = u + (r^2-2)u^3 + u^5 = v; \\text{ i.e., } v&#x27; = v/u^6. \\text{ Note that }</span>   <span class="math">\\chi(v&#x27;) = \\chi(v) \\text{ since } \\chi(u^6) = 1.</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{X&#x27;} = \\chi(v&#x27;)u&#x27; = \\chi(v)/u = 1/(\\chi(v)u) = 1/X</span>  since  <span class="math">\\chi(v) = 1/\\chi(v)</span> .</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{y&#x27;} = \\frac{rX&#x27; - (1+X&#x27;)^2}{rX&#x27; + (1+X&#x27;)^2} = \\frac{r\\frac{1}{X} - (1+\\frac{1}{X})^2}{r\\frac{1}{X} + (1+\\frac{1}{X})^2} = \\frac{rX - (X+1)^2}{rX + (X+1)^2} = y.</span>$</p>

    <p class="text-gray-300"><span class="math">Y&#x27; = (\\chi(v&#x27;)v&#x27;)^{(q+1)/4}\\chi(v&#x27;)\\chi(u&#x27;^2 + 1/c^2)</span> . This takes the most work; the first and third factors each need careful analyses. The second factor is easy:  <span class="math">\\chi(v&#x27;) = \\chi(v)</span>  as above.</p>

    <p class="text-gray-300">First factor:  <span class="math">\\chi(v&#x27;)v&#x27; = \\chi(v)v/u^6</span> . Note that the product  <span class="math">\\chi(u)u^3</span>  is a square and is therefore the principal square root of  <span class="math">u^6</span> ; i.e.,  <span class="math">(u^6)^{(q+1)/4} = \\chi(u)u^3</span> . Hence  <span class="math">(\\chi(v&#x27;)v&#x27;)^{(q+1)/4} = (\\chi(v)v/u^6)^{(q+1)/4} = (\\chi(v)v)^{(q+1)/4}\\chi(u)/u^3</span> .</p>

    <p class="text-gray-300">Third factor: Recall that  <span class="math">v = u(u^2 + c^2)(u^2 + 1/c^2)</span>  and that  <span class="math">\\chi(a) = \\chi(ab^2)</span>  for any  <span class="math">b \\neq 0</span> . Thus</p>

    <p class="text-gray-300"><span class="math">$\\chi(u&#x27;^2 + 1/c^2) = \\chi(c^2 u^4 (u&#x27;^2 + 1/c^2)(u^2 + 1/c^2)^2)</span>$
<span class="math">$= \\chi(u^2 (c^2 + u^2)(u^2 + 1/c^2)^2)</span>$
<span class="math">$= \\chi(uv(u^2 + 1/c^2)).</span>$</p>

    <p class="text-gray-300">Now multiply to obtain  <span class="math">Y&#x27; = Y\\chi(u)\\chi(uv)/u^3 = Y/(\\chi(v)u)^3 = Y/X^3</span> . Finally</p>

    <p class="text-gray-300"><span class="math">$x&#x27; = (c-1)sX&#x27;(1+X&#x27;)/Y&#x27; = (c-1)s\\frac{1}{X}\\left(1+\\frac{1}{X}\\right) / \\frac{Y}{X^3}</span>$</p>

    <p class="text-gray-300">=  <span class="math">(c-1)sX(1+X)/Y = x</span> .</p>

    <p class="text-gray-300">Hence  <span class="math">\\phi(-t) = (x&#x27;, y&#x27;) = (x, y) = \\phi(t)</span>  as claimed.</p>

    <p class="text-gray-300"><strong>B.</strong> Fix  <span class="math">t \\in \\mathbf{F}_q</span> , and define  <span class="math">(x,y) = \\phi(t)</span> . We show that  <span class="math">\\bar{X}, z, \\bar{u}, \\bar{t}</span>  in the theorem are defined and that  <span class="math">\\bar{t} \\in \\{t, -t\\}</span> , so  <span class="math">\\phi(\\bar{t}) = (x,y)</span> ; this is statement 3 in the theorem. We also show the forward part of statement 2: namely,  <span class="math">y+1 \\neq 0</span> ;  <span class="math">(1+\\eta r)^2-1</span>  is a square, where  <span class="math">\\eta=(y-1)/(2(y+1))</span> ; and if  <span class="math">\\eta r=-2</span>  then  <span class="math">x=2s(c-1)\\chi(c)/r</span> . We also show the reverse part of statement 1: there are no preimages of  <span class="math">\\phi(t)</span>  other than t and -t.</p>

    <p class="text-gray-300">The definition of  <span class="math">\\phi</span>  has two cases: if  <span class="math">t \\in \\{1, -1\\}</span>  then (x, y) = (0, 1); if  <span class="math">t \\notin \\{1, -1\\}</span>  then u, v, X, Y, x, y are defined in Theorem 1. Note that in the second case  <span class="math">x \\neq 0</span>  by Theorem 1, so in particular t is not a preimage of (0, 1).</p>

    <p class="text-gray-300">In the first case  <span class="math">y+1=2\\neq 0</span> ;  <span class="math">\\eta=0</span> ;  <span class="math">(1+\\eta r)^2-1=0</span>  is a square;  <span class="math">\\bar{X}=-1</span> ; z=0;  <span class="math">\\bar{u}=0</span> ; and  <span class="math">\\bar{t}=1\\in\\{t,-t\\}</span> . As noted above, 1 and -1 are the only preimages of (0,1).</p>

    <p class="text-gray-300">What remains is the second case. Here  <span class="math">y+1 \\neq 0</span>  by Theorem 1. The equation  <span class="math">y = (rX - (1+X)^2)/(rX + (1+X)^2)</span>  implies  <span class="math">X^2 + (2+r(y-1)/(y+1))X + 1 = 0</span> , i.e.,  <span class="math">X^2 + 2(1+\\eta r)X + 1 = 0</span> . Note that this forces the discriminant  <span class="math">4(1+\\eta r)^2 - 4</span>  to be a square; i.e.,  <span class="math">(1+\\eta r)^2 - 1</span>  is a square. Divide by X to see that  <span class="math">X + 1/X = -2(1+\\eta r)</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\eta r = -2</span>  then  <span class="math">(X - 1)^2 = 0</span>  so X = 1 so  <span class="math">u \\in \\{\\pm 1\\}</span> ; the case u = -1 forces 1 - t = -(1 + t), contradiction, so u = 1 and t = 0; so  <span class="math">v = r^2</span> , so  <span class="math">Y = (r^2)^{(q+1)/4}\\chi(1 + 1/c^2) = \\chi(r)r\\chi(r/c) = r\\chi(c)</span> , so  <span class="math">x = 2(c - 1)s\\chi(c)/r</span>  as claimed; also note for future reference that y = (r - 4)/(r + 4), i.e.,  <span class="math">\\phi(0) = (2(c - 1)s\\chi(c)/r, (r - 4)/(r + 4))</span> .</p>

    <p class="text-gray-300">Define t' = -t, and define u', v', X', Y', x', y' as in Part A of this proof. Then X' = 1/X, so  <span class="math">X + X&#x27; = -2(1 + \\eta r)</span> .</p>

    <p class="text-gray-300">By construction  <span class="math">1+\\eta r+\\bar{X}</span>  is a square root of  <span class="math">(1+\\eta r)^2-1</span> ; i.e.,  <span class="math">\\bar{X}^2+2(1+\\eta r)\\bar{X}+1=0</span> . Now  <span class="math">(\\bar{X}-X)(\\bar{X}-X&#x27;)=\\bar{X}^2-(X+X&#x27;)\\bar{X}+XX&#x27;=\\bar{X}^2+2(1+\\eta r)\\bar{X}+1=0</span>  so  <span class="math">\\bar{X}=X</span>  or  <span class="math">\\bar{X}=X&#x27;</span> . This forces  <span class="math">\\bar{u}=u</span>  or  <span class="math">\\bar{u}=u&#x27;</span> , since the definition of z turns out to match  <span class="math">\\chi(v)</span>  and  <span class="math">\\chi(v&#x27;)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\bar{X} = X</span>  then  <span class="math">(c-1)s\\bar{X}(1+\\bar{X}) = xY</span>  so  <span class="math">z = \\chi(x^2Y(X^2+1/c^2)) = \\chi(Y)\\chi(X^2+1/c^2)</span> . Note that  <span class="math">(\\chi(v)v)^{(q+1)/4}</span>  is a square and  <span class="math">\\chi(u^2+1/c^2) = \\chi(X^2+1/c^2)</span> , so  <span class="math">\\chi(Y) = \\chi(v)\\chi(X^2+1/c^2)</span> , so  <span class="math">z = \\chi(v)</span> , so  <span class="math">\\bar{u} = \\chi(v)X = u</span> , so  <span class="math">\\bar{t} = t</span> .</li>
      <li>If  <span class="math">\\bar{X}=X&#x27;</span>  then similarly  <span class="math">z=\\chi(v&#x27;), \\ \\bar{u}=u&#x27;, \\ {\\rm and} \\ \\bar{t}=t&#x27;=-t.</span></li>
    </ul>

    <p class="text-gray-300">To summarize,  <span class="math">\\bar{t} \\in \\{t, -t\\}</span> , so  <span class="math">\\phi(\\bar{t}) = (x, y)</span> .</p>

    <p class="text-gray-300">The same logic also shows that there are no preimages p of (x,y) except for t and -t. Indeed, if  <span class="math">(x,y)=\\phi(p)</span>  then substituting p for t in the same proof shows that  <span class="math">\\bar{t}\\in\\{p,-p\\}</span> , so  <span class="math">p\\in\\{\\bar{t},-\\bar{t}\\}=\\{t,-t\\}</span> .</p>

    <p class="text-gray-300"><strong>C.</strong> Fix  <span class="math">(x,y) \\in E(\\mathbf{F}_q)</span> . Assume that  <span class="math">y+1 \\neq 0</span> ; that  <span class="math">(1+\\eta r)^2-1</span>  is a square, where  <span class="math">\\eta=(y-1)/(2(y+1))</span> ; and that if  <span class="math">\\eta r=-2</span>  then  <span class="math">x=2s(c-1)\\chi(c)/r</span> . We now show that  <span class="math">(x,y) \\in \\phi(\\mathbf{F}_q)</span> . This is the reverse part of statement 2 of the theorem.</p>

    <p class="text-gray-300">If x=0 then  <span class="math">(x,y)=(0,\\pm 1)</span>  from the curve equation; but  <span class="math">y+1\\neq 0</span> , so  <span class="math">(x,y)=(0,1)=\\phi(1)\\in\\phi(\\mathbf{F}_q)</span>  as claimed. Assume from now on that  <span class="math">x\\neq 0</span> .</p>

    <p class="text-gray-300">If y=1 then x=0 from the curve equation, contradiction. Hence  <span class="math">y\\neq 1</span> ; i.e.,  <span class="math">\\eta\\neq 0</span> .</p>

    <p class="text-gray-300">Define  <span class="math">X=-(1+\\eta r)+((1+\\eta r)^2-1)^{(q+1)/4}</span> . As above  <span class="math">1+\\eta r+X</span>  is a square root of  <span class="math">(1+\\eta r)^2-1</span> , so  <span class="math">X^2+2(1+\\eta r)X+1=0</span> . This quadratic equation has several consequences. First,  <span class="math">X\\neq 0</span> . Second,  <span class="math">rX+(1+X)^2\\neq 0</span> : otherwise subtract to see that  <span class="math">(1-2\\eta)rX=0</span> , so  <span class="math">1=2\\eta</span> , so y-1=y+1, contradiction. Third,  <span class="math">X\\neq -1</span> : otherwise  <span class="math">\\eta=0</span> , contradiction. Fourth,  <span class="math">y=(rX-(1+X)^2)/(rX+(1+X)^2)</span> .</p>

    <p class="text-gray-300">If X=1 then y=(r-4)/(r+4); also  <span class="math">\\eta r=-2</span>  so by assumption  <span class="math">x=2s(c-1)\\chi(c)/r</span>  so  <span class="math">(x,y)=\\phi(0)\\in\\phi(\\mathbf{F}_q)</span> . Assume from now on that  <span class="math">X\\neq 1</span> .</p>

    <p class="text-gray-300">Observe that</p>

    <p class="text-gray-300"><span class="math">$(rX + (1+X)^{2})^{2}(1-y^{2})</span>$</p>

    <p class="text-gray-300"><span class="math">$= (rX + (1+X)^{2})^{2} - (rX - (1+X)^{2})^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$= 4rX(1+X)^{2}.</span>$</p>

    <p class="text-gray-300">Recall that -d = (r+2)/(r-2) and similarly observe that  <span class="math">(rX + (1+X)^2)^2(1-dy^2)</span></p>

    <p class="text-gray-300"><span class="math">$= (rX + (1+X)^2)^2 + \\frac{r+2}{r-2}(rX - (1+X)^2)^2</span>$
<span class="math">$= (2r/(r-2))(X^4 + (r^2-2)X^2 + 1).</span>$</p>

    <p class="text-gray-300">Note that  <span class="math">1 - dy^2 \\neq 0</span>  since d is not a square. Divide:</p>

    <p class="text-gray-300"><span class="math">$x^{2} = \\frac{1 - y^{2}}{1 - dy^{2}} = \\frac{2(r - 2)X^{2}(1 + X)^{2}}{X^{5} + (r^{2} - 2)X^{3} + X}.</span>$</p>

    <p class="text-gray-300">Define
<span class="math">$Y = (c-1)sX(1+X)/x</span>$
. Then</p>

    <p class="text-gray-300"><span class="math">$Y^2 = (c-1)^2s^2X^2(1+X)^2/x^2</span>$</p>

    <p class="text-gray-300"><span class="math">$= 2(r-2)X^2(1+X)^2/x^2</span>$</p>

    <p class="text-gray-300"><span class="math">$= X^5 + (r^2 - 2)X^3 + X.</span>$</p>

    <p class="text-gray-300">Define  <span class="math">z = \\chi(Y(X^2 + 1/c^2))</span> . Both Y and  <span class="math">X^2 + 1/c^2</span>  are nonzero, so  <span class="math">z \\in \\{\\pm 1\\}</span> .</p>

    <p class="text-gray-300">Define u = zX. Then  <span class="math">u \\in \\{\\pm X\\}</span> . Note that  <span class="math">u \\neq -1</span> , since  <span class="math">X \\notin \\{\\pm 1\\}</span> .</p>

    <p class="text-gray-300">Define  <span class="math">v = u^5 + (r^2 - 2)u^3 + u</span> . Then  <span class="math">v = z(X^5 + (r^2 - 2)X^3 + X) = zY^2</span> , so  <span class="math">\\chi(v) = \\chi(z) = z</span> . Hence  <span class="math">X = \\chi(v)u</span>  and  <span class="math">Y^2 = \\chi(v)v</span> . Furthermore  <span class="math">\\chi(v) = z = \\chi(Y(X^2 + 1/c^2)) = \\chi(Y(u^2 + 1/c^2))</span> , so  <span class="math">\\chi(Y) = \\chi(v)\\chi(u^2 + 1/c^2)</span> , so  <span class="math">Y = (\\chi(v)v)^{(q+1)/4}\\chi(v)\\chi(u^2 + 1/c^2)</span> . Finally define t = (1-u)/(1+u). Then  <span class="math">t \\notin \\{\\pm 1\\}</span>  and u = (1-t)/(1+t). The formulas for u, v, X, Y, x, y in Theorem 1 are all satisfied, so  <span class="math">(x, y) = \\phi(t) \\in \\phi(\\mathbf{F}_q)</span>  as claimed.  <span class="math">\\square</span></p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Encoding as strings</h3>

    <p class="text-gray-300">Theorem 4. In the situation of Definition 2, assume that q is prime, and define  <span class="math">b = \\lfloor \\log_2 q \\rfloor</span> . Define  <span class="math">\\sigma</span> :  <span class="math">\\{0,1\\}^b \\to \\mathbf{F}_q</span>  by  <span class="math">\\sigma(\\tau_0,\\tau_1,\\ldots,\\tau_{b-1}) = \\sum_i \\tau_i 2^i</span> . Define  <span class="math">S = \\sigma^{-1}(\\{0,1,2,\\ldots,(q-1)/2\\})</span> . Define  <span class="math">\\iota: S \\to E(\\mathbf{F}_q)</span>  as follows:  <span class="math">\\iota(\\tau) = \\phi(\\sigma(\\tau))</span> . Then #S = (q+1)/2;  <span class="math">\\iota</span>  is an injective map from S to  <span class="math">E(\\mathbf{F}_q)</span> ; and  <span class="math">\\iota(S) = \\phi(\\mathbf{F}_q)</span> .</p>

    <p class="text-gray-300">PROOF. First  <span class="math">2^b \\leq q</span>  so the integers  <span class="math">0, 1, \\ldots, 2^b - 1</span>  are distinct in  <span class="math">\\mathbf{F}_q</span> ; hence  <span class="math">\\sigma</span>  is injective. Furthermore  <span class="math">2^b &gt; q/2</span>  so  <span class="math">\\{0, 1, \\ldots, (q-1)/2\\}</span>  is a subset of  <span class="math">\\{0, 1, \\ldots, 2^b - 1\\}</span> ; hence each of  <span class="math">0, 1, \\ldots, (q-1)/2</span>  has a preimage under  <span class="math">\\sigma</span> , and S has exactly (q+1)/2 elements.</p>

    <p class="text-gray-300">If  <span class="math">\\iota(\\tau) = \\iota(\\tau&#x27;)</span>  then  <span class="math">\\phi(\\sigma(\\tau)) = \\phi(\\sigma(\\tau&#x27;))</span> , so  <span class="math">\\sigma(\\tau) = \\pm \\sigma(\\tau&#x27;)</span>  by Theorem 3; but  <span class="math">\\sigma(\\tau)</span>  and  <span class="math">\\sigma(\\tau&#x27;)</span>  are both in  <span class="math">\\{0, 1, \\ldots, (q-1)/2\\}</span> , so  <span class="math">\\sigma(\\tau) = \\sigma(\\tau&#x27;)</span> , so  <span class="math">\\tau = \\tau&#x27;</span> . Hence  <span class="math">\\iota</span>  is injective.</p>

    <p class="text-gray-300">Each element of  <span class="math">\\iota(S)</span>  has the form  <span class="math">\\phi(\\sigma(\\tau))</span>  and is therefore in  <span class="math">\\phi(\\mathbf{F}_q)</span> . Conversely, if  <span class="math">P \\in \\phi(\\mathbf{F}_q)</span>  then  <span class="math">P = \\phi(t)</span>  for some  <span class="math">t \\in \\mathbf{F}_q</span> , so also  <span class="math">P = \\phi(-t)</span>  by Theorem 3. At least one of t, -t is in  <span class="math">\\{0, 1, \\ldots, (q-1)/2\\}</span> , i.e., in  <span class="math">\\sigma(S)</span> , so P is in  <span class="math">\\phi(\\sigma(S)) = \\iota(S)</span> .  <span class="math">\\square</span></p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">3.5 Performance analysis</h3>

    <p class="text-gray-300">The definitions of u, v, X, Y, x, y in Theorem 1 involve divisions by 1 + t, c, Y, and  <span class="math">rX + (1 + X)^2</span> . The reciprocal of c is trivially precomputed, and the other divisions are easily replaced by a few multiplications: one simply stores field elements as fractions, i.e., works in projective coordinates. There are several easy ways to reduce the number of multiplications: for example, factor  <span class="math">u^5 + (r^2 - 2)u^3 + u</span>  as  <span class="math">u(u^2 + c^2)(u^2 + 1/c^2)</span> , and reuse  <span class="math">u^2 + 1/c^2</span>  in computing Y.</p>

    <p class="text-gray-300">The main bottlenecks are then the following exponentiations: computing  <span class="math">\\chi(v)</span>  (used repeatedly); computing  <span class="math">\\chi(u^2+1/c^2)</span> ; computing  <span class="math">(\\chi(v)v)^{(q+1)/4}</span> , the principal square root of  <span class="math">\\chi(v)v</span> ; and computing a final division if the output (x,y) is needed in affine coordinates instead of projective coordinates. The only essential exponentiation is for the square-root computation: the  <span class="math">\\chi</span>  computations and division can use Euclid's algorithm (blinded to protect against timing attacks) rather than exponentiation.</p>

    <p class="text-gray-300">Similar comments apply to inverting  <span class="math">\\phi</span>  (or  <span class="math">\\iota</span> ). There is one essential exponentiation, the square-root computation to obtain  <span class="math">\\bar{X}</span>  in Theorem 3. There are also two exponentiations that can be replaced by Euclidean computations: one  <span class="math">\\chi</span>  computation to obtain z, and one division to obtain the final output  <span class="math">\\bar{t}</span> . Fractions eliminate the initial division by 2(y+1), but fractions cannot be used for  <span class="math">\\bar{t}</span> , since the goal is to obtain the unique string representing  <span class="math">\\bar{t}</span> .</p>

    <p class="text-gray-300">It is easier to test, given  <span class="math">(x,y) \\in \\mathbf{F}_q \\times \\mathbf{F}_q</span> , whether  <span class="math">(x,y) \\in \\phi(\\mathbf{F}_q)</span>  (i.e., whether  <span class="math">(x,y) \\in \\iota(S)</span> ) without inverting  <span class="math">\\phi</span> . One first checks  <span class="math">x^2 + y^2 = 1 + dx^2y^2</span>  to verify  <span class="math">(x,y) \\in E(\\mathbf{F}_q)</span> , if this is not already known. Then, by</p>

    <p class="text-gray-300">Theorem 3,  <span class="math">(x, y) \\in \\phi(\\mathbf{F}_q)</span>  if and only if the following three conditions are satisfied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">y + 1 \\neq 0</span> ;</li>
      <li><span class="math">(1+\\eta r)^2 1</span>  is a square, where  <span class="math">\\eta = (y-1)/(2(y+1))</span> ; i.e., r(y-1)(r(y-1)+4(y+1)) is a square;</li>
      <li>if  <span class="math">\\eta r = -2</span>  (equivalently, if r(y-1) = -4(y+1)) then  <span class="math">x = 2s(c-1)\\chi(c)/r</span> .</li>
    </ul>

    <p class="text-gray-300">This requires a few multiplications and one  <span class="math">\\chi</span>  computation.</p>

    <p class="text-gray-300">This section introduces a new high-security high-speed elliptic curve, called Curve1174, that supports the injective map presented in Section 3. In particular, this section specifies Curve1174; presents the criteria that we used to construct Curve1174; and analyzes the extent to which various previous curves meet the same criteria.</p>

    <p class="text-gray-300">Curve1174 illustrates state-of-the-art criteria for choosing elliptic curves. It is compatible with Elligator 1, and is also compatible with the new map Elligator 2 introduced in the next section. It is even more concisely expressible than the existing Curve25519 curve.</p>

    <p class="text-gray-300">We do not mean to suggest that users of Curve25519 are required to switch to Curve1174 to take advantage of this paper. Curve25519 is fully compatible with Elligator 2.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 The curve</h3>

    <p class="text-gray-300">Curve1174 is the Edwards curve  <span class="math">x^2 + y^2 = 1 - 1174x^2y^2</span>  over the field  <span class="math">\\mathbf{F}_q</span> , where q is the prime number  <span class="math">2^{251} - 9</span> . The coefficient -1174 is a non-square in  <span class="math">\\mathbf{F}_q</span> , so Curve1174 is a complete Edwards curve by [9, Theorem 3.3]: the sum of any two points  <span class="math">(x_1, y_1)</span>  and  <span class="math">(x_2, y_2)</span>  in Curve1174( <span class="math">\\mathbf{F}_q</span> ) is</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{x_1y_2+y_1x_2}{1-1174x_1x_2y_1y_2}, \\frac{y_1y_2-x_1x_2}{1+1174x_1x_2y_1y_2}\\right),</span>$</p>

    <p class="text-gray-300">with no divisions by 0 and no exceptional cases. The neutral element of the curve is (0,1).</p>

    <p class="text-gray-300">To see that we have the desired injective map, note that q is congruent to 3 modulo 4; define s as the element</p>

    <p class="text-gray-300">18064941211227179925228040535007972296</p>

    <p class="text-gray-300">48438766985538871240722010849934886421</p>

    <p class="text-gray-300">of  <span class="math">\\mathbf{F}_q</span>  (split onto two lines here for readability); define  <span class="math">c = 2/s^2</span> ; and define  <span class="math">d = -(c+1)^2/(c-1)^2</span> . Then d = -1174. The Edwards curve in Theorem 1 and Definition 2, for this choice of (q,s), is exactly Curve1174.</p>

    <p class="text-gray-300">Curve1174 is birationally equivalent to the Montgomery curve  <span class="math">(4/1175)V^2 = U^3 + (4/1175-2)U^2 + U</span>  by [9, Theorem 3.2]. The leading coefficient 4/1175 is a non-square in  <span class="math">\\mathbf{F}_q</span> , so  <span class="math">V^2 = U^3 + (4/1175-2)U^2 + U</span>  is a nontrivial quadratic twist of this curve. The Sage computer-algebra system [46] counts points on this curve in under 10 seconds on a laptop using the following script:</p>

    <pre><code class="language-text">q=2^251-9
E=EllipticCurve(GF(q),[0,4/1175-2,0,1,0])
print E.trace_of_frobenius()
# output -45330879683285730139092453152713398836
</code></pre>

    <p class="text-gray-300">The number of points on the twist is thus q+1+t, and the number of points on Curvel174 is q+1-t, where t=45330879683285730139092453152713398836. These integers</p>

    <p class="text-gray-300">q + 1 + t, q + 1 &minus; t have the form 4p0, 4p<sup>1</sup> respectively, where p<sup>0</sup> and p<sup>1</sup> are primes close to 2<sup>249</sup>. Generic methods to compute a discrete logarithm on Curve1174 or its twist take approximately <sup>&radic;</sup> &pi;2 <sup>247</sup> &asymp; 2 124.3 group operations on average.</p>

    <p class="text-gray-300">The point (U, V ) = (4, 192257776421116702304087124422 05514783403012708409058383774613284963344096) on the Montgomery curve (4/1175)V <sup>2</sup> = U <sup>3</sup> + (4/1175 &minus; 2)U <sup>2</sup> + U has order 4p1. The corresponding point on Curve1174 is (x, y) = (4/V, 3/5).</p>

    <p class="text-gray-300">Curve1174 and its twist do not have any structure allowing fast pairings or other special approaches to computing discrete logarithms. The primes p<sup>0</sup> and p<sup>1</sup> do not equal the field characteristic q. The order of q modulo p<sup>0</sup> is not small: it is (p<sup>0</sup> &minus; 1)/2. The order of q modulo p<sup>1</sup> is not small: it is p<sup>1</sup> &minus; 1. The endomorphism ring of Curve1174 has a large discriminant: up to squares this discriminant equals t <sup>2</sup>&minus;4q, which is divisible once by the prime 161567415114024992333870349255799, so the discriminant must be a multiple of this prime.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Design criteria</h3>

    <p class="text-gray-300">We consider only prime fields. Bernstein, citing subfield attacks from [28] and [18], wrote in [6] that prime fields &quot;have the virtue of minimizing the number of security concerns for elliptic-curve cryptography&quot;; see [22] and [43] for recent developments of the attack strategy from [18]. Similarly, the Brainpool standard [14] and NSA's Suite B standards [37] require prime fields. There is general agreement that prime fields are the safe, conservative choice for ECC. Prime fields also perform very well across a wide range of processors; the current ECC speed records on high-end Intel processors take advantage of special Intel support for binary fields (see [42]), but most CPUs do not have any comparable support.</p>

    <p class="text-gray-300">We consider only primes q congruent to 3 modulo 4. This is required for the injective map &phi;. These primes also have the well-known benefit of allowing very simple square-root computations; most other primes allow square-root computations at similar speed but with more complicated methods.</p>

    <p class="text-gray-300">We consider only complete Edwards curves, i.e., curves x <sup>2</sup> + y <sup>2</sup> = 1 + dx<sup>2</sup> y <sup>2</sup> where d is not a square. This is required for the injective map. About 25% of all elliptic curves over F<sup>q</sup> are expressible as complete Edwards curves, as mentioned in [9, Abstract] and experimentally verified in [7, Section 4]. Complete Edwards curves also have the advantages of being extremely fast and of allowing a single addition formula with no exceptions. Complete Edwards curves are also expressible as Montgomery curves supporting very fast and uniform Montgomery-ladder computations.</p>

    <p class="text-gray-300">To protect against generic discrete-logarithm algorithms we impose the standard requirement of a large prime dividing the number of curve points. This forces q to be even larger, where the gap accounts for the cofactor: the number of curve points divided by this prime. To minimize the performance problems of a large q we consider only Edwards curves with minimal cofactor, namely 4. The number of curve points is 4 times a prime for slightly below 1% of all choices of d, for the size of q that we consider below.</p>

    <p class="text-gray-300">We also impose the requirement of &quot;twist security&quot;: a large prime dividing the number of points on the quadratic twist of the curve. This prevents &quot;twist attacks&quot; against protocols that use the &quot;Montgomery ladder&quot; without checking that incoming points are on the curve; this defense was proposed by Bernstein in [5, page 23] and [4]. For q &equiv; 3 (mod 4) roughly 1/10000 of all choices of d have the number of points on the curve and the number of points on the twist each being 4 times a prime.</p>

    <p class="text-gray-300">We require d to have the form &minus;(c + 1)<sup>2</sup> /(c &minus; 1)<sup>2</sup> with c = 2/s<sup>2</sup> . This is required for the injective map, and covers about half of all non-squares d for q &equiv; 3 (mod 4).</p>

    <p class="text-gray-300">For standard performance reasons we take q very close to, but not above, a power of 2. The primes q &equiv; 3 (mod 4) within 32 of 2<sup>e</sup> for 200 &le; e &le; 300 are 2<sup>206</sup> &minus; 5, 2<sup>212</sup> &minus; 29, 2 <sup>226</sup> &minus; 5, 2<sup>243</sup> &minus; 9, 2<sup>251</sup> &minus; 9, and 2<sup>285</sup> &minus; 9. Note that these fields ensure that &sigma; &minus;1 covers nearly all of 0, 1, . . . , 2 <sup>b</sup> &minus; 1 giving a very close to uniform distribution of the encoding function. We focus on the last two of these primes as providing quantitatively safe security levels, and choose 2<sup>251</sup>&minus;9 as being obviously faster.</p>

    <p class="text-gray-300">Some curve operations involve multiplications by d. To speed up these multiplications we take the smallest possible d in absolute value, subject to the other requirements. The choice d = &minus;1174 for q = 2<sup>251</sup> &minus; 9 is smaller than expected.</p>

    <p class="text-gray-300">There is a long history of specific elliptic curves being designed to meet various security and performance criteria. For example, almost fifteen years ago the IEEE P1363 standard [33, Sections A.9&ndash;A.12]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>specified curves y <sup>2</sup> = x <sup>3</sup>&minus;3x+b to &quot;provide the fastest arithmetic on elliptic curves&quot;;</li>
      <li>imposed various further conditions upon these curves, with the security goal of making discrete logarithms difficult to compute; and</li>
      <li>specified a procedure to generate &quot;verifiably pseudorandom&quot; curves meeting these conditions.</li>
    </ul>

    <p class="text-gray-300">NIST's standard curves P-192, P-224, P-256, P-384, and P-521 were generated as follows: five particular prime fields were chosen with the goal of maximizing performance; the IEEE P1363 procedure was used to generate one curve over each of those fields.</p>

    <p class="text-gray-300">Subsequent research developed new security and performance criteria for curves over prime fields: twist security, Montgomery compatibility, Edwards compatibility, and completeness. The NIST curves, unsurprisingly, flunk these criteria: choosing cofactor 1 for y <sup>2</sup> = x <sup>3</sup>&minus;3x+b is incompatible with both Montgomery and Edwards, and one cannot expect twist security if it is not demanded in advance. Newer curves meet all of these criteria: for example, Curve25519 was explicitly designed for twist security and Montgomery compatibility, and was shown in [9] to also be expressible as a complete Edwards curve.</p>

    <p class="text-gray-300">These extra criteria do not improve discrete-logarithm security, but they do improve real-world security. They allow the simplest implementations to be correct implementations, whereas for other curves the simplest implementations that seem to work actually have hidden flaws that compromise security. See, e.g., [11, Section 4.1], [34], and [24].</p>

    <p class="text-gray-300">We are imposing a new security condition to support censorship circumvention: namely, an efficient way to encode a large fraction of all curve points as strings indistinguishable from uniform random strings. The generality of Elligator 1 makes it easy to imagine how this security condition could be accidentally met by previously generated curves:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The advantages of complete Edwards curves have been well known for five years.</li>
      <li>The advantages of Montgomery curves have been well known for even longer. A random Montgomery curve has a good chance of being expressible as a complete Edwards curve; see [7, Section 4].</li>
      <li>All complete Edwards curves over  <span class="math">\\mathbf{F}_q</span>  for  <span class="math">q \\equiv 3 \\pmod{4}</span>  meet the new security condition. Half of these curves are within the streamlined case expressed by Theorem 1.</li>
    </ul>

    <p class="text-gray-300">Given the amount of speed optimization of Curve25519 (see [6], [29], [17], [8], and [10]) and the wide deployment of Curve25519 in several applications (see, e.g., [2]) one of our initial goals for this paper was to show that Curve25519 meets this security condition. However, Elligator 1 is clearly limited to  <span class="math">q \\equiv 3 \\pmod 4</span> , while Curve25519 is defined over  <span class="math">\\mathbf{F}_q</span>  with  <span class="math">q \\equiv 1 \\pmod 4</span> . We provide two different solutions for this problem: Elligator 2 (see Section 5) and Curve1174.</p>

    <p class="text-gray-300">We would expect serious implementations of Curve1174 to be competitive in speed with Curve25519. Curve1174 has some small advantages: for example,  <span class="math">2^{251}-9</span>  is closer to a power of 2 than  <span class="math">2^{255}-19</span>  is; 1174 is considerably smaller than 486662; and square roots modulo  <span class="math">2^{251}-9</span>  are slightly easier than square roots modulo  <span class="math">2^{255}-19</span> . On the other hand, Curve25519 also has a small advantage: it is expressible in &quot;-1-twisted Edwards form&quot;, allowing the speedup explained in [31]. Obviously applications already using Curve25519 should not switch away from it, but for new applications it is not clear which curve is better.</p>

    <p class="text-gray-300">This section introduces a new injective map  <span class="math">\\psi</span>  to any elliptic curve of the form  <span class="math">y^2=x^3+Ax^2+Bx</span>  with  <span class="math">AB(A^2-4B)\\neq 0</span>  over any odd finite field, i.e., any finite field of odd characteristic. We emphasize that the characteristic is not required to be 3 modulo 4. This curve shape includes all Montgomery curves  <span class="math">y^2=x^3+Ax^2+x</span>  except  <span class="math">y^2=x^3+x</span> , and in particular it includes Curve25519.</p>

    <p class="text-gray-300">Any curve of this form has a point (0,0) of order 2. Conversely, over any odd finite field, almost every elliptic curve having a point of order 2 can be written in this form. Indeed, an elliptic curve over an odd finite field can always be written as  <span class="math">y^2 = u^3 + a_2u^2 + a_4u + a_6</span> ; a point of order 2 on this curve must have the form (r,0) where  <span class="math">r^3 + a_2r^2 + a_4r + a_6 = 0</span> ; substituting u = x + r produces the curve  <span class="math">y^2 = x^3 + Ax^2 + Bx</span>  where  <span class="math">A = a_2 + 3r</span>  and  <span class="math">B = a_4 + 2a_2r + 3r^2</span> . This curve must have  <span class="math">B(A^2 - 4B) \\neq 0</span>  since it is elliptic. The only exceptional case is A = 0, i.e., curves whose j-invariant equals 1728; this section assumes  <span class="math">A \\neq 0</span> .</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Squares</h3>

    <p class="text-gray-300">Fix an odd prime power q. As in Section 3.1 we define  <span class="math">\\chi: \\mathbf{F}_q \\to \\mathbf{F}_q</span>  by  <span class="math">\\chi(a) = a^{(q-1)/2}</span> , and we have  <span class="math">\\chi(a)</span>  equal to 1, -1, or 0 when a is, respectively, a non-zero square, a non-square, or zero.</p>

    <p class="text-gray-300">The definition of Elligator 2 is parametrized by a squareroot function for  <span class="math">\\mathbf{F}_q</span> : a function  <span class="math">\\sqrt{\\phantom{a}}: \\mathbf{F}_q^2 \\to \\mathbf{F}_q</span>  such that  <span class="math">\\sqrt{a^2} \\in \\{a, -a\\}</span>  for each  <span class="math">a \\in \\mathbf{F}_q</span> , where  <span class="math">\\mathbf{F}_q^2</span>  means  <span class="math">\\{a^2: a \\in \\mathbf{F}_q\\}</span> . Note that a square-root function  <span class="math">\\sqrt{\\phantom{a}}</span>  is completely described by its image  <span class="math">\\sqrt{\\mathbf{F}_q^2}</span> . For  <span class="math">q \\equiv 3 \\pmod{4}</span>  one can take the principal square root as a square-root function, i.e., take  <span class="math">\\sqrt{\\mathbf{F}_q^2} = \\mathbf{F}_q^2</span> , as in Section 3.1; but the concept of principal square roots does not generalize to  <span class="math">q \\equiv 1 \\pmod{4}</span> . For any odd prime q one can take  <span class="math">\\sqrt{\\mathbf{F}_q^2} = \\{0, 1, \\ldots, (q-1)/2\\}</span> . Other choices sometimes have computational benefits.</p>

    <p class="text-gray-300">The definition of Elligator 2 is also parametrized by a non-square  <span class="math">u \\in \\mathbf{F}_q</span> . If  <span class="math">q \\equiv 3 \\pmod{4}</span>  then one can take u = -1. If  <span class="math">q \\equiv 5 \\pmod{8}</span>  then one can take u = 2. Finding a non-square is an easy computation in general since about half of the elements of  <span class="math">\\mathbf{F}_q</span>  are non-squares. For efficiency it is desirable to choose u to be small, or otherwise to choose u to speed up multiplications by u.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 The map</h3>

    <p class="text-gray-300">Theorem 5. Let q be an odd prime power. Let A, B be elements of  <span class="math">\\mathbf{F}_q</span>  such that  <span class="math">AB(A^2-4B)\\neq 0</span> . Let u be a non-square in  <span class="math">\\mathbf{F}_q</span> . Let  <span class="math">\\sqrt{\\phantom{a}}</span>  be a square-root function for  <span class="math">\\mathbf{F}_q</span> . Define R as the set</p>

    <p class="text-gray-300"><span class="math">$\\{r \\in \\mathbf{F}_q : 1 + ur^2 \\neq 0, \\ A^2 ur^2 \\neq B(1 + ur^2)^2\\}.</span>$</p>

    <p class="text-gray-300">The following elements of  <span class="math">\\mathbf{F}_q</span>  are defined for each nonzero  <span class="math">r \\in R</span> :</p>

    <p class="text-gray-300"><span class="math">$v = -A/(1 + ur^{2}),</span>$</p>

    <p class="text-gray-300"><span class="math">$\\epsilon = \\chi(v^{3} + Av^{2} + Bv),</span>$</p>

    <p class="text-gray-300"><span class="math">$x = \\epsilon v - (1 - \\epsilon)A/2,</span>$</p>

    <p class="text-gray-300"><span class="math">$y = -\\epsilon \\sqrt{x^{3} + Ax^{2} + Bx}.</span>$</p>

    <p class="text-gray-300">Furthermore  <span class="math">v \\in xy \\neq 0</span>  and  <span class="math">y^2 = x^3 + Ax^2 + Bx</span> .</p>

    <p class="text-gray-300">If  <span class="math">q \\equiv 1 \\pmod{4}</span>  and  <span class="math">A^2 - 4B</span>  is a non-square in  <span class="math">\\mathbf{F}_q</span>  then  <span class="math">R = \\mathbf{F}_q</span> .</p>

    <p class="text-gray-300">PROOF. v is defined and  <span class="math">v \\neq 0</span> : By hypothesis  <span class="math">A \\neq 0</span>  and  <span class="math">1 + ur^2 \\neq 0</span> .</p>

    <p class="text-gray-300"><span class="math">v^3 + Av^2 + Bv \\neq 0</span>  and  <span class="math">\\epsilon \\neq 0</span> : Note that  <span class="math">v + vur^2 = -A</span>  so  <span class="math">v^2 + Av = v(v + A) = v(-vur^2)</span> . If  <span class="math">v^2 + Av + B = 0</span>  then  <span class="math">v^2ur^2 = B</span>  so, using the definition of v,  <span class="math">A^2ur^2 = B(1 + ur^2)^2</span> , contradicting the definition of R. Hence  <span class="math">v^2 + Av + B \\neq 0</span> , so  <span class="math">v^3 + Av^2 + Bv \\neq 0</span> , so  <span class="math">\\epsilon \\neq 0</span> .</p>

    <p class="text-gray-300"><span class="math">x^3 + Ax^2 + Bx</span>  is a nonzero square and  <span class="math">x \\neq 0</span> : There are two cases. First case:  <span class="math">\\epsilon = 1</span> , i.e.,  <span class="math">v^3 + Av^2 + Bv</span>  is a nonzero square. Then x = v so  <span class="math">x^3 + Ax^2 + Bx</span>  is a nonzero square; and  <span class="math">x \\neq 0</span>  since  <span class="math">v \\neq 0</span> .</p>

    <p class="text-gray-300">Second case:  <span class="math">\\epsilon=-1</span> , i.e.,  <span class="math">v^3+Av^2+Bv</span>  is a non-square. Then  <span class="math">x=-v-A=vur^2</span> . All factors  <span class="math">v,u,r^2</span>  here are nonzero so  <span class="math">x\\neq 0</span> ; note also that  <span class="math">\\chi(x)=\\chi(v)\\chi(u)=-\\chi(v)</span> . Furthermore x(x+A)=(-v-A)(-v)=v(v+A) so  <span class="math">x^2+Ax+B=v^2+Av+B</span>  so  <span class="math">\\chi(x^3+Ax^2+Bx)=-\\chi(v^3+Av^2+Bv)=-\\epsilon=1</span>  so  <span class="math">x^3+Ax^2+Bx</span>  is a nonzero square. y is defined,  <span class="math">y^2=x^3+Ax^2+Bx</span> , and  <span class="math">y\\neq 0</span> :  <span class="math">x^3+Ax^2+Bx</span>  is a nonzero square so  <span class="math">\\sqrt{x^3+Ax^2+Bx}</span>  is defined; all factors in  <span class="math">y=-\\epsilon\\sqrt{x^3+Ax^2+Bx}</span>  are nonzero, and  <span class="math">y^2=x^3+Ax^2+Bx</span> .</p>

    <p class="text-gray-300">If  <span class="math">q \\equiv 1 \\pmod{4}</span>  and  <span class="math">A^2 - 4B</span>  is a non-square then  <span class="math">R = \\mathbf{F}_q</span> : Fix  <span class="math">r \\in \\mathbf{F}_q</span> , and write  <span class="math">s = ur^2</span> . Then  <span class="math">\\chi(s) \\in \\{0, -1\\}</span>  while  <span class="math">\\chi(\\pm 1) = 1</span>  so  <span class="math">s \\neq \\pm 1</span> . In particular  <span class="math">1 + ur^2 \\neq 0</span> .</p>

    <p class="text-gray-300">Suppose that  <span class="math">A^2s = B(1+s)^2</span> . Subtract 4Bs to obtain  <span class="math">(A^2-4B)s = B(1-s)^2</span> . Multiply to obtain  <span class="math">(A^2-4B)A^2s^2 = B^2(1+s)^2(1-s)^2</span> . By hypothesis  <span class="math">\\chi(A^2-4B) = -1</span>  so  <span class="math">\\chi((A^2-4B)A^2s^2) \\in \\{-1,0\\}</span> , while all of B,1+s,1-s are nonzero so  <span class="math">\\chi(B^2(1+s)^2(1-s)^2) = 1</span> , contradiction. Consequently  <span class="math">A^2ur^2 \\neq B(1+ur^2)^2</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300">DEFINITION 6. In the situation of Theorem 5, the decoding function for the Weierstrass curve  <span class="math">E: y^2 = x^3 + Ax^2 + Bx</span>  is the function  <span class="math">\\psi: R \\to E(\\mathbf{F}_q)</span>  defined as follows:  <span class="math">\\psi(0) = (0,0)</span> ; if  <span class="math">r \\neq 0</span>  then  <span class="math">\\psi(r) = (x,y)</span> .</p>

    <p class="text-gray-300">With more work one can extend the definition of  <span class="math">\\psi</span>  to cover elements of  <span class="math">\\mathbf{F}_q</span>  outside R. For example, if  <span class="math">A^2-4B</span>  is a square then one can map any square roots in  <span class="math">\\mathbf{F}_q</span>  of  <span class="math">(A^2-2B\\pm A\\sqrt{A^2-4B})/(2uB)</span>  to  <span class="math">((-A\\pm\\sqrt{A^2-4B})/2,0)</span> . However, our main interest is in the case  <span class="math">R=\\mathbf{F}_q</span> , and then this extra work is unnecessary.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Inverting the map</h3>

    <p class="text-gray-300">Theorem 7. In the situation of Definition 6:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">r \\in R</span>  then the set of preimages of  <span class="math">\\psi(r)</span>  under  <span class="math">\\psi</span>  is  <span class="math">\\{r, -r\\}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\psi(R)</span>  is the set of  <span class="math">(x,y) \\in E(\\mathbf{F}_q)</span>  such that</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">x \\neq -A</span> ,</li>
      <li>if y = 0 then x = 0, and</li>
      <li>-ux(x+A) is a square in  <span class="math">\\mathbf{F}_q</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">(x,y) \\in \\psi(R)</span>  then the following element  <span class="math">\\bar{r}</span>  of R is defined and  <span class="math">\\psi(\\bar{r}) = (x,y)</span> :</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\bar{r} = \\begin{cases} \\sqrt{-x/((x+A)u)} &amp; \\text{if } y \\in \\sqrt{\\mathbf{F}_q^2}; \\\\ \\sqrt{-(x+A)/(ux)} &amp; \\text{if } y \\notin \\sqrt{\\mathbf{F}_q^2}. \\end{cases}</span>$</p>

    <p class="text-gray-300">PROOF. 1. If r=0 then r=-r so  <span class="math">\\psi(r)=\\psi(-r)</span> . If  <span class="math">r\\neq 0</span>  then Theorem 5 defines  <span class="math">\\psi(r)</span>  purely in terms of  <span class="math">r^2</span>  so  <span class="math">\\psi(r)=\\psi(-r)</span> .</p>

    <p class="text-gray-300">Conversely, assume that  <span class="math">\\psi(r) = \\psi(r&#x27;)</span> ; our goal is to show that  <span class="math">r&#x27; \\in \\{r, -r\\}</span> . If r = 0 then  <span class="math">\\psi(r) = (0, 0)</span> , and otherwise  <span class="math">\\psi(r)</span>  has nonzero coordinates by Theorem 5; hence r = 0 if and only if r' = 0. The only remaining case is that  <span class="math">r \\neq 0</span>  and  <span class="math">r&#x27; \\neq 0</span> .</p>

    <p class="text-gray-300">Define  <span class="math">v&#x27;, \\epsilon&#x27;, x&#x27;, y&#x27;</span>  from r' as in Theorem 5. Then  <span class="math">(x&#x27;, y&#x27;) = \\psi(r&#x27;) = \\psi(r) = (x, y)</span> . Furthermore  <span class="math">y = -\\epsilon \\sqrt{x^3 + Ax^2 + Bx}</span>  and  <span class="math">y&#x27; = -\\epsilon&#x27; \\sqrt{(x&#x27;)^3 + A(x&#x27;)^2 + B(x&#x27;)}</span>  so  <span class="math">\\epsilon&#x27; = \\epsilon</span>  since  <span class="math">\\sqrt{\\phantom{a}}</span>  is a function. Next  <span class="math">x = \\epsilon v - (1 - \\epsilon)A/2</span>  and  <span class="math">x&#x27; = \\epsilon&#x27; v&#x27; - (1 - \\epsilon&#x27;)A/2</span>  so v' = v. Finally  <span class="math">1 + ur^2 = 1 + u(r&#x27;)^2</span>  so  <span class="math">r&#x27; \\in \\{r, -r\\}</span>  as claimed.</p>

    <p class="text-gray-300"><strong>2.</strong> Fix  <span class="math">r \\in R</span> , and write  <span class="math">(x,y) = \\psi(r)</span> . If r = 0 then (x,y) = (0,0) so x = 0;  <span class="math">x \\neq -A</span> ; and -ux(x+A) = 0 is a square. If  <span class="math">r \\neq 0</span>  then (x,y) is defined in Theorem 5, and there are two cases. The first case is that  <span class="math">\\epsilon = 1</span> ; then  <span class="math">x = v \\neq -A</span>  since  <span class="math">ur^2 \\neq 0</span> . The second case is that  <span class="math">\\epsilon = -1</span> ; then  <span class="math">x = -v - A \\neq -A</span>  since  <span class="math">v \\neq 0</span> . In both cases  <span class="math">y \\neq 0</span>  by Theorem 5, and  <span class="math">-ux(x+A) = -uv(v+A) = -uv(-vur^2) = u^2v^2r^2</span> , which is a square.</p>

    <p class="text-gray-300">Conversely, assume that  <span class="math">(x,y) \\in E(\\mathbf{F}_q)</span> , that  <span class="math">x \\neq -A</span> , then if y=0 then x=0, and that -ux(x+A) is a square. Our goal is to show that  <span class="math">(x,y) \\in \\psi(R)</span> . We will in fact show more:  <span class="math">(x,y) = \\psi(\\bar{r})</span>  where  <span class="math">\\bar{r}</span>  is defined as in the third part of the theorem statement.</p>

    <p class="text-gray-300">If y=0 then x=0 by assumption. Furthermore  <span class="math">y=\\sqrt{0}\\in\\sqrt{\\mathbf{F}_q^2}</span>  and -x/((x+A)u)=0 so  <span class="math">\\bar{r}</span>  is defined as 0. Hence  <span class="math">(x,y)=(0,0)=\\psi(0)=\\psi(\\bar{r})</span>  as claimed.</p>

    <p class="text-gray-300">Assume from now on that  <span class="math">y \\neq 0</span> . The curve equation then implies that  <span class="math">x \\neq 0</span> . Now (x+A)u and ux are both nonzero, and both -x/((x+A)u) and -(x+A)/(ux) are squares, so  <span class="math">\\bar{r}</span>  is defined and nonzero. We will see below that  <span class="math">1+u\\bar{r}^2\\neq 0</span></p>

    <p class="text-gray-300">and  <span class="math">A^2u\\bar{r}^2\\neq B(1+u\\bar{r}^2)^2,</span>  so  <span class="math">\\bar{r}\\in R.</span>  Define  <span class="math">\\bar{v},\\bar{\\epsilon},\\bar{x},\\bar{y}</span>  as in Theorem 5.</p>

    <p class="text-gray-300">If  <span class="math">y \\in \\sqrt{\\mathbf{F}_q^2}</span>  then  <span class="math">\\bar{r}^2 = -x/((x+A)u)</span>  so  <span class="math">1 + u\\bar{r}^2 = A/(x+A)</span>  so  <span class="math">\\bar{v} = -x - A</span>  so  <span class="math">\\chi(\\bar{v}) = \\chi(-x-A) = \\chi(ux) = -\\chi(x)</span> . Next  <span class="math">\\bar{v}^2 + A\\bar{v} + B = x^2 + Ax + B</span>  so  <span class="math">\\bar{\\epsilon} = \\chi(\\bar{v}^3 + A\\bar{v}^2 + B\\bar{v}) = -\\chi(x^3 + Ax^2 + Bx) = -1</span> . Consequently  <span class="math">\\bar{x} = -\\bar{v} - A = x</span>  and  <span class="math">\\bar{y} = -\\bar{\\epsilon}\\sqrt{x^3 + Ax^2 + Bx} = \\sqrt{x^3 + Ax^2 + Bx} = y</span> .</p>

    <p class="text-gray-300">The remaining case is that  <span class="math">y \\notin \\sqrt{\\mathbf{F}_q^2}</span> , i.e.,  <span class="math">y = -\\sqrt{x^3 + Ax^2 + Bx}</span> . Then  <span class="math">\\bar{r}^2 = -(x+A)/(ux)</span>  so  <span class="math">1 + u\\bar{r}^2 = -A/x</span>  so  <span class="math">\\bar{v} = x</span> . Now  <span class="math">\\bar{v}^3 + A\\bar{v}^2 + B\\bar{v} = x^3 + Ax^2 + Bx</span>  so  <span class="math">\\bar{\\epsilon} = 1</span> . Consequently  <span class="math">\\bar{x} = \\bar{v} = x</span>  and  <span class="math">\\bar{y} = -\\bar{\\epsilon}\\sqrt{x^3 + Ax^2 + Bx} = -\\sqrt{x^3 + Ax^2 + Bx} = y</span> .</p>

    <p class="text-gray-300">In both cases we have  <span class="math">\\bar{v}^2 + A\\bar{v} + B = x^2 + Ax + B \\neq 0</span>  so  <span class="math">A^2 u \\bar{r}^2 \\neq B(1 + u \\bar{r}^2)^2</span> .</p>

    <p class="text-gray-300"><strong>3.</strong> Fix  <span class="math">(x,y) \\in \\psi(R)</span> . We showed above that  <span class="math">x \\neq -A</span> ; that if y=0 then x=0; and that -ux(x+A) is a square. We also showed that under these conditions  <span class="math">\\bar{r}</span>  is defined and  <span class="math">\\psi(\\bar{r})=(x,y)</span> .  <span class="math">\\square</span></p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Encoding as strings</h3>

    <p class="text-gray-300">THEOREM 8. In the situation of Definition 6, assume that q is prime, that  <span class="math">q \\equiv 1 \\pmod{4}</span> , and that  <span class="math">A^2 - 4B</span>  is not a square in  <span class="math">\\mathbf{F}_q</span> . Define  <span class="math">b = \\lfloor \\log_2 q \\rfloor</span> . Define  <span class="math">\\sigma: \\{0,1\\}^b \\to \\mathbf{F}_q</span>  by  <span class="math">\\sigma(\\rho_0,\\rho_1,\\ldots,\\rho_{b-1}) = \\sum_i \\rho_i 2^i</span> . Define  <span class="math">S = \\sigma^{-1}(\\{0,1,2,\\ldots,(q-1)/2\\})</span> . Define  <span class="math">\\iota: S \\to E(\\mathbf{F}_q)</span>  as follows:  <span class="math">\\iota(\\rho) = \\psi(\\sigma(\\rho))</span> . Then #S = (q+1)/2;  <span class="math">\\iota</span>  is an injective map from S to  <span class="math">E(\\mathbf{F}_q)</span> ; and  <span class="math">\\iota(S) = \\psi(\\mathbf{F}_q)</span> .</p>

    <p class="text-gray-300">PROOF. Note that  <span class="math">R=\\mathbf{F}_q</span>  by Theorem 5; i.e.,  <span class="math">\\psi</span>  is defined on all of  <span class="math">\\mathbf{F}_q</span> . The rest of the proof is identical to the proof of Theorem 4 with  <span class="math">\\phi</span>  replaced by  <span class="math">\\psi</span> ,  <span class="math">\\tau</span>  replaced by  <span class="math">\\rho</span> , Theorem 1 replaced by Theorem 5, and Theorem 3 replaced by Theorem 7.  <span class="math">\\square</span></p>

      <h3 id="sec-5.5" class="text-xl font-semibold mt-8">5.5 Application of <span class="math">\\psi</span> to Curve25519</h3>

    <p class="text-gray-300">Curve 25519 is the curve  <span class="math">y^2 = x^3 + Ax^2 + Bx</span>  over  <span class="math">\\mathbf{F}_q</span>  with  <span class="math">q = 2^{255} - 19</span> , A = 486662, and B = 1. Here  <span class="math">q \\equiv 1 \\pmod{4}</span>  and  <span class="math">A^2 - 4B</span>  is a non-square in  <span class="math">\\mathbf{F}_q</span> , so  <span class="math">R = \\mathbf{F}_q</span> .</p>

    <p class="text-gray-300">We take u=2. We copy from [8] the following standard efficiently computable square-root function for  <span class="math">\\mathbf{F}_q</span> . Given a square  <span class="math">a\\in \\mathbf{F}_q</span>  compute  <span class="math">b=a^{(q+3)/8}</span> ; note that  <span class="math">q\\equiv 5\\pmod 8</span> , so (q+3)/8 is an integer. Then  <span class="math">b^4=a^2</span> , i.e.,  <span class="math">b^2\\in \\{a,-a\\}</span> . Define  <span class="math">\\sqrt{a}</span>  as |b| if  <span class="math">b^2=a</span>  and as  <span class="math">|b\\sqrt{-1}|</span>  otherwise. Here |b| means b if  <span class="math">b\\in \\{0,1,\\ldots,(q-1)/2\\}</span> , otherwise -b.</p>

    <p class="text-gray-300">Computing  <span class="math">\\iota</span>  takes 1 square-root computation, 1 inversion, 1 computation of  <span class="math">\\chi</span> , and a few multiplications. Note that the inversion and the square-root computation can be combined into one exponentiation, as in [8]. The computation of  <span class="math">\\chi</span>  can also be combined into the square-root computation as follows. First compute a power of  <span class="math">v^3 + Av^2 + Bv</span>  as above, obtaining a square root of  <span class="math">v^3 + Av^2 + Bv</span>  if  <span class="math">v^3 + Av^2 + Bv</span>  is a square. If the square of this power turns out to match  <span class="math">v^3 + Av^2 + Bv</span>  then  <span class="math">\\epsilon = 1</span>  and x = v. Otherwise  <span class="math">\\epsilon = -1</span> ,  <span class="math">x = vur^2</span> , and  <span class="math">x^3 + Ax^2 + Bx = ur^2(v^3 + Av^2 + Bv)</span> ; multiply the previous power by r and by a precomputed power of v to obtain a square root of  <span class="math">v^3 + Av^2 + Bv</span> .</p>

    <p class="text-gray-300">Similar comments apply to computing the inverse map. Checking for  <span class="math">P \\in \\iota(S)</span>  takes 1 squaring and a computation of  <span class="math">\\chi</span>  to obtain  <span class="math">\\chi((x + A/2)^2 - A^2/4) = \\chi(x(x + A))</span> .</p>

    <p class="text-gray-300">This map and its inverse seem simplest to describe in Weierstrass coordinates, but maps to and from Edwards form, and other curve shapes, are also easily obtained.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">6. REFERENCES</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">APPELBAUM, J., AND DINGLEDINE, R. How governments have tried to block Tor, 2011. http: //ftp.ccc.de/congress/28C3/mp4-h264-HQ/28c3-4800-en-how_ governments_have_tried_to_block_tor_h264.mp4.</p></li>
      <li><p class="text-gray-300">[2] APPLE. iOS security, 2012. http://images.apple.com/iphone/business/docs/iOS_Security_Oct12.pdf.</p></li>
      <li><p class="text-gray-300">[3] BELLARE, M., DESAI, A., JOKIPII, E., AND ROGAWAY, P. A concrete security treatment of symmetric encryption. In FOCS (1997), IEEE Computer Society, pp. 394&ndash;403.</p></li>
      <li><p class="text-gray-300">[4] BERNSTEIN, D. J. Current consensus on ECC, 2001. https://groups.google.com/forum/message/raw?msg=sci.crypt/mu_paShEU3w/m491pYxHbtAJ.</p></li>
      <li><p class="text-gray-300">[5] BERNSTEIN, D. J. A software implementation of NIST P-224, 2001. http://cr.yp.to/talks.html#2001.10.29.</p></li>
      <li><p class="text-gray-300">[6] BERNSTEIN, D. J. Curve25519: New Diffie-Hellman speed records. In <em>Public Key Cryptography</em> (2006), M. Yung, Y. Dodis, A. Kiayias, and T. Malkin, Eds., vol. 3958 of <em>LNCS</em>, Springer, pp. 207&ndash;228.</p></li>
      <li><p class="text-gray-300">BERNSTEIN, D. J., BIRKNER, P., JOYE, M., LANGE, T., AND PETERS,
C. Twisted Edwards curves. In AFRICACRYPT (2008),
S. Vaudenay, Ed., vol. 5023 of LNCS, Springer, pp. 389&ndash;405.</p></li>
      <li><p class="text-gray-300">[8] BERNSTEIN, D. J., DUIF, N., LANGE, T., SCHWABE, P., AND YANG, B.-Y. High-speed high-security signatures. J. Cryptographic Engineering 2, 2 (2012), 77&ndash;89.</p></li>
      <li><p class="text-gray-300">[9] BERNSTEIN, D. J., AND LANGE, T. Faster addition and doubling on elliptic curves. In ASIACRYPT (2007), K. Kurosawa, Ed., vol. 4833 of LNCS, Springer, pp. 29&ndash;50.</p></li>
      <li><p class="text-gray-300">[10] BERNSTEIN, D. J., AND SCHWABE, P. NEON crypto. In CHES (2012), E. Prouff and P. Schaumont, Eds., vol. 7428 of LNCS, Springer, pp. 320&ndash;339.</p></li>
      <li><p class="text-gray-300">[11] BIEHL, I., MEYER, B., AND M&Uuml;LLER, V. Differential fault attacks on elliptic curve cryptosystems. In CRYPTO (2000), M. Bellare, Ed., vol. 1880 of LNCS, Springer, pp. 131&ndash;146.</p></li>
      <li><p class="text-gray-300">[12] BONEH, D., AND FRANKLIN, M. K. Identity-based encryption from the Weil pairing. In CRYPTO (2001), J. Kilian, Ed., vol. 2139 of LNCS, Springer, pp. 213&ndash;229.</p></li>
      <li><p class="text-gray-300">[13] BOYD, C., MONTAGUE, P., AND NGUYEN, K. Q. Elliptic curve based password authenticated key exchange protocols. In ACISP (2001), V. Varadharajan and Y. Mu, Eds., vol. 2119 of LNCS, Springer, pp. 487&ndash;501.</p></li>
      <li><p class="text-gray-300">[14] BRAINPOOL. ECC Brainpool standard curves and curve generation, v. 1.0, 2005. http://www.ecc-brainpool.org/download/Domain-parameters.pdf.</p></li>
      <li><p class="text-gray-300">[15] BRIER, E., CORON, J.-S., ICART, T., MADORE, D., RANDRIAM, H., AND TIBOUCHI, M. Efficient indifferentiable hashing into ordinary elliptic curves. In CRYPTO (2010), T. Rabin, Ed., vol. 6223 of LNCS, Springer, pp. 237&ndash;254.</p></li>
      <li><p class="text-gray-300">Brier, E., and Joye, M. Weierstra&szlig; elliptic curves and side-channel attacks. In <em>Public Key Cryptography</em> (2002),
D. Naccache and P. Paillier, Eds., vol. 2274 of <em>LNCS</em>, Springer, pp. 335&ndash;345.</p></li>
      <li><p class="text-gray-300">[17] COSTIGAN, N., AND SCHWABE, P. Fast elliptic-curve cryptography on the Cell Broadband Engine. In AFRICACRYPT (2009), B. Preneel, Ed., vol. 5580 of LNCS, Springer, pp. 368&ndash;385.</p></li>
      <li><p class="text-gray-300">[18] DIEM, C. The GHS attack in odd characteristic. J. Ramanujan Mathematical Society 18 (2003), 1&ndash;32.</p></li>
      <li><p class="text-gray-300">[19] DINGLEDINE, R., MATHEWSON, N., AND SYVERSON, P. F. Tor: The second-generation onion router. In <em>USENIX Security</em> Symposium (2004), USENIX, pp. 303&ndash;320.</p></li>
      <li><p class="text-gray-300">[20] FARASHAHI, R. R. Hashing into Hessian curves. In AFRICACRYPT (2011), A. Nitaj and D. Pointcheval, Eds., vol. 6737 of LNCS, Springer, pp. 278&ndash;289.</p></li>
      <li><p class="text-gray-300">[21] FARASHAHI, R. R., FOUQUE, P.-A., SHPARLINSKI, I., TIBOUCHI, M., AND VOLOCH, J. F. Indifferentiable deterministic hashing to elliptic and hyperelliptic curves. <em>Math. Comput.</em> 82, 281 (2013).</p></li>
      <li><p class="text-gray-300">[22] FAUG&Egrave;RE, J.-C., PERRET, L., PETIT, C., AND RENAULT, G. Improving the complexity of index calculus algorithms in elliptic curves over binary fields. In EUROCRYPT (2012), D. Pointcheval and T. Johansson, Eds., vol. 7237 of LNCS, Springer, pp. 27&ndash;44.</p></li>
      <li><p class="text-gray-300">[23] FOUQUE, P.-A., JOUX, A., AND TIBOUCHI, M. Injective encodings to elliptic curves. In ACISP (2013), C. Boyd and L. Simpson, Eds., vol. 7959 of LNCS, Springer, pp. 203&ndash;218.</p></li>
      <li><p class="text-gray-300">[24] FOUQUE, P.-A., LERCIER, R., R&Eacute;AL, D., AND VALETTE, F. Fault attack on elliptic curve Montgomery ladder implementation. In FDTC (2008), L. Breveglieri, S. Gueron, I. Koren, D. Naccache, and J.-P. Seifert, Eds., IEEE Computer Society, pp. 92&ndash;98.</p></li>
      <li><p class="text-gray-300">[25] FOUQUE, P.-A., AND TIBOUCHI, M. Deterministic encoding and hashing to odd hyperelliptic curves. In <em>Pairing</em> (2010),</p></li>
      <li><p class="text-gray-300">M. Joye, A. Miyaji, and A. Otsuka, Eds., vol. 6487 of LNCS, Springer, pp. 265&ndash;277.</p></li>
      <li><p class="text-gray-300">[26] FOUQUE, P.-A., AND TIBOUCHI, M. Estimating the size of the image of deterministic hash functions to elliptic curves. In LATINCRYPT (2010), M. Abdalla and P. S. L. M. Barreto, Eds., vol. 6212 of LNCS, Springer, pp. 81&ndash;91.</p></li>
      <li><p class="text-gray-300">[27] FOUQUE, P.-A., AND TIBOUCHI, M. Indifferentiable hashing to Barreto-Naehrig curves. In <em>LATINCRYPT</em> (2012), A. Hevia and G. Neven, Eds., vol. 7533 of <em>LNCS</em>, Springer, pp. 1&ndash;17.</p></li>
      <li><p class="text-gray-300">[28] FREY, G. How to disguise an elliptic curve (Weil descent), 1998. http://www.cacr.math.uwaterloo.ca/conferences/1998/ecc98/ slides.html.</p></li>
      <li><p class="text-gray-300">[29] GAUDRY, P., AND THOM&Eacute;, E. The mpFq library and implementing curve-based key exchanges. In SPEED: software performance enhancement for encryption and decryption (2007), pp. 49-64.</p></li>
      <li><p class="text-gray-300">[30] GOLDBERG, I., STEBILA, D., AND USTAOGLU, B. Anonymity and one-way authentication in key exchange protocols. <em>Des. Codes</em> Cryptography 67, 2 (2013), 245&ndash;269.</p></li>
      <li><p class="text-gray-300">[31] HISIL, H., WONG, K. K.-H., CARTER, G., AND DAWSON, E. Twisted Edwards curves revisited. In ASIACRYPT (2008), J. Pieprzyk, Ed., vol. 5350 of LNCS, Springer, pp. 326&ndash;343.</p></li>
      <li><p class="text-gray-300">[32] ICART, T. How to hash into elliptic curves. In CRYPTO (2009),
S. Halevi, Ed., vol. 5677 of LNCS, Springer, pp. 303&ndash;316.</p></li>
      <li><p class="text-gray-300">[33] Institute of Electrical and Electronics Engineers. P1363 Draft Standard Specifications for Public Key Cryptography. IEEE, 1999.</p></li>
      <li><p class="text-gray-300">[34] IZU, T., AND TAKAGI, T. Exceptional procedure attack on elliptic curve cryptosystems. In <em>Public Key Cryptography</em> (2003), Y. Desmedt, Ed., vol. 2567 of <em>LNCS</em>, Springer, pp. 224&ndash;239.</p></li>
      <li><p class="text-gray-300">[35] Kaliski Jr., B. S. A pseudo-random bit generator based on elliptic logarithms. In CRYPTO (1986), A. M. Odlyzko, Ed., vol. 263 of LNCS, Springer, pp. 84&ndash;103.</p></li>
      <li><p class="text-gray-300">[36] KALISKI JR., B. S. Elliptic Curves and Cryptography: A Pseudorandom Bit Generator and Other Tools. PhD thesis, MIT, 1988. MIT/LCS/TR-411.</p></li>
      <li><p class="text-gray-300">[37] LAW, L. E., AND SOLINAS, J. A. Suite B cryptographic suites for IPsec, 2011. https://tools.ietf.org/html/rfc6379.</p></li>
      <li><p class="text-gray-300">[38] LIDL, R., AND NIEDERREITER, H. Finite Fields. Encyclopedia of Mathematics and its Applications. Cambridge University Press, 1997</p></li>
      <li><p class="text-gray-300">[39] L&Oacute;PEZ, J., AND DAHAB, R. Fast multiplication on elliptic curves over GF(2<sup>m</sup>) without precomputation. In CHES (1999), &Ccedil;. K. Ko&ccedil; and C. Paar, Eds., vol. 1717 of LNCS, Springer, pp. 316&ndash;327.</p></li>
      <li><p class="text-gray-300">[40] M&Ouml;LLER, B. A public-key encryption scheme with pseudo-random ciphertexts. In Computer Security&mdash;ESORICS 2004, P. Samarati, P. Ryan, D. Gollmann, and R. Molva, Eds., vol. 3193 of LNCS. Springer Berlin Heidelberg, 2004, pp. 335&ndash;351.</p></li>
      <li><p class="text-gray-300">[41] MONTGOMERY, P. L. Speeding the Pollard and elliptic curve methods of factorization. <em>Math. Comp.</em> 48, 177 (1987), 243&ndash;264.</p></li>
      <li><p class="text-gray-300">[42] OLIVEIRA, T., L&Oacute;PEZ, J., ARANHA, D. F., AND RODR&Iacute;GUEZ-HENR&Iacute;QUEZ, F. Lambda coordinates for binary elliptic curves. In CHES (2013), G. Bertoni and J.-S. Coron, Eds., vol. 8086 of LNCS, Springer, pp. 311&ndash;330.</p></li>
      <li><p class="text-gray-300">[43] PETIT, C., AND QUISQUATER, J.-J. On polynomial systems arising from a Weil descent. In ASIACRYPT (2012), X. Wang and K. Sako, Eds., vol. 7658 of LNCS, Springer, pp. 451&ndash;466.</p></li>
      <li><p class="text-gray-300">[44] ROGAWAY, P., AND SHRIMPTON, T. A provable-security treatment of the key-wrap problem. In <em>EUROCRYPT</em> (2006), S. Vaudenay, Ed., vol. 4004 of <em>LNCS</em>, Springer, pp. 373&ndash;390.</p></li>
      <li><p class="text-gray-300">[45] SHALLUE, A., AND VAN DE WOESTIJNE, C. Construction of rational points on elliptic curves over finite fields. In ANTS (2006), F. Hess, S. Pauli, and M. E. Pohst, Eds., vol. 4076 of LNCS, Springer, pp. 510&ndash;524.</p></li>
      <li><p class="text-gray-300">[46] STEIN, W., ET AL. Sage Mathematics Software (Version 2.9). The Sage Development Team, 2013. http://www.sagemath.org.</p></li>
      <li><p class="text-gray-300">[47] WEINBERG, Z., WANG, J., YEGNESWARAN, V., BRIESEMEISTER, L., CHEUNG, S., WANG, F., AND BONEH, D. StegoTorus: a camouflage proxy for the Tor anonymity system. In ACM Conference on Computer and Communications Security (2012), T. Yu, G. Danezis, and V. D. Gligor, Eds., ACM, pp. 109&ndash;120.</p></li>
      <li><p class="text-gray-300">[48] WUSTROW, E., WOLCHOK, S., GOLDBERG, I., AND HALDERMAN, J. A. Telex: Anticensorship in the network infrastructure. In USENIX Security Symposium (2011), USENIX Association.</p></li>
      <li><p class="text-gray-300">[49] YOUNG, A. L., AND YUNG, M. Kleptography from standard assumptions and applications. In SCN (2010), J. A. Garay and R. D. Prisco, Eds., vol. 6280 of LNCS, Springer, pp. 271&ndash;290.</p></li>
    </ul>

`;
---

<BaseLayout title="Elligator: Elliptic-curve points indistinguishable from unif... (2013/325)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/325
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="elligator-elliptic-curve-points-indistinguishable-from-2013" />
  </article>
</BaseLayout>
