---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/349';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zerocash: Decentralized Anonymous Payments from Bitcoin';
const AUTHORS_HTML = 'Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, Madars Virza';

const CONTENT = `    <p class="text-gray-300">Eli Ben-Sasson* Alessandro Chiesa† Christina Garman‡ Matthew Green‡ Ian Miers‡ Eran Tromer§ Madars Virza†</p>

    <p class="text-gray-300">May 18, 2014</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">Bitcoin is the first digital currency to see widespread adoption. Although payments are conducted between pseudonyms, Bitcoin cannot offer strong privacy guarantees: payment transactions are recorded in a public decentralized ledger, from which much information can be deduced. Zerocoin (Miers et al., IEEE S&amp;P 2013) tackles some of these privacy issues by unlinking transactions from the payment's origin. Yet it still reveals payment destinations and amounts, and is limited in functionality.</p>

    <p class="text-gray-300">In this paper, we construct a full-fledged ledger-based digital currency with strong privacy guarantees. Our results leverage recent advances in zero-knowledge Succinct Non-interactive ARguments of Knowledge (zk-SNARKs).</p>

    <p class="text-gray-300">We formulate and construct decentralized anonymous payment schemes (DAP schemes). A DAP scheme lets users pay each other directly and privately: the corresponding transaction hides the payment's origin, destination, and amount. We provide formal definitions and proofs of the construction's security.</p>

    <p class="text-gray-300">We then build Zerocash, a practical instantiation of our DAP scheme construction. In Zerocash, transactions are less than 1 kB and take under 6 ms to verify — orders of magnitude more efficient than the less-anonymous Zerocoin and competitive with plain Bitcoin.</p>

    <p class="text-gray-300"><strong>Keywords</strong>: Bitcoin, decentralized electronic cash, zero-knowledge proofs</p>

    <p class="text-gray-300">*Technion, eli@cs.technion.ac.il</p>

    <p class="text-gray-300">†MIT, {alexch, madars}@mit.edu</p>

    <p class="text-gray-300">‡Johns Hopkins University, {cgarman, imiers, mgreen}@cs.jhu.edu</p>

    <p class="text-gray-300">§Tel Aviv University, tromer@cs.tau.ac.il</p>

    <p class="text-gray-300">1 Introduction 3 1.1 zk-SNARKs 4 1.2 Centralized anonymous payment systems 5 1.3 Decentralized anonymous payment schemes 5 1.4 Zerocash 9 1.5 Paper organization 10</p>

    <p class="text-gray-300">2 Background on zk-SNARKs 10 2.1 Informal definition 10 2.2 Comparison with NIZKs 11 2.3 Known constructions and security 12 2.4 zk-SNARK implementations 12</p>

    <p class="text-gray-300">3 Definition of a decentralized anonymous payment scheme 13 3.1 Data structures 13 3.2 Algorithms 14 3.3 Completeness 16 3.4 Security 16</p>

    <p class="text-gray-300">4 Construction of a decentralized anonymous payment scheme 18 4.1 Cryptographic building blocks 18 4.2 zk-SNARKs for pouring coins 19 4.3 Algorithm constructions 20 4.4 Completeness and security 20</p>

    <p class="text-gray-300">5 Zerocash 20 5.1 Instantiation of building blocks 22 5.2 Arithmetic circuit for pouring coins 23</p>

    <p class="text-gray-300">6 Integration with existing ledger-based currencies 26 6.1 Integration by replacing the base currency 26 6.2 Integration by hybrid currency 26 6.3 Extending the Bitcoin protocol to support the combined semantics 28 6.4 Additional anonymity considerations 28</p>

    <p class="text-gray-300">7 Experiments 28 7.1 Performance of zk-SNARKs for pouring coins 29 7.2 Performance of Zerocash algorithms 29 7.3 Large-scale network simulation 30</p>

    <p class="text-gray-300">8 Optimizations and extensions 33 8.1 Everlasting anonymity 33 8.2 Fast block propagation 34 8.3 Improved storage requirements 34</p>

    <p class="text-gray-300">9 Concurrent work 36</p>

    <p class="text-gray-300">10 Conclusion 36</p>

    <p class="text-gray-300">Acknowledgments 37</p>

    <p class="text-gray-300">A Overview of Bitcoin and Zerocoin 38 A.1 Bitcoin 38 A.2 Zerocoin 38</p>

    <p class="text-gray-300">B Completeness of DAP schemes 39</p>

    <p class="text-gray-300">C Security of DAP schemes 40 C.1 Ledger indistinguishability 41 C.2 Transaction non-malleability 42 C.3 Balance 43</p>

    <p class="text-gray-300">D Proof of Theorem 4.1 44 D.1 Proof of ledger indistinguishability 44 D.2 Proof of transaction non-malleability 48 D.3 Proof of balance 51</p>

    <p class="text-gray-300">References 54</p>

    <p class="text-gray-300">3</p>

    <p class="text-gray-300">Bitcoin is the first digital currency to achieve widespread adoption. The currency owes its rise in part to the fact that, unlike traditional e-cash schemes [Cha82, CHL05, ST99], it requires no trusted parties. Instead of appointing a central bank, Bitcoin uses a distributed ledger known as the <em>block chain</em> to store transactions carried out between users. Because the block chain is massively replicated by mutually-distrustful peers, the information it contains is public.</p>

    <p class="text-gray-300">While users may employ many identities (or <em>pseudonyms</em>) to enhance their privacy, an increasing body of research shows that anyone can <em>de-anonymize</em> Bitcoin by using information in the block chain [RM11, BBSU12, RS12, MPJ⁺¹³], such as the structure of the transaction graph as well as the value and dates of transactions. As a result, Bitcoin fails to offer even a modicum of the privacy provided by traditional payment systems, let alone the robust privacy of anonymous e-cash schemes.</p>

    <p class="text-gray-300">While Bitcoin is not anonymous itself, those with sufficient motivation can obfuscate their transaction history with the help of <em>mixes</em> (also known as <em>laundries</em> or <em>tumblers</em>). A mix allows users to entrust a set of coins to a pool operated by a central party and then, after some interval, retrieve different coins (with the same total value) from the pool. However, mixes suffer from three limitations: (i) the delay to reclaim coins must be large to allow enough coins to be mixed in; (ii) the mix operator can trace coins; and (iii) the mix operator may steal coins.¹ For users with “something to hide”, these risks may be acceptable. But typical legitimate users (1) wish to keep their spending habits private from their peers, (2) are risk-averse and do not wish to expend continual effort in protecting their privacy, and (3) are often not sufficiently aware that their privacy has been compromised.</p>

    <p class="text-gray-300">To protect their <em>privacy</em>, users thus need an instant, risk-free, and, most importantly, automatic guarantee that data revealing their spending habits and account balances is not publicly accessible by their neighbors, co-workers, and the merchants with whom they do business. Anonymous transactions also ensure that the market value of a coin is independent of its history, thus ensuring that legitimate users’ coins remain <em>fungible</em>.²</p>

    <p class="text-gray-300"><strong>Zerocoin: a decentralized mix.</strong> Miers et al. [MGGR13] proposed Zerocoin, which extends Bitcoin to provide strong anonymity guarantees. Like many e-cash protocols (e.g., [CHL05]), Zerocoin employs zero-knowledge proofs to prevent transaction graph analyses. Unlike earlier practical e-cash protocols, however, Zerocoin does not rely on digital signatures to validate coins, nor does it require a central bank to prevent double spending. Instead, Zerocoin authenticates coins by proving, in zero-knowledge, that they belong to a public list of valid coins (which can be maintained on the block chain). Yet rather than a full-fledged anonymous currency, Zerocoin is a <em>decentralized mix</em>, where users may periodically “wash” their bitcoins via the Zerocoin protocol. Routine day-to-day transactions must be conducted via Bitcoin, due to reasons that we now review.</p>

    <p class="text-gray-300">The first reason is performance. Redeeming zerocoins requires double-discrete-logarithm proofs of knowledge, which have size that exceeds 45 kB and require 450 ms to verify (at the 128-bit security level).³ These proofs must be broadcast through the network, verified by every node, and permanently stored in the ledger. The entailed costs are higher, by orders of magnitude, than those in Bitcoin and can seriously tax a Bitcoin network operating at normal scale.</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300">¹CoinJoin [Max13], an alternative proposal, replaces the central party of a mix with multi-signature transactions that involve many collaborating Bitcoin users. CoinJoin can thus only mix small volumes of coins amongst users who are currently online, is prone to denial-of-service attacks by third parties, and requires effort to find mixing partners.</p>

    <p class="text-gray-300">²While the methods we detail in this paper accomplish this, the same techniques open the door for privacy-preserving accountability and oversight (see Section 10).</p>

    <p class="text-gray-300">³These published numbers [MGGR13] actually use a mix of parameters at both 128-bit and 80-bit security for different components of the construction. The cost is higher if all parameters are instantiated at 128-bit security.</p>

    <p class="text-gray-300">The second reason is functionality. While Zerocoin constitutes a basic e-cash scheme, it lacks critical features required of full-fledged anonymous payments. First, Zerocoin uses coins of fixed denomination: it does not support payments of exact values, nor does it provide a means to give change following a transaction (i.e., divide coins). Second, Zerocoin has no mechanism for one user to pay another one directly in “zerocoins”. And third, while Zerocoin provides anonymity by unlinking a payment transaction from its origin address, it does not hide the amount or other metadata about transactions occurring on the network.</p>

    <p class="text-gray-300">Our contribution. Addressing this challenge, this work offers two main contributions.</p>

    <p class="text-gray-300">(1) We introduce the notion of a <em>decentralized anonymous payment scheme</em>, which formally captures the functionality and security guarantees of a full-fledged decentralized electronic currency with strong anonymity guarantees. We provide a construction of this primitive and prove its security under specific cryptographic assumptions. The construction leverages recent advances in the area of zero-knowledge proofs. Specifically, it uses <em>zero-knowledge Succinct Non-interactive ARguments of Knowledge</em> (zk-SNARKs) <em>[x11, x14, BCI^{+}13, x10, x11, BCG^{+}13, x12, x1, x13]</em>.</p>

    <p class="text-gray-300">(2) We implement the above primitive, via a system that we call Zerocash. Our system (at 128 bits of security):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>reduces the size of transactions spending a coin to under 1 kB (an improvement of over 97.7%);</li>

      <li>reduces the spend-transaction verification time to under 6 ms (an improvement of over 98.6%);</li>

      <li>allows for anonymous transactions of variable amounts;</li>

      <li>hides transaction amounts and the values of coins held by users; and</li>

      <li>allows for payments to be made directly to a user’s fixed address (without user interaction).</li>

    </ul>

    <p class="text-gray-300">To validate our system, we measured its performance and established feasibility by conducting experiments in a test network of 1000 nodes (approximately <span class="math">\\frac{1}{16}</span> of the unique IPs in the Bitcoin network and <span class="math">\\frac{1}{3}</span> of the nodes reachable at any given time <em>[x12]</em>). This inspires confidence that Zerocash can be deployed as a fork of Bitcoin and operate at the same scale. Thus, due to its substantially improved functionality and performance, Zerocash makes it possible to entirely replace traditional Bitcoin payments with anonymous alternatives.</p>

    <p class="text-gray-300">Concurrent work. The idea of using zk-SNARKs in the Bitcoin setting was first presented by one of the authors at Bitcoin 2013 <em>[x2]</em>. In concurrent work, Danezis et al. <em>[x7]</em> suggest using zk-SNARKs to reduce proof size and verification time in Zerocoin; see Section 9 for a comparison.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 zk-SNARKs</h3>

    <p class="text-gray-300">A zk-SNARK is an efficient variant of a <em>zero-knowledge proof of knowledge</em> <em>[x11]</em>, which we first informally describe via an example. Suppose Alice wishes to prove to Bob the statement <em>“I (Alice) own 30 bitcoins”</em>. A simple method for Alice to do so is to point to 30 coins on the block chain and, for each of them, sign a message (“hello, world”) using the secret key that controls that coin. Alas, this method <em>leaks knowledge</em> to Bob, by identifying which coins are Alice’s. A zero-knowledge proof of knowledge allows Alice to achieve the same goal, while revealing <em>no information</em> to Bob (beyond the fact that she <em>knows</em> some secret keys that control 30 coins). Crucially, such proofs can be obtained for any statement that can be verified to be true by use of an efficient computation involving auxiliary inputs such as trapdoors and passwords (such statements are called “NP statements”).</p>

    <p class="text-gray-300">We now sketch in more technical terms the definition of a zk-SNARK; see Section 2 for more details. A zk-SNARK is a non-interactive zero-knowledge proof of knowledge that is <em>succinct</em>, i.e., for which proofs are very short and easy to verify. More precisely, let <span class="math">\\mathcal{L}</span> be an NP language, and let <span class="math">C</span> be a nondeterministic decision circuit for <span class="math">\\mathcal{L}</span> on a given instance size <span class="math">n</span>. A zk-SNARK can be used</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">to prove and verify membership in <span class="math">\\mathcal{L}</span>, for instances of size <span class="math">n</span>, as follows. After taking <span class="math">C</span> as input, a trusted party conducts a one-time setup phase that results in two public keys: a proving key <span class="math">\\mathsf{pk}</span> and a verification key <span class="math">\\mathsf{vk}</span>. The proving key <span class="math">\\mathsf{pk}</span> enables any (untrusted) prover to produce a proof <span class="math">\\pi</span> attesting to the fact that <span class="math">x\\in\\mathcal{L}</span>, for an instance <span class="math">x</span> (of size <span class="math">n</span>) of his choice. The non-interactive proof <span class="math">\\pi</span> is <em>zero knowledge</em> and a <em>proof of knowledge</em>. Anyone can use the verification key <span class="math">\\mathsf{vk}</span> to verify the proof <span class="math">\\pi</span>; in particular zk-SNARK proofs are publicly verifiable: anyone can verify <span class="math">\\pi</span>, without ever having to interact with the prover who generated <span class="math">\\pi</span>. Succinctness requires that (for a given security level) <span class="math">\\pi</span> has <em>constant size</em> and can be verified in time that is linear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (rather than linear in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Centralized anonymous payment systems</h3>

    <p class="text-gray-300">Before describing our new decentralized payment system, we put it in context by recalling two pre-Bitcoin payment schemes, both of which relied on a <em>bank</em>, acting as a central trusted party.</p>

    <p class="text-gray-300">Anonymous e-cash. Chaum <em>[x1]</em> first obtained anonymous e-cash. In Chaum’s scheme, the minting of a coin involves both a user, Alice, and the bank: to mint a coin of a given value <span class="math">v</span>, Alice first selects a random secret serial number <span class="math">\\mathsf{sn}</span> (unknown to the bank); then, the bank, after deducting <span class="math">v</span> from Alice’s balance, signs <span class="math">\\mathsf{sn}</span> via a <em>blind signature</em>. Afterwards, if Alice wants to transfer her coin to Bob, she reveals <span class="math">\\mathsf{sn}</span> to him and proves that <span class="math">\\mathsf{sn}</span> was signed by the bank; during this transfer, Bob (or the bank) cannot deduce Alice’s identity from the revealed information. Double-spending is prevented because the bank will not honor a coin with a previously-seen serial number.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unforgeable e-cash. One problem with Chaum’s scheme is that coins can be forged if the bank’s secret key is compromised. Sander and Ta-Shma <em>[x20]</em> addressed this, as follows. The bank maintains a public Merkle tree of “coin commitments”, and users periodically retrieve its root <span class="math">\\mathsf{rt}</span>; in particular, the bank maintains no secrets. When Alice requests a coin (of unit value), she picks a random serial number <span class="math">\\mathsf{sn}</span> and auxiliary string <span class="math">r</span>, and then sends $\\mathsf{cm}:=\\mathsf{CRH}(\\mathsf{sn}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)<span class="math"> to the bank, where </span>\\mathsf{CRH}<span class="math"> is a collision-resistant hash; the bank deducts the appropriate amount from Alice’s balance and then records </span>\\mathsf{cm}<span class="math"> as a leaf in the Merkle tree. Afterwards, to pay Bob, Alice sends him </span>\\mathsf{sn}<span class="math"> along with a zero-knowledge proof of knowledge </span>\\pi<span class="math"> of the following </span>\\mathsf{NP}<span class="math"> statement: *“there exists </span>r<span class="math"> such that </span>\\mathsf{CRH}(\\mathsf{sn}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)<span class="math"> is a leaf in a Merkle tree with root </span>\\mathsf{rt}<span class="math">”<em>. In other words, Alice can convince Bob that </span>\\mathsf{sn}<span class="math"> is the serial number contained in </em>some* coin commitment in the Merkle tree; but the zero-knowledge property prevents Bob from learning information about which coin commitment is Alice’s, thereby protecting Alice’s identity. Later, Bob can “cash out” Alice’s coin by showing </span>\\mathsf{sn}<span class="math"> and </span>\\pi$ to the bank.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moving to a fungible anonymous decentralized system. In this paper, like <em>[x20]</em>, we hash a coin’s serial number and use Merkle trees to compactly represent the set of minted coins. Unlike <em>[x20]</em>, we also ensure the privacy of a coin’s value and support transactions that split and merge coins, thus achieving (and implementing) a new kind of fully-fungible and divisible payment scheme. As in Bitcoin (and in stark contrast to previous e-cash schemes), we do not rely on a trusted bank. Therefore, we require a new set of definitions and protocols, designed to protect Alice’s anonymity while preventing her from falsely increasing her balance under the veil of her boosted privacy. An informal description of our payment scheme follows.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.3 Decentralized anonymous payment schemes</h3>

    <p class="text-gray-300">We construct a <em>decentralized anonymous payment (DAP) scheme</em>, which is a decentralized e-cash scheme that allows direct anonymous payments of any amount. See Section 3 for a formal definition.</p>

    <p class="text-gray-300">Here, we outline our construction in six incremental steps; the construction details are in Section 4.</p>

    <p class="text-gray-300">Our construction functions on top of any ledger-based base currency, such as Bitcoin. At any given time, a unique valid snapshot of the currency’s <em>ledger</em> is available to all users. The ledger is a sequence of <em>transactions</em> and is append-only. Transactions include both the underlying currency’s transactions, as well as new transactions introduced by our construction. For concreteness, we focus the discussion below on Bitcoin (though later definitions and constructions are stated abstractly). We assume familiarity with Bitcoin <em>[x21]</em> and Zerocoin <em>[x18]</em>; both are reviewed in Appendix A.</p>

    <p class="text-gray-300">Step 1: user anonymity with fixed-value coins. We first describe a simplified construction, in which all coins have the same value of, e.g., 1 BTC. This construction, similar to the Zerocoin protocol, shows how to hide a payment’s origin. In terms of tools, we make use of zk-SNARKs (recalled above) and a commitment scheme. Let COMM denote a statistically-hiding non-interactive commitment scheme (i.e., given randomness <span class="math">r</span> and message <span class="math">m</span>, the commitment is <span class="math">c:=\\textsf{COMM}_{r}(m)</span>; subsequently, <span class="math">c</span> is opened by revealing <span class="math">r</span> and <span class="math">m</span>, and one can verify that <span class="math">\\textsf{COMM}_{r}(m)</span> equals <span class="math">c</span>).</p>

    <p class="text-gray-300">In the simplified construction, a new coin c is minted as follows: a user <span class="math">u</span> samples a random <em>serial number</em> sn and a <em>trapdoor</em> <span class="math">r</span>, computes a <em>coin commitment</em> cm <span class="math">:=\\textsf{COMM}_{r}(\\textsf{sn})</span>, and sets c <span class="math">:=(r,\\textsf{sn},\\textsf{cm})</span>. A corresponding mint transaction <span class="math">\\textsf{tx}_{\\textsf{Mint}}</span>, containing cm (but not sn or <span class="math">r</span>), is sent to the ledger; <span class="math">\\textsf{tx}_{\\textsf{Mint}}</span> is appended to the ledger only if <span class="math">u</span> has paid 1 BTC to a backing escrow pool (e.g., the 1 BTC may be paid via plaintext information encoded in <span class="math">\\textsf{tx}_{\\textsf{Mint}}</span>). Mint transactions are thus certificates of deposit, deriving their value from the backing pool.</p>

    <p class="text-gray-300">Subsequently, letting CMList denote the list of all coin commitments on the ledger, <span class="math">u</span> may spend c by posting a spend transaction <span class="math">\\textsf{tx}_{\\textsf{Spend}}</span> that contains (i) the coin’s serial number sn; and (ii) a zk-SNARK proof <span class="math">\\pi</span> of the NP statement <em>“I know <span class="math">r</span> such that <span class="math">\\textsf{COMM}_{r}(\\textsf{sn})</span> appears in the list CMList of coin commitments”</em>. Assuming that sn does not already appear on the ledger (as part of a past spend transaction), <span class="math">u</span> can redeem the deposited amount of 1 BTC, which <span class="math">u</span> can either keep, transfer to someone else, or mint a new coin. (If sn does already appear on the ledger, this is considered double spending, and the transaction is discarded.)</p>

    <p class="text-gray-300">User anonymity is achieved because the proof <span class="math">\\pi</span> is zero-knowledge: while sn is revealed, no information about <span class="math">r</span> is, and finding which of the numerous commitments in CMList corresponds to a particular spend transaction <span class="math">\\textsf{tx}_{\\textsf{Spend}}</span> is equivalent to inverting <span class="math">f(x):=\\textsf{COMM}_{x}(\\textsf{sn})</span>, which is assumed to be infeasible. Thus, the origin of the payment is anonymous.</p>

    <p class="text-gray-300">Step 2: compressing the list of coin commitments. In the above NP statement, CMList is specified explicitly as a list of coin commitments. This naive representation severely limits scalability because the time and space complexity of most protocol algorithms (e.g., the proof verification algorithm) grow linearly with CMList. Moreover, coin commitments corresponding to already-spent coins cannot be dropped from CMList to reduce costs, since they cannot be identified (due to the same zero-knowledge property that provides anonymity).</p>

    <p class="text-gray-300">As in <em>[x24]</em>, we rely on a collision-resistant function CRH to avoid an explicit representation of CMList. We maintain an efficiently-updatable append-only CRH-based Merkle tree Tree(CMList) over the (growing) list CMList and let rt denote the root of Tree(CMList). It is well-known that rt can be updated to account for the insertion of new leaves with time and space proportional to just the tree depth. Hence, the time and space complexity is reduced from linear in the size of CMList to logarithmic. With this in mind, we modify the NP statement to the following one: <em>“I know <span class="math">r</span> such that <span class="math">\\textsf{COMM}_{r}(\\textsf{sn})</span> appears as a leaf in a CRH-based Merkle tree whose root is <span class="math">\\textsf{rt}</span>”</em>. Compared with the naive data structure for CMList, this modification increases exponentially the size of CMList that a given zk-SNARK implementation can support. (Concretely: using Merkle trees of depth 64, Zerocash supports 2^{64} coins.)</p>

    <p class="text-gray-300">Step 3: extending coins for direct anonymous payments. So far, the coin commitment</p>

    <p class="text-gray-300"><span class="math">\\mathbf{cm}</span> of a coin <span class="math">\\mathbf{c}</span> is a commitment to the coin’s serial number <span class="math">\\mathsf{sn}</span>. However, this creates a problem when transferring <span class="math">\\mathbf{c}</span> to another user. Indeed, suppose that a user <span class="math">u_{A}</span> created <span class="math">\\mathbf{c}</span>, and <span class="math">u_{A}</span> sends <span class="math">\\mathbf{c}</span> to another user <span class="math">u_{B}</span>. First, since <span class="math">u_{A}</span> knows <span class="math">\\mathsf{sn}</span>, the spending of <span class="math">\\mathbf{c}</span> by <span class="math">u_{B}</span> is both non-anonymous (since <span class="math">u_{A}</span> sees when <span class="math">\\mathbf{c}</span> is spent, by recognizing <span class="math">\\mathsf{sn}</span>) and risky (since <span class="math">u_{A}</span> could still spend <span class="math">\\mathbf{c}</span> first). Thus, <span class="math">u_{B}</span> must immediately spend <span class="math">\\mathbf{c}</span> and mint a new coin <span class="math">\\mathbf{c}^{\\prime}</span> to protect himself. Second, if <span class="math">u_{A}</span> in fact wants to transfer to <span class="math">u_{B}</span>, e.g., 100 BTC, then doing so is both unwieldy (since it requires 100 transfers) and non-anonymous (since the amount of the transfer is leaked). And third, transfers in amounts that are not multiples of 1 BTC (the fixed value of a coin) are not supported. Thus, the simplified construction described is inadequate as a payment scheme.</p>

    <p class="text-gray-300">We address this by modifying the derivation of a coin commitment, and using pseudorandom functions to target payments and to derive serial numbers, as follows. We use three pseudorandom functions (derived from a single one). For a seed <span class="math">x</span>, these are denoted <span class="math">\\mathsf{PRF}_{x}^{\\mathrm{addr}}(\\cdot)</span>, <span class="math">\\mathsf{PRF}_{x}^{\\mathrm{sn}}(\\cdot)</span>, and <span class="math">\\mathsf{PRF}_{x}^{\\mathrm{pk}}(\\cdot)</span>. We assume that <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}</span> is moreover collision-resistant.</p>

    <p class="text-gray-300">To provide targets for payments, we use <em>addresses</em>: each user <span class="math">u</span> generates an address key pair <span class="math">(a_{\\mathsf{pk}},a_{\\mathsf{sk}})</span>, the <em>address public key</em> and <em>address private key</em> respectively. The coins of <span class="math">u</span> contain the value <span class="math">a_{\\mathsf{pk}}</span> and can be spent only with knowledge of <span class="math">a_{\\mathsf{sk}}</span>. A key pair <span class="math">(a_{\\mathsf{pk}},a_{\\mathsf{sk}})</span> is sampled by selecting a random seed <span class="math">a_{\\mathsf{sk}}</span> and setting <span class="math">a_{\\mathsf{pk}}:=\\mathsf{PRF}_{a_{\\mathsf{sk}}}^{\\mathrm{addr}}(0)</span>. A user can generate and use any number of address key pairs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we redesign minting to allow for greater functionality. To mint a coin <span class="math">\\mathbf{c}</span> of a desired value <span class="math">v</span>, the user <span class="math">u</span> first samples <span class="math">\\rho</span>, which is a secret value that determines the coin’s serial number as <span class="math">\\mathsf{sn}:=\\mathsf{PRF}_{a_{\\mathsf{sk}}}^{\\mathrm{sn}}(\\rho)</span>. Then, <span class="math">u</span> commits to the tuple <span class="math">(a_{\\mathsf{pk}},v,\\rho)</span> in two phases: (a) <span class="math">u</span> computes $k:=\\mathsf{COMM}_{r}(a_{\\mathsf{pk}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math"> for a random </span>r<span class="math">; and then (b) </span>u<span class="math"> computes </span>\\mathsf{cm}:=\\mathsf{COMM}_{s}(v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k)<span class="math"> for a random </span>s<span class="math">. The minting results in a coin </span>\\mathbf{c}:=(a_{\\mathsf{pk}},v,\\rho,r,s,\\mathsf{cm})<span class="math"> and a mint transaction </span>\\mathsf{tx}_{\\mathsf{Mint}}:=(v,k,s,\\mathsf{cm})<span class="math">. Crucially, due to the nested commitment, anyone can verify that </span>\\mathsf{cm}<span class="math"> in </span>\\mathsf{tx}_{\\mathsf{Mint}}<span class="math"> is a coin commitment of a coin of value </span>v<span class="math"> (by checking that </span>\\mathsf{COMM}_{s}(v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k)<span class="math"> equals </span>\\mathsf{cm}<span class="math">) but cannot discern the owner (by learning the address key </span>a_{\\mathsf{pk}}<span class="math">) or serial number (derived from </span>\\rho<span class="math">) because these are hidden in </span>k<span class="math">. As before, </span>\\mathsf{tx}_{\\mathsf{Mint}}<span class="math"> is accepted by the ledger only if </span>u<span class="math"> deposits the correct amount, in this case </span>v$ BTC.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Coins are spent using the <em>pour</em> operation, which takes a set of input coins, to be consumed, and “pours” their value into a set of fresh output coins — such that the total value of output coins equals the total value of the input coins. Suppose that <span class="math">u</span>, with address key pair <span class="math">(a_{\\mathsf{pk}}^{\\mathsf{old}},a_{\\mathsf{sk}}^{\\mathsf{old}})</span>, wishes to consume his coin <span class="math">\\mathbf{c}^{\\mathsf{old}}=(a_{\\mathsf{pk}}^{\\mathsf{old}},v^{\\mathsf{old}},\\rho^{\\mathsf{old}},r^{\\mathsf{old}},s^{\\mathsf{old}},\\mathsf{cm}^{\\mathsf{old}})</span> and produce two new coins <span class="math">\\mathbf{c}_{1}^{\\mathsf{new}}</span> and <span class="math">\\mathbf{c}_{2}^{\\mathsf{new}}</span>, with total value <span class="math">v_{1}^{\\mathsf{new}}+v_{2}^{\\mathsf{new}}=v^{\\mathsf{old}}</span>, respectively targeted at address public keys <span class="math">a_{\\mathsf{pk},1}^{\\mathsf{new}}</span> and <span class="math">a_{\\mathsf{pk},2}^{\\mathsf{new}}</span>. (The addresses <span class="math">a_{\\mathsf{pk},1}^{\\mathsf{new}}</span> and <span class="math">a_{\\mathsf{pk},2}^{\\mathsf{new}}</span> may belong to <span class="math">u</span> or to some other user.) The user <span class="math">u</span>, for each <span class="math">i\\in\\{1,2\\}</span>, proceeds as follows: (i) <span class="math">u</span> samples serial number randomness <span class="math">\\rho_{i}^{\\mathsf{new}}</span>; (ii) <span class="math">u</span> computes $k_{i}^{\\mathsf{new}}:=\\mathsf{COMM}_{r_{i}^{\\mathsf{new}}}(a_{\\mathsf{pk},i}^{\\mathsf{new}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{i}^{\\mathsf{new}})<span class="math"> for a random </span>r_{i}^{\\mathsf{new}}<span class="math">; and (iii) </span>u<span class="math"> computes </span>\\mathsf{cm}_{i}^{\\mathsf{new}}:=\\mathsf{COMM}_{s_{i}^{\\mathsf{new}}}(v_{i}^{\\mathsf{new}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{i}^{\\mathsf{new}})<span class="math"> for a random </span>s_{i}^{\\mathsf{new}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This yields the coins <span class="math">\\mathbf{c}_{1}^{\\mathsf{new}}:=(a_{\\mathsf{pk},1}^{\\mathsf{new}},v_{1}^{\\mathsf{new}},\\rho_{1}^{\\mathsf{new}},r_{1}^{\\mathsf{new}},s_{1}^{\\mathsf{new}},\\mathsf{cm}_{1}^{\\mathsf{new}})</span> and <span class="math">\\mathbf{c}_{2}^{\\mathsf{new}}:=(a_{\\mathsf{pk},2}^{\\mathsf{new}},v_{2}^{\\mathsf{new}},\\rho_{2}^{\\mathsf{new}}</span>, <span class="math">r_{2}^{\\mathsf{new}},s_{2}^{\\mathsf{new}},\\mathsf{cm}_{2}^{\\mathsf{new}})</span>. Next, <span class="math">u</span> produces a zk-SNARK proof <span class="math">\\pi_{\\mathsf{POUR}}</span> for the following NP statement, which we call POUR:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“Given the Merkle-tree root <span class="math">\\mathsf{rt}</span>, serial number <span class="math">\\mathsf{sn}^{\\mathsf{old}}</span>, and coin commitments <span class="math">\\mathsf{cm}_{1}^{\\mathsf{new}},\\mathsf{cm}_{2}^{\\mathsf{new}}</span>, I know coins <span class="math">\\mathbf{c}^{\\mathsf{old}},\\mathbf{c}_{1}^{\\mathsf{new}},\\mathbf{c}_{2}^{\\mathsf{new}}</span>, and address secret key <span class="math">a_{\\mathsf{sk}}^{\\mathsf{old}}</span> such that:

- The coins are well-formed: for <span class="math">\\mathbf{c}^{\\mathsf{old}}</span> it holds that <span class="math">k^{\\mathsf{old}}=\\mathsf{COMM}_{r^{\\mathsf{old}}}(a_{\\mathsf{pk}}^{\\mathsf{old}}\\|\\rho^{\\mathsf{old}})</span> and <span class="math">\\mathsf{cm}^{\\mathsf{old}}=\\mathsf{COMM}_{s^{\\mathsf{old}}}(v^{\\mathsf{old}}\\|k^{\\mathsf{old}})</span>; and similarly for <span class="math">\\mathbf{c}_{1}^{\\mathsf{new}}</span> and <span class="math">\\mathbf{c}_{2}^{\\mathsf{new}}</span>.
- The address secret key matches the public key: <span class="math">a_{\\mathsf{pk}}^{\\mathsf{old}}=\\mathsf{PRF}_{a_{\\mathsf{sk}}^{\\mathsf{old}}}^{\\mathrm{addr}}(0)</span>.
- The serial number is computed correctly: <span class="math">\\mathsf{sn}^{\\mathsf{old}}:=\\mathsf{PRF}_{a_{\\mathsf{sk}}^{\\mathsf{old}}}^{\\mathrm{sn}}(\\rho^{\\mathsf{old}})</span>.
- The coin commitment <span class="math">\\mathsf{cm}^{\\mathsf{old}}</span> appears as a leaf of a Merkle-tree with root <span class="math">\\mathsf{rt}</span>.
- The values add up: <span class="math">v_{1}^{\\mathsf{new}}+v_{2}^{\\mathsf{new}}=v^{\\mathsf{old}}</span>.”</p>
    </blockquote>

    <p class="text-gray-300">A resulting pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}} := (\\mathsf{rt}, \\mathsf{sn}^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, \\pi_{\\mathsf{POUR}})</span> is appended to the ledger. (As before, the transaction is rejected if the serial number <span class="math">\\mathsf{sn}</span> appears in a previous transaction.)</p>

    <p class="text-gray-300">Now suppose that <span class="math">u</span> does not know, say, the address secret key <span class="math">a_{\\mathsf{sk},1}^{\\mathsf{new}}</span> that is associated with the public key <span class="math">a_{\\mathsf{pk},1}^{\\mathsf{new}}</span>. Then, <span class="math">u</span> cannot spend <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> because he cannot provide <span class="math">a_{\\mathsf{sk},1}^{\\mathsf{new}}</span> as part of the witness of a subsequent pour operation. Furthermore, when a user who knows <span class="math">a_{\\mathsf{sk},1}^{\\mathsf{new}}</span> does spend <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>, the user <span class="math">u</span> cannot track it, because he knows no information about its revealed serial number, which is <span class="math">\\mathsf{sn}_1^{\\mathsf{new}} := \\mathsf{PRF}_{a_{\\mathsf{sk},1}^{\\mathsf{new}}}^{\\mathsf{sn}}(\\rho_1^{\\mathsf{new}})</span>.</p>

    <p class="text-gray-300">Also observe that <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> reveals no information about how the value of the consumed coin was divided among the two new fresh coins, nor which coin commitment corresponds to the consumed coin, nor the address public keys to which the two new fresh coins are targeted. The payment was conducted in full anonymity.</p>

    <p class="text-gray-300">More generally, a user may pour <span class="math">N^{\\mathrm{old}} \\geq 0</span> coins into <span class="math">N^{\\mathrm{new}} \\geq 0</span> coins. For simplicity we consider the case <span class="math">N^{\\mathrm{old}} = N^{\\mathrm{new}} = 2</span>, without loss of generality. Indeed, for <span class="math">N^{\\mathrm{old}} &amp;lt; 2</span>, the user can mint a coin with value 0 and then provide it as a "null" input, and for <span class="math">N^{\\mathrm{new}} &amp;lt; 2</span>, the user can create (and discard) a new coin with value 0. For <span class="math">N^{\\mathrm{old}} &amp;gt; 2</span> or <span class="math">N^{\\mathrm{new}} &amp;gt; 2</span>, the user can compose <span class="math">\\log N^{\\mathrm{old}} + \\log N^{\\mathrm{new}}</span> of the 2-input/2-output pours.</p>

    <p class="text-gray-300">Step 4: sending coins. Suppose that <span class="math">a_{\\mathsf{pk},1}^{\\mathsf{new}}</span> is the address public key of <span class="math">u_{1}</span>. In order to allow <span class="math">u_{1}</span> to actually spend the new coin <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> produced above, <span class="math">u</span> must somehow send the secret values in <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> to <span class="math">u_{1}</span>. One way is for <span class="math">u</span> to send <span class="math">u_{1}</span> a private message, but the requisite private communication channel necessitates additional infrastructure or assumptions. We avoid this "out-of-band" channel and instead build this capability directly into our construction by leveraging the ledger as follows.</p>

    <p class="text-gray-300">We modify the structure of an address key pair. Each user now has a key pair <span class="math">(\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}})</span>, where <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}})</span> and <span class="math">\\mathsf{addr}_{\\mathsf{sk}} = (a_{\\mathsf{sk}}, \\mathsf{sk}_{\\mathsf{enc}})</span>. The values <span class="math">(a_{\\mathsf{pk}}, a_{\\mathsf{sk}})</span> are generated as before. In addition, <span class="math">(\\mathsf{pk}_{\\mathsf{enc}}, \\mathsf{sk}_{\\mathsf{enc}})</span> is a key pair for a key-private encryption scheme [BBDP01].</p>

    <p class="text-gray-300">Then, <span class="math">u</span> computes the ciphertext <span class="math">\\mathbf{C}_1</span> that is the encryption of the plaintext <span class="math">(v_1^{\\mathrm{new}}, \\rho_1^{\\mathrm{new}}, r_1^{\\mathrm{new}}, s_1^{\\mathrm{new}})</span>, under <span class="math">\\mathsf{pk}_{\\mathsf{enc},1}^{\\mathsf{new}}</span> (which is part of <span class="math">u_1</span>'s address public key <span class="math">\\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{new}}</span>), and includes <span class="math">\\mathbf{C}_1</span> in the pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>. The user <span class="math">u_1</span> can then find and decrypt this message (using his <span class="math">\\mathsf{sk}_{\\mathsf{enc},1}^{\\mathsf{new}}</span>) by scanning the pour transactions on the public ledger. Again, note that adding <span class="math">\\mathbf{C}_1</span> to <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> leaks neither paid amounts, nor target addresses due to the key-private property of the encryption scheme. (The user <span class="math">u</span> does the same with <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span> and includes a corresponding ciphertext <span class="math">\\mathbf{C}_2</span> in <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>.)</p>

    <p class="text-gray-300">Step 5: public outputs. The construction so far allows users to mint, merge, and split coins. But how can a user redeem one of his coins, i.e., convert it back to the base currency (Bitcoin)? For this, we modify the pour operation to include a public output. When spending a coin, the user <span class="math">u</span> also specifies a nonnegative <span class="math">v_{\\mathsf{pub}}</span> and a transaction string <span class="math">\\mathsf{info} \\in \\{0,1\\}^*</span>. The balance equation in the NP statement POUR is changed accordingly: “<span class="math">v_1^{\\mathsf{new}} + v_2^{\\mathsf{new}} + v_{\\mathsf{pub}} = v^{\\mathsf{old}}</span>”. Thus, of the input value <span class="math">v^{\\mathsf{old}}</span>, a part <span class="math">v_{\\mathsf{pub}}</span> is publicly declared, and its target is specified, somehow, by the string info. The string info can be used to specify the destination of these redeemed funds (e.g., a Bitcoin wallet public key). Both <span class="math">v_{\\mathsf{pub}}</span> and info are now included in the resulting pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>. (The public output is optional, as the user <span class="math">u</span> can set <span class="math">v_{\\mathsf{pub}} = 0</span>.)</p>

    <p class="text-gray-300">Step 6: non-malleability. To prevent malleability attacks on a pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> (e.g., embezzlement by re-targeting the public output of the pour by modifying info), we further modify the NP statement POUR and use digital signatures. Specifically, during the pour operation, the user <span class="math">u</span> (i) samples a key pair <span class="math">(\\mathsf{pk}_{\\mathsf{sig}}, \\mathsf{sk}_{\\mathsf{sig}})</span> for a one-time signature scheme; (ii) computes <span class="math">h_{\\mathsf{Sig}} := \\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}})</span>; (iii) computes the two values <span class="math">h_1 := \\mathsf{PRF}_{a_{\\mathsf{sk},1}^{\\mathsf{pk}}}^{\\mathsf{pk}}(h_{\\mathsf{Sig}})</span> and <span class="math">h_2 := \\mathsf{PRF}_{a_{\\mathsf{sk},2}^{\\mathsf{pk}}}^{\\mathsf{pk}}(h_{\\mathsf{Sig}})</span>, which act as MACs to</p>

    <p class="text-gray-300">5These public outputs can be considered as an "input" to a Bitcoin-style transaction, where the string info contains the Bitcoin output scripts. This mechanism also allows us to support Bitcoin's public transaction fees.</p>

    <p class="text-gray-300">"tie"  <span class="math">h_{\\mathrm{Sig}}</span>  to both address secret keys; (iv) modifies POUR to include the three values  <span class="math">h_{\\mathrm{Sig}}, h_1, h_2</span>  and prove that the latter two are computed correctly; and (v) uses  <span class="math">\\mathsf{sk}_{\\mathrm{sig}}</span>  to sign every value associated with the pour operation, thus obtaining a signature  <span class="math">\\sigma</span> , which is included, along with  <span class="math">\\mathsf{pk}_{\\mathrm{sig}}</span> , in  <span class="math">\\mathsf{tx}_{\\mathrm{Pour}}</span> . Since the  <span class="math">a_{\\mathsf{sk},i}^{\\mathrm{old}}</span>  are secret, and with high probability  <span class="math">h_{\\mathrm{Sig}}</span>  changes for each pour transaction, the values  <span class="math">h_1, h_2</span>  are unpredictable. Moreover, the signature on the NP statement (and other values) binds all of these together, as argued in more detail in Appendix C and Appendix D.</p>

    <p class="text-gray-300">This ends the outline of the construction, which is summarized in part in Figure 1. We conclude by noting that, due to the zk-SNARK, our construction requires a one-time trusted setup of public parameters. The soundness of the proofs depends on this trust, though anonymity continues to hold even if the setup is corrupted by a malicious party.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) Merke tree over  <span class="math">(\\mathrm{cm}_1,\\mathrm{cm}_2,\\dots)</span> Figure 1: (a) Illustration of the CRH-based Merkle tree over the list CMList of coin commitments. (b) A coin c. (c) Illustration of the structure of a coin commitment cm. (d) Illustration of the structure of a coin serial number sn.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) coin <span class="math">\\mathbf{c} = ((\\mathbf{a}_{\\mathrm{pk}}\\cdot \\mathbf{pk}_{\\mathrm{enc}}),\\mathbf{v},\\rho ,\\mathbf{r},\\mathbf{s},\\mathbf{cm})</span> (c) coin commitment (d) serial number</p>

    <p class="text-gray-300">rt = Merkle-tree root cm = coin commitment sn = serial number v = coin value r,s = commitment rand. <span class="math">\\rho =</span>  serial number rand. (a pk pk enc) = address public key (a sk,sk enc) = address secret key</p>

    <p class="text-gray-300">We outline Zerocash, a concrete implementation, at 128 bits of security, of our DAP scheme construction; see Section 5 for details. Zerocash entails carefully instantiating the cryptographic ingredients of the construction to ensure that the zk-SNARK, the "heaviest" component, is efficient enough in practice. In the construction, the zk-SNARK is used to prove/verify a specific NP statement: POUR. While zk-SNARKs are asymptotically efficient, their concrete efficiency depends on the arithmetic circuit  <span class="math">C</span>  that is used to decide the NP statement. Thus, we seek instantiations for which we can design a relatively small arithmetic circuit  <span class="math">C_{\\text{POUR}}</span>  for verifying the NP statement POUR.</p>

    <p class="text-gray-300">Our approach is to instantiate all of the necessary cryptographic ingredients (commitment schemes, pseudorandom functions, and collision-resistant hashing) based on SHA256. We first design a hand-optimized circuit for verifying SHA256 computations (or, more precisely, its compression function, which suffices for our purposes). Then, we use this circuit to construct  <span class="math">C_{\\text{POUR}}</span> , which verifies all the necessary checks for satisfying the NP statement  <span class="math">C_{\\text{POUR}}</span> .</p>

    <p class="text-gray-300">This, along with judicious parameter choices, and a state-of-the-art implementation of a zk-SNARK for arithmetic circuits [BCTV14] (see Section 2.4), results in a zk-SNARK prover</p>

    <p class="text-gray-300">running time of a few minutes and zk-SNARK verifier running time of a few milliseconds. This allows the DAP scheme implementation to be practical for deployment, as our experiments show.</p>

    <p class="text-gray-300">Zerocash can be integrated into Bitcoin or forks of it (commonly referred to as "altcoins"); we later describe how this is done.</p>

    <h2 id="sec-9" class="text-2xl font-bold">1.5 Paper organization</h2>

    <p class="text-gray-300">The remainder of this paper is organized as follows. Section 2 provides background on zk-SNARKs. We define DAP schemes in Section 3, and our construction thereof in Section 4. Section 5 discusses the concrete instantiation in Zerocash. Section 6 describes the integration of Zerocash into existing ledger-based currencies. Section 7 provides microbenchmarks for our prototype implementation, as well as results based on full-network simulations. Section 8 describes optimizations. We discuss concurrent work in Section 9 and summarize our contributions and future directions in Section 10.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Background on zk-SNARKs</h2>

    <p class="text-gray-300">The main cryptographic primitive used in this paper is a special kind of <em>Succinct Non-interactive AR-gument of Knowledge</em> (SNARK). Concretely, we use a publicly-verifiable preprocessing zero-knowledge SNARK, or zk-SNARK for short. In this section we provide basic background on zk-SNARKs, provide an informal definition, compare zk-SNARKs with the more familiar notion of NIZKs, and recall known constructions and implementations.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2.1 Informal definition</h2>

    <p class="text-gray-300">We informally define zk-SNARKs for arithmetic circuit satisfiability. We refer the reader to, e.g., [BCI⁺13] for a formal definition.</p>

    <p class="text-gray-300">For a field <span class="math">\\mathbb{F}</span>, an <span class="math">\\mathbb{F}</span>-arithmetic circuit takes inputs that are elements in <span class="math">\\mathbb{F}</span>, and its gates output elements in <span class="math">\\mathbb{F}</span>. We naturally associate a circuit with the function it computes. To model nondeterminism we consider circuits that have an input <span class="math">x \\in \\mathbb{F}^n</span> and an auxiliary input <span class="math">a \\in \\mathbb{F}^h</span>, called a witness. The circuits we consider only have bilinear gates.⁷ Arithmetic circuit satisfiability is defined analogously to the boolean case, as follows.</p>

    <p class="text-gray-300"><strong>Definition 2.1.</strong> The arithmetic circuit satisfiability problem of an <span class="math">\\mathbb{F}</span>-arithmetic circuit <span class="math">C\\colon \\mathbb{F}^n\\times \\mathbb{F}^h\\to \\mathbb{F}^l</span> is captured by the relation <span class="math">\\mathcal{R}_C = \\{(x,a)\\in \\mathbb{F}^n\\times \\mathbb{F}^h\\colon C(x,a) = 0^l\\}</span>; its language is <span class="math">\\mathcal{L}_C = \\{x\\in \\mathbb{F}^n:\\exists a\\in \\mathbb{F}^h\\text{s.t.} C(x,a) = 0^l\\}</span>.</p>

    <p class="text-gray-300">Given a field <span class="math">\\mathbb{F}</span>, a (publicly-verifiable preprocessing) zk-SNARK for <span class="math">\\mathbb{F}</span>-arithmetic circuit satisfiability is a triple of polynomial-time algorithms (KeyGen, Prove, Verify):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen<span class="math">(1^{\\lambda}, C) \\to (\\mathsf{pk}, \\mathsf{vk})</span>. On input a security parameter <span class="math">\\lambda</span> (presented in unary) and an <span class="math">\\mathbb{F}</span>-arithmetic circuit <span class="math">C</span>, the key generator KeyGen probabilistically samples a proving key <span class="math">\\mathsf{pk}</span> and a verification key <span class="math">\\mathsf{vk}</span>. Both keys are published as public parameters and can be used, any number of times, to prove/verify membership in <span class="math">\\mathcal{L}_C</span>.</li>

      <li><span class="math">\\operatorname{Prove}(\\mathsf{pk}, x, a) \\to \\pi</span>. On input a proving key <span class="math">\\mathsf{pk}</span> and any <span class="math">(x, a) \\in \\mathcal{R}_C</span>, the prover <span class="math">\\operatorname{Prove}</span> outputs a non-interactive proof <span class="math">\\pi</span> for the statement <span class="math">x \\in \\mathcal{L}_C</span>.</li>

    </ul>

    <p class="text-gray-300">⁷ A gate with inputs <span class="math">y_1, \\ldots, y_m \\in \\mathbb{F}</span> is bilinear if the output is <span class="math">\\langle \\vec{a}, (1, y_1, \\ldots, y_m) \\rangle \\cdot \\langle \\vec{b}, (1, y_1, \\ldots, y_m) \\rangle</span> for some <span class="math">\\vec{a}, \\vec{b} \\in \\mathbb{F}^{m+1}</span>. These include addition, multiplication, negation, and constant gates.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify  <span class="math">(\\mathsf{vk}, x, \\pi) \\to b</span> . On input a verification key  <span class="math">\\mathsf{vk}</span> , an input  <span class="math">x</span> , and a proof  <span class="math">\\pi</span> , the verifier Verify outputs  <span class="math">b = 1</span>  if he is convinced that  <span class="math">x \\in \\mathcal{L}_C</span> .</li>

    </ul>

    <p class="text-gray-300">A zk-SNARK satisfies the following properties.</p>

    <p class="text-gray-300">Completeness. For every security parameter  <span class="math">\\lambda</span> , any  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C</span> , and any  <span class="math">(x, a) \\in \\mathcal{R}_C</span> , the honest prover can convince the verifier. Namely,  <span class="math">b = 1</span>  with probability  <span class="math">1 - \\mathrm{negl}(\\lambda)</span>  in the following experiment:  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathsf{KeyGen}(1^{\\lambda}, C)</span> ;  <span class="math">\\pi \\gets \\mathsf{Prove}(\\mathsf{pk}, x, a)</span> ;  <span class="math">b \\gets \\mathsf{Verify}(\\mathsf{vk}, x, \\pi)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinctness. An honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda}(1)</span>  bits and  <span class="math">\\mathsf{Verify}(\\mathsf{vk},x,\\pi)</span>  runs in time  $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . (Here,  </span>O_{\\lambda}<span class="math">  hides a fixed polynomial factor in  </span>\\lambda$ .)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of knowledge (and soundness). If the verifier accepts a proof output by a bounded prover, then the prover "knows" a witness for the given instance. (In particular, soundness holds against bounded provers.) Namely, for every poly  <span class="math">(\\lambda)</span> -size adversary  <span class="math">\\mathcal{A}</span> , there is a poly  <span class="math">(\\lambda)</span> -size extractor  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\text{Verify}(\\mathsf{vk}, x, \\pi) = 1</span>  and  <span class="math">(x, a) \\notin \\mathcal{R}_C</span>  with probability  <span class="math">\\text{negl}(\\lambda)</span>  in the following experiment:  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\text{KeyGen}(1^\\lambda, C)</span> ;  <span class="math">(x, \\pi) \\gets \\mathcal{A}(\\mathsf{pk}, \\mathsf{vk})</span> ;  <span class="math">a \\gets \\mathcal{E}(\\mathsf{pk}, \\mathsf{vk})</span> .</p>

    <p class="text-gray-300">Perfect zero knowledge. An honestly-generated proof is perfect zero knowledge. <span class="math">^{8}</span>  Namely, there is a polynomial-time simulator Sim such that for all stateful distinguishers  <span class="math">\\mathcal{D}</span>  the following two probabilities are equal:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c} (x, a) \\in \\mathcal {R} _ {C} \\\\ \\mathcal {D} (\\pi) = 1 \\end{array} \\right] \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {K e y G e n} (1 ^ {\\lambda}, C) \\\\ (x, a) \\leftarrow \\mathcal {D} (\\mathsf {p k}, \\mathsf {v k}) \\\\ \\pi \\leftarrow \\mathsf {P r o v e} (\\mathsf {p k}, x, a) \\end{array} \\right. \\quad \\text {a n d} \\quad \\operatorname * {P r} \\left[ \\begin{array}{c} (x, a) \\in \\mathcal {R} _ {C} \\\\ \\mathcal {D} (\\pi) = 1 \\end{array} \\right] \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {p k}, \\mathsf {v k}, \\mathsf {t r a p}) \\leftarrow \\mathsf {S i m} (1 ^ {\\lambda}, C) \\\\ (x, a) \\leftarrow \\mathcal {D} (\\mathsf {p k}, \\mathsf {v k}) \\\\ \\pi \\leftarrow \\mathsf {S i m} (\\mathsf {t r a p}, x) \\end{array} \\right].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(the probability that  <span class="math">\\mathcal{D}(\\pi) = 1</span>  on an honest proof)</p>

    <p class="text-gray-300">(the probability that  <span class="math">\\mathcal{D}(\\pi) = 1</span>  on a simulated proof)</p>

    <p class="text-gray-300">Remark. Both proof of knowledge and zero knowledge are essential to the use of zk-SNARKs in this paper. Indeed, we consider circuits  <span class="math">C</span>  that verify assertions about cryptographic primitives (such as using a knowledge of SHA256 pre-image as a binding commitment). Thus it does not suffice to merely know that, for a given input  <span class="math">x</span> , a witness for  <span class="math">x \\in \\mathcal{L}_C</span>  exists. Instead, proof of knowledge ensures that a witness can be efficiently found (by extracting it from the prover) whenever the verifier accepts a proof. As for zero knowledge, it ensures that a proof leaks no information about the witness, beyond the fact that  <span class="math">x \\in \\mathcal{L}_C</span> .</p>

    <p class="text-gray-300">Remark. In the security proofs (see Appendix D), we deal with provers producing a vector of inputs  <span class="math">\\vec{x}</span>  together with a vector of corresponding proofs  <span class="math">\\vec{\\pi}</span> . In such cases, it is convenient to use an extractor that can extract a vector of witnesses  <span class="math">\\vec{a}</span>  containing a valid witness for each valid proof. This "multi-instance" extraction follows from the "single-instance" one described above [BCCT12, BCCT13]. Namely, if (KeyGen, Prove, Verify) is a zk-SNARK, then for any poly  <span class="math">(\\lambda)</span> -size prover adversary  <span class="math">\\mathcal{A}</span>  there exists a poly  <span class="math">(\\lambda)</span> -size extractor  <span class="math">\\mathcal{E}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\exists i \\mathrm {s . t .} &amp; \\mathsf {V e r i f y} (\\mathsf {v k}, x _ {i}, \\pi_ {i}) = 1 \\\\ &amp; (x _ {i}, a _ {i}) \\notin \\mathcal {R} _ {C} \\end{array} \\right] \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {K e y G e n} (1 ^ {\\lambda}, C) \\\\ (\\vec {x}, \\vec {\\pi}) \\leftarrow \\mathcal {A} (\\mathsf {p k}, \\mathsf {v k}) \\\\ \\vec {a} \\leftarrow \\mathcal {E} (\\mathsf {p k}, \\mathsf {v k}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">zk-SNARKs are related to a familiar cryptographic primitive: non-interactive zero-knowledge proofs of knowledge (NIZKs). Both zk-SNARKs and NIZKs require a one-time trusted setup of public</p>

    <p class="text-gray-300">parameters (proving and verification keys for zk-SNARKs, and a common reference string for NIZKs). Both provide the same guarantees of completeness, proof of knowledge, and zero knowledge. The difference lies in efficiency guarantees. In a NIZK, the proof length and verification time depend on the NP language being proved. For instance, for the language of circuit satisfiability, the proof length and verification time in <em>[x11, x12]</em> are linear in the circuit size. Conversely, in a zk-SNARK, proof length depends only on the security parameter, and verification time depends only on the instance size (and security parameter) but not on the circuit or witness size.</p>

    <p class="text-gray-300">Thus, zk-SNARKs can be thought of as “succinct NIZKs”, having short proofs and fast verification times. Succinctness comes with a caveat: known zk-SNARK constructions rely on stronger assumptions than NIZKs do (see below).</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.3 Known constructions and security</h3>

    <p class="text-gray-300">There are many zk-SNARK constructions in the literature <em>[x13, x20, BCI^{+}13, x14, x15, BCTV14]</em>. We are interested in zk-SNARKs for arithmetic circuit satisfiability, and the most efficient ones for this language are based on <em>quadratic arithmetic programs</em> <em>[x14, BCI^{+}13, x15, BCC^{+}13, x16]</em>; such constructions provide a linear-time KeyGen, quasilinear-time Prove, and linear-time Verify.</p>

    <p class="text-gray-300">Security of zk-SNARKs is based on knowledge-of-exponent assumptions and variants of Diffie–Hellman assumptions in bilinear groups <em>[x13, x4, x17]</em>. While knowledge-of-exponent assumptions are fairly strong, there is evidence that such assumptions may be inherent for constructing zk-SNARKs <em>[x18, x5]</em>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Remark (fully-succinct zk-SNARKs).</h6>

    <p class="text-gray-300">The key generator KeyGen takes a circuit <span class="math">C</span> as input. Thus, KeyGen’s running time is at least linear in the size of the circuit <span class="math">C</span>. One could require KeyGen to <em>not</em> have to take <span class="math">C</span> as input, and have its output keys work for <em>all</em> (polynomial-size) circuits <span class="math">C</span>. In such a case, KeyGen’s running time would be independent of <span class="math">C</span>. A zk-SNARK satisfying this stronger property is <em>fully succinct</em>. Theoretical constructions of fully-succinct zk-SNARKs are known, based on various cryptographic assumptions <em>[x21, x33, x5]</em>. Despite achieving essentially-optimal asymptotics <em>[x2, BGH^{+}05, x6, x13, x7, x14]</em> no implementations of them have been reported in the literature to date.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.4 zk-SNARK implementations</h3>

    <p class="text-gray-300">There are three published implementations of zk-SNARKs: (i) Parno et al. <em>[x15]</em> present an implementation of zk-SNARKs for programs having no data dependencies; (ii) Ben-Sasson et al. <em>[BCG^{+}13]</em> present an implementation of zk-SNARKs for arbitrary programs (with data dependencies); and (iii) Ben-Sasson et al. <em>[x6]</em> present an implementation of zk-SNARKs that supports programs that modify their own code (e.g., for runtime code generation); their implementation also reduces costs for programs of larger size and allows for universal key pairs.</p>

    <p class="text-gray-300">Each of the works above also achieves zk-SNARKs for arithmetic circuit satisfiability as a stepping stone towards their respective higher-level efforts. In this paper we are only interested in a zk-SNARK for arithmetic circuit satisfiability, and we rely on the implementation of <em>[x6]</em> for such a zk-SNARK. The implementation in <em>[x6]</em> is itself based on the protocol of Parno et al. <em>[x15]</em>. We thus refer the interested reader to <em>[x15]</em> for details of the protocol, its</p>

    <p class="text-gray-300">intuition, and its proof of security; and to [BCTV14] for the implementation and its performance. In terms of concrete parameters, the implementation of [BCTV14] provides 128 bits of security, and the field <span class="math">\\mathbb{F}</span> is of a 256-bit prime order <span class="math">p</span>.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3 Definition of a decentralized anonymous payment scheme</h2>

    <p class="text-gray-300">We introduce the notion of a <em>decentralized anonymous payment scheme</em> (DAP scheme), extending the notion of <em>decentralized e-cash</em> [MGGR13]. Later, in Section 4, we provide a construction.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.1 Data structures</h3>

    <p class="text-gray-300">We begin by describing, and giving intuition about, the data structures used by a DAP scheme. The algorithms that use and produce these data structures are introduced in Section 3.2.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Basecoin ledger.</h5>

    <p class="text-gray-300">Our protocol is applied on top of a ledger-based base currency such as Bitcoin; for generality we refer to this base currency as <em>Basecoin</em>. At any given time <span class="math">T</span>, all users have access to <span class="math">L_{T}</span>, the <em>ledger</em> at time <span class="math">T</span>, which is a sequence of <em>transactions</em>. The ledger is append-only (i.e., <span class="math">T&lt;T^{\\prime}</span> implies that <span class="math">L_{T}</span> is a prefix of <span class="math">L_{T^{\\prime}}</span>). The transactions in the ledger include both Basecoin transactions as well as two new transaction types described below.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Public parameters.</h5>

    <p class="text-gray-300">A list of <em>public parameters</em> <span class="math">\\mathsf{pp}</span> is available to all users in the system. These are generated by a trusted party at the “start of time” and are used by the system’s algorithms.</p>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Addresses.</h5>

    <p class="text-gray-300">Each user generates at least one <em>address key pair</em> <span class="math">(\\mathsf{addr}_{\\mathsf{pk}},\\mathsf{addr}_{\\mathsf{sk}})</span>. The public key <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> is published and enables others to direct payments to the user. The secret key <span class="math">\\mathsf{addr}_{\\mathsf{sk}}</span> is used to receive payments sent to <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>. A user may generate any number of address key pairs.</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Coins.</h5>

    <p class="text-gray-300">A <em>coin</em> is a data object <span class="math">\\mathbf{c}</span>, to which we associate the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <em>coin commitment</em>, denoted <span class="math">\\mathsf{cm}(\\mathbf{c})</span>: a string that appears on the ledger once <span class="math">\\mathbf{c}</span> is <em>minted</em>.</li>

      <li>A <em>coin value</em>, denoted <span class="math">v(\\mathbf{c})</span>: the denomination of <span class="math">\\mathbf{c}</span>, as measured in basecoins, as an integer between 0 and a maximum value <span class="math">v_{\\mathsf{max}}</span> (which is a system parameter).</li>

      <li>A <em>coin serial number</em>, denoted <span class="math">\\mathsf{sn}(\\mathbf{c})</span>: a unique string associated with <span class="math">\\mathbf{c}</span>, used to prevent double spending.</li>

      <li>A <em>coin address</em>, denoted <span class="math">\\mathsf{addr}_{\\mathsf{pk}}(\\mathbf{c})</span>: an address public key, representing who owns <span class="math">\\mathbf{c}</span>.</li>

    </ul>

    <p class="text-gray-300">Any other quantities associated with a coin <span class="math">\\mathbf{c}</span> (e.g., various trapdoors) are implementation details.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">New transactions.</h5>

    <p class="text-gray-300">Besides Basecoin transactions, there are two new types of transactions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Mint transactions</em>. A mint transaction <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span> is a tuple <span class="math">(\\mathsf{cm},v,<em>)</span>, where <span class="math">\\mathsf{cm}</span> is a coin commitment, <span class="math">v</span> is a coin value, and <span class="math"></em></span> denotes other (implementation-dependent) information. The transaction <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span> records that a coin <span class="math">\\mathbf{c}</span> with coin commitment <span class="math">\\mathsf{cm}</span> and value <span class="math">v</span> has been minted.</li>

      <li><em>Pour transactions</em>. A pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> is a tuple <span class="math">(\\mathsf{rt},\\mathsf{sn}_{1}^{\\mathsf{old}},\\mathsf{sn}_{2}^{\\mathsf{old}},\\mathsf{cm}_{1}^{\\mathsf{new}},\\mathsf{cm}_{2}^{\\mathsf{new}},v_{\\mathsf{pub}},\\mathsf{info},<em>)</span>, where <span class="math">\\mathsf{rt}</span> is a root of a Merkle tree, <span class="math">\\mathsf{sn}_{1}^{\\mathsf{old}},\\mathsf{sn}_{2}^{\\mathsf{old}}</span> are two coin serial numbers, <span class="math">\\mathsf{cm}_{1}^{\\mathsf{new}},\\mathsf{cm}_{2}^{\\mathsf{new}}</span> are two coin commitments, <span class="math">v_{\\mathsf{pub}}</span> is a coin value, <span class="math">\\mathsf{info}</span> is an arbitrary string, and <span class="math"></em></span> denotes other (implementation-dependent) information. The transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> records the pouring of two input (and now consumed) coins <span class="math">\\mathbf{c}_{1}^{\\mathsf{old}},\\mathbf{c}_{2}^{\\mathsf{old}}</span>, with respective serial numbers <span class="math">\\mathsf{sn}_{1}^{\\mathsf{old}},\\mathsf{sn}_{2}^{\\mathsf{old}}</span>, into two new output coins <span class="math">\\mathbf{c}_{1}^{\\mathsf{new}},\\mathbf{c}_{2}^{\\mathsf{new}}</span>, with respective coin commitments <span class="math">\\mathsf{cm}_{1}^{\\mathsf{new}},\\mathsf{cm}_{2}^{\\mathsf{new}}</span>, as well as a public output <span class="math">v_{\\mathsf{pub}}</span> (which may be zero). Furthermore, <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> also records an information string <span class="math">\\mathsf{info}</span> (perhaps containing information on who is the recipient of <span class="math">v_{\\mathsf{pub}}</span> basecoins) and that, when this transaction was made, the root of the Merkle tree over coin commitments was <span class="math">\\mathsf{rt}</span> (see below).</li>

    </ul>

    <p class="text-gray-300">Commitments of minted coins and serial numbers of spent coins. For any given time <span class="math">T</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{CMList}_T</span> denotes the list of all coin commitments appearing in mint and pour transactions in <span class="math">L_T</span>;</li>

      <li><span class="math">\\mathsf{SNList}_T</span> denotes the list of all serial numbers appearing in pour transactions in <span class="math">L_T</span>.</li>

    </ul>

    <p class="text-gray-300">While both of these lists can be deduced from <span class="math">L_T</span>, it will be convenient to think about them as separate (as, in practice, these may be separately maintained for efficiency reasons; cf. Section 8.3).</p>

    <p class="text-gray-300">Merkle tree over commitments. For any given time <span class="math">T</span>, <span class="math">\\mathsf{Tree}_T</span> denotes a Merkle tree over <span class="math">\\mathsf{CMList}_T</span> and <span class="math">\\mathsf{rt}_T</span> its root. Moreover, the function <span class="math">\\mathsf{Path}_T(\\mathsf{cm})</span> gives the authentication path from a coin commitment <span class="math">\\mathsf{cm}</span> appearing in <span class="math">\\mathsf{CMList}_T</span> to the root of <span class="math">\\mathsf{Tree}_T</span>. For convenience, we assume that <span class="math">L_T</span> also stores <span class="math">\\mathsf{rt}_{T&#x27;}</span> for all <span class="math">T&#x27; \\leq T</span> (i.e., it stores all past Merkle tree roots).</p>

    <h2 id="sec-23" class="text-2xl font-bold">3.2 Algorithms</h2>

    <p class="text-gray-300">A DAP scheme <span class="math">\\Pi</span> is a tuple of polynomial-time algorithms</p>

    <div class="my-4 text-center"><span class="math-block">(\\text{Setup}, \\text{CreateAddress}, \\text{Mint}, \\text{Pour}, \\text{VerifyTransaction}, \\text{Receive})</span></div>

    <p class="text-gray-300">with the following syntax and semantics.</p>

    <p class="text-gray-300">System setup. The algorithm Setup generates a list of public parameters:</p>

    <p class="text-gray-300"><strong>Setup</strong></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS: security parameter <span class="math">\\lambda</span></li>

      <li>OUTPUTS: public parameters <span class="math">\\mathsf{pp}</span></li>

    </ul>

    <p class="text-gray-300">The algorithm Setup is executed by a trusted party. The resulting public parameters <span class="math">\\mathsf{pp}</span> are published and made available to all parties (e.g., by embedding them into the protocol's implementation). The setup is done <em>only once</em>; afterwards, no trusted party is needed, and no global secrets or trapdoors are kept.</p>

    <p class="text-gray-300">Creating payment addresses. The algorithm CreateAddress generates a new address key pair:</p>

    <p class="text-gray-300"><strong>CreateAddress</strong></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS: public parameters <span class="math">\\mathsf{pp}</span></li>

      <li>OUTPUTS: address key pair <span class="math">(\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}})</span></li>

    </ul>

    <p class="text-gray-300">Each user generates at least one address key pair <span class="math">(\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}})</span> in order to receive coins. The public key <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> is published, while the secret key <span class="math">\\mathsf{addr}_{\\mathsf{sk}}</span> is used to redeem coins sent to <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>. A user may generate any number of address key pairs; doing so does not require any interaction.</p>

    <p class="text-gray-300">Minting coins. The algorithm Mint generates a coin (of a given value) and a mint transaction:</p>

    <p class="text-gray-300"><strong>Mint</strong></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

      <li>public parameters <span class="math">\\mathsf{pp}</span></li>

      <li>coin value <span class="math">v \\in \\{0,1,\\ldots,v_{\\max}\\}</span></li>

      <li>destination address public key <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span></li>

      <li>OUTPUTS: coin <span class="math">\\mathbf{c}</span> and mint transaction <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span></li>

    </ul>

    <p class="text-gray-300">A system parameter, <span class="math">v_{\\max}</span>, caps the value of any single coin. The output coin <span class="math">\\mathbf{c}</span> has value <span class="math">v</span> and coin address <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>; the output mint transaction <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span> equals <span class="math">(\\mathsf{cm},v,*)</span>, where <span class="math">\\mathsf{cm}</span> is the coin commitment of <span class="math">\\mathbf{c}</span>.</p>

    <p class="text-gray-300">12While we refer to Mekle trees for simplicity, it is straightforward to extend the definition to allow other data structures representing sets with fast insertion and efficient proofs of membership.</p>

    <p class="text-gray-300">Pouring coins. The Pour algorithm transfers value from input coins into new output coins, marking the input coins as consumed. Moreover, a fraction of the input value may be publicly revealed. Pouring allows users to subdivide coins into smaller denominations, merge coins, and transfer ownership of anonymous coins, or make public payments.¹³</p>

    <p class="text-gray-300">Pour</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

      <li>public parameters pp</li>

      <li>the Merkle root rt</li>

      <li>old coins c₁ᵒᵗᵗ, c₂ᵒᵗᵗ</li>

      <li>old addresses secret keys addrₛₗ₁ᵗᵗ, addrₛₗ₂ᵗᵗ</li>

      <li>authentication path path₁ from commitment cm(c₁ᵒᵗᵗ) to root rt,</li>

    </ul>

    <p class="text-gray-300">authentication path path₂ from commitment cm(c₂ᵒᵗᵗ) to root rt</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>new values v₁ᵒᵉᵉᵘ, v₂ᵒᵉᵉᵘ</li>

      <li>new addresses public keys addrₚₖ₁ᵗᵗᵗ, addrₚₖ₂ᵗᵗᵗ</li>

      <li>public value vₚₒₒ</li>

      <li>transaction string info</li>

      <li>OUTPUTS: new coins c₁ᵒᵉᵉᵘ, c₂ᵒᵉᵉᵘ and pour transaction txPour</li>

    </ul>

    <p class="text-gray-300">Thus, the Pour algorithm takes as input two distinct input coins c₁ᵒᵗᵗ, c₂ᵒᵗᵗ, along with corresponding address secret keys addrₛₗ₁ᵗᵗᵗ, addrₛₗ₂ᵗᵗᵗ (required to redeem the two input coins). To ensure that c₁ᵒᵗᵗ, c₂ᵒᵗᵗ have been previously minted, the Pour algorithm also takes as input the Merkle root rt (allegedly, equal to the root of Merkle tree over all coin commitments so far), along with two authentication paths path₁, path₂ for the two coin commitments cm(c₁ᵒᵗᵗ), cm(c₂ᵒᵗᵗ). Two input values v₁ᵒᵉᵉᵘ, v₂ᵒᵉᵉᵘ specify the values of two new anonymous coins c₁ᵒᵉᵉᵘ, c₂ᵒᵉᵉᵘ to be generated, and two input address public keys addrₚₖ₁ᵗᵗᵗᵗ, addrₚₖ₂ᵗᵗᵗᵗ specify the recipients of c₁ᵒᵉᵉᵘ, c₂ᵒᵉᵉᵘ. A third value, vₚₒₒ, specifies the amount to be publicly spent (e.g., to redeem coins or pay transaction fees). The sum of output values v₁ᵒᵉᵉᵘ + v₂ᵒᵉᵉᵘ + vₚₒₒ must be equal to the sum of the values of the input coins (and cannot exceed vₘₐₓ). Finally, the Pour algorithm also receives an arbitrary string info, which is bound into the output pour transaction txPour.</p>

    <p class="text-gray-300">The Pour algorithm outputs two new coins c₁ᵒᵉᵉᵘ, c₂ᵒᵉᵉᵘ and a pour transaction txPour. The transaction txPour equals (rt, sn₁ᵒᵗᵗ, sn₂ᵒᵗᵗ, cm₁ᵒᵉᵉᵘ, cm₂ᵒᵉᵉᵘ, vₚₒₒ, info, <em>), where cm₁ᵒᵉᵉᵘ, cm₂ᵒᵉᵉᵘ are the two coin commitments of the two output coins, and </em> denotes other (implementation-dependent) information. Crucially, txPour reveals only one value, the public value vₚₒₒ (which may be zero); it does not reveal the payment addresses or values of the old or new coins.</p>

    <p class="text-gray-300">Verifying transactions. The algorithm VerifyTransaction checks the validity of a transaction:</p>

    <p class="text-gray-300">VerifyTransaction</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

      <li>public parameters pp</li>

      <li>a (mint or pour) transaction tx</li>

      <li>the current ledger L</li>

      <li>OUTPUTS: bit b, equals 1 iff the transaction is valid</li>

    </ul>

    <p class="text-gray-300">Both mint and pour transactions must be verified before being considered well-formed. In practice, transactions can be verified by the nodes in the distributed system maintaining the ledger, as well</p>

    <p class="text-gray-300">¹³We consider pours with 2 inputs and 2 outputs, for simplicity and (as discussed in Section 1.3) without loss of generality.</p>

    <p class="text-gray-300">as by users who rely on these transactions.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Receiving coins.</h4>

    <p class="text-gray-300">The algorithm Receive scans the ledger and retrieves unspent coins paid to a particular user address:</p>

    <p class="text-gray-300">Receive</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs:</li>

      <li>recipient address key pair (addr_{pk}, addr_{sk})</li>

      <li>the current ledger <span class="math">L</span></li>

      <li>outputs: set of (unspent) received coins</li>

    </ul>

    <p class="text-gray-300">When a user with address key pair (addr_{pk}, addr_{sk}) wishes to receive payments sent to addr_{pk}, he uses the Receive algorithm to scan the ledger. For each payment to addr_{pk} appearing in the ledger, Receive outputs the corresponding coins whose serial numbers do not appear on the ledger <span class="math">L</span>. Coins received in this way may be spent, just like minted coins, using the Pour algorithm. (We only require Receive to detect coins paid to addr_{pk} via the Pour algorithm and not also detect coins minted by the user himself.)</p>

    <p class="text-gray-300">Next, we describe completeness (Section 3.3) and security (Section 3.4).</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.3 Completeness</h3>

    <p class="text-gray-300">Completeness of a DAP scheme requires that unspent coins can be spent. More precisely, consider a ledger sampler <span class="math">\\mathcal{S}</span> outputting a ledger <span class="math">L</span>. If <span class="math">\\mathbf{c}_{1}</span> and <span class="math">\\mathbf{c}_{2}</span> are two coins whose coin commitments appear in (valid) transactions on <span class="math">L</span>, but their serial numbers do not appear in <span class="math">L</span>, then <span class="math">\\mathbf{c}_{1}</span> and <span class="math">\\mathbf{c}_{2}</span> can be spent using Pour. Namely, running Pour results in a pour transaction tx_{Pour} that VerifyTransaction accepts, and the new coins can be received by the intended recipients (by using Receive); moreover, tx_{Pour} correctly records the intended <span class="math">v_{\\text{pub}}</span> and transaction string info. This property is formalized via an <em>incompleteness experiment</em> INCOMP.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">A DAP scheme <span class="math">\\Pi=(\\text{Setup},\\text{CreateAddress},\\text{Mint},\\text{Pour},\\text{VerifyTransaction},\\text{Receive})</span> is complete if no polynomial-size ledger sampler <span class="math">\\mathcal{S}</span> wins INCOMP with more than negligible probability. (See Appendix B for details.)</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.4 Security</h3>

    <p class="text-gray-300">Security of a DAP scheme is characterized by three properties, which we call ledger indistinguishability, transaction non-malleability, and balance.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 3.2.</h6>

    <p class="text-gray-300">A DAP scheme <span class="math">\\Pi=(\\text{Setup},\\text{CreateAddress},\\text{Mint},\\text{Pour},\\text{VerifyTransaction},\\text{Receive})</span> is secure if it satisfies ledger indistinguishability, transaction non-malleability, and balance.</p>

    <p class="text-gray-300">Below, we provide an informal overview of each property, and defer formal definitions to Appendix C.</p>

    <p class="text-gray-300">Each property is formalized as a game between an adversary <span class="math">\\mathcal{A}</span> and a challenger <span class="math">\\mathcal{C}</span>. In each game, the behavior of honest parties is realized via a DAP scheme oracle <span class="math">\\mathcal{O}^{\\text{DAP}}</span>, which maintains a ledger <span class="math">L</span> and provides an interface for executing CreateAddress, Mint, Pour and Receive algorithms for honest parties. To elicit behavior from honest parties, <span class="math">\\mathcal{A}</span> passes a query to <span class="math">\\mathcal{C}</span>, which (after sanity checks) proxies the query to <span class="math">\\mathcal{O}^{\\text{DAP}}</span>. For each query that requests an honest party to perform an action, <span class="math">\\mathcal{A}</span> specifies identities of previous transactions and the input values, and learns the resulting transaction, but not any of the secrets or trapdoors involved in producing that transaction. The oracle <span class="math">\\mathcal{O}^{\\text{DAP}}</span> also provides an Insert query that allows <span class="math">\\mathcal{A}</span> to directly add aribtrary transactions to the ledger <span class="math">L</span>.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Ledger indistinguishability.</h4>

    <p class="text-gray-300">This property captures the requirement that the ledger reveals no new information to the adversary beyond the publicly-revealed information (values of minted coins, public values, information strings, total number of transactions, etc.), even when the adversary can adaptively induce honest parties to perform DAP operations of his choice. That is, no bounded adversary <span class="math">\\mathcal{A}</span> can distinguish between two ledgers <span class="math">L_{0}</span> and <span class="math">L_{1}</span>, constructed by <span class="math">\\mathcal{A}</span> using queries to two DAP scheme oracles, when the queries to the two oracles are <em>publicly consistent</em>: they have matching type and are identical in terms of publicly-revealed information and the information related to addresses controlled by <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Ledger indistinguishability is formalized by an experiment L-IND that proceeds as follows. First, a challenger samples a random bit <span class="math">b</span> and initializes two DAP scheme oracles <span class="math">\\mathcal{O}_{0}^{\\text{DAP}}</span> and <span class="math">\\mathcal{O}_{0}^{\\text{DAP}}</span>, maintaining ledgers <span class="math">L_{0}</span> and <span class="math">L_{1}</span>. Throughout, the challenger allows <span class="math">\\mathcal{A}</span> to issue queries to <span class="math">\\mathcal{O}_{0}^{\\text{DAP}}</span> and <span class="math">\\mathcal{O}_{1}^{\\text{DAP}}</span>, thus controlling the behavior of honest parties on <span class="math">L_{0}</span> and <span class="math">L_{1}</span>. The challenger provides the adversary with the view of both ledgers, but in randomized order: <span class="math">L_{\\text{Left}}:=L_{b}</span> and <span class="math">L_{\\text{Right}}:=L_{1-b}</span>. The adversary’s goal is to distinguish whether the view he sees corresponds to <span class="math">(L_{\\text{Left}},L_{\\text{Right}})=(L_{0},L_{1})</span>, i.e. <span class="math">b=0</span>, or to <span class="math">(L_{\\text{Left}},L_{\\text{Right}})=(L_{1},L_{0})</span>, i.e. <span class="math">b=1</span>.</p>

    <p class="text-gray-300">At each round of the experiment, the adversary issues queries in pairs <span class="math">Q,Q^{\\prime}</span> of matching query type. If the query type is CreateAddress, then the same address is generated at both oracles. If it is to Mint, Pour or Receive, then <span class="math">Q</span> is forwarded to <span class="math">L_{0}</span> and <span class="math">Q^{\\prime}</span> to <span class="math">L_{1}</span>; for Insert queries, query <span class="math">Q</span> is forwarded to <span class="math">L_{\\text{Left}}</span> and <span class="math">Q^{\\prime}</span> is forwarded to <span class="math">L_{\\text{Right}}</span>. The adversary’s queries are restricted in the sense that they must maintain the <em>public consistency</em> of the two ledgers. For example, the public values for Pour queries must be the same, as well as minted amounts for Mint queries.</p>

    <p class="text-gray-300">At the conclusion of the experiment, <span class="math">\\mathcal{A}</span> outputs a guess <span class="math">b^{\\prime}</span>, and wins when <span class="math">b=b^{\\prime}</span>. Ledger indistinguishability requires that <span class="math">\\mathcal{A}</span> wins L-IND with probability at most negligibly greater than <span class="math">1/2</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Transaction non-malleability.</h4>

    <p class="text-gray-300">This property requires that no bounded adversary <span class="math">\\mathcal{A}</span> can alter any of the data stored within a (valid) pour transaction <span class="math">\\textsf{tx}_{\\textsf{Pour}}</span>. This <em>transaction non-malleability</em> prevents malicious attackers from modifying others’ transactions before they are added to the ledger (e.g., by re-targeting the Basecoin public output of a pour transaction).</p>

    <p class="text-gray-300">Transaction non-malleability is formalized by an experiment TR-NM, in which <span class="math">\\mathcal{A}</span> adaptively interacts with a DAP scheme oracle <span class="math">\\mathcal{O}^{\\text{DAP}}</span> and then outputs a pour transaction <span class="math">\\textsf{tx}^{<em>}</span>. Letting <span class="math">\\mathcal{T}</span> denote the set of pour transactions returned by <span class="math">\\mathcal{O}^{\\text{DAP}}</span>, and <span class="math">L</span> denote the final ledger, <span class="math">\\mathcal{A}</span> wins the game if there exists <span class="math">\\textsf{tx}\\in\\mathcal{T}</span>, such that (i) <span class="math">\\textsf{tx}^{</em>}\\neq\\textsf{tx}</span>; (ii) <span class="math">\\textsf{tx}^{<em>}</span> reveals a serial number contained in <span class="math">\\textsf{tx}</span>; and (iii) both <span class="math">\\textsf{tx}</span> and <span class="math">\\textsf{tx}^{</em>}</span> are valid with respect to the ledger <span class="math">L^{\\prime}</span> containing all transactions preceding <span class="math">\\textsf{tx}</span> on <span class="math">L</span>. In other words, <span class="math">\\mathcal{A}</span> wins the game if <span class="math">\\textsf{tx}^{*}</span> manages to modify some previous pour transaction to spend the same coin in a different way.</p>

    <p class="text-gray-300">Transaction non-malleability requires that <span class="math">\\mathcal{A}</span> wins TR-NM with only negligible probability. (Note that <span class="math">\\mathcal{A}</span> can of course produce valid pour transactions that are unrelated to those in <span class="math">\\mathcal{T}</span>; the condition that <span class="math">\\textsf{tx}^{*}</span> reveals a serial number of a previously-spent coin captures non-malleability.)</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Balance.</h4>

    <p class="text-gray-300">This property requires that no bounded adversary <span class="math">\\mathcal{A}</span> can own more money than what he minted or received via payments from others.</p>

    <p class="text-gray-300">Balance is formalized by an experiment BAL, in which <span class="math">\\mathcal{A}</span> adaptively interacts with a DAP scheme oracle <span class="math">\\mathcal{O}^{\\text{DAP}}</span> and then outputs a set of coins <span class="math">S_{\\text{coin}}</span>. Letting ADDR be set of addresses returned by CreateAddress queries (i.e., addresses of “honest” users), <span class="math">\\mathcal{A}</span> wins the game if the total value he can spend or has spent (either as coins or Basecoin public outputs) is greater than the value he has minted or received. That is, <span class="math">\\mathcal{A}</span> wins if <span class="math">v_{\\textsf{Unspent}}+v_{\\textsf{Basecoin}}+v_{\\mathcal{A}\\rightarrow\\textsf{ADDR}}&gt;v_{\\textsf{Mint}}+v_{\\textsf{ADDR}\\rightarrow\\mathcal{A}}</span> where: (i) <span class="math">v_{\\textsf{Unspent}}</span> is the total value of unspent coins in <span class="math">S_{\\text{coin}}</span>; (ii) <span class="math">v_{\\textsf{Basecoin}}</span> is the total value of public outputs placed by <span class="math">\\mathcal{A}</span> on the ledger; (iii) <span class="math">v_{\\textsf{Mint}}</span> is the total value of <span class="math">\\mathcal{A}</span>’s mint transactions; (iv) <span class="math">v_{\\textsf{ADDR}\\rightarrow\\mathcal{A}}</span> is the total value of payments received by <span class="math">\\mathcal{A}</span> from addresses in ADDR; (v) <span class="math">v_{\\mathcal{A}\\rightarrow\\textsf{ADDR}}</span> is the total value</p>

    <p class="text-gray-300">of payments sent by <span class="math">\\mathcal{A}</span> to addresses in ADDR.</p>

    <p class="text-gray-300">Balance requires that <span class="math">\\mathcal{A}</span> wins BAL with only negligible probability.</p>

    <h2 id="sec-32" class="text-2xl font-bold">4 Construction of a decentralized anonymous payment scheme</h2>

    <p class="text-gray-300">We show how to construct a DAP scheme (introduced in Section 3) using zk-SNARKs and other building blocks. Later, in Section 5, we give a concrete instantiation of this construction.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.1 Cryptographic building blocks</h3>

    <p class="text-gray-300">We first introduce notation for the standard cryptographic building blocks that we use. We assume familiarity with the definitions of these building blocks; for more details, see, e.g., <em>[x10]</em>. Throughout, <span class="math">\\lambda</span> denotes the security parameter.</p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Collision-resistant hashing.</h5>

    <p class="text-gray-300">We use a collision-resistant hash function <span class="math">\\mathsf{CRH}\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{O(\\lambda)}</span>.</p>

    <h5 id="sec-35" class="text-base font-semibold mt-4">Pseudorandom functions.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use a pseudorandom function family <span class="math">\\mathsf{PRF}=\\{\\mathsf{PRF}_{x}\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{O(\\lambda)}\\}_{x}</span> where <span class="math">x</span> denotes the seed. From <span class="math">\\mathsf{PRF}_{x}</span>, we derive three “non-overlapping” pseudorandom functions, chosen arbitrarily as $\\mathsf{PRF}_{x}^{\\text{addr}}(z):=\\mathsf{PRF}_{x}(00\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z)\\,,\\ \\mathsf{PRF}_{x}^{\\text{sn}}(z):=\\mathsf{PRF}_{x}(01\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z)\\,,\\ \\mathsf{PRF}_{x}^{\\text{pk}}(z):=\\mathsf{PRF}_{x}(10\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z)<span class="math">. Furthermore, we assume that </span>\\mathsf{PRF}^{\\text{sn}}<span class="math"> is also collision resistant, in the sense that it is infeasible to find </span>(x,z)\\neq(x^{\\prime},z^{\\prime})<span class="math"> such that </span>\\mathsf{PRF}_{x}^{\\text{sn}}(z)=\\mathsf{PRF}_{x^{\\prime}}^{\\text{sn}}(z^{\\prime})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Statistically-hiding commitments.</h5>

    <p class="text-gray-300">We use a commitment scheme COMM where the binding property holds computationally, while the hiding property holds statistically. It is denoted <span class="math">\\{\\mathsf{COMM}_{x}\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{O(\\lambda)}\\}_{x}</span> where <span class="math">x</span> denotes the commitment trapdoor. Namely, to reveal a commitment cm to a value <span class="math">z</span>, it suffices to provide <span class="math">z</span> and the trapdoor <span class="math">x</span>; then one can check that <span class="math">\\mathsf{cm}=\\mathsf{COMM}_{x}(z)</span>.</p>

    <h5 id="sec-37" class="text-base font-semibold mt-4">One-time strongly-unforgeable digital signatures.</h5>

    <p class="text-gray-300">We use a digital signature scheme <span class="math">\\mathsf{Sig}=(\\mathcal{G}_{\\mathsf{sig}},\\mathcal{K}_{\\mathsf{sig}},\\mathcal{S}_{\\mathsf{sig}},\\mathcal{V}_{\\mathsf{sig}})</span> that works as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{\\mathsf{sig}}(1^{\\lambda})\\to\\mathsf{pp}_{\\mathsf{sig}}</span>. Given a security parameter <span class="math">\\lambda</span> (presented in unary), <span class="math">\\mathcal{G}_{\\mathsf{sig}}</span> samples public parameters <span class="math">\\mathsf{pp}_{\\mathsf{sig}}</span> for the encryption scheme.</li>

      <li><span class="math">\\mathcal{K}_{\\mathsf{sig}}(\\mathsf{pp}_{\\mathsf{sig}})\\to(\\mathsf{pk}_{\\mathsf{sig}},\\mathsf{sk}_{\\mathsf{sig}})</span>. Given public parameters <span class="math">\\mathsf{pp}_{\\mathsf{sig}}</span>, <span class="math">\\mathcal{K}_{\\mathsf{sig}}</span> samples a public key and a secret key for a single user.</li>

      <li><span class="math">\\mathcal{S}_{\\mathsf{sig}}(\\mathsf{sk}_{\\mathsf{sig}},m)\\to\\sigma</span>. Given a secret key <span class="math">\\mathsf{sk}_{\\mathsf{sig}}</span> and a message <span class="math">m</span>, <span class="math">\\mathcal{S}_{\\mathsf{sig}}</span> signs <span class="math">m</span> to obtain a signature <span class="math">\\sigma</span>.</li>

      <li><span class="math">\\mathcal{V}_{\\mathsf{sig}}(\\mathsf{pk}_{\\mathsf{sig}},m,\\sigma)\\to b</span>. Given a public key <span class="math">\\mathsf{pk}_{\\mathsf{sig}}</span>, message <span class="math">m</span>, and signature <span class="math">\\sigma</span>, <span class="math">\\mathcal{V}_{\\mathsf{sig}}</span> outputs <span class="math">b=1</span> if the signature <span class="math">\\sigma</span> is valid for message <span class="math">m</span>; else it outputs <span class="math">b=0</span>.</li>

    </ul>

    <p class="text-gray-300">The signature scheme Sig satisfies the security property of <em>one-time strong unforgeability against chosen-message attacks</em> (<span class="math">\\mathsf{SUF-1CMA}</span> security).</p>

    <h5 id="sec-38" class="text-base font-semibold mt-4">Key-private public-key encryption.</h5>

    <p class="text-gray-300">We use a public-key encryption scheme <span class="math">\\mathsf{Enc}=(\\mathcal{G}_{\\mathsf{enc}},\\mathcal{K}_{\\mathsf{enc}},\\mathcal{E}_{\\mathsf{enc}},\\mathcal{D}_{\\mathsf{enc}})</span> that works as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}_{\\mathsf{enc}}(1^{\\lambda})\\to\\mathsf{pp}_{\\mathsf{enc}}</span>. Given a security parameter <span class="math">\\lambda</span> (presented in unary), <span class="math">\\mathcal{G}_{\\mathsf{enc}}</span> samples public parameters <span class="math">\\mathsf{pp}_{\\mathsf{enc}}</span> for the encryption scheme.</li>

      <li><span class="math">\\mathcal{K}_{\\mathsf{enc}}(\\mathsf{pp}_{\\mathsf{enc}})\\to(\\mathsf{pk}_{\\mathsf{enc}},\\mathsf{sk}_{\\mathsf{enc}})</span>. Given public parameters <span class="math">\\mathsf{pp}_{\\mathsf{enc}}</span>, <span class="math">\\mathcal{K}_{\\mathsf{enc}}</span> samples a public key and a secret key for a single user.</li>

      <li><span class="math">\\mathcal{E}_{\\mathsf{enc}}(\\mathsf{pk}_{\\mathsf{enc}},m)\\to c</span>. Given a public key <span class="math">\\mathsf{pk}_{\\mathsf{enc}}</span> and a message <span class="math">m</span>, <span class="math">\\mathcal{E}_{\\mathsf{enc}}</span> encrypts <span class="math">m</span> to obtain a ciphertext <span class="math">c</span>.</li>

      <li><span class="math">\\mathcal{D}_{\\mathsf{enc}}(\\mathsf{sk}_{\\mathsf{enc}},c)\\to m</span>. Given a secret key <span class="math">\\mathsf{sk}_{\\mathsf{enc}}</span> and a ciphertext <span class="math">c</span>, <span class="math">\\mathcal{D}_{\\mathsf{enc}}</span> decrypts <span class="math">c</span> to produce a message <span class="math">m</span> (or <span class="math">\\bot</span> if decryption fails).</li>

    </ul>

    <p class="text-gray-300">The encryption scheme <span class="math">\\mathsf{Enc}</span> satisfies two security properties: (i) ciphertext indistinguishability under chosen-ciphertext attack (<span class="math">\\mathsf{IND-CCA}</span> security); and (ii) key indistinguishability under chosen-ciphertext</p>

    <p class="text-gray-300">attack (IK-CCA security). While the first property is standard, the second is less known; informally, IK-CCA requires that ciphertexts cannot be linked to the public key used to encrypt them, or to other ciphertexts encrypted with the same public key. For definitions, we refer the reader to <em>[x1]</em>.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.2 zk-SNARKs for pouring coins</h3>

    <p class="text-gray-300">As outlined in Section 1.3, our construction invokes a zk-SNARK for a specific NP statement, POUR, which we now define. We first recall the context motivating POUR. When a user <span class="math">u</span> <em>pours</em> “old” coins <span class="math">\\mathbf{c}_{1}^{\\text{old}},\\mathbf{c}_{2}^{\\text{old}}</span> into new coins <span class="math">\\mathbf{c}_{1}^{\\text{new}},\\mathbf{c}_{2}^{\\text{new}}</span>, a corresponding pour transaction</p>

    <p class="text-gray-300"><span class="math">\\mathsf{tx}_{\\mathsf{Pour}}=(r\\mathsf{t},\\mathsf{sn}_{1}^{\\text{old}},\\mathsf{sn}_{2}^{\\text{old}},\\mathsf{cm}_{1}^{\\text{new}},\\mathsf{cm}_{2}^{\\text{new}},v_{\\mathsf{pub}},\\mathsf{info},*)</span></p>

    <p class="text-gray-300">is generated. In our construction, we need to provide evidence in “*” that various conditions were respected by the pour operation. Concretely, <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> should demonstrate that (i) <span class="math">u</span> owns <span class="math">\\mathbf{c}_{1}^{\\text{old}},\\mathbf{c}_{2}^{\\text{old}}</span>; (ii) coin commitments for <span class="math">\\mathbf{c}_{1}^{\\text{old}},\\mathbf{c}_{2}^{\\text{old}}</span> appear somewhere on the ledger; (iii) the revealed serial numbers <span class="math">\\mathsf{sn}_{1}^{\\text{old}},\\mathsf{sn}_{2}^{\\text{old}}</span> are of <span class="math">\\mathbf{c}_{1}^{\\text{old}},\\mathbf{c}_{2}^{\\text{old}}</span>; (iv) the revealed coin commitments <span class="math">\\mathsf{cm}_{1}^{\\text{new}},\\mathsf{cm}_{2}^{\\text{new}}</span> are of <span class="math">\\mathbf{c}_{1}^{\\text{new}},\\mathbf{c}_{2}^{\\text{new}}</span>; (v) balance is preserved. Our construction achieves this by including a zk-SNARK proof <span class="math">\\pi_{\\mathsf{POUR}}</span> for the statement POUR which checks the above invariants (as well as others needed for non-malleability).</p>

    <p class="text-gray-300">The statement POUR. Concretely, the NP statement POUR is defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Instances are of the form <span class="math">x=(\\mathsf{rt},\\mathsf{sn}_{1}^{\\text{old}},\\mathsf{sn}_{2}^{\\text{old}},\\mathsf{cm}_{1}^{\\text{new}},\\mathsf{cm}_{2}^{\\text{new}},v_{\\mathsf{pub}},h_{\\mathsf{Sig}},h_{1},h_{2})</span>. Thus, an instance <span class="math">x</span> specifies a root rt for a CRH-based Merkle tree (over the list of commitments so far), the two serial numbers of the consumed coins, two coin commitments for the two new coins, a public value, and fields <span class="math">h_{\\mathsf{Sig}},h_{1},h_{2}</span> used for non-malleability.</li>

      <li>Witnesses are of the form <span class="math">a=(\\mathsf{path}_{1},\\mathsf{path}_{2},\\mathsf{c}_{1}^{\\text{old}},\\mathsf{c}_{2}^{\\text{old}},\\mathsf{addr}_{\\mathsf{sk},1}^{\\text{old}},\\mathsf{addr}_{\\mathsf{sk},2}^{\\text{old}},\\mathsf{c}_{1}^{\\text{new}},\\mathsf{c}_{2}^{\\text{new}})</span> where, for each <span class="math">i\\in\\{1,2\\}</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{c}_{i}^{\\text{old}}</span> <span class="math">=(\\mathsf{addr}_{\\mathsf{pk},i}^{\\text{old}},v_{i}^{\\text{old}},\\rho_{i}^{\\text{old}},r_{i}^{\\text{old}},s_{i}^{\\text{old}},\\mathsf{cm}_{i}^{\\text{old}})\\enspace,</span> <span class="math">\\mathbf{c}_{i}^{\\text{new}}</span> <span class="math">=(\\mathsf{addr}_{\\mathsf{pk},i}^{\\text{new}},v_{i}^{\\text{new}},\\rho_{i}^{\\text{new}},r_{i}^{\\text{new}},s_{i}^{\\text{new}},\\mathsf{cm}_{i}^{\\text{new}})\\text{ for the same }\\mathsf{cm}_{i}^{\\text{new}}\\text{ as in }x,</span> <span class="math">\\mathsf{addr}_{\\mathsf{pk},i}^{\\text{old}}</span> <span class="math">=(a_{\\mathsf{pk},i}^{\\text{old}},\\mathsf{pk}_{\\mathsf{enc},i}^{\\text{old}})\\enspace,</span> <span class="math">\\mathsf{addr}_{\\mathsf{pk},i}^{\\text{new}}</span> <span class="math">=(a_{\\mathsf{pk},i}^{\\text{new}},\\mathsf{pk}_{\\mathsf{enc},i}^{\\text{new}})\\enspace,</span> <span class="math">\\mathsf{addr}_{\\mathsf{sk},i}^{\\text{old}}</span> <span class="math">=(a_{\\mathsf{sk},i}^{\\text{old}},\\mathsf{sk}_{\\mathsf{enc},i}^{\\text{old}})\\enspace.</span></p>

    <p class="text-gray-300">Thus, a witness <span class="math">a</span> specifies authentication paths for the two new coin commitments, the entirety of coin information about both the old and new coins, and address secret keys for the old coins.</p>

    <p class="text-gray-300">Given a POUR instance <span class="math">x</span>, a witness <span class="math">a</span> is valid for <span class="math">x</span> if the following holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in\\{1,2\\}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The coin commitment <span class="math">\\mathsf{cm}_{i}^{\\text{old}}</span> of <span class="math">\\mathbf{c}_{i}^{\\text{old}}</span> appears on the ledger, i.e., <span class="math">\\mathsf{path}_{i}</span> is a valid authentication path for leaf <span class="math">\\mathsf{cm}_{i}^{\\text{old}}</span> with respect to root rt, in a CRH-based Merkle tree.</li>

      <li>The address secret key <span class="math">a_{\\mathsf{sk},i}^{\\text{old}}</span> matches the address public key of <span class="math">\\mathbf{c}_{i}^{\\text{old}}</span>, i.e., <span class="math">a_{\\mathsf{pk},i}^{\\text{old}}=\\mathsf{PRF}_{a_{\\mathsf{sk},i}^{\\text{old}}}^{\\mathsf{addr}}(0)</span>.</li>

      <li>The serial number <span class="math">\\mathsf{sn}_{i}^{\\text{old}}</span> of <span class="math">\\mathbf{c}_{i}^{\\text{old}}</span> is computed correctly, i.e., <span class="math">\\mathsf{sn}_{i}^{\\text{old}}=\\mathsf{PRF}_{\\mathsf{sn}_{i}^{\\text{old}}}^{\\mathsf{sn}_{i}}(\\rho_{i}^{\\text{old}})</span>.</li>

      <li>The coin <span class="math">\\mathbf{c}_{i}^{\\text{old}}</span> is well-formed, i.e., <span class="math">\\mathsf{cm}_{i}^{\\text{old}}=\\mathsf{COMM}_{\\mathsf{c}_{i}^{\\text{old}}}(\\mathsf{COMM}_{\\mathsf{c}_{i}^{\\text{old}}}(\\mathsf{c}_{i}^{\\text{old}})</span> is computed correctly, i.e., <span class="math">\\mathsf{sn}_{i}^{\\text{old}}=\\mathsf{PRF}_{\\mathsf{sn}_{i}^{\\text{old}}}^{\\mathsf{sn}_{i}}(\\rho_{i}^{\\text{old}})</span>.</li>

      <li>The coin <span class="math">\\mathbf{c}_{i}^{\\text{new}}</span> is well-formed, i.e., <span class="math">\\mathsf{cm}_{i}^{\\text{new}}=\\mathsf{COMM}_{\\mathsf{c}_{i}^{\\text{new}}}(\\mathsf{COMM}_{\\mathsf{c}_{i}^{\\text{new}}}(\\mathsf{c}_{i}^{\\text{new}})</span> is</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Balance is preserved: <span class="math">v_{1}^{\\text{new}}+v_{2}^{\\text{new}}+v_{\\text{pub}}=v_{1}^{\\text{old}}+v_{2}^{\\text{old}}</span> (with <span class="math">v_{1}^{\\text{old}},v_{2}^{\\text{old}}\\geq 0</span> and <span class="math">v_{1}^{\\text{old}}+v_{2}^{\\text{old}}\\leq v_{\\text{max}}</span>).</li>

    </ol>

    <p class="text-gray-300">Recall that in this paper zk-SNARKs are relative to the language of arithmetic circuit satisfiability (see Section 2); thus, we express the checks in POUR via an arithmetic circuit, denoted <span class="math">C_{\\text{POUR}}</span>. In particular, the depth <span class="math">d_{\\text{tree}}</span> of the Merkle tree needs to be hardcoded in <span class="math">C_{\\text{POUR}}</span>, and we thus make it a parameter of our construction (see below); the maximum number of supported coins is then <span class="math">2^{d_{\\text{tree}}}</span>.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">4.3 Algorithm constructions</h3>

    <p class="text-gray-300">We proceed to describe the construction of the DAP scheme <span class="math">\\Pi=(\\text{Setup},\\text{CreateAddress},\\text{Mint},\\text{Pour},\\text{VerifyTransaction},\\text{Receive})</span> whose intuition was given in Section 1.3. Figure 2 gives the pseudocode for each one of the six algorithms in <span class="math">\\Pi</span>, in terms of the building blocks introduced in Section 4.1 and Section 4.2. In the construction, we hardcode two quantities: the maximum value of a coin, <span class="math">v_{\\text{max}}</span>, and the depth of the Merkle tree, <span class="math">d_{\\text{tree}}</span>.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">4.4 Completeness and security</h3>

    <p class="text-gray-300">Our main theorem states that the above construction is indeed a DAP scheme.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 4.1.</h6>

    <p class="text-gray-300">The tuple <span class="math">\\Pi=(\\text{Setup},\\text{CreateAddress},\\text{Mint},\\text{Pour},\\text{VerifyTransaction},\\text{Receive})</span>, as defined in Section 4.3, is a complete (cf. Definition 3.1) and secure (cf. Definition 3.2) DAP scheme.</p>

    <p class="text-gray-300">We provide a proof of Theorem 4.1 in Appendix D. We note that our construction can be modified to yield statistical (i.e., everlasting) anonymity; see the discussion in Section 8.1.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark (trusted setup).</h6>

    <p class="text-gray-300">Security of <span class="math">\\Pi</span> relies on a trusted party running Setup to generate the public parameters (once and for all). This trust is needed for the transaction non-malleability and balance properties but not for ledger indistinguishability. Thus, even if a powerful espionage agency were to corrupt the setup, anonymity will <em>still</em> be maintained. Moreover, if one wishes to mitigate the trust requirements of this step, one can conduct the computation of Setup using secure multiparty computation techniques; we leave this to future work.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Remark (use of pp).</h6>

    <p class="text-gray-300">According to the definition of a DAP scheme (see Section 3), the public parameters pp are given as input to each one of the six algorithms; this is also how we presented our construction in Figure 2. However, in our construction, the public parameters pp equal a tuple <span class="math">(\\text{pk}_{\\text{POUR}},\\text{vk}_{\\text{POUR}},\\text{pp}_{\\text{enc}},\\text{pp}_{\\text{sig}})</span>, and not every algorithm needs every component of pp. Concretely, CreateAddress only needs pp_{enc}; Mint only the security parameter <span class="math">\\lambda</span>; Pour only pk_{POUR} and pp_{sig}; VerifyTransaction only vk_{POUR}; and Receive only <span class="math">\\lambda</span>. In particular, since we rely on zk-SNARKs to prove/verify POUR, pk_{POUR} is of constant, but large, size, and is only required by Pour. All other components of pp are of small constant size.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Remark (checking received coins in ledger).</h6>

    <p class="text-gray-300">The algorithm Receive tests whether the serial number of a received coin already appears on the ledger, in order not to output coins that the user has already received and spent by himself. Other users are, in any case, unable to spend coins addressed to this user.</p>

    <h2 id="sec-46" class="text-2xl font-bold">5 Zerocash</h2>

    <p class="text-gray-300">We describe a concrete instantiation of a DAP scheme; this instantiation forms the basis of Zerocash. Later, in Section 6, we discuss how Zerocash can be integrated with existing ledger-based currencies.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS: security parameter  <span class="math">\\lambda</span></li>

      <li>OUTPUTS: public parameters pp</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct  <span class="math">C_{\\mathrm{POUR}}</span>  for POUR at security  <span class="math">\\lambda</span> .</li>

      <li>Compute  <span class="math">(\\mathsf{pk}_{\\mathsf{POUR}},\\mathsf{vk}_{\\mathsf{POUR}})\\coloneqq \\mathsf{KeyGen}(1^{\\lambda},C_{\\mathsf{POUR}})</span></li>

      <li>Compute  <span class="math">\\mathsf{pp}_{\\mathrm{enc}}\\coloneqq \\mathcal{G}_{\\mathrm{enc}}(1^{\\lambda})</span></li>

      <li>Compute  <span class="math">\\mathsf{pp}_{\\mathrm{sig}}\\coloneqq \\mathcal{G}_{\\mathrm{sig}}(1^{\\lambda})</span></li>

      <li>Set  <span class="math">\\mathsf{pp} \\coloneqq (\\mathsf{pk}_{\\mathsf{POUR}}, \\mathsf{vk}_{\\mathsf{POUR}}, \\mathsf{pp}_{\\mathsf{enc}}, \\mathsf{pp}_{\\mathsf{sig}})</span> .</li>

      <li>Output pp.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS: public parameters pp</li>

      <li>OUTPUTS: address key pair (addrpk, addrsk)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\mathsf{pk}_{\\mathrm{enc}},\\mathsf{sk}_{\\mathrm{enc}})\\coloneqq \\mathcal{K}_{\\mathrm{enc}}(\\mathsf{pp}_{\\mathrm{enc}})</span></li>

      <li>Randomly sample a PRF <span class="math">^{\\text{addr}}</span>  seed  <span class="math">a_{\\text{sk}}</span> .</li>

      <li>Compute  <span class="math">a_{\\mathrm{pk}} = \\mathsf{PRF}_{\\mathsf{mk}}^{\\mathsf{addr}}(0)</span></li>

      <li>Set  <span class="math">\\mathsf{addr}_{\\mathsf{pk}} := (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}})</span> .</li>

      <li>Set  <span class="math">\\mathsf{addr}_{\\mathsf{sk}} := (a_{\\mathsf{sk}}, \\mathsf{sk}_{\\mathsf{enc}})</span> .</li>

      <li>Output (addrpk, addrsk).</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

    </ul>

    <p class="text-gray-300">public parameters pp</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>coin value  <span class="math">v \\in \\{0,1,\\dots,v_{\\max}\\}</span></li>

      <li>destination address public key addrpk</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OUTPUTS: coin c and mint transaction txMint</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>  as  <span class="math">(a_{\\mathsf{pk}},\\mathsf{pk}_{\\mathsf{enc}})</span></li>

      <li>Randomly sample a PRF <span class="math">^{\\text{PRF}}</span>  seed  <span class="math">\\rho</span> .</li>

      <li>Randomly sample two COMM trapdoors  <span class="math">r, s</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Compute  $k\\coloneqq \\mathsf{COMM}_r(a_{\\mathsf{pk}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathbf{c} \\coloneqq (\\mathsf{addr}_{\\mathsf{pk}}, v, \\rho, r, s, \\mathbf{cm})</span> .</li>

      <li>Set  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}} := (\\mathsf{cm}, v, <em>)</span> , where  <span class="math"></em> := (k, s)</span> .</li>

      <li>Output  <span class="math">\\mathbf{c}</span>  and  <span class="math">\\mathrm{tx}_{\\mathrm{Mint}}</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

    </ul>

    <p class="text-gray-300">public parameters pp</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a (mint or pour) transaction tx</li>

      <li>the current ledger  <span class="math">L</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OUTPUTS: bit  <span class="math">b</span> , equals 1 iff the transaction is valid</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If given a mint transaction  <span class="math">\\mathsf{tx} = \\mathsf{tx}_{\\mathsf{Mint}}</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Parse  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span>  as  <span class="math">(\\mathbf{cm},v,<em>)</span>  , and  <span class="math"></em></span>  as  <span class="math">(k,s)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) Set  $\\mathbf{cm}^{\\prime}\\coloneqq \\mathsf{COMM}_{s}(v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c) Output  <span class="math">b \\coloneqq 1</span>  if  <span class="math">\\mathbf{cm} = \\mathbf{cm}&#x27;</span> , else output  <span class="math">b \\coloneqq 0</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If given a pour transaction  <span class="math">\\mathsf{tx} = \\mathsf{tx}_{\\mathsf{Pour}}</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Parse  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  as  <span class="math">(\\mathsf{rt},\\mathsf{sn}_1^{\\mathrm{old}},\\mathsf{sn}_2^{\\mathrm{old}},\\mathsf{cm}_1^{\\mathrm{new}},\\mathsf{cm}_2^{\\mathrm{new}},v_{\\mathsf{pub}},\\mathsf{info},<em>)</span>  , and  <span class="math"></em></span>  as  <span class="math">(\\mathsf{pk}_{\\mathrm{sig}},h_1,h_2,\\pi_{\\mathsf{POUR}},\\mathbf{C}_1,\\mathbf{C}_2,\\sigma)</span> (b) If  <span class="math">\\mathsf{sn}_1^{\\mathrm{old}}</span>  or  <span class="math">\\mathsf{sn}_2^{\\mathrm{old}}</span>  appears on  <span class="math">L</span>  (or  <span class="math">\\mathsf{sn}_1^{\\mathrm{old}} = \\mathsf{sn}_2^{\\mathrm{old}}</span> ), output  <span class="math">b := 0</span> . (c) If the Merkle root rt does not appear on  <span class="math">L</span> , output  <span class="math">b \\coloneqq 0</span> . (d) Compute  <span class="math">h_{\\mathrm{Sig}} \\coloneqq \\mathsf{CRH}(\\mathsf{pk}_{\\mathrm{sig}})</span> . (e) Set  <span class="math">x \\coloneqq (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathrm{old}}, \\mathsf{sn}_2^{\\mathrm{old}}, \\mathsf{cm}_1^{\\mathrm{new}}, \\mathsf{cm}_2^{\\mathrm{new}}, v_{\\mathrm{pub}}, h_{\\mathrm{Sig}}, h_1, h_2)</span> . (f) Set  <span class="math">m\\coloneqq (x,\\pi_{\\mathsf{POUR}},\\mathsf{info},\\mathbf{C}_1,\\mathbf{C}_2)</span> (g) Compute  <span class="math">b\\coloneqq \\mathcal{V}_{\\mathrm{sig}}(\\mathsf{pk}_{\\mathrm{sig}},m,\\sigma)</span> (h) Compute  <span class="math">b^{\\prime}\\coloneqq \\mathsf{Verify}(\\mathsf{vk}_{\\mathsf{POUR}},x,\\pi_{\\mathsf{POUR}})</span>  , and output  <span class="math">b\\wedge b^{\\prime}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

    </ul>

    <p class="text-gray-300">public parameters pp</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the Merkle root rt</li>

      <li>old coins  <span class="math">\\mathbf{c}_1^{\\mathrm{old}},\\mathbf{c}_2^{\\mathrm{old}}</span></li>

      <li>old addresses secret keys  <span class="math">\\mathsf{addr}_{\\mathsf{pk},1}^{\\mathsf{old}}</span> ,  <span class="math">\\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}}</span></li>

      <li>path path from commitment  <span class="math">\\mathbf{cm}(\\mathbf{c}_1^{\\mathrm{old}})</span>  to root rt, path path from commitment  <span class="math">\\mathbf{cm}(\\mathbf{c}_2^{\\mathrm{old}})</span>  to root rt</li>

      <li>new values  <span class="math">v_{1}^{\\mathrm{new}}</span> ,  <span class="math">v_{2}^{\\mathrm{new}}</span></li>

      <li>new addresses public keys  <span class="math">\\mathsf{addr}_{\\mathsf{pk},1}^{\\mathsf{new}}</span> ,  <span class="math">\\mathsf{addr}_{\\mathsf{pk},2}^{\\mathsf{new}}</span></li>

      <li>public value  <span class="math">v_{\\mathrm{pub}}</span></li>

      <li>transaction string info</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OUTPUTS: new coins  <span class="math">\\mathbf{c}_1^{\\mathrm{new}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathrm{new}}</span>  and pour transaction  <span class="math">\\mathbf{tx}_{\\mathrm{Pour}}</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i\\in \\{1,2\\}</span></li>

    </ol>

    <p class="text-gray-300">(a) Parse  <span class="math">\\mathbf{c}_i^{\\mathrm{old}}</span>  as  <span class="math">(\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathrm{old}},\\rho_i^{\\mathrm{old}},r_i^{\\mathrm{old}},s_i^{\\mathrm{old}},\\mathbf{cm}_i^{\\mathrm{old}})</span> . (b) Parse  <span class="math">\\mathsf{addr}_{\\mathsf{sk},i}^{\\mathsf{old}}</span>  as  <span class="math">(a_{\\mathsf{sk},i}^{\\mathsf{old}},\\mathsf{sk}_{\\mathsf{enc},i}^{\\mathsf{old}})</span> (c) Compute  <span class="math">\\mathsf{sn}_i^{\\mathrm{old}}\\coloneqq \\mathsf{PRF}_{\\mathsf{sn}_i}^{\\mathsf{sn}_i}(\\rho_i^{\\mathrm{old}})</span> (d) Parse  <span class="math">\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{new}}</span>  as  <span class="math">(a_{\\mathsf{pk},i}^{\\mathsf{new}},\\mathsf{pk}_{\\mathsf{enc},i}^{\\mathsf{new}})</span> (e) Randomly sample a PRF <span class="math">^{\\text{sn}}</span>  seed  <span class="math">\\rho_{i}^{\\text{new}}</span> . (f) Randomly sample two COMM trapdoors  <span class="math">r_i^{\\mathrm{new}}, s_i^{\\mathrm{new}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(g) Compute  $k_{i}^{\\mathrm{new}}\\coloneqq \\mathsf{COMM}_{r_{i}^{\\mathrm{new}}}(a_{\\mathrm{pk},i}^{\\mathrm{new}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{i}^{\\mathrm{new}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(i) Set  <span class="math">\\mathbf{c}_i^{\\mathrm{new}}\\coloneqq (\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{new}},v_i^{\\mathrm{new}},v_i^{\\mathrm{new}},r_i^{\\mathrm{new}},c_m^{\\mathrm{new}})</span> (j) Set  <span class="math">\\mathbf{C}_i\\coloneqq \\mathcal{E}_{\\mathrm{enc}}(\\mathsf{pk}_{\\mathrm{enc},i}^{\\mathrm{new}},(v_i^{\\mathrm{new}},\\rho_i^{\\mathrm{new}},r_i^{\\mathrm{new}},s_i^{\\mathrm{new}}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate  <span class="math">(\\mathsf{pk}_{\\mathrm{sig}},\\mathsf{sk}_{\\mathrm{sig}})\\coloneqq \\mathcal{K}_{\\mathrm{sig}}(\\mathsf{pp}_{\\mathrm{sig}})</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">h_{\\mathrm{Sig}} \\coloneqq \\mathsf{CRH}(\\mathsf{pk}_{\\mathrm{sig}})</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Compute  $h_1 \\coloneqq \\mathsf{PRF}_{\\mathsf{sik}}^{\\mathsf{pk}}(1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathsf{Sig}})<span class="math">  and  </span>h_2 \\coloneqq \\mathsf{PRF}_{\\mathsf{sik}}^{\\mathsf{pk}}(2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathsf{Sig}})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">x \\coloneqq (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathrm{old}}, \\mathsf{sn}_2^{\\mathrm{old}}, \\mathsf{cm}_1^{\\mathrm{new}}, \\mathsf{cm}_2^{\\mathrm{new}}, v_{\\mathrm{pub}}, h_{\\mathrm{Sig}}, h_1, h_2)</span> .</li>

      <li>Set  <span class="math">a \\coloneqq (\\mathsf{path}_1, \\mathsf{path}_2, \\mathsf{c}_1^{\\mathrm{old}}, \\mathsf{c}_2^{\\mathrm{old}}, \\mathsf{addr}_{\\mathrm{sk},1}^{\\mathrm{old}}, \\mathsf{addr}_{\\mathrm{sk},2}^{\\mathrm{old}}, \\mathsf{c}_1^{\\mathrm{new}}, \\mathsf{c}_2^{\\mathrm{new}})</span> .</li>

      <li>Compute  <span class="math">\\pi_{\\mathsf{POUR}}\\coloneqq \\mathsf{Prove}(\\mathsf{pk}_{\\mathsf{POUR}},x,a)</span></li>

      <li>Set  <span class="math">m\\coloneqq (x,\\pi_{\\mathsf{POUR}},\\mathsf{info},\\mathbf{C}_1,\\mathbf{C}_2)</span></li>

      <li>Compute  <span class="math">\\sigma \\coloneqq S_{\\mathrm{sig}}(\\mathsf{sk}_{\\mathrm{sig}},m)</span></li>

      <li>Set  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}\\coloneqq (\\mathsf{rt},\\mathsf{sn}_1^{\\mathrm{old}},\\mathsf{sn}_2^{\\mathrm{old}},\\mathsf{cm}_1^{\\mathrm{new}},\\mathsf{cm}_2^{\\mathrm{new}},v_{\\mathsf{pub}},\\mathsf{info},<em>)</span>  where  <span class="math"></em>\\coloneqq (\\mathsf{pk}_{\\mathrm{sig}},h_1,h_2,\\pi_{\\mathsf{POUR}},\\mathbf{C}_1,\\mathbf{C}_2,\\sigma)</span></li>

      <li>Output  <span class="math">\\mathbf{c}_1^{\\mathrm{new}},\\mathbf{c}_2^{\\mathrm{new}}</span>  and  <span class="math">\\mathbf{tx}_{\\mathrm{Pour}}</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

    </ul>

    <p class="text-gray-300">public parameters pp</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>recipient address key pair (addrpk, addrsk)</li>

      <li>the current ledger  <span class="math">L</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OUTPUTS: set of received coins</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>  as  <span class="math">(a_{\\mathsf{pk}},\\mathsf{pk}_{\\mathsf{enc}})</span></li>

      <li>Parse  <span class="math">\\mathsf{addr}_{\\mathsf{sk}}</span>  as  <span class="math">(a_{\\mathsf{sk}},\\mathsf{sk}_{\\mathsf{enc}})</span></li>

      <li>For each Pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  on the ledger:</li>

    </ol>

    <p class="text-gray-300">(a) Parse  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  as  <span class="math">(\\mathsf{rt},\\mathsf{sn}_1^{\\mathrm{old}},\\mathsf{sn}_2^{\\mathrm{old}},\\mathsf{cm}_1^{\\mathrm{new}},\\mathsf{cm}_2^{\\mathrm{new}},v_{\\mathsf{pub}},\\mathsf{info},<em>)</span>  and  <span class="math"></em></span>  as  <span class="math">(\\mathsf{pk}_{\\mathrm{sig}},h_1,h_2,\\pi_{\\mathsf{POUR}},\\mathbf{C}_1,\\mathbf{C}_2,\\sigma)</span> (b) For each  <span class="math">i\\in \\{1,2\\}</span></p>

    <p class="text-gray-300">i. Compute  <span class="math">(v_{i},\\rho_{i},r_{i},s_{i})\\coloneqq \\mathcal{D}_{\\mathrm{enc}}(\\mathsf{sk}_{\\mathrm{enc}},\\mathbf{C}_{i})</span> ii. If  <span class="math">\\mathcal{D}_{\\mathrm{enc}}</span>  's output is not  <span class="math">\\perp</span>  , verify that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\mathbf{cm}_i^{\\mathrm{new}}</span>  equals  $\\mathsf{COMM}_{s_i}(v_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{COMM}_{r_i}(a_{\\mathrm{pk}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_i))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{sn}_i\\coloneqq \\mathsf{PRF}_{\\mathsf{sik}}^{\\mathsf{sn}_i}(\\rho_i)</span>  does not appear on  <span class="math">L</span></li>

    </ul>

    <p class="text-gray-300">iii. If both checks succeed, output</p>

    <p class="text-gray-300"><span class="math">\\mathbf{c}_i \\coloneqq (\\mathsf{addr}_{\\mathsf{pk}}, v_i, \\rho_i, r_i, s_i, \\mathbf{cm}_i^{\\mathrm{new}})</span> .</p>

    <p class="text-gray-300">Figure 2: Construction of a DAP scheme using zk-SNARKs and other ingredients.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">We instantiate the DAP scheme construction from Section 4 (see Figure 2), aiming at a level of security of 128 bits. Doing so requires concrete choices, described next.</p>

    <p class="text-gray-300"><strong>CRH, PRF, COMM</strong> from SHA256. Let <span class="math">\\mathcal{H}</span> be the SHA256 compression function, which maps a 512-bit input to a 256-bit output. We mostly rely on <span class="math">\\mathcal{H}</span>, rather than the “full” hash, since this suffices for our fixed-size single-block inputs, and it simplifies the construction of <span class="math">C_{\\text{POUR}}</span> (see Section 5.2). We instantiate <span class="math">\\text{CRH}, \\text{PRF}, \\text{COMM}</span> via <span class="math">\\mathcal{H}</span> (under suitable assumptions on <span class="math">\\mathcal{H}</span>).</p>

    <p class="text-gray-300">First, we instantiate the collision-resistant function <span class="math">\\mathsf{CRH}</span> as <span class="math">\\mathcal{H}(z)</span> for <span class="math">z\\in \\{0,1\\}^{512}</span>; this function compresses “two-to-one”, so it can be used to construct binary Merkle trees.¹⁴</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we instantiate the pseudorandom function <span class="math">\\mathsf{PRF}_x(z)</span> as $\\mathcal{H}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z)<span class="math">, with </span>x\\in\\{0,1\\}^{256}<span class="math"> as the seed, and </span>z\\in\\{0,1\\}^{256}$ as the input.¹⁵ Thus, the derived functions are:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{PRF}_x^{\\mathrm{addr}}(z) := \\mathcal{H}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">00\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z), \\quad \\mathsf{PRF}_x^{\\mathrm{sn}}(z) := \\mathcal{H}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">01\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z), \\quad \\mathsf{PRF}_x^{\\mathrm{pk}}(z) := \\mathcal{H}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">with <span class="math">x\\in\\{0,1\\}^{256}</span> and <span class="math">z\\in\\{0,1\\}^{254}</span>.</p>

    <p class="text-gray-300">As for the commitment scheme COMM, we only use it in the following pattern:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k := \\mathsf{COMM}_r(a_{\\mathsf{pk}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho) \\, , \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Due to our instantiation of PRF, <span class="math">a_{\\mathsf{pk}}</span> is 256 bits. So we can set <span class="math">\\rho</span> also to 256 bits and <span class="math">r</span> to <span class="math">256 + 128 = 384</span> bits; then we can compute</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k := \\mathsf{COMM}_r(a_{\\mathsf{pk}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho) \\quad \\text{as} \\quad \\mathcal{H}(r\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[\\mathcal{H}(a_{\\mathsf{pk}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)]_{128}) \\, .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above, <span class="math">[\\cdot]_{128}</span> denotes that we are truncating the 256-bit string to 128 bits (say, by dropping least-significant bits, as in our implementation). Heuristically, for any string <span class="math">z \\in \\{0,1\\}^{128}</span>, the distribution induced by $\\mathcal{H}(r\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z)<span class="math"> is </span>2^{-128}<span class="math">-close to uniform, and this forms the basis of the statistically-hiding property. For computing cm, we set coin values to be 64-bit integers (so that, in particular, </span>v_{\\max} = 2^{64} - 1$ in our implementation), and then compute</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cm} := \\mathsf{COMM}_s(v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k) \\quad \\text{as} \\quad \\mathcal{H}(k\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{192}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v) \\, .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Noticeably, above we are <em>ignoring</em> the commitment randomness <span class="math">s</span>. The reason is that we already know that <span class="math">k</span>, being the output of a statistically-hiding commitment, can serve as randomness for the next commitment scheme.</p>

    <p class="text-gray-300"><strong>Instantiating the NP statement POUR.</strong> The above choices imply a concrete instantiation of the NP statement POUR (see Section 4.2). Specifically, in our implementation, POUR checks that the following holds, for each <span class="math">i\\in \\{1,2\\}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{path}_i</span> is an authentication path for leaf <span class="math">\\mathsf{cm}_i^{\\mathrm{old}}</span> with respect to root rt, in a CRH-based Merkle tree;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $a_{\\mathsf{pk},i}^{\\mathrm{old}} = \\mathcal{H}(a_{\\mathsf{sk},i}^{\\mathrm{old}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{256})$;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $\\mathsf{cm}_i^{\\mathrm{old}} = \\mathcal{H}(\\mathcal{H}(r_i^{\\mathrm{old}}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">[\\mathcal{H}(a_{\\mathsf{pk},i}^{\\mathrm{old}}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\rho_i^{\\mathrm{old}})]_{128})\\</td>

            <td class="px-3 py-2 border-b border-gray-700">0^{192}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">v_i^{\\mathrm{old}})$;</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{cm}_{i}^{\\mathsf{new}}=\\mathcal{H}(\\mathcal{H}(r_{i}^{\\mathsf{new}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[\\mathcal{H}(a_{\\mathsf{pk},i}^{\\mathsf{new}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i}^{\\mathsf{new}})]_{128})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{192}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{i}^{\\mathsf{new}})$; and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, POUR checks that <span class="math">v_{1}^{\\mathsf{new}}+v_{2}^{\\mathsf{new}}+v_{\\mathsf{pub}}=v_{1}^{\\mathsf{old}}+v_{2}^{\\mathsf{old}}</span>, with <span class="math">v_{1}^{\\mathsf{old}},v_{2}^{\\mathsf{old}}\\geq 0</span> and <span class="math">v_{1}^{\\mathsf{old}}+v_{2}^{\\mathsf{old}}&lt;2^{64}</span>.</p>

    <p class="text-gray-300">Finally, as mentioned, in order for <span class="math">C_{\\mathsf{POUR}}</span> to be well-defined, we need to fix a Merkle-tree depth <span class="math">d_{\\mathsf{tree}}</span>. In our implementation, we fix <span class="math">d_{\\mathsf{tree}}=64</span>, and thus support up to <span class="math">2^{64}</span> coins.</p>

    <p class="text-gray-300">Instantiating Sig. For the signature scheme Sig, we use ECDSA to retain consistency and compatibility with the existing bitcoind source code. However, standard ECDSA is malleable: both <span class="math">(r,s)</span> and <span class="math">(r,-s)</span> verify as valid signatures. We use a non-malleable variant, where <span class="math">s</span> is restricted to the “lower half” of field elements. While we are not aware of a formal SUF-1CMA proof for this variant, its use is consistent with proposals to resolve Bitcoin transaction malleability <em>[x21]</em>.</p>

    <p class="text-gray-300">Instantiating Enc. For the encryption scheme Enc, we use the key-private Elliptic-Curve Integrated Encryption Scheme (ECIES) <em>[x3]</em>; it is one of the few standardized key-private encryption schemes with available implementations.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">5.2 Arithmetic circuit for pouring coins</h3>

    <p class="text-gray-300">Our DAP scheme construction from Section 4 (see Figure 2) also requires zk-SNARKs relative to the NP statement POUR. These are obtained by invoking a zk-SNARK for arithmetic circuit satisfiability (see Section 2.4) on an arithmetic circuit <span class="math">C_{\\mathsf{POUR}}</span>, which verifies the NP statement POUR. In our instantiation, we rely on the implementation of <em>[x1]</em> for the basic zk-SNARK (see Section 2.4), and apply it to the circuit <span class="math">C_{\\mathsf{POUR}}</span> whose construction is described next.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">5.2.1 An arithmetic circuit for verifying SHA256’s compression function</h4>

    <p class="text-gray-300">The vast majority of the “verification work” in POUR is verifying computations of <span class="math">\\mathcal{H}</span>, the compression function of SHA256 (see Section 5.1). Thus, we begin by discussing our construction of an arithmetic circuit <span class="math">C_{\\mathcal{H}}</span> for verifying SHA256 computations. Later, in Section 5.2.2, we discuss the construction of <span class="math">C_{\\mathsf{POUR}}</span>, given the circuit <span class="math">C_{\\mathcal{H}}</span>.</p>

    <p class="text-gray-300">We wish to construct an arithmetic circuit <span class="math">C_{\\mathcal{H}}</span> such that, for every 256-bit digest <span class="math">h</span> and 512-bit input <span class="math">z</span>, <span class="math">(h,z)\\in\\mathcal{R}_{C_{\\mathcal{H}}}</span> if and only if <span class="math">h=\\mathcal{H}(z)</span>. Naturally, our goal is to minimize the size of <span class="math">C_{\\mathcal{H}}</span>. Our high-level strategy is to construct <span class="math">C_{\\mathcal{H}}</span>, piece by piece, by closely following the SHA256 official specification <em>[x18]</em>. For each subcomputation of SHA256, we use nondeterminism and field operations to verify the subcomputation using as few gates as possible.</p>

    <p class="text-gray-300">Overview of SHA256’s compression function. The primitive unit in SHA256 is a 32-bit <em>word</em>. All subcomputations are simple word operations: three bitwise operations (and, or, xor), shift-right, rotate-right, and addition modulo <span class="math">2^{32}</span>. The compression function internally has a <em>state</em> of 8 words, initialized to a fixed value, and then transformed in 64 successive rounds by following the 64-word <em>message schedule</em> (deduced from the input <span class="math">z</span>). The 256-bit output is the concatenation of the 8 words of the final state.</p>

    <p class="text-gray-300">Representing a state. We find that, for each word operation (except for addition modulo <span class="math">2^{32}</span>), it is more efficient to verify the operation when its inputs are represented as separate wires, each carrying a bit. Thus, <span class="math">C_{\\mathcal{H}}</span> maintains the 8-word state as 256 individual wires, and the 64-word message schedule as <span class="math">64\\cdot 32</span> wires.</p>

    <p class="text-gray-300">Addition modulo 32. To verify addition modulo <span class="math">2^{32}</span> we use techniques employed in previous work <em>[x14, BCG^{+}13, x1]</em>. Given two words <span class="math">A</span> and <span class="math">B</span>, we compute <span class="math">\\alpha:=\\sum_{i=0}^{31}2^{i}(A_{i}+B_{i})</span>.</p>

    <p class="text-gray-300">Because  <span class="math">\\mathbb{F}</span>  has characteristic larger than  <span class="math">2^{33}</span> , there is no wrap around; thus, field addition coincides with integer addition. We then make a non-deterministic guess for the 33 bits  <span class="math">\\alpha_{i}</span>  of  <span class="math">\\alpha</span>  (including carry), and enforce consistency by requiring that  <span class="math">\\alpha = \\sum_{i=0}^{32} 2^{i} \\alpha_{i}</span> . To ensure that each  <span class="math">\\alpha_{i} \\in \\{0,1\\}</span> , we use a 33-gate subcircuit computing  <span class="math">\\alpha_{i}(\\alpha_{i} - 1)</span> , all of which must be 0 for the subcircuit to be satisfiable. Overall, verifying addition modulo  <span class="math">2^{32}</span>  only requires 34 gates. This approach extends in a straightforward way to summation of more than two terms.</p>

    <p class="text-gray-300">Verifying the SHA256 message schedule. The first 16 words  <span class="math">W_{i}</span>  of the message schedule are the 16 words of the 512-bit input  <span class="math">z</span> . The remaining 48 words are computed as  <span class="math">W_{t} \\coloneqq \\sigma_{1}(W_{t - 2}) + W_{t - 7} + \\sigma_{0}(W_{t - 15}) + W_{t - 16}</span> , where  <span class="math">\\sigma_0(W) \\coloneqq \\mathrm{rotr}_7(W) \\oplus \\mathrm{rotr}_{18}(W) \\oplus \\mathrm{shr}_3(W)</span>  and  <span class="math">\\sigma_{1}</span>  has the same structure but different rotation and shift constants.</p>

    <p class="text-gray-300">The rotation and shift amounts are constants, so rotates and shifts can be achieved by suitable wiring to previously computed bits (or the constant 0 for high-order bits in shr). Thus, since the XOR of 3 bits can be computed using 2 gates, both  <span class="math">\\sigma_0</span>  and  <span class="math">\\sigma_{1}</span>  can be computed in 64 gates. We then compute (or more precisely, guess and verify) the addition modulo  <span class="math">2^{32}</span>  of the four terms.</p>

    <p class="text-gray-300">Verifying the SHA256 round function. The round function modifies the 8-word state by changing two of its words and then permuting the 8-word result.</p>

    <p class="text-gray-300">Each of the two modified words is a sum modulo  <span class="math">2^{32}</span>  of (i) round-specific constant words  <span class="math">K_{t}</span> ; (ii) message schedule words  <span class="math">W_{t}</span> ; and (iii) words obtained by applying simple functions to state words. Two of those functions are bitwise majority  <span class="math">(\\mathsf{Maj}(A,B,C)_i = 0</span>  if  <span class="math">A_{i} + B_{i} + C_{i}\\leq 1</span>  else 1) and bitwise choice  <span class="math">(\\mathsf{Ch}(A,B,C)_i = B_i</span>  if  <span class="math">A_{i} = 1</span> , else  <span class="math">C_i</span> ). We verify correct computation of Maj using 2 gates per output bit, and Ch with 1.</p>

    <p class="text-gray-300">Then, instead of copying 6 unchanged state words to obtain the permuted result, we make the permutation implicit in the circuit's wiring, by using output wires of previous sub-computations (sometimes reaching 4 round functions back) as input wires to the current sub-computation.</p>

    <p class="text-gray-300">Performance. Overall, we obtain an arithmetic circuit  <span class="math">C_{\\mathcal{H}}</span>  for verifying SHA256's compression function with less than 30000 arithmetic gates. See Figure 3 for a breakdown of gate counts.</p>

    <p class="text-gray-300">|  Gate count for CH  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">All rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">19584</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1 round (of 64)</td>

            <td class="px-3 py-2 border-b border-gray-700">306</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Finalize</td>

            <td class="px-3 py-2 border-b border-gray-700">288</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">27904</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3: Size of circuit  <span class="math">C_{\\mathcal{H}}</span>  for SHA256's compression function.</p>

    <p class="text-gray-300">Comparison with generic approaches. We constructed the circuit  <span class="math">C_{\\mathcal{H}}</span>  from scratch. We could have instead opted for more generic approaches: implement SHA256's compression function in a higher-level language, and use a circuit generator to obtain a corresponding circuit. However, generic approaches are significantly more expensive for our application, as we now explain.</p>

    <p class="text-gray-300">Starting from the SHA256 implementation in PolarSSL (a popular cryptographic library) [Pol13], it is fairly straightforward to write a C program for computing  <span class="math">\\mathcal{H}</span> . We wrote such a program, and gave it as input to the circuit generator of [PGHR13]. The output circuit had 58160 gates, more than twice larger than our hand-optimized circuit.</p>

    <p class="text-gray-300">Alternatively, we also compiled the same C program to TinyRAM, which is the architecture supported in  <span class="math">\\left[\\mathrm{BCG}^{+}13\\right]</span> ; we obtained a 5371-instruction assembly code that takes 5704 cycles to execute on TinyRAM. We could then invoke the circuit generator in  <span class="math">\\left[\\mathrm{BCG}^{+}13\\right]</span>  when given this TinyRAM program and time bound. However, each TinyRAM cycle costs  <span class="math">\\approx 1000</span>  gates, so the resulting circuit would have at least  <span class="math">5.7 \\cdot 10^{6}</span>  gates, i.e., over 190 times larger than our circuit. A</p>

    <p class="text-gray-300">similar computation holds for the circuit generator in [BCTV14], which supports an even more flexible architecture.</p>

    <p class="text-gray-300">Thus, overall, we are indeed much better off constructing  <span class="math">C_{\\mathcal{H}}</span>  from scratch. Of course, this is not surprising, because a SHA256 computation is almost a "circuit computation": it does not make use of complex program flow, accesses to memory, and so on. Thus, relying on machinery developed to support much richer classes of programs does not pay off.</p>

    <p class="text-gray-300">The NP statement POUR requires verifying membership in a Merkle tree based on  <span class="math">\\mathcal{H}</span> , a few additional invocations of  <span class="math">\\mathcal{H}</span> , and integer addition and comparison. We construct the circuit  <span class="math">C_{\\mathrm{POUR}}</span>  for POUR by combining various subcircuits verifying each of these. There remains to discuss the subcircuits for verifying membership in a Merkle tree (using the aforementioned subcircuit  <span class="math">C_{\\mathcal{H}}</span>  for verifying invocations of  <span class="math">\\mathcal{H}</span> ), and integer addition and comparison.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Merkle tree membership. We need to construct an arithmetic circuit that, given a root  <span class="math">\\mathsf{rt}</span> , authentication path path, and coin commitment  <span class="math">\\mathsf{cm}</span> , is satisfied if and only if path is a valid authentication path for the leaf  <span class="math">\\mathsf{cm}</span>  with respect to the root  <span class="math">\\mathsf{rt}</span> . The authentication path path includes, for each layer  <span class="math">i</span> , an auxiliary hash value  <span class="math">h_i</span>  and a bit  <span class="math">r_i</span>  specifying whether  <span class="math">h_i</span>  was the left  <span class="math">(r_i = 0)</span>  or the right  <span class="math">(r_i = 1)</span>  child of the parent node. We then check membership in the Merkle tree by verifying invocations of  <span class="math">\\mathcal{H}</span> , bottom-up. Namely, for  <span class="math">d = 64</span> , we set  <span class="math">k_{d-1} = \\mathsf{cm}</span> ; then, for each  <span class="math">i = d-1, \\ldots, 1</span> , we set  $B_i = h_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_i<span class="math">  if  </span>r_i = 0<span class="math">  else  </span>k_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_i<span class="math"> , and compute  </span>k_{i-1} = \\mathcal{H}(B_i)<span class="math"> . Finally we check that the root  </span>k_0<span class="math">  matches the given root  </span>\\mathsf{rt}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Integer addition. We need to construct an arithmetic circuit that, given 64-bit integers  <span class="math">A, B, C</span>  (presented as binary strings), is satisfied if and only if  <span class="math">C = A + B</span>  over the integers. Again relying on the fact that  <span class="math">\\mathbb{F}</span> 's characteristic is sufficiently large, we do so by checking that  <span class="math">\\sum_{i=0}^{63} 2^i c_i = \\sum_{i=0}^{63} 2^i (b_i + a_i)</span>  over  <span class="math">\\mathbb{F}</span> ; this is enough, because there is no wrap around.</p>

    <p class="text-gray-300">Integer comparison. We need to construct an arithmetic circuit that, given two 64-bit integers  <span class="math">A, B</span>  (represented in binary), is satisfied if and only if  <span class="math">A + B</span>  fits in 64 bits (i.e.  <span class="math">A + B &amp;lt; 2^{64}</span> ). We do so by checking that  <span class="math">\\sum_{i=0}^{63} 2^i (b_i + a_i) = \\sum_{i=0}^{63} c_i</span>  for some  <span class="math">c_i \\in \\{0,1\\}</span> . Indeed, if  <span class="math">A + B &amp;lt; 2^{64}</span>  then it suffices to take  <span class="math">c_i</span>  as the binary representation of  <span class="math">A + B</span> . However, if  <span class="math">A + B \\geq 2^{64}</span>  then no choice of  <span class="math">c_i</span>  can satisfy the constraint as  <span class="math">\\sum_{i=0}^{63} c_i \\leq 2^{64} - 1</span> . Overall, this requires 65 gates (1 gate for the equality check, and 64 gates for ensuring that  <span class="math">c_0, \\ldots, c_{63}</span>  are boolean).</p>

    <p class="text-gray-300">Overall circuit sizes. See Figure 4 for the size of  <span class="math">C_{\\text{POUR}}</span> . More than  <span class="math">99\\%</span>  of the gates are devoted to verifying invocations of  <span class="math">\\mathcal{H}</span> .</p>

    <p class="text-gray-300">|  Gate count for CPOUR  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ensure cm2old is in Merkle tree (1 layer out of 64)</td>

            <td class="px-3 py-2 border-b border-gray-700">1802304 (28161)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Check computation of sn1old, sn2old</td>

            <td class="px-3 py-2 border-b border-gray-700">2 × 27904</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Check computation of apd, apd, apd, apd, 2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 × 27904</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Check computation of cm1old, cm2old, cm1new, cm2new</td>

            <td class="px-3 py-2 border-b border-gray-700">4 × 83712</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Check computation of h1, h2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 × 27904</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ensure that v1new + v2new + vpub = v1old + v2old</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ensure that v1old + v2old < 264</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Miscellaneous</td>

            <td class="px-3 py-2 border-b border-gray-700">2384</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">4109330</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Size of the circuit  <span class="math">C_{\\text{POUR}}</span> , which verifies the statement POUR.</p>

    <p class="text-gray-300">6 Integration with existing ledger-based currencies</p>

    <p class="text-gray-300">Zerocash can be deployed atop any ledger (even one maintained by a central bank). Here, we briefly detail integration with the Bitcoin protocol. Unless explicitly stated otherwise, in the following section when referring to Bitcoin, and its unit of account bitcoin (plural bitcoins), we mean the underlying protocol and software, not the currency system. (The discussion holds, with little or no modification, for many forks of Bitcoin, also known as “altcoins”, such as Litecoin.)</p>

    <p class="text-gray-300">By introducing new transaction types and payment semantics, Zerocash breaks compatibility with the Bitcoin network. While Zerocash could be integrated into Bitcoin (the actual currency and its supporting software) via a “flag day” where a super-majority of Bitcoin miners simultaneously adopt the new software, we neither expect nor advise such integration in the near future and suggest using Zerocash in a separate altcoin.</p>

    <p class="text-gray-300">Integrating Zerocash into Bitcoin consists of adding a new transaction type, Zerocash transactions, and modifying the protocol and software to invoke Zerocash’s DAP interface to create and verify these transactions. There are at least two possible approaches to this integration. The first approach replaces all bitcoins with zerocoins, making all transactions anonymous at the cost of losing any additional Bitcoin functionality provided by, e.g., the Bitcoin scripting language (see Section 6.1). The second approach maintains this functionality, adding a parallel Zerocash currency, zerocoin, which can be converted to and from bitcoin at a one-to-one rate (see Section 6.2). Options for protocol-level modifications for the later approach are discussed in Section 6.3; the former can be readily inferred. In Section 6.4 we discuss anonymizing the network layer of Bitcoin and anonymity safeguards.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">6.1 Integration by replacing the base currency</h3>

    <p class="text-gray-300">One approach is to alter the underlying system so that all monetary transactions are done using Zerocash, i.e., by invoking the DAP interface and writing/reading the associated transactions in the distributed ledger.</p>

    <p class="text-gray-300">As seen in Section 3, this suffices to offer the core functionality of payments, minting, merging, splitting, etc., while assuring users that all transactions using this currency are anonymous. However, this has several drawbacks: (1) All pour transactions incur the cost of generating a zk-SNARK proof. (2) If Bitcoin supports additional features, such as a scripting language for specifying conditions for claiming bitcoins (as in Bitcoin), then these features are lost. (3) Bitcoin allows the flexibility of spending unconfirmed transactions; instead, with a Zerocash-only Bitcoin, this flexibility is lost: transactions must be confirmed before they can be spent. (And this imposes a minimal delay between receiving funds and spending them.)</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">6.2 Integration by hybrid currency</h3>

    <p class="text-gray-300">A different approach is to extend Bitcoin with a parallel, anonymized currency of “zerocoins”, existing alongside bitcoins, using the same ledger, and with the ability to convert freely between the two. The behavior and functionality of regular bitcoins is unaltered; in particular, they may support functionality such as scripting.</p>

    <p class="text-gray-300">In this approach, the Bitcoin ledger consists of Bitcoin-style transactions, containing inputs and outputs <em>[x11]</em>. Each input is either a pointer to an output of a previous transaction (as in plain Bitcoin), or a Zerocash pour transaction (which contributes its public value, <span class="math">v_{\\mathsf{pub}}</span>, of bitcoins to this transaction). Outputs are either an amount and destination public address/script (as in plain</p>

    <p class="text-gray-300">Bitcoin), or a Zerocash mint transaction (which consumes the input bitcoins to produce zerocoins). The usual invariant over bitcoins is maintained and checked in plain view: the sum of bitcoin inputs (including pours’ <span class="math">v_{\\mathsf{pub}}</span>) must be at least the sum of bitcoin outputs (including mints’ <span class="math">v</span>), and any difference is offered as a transaction fee. However, the accounting for zerocoins consumed and produced is done separately and implicitly by the DAP scheme.</p>

    <p class="text-gray-300">The life cycle of a zerocoin is as follows.</p>

    <p class="text-gray-300">Creating new zerocoins. A mint transaction consumes <span class="math">v</span> worth of bitcoins as inputs, and outputs coin commitment worth <span class="math">v</span> zerocoins. The <span class="math">v</span> bitcoins are effectively destroyed, in exchange for the newly-minted zerocoins.</p>

    <p class="text-gray-300">Spending zerocoins. Zerocoins can then be transferred, split, and merged into other zerocoins arbitrarily, via pour transactions which, instead of explicit inputs, include zero-knowledge proofs that such inputs exist. Pour transactions may optionally reveal a non-zero public output <span class="math">v_{\\mathsf{pub}}</span>. This is either left unclaimed as a transaction fee, placed into a standard Bitcoin transaction output (e.g., one paying to a public key) or consumed by a mint transaction. Thus, <span class="math">v_{\\mathsf{pub}}</span> bitcoins are created ex nihilo (similarly to how coinbase transactions produce bitcoin outputs as mining reward), in exchange for destroying that amount of zerocoins. The Bitcoin outputs must be included in the transaction string info, which is included as part of a pour transaction; transaction non-malleability ensures that all this information is bound together.</p>

    <p class="text-gray-300">Spending multiple zerocoins. To allow for pours to span more than two input and output coins, <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> structures may be chained together within one transaction by marking some output coin commitments as intermediates and having subsequent pours in the same transaction constructed relative to an ephemeral Merkle tree consisting of only the intermediates commitments. For example, a transaction might accept four input coins, with the first two Pour operations combining two of the inputs to produce an intermediate commitment each and a final Pour combining the two intermediate commitments into a final output new coin. Since the intermediate results are consumed instantly within the transaction, they need not be recorded in the global Merkle tree or have their serial numbers marked as spent.</p>

    <p class="text-gray-300">Transaction fees. Collecting transaction fees is done as usual, via a coinbase transaction added to each block, which pays as mining reward the difference between the total inputs (bitcoin and pours’ <span class="math">v_{\\mathsf{pub}}</span>) and total outputs (bitcoin and mints’ <span class="math">v</span>) in this block. Payment is either in bitcoins or in newly-minted zerocoins (via a Mint).</p>

    <p class="text-gray-300">Validation and block generation. All transactions are verified via VerifyTransaction when they are received by a node. Any plain Bitcoin inputs and outputs are processed as usual, and any Zerocash inputs and outputs are checked using VerifyTransaction with the entire Bitcoin transaction fed in as info for authentication. Once these transactions are assembled into a candidate block, each transaction needs to be verified again to ensure its serial number has not become spent or its Merkle root invalid. If these checks pass, the set of new coin commitments and spent serial numbers output by the included transactions are added to the global sets, and the new Merkle root and a digest of the serial number list is stored in the new block. Embedding this data simplifies statekeeping and allows nodes to readily verify they have the correct coin list and serial number list. Upon receiving a candidate block, nodes validate the block is formed correctly with respect to the above procedure.</p>

    <p class="text-gray-300">Receiving payments. In order to receive payments to an address, users may scan the block chain by running the Receive on every pour transaction. Alternatively they may receive coin information</p>

    <p class="text-gray-300">via some out-of-band mechanism (e.g., via encrypted email). The former process is nearly identical to the one proposed for “stealth addresses” for Bitcoin. In the worst case, scanning the block chain requires a trial decryption of every ciphertext <span class="math">\\mathbf{C}</span>. We expect many scenarios to provide explicit notification, e.g., in interactive purchases where a communication channel already exists from the payer to the payee. (Implementations may opt to drop the receive mechanism entirely, and require out-of-band notification, in order to avoid storing the ciphertexts in the block chain.)</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">6.3 Extending the Bitcoin protocol to support the combined semantics</h3>

    <p class="text-gray-300">While the section above describes the life-cycle of a zerocoin and semantics of the system, there remains the question of how transactions acquire the above necessary semantics. Two implementation approaches are possible, with different engineering tradeoffs.</p>

    <p class="text-gray-300">The first approach is to extend the protocol and its implementation with hard-coded validation of Zerocash transactions, reading them from new, designated fields in transactions and running VerifyTransaction. In this case the zk-SNARK itself effectively replaces the scripting language for Zerocash transactions.</p>

    <p class="text-gray-300">The second approach is to extend Bitcoin’s scripting language by adding an opcode that invokes VerifyTransaction, with the requisite arguments embeded alongside the opcode script. Such transactions must be exempt from the requirement they reference an input (as they are Zerocash transactions are self-contained), and, like coinbase transactions, be able to create bitcoins ex nihilo (to account for <span class="math">v_{\\mathsf{pub}}</span>). Moreover, while VerifyTransaction is run at the standard point in the Bitcoin transaction processing flow for evaluating scripts, the coin commitments and spent serial numbers are not actually added to CMList (resp., SNList) until their containing block is accepted (i.e., merely verifying a transaction does not have side effects).</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">6.4 Additional anonymity considerations</h3>

    <p class="text-gray-300">Zerocash only anonymizes the transaction ledger. Network traffic used to announce transactions, retrieve blocks, and contact merchants still leaks identifying information (e.g., IP addresses). Thus users need some anonymity network to safely use Zerocash. The most obvious way to do this is via Tor <em>[x10]</em>. Given that Zerocash transactions are not low latency themselves, Mixnets (e.g., Mixminion <em>[x11]</em>) are also a viable way to add anonymity (and one that, unlike Tor, is not as vulnerable to traffic analysis). Using mixnets that provide email-like functionality has the added benefit of providing an out-of-band notification mechanism that can replace Receive.</p>

    <p class="text-gray-300">Additionally, although in theory all users have a single view of the block chain, a powerful attacker could potentially fabricate an additional block <em>solely</em> for a targeted user. Spending any coins with respect to the updated Merkle tree in this “poison-pill” block will uniquely identify the targeted user. To mitigate such attacks, users should check with trusted peers their view of the block chain and, for sensitive transactions, only spend coins relative to blocks further back in the ledger (since creating the illusion for multiple blocks is far harder).</p>

    <h2 id="sec-61" class="text-2xl font-bold">7 Experiments</h2>

    <p class="text-gray-300">To measure the performance of Zerocash, we ran several experiments. First, we benchmarked the performance of the zk-SNARK for the NP statement POUR (Section 7.1) and of the six DAP scheme algorithms (Section 7.2). Second, we studied the impact of a higher block verification time via a simulation of a Bitcoin network (Section 7.3).</p>

    <p class="text-gray-300">Our zk-SNARK for the NP statement POUR is obtained by constructing an arithmetic circuit  <span class="math">C_{\\text{POUR}}</span>  for verifying POUR, and then invoking the generic implementation of zk-SNARK for arithmetic circuit satisfiability of [BCTV14] (see Section 2.4). The arithmetic circuit  <span class="math">C_{\\text{POUR}}</span>  is built from scratch and hand-optimized to exploit nondeterministic verification and the large field characteristic (see Section 5.2).</p>

    <p class="text-gray-300">Figure 5 reports performance characteristics of the resulting zk-SNARK for POUR. This includes three settings: single-thread performance on a laptop machine; and single-thread and multi-thread performance on a desktop machine. (The time measurements are the average of 10 runs, with standard deviation under  <span class="math">2.5\\%</span> .) For instance, with single-thread code on the laptop machine, we obtain that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key generation takes  <span class="math">7\\mathrm{min}48\\mathrm{s}</span> , and results in a proving key  <span class="math">\\mathsf{pk}_{\\mathsf{POUR}}</span>  of 896 MiB and a verification key  <span class="math">\\mathsf{vk}_{\\mathsf{POUR}}</span>  of 749 B. This is performed only once, as part of the Setup algorithm.</li>

      <li>Producing a proof  <span class="math">\\pi_{\\mathsf{POUR}}</span>  requires about 3 minutes; proofs have a constant size of  <span class="math">288\\mathrm{B}</span> . Proof generation is a subroutine of the Pour algorithm, and the resulting proof is included in the corresponding pour transaction.</li>

      <li>A proof  <span class="math">\\pi_{\\mathsf{POUR}}</span>  can be verified in only  <span class="math">8.5\\mathrm{ms}</span> . Proof verification is a subroutine of the VerifyTransaction algorithm, when it is given as input a pour transaction to verify.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intel Core i7-2620M @ 2.70GHz 12GB of RAM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intel Core i7-4770 @ 3.40GHz 16GB of RAM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1 thread</td>

            <td class="px-3 py-2 border-b border-gray-700">1 thread</td>

            <td class="px-3 py-2 border-b border-gray-700">4 threads</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">7 min 48 s</td>

            <td class="px-3 py-2 border-b border-gray-700">5 min 11 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1 min 47 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proving key</td>

            <td class="px-3 py-2 border-b border-gray-700">896 MiB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verification key</td>

            <td class="px-3 py-2 border-b border-gray-700">749 B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">2 min 55 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1 min 59 s</td>

            <td class="px-3 py-2 border-b border-gray-700">46 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof</td>

            <td class="px-3 py-2 border-b border-gray-700">288 B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">8.5 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">5.4 ms</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5: Performance of our zk-SNARK for the NP statement POUR.  <span class="math">(N = 10, \\sigma \\leq 2.5\\%)</span></p>

    <p class="text-gray-300">In Figure 6 we report performance characteristics for each of the six DAP scheme algorithms in our implementation (single-thread on our desktop machine). For VerifyTransaction, we separately report the cost of verifying mint and pour transactions and, in the latter case, we exclude the cost of scanning  <span class="math">L</span>  (e.g., to check if a serial number is duplicate);[20] for the case of Receive, we report the cost to process a given pour transaction in  <span class="math">L</span> .</p>

    <p class="text-gray-300">We obtain that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup takes about 5 minutes to run; its running time is dominated by the running time of KeyGen on  <span class="math">C_{\\text{POUR}}</span> . (Either way, Setup is run only once.) The size of the resulting public parameters  <span class="math">\\mathfrak{pp}</span>  is dominated by the size of  <span class="math">\\mathfrak{pk}_{\\text{POUR}}</span> .</li>

      <li>CreateAddress takes  <span class="math">326.0\\mathrm{ms}</span>  to run. The size of the resulting address key pair is just a few hundred bytes.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mint takes <span class="math">23\\text{\\,}\\mathrm{\\SIUnitSymbolMicro s}</span> to run. It results in a coin of size <span class="math">463\\text{\\,}\\mathrm{B}</span> and mint transaction of size <span class="math">72\\text{\\,}\\mathrm{B}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Pour takes about 2 minutes to run. Besides Setup, it is the only “expensive” algorithm to run; as expected, its running time is dominated by the running time of Prove. For a transaction string info, it results in (two new coins and) a pour transaction of size <span class="math">996\\text{\\,}\\mathrm{B}</span> + $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\,}\\mathrm{info}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VerifyTransaction takes <span class="math">8.3\\text{\\,}\\mathrm{\\SIUnitSymbolMicro s}</span> to verify a mint transaction and <span class="math">5.7\\text{\\,}\\mathrm{ms}</span> to verify a pour transaction; the latter’s time is dominated by that of Verify, which checks the zk-SNARK proof <span class="math">\\pi_{\\text{\\,}\\mathrm{POUR}}</span>.</li>

      <li>Receive takes <span class="math">1.6\\text{\\,}\\mathrm{ms}</span> per pour transaction.</li>

    </ul>

    <p class="text-gray-300">Note that the above numbers do not include the costs of maintaining the Merkle tree because doing so is not the responsibility of the DAP scheme algorithms. Nevertheless, these additional costs are not large: (i) each update of the root of the CRH-based Merkle tree only requires <span class="math">d_{\\text{\\,}\\mathrm{tree}}</span> invocations of CRH, and (ii) an authentication path consists of only <span class="math">d_{\\text{\\,}\\mathrm{tree}}</span> digests of CRH. In our implementation, where <span class="math">\\text{\\,}\\mathrm{CRH}=\\mathcal{H}</span> (the SHA256 compression function) and <span class="math">d_{\\text{\\,}\\mathrm{tree}}=64</span>, each update requires <span class="math">64</span> invocations of <span class="math">\\mathcal{H}</span> and an authentication path requires <span class="math">64\\cdot 32\\text{\\,}\\mathrm{B}=2\\text{\\,}\\mathrm{KiB}</span> of storage.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Remark.</h6>

    <p class="text-gray-300">If one does not want to rely on the ledger to communicate coins, via the ciphertexts <span class="math">\\mathbf{C}_{1},\\mathbf{C}_{2}</span>, and instead rely instead on some out-of-band mechanism (e.g., encrypted email), then the Receive algorithm is not needed, and moreover, many of the aforementioned sizes decrease because some pieces of data are not needed anymore; we denoted these pieces of data with “<span class="math">\\star</span>” in Figure 6. (E.g., the size of an address key pair is reduced to only <span class="math">64\\text{\\,}\\mathrm{B}</span>, and the size of a coin to only <span class="math">120\\text{\\,}\\mathrm{B}</span>.)</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">7.3 Large-scale network simulation</h3>

    <p class="text-gray-300">Because Bitcoin mining typically takes place on dedicated GPUs or ASICs, the CPU resources to execute the DAP scheme algorithms are often of minimal consequence to network performance. There is one potential exception to this rule: the VerifyTransaction algorithm must be run by all of the network nodes in the course of routine transaction validation. The time it takes to perform this verification may have significant impact on network performance.</p>

    <p class="text-gray-300">In the Zerocash implementation (as in Bitcoin), every Zerocash transaction is verified at each hop as it is forwarded though the network and, potentially, again when blocks containing the transaction are verified. Verifying a block consists of checking the proof of work and validating the contained transactions. Thus Zerocash transactions may take longer to spread though the network and blocks containing Zerocash transactions may take longer to verify. While we are concerned with the first issue, the potential impact of the second issue is cause for greater concern. This is because Zerocash transactions cannot be spent until they make it onto the ledger.</p>

    <p class="text-gray-300">Because blocks are also verified at each hop before they are forwarded through the network, delays in block verification slow down the propagation of new blocks through the network. This causes nodes to waste CPU-cycles mining on out-of-date blocks, reducing the computational power of the network and making it easier to mount a “51% attack” (dishonest majority of miners) on the distributed ledger.</p>

    <p class="text-gray-300">It is a priori unclear whether this potential issue is a real concern. Bitcoin caches transaction verifications, so a transaction that was already verified when it propagated through the network need not be verified again when it is seen in a block. The unknown is what percentage of transactions in a block are actually in any given node’s cache. We thus conduct a simulation of the Bitcoin network to investigate both the time it takes Zerocash transactions to make it onto the ledger and establish the effects of Zerocash transactions on block verification and propagation. We find that Zerocash transactions can be spent reasonably quickly and that the effects of increased block validation time are minimal.</p>

    <p class="text-gray-300">|   | Intel Core i7-4770 @ 3.40GHz 16GB of RAM  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  1 thread  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5 min 17 s</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of pkPOUR</td>

            <td class="px-3 py-2 border-b border-gray-700">896 MiB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of vkPOUR</td>

            <td class="px-3 py-2 border-b border-gray-700">749 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">★ size of ppenc</td>

            <td class="px-3 py-2 border-b border-gray-700">0 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of ppsig</td>

            <td class="px-3 py-2 border-b border-gray-700">0 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CreateAddress</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">326.0 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Size of addrpk</td>

            <td class="px-3 py-2 border-b border-gray-700">343 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of apk</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">★ size of pkenc</td>

            <td class="px-3 py-2 border-b border-gray-700">311 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Size of addrsk</td>

            <td class="px-3 py-2 border-b border-gray-700">319 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of ask</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">★ size of skenc</td>

            <td class="px-3 py-2 border-b border-gray-700">287 B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mint</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">23 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Size of coin c</td>

            <td class="px-3 py-2 border-b border-gray-700">463 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of addrpk</td>

            <td class="px-3 py-2 border-b border-gray-700">343 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of v</td>

            <td class="px-3 py-2 border-b border-gray-700">8 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of r</td>

            <td class="px-3 py-2 border-b border-gray-700">48 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of s</td>

            <td class="px-3 py-2 border-b border-gray-700">0 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of cm</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Size of txMint</td>

            <td class="px-3 py-2 border-b border-gray-700">72 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of cm</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of v</td>

            <td class="px-3 py-2 border-b border-gray-700">8 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of k</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">size of s</td>

            <td class="px-3 py-2 border-b border-gray-700">0 B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pour</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">2 min 2.01 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Size of txPour</td>

            <td class="px-3 py-2 border-b border-gray-700">996 B + [info]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of rt</td>

            <td class="px-3 py-2 border-b border-gray-700">32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of sn1old, sn2old</td>

            <td class="px-3 py-2 border-b border-gray-700">2 × 32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of cm1new, cm2new</td>

            <td class="px-3 py-2 border-b border-gray-700">2 × 32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of vpub</td>

            <td class="px-3 py-2 border-b border-gray-700">8 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of info</td>

            <td class="px-3 py-2 border-b border-gray-700">[info]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of pksig</td>

            <td class="px-3 py-2 border-b border-gray-700">66 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of h1, h2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 × 32 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of πPOUR</td>

            <td class="px-3 py-2 border-b border-gray-700">288 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">★ size of C1, C2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 × 173 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size of σ</td>

            <td class="px-3 py-2 border-b border-gray-700">64 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VerifyTransaction</td>

            <td class="px-3 py-2 border-b border-gray-700">Time for mint tx</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Time for pour tx (excludes L scan)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.7 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Receive</td>

            <td class="px-3 py-2 border-b border-gray-700">Time (per pour tx)</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 6: Performance of Zerocash algorithms. Above, we report the sizes of  <span class="math">\\mathsf{pp}_{\\mathrm{enc}}</span>  and  <span class="math">\\mathsf{pp}_{\\mathrm{sig}}</span>  as  <span class="math">0\\mathrm{B}</span> , because these parameters are "hardcoded" in the libraries we rely on for Enc and Sig. ( <span class="math">N = 10</span>  with  <span class="math">\\sigma \\leq 2.5\\%</span>  for all except that, due to variability at short timescales,  <span class="math">\\sigma(\\text{Mint}) \\leq 3.3\\mu s</span>  and  <span class="math">\\sigma(\\text{VerifyTransaction}) \\leq 1.9\\mu s</span> )</p>

    <p class="text-gray-300">Simulation design. Because Zerocash requires breaking changes to the Bitcoin protocol, we cannot test our protocol in the live Bitcoin network or even in the dedicated testnet. We must run our own private testnet. For efficiency and cost reasons, we would like to run as many Bitcoin nodes as possible on the least amount of hardware. This raises two issues. First, reducing the proof of work to practical levels while still preserving a realistic rate of new blocks is difficult (especially on</p>

    <p class="text-gray-300">virtualized hardware with variable performance). Second, the overhead of zk-SNARK verification prevents us from running many Bitcoin nodes on one virtualized server.</p>

    <p class="text-gray-300">The frequency of new blocks can be modeled as a Poisson process with a mean of <span class="math">\\Lambda_{\\text{block}}</span> seconds.²¹ To generate blocks stochastically, we modify bitcoind to fix its block difficulty at a trivial level ²² and run a Poisson process, on the simulation control server, which trivially mines a block on a randomly selected node. This preserves the distribution of blocks, without the computational overhead of a real proof of work. Another Poisson process triggering mechanism, with a different mean <span class="math">\\Lambda_{\\text{tx}}</span>, introduces new transactions at random network nodes.</p>

    <p class="text-gray-300">To differentiate which transactions represent normal Bitcoin expenditures versus which contain Zerocash pour transactions, simulated Zerocash transactions pay a unique amount of bitcoins (we set this value arbitrarily at 7 BTC). If a transaction's output matches this preset value, and it is not in verification cache, then our modified Bitcoin client inserts a 10 ms delay simulating the runtime of VerifyTransaction.²³ Otherwise transactions are processed as specified by the Bitcoin protocol. We vary the amount of simulated Zerocash traffic by varying the number of transactions with this particular output amount. This minimizes code changes and estimates only the generic impact of verification delays and not of any specific implementation choice.</p>

    <p class="text-gray-300"><strong>Methodology.</strong> Recent research [DW13] suggests that the Bitcoin network contains 16,000 distinct nodes though most are likely no longer participating: approximately 3,500 are reachable at any given time. Each node has an average of 32 open connections to randomly selected peers. As of November 2013, the peak observed transaction rate for Bitcoin is slightly under one transaction per second [Lee13].</p>

    <p class="text-gray-300">In our simulation, we use a 1000-node network in which each node has an average of 32 peers, transactions are generated with a mean of <span class="math">\\Lambda_{\\mathrm{tx}} = 1\\mathrm{s}</span>, a duration of 1 hour, and a variable percentage <span class="math">\\epsilon</span> of Zerocash traffic. To allow for faster experiments, instead of generating a block every 10 minutes as in Bitcoin, we create blocks at an average of every <span class="math">\\Lambda_{\\mathrm{block}} = 150\\mathrm{s}</span> (as in Litecoin, a popular altcoin).</p>

    <p class="text-gray-300">We run our simulation for different traffic mixes, where <span class="math">\\epsilon</span> indicates the percentage of Zerocash transactions and <span class="math">\\epsilon \\in \\{0\\%, 25\\%, 50\\%, 75\\%, 100\\% \\}</span>. Each simulation is run on 200 Amazon EC2 general-purpose m1.medium instances, in one region on a 10.10./16 private network. On each instance, we deploy 5 instances of bitcoind.²⁴</p>

    <p class="text-gray-300"><strong>Results.</strong> Transactions are triggered by a blocking function call on the simulation control node that must connect to a random node and wait for it to complete sending a transaction. Because the Poisson process modeling transactions generates delays between such calls and not between the exact points when the node actuals sends the transactions, the actual transaction rate is skewed. In our experiments the real transaction rate shifts away from our target of one per second to an average of one every 1.4 seconds.</p>

    <p class="text-gray-300">In Figure 7 we plot three metrics for <span class="math">\\epsilon \\in \\{0\\%, 25\\%, 50\\%, 75\\%, 100\\% \\}</span>. Each is the average defined over the data from the entire run of the simulation for a given <span class="math">\\epsilon</span> (i.e., they include multiple transactions and blocks).²⁵ Transaction latency is the interval between a transaction's creation and</p>

    <p class="text-gray-300">²¹ Since computational power is added to the Bitcoin network faster than the 2-week difficulty adjustment period, the frequency of block generation is actually skewed. As our experiments run for at most an hour, we ignore this.</p>

    <p class="text-gray-300">²² These code modifications have been rendered moot by the subsequent inclusion of a “regtest” mode in Bitcoin 0.9 that allows for precisely this type of behavior and block generation on command. At the time of our experiments, this feature was not available in a stable release. Future work should use this feature.</p>

    <p class="text-gray-300">²³ We used a generous delay of 10 ms (higher than the time reported in Figure 6) to leave room for machines slower than our desktop machine.</p>

    <p class="text-gray-300">²⁴ Higher densities of nodes per VM resulted in issues initializing all of the bitcoind instances on boot.</p>

    <p class="text-gray-300">²⁵ Because our simulated Bitcoin nodes ran on shared EC2 instances, they were subject to variable external load,</p>

    <p class="text-gray-300">32</p>

    <p class="text-gray-300">its inclusion in a block. Block propagation time comes in two flavors: (1) the average time for a new block to reach a node computed over the times for all nodes, and (2) the same average computed over only the last node to see the block.</p>

    <p class="text-gray-300">Block verification time is the average time, over all nodes, required to verify a block. If verification caching was not effective, we would expect to see a marked increase in both block verification time and propagation time. Since blocks occur on average every  <span class="math">150\\mathrm{s}</span> , and we expect approximately one transaction each second, we should see  <span class="math">150 \\times 10\\mathrm{ms} = 1500\\mathrm{ms}</span>  of delay if all transactions were non-cached Zerocash transactions. Instead, we see worst case  <span class="math">80\\mathrm{ms}</span>  and conclude caching is effective. This results in a negligible effect on block propagation (likely because network operations dominate).</p>

    <p class="text-gray-300">The time needed for a transaction to be confirmed, and hence spendable, is roughly 190s. For slower block generation rates (e.g., Bitcoin's block every 10 minutes) this should mean users must wait only one block before spending received transactions.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (a) Transaction latency</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (b) Block propagation time</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (c) Block verification time Figure 7: The average values of the three metrics we study, as a function of  <span class="math">\\epsilon</span> , the percentage of transactions that are Zerocash transactions. Note that, in (a), latency is undefined when  <span class="math">\\epsilon = 0</span>  and hence omitted.</p>

    <p class="text-gray-300">We outline several optimizations and extensions to Zerocash: everlasting anonymity (Section 8.1), faster block propagation (Section 8.2), and improved storage requirements (Section 8.3).</p>

    <p class="text-gray-300">Since transactions may persist virtually forever on the ledger, users may wish to ensure the anonymity of their transactions also lasts forever, even if particular primitives are eventually broken (by cryptanalytic breakthrough, engineering progress, or quantum computers). As we now explain, the DAP scheme construction described in Section 4 is only computationally private, but can be modified to achieve everlasting anonymity.</p>

    <p class="text-gray-300">Recall that every Pour operation publishes a pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}} = (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, <em>)</span> , where  <span class="math"></em> = (\\mathsf{pk}_{\\mathsf{sig}}, h_1, h_2, \\pi_{\\mathsf{POUR}}, \\mathbf{C}_1, \\mathbf{C}_2, \\sigma)</span>  and  <span class="math">\\mathbf{C}_i = \\mathcal{E}_{\\mathsf{enc}}(\\mathsf{pk}_{\\mathsf{enc},i}^{\\mathsf{new}}, (v_i^{\\mathsf{new}}, \\rho_i^{\\mathsf{new}}, r_i^{\\mathsf{new}}, s_i^{\\mathsf{new}}))</span> . Observe that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Since <span class="math">h_{\\mathsf{Sig}} = \\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}})</span> and <span class="math">h_i = \\mathsf{PRF}_{a_{\\mathsf{sk},i}}^{\\mathsf{pk}}(h_{\\mathsf{Sig}})</span>, an unbounded adversary <span class="math">\\mathcal{A}</span> can iterate over all <span class="math">x</span> until <span class="math">\\mathsf{PRF}_x^{\\mathsf{pk}}(h_{\\mathsf{Sig}})</span> equals <span class="math">h_i</span>; with overwhelming probability, there is only one such <span class="math">x</span>, in which case it equals <span class="math">a_{\\mathsf{sk},i}^{\\mathsf{old}}</span>. Thus, <span class="math">\\mathcal{A}</span> learns <span class="math">a_{\\mathsf{sk},i}^{\\mathsf{old}}</span>, and hence <span class="math">a_{\\mathsf{pk},i}^{\\mathsf{old}} := \\mathsf{PRF}_{a_{\\mathsf{sk},i}}^{\\mathsf{addr}}(0)</span>. This identifies the sender.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- An unbounded <span class="math">\\mathcal{A}</span> can also decrypt <span class="math">\\mathbf{C}_i</span>, so to learn <span class="math">(v_i^{\\mathsf{new}}, \\rho_i^{\\mathsf{new}}, r_i^{\\mathsf{new}}, s_i^{\\mathsf{new}})</span>; then, <span class="math">\\mathcal{A}</span> can try all possible <span class="math">x</span> until $\\mathsf{COMM}_{s_i^{\\mathsf{new}}}(v_i^{\\mathsf{new}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{COMM}_{r_i^{\\mathsf{new}}}(\\mathsf{PRF}_x^{\\mathsf{addr}}(0) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_i^{\\mathsf{new}}))<span class="math"> equals </span>\\mathsf{cm}_i^{\\mathsf{new}}<span class="math">; with overwhelming probability, there is only one such </span>x<span class="math">, in which case it equals </span>a_{\\mathsf{sk},i}^{\\mathsf{new}}$. This identifies the recipient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above attacks can be prevented as follows. First, every sender must use any given address only once (for receiving or sending coins): after receiving a coin <span class="math">\\mathbf{c}</span>, a user <span class="math">u</span> should immediately generate a new address and pour <span class="math">\\mathbf{c}</span> into a fresh one <span class="math">\\mathbf{c}&#x27;</span> relative to the new address; only afterwards can <span class="math">u</span> spend the coin. Second, a user should not put any data in a ciphertext <span class="math">\\mathbf{C}_i</span> to communicate a coin's information, but must instead use some (informationally-secure) out-of-band channel to do so. With these modifications (and recalling that COMM is statistically hiding and <span class="math">\\pi_{\\mathsf{POUR}}</span> is a perfect-zero-knowledge proof), one can verify that the pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> is statistically hiding, i.e., leaks no information even to unbounded adversaries.²⁶</p>

    <h2 id="sec-68" class="text-2xl font-bold">8.2 Fast block propagation</h2>

    <p class="text-gray-300">As mentioned in Section 7.3, the higher block-verification time of Zerocash compared to, e.g., Bitcoin does not affect much block propagation. Even so, we note a simple modification that further mitigates concerns. Upon receiving a block, a node validates the proof of work and (optionally) transactions other than mint and pour, and then forward the block right away. Only afterwards, the node executes VerifyTransaction on any mint/pour transactions, before accepting it for use in transacting. Thus, blocks are still validated by every node (so the security properties are unhampered), and propagation delays in the broadcast of blocks are reduced.</p>

    <p class="text-gray-300">In principle, this opens the possibility of a denial-of-service attack, in which the network is spammed with invalid blocks which pass the proof-of-work check but contain invalid mint or pour transactions. However, this attack appears unrealistic given the enormous (by design) cost of creating blocks passing the proof-of-work check.</p>

    <h2 id="sec-69" class="text-2xl font-bold">8.3 Improved storage requirements</h2>

    <p class="text-gray-300">Beyond the ledger <span class="math">L</span>, users need to maintain two lists: CMList, the list of all coin commitments, and SNList, the list of all serial numbers of spent coins (see Section 3.1). In our construction, CMList is required to deduce authentication paths to create new pour transactions (via Pour), while SNList is used to verify pour transactions (via VerifyTransaction). As the ledger grows, both CMList and SNList grow in size, and can eventually impose substantial storage requirements (though both are derived from, and smaller than, the block chain per se). We now explain how these storage requirements can be mitigated, by relying on smaller representations of CMList and SNList that suffice within our construction.</p>

    <h2 id="sec-70" class="text-2xl font-bold">8.3.1 Supporting many coin commitments</h2>

    <p class="text-gray-300">To execute the Pour algorithm to spend a coin <span class="math">\\mathbf{c}</span>, a user <span class="math">u</span> needs to provide an authentication path from <span class="math">\\mathbf{c}</span>'s coin commitment to rt, the Merkle-tree root over CMList. If we make the following protocol modifications, <span class="math">u</span> does not need all of CMList to compute this authentication path.</p>

    <p class="text-gray-300">²⁶ As for mint transactions, one can verify that they are already statistically hiding, without any modifications.</p>

    <p class="text-gray-300">In each block <span class="math">B</span> of transactions, we store the Merkle-tree path <span class="math">\\mathsf{path}_{B}</span> from the first coin commitment in <span class="math">B</span> to the root <span class="math">\\mathsf{rt}_{B}</span> of the Merkle tree over <span class="math">\\mathsf{CMList}</span> when the last block in the ledger is <span class="math">B</span>. (In Zerocash, the additional per-block storage cost to store this information is only <span class="math">2\\text{\\,}\\mathrm{KiB}</span>.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that, given a block <span class="math">B</span> and its successor block <span class="math">B^{\\prime}</span>, the corresponding authentication paths <span class="math">\\mathsf{path}_{B}</span> and <span class="math">\\mathsf{path}_{B^{\\prime}}</span> can be easily checked for consistency as follows. Let <span class="math">\\mathsf{CMList}_{B}</span> and <span class="math">\\mathsf{CMList}_{B^{\\prime}}</span> be the two lists of coin commitments corresponding to the two ledgers ending in block <span class="math">B</span> and <span class="math">B^{\\prime}</span> respectively; since <span class="math">\\mathsf{CMList}_{B}</span> (i.e., coin commitments to “to the left” of <span class="math">\\mathsf{path}_{B}</span>) is a prefix of <span class="math">\\mathsf{CMList}_{B^{\\prime}}</span>, <span class="math">\\mathsf{path}_{B^{\\prime}}</span> can be computed from <span class="math">\\mathsf{path}_{B}</span> and <span class="math">B</span> in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{\\mathsf{tree}})<span class="math">, where </span>d_{\\mathsf{tree}}$ is the tree depth.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When the user <span class="math">u</span> first receives (or mints) the coin <span class="math">\\mathbf{c}</span>, and its coin commitment is included in a block <span class="math">B</span>, <span class="math">u</span> immediately computes <span class="math">\\mathsf{path}_{B}</span>, by using the predecessor block and its authentication path. Afterwards, each time a new block is added to the ledger, <span class="math">u</span> obtains a new path for <span class="math">\\mathbf{c}</span> by using the new block and the old path for <span class="math">\\mathbf{c}</span>. Thus, <span class="math">u</span> only needs to act each time a new block is added, and each such update costs <span class="math">O(d_{\\mathsf{tree}})</span> per transaction in the block.</p>

    <p class="text-gray-300">Overall, <span class="math">u</span> incurs a storage requirement of only <span class="math">O(d_{\\mathsf{tree}})</span> for each coin he owns, and does not need to store <span class="math">\\mathsf{CMList}</span> anymore.</p>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">8.3.2 Supporting many spent serial numbers</h4>

    <p class="text-gray-300">To execute the VerifyTransaction algorithm on a pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>, a user <span class="math">u</span> needs access to <span class="math">\\mathsf{SNList}</span> (in order to check for duplicate serial numbers). Note, in Bitcoin, nodes need to maintain only the list of unspent transaction outputs, which is pruned as outputs are spent. In a DAP scheme, in contrast, nodes have to maintain <span class="math">\\mathsf{SNList}</span>, which is a list that <em>always grows</em>. We now explain how to mitigate this storage requirement, in three incremental steps.</p>

    <p class="text-gray-300">Step 1. The first step is to build a Merkle tree over <span class="math">\\mathsf{SNList}</span> so to allow easy-to-verify non-membership proofs for <span class="math">\\mathsf{SNList}</span>; this can be done by letting the leaves of the Merkle tree be the intervals of unspent serial numbers. Then, given the root <span class="math">\\mathsf{rt}</span> of such tree, a serial number <span class="math">\\mathsf{sn}</span> claimed to be unspent, and an authentication path <span class="math">\\mathsf{path}</span> for an interval <span class="math">I</span>, the user can check that <span class="math">\\mathsf{path}</span> is valid for <span class="math">\\mathsf{rt}</span> and that <span class="math">\\mathsf{sn}</span> lies in <span class="math">I</span>; the root <span class="math">\\mathsf{rt}</span> and path <span class="math">\\mathsf{path}</span> would be part of the pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> to be verified. The problem with this approach, however, is that generating <span class="math">\\mathsf{path}</span> (and also updating <span class="math">\\mathsf{rt}</span>) requires knowledge of all of <span class="math">\\mathsf{SNList}</span>.</p>

    <p class="text-gray-300">Step 2. Next, instead of maintaining <span class="math">\\mathsf{SNList}</span> in a single Merkle tree, we divide <span class="math">\\mathsf{SNList}</span>, maintaining its chronological order, into sublists of serial numbers <span class="math">\\mathsf{SNList}_{0},\\mathsf{SNList}_{1},\\ldots</span> and build a Merkle tree over the intervals induced by each sublist (i.e., apply Step 1 to each sublist). This modification implies a corresponding modification for the auxiliary information stored in a pour transaction that allows VerifyTransaction to check it. Now, however, producing such auxiliary information is less expensive. Indeed, a user with a coin <span class="math">\\mathbf{c}</span> should maintain a list of authentication paths <span class="math">\\mathsf{path}_{\\mathbf{c},0},\\mathsf{path}_{\\mathbf{c},1},\\ldots</span> (one for each sublist). Only the last path, corresponding to the active sublist, needs to be updated when a serial number is added; the other sublists and authentication paths remain unchanged (and these old sublists can in fact be discarded). When the user spends the coin, he can simply include these paths in the pour transaction. While updating these paths is an efficient operation, computing the initial paths for <span class="math">\\mathbf{c}</span> is not, as it still requires the full set of sublists.</p>

    <p class="text-gray-300">Step 3. To enable users to avoid the initial cost of computing paths for a new coin, we proceed as follows. First, a coin <span class="math">\\mathbf{c}</span> is extended to contain a time stamp <span class="math">T_{\\mathbf{c}}</span> corresponding to when <span class="math">\\mathbf{c}</span> is created (minted or poured into); the coin’s commitment is modified to depend on the timestamp, and the timestamp is included in the clear within the transaction that creates the coin. Then, a user, upon spending <span class="math">\\mathbf{c}</span>, produces a zk-SNARK for the following <span class="math">\\mathsf{NP}</span> statement: “for each Merkle-tree root created (or updated) after <span class="math">T_{\\mathbf{c}}</span> there is an interval and an authentication path for that interval</p>

    <p class="text-gray-300">such that the serial number of <span class="math">\\mathbf{c}</span> is in that interval”. Depending on the number of Merkle trees in such an <span class="math">\\mathsf{NP}</span> statement, such proofs may already be more efficient to produce, compared to the naive (Step 1) solution, using existing zk-SNARK implementations.</p>

    <h2 id="sec-72" class="text-2xl font-bold">9 Concurrent work</h2>

    <p class="text-gray-300">Danezis et al. <em>[x10]</em> suggest using zk-SNARKs to reduce proof size and verification time in Zerocoin. Our work differs from <em>[x10]</em> in both supported functionality and scalability.</p>

    <p class="text-gray-300">First, <em>[x10]</em>’s protocol, like Zerocoin, only supports fixed-value coins, and is best viewed as a decentralized mix. Instead, we define, construct, and implement a full-fledged decentralized electronic currency, which provides anonymous payments of any amount.</p>

    <p class="text-gray-300">Second, in <em>[x10]</em>, the complexity of the zk-SNARK generator, prover, and verifier all scale superlinearly in the number of coins, because their arithmetic circuit computes, <em>explicitly</em>, a product over all coins. In particular, the number of coins “mixed together” for anonymity cannot be large. Instead, in our construction, the respective complexities are polylogarithmic, polylogarithmic, and constant in the number of coins; our approach supports a practically-unbounded number of coins.</p>

    <p class="text-gray-300">While we do not rely on Pedersen commitments, our approach also yields statistical (i.e., everlasting) anonymity; see the discussion in Section 8.1.</p>

    <h2 id="sec-73" class="text-2xl font-bold">10 Conclusion</h2>

    <p class="text-gray-300">Decentralized currencies should ensure a user’s privacy from his peers when conducting legitimate financial transactions. Zerocash provides such privacy protection, by hiding user identities, transaction amounts, and account balances from public view. This, however, may be criticized for hampering accountability, regulation, and oversight. Yet Zerocash need not be limited to enforcing the basic monetary invariants of a currency system. The underlying zk-SNARK cryptographic proof machinery is flexible enough to support a wide range of policies. It can, for example, let a user prove that he paid his due taxes on all transactions <em>without</em> revealing those transactions, their amounts, or even the amount of taxes paid. As long as the policy can be specified by efficient nondeterministic computation using <span class="math">\\mathsf{NP}</span> statements, it can (in principle) be enforced using zk-SNARKs, and added to Zerocash. This can enable automated, privacy-preserving verification and enforcement of a wide range of compliance and regulatory policies that would otherwise be invasive to check directly or might be bypassed by corrupt authorities. This raises research, policy, and engineering questions regarding which such policies are desirable and practically realizable.</p>

    <p class="text-gray-300">Another research question is what new functionality can be realized by augmenting the capabilities already present in Bitcoin’s scripting language with zk-SNARKs that allow fast verification of expressive statements.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Amazon for their assistance and kind donation of EC2 resources, and Gregory Maxwell for his advice regarding the Bitcoin codebase. We thank Iddo Ben-Tov and the SCIPR Lab members — Daniel Genkin, Lior Greenblatt, Shaul Kfir, Gil Timnat, and Michael Riabzev — for inspiring discussions. We thank Sharon Kessler for editorial advice.</p>

    <p class="text-gray-300">This work was supported by: Amazon.com through an AWS in Education research grant; the Broadcom Foundation and Tel Aviv University Authentication Initiative; the Center for Science of Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370; the Check Point Institute for Information Security; the U.S. Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL) under contract FA8750-11-2-0211; the European Community’s Seventh Framework Programme (FP7/2007-2013) under grant agreement number 240258; the Israeli Centers of Research Excellence I-CORE program (center 4/11); the Israeli Ministry of Science and Technology; the Office of Naval Research under contract N00014-11-1-0470; the Simons Foundation, with a Simons Award for Graduate Students in Theoretical Computer Science; and the Skolkovo Foundation with agreement dated 10/26/2011.</p>

    <p class="text-gray-300">The views expressed are those of the authors and do not reflect the official policy or position of the Department of Defense or the U.S. Government.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">A Overview of Bitcoin and Zerocoin</p>

    <p class="text-gray-300">We provide an overview of the Bitcoin and Zerocoin protocols. For more details, we refer the reader to Nakamoto <em>[nakamoto]</em> and Miers et al. <em>[miers]</em> respectively.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">A.1 Bitcoin</h3>

    <p class="text-gray-300">Bitcoin <em>[nakamoto]</em> is a decentralized currency operated by a collection of mutually-distrusting peers. It consists of three basic components: (i) a peer-to-peer network for broadcasting new transactions; (ii) semantics for identifying and validating new transactions; and (iii) a protocol for maintaining a decentralized ledger, known as the <em>block chain</em>, that stores the history of all valid transactions so far.</p>

    <p class="text-gray-300">Identities in Bitcoin are represented via ECDSA public keys. Each user <span class="math">u</span> generates an ECDSA key pair <span class="math">(\\mathsf{vk}_{u},\\mathsf{sk}_{u})</span> and, to receive payments, publishes the verification key <span class="math">\\mathsf{vk}_{u}</span> (or its hash) as an address. (In fact, there is no limit to the number of addresses that an individual user may possess.)</p>

    <p class="text-gray-300">Transactions. A <em>transaction</em> <span class="math">\\mathsf{tx}</span> represents a payment from a list of input transactions to a list of output recipients. More precisely, <span class="math">\\mathsf{tx}</span> is specified by a list <span class="math">\\{I_{j}\\}_{j}</span> of inputs and a list <span class="math">\\{O_{j}\\}_{j}</span> of outputs. Each output <span class="math">O_{j}</span> specifies a value <span class="math">v_{j}</span>, denominated in <em>Satoshi</em> (<span class="math">10^{9}</span> Satoshi amounts to 1 bitcoin), and a recipient specification <span class="math">r_{j}</span>, called ScriptPubKey. The specification <span class="math">r_{j}</span> is given in <em>Bitcoin script</em>, a stack-based non-Turing-complete language similar to Forth, and specifies the identity of the recipient of the <span class="math">v_{j}</span> Satoshi. Each input <span class="math">I_{j}</span> references an output of a previous transaction <span class="math">\\mathsf{tx}_{j}</span>: the reference is specified by a tuple <span class="math">(h_{j},k_{j},\\sigma_{j})</span>, where <span class="math">h_{j}</span> is the hash of <span class="math">\\mathsf{tx}_{j}</span>, <span class="math">k_{j}</span> is an index specifying which output of <span class="math">\\mathsf{tx}_{j}</span> is referenced, and <span class="math">\\sigma_{j}</span>, called ScriptSig, is a an input satisfying the ScriptPubKey of the <span class="math">k_{j}</span>-th output of <span class="math">\\mathsf{tx}_{j}</span>. Typically, the ScriptPubKey specifies a public key that must sign the transaction spending the output and <span class="math">\\sigma_{j}</span> contains such a signature, hence their names. Inputs can only be claimed by one transaction to prevent double spending.</p>

    <p class="text-gray-300">The total number of bitcoins output by a transaction, <span class="math">\\sum_{j}v_{j}</span>, cannot exceed the total value of the referenced outputs. Any difference between these two quantities is claimed as a <em>transaction fee</em> (see below). Thus, any unspent inputs to a transaction become a fee, and transactions typically have at least two outputs: one to the payment’s recipient and one back to the sender as “change”.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The block chain. Transactions are broadcast in the Bitcoin peer-to-peer network, but are considered valid only once they have been added to the the block chain. To assemble the block chain, <em>miners</em> (usually but not necessarily, network nodes) collect transactions from the Bitcoin network and bundle them into <em>blocks</em>. Miners then compete for the opportunity to append their own candidate block <span class="math">B</span> to the block chain by searching for a string <span class="math">s</span> such that the integer specified by SHA256(SHA256($B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s$)) is below some threshold. To incentivize block creation, miners receive a protocol-specified reward (currently 25 BTC) for adding a new block and, moreover, receive per-transaction fees (whose value is specified by the transaction’s creator).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of work protects a block against tampering and also ensures that meaningful computational resources were devoted to finding it. This prevents a sybil attack since all the sybils share the same total computational resources (e.g., the server they are virtualized on). Bitcoin assumes that provided more than half the computational work is held by honest nodes, the block-chain is secure. (Though recent work <em>[esma2023block]</em> has suggested that the threshold may be larger than 50%.)</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">A.2 Zerocoin</h3>

    <p class="text-gray-300">Zerocoin extends Bitcoin by creating two new transaction types: <em>mint</em> and <em>spend</em>. A mint transaction allows a user to exchange a quantity of bitcoins for the right to mint a new <em>zerocoin</em>. Each zerocoin consists of a digital commitment <span class="math">\\mathsf{cm}</span> to a random serial number <span class="math">\\mathsf{sn}</span>. At a later point, a (potentially</p>

    <p class="text-gray-300">different) user may issue a spend transaction containing a destination identity, the serial number sn, and a non-interactive zero-knowledge proof for the NP statement “I know secret cm and <span class="math">r</span> such that (i) cm can be opened to sn with commitment randomness <span class="math">r</span>, and (ii) cm was previously minted at some point in the past”. Crucially, the proof, being zero knowledge, <em>does not link the spend transaction to any particular mint transaction</em> (among all mint transactions so far). If the proof verifies correctly and the serial number has not been spent previously, the protocol semantics transfer a corresponding amount of bitcoins to the destination address. In this fashion, Zerocoin functions as a decentralized mix.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zerocoin uses Pedersen commitments over a prime field <span class="math">\\mathbb{F}_{p}</span>, i.e., <span class="math">\\texttt{cm}:=g^{\\texttt{sn}}h^{r}</span>, for random generators <span class="math">g,h</span> of a subgroup of <span class="math">\\mathbb{F}_{p}^{<em>}</span>. The corresponding zero-knowledge proofs are constructed by first </em>accumulating<em> (via the Strong-RSA accumulator of </em>[x10]*) the set of commitments of all minted zerocoins, and then proving knowledge of the corresponding commitment randomness and membership in this set. For technical reasons, the proof requires a double-discrete-logarithm (DDL) Fiat–Shamir proof of size $\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda<span class="math">, where </span>\\lambda<span class="math"> is the security parameter. In practice, the size of these proofs exceeds </span>45\\text{\\,}\\mathrm{kB}<span class="math"> at the 128-bit security level, and require </span>450\\text{\\,}\\mathrm{ms}$ or more to verify.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Also note that, in Zerocoin, computing the witness for the accumulator requires access to the <em>entire</em> set of commitments so far (though the witness can be incrementally updated for each insertion). This technique supports an unlimited number of coins. In contrast, our construction places a cap <span class="math">N</span> on the number of coins (in our implementation, <span class="math">N=2^{64}</span>) but needs only <span class="math">\\log N</span> updates to issue <span class="math">N</span> new coins (and these updates can be efficiently batched, cf. Section 8.3.1).</p>

    <h2 id="sec-76" class="text-2xl font-bold">Appendix B Completeness of DAP schemes</h2>

    <p class="text-gray-300">A DAP scheme <span class="math">\\Pi=(\\texttt{Setup},\\texttt{CreateAddress},\\texttt{Mint},\\texttt{Pour},\\texttt{VerifyTransaction},\\texttt{Receive})</span> is complete if no polynomial-size ledger sampler <span class="math">\\mathcal{S}</span> can win the incompleteness experiment with more than negligible probability. In Section 3.4 we informally described this property; we now formally define it.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Definition B.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\texttt{Setup},\\texttt{CreateAddress},\\texttt{Mint},\\texttt{Pour},\\texttt{VerifyTransaction},\\texttt{Receive})</span> be a (candidate) DAP scheme. We say that <span class="math">\\Pi</span> is complete if, for every <span class="math">\\text{poly}(\\lambda)</span>-size ledger sampler <span class="math">\\mathcal{S}</span> and sufficiently large <span class="math">\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">\\texttt{Adv}_{\\Pi,\\mathcal{S}}^{\\texttt{INCOMP}}(\\lambda)&lt;\\text{negl}(\\lambda)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">\\texttt{Adv}_{\\Pi,\\mathcal{S}}^{\\texttt{INCOMP}}(\\lambda):=\\Pr[\\texttt{INCOMP}(\\Pi,\\mathcal{S},\\lambda)=1]</span> is <span class="math">\\mathcal{S}</span>’s advantage in the incompleteness experiment.</p>

    <p class="text-gray-300">We now describe the incompleteness experiment mentioned above. Given a (candidate) DAP scheme <span class="math">\\Pi</span>, a ledger sampler <span class="math">\\mathcal{S}</span>, and a security parameter <span class="math">\\lambda</span>, the (probabilistic) experiment <span class="math">\\texttt{INCOMP}(\\Pi,\\mathcal{S},\\lambda)</span> consists of an interaction between <span class="math">\\mathcal{S}</span> and a challenger <span class="math">\\mathcal{C}</span>, terminating with a binary output by <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">At the beginning of the experiment, <span class="math">\\mathcal{C}</span> samples <span class="math">\\texttt{pp}\\leftarrow\\texttt{Setup}(1^{\\lambda})</span> and sends pp to <span class="math">\\mathcal{S}</span>. Then, <span class="math">\\mathcal{S}</span> sends <span class="math">\\mathcal{C}</span> a ledger, two coins to be spent, and parameters for a pour transaction; more precisely, <span class="math">\\mathcal{S}</span> sends (1) a ledger <span class="math">L</span>; (2) two coins <span class="math">\\texttt{c}_{1}^{\\texttt{old}}</span>, <span class="math">\\texttt{c}_{2}^{\\texttt{old}}</span>; (3) two address secret keys <span class="math">\\texttt{addr}_{\\texttt{sk},1}^{\\texttt{old}},\\texttt{addr}_{\\texttt{sk},2}^{\\texttt{old}}</span>; (4) two values <span class="math">v_{1}^{\\texttt{new}},v_{2}^{\\texttt{new}}</span>; (5) new address key pairs <span class="math">(\\texttt{addr}_{\\texttt{pk},1}^{\\texttt{new}},\\texttt{addr}_{\\texttt{sk},1}^{\\texttt{new}}),(\\texttt{addr}_{\\texttt{pk},2}^{\\texttt{new}},\\texttt{addr}_{\\texttt{sk},2}^{\\texttt{new}})</span>; (6) a public value <span class="math">v_{\\texttt{pub}}</span>; and (7) a transaction string info. Afterwards, <span class="math">\\mathcal{C}</span> performs various checks on <span class="math">\\mathcal{S}</span>’s message.</p>

    <p class="text-gray-300">Concretely, <span class="math">\\mathcal{C}</span> first checks that <span class="math">\\texttt{c}_{1}^{\\texttt{old}}</span> and <span class="math">\\texttt{c}_{2}^{\\texttt{old}}</span> are valid unspent coins, i.e., checks that: (i) <span class="math">\\texttt{c}_{1}^{\\texttt{old}}</span> and <span class="math">\\texttt{c}_{2}^{\\texttt{old}}</span> are well-formed; (ii) their coin commitments <span class="math">\\texttt{cm}_{1}^{\\texttt{old}}</span> and <span class="math">\\texttt{cm}_{2}^{\\texttt{old}}</span> appear in (valid) transactions on <span class="math">L</span>; (iii) their serial numbers <span class="math">\\texttt{sn}_{1}^{\\texttt{old}}</span> and <span class="math">\\texttt{sn}_{2}^{\\texttt{old}}</span> do <em>not</em> appear in (valid) transactions on <span class="math">L</span>. Next, <span class="math">\\mathcal{C}</span> checks that <span class="math">v_{1}^{\\texttt{new}}+v_{2}^{\\texttt{new}}+v_{\\texttt{pub}}=v_{1}^{\\texttt{old}}+v_{2}^{\\texttt{old}}</span> (i.e., the values suggested by <span class="math">\\mathcal{S}</span> preserve balance) and <span class="math">v_{1}^{\\texttt{old}}+v_{2}^{\\texttt{old}}\\leq v_{\\texttt{max}}</span> (i.e., the maximum value is not exceeded). If any of these checks fail, <span class="math">\\mathcal{C}</span> aborts and outputs <span class="math">0</span>.</p>

    <p class="text-gray-300">Otherwise, <span class="math">\\mathcal{C}</span> computes <span class="math">\\mathsf{rt}</span>, the Merkle-tree root over all coin commitments in <span class="math">L</span> (appearing in valid transactions), and, for <span class="math">i \\in \\{1,2,\\}</span>, <span class="math">\\mathsf{path}_i</span>, the authentication path from commitment <span class="math">\\mathsf{cm}_i^{\\mathrm{old}}</span> to the root <span class="math">\\mathsf{rt}</span>. Then, <span class="math">\\mathcal{C}</span> attempts to spend <span class="math">\\mathbf{c}_1^{\\mathrm{old}}</span>, <span class="math">\\mathbf{c}_2^{\\mathrm{old}}</span> as instructed by <span class="math">\\mathcal{S}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {c} _ {1} ^ {\\text {n e w}}, \\mathbf {c} _ {2} ^ {\\text {n e w}}, \\operatorname {t x} _ {\\text {P o u r}}\\right) \\leftarrow \\operatorname {P o u r} (\\mathrm {p p}, \\mathrm {r t}, \\mathbf {c} _ {1} ^ {\\text {o l d}}, \\mathbf {c} _ {2} ^ {\\text {o l d}}, \\operatorname {a d d r} _ {\\mathrm {s k}, 1} ^ {\\text {o l d}}, \\operatorname {a d d r} _ {\\mathrm {s k}, 2} ^ {\\text {o l d}}, \\operatorname {p a t h} _ {1}, \\operatorname {p a t h} _ {2}, v _ {1} ^ {\\text {n e w}}, v _ {2} ^ {\\text {n e w}}, \\operatorname {a d d r} _ {\\mathrm {p k}, 1} ^ {\\text {n e w}}, \\operatorname {a d d r} _ {\\mathrm {p k}, 2} ^ {\\text {n e w}}, v _ {\\text {p u b}}, \\text {i n f o}\\right).</span></div>

    <p class="text-gray-300">Finally, <span class="math">\\mathcal{C}</span> outputs 1 if and only if any of the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{tx}_{\\mathsf{Pour}} \\neq (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, *)</span>, where <span class="math">\\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}</span> are the coin commitments of <span class="math">\\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}</span>; OR</li>

      <li><span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> is not valid, i.e., VerifyTransaction(pp, <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}, L</span>) outputs 0; OR</li>

      <li>for some <span class="math">i \\in \\{1,2\\}</span>, the coin <span class="math">\\mathbf{c}_i^{\\mathrm{new}}</span> is not returned by Receive(pp, (addrpk,i, addrsk,i), <span class="math">L&#x27;</span>), where <span class="math">L&#x27;</span> is the ledger obtained by appending <span class="math">\\mathrm{tx}_{\\mathrm{Pour}}</span> to <span class="math">L</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Remark.</strong> There is no need for the challenger <span class="math">\\mathcal{C}</span> check that, in turn, both <span class="math">\\mathbf{c}_1^{\\mathrm{new}}</span> and <span class="math">\\mathbf{c}_2^{\\mathrm{new}}</span> are spendable, because this follows by induction. Namely, if <span class="math">\\mathbf{c}_1^{\\mathrm{new}}, \\mathbf{c}_2^{\\mathrm{new}}</span> were not spendable, a different sampler <span class="math">\\mathcal{S}&#x27;</span> (that simulates <span class="math">\\mathcal{S}</span> and then computes and outputs <span class="math">\\mathbf{c}_1^{\\mathrm{new}}</span> and <span class="math">\\mathbf{c}_2^{\\mathrm{new}}</span>) would provide a counterexample to the above definition.</p>

    <h2 id="sec-78" class="text-2xl font-bold">C Security of DAP schemes</h2>

    <p class="text-gray-300">A DAP scheme <span class="math">\\Pi = (\\text{Setup}, \\text{CreateAddress}, \\text{Mint}, \\text{Pour}, \\text{VerifyTransaction}, \\text{Receive})</span> is <em>secure</em> if it satisfies ledger indistinguishability, transaction non-malleability, and balance. (See Definition 3.2.) In Section 3.4 we informally described these three properties; we now formally define them.</p>

    <p class="text-gray-300">Each of the definitions employs an experiment involving a (stateful) DAP oracle <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span> that receives and answers queries from an adversary <span class="math">\\mathcal{A}</span> (proxied via a challenger <span class="math">\\mathcal{C}</span>, which performs the experiment-specific sanity checks). Below, we first describe how <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span> works.</p>

    <p class="text-gray-300">The oracle <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span> is initialized by a list of public parameters <span class="math">\\mathsf{pp}</span> and maintains state. Internally, <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span> stores: (i) <span class="math">L</span>, a ledger; (ii) ADDR, a set of address key pairs; (iii) COIN, a set of coins. All of <span class="math">L, \\mathsf{ADDR}, \\mathsf{COIN}</span> start out empty. The oracle <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span> accepts different types of queries, and each query causes different updates to <span class="math">L, \\mathsf{ADDR}, \\mathsf{COIN}</span> and outputs. We now describe each type of query <span class="math">Q</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q = (\\text{CreateAddress})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}}) := \\text{CreateAddress}(\\mathsf{pp})</span>.</li>

      <li>Add the address key pair <span class="math">(\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}})</span> to ADDR.</li>

      <li>Output the address public key <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>.</li>

    </ol>

    <p class="text-gray-300">The ledger <span class="math">L</span> and coin set COIN remain unchanged.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q = (\\text{Mint}, v, \\text{addr}_{\\text{pk}})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathbf{c}, \\mathrm{tx}_{\\text{Mint}}) := \\text{Mint}(\\mathrm{pp}, v, \\mathrm{addr}_{\\mathrm{pk}})</span>.</li>

      <li>Add the coin <span class="math">\\mathbf{c}</span> to COIN.</li>

      <li>Add the mint transaction <span class="math">\\mathrm{tx}_{\\text{Mint}}</span> to <span class="math">L</span>.</li>

      <li>Output <span class="math">\\perp</span>.</li>

    </ol>

    <p class="text-gray-300">The address set ADDR remains unchanged.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q = (\\text{Pour}, \\mathrm{idx}_1^{\\mathrm{old}}, \\mathrm{idx}_2^{\\mathrm{old}}, \\mathrm{addr}_{\\mathrm{pk},1}^{\\mathrm{old}}, \\mathrm{addr}_{\\mathrm{pk},2}^{\\mathrm{old}}, \\mathrm{info}, v_1^{\\mathrm{new}}, v_2^{\\mathrm{new}}, \\mathrm{addr}_{\\mathrm{pk},1}^{\\mathrm{new}}, \\mathrm{addr}_{\\mathrm{pk},2}^{\\mathrm{new}}, v_{\\mathrm{pub}})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\mathsf{rt}</span>, the root of a Merkle tree over all coin commitments in <span class="math">L</span>.</li>

      <li>For each <span class="math">i \\in \\{1, 2\\}</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Let <span class="math">\\mathsf{cm}_i^{\\mathrm{old}}</span> be the <span class="math">\\mathrm{idx}_i^{\\mathrm{old}}</span>-th coin commitment in <span class="math">L</span>.</p>

    <p class="text-gray-300">40</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{tx}_{i}</span> be the mint/pour transaction in <span class="math">L</span> that contains <span class="math">\\mathsf{cm}_{i}^{\\mathsf{old}}</span>.</li>

      <li>Let <span class="math">\\mathsf{c}_{i}^{\\mathsf{old}}</span> be the first coin in <span class="math">\\mathsf{COIN}</span> with coin commitment <span class="math">\\mathsf{cm}_{i}^{\\mathsf{old}}</span>.</li>

      <li>Let <span class="math">(\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{old}},\\mathsf{addr}_{\\mathsf{sk},i}^{\\mathsf{old}})</span> be the first key pair in <span class="math">\\mathsf{ADDR}</span> with <span class="math">\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{old}}</span> being <span class="math">\\mathsf{c}_{i}^{\\mathsf{old}}</span>’s address.</li>

      <li>Compute <span class="math">\\mathsf{path}_{i}</span>, the authentication path from <span class="math">\\mathsf{cm}_{i}^{\\mathsf{old}}</span> to <span class="math">\\mathsf{rt}</span>.</li>

      <li>Compute <span class="math">(\\mathsf{c}_{1}^{\\mathsf{new}},\\mathsf{c}_{2}^{\\mathsf{new}},\\mathsf{tx}_{\\mathsf{Pour}}):=\\mathsf{Pour}(\\mathsf{pp},\\mathsf{rt},\\mathsf{c}_{1}^{\\mathsf{old}},\\mathsf{c}_{2}^{\\mathsf{old}},\\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{old}},\\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}},\\mathsf{path}_{1},\\mathsf{path}_{2},v_{1}^{\\mathsf{new}},v_{2}^{\\mathsf{new}},</span> <span class="math">\\mathsf{addr}_{\\mathsf{pk},1}^{\\mathsf{new}},\\mathsf{addr}_{\\mathsf{pk},2}^{\\mathsf{new}},v_{\\mathsf{pub}},\\mathsf{info})</span>.</li>

      <li>Verify that <span class="math">\\mathsf{VerifyTransaction}(\\mathsf{pp},\\mathsf{tx}_{\\mathsf{Pour}},L)</span> outputs 1.</li>

      <li>Add the coin <span class="math">\\mathsf{c}_{1}^{\\mathsf{new}}</span> to <span class="math">\\mathsf{COIN}</span>.</li>

      <li>Add the coin <span class="math">\\mathsf{c}_{2}^{\\mathsf{new}}</span> to <span class="math">\\mathsf{COIN}</span>.</li>

      <li>Add the pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> to <span class="math">L</span>.</li>

      <li>Output <span class="math">\\bot</span>.</li>

    </ol>

    <p class="text-gray-300">If any of the above operations fail, the output is <span class="math">\\bot</span> (and <span class="math">L,\\mathsf{ADDR},\\mathsf{COIN}</span> remain unchanged).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q=(\\mathbf{Receive},\\mathsf{addr}_{\\mathsf{pk}})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Look up <span class="math">(\\mathsf{addr}_{\\mathsf{pk}},\\mathsf{addr}_{\\mathsf{sk}})</span> in <span class="math">\\mathsf{ADDR}</span>. (If no such key pair is found, abort.)</li>

      <li>Compute <span class="math">(\\mathsf{c}_{1},\\ldots,\\mathsf{c}_{n})\\leftarrow\\mathsf{Receive}(\\mathsf{pp},(\\mathsf{addr}_{\\mathsf{pk}},\\mathsf{addr}_{\\mathsf{sk}}),L)</span>.</li>

      <li>Add <span class="math">\\mathsf{c}_{1},\\ldots,\\mathsf{c}_{n}</span> to <span class="math">\\mathsf{COIN}</span>.</li>

      <li>Output <span class="math">(\\mathsf{cm}_{1},\\ldots,\\mathsf{cm}_{n})</span>, the corresponding coin commitments.</li>

    </ol>

    <p class="text-gray-300">The ledger <span class="math">L</span> and address set <span class="math">\\mathsf{ADDR}</span> remain unchanged.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q=(\\mathbf{Insert},\\mathsf{tx})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify that <span class="math">\\mathsf{VerifyTransaction}(\\mathsf{pp},\\mathsf{tx},L)</span> outputs 1. (Else, abort.)</li>

      <li>Add the mint/pour transaction <span class="math">\\mathsf{tx}</span> to <span class="math">L</span>.</li>

      <li>Run <span class="math">\\mathbf{Receive}</span> for all addresses <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> in <span class="math">\\mathsf{ADDR}</span>; this updates the <span class="math">\\mathsf{COIN}</span> with any coins that might have been sent to honest parties via <span class="math">\\mathsf{tx}</span>.</li>

      <li>Output <span class="math">\\bot</span>.</li>

    </ol>

    <p class="text-gray-300">The address set <span class="math">\\mathsf{ADDR}</span> remains unchanged.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Remark.</h6>

    <p class="text-gray-300">The oracle <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span> provides <span class="math">\\mathcal{A}</span> with two ways to cause a pour transaction to be added to <span class="math">L</span>. If <span class="math">\\mathcal{A}</span> has already obtained address public keys <span class="math">\\mathsf{addr}_{\\mathsf{pk},1}</span> and <span class="math">\\mathsf{addr}_{\\mathsf{pk},2}</span> (via previous CreateAddress queries), then <span class="math">\\mathcal{A}</span> can use a Pour query to elicit a pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> (despite not knowing address secret keys <span class="math">\\mathsf{addr}_{\\mathsf{sk},1},\\mathsf{addr}_{\\mathsf{sk},2}</span> corresponding to <span class="math">\\mathsf{addr}_{\\mathsf{pk},1},\\mathsf{addr}_{\\mathsf{pk},2}</span>). Alternatively, if <span class="math">\\mathcal{A}</span> has himself generated both address public keys, then <span class="math">\\mathcal{A}</span> knows corresponding address secret keys, and can invoke <span class="math">\\mathsf{Pour}</span> “in his head” to obtain a pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>, which he can add to <span class="math">L</span> by using an Insert query. In the first case, both addresses belong to honest users; in the second, both to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">But what about pour transactions where one address belongs to an honest user and one to <span class="math">\\mathcal{A}</span>? Such pour transactions might arise from MPC computations (e.g., to make matching donations). The ledger oracle <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>, as defined above, does not support such queries. While extending the definition is straightforward, for simplicity we leave handling such queries to future work.</p>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">C.1 Ledger indistinguishability</h3>

    <p class="text-gray-300">Ledger indistinguishability is characterized by an experiment <span class="math">\\mathsf{L}</span>-<span class="math">\\mathsf{IND}</span>, which involves a polynomial-size adversary <span class="math">\\mathcal{A}</span> attempting to break a given (candidate) <span class="math">\\mathsf{DAP}</span> scheme.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Definition C.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathsf{CreateAddress},\\mathsf{Mint},\\mathsf{Pour},\\mathsf{VerifyTransaction},\\mathsf{Receive})</span> be a (candidate) <span class="math">\\mathsf{DAP}</span> scheme. We say that <span class="math">\\Pi</span> is <span class="math">\\mathsf{L}</span>-<span class="math">\\mathsf{IND}</span> secure if, for every <span class="math">\\mathrm{poly}(\\lambda)</span>-size adversary <span class="math">\\mathcal{A}</span> and sufficiently large <span class="math">\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\Pi,\\mathcal{A}}^{\\mathsf{L}\\text{-}\\mathsf{IND}}(\\lambda)&lt;\\mathrm{negl}(\\lambda)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Adv}_{\\Pi,\\mathcal{A}}^{\\mathsf{L}\\text{-IND}}(\\lambda):=2\\cdot\\Pr[\\mathsf{L}\\text{-IND}(\\Pi,\\mathcal{A},\\lambda)=1]-1</span> is <span class="math">\\mathcal{A}</span>’s advantage in the <span class="math">\\mathsf{L}\\text{-IND}</span> experiment.</p>

    <p class="text-gray-300">We now describe the <span class="math">\\mathsf{L}\\text{-IND}</span> experiment mentioned above. Given a (candidate) DAP scheme <span class="math">\\Pi</span>, adversary <span class="math">\\mathcal{A}</span>, and security parameter <span class="math">\\lambda</span>, the (probabilistic) experiment <span class="math">\\mathsf{L}\\text{-IND}(\\Pi,\\mathcal{A},\\lambda)</span> consists of an interaction between <span class="math">\\mathcal{A}</span> and a challenger <span class="math">\\mathcal{C}</span>, terminating with a binary output by <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">At the beginning of the experiment, <span class="math">\\mathcal{C}</span> samples <span class="math">b\\in\\{0,1\\}</span> at random, samples <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span>, and sends <span class="math">\\mathsf{pp}</span> to <span class="math">\\mathcal{A}</span>; next, <span class="math">\\mathcal{C}</span> initializes (using <span class="math">\\mathsf{pp}</span>) two separate DAP oracles <span class="math">\\mathcal{O}_{0}^{\\mathsf{DAP}}</span> and <span class="math">\\mathcal{O}_{1}^{\\mathsf{DAP}}</span> (i.e., the two oracles have separate ledgers and internal tables).</p>

    <p class="text-gray-300">The experiment proceeds in steps and, at each step, <span class="math">\\mathcal{C}</span> provides to <span class="math">\\mathcal{A}</span> two ledgers <span class="math">(L_{\\mathsf{Left}},L_{\\mathsf{Right}})</span>, where <span class="math">L_{\\mathsf{Left}}:=L_{b}</span> is the current ledger in <span class="math">\\mathcal{O}_{b}^{\\mathsf{DAP}}</span> and <span class="math">L_{\\mathsf{Right}}:=L_{1-b}</span> the one in <span class="math">\\mathcal{O}_{1-b}^{\\mathsf{DAP}}</span>; then <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{C}</span> a pair of queries <span class="math">(Q,Q^{\\prime})</span>, which must be of the <em>same</em> type (i.e., one of CreateAddress, Mint, Pour, Receive, Insert). The challenger <span class="math">\\mathcal{C}</span> acts differently depending on the query type, as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the query type is Insert, <span class="math">\\mathcal{C}</span> forwards <span class="math">Q</span> to <span class="math">\\mathcal{O}_{b}^{\\mathsf{DAP}}</span>, and <span class="math">Q^{\\prime}</span> to <span class="math">\\mathcal{O}_{1-b}^{\\mathsf{DAP}}</span>. This allows <span class="math">\\mathcal{A}</span> to insert his own transactions directly in <span class="math">L_{\\mathsf{Left}}</span> and <span class="math">L_{\\mathsf{Right}}</span>.</li>

      <li>For any other query type, <span class="math">\\mathcal{C}</span> first ensures that <span class="math">Q,Q^{\\prime}</span> are <em>publicly consistent</em> (see below) and then forwards <span class="math">Q</span> to <span class="math">\\mathcal{O}_{0}^{\\mathsf{DAP}}</span>, and <span class="math">Q^{\\prime}</span> to <span class="math">\\mathcal{O}_{1}^{\\mathsf{DAP}}</span>; letting <span class="math">(a_{0},a_{1})</span> be the two oracle answers, <span class="math">\\mathcal{C}</span> replies to <span class="math">\\mathcal{A}</span> with <span class="math">(a_{b},a_{1-b})</span>. This allows <span class="math">\\mathcal{A}</span> to elicit behavior from honest users. However note that <span class="math">\\mathcal{A}</span> does not know the bit <span class="math">b</span>, and hence the mapping between <span class="math">(L_{\\mathsf{Left}},L_{\\mathsf{Right}})</span> and <span class="math">(L_{0},L_{1})</span>; in other words, <span class="math">\\mathcal{A}</span> does not know if he elicits behavior on <span class="math">(L_{0},L_{1})</span> or on <span class="math">(L_{1},L_{0})</span>.</li>

    </ul>

    <p class="text-gray-300">At the end of the experiment, <span class="math">\\mathcal{A}</span> sends <span class="math">\\mathcal{C}</span> a guess <span class="math">b^{\\prime}\\in\\{0,1\\}</span>. If <span class="math">b=b^{\\prime}</span>, <span class="math">\\mathcal{C}</span> outputs <span class="math">1</span>; else, <span class="math">\\mathcal{C}</span> outputs <span class="math">0</span>.</p>

    <h4 id="sec-82" class="text-lg font-semibold mt-6">Public consistency.</h4>

    <p class="text-gray-300">As mentioned above, <span class="math">\\mathcal{A}</span> sends <span class="math">\\mathcal{C}</span> pairs of queries <span class="math">(Q,Q^{\\prime})</span>, which must be of the same type and publicly consistent, a property that we now define. If <span class="math">Q,Q^{\\prime}</span> are both of type CreateAddress or Receive, then they are always publicly consistent. In the special case of CreateAddress we require that both oracles generate the same address. If they are both of type Mint, then the minted value in <span class="math">Q</span> must equal that in <span class="math">Q^{\\prime}</span>. Finally, if they are both of type Pour, the following restrictions apply.</p>

    <p class="text-gray-300">First, <span class="math">Q,Q^{\\prime}</span> must be individually well-formed; namely, (i) the coin commitments referenced by <span class="math">Q</span> (via the two indices <span class="math">\\mathsf{idx}_{1}^{\\mathsf{old}},\\mathsf{idx}_{2}^{\\mathsf{old}}</span>) must correspond to coins <span class="math">\\mathbf{c}_{1}^{\\mathsf{old}},\\mathbf{c}_{2}^{\\mathsf{old}}</span> that appear in the ledger oracle’s coin table <span class="math">\\mathsf{COIN}</span>; (ii) the two coins <span class="math">\\mathbf{c}_{1}^{\\mathsf{old}},\\mathbf{c}_{2}^{\\mathsf{old}}</span> must be unspent (i.e. their serial numbers must not appear in a valid pour transactions on the corresponding oracle’s ledger); (iii) the address public keys specified in <span class="math">Q</span> must match those in <span class="math">\\mathbf{c}_{1}^{\\mathsf{old}},\\mathbf{c}_{2}^{\\mathsf{old}}</span>; and (iv) the balance equation must hold (i.e., <span class="math">v_{1}^{\\mathsf{new}}+v_{2}^{\\mathsf{new}}+v_{\\mathsf{pub}}=v_{1}^{\\mathsf{old}}+v_{2}^{\\mathsf{old}}</span>).</p>

    <p class="text-gray-300">Furthermore, <span class="math">Q,Q^{\\prime}</span> must be jointly consistent with respect to public information and <span class="math">\\mathcal{A}</span>’s view; namely: (i) the public values in <span class="math">Q</span> and <span class="math">Q^{\\prime}</span> must equal; (ii) the transaction strings in <span class="math">Q</span> and <span class="math">Q^{\\prime}</span> must equal; (iii) for each <span class="math">i\\in\\{1,2\\}</span>, if the <span class="math">i</span>-th recipient addresses in <span class="math">Q</span> is not in <span class="math">\\mathsf{ADDR}</span> (i.e., belongs to <span class="math">\\mathcal{A}</span>) then <span class="math">v_{i}^{\\mathsf{new}}</span> in <em>both</em> <span class="math">Q</span> and <span class="math">Q^{\\prime}</span> must equal (and vice versa for <span class="math">Q^{\\prime}</span>); and (iv) for each <span class="math">i\\in\\{1,2\\}</span>, if the <span class="math">i</span>-th index in <span class="math">Q</span> references (in <span class="math">L_{0}</span>) a coin commitment contained in a transaction that was posted via an Insert query, then the corresponding index in <span class="math">Q^{\\prime}</span> must reference (in <span class="math">L_{1}</span>) a coin commitment that also appears in a transaction posted via an Insert query and, moreover, <span class="math">v_{i}^{\\mathsf{old}}</span> in <em>both</em> <span class="math">Q</span> and <span class="math">Q^{\\prime}</span> must equal (and vice versa for <span class="math">Q^{\\prime}</span>). The challenger <span class="math">\\mathcal{C}</span> learns <span class="math">v_{i}^{\\mathsf{old}}</span> by looking-up the corresponding coin <span class="math">\\mathbf{c}_{i}^{\\mathsf{old}}</span> in the oracle’s coin set <span class="math">\\mathsf{COIN}</span>. (v) for each <span class="math">i\\in\\{1,2\\}</span> if the <span class="math">i</span>-th index in <span class="math">Q</span> must not reference a coin that has previously been spent.</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">C.2 Transaction non-malleability</h3>

    <p class="text-gray-300">Transaction non-malleability is characterized by an experiment <span class="math">\\mathsf{TR}\\text{-}\\mathsf{NM}</span>, which involves a polynomial-size adversary <span class="math">\\mathcal{A}</span> attempting to break a given (candidate) DAP scheme.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Definition C.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=({\\sf Setup},{\\sf CreateAddress},{\\sf Mint},{\\sf Pour},{\\sf VerifyTransaction},{\\sf Receive})</span> be a (candidate) DAP scheme. We say that <span class="math">\\Pi</span> is <span class="math">{\\sf TR\\mathchar 45\\relax N\\mathchar 45\\relax}</span> secure if, for every <span class="math">\\mathrm{poly}(\\lambda)</span>-size adversary <span class="math">\\mathcal{A}</span> and sufficiently large <span class="math">\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">{\\sf Adv}^{\\sf TR\\mathchar 45\\relax N\\mathchar 45\\relax}_{{\\Pi,\\mathcal{A}}}(\\lambda)</span> <span class="math">&lt;{\\rm negl}(\\lambda)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">{\\sf Adv}^{\\sf TR\\mathchar 45\\relax N\\mathchar 45\\relax}_{{\\Pi,\\mathcal{A}}}(\\lambda):=\\Pr[{\\sf TR\\mathchar 45\\relax N\\mathchar 45\\relax}({\\Pi,\\mathcal{A}},\\lambda)=1]</span> is <span class="math">\\mathcal{A}</span>’s advantage in the <span class="math">{\\sf TR\\mathchar 45\\relax N\\mathchar 45\\relax}</span> experiment.</p>

    <p class="text-gray-300">We now describe the <span class="math">{\\sf TR\\mathchar 45\\relax N\\mathchar 45\\relax}</span> experiment mentioned above. Given a (candidate) DAP scheme <span class="math">\\Pi</span>, adversary <span class="math">\\mathcal{A}</span>, and security parameter <span class="math">\\lambda</span>, the (probabilistic) experiment <span class="math">{\\sf TR\\mathchar 45\\relax N\\mathchar 45\\relax}({\\Pi,\\mathcal{A}},\\lambda)</span> consists of an interaction between <span class="math">\\mathcal{A}</span> and a challenger <span class="math">\\mathcal{C}</span>, terminating with a binary output by <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">At the beginning of the experiment, <span class="math">\\mathcal{C}</span> samples <span class="math">{\\sf pp}\\leftarrow{\\sf Setup}(1^{\\lambda})</span> and sends <span class="math">{\\sf pp}</span> to <span class="math">\\mathcal{A}</span>; next, <span class="math">\\mathcal{C}</span> initializes a DAP oracle <span class="math">\\mathcal{O}^{\\sf DAP}</span> with <span class="math">{\\sf pp}</span> and allows <span class="math">\\mathcal{A}</span> to issue queries to <span class="math">\\mathcal{O}^{\\sf DAP}</span>. At the end of the experiment, <span class="math">\\mathcal{A}</span> sends <span class="math">\\mathcal{C}</span> a pour transaction <span class="math">{\\sf tx}^{<em>}</span>, and <span class="math">\\mathcal{C}</span> outputs <span class="math">1</span> if and only if the following conditions hold. Letting <span class="math">\\mathcal{T}</span> be the set of pour transactions generated by <span class="math">\\mathcal{O}^{\\sf DAP}</span> in response to <span class="math">{\\bf Pour}</span> queries, there exists <span class="math">{\\sf tx}\\in\\mathcal{T}</span> such that: (i) <span class="math">{\\sf tx}^{</em>}\\neq{\\sf tx}</span>; (ii) <span class="math">{\\sf VerifyTransaction}({\\sf pp},{\\sf tx}^{<em>},L^{\\prime})=1</span>, where <span class="math">L^{\\prime}</span> is the portion of the ledger preceding <span class="math">{\\sf tx}</span>; and (iii) a serial number revealed in <span class="math">{\\sf tx}^{</em>}</span> is also revealed in <span class="math">{\\sf tx}</span>.</p>

    <h3 id="sec-85" class="text-xl font-semibold mt-8">C.3 Balance</h3>

    <p class="text-gray-300">Balance is characterized by an experiment <span class="math">{\\sf BAL}</span>, which involves a polynomial-size adversary <span class="math">\\mathcal{A}</span> attempting to break a given (candidate) DAP scheme.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition C.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=({\\sf Setup},{\\sf CreateAddress},{\\sf Mint},{\\sf Pour},{\\sf VerifyTransaction},{\\sf Receive})</span> be a (candidate) DAP scheme. We say that <span class="math">\\Pi</span> is <span class="math">{\\sf BAL}</span> secure if, for every <span class="math">\\mathrm{poly}(\\lambda)</span>-size adversary <span class="math">\\mathcal{A}</span> and sufficiently large <span class="math">\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">{\\sf Adv}^{\\sf BAL}_{\\Pi,\\mathcal{A}}(\\lambda)</span> <span class="math">&lt;{\\rm negl}(\\lambda)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">{\\sf Adv}^{\\sf BAL}_{\\Pi,\\mathcal{A}}(\\lambda):=\\Pr[{\\sf BAL}(\\Pi,\\mathcal{A},\\lambda)=1]</span> is <span class="math">\\mathcal{A}</span>’s advantage in the <span class="math">{\\sf BAL}</span> experiment.</p>

    <p class="text-gray-300">We now describe the <span class="math">{\\sf BAL}</span> experiment mentioned above. Given a (candidate) DAP scheme <span class="math">\\Pi</span>, adversary <span class="math">\\mathcal{A}</span>, and security parameter <span class="math">\\lambda</span>, the (probabilistic) experiment <span class="math">{\\sf BAL}(\\Pi,\\mathcal{A},\\lambda)</span> consists of an interaction between <span class="math">\\mathcal{A}</span> and a challenger <span class="math">\\mathcal{C}</span>, terminating with a binary output by <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">At the beginning of the experiment, <span class="math">\\mathcal{C}</span> samples <span class="math">{\\sf pp}\\leftarrow{\\sf Setup}(1^{\\lambda})</span>, and sends <span class="math">{\\sf pp}</span> to <span class="math">\\mathcal{A}</span>; next, <span class="math">\\mathcal{C}</span> (using <span class="math">{\\sf pp}</span>) initializes a DAP oracle <span class="math">\\mathcal{O}^{\\sf DAP}</span> and allows <span class="math">\\mathcal{A}</span> to issue queries to <span class="math">\\mathcal{O}^{\\sf DAP}</span>. At the conclusion of the experiment, <span class="math">\\mathcal{A}</span> sends <span class="math">\\mathcal{C}</span> a set of coins <span class="math">S_{\\sf coin}</span>. Recalling that <span class="math">{\\sf ADDR}</span> is the set of addresses returned by <span class="math">{\\bf CreateAddress}</span> queries (i.e., addresses of “honest” users), <span class="math">\\mathcal{C}</span> computes the following five quantities.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">v_{\\sf Unspent}</span>, the total value of all spendable coins in <span class="math">S_{\\sf coin}</span>. The challenger <span class="math">\\mathcal{C}</span> can check if a coin <span class="math">{\\bf c}\\in S_{\\sf coin}</span> is spendable as follows: mint a fresh coin <span class="math">{\\bf c}^{\\prime}</span> of value <span class="math">0</span> (via a <span class="math">{\\bf Mint}</span> query) and check if a corresponding <span class="math">{\\bf Pour}</span> query consuming <span class="math">{\\bf c},{\\bf c}^{\\prime}</span> yields a pour transaction <span class="math">{\\sf tx}_{\\sf Pour}</span> that is valid.</li>

      <li><span class="math">v_{\\sf Mint}</span>, the total value of all coins minted by <span class="math">\\mathcal{A}</span>. To compute <span class="math">v_{\\sf Mint}</span>, the challenger <span class="math">\\mathcal{C}</span> sums up the values of all coins that (i) were minted via <span class="math">{\\bf Mint}</span> queries using addresses not in <span class="math">{\\sf ADDR}</span>, or (ii) whose mint transactions were directly placed on the ledger via <span class="math">{\\bf Insert}</span> queries.</li>

      <li><span class="math">v_{\\sf ADDR\\to\\mathcal{A}}</span>, the total value payments received by <span class="math">\\mathcal{A}</span> from addresses in <span class="math">{\\sf ADDR}</span>. To compute <span class="math">v_{\\sf ADDR\\to\\mathcal{A}}</span>, the challenger <span class="math">\\mathcal{C}</span> looks up all pour transactions placed on the ledger via <span class="math">{\\bf Pour}</span> queries and sums up the values that were transferred to addresses not in <span class="math">{\\sf ADDR}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">v_{\\mathcal{A}\\to\\mathsf{ADDR}}</span>, the total value of payments sent by <span class="math">\\mathcal{A}</span> to addresses in <span class="math">\\mathsf{ADDR}</span>. To compute <span class="math">v_{\\mathcal{A}\\to\\mathsf{ADDR}}</span>, the challenger <span class="math">\\mathcal{C}</span> first deduces the set <span class="math">S^{\\prime}\\subseteq\\mathsf{COIN}</span> of all coins received by honest parties and then sums up the values of coins in <span class="math">S^{\\prime}</span>. (Note that <span class="math">\\mathcal{C}</span> can compute <span class="math">S^{\\prime}</span> by selecting all coins in <span class="math">\\mathsf{COIN}</span> that are both tied to an address in <span class="math">\\mathsf{ADDR}</span> and arose from transactions placed on the ledger by Insert queries.)</li>

      <li><span class="math">v_{\\mathsf{Basecoin}}</span>, the total value of public outputs placed by <span class="math">\\mathcal{A}</span> on the ledger. To compute <span class="math">v_{\\mathsf{Basecoin}}</span>, the challenger <span class="math">\\mathcal{C}</span> looks up all pour transactions placed on the ledger by Insert and sums up the corresponding <span class="math">v_{\\mathsf{pub}}</span> values.</li>

    </ul>

    <p class="text-gray-300">At the end of the experiment, <span class="math">\\mathcal{C}</span> outputs 1 if <span class="math">v_{\\mathsf{Unspent}}+v_{\\mathsf{Basecoin}}+v_{\\mathcal{A}\\to\\mathsf{ADDR}}&gt;v_{\\mathsf{Mint}}+v_{\\mathsf{ADDR}\\to\\mathcal{A}}</span>; else, <span class="math">\\mathcal{C}</span> outputs 0.</p>

    <p class="text-gray-300">Remark. There are two methods for <span class="math">\\mathcal{A}</span> to spend more public-output money than he owns: (i) by directly inserting transactions on the ledger, and (ii) by asking honest parties to create such transactions. The first method is accounted for in the computation of <span class="math">v_{\\mathsf{Basecoin}}</span>, while the second method is accounted for in the computation of <span class="math">v_{\\mathcal{A}\\to\\mathsf{ADDR}}</span> (since <span class="math">\\mathcal{A}</span> must first pay the honest party).</p>

    <h2 id="sec-87" class="text-2xl font-bold">Appendix D Proof of Theorem 4.1</h2>

    <p class="text-gray-300">We prove Theorem 4.1. We omit a formal proof of the completeness claim; one can verify that the DAP scheme’s completeness follows, in a straightforward way, from the completeness of the construction’s building blocks. Next, we argue security via three separate proofs, respectively showing that our construction satisfies (i) ledger indistinguishability, (ii) transaction non-malleability, and (iii) balance.</p>

    <h3 id="sec-88" class="text-xl font-semibold mt-8">D.1 Proof of ledger indistinguishability</h3>

    <p class="text-gray-300">We describe a simulation <span class="math">\\partial_{\\mathsf{sim}}</span> in which the adversary <span class="math">\\mathcal{A}</span> interacts with a challenger <span class="math">\\mathcal{C}</span>, as in the <span class="math">\\mathsf{L}\\text{-}\\mathsf{IND}</span> experiment. However <span class="math">\\partial_{\\mathsf{sim}}</span> differs from the <span class="math">\\mathsf{L}\\text{-}\\mathsf{IND}</span> experiment in a critical way: all answers sent to <span class="math">\\mathcal{A}</span> are computed <em>independently</em> of the bit <span class="math">b</span>, so that <span class="math">\\mathcal{A}</span>’s advantage in <span class="math">\\partial_{\\mathsf{sim}}</span> is 0. The remainder of the proof is devoted to showing that <span class="math">\\mathsf{Adv}_{\\Pi,\\mathcal{A}}^{\\mathsf{L}\\text{-}\\mathsf{IND}}(\\lambda)</span> (i.e., <span class="math">\\mathcal{A}</span>’s advantage in the <span class="math">\\mathsf{L}\\text{-}\\mathsf{IND}</span> experiment) is at most negligibly different than <span class="math">\\mathcal{A}</span>’s advantage in <span class="math">\\partial_{\\mathsf{sim}}</span>.</p>

    <p class="text-gray-300">The simulation. The simulation <span class="math">\\partial_{\\mathsf{sim}}</span> works as follows. First, after sampling <span class="math">b\\in\\{0,1\\}</span> at random, <span class="math">\\mathcal{C}</span> samples <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span>, with the following modification: the zk-SNARK keys are generated as <span class="math">(\\mathsf{pk}_{\\mathsf{POUR}},\\mathsf{vk}_{\\mathsf{POUR}},\\mathsf{trap})\\leftarrow\\mathsf{Sim}(1^{\\lambda},C_{\\mathsf{POUR}})</span>, to obtain the zero-knowledge trapdoor <span class="math">\\mathsf{trap}</span>. Then, as in the <span class="math">\\mathsf{L}\\text{-}\\mathsf{IND}</span> experiment, <span class="math">\\mathcal{C}</span> sends <span class="math">\\mathsf{pp}</span> to <span class="math">\\mathcal{A}</span>, and then initializes two separate DAP oracles <span class="math">\\mathcal{O}_{0}^{\\mathsf{DAP}}</span> and <span class="math">\\mathcal{O}_{1}^{\\mathsf{DAP}}</span>.</p>

    <p class="text-gray-300">Afterwards, as in <span class="math">\\mathsf{L}\\text{-}\\mathsf{IND}</span>, <span class="math">\\partial_{\\mathsf{sim}}</span> proceeds in steps and, at each step, <span class="math">\\mathcal{C}</span> provides to <span class="math">\\mathcal{A}</span> two ledgers <span class="math">(L_{\\mathsf{Left}},L_{\\mathsf{Right}})</span>, where <span class="math">L_{\\mathsf{Left}}:=L_{b}</span> is the current ledger in <span class="math">\\mathcal{O}_{b}^{\\mathsf{DAP}}</span> and <span class="math">L_{\\mathsf{Right}}:=L_{1-b}</span> the one in <span class="math">\\mathcal{O}_{1-b}^{\\mathsf{DAP}}</span>; then <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{C}</span> a message <span class="math">(Q,Q^{\\prime})</span>, which consist of two (publicly-consistent) queries of the same type. The challenger <span class="math">\\mathcal{C}</span> acts differently depending on the query type, as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Answering <span class="math">\\mathsf{CreateAddress}</span> queries.</em> In this case, <span class="math">Q=Q^{\\prime}=\\mathsf{CreateAddress}</span>.</li>

    </ul>

    <p class="text-gray-300">To answer <span class="math">Q</span>, <span class="math">\\mathcal{C}</span> behaves as in <span class="math">\\mathsf{L}\\text{-}\\mathsf{IND}</span>, except for the following modification: after obtaining <span class="math">(\\mathsf{addr}_{\\mathsf{pk}},\\mathsf{addr}_{\\mathsf{sk}})\\leftarrow\\mathsf{CreateAddress}(\\mathsf{pp})</span>, <span class="math">\\mathcal{C}</span> replaces <span class="math">a_{\\mathsf{pk}}</span> in <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> with a random string of the appropriate length; then, <span class="math">\\mathcal{C}</span> stores <span class="math">\\mathsf{addr}_{\\mathsf{sk}}</span> in a table and returns <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Afterwards, <span class="math">\\mathcal{C}</span> does the same for <span class="math">Q^{\\prime}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Answering Mint queries. In this case, <span class="math">Q = (\\mathbf{Mint}, v, \\mathsf{addr}_{\\mathsf{pk}})</span> and <span class="math">Q&#x27; = (\\mathbf{Mint}, v, \\mathsf{addr}_{\\mathsf{pk}}&#x27;)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To answer <span class="math">Q</span>, <span class="math">\\mathcal{C}</span> behaves as in L-IND, except for the following modification: the Mint algorithm computes the commitment <span class="math">k</span> as $\\mathsf{COMM}_r(\\tau \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math">, for a random string </span>\\tau<span class="math"> of the appropriate length, instead of as </span>\\mathsf{COMM}_r(a_{\\mathsf{pk}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math">, where </span>a_{\\mathsf{pk}}<span class="math"> is the value specified in </span>\\mathsf{addr}_{\\mathsf{pk}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Afterwards, <span class="math">\\mathcal{C}</span> does the same for <span class="math">Q&#x27;</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Answering Pour queries. In this case, <span class="math">Q</span> and <span class="math">Q&#x27;</span> both have the form <span class="math">(\\mathbf{Pour}, \\mathsf{cm}_1^{\\mathrm{old}}, \\mathsf{cm}_2^{\\mathrm{old}}, \\mathsf{addr}_{\\mathsf{pk},1}^{\\mathrm{old}})</span>, <span class="math">\\mathsf{addr}_{\\mathsf{pk},2}^{\\mathrm{old}}</span>, <span class="math">\\mathsf{info}</span>, <span class="math">v_1^{\\mathrm{new}}</span>, <span class="math">v_2^{\\mathrm{new}}</span>, <span class="math">\\mathsf{addr}_{\\mathsf{pk},1}^{\\mathrm{new}}</span>, <span class="math">\\mathsf{addr}_{\\mathsf{pk},2}^{\\mathrm{new}}</span>, <span class="math">v_{\\mathsf{pub}}^{\\mathrm{new}}</span>).</li>

    </ul>

    <p class="text-gray-300">To answer <span class="math">Q</span>, <span class="math">\\mathcal{C}</span> modifies the way some values are computed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\mathsf{rt}_i</span> by accumulating all of the valid coin commitments on <span class="math">L_i</span>.</li>

      <li>Set <span class="math">v_{\\mathrm{pub}}</span> and <span class="math">\\mathsf{info}</span> to the corresponding input values.</li>

      <li>For each <span class="math">j \\in \\{1, 2\\}</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Sample a uniformly random <span class="math">\\mathsf{sn}_j^{\\mathrm{old}}</span>. (b) If <span class="math">\\mathsf{addr}_{\\mathsf{pk},j}^{\\mathsf{new}}</span> is an address generated by a previous query to CreateAddress, (i) sample a coin commitment <span class="math">\\mathsf{cm}_j^{\\mathsf{new}}</span> on a random input, (ii) run <span class="math">\\mathcal{K}_{\\mathrm{enc}}(\\mathsf{pp}_{\\mathrm{enc}}) \\to (\\mathsf{pk}_{\\mathrm{enc}}, \\mathsf{sk}_{\\mathrm{enc}})</span> and compute <span class="math">\\mathbf{C}_j^{\\mathrm{new}} := \\mathcal{E}_{\\mathrm{enc}}(\\mathsf{pk}_{\\mathrm{enc}}, r)</span> for a random <span class="math">r</span> of suitable length. (c) Otherwise, calculate <span class="math">(\\mathsf{cm}_i^{\\mathsf{new}}, \\mathbf{C}_i^{\\mathsf{new}})</span> as in the Pour algorithm.²⁸</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">h_1</span> and <span class="math">h_2</span> to be random strings of the appropriate length.</li>

      <li>Compute all remaining values as in the Pour algorithm</li>

      <li>The pour proof is computed as <span class="math">\\pi_{\\mathsf{POUR}} := \\mathsf{Sim}(\\mathsf{trap}, x)</span>, where <span class="math">x := (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathrm{old}}, \\mathsf{sn}_2^{\\mathrm{old}}, \\mathsf{cm}_1^{\\mathrm{new}}, \\mathsf{cm}_2^{\\mathrm{new}}, v_{\\mathsf{pub}}, h_1, h_2)</span>.</li>

    </ol>

    <p class="text-gray-300">Afterwards, <span class="math">\\mathcal{C}</span> does the same for <span class="math">Q&#x27;</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Answering Receive queries. In this case, <span class="math">Q = (\\mathbf{Receive}, \\mathsf{addr}_{\\mathsf{pk}})</span> and <span class="math">Q&#x27; = (\\mathbf{Receive}, \\mathsf{addr}_{\\mathsf{pk}}&#x27;)</span>. The answer to each query proceeds as in the L-IND experiment.</li>

      <li>Answering Insert queries. In this case, <span class="math">Q = (\\mathbf{Insert}, \\mathbf{tx})</span> and <span class="math">Q = (\\mathbf{Insert}, \\mathbf{tx}&#x27;)</span>. The answer to each query proceeds as in the L-IND experiment.</li>

    </ul>

    <p class="text-gray-300">In each of the above cases, the response to <span class="math">\\mathcal{A}</span> is computed independently of the bit <span class="math">b</span>. Thus, when <span class="math">\\mathcal{A}</span> outputs a guess <span class="math">b&#x27;</span>, it must be the case that <span class="math">\\operatorname*{Pr}[b = b&#x27;] = 1/2</span>, i.e., <span class="math">\\mathcal{A}</span>'s advantage in <span class="math">\\partial_{\\mathrm{sim}}</span> is 0.</p>

    <p class="text-gray-300">Proof that the simulation is indistinguishable from the real experiment. We now describe a sequence of hybrid experiments <span class="math">(\\partial_{\\mathrm{real}}, \\partial_1, \\partial_2, \\partial_3, \\partial_{\\mathrm{sim}})</span> in each of which a challenger <span class="math">\\mathcal{C}</span> conducts a modification of the L-IND experiment with <span class="math">\\mathcal{A}</span>. We define <span class="math">\\partial_{\\mathrm{real}}</span> to be the original L-IND experiment, and <span class="math">\\partial_{\\mathrm{sim}}</span> to be the simulation described above.</p>

    <p class="text-gray-300">With a slight abuse of notation, given experiment <span class="math">\\partial</span>, we define <span class="math">\\mathsf{Adv}^{\\partial}</span> to be the absolute value of the difference between (i) the L-IND advantage of <span class="math">\\mathcal{A}</span> in <span class="math">\\partial</span> and (ii) the L-IND advantage of <span class="math">\\mathcal{A}</span> in <span class="math">\\partial_{\\mathrm{real}}</span>. Also, let</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">q_{\\mathbf{CA}}</span> be the total number of CreateAddress queries issued by <span class="math">\\mathcal{A}</span>,</li>

      <li><span class="math">q_{\\mathbf{P}}</span> be the total number of Pour queries issued by <span class="math">\\mathcal{A}</span>, and</li>

      <li><span class="math">q_{\\mathbf{M}}</span> be the total number of Mint queries issued by <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <p class="text-gray-300">Finally, define <span class="math">\\mathsf{Adv}^{\\mathsf{Enc}}</span> to be <span class="math">\\mathcal{A}</span>'s advantage in <span class="math">\\mathsf{Enc}</span>'s IND-CCA and IK-CCA experiments, <span class="math">\\mathsf{Adv}^{\\mathsf{PRF}}</span> to be <span class="math">\\mathcal{A}</span>'s advantage in distinguishing the pseudorandom function PRF from a random one, and <span class="math">\\mathsf{Adv}^{\\mathsf{COMM}}</span> to be <span class="math">\\mathcal{A}</span>'s advantage against the hiding property of COMM.</p>

    <p class="text-gray-300">We now describe each of the hybrid experiments.</p>

    <p class="text-gray-300">²⁸ Note that by the restrictions of the experiment, the value <span class="math">v_i^{\\mathrm{new}}</span> is identical between <span class="math">Q_{\\mathrm{Left}}</span> and <span class="math">Q_{\\mathrm{Right}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Experiment <span class="math">\\supset_{1}</span>. The experiment <span class="math">\\supset_{1}</span> modifies <span class="math">\\supset_{\\text{real}}</span> by simulating the zk-SNARKs. More precisely, we modify <span class="math">\\supset_{\\text{real}}</span> so that <span class="math">\\mathcal{C}</span> simulates each zk-SNARK proof, as follows. At the beginning of the experiment, instead of invoking <span class="math">\\text{KeyGen}(1^{\\lambda}, C_{\\text{POUR}})</span>, <span class="math">\\mathcal{C}</span> invokes <span class="math">\\text{Sim}(1^{\\lambda}, C_{\\text{POUR}})</span> and obtains <span class="math">(\\text{pk}_{\\text{POUR}}, \\text{vk}_{\\text{POUR}}, \\text{trap})</span>. At each subsequent invocation of the Pour algorithm, <span class="math">\\mathcal{C}</span> computes <span class="math">\\pi_{\\text{POUR}} \\gets \\text{Sim}(\\text{trap}, x)</span>, without using any witnesses, instead of using Prove. Since the zk-SNARK system is perfect zero knowledge, the distribution of the simulated <span class="math">\\pi_{\\text{POUR}}</span> is identical to that of the proofs computed in <span class="math">\\supset_{\\text{real}}</span>. Hence <span class="math">\\text{Adv}^{\\supset_{1}} = 0</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Experiment <span class="math">\\supset_{2}</span>. The experiment <span class="math">\\supset_{2}</span> modifies <span class="math">\\supset_{1}</span> by replacing the ciphertexts in a pour transaction by encryptions of random strings. More precisely, we modify <span class="math">\\supset_{1}</span> so that, each time <span class="math">\\mathcal{A}</span> issues a Pour query where one of the output addresses <span class="math">(\\text{addr}_{\\text{pk},1}^{\\text{new}}, \\text{addr}_{\\text{pk},2}^{\\text{new}})</span> is in the set of addresses previously generated by a CreateAddress query, the two ciphertexts <span class="math">\\mathbf{C}_1^{\\text{new}}, \\mathbf{C}_2^{\\text{new}}</span> are generated as follows: (i) <span class="math">(\\text{pk}_{\\text{enc}}^{\\text{new}}, \\text{sk}_{\\text{enc}}^{\\text{new}}) \\leftarrow \\mathcal{K}_{\\text{enc}}(\\text{pp}_{\\text{enc}})</span>; (ii) for each <span class="math">j \\in \\{1, 2\\}</span>, <span class="math">\\mathbf{C}_j^{\\text{new}} := \\mathcal{E}_{\\text{enc}}(\\text{pk}_{\\text{enc},j}^{\\text{new}}, r)</span> where <span class="math">r</span> is a message sampled uniformly from the plaintext space of the encryption scheme. By Lemma D.1 (see below), $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Adv}^{\\supset_{2}} - \\text{Adv}^{\\supset_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\text{Adv}^{\\text{Enc}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Experiment <span class="math">\\supset_{3}</span>. The experiment <span class="math">\\supset_{3}</span> modifies <span class="math">\\supset_{2}</span> by replacing all PRF-generated values with random strings. More precisely, we modify <span class="math">\\supset_{2}</span> so that:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>each time <span class="math">\\mathcal{A}</span> issues a CreateAddress query, the value <span class="math">a_{\\text{pk}}</span> within the returned <span class="math">\\text{addr}_{\\text{pk}}</span> is substituted with a random string of the same length;</li>

      <li>each time <span class="math">\\mathcal{A}</span> issues a Pour query, each of the serial numbers <span class="math">\\text{sn}_1^{\\text{old}}, \\text{sn}_2^{\\text{old}}</span> in <span class="math">\\text{tx}_{\\text{Pour}}</span> is substituted with a random string of the same length, and <span class="math">h_{\\text{info}}</span> with a random string of the same length.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma D.2 (see below), $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Adv}^{\\supset_3} - \\text{Adv}^{\\supset_2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_{\\mathbf{CA}} \\cdot \\text{Adv}^{\\text{PRF}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Experiment <span class="math">\\supset_{\\text{sim}}</span>. The experiment <span class="math">\\supset_{\\text{sim}}</span> is already described above. For comparison, we explain how it differs from <span class="math">\\supset_{3}</span>: the coin commitments are replaced with commitments to random inputs. More precisely, we modify <span class="math">\\supset_{3}</span> so that:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>each time <span class="math">\\mathcal{A}</span> issues a Mint query, the coin commitment <span class="math">\\text{cm}</span> in <span class="math">\\text{tx}_{\\text{Mint}}</span> is substituted with a commitment to a random input; and</li>

      <li>each time <span class="math">\\mathcal{A}</span> issues a Pour query, then, for each <span class="math">j \\in \\{1,2\\}</span>, if the output address <span class="math">\\text{addr}_{\\text{pk},j}^{\\text{new}}</span> is in the set of addresses previously generated by an CreateAddress query, <span class="math">\\text{cm}_j^{\\text{new}}</span> is substituted with a commitment to a random input.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma D.3 (see below), $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Adv}^{\\supset_{\\text{sim}}} - \\text{Adv}^{\\supset_3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (q_{\\mathbf{M}} + 4 \\cdot q_{\\mathbf{P}}) \\cdot \\text{Adv}^{\\text{COMM}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As argued above, the responses provided to <span class="math">\\mathcal{A}</span> in <span class="math">\\supset_{\\text{sim}}</span> are independent of the bit <span class="math">b</span>, so that <span class="math">\\text{Adv}^{\\supset_{\\text{sim}}} = 0</span>. Then, by summing over <span class="math">\\mathcal{A}</span>'s advantages in the hybrid experiments, we can bound <span class="math">\\mathcal{A}</span>'s advantage in <span class="math">\\supset_{\\text{real}}</span> by</p>

    <div class="my-4 text-center"><span class="math-block">\\text{Adv}_{\\Pi,\\mathcal{A}}^{\\text{L-IND}}(\\lambda) \\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\text{Adv}^{\\text{Enc}} + q_{\\mathbf{CA}} \\cdot \\text{Adv}^{\\text{PRF}} + (q_{\\mathbf{M}} + 4 \\cdot q_{\\mathbf{P}}) \\cdot \\text{Adv}^{\\text{COMM}},</span></div>

    <p class="text-gray-300">which is negligible in <span class="math">\\lambda</span>. This concludes the proof of ledger indistinguishability. Below, we sketch proofs for the lemmas used above (Lemma D.1, Lemma D.2, and Lemma D.3).</p>

    <p class="text-gray-300"><strong>Lemma D.1.</strong> Let <span class="math">\\text{Adv}^{\\text{Enc}}</span> be the maximum of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span>'s advantage in the IND-CCA experiment against the encryption scheme Enc, and</li>

      <li><span class="math">\\mathcal{A}</span>'s advantage in the IK-CCA experiment against the encryption scheme Enc.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then after <span class="math">q_{\\mathbf{P}}</span> Pour queries, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Adv}^{\\supset_2} - \\text{Adv}^{\\supset_1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\text{Adv}^{\\text{Enc}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">46</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof sketch. Define <span class="math">\\epsilon := \\mathsf{Adv}^{\\supset_2} - \\mathsf{Adv}^{\\supset_1}</span>. Using <span class="math">\\mathcal{A}</span>, we first show how to construct a solver with advantage <span class="math">\\geq \\frac{\\epsilon}{2 \\cdot q_{\\mathbf{P}}}</span> in the IK-CCA or IND-CCA experiments. We use a hybrid <span class="math">\\mathbf{H}</span>, intermediate between <span class="math">\\supset_1</span> and <span class="math">\\supset_2</span>; concretely, <span class="math">\\mathbf{H}</span> modifies <span class="math">\\supset_1</span> so that each ciphertext (where the corresponding public key appears in the set generated by a CreateAddress query) is replaced with the encryption of the same plaintext, but under a new, random public key generated via the <span class="math">\\mathcal{K}_{\\mathrm{enc}}</span> algorithm. (For comparison, <span class="math">\\supset_2</span> modifies <span class="math">\\mathbf{H}</span> so that each plaintext is replaced with a random plaintext drawn from the plaintext space.) We now argue that <span class="math">\\mathcal{A}</span>'s advantage in distinguishing <span class="math">\\mathbf{H}</span> and <span class="math">\\supset_1</span> is at most <span class="math">2 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}</span>, and so is for distinguishing <span class="math">\\supset_2</span> and <span class="math">\\mathbf{H}</span>. Overall, we deduce that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}^{\\supset_2} - \\mathsf{Adv}^{\\supset_1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we discuss <span class="math">\\mathbf{H}</span> and <span class="math">\\supset_1</span>. For some <span class="math">j \\in \\{1, \\dots, q_{\\mathbf{CA}}\\}</span>, when <span class="math">\\mathcal{A}</span> makes the <span class="math">j</span>-th query of the form CreateAddress, query the IK-CCA challenger to obtain two public keys <span class="math">(\\mathsf{pk}_{\\mathrm{enc},0}, \\mathsf{pk}_{\\mathrm{enc},1})</span> and return <span class="math">\\mathsf{pk}_{\\mathrm{enc}} := \\mathsf{pk}_{\\mathrm{enc},0}</span> in the response to <span class="math">\\mathcal{A}</span>. At the time <span class="math">\\mathcal{A}</span> issues a Pour query that results in the <span class="math">i</span>-th ciphertext <span class="math">\\mathbf{C}_i</span> being encrypted under <span class="math">\\mathsf{pk}_{\\mathrm{enc}}</span>, query the IK-CCA challenger on the corresponding plaintext <span class="math">m</span> and receive <span class="math">\\mathbf{C}^<em> = \\mathcal{E}_{\\mathrm{enc}}(\\mathsf{pk}_{\\mathrm{enc},\\bar{b}}, m)</span> where <span class="math">\\bar{b}</span> is the bit chosen by the IK-CCA challenger. Substitute <span class="math">\\mathbf{C}_i := \\mathbf{C}^</em></span> and write the resulting <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> to the Ledger. When <span class="math">\\mathcal{A}</span> outputs <span class="math">b&#x27;</span> we return this guess as our guess in the IK-CCA experiment. We note that when <span class="math">\\bar{b} = 0</span> then <span class="math">\\mathcal{A}</span>'s view of the interaction is distributed identically to that of <span class="math">\\supset_1</span>, and when <span class="math">\\bar{b}</span> is 1 then <span class="math">\\mathcal{A}</span>'s view represents an intermediate hybrid where one key has been substituted. By a standard hybrid argument over each of the <span class="math">2 \\cdot q_{\\mathbf{P}}</span> ciphertexts, we note that over the random coins of the experiment, our solver must succeed in the IK-CCA experiment with advantage <span class="math">\\geq \\frac{\\epsilon}{2 \\cdot q_{\\mathbf{P}}}</span>. If we assume a maximum adversarial advantage <span class="math">\\mathsf{Adv}^{\\mathsf{Enc}}</span> against the IK-CCA experiment for the encryption scheme, then we get that $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}^{\\mathbf{H}} - \\mathsf{Adv}^{\\supset_2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we discuss <span class="math">\\supset_2</span> and <span class="math">\\mathbf{H}</span>; the argument is similar to the above one. This time, rather than replacing the key used to encrypt, we replace the plaintext with a random message drawn from the plaintext space; this final distribution is the same as in <span class="math">\\supset_2</span>. We omit the formal description of the resulting IND-CCA solver (which essentially follows the pattern above), and simply note that $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}^{\\supset_2} - \\mathsf{Adv}^{\\mathbf{H}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma D.2. Let <span class="math">\\mathsf{Adv}^{\\mathsf{PRF}}</span> be <span class="math">\\mathcal{A}</span>'s advantage in distinguishing the pseudorandom function PRF from a random function. Then, after <span class="math">q_{\\mathbf{CA}}</span> CreateAddress queries, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}^{\\supset_3} - \\mathsf{Adv}^{\\supset_2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_{\\mathbf{CA}} \\cdot \\mathsf{Adv}^{\\mathsf{PRF}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof sketch. We first describe a hybrid <span class="math">\\mathbf{H}</span>, intermediate between <span class="math">\\supset_2</span> and <span class="math">\\supset_3</span>, in which all values computed using the first (rather than all) oracle-generated key <span class="math">a_{\\mathbf{sk}}</span> are replaced with random strings. Then, we show that <span class="math">\\mathcal{A}</span>'s advantage in distinguishing between <span class="math">\\mathbf{H}</span> and <span class="math">\\supset_2</span> is at most <span class="math">\\mathsf{Adv}^{\\mathsf{PRF}}</span>. Finally, we extend the argument to all <span class="math">q_{\\mathbf{CA}}</span> oracle-generated keys (corresponding to what happens in <span class="math">\\supset_3</span>).</p>

    <p class="text-gray-300">We now describe <span class="math">\\mathbf{H}</span>. On receiving <span class="math">\\mathcal{A}</span>'s first CreateAddress query, replace the public address <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}})</span> with <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (\\tau, \\mathsf{pk}_{\\mathsf{enc}})</span> where <span class="math">\\tau</span> is a random string of the appropriate length. On each subsequent Pour query, for each <span class="math">i \\in \\{1, 2\\}</span>, if <span class="math">\\mathsf{addr}_{\\mathsf{pk}, i}^{\\mathsf{old}} = \\mathsf{addr}_{\\mathsf{pk}}</span> then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>in the output <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>, replace <span class="math">\\mathsf{sn}_i^{\\mathsf{old}}</span> with a random string of appropriate length;</li>

      <li>in the output <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>, replace each of <span class="math">h_1, h_2</span> with a random string of appropriate length.</li>

      <li>simulate the zk-SNARK proof <span class="math">\\pi_{\\mathsf{POUR}}</span> for the new transaction.</li>

    </ol>

    <p class="text-gray-300">Note that the above modifications do not affect the computation of the zk-SNARK proof <span class="math">\\pi_{\\mathsf{POUR}}</span>, because <span class="math">\\pi_{\\mathsf{POUR}}</span> is simulated with the help of a trapdoor.</p>

    <p class="text-gray-300">We now argue that <span class="math">\\mathcal{A}</span>'s advantage in distinguishing between <span class="math">\\mathbf{H}</span> and <span class="math">\\supset_2</span> is at most <span class="math">\\mathsf{Adv}^{\\mathsf{PRF}}</span>. Let <span class="math">a_{\\mathbf{sk}}</span> be the random, secret seed for PRF generated by the oracle in answering the first CreateAddress query. In <span class="math">\\supset_2</span> (as in <span class="math">\\supset_{\\mathrm{real}}</span>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a_{\\mathsf{pk}} := \\mathsf{PRF}_{a_{\\mathsf{sk}}}^{\\mathsf{addr}}(0)</span>;</li>

      <li>for each <span class="math">i \\in \\{1, 2\\}</span>, <span class="math">\\mathsf{sn}_i := \\mathsf{PRF}_{a_{\\mathsf{sk}}}^{\\mathsf{sn}}(\\rho)</span> for a random (and not previously used) <span class="math">\\rho</span></li>

    </ul>

    <p class="text-gray-300">47</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for each <span class="math">i \\in \\{1,2\\}</span>, $h_i := \\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{pk}}(i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathsf{Sig}})<span class="math"> and, with overwhelming probability, </span>h_{\\mathsf{Sig}}$ is unique.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, each of <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{addr}}</span>, <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{sn}}</span>, <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{pk}}</span> are constructed from <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}</span> as specified in Section 4.1. Note that, with overwhelming probability, no two calls to <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}</span> are made on the same input. First, even identical inputs passed to <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{addr}}</span>, <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{sn}}</span>, <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{pk}}</span> produce different underlying calls to <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}</span>. Second, within each construction, there is exactly one call to <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{addr}}</span>, and the calls to <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{sn}}</span> are each by definition unique. Finally, with overwhelming probability, the calls to <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{pk}}</span> from different transactions each reference a distinct digest <span class="math">h_{\\mathsf{Sig}}</span>, and, within a given transaction, the two calls each begin with a distinct prefix.</p>

    <p class="text-gray-300">Now let <span class="math">\\mathcal{O}</span> be an oracle that implements either <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}</span> or a random function. We show that if <span class="math">\\mathcal{A}</span> distinguishes <span class="math">\\mathbf{H}</span> from <span class="math">\\partial_2</span> with probability <span class="math">\\epsilon</span>, then we can construct a distinguisher for the two cases of <span class="math">\\mathcal{O}</span>. In either case we use <span class="math">\\mathcal{O}</span> to generate all values computed using <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{addr}}</span>, <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{sn}}</span>, <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}^{\\mathrm{pk}}</span>. Clearly, when <span class="math">\\mathcal{O}</span> implements <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk}}}</span>, the distribution of the experiment is identical to <span class="math">\\partial_2</span>; instead, when <span class="math">\\mathcal{O}</span> implements a random function, the distribution of the experiment is identical to <span class="math">\\mathbf{H}</span>. Thus, <span class="math">\\mathcal{A}</span>'s advantage is at most <span class="math">\\mathsf{Adv}^{\\mathsf{PRF}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, by a standard hybrid argument, we extend the above to all <span class="math">q_{\\mathbf{CA}}</span> oracle-generated addresses; then, <span class="math">\\mathcal{A}</span>'s differential distinguishing advantage is at most <span class="math">q_{\\mathbf{CA}} \\cdot \\mathsf{Adv}^{\\mathsf{PRF}}</span>. Because this final hybrid is equal to <span class="math">\\partial_3</span>, we deduce that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}^{\\partial_3} - \\mathsf{Adv}^{\\partial_2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_{\\mathbf{CA}} \\cdot \\mathsf{Adv}^{\\mathsf{PRF}}<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma D.3.</strong> Let <span class="math">\\mathsf{Adv}^{\\mathsf{COMM}}</span> be <span class="math">\\mathcal{A}</span>'s advantage against the hiding property of COMM. After <span class="math">q_{\\mathbf{M}}</span> Mint queries and <span class="math">q_{\\mathbf{P}}</span> Pour queries, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}^{\\partial_{\\mathrm{sim}}} - \\mathsf{Adv}^{\\partial_3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (q_{\\mathbf{M}} + 4 \\cdot q_{\\mathbf{P}}) \\cdot \\mathsf{Adv}^{\\mathsf{COMM}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof sketch.</strong> We only provide a short sketch, because the structure of the argument is similar to the one used to prove Lemma D.2 above.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the first Mint or Pour query, replace the "internal" commitment $k \\coloneqq \\mathsf{COMM}_r(a_{\\mathsf{pk}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math"> with a random string of the appropriate length. Since </span>\\rho<span class="math"> is random (and unique), then </span>\\mathcal{A}<span class="math">&#x27;s advantage in distinguishing this modified experiment from </span>\\partial_2<span class="math"> is at most </span>\\mathsf{Adv}^{\\mathsf{COMM}}<span class="math">. Then, if we similarly modify all </span>q_{\\mathbf{M}}<span class="math"> Mint queries and all </span>q_{\\mathbf{P}}<span class="math"> Pour queries, by replacing the resulting </span>q_{\\mathbf{M}} + 2 \\cdot q_{\\mathbf{P}}<span class="math"> internal commitments with random strings, we can bound </span>\\mathcal{A}<span class="math">&#x27;s advantage by </span>(q_{\\mathbf{M}} + 2 \\cdot q_{\\mathbf{P}}) \\cdot \\mathsf{Adv}^{\\mathsf{COMM}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, in a similar vein, if replace the coin commitment in the first Pour with a commitment to a random value, then <span class="math">\\mathcal{A}</span>'s advantage in distinguishing this modified experiment from the above one is at most <span class="math">\\mathsf{Adv}^{\\mathsf{COMM}}</span>. Then, if we similarly modify all <span class="math">q_{\\mathbf{P}}</span> Pour queries, by replacing the resulting <span class="math">2 \\cdot q_{\\mathbf{P}}</span> coin commitments with random strings, we obtain the experiment <span class="math">\\partial_{\\mathrm{sim}}</span>, and deduce that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}^{\\partial_{\\mathrm{sim}}} - \\mathsf{Adv}^{\\partial_3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (q_{\\mathbf{M}} + 4 \\cdot q_{\\mathbf{P}}) \\cdot \\mathsf{Adv}^{\\mathsf{COMM}}<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-89" class="text-2xl font-bold">D.2 Proof of transaction non-malleability</h2>

    <p class="text-gray-300">Letting <span class="math">\\mathcal{T}</span> be the set of pour transactions generated by <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span> in response to Pour queries, recall that <span class="math">\\mathcal{A}</span> wins the TR-NM experiment whenever it outputs <span class="math">\\mathsf{tx}^<em></span> such that there exists <span class="math">\\mathsf{tx}&#x27; \\in \\mathcal{T}</span> such that: (i) <span class="math">\\mathsf{tx}^</em> \\neq \\mathsf{tx}&#x27;</span>; (ii) VerifyTransaction <span class="math">(\\mathsf{pp}, \\mathsf{tx}^<em>, L&#x27;) = 1</span>, where <span class="math">L&#x27;</span> is the portion of the ledger preceding <span class="math">\\mathsf{tx}&#x27;</span>; and (iii) a serial number revealed in <span class="math">\\mathsf{tx}^</em></span> is also revealed in <span class="math">\\mathsf{tx}&#x27;</span>. Being a pour transaction, <span class="math">\\mathsf{tx}^<em></span> has the form <span class="math">(\\mathsf{rt}, \\mathsf{sn}_1^{\\mathrm{old}}, \\mathsf{sn}_2^{\\mathrm{old}}, \\mathsf{cm}_1^{\\mathrm{new}}, \\mathsf{cm}_2^{\\mathrm{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, </em>)</span>, where <span class="math">* := (\\mathsf{pk}_{\\mathrm{sig}}, h_1, h_2, \\pi_{\\mathsf{POUB}}, \\mathbf{C}_1, \\mathbf{C}_2, \\sigma)</span>; set <span class="math">h_{\\mathsf{Sig}} := \\mathsf{CRH}(\\mathsf{pk}_{\\mathrm{sig}})</span>. Let <span class="math">\\mathsf{pk}_{\\mathrm{sig}}&#x27;</span> be the corresponding public key in <span class="math">\\mathsf{tx}&#x27;</span> and set <span class="math">h_{\\mathsf{Sig}}&#x27; := \\mathsf{CRH}(\\mathsf{pk}_{\\mathrm{sig}}&#x27;)</span>.</p>

    <p class="text-gray-300">Define <span class="math">\\epsilon := \\mathsf{Adv}_{\\Pi, \\mathcal{A}}^{\\mathsf{TR - NM}}(\\lambda)</span>, and let <span class="math">\\mathcal{Q}_{\\mathbf{CA}} = \\{a_{\\mathbf{sk}, 1}, \\ldots, a_{\\mathbf{sk}, q_{\\mathbf{CA}}}\\}</span> be the set of internal address keys created by <span class="math">\\mathcal{C}</span> in response to <span class="math">\\mathcal{A}</span>'s CreateAddress queries. Let <span class="math">\\mathcal{Q}_{\\mathbf{P}} = (\\mathsf{pk}_{\\mathrm{sig}, 1}, \\ldots, \\mathsf{pk}_{\\mathrm{sig}, q_{\\mathbf{P}}})</span> be the set of signature public keys created by <span class="math">\\mathcal{C}</span> in response to <span class="math">\\mathcal{A}</span>'s Pour queries. We decompose the event in which <span class="math">\\mathcal{A}</span> wins into the following four disjoint events.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Event}_{\\mathsf{sig}}</span>: <span class="math">\\mathcal{A}</span> wins, and there is <span class="math">\\mathsf{pk}_{\\mathsf{sig}}^{\\prime \\prime} \\in \\mathcal{Q}_{\\mathbf{P}}</span> such that <span class="math">\\mathsf{pk}_{\\mathsf{sig}} = \\mathsf{pk}_{\\mathsf{sig}}^{\\prime \\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">48</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Event}_{\\mathsf{col}}</span>: <span class="math">\\mathcal{A}</span> wins, the above event does not occur, and there is <span class="math">\\mathsf{pk}_{\\mathsf{sig}}^{\\prime\\prime} \\in \\mathcal{Q}_{\\mathbf{P}}</span> such that <span class="math">h_{\\mathsf{Sig}} = \\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}}^{\\prime\\prime})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{Event}_{\\mathsf{mac}}</span>: <span class="math">\\mathcal{A}</span> wins, the above two events do not occur, and $h_i = \\mathsf{PRF}_a^{\\mathrm{pk}}(i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathsf{Sig}})<span class="math"> for some </span>i \\in \\{1, 2\\}<span class="math"> and </span>a \\in \\mathcal{Q}_{\\mathbf{CA}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Clearly, <span class="math">\\epsilon = \\operatorname<em>{Pr}\\left[\\mathrm{Event}_{\\mathrm{sig}}\\right] + \\operatorname</em>{Pr}\\left[\\mathrm{Event}_{\\mathrm{col}}\\right] + \\operatorname<em>{Pr}\\left[\\mathrm{Event}_{\\mathrm{key}}\\right] + \\operatorname</em>{Pr}\\left[\\mathrm{Event}_{\\mathrm{mac}}\\right]</span>. Hence, to show that <span class="math">\\epsilon</span> is negligible in <span class="math">\\lambda</span>, it suffices to argue that each of these probabilities is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300"><strong>Bounding the probability of <span class="math">\\text{Event}_{\\text{sig}}</span>.</strong> Define <span class="math">\\epsilon_1 := \\Pr[\\text{Event}_{\\text{sig}}]</span>. Let <span class="math">\\sigma</span> be the signature in <span class="math">\\mathsf{tx}^<em></span>, and <span class="math">\\sigma&#x27;&#x27;</span> be the signature in the first pour transaction <span class="math">\\mathsf{tx}&#x27;&#x27; \\in \\mathcal{T}</span> that contains <span class="math">\\mathsf{pk}_{\\text{sig}}&#x27;&#x27;</span>. When <span class="math">\\text{Event}_{\\text{sig}}</span> occurs, since <span class="math">\\mathsf{pk}_{\\text{sig}} = \\mathsf{pk}_{\\text{sig}}&#x27;&#x27;</span>, the two signatures are with respect to the same public key. Moreover, since <span class="math">\\mathsf{tx}^</em></span> is valid, <span class="math">\\mathcal{V}_{\\text{sig}}(\\mathsf{pk}_{\\text{sig}}, m, \\sigma) = 1</span> where <span class="math">m</span> is everything in <span class="math">\\mathsf{tx}^<em></span> but for <span class="math">\\sigma</span>. Let <span class="math">m&#x27;&#x27;</span> consist of all elements in <span class="math">\\mathsf{tx}&#x27;&#x27;</span> but for <span class="math">\\sigma&#x27;&#x27;</span>. Observe that whenever <span class="math">\\mathsf{tx}^</em> \\neq \\mathsf{tx}&#x27;&#x27;</span> we also have <span class="math">(m, \\sigma) \\neq (m&#x27;&#x27;, \\sigma&#x27;&#x27;)</span>. We use this fact below to show that <span class="math">\\mathcal{A}</span> forges a signature with non-negligible probability.</p>

    <p class="text-gray-300">First, we argue that, conditioned on <span class="math">\\mathsf{Event}_{\\mathsf{sig}}</span>, <span class="math">\\mathsf{tx}^<em> \\neq \\mathsf{tx}&#x27;&#x27;</span> with overwhelming probability; we do so by way of contradiction. First, since <span class="math">\\mathcal{A}</span> wins, by definition there is <span class="math">\\mathsf{tx}&#x27; \\in \\mathcal{T}</span> such that <span class="math">\\mathsf{tx}^</em> \\neq \\mathsf{tx}&#x27;</span> and yet each of <span class="math">\\mathsf{tx}^<em></span> and <span class="math">\\mathsf{tx}&#x27;</span> share one serial number. Therefore: (i) <span class="math">\\mathsf{tx}^</em> \\neq \\mathsf{tx}&#x27;</span>; and (ii) if <span class="math">\\mathsf{tx}^<em> = \\mathsf{tx}&#x27;&#x27;</span> then <span class="math">\\mathsf{tx}&#x27;&#x27;</span> and <span class="math">\\mathsf{tx}&#x27;</span> also share a serial number. However the probability that <span class="math">\\mathsf{tx}&#x27;</span> and <span class="math">\\mathsf{tx}&#x27;&#x27;</span> share a serial number is bounded by the probability <span class="math">\\tilde{p}</span> that <span class="math">\\mathcal{T}</span> contains two transactions that share the same serial number. Because each serial number is computed as <span class="math">\\mathsf{PRF}_{\\mathrm{stg}}^{\\mathrm{sn}}(\\rho)</span>, where <span class="math">\\rho</span> is random, <span class="math">\\tilde{p}</span> is negligible. We conclude that <span class="math">\\mathsf{tx}^</em> \\neq \\mathsf{tx}&#x27;&#x27;</span> with all but negligible probability.</p>

    <p class="text-gray-300">Next, we describe an algorithm <span class="math">\\mathcal{B}</span>, which uses <span class="math">\\mathcal{A}</span> as a subroutine, that wins the SUF-1CMA game against Sig with probability <span class="math">\\epsilon_1 / q_{\\mathbf{P}}</span>. After receiving a verification key <span class="math">\\mathsf{pk}_{\\mathsf{sig}}^{\\prime \\prime}</span> from the SUF-1CMA challenger, the algorithm <span class="math">\\mathcal{B}</span> performs the following steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{B}</span> selects a random index <span class="math">j \\gets \\{1, \\dots, q_{\\mathbf{P}}\\}</span>.</li>

      <li><span class="math">\\mathcal{B}</span> conducts the TR-NM experiment with <span class="math">\\mathcal{A}</span>, except that, when <span class="math">\\mathcal{A}</span> issues the <span class="math">j</span>-th Pour query, <span class="math">\\mathcal{B}</span> executes Pour as usual, but modifies the resulting pour transaction <span class="math">\\mathsf{tx}&#x27;&#x27;</span> as follows: (i) it substitutes <span class="math">\\mathsf{pk}_{\\mathsf{sig}}^{\\prime \\prime}</span> for the signature public key in <span class="math">\\mathsf{tx}&#x27;&#x27;</span>; (ii) it queries the SUF-1CMA challenger to obtain <span class="math">\\sigma&#x27;&#x27;</span> on the appropriate message <span class="math">m&#x27;&#x27;</span>; and (iii) it substitutes <span class="math">\\sigma&#x27;&#x27;</span> for the signature in <span class="math">\\mathsf{tx}&#x27;&#x27;</span>.</li>

      <li>When <span class="math">\\mathcal{A}</span> outputs <span class="math">\\mathsf{tx}^<em></span>, <span class="math">\\mathcal{B}</span> looks into <span class="math">\\mathsf{tx}^</em></span> to obtain <span class="math">\\mathsf{pk}_{\\mathrm{sig}}</span>, <span class="math">m</span>, and <span class="math">\\sigma</span>.</li>

      <li>If <span class="math">\\mathsf{pk}_{\\mathrm{sig}} \\neq \\mathsf{pk}_{\\mathrm{sig}}^{\\prime \\prime}</span> then <span class="math">\\mathcal{B}</span> aborts; otherwise <span class="math">\\mathcal{B}</span> outputs <span class="math">(m, \\sigma)</span> as a forgery for Sig.</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{tx}&#x27;&#x27;</span> has the same distribution as an "untampered" pour transaction; thus, all transactions returned to <span class="math">\\mathcal{A}</span> are distributed as in the TR-NM experiment. Since the index <span class="math">j</span> is selected at random, <span class="math">\\mathcal{B}</span> succeeds in the experiment with probability at least <span class="math">\\epsilon_1 / q_{\\mathbf{P}}</span>. Because Sig is SUF-1CMA, <span class="math">\\epsilon_1</span> must be negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300"><strong>Bounding the probability of <span class="math">\\text{Event}_{\\text{col}}</span>.</strong> Define <span class="math">\\epsilon_2 := \\Pr[\\text{Event}_{\\text{col}}]</span>. When <span class="math">\\text{Event}_{\\text{col}}</span> occurs, <span class="math">\\mathcal{A}</span> receives a transaction <span class="math">\\mathsf{tx}&#x27;</span> containing a public key <span class="math">\\mathsf{pk}_{\\mathsf{sig}}&#x27;&#x27;</span>, and subsequently outputs a transaction <span class="math">\\mathsf{tx}^*</span> containing a public key <span class="math">\\mathsf{pk}_{\\mathsf{sig}}</span> such that (i) <span class="math">\\mathsf{pk}_{\\mathsf{sig}} \\neq \\mathsf{pk}_{\\mathsf{sig}}&#x27;&#x27;</span>, but (ii) <span class="math">\\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}}) = \\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}}&#x27;)</span>. In particular, <span class="math">\\mathcal{A}</span> finds collisions for CRH with probability <span class="math">\\epsilon_2</span>. Because CRH is collision resistant, <span class="math">\\epsilon_2</span> must be negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300"><strong>Bounding the probability of <span class="math">\\text{Event}_{\\text{mac}}</span>.</strong> Define <span class="math">\\epsilon_3 := \\Pr[\\text{Event}_{\\text{mac}}]</span>. We first define an experiment <span class="math">\\partial_1</span>, which modifies the TR-NM experiment as follows. When <span class="math">\\mathcal{C}</span> samples <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>, the sub-call to <span class="math">(\\mathsf{pk}_{\\mathsf{POUR}}, \\mathsf{vk}_{\\mathsf{POUR}}) \\gets \\mathsf{KeyGen}(1^{\\lambda}, C_{\\mathsf{POUR}})</span> is replaced by <span class="math">(\\mathsf{pk}_{\\mathsf{POUR}}, \\mathsf{vk}_{\\mathsf{POUR}}, \\mathsf{trap}) \\gets \\mathsf{Sim}(1^{\\lambda}, C_{\\mathsf{POUR}})</span>, so to obtain the zero-knowledge trapdoor trap. Afterwards, each time <span class="math">\\mathcal{A}</span> issues a Pour query, <span class="math">\\mathcal{C}</span> replaces the zk-SNARK proof in the resulting pour transaction with a simulated proof, obtained by running <span class="math">\\mathsf{Sim}(\\mathsf{trap}, x)</span> for an appropriate input <span class="math">x</span>. Because the zk-SNARK is perfect zero knowledge, <span class="math">\\Pr[\\text{Event}_{\\text{mac}}] = \\epsilon_3</span> in the <span class="math">\\partial_1</span> experiment as well.</p>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300">Assume by way of contradiction that <span class="math">\\epsilon_3</span> is non-negligible. We now show how to construct an attacker <span class="math">\\mathcal{B}</span>, which uses <span class="math">\\mathcal{A}</span> as a subroutine, that distinguishes PRF from a random function RAND with non-negligible probability. The algorithm <span class="math">\\mathcal{B}</span>, which has access either to <span class="math">\\mathcal{O} = \\mathsf{PRF}</span> or <span class="math">\\mathcal{O} = \\mathsf{RAND}</span>, "interfaces" between <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{C}</span> in the experiment <span class="math">\\partial_1</span> above, as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, <span class="math">\\mathcal{B}</span> selects a random index <span class="math">j \\gets \\{1, \\dots, q_{\\mathbf{CA}}\\}</span>, which identifies <span class="math">a_{\\mathbf{sk},j} \\in \\mathcal{Q}_{\\mathbf{CA}}</span>.</li>

      <li>Next, <span class="math">\\mathcal{B}</span> uses the oracle <span class="math">\\mathcal{O}</span> instead of <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk},j}}</span>, i.e., anytime a value needs to be computed depending on <span class="math">\\mathsf{PRF}_{a_{\\mathrm{sk},j}}(z)</span>, for some <span class="math">z</span>, <span class="math">\\mathcal{O}(z)</span> is used instead. (For instance, the public address key <span class="math">a_{\\mathbf{pk},j}</span> is one such value.)</li>

      <li>Finally, after <span class="math">\\mathcal{A}</span> outputs <span class="math">\\mathsf{tx}^*</span>:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) if <span class="math">\\mathcal{O}</span> has been previously evaluated the expression “PRFpksk, j (i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hSig)” using <span class="math">\\mathcal{O}</span>, <span class="math">\\mathcal{B}</span> aborts and outputs 1;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Conducting the above strategy does not require knowledge of <span class="math">a_{\\mathbf{sk},j}</span> because, having the simulation trapdoor, <span class="math">\\mathcal{B}</span> does not need witnesses to generate (valid) zk-SNARK proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now argue that $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}\\left[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) = 1\\right] - \\operatorname{Pr}\\left[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) = 1\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is non-negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\mathcal{O} = \\text{RAND}</span>. Observe that:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {B} ^ {\\text {R A N D}} \\left(1 ^ {\\lambda}\\right) = 1 \\mid \\mathcal {B} ^ {\\text {R A N D}} \\left(1 ^ {\\lambda}\\right) \\text {does not abort} \\right] = 2 ^ {- \\omega}.</span></div>

    <p class="text-gray-300">where <span class="math">\\omega</span> is the output length of PRF. Hence:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {B} ^ {\\text {R A N D}} \\left(1 ^ {\\lambda}\\right) = 1 \\right] = \\left(1 - \\Pr \\left[ \\mathcal {B} ^ {\\text {R A N D}} \\left(1 ^ {\\lambda}\\right) \\text {aborts} \\right]\\right) \\cdot 2 ^ {- \\omega} + \\Pr \\left[ \\mathcal {B} ^ {\\text {R A N D}} \\left(1 ^ {\\lambda}\\right) \\text {aborts} \\right].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2: <span class="math">\\mathcal{O} = \\mathsf{PRF}</span>. In this case the distribution of the simulation is identical to that of <span class="math">\\partial_1</span>, and <span class="math">\\mathcal{B}</span> has set <span class="math">a_{\\mathbf{sk},j}</span> equal to the seed used by <span class="math">\\mathcal{O}</span>. Recall that, when <span class="math">\\mathrm{Event}_{\\mathrm{mac}}</span> holds, $h_i = \\mathsf{PRF}_a^{\\mathrm{pk}}(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathrm{Sig}})<span class="math"> for some </span>a \\in \\mathcal{Q}_{\\mathbf{CA}}<span class="math">. Since </span>\\mathcal{A}<span class="math">&#x27;s view of the experiment is independent of </span>j<span class="math">, the probability that </span>a = a_{\\mathbf{sk},j}<span class="math"> is at least </span>1 / q_{\\mathbf{CA}}<span class="math">, and the probability that </span>h_i = \\mathsf{PRF}_{a_{\\mathbf{sk},j}}^{\\mathrm{pk}}(i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mathrm{Sig}})<span class="math"> is at least </span>\\epsilon_3 / q_{\\mathbf{CA}}$. Hence:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {B} ^ {\\mathsf {P R F}} \\left(1 ^ {\\lambda}\\right) = 1 \\mid \\mathcal {B} ^ {\\mathsf {P R F}} \\left(1 ^ {\\lambda}\\right) \\text {does not abort} \\right] = \\epsilon_ {3} / q _ {\\mathbf {C A}}.</span></div>

    <p class="text-gray-300">Thus:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {B} ^ {\\mathsf {P R F}} \\left(1 ^ {\\lambda}\\right) = 1 \\right] = \\left(1 - \\Pr \\left[ \\mathcal {B} ^ {\\mathsf {P R F}} \\left(1 ^ {\\lambda}\\right) \\text {aborts} \\right]\\right) \\cdot \\epsilon_ {3} / q _ {\\mathbf {C A}} + \\Pr \\left[ \\mathcal {B} ^ {\\mathsf {P R F}} \\left(1 ^ {\\lambda}\\right) \\text {aborts} \\right].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly, <span class="math">2^{-\\omega}</span> is negligible; moreover, if <span class="math">\\epsilon_3</span> is non-negligible, then so is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon_3 / q_{\\mathbf{CA}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, to show that </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}\\left[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) = 1\\right] - \\operatorname{Pr}\\left[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) = 1\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is non-negligible, it suffices to show that each of </span>\\operatorname{Pr}\\left[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda})\\right.<span class="math"> aborts] and </span>\\operatorname{Pr}\\left[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda})\\right.$ aborts] is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To do so, recall that <span class="math">\\mathcal{B}</span> aborts if and only if it has previously evaluated the expression “PRFpksk, j (i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hSig)” using <span class="math">\\mathcal{O}</span> prior to receiving <span class="math">\\mathcal{A}</span>'s output. First note that <span class="math">\\mathcal{B}</span>'s only calls to <span class="math">\\mathcal{O}</span> occur when it evaluates the functions PRFaddr, PRFsn and PRFpk. Moreover, due to the construction of these functions it is not possible to evaluate the expression PRFpksk, j (i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hSig) using any calls to PRFaddr or PRFsn. Thus <span class="math">\\mathcal{B}</span> aborts if and only if it has previously queried PRFpk on the expression PRFpksk, j (i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hSig). However it is easy to see that this cannot happen under the conditions of Eventmac, since such a query would imply the condition Eventsig or Eventcol, each of which is excluded by Eventmac. Hence the probability of either condition occurring is 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">50</p>

    <p class="text-gray-300">Bounding the probability of Eventkey. Define  <span class="math">\\epsilon_4 \\coloneqq \\operatorname{Pr}\\left[\\mathrm{EVENT}_{\\mathrm{key}}\\right]</span> , and let  <span class="math">\\mathcal{E}</span>  be the zk-SNARK extractor for  <span class="math">\\mathcal{A}</span> . Assume by way of contradiction that  <span class="math">\\epsilon_4</span>  is non-negligible. We construct an algorithm  <span class="math">\\mathcal{B}</span>  that finds collisions for  <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}</span>  with non-negligible probability (contradicting the fact that  <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}</span>  is collision resistant). The algorithm  <span class="math">\\mathcal{B}</span>  works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">\\mathcal{A}</span>  (simulating its interaction with the challenger  <span class="math">\\mathcal{C}</span> ) to obtain  <span class="math">\\mathsf{tx}^*</span> .</li>

      <li>Run  <span class="math">\\mathcal{E}(\\mathsf{pk}_{\\mathsf{POUR}},\\mathsf{vk}_{\\mathsf{POUR}})</span>  to obtain a witness  <span class="math">a</span>  for the zk-SNARK proof  <span class="math">\\pi_{\\mathsf{POUR}}</span>  in  <span class="math">\\mathsf{tx}^*</span> .</li>

      <li>If  <span class="math">a</span>  is not a valid witness for the instance  <span class="math">x \\coloneqq (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathrm{old}}, \\mathsf{sn}_2^{\\mathrm{old}}, \\mathsf{cm}_1^{\\mathrm{new}}, \\mathsf{cm}_2^{\\mathrm{new}}, v_{\\mathrm{pub}}, h_{\\mathrm{Sig}}, h_1, h_2)</span> , abort and output 0.</li>

      <li>Parse  <span class="math">a</span>  as  <span class="math">(\\mathsf{path}_1, \\mathsf{path}_2, \\mathbf{c}_1^{\\mathrm{old}}, \\mathbf{c}_2^{\\mathrm{old}}, \\mathsf{addr}_{\\mathrm{sk},1}^{\\mathrm{old}}, \\mathsf{addr}_{\\mathrm{sk},2}^{\\mathrm{old}}, \\mathbf{c}_1^{\\mathrm{new}}, \\mathbf{c}_2^{\\mathrm{new}})</span> .</li>

      <li>For each  <span class="math">i\\in \\{1,2\\}</span> , parse  <span class="math">\\mathbf{c}_i^{\\mathrm{old}}</span>  as  <span class="math">(\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathrm{old}},v_i^{\\mathrm{old}},\\rho_i^{\\mathrm{old}},r_i^{\\mathrm{old}},s_i^{\\mathrm{old}},\\mathsf{cm}_i^{\\mathrm{old}})</span> .</li>

      <li>For each  <span class="math">i\\in \\{1,2\\}</span> , parse  <span class="math">\\mathsf{addr}_{\\mathsf{sk},i}^{\\mathsf{old}}</span>  as  <span class="math">(a_{\\mathsf{sk},i}^{\\mathsf{old}},\\mathsf{sk}_{\\mathsf{enc},i}^{\\mathsf{old}})</span> .</li>

    </ol>

    <p class="text-gray-300">(Note that, since  <span class="math">a</span>  is a valid witness,  <span class="math">\\mathsf{sn}_i^{\\mathrm{old}} = \\mathsf{PRF}_{\\mathsf{a}_{\\mathrm{sk},i}^{\\mathrm{old}}}^{\\mathrm{sn}}(\\rho_i^{\\mathrm{old}})</span>  for all  <span class="math">i \\in \\{1,2\\}</span> .)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i\\in \\{1,2\\}</span></li>

    </ol>

    <p class="text-gray-300">(a) Look for a pour transaction  <span class="math">\\mathsf{tx}\\in \\mathcal{T}</span>  that contains  <span class="math">\\mathsf{sn}_i^{\\mathrm{old}}</span> (b) If one  <span class="math">\\mathsf{tx}</span>  is found, let  <span class="math">\\overline{a_{\\mathrm{sk}}}</span>  and  <span class="math">\\overline{\\rho}</span>  be the seed and input used to compute  <span class="math">\\mathsf{sn}_i^{\\mathrm{old}}</span>  in  <span class="math">\\mathsf{tx}</span> ; thus,  <span class="math">\\mathsf{sn}_i^{\\mathrm{old}} = \\mathsf{PRF}_{\\overline{a_{\\mathrm{sk}}}}^{\\mathrm{sn}}(\\overline{\\rho})</span> . If  <span class="math">a_{\\mathrm{sk},i}^{\\mathrm{old}} \\neq \\overline{a_{\\mathrm{sk}}}</span> , output  <span class="math">\\left((a_{\\mathrm{sk},i}^{\\mathrm{old}}, \\rho_i^{\\mathrm{old}}), (\\overline{a_{\\mathrm{sk}}}, \\overline{\\rho})\\right)</span>  as a collision for  <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}</span> .</p>

    <p class="text-gray-300">Note that, whenever  <span class="math">\\mathrm{EVENT}_{\\mathrm{key}}</span>  holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the proof  <span class="math">\\pi_{\\mathsf{POUR}}</span>  is valid and, with all but negligible probability, the witness  <span class="math">a</span>  is valid;</li>

      <li>the serial number  <span class="math">\\mathsf{sn}_1^{\\mathrm{old}}</span>  or  <span class="math">\\mathsf{sn}_2^{\\mathrm{old}}</span>  appears in some previous pour transaction in  <span class="math">\\mathcal{T}</span> ;</li>

      <li>whenever  <span class="math">a</span>  is valid, it holds that  <span class="math">h_1 = \\mathsf{PRF}_{a_{\\mathrm{sk},1}^{\\mathrm{old}}}^{\\mathrm{pk}}(h_{\\mathrm{Sig}})</span>  and  <span class="math">h_2 = \\mathsf{PRF}_{a_{\\mathrm{sk},2}^{\\mathrm{old}}}^{\\mathrm{pk}}(h_{\\mathrm{Sig}})</span> , so that it cannot be that  <span class="math">a_{\\mathrm{sk},1}^{\\mathrm{old}} = a_{\\mathrm{sk},2}^{\\mathrm{old}} = \\overline{a_{\\mathrm{sk}}}</span>  (as this contradicts the conditions of the event  <span class="math">\\mathrm{EVENT}_{\\mathrm{key}}</span> ).</li>

    </ul>

    <p class="text-gray-300">Overall, we conclude that  <span class="math">\\mathcal{B}</span>  finds a collision for  <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}</span>  with probability  <span class="math">\\epsilon_4 - \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Define  <span class="math">\\epsilon := \\mathsf{Adv}_{\\mathrm{II},\\mathcal{A}}^{\\mathrm{BAL}}(\\lambda)</span> ; our goal is to show that  <span class="math">\\epsilon</span>  is negligible in  <span class="math">\\lambda</span> . Recall that ADDR is the set of addresses returned by  <span class="math">\\mathcal{A}</span> 's CreateAddress queries.</p>

    <p class="text-gray-300">Augmenting the ledger with witnesses. We modify the BAL experiment in a way that does not affect  <span class="math">\\mathcal{A}</span> 's view: the challenger  <span class="math">\\mathcal{C}</span>  computes, for each pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  on the ledger  <span class="math">L</span>  (maintained by the oracle  <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span> ), a witness  <span class="math">a = (\\mathsf{path}_1, \\mathsf{path}_2, \\mathsf{c}_1^{\\mathrm{old}}, \\mathsf{c}_2^{\\mathrm{old}}, \\mathsf{addr}_{\\mathrm{sk},1}^{\\mathrm{old}}, \\mathsf{addr}_{\\mathrm{sk},2}^{\\mathrm{old}}, \\mathsf{c}_1^{\\mathrm{new}}, \\mathsf{c}_2^{\\mathrm{new}})</span>  for the zk-SNARK instance  <span class="math">x = (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathrm{old}}, \\mathsf{sn}_2^{\\mathrm{old}}, \\mathsf{cm}_1^{\\mathrm{new}}, \\mathsf{cm}_2^{\\mathrm{new}}, v_{\\mathrm{pub}}, h_{\\mathrm{Sig}}, h_1, h_2)</span>  corresponding to  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> . In this way,  <span class="math">\\mathcal{C}</span>  obtains an augmented ledger  <span class="math">(L, \\vec{a})</span> , where  <span class="math">a_i</span>  is a witness for the zk-SNARK instance  <span class="math">x_i</span>  of the  <span class="math">i</span> -th pour transaction in  <span class="math">L</span> . Note that we can parse  <span class="math">(L, \\vec{a})</span>  as a list of matched pairs  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}}, a)</span>  where  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  is a pour transaction in  <span class="math">L</span>  and  <span class="math">a</span>  is its corresponding witness.</p>

    <p class="text-gray-300">The discussion below is relative to the above modification of the BAL experiment.</p>

    <p class="text-gray-300">Balanced ledgers. We say that an augmented ledger  <span class="math">(L, \\vec{a})</span>  is balanced if the following holds.</p>

    <p class="text-gray-300">I. Each  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}},a)</span>  in  <span class="math">(L,\\vec{a})</span>  contains openings (i.e., decommitments) of two distinct coin commitments  <span class="math">\\mathsf{cm}_1^{\\mathrm{old}}</span>  and  <span class="math">\\mathsf{cm}_2^{\\mathrm{old}}</span> ; also, each  <span class="math">\\mathsf{cm}_i^{\\mathrm{old}}</span>  is the output coin commitment of a pour or mint transaction that precedes  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  on  <span class="math">L</span> . II. No two  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}},a)</span>  and  <span class="math">(a^{\\prime},\\mathsf{tx}_{\\mathsf{Pour}}^{\\prime})</span>  in  <span class="math">(L,\\vec{a})</span>  contain openings of the same coin commitment.</p>

    <p class="text-gray-300">II. Each <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}},a)</span> in <span class="math">(L,\\vec{a})</span> contains openings of <span class="math">\\mathsf{cm}_1^{\\mathsf{old}},\\mathsf{cm}_2^{\\mathsf{old}},\\mathsf{cm}_1^{\\mathsf{new}},\\mathsf{cm}_2^{\\mathsf{new}}</span> to values <span class="math">v_{1}^{\\mathsf{old}},v_{2}^{\\mathsf{old}}</span>, <span class="math">v_{1}^{\\mathsf{new}},v_{2}^{\\mathsf{new}}</span> (respectively), with the condition that <span class="math">v_{1}^{\\mathsf{old}} + v_{2}^{\\mathsf{old}} = v_{1}^{\\mathsf{new}} + v_{2}^{\\mathsf{new}} + v_{\\mathsf{pub}}</span>.</p>

    <p class="text-gray-300">IV. For each <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}},a)</span> in <span class="math">(L,\\vec{a})</span> and for each <span class="math">i\\in \\{1,2\\}</span>, the following conditions hold:</p>

    <p class="text-gray-300">(a) If <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span> is also the output of a mint transaction <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span> on <span class="math">L</span>, then the public value <span class="math">v</span> in <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span> is equal to <span class="math">v_i^{\\mathsf{old}}</span>.</p>

    <p class="text-gray-300">(b) If <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span> is also the output of a pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}&#x27;</span> on <span class="math">L</span>, then its witness <span class="math">a&#x27;</span> contains an opening of <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span> to a value <span class="math">v&#x27;</span> that is equal to <span class="math">v_i^{\\mathsf{old}}</span>.</p>

    <p class="text-gray-300">V. For each <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}},a)</span> in <span class="math">(L,\\vec{a})</span>, where <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> was inserted by <span class="math">\\mathcal{A}</span>, it holds that, for each <span class="math">i\\in \\{1,2\\}</span>, if <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span> is the output of an earlier mint or pour transaction <span class="math">\\mathsf{tx}&#x27;</span>, then the public address of the <span class="math">i</span>-th output of <span class="math">\\mathsf{tx}&#x27;</span> is not contained in ADDR.</p>

    <p class="text-gray-300">Intuitively, the above conditions ensure that, in <span class="math">L</span>, <span class="math">\\mathcal{A}</span> did not spend money that was not previously minted, or paid to an address under <span class="math">\\mathcal{A}</span>'s control. Concretely, one can prove by induction that if <span class="math">(L,\\vec{a})</span> is balanced then <span class="math">v_{\\text{Unspent}} + v_{\\text{Basecoin}} + v_{\\mathcal{A} \\to \\text{ADDR}} &amp;gt; v_{\\text{Mint}} + v_{\\text{ADDR} \\to \\mathcal{A}}</span>.</p>

    <p class="text-gray-300">In light of the above, it suffices to argue that the augmented ledger induced by the (modified) BAL experiment is balanced with all but negligible probability. Suppose, by way of contradiction, that is is not the case: <span class="math">\\mathcal{A}</span> induces, with non-negligible probability, an augmented ledger <span class="math">(L,\\vec{a})</span> that is not balanced. We distinguish between five cases, corresponding to which one of the above conditions does not hold with non-negligible probability. In each case, we show how to reach a contradiction, concluding the proof.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> violates Condition I. Suppose that <span class="math">\\operatorname*{Pr}[\\mathcal{A}</span> wins but violates Condition I] is non-negligible. By construction of <span class="math">\\mathcal{O}^{\\mathrm{DAP}}</span>, every <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}},a)</span> in <span class="math">(L,\\vec{a})</span> for which <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> was not inserted by <span class="math">\\mathcal{A}</span> satisfies Condition I; thus, the violation can only originate from a pair <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}},a)</span> in <span class="math">(L,\\vec{a})</span> for which <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> was inserted by <span class="math">\\mathcal{A}</span> and such that: (i) <span class="math">\\mathsf{cm}_1^{\\mathsf{old}} = \\mathsf{cm}_2^{\\mathsf{old}}</span>; or (ii) there is <span class="math">i\\in \\{1,2\\}</span> such that <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span> has no corresponding output coin commitment in any pour or mint transaction that precedes <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> on <span class="math">L</span>.</p>

    <p class="text-gray-300">Observe that the validity of <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> implies that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The two serial numbers <span class="math">\\mathsf{sn}_1^{\\mathrm{old}}</span> and <span class="math">\\mathsf{sn}_2^{\\mathrm{old}}</span> are distinct. Moreover, recalling that each <span class="math">\\mathsf{sn}_i^{\\mathrm{old}}</span> equals <span class="math">\\mathsf{PRF}_{a_{\\mathsf{sk},i}^{\\mathrm{on}}}^{\\mathrm{in}}(\\rho_i^{\\mathrm{old}})</span>, this also implies that <span class="math">(a_{\\mathsf{sk},1}^{\\mathrm{old}},\\rho_1^{\\mathrm{old}})\\neq (a_{\\mathsf{sk},2}^{\\mathrm{old}},\\rho_2^{\\mathrm{old}})</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The witness <span class="math">a</span> contains two valid authentication paths <span class="math">\\mathsf{path}_1, \\mathsf{path}_2</span> for a Merkle tree constructed using only coin commitments of transactions preceding <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> in <span class="math">L</span>.</li>

    </ul>

    <p class="text-gray-300">In either (i) or (ii), we reach a contradiction. Indeed:</p>

    <p class="text-gray-300">(i) If <span class="math">\\mathsf{cm}_1^{\\mathsf{old}} = \\mathsf{cm}_2^{\\mathsf{old}}</span>, then the fact that <span class="math">\\mathsf{sn}_1^{\\mathsf{old}} \\neq \\mathsf{sn}_2^{\\mathsf{old}}</span> implies that the witness <span class="math">a</span> contains two distinct openings of <span class="math">\\mathsf{cm}_1^{\\mathsf{old}}</span> (the first opening contains <span class="math">(a_{\\mathsf{sk},1}^{\\mathsf{old}}, \\rho_1^{\\mathsf{old}})</span>, while the second opening contains <span class="math">(a_{\\mathsf{sk},2}^{\\mathsf{old}}, \\rho_2^{\\mathsf{old}})</span>). This violates the binding property of the commitment scheme COMM.</p>

    <p class="text-gray-300">(ii) If there is <span class="math">i \\in \\{1, 2\\}</span> such that <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span> does not previously appear in <span class="math">L</span>, then <span class="math">\\mathsf{path}_i</span> is an invalid authentication path, and thus yields a collision in the function CRH. This violates the collision resistance of CRH.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> violates Condition II. Suppose that <span class="math">\\operatorname*{Pr}[\\mathcal{A}</span> wins but violates Condition II] is non-negligible. Observe that, when Condition II is violated, <span class="math">L</span> contains two pour transactions <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}, \\mathsf{tx}_{\\mathsf{Pour}}&#x27;</span> spending the same coin commitment <span class="math">\\mathsf{cm}</span>, and revealing two serial numbers <span class="math">\\mathsf{sn}</span> and <span class="math">\\mathsf{sn}&#x27;</span>. Since <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}, \\mathsf{tx}_{\\mathsf{Pour}}&#x27;</span> are valid, it must be the case that <span class="math">\\mathsf{sn} \\neq \\mathsf{sn}&#x27;</span>. However (as argued already above), if both transactions spend <span class="math">\\mathsf{cm}</span> but produce different serial numbers, then the corresponding witnesses <span class="math">a, a&#x27;</span> contain different openings of <span class="math">\\mathsf{cm}</span>. This contradicts the binding property of the commitment scheme COMM.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> violates Condition III. Suppose that <span class="math">\\operatorname*{Pr}[\\mathcal{A}</span> wins but violates Condition III] is non-negligible. In this case, the contradiction is immediate: whenever Condition III is violated, the equation</p>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300"><span class="math">v_{1}^{\\mathrm{old}} + v_{2}^{\\mathrm{old}} = v_{1}^{\\mathrm{new}} + v_{2}^{\\mathrm{new}} + v_{\\mathrm{pub}}</span> does not hold, and thus, by construction of the statement POUR, the soundness of the zk-SNARK is violated as well.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> violates Condition IV. Suppose that <span class="math">\\operatorname*{Pr}\\left[\\mathcal{A}\\right.</span> wins but violates Condition IV] is non-negligible. Observe that, when Condition IV is violated, <span class="math">L</span> contains:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> in which a coin commitment <span class="math">\\mathsf{cm}^{\\mathsf{old}}</span> is opened to a value <span class="math">v^{\\mathsf{old}}</span>; and also</li>

      <li>a (mint or pour) transaction <span class="math">\\mathsf{tx}&#x27;</span> that opens <span class="math">\\mathsf{cm}^{\\mathsf{old}}</span> to a value <span class="math">v&#x27;</span> different from <span class="math">v^{\\mathsf{old}}</span>.</li>

    </ul>

    <p class="text-gray-300">This contradicts the binding property of the commitment scheme COMM.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> violates Condition V. Suppose that <span class="math">\\operatorname*{Pr}\\left[\\mathcal{A}\\right.</span> wins but violates Condition V] is non-negligible. Observe that, when Condition V is violated, <span class="math">L</span> contains an inserted pour transaction <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> that spends the output of a previous transaction <span class="math">\\mathsf{tx}&#x27;</span> whose public address <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}})</span> lies in ADDR; moreover, the witness associated to <span class="math">\\mathsf{tx}&#x27;</span> contains <span class="math">a_{\\mathsf{sk}}</span> such that <span class="math">a_{\\mathsf{pk}} = \\mathsf{PRF}_{a_{\\mathsf{sk}}}^{\\mathsf{addr}}(0)</span>. We omit the full argument, but one can verify that, in this case, we can construct a new adversary <span class="math">\\mathcal{B}</span> that uses <span class="math">\\mathcal{A}</span> to distinguish, with non-negligible probability, PRF from a random function.</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BB04] Dan Boneh and Xavier Boyen. Secure identity based encryption without random oracles. In Proceedings of the 24th Annual International Cryptology Conference, CRYPTO ’04, pages 443–459, 2004.</li>

      <li>[BBDP01] Mihir Bellare, Alexandra Boldyreva, Anand Desai, and David Pointcheval. Key-privacy in public-key encryption. In Proceedings of the 7th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT ’01, pages 566–582, 2001.</li>

      <li>[BBSU12] Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to better - how to make Bitcoin a better currency. In Proceedings of the 16th International Conference on Financial Cryptography and Data Security, FC ’12, pages 399–414, 2012.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, ITCS ’12, pages 326–349, 2012.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In Proceedings of the 45th ACM Symposium on the Theory of Computing, STOC ’13, pages 111–120, 2013.</li>

      <li>[BCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: verifying program executions succinctly and in zero knowledge. In Proceedings of the 33rd Annual International Cryptology Conference, CRYPTO ’13, pages 90–108, 2013.</li>

      <li>[BCGT13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems. In Proceedings of the 4th Innovations in Theoretical Computer Science Conference, ITCS ’13, pages 401–414, 2013.</li>

      <li>[BCGT13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. On the concrete efficiency of probabilistically-checkable proofs. In Proceedings of the 45th ACM Symposium on the Theory of Computing, STOC ’13, pages 585–594, 2013.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Proceedings of the 10th Theory of Cryptography Conference, TCC ’13, pages 315–333, 2013.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, Security ’14, pages ???–???, 2014. Available at http://eprint.iacr.org/2013/879.</li>

      <li>[Bel06] Mihir Bellare. New proofs for NMAC and HMAC: security without collision-resistance. In Proceedings of the 26th Annual International Conference on Advances in Cryptology, CRYPTO ’06, pages 602–619, 2006.</li>

      <li>[Ben13] Eli Ben-Sasson. Universal and affordable computational integrity, May 2013. Bitcoin 2013: The Future of Payments. URL: http://www.youtube.com/watch?v=YRcPReUpkcU&feature=youtu.be&t=26m6s.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, STOC ’91, pages 21–32, 1991.</li>

      <li>[BGH^{+}05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil Vadhan. Short PCPs verifiable in polylogarithmic time. In Proceedings of the 20th Annual IEEE Conference on Computational Complexity, CCC ’05, pages 120–134, 2005.</li>

      <li>[Cer00] Certicom Research. SEC 1: Elliptic curve cryptography, 2000. URL: http://www.secg.org/collateral/sec1_final.pdf.</li>

      <li>[Cha82] David Chaum. Blind signatures for untraceable payments. In Proceedings of the 2nd Annual International Cryptology Conference, CRYPTO ’82, pages 199–203, 1982.</li>

      <li>[CHL05] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Proceedings of the 24th Annual International Conference on Theory and Applications of Cryptographic Techniques, EUROCRYPT ’05, pages 302–321, 2005.</li>

      <li>[CL01] Jan Camenisch and Anna Lysyanskaya. An efficient system for non-transferable anonymous credentials with optional anonymity revocation. In Proceedings of the 20th Annual International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT ’01, pages 93–118, 2001.</li>

      <li>[DDM03] George Danezis, Roger Dingledine, and Nick Mathewson. Mixminion: Design of a type III anonymous remailer protocol. In Proceedings of the 2003 IEEE Symposium on Security and Privacy, SP ’03, pages 2–15, 2003.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[DFKP13] George Danezis, Cedric Fournet, Markulf Kohlweiss, and Bryan Parno. Pinocchio Coin: building Zerocoin from a succinct pairing-based proof system. In Proceedings of the 2013 Workshop on Language Support for Privacy Enhancing Technologies, PETShop ’13, 2013. URL: http://www0.cs.ucl.ac.uk/staff/G.Danezis/papers/DanezisFournetKohlweissParno13.pdf.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DMS04] Roger Dingledine, Nick Mathewson, and Paul Syverson. Tor: the second-generation onion router. In Proceedings of the 13th USENIX Security Symposium, Security ’04, pages 21–21, 2004.</li>

      <li>[DW13] Christian Decker and Roger Wattenhofer. Information propagation in the Bitcoin network. In Proceedings of the 13th IEEE International Conference on Peer-to-Peer Computing, P2P ’13, pages 1–10, 2013.</li>

      <li>[ES13] Ittay Eyal and Emin Gün Sirer. Majority is not enough: Bitcoin mining is vulnerable, 2013.</li>

      <li>[Gen04] Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks. In Proceedings of the 24th Annual International Cryptology Conference, CRYPTO ’04, pages 220–236, 2004.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT ’13, pages 626–645, 2013.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989. Preliminary version appeared in STOC ’85.</li>

      <li>[GOS06a] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive Zaps and new techniques for NIZK. In Proceedings of the 26th Annual International Conference on Advances in Cryptology, CRYPTO ’06, pages 97–111, 2006.</li>

      <li>[GOS06b] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In Proceedings of the 25th Annual International Conference on Advances in Cryptology, EUROCRYPT ’06, pages 339–358, 2006.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT ’10, pages 321–340, 2010.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Proceedings of the 43rd Annual ACM Symposium on Theory of Computing, STOC ’11, pages 99–108, 2011.</li>

      <li>[KL07] Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography. Chapman & Hall/CRC, 2007.</li>

      <li>[Lee13] Timothy B. Lee. Bitcoin needs to scale by a factor of 1000 to compete with Visa. here’s how to do it. The Washington Post (http://www.washingtonpost.com), November 2013.</li>

      <li>[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography, TCC ’12, pages 169–189, 2012.</li>

      <li>[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. In Proceedings of the 19th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT ’13, pages 41–60, 2013.</li>

      <li>[Max13] Greg Maxwell. CoinJoin: Bitcoin privacy for the real world, August 2013. Bitcoin Forum. URL: https://bitcointalk.org/index.php?topic=279249.0.</li>

      <li>[MGGR13] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed e-cash from bitcoin. In Proceedings of the 2013 IEEE Symposium on Security and Privacy, SP ’13, pages 397–411, 2013.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000. Preliminary version appeared in FOCS ’94.</li>

      <li>[MPJ^{+}13] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoffrey M. Voelker, and Stefan Savage. A fistful of Bitcoins: Characterizing payments among men with no names. In Proceedings of the 2013 Conference on Internet Measurement Conference, IMC ’13, pages 127–140, 2013.</li>

      <li>[Nak09] Satoshi Nakamoto. Bitcoin: a peer-to-peer electronic cash system, 2009. URL: http://www.bitcoin.org/bitcoin.pdf.</li>

      <li>[Nat12] National Institute of Standards and Technology. FIPS PUB 180-4: Secure Hash Standard. http://csrc.nist.gov/publications/PubsFIPS.html, 2012.</li>

    </ul>

    <p class="text-gray-300">[PGHR13] Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: nearly practical verifiable computation. In Proceedings of the 34th IEEE Symposium on Security and Privacy, Oakland ’13, pages 238–252, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Pol13] PolarSSL. PolarSSL. http://polarssl.org, Oct 2013.</li>

      <li>[RM11] Fergal Reid and Harrigan Martin. An analysis of anonymity in the Bitcoin system. In Proceedings of the 3rd IEEE International Conference on Privacy, Security, Risk and Trust and on Social Computing, SocialCom/PASSAT ’11, pages 1318–1326, 2011.</li>

      <li>[RS12] Dorit Ron and Adi Shamir. Quantitative analysis of the full Bitcoin transaction graph. Cryptology ePrint Archive, Report 2012/584, 2012.</li>

      <li>[ST99] Tomas Sander and Amnon Ta-Shma. Auditable, anonymous electronic cash. In Proceedings of the 19th Annual International Cryptology Conference on Advances in Cryptology, CRYPTO ’99, pages 555–572, 1999.</li>

      <li>[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Proceedings of the 5th Theory of Cryptography Conference, TCC ’08, pages 1–18, 2008.</li>

      <li>[Wui14] Pieter Wuille. Proposed BIP for dealing with malleability. Available at https://gist.github.com/sipa/8907691, 2014.</li>

    </ul>`;
---

<BaseLayout title="Zerocash: Decentralized Anonymous Payments from Bitcoin (2014/349)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/349
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
