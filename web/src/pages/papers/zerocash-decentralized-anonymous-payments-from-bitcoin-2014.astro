---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/349';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Zerocash: Decentralized Anonymous Payments from Bitcoin';
const AUTHORS_HTML = 'Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, Madars Virza';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Bitcoin is the first digital currency to see widespread adoption. While payments are conducted between pseudonyms, Bitcoin cannot offer strong privacy guarantees: payment transactions are recorded in a public decentralized ledger, from which much information can be deduced. Zerocoin (Miers et al., IEEE S&amp;P 2013) tackles some of these privacy issues by unlinking transactions from the payment&#x27;s origin. Yet, it still reveals payments&#x27; destinations and amounts, and is limited in functionality.

In this paper, we construct a full-fledged ledger-based digital currency with strong privacy guarantees. Our results leverage recent advances in zero-knowledge Succinct Non-interactive ARguments of Knowledge (zk-SNARKs).

First, we formulate and construct decentralized anonymous payment schemes (DAP schemes). A DAP scheme enables users to directly pay each other privately: the corresponding transaction hides the payment&#x27;s origin, destination, and transferred amount. We provide formal definitions and proofs of the construction&#x27;s security.

Second, we build Zerocash, a practical instantiation of our DAP scheme construction. In Zerocash, transactions are less than 1 kB and take under 6 ms to verify --- orders of magnitude more efficient than the less-anonymous Zerocoin and competitive with plain Bitcoin.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Bitcoin &middot; decentralized electronic cash &middot; zero-knowledge proofs</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Bitcoin is the first digital currency to achieve widespread adoption. The currency owes its rise in part to the fact that, unlike traditional e-cash schemes <a href="#page-53-1">[Cha82,</a> <a href="#page-53-2">CHL05,</a> <a href="#page-55-0">ST99]</a>, it requires no trusted parties. Instead of appointing a central bank, Bitcoin uses a distributed ledger known as the block chain to store transactions carried out between users. Because the block chain is massively replicated by mutually-distrustful peers, the information it contains is public.</p>

    <p class="text-gray-300">While users may employ many identities (or pseudonyms) to enhance their privacy, an increasing body of research shows that anyone can de-anonymize Bitcoin by using information in the block chain <a href="#page-55-1">[RM11,</a> <a href="#page-53-3">BBSU12,</a> <a href="#page-55-2">RS12,</a> <a href="#page-54-0">MPJ</a>+13], such as the structure of the transaction graph as well as the value and dates of transactions. As a result, Bitcoin fails to offer even a modicum of the privacy provided by traditional payment systems, let alone the robust privacy of anonymous e-cash schemes.</p>

    <p class="text-gray-300">While Bitcoin is not anonymous itself, those with sufficient motivation can obfuscate their transaction history with the help of mixes (also known as laundries or tumblers). A mix allows users to entrust a set of coins to a pool operated by a central party and then, after some interval, retrieve different coins (with the same total value) from the pool. However, mixes suffer from three limitations: (i) the delay to reclaim coins must be large to allow enough coins to be mixed in; (ii) the mix operator can trace coins; and (iii) the mix operator may steal coins.<a href="#page-2-1">1</a> For users with &quot;something to hide&quot;, these risks may be acceptable. But typical legitimate users (1) wish to keep their spending habits private from their peers, (2) are risk-averse and do not wish to expend continual effort in protecting their privacy, and (3) are often not sufficiently aware that their privacy has been compromised.</p>

    <p class="text-gray-300">To protect their privacy, users thus need an instant, risk-free, and, most importantly, automatic guarantee that data revealing their spending habits and account balances is not publicly accessible by their neighbors, co-workers, and the merchants with whom they do business. Anonymous transactions also ensure that the market value of a coin is independent of its history, thus ensuring that legitimate users' coins remain fungible. <a href="#page-2-2">2</a></p>

    <p class="text-gray-300">Zerocoin: a decentralized mix. Miers et al. <a href="#page-54-1">[MGGR13]</a> proposed Zerocoin, which extends Bitcoin to provide strong anonymity guarantees. Like many e-cash protocols (e.g., <a href="#page-53-2">[CHL05]</a>), Zerocoin employs zero-knowledge proofs to prevent transaction graph analyses. Unlike earlier practical e-cash protocols, however, Zerocoin does not rely on digital signatures to validate coins, nor does it require a central bank to prevent double spending. Instead, Zerocoin authenticates coins by proving, in zero-knowledge, that they belong to a public list of valid coins (which can be maintained on the block chain). Yet rather than a full-fledged anonymous currency, Zerocoin is a decentralized mix, where users may periodically &quot;wash&quot; their bitcoins via the Zerocoin protocol. Routine day-to-day transactions must be conducted via Bitcoin, due to reasons that we now review.</p>

    <p class="text-gray-300">The first reason is performance. Redeeming zerocoins requires double-discrete-logarithm proofs of knowledge, which have size that exceeds 45 kB and require 450 ms to verify (at the 128-bit security level).<a href="#page-2-3">3</a> These proofs must be broadcast through the network, verified by every node, and permanently stored in the ledger. The entailed costs are higher, by orders of magnitude, than those in Bitcoin and can seriously tax a Bitcoin network operating at normal scale.</p>

    <p class="text-gray-300"><sup>1</sup>CoinJoin <a href="#page-54-2">[Max13]</a>, an alternative proposal, replaces the central party of a mix with multi-signature transactions that involve many collaborating Bitcoin users. CoinJoin can thus only mix small volumes of coins amongst users who are currently online, is prone to denial-of-service attacks by third parties, and requires effort to find mixing partners.</p>

    <p class="text-gray-300"><sup>2</sup>While the methods we detail in this paper accomplish this, the same techniques open the door for privacy-preserving accountability and oversight (see Section <a href="#page-35-1">10)</a>.</p>

    <p class="text-gray-300"><sup>3</sup>These published numbers <a href="#page-54-1">[MGGR13]</a> actually use a mix of parameters at both 128-bit and 80-bit security for different components of the construction. The cost is higher if all parameters are instantiated at 128-bit security.</p>

    <p class="text-gray-300">The second reason is functionality. While Zerocoin constitutes a basic e-cash scheme, it lacks critical features required of full-fledged anonymous payments. First, Zerocoin uses coins of fixed denomination: it does not support payments of exact values, nor does it provide a means to give change following a transaction (i.e., divide coins). Second, Zerocoin has no mechanism for one user to pay another one directly in &quot;zerocoins&quot;. And third, while Zerocoin provides anonymity by unlinking a payment transaction from its origin address, it does not hide the amount or other metadata about transactions occurring on the network.</p>

    <p class="text-gray-300">Our contribution. Addressing this challenge, this work offers two main contributions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) We introduce the notion of a decentralized anonymous payment scheme, which formally captures the functionality and security guarantees of a full-fledged decentralized electronic currency with strong anonymity guarantees. We provide a construction of this primitive and prove its security under specific cryptographic assumptions. The construction leverages recent advances in the area of zero-knowledge proofs. Specifically, it uses zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs) [Gro10, Lip12, BCI<sup>+</sup>13, GGPR13, PGHR13, BCG<sup>+</sup>13, Lip13, BCTV14].</li>
      <li>(2) We implement the above primitive, via a system that we call <strong>Zerocash</strong>. Our system (at 128 bits of security):</li>
      <li>reduces the size of transactions spending a coin to under 1 kB (an improvement of over 97.7%);</li>
      <li>reduces the spend-transaction verification time to under 6 ms (an improvement of over 98.6%);</li>
      <li>allows for anonymous transactions of variable amounts;</li>
      <li>hides transaction amounts and the values of coins held by users; and</li>
      <li>allows for payments to be made directly to a user's fixed address (without user interaction).</li>
    </ul>

    <p class="text-gray-300">To validate our system, we measured its performance and established feasibility by conducting experiments in a test network of 1000 nodes (approximately  <span class="math">\\frac{1}{16}</span>  of the unique IPs in the Bitcoin network and  <span class="math">\\frac{1}{3}</span>  of the nodes reachable at any given time [DW13]). This inspires confidence that Zerocash can be deployed as a fork of Bitcoin and operate at the same scale. Thus, due to its substantially improved functionality and performance, Zerocash makes it possible to entirely replace traditional Bitcoin payments with anonymous alternatives.</p>

    <p class="text-gray-300"><strong>Concurrent work.</strong> The idea of using zk-SNARKs in the Bitcoin setting was first presented by one of the authors at Bitcoin 2013 [Ben13]. In concurrent work, Danezis et al. [DFKP13] suggest using zk-SNARKs to reduce proof size and verification time in Zerocoin; see Section 9 for a comparison.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 zk-SNARKs</h3>

    <p class="text-gray-300">A zk-SNARK is an efficient variant of a zero-knowledge proof of knowledge [GMR89], which we first informally describe via an example. Suppose Alice wishes to prove to Bob the statement &quot;I (Alice) own 30 bitcoins&quot;. A simple method for Alice to do so is to point to 30 coins on the block chain and, for each of them, sign a message (&quot;hello, world&quot;) using the secret key that controls that coin. Alas, this method leaks knowledge to Bob, by identifying which coins are Alice's. A zero-knowledge proof of knowledge allows Alice to achieve the same goal, while revealing no information to Bob (beyond the fact that she knows some secret keys that control 30 coins). Crucially, such proofs can be obtained for any statement that can be verified to be true by use of an efficient computation involving auxiliary inputs such as trapdoors and passwords (such statements are called &quot;NP statements&quot;).</p>

    <p class="text-gray-300">We now sketch in more technical terms the definition of a zk-SNARK; see Section 2 for more details. A zk-SNARK is a non-interactive zero-knowledge proof of knowledge that is <em>succinct</em>, i.e., for which proofs are very short and easy to verify. More precisely, let  <span class="math">\\mathcal{L}</span>  be an NP language, and let C be a nondeterministic decision circuit for  <span class="math">\\mathcal{L}</span>  on a given instance size n. A zk-SNARK can be used</p>

    <p class="text-gray-300">to prove and verify membership in L, for instances of size n, as follows. After taking C as input, a trusted party conducts a one-time setup phase that results in two public keys: a proving key pk and a verification key vk. The proving key pk enables any (untrusted) prover to produce a proof &pi; attesting to the fact that x &isin; L, for an instance x (of size n) of his choice. The non-interactive proof &pi; is zero knowledge and a proof of knowledge. Anyone can use the verification key vk to verify the proof &pi;; in particular zk-SNARK proofs are publicly verifiable: anyone can verify &pi;, without ever having to interact with the prover who generated &pi;. Succinctness requires that (for a given security level) &pi; has constant size and can be verified in time that is linear in |x| (rather than linear in |C|).</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Centralized anonymous payment systems</h3>

    <p class="text-gray-300">Before describing our new decentralized payment system, we put it in context by recalling two pre-Bitcoin payment schemes, both of which relied on a bank, acting as a central trusted party.</p>

    <p class="text-gray-300">Anonymous e-cash. Chaum <a href="#page-53-1">[Cha82]</a> first obtained anonymous e-cash. In Chaum's scheme, the minting of a coin involves both a user, Alice, and the bank: to mint a coin of a given value v, Alice first selects a random secret serial number sn (unknown to the bank); then, the bank, after deducting v from Alice's balance, signs sn via a blind signature. Afterwards, if Alice wants to transfer her coin to Bob, she reveals sn to him and proves that sn was signed by the bank; during this transfer, Bob (or the bank) cannot deduce Alice's identity from the revealed information. Double-spending is prevented because the bank will not honor a coin with a previously-seen serial number.</p>

    <p class="text-gray-300">Unforgeable e-cash. One problem with Chaum's scheme is that coins can be forged if the bank's secret key is compromised. Sander and Ta-Shma <a href="#page-55-0">[ST99]</a> addressed this, as follows. The bank maintains a public Merkle tree of &quot;coin commitments&quot;, and users periodically retrieve its root rt; in particular, the bank maintains no secrets. When Alice requests a coin (of unit value), she picks a random serial number sn and auxiliary string r, and then sends cm := CRH(snkr) to the bank, where CRH is a collision-resistant hash; the bank deducts the appropriate amount from Alice's balance and then records cm as a leaf in the Merkle tree. Afterwards, to pay Bob, Alice sends him sn along with a zero-knowledge proof of knowledge &pi; of the following NP statement: &quot;there exists r such that CRH(snkr) is a leaf in a Merkle tree with root rt&quot;. In other words, Alice can convince Bob that sn is the serial number contained in some coin commitment in the Merkle tree; but the zero-knowledge property prevents Bob from learning information about which coin commitment is Alice's, thereby protecting Alice's identity. Later, Bob can &quot;cash out&quot; Alice's coin by showing sn and &pi; to the bank.<a href="#page-4-2">4</a></p>

    <p class="text-gray-300">Moving to a fungible anonymous decentralized system. In this paper, like <a href="#page-55-0">[ST99]</a>, we hash a coin's serial number and use Merkle trees to compactly represent the set of minted coins. Unlike <a href="#page-55-0">[ST99]</a>, we also ensure the privacy of a coin's value and support transactions that split and merge coins, thus achieving (and implementing) a new kind of fully-fungible and divisible payment scheme. As in Bitcoin (and in stark contrast to previous e-cash schemes), we do not rely on a trusted bank. Therefore, we require a new set of definitions and protocols, designed to protect Alice's anonymity while preventing her from falsely increasing her balance under the veil of her boosted privacy. An informal description of our payment scheme follows.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Decentralized anonymous payment schemes</h3>

    <p class="text-gray-300">We construct a decentralized anonymous payment (DAP) scheme, which is a decentralized e-cash scheme that allows direct anonymous payments of any amount. See Section <a href="#page-12-0">3</a> for a formal definition.</p>

    <p class="text-gray-300"><sup>4</sup>We omit details about how the bank can identify Alice in the event that she double spends her coin.</p>

    <p class="text-gray-300">Here, we outline our construction in six incremental steps; the construction details are in Section <a href="#page-17-0">4.</a></p>

    <p class="text-gray-300">Our construction functions on top of any ledger-based base currency, such as Bitcoin. At any given time, a unique valid snapshot of the currency's ledger is available to all users. The ledger is a sequence of transactions and is append-only. Transactions include both the underlying currency's transactions, as well as new transactions introduced by our construction. For concreteness, we focus the discussion below on Bitcoin (though later definitions and constructions are stated abstractly). We assume familiarity with Bitcoin <a href="#page-54-10">[Nak09]</a> and Zerocoin <a href="#page-54-1">[MGGR13]</a>; both are reviewed in Appendix <a href="#page-37-0">A.</a></p>

    <p class="text-gray-300">Step 1: user anonymity with fixed-value coins. We first describe a simplified construction, in which all coins have the same value of, e.g., 1 BTC. This construction, similar to the Zerocoin protocol, shows how to hide a payment's origin. In terms of tools, we make use of zk-SNARKs (recalled above) and a commitment scheme. Let COMM denote a statistically-hiding non-interactive commitment scheme (i.e., given randomness r and message m, the commitment is c := COMMr(m); subsequently, c is opened by revealing r and m, and one can verify that COMMr(m) equals c).</p>

    <p class="text-gray-300">In the simplified construction, a new coin c is minted as follows: a user u samples a random serial number sn and a trapdoor r, computes a coin commitment cm := COMMr(sn), and sets c := (r,sn, cm). A corresponding mint transaction txMint, containing cm (but not sn or r), is sent to the ledger; txMint is appended to the ledger only if u has paid 1 BTC to a backing escrow pool (e.g., the 1 BTC may be paid via plaintext information encoded in txMint). Mint transactions are thus certificates of deposit, deriving their value from the backing pool.</p>

    <p class="text-gray-300">Subsequently, letting CMList denote the list of all coin commitments on the ledger, u may spend c by posting a spend transaction txSpend that contains (i) the coin's serial number sn; and (ii) a zk-SNARK proof &pi; of the NP statement &quot;I know r such that COMMr(sn) appears in the list CMList of coin commitments&quot;. Assuming that sn does not already appear on the ledger (as part of a past spend transaction), u can redeem the deposited amount of 1 BTC, which u can either keep, transfer to someone else, or mint a new coin. (If sn does already appear on the ledger, this is considered double spending, and the transaction is discarded.)</p>

    <p class="text-gray-300">User anonymity is achieved because the proof &pi; is zero-knowledge: while sn is revealed, no information about r is, and finding which of the numerous commitments in CMList corresponds to a particular spend transaction txSpend is equivalent to inverting f(x) := COMMx(sn), which is assumed to be infeasible. Thus, the origin of the payment is anonymous.</p>

    <p class="text-gray-300">Step 2: compressing the list of coin commitments. In the above NP statement, CMList is specified explicitly as a list of coin commitments. This naive representation severely limits scalability because the time and space complexity of most protocol algorithms (e.g., the proof verification algorithm) grow linearly with CMList. Moreover, coin commitments corresponding to already-spent coins cannot be dropped from CMList to reduce costs, since they cannot be identified (due to the same zero-knowledge property that provides anonymity).</p>

    <p class="text-gray-300">As in <a href="#page-55-0">[ST99]</a>, we rely on a collision-resistant function CRH to avoid an explicit representation of CMList. We maintain an efficiently-updatable append-only CRH-based Merkle tree Tree(CMList) over the (growing) list CMList and let rt denote the root of Tree(CMList). It is well-known that rt can be updated to account for the insertion of new leaves with time and space proportional to just the tree depth. Hence, the time and space complexity is reduced from linear in the size of CMList to logarithmic. With this in mind, we modify the NP statement to the following one: &quot;I know r such that COMMr(sn) appears as a leaf in a CRH-based Merkle tree whose root is rt&quot;. Compared with the naive data structure for CMList, this modification increases exponentially the size of CMList that a given zk-SNARK implementation can support. (Concretely: using Merkle trees of depth 64, Zerocash supports 2<sup>64</sup> coins.)</p>

    <p class="text-gray-300">Step 3: extending coins for direct anonymous payments. So far, the coin commitment</p>

    <p class="text-gray-300">cm of a coin c is a commitment to the coin's serial number sn. However, this creates a problem when transferring  <span class="math">\\mathbf{c}</span>  to another user. Indeed, suppose that a user  <span class="math">u_A</span>  created  <span class="math">\\mathbf{c}</span> , and  <span class="math">u_A</span>  sends  <span class="math">\\mathbf{c}</span>  to another user  <span class="math">u_B</span> . First, since  <span class="math">u_A</span>  knows sn, the spending of c by  <span class="math">u_B</span>  is both non-anonymous (since  <span class="math">u_A</span>  sees when <strong>c</strong> is spent, by recognizing sn) and risky (since  <span class="math">u_A</span>  could still spend <strong>c</strong> first). Thus,  <span class="math">u_B</span> must immediately spend  <span class="math">\\mathbf{c}</span>  and mint a new coin  <span class="math">\\mathbf{c}&#x27;</span>  to protect himself. Second, if  <span class="math">u_A</span>  in fact wants to transfer to  <span class="math">u_B</span> , e.g., 100 BTC, then doing so is both unwieldy (since it requires 100 transfers) and non-anonymous (since the amount of the transfer is leaked). And third, transfers in amounts that are not multiples of 1 BTC (the fixed value of a coin) are not supported. Thus, the simplified construction described is inadequate as a payment scheme.</p>

    <p class="text-gray-300">We address this by modifying the derivation of a coin commitment, and using pseudorandom functions to target payments and to derive serial numbers, as follows. We use three pseudorandom functions (derived from a single one). For a seed x, these are denoted  <span class="math">\\mathsf{PRF}^{\\mathrm{addr}}_x(\\cdot)</span> ,  <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}_x(\\cdot)</span> , and  <span class="math">\\mathsf{PRF}^{\\mathrm{pk}}_{x}(\\cdot)</span> . We assume that  <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}</span>  is moreover collision-resistant.</p>

    <p class="text-gray-300">To provide targets for payments, we use addresses: each user u generates an address key pair  <span class="math">(a_{\\mathsf{pk}}, a_{\\mathsf{sk}})</span> , the address public key and address private key respectively. The coins of u contain the value  <span class="math">a_{pk}</span>  and can be spent only with knowledge of  <span class="math">a_{sk}</span> . A key pair  <span class="math">(a_{pk}, a_{sk})</span>  is sampled by selecting a random seed  <span class="math">a_{sk}</span>  and setting  <span class="math">a_{pk} := \\mathsf{PRF}^{\\mathrm{addr}}_{a_{sk}}(0)</span> . A user can generate and use any number of address key pairs.</p>

    <p class="text-gray-300">Next, we redesign minting to allow for greater functionality. To mint a coin c of a desired value v, the user u first samples  <span class="math">\\rho</span> , which is a secret value that determines the coin's serial number as  <span class="math">\\operatorname{sn} := \\operatorname{PRF}_{a_{\\mathsf{sk}}}^{\\operatorname{sn}}(\\rho)</span> . Then, u commits to the tuple  <span class="math">(a_{\\mathsf{pk}}, v, \\rho)</span>  in two phases: (a) u computes  <span class="math">k := \\mathsf{COMM}_r(a_{\\mathsf{pk}} \\| \\rho)</span>  for a random r; and then (b) u computes  <span class="math">\\mathsf{cm} := \\mathsf{COMM}_s(v \\| k)</span>  for a random s. The minting results in a coin  <span class="math">\\mathbf{c} := (a_{\\mathsf{pk}}, v, \\rho, r, s, \\mathsf{cm})</span>  and a mint transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}} := (v, k, s, \\mathsf{cm})</span> . Crucially, due to the nested commitment, anyone can verify that cm in tx<sub>Mint</sub> is a coin commitment of a coin of value v (by checking that  <span class="math">COMM_s(v||k)</span>  equals cm) but cannot discern the owner (by learning the address key  <span class="math">a_{pk}</span> ) or serial number (derived from  <span class="math">\\rho</span> ) because these are hidden in k. As before,  <span class="math">tx_{Mint}</span>  is accepted by the ledger only if u deposits the correct amount, in this case v BTC.</p>

    <p class="text-gray-300">Coins are spent using the <em>pour</em> operation, which takes a set of input coins, to be consumed, and &quot;pours&quot; their value into a set of fresh output coins &mdash; such that the total value of output coins equals the total value of the input coins. Suppose that u, with address key pair  <span class="math">(a_{\\sf pk}^{\\sf old}, a_{\\sf sk}^{\\sf old})</span> , wishes to consume his coin  <span class="math">\\mathbf{c}^{\\mathsf{old}} = (a_{\\mathsf{pk}}^{\\mathsf{old}}, v^{\\mathsf{old}}, \\rho^{\\mathsf{old}}, r^{\\mathsf{old}}, s^{\\mathsf{old}}, \\mathsf{cm}^{\\mathsf{old}})</span>  and produce two new coins  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>  and  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span> , with total value  <span class="math">v_1^{\\text{new}} + v_2^{\\text{new}} = v^{\\text{old}}</span> , respectively targeted at address public keys  <span class="math">a_{\\text{pk},1}^{\\text{new}}</span>  and  <span class="math">a_{\\text{pk},2}^{\\text{new}}</span> . (The addresses  <span class="math">a_{\\mathsf{pk},1}^{\\mathsf{new}}</span>  and  <span class="math">a_{\\mathsf{pk},2}^{\\mathsf{new}}</span>  may belong to u or to some other user.) The user u, for each  <span class="math">i \\in \\{1,2\\}</span> , proceeds as follows: (i) u samples serial number randomness  <span class="math">\\rho_i^{\\mathsf{new}}</span> ; (ii) u computes  <span class="math">k_i^{\\mathsf{new}} := \\mathsf{COMM}_{r_i^{\\mathsf{new}}}(a_{\\mathsf{pk},i}^{\\mathsf{new}} \\| \\rho_i^{\\mathsf{new}})</span>  for a random  <span class="math">r_i^{\\mathsf{new}}</span> ; and (iii) u computes  <span class="math">\\mathsf{cm}_i^{\\mathsf{new}} := \\mathsf{COMM}_{s_i^{\\mathsf{new}}}(v_i^{\\mathsf{new}} \\| k_i^{\\mathsf{new}})</span>  for a random  <span class="math">s_i^{\\mathsf{new}}</span> .</p>

    <p class="text-gray-300">This yields the coins  <span class="math">\\mathbf{c}_1^{\\mathsf{new}} := (a_{\\mathsf{pk},1}^{\\mathsf{new}}, v_1^{\\mathsf{new}}, \\rho_1^{\\mathsf{new}}, r_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, \\mathsf{cm}_1^{\\mathsf{new}})</span>  and  <span class="math">\\mathbf{c}_2^{\\mathsf{new}} := (a_{\\mathsf{pk},2}^{\\mathsf{new}}, v_2^{\\mathsf{new}}, \\rho_2^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}}, s_1^{\\mathsf{new}},</span></p>

    <p class="text-gray-300"><span class="math">r_2^{\\text{new}}, s_2^{\\text{new}}, \\text{cm}_2^{\\text{new}}</span> ). Next, u produces a zk-SNARK proof  <span class="math">\\pi_{\\text{POUR}}</span>  for the following NP statement, which we call POUR:</p>

    <p class="text-gray-300">&quot;Given the Merkle-tree root rt, serial number snold, and coin commitments cm<sub>1</sub><sup>new</sup>, cm<sub>2</sub><sup>new</sup>, I know coins  <span class="math">\\mathbf{c}^{\\mathsf{old}}, \\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}</span> , and address secret key  <span class="math">a_{\\mathsf{sk}}^{\\mathsf{old}}</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The coins are well-formed: for  <span class="math">\\mathbf{c}^{\\text{old}}</span>  it holds that  <span class="math">k^{\\text{old}} = \\text{COMM}_{r^{\\text{old}}}(a_{\\text{nk}}^{\\text{old}} || \\rho^{\\text{old}})</span>  and  <span class="math">\\text{cm}^{\\text{old}} = \\text{coins}</span>  <span class="math">\\begin{array}{l} \\mathsf{COMM}_{s^{\\mathsf{old}}}(v^{\\mathsf{old}} \\| k^{\\mathsf{old}}); \\ and \\ similarly \\ for \\ \\mathbf{c}_1^{\\mathsf{new}} \\ and \\ \\mathbf{c}_2^{\\mathsf{new}}. \\\\ \\bullet \\ The \\ address \\ secret \\ key \\ matches \\ the \\ public \\ key: \\ a_{\\mathsf{pk}}^{\\mathsf{old}} = \\mathsf{PRF}_{a_{\\mathsf{sk}}^{\\mathsf{old}}}^{\\mathsf{addr}}(0). \\end{array}</span></li>
      <li>The serial number is computed correctly:  <span class="math">\\operatorname{sn}^{\\operatorname{old}} := \\operatorname{PRF}^{\\operatorname{sn}}_{a^{\\operatorname{old}}}(\\rho^{\\widehat{\\operatorname{old}}})</span> .</li>
      <li>The coin commitment cmold appears as a leaf of a Merkle-tree with root rt.</li>
      <li>The values add up:  <span class="math">v_1^{\\text{new}} + v_2^{\\text{new}} = v^{\\text{old}}</span> .&quot;</li>
    </ul>

    <p class="text-gray-300">A resulting pour transaction  <span class="math">tx_{Pour} := (rt, sn^{old}, cm_1^{new}, cm_2^{new}, \\pi_{POUR})</span>  is appended to the ledger. (As before, the transaction is rejected if the serial number sn appears in a previous transaction.)</p>

    <p class="text-gray-300">Now suppose that u does not know, say, the address secret key  <span class="math">a_{\\mathsf{sk},1}^{\\mathsf{new}}</span>  that is associated with the public key  <span class="math">a_{\\mathsf{pk},1}^{\\mathsf{new}}</span> . Then, u cannot spend  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>  because he cannot provide  <span class="math">a_{\\mathsf{sk},1}^{\\mathsf{new}}</span>  as part of the witness of a subsequent pour operation. Furthermore, when a user who knows  <span class="math">a_{\\mathsf{sk},1}^{\\mathsf{new}}</span>  does spend  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> , the user u cannot track it, because he knows no information about its revealed serial number, which is  <span class="math">\\mathsf{sn}_1^{\\mathsf{new}} := \\mathsf{PRF}_{a_{\\mathsf{sk},1}^{\\mathsf{new}}}^{\\mathsf{sn}}(\\rho_1^{\\mathsf{new}})</span> .</p>

    <p class="text-gray-300">Also observe that  <span class="math">tx_{Pour}</span>  reveals no information about how the value of the consumed coin was divided among the two new fresh coins, nor which coin commitment corresponds to the consumed coin, nor the address public keys to which the two new fresh coins are targeted. The payment was conducted in full anonymity.</p>

    <p class="text-gray-300">More generally, a user may pour  <span class="math">N^{\\mathsf{old}} \\geq 0</span>  coins into  <span class="math">N^{\\mathsf{new}} \\geq 0</span>  coins. For simplicity we consider the case  <span class="math">N^{\\mathsf{old}} = N^{\\mathsf{new}} = 2</span> , without loss of generality. Indeed, for  <span class="math">N^{\\mathsf{old}} &lt; 2</span> , the user can mint a coin with value 0 and then provide it as a &quot;null&quot; input, and for  <span class="math">N^{\\mathsf{new}} &lt; 2</span> , the user can create (and discard) a new coin with value 0. For  <span class="math">N^{\\mathsf{old}} &gt; 2</span>  or  <span class="math">N^{\\mathsf{new}} &gt; 2</span> , the user can compose  <span class="math">\\log N^{\\mathsf{old}} + \\log N^{\\mathsf{new}}</span>  of the 2-input/2-output pours.</p>

    <p class="text-gray-300">Step 4: sending coins. Suppose that  <span class="math">a_{\\mathsf{pk},1}^{\\mathsf{new}}</span>  is the address public key of  <span class="math">u_1</span> . In order to allow  <span class="math">u_1</span>  to actually spend the new coin  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>  produced above, u must somehow send the secret values in  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>  to  <span class="math">u_1</span> . One way is for u to send  <span class="math">u_1</span>  a private message, but the requisite private communication channel necessitates additional infrastructure or assumptions. We avoid this &quot;out-of-band&quot; channel and instead build this capability directly into our construction by leveraging the ledger as follows.</p>

    <p class="text-gray-300">We modify the structure of an address key pair. Each user now has a key pair  <span class="math">(\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}})</span> , where  <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}})</span>  and  <span class="math">\\mathsf{addr}_{\\mathsf{sk}} = (a_{\\mathsf{sk}}, \\mathsf{sk}_{\\mathsf{enc}})</span> . The values  <span class="math">(a_{\\mathsf{pk}}, a_{\\mathsf{sk}})</span>  are generated as before. In addition,  <span class="math">(\\mathsf{pk}_{\\mathsf{enc}}, \\mathsf{sk}_{\\mathsf{enc}})</span>  is a key pair for a <em>key-private encryption scheme</em> [BBDP01].</p>

    <p class="text-gray-300">Then, u computes the ciphertext  <span class="math">\\mathbf{C}_1</span>  that is the encryption of the plaintext  <span class="math">(v_1^{\\mathsf{new}}, \\rho_1^{\\mathsf{new}}, r_1^{\\mathsf{new}}, s_1^{\\mathsf{new}})</span> , under  <span class="math">\\mathsf{pk}_{\\mathsf{enc},1}^{\\mathsf{new}}</span>  (which is part of  <span class="math">u_1</span> 's address public key  <span class="math">\\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{new}}</span> ), and includes  <span class="math">\\mathbf{C}_1</span>  in the pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> . The user  <span class="math">u_1</span>  can then find and decrypt this message (using his  <span class="math">\\mathsf{sk}_{\\mathsf{enc},1}^{\\mathsf{new}}</span> ) by scanning the pour transactions on the public ledger. Again, note that adding  <span class="math">\\mathbf{C}_1</span>  to  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  leaks neither paid amounts, nor target addresses due to the key-private property of the encryption scheme. (The user u does the same with  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span>  and includes a corresponding ciphertext  <span class="math">\\mathbf{C}_2</span>  in  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> .)</p>

    <p class="text-gray-300">Step 5: public outputs. The construction so far allows users to mint, merge, and split coins. But how can a user redeem one of his coins, i.e., convert it back to the base currency (Bitcoin)? For this, we modify the pour operation to include a public output. When spending a coin, the user u also specifies a nonnegative  <span class="math">v_{\\text{pub}}</span>  and a transaction string info  <span class="math">\\in \\{0,1\\}^*</span> . The balance equation in the NP statement POUR is changed accordingly: &quot; <span class="math">v_1^{\\text{new}} + v_2^{\\text{new}} + v_{\\text{pub}} = v^{\\text{old}}</span> &quot;. Thus, of the input value  <span class="math">v^{\\text{old}}</span> , a part  <span class="math">v_{\\text{pub}}</span>  is publicly declared, and its target is specified, somehow, by the string info. The string info can be used to specify the destination of these redeemed funds (e.g., a Bitcoin wallet public key). Both  <span class="math">v_{\\text{pub}}</span>  and info are now included in the resulting pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> . (The public output is optional, as the user u can set  <span class="math">v_{\\mathsf{pub}} = 0</span> .)</p>

    <p class="text-gray-300">Step 6: non-malleability. To prevent malleability attacks on a pour transaction  <span class="math">tx_{Pour}</span>  (e.g., embezzlement by re-targeting the public output of the pour by modifying info), we further modify the NP statement POUR and use digital signatures. Specifically, during the pour operation, the user u (i) samples a key pair  <span class="math">(pk_{sig}, sk_{sig})</span>  for a one-time signature scheme; (ii) computes  <span class="math">h_{Sig} := CRH(pk_{sig})</span> ; (iii) computes the two values  <span class="math">h_1 := PRF_{a_{sk,1}^{old}}^{pk}(h_{Sig})</span>  and  <span class="math">h_2 := PRF_{a_{sk,2}^{old}}^{pk}(h_{Sig})</span> , which act as MACs to</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^5&lt;/sup&gt;</span> These public outputs can be considered as an &quot;input&quot; to a Bitcoin-style transaction, where the string info contains the Bitcoin output scripts. This mechanism also allows us to support Bitcoin's public transaction fees.</p>

    <p class="text-gray-300">&quot;tie&quot;  <span class="math">h_{\\mathsf{Sig}}</span>  to both address secret keys; (iv) modifies POUR to include the three values  <span class="math">h_{\\mathsf{Sig}}</span> ,  <span class="math">h_1</span> ,  <span class="math">h_2</span>  and prove that the latter two are computed correctly; and (v) uses  <span class="math">\\mathsf{sk}_{\\mathsf{sig}}</span>  to sign every value associated with the pour operation, thus obtaining a signature  <span class="math">\\sigma</span> , which is included, along with  <span class="math">\\mathsf{pk}_{\\mathsf{sig}}</span> , in  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> . Since the  <span class="math">a_{\\mathsf{sk},i}^{\\mathsf{old}}</span>  are secret, and with high probability  <span class="math">h_{\\mathsf{Sig}}</span>  changes for each pour transaction, the values  <span class="math">h_1, h_2</span>  are unpredictable. Moreover, the signature on the NP statement (and other values) binds all of these together, as argued in more detail in Appendix C and Appendix D.</p>

    <p class="text-gray-300">This ends the outline of the construction, which is summarized in part in Figure 1. We conclude by noting that, due to the zk-SNARK, our construction requires a one-time trusted setup of public parameters. The soundness of the proofs depends on this trust, though anonymity continues to hold even if the setup is corrupted by a malicious party.</p>

    <p class="text-gray-300">    <img src="_page_8_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: (a) Illustration of the CRH-based Merkle tree over the list CMList of coin commitments. (b) A coin c. (c) Illustration of the structure of a coin commitment cm. (d) Illustration of the structure of a coin serial number sn.</p>

      <h3 id="sec-1.4" class="text-xl font-semibold mt-8">1.4 Zerocash</h3>

    <p class="text-gray-300">We outline Zerocash, a concrete implementation, at 128 bits of security, of our DAP scheme construction; see Section 5 for details. Zerocash entails carefully instantiating the cryptographic ingredients of the construction to ensure that the zk-SNARK, the &quot;heaviest&quot; component, is efficient enough in practice. In the construction, the zk-SNARK is used to prove/verify a specific NP statement: POUR. While zk-SNARKs are asymptotically efficient, their concrete efficiency depends on the arithmetic circuit C that is used to decide the NP statement. Thus, we seek instantiations for which we can design a relatively small arithmetic circuit  <span class="math">C_{\\text{POUR}}</span>  for verifying the NP statement POUR</p>

    <p class="text-gray-300">Our approach is to instantiate all of the necessary cryptographic ingredients (commitment schemes, pseudorandom functions, and collision-resistant hashing) based on SHA256. We first design a hand-optimized circuit for verifying SHA256 computations (or, more precisely, its compression function, which suffices for our purposes).<sup>6</sup> Then, we use this circuit to construct  <span class="math">C_{POUR}</span> , which verifies all the necessary checks for satisfying the NP statement  <span class="math">C_{POUR}</span> .</p>

    <p class="text-gray-300">This, along with judicious parameter choices, and a state-of-the-art implementation of a zk-SNARK for arithmetic circuits [BCTV14] (see Section 2.4), results in a zk-SNARK prover</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>Alternatively, we could have opted to rely on the circuit generators [PGHR13, BCG<sup>+</sup>13, BCTV14], which support various classes of C programs, by writing C code expressing the POUR checks. However, as discussed later, these generic approaches are more expensive than our hand-optimized construction.</p>

    <p class="text-gray-300">running time of a few minutes and zk-SNARK verifier running time of a few milliseconds. This allows the DAP scheme implementation to be practical for deployment, as our experiments show.</p>

    <p class="text-gray-300">Zerocash can be integrated into Bitcoin or forks of it (commonly referred to as &quot;altcoins&quot;); we later describe how this is done.</p>

      <h3 id="sec-1.5" class="text-xl font-semibold mt-8">1.5 Paper organization</h3>

    <p class="text-gray-300">The remainder of this paper is organized as follows. Section 2 provides background on zk-SNARKs. We define DAP schemes in Section 3, and our construction thereof in Section 4. Section 5 discusses the concrete instantiation in Zerocash. Section 6 describes the integration of Zerocash into existing ledger-based currencies. Section 7 provides microbenchmarks for our prototype implementation, as well as results based on full-network simulations. Section 8 describes optimizations. We discuss concurrent work in Section 9 and summarize our contributions and future directions in Section 10.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Background on zk-SNARKs</h2>

    <p class="text-gray-300">The main cryptographic primitive used in this paper is a special kind of Succinct Non-interactive ARgument of Knowledge (SNARK). Concretely, we use a publicly-verifiable preprocessing zero-knowledge SNARK, or zk-SNARK for short. In this section we provide basic background on zk-SNARKs, provide an informal definition, compare zk-SNARKs with the more familiar notion of NIZKs, and recall known constructions and implementations.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Informal definition</h3>

    <p class="text-gray-300">We informally define zk-SNARKs for arithmetic circuit satisfiability. We refer the reader to, e.g., [BCI<sup>+</sup>13] for a formal definition.</p>

    <p class="text-gray-300">For a field  <span class="math">\\mathbb{F}</span> , an  <span class="math">\\mathbb{F}</span> -arithmetic circuit takes inputs that are elements in  <span class="math">\\mathbb{F}</span> , and its gates output elements in  <span class="math">\\mathbb{F}</span> . We naturally associate a circuit with the function it computes. To model nondeterminism we consider circuits that have an input  <span class="math">x \\in \\mathbb{F}^n</span>  and an auxiliary input  <span class="math">a \\in \\mathbb{F}^h</span> , called a witness. The circuits we consider only have bilinear gates.<sup>7</sup> Arithmetic circuit satisfiability is defined analogously to the boolean case, as follows.</p>

    <p class="text-gray-300"><strong>Definition 2.1.</strong> The arithmetic circuit satisfiability problem of an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C \\colon \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  is captured by the relation  <span class="math">\\mathcal{R}_C = \\{(x, a) \\in \\mathbb{F}^n \\times \\mathbb{F}^h \\colon C(x, a) = 0^l\\}</span> ; its language is  <span class="math">\\mathcal{L}_C = \\{x \\in \\mathbb{F}^n : \\exists a \\in \\mathbb{F}^h \\text{ s.t. } C(x, a) = 0^l\\}.</span></p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}</span> , a (publicly-verifiable preprocessing) <strong>zk-SNARK</strong> for  <span class="math">\\mathbb{F}</span> -arithmetic circuit satisfiability is a triple of polynomial-time algorithms (KeyGen, Prove, Verify):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>KeyGen( <span class="math">1^{\\lambda}</span> , C)  <span class="math">\\rightarrow</span>  (pk, vk). On input a security parameter  <span class="math">\\lambda</span>  (presented in unary) and an  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, the <em>key generator</em> KeyGen probabilistically samples a <em>proving key</em> pk and a <em>verification key</em> vk. Both keys are published as public parameters and can be used, any number of times, to prove/verify membership in  <span class="math">\\mathcal{L}_C</span> .</li>
      <li>Prove(pk, x, a)  <span class="math">\\to \\pi</span> . On input a proving key pk and any  <span class="math">(x, a) \\in \\mathcal{R}_C</span> , the prover Prove outputs a non-interactive proof  <span class="math">\\pi</span>  for the statement  <span class="math">x \\in \\mathcal{L}_C</span> .</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>A gate with inputs  <span class="math">y_1, \\ldots, y_m \\in \\mathbb{F}</span>  is <em>bilinear</em> if the output is  <span class="math">\\langle \\vec{a}, (1, y_1, \\ldots, y_m) \\rangle \\cdot \\langle \\vec{b}, (1, y_1, \\ldots, y_m) \\rangle</span>  for some  <span class="math">\\vec{a}, \\vec{b} \\in \\mathbb{F}^{m+1}</span> . These include addition, multiplication, negation, and constant gates.</p>

    <p class="text-gray-300">&bull; Verify(vk,  <span class="math">x, \\pi</span> )  <span class="math">\\to b</span> . On input a verification key vk, an input x, and a proof  <span class="math">\\pi</span> , the verifier Verify outputs b = 1 if he is convinced that  <span class="math">x \\in \\mathcal{L}_C</span> .</p>

    <p class="text-gray-300">A zk-SNARK satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> For every security parameter  <span class="math">\\lambda</span> , any  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, and any  <span class="math">(x, a) \\in \\mathcal{R}_C</span> , the honest prover can convince the verifier. Namely, b = 1 with probability  <span class="math">1 - \\text{negl}(\\lambda)</span>  in the following experiment:  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathsf{KeyGen}(1^{\\lambda}, C)</span> ;  <span class="math">\\pi \\leftarrow \\mathsf{Prove}(\\mathsf{pk}, x, a)</span> ;  <span class="math">b \\leftarrow \\mathsf{Verify}(\\mathsf{vk}, x, \\pi)</span> .</p>

    <p class="text-gray-300"><strong>Succinctness.</strong> An honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda}(1)</span>  bits and  <span class="math">\\mathsf{Verify}(\\mathsf{vk}, x, \\pi)</span>  runs in time  <span class="math">O_{\\lambda}(|x|)</span> . (Here,  <span class="math">O_{\\lambda}</span>  hides a fixed polynomial factor in  <span class="math">\\lambda</span> .)</p>

    <p class="text-gray-300"><strong>Proof of knowledge (and soundness).</strong> If the verifier accepts a proof output by a bounded prover, then the prover &quot;knows&quot; a witness for the given instance. (In particular, soundness holds against bounded provers.) Namely, for every poly( <span class="math">\\lambda</span> )-size adversary  <span class="math">\\mathcal{A}</span> , there is a poly( <span class="math">\\lambda</span> )-size extractor  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\mathsf{Verify}(\\mathsf{vk}, x, \\pi) = 1</span>  and  <span class="math">(x, a) \\notin \\mathcal{R}_C</span>  with probability  <span class="math">\\mathsf{negl}(\\lambda)</span>  in the following experiment:  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathsf{KeyGen}(1^{\\lambda}, C)</span> ;  <span class="math">(x, \\pi) \\leftarrow \\mathcal{A}(\\mathsf{pk}, \\mathsf{vk})</span> ;  <span class="math">a \\leftarrow \\mathcal{E}(\\mathsf{pk}, \\mathsf{vk})</span> .</p>

    <p class="text-gray-300"><strong>Perfect zero knowledge.</strong> An honestly-generated proof is perfect zero knowledge.<sup>8</sup> Namely, there is a polynomial-time simulator  <span class="math">\\mathsf{Sim}</span>  such that for all stateful distinguishers  <span class="math">\\mathcal{D}</span>  the following two probabilities are equal:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} (x,a) \\in \\mathcal{R}_C \\\\ \\mathcal{D}(\\pi) = 1 \\end{array} \\middle| \\begin{array}{c} (\\mathsf{pk},\\mathsf{vk}) \\leftarrow \\mathsf{KeyGen}(1^\\lambda,C) \\\\ (x,a) \\leftarrow \\mathcal{D}(\\mathsf{pk},\\mathsf{vk}) \\\\ \\pi \\leftarrow \\mathsf{Prove}(\\mathsf{pk},x,a) \\end{array} \\right] \\quad \\text{and} \\quad \\Pr\\left[\\begin{array}{c|c} (x,a) \\in \\mathcal{R}_C \\\\ \\mathcal{D}(\\pi) = 1 \\end{array} \\middle| \\begin{array}{c} (\\mathsf{pk},\\mathsf{vk},\\mathsf{trap}) \\leftarrow \\mathsf{Sim}(1^\\lambda,C) \\\\ (x,a) \\leftarrow \\mathcal{D}(\\mathsf{pk},\\mathsf{vk}) \\\\ \\pi \\leftarrow \\mathsf{Sim}(\\mathsf{trap},x) \\end{array} \\right] \\ .</span>$</p>

    <p class="text-gray-300">(the probability that  <span class="math">\\mathcal{D}(\\pi) = 1</span>  on an honest proof)</p>

    <p class="text-gray-300">(the probability that  <span class="math">\\mathcal{D}(\\pi) = 1</span>  on a simulated proof)</p>

    <p class="text-gray-300"><strong>Remark.</strong> Both proof of knowledge and zero knowledge are essential to the use of zk-SNARKs in this paper. Indeed, we consider circuits C that verify assertions about cryptographic primitives (such as using a knowledge of SHA256 pre-image as a binding commitment). Thus it <em>does not suffice</em> to merely know that, for a given input x, a witness for  <span class="math">x \\in \\mathcal{L}_C</span>  exists. Instead, proof of knowledge ensures that a witness can be efficiently found (by extracting it from the prover) whenever the verifier accepts a proof. As for zero knowledge, it ensures that a proof leaks no information about the witness, beyond the fact that  <span class="math">x \\in \\mathcal{L}_C</span> .</p>

    <p class="text-gray-300"><strong>Remark.</strong> In the security proofs (see Appendix D), we deal with provers producing a vector of inputs  <span class="math">\\vec{x}</span>  together with a vector of corresponding proofs  <span class="math">\\vec{\\pi}</span> . In such cases, it is convenient to use an extractor that can extract a vector of witnesses  <span class="math">\\vec{a}</span>  containing a valid witness for each valid proof. This &quot;multi-instance&quot; extraction follows from the &quot;single-instance&quot; one described above [BCCT12, BCCT13]. Namely, if (KeyGen, Prove, Verify) is a zk-SNARK, then for any poly( <span class="math">\\lambda</span> )-size prover adversary  <span class="math">\\mathcal A</span>  there exists a poly( <span class="math">\\lambda</span> )-size extractor  <span class="math">\\mathcal E</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{ll} \\exists \\ i \\ \\text{ s.t. } &amp; \\mathsf{Verify}(\\mathsf{vk}, x_i, \\pi_i) = 1 \\\\ (x_i, a_i) \\notin \\mathcal{R}_C \\end{array} \\right| \\begin{array}{c} (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathsf{KeyGen}(1^\\lambda, C) \\\\ (\\vec{x}, \\vec{\\pi}) \\leftarrow \\mathcal{A}(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\vec{a} \\leftarrow \\mathcal{E}(\\mathsf{pk}, \\mathsf{vk}) \\end{array} \\right] \\leq \\operatorname{negl}(\\lambda) \\ .</span>$</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Comparison with NIZKs</h3>

    <p class="text-gray-300">zk-SNARKs are related to a familiar cryptographic primitive: non-interactive zero-knowledge proofs of knowledge (NIZKs). Both zk-SNARKs and NIZKs require a one-time trusted setup of public</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>While most zk-SNARK descriptions in the literature only mention statistical zero knowledge, all zk-SNARK constructions can be made perfect zero knowledge by allowing for a negligible error probability in completeness.</p>

    <p class="text-gray-300">parameters (proving and verification keys for zk-SNARKs, and a common reference string for NIZKs). Both provide the same guarantees of completeness, proof of knowledge, and zero knowledge. The difference lies in efficiency guarantees. In a NIZK, the proof length and verification time depend on the NP language being proved. For instance, for the language of circuit satisfiability, the proof length and verification time in <a href="#page-54-11">[GOS06b,</a> <a href="#page-54-12">GOS06a]</a> are linear in the circuit size. Conversely, in a zk-SNARK, proof length depends only on the security parameter, and verification time depends only on the instance size (and security parameter) but not on the circuit or witness size.</p>

    <p class="text-gray-300">Thus, zk-SNARKs can be thought of as &quot;succinct NIZKs&quot;, having short proofs and fast verification times. Succinctness comes with a caveat: known zk-SNARK constructions rely on stronger assumptions than NIZKs do (see below).</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Known constructions and security</h3>

    <p class="text-gray-300">There are many zk-SNARK constructions in the literature <a href="#page-54-3">[Gro10,</a> <a href="#page-54-4">Lip12,</a> <a href="#page-53-4">BCI</a>+13, <a href="#page-54-5">GGPR13,</a> <a href="#page-55-3">PGHR13,</a> <a href="#page-53-5">BCG</a>+13, <a href="#page-54-6">Lip13,</a> <a href="#page-53-6">BCTV14]</a>. We are interested in zk-SNARKs for arithmetic circuit satisfiability, and the most efficient ones for this language are based on quadratic arithmetic programs <a href="#page-54-5">[GGPR13,</a> <a href="#page-53-4">BCI</a>+13, <a href="#page-55-3">PGHR13,</a> <a href="#page-53-5">BCG</a>+13, <a href="#page-53-6">BCTV14]</a>; such constructions provide a lineartime KeyGen, quasilinear-time Prove, and linear-time Verify.</p>

    <p class="text-gray-300">Security of zk-SNARKs is based on knowledge-of-exponent assumptions and variants of Diffie&ndash; Hellman assumptions in bilinear groups <a href="#page-54-3">[Gro10,</a> <a href="#page-53-11">BB04,</a> <a href="#page-54-13">Gen04]</a>. While knowledge-of-exponent assumptions are fairly strong, there is evidence that such assumptions may be inherent for constructing zk-SNARKs <a href="#page-54-14">[GW11,</a> <a href="#page-53-9">BCCT12]</a>.</p>

    <p class="text-gray-300">Remark (fully-succinct zk-SNARKs). The key generator KeyGen takes a circuit C as input. Thus, KeyGen's running time is at least linear in the size of the circuit C. One could require KeyGen to not have to take C as input, and have its output keys work for all (polynomial-size) circuits C. In such a case, KeyGen's running time would be independent of C. A zk-SNARK satisfying this stronger property is fully succinct. Theoretical constructions of fully-succinct zk-SNARKs are known, based on various cryptographic assumptions <a href="#page-54-15">[Mic00,</a> <a href="#page-55-4">Val08,</a> <a href="#page-53-10">BCCT13]</a>. Despite achieving essentially-optimal asymptotics <a href="#page-53-12">[BFLS91,</a> <a href="#page-53-13">BGH</a>+05, <a href="#page-53-14">BCGT13b,</a> <a href="#page-53-15">BCGT13a,</a> <a href="#page-53-10">BCCT13]</a> no implementations of them have been reported in the literature to date.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 zk-SNARK implementations</h3>

    <p class="text-gray-300">There are three published implementations of zk-SNARKs: (i) Parno et al. <a href="#page-55-3">[PGHR13]</a> present an implementation of zk-SNARKs for programs having no data dependencies;<a href="#page-11-2">9</a> (ii) Ben-Sasson et al. <a href="#page-53-5">[BCG</a>+13] present an implementation of zk-SNARKs for arbitrary programs (with data dependencies); and (iii) Ben-Sasson et al. <a href="#page-53-6">[BCTV14]</a> present an implementation of zk-SNARKs that supports programs that modify their own code (e.g., for runtime code generation); their implementation also reduces costs for programs of larger size and allows for universal key pairs.</p>

    <p class="text-gray-300">Each of the works above also achieves zk-SNARKs for arithmetic circuit satisfiability as a stepping stone towards their respective higher-level efforts. In this paper we are only interested in a zk-SNARK for arithmetic circuit satisfiability, and we rely on the implementation of <a href="#page-53-6">[BCTV14]</a> for such a zk-SNARK. <a href="#page-11-3">10</a> The implementation in <a href="#page-53-6">[BCTV14]</a> is itself based on the protocol of Parno et al. <a href="#page-55-3">[PGHR13]</a>. We thus refer the interested reader to <a href="#page-55-3">[PGHR13]</a> for details of the protocol, its</p>

    <p class="text-gray-300"><sup>9</sup>They only support programs where array indices are restricted to be known compile-time constants; similarly, loop iteration counts (or at least upper bounds to these) must be known at compile time.</p>

    <p class="text-gray-300"><sup>10</sup>In <a href="#page-53-6">[BCTV14]</a>, one optimization to the verifier's runtime requires preprocessing the verification key vk; for simplicity, we do not use this optimization.</p>

    <p class="text-gray-300">intuition, and its proof of security; and to [BCTV14] for the implementation and its performance. In terms of concrete parameters, the implementation of [BCTV14] provides 128 bits of security, and the field  <span class="math">\\mathbb{F}</span>  is of a 256-bit prime order p.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Definition of a decentralized anonymous payment scheme</h2>

    <p class="text-gray-300">We introduce the notion of a decentralized anonymous payment scheme (DAP scheme), extending the notion of decentralized e-cash [MGGR13]. Later, in Section 4, we provide a construction.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Data structures</h3>

    <p class="text-gray-300">We begin by describing, and giving intuition about, the data structures used by a DAP scheme. The algorithms that use and produce these data structures are introduced in Section 3.2.</p>

    <p class="text-gray-300"><strong>Basecoin ledger.</strong> Our protocol is applied on top of a ledger-based base currency such as Bitcoin; for generality we refer to this base currency as <em>Basecoin</em>. At any given time T, all users have access to  <span class="math">L_T</span> , the <em>ledger</em> at time T, which is a sequence of <em>transactions</em>. The ledger is append-only (i.e., T &lt; T' implies that  <span class="math">L_T</span>  is a prefix of  <span class="math">L_{T&#x27;}</span> ). The transactions in the ledger include both Basecoin transactions as well as two new transaction types described below.</p>

    <p class="text-gray-300"><strong>Public parameters.</strong> A list of <em>public parameters</em> <strong>pp</strong> is available to all users in the system. These are generated by a trusted party at the &quot;start of time&quot; and are used by the system's algorithms.</p>

    <p class="text-gray-300"><strong>Addresses.</strong> Each user generates at least one <em>address key pair</em> ( <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> ,  <span class="math">\\mathsf{addr}_{\\mathsf{sk}}</span> ). The public key  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>  is published and enables others to direct payments to the user. The secret key  <span class="math">\\mathsf{addr}_{\\mathsf{sk}}</span>  is used to receive payments sent to  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> . A user may generate any number of address key pairs.</p>

    <p class="text-gray-300">Coins. A coin is a data object c, to which we associate the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A coin commitment, denoted cm(c): a string that appears on the ledger once c is minted.</li>
      <li>A coin value, denoted  <span class="math">v(\\mathbf{c})</span> : the denomination of  <span class="math">\\mathbf{c}</span> , as measured in basecoins, as an integer between 0 and a maximum value  <span class="math">v_{\\text{max}}</span>  (which is a system parameter).</li>
      <li>A coin serial number, denoted sn(c): a unique string associated with c, used to prevent double spending.</li>
      <li><span class="math">\\bullet</span>  A  <span class="math">\\mathit{coin}</span>   <span class="math">\\mathit{address},</span>  denoted  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}(\\mathbf{c}):</span>  an address public key, representing who owns  <span class="math">\\mathbf{c}.</span></li>
    </ul>

    <p class="text-gray-300">Any other quantities associated with a coin  <span class="math">\\mathbf{c}</span>  (e.g., various trapdoors) are implementation details.</p>

    <p class="text-gray-300"><strong>New transactions.</strong> Besides Basecoin transactions, there are two new types of transactions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Mint transactions. A mint transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span>  is a tuple  <span class="math">(\\mathsf{cm}, v, *)</span> , where  <span class="math">\\mathsf{cm}</span>  is a coin commitment, v is a coin value, and * denotes other (implementation-dependent) information. The transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span>  records that a coin  <span class="math">\\mathbf{c}</span>  with coin commitment  <span class="math">\\mathsf{cm}</span>  and value v has been minted.</li>
      <li>Pour transactions. A pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  is a tuple  <span class="math">(\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, *)</span> , where  <span class="math">\\mathsf{rt}</span>  is a root of a Merkle tree,  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}</span>  are two coin serial numbers,  <span class="math">\\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}</span>  are two coin commitments,  <span class="math">v_{\\mathsf{pub}}</span>  is a coin value, info is an arbitrary string, and * denotes other (implementation-dependent) information. The transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  records the pouring of two input (and now consumed) coins  <span class="math">\\mathsf{c}_1^{\\mathsf{old}}, \\mathsf{c}_2^{\\mathsf{old}}</span> , with respective serial numbers  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}</span> , into two new output coins  <span class="math">\\mathsf{c}_1^{\\mathsf{new}}, \\mathsf{c}_2^{\\mathsf{new}}</span> , with respective coin commitments  <span class="math">\\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}</span> , as well as a public output  <span class="math">v_{\\mathsf{pub}}</span>  (which may be zero). Furthermore,  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  also records an information string info (perhaps containing information on who is the recipient of  <span class="math">v_{\\mathsf{pub}}</span>  basecoins) and that, when this transaction was made, the root of the Merkle tree over coin commitments was  <span class="math">\\mathsf{rt}</span>  (see below).</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup>In reality, the Basecoin ledger (such as the one of Bitcoin) is not perfect and may incur temporary inconsistencies. In this respect our construction is as good as the underlying ledger. We discuss the effects of this on anonymity and mitigations in Section 6.4.</p>

    <p class="text-gray-300">Commitments of minted coins and serial numbers of spent coins. For any given time T,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>CMList<sub>T</sub> denotes the list of all coin commitments appearing in mint and pour transactions in  <span class="math">L_T</span> ;</li>
      <li><span class="math">\\mathsf{SNList}_T</span>  denotes the list of all serial numbers appearing in pour transactions in  <span class="math">L_T</span> .</li>
    </ul>

    <p class="text-gray-300">While both of these lists can be deduced from  <span class="math">L_T</span> , it will be convenient to think about them as separate (as, in practice, these may be separately maintained for efficiency reasons; cf. Section 8.3).</p>

    <p class="text-gray-300">Merkle tree over commitments. For any given time T,  <span class="math">\\mathsf{Tree}_T</span>  denotes a Merkle tree over  <span class="math">\\mathsf{CMList}_T</span>  and  <span class="math">\\mathsf{rt}_T</span>  its root. Moreover, the function  <span class="math">\\mathsf{Path}_T(\\mathsf{cm})</span>  gives the authentication path from a coin commitment  <span class="math">\\mathsf{cm}</span>  appearing in  <span class="math">\\mathsf{CMList}_T</span>  to the root of  <span class="math">\\mathsf{Tree}_T</span> . For convenience, we assume that  <span class="math">L_T</span>  also stores  <span class="math">\\mathsf{rt}_{T&#x27;}</span>  for all  <span class="math">T&#x27; \\leq T</span>  (i.e., it stores all past Merkle tree roots).</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Algorithms</h3>

    <p class="text-gray-300">A DAP scheme  <span class="math">\\Pi</span>  is a tuple of polynomial-time algorithms</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{Setup}, \\mathsf{CreateAddress}, \\mathsf{Mint}, \\mathsf{Pour}, \\mathsf{VerifyTransaction}, \\mathsf{Receive})</span></p>

    <p class="text-gray-300">with the following syntax and semantics.</p>

    <p class="text-gray-300">System setup. The algorithm Setup generates a list of public parameters:</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold">Setup</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet</span>  inputs: security parameter  <span class="math">\\lambda</span></li>
      <li>OUTPUTS: public parameters pp</li>
    </ul>

    <p class="text-gray-300">The algorithm Setup is executed by a trusted party. The resulting public parameters pp are published and made available to all parties (e.g., by embedding them into the protocol's implementation). The setup is done <em>only once</em>; afterwards, no trusted party is needed, and no global secrets or trapdoors are kept.</p>

    <p class="text-gray-300">Creating payment addresses. The algorithm CreateAddress generates a new address key pair:</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">CreateAddress</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS: public parameters pp</li>
      <li>OUTPUTS: address key pair (addr<sub>pk</sub>, addr<sub>sk</sub>)</li>
    </ul>

    <p class="text-gray-300">Each user generates at least one address key pair  <span class="math">(addr_{pk}, addr_{sk})</span>  in order to receive coins. The public key  <span class="math">addr_{pk}</span>  is published, while the secret key  <span class="math">addr_{sk}</span>  is used to redeem coins sent to  <span class="math">addr_{pk}</span> . A user may generate any number of address key pairs; doing so does not require any interaction.</p>

    <p class="text-gray-300">Minting coins. The algorithm Mint generates a coin (of a given value) and a mint transaction:</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">Mint</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>public parameters pp</li>
      <li>coin value  <span class="math">v \\in \\{0, 1, \\dots, v_{\\mathsf{max}}\\}</span></li>
      <li>destination address public key addr<sub>pk</sub></li>
    </ul></li>
      <li><span class="math">\\bullet</span>  OUTPUTS: coin  <span class="math">{\\bf c}</span>  and mint transaction  <span class="math">{\\sf tx}_{\\sf Mint}</span></li>
    </ul>

    <p class="text-gray-300">A system parameter,  <span class="math">v_{\\text{max}}</span> , caps the value of any single coin. The output coin  <span class="math">\\mathbf{c}</span>  has value v and coin address  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> ; the output mint transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span>  equals  <span class="math">(\\mathsf{cm}, v, *)</span> , where  <span class="math">\\mathsf{cm}</span>  is the coin commitment of  <span class="math">\\mathbf{c}</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;12</sup>While we refer to Mekle trees for simplicity, it is straightforward to extend the definition to allow other data structures representing sets with fast insertion and efficient proofs of membership.</p>

    <p class="text-gray-300"><strong>Pouring coins.</strong> The <strong>Pour</strong> algorithm transfers value from input coins into new output coins, marking the input coins as consumed. Moreover, a fraction of the input value may be publicly revealed. Pouring allows users to subdivide coins into smaller denominations, merge coins, and transfer ownership of anonymous coins, or make public payments.<sup>13</sup></p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Pour</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>public parameters pp</li>
      <li>the Merkle root rt</li>
      <li>old coins  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span></li>
      <li>old addresses secret keys addrold, addrold sk.1,</li>
      <li>authentication path  <span class="math">\\mathsf{path}_1</span>  from commitment  <span class="math">\\mathsf{cm}(\\mathbf{c}_1^\\mathsf{old})</span>  to root rt, authentication path  <span class="math">\\mathsf{path}_2</span>  from commitment  <span class="math">\\mathsf{cm}(\\mathbf{c}_2^\\mathsf{old})</span>  to root rt</li>
      <li>new values  <span class="math">v_1^{\\mathsf{new}}, v_2^{\\mathsf{new}}</span></li>
      <li>new addresses public keys addr<sup>new</sup><sub>pk,1</sub>, addr<sup>new</sup><sub>pk,2</sub></li>
      <li>public value  <span class="math">v_{\\sf pub}</span></li>
      <li>transaction string info</li>
    </ul></li>
      <li>OUTPUTS: new coins  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}</span>  and pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span></li>
    </ul>

    <p class="text-gray-300">Thus, the Pour algorithm takes as input two distinct input coins  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{old}}</span> , along with corresponding address secret keys  <span class="math">\\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{old}}</span> ,  <span class="math">\\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}}</span>  (required to redeem the two input coins). To ensure that  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{old}}</span>  have been previously minted, the Pour algorithm also takes as input the Merkle root rt (allegedly, equal to the root of Merkle tree over all coin commitments so far), along with two authentication paths  <span class="math">\\mathsf{path}_1</span> ,  <span class="math">\\mathsf{path}_2</span>  for the two coin commitments  <span class="math">\\mathsf{cm}(\\mathbf{c}_1^{\\mathsf{old}})</span> ,  <span class="math">\\mathsf{cm}(\\mathbf{c}_2^{\\mathsf{old}})</span> . Two input values  <span class="math">v_1^{\\mathsf{new}}</span> ,  <span class="math">v_2^{\\mathsf{new}}</span>  specify the values of two new anonymous coins  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span>  to be generated, and two input address public keys  <span class="math">\\mathsf{addr}_{\\mathsf{pk},1}^{\\mathsf{new}}</span> ,  <span class="math">\\mathsf{addr}_{\\mathsf{pk},2}^{\\mathsf{new}}</span>  specify the recipients of  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span> . A third value,  <span class="math">v_{\\mathsf{pub}}</span> , specifies the amount to be publicly spent (e.g., to redeem coins or pay transaction fees). The sum of output values  <span class="math">v_1^{\\mathsf{new}} + v_2^{\\mathsf{new}} + v_{\\mathsf{pub}}</span>  must be equal to the sum of the values of the input coins (and cannot exceed  <span class="math">v_{\\mathsf{max}}</span> ). Finally, the Pour algorithm also receives an arbitrary string info, which is bound into the output pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> .</p>

    <p class="text-gray-300">The Pour algorithm outputs two new coins  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span>  and a pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> . The transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  equals  <span class="math">(\\mathsf{rt}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, \\mathsf{v}_{\\mathsf{pub}}, \\mathsf{info}, *)</span> , where  <span class="math">\\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}</span>  are the two coin commitments of the two output coins, and * denotes other (implementation-dependent) information. Crucially,  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  reveals only one value, the public value  <span class="math">v_{\\mathsf{pub}}</span>  (which may be zero); it does not reveal the payment addresses or values of the old or new coins.</p>

    <p class="text-gray-300">Verifying transactions. The algorithm VerifyTransaction checks the validity of a transaction:</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">VerifyTransaction</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>public parameters pp</li>
      <li>a (mint or pour) transaction tx</li>
      <li>the current ledger L</li>
    </ul></li>
      <li><span class="math">\\bullet</span>  OUTPUTS: bit b, equals 1 iff the transaction is valid</li>
    </ul>

    <p class="text-gray-300">Both mint and pour transactions must be verified before being considered well-formed. In practice, transactions can be verified by the nodes in the distributed system maintaining the ledger, as well</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{13}&lt;/sup&gt;</span> We consider pours with 2 inputs and 2 outputs, for simplicity and (as discussed in Section 1.3) without loss of generality.</p>

    <p class="text-gray-300">as by users who rely on these transactions.</p>

    <p class="text-gray-300">Receiving coins. The algorithm Receive scans the ledger and retrieves unspent coins paid to a particular user address:</p>

    <h3 id="sec-misc-6" class="text-xl font-semibold mt-8">Receive</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>inputs:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>recipient address key pair (addrpk, addrsk)</li>
      <li>the current ledger L</li>
    </ul></li>
      <li>outputs: set of (unspent) received coins</li>
    </ul>

    <p class="text-gray-300">When a user with address key pair (addrpk, addrsk) wishes to receive payments sent to addrpk, he uses the Receive algorithm to scan the ledger. For each payment to addrpk appearing in the ledger, Receive outputs the corresponding coins whose serial numbers do not appear on the ledger L. Coins received in this way may be spent, just like minted coins, using the Pour algorithm. (We only require Receive to detect coins paid to addrpk via the Pour algorithm and not also detect coins minted by the user himself.)</p>

    <p class="text-gray-300">Next, we describe completeness (Section <a href="#page-15-0">3.3)</a> and security (Section <a href="#page-15-1">3.4)</a>.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Completeness</h3>

    <p class="text-gray-300">Completeness of a DAP scheme requires that unspent coins can be spent. More precisely, consider a ledger sampler S outputting a ledger L. If c<sup>1</sup> and c<sup>2</sup> are two coins whose coin commitments appear in (valid) transactions on L, but their serial numbers do not appear in L, then c<sup>1</sup> and c<sup>2</sup> can be spent using Pour. Namely, running Pour results in a pour transaction txPour that VerifyTransaction accepts, and the new coins can be received by the intended recipients (by using Receive); moreover, txPour correctly records the intended vpub and transaction string info. This property is formalized via an incompleteness experiment INCOMP.</p>

    <p class="text-gray-300">Definition 3.1. A DAP scheme &Pi; = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) is complete if no polynomial-size ledger sampler S wins INCOMP with more than negligible probability. (See Appendix <a href="#page-38-0">B</a> for details.)</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Security</h3>

    <p class="text-gray-300">Security of a DAP scheme is characterized by three properties, which we call ledger indistinguishability, transaction non-malleability, and balance.</p>

    <p class="text-gray-300">Definition 3.2. A DAP scheme &Pi; = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) is secure if it satisfies ledger indistinguishability, transaction non-malleability, and balance.</p>

    <p class="text-gray-300">Below, we provide an informal overview of each property, and defer formal definitions to Appendix <a href="#page-39-0">C.</a></p>

    <p class="text-gray-300">Each property is formalized as a game between an adversary A and a challenger C. In each game, the behavior of honest parties is realized via a DAP scheme oracle ODAP, which maintains a ledger L and provides an interface for executing CreateAddress, Mint, Pour and Receive algorithms for honest parties. To elicit behavior from honest parties, A passes a query to C, which (after sanity checks) proxies the query to ODAP. For each query that requests an honest party to perform an action, A specifies identities of previous transactions and the input values, and learns the resulting transaction, but not any of the secrets or trapdoors involved in producing that transaction. The oracle ODAP also provides an Insert query that allows A to directly add aribtrary transactions to the ledger L. <strong>Ledger indistinguishability.</strong> This property captures the requirement that the ledger reveals no new information to the adversary beyond the publicly-revealed information (values of minted coins, public values, information strings, total number of transactions, etc.), even when the adversary can adaptively induce honest parties to perform DAP operations of his choice. That is, no bounded adversary  <span class="math">\\mathcal{A}</span>  can distinguish between two ledgers  <span class="math">L_0</span>  and  <span class="math">L_1</span> , constructed by  <span class="math">\\mathcal{A}</span>  using queries to two DAP scheme oracles, when the queries to the two oracles are <em>publicly consistent</em>: they have matching type and are identical in terms of publicly-revealed information and the information related to addresses controlled by  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Ledger indistinguishability is formalized by an experiment L-IND that proceeds as follows. First, a challenger samples a random bit b and initializes two DAP scheme oracles  <span class="math">\\mathcal{O}_0^{\\mathsf{DAP}}</span>  and  <span class="math">\\mathcal{O}_1^{\\mathsf{DAP}}</span> , maintaining ledgers  <span class="math">L_0</span>  and  <span class="math">L_1</span> . Throughout, the challenger allows  <span class="math">\\mathcal{A}</span>  to issue queries to  <span class="math">\\mathcal{O}_0^{\\mathsf{DAP}}</span>  and  <span class="math">\\mathcal{O}_1^{\\mathsf{DAP}}</span> , thus controlling the behavior of honest parties on  <span class="math">L_0</span>  and  <span class="math">L_1</span> . The challenger provides the adversary with the view of both ledgers, but in randomized order:  <span class="math">L_{\\mathsf{Left}} := L_b</span>  and  <span class="math">L_{\\mathsf{Right}} := L_{1-b}</span> . The adversary's goal is to distinguish whether the view he sees corresponds to  <span class="math">(L_{\\mathsf{Left}}, L_{\\mathsf{Right}}) = (L_0, L_1)</span> , i.e. b = 0, or to  <span class="math">(L_{\\mathsf{Left}}, L_{\\mathsf{Right}}) = (L_1, L_0)</span> , i.e. b = 1.</p>

    <p class="text-gray-300">At each round of the experiment, the adversary issues queries in pairs Q, Q' of matching query type. If the query type is <strong>CreateAddress</strong>, then the same address is generated at both oracles. If it is to <strong>Mint</strong>, <strong>Pour</strong> or <strong>Receive</strong>, then Q is forwarded to  <span class="math">L_0</span>  and Q' to  <span class="math">L_1</span> ; for <strong>Insert</strong> queries, query Q is forwarded to  <span class="math">L_{\\text{Left}}</span>  and Q' is forwarded to  <span class="math">L_{\\text{Right}}</span> . The adversary's queries are restricted in the sense that they must maintain the <em>public consistency</em> of the two ledgers. For example, the public values for <strong>Pour</strong> queries must be the same, as well as minted amounts for <strong>Mint</strong> queries.</p>

    <p class="text-gray-300">At the conclusion of the experiment,  <span class="math">\\mathcal{A}</span>  outputs a guess b', and wins when b = b'. Ledger indistinguishability requires that  <span class="math">\\mathcal{A}</span>  wins L-IND with probability at most negligibly greater than 1/2. <strong>Transaction non-malleability.</strong> This property requires that no bounded adversary  <span class="math">\\mathcal{A}</span>  can alter any of the data stored within a (valid) pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> . This transaction non-malleability prevents malicious attackers from modifying others' transactions before they are added to the ledger (e.g., by re-targeting the Basecoin public output of a pour transaction).</p>

    <p class="text-gray-300">Transaction non-malleability is formalized by an experiment TR-NM, in which  <span class="math">\\mathcal{A}</span>  adaptively interacts with a DAP scheme oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  and then outputs a pour transaction  <span class="math">\\mathsf{tx}^*</span> . Letting  <span class="math">\\mathcal{T}</span>  denote the set of pour transactions returned by  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span> , and L denote the final ledger,  <span class="math">\\mathcal{A}</span>  wins the game if there exists  <span class="math">\\mathsf{tx} \\in \\mathcal{T}</span> , such that (i)  <span class="math">\\mathsf{tx}^* \\neq \\mathsf{tx}</span> ; (ii)  <span class="math">\\mathsf{tx}^*</span>  reveals a serial number contained in  <span class="math">\\mathsf{tx}</span> ; and (iii) both  <span class="math">\\mathsf{tx}</span>  and  <span class="math">\\mathsf{tx}^*</span>  are valid with respect to the ledger L' containing all transactions preceding  <span class="math">\\mathsf{tx}</span>  on L. In other words,  <span class="math">\\mathcal{A}</span>  wins the game if  <span class="math">\\mathsf{tx}^*</span>  manages to modify some previous pour transaction to spend the same coin in a different way.</p>

    <p class="text-gray-300">Transaction non-malleability requires that  <span class="math">\\mathcal{A}</span>  wins TR-NM with only negligible probability. (Note that  <span class="math">\\mathcal{A}</span>  can of course produce valid pour transactions that are unrelated to those in  <span class="math">\\mathcal{T}</span> ; the condition that  <span class="math">\\mathsf{tx}^*</span>  reveals a serial number of a previously-spent coin captures non-malleability.)</p>

    <p class="text-gray-300"><strong>Balance.</strong> This property requires that no bounded adversary  <span class="math">\\mathcal{A}</span>  can own more money than what he minted or received via payments from others.</p>

    <p class="text-gray-300">Balance is formalized by an experiment BAL, in which  <span class="math">\\mathcal{A}</span>  adaptively interacts with a DAP scheme oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  and then outputs a set of coins  <span class="math">S_{\\mathsf{coin}}</span> . Letting ADDR be set of addresses returned by <strong>CreateAddress</strong> queries (i.e., addresses of &quot;honest&quot; users),  <span class="math">\\mathcal{A}</span>  wins the game if the total value he can spend or has spent (either as coins or Basecoin public outputs) is greater than the value he has minted or received. That is,  <span class="math">\\mathcal{A}</span>  wins if  <span class="math">v_{\\mathsf{Unspent}} + v_{\\mathsf{Basecoin}} + v_{\\mathcal{A} \\to \\mathsf{ADDR}} &gt; v_{\\mathsf{Mint}} + v_{\\mathsf{ADDR} \\to \\mathcal{A}}</span>  where: (i)  <span class="math">v_{\\mathsf{Unspent}}</span>  is the total value of unspent coins in  <span class="math">S_{\\mathsf{coin}}</span> ; (ii)  <span class="math">v_{\\mathsf{Basecoin}}</span>  is the total value of public outputs placed by  <span class="math">\\mathcal{A}</span>  on the ledger; (iii)  <span class="math">v_{\\mathsf{Mint}}</span>  is the total value of payments received by  <span class="math">\\mathcal{A}</span>  from addresses in ADDR; (v)  <span class="math">v_{\\mathcal{A} \\to \\mathsf{ADDR}}</span>  is the total value</p>

    <p class="text-gray-300">of payments sent by  <span class="math">\\mathcal{A}</span>  to addresses in ADDR.</p>

    <p class="text-gray-300">Balance requires that A wins BAL with only negligible probability.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Construction of a decentralized anonymous payment scheme</h2>

    <p class="text-gray-300">We show how to construct a DAP scheme (introduced in Section 3) using zk-SNARKs and other building blocks. Later, in Section 5, we give a concrete instantiation of this construction.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Cryptographic building blocks</h3>

    <p class="text-gray-300">We first introduce notation for the standard cryptographic building blocks that we use. We assume familiarity with the definitions of these building blocks; for more details, see, e.g., [KL07]. Throughout,  <span class="math">\\lambda</span>  denotes the security parameter.</p>

    <p class="text-gray-300">Collision-resistant hashing. We use a collision-resistant hash function CRH:  <span class="math">\\{0,1\\}^* \\to \\{0,1\\}^{O(\\lambda)}</span> .</p>

    <p class="text-gray-300"><strong>Pseudorandom functions.</strong> We use a pseudorandom function family  <span class="math">\\mathsf{PRF} = \\{\\mathsf{PRF}_x \\colon \\{0,1\\}^* \\to \\{0,1\\}^{O(\\lambda)}\\}_x</span>  where x denotes the seed. From  <span class="math">\\mathsf{PRF}_x</span> , we derive three &quot;non-overlapping&quot; pseudorandom functions, chosen arbitrarily as  <span class="math">\\mathsf{PRF}_x^{\\mathrm{addr}}(z) := \\mathsf{PRF}_x(00\\|z)</span> ,  <span class="math">\\mathsf{PRF}_x^{\\mathrm{sn}}(z) := \\mathsf{PRF}_x(01\\|z)</span> ,  <span class="math">\\mathsf{PRF}_x^{\\mathrm{pk}}(z) := \\mathsf{PRF}_x(10\\|z)</span> . Furthermore, we assume that  <span class="math">\\mathsf{PRF}_x^{\\mathrm{sn}}</span>  is also collision resistant, in the sense that it is infeasible to find  <span class="math">(x,z) \\neq (x&#x27;,z&#x27;)</span>  such that  <span class="math">\\mathsf{PRF}_x^{\\mathrm{sn}}(z) = \\mathsf{PRF}_{x&#x27;}^{\\mathrm{sn}}(z&#x27;)</span> .</p>

    <p class="text-gray-300">Statistically-hiding commitments. We use a commitment scheme COMM where the binding property holds computationally, while the hiding property holds statistically. It is denoted  <span class="math">\\{\\mathsf{COMM}_x\\colon \\{0,1\\}^* \\to \\{0,1\\}^{O(\\lambda)}\\}_x</span>  where x denotes the commitment trapdoor. Namely, to reveal a commitment cm to a value z, it suffices to provide z and the trapdoor x; then one can check that  <span class="math">\\mathsf{cm} = \\mathsf{COMM}_x(z)</span> .</p>

    <p class="text-gray-300">One-time strongly-unforgeable digital signatures. We use a digital signature scheme  <span class="math">Sig = (\\mathcal{G}_{sig}, \\mathcal{K}_{sig}, \\mathcal{S}_{sig}, \\mathcal{V}_{sig})</span>  that works as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{G}_{sig}(1^{\\lambda}) \\to pp_{sig}</span> . Given a security parameter  <span class="math">\\lambda</span>  (presented in unary),  <span class="math">\\mathcal{G}_{sig}</span>  samples public parameters  <span class="math">pp_{sig}</span>  for the encryption scheme.</li>
      <li><span class="math">\\mathcal{K}_{sig}(pp_{sig}) \\to (pk_{sig}, sk_{sig})</span> . Given public parameters  <span class="math">pp_{sig}</span> ,  <span class="math">\\mathcal{K}_{sig}</span>  samples a public key and a secret key for a single user.</li>
      <li><span class="math">S_{\\text{sig}}(\\mathsf{sk}_{\\mathsf{sig}}, m) \\to \\sigma</span> . Given a secret key  <span class="math">\\mathsf{sk}_{\\mathsf{sig}}</span>  and a message m,  <span class="math">S_{\\mathsf{sig}}</span>  signs m to obtain a signature  <span class="math">\\sigma</span> .</li>
      <li><span class="math">\\mathcal{V}_{\\text{sig}}(\\mathsf{pk}_{\\mathsf{sig}}, m, \\sigma) \\to b</span> . Given a public key  <span class="math">\\mathsf{pk}_{\\mathsf{sig}}</span> , message m, and signature  <span class="math">\\sigma</span> ,  <span class="math">\\mathcal{V}_{\\mathsf{sig}}</span>  outputs b = 1 if the signature  <span class="math">\\sigma</span>  is valid for message m; else it outputs b = 0.</li>
    </ul>

    <p class="text-gray-300">The signature scheme Sig satisfies the security property of <em>one-time strong unforgeability against chosen-message attacks</em> (SUF-1CMA security).</p>

    <p class="text-gray-300"><strong>Key-private public-key encryption.</strong> We use a public-key encryption scheme  <span class="math">Enc = (\\mathcal{G}_{enc}, \\mathcal{K}_{enc}, \\mathcal{E}_{enc}, \\mathcal{D}_{enc})</span>  that works as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{G}_{enc}(1^{\\lambda}) \\to pp_{enc}</span> . Given a security parameter  <span class="math">\\lambda</span>  (presented in unary),  <span class="math">\\mathcal{G}_{enc}</span>  samples public parameters  <span class="math">pp_{enc}</span>  for the encryption scheme.</li>
      <li><span class="math">\\mathcal{K}_{enc}(pp_{enc}) \\to (pk_{enc}, sk_{enc})</span> . Given public parameters  <span class="math">pp_{enc}</span> ,  <span class="math">\\mathcal{K}_{enc}</span>  samples a public key and a secret key for a single user.</li>
      <li><span class="math">\\mathcal{E}_{enc}(\\mathsf{pk}_{enc}, m) \\to c</span> . Given a public key  <span class="math">\\mathsf{pk}_{enc}</span>  and a message m,  <span class="math">\\mathcal{E}_{enc}</span>  encrypts m to obtain a ciphertext c.</li>
      <li><span class="math">\\mathcal{D}_{\\mathsf{enc}}(\\mathsf{sk}_{\\mathsf{enc}}, c) \\to m</span> . Given a secret key  <span class="math">\\mathsf{sk}_{\\mathsf{enc}}</span>  and a ciphertext c,  <span class="math">\\mathcal{D}_{\\mathsf{enc}}</span>  decrypts c to produce a message m (or  <span class="math">\\bot</span>  if decryption fails).</li>
    </ul>

    <p class="text-gray-300">The encryption scheme Enc satisfies two security properties: (i) ciphertext indistinguishability under chosen-ciphertext attack (IND-CCA security); and (ii) key indistinguishability under chosen-ciphertext</p>

    <p class="text-gray-300">attack (IK-CCA security). While the first property is standard, the second is less known; informally, IK-CCA requires that ciphertexts cannot be linked to the public key used to encrypt them, or to other ciphertexts encrypted with the same public key. For definitions, we refer the reader to [BBDP01].</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 zk-SNARKs for pouring coins</h3>

    <p class="text-gray-300">As outlined in Section 1.3, our construction invokes a zk-SNARK for a specific NP statement, POUR, which we now define. We first recall the context motivating POUR. When a user u pours &quot;old&quot; coins  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{old}}</span>  into new coins  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span> , a corresponding pour transaction</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{tx}_{\\mathsf{Pour}} = (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, *)</span>$</p>

    <p class="text-gray-300">is generated. In our construction, we need to provide evidence in &quot;*&quot; that various conditions were respected by the pour operation. Concretely,  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  should demonstrate that (i) u owns  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span> ; (ii) coin commitments for  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span>  appear somewhere on the ledger; (iii) the revealed serial numbers  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}</span>  are of  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span> ; (iv) the revealed coin commitments  <span class="math">\\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}</span>  are of  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}</span> ; (v) balance is preserved. Our construction achieves this by including a  <span class="math">\\mathsf{zk}</span> -SNARK proof  <span class="math">\\pi_{\\mathsf{POUR}}</span>  for the statement POUR which checks the above invariants (as well as others needed for non-malleability).</p>

    <p class="text-gray-300">The statement POUR. Concretely, the NP statement POUR is defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Instances are of the form  <span class="math">x = (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, h_{\\mathsf{Sig}}, h_1, h_2)</span> . Thus, an instance x specifies a root rt for a CRH-based Merkle tree (over the list of commitments so far), the two serial numbers of the consumed coins, two coin commitments for the two new coins, a public value, and fields  <span class="math">h_{\\mathsf{Sig}}, h_1, h_2</span>  used for non-malleability.</li>
      <li>Witnesses are of the form  <span class="math">a=(\\mathsf{path}_1,\\mathsf{path}_2,\\mathbf{c}_1^{\\mathsf{old}},\\mathbf{c}_2^{\\mathsf{old}},\\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{old}},\\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}},\\mathbf{c}_1^{\\mathsf{new}},\\mathbf{c}_2^{\\mathsf{new}})</span>  where, for each  <span class="math">i\\in\\{1,2\\}</span> :</li>
    </ul>

    <pre><code class="language-text">\\begin{split} \\mathbf{c}_i^{\\text{old}} &amp;= (\\text{addr}_{\\text{pk},i}^{\\text{old}}, v_i^{\\text{old}}, \\rho_i^{\\text{old}}, r_i^{\\text{old}}, s_i^{\\text{old}}, \\text{cm}_i^{\\text{old}}) \\ , \\\\ \\mathbf{c}_i^{\\text{new}} &amp;= (\\text{addr}_{\\text{pk},i}^{\\text{new}}, v_i^{\\text{new}}, \\rho_i^{\\text{new}}, r_i^{\\text{new}}, s_i^{\\text{new}}, \\text{cm}_i^{\\text{new}}) \\ \\text{for the same cm}_i^{\\text{new}} \\ \\text{as in } x, \\\\ \\text{addr}_{\\text{pk},i}^{\\text{old}} &amp;= (a_{\\text{pk},i}^{\\text{old}}, \\text{pk}_{\\text{enc},i}^{\\text{old}}) \\ , \\\\ \\text{addr}_{\\text{pk},i}^{\\text{new}} &amp;= (a_{\\text{pk},i}^{\\text{new}}, \\text{pk}_{\\text{enc},i}^{\\text{new}}) \\ , \\\\ \\text{addr}_{\\text{sk},i}^{\\text{old}} &amp;= (a_{\\text{sk},i}^{\\text{old}}, \\text{sk}_{\\text{enc},i}^{\\text{old}}) \\ . \\end{split}
</code></pre>

    <p class="text-gray-300">Thus, a witness a specifies authentication paths for the two new coin commitments, the entirety of coin information about both the old and new coins, and address secret keys for the old coins.</p>

    <p class="text-gray-300">Given a POUR instance x, a witness a is valid for x if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">i \\in \\{1, 2\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) The coin commitment  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  of  <span class="math">\\mathbf{c}_i^{\\mathsf{old}}</span>  appears on the ledger, i.e.,  <span class="math">\\mathsf{path}_i</span>  is a valid authentication path for leaf  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  with respect to root rt, in a CRH-based Merkle tree.</li>
      <li>(b) The address secret key  <span class="math">a_{\\mathsf{sk},i}^{\\mathsf{old}}</span>  matches the address public key of  <span class="math">\\mathbf{c}_{i}^{\\mathsf{old}}</span> , i.e.,  <span class="math">a_{\\mathsf{pk},i}^{\\mathsf{old}} = \\mathsf{PRF}_{a_{\\mathsf{sk},i}^{\\mathsf{old}}}^{\\mathsf{addr}}(0)</span> .</li>
      <li>(c) The serial number  <span class="math">\\mathsf{sn}_i^\\mathsf{old}</span>  of  <span class="math">\\mathbf{c}_i^\\mathsf{old}</span>  is computed correctly, i.e.,  <span class="math">\\mathsf{sn}_i^\\mathsf{old} = \\mathsf{PRF}_{a_i^\\mathsf{old}}^\\mathsf{sn}(\\rho_i^\\mathsf{old})</span> .</li>
      <li><span class="math">\\text{(d) The coin } \\mathbf{c}_i^{\\mathsf{old}} \\text{ is well-formed, i.e., } \\mathbf{cm}_i^{\\mathsf{old}} = \\mathsf{COMM}_{s_i^{\\mathsf{old}}}(\\mathsf{COMM}_{r_i^{\\mathsf{old}}}(a_{\\mathsf{pk},i}^{\\mathsf{old}} \\| \\rho_i^{\\mathsf{old}}) \\| v_i^{\\mathsf{old}}).</span></li>
      <li>(e) The coin  <span class="math">\\mathbf{c}_i^{\\mathsf{new}}</span>  is well-formed, i.e.,  <span class="math">\\mathsf{cm}_i^{\\mathsf{new}} = \\mathsf{COMM}_{s_i^{\\mathsf{new}}}(\\mathsf{COMM}_{r_i^{\\mathsf{new}}}(a_{\\mathsf{pk},i}^{\\mathsf{new}} \\| \\rho_i^{\\mathsf{new}}) \\| v_i^{\\mathsf{new}})</span></li>
      <li>(f) The address secret key  <span class="math">a_{\\mathsf{sk},i}^{\\mathsf{old}}</span>  ties  <span class="math">h_{\\mathsf{Sig}}</span>  to  <span class="math">h_i</span> , i.e.,  <span class="math">h_i = \\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk},i}^{\\mathsf{old}}}(i\\|h_{\\mathsf{Sig}})</span> .</li>
    </ul></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Balance is preserved: v new <sup>1</sup> + v new <sup>2</sup> + vpub = v old <sup>1</sup> + v old 2 (with v old 1 , vold <sup>2</sup> &ge; 0 and v old <sup>1</sup> + v old <sup>2</sup> &le; vmax).</li>
    </ol>

    <p class="text-gray-300">Recall that in this paper zk-SNARKs are relative to the language of arithmetic circuit satisfiability (see Section <a href="#page-9-1">2)</a>; thus, we express the checks in POUR via an arithmetic circuit, denoted CPOUR. In particular, the depth dtree of the Merkle tree needs to be hardcoded in CPOUR, and we thus make it a parameter of our construction (see below); the maximum number of supported coins is then 2dtree .</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Algorithm constructions</h3>

    <p class="text-gray-300">We proceed to describe the construction of the DAP scheme &Pi; = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) whose intuition was given in Section <a href="#page-4-1">1.3.</a> Figure <a href="#page-20-0">2</a> gives the pseudocode for each one of the six algorithms in &Pi;, in terms of the building blocks introduced in Section <a href="#page-17-1">4.1</a> and Section <a href="#page-18-0">4.2.</a> In the construction, we hardcode two quantities: the maximum value of a coin, vmax, and the depth of the Merkle tree, dtree.</p>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 Completeness and security</h3>

    <p class="text-gray-300">Our main theorem states that the above construction is indeed a DAP scheme.</p>

    <p class="text-gray-300">Theorem 4.1. The tuple &Pi; = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive), as defined in Section <a href="#page-19-0">4.3,</a> is a complete (cf. Definition <a href="#page-15-2">3.1)</a> and secure (cf. Definition <a href="#page-15-3">3.2)</a> DAP scheme.</p>

    <p class="text-gray-300">We provide a proof of Theorem <a href="#page-19-3">4.1</a> in Appendix <a href="#page-43-0">D.</a> We note that our construction can be modified to yield statistical (i.e., everlasting) anonymity; see the discussion in Section <a href="#page-32-1">8.1.</a></p>

    <p class="text-gray-300">Remark (trusted setup). Security of &Pi; relies on a trusted party running Setup to generate the public parameters (once and for all). This trust is needed for the transaction non-malleability and balance properties but not for ledger indistinguishability. Thus, even if a powerful espionage agency were to corrupt the setup, anonymity will still be maintained. Moreover, if one wishes to mitigate the trust requirements of this step, one can conduct the computation of Setup using secure multiparty computation techniques; we leave this to future work.</p>

    <p class="text-gray-300">Remark (use of pp). According to the definition of a DAP scheme (see Section <a href="#page-12-0">3)</a>, the public parameters pp are given as input to each one of the six algorithms; this is also how we presented our construction in Figure <a href="#page-20-0">2.</a> However, in our construction, the public parameters pp equal a tuple (pkPOUR, vkPOUR, ppenc, ppsig), and not every algorithm needs every component of pp. Concretely, CreateAddress only needs ppenc; Mint only the security parameter &lambda;; Pour only pkPOUR and ppsig; VerifyTransaction only vkPOUR; and Receive only &lambda;. In particular, since we rely on zk-SNARKs to prove/verify POUR, pkPOUR is of constant, but large, size, and is only required by Pour. All other components of pp are of small constant size.</p>

    <p class="text-gray-300">Remark (checking received coins in ledger). The algorithm Receive tests whether the serial number of a received coin already appears on the ledger, in order not to output coins that the user has already received and spent by himself. Other users are, in any case, unable to spend coins addressed to this user.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Zerocash</h2>

    <p class="text-gray-300">We describe a concrete instantiation of a DAP scheme; this instantiation forms the basis of Zerocash. Later, in Section <a href="#page-25-0">6,</a> we discuss how Zerocash can be integrated with existing ledger-based currencies.</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Setup</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS: security parameter  <span class="math">\\lambda</span></li>
      <li>OUTPUTS: public parameters pp</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Construct  <span class="math">C_{POUR}</span>  for POUR at security  <span class="math">\\lambda</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">(\\mathsf{pk}_{\\mathsf{POUR}}, \\mathsf{vk}_{\\mathsf{POUR}}) := \\mathsf{KeyGen}(1^{\\lambda}, C_{\\mathsf{POUR}}).</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">pp_{enc} := \\mathcal{G}_{enc}(1^{\\lambda})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">pp_{sig} := \\mathcal{G}_{sig}(1^{\\lambda})</span> .</li>
    </ol></li>
      <li><span class="math">5. \\ \\operatorname{Set} \\ \\mathsf{pp} := (\\mathsf{pk}_{\\mathtt{POUR}}, \\mathsf{vk}_{\\mathtt{POUR}}, \\mathsf{pp}_{\\mathsf{enc}}, \\mathsf{pp}_{\\mathsf{sig}}).</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output pp.</li>
    </ol></li>
    </ul>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">CreateAddress</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS: public parameters pp</li>
      <li>OUTPUTS: address key pair (addr<sub>pk</sub>, addr<sub>sk</sub>)</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">(pk_{enc}, sk_{enc}) := \\mathcal{K}_{enc}(pp_{enc})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample a  <span class="math">PRF^{addr}</span>  seed  <span class="math">a_{sk}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">a_{pk} = \\mathsf{PRF}^{\\mathrm{addr}}_{a_{sk}}(0)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">\\operatorname{\\mathsf{addr}}_{\\mathsf{pk}} := (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}}).</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">addr_{sk} := (a_{sk}, sk_{enc})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output (addr<sub>pk</sub>, addr<sub>sk</sub>).</li>
    </ol></li>
    </ul>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Mint</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>public parameters pp</li>
      <li>coin value  <span class="math">v \\in \\{0, 1, \\dots, v_{\\mathsf{max}}\\}</span></li>
      <li>destination address public key addr<sub>pk</sub></li>
    </ul></li>
      <li>OUTPUTS: coin c and mint transaction  <span class="math">tx_{Mint}</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">addr_{pk}</span>  as  <span class="math">(a_{pk}, pk_{enc})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample a  <span class="math">\\mathsf{PRF}^{\\mathsf{sn}}</span>  seed  <span class="math">\\rho</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample two COMM trapdoors r, s.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">k := \\mathsf{COMM}_r(a_{\\mathsf{pk}} || \\rho)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute cm :=  <span class="math">COMM_s(v||k)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">\\mathbf{c} := (\\mathsf{addr}_{\\mathsf{pk}}, v, \\rho, r, s, \\mathsf{cm}).</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">tx_{Mint} := (cm, v, *)</span> , where * := (k, s).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\mathbf{c}</span>  and  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span> .</li>
    </ol></li>
    </ul>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6"><strong>VerifyTransaction</strong></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>public parameters pp</li>
      <li>a (mint or pour) transaction tx</li>
      <li>the current ledger L</li>
    </ul></li>
      <li>OUTPUTS: bit b, equals 1 iff the transaction is valid</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If given a mint transaction  <span class="math">tx = tx_{Mint}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Parse  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span>  as  <span class="math">(\\mathsf{cm}, v, *)</span> , and * as (k, s).</li>
      <li>(b) Set  <span class="math">cm&#x27; := COMM_s(v||k)</span> .</li>
      <li>(c) Output b := 1 if cm = cm', else output b := 0.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If given a pour transaction  <span class="math">tx = tx_{Pour}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Parse  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  as  <span class="math">(\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, *)</span> , and * as  <span class="math">(\\mathsf{pk}_{\\mathsf{sig}}, h_1, h_2, \\pi_{\\mathtt{POUR}}, \\mathbf{C}_1, \\mathbf{C}_2, \\sigma)</span> .</li>
      <li>(b) If  <span class="math">\\operatorname{sn_1^{old}}</span>  or  <span class="math">\\operatorname{sn_2^{old}}</span>  appears on L (or  <span class="math">\\operatorname{sn_1^{old}} = \\operatorname{sn_2^{old}}</span> ), output b := 0.</li>
      <li>(c) If the Merkle root rt does not appear on L, output b := 0.</li>
      <li>(d) Compute  <span class="math">h_{Sig} := CRH(pk_{sig})</span> .</li>
      <li>(e) Set  <span class="math">x := (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, h_{\\mathsf{Sig}}, h_1, h_2).</span></li>
      <li>(f) Set  <span class="math">m := (x, \\pi_{POUR}, info, \\mathbf{C}_1, \\mathbf{C}_2)</span> .</li>
      <li>(g) Compute  <span class="math">b := \\mathcal{V}_{sig}(\\mathsf{pk}_{sig}, m, \\sigma)</span> .</li>
      <li>(h) Compute  <span class="math">b&#x27; := \\mathsf{Verify}(\\mathsf{vk}_{\\mathsf{POUR}}, x, \\pi_{\\mathsf{POUR}})</span> , and output  <span class="math">b \\wedge b&#x27;</span> .</li>
    </ul></li>
    </ul>

    <h4 id="sec-misc-11" class="text-lg font-semibold mt-6">Pour</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>public parameters pp</li>
      <li>the Merkle root rt</li>
      <li>old coins  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span></li>
      <li>old addresses secret keys addr<sub>sk,1</sub>, addr<sub>sk,2</sub></li>
      <li>path  <span class="math">path_1</span>  from commitment  <span class="math">cm(c_1^{old})</span>  to root rt, path  <span class="math">\\mathsf{path}_2</span>  from commitment  <span class="math">\\mathsf{cm}(\\mathbf{c}_2^{\\mathsf{old}})</span>  to root  <span class="math">\\mathsf{rt}</span></li>
      <li>new values  <span class="math">v_1^{\\text{new}}, v_2^{\\text{new}}</span></li>
      <li>new addresses public keys  <span class="math">addr_{pk,1}^{new}</span> ,  <span class="math">addr_{pk,2}^{new}</span></li>
      <li>public value v<sub>pub</sub></li>
      <li>transaction string info</li>
    </ul></li>
      <li><span class="math">\\bullet</span>  OUTPUTS: new coins  <span class="math">{\\bf c}_1^{\\sf new}, {\\bf c}_2^{\\sf new}</span>  and pour transaction  <span class="math">{\\sf tx}_{\\sf Pour}</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">i \\in \\{1, 2\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">(a) Parse  <span class="math">\\mathbf{c}_i^{\\text{old}}</span>  as  <span class="math">(\\text{addr}_{\\text{pk},i}^{\\text{old}}, v_i^{\\text{old}}, \\rho_i^{\\text{old}}, r_i^{\\text{old}}, s_i^{\\text{old}}, \\text{cm}_i^{\\text{old}})</span> .</p></li>
      <li><p class="text-gray-300">(b) Parse  <span class="math">\\operatorname{\\mathsf{addr}}^{\\operatorname{\\mathsf{old}}}_{\\operatorname{\\mathsf{sk}},i}</span>  as  <span class="math">(a^{\\operatorname{\\mathsf{old}}}_{\\operatorname{\\mathsf{sk}},i},\\operatorname{\\mathsf{sk}}^{\\operatorname{\\mathsf{old}}}_{\\operatorname{\\mathsf{enc}},i})</span> .</p></li>
      <li><p class="text-gray-300">(c) Compute  <span class="math">\\mathsf{sn}_i^\\mathsf{old} := \\mathsf{PRF}^\\mathsf{sn}_{a^\\mathsf{old}} \\left( \\rho_i^\\mathsf{old} \\right)</span></p></li>
      <li><p class="text-gray-300">(d) Parse  <span class="math">\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{new}}</span>  as  <span class="math">(a_{\\mathsf{pk},i}^{\\mathsf{new}},\\mathsf{pk}_{\\mathsf{enc},i}^{\\mathsf{new}})</span> .</p></li>
      <li><p class="text-gray-300">(e) Randomly sample a PRF<sup>sn</sup> seed  <span class="math">\\rho_i^{\\text{new}}</span> .</p></li>
      <li><p class="text-gray-300">(f) Randomly sample two COMM trapdoors  <span class="math">r_i^{\\text{new}}</span> ,  <span class="math">s_i^{\\text{new}}</span> .</p></li>
      <li><p class="text-gray-300">(g) Compute  <span class="math">k_i^{\\text{new}} := \\mathsf{COMM}_{r_i^{\\text{new}}}(a_{\\mathsf{pk},i}^{\\text{new}} | \\rho_i^{\\text{new}}).</span> (h) Compute  <span class="math">\\mathsf{cm}_i^{\\text{new}} := \\mathsf{COMM}_{s_i^{\\text{new}}}(v_i^{\\text{new}} | k_i^{\\text{new}}).</span> (i) Set  <span class="math">\\mathbf{c}_i^{\\text{new}} := (\\mathsf{addr}_{\\mathsf{pk},i}^{\\text{new}}, v_i^{\\text{new}}, \\rho_i^{\\text{new}}, r_i^{\\text{new}}, s_i^{\\text{new}}, \\mathsf{cm}_i^{\\text{new}}).</span> (j) Set  <span class="math">\\mathbf{C}_i := \\mathcal{E}_{\\mathsf{enc}}(\\mathsf{pk}_{\\mathsf{enc},i}^{\\text{new}}, (v_i^{\\text{new}}, \\rho_i^{\\text{new}}, r_i^{\\text{new}}, s_i^{\\text{new}}).</span></p></li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate  <span class="math">(pk_{sig}, sk_{sig}) := \\mathcal{K}_{sig}(pp_{sig})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">h_{Sig} := CRH(pk_{sig})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">h_1 := \\mathsf{PRF}^{\\mathsf{pk}}_{a^{\\mathsf{old}}}(1 \\| h_{\\mathsf{Sig}})</span>  and  <span class="math">h_2 := \\mathsf{PRF}^{\\mathsf{pk}}_{a^{\\mathsf{old}}}(2 \\| h_{\\mathsf{Sig}})</span></li>
    </ol></li>
      <li><span class="math">\\begin{array}{l} 5. \\hspace{0.1cm} \\mathrm{Set} \\hspace{0.1cm} x := (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, h_{\\mathsf{Sig}}, h_1, h_2). \\\\ 6. \\hspace{0.1cm} \\mathrm{Set} \\hspace{0.1cm} a := (\\mathsf{path}_1, \\mathsf{path}_2, \\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}}, \\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}). \\end{array}</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\pi_{\\mathtt{POUR}} := \\mathsf{Prove}(\\mathsf{pk}_{\\mathtt{POUR}}, x, a)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">m := (x, \\pi_{POUR}, info, \\mathbf{C}_1, \\mathbf{C}_2)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\sigma := \\mathcal{S}_{sig}(sk_{sig}, m)</span> .</li>
    </ol></li>
      <li><span class="math">10. \\ \\, \\mathbf{Set} \\ \\, \\mathsf{tx}_{\\mathsf{Pour}} := (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, \\ast), \\, \\mathsf{where}</span>  <span class="math">* := (\\mathsf{pk}_{\\mathsf{sig}}, h_1, h_2, \\pi_{\\mathsf{POUR}}, \\mathbf{C}_1, \\mathbf{C}_2, \\sigma).</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}</span>  and  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> .</li>
    </ol></li>
    </ul>

    <h4 id="sec-misc-12" class="text-lg font-semibold mt-6">Receive</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>public parameters pp</li>
      <li>recipient address key pair (addr<sub>pk</sub>, addr<sub>sk</sub>)</li>
      <li>the current ledger L</li>
    </ul></li>
      <li>OUTPUTS: set of received coins</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">addr_{pk}</span>  as  <span class="math">(a_{pk}, pk_{enc})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">addr_{sk}</span>  as  <span class="math">(a_{sk}, sk_{enc})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each Pour transaction  <span class="math">tx_{Pour}</span>  on the ledger:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Parse  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  as  <span class="math">(\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, *)</span> , and * as  <span class="math">(pk_{sig}, h_1, h_2, \\pi_{POUR}, \\mathbf{C}_1, \\mathbf{C}_2, \\sigma)</span> .</li>
      <li>(b) For each  <span class="math">i \\in \\{1, 2\\}</span> :    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. Compute  <span class="math">(v_i, \\rho_i, r_i, s_i) := \\mathcal{D}_{enc}(\\mathsf{sk}_{enc}, \\mathbf{C}_i)</span> .</li>
      <li>ii. If  <span class="math">\\mathcal{D}_{enc}</span> 's output is not  <span class="math">\\perp</span> , verify that:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathsf{cm}_i^{\\mathsf{new}} \\text{ equals } \\mathsf{COMM}_{s_i}(v_i \\| \\mathsf{COMM}_{r_i}(a_{\\mathsf{pk}} \\| \\rho_i));</span></li>
      <li><span class="math">\\operatorname{sn}_i := \\operatorname{PRF}_{a_{\\operatorname{sk}}}^{\\operatorname{sn}}(\\rho_i)</span>  does not appear on L.</li>
    </ul></li>
      <li>iii. If both checks succeed, output  <span class="math">\\mathbf{c}_i := (\\mathsf{addr}_{\\mathsf{pk}}, v_i, \\rho_i, r_i, s_i, \\mathsf{cm}_i^{\\mathsf{new}}).</span></li>
    </ul></li>
    </ul></li>
    </ul>

    <h4 id="sec-misc-13" class="text-lg font-semibold mt-6">Instantiation of building blocks</h4>

    <p class="text-gray-300">We instantiate the DAP scheme construction from Section 4 (see Figure 2), aiming at a level of security of 128 bits. Doing so requires concrete choices, described next.</p>

    <p class="text-gray-300">CRH, PRF, COMM from SHA256. Let  <span class="math">\\mathcal{H}</span>  be the SHA256 compression function, which maps a 512-bit input to a 256-bit output. We mostly rely on  <span class="math">\\mathcal{H}</span> , rather than the &quot;full&quot; hash, since this suffices for our fixed-size single-block inputs, and it simplifies the construction of  <span class="math">C_{POUR}</span>  (see Section 5.2). We instantiate CRH, PRF, COMM via  <span class="math">\\mathcal{H}</span>  (under suitable assumptions on  <span class="math">\\mathcal{H}</span> ).</p>

    <p class="text-gray-300">First, we instantiate the collision-resistant function CRH as  <span class="math">\\mathcal{H}(z)</span>  for  <span class="math">z \\in \\{0,1\\}^{512}</span> ; this function compresses &quot;two-to-one&quot;, so it can be used to construct binary Merkle trees. 14</p>

    <p class="text-gray-300">Next, we instantiate the pseudorandom function  <span class="math">\\mathsf{PRF}_x(z)</span>  as  <span class="math">\\mathcal{H}(x||z)</span> , with  <span class="math">x \\in \\{0,1\\}^{256}</span>  as the seed, and  <span class="math">z \\in \\{0,1\\}^{256}</span>  as the input.<sup>15</sup> Thus, the derived functions are:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PRF}^{\\mathrm{addr}}_x(z) := \\mathcal{H}(x\\|00\\|z)\\,, \\quad \\mathsf{PRF}^{\\mathrm{sn}}_x(z) := \\mathcal{H}(x\\|01\\|z)\\,, \\quad \\mathsf{PRF}^{\\mathrm{pk}}_x(z) := \\mathcal{H}(x\\|10\\|z)\\,,</span>$</p>

    <p class="text-gray-300">with  <span class="math">x \\in \\{0, 1\\}^{256}</span>  and  <span class="math">z \\in \\{0, 1\\}^{254}</span> .</p>

    <p class="text-gray-300">As for the commitment scheme COMM, we only use it in the following pattern:</p>

    <p class="text-gray-300"><span class="math">$k := \\mathsf{COMM}_r(a_{\\mathsf{pk}} \\| \\rho) \\enspace ,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{cm} := \\mathsf{COMM}_s(v \\| k) \\enspace .</span>$</p>

    <p class="text-gray-300">Due to our instantiation of PRF,  <span class="math">a_{pk}</span>  is 256 bits. So we can set  <span class="math">\\rho</span>  also to 256 bits and r to 256 + 128 = 384 bits; then we can compute</p>

    <p class="text-gray-300"><span class="math">$k := \\mathsf{COMM}_r(a_{\\mathsf{pk}} \\| \\rho)</span>$
as  <span class="math">\\mathcal{H}(r \\| [\\mathcal{H}(a_{\\mathsf{pk}} \\| \\rho)]_{128})</span> .</p>

    <p class="text-gray-300">Above,  <span class="math">[\\cdot]_{128}</span>  denotes that we are truncating the 256-bit string to 128 bits (say, by dropping leastsignificant bits, as in our implementation). Heuristically, for any string  <span class="math">z \\in \\{0,1\\}^{128}</span> , the distribution induced by  <span class="math">\\mathcal{H}(r||z)</span>  is  <span class="math">2^{-128}</span> -close to uniform, and this forms the basis of the statistically-hiding property. For computing cm, we set coin values to be 64-bit integers (so that, in particular,  <span class="math">v_{\\text{max}} = 2^{64} - 1</span>  in our implementation), and then compute</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{cm} := \\mathsf{COMM}_s(v \\| k) \\quad \\text{as} \\quad \\mathcal{H}(k \\| 0^{192} \\| v) \\ .</span>$</p>

    <p class="text-gray-300">Noticeably, above we are <em>ignoring</em> the commitment randomness s. The reason is that we already know that k, being the output of a statistically-hiding commitment, can serve as randomness for the next commitment scheme.</p>

    <p class="text-gray-300">Instantiating the NP statement POUR. The above choices imply a concrete instantiation of the NP statement POUR (see Section 4.2). Specifically, in our implementation, POUR checks that the following holds, for each  <span class="math">i \\in \\{1, 2\\}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>path<sub>i</sub> is an authentication path for leaf cm<sub>i</sub><sup>old</sup> with respect to root rt, in a CRH-based Merkle tree;</li>
      <li><span class="math">\\bullet \\ a_{\\mathsf{pk},i}^{\\mathsf{old}} = \\mathcal{H}(a_{\\mathsf{sk},i}^{\\mathsf{old}} \\| 0^{256});</span></li>
      <li><span class="math">$\\begin{split} &amp; \\bullet \\quad \\text{sn}_i^{\\text{old}} = \\mathcal{H}(a_{\\text{sk},i}^{\\text{old}} \\| 01 \\| [\\rho_i^{\\text{old}}]_{254}); \\\\ &amp; \\bullet \\quad \\text{cm}_i^{\\text{old}} = \\mathcal{H}(\\mathcal{H}(r_i^{\\text{old}} \\| [\\mathcal{H}(a_{\\text{pk},i}^{\\text{old}} \\| \\rho_i^{\\text{old}})]_{128}) \\| 0^{192} \\| v_i^{\\text{old}}); \\end{split}</span>$</li>
    </ul>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{14}&lt;/sup&gt;</span> A single exception: we still compute  <span class="math">h_{\\mathsf{Sig}}</span>  according to the full hash SHA256, rather than its compression function, because there is no need for this computation to be verified by  <span class="math">C_{\\mathtt{POUR}}</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;15</sup>This assumption is reminiscent of previous works analyzing the security of hash-based constructions (e.g., [Bel06]). However in this work we assume that a portion of the compression function is the seed for the pseudorandom function, rather than using the chaining variable as in [Bel06].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ \\operatorname{cm}_i^{\\mathsf{new}} = \\mathcal{H}(\\mathcal{H}(r_i^{\\mathsf{new}} \\| [\\mathcal{H}(a_{\\mathsf{pk},i}^{\\mathsf{new}} \\| \\rho_i^{\\mathsf{new}})]_{128}) \\| 0^{192} \\| v_i^{\\mathsf{new}}); \\ \\operatorname{and}</span></li>
      <li><span class="math">h_i = \\mathcal{H}(a_{\\mathsf{sk},i}^{\\mathsf{old}} || 10 || b_i || [h_{\\mathsf{Sig}}]_{253})</span>  where  <span class="math">b_1 := 0</span>  and  <span class="math">b_2 := 1</span> .</li>
    </ul>

    <p class="text-gray-300">Moreover, POUR checks that  <span class="math">v_1^{\\mathsf{new}} + v_2^{\\mathsf{new}} + v_{\\mathsf{pub}} = v_1^{\\mathsf{old}} + v_2^{\\mathsf{old}}</span> , with  <span class="math">v_1^{\\mathsf{old}}, v_2^{\\mathsf{old}} \\geq 0</span>  and  <span class="math">v_1^{\\mathsf{old}} + v_2^{\\mathsf{old}} &lt; 2^{64}</span> . Finally, as mentioned, in order for  <span class="math">C_{\\mathsf{POUR}}</span>  to be well-defined, we need to fix a Merkle-tree depth  <span class="math">d_{\\mathsf{tree}}</span> . In our implementation, we fix  <span class="math">d_{\\mathsf{tree}} = 64</span> , and thus support up to  <span class="math">2^{64}</span>  coins.</p>

    <p class="text-gray-300">Instantiating Sig. For the signature scheme Sig, we use ECDSA to retain consistency and compatibility with the existing bitcoind source code. However, standard ECDSA is malleable: both (r, s) and (r, -s) verify as valid signatures. We use a non-malleable variant, where s is restricted to the &quot;lower half&quot; of field elements. While we are not aware of a formal SUF-1CMA proof for this variant, its use is consistent with proposals to resolve Bitcoin transaction malleability [Wui14]. <sup>16</sup></p>

    <p class="text-gray-300"><strong>Instantiating Enc.</strong> For the encryption scheme Enc, we use the key-private Elliptic-Curve Integrated Encryption Scheme (ECIES) [Cer00]; it is one of the few standardized key-private encryption schemes with available implementations.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Arithmetic circuit for pouring coins</h3>

    <p class="text-gray-300">Our DAP scheme construction from Section 4 (see Figure 2) also requires zk-SNARKs relative to the NP statement POUR. These are obtained by invoking a zk-SNARK for arithmetic circuit satisfiability (see Section 2.4) on an arithmetic circuit  <span class="math">C_{\\text{POUR}}</span> , which verifies the NP statement POUR. In our instantiation, we rely on the implementation of [BCTV14] for the basic zk-SNARK (see Section 2.4), and apply it to the circuit  <span class="math">C_{\\text{POUR}}</span>  whose construction is described next.</p>

      <h4 id="sec-5.2.1" class="text-lg font-semibold mt-6">5.2.1 An arithmetic circuit for verifying SHA256's compression function</h4>

    <p class="text-gray-300">The vast majority of the &quot;verification work&quot; in POUR is verifying computations of  <span class="math">\\mathcal{H}</span> , the compression function of SHA256 (see Section 5.1). Thus, we begin by discussing our construction of an arithmetic circuit  <span class="math">C_{\\mathcal{H}}</span>  for verifying SHA256 computations. Later, in Section 5.2.2, we discuss the construction of  <span class="math">C_{\\text{POUR}}</span> , given the circuit  <span class="math">C_{\\mathcal{H}}</span> .</p>

    <p class="text-gray-300">We wish to construct an arithmetic circuit  <span class="math">C_{\\mathcal{H}}</span>  such that, for every 256-bit digest h and 512-bit input z,  <span class="math">(h, z) \\in \\mathcal{R}_{C_{\\mathcal{H}}}</span>  if and only if  <span class="math">h = \\mathcal{H}(z)</span> . Naturally, our goal is to minimize the size of  <span class="math">C_{\\mathcal{H}}</span> . Our high-level strategy is to construct  <span class="math">C_{\\mathcal{H}}</span> , piece by piece, by closely following the SHA256 official specification [Nat12]. For each subcomputation of SHA256, we use nondeterminism and field operations to verify the subcomputation using as few gates as possible.</p>

    <p class="text-gray-300">Overview of SHA256's compression function. The primitive unit in SHA256 is a 32-bit word. All subcomputations are simple word operations: three bitwise operations (and, or, xor), shift-right, rotate-right, and addition modulo  <span class="math">2^{32}</span> . The compression function internally has a state of 8 words, initialized to a fixed value, and then transformed in 64 successive rounds by following the 64-word message schedule (deduced from the input z). The 256-bit output is the concatenation of the 8 words of the final state.</p>

    <p class="text-gray-300"><strong>Representing a state.</strong> We find that, for each word operation (except for addition modulo  <span class="math">2^{32}</span> ), it is more efficient to verify the operation when its inputs are represented as separate wires, each carrying a bit. Thus,  <span class="math">C_{\\mathcal{H}}</span>  maintains the 8-word state as 256 individual wires, and the 64-word message schedule as  <span class="math">64 \\cdot 32</span>  wires.</p>

    <p class="text-gray-300"><strong>Addition modulo 32.</strong> To verify addition modulo  <span class="math">2^{32}</span>  we use techniques employed in previous work [PGHR13, BCG<sup>+</sup>13, BCTV14]. Given two words A and B, we compute  <span class="math">\\alpha := \\sum_{i=0}^{31} 2^i (A_i + B_i)</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;16</sup>In practice, one might replace this ECDSA variant with an EC-Schnorr signature satisfying SUF-1CMA security with proper encoding of EC group elements; the performance would be similar.</p>

    <p class="text-gray-300">Because  <span class="math">\\mathbb{F}</span>  has characteristic larger than  <span class="math">2^{33}</span> , there is no wrap around; thus, field addition coincides with integer addition. We then make a non-deterministic guess for the 33 bits  <span class="math">\\alpha_i</span>  of  <span class="math">\\alpha</span>  (including carry), and enforce consistency by requiring that  <span class="math">\\alpha = \\sum_{i=0}^{32} 2^i \\alpha_i</span> . To ensure that each  <span class="math">\\alpha_i \\in \\{0,1\\}</span> , we use a 33-gate subcircuit computing  <span class="math">\\alpha_i(\\alpha_i - 1)</span> , all of which must be 0 for the subcircuit to be satisfiable. Overall, verifying addition modulo  <span class="math">2^{32}</span>  only requires 34 gates. This approach extends in a straightforward way to summation of more than two terms.</p>

    <p class="text-gray-300">Verifying the SHA256 message schedule. The first 16 words  <span class="math">W_i</span>  of the message schedule are the 16 words of the 512-bit input z. The remaining 48 words are computed as  <span class="math">W_t := \\sigma_1(W_{t-2}) + W_{t-7} + \\sigma_0(W_{t-15}) + W_{t-16}</span> , where  <span class="math">\\sigma_0(W) := \\mathsf{rotr}_7(W) \\oplus \\mathsf{rotr}_{18}(W) \\oplus \\mathsf{shr}_3(W)</span>  and  <span class="math">\\sigma_1</span>  has the same structure but different rotation and shift constants.</p>

    <p class="text-gray-300">The rotation and shift amounts are constants, so rotates and shifts can be achieved by suitable wiring to previously computed bits (or the constant 0 for high-order bits in shr). Thus, since the XOR of 3 bits can be computed using 2 gates, both  <span class="math">\\sigma_0</span>  and  <span class="math">\\sigma_1</span>  can be computed in 64 gates. We then compute (or more precisely, guess and verify) the addition modulo  <span class="math">2^{32}</span>  of the four terms.</p>

    <p class="text-gray-300">Verifying the SHA256 round function. The round function modifies the 8-word state by changing two of its words and then permuting the 8-word result.</p>

    <p class="text-gray-300">Each of the two modified words is a sum modulo  <span class="math">2^{32}</span>  of (i) round-specific constant words  <span class="math">K_t</span> ; (ii) message schedule words  <span class="math">W_t</span> ; and (iii) words obtained by applying simple functions to state words. Two of those functions are bitwise majority (Maj <span class="math">(A, B, C)_i = 0</span>  if  <span class="math">A_i + B_i + C_i \\le 1</span>  else 1) and bitwise choice (Ch <span class="math">(A, B, C)_i = B_i</span>  if  <span class="math">A_i = 1</span> , else  <span class="math">C_i</span> ). We verify correct computation of Maj using 2 gates per output bit, and Ch with 1.</p>

    <p class="text-gray-300">Then, instead of copying 6 unchanged state words to obtain the permuted result, we make the permutation implicit in the circuit's wiring, by using output wires of previous sub-computations (sometimes reaching 4 round functions back) as input wires to the current sub-computation.</p>

    <p class="text-gray-300"><strong>Performance.</strong> Overall, we obtain an arithmetic circuit  <span class="math">C_{\\mathcal{H}}</span>  for verifying SHA256's compression function with less than 30 000 arithmetic gates. See Figure 3 for a breakdown of gate counts.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Gate count for</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Gate count for <span class="math">C_{\\mathcal{H}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Message schedule</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8032</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">All rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19584</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 round (of 64)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">306</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Finalize</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Total</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27904</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 3: Size of circuit  <span class="math">C_{\\mathcal{H}}</span>  for SHA256's compression function.</p>

    <p class="text-gray-300">Comparison with generic approaches. We constructed the circuit  <span class="math">C_{\\mathcal{H}}</span>  from scratch. We could have instead opted for more generic approaches: implement SHA256's compression function in a higher-level language, and use a circuit generator to obtain a corresponding circuit. However, generic approaches are significantly more expensive for our application, as we now explain.</p>

    <p class="text-gray-300">Starting from the SHA256 implementation in PolarSSL (a popular cryptographic library) [Pol13], it is fairly straightforward to write a C program for computing  <span class="math">\\mathcal{H}</span> . We wrote such a program, and gave it as input to the circuit generator of [PGHR13]. The output circuit had 58160 gates, more than twice larger than our hand-optimized circuit.</p>

    <p class="text-gray-300">Alternatively, we also compiled the same C program to TinyRAM, which is the architecture supported in [BCG<sup>+</sup>13]; we obtained a 5371-instruction assembly code that takes 5704 cycles to execute on TinyRAM. We could then invoke the circuit generator in [BCG<sup>+</sup>13] when given this TinyRAM program and time bound. However, each TinyRAM cycle costs  <span class="math">\\approx 1000</span>  gates, so the resulting circuit would have at least  <span class="math">5.7 \\cdot 10^6</span>  gates, i.e., over 190 times larger than our circuit. A</p>

    <p class="text-gray-300">similar computation holds for the circuit generator in [BCTV14], which supports an even more flexible architecture.</p>

    <p class="text-gray-300">Thus, overall, we are indeed much better off constructing  <span class="math">C_{\\mathcal{H}}</span>  from scratch. Of course, this is not surprising, because a SHA256 computation is almost a &quot;circuit computation&quot;: it does not make use of complex program flow, accesses to memory, and so on. Thus, relying on machinery developed to support much richer classes of programs does not pay off.</p>

      <h4 id="sec-5.2.2" class="text-lg font-semibold mt-6">5.2.2 Arithmetic circuit for POUR</h4>

    <p class="text-gray-300">The NP statement POUR requires verifying membership in a Merkle tree based on  <span class="math">\\mathcal{H}</span> , a few additional invocations of  <span class="math">\\mathcal{H}</span> , and integer addition and comparison. We construct the circuit  <span class="math">C_{\\text{POUR}}</span>  for POUR by combining various subcircuits verifying each of these. There remains to to discuss the subcircuits for verifying membership in a Merkle tree (using the aforementioned subcircuit  <span class="math">C_{\\mathcal{H}}</span>  for verifying invocations of  <span class="math">\\mathcal{H}</span> ), and integer addition and comparison.</p>

    <p class="text-gray-300">Merkle tree membership. We need to construct an arithmetic circuit that, given a root rt, authentication path path, and coin commitment cm, is satisfied if and only if path is a valid authentication path for the leaf cm with respect to the root rt. The authentication path path includes, for each layer i, an auxiliary hash value  <span class="math">h_i</span>  and a bit  <span class="math">r_i</span>  specifying whether  <span class="math">h_i</span>  was the left  <span class="math">(r_i = 0)</span>  or the right  <span class="math">(r_i = 1)</span>  child of the parent node. We then check membership in the Merkle tree by verifying invocations of  <span class="math">\\mathcal{H}</span> , bottom-up. Namely, for d = 64, we set  <span class="math">k_{d-1} = \\text{cm}</span> ; then, for each  <span class="math">i = d - 1, \\ldots, 1</span> , we set  <span class="math">B_i = h_i || k_i</span>  if  <span class="math">r_i = 0</span>  else  <span class="math">k_i || h_i</span> , and compute  <span class="math">k_{i-1} = \\mathcal{H}(B_i)</span> . Finally we check that the root  <span class="math">k_0</span>  matches the given root rt.</p>

    <p class="text-gray-300"><strong>Integer addition.</strong> We need to construct an arithmetic circuit that, given 64-bit integers A, B, C (presented as binary strings), is satisfied if and only if C = A + B over the integers. Again relying on the fact that  <span class="math">\\mathbb{F}</span> 's characteristic is sufficiently large, we do so by checking that  <span class="math">\\sum_{i=0}^{63} 2^i c_i = \\sum_{i=0}^{63} 2^i (b_i + a_i)</span>  over  <span class="math">\\mathbb{F}</span> ; this is enough, because there is no wrap around.</p>

    <p class="text-gray-300">Integer comparison. We need to construct an arithmetic circuit that, given two 64-bit integers A, B (represented in binary), is satisfied if and only if A+B fits in 64 bits (i.e.  <span class="math">A+B&lt;2^{64}</span> ). We do so by checking that  <span class="math">\\sum_{i=0}^{63} 2^i(b_i+a_i) = \\sum_{i=0}^{63} c_i</span>  for some  <span class="math">c_i \\in \\{0,1\\}</span> . Indeed, if  <span class="math">A+B&lt;2^{64}</span>  then it suffices to take  <span class="math">c_i</span>  as the binary representation of A+B. However, if  <span class="math">A+B \\geq 2^{64}</span>  then no choice of  <span class="math">c_i</span>  can satisfy the constraint as  <span class="math">\\sum_{i=0}^{63} c_i \\leq 2^{64} - 1</span> . Overall, this requires 65 gates (1 gate for the equality check, and 64 gates for ensuring that  <span class="math">c_0, \\ldots, c_{63}</span>  are boolean).</p>

    <p class="text-gray-300">Overall circuit sizes. See Figure 4 for the size of  <span class="math">C_{POUR}</span> . More than 99% of the gates are devoted to verifying invocations of  <span class="math">\\mathcal{H}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Gate count for <span class="math">C_{\\mathtt{POUR}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ensure cm <sub>1</sub> <sup>old</sup> is in Merkle tree</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1802304</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(1 layer out of 64)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(28161)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ensure cm <sub>2</sub> <sup>old</sup> is in Merkle tree</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1802304</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(1 layer out of 64)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(28161)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Check computation of <span class="math">sn_1^{old}, sn_2^{old}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\times 27904</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Check computation of <span class="math">a_{pk,1}^{old}, a_{pk,2}^{old}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\times 27904</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Check computation of <span class="math">cm_1^{old}, cm_2^{old}, cm_1^{new}, cm_2^{new}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">4 \\times 83712</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Check computation of <span class="math">h_1, h_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\times 27904</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ensure that <span class="math">v_1^{\\text{new}} + v_2^{\\text{new}} + v_{\\text{pub}} = v_1^{\\text{old}} + v_2^{\\text{old}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ensure that <span class="math">v_1^{\\text{old}} + v_2^{\\text{old}} &lt; 2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Miscellaneous</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Total</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 109 330</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 4: Size of the circuit  <span class="math">C_{POUR}</span> , which verifies the statement POUR.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Integration with existing ledger-based currencies</h2>

    <p class="text-gray-300">Zerocash can be deployed atop any ledger (even one maintained by a central bank). Here, we briefly detail integration with the Bitcoin protocol. Unless explicitly stated otherwise, in the following section when referring to Bitcoin, and its unit of account bitcoin (plural bitcoins), we mean the underlying protocol and software, not the currency system. (The discussion holds, with little or no modification, for many forks of Bitcoin, also known as &quot;altcoins&quot;, such as Litecoin.)</p>

    <p class="text-gray-300">By introducing new transaction types and payment semantics, Zerocash breaks compatibility with the Bitcoin network. While Zerocash could be integrated into Bitcoin (the actual currency and its supporting software) via a &quot;flag day&quot; where a super-majority of Bitcoin miners simultaneously adopt the new software, we neither expect nor advise such integration in the near future and suggest using Zerocash in a separate altcoin.</p>

    <p class="text-gray-300">Integrating Zerocash into Bitcoin consists of adding a new transaction type, Zerocash transactions, and modifying the protocol and software to invoke Zerocash's DAP interface to create and verify these transactions. There are at least two possible approaches to this integration. The first approach replaces all bitcoins with zerocoins, making all transactions anonymous at the cost of losing any additional Bitcoin functionality provided by, e.g., the Bitcoin scripting language (see Section <a href="#page-25-1">6.1)</a>. The second approach maintains this functionality, adding a parallel Zerocash currency, zerocoin, which can be converted to and from bitcoin at a one-to-one rate (see Section <a href="#page-25-2">6.2)</a>. Options for protocol-level modifications for the later approach are discussed in Section <a href="#page-27-0">6.3;</a> the former can be readily inferred. In Section <a href="#page-27-1">6.4</a> we discuss anonymizing the network layer of Bitcoin and anonymity safeguards.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Integration by replacing the base currency</h3>

    <p class="text-gray-300">One approach is to alter the underlying system so that all monetary transactions are done using Zerocash, i.e., by invoking the DAP interface and writing/reading the associated transactions in the distributed ledger.</p>

    <p class="text-gray-300">As seen in Section <a href="#page-12-0">3,</a> this suffices to offer the core functionality of payments, minting, merging, splitting, etc., while assuring users that all transactions using this currency are anonymous. However, this has several drawbacks: (1) All pour transactions incur the cost of generating a zk-SNARK proof. (2) If Bitcoin supports additional features, such as a scripting language for specifying conditions for claiming bitcoins (as in Bitcoin), then these features are lost.<a href="#page-25-3">17</a> (3) Bitcoin allows the flexibility of spending unconfirmed transactions; instead, with a Zerocash-only Bitcoin, this flexibility is lost: transactions must be confirmed before they can be spent. (And this imposes a minimal delay between receiving funds and spending them.)</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Integration by hybrid currency</h3>

    <p class="text-gray-300">A different approach is to extend Bitcoin with a parallel, anonymized currency of &quot;zerocoins&quot;, existing alongside bitcoins, using the same ledger, and with the ability to convert freely between the two. The behavior and functionality of regular bitcoins is unaltered; in particular, they may support functionality such as scripting.</p>

    <p class="text-gray-300">In this approach, the Bitcoin ledger consists of Bitcoin-style transactions, containing inputs and outputs <a href="#page-54-10">[Nak09]</a>. Each input is either a pointer to an output of a previous transaction (as in plain Bitcoin), or a Zerocash pour transaction (which contributes its public value, vpub, of bitcoins to this transaction). Outputs are either an amount and destination public address/script (as in plain</p>

    <p class="text-gray-300"><sup>17</sup>However, in principle POUR could be extended to include a scripting language interpreter.</p>

    <p class="text-gray-300">Bitcoin), or a Zerocash mint transaction (which consumes the input bitcoins to produce zerocoins). The usual invariant over bitcoins is maintained and checked in plain view: the sum of bitcoin inputs (including pours' vpub) must be at least the sum of bitcoin outputs (including mints' v), and any difference is offered as a transaction fee. However, the accounting for zerocoins consumed and produced is done separately and implicitly by the DAP scheme.</p>

    <p class="text-gray-300">The life cycle of a zerocoin is as follows.</p>

    <p class="text-gray-300">Creating new zerocoins. A mint transaction consumes v worth of bitcoins as inputs, and outputs coin commitment worth v zerocoins. The v bitcoins are effectively destroyed, in exchange for the newly-minted zerocoins.</p>

    <p class="text-gray-300">Spending zerocoins. Zerocoins can then be transferred, split, and merged into other zerocoins arbitrarily, via pour transactions which, instead of explicit inputs, include zero-knowledge proofs that such inputs exist. Pour transactions may optionally reveal a non-zero public output vpub. This is either left unclaimed as a transaction fee,<a href="#page-26-0">18</a> placed into a standard Bitcoin transaction output (e.g., one paying to a public key) or consumed by a mint transaction. Thus, vpub bitcoins are created ex nihilo (similarly to how coinbase transactions produce bitcoin outputs as mining reward), in exchange for destroying that amount of zerocoins. The Bitcoin outputs must be included in the transaction string info, which is included as part of a pour transaction; transaction non-malleability ensures that all this information is bound together.</p>

    <p class="text-gray-300">Spending multiple zerocoins. To allow for pours to span more than two input and output coins, txPour structures may be chained together within one transaction by marking some output coin commitments as intermediates and having subsequent pours in the same transaction constructed relative to an ephemeral Merkle tree consisting of only the intermediates commitments. For example, a transaction might accept four input coins, with the first two Pour operations combining two of the inputs to produce an intermediate commitment each and a final Pour combining the two intermediate commitments into a final output new coin. Since the intermediate results are consumed instantly within the transaction, they need not be recorded in the global Merkle tree or have their serial numbers marked as spent.</p>

    <p class="text-gray-300">Transaction fees. Collecting transaction fees is done as usual, via a coinbase transaction added to each block, which pays as mining reward the difference between the total inputs (bitcoin and pours' vpub) and total outputs (bitcoin and mints' v) in this block. Payment is either in bitcoins or in newly-minted zerocoins (via a Mint).</p>

    <p class="text-gray-300">Validation and block generation. All transactions are verified via VerifyTransaction when they are received by a node. Any plain Bitcoin inputs and outputs are processed as usual, and any Zerocash inputs and outputs are checked using VerifyTransaction with the entire Bitcoin transaction fed in as info for authentication. Once these transactions are assembled into a candidate block, each transaction needs to be verified again to ensure its serial number has not become spent or its Merkle root invalid. If these checks pass, the set of new coin commitments and spent serial numbers output by the included transactions are added to the global sets, and the new Merkle root and a digest of the serial number list is stored in the new block.<a href="#page-26-1">19</a> Embedding this data simplifies statekeeping and allows nodes to readily verify they have the correct coin list and serial number list. Upon receiving a candidate block, nodes validate the block is formed correctly with respect to the above procedure.</p>

    <p class="text-gray-300">Receiving payments. In order to receive payments to an address, users may scan the block chain by running the Receive on every pour transaction. Alternatively they may receive coin information</p>

    <p class="text-gray-300"><sup>18</sup>Since transaction fees may potentially be claimed by any node in the network, they represent the sole zerocoin output that cannot be hidden from public view even in a Zerocash-only system.</p>

    <p class="text-gray-300"><sup>19</sup>This can be stored in the coinbase transaction, as certain other data currently is, or in a new field in the block header.</p>

    <p class="text-gray-300">via some out-of-band mechanism (e.g., via encrypted email). The former process is nearly identical to the one proposed for &quot;stealth addresses&quot; for Bitcoin. In the worst case, scanning the block chain requires a trial decryption of every ciphertext C. We expect many scenarios to provide explicit notification, e.g., in interactive purchases where a communication channel already exists from the payer to the payee. (Implementations may opt to drop the receive mechanism entirely, and require out-of-band notification, in order to avoid storing the ciphertexts in the block chain.)</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Extending the Bitcoin protocol to support the combined semantics</h3>

    <p class="text-gray-300">While the section above describes the life-cycle of a zerocoin and semantics of the system, there remains the question of how transactions acquire the above necessary semantics. Two implementation approaches are possible, with different engineering tradeoffs.</p>

    <p class="text-gray-300">The first approach is to extend the protocol and its implementation with hard-coded validation of Zerocash transactions, reading them from new, designated fields in transactions and running VerifyTransaction. In this case the zk-SNARK itself effectively replaces the scripting language for Zerocash transactions.</p>

    <p class="text-gray-300">The second approach is to extend Bitcoin's scripting language by adding an opcode that invokes VerifyTransaction, with the requisite arguments embeded alongside the opcode script. Such transactions must be exempt from the requirement they reference an input (as they are Zerocash transactions are self-contained), and, like coinbase transactions, be able to create bitcoins ex nihilo (to account for vpub). Moreover, while VerifyTransaction is run at the standard point in the Bitcoin transaction processing flow for evaluating scripts, the coin commitments and spent serial numbers are not actually added to CMList (resp., SNList) until their containing block is accepted (i.e., merely verifying a transaction does not have side effects).</p>

      <h3 id="sec-6.4" class="text-xl font-semibold mt-8">6.4 Additional anonymity considerations</h3>

    <p class="text-gray-300">Zerocash only anonymizes the transaction ledger. Network traffic used to announce transactions, retrieve blocks, and contact merchants still leaks identifying information (e.g., IP addresses). Thus users need some anonymity network to safely use Zerocash. The most obvious way to do this is via Tor <a href="#page-54-18">[DMS04]</a>. Given that Zerocash transactions are not low latency themselves, Mixnets (e.g., Mixminion <a href="#page-53-18">[DDM03]</a>) are also a viable way to add anonymity (and one that, unlike Tor, is not as vulnerable to traffic analysis). Using mixnets that provide email-like functionality has the added benefit of providing an out-of-band notification mechanism that can replace Receive.</p>

    <p class="text-gray-300">Additionally, although in theory all users have a single view of the block chain, a powerful attacker could potentially fabricate an additional block solely for a targeted user. Spending any coins with respect to the updated Merkle tree in this &quot;poison-pill&quot; block will uniquely identify the targeted user. To mitigate such attacks, users should check with trusted peers their view of the block chain and, for sensitive transactions, only spend coins relative to blocks further back in the ledger (since creating the illusion for multiple blocks is far harder).</p>

    <p class="text-gray-300">To measure the performance of Zerocash, we ran several experiments. First, we benchmarked the performance of the zk-SNARK for the NP statement POUR (Section <a href="#page-28-0">7.1)</a> and of the six DAP scheme algorithms (Section <a href="#page-28-1">7.2)</a>. Second, we studied the impact of a higher block verification time via a simulation of a Bitcoin network (Section <a href="#page-29-0">7.3)</a>.</p>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8">7.1 Performance of zk-SNARKs for pouring coins</h3>

    <p class="text-gray-300">Our zk-SNARK for the NP statement POUR is obtained by constructing an arithmetic circuit CPOUR for verifying POUR, and then invoking the generic implementation of zk-SNARK for arithmetic circuit satisfiability of <a href="#page-53-6">[BCTV14]</a> (see Section <a href="#page-11-1">2.4)</a>. The arithmetic circuit CPOUR is built from scratch and hand-optimized to exploit nondeterministic verification and the large field characteristic (see Section <a href="#page-22-0">5.2)</a> .</p>

    <p class="text-gray-300">Figure <a href="#page-28-2">5</a> reports performance characteristics of the resulting zk-SNARK for POUR. This includes three settings: single-thread performance on a laptop machine; and single-thread and multi-thread performance on a desktop machine. (The time measurements are the average of 10 runs, with standard deviation under 2.5%.) For instance, with single-thread code on the laptop machine, we obtain that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key generation takes 7 min 48 s, and results in a proving key pkPOUR of 896 MiB and a verification key vkPOUR of 749 B. This is performed only once, as part of the Setup algorithm.</li>
      <li>Producing a proof &pi;POUR requires about 3 minutes; proofs have a constant size of 288 B. Proof generation is a subroutine of the Pour algorithm, and the resulting proof is included in the corresponding pour transaction.</li>
      <li>&bull; A proof &pi;POUR can be verified in only 8.5 ms. Proof verification is a subroutine of the VerifyTransaction algorithm, when it is given as input a pour transaction to verify.</li>
    </ul>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Intel</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Intel</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Core i7-2620M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Core i7-4770</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">@ 2.70GHz</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">@ 3.40GHz</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12GB of RAM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16GB of RAM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 thread</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 thread</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 threads</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KeyGen</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7 min 48 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5 min 11 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 min 47 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proving key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">896 MiB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verification key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">749 B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Prove</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 min 55 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 min 59 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proof</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288 B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.5 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.4 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 5: Performance of our zk-SNARK for the NP statement POUR. (N = 10, &sigma; &le; 2.5%)</p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8">7.2 Performance of Zerocash algorithms</h3>

    <p class="text-gray-300">In Figure <a href="#page-30-0">6</a> we report performance characteristics for each of the six DAP scheme algorithms in our implementation (single-thread on our desktop machine). For VerifyTransaction, we separately report the cost of verifying mint and pour transactions and, in the latter case, we exclude the cost of scanning L (e.g., to check if a serial number is duplicate);<a href="#page-28-3">20</a> for the case of Receive, we report the cost to process a given pour transaction in L.</p>

    <p class="text-gray-300">We obtain that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup takes about 5 minutes to run; its running time is dominated by the running time of KeyGen on CPOUR. (Either way, Setup is run only once.) The size of the resulting public parameters pp is dominated by the size of pkPOUR.</li>
      <li>CreateAddress takes 326.0 ms to run. The size of the resulting address key pair is just a few hundred bytes.</li>
    </ul>

    <p class="text-gray-300"><sup>20</sup>Naturally, if SNList has 2<sup>64</sup> serial numbers (the maximum possible in our implementation), then scanning is very expensive! However, we do not expect that a system like Zerocash will grow to 2<sup>64</sup> transactions. Still, such a system may grow to the point that scanning SNList is too expensive. We detail possible mitigations to this in Section <a href="#page-34-0">8.3.2.</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Mint takes 23 &micro;s to run. It results in a coin of size 463 B and mint transaction of size 72 B.</li>
      <li>Pour takes about 2 minutes to run. Besides Setup, it is the only &quot;expensive&quot; algorithm to run; as expected, its running time is dominated by the running time of Prove. For a transaction string info, it results in (two new coins and) a pour transaction of size 996 B + |info|.</li>
      <li>VerifyTransaction takes 8.3 &micro;s to verify a mint transaction and 5.7 ms to verify a pour transaction; the latter's time is dominated by that of Verify, which checks the zk-SNARK proof &pi;POUR.</li>
      <li>Receive takes 1.6 ms per pour transaction.</li>
    </ul>

    <p class="text-gray-300">Note that the above numbers do not include the costs of maintaining the Merkle tree because doing so is not the responsibility of the DAP scheme algorithms. Nevertheless, these additional costs are not large: (i) each update of the root of the CRH-based Merkle tree only requires dtree invocations of CRH, and (ii) an authentication path consists of only dtree digests of CRH. In our implementation, where CRH = H (the SHA256 compression function) and dtree = 64, each update requires 64 invocations of H and an authentication path requires 64 &middot; 32 B = 2 KiB of storage.</p>

    <p class="text-gray-300">Remark. If one does not want to rely on the ledger to communicate coins, via the ciphertexts C1, C2, and instead rely instead on some out-of-band mechanism (e.g., encrypted email), then the Receive algorithm is not needed, and moreover, many of the aforementioned sizes decrease because some pieces of data are not needed anymore; we denoted these pieces of data with &quot;?&quot; in Figure <a href="#page-30-0">6.</a> (E.g., the size of an address key pair is reduced to only 64 B, and the size of a coin to only 120 B.)</p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8">7.3 Large-scale network simulation</h3>

    <p class="text-gray-300">Because Bitcoin mining typically takes place on dedicated GPUs or ASICs, the CPU resources to execute the DAP scheme algorithms are often of minimal consequence to network performance. There is one potential exception to this rule: the VerifyTransaction algorithm must be run by all of the network nodes in the course of routine transaction validation. The time it takes to perform this verification may have significant impact on network performance.</p>

    <p class="text-gray-300">In the Zerocash implementation (as in Bitcoin), every Zerocash transaction is verified at each hop as it is forwarded though the network and, potentially, again when blocks containing the transaction are verified. Verifying a block consists of checking the proof of work and validating the contained transactions. Thus Zerocash transactions may take longer to spread though the network and blocks containing Zerocash transactions may take longer to verify. While we are concerned with the first issue, the potential impact of the second issue is cause for greater concern. This is because Zerocash transactions cannot be spent until they make it onto the ledger.</p>

    <p class="text-gray-300">Because blocks are also verified at each hop before they are forwarded through the network, delays in block verification slow down the propagation of new blocks through the network. This causes nodes to waste CPU-cycles mining on out-of-date blocks, reducing the computational power of the network and making it easier to mount a &quot;51% attack&quot; (dishonest majority of miners) on the distributed ledger.</p>

    <p class="text-gray-300">It is a priori unclear whether this potential issue is a real concern. Bitcoin caches transaction verifications, so a transaction that was already verified when it propagated through the network need not be verified again when it is seen in a block. The unknown is what percentage of transactions in a block are actually in any given node's cache. We thus conduct a simulation of the Bitcoin network to investigate both the time it takes Zerocash transactions to make it onto the ledger and establish the effects of Zerocash transactions on block verification and propagation. We find that Zerocash transactions can be spent reasonably quickly and that the effects of increased block validation time are minimal.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Intel</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Core i7-4770</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">@ 3.40GHz</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16GB of RAM</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 thread</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Setup</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">5 \\min 17  \\mathrm{s}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of pp</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">896 MiB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of pk <sub>POUR</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">896 MiB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of vk <sub>POUR</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">749 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#9733; size of pp <sub>enc</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#304;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of pp <sub>sig</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CreateAddress</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">326.0\\mathrm{ms}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of addr <sub>pk</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">343 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">a_{pk}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#9733; size of pk <sub>enc</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">311 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of addr <sub>sk</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">319 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">a_{sk}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#9733; size of sk <sub>enc</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">287 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mint</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23 &mu;s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of coin c</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">463 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of addr <sub>pk</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">343 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">v</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">\\rho</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">r</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">s</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of cm</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">32\\mathrm{B}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of tx <sub>Mint</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of cm</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">32\\mathrm{B}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">v</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">32\\mathrm{B}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">s</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Pour</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\min 2.01 \\mathrm{s}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of tx <sub>Pour</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">996\\mathrm{B} +  info </span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of rt</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of sn <sup>old</sup> , sn <sup>old</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\times 32 \\mathrm{B}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of cm <sub>1</sub> <sup>new</sup> , cm <sub>2</sub> <sup>new</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\times 32 \\mathrm{B}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">v_{pub}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of info</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">info</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of pk <sub>sig</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">h_1, h_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\times 32 \\mathrm{B}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">\\pi_{POUR}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\star</span> size of <span class="math">\\mathbf{C}_1, \\mathbf{C}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\times 173 \\mathrm{B}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">size of <span class="math">\\sigma</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64 B</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VerifyTransaction</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time for mint tx</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.3 &micro;s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&bull;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time for pour <span class="math">tx</span> (excludes <span class="math">L</span> scan)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">5.7\\mathrm{ms}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Receive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time (per pour tx)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1.6\\mathrm{ms}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">\\1 1 /</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 6: Performance of Zerocash algorithms. Above, we report the sizes of  <span class="math">pp_{enc}</span>  and  <span class="math">pp_{sig}</span>  as 0 B, because these parameters are &quot;hardcoded&quot; in the libraries we rely on for Enc and Sig. (N=10 with  <span class="math">\\sigma \\leq 2.5\\%</span>  for all except that, due to variability at short timescales,  <span class="math">\\sigma(\\mathsf{Mint}) \\leq 3.3\\,\\mu\\mathrm{s}</span>  and  <span class="math">\\sigma(\\mathsf{VerifyTransaction}) \\leq 1.9\\,\\mu\\mathrm{s}</span> )</p>

    <p class="text-gray-300"><strong>Simulation design.</strong> Because Zerocash requires breaking changes to the Bitcoin protocol, we cannot test our protocol in the live Bitcoin network or even in the dedicated testnet. We must run our own private testnet. For efficiency and cost reasons, we would like to run as many Bitcoin nodes as possible on the least amount of hardware. This raises two issues. First, reducing the proof of work to practical levels while still preserving a realistic rate of new blocks is difficult (especially on</p>

    <p class="text-gray-300">virtualized hardware with variable performance). Second, the overhead of zk-SNARK verification prevents us from running many Bitcoin nodes on one virtualized server.</p>

    <p class="text-gray-300">The frequency of new blocks can be modeled as a Poisson process with a mean of &Lambda;block seconds.<a href="#page-31-0">21</a> To generate blocks stochastically, we modify bitcoind to fix its block difficulty at a trivial level <a href="#page-31-1">22</a> and run a Poisson process, on the simulation control server, which trivially mines a block on a randomly selected node. This preserves the distribution of blocks, without the computational overhead of a real proof of work. Another Poisson process triggering mechanism, with a different mean &Lambda;tx, introduces new transactions at random network nodes.</p>

    <p class="text-gray-300">To differentiate which transactions represent normal Bitcoin expenditures versus which contain Zerocash pour transactions, simulated Zerocash transactions pay a unique amount of bitcoins (we set this value arbitrarily at 7 BTC). If a transaction's output matches this preset value, and it is not in verification cache, then our modified Bitcoin client inserts a 10 ms delay simulating the runtime of VerifyTransaction. <a href="#page-31-2">23</a> Otherwise transactions are processed as specified by the Bitcoin protocol. We vary the amount of simulated Zerocash traffic by varying the number of transactions with this particular output amount. This minimizes code changes and estimates only the generic impact of verification delays and not of any specific implementation choice.</p>

    <p class="text-gray-300">Methodology. Recent research <a href="#page-54-7">[DW13]</a> suggests that the Bitcoin network contains 16,000 distinct nodes though most are likely no longer participating: approximately 3,500 are reachable at any given time. Each node has an average of 32 open connections to randomly selected peers. As of November 2013, the peak observed transaction rate for Bitcoin is slightly under one transaction per second <a href="#page-54-19">[Lee13]</a>.</p>

    <p class="text-gray-300">In our simulation, we use a 1000-node network in which each node has an average of 32 peers, transactions are generated with a mean of &Lambda;tx = 1 s, a duration of 1 hour, and a variable percentage of Zerocash traffic. To allow for faster experiments, instead of generating a block every 10 minutes as in Bitcoin, we create blocks at an average of every &Lambda;block = 150 s (as in Litecoin, a popular altcoin).</p>

    <p class="text-gray-300">We run our simulation for different traffic mixes, where indicates the percentage of Zerocash transactions and &isin; {0%, 25%, 50%, 75%, 100%}. Each simulation is run on 200 Amazon EC2 general-purpose m1.medium instances, in one region on a 10.10./16 private network. On each instance, we deploy 5 instances of bitcoind. <a href="#page-31-3">24</a></p>

    <p class="text-gray-300">Results. Transactions are triggered by a blocking function call on the simulation control node that must connect to a random node and wait for it to complete sending a transaction. Because the Poisson process modeling transactions generates delays between such calls and not between the exact points when the node actuals sends the transactions, the actual transaction rate is skewed. In our experiments the real transaction rate shifts away from our target of one per second to an average of one every 1.4 seconds.</p>

    <p class="text-gray-300">In Figure <a href="#page-32-2">7</a> we plot three metrics for &isin; {0%, 25%, 50%, 75%, 100%}. Each is the average defined over the data from the entire run of the simulation for a given (i.e., they include multiple transactions and blocks).<a href="#page-31-4">25</a> Transaction latency is the interval between a transaction's creation and</p>

    <p class="text-gray-300"><sup>21</sup>Since computational power is added to the Bitcoin network faster than the 2-week difficulty adjustment period, the frequency of block generation is actually skewed. As our experiments run for at most an hour, we ignore this.</p>

    <p class="text-gray-300"><sup>22</sup>These code modifications have been rendered moot by the subsequent inclusion of a &quot;regtest&quot; mode in Bitcoin 0.9 that allows for precisely this type of behavior and block generation on command. At the time of our experiments, this feature was not available in a stable release. Future work should use this feature.</p>

    <p class="text-gray-300"><sup>23</sup>We used a generous delay of 10 ms (higher than the time reported in Figure <a href="#page-30-0">6)</a> to leave room for machines slower than our desktop machine.</p>

    <p class="text-gray-300"><sup>24</sup>Higher densities of nodes per VM resulted in issues initializing all of the bitcoind instances on boot.</p>

    <p class="text-gray-300"><sup>25</sup>Because our simulated Bitcoin nodes ran on shared EC2 instances, they were subject to variable external load,</p>

    <p class="text-gray-300">its inclusion in a block. <em>Block propagation time</em> comes in two flavors: (1) the average time for a new block to reach a node computed over the times for all nodes, and (2) the same average computed over only the last node to see the block.</p>

    <p class="text-gray-300">Block verification time is the average time, over all nodes, required to verify a block. If verification caching was not effective, we would expect to see a marked increase in both block verification time and propagation time. Since blocks occur on average every 150 s, and we expect approximately one transaction each second, we should see  <span class="math">150 \\times 10 \\,\\mathrm{ms} = 1500 \\,\\mathrm{ms}</span>  of delay if all transactions were non-cached Zerocash transactions. Instead, we see worst case 80 ms and conclude caching is effective. This results in a negligible effect on block propagation (likely because network operations dominate).</p>

    <p class="text-gray-300">The time needed for a transaction to be confirmed, and hence spendable, is roughly 190 s. For slower block generation rates (e.g., Bitcoin's block every 10 minutes) this should mean users must wait only one block before spending received transactions.</p>

    <p class="text-gray-300">    <img src="_page_32_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 7: The average values of the three metrics we study, as a function of  <span class="math">\\epsilon</span> , the percentage of transactions that are Zerocash transactions. Note that, in (a), latency is undefined when  <span class="math">\\epsilon = 0</span>  and hence omitted.</p>

    <p class="text-gray-300">We outline several optimizations and extensions to Zerocash: everlasting anonymity (Section 8.1), faster block propagation (Section 8.2), and improved storage requirements (Section 8.3).</p>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8">8.1 Everlasting anonymity</h3>

    <p class="text-gray-300">Since transactions may persist virtually forever on the ledger, users may wish to ensure the anonymity of their transactions also lasts forever, even if particular primitives are eventually broken (by cryptanalytic breakthrough, engineering progress, or quantum computers). As we now explain, the DAP scheme construction described in Section 4 is only computationally private, but can be modified to achieve <em>everlasting anonymity</em>.</p>

    <p class="text-gray-300">Recall that every Pour operation publishes a pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}} = (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, *), \\text{ where } * = (\\mathsf{pk}_{\\mathsf{sig}}, h_1, h_2, \\pi_{\\mathsf{POUR}}, \\mathbf{C}_1, \\mathbf{C}_2, \\sigma) \\text{ and } \\mathbf{C}_i = \\mathcal{E}_{\\mathsf{enc}}(\\mathsf{pk}_{\\mathsf{enc},i}^{\\mathsf{new}}, (v_i^{\\mathsf{new}}, \\rho_i^{\\mathsf{new}}, r_i^{\\mathsf{new}}, s_i^{\\mathsf{new}})).</span>  Observe that:</p>

    <p class="text-gray-300">limiting the benchmark precision. Still, it clearly demonstrates that the mild additional delay does not cause catastrophic network effects.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Since  <span class="math">h_{\\mathsf{Sig}} = \\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}})</span>  and  <span class="math">h_i = \\mathsf{PRF}^{\\mathsf{pk}}_{a^{\\mathsf{old}}_{\\mathsf{sk},i}}(h_{\\mathsf{Sig}})</span> , an unbounded adversary  <span class="math">\\mathcal{A}</span>  can iterate over all x until  <span class="math">\\mathsf{PRF}^{\\mathsf{pk}}_x(h_{\\mathsf{Sig}})</span>  equals  <span class="math">h_i</span> ; with overwhelming probability, there is only one such x, in which case it equals  <span class="math">a^{\\mathsf{old}}_{\\mathsf{sk},i}</span> . Thus,  <span class="math">\\mathcal{A}</span>  learns  <span class="math">a^{\\mathsf{old}}_{\\mathsf{sk},i}</span> , and hence  <span class="math">a^{\\mathsf{old}}_{\\mathsf{pk},i} := \\mathsf{PRF}^{\\mathsf{addr}}_{a^{\\mathsf{old}}_{\\mathsf{sk},i}}(0)</span> . This identifies the sender.</li>
      <li>An unbounded  <span class="math">\\mathcal{A}</span>  can also decrypt  <span class="math">\\mathbf{C}_i</span> , so to learn  <span class="math">(v_i^{\\mathsf{new}}, \\rho_i^{\\mathsf{new}}, r_i^{\\mathsf{new}}, s_i^{\\mathsf{new}})</span> ; then,  <span class="math">\\mathcal{A}</span>  can try all possible x until  <span class="math">\\mathsf{COMM}_{s_i^{\\mathsf{new}}}(v_i^{\\mathsf{new}} \\| \\mathsf{COMM}_{r_i^{\\mathsf{new}}}(\\mathsf{PRF}_x^{\\mathsf{addr}}(0) \\| \\rho_i^{\\mathsf{new}}))</span>  equals  <span class="math">\\mathsf{cm}_i^{\\mathsf{new}}</span> ; with overwhelming probability, there is only one such x, in which case it equals  <span class="math">a_{\\mathsf{sk},i}^{\\mathsf{new}}</span> . This identifies the recipient.</li>
    </ul>

    <p class="text-gray-300">The above attacks can be prevented as follows. First, every sender must use any given address only once (for receiving or sending coins): after receiving a coin  <span class="math">\\mathbf{c}</span> , a user u should immediately generate a new address and pour  <span class="math">\\mathbf{c}</span>  into a fresh one  <span class="math">\\mathbf{c}&#x27;</span>  relative to the new address; only afterwards can u spend the coin. Second, a user should not put any data in a ciphertext  <span class="math">\\mathbf{C}_i</span>  to communicate a coin's information, but must instead use some (informationally-secure) out-of-band channel to do so. With these modifications (and recalling that COMM is statistically hiding and  <span class="math">\\pi_{POUR}</span>  is a perfect-zero-knowledge proof), one can verify that the pour transaction  <span class="math">\\operatorname{tx}_{Pour}</span>  is statistically hiding i.e., leaks no information even to unbounded adversaries.</p>

      <h3 id="sec-8.2" class="text-xl font-semibold mt-8">8.2 Fast block propagation</h3>

    <p class="text-gray-300">As mentioned in Section 7.3, the higher block-verification time of Zerocash compared to, e.g., Bitcoin does not affect much block propagation. Even so, we note a simple modification that further mitigates concerns. Upon receiving a block, a node validates the proof of work and (optionally) transactions other than mint and pour, and then forward the block right away. Only afterwards, the node executes VerifyTransaction on any mint/pour transactions, before accepting it for use in transacting. Thus, blocks are still validated by every node (so the security properties are unhampered), and propagation delays in the broadcast of blocks are reduced.</p>

    <p class="text-gray-300">In principle, this opens the possibility of a denial-of-service attack, in which the network is spammed with invalid blocks which pass the proof-of-work check but contain invalid mint or pour transactions. However, this attack appears unrealistic given the enormous (by design) cost of creating blocks passing the proof-of-work check.</p>

      <h3 id="sec-8.3" class="text-xl font-semibold mt-8">8.3 Improved storage requirements</h3>

    <p class="text-gray-300">Beyond the ledger L, users need to maintain two lists: CMList, the list of all coin commitments, and SNList, the list of all serial numbers of spent coins (see Section 3.1). In our construction, CMList is required to deduce authentication paths to create new pour transactions (via Pour), while SNList is used to verify pour transactions (via VerifyTransaction). As the ledger grows, both CMList and SNList grow in size, and can eventually impose substantial storage requirements (though both are derived from, and smaller than, the block chain per se). We now explain how these storage requirements can be mitigated, by relying on smaller representations of CMList and SNList that suffice within our construction.</p>

      <h4 id="sec-8.3.1" class="text-lg font-semibold mt-6">8.3.1 Supporting many coin commitments</h4>

    <p class="text-gray-300">To execute the Pour algorithm to spend a coin  <span class="math">\\mathbf{c}</span> , a user u needs to provide an authentication path from  <span class="math">\\mathbf{c}</span> 's coin commitment to rt, the Merkle-tree root over CMList. If we make the following protocol modifications, u does not need all of CMList to compute this authentication path.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;26</sup>As for mint transactions, one can verify that they are already statistically hiding, without any modifications.</p>

    <p class="text-gray-300">In each block B of transactions, we store the Merkle-tree path path<sup>B</sup> from the first coin commitment in B to the root rt<sup>B</sup> of the Merkle tree over CMList when the last block in the ledger is B. (In Zerocash, the additional per-block storage cost to store this information is only 2 KiB.)</p>

    <p class="text-gray-300">Note that, given a block B and its successor block B<sup>0</sup> , the corresponding authentication paths path<sup>B</sup> and pathB<sup>0</sup> can be easily checked for consistency as follows. Let CMList<sup>B</sup> and CMListB<sup>0</sup> be the two lists of coin commitments corresponding to the two ledgers ending in block B and B<sup>0</sup> respectively; since CMList<sup>B</sup> (i.e., coin commitments to &quot;to the left&quot; of pathB) is a prefix of CMListB<sup>0</sup>, pathB<sup>0</sup> can be computed from path<sup>B</sup> and B in time O(|B|dtree), where dtree is the tree depth.</p>

    <p class="text-gray-300">When the user u first receives (or mints) the coin c, and its coin commitment is included in a block B, u immediately computes pathB, by using the predecessor block and its authentication path. Afterwards, each time a new block is added to the ledger, u obtains a new path for c by using the new block and the old path for c. Thus, u only needs to act each time a new block is added, and each such update costs O(dtree) per transaction in the block.</p>

    <p class="text-gray-300">Overall, u incurs a storage requirement of only O(dtree) for each coin he owns, and does not need to store CMList anymore.</p>

      <h4 id="sec-8.3.2" class="text-lg font-semibold mt-6">8.3.2 Supporting many spent serial numbers</h4>

    <p class="text-gray-300">To execute the VerifyTransaction algorithm on a pour transaction txPour, a user u needs access to SNList (in order to check for duplicate serial numbers). Note, in Bitcoin, nodes need to maintain only the list of unspent transaction outputs, which is pruned as outputs are spent. In a DAP scheme, in contrast, nodes have to maintain SNList, which is a list that always grows. We now explain how to mitigate this storage requirement, in three incremental steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1. The first step is to build a Merkle tree over SNList so to allow easy-to-verify non-membership proofs for SNList; this can be done by letting the leaves of the Merkle tree be the intervals of unspent serial numbers. Then, given the root rt of such tree, a serial number sn claimed to be unspent, and an authentication path path for an interval I, the user can check that path is valid for rt and that sn lies in I; the root rt and path path would be part of the pour transaction txPour to be verified. The problem with this approach, however, is that generating path (and also updating rt) requires knowledge of all of SNList.</li>
      <li>Step 2. Next, instead of maintaining SNList in a single Merkle tree, we divide SNList, maintaining its chronological order, into sublists of serial numbers SNList0, SNList1, . . . and build a Merkle tree over the intervals induced by each sublist (i.e., apply Step 1 to each sublist). This modification implies a corresponding modification for the auxiliary information stored in a pour transaction that allows VerifyTransaction to check it. Now, however, producing such auxiliary information is less expensive. Indeed, a user with a coin c should maintain a list of authentication paths pathc,<sup>0</sup> , pathc,<sup>1</sup> , . . . (one for each sublist). Only the last path, corresponding to the active sublist, needs to be updated when a serial number is added; the other sublists and authentication paths remain unchanged (and these old sublists can in fact be discarded). When the user spends the coin, he can simply include these paths in the pour transaction. While updating these paths is an efficient operation, computing the initial paths for c is not, as it still requires the full set of sublists.</li>
      <li>Step 3. To enable users to avoid the initial cost of computing paths for a new coin, we proceed as follows. First, a coin c is extended to contain a time stamp T<sup>c</sup> corresponding to when c is created (minted or poured into); the coin's commitment is modified to depend on the timestamp, and the timestamp is included in the clear within the transaction that creates the coin. Then, a user, upon spending c, produces a zk-SNARK for the following NP statement: &quot;for each Merkle-tree root created (or updated) after T<sup>c</sup> there is an interval and an authentication path for that interval</li>
    </ul>

    <p class="text-gray-300">such that the serial number of c is in that interval&quot;. Depending on the number of Merkle trees in such an NP statement, such proofs may already be more efficient to produce, compared to the naive (Step 1) solution, using existing zk-SNARK implementations.</p>

    </section>

    <section id="sec-9" class="mb-10">
      <h2 class="text-2xl font-bold">9 Concurrent work</h2>

    <p class="text-gray-300">Danezis et al. <a href="#page-54-8">[DFKP13]</a> suggest using zk-SNARKs to reduce proof size and verification time in Zerocoin. Our work differs from <a href="#page-54-8">[DFKP13]</a> in both supported functionality and scalability.</p>

    <p class="text-gray-300">First, <a href="#page-54-8">[DFKP13]</a>'s protocol, like Zerocoin, only supports fixed-value coins, and is best viewed as a decentralized mix. Instead, we define, construct, and implement a full-fledged decentralized electronic currency, which provides anonymous payments of any amount.</p>

    <p class="text-gray-300">Second, in <a href="#page-54-8">[DFKP13]</a>, the complexity of the zk-SNARK generator, prover, and verifier all scale superlinearly in the number of coins, because their arithmetic circuit computes, explicitly, a product over all coins. In particular, the number of coins &quot;mixed together&quot; for anonymity cannot be large. Instead, in our construction, the respective complexities are polylogarithmic, polylogarithmic, and constant in the number of coins; our approach supports a practically-unbounded number of coins.</p>

    <p class="text-gray-300">While we do not rely on Pedersen commitments, our approach also yields statistical (i.e., everlasting) anonymity; see the discussion in Section <a href="#page-32-1">8.1.</a></p>

    </section>

    <section id="sec-10" class="mb-10">
      <h2 class="text-2xl font-bold">10 Conclusion</h2>

    <p class="text-gray-300">Decentralized currencies should ensure a user's privacy from his peers when conducting legitimate financial transactions. Zerocash provides such privacy protection, by hiding user identities, transaction amounts, and account balances from public view. This, however, may be criticized for hampering accountability, regulation, and oversight. Yet Zerocash need not be limited to enforcing the basic monetary invariants of a currency system. The underlying zk-SNARK cryptographic proof machinery is flexible enough to support a wide range of policies. It can, for example, let a user prove that he paid his due taxes on all transactions without revealing those transactions, their amounts, or even the amount of taxes paid. As long as the policy can be specified by efficient nondeterministic computation using NP statements, it can (in principle) be enforced using zk-SNARKs, and added to Zerocash. This can enable automated, privacy-preserving verification and enforcement of a wide range of compliance and regulatory policies that would otherwise be invasive to check directly or might be bypassed by corrupt authorities. This raises research, policy, and engineering questions regarding which such policies are desirable and practically realizable.</p>

    <p class="text-gray-300">Another research question is what new functionality can be realized by augmenting the capabilities already present in Bitcoin's scripting language with zk-SNARKs that allow fast verification of expressive statements.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Amazon for their assistance and kind donation of EC2 resources, and Gregory Maxwell for his advice regarding the Bitcoin codebase. We thank Iddo Ben-Tov and the SCIPR Lab members &mdash; Daniel Genkin, Lior Greenblatt, Shaul Kfir, Gil Timnat, and Michael Riabzev &mdash; for inspiring discussions. We thank Sharon Kessler for editorial advice.</p>

    <p class="text-gray-300">This work was supported by: Amazon.com through an AWS in Education research grant; the Broadcom Foundation and Tel Aviv University Authentication Initiative; the Center for Science of Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370; the Check Point Institute for Information Security; the U.S. Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL) under contract FA8750-11-2-0211; the European Community's Seventh Framework Programme (FP7/2007-2013) under grant agreement number 240258; the Israeli Centers of Research Excellence I-CORE program (center 4/11); the Israeli Ministry of Science and Technology; the Office of Naval Research under contract N00014-11-1-0470; the Simons Foundation, with a Simons Award for Graduate Students in Theoretical Computer Science; and the Skolkovo Foundation with agreement dated 10/26/2011.</p>

    <p class="text-gray-300">The views expressed are those of the authors and do not reflect the official policy or position of the Department of Defense or the U.S. Government.</p>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Overview of Bitcoin and Zerocoin</h2>

    <p class="text-gray-300">We provide an overview of the Bitcoin and Zerocoin protocols. For more details, we refer the reader to Nakamoto <a href="#page-54-10">[Nak09]</a> and Miers et al. <a href="#page-54-1">[MGGR13]</a> respectively.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Bitcoin</h3>

    <p class="text-gray-300">Bitcoin <a href="#page-54-10">[Nak09]</a> is a decentralized currency operated by a collection of mutually-distrusting peers. It consists of three basic components: (i) a peer-to-peer network for broadcasting new transactions; (ii) semantics for identifying and validating new transactions; and (iii) a protocol for maintaining a decentralized ledger, known as the block chain, that stores the history of all valid transactions so far.</p>

    <p class="text-gray-300">Identities in Bitcoin are represented via ECDSA public keys. Each user u generates an ECDSA key pair (vku,sku) and, to receive payments, publishes the verification key vk<sup>u</sup> (or its hash) as an address. (In fact, there is no limit to the number of addresses that an individual user may possess.)</p>

    <p class="text-gray-300">Transactions. A transaction tx represents a payment from a list of input transactions to a list of output recipients. More precisely, tx is specified by a list {Ij}<sup>j</sup> of inputs and a list {Oj}<sup>j</sup> of outputs. Each output O<sup>j</sup> specifies a value v<sup>j</sup> , denominated in Satoshi (10<sup>9</sup> Satoshi amounts to 1 bitcoin), and a recipient specification r<sup>j</sup> , called ScriptPubKey. The specification r<sup>j</sup> is given in Bitcoin script, a stack-based non-Turing-complete language similar to Forth, and specifies the identity of the recipient of the v<sup>j</sup> Satoshi. Each input I<sup>j</sup> references an output of a previous transaction tx<sup>j</sup> : the reference is specified by a tuple (h<sup>j</sup> , k<sup>j</sup> , &sigma;<sup>j</sup> ), where h<sup>j</sup> is the hash of tx<sup>j</sup> , k<sup>j</sup> is an index specifying which output of tx<sup>j</sup> is referenced, and &sigma;<sup>j</sup> , called ScriptSig, is a an input satisfying the ScriptPubKey of the k<sup>j</sup> -th output of tx<sup>j</sup> . Typically, the ScriptPubKey specifies a public key that must sign the transaction spending the output and &sigma;<sup>j</sup> contains such a signature, hence their names. Inputs can only be claimed by one transaction to prevent double spending.</p>

    <p class="text-gray-300">The total number of bitcoins output by a transaction, P j v<sup>j</sup> , cannot exceed the total value of the referenced outputs. Any difference between these two quantities is claimed as a transaction fee (see below). Thus, any unspent inputs to a transaction become a fee, and transactions typically have at least two outputs: one to the payment's recipient and one back to the sender as &quot;change&quot;.</p>

    <p class="text-gray-300">The block chain. Transactions are broadcast in the Bitcoin peer-to-peer network, but are considered valid only once they have been added to the the block chain. To assemble the block chain, miners (usually but not necessarily, network nodes) collect transactions from the Bitcoin network and bundle them into blocks. Miners then compete for the opportunity to append their own candidate block B to the block chain by searching for a string s such that the integer specified by SHA256(SHA256(Bks)) is below some threshold. To incentivize block creation, miners receive a protocol-specified reward (currently 25 BTC) for adding a new block and, moreover, receive per-transaction fees (whose value is specified by the transaction's creator).</p>

    <p class="text-gray-300">The proof of work protects a block against tampering and also ensures that meaningful computational resources were devoted to finding it. This prevents a sybil attack since all the sybils share the same total computational resources (e.g., the server they are virtualized on). Bitcoin assumes that provided more than half the computational work is held by honest nodes, the block-chain is secure. (Though recent work <a href="#page-54-20">[ES13]</a> has suggested that the threshold may be larger than 50%.)</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Zerocoin</h3>

    <p class="text-gray-300">Zerocoin extends Bitcoin by creating two new transaction types: mint and spend. A mint transaction allows a user to exchange a quantity of bitcoins for the right to mint a new zerocoin. Each zerocoin consists of a digital commitment cm to a random serial number sn. At a later point, a (potentially different) user may issue a spend transaction containing a destination identity, the serial number sn, and a non-interactive zero-knowledge proof for the NP statement &quot;I know secret cm and r such that (i) cm can be opened to sn with commitment randomness r, and (ii) cm was previously minted at some point in the past&quot;. Crucially, the proof, being zero knowledge, does not link the spend transaction to any particular mint transaction (among all mint transactions so far). If the proof verifies correctly and the serial number has not been spent previously, the protocol semantics transfer a corresponding amount of bitcoins to the destination address. In this fashion, Zerocoin functions as a decentralized mix.</p>

    <p class="text-gray-300">Zerocoin uses Pedersen commitments over a prime field  <span class="math">\\mathbb{F}_p</span> , i.e.,  <span class="math">\\mathsf{cm} := g^{\\mathsf{sn}} h^r</span> , for random generators g,h of a subgroup of  <span class="math">\\mathbb{F}_p^*</span> . The corresponding zero-knowledge proofs are constructed by first accumulating (via the Strong-RSA accumulator of [CL01]) the set of commitments of all minted zerocoins, and then proving knowledge of the corresponding commitment randomness and membership in this set. For technical reasons, the proof requires a double-discrete-logarithm (DDL) Fiat-Shamir proof of size  <span class="math">\\approx |p|\\lambda</span> , where  <span class="math">\\lambda</span>  is the security parameter. In practice, the size of these proofs exceeds 45 kB at the 128-bit security level, and require 450 ms or more to verify.</p>

    <p class="text-gray-300">Also note that, in Zerocoin, computing the witness for the accumulator requires access to the <em>entire</em> set of commitments so far (though the witness can be incrementally updated for each insertion). This technique supports an unlimited number of coins. In contrast, our construction places a cap N on the number of coins (in our implementation,  <span class="math">N=2^{64}</span> ) but needs only  <span class="math">\\log N</span>  updates to issue N new coins (and these updates can be efficiently batched, cf. Section 8.3.1).</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Completeness of DAP schemes</h2>

    <p class="text-gray-300">A DAP scheme  <span class="math">\\Pi = (\\mathsf{Setup}, \\mathsf{CreateAddress}, \\mathsf{Mint}, \\mathsf{Pour}, \\mathsf{VerifyTransaction}, \\mathsf{Receive})</span>  is <strong>complete</strong> if no polynomial-size ledger sampler  <span class="math">\\mathcal S</span>  can win the incompleteness experiment with more than negligible probability. In Section 3.4 we informally described this property; we now formally define it.</p>

    <p class="text-gray-300"><strong>Definition B.1.</strong> Let  <span class="math">\\Pi = (\\mathsf{Setup}, \\mathsf{CreateAddress}, \\mathsf{Mint}, \\mathsf{Pour}, \\mathsf{VerifyTransaction}, \\mathsf{Receive})</span>  be a (candidate) DAP scheme. We say that  <span class="math">\\Pi</span>  is <strong>complete</strong> if, for every  <span class="math">\\mathsf{poly}(\\lambda)</span> -size ledger sampler  <span class="math">\\mathcal S</span>  and sufficiently large  <span class="math">\\lambda</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{INCOMP}}_{\\Pi,\\mathcal{S}}(\\lambda) &lt; \\mathrm{negl}(\\lambda) \\ ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{Adv}_{\\Pi,\\mathcal{S}}^{\\mathsf{INCOMP}}(\\lambda) := \\Pr[\\mathsf{INCOMP}(\\Pi,\\mathcal{S},\\lambda) = 1]</span>  is  <span class="math">\\mathcal{S}</span> 's advantage in the incompleteness experiment.</p>

    <p class="text-gray-300">We now describe the incompleteness experiment mentioned above. Given a (candidate) DAP scheme  <span class="math">\\Pi</span> , a ledger sampler  <span class="math">\\mathcal{S}</span> , and a security parameter  <span class="math">\\lambda</span> , the (probabilistic) experiment INCOMP( <span class="math">\\Pi</span> ,  <span class="math">\\mathcal{S}</span> ,  <span class="math">\\lambda</span> ) consists of an interaction between  <span class="math">\\mathcal{S}</span>  and a challenger  <span class="math">\\mathcal{C}</span> , terminating with a binary output by  <span class="math">\\mathcal{C}</span> .</p>

    <p class="text-gray-300">At the beginning of the experiment,  <span class="math">\\mathcal{C}</span>  samples  <span class="math">\\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^\\lambda)</span>  and sends  <span class="math">\\mathsf{pp}</span>  to  <span class="math">\\mathcal{S}</span> . Then,  <span class="math">\\mathcal{S}</span>  sends  <span class="math">\\mathcal{C}</span>  a ledger, two coins to be spent, and parameters for a pour transaction; more precisely,  <span class="math">\\mathcal{S}</span>  sends (1) a ledger L; (2) two coins  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{old}}</span> ; (3) two address secret keys  <span class="math">\\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{old}}</span> ,  <span class="math">\\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}}</span> ; (4) two values  <span class="math">v_1^{\\mathsf{new}}</span> ,  <span class="math">v_2^{\\mathsf{new}}</span> ; (5) new address key pairs  <span class="math">(\\mathsf{addr}_{\\mathsf{pk},1}^{\\mathsf{new}}, \\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{new}})</span> ,  <span class="math">(\\mathsf{addr}_{\\mathsf{pk},2}^{\\mathsf{new}}, \\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{new}})</span> ; (6) a public value  <span class="math">v_{\\mathsf{pub}}</span> ; and (7) a transaction string info. Afterwards,  <span class="math">\\mathcal{C}</span>  performs various checks on  <span class="math">\\mathcal{S}</span> 's message.</p>

    <p class="text-gray-300">Concretely,  <span class="math">\\mathcal{C}</span>  first checks that  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}</span>  and  <span class="math">\\mathbf{c}_2^{\\mathsf{old}}</span>  are valid unspent coins, i.e., checks that: (i)  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}</span>  and  <span class="math">\\mathbf{c}_2^{\\mathsf{old}}</span>  are well-formed; (ii) their coin commitments  <span class="math">\\mathsf{cm}_1^{\\mathsf{old}}</span>  and  <span class="math">\\mathsf{cm}_2^{\\mathsf{old}}</span>  appear in (valid) transactions on L; (iii) their serial numbers  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}}</span>  and  <span class="math">\\mathsf{sn}_2^{\\mathsf{old}}</span>  do not appear in (valid) transactions on L. Next,  <span class="math">\\mathcal{C}</span>  checks that  <span class="math">v_1^{\\mathsf{new}} + v_2^{\\mathsf{new}} + v_{\\mathsf{pub}} = v_1^{\\mathsf{old}} + v_2^{\\mathsf{old}}</span>  (i.e., the values suggested by  <span class="math">\\mathcal{S}</span>  preserve balance) and  <span class="math">v_1^{\\mathsf{old}} + v_2^{\\mathsf{old}} \\leq v_{\\mathsf{max}}</span>  (i.e., the maximum value is not exceeded). If any of these checks fail,  <span class="math">\\mathcal{C}</span>  aborts and outputs 0.</p>

    <p class="text-gray-300">Otherwise, C computes rt, the Merkle-tree root over all coin commitments in L (appearing in valid transactions), and, for  <span class="math">i \\in \\{1, 2, \\}</span> ,  <span class="math">\\mathsf{path}_i</span> , the authentication path from commitment  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  to the root rt. Then, C attempts to spend  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{old}}</span>  as instructed by S:</p>

    <p class="text-gray-300"><span class="math">$(\\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}, \\mathsf{tx}_{\\mathsf{Pour}}) \\leftarrow \\mathsf{Pour}(\\mathsf{pp}, \\mathsf{rt}, \\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk}, 1}^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk}, 2}^{\\mathsf{old}}, \\mathsf{path}_1, \\mathsf{path}_2, v_1^{\\mathsf{new}}, v_2^{\\mathsf{new}}, \\mathsf{addr}_{\\mathsf{pk}, 1}^{\\mathsf{new}}, \\mathsf{addr}_{\\mathsf{pk}, 2}^{\\mathsf{new}}, \\mathsf{info}) \\ .</span>$</p>

    <p class="text-gray-300">Finally, C outputs 1 if and only if any of the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathsf{tx}_{\\mathsf{Pour}} \\neq (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}, *)</span> , where  <span class="math">\\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}</span>  are the coin commitments of  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}</span> ; OR</li>
      <li><span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  is not valid, i.e.,  <span class="math">\\mathsf{VerifyTransaction}(\\mathsf{pp}, \\mathsf{tx}_{\\mathsf{Pour}}, L)</span>  outputs 0; OR</li>
      <li>for some  <span class="math">i \\in \\{1, 2\\}</span> , the coin  <span class="math">\\mathbf{c}_i^{\\mathsf{new}}</span>  is not returned by Receive(pp, (addr_{\\mathsf{pk},i}^{\\mathsf{new}}, \\mathsf{addr}_{\\mathsf{sk},i}^{\\mathsf{new}}), L'), where L' is the ledger obtained by appending  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  to L.</li>
    </ul>

    <p class="text-gray-300"><strong>Remark.</strong> There is no need for the challenger  <span class="math">\\mathcal{C}</span>  check that, in turn, both  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>  and  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span>  are spendable, because this follows by induction. Namely, if  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span> ,  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span>  were not spendable, a different sampler  <span class="math">\\mathcal{S}&#x27;</span>  (that simulates  <span class="math">\\mathcal{S}</span>  and then computes and outputs  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>  and  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span> ) would provide a counterexample to the above definition.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Security of DAP schemes</h2>

    <p class="text-gray-300">A DAP scheme  <span class="math">\\Pi = (\\text{Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive})</span>  is secure if it satisfies ledger indistinguishability, transaction non-malleability, and balance. (See Definition 3.2.) In Section 3.4 we informally described these three properties; we now formally define them.</p>

    <p class="text-gray-300">Each of the definitions employs an experiment involving a (stateful) DAP oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  that receives and answers queries from an adversary  <span class="math">\\mathcal{A}</span>  (proxied via a challenger  <span class="math">\\mathcal{C}</span> , which performs the experiment-specific sanity checks). Below, we first describe how  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  works.</p>

    <p class="text-gray-300">The oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  is initialized by a list of public parameters  <span class="math">\\mathsf{pp}</span>  and maintains state. Internally,  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  stores: (i) L, a ledger; (ii) ADDR, a set of address key pairs; (iii) COIN, a set of coins. All of L, ADDR, COIN start out empty. The oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  accepts different types of queries, and each query causes different updates to L, ADDR, COIN and outputs. We now describe each type of query Q.</p>

    <h4 id="sec-misc-14" class="text-lg font-semibold mt-6">&bull; Q = (CreateAddress)</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">(addr_{pk}, addr_{sk}) := CreateAddress(pp)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add the address key pair (addr<sub>pk</sub>, addr<sub>sk</sub>) to ADDR.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the address public key addr<sub>pk</sub>.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The ledger L and coin set COIN remain unchanged.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">Q = (\\mathbf{Mint}, v, \\mathsf{addr}_{\\mathsf{pk}})</span>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">(\\mathbf{c}, \\mathsf{tx}_{\\mathsf{Mint}}) := \\mathsf{Mint}(\\mathsf{pp}, v, \\mathsf{addr}_{\\mathsf{pk}}).</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add the coin  <span class="math">\\mathbf{c}</span>  to COIN.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add the mint transaction  <span class="math">tx_{Mint}</span>  to L.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\perp</span> .</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The address set ADDR remains unchanged.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">\\bullet \\ \\ Q = (\\mathbf{Pour}, \\mathsf{idx}^{\\mathsf{old}}_1, \\mathsf{idx}^{\\mathsf{old}}_2, \\mathsf{addr}^{\\mathsf{old}}_{\\mathsf{pk}, 1}, \\mathsf{addr}^{\\mathsf{old}}_{\\mathsf{pk}, 2}, \\mathsf{info}, v_1^{\\mathsf{new}}, v_2^{\\mathsf{new}}, \\mathsf{addr}^{\\mathsf{new}}_{\\mathsf{pk}, 1}, \\mathsf{addr}^{\\mathsf{new}}_{\\mathsf{pk}, 2}, v_{\\mathsf{pub}})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute rt, the root of a Merkle tree over all coin commitments in L.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">i \\in \\{1, 2\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Let  <span class="math">cm_i^{old}</span>  be the  <span class="math">idx_i^{old}</span> -th coin commitment in L.</li>
    </ul></li>
    </ul></li>
      <li><p class="text-gray-300">(b) Let  <span class="math">tx_i</span>  be the mint/pour transaction in L that contains  <span class="math">cm_i^{old}</span> .</p></li>
      <li><p class="text-gray-300">(c) Let  <span class="math">\\mathbf{c}_{i}^{\\text{old}}</span>  be the first coin in COIN with coin commitment  <span class="math">\\mathsf{cm}_{i}^{\\text{old}}</span> . (d) Let  <span class="math">(\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{old}},\\mathsf{addr}_{\\mathsf{sk},i}^{\\mathsf{old}})</span>  be the first key pair in ADDR with  <span class="math">\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{old}}</span>  being  <span class="math">\\mathbf{c}_{i}^{\\mathsf{old}}</span> 's address.</p></li>
      <li><p class="text-gray-300">(e) Compute  <span class="math">\\mathsf{path}_i</span> , the authentication path from  <span class="math">\\mathsf{cm}_i^\\mathsf{old}</span>  to rt.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">(\\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}}, \\mathsf{tx}_{\\mathsf{Pour}}) := \\mathsf{Pour}(\\mathsf{pp}, \\mathsf{rt}, \\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}}, \\mathsf{path}_1, \\mathsf{path}_2, v_1^{\\mathsf{new}}, v_2^{\\mathsf{new}}, \\mathsf{addr}_{\\mathsf{pk},1}^{\\mathsf{new}}, \\mathsf{addr}_{\\mathsf{pk},2}^{\\mathsf{new}}, v_{\\mathsf{pub}}, \\mathsf{info}).</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify that VerifyTransaction(pp,  <span class="math">tx_{Pour}, L</span> ) outputs 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add the coin  <span class="math">\\mathbf{c}_1^{\\mathsf{new}}</span>  to COIN.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add the coin  <span class="math">\\mathbf{c}_2^{\\mathsf{new}}</span>  to COIN.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add the pour transaction  <span class="math">tx_{Pour}</span>  to L.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\perp</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If any of the above operations fail, the output is  <span class="math">\\perp</span>  (and L, ADDR, COIN remain unchanged).</p>

    <h2 id="sec-misc-15" class="text-2xl font-bold">&bull; <span class="math">Q = (\\mathbf{Receive}, \\mathsf{addr}_{\\mathsf{pk}})</span></h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Look up (addr<sub>pk</sub>, addr<sub>sk</sub>) in ADDR. (If no such key pair is found, abort.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">(\\mathbf{c}_1, \\dots, \\mathbf{c}_n) \\leftarrow \\mathsf{Receive}(\\mathsf{pp}, (\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}}), L)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add  <span class="math">\\mathbf{c}_1, \\ldots, \\mathbf{c}_n</span>  to COIN.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">(cm_1, \\ldots, cm_n)</span> , the corresponding coin commitments.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The ledger L and address set ADDR remain unchanged.</p>

    <h3 id="sec-misc-16" class="text-xl font-semibold mt-8">&bull; <span class="math">Q = (\\mathbf{Insert}, \\mathsf{tx})</span></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify that VerifyTransaction(pp, tx, L) outputs 1. (Else, abort.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add the mint/pour transaction tx to L.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run Receive for all addresses addr<sub>pk</sub> in ADDR; this updates the COIN with any coins that might have been sent to honest parties via tx.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\perp</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The address set ADDR remains unchanged.</p>

    <p class="text-gray-300"><strong>Remark.</strong> The oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  provides  <span class="math">\\mathcal{A}</span>  with two ways to cause a pour transaction to be added to L. If A has already obtained address public keys  <span class="math">\\mathsf{addr}_{\\mathsf{pk},1}</span>  and  <span class="math">\\mathsf{addr}_{\\mathsf{pk},2}</span>  (via previous  <span class="math">\\mathsf{CreateAddress}</span> queries), then A can use a <strong>Pour</strong> query to elicit a pour transaction  <span class="math">tx_{Pour}</span>  (despite not knowing address secret keys  <span class="math">addr_{sk,1}</span> ,  <span class="math">addr_{sk,2}</span>  corresponding to  <span class="math">addr_{pk,1}</span> ,  <span class="math">addr_{pk,2}</span> ). Alternatively, if A has himself generated both address public keys, then  <span class="math">\\mathcal{A}</span>  knows corresponding address secret keys, and can invoke Pour &quot;in his head&quot; to obtain a pour transaction  <span class="math">tx_{Pour}</span> , which he can add to L by using an Insert query. In the first case, both addresses belong to honest users; in the second, both to A.</p>

    <p class="text-gray-300">But what about pour transactions where one address belongs to an honest user and one to A? Such pour transactions might arise from MPC computations (e.g., to make matching donations). The ledger oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span> , as defined above, does not support such queries. While extending the definition is straightforward, for simplicity we leave handling such queries to future work.</p>

    <h4 id="sec-misc-17" class="text-lg font-semibold mt-6">C.1Ledger indistinguishability</h4>

    <p class="text-gray-300">Ledger indistinguishability is characterized by an experiment L-IND, which involves a polynomial-size adversary  <span class="math">\\mathcal{A}</span>  attempting to break a given (candidate) DAP scheme.</p>

    <p class="text-gray-300"><strong>Definition C.1.</strong> Let  <span class="math">\\Pi = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candi</span> date) DAP scheme. We say that  <span class="math">\\Pi</span>  is L-IND secure if, for every poly( <span class="math">\\lambda</span> )-size adversary  <span class="math">\\mathcal{A}</span>  and sufficiently large  <span class="math">\\lambda</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{L-IND}}_{\\Pi,\\mathcal{A}}(\\lambda) &lt; \\mathrm{negl}(\\lambda)</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{Adv}_{\\Pi,A}^{\\mathsf{L-IND}}(\\lambda) := 2 \\cdot \\Pr[\\mathsf{L-IND}(\\Pi,\\mathcal{A},\\lambda) = 1] - 1</span>  is  <span class="math">\\mathcal{A}</span> 's advantage in the  <span class="math">\\mathsf{L-IND}</span>  experiment.</p>

    <p class="text-gray-300">We now describe the L-IND experiment mentioned above. Given a (candidate) DAP scheme  <span class="math">\\Pi</span> , adversary  <span class="math">\\mathcal{A}</span> , and security parameter  <span class="math">\\lambda</span> , the (probabilistic) experiment L-IND( <span class="math">\\Pi</span> ,  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\lambda</span> ) consists of an interaction between  <span class="math">\\mathcal{A}</span>  and a challenger  <span class="math">\\mathcal{C}</span> , terminating with a binary output by  <span class="math">\\mathcal{C}</span> .</p>

    <p class="text-gray-300">At the beginning of the experiment,  <span class="math">\\mathcal{C}</span>  samples  <span class="math">b \\in \\{0,1\\}</span>  at random, samples  <span class="math">\\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\lambda})</span> , and sends  <span class="math">\\mathsf{pp}</span>  to  <span class="math">\\mathcal{A}</span> ; next,  <span class="math">\\mathcal{C}</span>  initializes (using  <span class="math">\\mathsf{pp}</span> ) two separate DAP oracles  <span class="math">\\mathcal{O}_0^{\\mathsf{DAP}}</span>  and  <span class="math">\\mathcal{O}_1^{\\mathsf{DAP}}</span>  (i.e., the two oracles have separate ledgers and internal tables).</p>

    <p class="text-gray-300">The experiment proceeds in steps and, at each step,  <span class="math">\\mathcal{C}</span>  provides to  <span class="math">\\mathcal{A}</span>  two ledgers  <span class="math">(L_{\\mathsf{Left}}, L_{\\mathsf{Right}})</span> , where  <span class="math">L_{\\mathsf{Left}} := L_b</span>  is the current ledger in  <span class="math">\\mathcal{O}_b^{\\mathsf{DAP}}</span>  and  <span class="math">L_{\\mathsf{Right}} := L_{1-b}</span>  the one in  <span class="math">\\mathcal{O}_{1-b}^{\\mathsf{DAP}}</span> ; then  <span class="math">\\mathcal{A}</span>  sends to  <span class="math">\\mathcal{C}</span>  a pair of queries (Q, Q'), which must be of the <em>same</em> type (i.e., one of <strong>CreateAddress</strong>, <strong>Mint</strong>, <strong>Pour</strong>, <strong>Receive</strong>, <strong>Insert</strong>). The challenger  <span class="math">\\mathcal{C}</span>  acts differently depending on the query type, as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If the query type is <strong>Insert</strong>, C forwards Q to  <span class="math">\\mathcal{O}_b^{\\mathsf{DAP}}</span> , and Q' to  <span class="math">\\mathcal{O}_{1-b}^{\\mathsf{DAP}}</span> . This allows A to insert his own transactions directly in  <span class="math">L_{\\mathsf{Left}}</span>  and  <span class="math">L_{\\mathsf{Right}}</span> .</li>
      <li>For any other query type, C first ensures that Q, Q' are publicly consistent (see below) and then forwards Q to  <span class="math">\\mathcal{O}_0^{\\mathsf{DAP}}</span> , and Q' to  <span class="math">\\mathcal{O}_1^{\\mathsf{DAP}}</span> ; letting  <span class="math">(a_0, a_1)</span>  be the two oracle answers, C replies to A with  <span class="math">(a_b, a_{1-b})</span> . This allows A to elicit behavior from honest users. However note that A does not know the bit b, and hence the mapping between  <span class="math">(L_{\\mathsf{Left}}, L_{\\mathsf{Right}})</span>  and  <span class="math">(L_0, L_1)</span> ; in other words, A does not know if he elicits behavior on  <span class="math">(L_0, L_1)</span>  or on  <span class="math">(L_1, L_0)</span> .</li>
    </ul>

    <p class="text-gray-300">At the end of the experiment,  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathcal{C}</span>  a guess  <span class="math">b&#x27; \\in \\{0,1\\}</span> . If b = b',  <span class="math">\\mathcal{C}</span>  outputs 1; else,  <span class="math">\\mathcal{C}</span>  outputs 0.</p>

    <p class="text-gray-300"><strong>Public consistency.</strong> As mentioned above,  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathcal{C}</span>  pairs of queries (Q, Q'), which must be of the same type and publicly consistent, a property that we now define. If Q, Q' are both of type <strong>CreateAddress</strong> or <strong>Receive</strong>, then they are always publicly consistent. In the special case of <strong>CreateAddress</strong> we require that both oracles generate the same address. If they are both of type <strong>Mint</strong>, then the minted value in Q must equal that in Q'. Finally, if they are both of type <strong>Pour</strong>, the following restrictions apply.</p>

    <p class="text-gray-300">First, Q, Q' must be individually well-formed; namely, (i) the coin commitments referenced by Q (via the two indices  <span class="math">\\mathrm{id} \\mathsf{x}_1^{\\mathsf{old}}, \\mathrm{id} \\mathsf{x}_2^{\\mathsf{old}}</span> ) must correspond to coins  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span>  that appear in the ledger oracle's coin table COIN; (ii) the two coins  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span>  must be unspent (i.e. their serial numbers must not appear in a valid pour transactions on the corresponding oracle's ledger); (iii) the address public keys specified in Q must match those in  <span class="math">\\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}</span> ; and (iv) the balance equation must hold (i.e.,  <span class="math">v_1^{\\mathsf{new}} + v_2^{\\mathsf{new}} + v_{\\mathsf{pub}} = v_1^{\\mathsf{old}} + v_2^{\\mathsf{old}}</span> ).</p>

    <p class="text-gray-300">Furthermore, Q, Q' must be jointly consistent with respect to public information and  <span class="math">\\mathcal{A}</span> 's view; namely: (i) the public values in Q and Q' must equal; (ii) the transaction strings in Q and Q' must equal; (iii) for each  <span class="math">i \\in \\{1,2\\}</span> , if the i-th recipient addresses in Q is not in ADDR (i.e., belongs to  <span class="math">\\mathcal{A}</span> ) then  <span class="math">v_i^{\\mathsf{new}}</span>  in  <span class="math">both \\ Q</span>  and Q' must equal (and vice versa for Q'); and (iv) for each  <span class="math">i \\in \\{1,2\\}</span> , if the i-th index in Q references (in  <span class="math">L_0</span> ) a coin commitment contained in a transaction that was posted via an <strong>Insert</strong> query, then the corresponding index in Q' must reference (in  <span class="math">L_1</span> ) a coin commitment that also appears in a transaction posted via an <strong>Insert</strong> query and, moreover,  <span class="math">v_i^{\\mathsf{old}}</span>  in  <span class="math">both \\ Q</span>  and Q' must equal (and vice versa for Q'). The challenger  <span class="math">\\mathcal{C}</span>  learns  <span class="math">v_i^{\\mathsf{old}}</span>  by looking-up the corresponding coin  <span class="math">\\mathbf{c}_i^{\\mathsf{old}}</span>  in the oracle's coin set COIN. (v) for each  <span class="math">i \\in \\{1,2\\}</span>  if the i-th index in Q must not reference a coin that has previously been spent.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 Transaction non-malleability</h3>

    <p class="text-gray-300">Transaction non-mall eability is characterized by an experiment TR-NM, which involves a polynomialsize adversary  <span class="math">\\mathcal{A}</span>  attempting to break a given (candidate) DAP scheme. Definition C.2. Let &Pi; = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candidate) DAP scheme. We say that &Pi; is TR-NM secure if, for every poly(&lambda;)-size adversary A and sufficiently large &lambda;,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}_{\\Pi,\\mathcal{A}}^{\\mathsf{TR}\\text{-}\\mathsf{NM}}(\\lambda) &lt; \\mathrm{negl}(\\lambda) \\enspace,</span>$</p>

    <p class="text-gray-300">where AdvTR-NM <sup>&Pi;</sup>,<sup>A</sup> (&lambda;) := Pr[TR-NM(&Pi;, A, &lambda;) = 1] is A's advantage in the TR-NM experiment.</p>

    <p class="text-gray-300">We now describe the TR-NM experiment mentioned above. Given a (candidate) DAP scheme &Pi;, adversary A, and security parameter &lambda;, the (probabilistic) experiment TR-NM(&Pi;, A, &lambda;) consists of an interaction between A and a challenger C, terminating with a binary output by C.</p>

    <p class="text-gray-300">At the beginning of the experiment, C samples pp &larr; Setup(1<sup>&lambda;</sup> ) and sends pp to A; next, C initializes a DAP oracle ODAP with pp and allows A to issue queries to ODAP. At the end of the experiment, A sends C a pour transaction tx<sup>&lowast;</sup> , and C outputs 1 if and only if the following conditions hold. Letting T be the set of pour transactions generated by ODAP in response to Pour queries, there exists tx &isin; T such that: (i) tx<sup>&lowast;</sup> =6 tx; (ii) VerifyTransaction(pp,tx<sup>&lowast;</sup> , L<sup>0</sup> ) = 1, where L 0 is the portion of the ledger preceding tx; <a href="#page-42-1">27</a> and (iii) a serial number revealed in tx<sup>&lowast;</sup> is also revealed in tx.</p>

      <h3 id="app-c.3" class="text-xl font-semibold mt-8">C.3 Balance</h3>

    <p class="text-gray-300">Balance is characterized by an experiment BAL, which involves a polynomial-size adversary A attempting to break a given (candidate) DAP scheme.</p>

    <p class="text-gray-300">Definition C.3. Let &Pi; = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candidate) DAP scheme. We say that &Pi; is BAL secure if, for every poly(&lambda;)-size adversary A and sufficiently large &lambda;,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{BAL}}_{\\Pi,\\mathcal{A}}(\\lambda) &lt; \\mathrm{negl}(\\lambda)</span>$
,</p>

    <p class="text-gray-300">where AdvBAL <sup>&Pi;</sup>,A(&lambda;) := Pr[BAL(&Pi;, A, &lambda;) = 1] is A's advantage in the BAL experiment.</p>

    <p class="text-gray-300">We now describe the BAL experiment mentioned above. Given a (candidate) DAP scheme &Pi;, adversary A, and security parameter &lambda;, the (probabilistic) experiment BAL(&Pi;, A, &lambda;) consists of an interaction between A and a challenger C, terminating with a binary output by C.</p>

    <p class="text-gray-300">At the beginning of the experiment, C samples pp &larr; Setup(1<sup>&lambda;</sup> ), and sends pp to A; next, C (using pp) initializes a DAP oracle ODAP and allows A to issue queries to ODAP. At the conclusion of the experiment, A sends C a set of coins Scoin. Recalling that ADDR is the set of addresses returned by CreateAddress queries (i.e., addresses of &quot;honest&quot; users), C computes the following five quantities.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>vUnspent, the total value of all spendable coins in Scoin. The challenger C can check if a coin c &isin; Scoin is spendable as follows: mint a fresh coin c <sup>0</sup> of value 0 (via a Mint query) and check if a corresponding Pour query consuming c, c <sup>0</sup> yields a pour transaction txPour that is valid.</li>
      <li>vMint, the total value of all coins minted by A. To compute vMint, the challenger C sums up the values of all coins that (i) were minted via Mint queries using addresses not in ADDR, or (ii) whose mint transactions were directly placed on the ledger via Insert queries.</li>
      <li>vADDR&rarr;A, the total value payments received by A from addresses in ADDR. To compute vADDR&rarr;A, the challenger C looks up all pour transactions placed on the ledger via Pour queries and sums up the values that were transferred to addresses not in ADDR.</li>
    </ul>

    <p class="text-gray-300"><sup>27</sup>That is, L 0 is the longest ledger prefix that can be used to spend at least one of the coins spent in tx.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">v_{\\mathcal{A}\\to\\mathsf{ADDR}}</span> , the total value of payments sent by  <span class="math">\\mathcal{A}</span>  to addresses in ADDR. To compute  <span class="math">v_{\\mathcal{A}\\to\\mathsf{ADDR}}</span> , the challenger  <span class="math">\\mathcal{C}</span>  first deduces the set  <span class="math">S&#x27;\\subseteq\\mathsf{COIN}</span>  of all coins received by honest parties and then sums up the values of coins in S'. (Note that  <span class="math">\\mathcal{C}</span>  can compute S' by selecting all coins in COIN that are both tied to an address in ADDR and arose from transactions placed on the ledger by Insert queries.)</li>
      <li><span class="math">v_{\\mathsf{Basecoin}}</span> , the total value of public outputs placed by  <span class="math">\\mathcal{A}</span>  on the ledger. To compute  <span class="math">v_{\\mathsf{Basecoin}}</span> , the challenger  <span class="math">\\mathcal{C}</span>  looks up all pour transactions placed on the ledger by <strong>Insert</strong> and sums up the corresponding  <span class="math">v_{\\mathsf{pub}}</span>  values.</li>
    </ul>

    <p class="text-gray-300">At the end of the experiment, C outputs 1 if  <span class="math">v_{\\mathsf{Unspent}} + v_{\\mathsf{Basecoin}} + v_{\\mathcal{A} \\to \\mathsf{ADDR}} &gt; v_{\\mathsf{Mint}} + v_{\\mathsf{ADDR} \\to \\mathcal{A}}</span> ; else, C outputs 0.</p>

    <p class="text-gray-300"><strong>Remark.</strong> There are two methods for  <span class="math">\\mathcal{A}</span>  to spend more public-output money than he owns: (i) by directly inserting transactions on the ledger, and (ii) by asking honest parties to create such transactions. The first method is accounted for in the computation of  <span class="math">v_{\\mathsf{Basecoin}}</span> , while the second method is accounted for in the computation of  <span class="math">v_{\\mathcal{A}\\to\\mathsf{ADDR}}</span>  (since  <span class="math">\\mathcal{A}</span>  must first pay the honest party).</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Proof of Theorem 4.1</h2>

    <p class="text-gray-300">We prove Theorem 4.1. We omit a formal proof of the completeness claim; one can verify that the DAP scheme's completeness follows, in a straightforward way, from the completeness of the construction's building blocks. Next, we argue security via three separate proofs, respectively showing that our construction satisfies (i) ledger indistinguishability, (ii) transaction non-malleability, and (iii) balance.</p>

      <h3 id="app-d.1" class="text-xl font-semibold mt-8">D.1 Proof of ledger indistinguishability</h3>

    <p class="text-gray-300">We describe a simulation  <span class="math">\\mathcal{D}_{\\mathsf{sim}}</span>  in which the adversary  <span class="math">\\mathcal{A}</span>  interacts with a challenger  <span class="math">\\mathcal{C}</span> , as in the L-IND experiment. However  <span class="math">\\mathcal{D}_{\\mathsf{sim}}</span>  differs from the L-IND experiment in a critical way: all answers sent to  <span class="math">\\mathcal{A}</span>  are computed <em>independently</em> of the bit b, so that  <span class="math">\\mathcal{A}</span> 's advantage in  <span class="math">\\mathcal{D}_{\\mathsf{sim}}</span>  is 0. The remainder of the proof is devoted to showing that  <span class="math">\\mathsf{Adv}^{\\mathsf{L-IND}}_{\\Pi,\\mathcal{A}}(\\lambda)</span>  (i.e.,  <span class="math">\\mathcal{A}</span> 's advantage in the L-IND experiment) is at most negligibly different than  <span class="math">\\mathcal{A}</span> 's advantage in  <span class="math">\\mathcal{D}_{\\mathsf{sim}}</span> .</p>

    <p class="text-gray-300">The simulation. The simulation  <span class="math">\\mathcal{D}_{\\mathsf{sim}}</span>  works as follows. First, after sampling  <span class="math">b \\in \\{0, 1\\}</span>  at random,  <span class="math">\\mathcal{C}</span>  samples  <span class="math">\\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\lambda})</span> , with the following modification: the zk-SNARK keys are generated as  <span class="math">(\\mathsf{pk}_{\\mathsf{POUR}}, \\mathsf{vk}_{\\mathsf{POUR}}, \\mathsf{trap}) \\leftarrow \\mathsf{Sim}(1^{\\lambda}, C_{\\mathsf{POUR}})</span> , to obtain the zero-knowledge trapdoor trap. Then, as in the L-IND experiment,  <span class="math">\\mathcal{C}</span>  sends  <span class="math">\\mathsf{pp}</span>  to  <span class="math">\\mathcal{A}</span> , and then initializes two separate DAP oracles  <span class="math">\\mathcal{O}_0^{\\mathsf{DAP}}</span>  and  <span class="math">\\mathcal{O}_1^{\\mathsf{DAP}}</span> .</p>

    <p class="text-gray-300">Afterwards, as in L-IND,  <span class="math">\\mathcal{D}_{sim}</span>  proceeds in steps and, at each step,  <span class="math">\\mathcal{C}</span>  provides to  <span class="math">\\mathcal{A}</span>  two ledgers  <span class="math">(L_{Left}, L_{Right})</span> , where  <span class="math">L_{Left} := L_b</span>  is the current ledger in  <span class="math">\\mathcal{O}_b^{DAP}</span>  and  <span class="math">L_{Right} := L_{1-b}</span>  the one in  <span class="math">\\mathcal{O}_{1-b}^{DAP}</span> ; then  <span class="math">\\mathcal{A}</span>  sends to  <span class="math">\\mathcal{C}</span>  a message (Q, Q'), which consist of two (publicly-consistent) queries of the same type. The challenger  <span class="math">\\mathcal{C}</span>  acts differently depending on the query type, as follows.</p>

    <p class="text-gray-300">&bull; Answering CreateAddress queries. In this case, Q = Q' = CreateAddress.</p>

    <p class="text-gray-300">To answer Q, C behaves as in L-IND, except for the following modification: after obtaining  <span class="math">(\\mathsf{addr}_{\\mathsf{pk}}, \\mathsf{addr}_{\\mathsf{sk}}) \\leftarrow \\mathsf{CreateAddress}(\\mathsf{pp})</span> , C replaces  <span class="math">a_{\\mathsf{pk}}</span>  in  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>  with a random string of the appropriate length; then, C stores  <span class="math">\\mathsf{addr}_{\\mathsf{sk}}</span>  in a table and returns  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span>  to A.</p>

    <p class="text-gray-300">Afterwards,  <span class="math">\\mathcal{C}</span>  does the same for Q'.</p>

    <p class="text-gray-300">&bull; Answering Mint queries. In this case,  <span class="math">Q = (\\mathbf{Mint}, v, \\mathsf{addr}_{\\mathsf{pk}})</span>  and  <span class="math">Q&#x27; = (\\mathbf{Mint}, v, \\mathsf{addr}&#x27;_{\\mathsf{pk}})</span> .</p>

    <p class="text-gray-300">To answer Q, C behaves as in L-IND, except for the following modification: the Mint algorithm computes the commitment k as  <span class="math">\\mathsf{COMM}_r(\\tau\\|\\rho)</span> , for a random string  <span class="math">\\tau</span>  of the appropriate length, instead of as  <span class="math">\\mathsf{COMM}_r(a_{\\mathsf{pk}}\\|\\rho)</span> , where  <span class="math">a_{\\mathsf{pk}}</span>  is the value specified in  <span class="math">\\mathsf{addr}_{\\mathsf{pk}}</span> .</p>

    <p class="text-gray-300">Afterwards, C does the same for Q'.</p>

    <p class="text-gray-300">&bull; Answering Pour queries. In this case, Q and Q' both have the form (Pour, cm<sub>1</sub><sup>old</sup>, cm<sub>2</sub><sup>old</sup>, addr<sub>pk,1</sub><sup>old</sup>, addr<sub>pk,2</sub><sup>old</sup>, info,  <span class="math">v_1^{\\text{new}}</span> ,  <span class="math">v_2^{\\text{new}}</span> , addr<sub>pk,2</sub><sup>new</sup>,  <span class="math">v_{\\text{pub}}^{\\text{new}}</span> ).</p>

    <p class="text-gray-300">To answer Q, C modifies the way some values are computed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\mathsf{rt}_i</span>  by accumulating all of the valid coin commitments on  <span class="math">L_i</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">v_{\\sf pub}</span>  and info to the corresponding input values.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">j \\in \\{1, 2\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Sample a uniformly random  <span class="math">sn_i^{old}</span> .</li>
      <li>(b) If  <span class="math">\\mathsf{addr}_{\\mathsf{pk},j}^{\\mathsf{new}}</span>  is an address generated by a previous query to  <span class="math">\\mathsf{CreateAddress}</span> , (i) sample a coin commitment  <span class="math">\\mathsf{cm}_{j}^{\\mathsf{new}}</span>  on a random input, (ii) run  <span class="math">\\mathcal{K}_{\\mathsf{enc}}(\\mathsf{pp}_{\\mathsf{enc}}) \\to (\\mathsf{pk}_{\\mathsf{enc}}, \\mathsf{sk}_{\\mathsf{enc}})</span>  and compute  <span class="math">\\mathsf{C}_{j}^{\\mathsf{new}} := \\mathcal{E}_{\\mathsf{enc}}(\\mathsf{pk}_{\\mathsf{enc}}, r)</span>  for a random r of suitable length.</li>
      <li>(c) Otherwise, calculate  <span class="math">(cm_i^{new}, C_i^{new})</span>  as in the Pour algorithm.<sup>28</sup></li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">h_1</span>  and  <span class="math">h_2</span>  to be random strings of the appropriate length.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute all remaining values as in the Pour algorithm</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The pour proof is computed as  <span class="math">\\pi_{POUR} := Sim(trap, x)</span> , where  <span class="math">x := (rt, sn_1^{old}, sn_2^{old}, cm_1^{new}, cm_2^{new}, v_{pub}, h_1, h_2)</span> . Afterwards, C does the same for Q'.</li>
    </ol></li>
      <li>Answering Receive queries. In this case,  <span class="math">Q = (\\mathbf{Receive}, \\mathsf{addr}_{\\mathsf{pk}})</span>  and  <span class="math">Q&#x27; = (\\mathbf{Receive}, \\mathsf{addr}&#x27;_{\\mathsf{pk}})</span> . The answer to each query proceeds as in the L-IND experiment.</li>
      <li>Answering Insert queries. In this case, Q = (Insert, tx) and Q = (Insert, tx'). The answer to each query proceeds as in the L-IND experiment.</li>
    </ul>

    <p class="text-gray-300">In each of the above cases, the response to  <span class="math">\\mathcal{A}</span>  is computed independently of the bit b. Thus, when  <span class="math">\\mathcal{A}</span>  outputs a guess b', it must be the case that  <span class="math">\\Pr[b=b&#x27;]=1/2</span> , i.e.,  <span class="math">\\mathcal{A}</span> 's advantage in  <span class="math">\\partial_{\\mathsf{sim}}</span>  is 0.</p>

    <p class="text-gray-300">Proof that the simulation is indistinguishable from the real experiment. We now describe a sequence of hybrid experiments  <span class="math">(\\partial_{\\text{real}}, \\partial_1, \\partial_2, \\partial_3, \\partial_{\\text{sim}})</span>  in each of which a challenger  <span class="math">\\mathcal{C}</span>  conducts a modification of the L-IND experiment with  <span class="math">\\mathcal{A}</span> . We define  <span class="math">\\partial_{\\text{real}}</span>  to be the original L-IND experiment, and  <span class="math">\\partial_{\\text{sim}}</span>  to be the simulation described above.</p>

    <p class="text-gray-300">With a slight abuse of notation, given experiment  <span class="math">\\supset</span> , we define  <span class="math">Adv^{\\supset}</span>  to be the absolute value of the difference between (i) the L-IND advantage of  <span class="math">\\mathcal{A}</span>  in  <span class="math">\\supset</span>  and (ii) the L-IND advantage of  <span class="math">\\mathcal{A}</span>  in  <span class="math">\\supset</span> <sub>real</sub>. Also, let</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">q_{CA}</span>  be the total number of CreateAddress queries issued by A,</li>
      <li><span class="math">q_{\\mathbf{P}}</span>  be the total number of <strong>Pour</strong> queries issued by  <span class="math">\\mathcal{A}</span> , and</li>
      <li><span class="math">q_{\\mathbf{M}}</span>  be the total number of <strong>Mint</strong> queries issued by  <span class="math">\\mathcal{A}</span> .</li>
    </ul>

    <p class="text-gray-300">Finally, define  <span class="math">Adv^{Enc}</span>  to be  <span class="math">\\mathcal{A}</span> 's advantage in Enc's IND-CCA and IK-CCA experiments,  <span class="math">Adv^{PRF}</span>  to be  <span class="math">\\mathcal{A}</span> 's advantage in distinguishing the pseudorandom function PRF from a random one, and  <span class="math">Adv^{COMM}</span>  to be  <span class="math">\\mathcal{A}</span> 's advantage against the hiding property of COMM.</p>

    <p class="text-gray-300">We now describe each of the hybrid experiments.</p>

    <p class="text-gray-300">Note that by the restrictions of the experiment, the value  <span class="math">v_i^{\\mathsf{new}}</span>  is identical between  <span class="math">Q_{\\mathsf{Left}}</span>  and  <span class="math">Q_{\\mathsf{Right}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Experiment  <span class="math">\\partial_1</span> . The experiment  <span class="math">\\partial_1</span>  modifies  <span class="math">\\partial_{\\text{real}}</span>  by simulating the zk-SNARKs. More precisely, we modify  <span class="math">\\partial_{\\text{real}}</span>  so that  <span class="math">\\mathcal{C}</span>  simulates each zk-SNARK proof, as follows. At the beginning of the experiment, instead of invoking  <span class="math">\\text{KeyGen}(1^{\\lambda}, C_{\\text{POUR}})</span> ,  <span class="math">\\mathcal{C}</span>  invokes  <span class="math">\\text{Sim}(1^{\\lambda}, C_{\\text{POUR}})</span>  and obtains  <span class="math">(\\text{pk}_{\\text{POUR}}, \\text{vk}_{\\text{POUR}}, \\text{trap})</span> . At each subsequent invocation of the Pour algorithm,  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\pi_{\\text{POUR}} \\leftarrow \\text{Sim}(\\text{trap}, x)</span> , without using any witnesses, instead of using Prove. Since the zk-SNARK system is perfect zero knowledge, the distribution of the simulated  <span class="math">\\pi_{\\text{POUR}}</span>  is identical to that of the proofs computed in  <span class="math">\\partial_{\\text{real}}</span> . Hence  <span class="math">\\text{Adv}^{\\partial_1} = 0</span> .</li>
      <li>Experiment  <span class="math">\\supset_2</span> . The experiment  <span class="math">\\supset_2</span>  modifies  <span class="math">\\supset_1</span>  by replacing the ciphertexts in a pour transaction by encryptions of random strings. More precisely, we modify  <span class="math">\\supset_1</span>  so that, each time  <span class="math">\\mathcal{A}</span>  issues a <strong>Pour</strong> query where one of the output addresses (addr_{pk,1}^{new}, addr_{pk,2}^{new}) is in the set of addresses previously generated by a <strong>CreateAddress</strong> query, the two ciphertexts  <span class="math">\\mathbf{C}_1^{new}</span> ,  <span class="math">\\mathbf{C}_2^{new}</span>  are generated as follows: (i) (pk_enc, sk_enc)  <span class="math">\\leftarrow \\mathcal{K}_{enc}(pp_{enc})</span> ; (ii) for each  <span class="math">j \\in \\{1, 2\\}</span> ,  <span class="math">\\mathbf{C}_j^{new} := \\mathcal{E}_{enc}(pk_{enc,j}^{new}, r)</span>  where r is a message sampled uniformly from the plaintext space of the encryption scheme. By Lemma D.1 (see below),  <span class="math">|\\mathsf{Adv}^{\\supset_2} \\mathsf{Adv}^{\\supset_1}| \\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}</span> .</li>
      <li>Experiment  <span class="math">\\partial_3</span> . The experiment  <span class="math">\\partial_3</span>  modifies  <span class="math">\\partial_2</span>  by replacing all PRF-generated values with random strings. More precisely, we modify  <span class="math">\\partial_2</span>  so that:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>each time  <span class="math">\\mathcal{A}</span>  issues a <strong>CreateAddress</strong> query, the value  <span class="math">a_{pk}</span>  within the returned  <span class="math">\\mathsf{addr}_{pk}</span>  is substituted with a random string of the same length;</li>
      <li>each time  <span class="math">\\mathcal{A}</span>  issues a <strong>Pour</strong> query, each of the serial numbers  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}}</span> ,  <span class="math">\\mathsf{sn}_2^{\\mathsf{old}}</span>  in  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  is substituted with a random string of the same length, and  <span class="math">h_{\\mathsf{info}}</span>  with a random string of the same length.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">By Lemma D.2 (see below),  <span class="math">|\\mathsf{Adv}^{\\circlearrowleft_3} - \\mathsf{Adv}^{\\circlearrowleft_2}| \\leq q_{\\mathbf{CA}} \\cdot \\mathsf{Adv}^{\\mathsf{PRF}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Experiment  <span class="math">\\partial_{sim}</span> . The experiment  <span class="math">\\partial_{sim}</span>  is already described above. For comparison, we explain how it differs from  <span class="math">\\partial_3</span> : the coin commitments are replaced with commitments to random inputs. More precisely, we modify  <span class="math">\\partial_3</span>  so that:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>each time  <span class="math">\\mathcal{A}</span>  issues a <strong>Mint</strong> query, the coin commitment cm in  <span class="math">tx_{\\mathsf{Mint}}</span>  is substituted with a commitment to a random input; and</li>
      <li>each time  <span class="math">\\mathcal{A}</span>  issues a <strong>Pour</strong> query, then, for each  <span class="math">j \\in \\{1, 2\\}</span> , if the output address  <span class="math">\\mathsf{addr}^{\\mathsf{new}}_{\\mathsf{pk}, j}</span>  is in the set of addresses previously generated by an  <span class="math">\\mathsf{CreateAddress}</span>  query,  <span class="math">\\mathsf{cm}^{\\mathsf{new}}_j</span>  is substituted with a commitment to a random input.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">By Lemma D.3 (see below),  <span class="math">|\\mathsf{Adv}^{\\partial_{\\mathsf{sim}}} - \\mathsf{Adv}^{\\partial_{3}}| \\leq (q_{\\mathbf{M}} + 4 \\cdot q_{\\mathbf{P}}) \\cdot \\mathsf{Adv}^{\\mathsf{COMM}}</span> .</p>

    <p class="text-gray-300">As argued above, the responses provided to  <span class="math">\\mathcal{A}</span>  in  <span class="math">\\partial_{\\mathsf{sim}}</span>  are independent of the bit b, so that  <span class="math">\\mathsf{Adv}^{\\partial_{\\mathsf{sim}}} = 0</span> . Then, by summing over  <span class="math">\\mathcal{A}</span> 's advantages in the hybrid experiments, we can bound  <span class="math">\\mathcal{A}</span> 's advantage in  <span class="math">\\partial_{\\mathsf{real}}</span>  by</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{L-IND}}_{\\Pi,\\mathcal{A}}(\\lambda) \\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}} + q_{\\mathbf{C}\\mathbf{A}} \\cdot \\mathsf{Adv}^{\\mathsf{PRF}} + (q_{\\mathbf{M}} + 4 \\cdot q_{\\mathbf{P}}) \\cdot \\mathsf{Adv}^{\\mathsf{COMM}}</span>$</p>

    <p class="text-gray-300">which is negligible in  <span class="math">\\lambda</span> . This concludes the proof of ledger indistinguishability. Below, we sketch proofs for the lemmas used above (Lemma D.1, Lemma D.2, and Lemma D.3).</p>

    <p class="text-gray-300"><strong>Lemma D.1.</strong> Let Adv<sup>Enc</sup> be the maximum of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A's advantage in the IND-CCA experiment against the encryption scheme Enc, and</li>
      <li>A's advantage in the IK-CCA experiment against the encryption scheme Enc.</li>
    </ul>

    <p class="text-gray-300">Then after  <span class="math">q_{\\mathbf{P}}</span>  <strong>Pour</strong> queries,  <span class="math">|\\mathsf{Adv}^{\\partial_2} - \\mathsf{Adv}^{\\partial_1}| \\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}</span> .</p>

    <p class="text-gray-300">Proof sketch. Define  <span class="math">\\epsilon := \\mathsf{Adv}^{\\partial_2} - \\mathsf{Adv}^{\\partial_1}</span> . Using  <span class="math">\\mathcal{A}</span> , we first show how to construct a solver with advantage  <span class="math">\\geq \\frac{\\epsilon}{2 \\cdot q_{\\mathbf{P}}}</span>  in the IK-CCA or IND-CCA experiments. We use a hybrid  <span class="math">\\mathbf{H}</span> , intermediate between  <span class="math">\\partial_1</span>  and  <span class="math">\\partial_2</span> ; concretely,  <span class="math">\\mathbf{H}</span>  modifies  <span class="math">\\partial_1</span>  so that each ciphertext (where the corresponding public key appears in the set generated by a <strong>CreateAddress</strong> query) is replaced with the encryption of the same plaintext, but under a new, random public key generated via the  <span class="math">\\mathcal{K}_{\\mathsf{enc}}</span>  algorithm. (For comparison,  <span class="math">\\partial_2</span>  modifies  <span class="math">\\mathbf{H}</span>  so that each plaintext is replaced with a random plaintext drawn from the plaintext space.) We now argue that  <span class="math">\\mathcal{A}</span> 's advantage in distinguishing  <span class="math">\\mathbf{H}</span>  and  <span class="math">\\partial_1</span>  is at most  <span class="math">2 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}</span> , and so is for distinguishing  <span class="math">\\partial_2</span>  and  <span class="math">\\mathbf{H}</span> . Overall, we deduce that  <span class="math">|\\mathsf{Adv}^{\\partial_2} - \\mathsf{Adv}^{\\partial_1}| \\leq 4 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}</span> .</p>

    <p class="text-gray-300">First, we discuss  <span class="math">\\mathbf{H}</span>  and  <span class="math">\\partial_1</span> . For some  <span class="math">j \\in \\{1, \\dots, q_{\\mathbf{CA}}\\}</span> , when  <span class="math">\\mathcal{A}</span>  makes the j-th query of the form  <span class="math">\\mathbf{CreateAddress}</span> , query the IK-CCA challenger to obtain two public keys  <span class="math">(\\mathsf{pk}_{\\mathsf{enc},0}, \\mathsf{pk}_{\\mathsf{enc},1})</span>  and return  <span class="math">\\mathsf{pk}_{\\mathsf{enc}} := \\mathsf{pk}_{\\mathsf{enc},0}</span>  in the response to  <span class="math">\\mathcal{A}</span> . At the time  <span class="math">\\mathcal{A}</span>  issues a  <span class="math">\\mathbf{Pour}</span>  query that results in the i-th ciphertext  <span class="math">\\mathbf{C}_i</span>  being encrypted under  <span class="math">\\mathsf{pk}_{\\mathsf{enc}}</span> , query the IK-CCA challenger on the corresponding plaintext m and receive  <span class="math">\\mathbf{C}^* = \\mathcal{E}_{\\mathsf{enc}}(\\mathsf{pk}_{\\mathsf{enc},\\bar{b}}, m)</span>  where  <span class="math">\\bar{b}</span>  is the bit chosen by the IK-CCA challenger. Substitute  <span class="math">\\mathbf{C}_i := \\mathbf{C}^*</span>  and write the resulting  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  to the Ledger. When  <span class="math">\\mathcal{A}</span>  outputs b' we return this guess as our guess in the IK-CCA experiment. We note that when  <span class="math">\\bar{b} = 0</span>  then  <span class="math">\\mathcal{A}</span> 's view of the interaction is distributed identically to that of  <span class="math">\\partial_1</span> , and when  <span class="math">\\bar{b}</span>  is 1 then  <span class="math">\\mathcal{A}</span> 's view represents an intermediate hybrid where one key has been substituted. By a standard hybrid argument over each of the  <span class="math">2 \\cdot q_{\\mathbf{P}}</span>  ciphertexts, we note that over the random coins of the experiment, our solver must succeed in the IK-CCA experiment with advantage  <span class="math">\\geq \\frac{\\epsilon}{2 \\cdot q_{\\mathbf{P}}}</span> . If we assume a maximum adversarial advantage  <span class="math">\\mathsf{Adv}^{\\mathsf{Enc}}</span>  against the IK-CCA experiment for the encryption scheme, then we get that  <span class="math">|\\mathsf{Adv}^{\\mathsf{H}} - \\mathsf{Adv}^{\\partial_2}| \\leq 2 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}</span> .</p>

    <p class="text-gray-300">Next, we discuss  <span class="math">\\partial_2</span>  and  <span class="math">\\mathbf{H}</span> ; the argument is similar to the above one. This time, rather than replacing the key used to encrypt, we replace the plaintext with a random message drawn from the plaintext space; this final distribution is the same as in  <span class="math">\\partial_2</span> . We omit the formal description of the resulting IND-CCA solver (which essentially follows the pattern above), and simply note that  <span class="math">|\\mathsf{Adv}^{\\partial_2} - \\mathsf{Adv}^{\\mathbf{H}}| \\leq 2 \\cdot q_{\\mathbf{P}} \\cdot \\mathsf{Adv}^{\\mathsf{Enc}}</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300"><strong>Lemma D.2.</strong> Let  <span class="math">Adv^{PRF}</span>  be  <span class="math">\\mathcal{A}</span> 's advantage in distinguishing the pseudorandom function PRF from a random function. Then, after  <span class="math">q_{\\mathbf{CA}}</span>  CreateAddress queries,  <span class="math">|Adv^{\\partial_3} - Adv^{\\partial_2}| \\leq q_{\\mathbf{CA}} \\cdot Adv^{\\mathsf{PRF}}</span> .</p>

    <p class="text-gray-300"><em>Proof sketch.</em> We first describe a hybrid  <span class="math">\\mathbf{H}</span> , intermediate between  <span class="math">\\mathfrak{D}_2</span>  and  <span class="math">\\mathfrak{D}_3</span> , in which all values computed using the first (rather than all) oracle-generated key  <span class="math">a_{\\mathsf{sk}}</span>  are replaced with random strings. Then, we show that  <span class="math">\\mathcal{A}</span> 's advantage in distinguishing between  <span class="math">\\mathbf{H}</span>  and  <span class="math">\\mathfrak{D}_2</span>  is at most  <span class="math">\\mathsf{Adv}^{\\mathsf{PRF}}</span> . Finally, we extend the argument to all  <span class="math">q_{\\mathsf{CA}}</span>  oracle-generated keys (corresponding to what happens in  <span class="math">\\mathfrak{D}_3</span> ).</p>

    <p class="text-gray-300">We now describe <strong>H</strong>. On receiving  <span class="math">\\mathcal{A}</span> 's first <strong>CreateAddress</strong> query, replace the public address  <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}})</span>  with  <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (\\tau, \\mathsf{pk}_{\\mathsf{enc}})</span>  where  <span class="math">\\tau</span>  is a random string of the appropriate length. On each subsequent <strong>Pour</strong> query, for each  <span class="math">i \\in \\{1, 2\\}</span> , if  <span class="math">\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{old}} = \\mathsf{addr}_{\\mathsf{pk}}</span>  then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>in the output  <span class="math">tx_{Pour}</span> , replace  <span class="math">sn_i^{old}</span>  with a random string of appropriate length;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>in the output  <span class="math">tx_{Pour}</span> , replace each of  <span class="math">h_1, h_2</span>  with a random string of appropriate length.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>simulate the zk-SNARK proof  <span class="math">\\pi_{POUR}</span>  for the new transaction.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Note that the above modifications do not affect the computation of the zk-SNARK proof  <span class="math">\\pi_{POUR}</span> , because  <span class="math">\\pi_{POUR}</span>  is simulated with the help of a trapdoor.</p>

    <p class="text-gray-300">We now argue that  <span class="math">\\mathcal{A}</span> 's advantage in distinguishing between  <span class="math">\\mathbf{H}</span>  and  <span class="math">\\mathcal{D}_2</span>  is at most  <span class="math">\\mathsf{Adv}^\\mathsf{PRF}</span> . Let  <span class="math">a_\\mathsf{sk}</span>  be the random, secret seed for  <span class="math">\\mathsf{PRF}</span>  generated by the oracle in answering the first  <span class="math">\\mathsf{CreateAddress}</span>  query. In  <span class="math">\\mathcal{D}_2</span>  (as in  <span class="math">\\mathcal{D}_\\mathsf{real}</span> ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">a_{\\mathsf{pk}} := \\mathsf{PRF}^{\\mathrm{addr}}_{a_{\\mathsf{sk}}}(0);</span></li>
      <li>for each  <span class="math">i \\in \\{1, 2\\}</span> ,  <span class="math">\\mathsf{sn}_i := \\mathsf{PRF}^{\\mathsf{sn}}_{a_{\\mathsf{sk}}}(\\rho)</span>  for a random (and not previously used)  <span class="math">\\rho</span></li>
    </ul>

    <p class="text-gray-300">&bull; for each  <span class="math">i \\in \\{1,2\\}</span> ,  <span class="math">h_i := \\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}}(i\\|h_{\\mathsf{Sig}})</span>  and, with overwhelming probability,  <span class="math">h_{\\mathsf{Sig}}</span>  is unique. Moreover, each of  <span class="math">\\mathsf{PRF}^{\\mathsf{addr}}_{a_{\\mathsf{sk}}}, \\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}}</span>  are constructed from  <span class="math">\\mathsf{PRF}_{a_{\\mathsf{sk}}}</span>  as specified in Section 4.1. Note that, with overwhelming probability, no two calls to  <span class="math">\\mathsf{PRF}_{a_{\\mathsf{sk}}}</span>  are made on the same input. First, even identical inputs passed to  <span class="math">\\mathsf{PRF}^{\\mathsf{addr}}_{a_{\\mathsf{sk}}}, \\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}}</span>  produce different underlying calls to  <span class="math">\\mathsf{PRF}_{a_{\\mathsf{sk}}}^{\\mathsf{sn}}</span> . Second, within each construction, there is exactly one call to  <span class="math">\\mathsf{PRF}^{\\mathsf{addr}}_{a_{\\mathsf{sk}}}</span> , and the calls to  <span class="math">\\mathsf{PRF}^{\\mathsf{sn}}_{a_{\\mathsf{sk}}}</span>  are each by definition unique. Finally, with overwhelming probability, the calls to  <span class="math">\\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}}</span>  from different transactions each reference a distinct digest  <span class="math">h_{\\mathsf{Sig}}</span> , and, within a given transaction, the two calls each begin with a distinct prefix.</p>

    <p class="text-gray-300">Now let  <span class="math">\\mathcal{O}</span>  be an oracle that implements either  <span class="math">\\mathsf{PRF}_{a_{\\mathsf{sk}}}</span>  or a random function. We show that if  <span class="math">\\mathcal{A}</span>  distinguishes  <span class="math">\\mathbf{H}</span>  from  <span class="math">\\mathcal{O}_2</span>  with probability  <span class="math">\\epsilon</span> , then we can construct a distinguisher for the two cases of  <span class="math">\\mathcal{O}</span> . In either case we use  <span class="math">\\mathcal{O}</span>  to generate all values computed using  <span class="math">\\mathsf{PRF}^{\\mathsf{addr}}_{a_{\\mathsf{sk}}}</span> ,  <span class="math">\\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}}</span> ,  <span class="math">\\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}}</span> , the distribution of the experiment is identical to  <span class="math">\\mathcal{O}_2</span> ; instead, when  <span class="math">\\mathcal{O}</span>  implements a random function, the distribution of the experiment is identical to  <span class="math">\\mathbf{H}</span> . Thus,  <span class="math">\\mathcal{A}</span> 's advantage is at most  <span class="math">\\mathsf{Adv}^{\\mathsf{PRF}}</span> .</p>

    <p class="text-gray-300">Finally, by a standard hybrid argument, we extend the above to all  <span class="math">q_{\\mathbf{CA}}</span>  oracle-generated addresses; then,  <span class="math">\\mathcal{A}</span> 's differential distinguishing advantage is at most  <span class="math">q_{\\mathbf{CA}} \\cdot \\mathsf{Adv}^{\\mathsf{PRF}}</span> . Because this final hybrid is equal to  <span class="math">\\partial_3</span> , we deduce that  <span class="math">|\\mathsf{Adv}^{\\partial_3} - \\mathsf{Adv}^{\\partial_2}| \\leq q_{\\mathbf{CA}} \\cdot \\mathsf{Adv}^{\\mathsf{PRF}}</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300"><strong>Lemma D.3.</strong> Let  <span class="math">\\mathsf{Adv}^\\mathsf{COMM}</span>  be  <span class="math">\\mathcal{A}</span> 's advantage against the hiding property of  <span class="math">\\mathsf{COMM}</span> . After  <span class="math">q_{\\mathbf{M}}</span>  Mint queries and  <span class="math">q_{\\mathbf{P}}</span>  Pour queries,  <span class="math">|\\mathsf{Adv}^{\\circlearrowleft_\\mathsf{sim}} - \\mathsf{Adv}^{\\circlearrowleft_\\mathsf{3}}| \\leq (q_{\\mathbf{M}} + 4 \\cdot q_{\\mathbf{P}}) \\cdot \\mathsf{Adv}^\\mathsf{COMM}</span> .</p>

    <p class="text-gray-300"><em>Proof sketch.</em> We only provide a short sketch, because the structure of the argument is similar to the one used to prove Lemma D.2 above.</p>

    <p class="text-gray-300">For the first <strong>Mint</strong> or <strong>Pour</strong> query, replace the &quot;internal&quot; commitment  <span class="math">k := \\mathsf{COMM}_r(a_{\\mathsf{pk}} \\| \\rho)</span>  with a random string of the appropriate length. Since  <span class="math">\\rho</span>  is random (and unique), then  <span class="math">\\mathcal{A}</span> 's advantage in distinguishing this modified experiment from  <span class="math">\\partial_2</span>  is at most  <span class="math">\\mathsf{Adv}^{\\mathsf{COMM}}</span> . Then, if we similarly modify all  <span class="math">q_{\\mathbf{M}}</span>  <strong>Mint</strong> queries and all  <span class="math">q_{\\mathbf{P}}</span>  <strong>Pour</strong> queries, by replacing the resulting  <span class="math">q_{\\mathbf{M}} + 2 \\cdot q_{\\mathbf{P}}</span>  internal commitments with random strings, we can bound  <span class="math">\\mathcal{A}</span> 's advantage by  <span class="math">(q_{\\mathbf{M}} + 2 \\cdot q_{\\mathbf{P}}) \\cdot \\mathsf{Adv}^{\\mathsf{COMM}}</span> .</p>

    <p class="text-gray-300">Next, in a similar vein, if replace the coin commitment in the first <strong>Pour</strong> with a commitment to a random value, then  <span class="math">\\mathcal{A}</span> 's advantage in distinguishing this modified experiment from the above one is at most  <span class="math">\\mathsf{Adv}^\\mathsf{COMM}</span> . Then, if we similarly modify all  <span class="math">q_\\mathbf{P}</span>  <strong>Pour</strong> queries, by replacing the resulting  <span class="math">2 \\cdot q_\\mathbf{P}</span>  coin commitments with random strings, we obtain the experiment  <span class="math">\\partial_{\\mathsf{sim}}</span> , and deduce that  <span class="math">|\\mathsf{Adv}^{\\partial_{\\mathsf{sim}}} - \\mathsf{Adv}^{\\partial_3}| \\leq (q_\\mathbf{M} + 4 \\cdot q_\\mathbf{P}) \\cdot \\mathsf{Adv}^\\mathsf{COMM}</span> .  <span class="math">\\square</span></p>

      <h3 id="app-d.2" class="text-xl font-semibold mt-8">D.2 Proof of transaction non-malleability</h3>

    <p class="text-gray-300">Letting  <span class="math">\\mathcal{T}</span>  be the set of pour transactions generated by  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span>  in response to <strong>Pour</strong> queries, recall that  <span class="math">\\mathcal{A}</span>  wins the TR-NM experiment whenever it outputs  <span class="math">\\mathsf{tx}^*</span>  such that there exists  <span class="math">\\mathsf{tx}&#x27; \\in \\mathcal{T}</span>  such that: (i)  <span class="math">\\mathsf{tx}^* \\neq \\mathsf{tx}&#x27;</span> ; (ii) VerifyTransaction( <span class="math">\\mathsf{pp}</span> ,  <span class="math">\\mathsf{tx}^*</span> , L') = 1, where L' is the portion of the ledger preceding  <span class="math">\\mathsf{tx}&#x27;</span> ; and (iii) a serial number revealed in  <span class="math">\\mathsf{tx}^*</span>  is also revealed in  <span class="math">\\mathsf{tx}&#x27;</span> . Being a pour transaction,  <span class="math">\\mathsf{tx}^*</span>  has the form ( <span class="math">\\mathsf{rt}</span> ,  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}}</span> ,  <span class="math">\\mathsf{sn}_2^{\\mathsf{old}}</span> ,  <span class="math">\\mathsf{cm}_1^{\\mathsf{new}}</span> ,  <span class="math">\\mathsf{cm}_2^{\\mathsf{new}}</span> ,  <span class="math">v_{\\mathsf{pub}}</span> ,  <span class="math">\\mathsf{info}</span> , *), where * := ( <span class="math">\\mathsf{pk}_{\\mathsf{sig}}</span> ,  <span class="math">h_1, h_2, \\pi_{\\mathsf{POUR}}</span> ,  <span class="math">\\mathbf{C}_1</span> ,  <span class="math">\\mathbf{C}_2</span> ,  <span class="math">\\sigma</span> ); set  <span class="math">h_{\\mathsf{Sig}} := \\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}})</span> . Let  <span class="math">\\mathsf{pk}&#x27;_{\\mathsf{sig}}</span>  be the corresponding public key in  <span class="math">\\mathsf{tx}&#x27;</span>  and set  <span class="math">h&#x27;_{\\mathsf{Sig}} := \\mathsf{CRH}(\\mathsf{pk}&#x27;_{\\mathsf{sig}})</span> .</p>

    <p class="text-gray-300">Define  <span class="math">\\epsilon := \\mathsf{Adv}_{\\Pi,\\mathcal{A}}^{\\mathsf{TR-NM}}(\\lambda)</span> , and let  <span class="math">\\mathcal{Q}_{\\mathbf{CA}} = \\{a_{\\mathsf{sk},1},\\ldots,a_{\\mathsf{sk},q_{\\mathbf{CA}}}\\}</span>  be the set of internal address keys created by  <span class="math">\\mathcal{C}</span>  in response to  <span class="math">\\mathcal{A}</span> 's <strong>CreateAddress</strong> queries. Let  <span class="math">\\mathcal{Q}_{\\mathbf{P}} = (\\mathsf{pk}_{\\mathsf{sig},1},\\ldots,\\mathsf{pk}_{\\mathsf{sig},q_{\\mathbf{P}}})</span>  be the set of signature public keys created by  <span class="math">\\mathcal{C}</span>  in response to  <span class="math">\\mathcal{A}</span> 's <strong>Pour</strong> queries. We decompose the event in which  <span class="math">\\mathcal{A}</span>  wins into the following four disjoint events.</p>

    <p class="text-gray-300"><span class="math">\\bullet \\ \\mathrm{EVENT}_{sig} \\colon \\mathcal{A} \\ \\mathrm{wins}, \\ \\mathrm{and} \\ \\mathrm{there} \\ \\mathrm{is} \\ pk_{sig}&#x27;&#x27; \\in \\mathcal{Q}_{\\mathbf{P}} \\ \\mathrm{such} \\ \\mathrm{that} \\ pk_{sig} = pk_{sig}&#x27;&#x27;.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>EVENT<sub>col</sub>:  <span class="math">\\mathcal{A}</span>  wins, the above event does not occur, and there is  <span class="math">\\mathsf{pk}&#x27;&#x27;_{\\mathsf{sig}} \\in \\mathcal{Q}_{\\mathbf{P}}</span>  such that  <span class="math">h_{\\mathsf{Sig}} = \\mathsf{CRH}(\\mathsf{pk}&#x27;&#x27;_{\\mathsf{sig}})</span> .</li>
      <li>EVENT<sub>mac</sub>:  <span class="math">\\mathcal{A}</span>  wins, the above two events do not occur, and  <span class="math">h_i = \\mathsf{PRF}_a^{\\mathsf{pk}}(i \\| h_{\\mathsf{Sig}})</span>  for some  <span class="math">i \\in \\{1, 2\\}</span>  and  <span class="math">a \\in \\mathcal{Q}_{\\mathsf{CA}}</span> .</li>
      <li>EVENT<sub>key</sub>:  <span class="math">\\mathcal{A}</span>  wins, the above three events do not occur, and  <span class="math">h_i \\neq \\mathsf{PRF}_a^{\\mathsf{pk}}(i \\| h_{\\mathsf{Sig}})</span>  for all  <span class="math">i \\in \\{1, 2\\}</span>  and  <span class="math">a \\in \\mathcal{Q}_{\\mathsf{CA}}</span> .</li>
    </ul>

    <p class="text-gray-300">Clearly,  <span class="math">\\epsilon = \\Pr[\\text{EVENT}_{\\mathsf{sig}}] + \\Pr[\\text{EVENT}_{\\mathsf{col}}] + \\Pr[\\text{EVENT}_{\\mathsf{key}}] + \\Pr[\\text{EVENT}_{\\mathsf{mac}}]</span> . Hence, to show that  <span class="math">\\epsilon</span>  is negligible in  <span class="math">\\lambda</span> , it suffices to argue that each of these probabilities is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Bounding the probability of Event<sub>sig</sub>. Define  <span class="math">\\epsilon_1 := \\Pr[\\text{EVENT}_{\\text{sig}}]</span> . Let  <span class="math">\\sigma</span>  be the signature in tx*, and  <span class="math">\\sigma&#x27;&#x27;</span>  be the signature in the first pour transaction tx''  <span class="math">\\in \\mathcal{T}</span>  that contains  <span class="math">\\mathsf{pk}&#x27;&#x27;_{\\mathsf{sig}}</span> . When  <span class="math">\\text{EVENT}_{\\mathsf{sig}}</span>  occurs, since  <span class="math">\\mathsf{pk}&#x27;&#x27;_{\\mathsf{sig}}</span> , the two signatures are with respect to the same public key. Moreover, since tx* is valid,  <span class="math">\\mathcal{V}_{\\mathsf{sig}}(\\mathsf{pk}_{\\mathsf{sig}}, m, \\sigma) = 1</span>  where m is everything in tx* but for  <span class="math">\\sigma</span> . Let m'' consist of all elements in tx'' but for  <span class="math">\\sigma&#x27;&#x27;</span> . Observe that whenever tx*  <span class="math">\\neq</span>  tx'' we also have  <span class="math">(m, \\sigma) \\neq (m&#x27;&#x27;, \\sigma&#x27;&#x27;)</span> . We use this fact below to show that  <span class="math">\\mathcal{A}</span>  forges a signature with non-negligible probability.</p>

    <p class="text-gray-300">First, we argue that, conditioned on EVENT<sub>sig</sub>,  <span class="math">tx^* \\neq tx&#x27;&#x27;</span>  with overwhelming probability; we do so by way of contradiction. First, since  <span class="math">\\mathcal{A}</span>  wins, by definition there is  <span class="math">tx&#x27; \\in \\mathcal{T}</span>  such that  <span class="math">tx^* \\neq tx&#x27;</span>  and yet each of  <span class="math">tx^*</span>  and tx' share one serial number. Therefore: (i)  <span class="math">tx^* \\neq tx&#x27;</span> ; and (ii) if  <span class="math">tx^* = tx&#x27;&#x27;</span>  then tx'' and tx' also share a serial number. However the probability that tx' and tx'' share a serial number is bounded by the probability  <span class="math">\\tilde{p}</span>  that  <span class="math">\\mathcal{T}</span>  contains two transactions that share the same serial number. Because each serial number is computed as  <span class="math">\\mathsf{PRF}^{\\mathsf{sn}}_{a_{\\mathsf{sk}}}(\\rho)</span> , where  <span class="math">\\rho</span>  is random,  <span class="math">\\tilde{p}</span>  is negligible. We conclude that  <span class="math">tx^* \\neq tx&#x27;&#x27;</span>  with all but negligible probability.</p>

    <p class="text-gray-300">Next, we describe an algorithm  <span class="math">\\mathcal{B}</span> , which uses  <span class="math">\\mathcal{A}</span>  as a subroutine, that wins the SUF-1CMA game against Sig with probability  <span class="math">\\epsilon_1/q_{\\mathbf{P}}</span> . After receiving a verification key  <span class="math">\\mathsf{pk}&#x27;&#x27;_{\\mathsf{sig}}</span>  from the SUF-1CMA challenger, the algorithm  <span class="math">\\mathcal{B}</span>  performs the following steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{B}</span>  selects a random index  <span class="math">j \\leftarrow \\{1, \\dots, q_{\\mathbf{P}}\\}.</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{B}</span>  conducts the TR-NM experiment with  <span class="math">\\mathcal{A}</span> , except that, when  <span class="math">\\mathcal{A}</span>  issues the j-th <strong>Pour</strong> query,  <span class="math">\\mathcal{B}</span>  executes Pour as usual, but modifies the resulting pour transaction  <span class="math">\\mathsf{tx&#x27;&#x27;}</span>  as follows: (i) it substitutes  <span class="math">\\mathsf{pk&#x27;&#x27;}_{\\mathsf{sig}}</span>  for the signature public key in  <span class="math">\\mathsf{tx&#x27;&#x27;}</span> ; (ii) it queries the SUF-1CMA challenger to obtain  <span class="math">\\sigma&#x27;&#x27;</span>  on the appropriate message m''; and (iii) it substitutes  <span class="math">\\sigma&#x27;&#x27;</span>  for the signature in  <span class="math">\\mathsf{tx&#x27;&#x27;}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When  <span class="math">\\mathcal A</span>  outputs  <span class="math">\\mathsf{tx}^*,\\,\\mathcal B</span>  looks into  <span class="math">\\mathsf{tx}^*</span>  to obtain  <span class="math">\\mathsf{pk}_{\\mathsf{sig}},\\,m,</span>  and  <span class="math">\\sigma.</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">pk_{sig} \\neq pk_{sig}&#x27;&#x27;</span>  then  <span class="math">\\mathcal{B}</span>  aborts; otherwise  <span class="math">\\mathcal{B}</span>  outputs  <span class="math">(m, \\sigma)</span>  as a forgery for Sig.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Note that tx'' has the same distribution has an &quot;untampered&quot; pour transaction; thus, all transactions returned to  <span class="math">\\mathcal{A}</span>  are distributed as in the TR-NM experiment. Since the index j is selected at random,  <span class="math">\\mathcal{B}</span>  succeeds in the experiment with probability at least  <span class="math">\\epsilon_1/q_{\\mathbf{P}}</span> . Because Sig is SUF-1CMA,  <span class="math">\\epsilon_1</span>  must be negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Bounding the probability of Event<sub>col</sub>. Define  <span class="math">\\epsilon_2 := \\Pr \\left[ \\text{EVENT}_{\\text{col}} \\right]</span> . When EVENT<sub>col</sub> occurs,  <span class="math">\\mathcal{A}</span>  receives a transaction tx' containing a public key  <span class="math">\\mathsf{pk}&#x27;&#x27;_{\\mathsf{sig}}</span> , and subsequently outputs a transaction tx* containing a public key  <span class="math">\\mathsf{pk}_{\\mathsf{sig}}</span>  such that (i)  <span class="math">\\mathsf{pk}_{\\mathsf{sig}} \\neq \\mathsf{pk}&#x27;&#x27;_{\\mathsf{sig}}</span> , but (ii)  <span class="math">\\mathsf{CRH}(\\mathsf{pk}_{\\mathsf{sig}}) = \\mathsf{CRH}(\\mathsf{pk}&#x27;_{\\mathsf{sig}})</span> . In particular,  <span class="math">\\mathcal{A}</span>  finds collisions for CRH with probability  <span class="math">\\epsilon_2</span> . Because CRH is collision resistant,  <span class="math">\\epsilon_2</span>  must be negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Bounding the probability of Event<sub>mac</sub>. Define  <span class="math">\\epsilon_3 := \\Pr[\\text{EVENT}_{\\text{mac}}]</span> . We first define an experiment  <span class="math">\\partial_1</span> , which modifies the TR-NM experiment as follows. When  <span class="math">\\mathcal{C}</span>  samples  <span class="math">pp \\leftarrow \\text{Setup}(1^{\\lambda})</span> , the sub-call to  <span class="math">(pk_{POUR}, vk_{POUR}) \\leftarrow \\text{KeyGen}(1^{\\lambda}, C_{POUR})</span>  is replaced by  <span class="math">(pk_{POUR}, vk_{POUR}, trap) \\leftarrow \\text{Sim}(1^{\\lambda}, C_{POUR})</span> , so to obtain the zero-knowledge trapdoor trap. Afterwards, each time  <span class="math">\\mathcal{A}</span>  issues a <strong>Pour</strong> query,  <span class="math">\\mathcal{C}</span>  replaces the zk-SNARK proof in the resulting pour transaction with a simulated proof, obtained by running Sim(trap, x) for an appropriate input x. Because the zk-SNARK is perfect zero knowledge,  <span class="math">\\Pr[\\text{EVENT}_{\\text{mac}}] = \\epsilon_3</span>  in the  <span class="math">\\partial_1</span>  experiment as well.</p>

    <p class="text-gray-300">Assume by way of contradiction that  <span class="math">\\epsilon_3</span>  is non-negligible. We now show how to construct an attacker  <span class="math">\\mathcal{B}</span> , which uses  <span class="math">\\mathcal{A}</span>  as a subroutine, that distinguishes PRF from a random function RAND with non-negligible probability. The algorithm  <span class="math">\\mathcal{B}</span> , which has access either to  <span class="math">\\mathcal{O} = \\mathsf{PRF}</span>  or  <span class="math">\\mathcal{O} = \\mathsf{RAND}</span> , &quot;interfaces&quot; between  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{C}</span>  in the experiment  <span class="math">\\partial_1</span>  above, as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First,  <span class="math">\\mathcal{B}</span>  selects a random index  <span class="math">j \\leftarrow \\{1, \\dots, q_{\\mathbf{CA}}\\}</span> , which identifies  <span class="math">a_{\\mathsf{sk},j} \\in \\mathcal{Q}_{\\mathbf{CA}}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Next,  <span class="math">\\mathcal{B}</span>  uses the oracle  <span class="math">\\mathcal{O}</span>  instead of  <span class="math">\\mathsf{PRF}_{a_{\\mathsf{sk},j}}</span> , i.e., anytime a value needs to be computed depending on  <span class="math">\\mathsf{PRF}_{a_{\\mathsf{sk},j}}(z)</span> , for some z,  <span class="math">\\mathcal{O}(z)</span>  is used instead. (For instance, the public address key  <span class="math">a_{\\mathsf{pk},j}</span>  is one such value.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally, after A outputs  <span class="math">tx^*</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) if  <span class="math">\\mathcal{O}</span>  has been previously evaluated the expression &quot;PRF <span class="math">_{a_{\\mathsf{sk},j}}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span> &quot; using  <span class="math">\\mathcal{O}</span> ,  <span class="math">\\mathcal{B}</span>  aborts and outputs 1;</li>
      <li>(b) otherwise,  <span class="math">\\mathcal{B}</span>  evaluates the expression &quot;PRF <span class="math">_{a_{\\mathsf{sk},j}}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span> &quot; by using  <span class="math">\\mathcal{O}</span> ; if the result equals  <span class="math">h_i</span> ,  <span class="math">\\mathcal{B}</span>  outputs 1, else it outputs 0.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Conducting the above strategy does not require knowledge of  <span class="math">a_{\\mathsf{sk},j}</span>  because, having the simulation trapdoor,  <span class="math">\\mathcal{B}</span>  does not need witnesses to generate (valid) zk-SNARK proofs.</p>

    <p class="text-gray-300">We now argue that  <span class="math">|\\Pr[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) = 1] - \\Pr[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) = 1]|</span>  is non-negligible.</p>

    <p class="text-gray-300">&bull; Case 1:  <span class="math">\\mathcal{O} = \\mathsf{RAND}</span> . Observe that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) = 1 \\mid \\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) \\text{ does not abort }\\right] = 2^{-\\omega} \\ .</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\omega</span>  is the output length of PRF. Hence:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) = 1\\right] = \\left(1 - \\Pr\\left[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) \\text{ aborts}\\right]\\right) \\cdot 2^{-\\omega} + \\Pr\\left[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) \\text{ aborts}\\right].</span>$</p>

    <p class="text-gray-300">&bull; Case 2:  <span class="math">\\mathcal{O} = \\mathsf{PRF}</span> . In this case the distribution of the simulation is identical to that of  <span class="math">\\mathfrak{O}_1</span> , and  <span class="math">\\mathcal{B}</span>  has set  <span class="math">a_{\\mathsf{sk},j}</span>  equal to the seed used by  <span class="math">\\mathcal{O}</span> . Recall that, when  <span class="math">\\mathsf{EVENT}_{\\mathsf{mac}}</span>  holds,  <span class="math">h_i = \\mathsf{PRF}_a^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span>  for some  <span class="math">a \\in \\mathcal{Q}_{\\mathbf{CA}}</span> . Since  <span class="math">\\mathcal{A}</span> 's view of the experiment is independent of j, the probability that  <span class="math">a = a_{\\mathsf{sk},j}</span>  is at least  <span class="math">1/q_{\\mathsf{CA}}</span> , and the probability that  <span class="math">h_i = \\mathsf{PRF}_{a_{\\mathsf{sk},j}}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span>  is at least  <span class="math">\\epsilon_3/q_{\\mathsf{CA}}</span> . Hence:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) = 1 \\mid \\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) \\text{ does not abort }\\right] = \\epsilon_3/q_{\\mathbf{CA}}.</span>$</p>

    <p class="text-gray-300">Thus:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) = 1\\right] = \\left(1 - \\Pr\\left[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) \\text{ aborts}\\right]\\right) \\cdot \\epsilon_3/q_{\\mathbf{CA}} + \\Pr\\left[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) \\text{ aborts}\\right].</span>$</p>

    <p class="text-gray-300">Clearly,  <span class="math">2^{-\\omega}</span>  is negligible; moreover, if  <span class="math">\\epsilon_3</span>  is non-negligible, then so is  <span class="math">|\\epsilon_3/q_{\\mathbf{CA}}|</span> . Thus, to show that  <span class="math">|\\Pr[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda}) = 1] - \\Pr[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda}) = 1]|</span>  is non-negligible, it suffices to show that each of  <span class="math">\\Pr[\\mathcal{B}^{\\mathsf{RAND}}(1^{\\lambda})]</span>  aborts and  <span class="math">\\Pr[\\mathcal{B}^{\\mathsf{PRF}}(1^{\\lambda})]</span>  aborts is negligible.</p>

    <p class="text-gray-300">To do so, recall that  <span class="math">\\mathcal{B}</span>  aborts if and only if it has previously evaluated the expression &quot;PRF <span class="math">_{a_{\\mathsf{sk},j}}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span> &quot; using  <span class="math">\\mathcal{O}</span>  prior to receiving  <span class="math">\\mathcal{A}</span> 's output. First note that  <span class="math">\\mathcal{B}</span> 's only calls to  <span class="math">\\mathcal{O}</span>  occur when it evaluates the functions PRF <span class="math">_{\\mathsf{add}}^{\\mathsf{pk}}</span> , PRF <span class="math">_{\\mathsf{sn}}^{\\mathsf{pk}}</span>  and PRF <span class="math">_{\\mathsf{ask},j}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span>  using any calls to of these functions it is not possible to evaluate the expression PRF <span class="math">_{\\mathsf{ask},j}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span>  using any calls to PRF <span class="math">_{\\mathsf{ask},j}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span> . Thus  <span class="math">\\mathcal{B}</span>  aborts if and only if it has previously queried PRF <span class="math">_{\\mathsf{pk}}^{\\mathsf{pk}}</span>  on the expression PRF <span class="math">_{\\mathsf{ask},j}^{\\mathsf{pk}}(i\\|h_{\\mathsf{Sig}})</span> . However it is easy to see that this cannot happen under the conditions of EVENT <span class="math">_{\\mathsf{mac}}</span> , since such a query would imply the condition EVENT <span class="math">_{\\mathsf{sig}}</span>  or EVENT <span class="math">_{\\mathsf{col}}</span> , each of which is excluded by EVENT <span class="math">_{\\mathsf{mac}}</span> . Hence the probability of either condition occurring is 0.</p>

    <p class="text-gray-300">Bounding the probability of Event<sub>key</sub>. Define  <span class="math">\\epsilon_4 := \\Pr[\\text{EVENT}_{\\text{key}}]</span> , and let  <span class="math">\\mathcal{E}</span>  be the zk-SNARK extractor for A. Assume by way of contradiction that  <span class="math">\\epsilon_4</span>  is non-negligible. We construct an algorithm  <span class="math">\\mathcal{B}</span>  that finds collisions for PRF<sup>sn</sup> with non-negligible probability (contradicting the fact that PRF<sup>sn</sup> is collision resistant). The algorithm  <span class="math">\\mathcal{B}</span>  works as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run  <span class="math">\\mathcal{A}</span>  (simulating its interaction with the challenger  <span class="math">\\mathcal{C}</span> ) to obtain  <span class="math">\\mathsf{tx}^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run  <span class="math">\\mathcal{E}(\\mathsf{pk}_{\\mathsf{POUR}}, \\mathsf{vk}_{\\mathsf{POUR}})</span>  to obtain a witness a for the zk-SNARK proof  <span class="math">\\pi_{\\mathsf{POUR}}</span>  in  <span class="math">\\mathsf{tx}^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If a is not a valid witness for the instance  <span class="math">x := (\\mathsf{rt}, \\mathsf{sn}_1^{\\mathsf{old}}, \\mathsf{sn}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}, v_{\\mathsf{pub}}, h_{\\mathsf{Sig}}, h_1, h_2),</span> abort and output 0.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Parse a as  <span class="math">(\\mathsf{path}_1, \\mathsf{path}_2, \\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk},1}^{\\mathsf{old}}, \\mathsf{addr}_{\\mathsf{sk},2}^{\\mathsf{old}}, \\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}})</span> .</p></li>
      <li><p class="text-gray-300">For each  <span class="math">i \\in \\{1, 2\\}</span> , parse  <span class="math">\\mathbf{c}_i^{\\mathsf{old}}</span>  as  <span class="math">(\\mathsf{addr}_{\\mathsf{pk},i}^{\\mathsf{old}}, v_i^{\\mathsf{old}}, \\rho_i^{\\mathsf{old}}, r_i^{\\mathsf{old}}, s_i^{\\mathsf{old}}, \\mathsf{cm}_i^{\\mathsf{old}})</span> .</p></li>
      <li><p class="text-gray-300">For each  <span class="math">i \\in \\{1, 2\\}</span> , parse  <span class="math">\\mathsf{addr}_{\\mathsf{sk},i}^{\\mathsf{old}}</span>  as  <span class="math">(a_{\\mathsf{sk},i}^{\\mathsf{old}}, \\mathsf{sk}_{\\mathsf{enc},i}^{\\mathsf{old}})</span> .</p></li>
    </ol>

    <p class="text-gray-300">(Note that, since a is a valid witness,  <span class="math">\\mathsf{sn}_i^{\\mathsf{old}} = \\mathsf{PRF}_{a_{\\mathsf{sk},i}^{\\mathsf{old}}}^{\\mathsf{sold}}(\\rho_i^{\\mathsf{old}})</span>  for all  <span class="math">i \\in \\{1, 2\\}</span> .)</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each  <span class="math">i \\in \\{1, 2\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Look for a pour transaction  <span class="math">tx \\in \\mathcal{T}</span>  that contains  <span class="math">sn_i^{old}</span> .</li>
      <li>(b) If one tx is found, let  <span class="math">\\overline{a_{\\mathsf{sk}}}</span>  and  <span class="math">\\overline{\\rho}</span>  be the seed and input used to compute  <span class="math">\\mathsf{sn}_i^{\\mathsf{old}}</span>  in tx; thus,  <span class="math">\\mathsf{sn}_i^{\\mathsf{old}} = \\mathsf{PRF}^{\\mathrm{sn}}_{\\overline{a_{\\mathsf{sk}}}}(\\overline{\\rho})</span> . If  <span class="math">a_{\\mathsf{sk},i}^{\\mathsf{old}} \\neq \\overline{a_{\\mathsf{sk}}}</span> , output  <span class="math">\\left((a_{\\mathsf{sk},i}^{\\mathsf{old}}, \\rho_i^{\\mathsf{old}}), (\\overline{a_{\\mathsf{sk}}}, \\overline{\\rho})\\right)</span>  as a collision for  <span class="math">\\mathsf{PRF}^{\\mathrm{sn}}</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Note that, whenever Event<sub>kev</sub> holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the proof  <span class="math">\\pi_{POUR}</span>  is valid and, with all but negligible probability, the witness a is valid;</li>
      <li>the serial number  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}}</span>  or  <span class="math">\\mathsf{sn}_2^{\\mathsf{old}}</span>  appears in some previous pour transaction in  <span class="math">\\mathcal{T}</span> ;</li>
      <li>whenever a is valid, it holds that  <span class="math">h_1 = \\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}^{\\mathsf{old}}}(h_{\\mathsf{Sig}})</span>  and  <span class="math">h_2 = \\mathsf{PRF}^{\\mathsf{pk}}_{a_{\\mathsf{sk}}^{\\mathsf{old}}}(h_{\\mathsf{Sig}})</span> , so that it cannot be that  <span class="math">a_{\\mathsf{sk},2}^{\\mathsf{old}} = a_{\\mathsf{sk},2}^{\\mathsf{old}} = \\overline{a_{\\mathsf{sk}}}</span>  (as this contradicts the conditions of the event EVENT<sub>key</sub>). Overall, we conclude that  <span class="math">\\mathcal{B}</span>  finds a collision for PRF<sup>sn</sup> with probability  <span class="math">\\epsilon_4 - \\text{negl}(\\lambda)</span> .</li>
    </ul>

    <h4 id="sec-misc-18" class="text-lg font-semibold mt-6">Proof of balance D.3</h4>

    <p class="text-gray-300">Define  <span class="math">\\epsilon := \\mathsf{Adv}^{\\mathsf{BAL}}_{\\Pi,\\mathcal{A}}(\\lambda)</span> ; our goal is to show that  <span class="math">\\epsilon</span>  is negligible in  <span class="math">\\lambda</span> . Recall that ADDR is the set of addresses returned by A's CreateAddress queries.</p>

    <p class="text-gray-300">Augmenting the ledger with witnesses. We modify the BAL experiment in a way that does not affect  <span class="math">\\mathcal{A}</span> 's view: the challenger  <span class="math">\\mathcal{C}</span>  computes, for each pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  on the ledger L(maintained by the oracle  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span> ), a witness  <span class="math">a = (\\mathsf{path}_1, \\mathsf{path}_2, \\mathbf{c}_1^{\\mathsf{old}}, \\mathbf{c}_2^{\\mathsf{old}}, \\mathsf{addr}^{\\mathsf{old}}_{\\mathsf{sk},1}, \\mathsf{addr}^{\\mathsf{old}}_{\\mathsf{sk},2}, \\mathbf{c}_1^{\\mathsf{new}}, \\mathbf{c}_2^{\\mathsf{new}})</span> for the zk-SNARK instance  <span class="math">x=(\\mathsf{rt},\\mathsf{sn}_1^\\mathsf{old},\\mathsf{sn}_2^\\mathsf{old},\\mathsf{cm}_1^\\mathsf{new},\\mathsf{cm}_2^\\mathsf{new},v_\\mathsf{pub},h_\\mathsf{Sig},h_1,h_2)</span>  corresponding to  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span> . In this way,  <span class="math">\\mathcal{C}</span>  obtains an augmented ledger  <span class="math">(L, \\vec{a})</span> , where  <span class="math">a_i</span>  is a witness for the zk-SNARK instance  <span class="math">x_i</span>  of the i-th pour transaction in L. Note that we can parse  <span class="math">(L, \\vec{a})</span>  as a list of matched pairs  <span class="math">(tx_{Pour}, a)</span>  where  <span class="math">tx_{Pour}</span>  is a pour transaction in L and a is its corresponding witness.</p>

    <p class="text-gray-300">The discussion below is relative to the above modification of the BAL experiment.</p>

    <p class="text-gray-300"><strong>Balanced ledgers.</strong> We say that an augmented ledger  <span class="math">(L, \\vec{a})</span>  is balanced if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>I. Each  <span class="math">(tx_{Pour}, a)</span>  in  <span class="math">(L, \\vec{a})</span>  contains openings (i.e., decommitments) of two distinct coin commitments  <span class="math">cm_1^{old}</span>  and  <span class="math">cm_2^{old}</span> ; also, each  <span class="math">cm_i^{old}</span>  is the output coin commitment of a pour or mint transaction that precedes  <span class="math">tx_{Pour}</span>  on L.</li>
      <li>II. No two  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}}, a)</span>  and  <span class="math">(a&#x27;, \\mathsf{tx}&#x27;_{\\mathsf{Pour}})</span>  in  <span class="math">(L, \\vec{a})</span>  contain openings of the same coin commitment.</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;29</sup> Concretely, for pour transactions in L not inserted by  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathcal{C}</span>  simply retains the witness a internally used by  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span> to generate the transaction. As for the (valid) pour transactions inserted by A, C uses the zk-SNARK multi-instance knowledge extractor corresponding to A; see Section 2.1. (If knowledge extraction fails, C aborts and outputs 1. However, this only happens with negligible probability.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>III. Each  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}}, a)</span>  in  <span class="math">(L, \\vec{a})</span>  contains openings of  <span class="math">\\mathsf{cm}_1^{\\mathsf{old}}, \\mathsf{cm}_2^{\\mathsf{old}}, \\mathsf{cm}_1^{\\mathsf{new}}, \\mathsf{cm}_2^{\\mathsf{new}}</span>  to values  <span class="math">v_1^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_1^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_2^{\\mathsf{old}}, v_</span></li>
      <li>IV. For each  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}}, a)</span>  in  <span class="math">(L, \\vec{a})</span>  and for each  <span class="math">i \\in \\{1, 2\\}</span> , the following conditions hold:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  is also the output of a mint transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span>  on L, then the public value v in  <span class="math">\\mathsf{tx}_{\\mathsf{Mint}}</span>  is equal to  <span class="math">v_i^{\\mathsf{old}}</span> .</li>
      <li>(b) If  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  is also the output of a pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}&#x27;</span>  on L, then its witness a' contains an opening of  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  to a value v' that is equal to  <span class="math">v_i^{\\mathsf{old}}</span> .</li>
    </ul></li>
      <li>V. For each  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}}, a)</span>  in  <span class="math">(L, \\vec{a})</span> , where  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  was inserted by  <span class="math">\\mathcal{A}</span> , it holds that, for each  <span class="math">i \\in \\{1, 2\\}</span> , if  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  is the output of an earlier mint or pour transaction  <span class="math">\\mathsf{tx}&#x27;</span> , then the public address of the i-th output of  <span class="math">\\mathsf{tx}&#x27;</span>  is not contained in ADDR.</li>
    </ul>

    <p class="text-gray-300">Intuitively, the above conditions ensure that, in L,  <span class="math">\\mathcal{A}</span>  did not spend money that was not previously minted, or paid to an address under  <span class="math">\\mathcal{A}</span> 's control. Concretely, one can prove by induction that if  <span class="math">(L, \\vec{a})</span>  is balanced then  <span class="math">v_{\\mathsf{Unspent}} + v_{\\mathsf{Basecoin}} + v_{\\mathcal{A} \\to \\mathsf{ADDR}} &gt; v_{\\mathsf{Mint}} + v_{\\mathsf{ADDR} \\to \\mathcal{A}}</span> .</p>

    <p class="text-gray-300">In light of the above, it suffices to argue that the augmented ledger induced by the (modified) BAL experiment is balanced with all but negligible probability. Suppose, by way of contradiction, that is is not the case:  <span class="math">\\mathcal{A}</span>  induces, with non-negligible probability, an augmented ledger  <span class="math">(L, \\vec{a})</span>  that is not balanced. We distinguish between five cases, corresponding to which one of the above conditions does not hold with non-negligible probability. In each case, we show how to reach a contradiction, concluding the proof.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span>  violates Condition I. Suppose that  <span class="math">\\Pr\\left[\\mathcal{A} \\text{ wins but violates Condition I}\\right]</span>  is non-negligible. By construction of  <span class="math">\\mathcal{O}^{\\mathsf{DAP}}</span> , every  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}}, a)</span>  in  <span class="math">(L, \\vec{a})</span>  for which  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  was not inserted by  <span class="math">\\mathcal{A}</span>  satisfies Condition I; thus, the violation can only originate from a pair  <span class="math">(\\mathsf{tx}_{\\mathsf{Pour}}, a)</span>  in  <span class="math">(L, \\vec{a})</span>  for which  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  was inserted by  <span class="math">\\mathcal{A}</span>  and such that: (i)  <span class="math">\\mathsf{cm}_1^{\\mathsf{old}} = \\mathsf{cm}_2^{\\mathsf{old}}</span> ; or (ii) there is  <span class="math">i \\in \\{1, 2\\}</span>  such that  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  has no corresponding output coin commitment in any pour or mint transaction that precedes  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  on L. Observe that the validity of  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  implies that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The two serial numbers  <span class="math">\\mathsf{sn}_1^\\mathsf{old}</span>  and  <span class="math">\\mathsf{sn}_2^\\mathsf{old}</span>  are distinct. Moreover, recalling that each  <span class="math">\\mathsf{sn}_i^\\mathsf{old}</span>  equals  <span class="math">\\mathsf{PRF}^\\mathsf{sn}_{a_{\\mathsf{sk},i}^\\mathsf{old}}(\\rho_i^\\mathsf{old})</span> , this also implies that  <span class="math">(a_{\\mathsf{sk},1}^\\mathsf{old}, \\rho_1^\\mathsf{old}) \\neq (a_{\\mathsf{sk},2}^\\mathsf{old}, \\rho_2^\\mathsf{old})</span> .</li>
      <li>The witness a contains two valid authentication paths  <span class="math">\\mathsf{path}_1, \\mathsf{path}_2</span>  for a Merkle tree constructed using only coin commitments of transactions preceding  <span class="math">\\mathsf{tx}_\\mathsf{Pour}</span>  in L.</li>
    </ul>

    <p class="text-gray-300">In either (i) or (ii), we reach a contradiction. Indeed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) If  <span class="math">\\mathsf{cm}_1^{\\mathsf{old}} = \\mathsf{cm}_2^{\\mathsf{old}}</span> , then the fact that  <span class="math">\\mathsf{sn}_1^{\\mathsf{old}} \\neq \\mathsf{sn}_2^{\\mathsf{old}}</span>  implies that the witness a contains two distinct openings of  <span class="math">\\mathsf{cm}_1^{\\mathsf{old}}</span>  (the first opening contains  <span class="math">(a_{\\mathsf{sk},1}^{\\mathsf{old}}, \\rho_1^{\\mathsf{old}})</span> , while the second opening contains  <span class="math">(a_{\\mathsf{sk},2}^{\\mathsf{old}}, \\rho_2^{\\mathsf{old}})</span> ). This violates the binding property of the commitment scheme COMM.</li>
      <li>(ii) If there is  <span class="math">i \\in \\{1, 2\\}</span>  such that  <span class="math">\\mathsf{cm}_i^{\\mathsf{old}}</span>  does not previously appear in L, then  <span class="math">\\mathsf{path}_i</span>  is an invalid authentication path, and thus yields a collision in the function CRH. This violates the collision resistance of CRH.</li>
    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span>  violates Condition II. Suppose that  <span class="math">\\Pr[\\mathcal{A} \\text{ wins but violates Condition II}]</span>  is non-negligible. Observe that, when Condition II is violated, L contains two pour transactions  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}, \\mathsf{tx}&#x27;_{\\mathsf{Pour}}</span>  spending the same coin commitment  <span class="math">\\mathsf{cm}</span> , and revealing two serial numbers  <span class="math">\\mathsf{sn}</span>  and  <span class="math">\\mathsf{sn}&#x27;</span> . Since  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}, \\mathsf{tx}&#x27;_{\\mathsf{Pour}}</span>  are valid, it must be the case that  <span class="math">\\mathsf{sn} \\neq \\mathsf{sn}&#x27;</span> . However (as argued already above), if both transactions spend  <span class="math">\\mathsf{cm}</span>  but produce different serial numbers, then the corresponding witnesses a, a' contain different openings of  <span class="math">\\mathsf{cm}</span> . This contradicts the binding property of the commitment scheme COMM.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span>  violates Condition III. Suppose that  <span class="math">\\Pr\\left[\\mathcal{A} \\text{ wins but violates Condition III}\\right]</span>  is non-negligible. In this case, the contradiction is immediate: whenever Condition III is violated, the equation</p>

    <p class="text-gray-300"><span class="math">v_1^{\\sf old} + v_2^{\\sf old} = v_1^{\\sf new} + v_2^{\\sf new} + v_{\\sf pub}</span>  does not hold, and thus, by construction of the statement POUR, the soundness of the zk-SNARK is violated as well.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span>  violates Condition IV. Suppose that  <span class="math">\\Pr[\\mathcal{A} \\text{ wins but violates Condition IV}]</span>  is non-negligible. Observe that, when Condition IV is violated, L contains:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a pour transaction  <span class="math">tx_{Pour}</span>  in which a coin commitment  <span class="math">cm^{old}</span>  is opened to a value  <span class="math">v^{old}</span> ; and also</li>
      <li>a (mint or pour) transaction tx' that opens  <span class="math">cm^{old}</span>  to a value v' different from  <span class="math">v^{old}</span> . This contradicts the binding property of the commitment scheme COMM.</li>
    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span>  violates Condition V. Suppose that  <span class="math">\\Pr\\left[\\mathcal{A} \\text{ wins but violates Condition V}\\right]</span>  is non-negligible. Observe that, when Condition V is violated, L contains an inserted pour transaction  <span class="math">\\mathsf{tx}_{\\mathsf{Pour}}</span>  that spends the output of a previous transaction  <span class="math">\\mathsf{tx&#x27;}</span>  whose public address  <span class="math">\\mathsf{addr}_{\\mathsf{pk}} = (a_{\\mathsf{pk}}, \\mathsf{pk}_{\\mathsf{enc}})</span>  lies in ADDR; moreover, the witness associated to  <span class="math">\\mathsf{tx&#x27;}</span>  contains  <span class="math">a_{\\mathsf{sk}}</span>  such that  <span class="math">a_{\\mathsf{pk}} = \\mathsf{PRF}^{\\mathsf{addr}}_{a_{\\mathsf{sk}}}(0)</span> . We omit the full argument, but one can verify that, in this case, we can construct a new adversary  <span class="math">\\mathcal{B}</span>  that uses  <span class="math">\\mathcal{A}</span>  to distinguish, with non-negligible probability,  <span class="math">\\mathsf{PRF}</span>  from a random function.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[BB04] Dan Boneh and Xavier Boyen. Secure identity based encryption without random oracles. In Proceedings of the 24th Annual International Cryptology Conference, CRYPTO '04, pages 443&ndash;459, 2004.</p></li>
      <li><p class="text-gray-300">[BBDP01] Mihir Bellare, Alexandra Boldyreva, Anand Desai, and David Pointcheval. Key-privacy in publickey encryption. In Proceedings of the 7th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT '01, pages 566&ndash;582, 2001.</p></li>
      <li><p class="text-gray-300">[BBSU12] Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to better - how to make Bitcoin a better currency. In Proceedings of the 16th International Conference on Financial Cryptography and Data Security, FC '12, pages 399&ndash;414, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, ITCS '12, pages 326&ndash;349, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In Proceedings of the 45th ACM Symposium on the Theory of Computing, STOC '13, pages 111&ndash;120, 2013.</p></li>
      <li><p class="text-gray-300">[BCG<sup>+</sup>13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: verifying program executions succinctly and in zero knowledge. In Proceedings of the 33rd Annual International Cryptology Conference, CRYPTO '13, pages 90&ndash;108, 2013.</p></li>
      <li><p class="text-gray-300">[BCGT13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems. In Proceedings of the 4th Innovations in Theoretical Computer Science Conference, ITCS '13, pages 401&ndash;414, 2013.</p></li>
      <li><p class="text-gray-300">[BCGT13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. On the concrete efficiency of probabilistically-checkable proofs. In Proceedings of the 45th ACM Symposium on the Theory of Computing, STOC '13, pages 585&ndash;594, 2013.</p></li>
      <li><p class="text-gray-300">[BCI<sup>+</sup>13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct noninteractive arguments via linear interactive proofs. In Proceedings of the 10th Theory of Cryptography Conference, TCC '13, pages 315&ndash;333, 2013.</p></li>
      <li><p class="text-gray-300">[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, Security '14, pages ???&ndash;???, 2014. Available at <a href="http://eprint.iacr.org/2013/879" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2013/879</a>.</p></li>
      <li><p class="text-gray-300">[Bel06] Mihir Bellare. New proofs for NMAC and HMAC: security without collision-resistance. In Proceedings of the 26th Annual International Conference on Advances in Cryptology, CRYPTO '06, pages 602&ndash;619, 2006.</p></li>
      <li><p class="text-gray-300">[Ben13] Eli Ben-Sasson. Universal and affordable computational integrity, May 2013. Bitcoin 2013: The Future of Payments. URL: <a href="http://www.youtube.com/watch?v=YRcPReUpkcU&feature=youtu.be&t=26m6s" target="_blank" rel="noopener noreferrer">http://www.youtube.com/watch?v=YRcPReUpkcU&amp;feature=youtu.be&amp;t=26m6s</a>.</p></li>
      <li><p class="text-gray-300">[BFLS91] L&acute;aszl&acute;o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, STOC '91, pages 21&ndash;32, 1991.</p></li>
      <li><p class="text-gray-300">[BGH<sup>+</sup>05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil Vadhan. Short PCPs verifiable in polylogarithmic time. In Proceedings of the 20th Annual IEEE Conference on Computational Complexity, CCC '05, pages 120&ndash;134, 2005.</p></li>
      <li><p class="text-gray-300">[Cer00] Certicom Research. SEC 1: Elliptic curve cryptography, 2000. URL: <a href="http://www.secg.org/collateral/sec1_final.pdf" target="_blank" rel="noopener noreferrer">http://www.secg.org/collateral/</a> <a href="http://www.secg.org/collateral/sec1_final.pdf" target="_blank" rel="noopener noreferrer">sec1\\_final.pdf</a>.</p></li>
      <li><p class="text-gray-300">[Cha82] David Chaum. Blind signatures for untraceable payments. In Proceedings of the 2nd Annual International Cryptology Conference, CRYPTO '82, pages 199&ndash;203, 1982.</p></li>
      <li><p class="text-gray-300">[CHL05] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Proceedings of the 24th Annual International Conference on Theory and Applications of Cryptographic Techniques, EUROCRYPT '05, pages 302&ndash;321, 2005.</p></li>
      <li><p class="text-gray-300">[CL01] Jan Camenisch and Anna Lysyanskaya. An efficient system for non-transferable anonymous credentials with optional anonymity revocation. In Proceedings of the 20th Annual International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT '01, pages 93&ndash;118, 2001.</p></li>
      <li><p class="text-gray-300">[DDM03] George Danezis, Roger Dingledine, and Nick Mathewson. Mixminion: Design of a type III anonymous remailer protocol. In Proceedings of the 2003 IEEE Symposium on Security and Privacy, SP '03, pages 2&ndash;15, 2003.</p></li>
      <li><p class="text-gray-300">[DFKP13] George Danezis, Cedric Fournet, Markulf Kohlweiss, and Bryan Parno. Pinocchio Coin: building Zerocoin from a succinct pairing-based proof system. In Proceedings of the 2013 Workshop on Language Support for Privacy Enhancing Technologies, PETShop '13, 2013. URL: <a href="http://www0.cs.ucl.ac.uk/staff/G.Danezis/papers/DanezisFournetKohlweissParno13.pdf" target="_blank" rel="noopener noreferrer">http://www0.cs.ucl.ac.uk/staff/G.</a> <a href="http://www0.cs.ucl.ac.uk/staff/G.Danezis/papers/DanezisFournetKohlweissParno13.pdf" target="_blank" rel="noopener noreferrer">Danezis/papers/DanezisFournetKohlweissParno13.pdf</a>.</p></li>
      <li><p class="text-gray-300">[DMS04] Roger Dingledine, Nick Mathewson, and Paul Syverson. Tor: the second-generation onion router. In Proceedings of the 13th USENIX Security Symposium, Security '04, pages 21&ndash;21, 2004.</p></li>
      <li><p class="text-gray-300">[DW13] Christian Decker and Roger Wattenhofer. Information propagation in the Bitcoin network. In Proceedings of the 13th IEEE International Conference on Peer-to-Peer Computing, P2P '13, pages 1&ndash;10, 2013.</p></li>
      <li><p class="text-gray-300">[ES13] Ittay Eyal and Emin G&uml;un Sirer. Majority is not enough: Bitcoin mining is vulnerable, 2013.</p></li>
      <li><p class="text-gray-300">[Gen04] Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks. In Proceedings of the 24th Annual International Cryptology Conference, CRYPTO '04, pages 220&ndash;236, 2004.</p></li>
      <li><p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT '13, pages 626&ndash;645, 2013.</p></li>
      <li><p class="text-gray-300">[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186&ndash;208, 1989. Preliminary version appeared in STOC '85.</p></li>
      <li><p class="text-gray-300">[GOS06a] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive Zaps and new techniques for NIZK. In Proceedings of the 26th Annual International Conference on Advances in Cryptology, CRYPTO '06, pages 97&ndash;111, 2006.</p></li>
      <li><p class="text-gray-300">[GOS06b] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In Proceedings of the 25th Annual International Conference on Advances in Cryptology, EUROCRYPT '06, pages 339&ndash;358, 2006.</p></li>
      <li><p class="text-gray-300">[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT '10, pages 321&ndash;340, 2010.</p></li>
      <li><p class="text-gray-300">[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Proceedings of the 43rd Annual ACM Symposium on Theory of Computing, STOC '11, pages 99&ndash;108, 2011.</p></li>
      <li><p class="text-gray-300">[KL07] Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography. Chapman &amp; Hall/CRC, 2007.</p></li>
      <li><p class="text-gray-300">[Lee13] Timothy B. Lee. Bitcoin needs to scale by a factor of 1000 to compete with Visa. here's how to do it. The Washington Post (<a href="http://www.washingtonpost.com" target="_blank" rel="noopener noreferrer">http://www.washingtonpost.com</a>), November 2013.</p></li>
      <li><p class="text-gray-300">[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography, TCC '12, pages 169&ndash;189, 2012.</p></li>
      <li><p class="text-gray-300">[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. In Proceedings of the 19th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT '13, pages 41&ndash;60, 2013.</p></li>
      <li><p class="text-gray-300">[Max13] Greg Maxwell. CoinJoin: Bitcoin privacy for the real world, August 2013. Bitcoin Forum. URL: <a href="https://bitcointalk.org/index.php?topic=279249.0" target="_blank" rel="noopener noreferrer">https://bitcointalk.org/index.php?topic=279249.0</a>.</p></li>
      <li><p class="text-gray-300">[MGGR13] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed e-cash from bitcoin. In Proceedings of the 2013 IEEE Symposium on Security and Privacy, SP '13, pages 397&ndash;411, 2013.</p></li>
      <li><p class="text-gray-300">[Mic00] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253&ndash;1298, 2000. Preliminary version appeared in FOCS '94.</p></li>
      <li><p class="text-gray-300">[MPJ<sup>+</sup>13] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoffrey M. Voelker, and Stefan Savage. A fistful of Bitcoins: Characterizing payments among men with no names. In Proceedings of the 2013 Conference on Internet Measurement Conference, IMC '13, pages 127&ndash;140, 2013.</p></li>
      <li><p class="text-gray-300">[Nak09] Satoshi Nakamoto. Bitcoin: a peer-to-peer electronic cash system, 2009. URL: <a href="http://www.bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">http://www.bitcoin.</a> <a href="http://www.bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">org/bitcoin.pdf</a>.</p></li>
      <li><p class="text-gray-300">[Nat12] National Institute of Standards and Technology. FIPS PUB 180-4: Secure Hash Standard. <a href="http://csrc.nist.gov/publications/PubsFIPS.html" target="_blank" rel="noopener noreferrer">http:</a> <a href="http://csrc.nist.gov/publications/PubsFIPS.html" target="_blank" rel="noopener noreferrer">//csrc.nist.gov/publications/PubsFIPS.html</a>, 2012.</p></li>
      <li><p class="text-gray-300">[PGHR13] Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: nearly practical verifiable computation. In Proceedings of the 34th IEEE Symposium on Security and Privacy, Oakland '13, pages 238&ndash;252, 2013.</p></li>
      <li><p class="text-gray-300">[Pol13] PolarSSL. PolarSSL. <a href="http://polarssl.org" target="_blank" rel="noopener noreferrer">http://polarssl.org</a>, Oct 2013.</p></li>
      <li><p class="text-gray-300">[RM11] Fergal Reid and Harrigan Martin. An analysis of anonymity in the Bitcoin system. In Proceedings of the 3rd IEEE International Conference on Privacy, Security, Risk and Trust and on Social Computing, SocialCom/PASSAT '11, pages 1318&ndash;1326, 2011.</p></li>
      <li><p class="text-gray-300">[RS12] Dorit Ron and Adi Shamir. Quantitative analysis of the full Bitcoin transaction graph. Cryptology ePrint Archive, Report 2012/584, 2012.</p></li>
      <li><p class="text-gray-300">[ST99] Tomas Sander and Amnon Ta-Shma. Auditable, anonymous electronic cash. In Proceedings of the 19th Annual International Cryptology Conference on Advances in Cryptology, CRYPTO '99, pages 555&ndash;572, 1999.</p></li>
      <li><p class="text-gray-300">[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Proceedings of the 5th Theory of Cryptography Conference, TCC '08, pages 1&ndash;18, 2008.</p></li>
      <li><p class="text-gray-300">[Wui14] Pieter Wuille. Proposed BIP for dealing with malleability. Available at <a href="https://gist.github.com/sipa/8907691" target="_blank" rel="noopener noreferrer">https://gist.github.com/</a> <a href="https://gist.github.com/sipa/8907691" target="_blank" rel="noopener noreferrer">sipa/8907691</a>, 2014.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Zerocash: Decentralized Anonymous Payments from Bitcoin (2014/349)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/349
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">zk-SNARKs</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Centralized anonymous payment systems</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Decentralized anonymous payment schemes</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Zerocash</a></li>
            <li><a href="#sec-1.5" class="hover:text-white">Paper organization</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Background on zk-SNARKs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Informal definition</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Comparison with NIZKs</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Known constructions and security</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">zk-SNARK implementations</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Definition of a decentralized anonymous payment scheme</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Data structures</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Algorithms</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Completeness</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Security</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Construction of a decentralized anonymous payment scheme</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Cryptographic building blocks</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">zk-SNARKs for pouring coins</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Algorithm constructions</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">Completeness and security</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Zerocash</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.2" class="hover:text-white">Arithmetic circuit for pouring coins</a></li>
            <li><a href="#sec-5.2.1" class="hover:text-white">An arithmetic circuit for verifying SHA256&#x27;s compression function</a></li>
            <li><a href="#sec-5.2.2" class="hover:text-white">Arithmetic circuit for POUR</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Integration with existing ledger-based currencies</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Integration by replacing the base currency</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Integration by hybrid currency</a></li>
            <li><a href="#sec-6.3" class="hover:text-white">Extending the Bitcoin protocol to support the combined semantics</a></li>
            <li><a href="#sec-6.4" class="hover:text-white">Additional anonymity considerations</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-7" class="hover:text-white">Experiments</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-7.1" class="hover:text-white">Performance of zk-SNARKs for pouring coins</a></li>
            <li><a href="#sec-7.2" class="hover:text-white">Performance of Zerocash algorithms</a></li>
            <li><a href="#sec-7.3" class="hover:text-white">Large-scale network simulation</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-8" class="hover:text-white">Optimizations and extensions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-8.1" class="hover:text-white">Everlasting anonymity</a></li>
            <li><a href="#sec-8.2" class="hover:text-white">Fast block propagation</a></li>
            <li><a href="#sec-8.3" class="hover:text-white">Improved storage requirements</a></li>
            <li><a href="#sec-8.3.1" class="hover:text-white">Supporting many coin commitments</a></li>
            <li><a href="#sec-8.3.2" class="hover:text-white">Supporting many spent serial numbers</a></li>
          </ol>
        </li>
        <li><a href="#sec-9" class="hover:text-white">Concurrent work</a></li>
        <li><a href="#sec-10" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Overview of Bitcoin and Zerocoin</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Bitcoin</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Zerocoin</a></li>
          </ol>
        </li>
        <li><a href="#app-b" class="hover:text-white">Completeness of DAP schemes</a></li>
        <li>
          <a href="#app-c" class="hover:text-white">Security of DAP schemes</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">Ledger indistinguishability</a></li>
            <li><a href="#app-c.2" class="hover:text-white">Transaction non-malleability</a></li>
            <li><a href="#app-c.3" class="hover:text-white">Balance</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-d" class="hover:text-white">Proof of Theorem 4.1</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-d.1" class="hover:text-white">Proof of ledger indistinguishability</a></li>
            <li><a href="#app-d.2" class="hover:text-white">Proof of transaction non-malleability</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="zerocash-decentralized-anonymous-payments-from-bitcoin-2014" />
  </article>
</BaseLayout>
