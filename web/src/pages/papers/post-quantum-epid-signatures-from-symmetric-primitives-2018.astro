---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/261';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Post-Quantum EPID Signatures from Symmetric Primitives';
const AUTHORS_HTML = 'Dan Boneh, Saba Eskandarian, Ben Fisch';

const CONTENT = `    <p class="text-gray-300">Dan Boneh Stanford University dabo@cs.stanford.edu Saba Eskandarian Stanford University saba@cs.stanford.edu Ben Fisch Stanford University bfisch@cs.stanford.edu</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">EPID signatures are used extensively in real-world systems for hardware enclave attestation. As such, there is a strong interest in making these schemes post-quantum secure. In this paper we initiate the study of EPID signature schemes built only from symmetric primitives, such as hash functions and PRFs. We present two constructions in the random oracle model. The first is a scheme satisfying the EPID signature syntax and security definitions needed for private hardware attestation used in Intel’s SGX. The second achieves significantly shorter signatures for many applications, including the use case of remote hardware attestation. While our EPID signatures for attestation are longer than standard post-quantum signatures, they are short enough for applications where the data being signed is large, such as analytics on large private data sets, or streaming media to a trusted display. We evaluate several instantiations of our schemes so that the costs and benefits of these constructions are clear. Along the way we also give improvements to the zero-knowledge Merkle inclusion proofs of Derler et al. (2017).</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Enhanced Privacy ID, or EPID, signatures allow members of a group to anonymously sign messages on behalf of the group, with the added property that a group manager can revoke the credentials of a misbehaving or compromised group member <em>[16, 38]</em>.</p>

    <p class="text-gray-300">In recent years, EPID signatures have become an important privacy mechanism in real-world systems, most prominently in trusted hardware attestation such as Intel’s SGX. Attestation is a process by which a hardware enclave running on a client device proves the authenticity of its execution environment to a remote party. EPID lets the client device attest without revealing its identity to the remote party. However, EPID signatures used today are not post-quantum secure <em>[16]</em>. An adversary with a quantum computer could subvert the attestation process and break a hardware enclave’s security in the worst possible way.</p>

    <p class="text-gray-300">In light of the above, there is strong interest in developing post-quantum secure EPID signatures. One way to do so is to construct an EPID signature scheme using only symmetric primitives, which are believed to be post-quantum secure. This is analogous to constructing a standard signature scheme from hash functions <em>[9, 17, 21, 45, 46]</em> to obtain a signature scheme whose post-quantum security is virtually assured.</p>

    <p class="text-gray-300">Can we build efficient and secure EPID signatures from symmetric primitives? Bellare et al. <em>[6]</em> give a generic construction of a group signature <em>[22]</em>, a related primitive, from a standard signature scheme, public-key encryption, and a non-interactive zero-knowledge (NIZK) proof. In this generic construction, the group manager adds a member to the group by signing that member’s public key. The member can then sign messages anonymously by first using the private key to sign</p>

    <p class="text-gray-300">the message, and then computing a NIZK proof of knowledge of both this signature and the group manager’s signature on the corresponding public key. This NIZK proof is the member’s group signature. With some work, their framework can be adapted to support the EPID group signature definition of Brickell and Li <em>[16]</em> and to only use symmetric primitives. The NIZK can be built from the “MPC in the Head” technique of Ishai et al. <em>[37, 31, 3]</em> using random oracles, and the standard signature scheme can also be built from one-way functions and collision-resistant hashing <em>[45, 21, 32, 9]</em>. Camenisch and Groth <em>[18]</em> give such a scheme from one-way functions and NIZKs. However, without careful optimization, this generic approach leads to very inefficient signatures due to the need for NIZK proofs on complex circuits (the proof size and prover time of these NIZKs is proportional to the number of multiplication gates in the arithmetic circuit representing the statement).</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">We construct an EPID signature scheme from symmetric primitives, and take a significant step towards reducing the signature size.</p>

    <p class="text-gray-300">Towards this goal, we build two signature schemes. Our first construction greatly reduces the size of the NIZK statement in the signature by using PRFs instead of signatures wherever possible. In particular, we are able to replace the inner group member’s signature in the generic approach with a PRF evaluation. Our construction does not treat the given primitives as a black-box and performs best when instantiated with NIZK-friendly PRFs and CRHFs. In particular, we evaluate the scheme using the LowMC cipher <em>[2]</em>, also including a comparison to AES to show the benefit of choosing the right instantiations for our primitives.</p>

    <p class="text-gray-300">Next, we show how to significantly improve our EPID signature by adapting it to the specific real-world use case where signature verification requires an interaction with the group manager to ensure that the signer has not been revoked. We take advantage of this structure to dramatically reduce the signature size by moving many heavy verification steps outside of the NIZK, without compromising anonymity or affecting security. This significantly shrinks the signature size over the first construction.</p>

    <p class="text-gray-300">Along the way, we develop a technique for proving membership in a Merkle tree, without revealing the leaf location, using a <em>third</em> preimage resistant hash function (Section 5.4). This also provides an improvement to the recent post-quantum accumulators of Derler et al. <em>[25]</em>.</p>

    <p class="text-gray-300">Performance and use cases. In Section 5 we discuss options for instantiating our schemes, and measure the sizes of the resulting signatures under different security assumptions. For the circuit sizes needed inside NIZKs in our construction, ZKB++ <em>[21]</em> provides the most efficient proofs. We report sizes for both the Random Oracle and Quantum Random Oracle models <em>[12]</em> (using the Fiat-Shamir <em>[28]</em> and Unruh <em>[50]</em> transforms, respectively), and find that our second signature scheme, designed for attestation, can support groups of over a million members with 3.45 MB signatures at 128-bit post-quantum security. While these signatures are not short, it is important to keep in mind that several megabytes of traffic for attestation is quite acceptable for many applications of trusted hardware, especially where the data transfer needs of the higher-level application dwarf the size of the attestation.</p>

    <p class="text-gray-300">One example is the case of analytics over large private data sets, an area of heavy investment, both in terms of research and financial resources <em>[30, 53]</em>. In this setting, nodes in a distributed network (or the server in a client-server setting) provide a single remote attestation and then</p>

    <p class="text-gray-300">exchange a great deal of data. As the quantity of data transferred exceeds millions of database records, the size of the initial attestation ceases to present a major bottleneck.</p>

    <p class="text-gray-300">The case of digital rights management (DRM), for which hardware enclaves such as Intel SGX seem particularly well-suited <em>[23]</em>, is another setting where the size of our signatures are acceptable. Consider the common situation where a content provider wishes to stream a movie (easily a few gigabytes in size) to a subscriber while preventing redistribution or unauthorized viewing of copyrighted content <em>[52, 54]</em>. The few additional megabytes of an attestation do not matter next to a film or television series several hundred times its size.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Additional Related Work</h3>

    <p class="text-gray-300">Trusted Hardware and Attestation. Hardware enclaves, particularly Intel’s SGX <em>[23]</em>, have recently been used for a variety of security applications <em>[29, 47]</em>. One of the primary cryptographic components of SGX is its use of direct anonymous attestation, a primitive introduced by Brickell et al. <em>[15]</em>. The EPID attestation mechanism currently in use by SGX, is due to Brickell et al. <em>[16, 38]</em>.</p>

    <p class="text-gray-300">Group Signatures. Anonymous attestation and EPID signatures bear a great deal of similarity to group signatures. Group signatures <em>[22]</em> allow members of a group to anonymously produce signatures on behalf of the group, with the added restriction that a group manager has the power to police the behavior of members, e.g. by revoking their group credentials or stripping their anonymity. The most frequently used definitions of group signatures are described by Bellare et al. <em>[6, 7]</em>. Subsequent work on group signatures has led to various schemes, for example, those of Lysyanskaya and Camenisch <em>[19, 20]</em>, Boneh et al. <em>[11, 13]</em>, and a scheme of Groth <em>[36]</em>. These constructions are not post-quantum secure.</p>

    <p class="text-gray-300">Post-Quantum Signatures and Proofs. Lattice-based cryptography is a popular candidate for post-quantum security. Lattice group signatures were introduced by Gordon et al. <em>[35]</em> and extended in several subsequent works <em>[41, 42, 43, 44]</em>. The resulting group signatures are shorter than the ones developed here, but rely on qualitatively stronger post-quantum assumptions.</p>

    <p class="text-gray-300">Another set of post-quantum tools come from the “MPC in the Head” technique <em>[37]</em> for zero-knowledge proofs. This idea has been extended by ZKBoo <em>[31]</em>, ZKB++ <em>[21]</em>, and Ligero <em>[3]</em>. In particular, Chase et al. use ZKB++ to construt two post-quantum signature schemes Fish and Picnic <em>[21]</em>. The recent development of zk-STARKS <em>[8]</em> opens another avenue to post-quantum zero-knowledge proofs. In concurrent work, El Bansarkhani and Misoczki <em>[4]</em> describe a stateful group signature scheme based on hash functions. Their work features small signature sizes but large keys. Derler et al <em>[25]</em> and Katz et al <em>[39]</em> also concurrently study post-quantum group and ring signatures from symmetric primitives.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. Let <span class="math">x\\leftarrow F(y)</span> denote the assignment of the output of <span class="math">F(y)</span> to <span class="math">x</span>, and let <span class="math">x\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}S</span> denote assignment to <span class="math">x</span> of a uniformly random element sampled from set <span class="math">S</span>. We use <span class="math">\\lambda</span> to refer to a security parameter and sometimes omit it if its presence is implicit. The notation <span class="math">[k]</span> represents the set of integers <span class="math">1,2,...,k</span>, and <span class="math">\\emptyset</span> denotes the empty set. We use <span class="math">\\mathcal{A}^{H}</span> to denote that <span class="math">\\mathcal{A}</span> has oracle access to some function <span class="math">H</span>. A function <span class="math">\\mathsf{negl}(x)</span> is <em>negligible</em> if for all <span class="math">c&gt;0</span>, there is an <span class="math">x_{0}</span> such that for any <span class="math">x&gt;x_{0}</span>, <span class="math">\\mathsf{negl}(x)&lt;\\frac{1}{x^{c}}</span>. We omit <span class="math">x</span> if the parameter is implicit. We use <span class="math">f(x)\\approx g(x)</span> to mean that for two functions <span class="math">f,g</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x)-g(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\mathsf{negl}(x)$. PPT stands for probabilistic polynomial time. We use</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the notation <span class="math">\\mathsf{Func}_{\\mathcal{A},\\mathcal{B}}\\langle a,b\\rangle</span> to refer to a protocol <span class="math">\\mathsf{Func}</span> between parties <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{B}</span> with inputs <span class="math">a</span> and <span class="math">b</span>, respectively. Finally, we allow algorithms to output <span class="math">\\perp</span> to indicate failure.</p>

    <p class="text-gray-300">Standard Primitives. In Appendix A we define the standard cryptographic primitives used throughout the paper. In particular, we define pseudorandom functions, secure signatures, commitments, and collision resistant hashing.</p>

    <p class="text-gray-300">Proof Systems. We briefly review the definitions of proof systems that we will need in later sections. The main notion we will use is that of a non-interactive zero knowledge proof of knowledge in the random oracle model. We use the definitions of <em>[27]</em>, which modify prior commom reference string-based definitions of non-interactive zero-knowledge for use in the Random Oracle Model.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1 (Non-interactive Proof System).</h6>

    <p class="text-gray-300">A non-interactive proof system <span class="math">\\Pi</span> for a relation <span class="math">R</span> consists of prover algorithm that on input <span class="math">x,w</span> outputs a proof <span class="math">\\pi</span> and a verifier algorithm that on input <span class="math">x,\\pi</span> outputs a bit <span class="math">b</span>. We say that <span class="math">(P,V)</span> is correct and sound if it satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x,w)\\in R\\to V(x,P(x,w))=1</span></li>

      <li><span class="math">(x,w)\\notin R\\to\\mathsf{Pr}[V(x,P^{<em>}(x,w))=1]&lt;\\mathsf{negl}</span> for any (potentially cheating) prover <span class="math">P^{</em>}</span>.</li>

    </ul>

    <p class="text-gray-300">For convenience and clarity of notation, we use <span class="math">P(\\mathsf{public}(\\cdot),\\mathsf{private}(\\cdot),R)</span> to indicate that the public parts of the input to a prover <span class="math">P</span> for relation <span class="math">R</span> correspond to the statement <span class="math">x</span> and that the private parts correspond to the witness <span class="math">w</span>.</p>

    <p class="text-gray-300">The zero-knowledge property <em>[34]</em> informally requires that a proof reveals nothing about <span class="math">(x,w)</span> except that <span class="math">(x,w)\\in R</span>. Formally, we model this property by describing a <em>simulator</em> that can provide a legitimate proof given only <span class="math">x</span> and not <span class="math">w</span> <em>[5]</em>.</p>

    <p class="text-gray-300"><em>Extractability</em>, informally, is a strengthening of the soundness property that requires any acceptable proof to have an <em>extractor</em> algorithm that can efficiently recover <span class="math">w</span> with high probability given the ability to interact with the prover. We refer to Bellare and Goldreich <em>[5]</em> for a full definition. Simulation-sound extractability <em>[36, 48, 49]</em> further strengthens the extractability requirement of proofs of knowledge to enable extracting a witness even after seeing many simulated proofs.</p>

    <p class="text-gray-300">EPID Signatures. We construct our EPID signature to match the syntax and security requirements as defined by Brickel and Li <em>[16]</em>. In this section we state the EPID syntax and sketch security requirements. Full definitions and security games appear in Appendix B. First, anonymity must ensure that the group manager colluding with any number of group members cannot uncover the identity of the signer. In particular, we do not want the group manager to have a tracing key that lets it compromise a group member’s identity from a signature. Nevertheless, we will later briefly explain how to extend our scheme to achieve traceability, if desired.</p>

    <p class="text-gray-300">Second, we want a revocation property where a group manager can revoke a user’s ability to sign by either:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>adding a revoked user’s leaked signing key to a revocation list KEY-RL, or</li>

      <li>adding a revoked user’s EPID signature to a revocation list SIG-RL.</li>

    </ul>

    <p class="text-gray-300">A user is revoked if its key is included in the list KEY-RL, or if any of its signatures are included in the list SIG-RL.</p>

    <p class="text-gray-300">With this setup, we define the syntax and security properties for an EPID signature scheme as follows.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2 (EPID Signature).</h6>

    <p class="text-gray-300">An EPID signature scheme <span class="math">\\mathcal{G}</span> involving a group manager <span class="math">\\mathcal{M}</span> and <span class="math">n</span> group members, parties <span class="math">\\mathcal{P}_{1}</span> to <span class="math">\\mathcal{P}_{n}</span>, consists of algorithms Init, Join, GPSign, GPVerify, RevokeKey and RevokeSig:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{gsk},\\mathsf{gpk})\\leftarrow\\mathsf{Init}(1^{\\lambda})</span>: This algorithm takes as input a security parameter <span class="math">1^{\\lambda}</span> and outputs a key pair <span class="math">(\\mathsf{gsk},\\mathsf{gpk})</span>.</li>

      <li><span class="math">\\langle\\mathsf{cert}_{i},(\\mathsf{sk}_{i},\\mathsf{cert}_{i})\\rangle\\leftarrow\\mathsf{Join}_{\\mathcal{M},\\mathcal{P}_{i}}\\langle(\\mathsf{gsk},\\mathsf{gpk}),\\mathsf{gpk}\\rangle</span>: This is a protocol between the group manager and a group member <span class="math">\\mathcal{P}_{i}</span> where each party has its keys as input, and both parties get party <span class="math">\\mathcal{P}_{i}</span>’s certificate as output. <span class="math">\\mathcal{P}_{i}</span> also gets its secret key <span class="math">\\mathsf{sk}_{i}</span> as an output.</li>

      <li><span class="math">\\bot/\\mathsf{sig}\\leftarrow\\mathsf{GPSign}(\\mathsf{gpk},\\mathsf{sk}_{i},\\mathsf{cert}_{i},m,\\mathsf{SIG-RL})</span>: This algorithm takes as input the public key, a signature revocation list <span class="math">\\mathsf{SIG-RL}</span>, and party <span class="math">\\mathcal{P}_{i}</span>’s secret key and certificate. The output is an EPID signature <span class="math">\\mathsf{sig}</span>.</li>

      <li><span class="math">1/0\\leftarrow\\mathsf{GPVerify}(\\mathsf{gpk},m,\\mathsf{KEY-RL},\\mathsf{SIG-RL},\\mathsf{sig})</span>: This algorithm verifies an EPID signature <span class="math">\\mathsf{sig}</span> on a message <span class="math">m</span> given the group public key and key/signature revocation lists <span class="math">\\mathsf{KEY-RL}</span>, <span class="math">\\mathsf{SIG-RL}</span>. It outputs <span class="math">1</span> to accept the signature and <span class="math">0</span> to reject it.</li>

      <li><span class="math">\\mathsf{KEY-RL}\\leftarrow\\mathsf{RevokeKey}(\\mathsf{gpk},\\mathsf{KEY-RL},\\mathsf{sk}_{i})</span>: This algorithm adds a secret key <span class="math">\\mathsf{sk}_{i}</span> to a key revocation list, so signatures created with this key will no longer be accepted.</li>

      <li><span class="math">\\mathsf{SIG-RL}\\leftarrow\\mathsf{RevokeSig}(\\mathsf{gpk},\\mathsf{KEY-RL},\\mathsf{SIG-RL},m,\\mathsf{sig})</span>: This algorithm adds a signature <span class="math">\\mathsf{sig}</span> to a signature revocation list, so signatures created with the same key as <span class="math">\\mathsf{sig}</span> will no longer be accepted.</li>

    </ul>

    <p class="text-gray-300">The algorithms must satisfy Correctness (Definition 20), Anonymity (Definition 23), and Unforgeability (Definition 26).</p>

    <p class="text-gray-300">For correctness, we require that if a group member has successfully completed the Join procedure and neither its key nor any of its signatures have been revoked, then that group member’s signatures should successfully verify.</p>

    <p class="text-gray-300">We define anonymity via the Anonymity game. Informally, the property of being Anonymous requires that signatures in <span class="math">\\mathcal{G}</span> hide the identity of the signer against any coalition of group members (including the group manager) except the signer herself. The definition of anonymity also implies notions of unlinkability between a signer and her signatures. The game allows the adversary to create users, sign messages, and corrupt users of its choosing before attempting to distinguish which of two uncorrupted users produced a signature on a challenge message of the adversary’s choice.</p>

    <p class="text-gray-300">Finally, we define unforgeability. Our unforgeability game consists of an adversary who can add arbitrary parties to a group and corrupt arbitrarily many members of a group. Security holds if this adversary cannot forge the signature of an uncorrupted party on a message of its own choosing.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Post-Quantum EPID Signatures</h2>

    <p class="text-gray-300">In this section we describe and prove the security of our first post-quantum EPID signature scheme. Our construction uses a standard signature scheme where each group member has its own key pair and a <em>certificate</em> from the group manager. Instead of signature keys, however, we construct our scheme so that each group member has a unique PRF secret key that will be used to issue EPID signatures. As we will see, this leads to significant savings over the general framework of Bellare</p>

    <p class="text-gray-300">et al. [6]. We still need a signature scheme for the group manager to produce certificates, but the NIZK proof is done over a circuit that verifies a single signature (the group manager's) along with a few evaluations of the PRF. An overview of the construction is as follows. Each member generates its own secret key <span class="math">\\mathsf{sk}</span> for a PRF <span class="math">f</span>. During the join procedure it obtains a challenge <span class="math">c</span> from the group manager, sends <span class="math">t = f(\\mathsf{sk}, c)</span> to the manager, and obtains back a signature <span class="math">\\sigma</span> on <span class="math">t</span>. To sign a message, the member first reveals <span class="math">t&#x27; = (f(\\mathsf{sk}, r), r)</span> for random <span class="math">r</span> and then a signature of knowledge, where the proof witness is <span class="math">\\mathsf{sk}</span> consistent with <span class="math">t&#x27;</span> as well as <span class="math">\\sigma</span>, i.e., a signature on <span class="math">f(\\mathsf{sk}, c^<em>)</span> for some <span class="math">c^</em></span>. Including <span class="math">t&#x27;</span> in the clear is used for signature revocation. Note that signatures need to be verified relative to the same signature revocation lists under which they were signed.</p>

    <p class="text-gray-300"><strong>Collision Resistant PRF.</strong> We state and prove security of our scheme using a function <span class="math">f: \\mathcal{K} \\times \\mathcal{X} \\to \\mathcal{Y}</span> that is both a secure PRF and a collision resistant function. In fact, it suffices that <span class="math">f</span> be collision-resistant on the keyspace, meaning that for a target input <span class="math">x \\in \\mathcal{X}</span> chosen by the adversary, it should be hard to find <span class="math">k_0 \\neq k_1 \\in \\mathcal{K}</span> such that <span class="math">f(k_0, x) = f(k_1, x)</span>. We explain how to construct an MPC-friendly function with this property in Section 5.</p>

    <p class="text-gray-300"><strong>Construction 3 (EPID Signature).</strong> Our EPID signature scheme <span class="math">\\mathcal{G} = (\\text{Init}, \\text{Join}, \\text{GPSign}, \\text{GPVerify}, \\text{RevokeKey}, \\text{RevokeSig})</span> with security parameter <span class="math">\\lambda</span> uses a signature scheme <span class="math">\\mathcal{S} = (\\text{Keygen}, \\text{Sign}, \\text{Verify})</span>, a proof system <span class="math">\\Pi = (P, V)</span>, and a PRF <span class="math">f</span> that also serves as a collision-resistant hash function.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Init}(1^{\\lambda})</span>: Group manager <span class="math">\\mathcal{M}</span> runs <span class="math">\\text{Keygen}(1^{\\lambda})</span> to get (gpk, gsk) and outputs this tuple (gpk is published and gsk kept secret).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Join}_{\\mathcal{M}, \\mathcal{P}_i} \\langle (\\mathsf{gsk}, \\mathsf{gpk}), \\mathsf{gpk} \\rangle</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Group manager <span class="math">\\mathcal{M}</span> sends challenge <span class="math">c_i</span> to member <span class="math">\\mathcal{P}_i</span>.</li>

      <li><span class="math">\\mathcal{P}_i</span> chooses <span class="math">\\mathsf{sk}_i \\xleftarrow{\\text{in}} \\{0,1\\}^\\lambda</span> and sends <span class="math">t_i^{\\text{join}} = f(\\mathsf{sk}_i, c_i)</span> back to <span class="math">\\mathcal{M}</span>.</li>

      <li><span class="math">\\mathcal{M}</span> produces signature <span class="math">\\sigma_i = \\text{Sign}(\\mathsf{gsk}, (t_i^{\\text{join}}, c_i))</span>, and constructs <span class="math">\\mathsf{cert}_i = (t_i^{\\text{join}}, c_i, \\sigma_i)</span>, sending a copy to <span class="math">\\mathcal{P}_i</span>. If the signature scheme is stateful, then algorithm Join must maintain a counter that is incremented for every user who joins the group.</li>

      <li>The group member's private key is <span class="math">\\mathsf{sk}_i</span> and both parties get copies of <span class="math">\\mathsf{cert}_i</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{GPSign}(\\mathsf{gpk}, \\mathsf{sk}_i, \\mathsf{cert}_i, m, \\text{SIG-RL})</span>: Compute the following and output <span class="math">\\mathsf{sig}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r \\xleftarrow{\\text{in}} \\{0,1\\}^\\lambda \\backslash c_i</span></li>

      <li><span class="math">t \\leftarrow (f(\\mathsf{sk}_i, r), r)</span></li>

      <li><span class="math">\\pi \\leftarrow P\\big(\\text{public}(\\lambda, m, \\mathsf{gpk}, t, \\text{SIG-RL}, \\text{KEY-RL}), \\text{private}(\\mathsf{sk}_i, \\mathsf{cert}_i), R_1\\big)</span></li>

      <li><span class="math">\\mathsf{sig} \\leftarrow (t, \\pi)</span>.</li>

    </ul>

    <p class="text-gray-300">We define the relation <span class="math">R_{1}</span> in the proof of knowledge <span class="math">\\pi</span> for <span class="math">(\\mathsf{sk}_i^<em>, \\mathsf{cert}_i^</em>)</span> to be true when the following statements hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t = (f(\\mathsf{sk}_i^*, r), r)</span></li>

      <li><span class="math">r \\neq c_i^*</span></li>

      <li><span class="math">\\text{Verify}(\\mathsf{gpk}, (t_i^{\\text{join<em>}}, c_i^</em>), \\sigma_i^*) = 1</span></li>

      <li><span class="math">t_i^{\\text{join<em>}} = f(\\mathsf{sk}_i^</em>, c_i^*)</span></li>

      <li>for each <span class="math">\\mathsf{sig}_j \\in \\text{SIG-RL}, t_{\\mathsf{sig}_j} \\neq (f(\\mathsf{sk}_i^*, r_{\\mathsf{sig}_j}), r_{\\mathsf{sig}_j})</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GPVerify(gpk, m, KEY-RL, SIG-RL, sig):</li>

      <li>Verify proof <span class="math">\\pi</span>: check <span class="math">V((\\lambda,m,\\mathsf{gpk},t,\\mathsf{SIG-RL},\\mathsf{KEY-RL}),\\pi)=1</span>.</li>

      <li>For each <span class="math">\\mathsf{sk}_{j}\\in\\mathsf{KEY-RL}</span>, check that <span class="math">t\\neq(f(\\mathsf{sk}_{j},r),r)</span>.</li>

      <li>Check that <span class="math">\\mathsf{sig}\\notin\\mathsf{SIG-RL}</span>.</li>

      <li>Output 1 if all of the above checks return 1; otherwise, output 0.</li>

      <li>RevokeKey(gpk, KEY-RL, <span class="math">\\mathsf{sk}_{i}</span>): Return <span class="math">\\mathsf{KEY-RL}\\cup\\{\\mathsf{sk}_{i}\\}</span>.</li>

      <li>RevokeSig(gpk, KEY-RL, SIG-RL, <span class="math">m</span>, <span class="math">\\mathsf{sig}</span>): return <span class="math">\\mathsf{SIG-RL}\\cup\\{\\mathsf{sig}\\}</span> if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{GPVerify(gpk, m, KEY-RL, SIG-RL, sig)}=1</span>. Otherwise, return <span class="math">\\mathsf{SIG-RL}</span>.</p>

    <p class="text-gray-300">Performance. We discuss concrete instantiations of this scheme, and their performance in Section 5.</p>

    <p class="text-gray-300">Revocation. Although the difference between the two forms of revocation does not affect our scheme’s security, the effect of revocation differs in practice depending on whether a group member is revoked by key or by signature. A revocation by key renders all signatures, past or future, invalid for that user, whereas a revocation by signature only applies to future signatures because past signatures need to be verified with respect to the SIG-RL in place at the time of signing. This does not matter for the purposes of the security game because the attempted forgery is always the last signature produced in the game. For the same reason, the decision to include the check that <span class="math">\\mathsf{sig}\\notin\\mathsf{SIG-RL}</span> during <span class="math">\\mathsf{GPVerify}</span> does not affect security for the purpose of the proof and can be omitted. We include it only to better capture behavior that may be expected of revocation in practice.</p>

    <p class="text-gray-300">Traceable Signatures. Our approach can also be used to achieve traceability. Traceability requires that the group manager have the power to learn the identity of a signer. We presented our scheme without a tracing property in order to guarantee a stronger anonymity property against the group manager, but a similar approach could be used to achieve traceability. The group manager could give each group member a signed secret token <span class="math">\\mathsf{sk}_{i}^{\\prime\\prime}</span>, and every signature would include the token <span class="math">t^{\\prime}=(f(\\mathsf{sk}_{i}^{\\prime\\prime},r^{\\prime}),r^{\\prime})</span>, for a newly picked random <span class="math">r^{\\prime}</span>, along with a proof of knowledge of a signature on <span class="math">\\mathsf{sk}_{i}^{\\prime\\prime}</span>. Now the group manager can trace a signature by trying to reconstruct <span class="math">t^{\\prime}</span> with the value of <span class="math">\\mathsf{sk}_{i}^{\\prime\\prime}</span> for each signer, but anonymity will still hold against any other group member.</p>

    <p class="text-gray-300">Camenisch and Groth <em>[18]</em> give a traceable group signature scheme from one-way functions and NIZKs. Although their scheme can be instantiated under the same assumptions as ours, they (loosely speaking) include a commitment to a credential for each group member in their public key and give a proof of knowledge that a signature corresponds to one of those credentials. By avoiding this cost, our scheme shrinks both the public key size and signature size by a factor <span class="math">O(N)</span>. Our public key can also be published at group initialization time before any members have joined the group.</p>

    <p class="text-gray-300">Security Theorems. We now state our various theorems regarding the security of our scheme and give a brief intuition to justify them. Proofs are deferred to Appendix C. Correctness follows almost immediately from the construction with the caveat that we must ensure that the revocation checks do not accidentally cause a signature from a legitimate key to be rejected.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Assuming the correctness of signature scheme <span class="math">\\mathcal{S}</span> and proof system <span class="math">\\Pi</span> and the pseudo-randomness of <span class="math">f</span>, <span class="math">\\mathcal{G}</span> is a correct EPID signature scheme.</p>

    <p class="text-gray-300">Anonymity follows from the zero-knowledge and pseudorandomness properties of the primitives used in our construction. Intuitively, the scheme achieves anonymity against the group manager by having each group member generate its own PRF secret key <span class="math">\\mathsf{sk}</span>, and from all other parties because the signatures are zero-knowledge signatures of knowledge.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Assuming that <span class="math">\\Pi</span> is a zero-knowledge proof system and that <span class="math">f</span> is a PRF, <span class="math">\\mathcal{G}</span> is an anonymous EPID signature scheme.</p>

    <p class="text-gray-300">The high level intuition for unforgeability is as follows. If the adversary <span class="math">A</span> has not obtained a signature from the group manager on <span class="math">t=f(sk,c)</span> then it cannot produce a PoK of valid signature on <span class="math">t</span> by unforgeability of the group manager’s signature scheme and soundness of the PoK. Second, if <span class="math">A</span> does not know <span class="math">sk</span> for some <span class="math">t=f(sk,c)</span> that has been signed, then even though it sees many <span class="math">f(sk,r),r</span> inside signatures it cannot produce <span class="math">f(sk,c^{<em>})</span> on a fresh <span class="math">c^{</em>}</span> by the security of the PRF. (Note that even if it were able to do this it has to actually learn <span class="math">sk</span> to forge a signature as otherwise it breaks PoK extractability). Finally, collision-resistance of the PRF ensures that <span class="math">A</span> who has a signature on <span class="math">f(sk,c)</span> for revoked <span class="math">sk</span> cannot find <span class="math">sk^{\\prime}\\neq sk</span> and <span class="math">r</span> such that <span class="math">f(sk^{\\prime},c)=t</span> and <span class="math">f(sk^{\\prime},r)\\neq f(sk,r)</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Assuming that <span class="math">\\Pi</span> is a zero knowledge proof of knowledge proof system with simulation-sound extractability, <span class="math">\\mathcal{S}</span> is an unforgeable signature scheme, that <span class="math">f</span> is a PRF, and that <span class="math">f</span> is additionally a collision-resistant hash function, <span class="math">\\mathcal{G}</span> is an unforgeable EPID signature scheme.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Practical Post-Quantum Signatures for Attestation</h2>

    <p class="text-gray-300">Attestation schemes (such as that used in Intel SGX <em>[23, 38]</em>) involve interaction with an attestation service on every attestation, among other reasons to obtain an updated revocation list. In the case of SGX, this attestation service is also the group manager. In this section, we present a significantly smaller post-quantum EPID-like signature scheme appropriate for this setting where frequent interaction with the group manager is allowed.</p>

    <p class="text-gray-300">The main bottleneck for signature size in our first construction was including verification of the group manager’s signature on a group member’s certificate inside the PoK (i.e. this contributed the most to arithmetic complexity). We remove this signature in our new scheme by making each group member’s certificate a leaf in a Merkle tree. The group manager signs only the root, providing each group member an inclusion proof during Join. The signature on the root can be public as it leaks nothing about the identity of a member. Signers now only need to include the Merkle inclusion proof inside the proof of knowledge instead of a hash-based signature. The verification of an inclusion proof requires a much smaller circuit.</p>

    <p class="text-gray-300">This modification has several implications for security. As a new Merkle tree root will need to be published each time a group member joins, this reduces the size of anonymity sets. In an extreme case the group manager could issue a sequence of Merkle roots where each tree only included a valid credential for one group member, uniquely identifying the member’s signatures.</p>

    <p class="text-gray-300">Fortunately, the continuing contact between group members and the group manager enforced by attestation in practice enable effective mitigations for these concerns. Group members can periodically “re-join” the group to update the Merkle root relative to which they provide membership proofs, thereby increasing the size of their anonymity sets. In practice, we can ensure that subsequent Merkle roots issued by the group manager only ever add new credentials to the group and</p>

    <p class="text-gray-300">never omit previous ones by using a <em>Merkle consistency proof</em> such as the one proposed by the Certificate Transparency standard <em>[40]</em> and proven secure by Dowling et al <em>[26]</em>. We model the Merkle trees used in our proofs as accumulators with zero-knowledge membership proofs and discuss how we instantiate this primitive with an improved construction in Section 5.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 Definitions</h3>

    <p class="text-gray-300">In this section we define accumulators and EPID-like signatures for attestation. We begin with a special case of the formalization of accumulators by <em>[24]</em>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 7 (Accumulator).</h6>

    <p class="text-gray-300">A static accumulator is a tuple of efficient algorithms (AGen, AEval, AWitCreate, AVerify, AProveCon, ACheckCon) which are defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AGen(<span class="math">1^{\\lambda}</span>): This algorithm takes a security parameter <span class="math">\\lambda</span> and returns a public key <span class="math">\\mathsf{pk}_{\\wedge}</span>.</li>

      <li>AEval(<span class="math">\\mathsf{pk}_{\\wedge},\\mathcal{X}</span>): This deterministic algorithm takes a key <span class="math">\\mathsf{pk}_{\\wedge}</span> and a set <span class="math">\\mathcal{X}</span> to be accumulated and returns an accumulator <span class="math">\\Lambda_{\\mathcal{X}}</span>.</li>

      <li>AWitCreate(<span class="math">\\mathsf{pk}_{\\wedge},\\Lambda_{\\mathcal{X}},\\mathcal{X},x_{i}</span>): This algorithm takes a key <span class="math">\\mathsf{pk}_{\\wedge}</span>, an accumulator <span class="math">\\Lambda_{\\mathcal{X}}</span>, the set <span class="math">\\mathcal{X}</span>, and a value <span class="math">x_{i}</span>. It returns <span class="math">\\perp</span> if <span class="math">x_{i}\\notin\\mathcal{X}</span> and a witness <span class="math">\\mathsf{wit}_{x_{i}}</span> for <span class="math">x_{i}</span> otherwise.</li>

      <li>AVerify(<span class="math">\\mathsf{pk}_{\\wedge}</span>, <span class="math">\\Lambda_{\\mathcal{X}}</span>, <span class="math">\\mathsf{wit}_{x_{i}}</span>, <span class="math">x_{i}</span>): This algorithm takes a public key <span class="math">\\mathsf{pk}_{\\wedge}</span>, an accumulator <span class="math">\\Lambda_{\\mathcal{X}}</span>, a witness <span class="math">\\mathsf{wit}_{x_{i}}</span>, and a value <span class="math">x_{i}</span>. It returns 1 if <span class="math">\\mathsf{wit}_{x_{i}}</span> is a witness for <span class="math">x_{i}\\in\\mathcal{X}</span> and 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">We require accumulators to be correct, meaning that AVerify will accept an honestly generated witness for <span class="math">x_{i}\\in\\mathcal{X}</span>. We also require a soundness property dubbed <em>collision-freeness</em>, formally defined below.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 8 (Collision Freeness).</h6>

    <p class="text-gray-300">An accumulator is collision free if for all PPT adversaries <span class="math">\\mathcal{A}</span>, we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Pr}[\\mathsf{AVerify}(\\mathsf{pk}_{\\wedge},\\Lambda^{<em>},\\mathsf{wit}_{x_{i}}^{</em>},x_{i}^{<em>})=1\\wedge x_{i}^{</em>}\\notin\\mathcal{X}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{pk}_{\\wedge}\\leftarrow\\mathsf{AGen}(1^{\\lambda},\\Lambda^{<em>}),\\Lambda^{</em>}\\leftarrow\\mathsf{Eval}_{r^{<em>}}(\\mathsf{pk}_{\\wedge},\\mathcal{X}^{</em>}),(\\mathsf{wit}_{x_{i}}^{<em>},x_{i}^{</em>},\\mathcal{X}^{<em>})\\leftarrow\\mathcal{A}(\\mathsf{pk}_{\\wedge},\\Lambda^{</em>})]\\leq\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">The setting of EPID signatures for attestation largely leaves the security definitions of Section 3 unaffected up to changes in syntax, so we present the updated syntax in Appendix D and omit statements of the security definitions. The only notable changes are that 1) in both security games the adversary can now choose to have a group member run the new GARejoin at any time it chooses, and 2) signatures are only indistinguishable for two signatures produced relative to the same accumulator.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.2 EPID Signature Construction II</h3>

    <p class="text-gray-300">The full construction of the modified EPID signature scheme appears below. Structurally similar to the construction in Section 3, the main changes involve the introduction of a post-quantum accumulator and the resulting restructuring of what needs to be proven inside/outside the proof of knowledge <span class="math">\\pi</span>, as described informally at the beginning of this section.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">Construction 9 (EPID Signature for Attestation). Our EPID signature scheme for attestation <span class="math">\\mathcal{GA} = (\\text{GAInit}, \\text{GAJoin}, \\text{GARejoin}, \\text{GASign}, \\text{GAVerify}, \\text{GARevokeKey}, \\text{GARevokeSig})</span> with security parameter <span class="math">\\lambda</span> uses a signature scheme <span class="math">\\mathcal{S} = (\\text{Keygen}, \\text{Sign}, \\text{Verify})</span>, a proof system <span class="math">\\Pi = (P, V)</span>, a PRF <span class="math">f</span> that also serves as a collision-resistant hash function, and an accumulator <span class="math">\\mathcal{A}c = (\\text{AGen}, \\text{AEval}, \\text{AWitCreate}, \\text{AVerify})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{GAInit}(1^{\\lambda})</span>: Group manager <span class="math">\\mathcal{M}</span> runs <span class="math">\\text{Keygen}(1^{\\lambda})</span> to get <span class="math">(\\mathsf{pk}_{\\mathsf{gp}}, \\mathsf{sk}_{\\mathsf{gp}})</span> and runs <span class="math">\\mathsf{AGEN}(1^{\\lambda})</span>, to get <span class="math">\\mathsf{pk}_{\\wedge}</span>. It outputs public key <span class="math">\\mathsf{gpk} = (\\mathsf{pk}_{\\mathsf{gp}}, \\mathsf{pk}_{\\wedge})</span> and secret key <span class="math">\\mathsf{gsk} = \\mathsf{sk}_{\\mathsf{gp}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{GAJoin}_{\\mathcal{M},\\mathcal{P}_i}\\langle (\\mathsf{gsk},\\mathsf{gpk},\\mathcal{X}),\\mathsf{gpk}\\rangle</span>:</li>

      <li>Group manager <span class="math">\\mathcal{M}</span> sends challenge <span class="math">c_{i}</span> to member <span class="math">\\mathcal{P}_i</span>.</li>

      <li><span class="math">\\mathcal{P}_i</span> picks <span class="math">\\mathsf{sk}_i \\xleftarrow{\\mathrm{sc}} \\{0,1\\}^{\\lambda}</span> and sends <span class="math">t_i^{\\mathrm{join}} = f(\\mathsf{sk}_i, c_i)</span> back to <span class="math">\\mathcal{M}</span>.</li>

      <li><span class="math">\\mathcal{M}</span> defines <span class="math">x_{i} = (t_{i}^{\\mathrm{join}},c_{i})</span>, sets <span class="math">\\mathcal{X} = \\mathcal{X}\\cup x_{i}</span>, sets <span class="math">\\Lambda = \\mathsf{AEval}(\\mathsf{pk}_{\\wedge},\\mathcal{X})</span>, and produces signature <span class="math">\\sigma_{\\wedge} = \\mathsf{Sign}(\\mathsf{gsk},\\Lambda)</span>. Next, <span class="math">\\mathcal{M}</span> creates <span class="math">\\mathsf{wit}_{x_i} = \\mathsf{AWitCreate}(\\mathsf{pk}_{\\wedge},\\Lambda ,\\mathcal{X},x_i)</span> and constructs <span class="math">\\mathsf{cert}_i = (x_i,\\mathsf{wit}_{x_i})</span>, sending a copy to <span class="math">\\mathcal{P}_i</span> along with <span class="math">\\Lambda</span> and <span class="math">\\sigma_{\\wedge}</span>.</li>

      <li>The group member's private key is <span class="math">\\mathsf{sk}_i</span> and both parties get copies of <span class="math">\\mathsf{cert}_i</span>, <span class="math">\\Lambda</span>, and <span class="math">\\sigma_{\\wedge}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{GARejoin}_{\\mathcal{M},\\mathcal{P}_i}\\langle (\\mathsf{gsk},\\mathsf{gpk},\\mathcal{X},\\Lambda ,\\sigma_{\\wedge}),(\\mathsf{gpk},\\mathsf{cert}_i)\\rangle</span>:</li>

      <li><span class="math">\\mathcal{P}_i</span> sends <span class="math">\\mathsf{cert}_i</span> to <span class="math">\\mathcal{M}</span>.</li>

      <li>First, <span class="math">\\mathcal{M}</span> verifies the signature in <span class="math">\\mathsf{cert}_i</span>, aborting in case of failure. Then it creates a new <span class="math">\\mathsf{wit}_{x_i} = \\mathsf{AWitCreate}(\\mathsf{pk}_{\\wedge}, \\Lambda, \\mathcal{X}, x_i)</span> and constructs the updated <span class="math">\\mathsf{cert}_i = (x_i, \\mathsf{wit}_{x_i})</span>, sending a copy to <span class="math">\\mathcal{P}_i</span> along with <span class="math">\\Lambda</span> and <span class="math">\\sigma_{\\wedge}</span>.</li>

      <li><span class="math">\\mathcal{P}_i</span> updates its values of <span class="math">\\mathsf{cert}_i</span>, <span class="math">\\Lambda</span>, and <span class="math">\\sigma_{\\wedge}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{GASign}(\\mathsf{gpk},\\mathsf{sk}_i,\\mathsf{cert}_i,m,\\mathsf{SIG-RL},\\Lambda ,\\sigma_{\\wedge})</span>: Compute the following and output <span class="math">\\mathsf{sig}</span>:</li>

      <li>Verify <span class="math">(\\mathsf{pk}_{\\mathsf{gp}},\\sigma_{\\wedge},\\Lambda)</span> (abort if it outputs 0)</li>

      <li><span class="math">r \\xleftarrow{\\mathrm{sc}} \\{0,1\\}^{\\lambda} \\backslash c_i</span></li>

      <li><span class="math">t = (f(\\mathsf{sk}_i,r),r)</span></li>

      <li><span class="math">\\pi = P(\\text{public}(\\lambda, m, \\mathsf{gpk}, t, \\mathsf{SIG-RL}, \\mathsf{KEY-RL}, \\Lambda), \\text{private}(\\mathsf{sk}_i, \\mathsf{cert}_i), R_2)</span></li>

      <li><span class="math">\\mathsf{sig} = (t,\\pi ,\\Lambda ,\\sigma_{\\wedge})</span>.</li>

    </ul>

    <p class="text-gray-300">We define <span class="math">R_{2}</span> as a relation in the proof of knowledge of <span class="math">(\\mathsf{sk}_i^<em>,\\mathsf{cert}_i^</em>)</span> such that the following statements hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t = (f(\\mathsf{sk}_i^*,r),r)</span></li>

      <li><span class="math">r\\neq c_i^*</span></li>

      <li><span class="math">\\mathsf{AVerify}(\\mathsf{pk}_{\\wedge},\\Lambda ,\\mathsf{wit}_{x_i}^<em>,(t_i^{\\mathrm{join</em>}},c_i^*))</span></li>

      <li><span class="math">t_i^{\\mathrm{join<em>}} = f(\\mathsf{sk}_i^</em>,c_i^*)</span></li>

      <li>for each <span class="math">\\mathsf{sig}_j\\in \\mathsf{SIG - RL},t_{\\mathsf{sig}_j}\\neq (f(\\mathsf{sk}_i^*,r_{\\mathsf{sig}_j}),r_{\\mathsf{sig}_j})</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{GAVerify}(\\mathsf{gpk},\\mathsf{m},\\mathsf{KEY - RL},\\mathsf{SIG - RL},\\mathsf{sig})</span>:</li>

      <li>Verify signature <span class="math">\\sigma_{\\wedge}</span>: check <span class="math">\\mathsf{Verify}(\\mathsf{pk}_{\\mathsf{gp}},\\sigma_{\\wedge},\\Lambda) = 1</span></li>

      <li>Verify proof <span class="math">\\pi</span>: check <span class="math">V((\\lambda, m, \\mathsf{gpk}, t, \\mathsf{SIG-RL}, \\mathsf{KEY-RL}, \\Lambda), \\pi) = 1</span>.</li>

      <li>For each <span class="math">\\mathsf{sk}_j\\in \\mathsf{KEY - RL}</span>, check that <span class="math">t\\neq (f(\\mathsf{sk}_j,r),r)</span>.</li>

      <li>Check that <span class="math">\\mathsf{sig} \\notin \\mathsf{SIG - RL}</span>.</li>

      <li>If all of the above checks return 1, output 1. Else, output 0.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GARevokeKey(gpk, KEY-RL, sk_{i}): Return KEY-RL <span class="math">\\cup</span> sk_{i}.</li>

      <li>GARevokeSig(gpk, KEY-RL, SIG-RL, <span class="math">m</span>, sig): If GAVerify(gpk, m, KEY-RL, SIG-RL, sig) = 1, return SIG-RL <span class="math">\\cup</span> sig. Otherwise, return SIG-RL.</li>

    </ul>

    <p class="text-gray-300">Performance. We discuss concrete instantiations of this scheme, and their performance in Section 5.</p>

    <p class="text-gray-300">Security Theorems. Correctness and anonymity proofs for <span class="math">\\mathcal{GA}</span> are almost completely unchanged from our standard EPID signature scheme, so we only state the corresponding theorems. The only proof that needs some tweaking is that of unforgeability. We sketch the modified proof in Appendix C.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 10.</h6>

    <p class="text-gray-300">Assuming the correctness of signature scheme <span class="math">\\mathcal{S}</span>, proof system <span class="math">\\Pi</span>, and accumulator <span class="math">\\mathcal{A}c</span>, as well as the pseudorandomness of <span class="math">f</span>, <span class="math">\\mathcal{GA}</span> is a correct EPID signature scheme.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">Assuming that <span class="math">\\Pi</span> is a zero-knowledge proof system and that <span class="math">f</span> is a PRF, <span class="math">\\mathcal{GA}</span> is an anonymous EPID signature scheme.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 12.</h6>

    <p class="text-gray-300">Assuming that <span class="math">\\Pi</span> is a proof system for zero-knowledge proofs of knowledge with simulation-sound extractability, <span class="math">\\mathcal{S}</span> is an unforgeable signature scheme, that <span class="math">f</span> is a PRF, that <span class="math">f</span> is additionally a collision-resistant hash function, and that <span class="math">\\mathcal{A}c</span> is a collision-free (sound) accumulator, <span class="math">\\mathcal{GA}</span> is an unforgeable EPID signature scheme.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Instantiation of Protocols</h2>

    <p class="text-gray-300">We have now described and proven the security of our constructions, but the post-quantum security of each construction relies on the existence of post-quantum secure instantiations of the various primitives required. In particular we require a PRF that is also a collision-resistant hash function, a signature scheme, zero knowledge proofs of knowledge (ZKPoKs), and an accumulator. In this section we describe options for instantiating each primitive under different security assumptions about the underlying ciphers used and report the signature sizes of our instantiated schemes in both the Random Oracle (RO) and Quantum Random Oracle (QRO) models <em>[12]</em>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.1 Zero Knowledge Proofs of Knowledge</h3>

    <p class="text-gray-300">In principle, standard symmetric primitives (AES, SHA) suffice for post-quantum security so long as we double our security parameters. However, our schemes uses these primitives in a non-black box manner by running them inside of a ZKPoK. In particular, the following ZKPoKs contribute significantly to signature sizes:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ZKPoK of a PRF key <span class="math">k</span> such that <span class="math">f(k,r)=t</span>, for a PRF that is collision-resistant on its key space.</li>

      <li>ZKPoK of a signature <span class="math">\\sigma</span> on a message <span class="math">m</span> such that <span class="math">\\mathsf{Verify}(m,\\sigma)=1</span> for a post-quantum signature scheme <span class="math">\\mathcal{S}=(\\mathsf{Keygen}</span>, <span class="math">\\mathsf{Sign}</span>, <span class="math">\\mathsf{Verify})</span>.</li>

      <li>ZKPoK of membership of element <span class="math">x_{i}</span> in accumulator <span class="math">\\Lambda</span> for set <span class="math">\\mathcal{X}</span></li>

    </ol>

    <p class="text-gray-300">We restrict our choice of ZKPoK proof system to those systems which rely only on symmetric primitives. This includes works following the “MPC in the Head” approach of Ishai et al <em>[37]</em> – ZKBoo <em>[31]</em>, ZKB++ <em>[21]</em>, and Ligero <em>[3]</em> – as well as zk-STARKs <em>[8]</em>. Although Ligero and zk-STARKs offer proofs asymptotically sublinear in the size of the circuit to be proven, a preliminary analysis suggested that, for our relatively small proof circuits, ZKB++ provides the smallest signature sizes in practice without requiring heavy computing costs for the signer. Moreover, ZKB++ has proofs of security in both the Random Oracle and Quantum Random Oracle models, whereas Ligero and zk-STARKs only have proofs in the classical RO model. As such, we choose to instantiate our signatures and measure signature size using ZKB++ as our underlying ZKPoK.</p>

    <p class="text-gray-300">In ZKB++ <em>[21]</em>, the underlying statement to be proven is represented as an arithmetic circuit over <span class="math">\\mathsf{GF}(2)</span>, and the proof size is proportional to the multiplicative complexity (i.e., number of AND gates) in the circuit. The most important practical consideration in signature schemes is signature size; therefore our main criterion in instantiating the PRF and outer signature scheme is to minimize their multiplicative complexity over <span class="math">\\mathsf{GF}(2)</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.2 PRF and Collision-Resistant Hash Function</h3>

    <p class="text-gray-300">Recently the ciphers LowMC <em>[2]</em> and MiMC <em>[1]</em> have been proposed as alternatives to AES that have significantly lower multiplicative complexity as arithmetic circuits over finite fields. Although relatively new and less extensively studied, these ciphers were shown to resist statistical cryptanalytic attacks, similar to other state-of-the-art designs. A number of works have already proposed using LowMC as the best candidate to-date for instantiating ciphers inside ZKB++-style proofs <em>[21, 25]</em>. The most recent public version of the LowMC cipher with parameters set for 128-bit post-quantum security (256-bit key, 256-bit block size) involves only 1374 AND gates, a significant improvement over the 7616 AND gates in AES-256 <em>[2]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Derler et. al <em>[25]</em> also suggest using the LowMC round function in the sponge framework (as described in <em>[1]</em>) to construct a collision-resistant hash function with low multiplicative complexity. However, since only a collision-resistant compression function on a fixed message length is needed (rather than full-blown indifferentiability from a random oracle), we propose applying the much simpler Davies-Meyer transformation to the LowMC cipher. Collision resistance of Davies-Meyer is proved in the ideal cipher model <em>[14]</em>, which is only marginally stronger than the security assumption underlying the sponge transformation. Given an ideal cipher <span class="math">E(k,x)</span> on equal sized key and message space, the Davies-Meyer compression function is $H(m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{2})=E(m_{1},m_{2})\\oplus m_{2}<span class="math">. For a collision-resistant PRF we would use </span>F(k,x)=E(k,x)\\oplus x<span class="math">; as long as </span>E<span class="math"> is a PRF then </span>F<span class="math"> is also a PRF. Note that the multiplicative complexity of </span>F<span class="math"> is the same as </span>E<span class="math">. To obtain a PRF that is collision-resistant only on its keyspace we can rely on a slightly weaker assumption than the ideal cipher model. The ideal cipher model assumes that </span>E<span class="math"> with <em>any</em> key is indistinguishable from a random permutation, whereas we only need to assume there is an explicit fixed key </span>k_{\\mathsf{fix}}<span class="math"> on which </span>E(k_{\\mathsf{fix}},\\cdot)<span class="math"> is indistinguishable from a random permutation. Then we can define </span>\\Pi(y)=E(k_{\\mathsf{fix}},y)<span class="math">, and define </span>F^{\\prime}(k,x)=\\Pi(E(k,x))\\oplus E(k,x)<span class="math">. (The inner evaluation of </span>E(k,x)<span class="math"> ensures the PRF property while </span>\\Pi(y)\\oplus y$ is collision resistant as a special case of Davies-Meyer).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5.3 Post-Quantum Signature Scheme</p>

    <p class="text-gray-300">Choices for post-quantum signatures that do not rely on stronger lattice assumptions include Merkle signatures <em>[45]</em>, Goldreich’s stateless signatures <em>[32]</em>, SPHINCS signatures <em>[9]</em>, or the Fish signatures of Chase et al <em>[21]</em>. The recent literature on post-quantum signatures has focused on optimizing signature size. When using signatures outside of proofs (in our construction of EPID signatures for attestation) we propose using SPHINCS, which has the smallest signature size. However, since our main EPID signature construction involves verifying the group manager’s post-quantum signature inside a ZKPoK, there we care about optimizing the arithmetic multiplicative complexity of signature verification rather than the signature size.</p>

    <p class="text-gray-300">We examine two options for instantiating the group manager’s signature scheme for signatures used inside a ZKPoK: one using stateful Merkle signatures, and other using Goldreich’s stateless signatures.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Stateful Merkle signatures</h5>

    <p class="text-gray-300">The signer runs a signature setup that generates a large number of one-time signature (OTS) keypairs. We would use Lamport signatures from one-way functions (instantiated with LowMC) for the OTS. The Lamport signature private key consists of 256 pairs of pseudorandom 256-bit strings the public key consists of the 256 pairs of outputs generated by applying the one-way function to each private key string. The signer finalizes the setup by computing a Merkle tree (using a 2-to-1 collision resistant compression function) over the OTS public keys at the leaves of the tree and publishing the root as the public verification key. Signing a message involves singing the message with one of the leaf OTS keys and proving membership of this OTS key in the Merkle tree. The signer needs to maintain state to ensure that no OTS key is used more than once. The stateful requirement is not prohibitive in the setting of managing a group of trusted hardware platforms. The preprocessing of a tree of up to <span class="math">2^{30}</span> members would take under a day on modern commodity hardware and would require the server to use only several GB of storage.</p>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Stateless Goldreich signatures</h5>

    <p class="text-gray-300">Instead of maintaining state in the Merkle signature scheme above, the signer could choose an OTS key at random. This requires squaring the size of the tree to make collisions unlikely. For a group of <span class="math">2^{30}</span> members storing a tree of size <span class="math">2^{60}</span> keys would be prohibitively expensive. However, Godlreich’s scheme provides a way to generate this tree pseudorandomly from a small seed. In this scheme, the signer pseudorandomly generates an OTS keypair for each node of the tree, which can be done by evaluating a PRF on the index of the tree node. The OTS public key at the root of the tree is the overall public key. The OTS key pair on each node of the tree is used to sign the hash of the public keys on each of its two child nodes. To sign a message a random leaf is selected and the signature includes the OTS signatures along the path from this leaf to the root, where each signature signs either a child public key or the actual message at the leaf.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.4 Reducing Circuit Size for Membership Proofs</h3>

    <p class="text-gray-300">As mentioned in Section 4, we will use Merkle trees to instantiate our accumulators. A recent work of Derler et al <em>[25]</em> points out, however, that the circuit used to verify standard Merkle inclusion proofs differs based on the path from the Merkle root to the leaf <span class="math">x_{i}</span>. The dependence arises based on whether the hash at depth <span class="math">j</span> of the tree becomes the left or right input of the hash at depth <span class="math">j-1</span>.</p>

    <p class="text-gray-300">This dependence of the AVerify circuit on <span class="math">i</span> must be removed in order to generically create a zero-knowledge inclusion proof with some zero-knowledge proof system. They suggest a modification to the standard inclusion proof that allows the same circuit to verify inclusion regardless of the index <span class="math">i</span> whose inclusion is proven. The idea is as follows: suppose <span class="math">x_{i}</span> resides in a subtree rooted at internal node <span class="math">a</span> and that <span class="math">a</span> has sibling and parent nodes <span class="math">b</span> and <span class="math">c</span>, respectively. At each level of the Merkle tree, instead of simply calculating <span class="math">h(a,b)</span> and only comparing the result to the root, they evaluate the expression <span class="math">c=h(a,b)\\vee c=h(b,a)</span> and reject the inclusion proof if it is not satisfied. This allows the construction of a circuit AVerify’ with a fixed ordering of inputs to each hash function, since as long as one ordering of inputs matches the node at the next level of the tree, correctness will hold. The cost of this transformation is an extra hash evaluation, an equality check, and a logical OR for each level of the tree.</p>

    <p class="text-gray-300">We propose a solution that eliminates the need for equality checks at each level of the tree and replaces the OR with an XOR, allowing smaller and more efficient zero-knowledge membership proofs. Our idea is to replace the hash function <span class="math">h</span> already used in computing the merkle root with a modified function <span class="math">h^{\\prime}(x,y)=h(x,y)\\oplus h(y,x)</span>. Using <span class="math">h^{\\prime}</span> in place of <span class="math">h</span> proves that the input <span class="math">x_{i}</span> is a <span class="math">d^{\\text{th}}</span> preimage of the merkle root for a tree of depth <span class="math">d</span> without any dependence on the position <span class="math">i</span> of <span class="math">x_{i}</span> among the tree’s leaves. Of course, <span class="math">h^{\\prime}</span> is trivially neither collision-resistant nor second preimage resistant, as a swapping of the inputs <span class="math">x</span> and <span class="math">y</span> results in the same output. Below we prove that <span class="math">h^{\\prime}</span> provides a third preimage resistance property and helps build the inclusion proofs we desire.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 13 (Third Preimage Resistance).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say a hash function <span class="math">H</span> defined over <span class="math">(\\mathcal{M},\\mathcal{T})</span> is third preimage resistant if given a random $m=a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\in\\mathcal{M}<span class="math"> (with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) and a different </span>m^{\\prime}=b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\in\\mathcal{M}<span class="math"> such that </span>H(m)=H(m^{\\prime})<span class="math">, it is difficult to find an </span>m^{\\prime\\prime}\\in\\mathcal{M}<span class="math"> such that </span>H(m^{\\prime\\prime})=H(m)=H(m^{\\prime})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Assuming the hash function <span class="math">h:\\mathcal{M}\\times\\mathcal{M}\\rightarrow\\mathcal{M}</span> is a random function, the hash function <span class="math">h^{\\prime}(x,y)=h(x,y)\\oplus h(y,x)</span> for <span class="math">x,y\\in\\mathcal{M}</span> is third preimage resistant, provided <span class="math">x\\neq y</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">h^{\\prime}(x,y)</span> admits a trivial collision <span class="math">h^{\\prime}(y,x)</span>. We argue it is hard to find any other collision unless <span class="math">x=y</span> (since <span class="math">h^{\\prime}(x,x)=0</span> for all <span class="math">x</span>). To find a third preimage of <span class="math">h^{\\prime}(x,y)</span> an adversary must produce <span class="math">w,z</span> such that either <span class="math">h^{\\prime}(w,z)=h^{\\prime}(x,y)</span> and either <span class="math">w\\neq x</span> or <span class="math">z\\neq y</span>. Since <span class="math">h</span> is a random function and <span class="math">(x,y),(y,x),(w,z),(z,w)</span> are all distinct tuples, <span class="math">h(x,y)</span>, <span class="math">h(y,x)</span>, <span class="math">h(w,z)</span>, and <span class="math">h(z,w)</span> will all be independently random strings. The probability that <span class="math">h(x,y)\\oplus h(y,x)=h(w,z)\\oplus h(z,w)</span> is therefore negligible in the length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Therefore no efficient adversary can find a third preimage for </span>h^{\\prime}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to replace <span class="math">h</span> with <span class="math">h^{\\prime}</span> in our merkle tree construction and retain security for the circuit AVerify’, we only need to show that we will have no leaves $x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y<span class="math"> in the accumulator such that </span>x=y<span class="math">. Fortunately, since the elements in the accumulator for our particular case are challenge/response pairs </span>(f(sk_{i},c_{i}),c_{i})<span class="math"> that serve as group member credentials (where </span>f<span class="math"> is collision-resistant and a PRF), the probability that </span>x=y$ is negligible in our setting.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Practically, our new circuit AVerify’ reduces the number of equality checks inside a ZKPoK from <span class="math">2\\log_{2}(N)</span> (where <span class="math">N</span> is the group size) to <span class="math">1</span>. Additionally, <span class="math">\\log_{2}(N)</span> OR gates are replaced with XORs which do not increase proof size.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">5.5 Signature Sizes</h3>

    <p class="text-gray-300">As discussed above, we instantiate our signatures using LowMC, Merkle signatures (inside the ZKPoK), SPHINCS signatures (outside the ZKPoK), ZKB++, and Merkle tree accumulators with</p>

    <p class="text-gray-300">Signature Sizes in RO Model</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Group Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ideal Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Random Permutation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">1.37MB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.28MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">1.85MB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.21MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">3.45MB</td>

            <td class="px-3 py-2 border-b border-gray-700">6.31MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">5.05MB</td>

            <td class="px-3 py-2 border-b border-gray-700">9.41MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">6.65MB</td>

            <td class="px-3 py-2 border-b border-gray-700">12.5MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Signature sizes for construction II under various security assumptions on LowMC, using Fiat-Shamir [28] to make proofs of knowledge noninteractive.</p>

    <p class="text-gray-300">Signature Sizes in QRO Model</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Group Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ideal Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Random Permutation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">2.64MB</td>

            <td class="px-3 py-2 border-b border-gray-700">4.45MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">3.59MB</td>

            <td class="px-3 py-2 border-b border-gray-700">6.30MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">6.74MB</td>

            <td class="px-3 py-2 border-b border-gray-700">12.5MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">9.89MB</td>

            <td class="px-3 py-2 border-b border-gray-700">18.6MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">13.0MB</td>

            <td class="px-3 py-2 border-b border-gray-700">24.8MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: Signature sizes for construction II under various security assumptions on LowMC, using the Unruh transform [50] to make proofs of knowledge noninteractive.</p>

    <p class="text-gray-300">our modified membership proof circuit.</p>

    <p class="text-gray-300">Figure 1 shows the sizes for our modified EPID signatures for various group sizes under (1) the assumption that LowMC is and ideal cipher and (2) the assumption that LowMC with a public fixed key is a random permutation. Figure 2 presents the same information, but uses the Unruh transform [50] instead of the Fiat-Shamir transform [28] to make the ZKB++ proof noninteractive. The Fiat-Shamir transform is proven secure in the Random Oracle model but only sometimes retains security in the Quantum Random Oracle model [12,51]. As visible from the figures, groups of size up to  <span class="math">2^{20}</span>  could use post-quantum signatures of size 6.74MB (3.45MB in RO model) under our scheme, a sufficiently small size for attestation in applications with heavy data transfer requirements. For comparison, the same signatures instantiated with AES-256 would require 33.8MB (16.9MB in RO model), meaning the choice of LowMC enables a  <span class="math">5 \\times</span>  improvement in signature size.</p>

    <p class="text-gray-300">For comparison, our signature sizes are smaller than the recent ring signatures of Derler et al [25], which require at least 10.4MB (5.26MB in RO Model) for signatures in a ring of  <span class="math">2^{20}</span>  members <span class="math">^{2}</span> , despite providing a more elaborate functionality. The improvement comes from our new accumulator membership proofs, as the accumulator constitutes the most costly component of both constructions. Note that subsequent to our paper, the Derler et al paper has been updated with new results which reduce the size of their signatures by a factor of 2. These techniques can be used in the same way to reduce signature sizes in our construction II as well.</p>

    <p class="text-gray-300">Our general-purpose EPID signatures require 216.82MB for signatures in a group of size  <span class="math">2^{30}</span></p>

    <p class="text-gray-300">assuming LowMC is an ideal cipher (110.81MB in QRO Model), a much larger value than the variation designed for attestation. This motivates the question of how to generalize the specialized version of our construction to apply to a wider range of use-cases, which we leave as an open problem.</p>

    <h2 id="sec-31" class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">We presented a general-purpose post-quantum EPID signature scheme as well as a construction of a specialized variant designed for trusted hardware enclave attestation. We also gave an analysis of the concrete sizes of our signatures based on the best possible instantiations with current tools and showed that our signatures for attestation can achieve sizes acceptable for use in some applications.</p>

    <p class="text-gray-300">EPID signatures play an important role in modern trusted hardware. Making these signatures post-quantum secure is an important goal, and we hope that this work will spur further research on this question that will further reduce the signature size.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We would like to thank David Wu for several helpful conversations. This work is supported by NSF, the DARPA/ARL SAFEWARE project, the Simons foundation, and a grant from ONR. The views expressed are those of the author and do not reflect the official policy or position of the Department of Defense, the National Science Foundation, or the U.S. Government.</p>

    <h2 id="sec-33" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In ASIACRYPT, pages 191–219, 2016.</li>

      <li>[2] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In EUROCRYPT, pages 430–454, 2015.</li>

      <li>[3] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In CCS, pages 2087–2104, 2017.</li>

      <li>[4] Rachid El Bansarkhani and Rafael Misoczki. G-merkle: A hash-based group signature scheme from standard assumptions. IACR Cryptology ePrint Archive, 2018.</li>

      <li>[5] Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In CRYPTO, pages 390–420, 1992.</li>

      <li>[6] Mihir Bellare, Daniele Micciancio, and Bogdan Warinschi. Foundations of group signatures: Formal definitions, simplified requirements, and a construction based on general assumptions. In EUROCRYPT, pages 614–629, 2003.</li>

      <li>[7] Mihir Bellare, Haixia Shi, and Chong Zhang. Foundations of group signatures: The case of dynamic groups. In CT-RSA, pages 136–153, 2005.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[8] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptology ePrint Archive, 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] Daniel J. Bernstein, Daira Hopwood, Andreas Hülsing, Tanja Lange, Ruben Niederhagen, Louiza Papachristodoulou, Michael Schneider, Peter Schwabe, and Zooko Wilcox-O’Hearn. SPHINCS: practical stateless hash-based signatures. In EUROCRYPT, pages 368–397, 2015.</li>

      <li>[10] Manuel Blum. Coin flipping by telephone. In Advances in Cryptology: A Report on CRYPTO 81, CRYPTO 81, IEEE Workshop on Communications Security, pages 11–15, 1981.</li>

      <li>[11] Dan Boneh, Xavier Boyen, and Hovav Shacham. Short group signatures. In CRYPTO, pages 41–55, 2004.</li>

      <li>[12] Dan Boneh, Özgür Dagdelen, Marc Fischlin, Anja Lehmann, Christian Schaffner, and Mark Zhandry. Random oracles in a quantum world. In ASIACRYPT, pages 41–69, 2011.</li>

      <li>[13] Dan Boneh and Hovav Shacham. Group signatures with verifier-local revocation. In Proceedings of the 11th ACM Conference on Computer and Communications Security (CCS), pages 168–177. ACM, 2004.</li>

      <li>[14] Dan Boneh and Victor Shoup. A Graduate Course in Applied Cryptography. 2017.</li>

      <li>[15] Ernest F. Brickell, Jan Camenisch, and Liqun Chen. Direct anonymous attestation. In CCS, pages 132–145, 2004.</li>

      <li>[16] Ernie Brickell and Jiangtao Li. Enhanced privacy ID from bilinear pairing. IACR Cryptology ePrint Archive, 2009:95, 2009.</li>

      <li>[17] Johannes Buchmann, Erik Dahmen, and Andreas Hülsing. Xmss-a practical forward secure signature scheme based on minimal security assumptions. In International Workshop on Post-Quantum Cryptography, pages 117–129. Springer, 2011.</li>

      <li>[18] Jan Camenisch and Jens Groth. Group signatures: Better efficiency and new theoretical aspects. In SCN, pages 120–133, 2004.</li>

      <li>[19] Jan Camenisch and Anna Lysyanskaya. A signature scheme with efficient protocols. In SCN, pages 268–289, 2002.</li>

      <li>[20] Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous credentials from bilinear maps. In CRYPTO, pages 56–72, 2004.</li>

      <li>[21] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In CCS, pages 1825–1842, 2017.</li>

      <li>[22] David Chaum and Eugène van Heyst. Group signatures. In EUROCRYPT, pages 257–265, 1991.</li>

      <li>[23] Victor Costan and Srinivas Devadas. Intel SGX explained. IACR Cryptology ePrint Archive, 2016:86, 2016.</li>

    </ul>

    <p class="text-gray-300">[24] David Derler, Christian Hanser, and Daniel Slamanig. Revisiting cryptographic accumulators, additional properties and relations to other primitives. In CT-RSA, pages 127–144, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[25] David Derler, Sebastian Ramacher, and Daniel Slamanig. Post-quantum zero-knowledge proofs for accumulators with applications to ring signatures from symmetric-key primitives. IACR Cryptology ePrint Archive, 2017.</li>

      <li>[26] Benjamin Dowling, Felix Günther, Udyani Herath, and Douglas Stebila. Secure logging schemes and certificate transparency. In ESORICS, pages 140–158, 2016.</li>

      <li>[27] Sebastian Faust, Markulf Kohlweiss, Giorgia Azzurra Marson, and Daniele Venturi. On the non-malleability of the fiat-shamir transform. In INDOCRYPT, pages 60–79, 2012.</li>

      <li>[28] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, pages 186–194, 1986.</li>

      <li>[29] Ben Fisch, Dhinakaran Vinayagamurthy, Dan Boneh, and Sergey Gorbunov. IRON: functional encryption using intel SGX. In CCS, pages 765–782, 2017.</li>

      <li>[30] Benjamin Fuller, Mayank Varia, Arkady Yerukhimovich, Emily Shen, Ariel Hamlin, Vijay Gadepally, Richard Shay, John Darby Mitchell, and Robert K. Cunningham. Sok: Cryptographically protected database search. In IEEE Symposium on Security and Privacy (Oakland), pages 172–191, 2017.</li>

      <li>[31] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster zero-knowledge for boolean circuits. In USENIX Security, pages 1069–1083, 2016.</li>

      <li>[32] Oded Goldreich. The Foundations of Cryptography - Volume 2, Basic Applications. Cambridge University Press, 2004.</li>

      <li>[33] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. On the cryptographic applications of random functions. In CRYPTO, pages 276–288, 1984.</li>

      <li>[34] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Comput., 18(1):186–208, 1989.</li>

      <li>[35] S. Dov Gordon, Jonathan Katz, and Vinod Vaikuntanathan. A group signature scheme from lattice assumptions. In ASIACRYPT, pages 395–412, 2010.</li>

      <li>[36] Jens Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In ASIACRYPT, pages 444–459, 2006.</li>

      <li>[37] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge proofs from secure multiparty computation. SIAM J. Comput., 39(3):1121–1152, 2009.</li>

      <li>[38] Simon Johnson, Vinnie Scarlata, Carlos Rozas, Ernie Brickell, and Frank Mckeen. Intel® software guard extensions: Epid provisioning and attestation services.</li>

      <li>[39] Jonathan Katz, Vladimir Kolesnikov, and Xiao Wang. Improved non-interactive zero knowledge with applications to post-quantum signatures. IACR Cryptology ePrint Archive, 2018:475, 2018.</li>

    </ul>

    <p class="text-gray-300">[40] B. Laurie, A. Langley, and E. Kasper. Certificate transparency. RFC 6962, June 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[41] Benoît Libert, San Ling, Fabrice Mouhartem, Khoa Nguyen, and Huaxiong Wang. Signature schemes with efficient protocols and dynamic group signatures from lattice assumptions. In ASIACRYPT, pages 373–403, 2016.</li>

      <li>[42] Benoît Libert, San Ling, Khoa Nguyen, and Huaxiong Wang. Zero-knowledge arguments for lattice-based accumulators: Logarithmic-size ring signatures and group signatures without trapdoors. In EUROCRYPT, pages 1–31, 2016.</li>

      <li>[43] San Ling, Khoa Nguyen, and Huaxiong Wang. Group signatures from lattices: Simpler, tighter, shorter, ring-based. In PKC, pages 427–449, 2015.</li>

      <li>[44] San Ling, Khoa Nguyen, Huaxiong Wang, and Yanhong Xu. Lattice-based group signatures: Achieving full dynamicity with ease. In ACNS, pages 293–312, 2017.</li>

      <li>[45] Ralph C. Merkle. A digital signature based on a conventional encryption function. In CRYPTO, pages 369–378, 1987.</li>

      <li>[46] Moni Naor and Moti Yung. Universal one-way hash functions and their cryptographic applications. In STOC, pages 33–43. ACM, 1989.</li>

      <li>[47] Kartik Nayak, Christopher W. Fletcher, Ling Ren, Nishanth Chandran, Satya Lokam, Elaine Shi, and Vipul Goyal. Hop: Hardware makes obfuscation practical. In NDSS, 2017.</li>

      <li>[48] Amit Sahai. Non-malleable non-interactive zero knowledge and adaptive chosen-ciphertext security. In FOCS, pages 543–553, 1999.</li>

      <li>[49] Alfredo De Santis, Giovanni Di Crescenzo, Rafail Ostrovsky, Giuseppe Persiano, and Amit Sahai. Robust non-interactive zero knowledge. In CRYPTO, pages 566–598, 2001.</li>

      <li>[50] Dominique Unruh. Non-interactive zero-knowledge proofs in the quantum random oracle model. In EUROCRYPT, pages 755–784, 2015.</li>

      <li>[51] Dominique Unruh. Post-quantum security of fiat-shamir. In ASIACRYPT, pages 65–95, 2017.</li>

      <li>[52] Miao Yu, Virgil D. Gligor, and Zongwei Zhou. Trusted display on untrusted commodity platforms. In CCS, pages 989–1003, 2015.</li>

      <li>[53] Wenting Zheng, Ankur Dave, Jethro G. Beekman, Raluca Ada Popa, Joseph E. Gonzalez, and Ion Stoica. Opaque: An oblivious and encrypted distributed analytics platform. In NSDI, pages 283–298, 2017.</li>

      <li>[54] Zongwei Zhou, Virgil D. Gligor, James Newsome, and Jonathan M. McCune. Building verifiable trusted path on commodity x86 computers. In IEEE Symposium on Security and Privacy (Oakland), pages 616–630, 2012.</li>

    </ul>

    <p class="text-gray-300">A General Security Definitions</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 14 (Pseudorandom Function <em>[33]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">F:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{n}</span> be an efficiently computable, length-preserving keyed function. We say that <span class="math">F</span> is a pseudorandom function (PRF) if for all probabilistic polynomial time distinguishers <span class="math">D</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pr}[D^{F_{k}}(1^{n})=1]-\\mathsf{Pr}[D^{f_{n}}(1^{n})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is negligible where <span class="math">k\\leftarrow\\{0,1\\}^{n}</span> is chosen uniformly at random and <span class="math">f_{n}</span> is chosen uniformly at random from the set of functions mapping <span class="math">n</span>-bit strings to <span class="math">n</span>-bit strings.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 15 (Collision-Resistant Hash Function <em>[14]</em>).</h6>

    <p class="text-gray-300">We say that a hash function <span class="math">h</span> over <span class="math">(\\mathcal{M},\\mathcal{T})</span> is collision resistant if for all efficient uniform adversaries <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{A}</span> cannot output two messages <span class="math">m_{0},m_{1}</span> such that <span class="math">h(m_{0})=h(m_{1})</span> with greater than negligible probability.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 16 (Signature).</h6>

    <p class="text-gray-300">A signature scheme <span class="math">\\mathcal{S}</span> is a triple (KeyGen, Sign, Verify) of PPT algorithms which are defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen(<span class="math">1^{\\lambda}</span>): This algorithm takes a security parameter <span class="math">\\lambda</span> as input and outputs a secret (signing) key sk and a public (verification) key pk.</li>

      <li>Sign(sk, <span class="math">m</span>): This algorithm takes a secret key sk and a message <span class="math">m</span> as input and outputs a signature <span class="math">\\sigma</span>.</li>

      <li>Verify(pk, <span class="math">m</span>, <span class="math">\\sigma</span>): This algorithm takes a public key pk, a message <span class="math">m</span>, and a signature <span class="math">\\sigma</span> as input and outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <p class="text-gray-300">The two properties we require from signatures are correctness and unforgeability. Correctness requires that <span class="math">\\mathsf{Verify}(\\mathsf{pk},m,\\mathsf{Sign}(\\mathsf{sk},m))=1</span>. Unforgeability (informally) requires that a computationally bounded adversary cannot forge a signature it has not seen with greater than negligible probability. Formally, we define unforgeability using the notion of existential unforgeability under a chosen message attack.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 17 (Existential Unforgeability Under Chosen Message Attack (EUF-CMA)).</h6>

    <p class="text-gray-300">A signature scheme <span class="math">\\mathcal{S}</span> is existentially unforgeable under chosen message attacks if for all PPT adversaries <span class="math">\\mathcal{A}</span>, we have that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Pr}[(\\mathsf{sk},\\mathsf{pk})\\leftarrow\\mathsf{KeyGen}(1^{\\lambda}),(m^{<em>},\\sigma^{</em>})\\leftarrow\\mathcal{A}^{\\mathsf{Sign}(\\mathsf{sk},\\cdot)}(\\mathsf{pk})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Verify}(\\mathsf{pk},m^{<em>},\\sigma^{</em>})=1\\wedge m^{*}\\notin\\mathcal{Q}^{\\mathsf{Sign}}]\\leq\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathcal{Q}^{\\mathsf{sign}}</span> keeps track of the queries made by the adversary to the signing oracle.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 18 (Commitment Scheme <em>[10]</em>).</h6>

    <p class="text-gray-300">A commitment scheme consists of two algorithms (<span class="math">\\mathsf{Com},\\mathsf{Vrfy}</span>) with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Com}(m,\\,r)</span>: On input of a message <span class="math">m</span> and randomness <span class="math">r</span>, the commitment algorithm outputs a commitment <span class="math">c</span>.</li>

      <li><span class="math">\\mathsf{Vrfy}(c,\\,m,\\,r)</span>: On input of a commitment <span class="math">c</span>, message <span class="math">m</span>, and randomness <span class="math">r</span>, <span class="math">\\mathsf{Vrfy}</span> outputs a bit <span class="math">b\\in\\{0,1\\}</span></li>

    </ul>

    <p class="text-gray-300">We require that computationally secure commitments satisfy the following three properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: <span class="math">\\mathsf{Vrfy}(\\mathsf{Com}(m, r), m, r)=1</span>.</li>

      <li>Hiding: For every message pair <span class="math">m, m&#x27;</span>, no computationally bounded adversary can distinguish between commitments to <span class="math">m</span> and <span class="math">m&#x27;</span> with greater than negligible advantage.</li>

      <li>Binding: No computationally bounded adversary can produce a commitment <span class="math">c</span> such that <span class="math">\\mathsf{Vrfy}(c, m, r) = \\mathsf{Vrfy}(c, m&#x27;, r&#x27;) = 1</span> for <span class="math">m \\neq m&#x27;</span> with greater than negligible probability.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 19 (Second Preimage Resistance [14]).</strong> We say a hash function <span class="math">H</span> defined over <span class="math">(\\mathcal{M}, \\mathcal{T})</span> is a second preimage resistant if given a random <span class="math">m \\in \\mathcal{M}</span>, it is difficult to find a different <span class="math">m&#x27; \\in \\mathcal{M}</span> such that <span class="math">H(m) = H(m&#x27;)</span>.</p>

    <h2 id="sec-39" class="text-2xl font-bold">B EPID Definitions</h2>

    <p class="text-gray-300">Here we give formal definitions of the security requirements for EPID signatures against which we prove security of our constructions. These definitions differ in presentation from those of Brickell and Li [16] for the purpose of clarity but are otherwise equivalent.</p>

    <p class="text-gray-300"><strong>Definition 20 (Correctness).</strong> Let <span class="math">\\Sigma_{i}</span> be the set of signatures issued by group member <span class="math">\\mathcal{P}_i</span> who has successfully run the Join procedure in EPID signature scheme <span class="math">\\mathcal{G}</span> with security parameter <span class="math">\\lambda</span>. <span class="math">\\mathcal{G}</span> is correct if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{sk}_i \\notin \\mathsf{KEY-RL} \\land \\Sigma_i \\cap \\mathsf{SIG-RL} = \\emptyset \\rightarrow \\\\ \\Pr[\\text{GPVerify}(\\mathsf{gpk}, m, \\mathsf{KEY-RL}, \\mathsf{SIG-RL}, \\mathsf{GPSign}(\\mathsf{gpk}, \\mathsf{sk}_i, \\mathsf{cert}_i, m, \\mathsf{SIG-RL})) \\neq 1] \\\\ &amp;lt; \\mathsf{negl}(\\lambda) \\end{array}</span></div>

    <p class="text-gray-300"><strong>Admissible adversaries</strong> The security games for both anonymity (Definition 21) and existential unforgeability (Definition 24) follow the standard practice of defining <em>admissible adversaries</em> whose behavior we restrict merely in order to simplify the presentation of the main game. We stress that defining an admissible adversary is not the same as a semi-honest adversary. In each of our games it is easy to see that any deviation from each admissibility criterion could be trivially detected by the challenger (in either experiment) and rejected so that the adversary does not gain any distinguishing advantage. Therefore, restricting to these admissible adversaries is without loss of generality, i.e. does not weaken the adversary.</p>

    <p class="text-gray-300"><strong>Definition 21 (Anonymity Experiment).</strong> The anonymity experiment denoted by <span class="math">\\mathsf{ANON}[\\mathcal{A}, \\lambda, b]</span> with security parameter <span class="math">\\lambda</span> is played between adversary <span class="math">\\mathcal{A}</span> and challenger <span class="math">\\mathcal{C}</span> who is given input <span class="math">b</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup. Adversary <span class="math">\\mathcal{A}</span> chooses <span class="math">(\\mathsf{gpk}, \\mathsf{gsk})^3</span> and sends <span class="math">\\mathsf{gpk}</span> to challenger <span class="math">\\mathcal{C}</span>.</li>

      <li>Unrestricted Queries. <span class="math">\\mathcal{A}</span> is allowed to make as many of the following queries to the <span class="math">\\mathcal{C}</span> as it wants:</li>

    </ol>

    <p class="text-gray-300">3Note that the adversary may choose these keys arbitrarily and may even cause the join protocol to fail as a result. However, it is easy to see that in our construction this will affect the adversary's view in both experiments equally (implicit in our security proof</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Join. <span class="math">\\mathcal{A}</span> requests creation of a new group member <span class="math">\\mathcal{P}_i</span>. <span class="math">\\mathcal{C}</span> runs Join<span class="math">\\mathcal{A}, \\mathcal{P}_i\\langle(\\mathsf{gsk}, \\mathsf{gpk}), \\mathsf{gpk}\\rangle</span> with <span class="math">\\mathcal{C}</span> playing the role of <span class="math">\\mathcal{P}_i</span>, so that <span class="math">\\mathcal{A}</span> gets <span class="math">\\mathsf{cert}_i</span> and <span class="math">\\mathcal{C}</span> gets <span class="math">(\\mathsf{sk}_i, \\mathsf{cert}_i)</span>.</li>

      <li>Sign. <span class="math">\\mathcal{A}</span> requests a signature on a message <span class="math">m</span> from party <span class="math">\\mathcal{P}_i</span> relative to a signature revocation list SIG-RL of its choosing, constructed from any subset of signatures it has received thus far in the game. <span class="math">\\mathcal{C}</span> computes <span class="math">\\mathsf{sig} \\gets \\mathsf{GPSign}(\\mathsf{gpk}, \\mathsf{sk}_i, \\mathsf{cert}_i, m, \\mathsf{SIG-RL})</span> and sends it to <span class="math">\\mathcal{A}</span>.</li>

      <li>Corrupt. <span class="math">\\mathcal{A}</span> requests the private key of <span class="math">\\mathcal{P}_i</span>. <span class="math">\\mathcal{C}</span> sends <span class="math">\\mathsf{sk}_i</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Challenge. <span class="math">\\mathcal{A}</span> sends <span class="math">\\mathcal{C}</span> a message <span class="math">m</span>, a signature list SIG-RL and two group member numbers <span class="math">i_0</span> and <span class="math">i_1</span>. <span class="math">\\mathcal{C}</span> computes <span class="math">\\mathsf{sig}^<em> = \\mathsf{GPSign}(\\mathsf{gpk}, \\mathsf{sk}_{i_b}, \\mathsf{cert}_{i_b}, m, \\mathsf{SIG-RL})</span>, and sends <span class="math">\\mathsf{sig}^</em></span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Restricted Queries. <span class="math">\\mathcal{A}</span> can make additional queries to <span class="math">\\mathcal{C}</span> as above.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output. <span class="math">\\mathcal{A}</span> outputs <span class="math">b&#x27;</span>.</li>

    </ol>

    <p class="text-gray-300">ANON<span class="math">[\\mathcal{A}, \\lambda, b]</span> outputs the value <span class="math">b&#x27;</span> returned by <span class="math">\\mathcal{A}</span> at the end of the game.</p>

    <p class="text-gray-300">Definition 22 (Admissible Anonymity Adversary). An adversary <span class="math">\\mathcal{A}</span> is admissible for ANON<span class="math">[\\mathcal{A}, \\lambda, b]</span> if it satisfies the following criteria:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>only makes Sign or Corrupt queries on parties that have already participated in a Join and does not make Join queries on parties that have already participated in a Join.</li>

      <li>only sends legitimate certificates <span class="math">\\mathsf{cert}_i</span> in the join phase (well-formed according to the protocol, e.g. signatures verify, over the correct values).</li>

      <li>chooses parties <span class="math">\\mathcal{P}_{i_0}</span> and <span class="math">\\mathcal{P}_{i_1}</span> that have already participated in a Join.</li>

      <li>chooses parties <span class="math">\\mathcal{P}_{i_0}</span> and <span class="math">\\mathcal{P}_{i_1}</span> that have not been corrupted and whose signatures have never appeared in a revocation list.</li>

      <li>makes no Corrupt queries on <span class="math">\\mathcal{P}_{i_0}</span> or <span class="math">\\mathcal{P}_{i_1}</span> in the "Restricted Queries" stage.</li>

      <li>never includes <span class="math">\\mathsf{sig}^*</span> in SIG-RL during the "Restricted Queries" stage.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 23 (Anonymous). EPID signature scheme <span class="math">\\mathcal{G}</span> is Anonymous if no admissible PPT adversary can win the Anonymity game with greater than negligible advantage. That is, if the quantity $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pr}[\\mathsf{ANON}[\\mathcal{A}, \\lambda, 0] = 1] - \\mathsf{Pr}[\\mathsf{ANON}[\\mathcal{A}, \\lambda, 1] = 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{negl}(\\lambda)<span class="math"> for any admissible PPT </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 24 (Unforgeability Experiment). The unforgeability experiment FORGE<span class="math">[\\mathcal{A}, \\lambda]</span> with security parameter <span class="math">\\lambda</span> is played between adversary <span class="math">\\mathcal{A}</span> and challenger <span class="math">\\mathcal{C}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup. <span class="math">\\mathcal{C}</span> computes <span class="math">(\\mathsf{gpk}, \\mathsf{gsk}) \\gets \\mathsf{Init}(1^{\\lambda})</span> and sends <span class="math">\\mathsf{gpk}</span> to <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{C}</span> creates a set <span class="math">U</span> of corrupted parties and initializes it as <span class="math">U = \\emptyset</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Queries. <span class="math">\\mathcal{A}</span> is allowed to make as many of the following queries to <span class="math">\\mathcal{C}</span> as it wants.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Join. <span class="math">\\mathcal{A}</span> requests creation of a new group member <span class="math">\\mathcal{P}_i</span>. One of two cases follows:</li>

    </ul>

    <p class="text-gray-300">i. <span class="math">\\mathcal{C}</span> runs Join internally, adding a new party <span class="math">\\mathcal{P}_i</span> to the group and keeping <span class="math">\\mathsf{sk}_i, \\mathsf{cert}_i</span>. <span class="math">\\mathcal{C}</span> also sends <span class="math">\\mathsf{cert}_i</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{A}</span> run <span class="math">\\textsf{Join}_{\\mathcal{C},\\mathcal{P}_{i}}\\langle(\\mathsf{gsk},\\mathsf{gpk}),\\mathsf{gpk}\\rangle</span> with <span class="math">\\mathcal{A}</span> playing the role of <span class="math">\\mathcal{P}_{i}</span>, so that <span class="math">\\mathcal{C}</span> gets <span class="math">\\mathsf{cert}_{i}</span> and <span class="math">\\mathcal{A}</span> gets <span class="math">(\\mathsf{sk}_{i},\\mathsf{cert}_{i})</span>. <span class="math">\\mathcal{A}</span> then sends <span class="math">\\mathsf{sk}_{i}</span> to <span class="math">\\mathcal{C}</span> who then appends <span class="math">i</span> to <span class="math">U</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sign. <span class="math">\\mathcal{A}</span> requests a signature on a message <span class="math">m</span> from party <span class="math">\\mathcal{P}_{i}</span> relative to a signature revocation list SIG-RL of its choosing, constructed from any subset of signatures it has received thus far in the game. <span class="math">\\mathcal{C}</span> computes <span class="math">\\mathsf{sig}\\leftarrow\\textsf{GPSign}(\\mathsf{gpk},\\mathsf{sk}_{i},\\mathsf{cert}_{i},m,\\textsf{SIG-RL})</span> and sends it to <span class="math">\\mathcal{A}</span>.</li>

      <li>Corrupt. <span class="math">\\mathcal{A}</span> requests the secret key of party <span class="math">\\mathcal{P}_{i}</span>. <span class="math">\\mathcal{C}</span> appends <span class="math">i</span> to <span class="math">U</span> and sends <span class="math">\\mathsf{sk}_{i}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Forgery. <span class="math">\\mathcal{A}</span> outputs a message <span class="math">m^{<em>}</span>, revocation lists <span class="math">\\textsf{KEY-RL}^{</em>}</span> and <span class="math">\\textsf{SIG-RL}^{<em>}</span>, and a signature <span class="math">\\mathsf{sig}^{</em>}</span>.</li>

    </ol>

    <p class="text-gray-300">FORGE<span class="math">[\\mathcal{A},\\lambda]</span> outputs <span class="math">1</span> (<span class="math">\\mathcal{A}</span> wins the unforgeability game) if <span class="math">\\textsf{GPVerify}(\\mathsf{gpk},m^{<em>},\\textsf{KEY-RL}^{</em>},\\textsf{SIG-RL}^{<em>},\\mathsf{sig}^{</em>})=1</span> and for every <span class="math">i\\in U</span>, either <span class="math">\\mathsf{sk}_{i}\\in\\textsf{KEY-RL}^{<em>}</span> or <span class="math">\\mathsf{sig}^{</em>}</span> signs a message in <span class="math">\\textsf{SIG-RL}^{*}</span>. Otherwise, it outputs <span class="math">0</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 25 (Admissible Unforgeability Adversary).</h6>

    <p class="text-gray-300">An adversary <span class="math">\\mathcal{A}</span> is <em>admissible</em> for FORGE<span class="math">[\\mathcal{A},\\lambda]</span> if it satisfies the following criteria:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>only makes Sign or Corrupt queries on parties that have already participated in a Join.</li>

      <li>does not make Join queries on parties that have already participated in a Join.</li>

      <li>only sends legitimate values for <span class="math">\\mathsf{sk}_{i}</span> in the join phase. That is, <span class="math">\\mathsf{sk}_{i}</span> should correspond to the certificate that <span class="math">\\mathcal{C}</span> issues for it.</li>

      <li>does not make a Sign query on <span class="math">m^{*}</span>.</li>

    </ul>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 26 (Unforgeable).</h6>

    <p class="text-gray-300">EPID signature scheme <span class="math">\\mathcal{G}</span> is Unforgeable if no admissible PPT adversary can win the Unforgeability game with greater than negligible probability. That is, if the quantity <span class="math">\\mathsf{Pr}[\\textsf{FORGE}[\\mathcal{A},\\lambda]=1]\\leq\\textsf{negl}(\\lambda)</span> for any admissible PPT <span class="math">\\mathcal{A}</span>.</p>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix C Deferred Proofs</h2>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof of Theorem 4.</h6>

    <p class="text-gray-300">A group member that is not affected by revocations of either form has all information to produce a signature that will verify, given that the signature and the proof system also have correctness. It remains to show that an unrevoked signature or key <span class="math">\\mathsf{sk}_{i}</span> will not “accidentally” satisfy the relation <span class="math">(f(\\mathsf{sk}_{i},r),\\ r)=(f(\\mathsf{sk}_{j},r^{\\prime}),\\ r^{\\prime})</span> for some revoked key <span class="math">\\mathsf{sk}_{j}</span> or signature with key/randomness pair <span class="math">(\\mathsf{sk}_{j},r)</span>. We call these events BAD-KEY and BAD-SIG. Given that <span class="math">f</span> is a PRF, we show they occur with negligible probability over the choices of <span class="math">\\mathsf{sk}_{i}</span>, <span class="math">\\mathsf{sk}_{j}</span>, <span class="math">r</span>, and <span class="math">r^{\\prime}</span>. We include the proof for BAD-KEY only; the proof for BAD-SIG is symmetric.</p>

    <p class="text-gray-300">Consider the transcript <span class="math">T=(t_{0},...,t_{k})</span> of <span class="math">k</span> (polynomial in <span class="math">\\lambda</span>) responses to queries on <span class="math">f</span> made up of <span class="math">f(\\mathsf{sk}_{j},r)</span> for all <span class="math">\\mathsf{sk}_{j}\\in\\textsf{KEY-RL}</span> as well as <span class="math">f(\\mathsf{sk}_{i},r)</span>. The event BAD-KEY occurs exactly when there exists some <span class="math">j</span> such that <span class="math">f(\\mathsf{sk}_{j},r)=f(\\mathsf{sk}_{i},r)</span>. We show that <span class="math">T</span> is indistinguishable from a list of random strings by a series of hybrids, where each successive (indistinguisable) hybrid replaces the next PRF output with a random string. An adversary who distinguishes the list with PRF output <span class="math">t_{i}</span> and the same list where <span class="math">t_{i}</span> is replaced by random string <span class="math">t^{\\prime}_{i}</span> can be given a list with the output of a purported PRF in position <span class="math">i</span> and determine whether that string is the output of a PRF or a truly random function. Call the final hybrid <span class="math">T^{\\prime}=(t^{\\prime}_{0},...,t^{\\prime}_{k})</span>. The probability of BAD-KEY in this hybrid is equal to the probability that the random string <span class="math">t^{\\prime}_{k}=t^{\\prime}_{j}</span> for some <span class="math">j\\in[k-1]</span>. This is negligible in the security parameter <span class="math">\\lambda</span>, completing the proof. ∎</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof of Theorem 5.</h6>

    <p class="text-gray-300">We proceed by a series of hybrids and begin by describing our hybrids. In the following, let <span class="math">x_{0}</span> and <span class="math">x_{1}</span> be distinct elements of <span class="math">[N]</span>, where <span class="math">N</span> is an upper bound on the number of group members. <span class="math">N</span> is necessarily polynomial in <span class="math">\\lambda</span> because the adversary <span class="math">\\mathcal{A}</span> is efficient.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{H}_{0}[x_{0},x_{1}]</span>: The real anonymity experiment, <span class="math">\\mathsf{ANON}[\\mathcal{A},\\lambda,0]</span> (Definition 21) run with an admissible adversary <span class="math">\\mathcal{A}</span>, except that we abort if <span class="math">\\mathcal{A}</span> does not choose <span class="math">i_{0}=x_{0}</span> and <span class="math">i_{1}=x_{1}</span> in the Challenge phase of the anonymity game.</li>

      <li><span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span>: Same as the previous hybrid, but with the proof of knowledge <span class="math">\\pi</span> always replaced with the output of its simulator. This is indistinguishable from the previous hybrid by the zero-knowledge property of the proof.</li>

      <li><span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span>: Same as the previous hybrid, but for group member <span class="math">\\mathcal{P}_{x_{0}}</span>, the output of <span class="math">f(\\mathsf{sk}_{x_{0}},\\cdot)</span> is replaced by a random string. This is indistinguishable from the previous hybrid by the PRF security of <span class="math">f</span>.</li>

      <li><span class="math">\\mathsf{H}_{3}[x_{0},x_{1}]</span>: Same as the previous hybrid, but for group member <span class="math">\\mathcal{P}_{x_{1}}</span>, the output of <span class="math">f(\\mathsf{sk}_{x_{1}},\\cdot)</span> is also replaced by a random string. This is indistinguishable from the previous hybrid by the PRF security of <span class="math">f</span>.</li>

    </ul>

    <p class="text-gray-300">Indistinguishability between hybrids <span class="math">\\mathsf{H}_{0}[x_{0},x_{1}]</span> and <span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span> follows immediately from the zero knowledge property of proof <span class="math">\\pi</span>, so we omit this proof. Next, we prove indistinguishability between the remaining hybrids.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Assuming that <span class="math">f</span> is a PRF, the outputs of <span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span> and <span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span> are indistinguishable.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We use an adversary <span class="math">\\mathcal{A}</span> that distinguishes between the outputs of <span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span> and <span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span> to construct an adversary <span class="math">\\mathcal{B}</span> that wins the PRF security game. <span class="math">\\mathcal{B}</span> acts as the challenger in the anonymity game of <span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span> and simultaneously plays the PRF security game with a PRF security game challenger. It reproduces the anonymity game for <span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span> exactly except any queries to <span class="math">f(sk_{x_{0}},\\cdot)</span> it replaces by queries to the PRF security game challenger (with a <span class="math">0</span> prepended to the input). <span class="math">\\mathcal{B}</span> then passes on the output of <span class="math">\\mathcal{A}</span> as its own output. Notice that in the anonymity game of <span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span> the key <span class="math">sk_{x_{0}}</span> is only used by the challenger to respond to queries for <span class="math">f(sk_{x_{0}},\\cdot)</span> (because the proof <span class="math">\\pi</span> has already been replaced by a simulated string). In particular, <span class="math">sk_{x_{0}}</span> is never given to the adversary <span class="math">\\mathcal{A}</span>. Therefore, in the case that the PRF challenger is using a PRF on a randomly sampled key then <span class="math">\\mathcal{B}</span> provides a perfect simulation of <span class="math">\\mathsf{H}_{1}[x_{0},x_{1}]</span> for <span class="math">\\mathcal{A}</span>. In the case that the PRF challenger is using a random function <span class="math">\\mathcal{B}</span> provides a perfect simulation of <span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span>. If the output of <span class="math">\\mathcal{A}</span> distinguishes these two cases w.h.p, then <span class="math">\\mathcal{B}</span> is able to win the PRF security game, contradicting the PRF security assumption. ∎</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Assuming that <span class="math">f</span> is a PRF, the outputs of <span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span> and <span class="math">\\mathsf{H}_{3}[x_{0},x_{1}]</span> are indistinguishable.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We use an adversary <span class="math">\\mathcal{A}</span> that distinguishes between the outputs of <span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span> and <span class="math">\\mathsf{H}_{3}[x_{0},x_{1}]</span> to construct an adversary <span class="math">\\mathcal{B}</span> that wins the PRF security game. <span class="math">\\mathcal{B}</span> acts as the challenger in the anonymity game of <span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span> and reproduces it exactly except any queries to <span class="math">f(sk_{x_{1}},\\cdot)</span> are replaced by queries to the PRF security game challenger (with a <span class="math">1</span> prepended to the input). <span class="math">\\mathcal{B}</span> then passes on the output of <span class="math">\\mathcal{A}</span> as its own output. Note that <span class="math">\\mathcal{B}</span> provides a perfect simulation of either <span class="math">\\mathsf{H}_{2}[x_{0},x_{1}]</span> or <span class="math">\\mathsf{H}_{3}[x_{0},x_{1}]</span> depending on whether the PRF challenger uses a PRF or a random function. As such, the output of <span class="math">\\mathcal{B}</span> will determine whether it was interacting with a PRF or a random function and win the PRF security game.</p>

    <p class="text-gray-300">By Lemmas 2 and 3, we have shown that <span class="math">\\mathsf{H}_{0}[x_{0},x_{1}]</span> is indistinguishable from <span class="math">\\mathsf{H}_{3}[x_{0},x_{1}]</span>. We can define corresponding hybrids <span class="math">\\mathsf{H}_{0}^{\\prime}</span>-<span class="math">\\mathsf{H}_{2}^{\\prime}[x_{0},x_{1}]</span> with accompanying indistinguishability proofs starting from <span class="math">\\mathsf{ANON}[\\mathcal{A},\\lambda,1]</span>. Note that this implies hybrids <span class="math">\\mathsf{H}_{0}[x_{0},x_{1}]</span> and <span class="math">\\mathsf{H}_{0}^{\\prime}[x_{0},x_{1}]</span> are indistinguishable. That is, for all admissible PPT adversaries <span class="math">\\mathcal{A}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pr}[\\mathsf{ANON}[\\mathcal{A},\\lambda,0]=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_{0}=x_{0},i_{1}=x_{1}]-\\mathsf{Pr}[\\mathsf{ANON}[\\mathcal{A},\\lambda,1]=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_{0}=x_{0},i_{1}=x_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">&lt;\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Now it only remains to show that the probability that <span class="math">i_{0}=x_{0},i_{1}=x_{1}</span> is polynomial in <span class="math">\\lambda</span> to complete the proof of anonymity. If we choose <span class="math">x_{0},x_{1}\\leftarrow^{0}[N]</span>, we will have that <span class="math">\\mathsf{Pr}[x_{0}=i_{0}]=\\frac{1}{N}</span> and <span class="math">\\mathsf{Pr}[x_{1}=i_{1}]=\\frac{1}{N}</span> because <span class="math">x_{0},x_{1}</span> are chosen independently of <span class="math">\\mathcal{A}</span>. So the probability that <span class="math">i_{0}=x_{0},i_{1}=x_{1}</span> is <span class="math">\\frac{1}{N^{2}}</span> which is polynomial in <span class="math">\\lambda</span> because <span class="math">N</span>, an upper bound on the group size, is polynomial in <span class="math">\\lambda</span>. Thus we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{1}{N^{2}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pr}[\\mathsf{ANON}[\\mathcal{A},\\lambda,0]=1]-\\mathsf{Pr}[\\mathsf{ANON}[\\mathcal{A},\\lambda,1]=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\mathsf{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since <span class="math">N^{2}\\mathsf{negl}(\\lambda)</span> is still negligible in <span class="math">\\lambda</span>, this completes the proof. ∎</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof of Theorem 6.</h6>

    <p class="text-gray-300">We proceed by a series of hybrids and begin by describing our hybrids:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{H}_{0}</span>: The real unforgeability game, <span class="math">\\mathsf{FORGE}[\\mathcal{A},\\lambda]</span> run with an admissible adversary <span class="math">\\mathcal{A}</span>. <span class="math">i_{0}=x_{0}</span> and <span class="math">i_{1}=x_{1}</span> in the Challenge phase of the anonymity game.</li>

      <li><span class="math">\\mathsf{H}_{1}</span>: Same as the previous hybrid, but with the proof of knowledge <span class="math">\\pi</span> always replaced with the output of its simulator. This is indistinguishable from the previous hybrid by the zero-knowledge property of the proof.</li>

      <li><span class="math">\\mathsf{H}_{2}</span>: Same as previous hybrid, but we also run the extractor on each hidden value in the proof of knowledge <span class="math">\\pi</span> from the forgery and output <span class="math">0</span> (i.e. adversary loses) if the extractor fails. This is indistinguishable from the previous world by the simulation-sound extractability property of the proof of knowledge.</li>

      <li><span class="math">\\mathsf{H}_{3}</span>: Same as the previous hybrid, but we output <span class="math">0</span> (i.e. adversary loses) if the values of (<span class="math">t_{i}^{\\mathsf{join}}</span>, <span class="math">c_{i}</span>) extracted from the forgery are not from a certificate issued by the group manager. This is indistinguishable from the previous world by the unforgeability of signature scheme <span class="math">\\mathcal{S}</span>.</li>

      <li><span class="math">\\mathsf{H}_{4}</span>: Same as previous hybrid, but we abort if there exists a <span class="math">j\\in U</span>, that is, a party <span class="math">\\mathcal{P}_{j}</span> in the set of corrupted group members, such that for <span class="math">\\mathsf{cert}_{i}</span> extracted from the forgery, <span class="math">t_{i}^{\\mathsf{join}}=f(\\mathsf{sk}_{j},c_{i})</span>. This is indistinguishable from the previous world by the collision-resistance of <span class="math">f</span>.</li>

    </ul>

    <p class="text-gray-300">Indistinguishability between hybrids <span class="math">\\mathsf{H}_{0}</span> and <span class="math">\\mathsf{H}_{1}</span> follows immediately from the zero-knowledge property of <span class="math">\\pi</span> and indistinguishability between hybrids <span class="math">\\mathsf{H}_{1}</span> and <span class="math">\\mathsf{H}_{2}</span> follows immediately from the simulation-sound extractability of <span class="math">\\pi</span>. We therefore omit these proofs. Next, we prove indistinguishability between the remaining hybrids.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Assuming that <span class="math">\\mathcal{S}</span> is an unforgeable signature scheme, the outputs of <span class="math">\\mathsf{H}_{2}</span> and <span class="math">\\mathsf{H}_{3}</span> are indistinguishable.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that so long as the <span class="math">\\mathsf{cert}_{i}</span> extracted from adversary <span class="math">\\mathcal{A}</span>’s forgery contains values <span class="math">(t_{i}^{\\mathsf{join}},c_{i})</span> from a certificate issued by the group manager, the outputs of <span class="math">\\mathsf{H}_{2}</span> and <span class="math">\\mathsf{H}_{3}</span> are identical, so the only case in which the two distributions differ is when <span class="math">\\mathsf{Verify}(\\mathsf{gpk},(t_{i}^{\\mathsf{join}},c_{i}),\\sigma_{i})=1</span> and <span class="math">(t_{i}^{\\mathsf{join}},c_{i})</span> were not issued by the group manager (and the adversary wins). Call this event <span class="math">F</span>. We will show that <span class="math">F</span> occurs with at most negligible probability.</p>

    <p class="text-gray-300">We build an adversary <span class="math">\\mathcal{B}</span> for <span class="math">\\mathcal{S}</span>’s unforgeability game that wins with non-negligible probability if <span class="math">\\mathsf{Pr}[F]&gt;\\mathsf{negl}(\\lambda)</span>. <span class="math">\\mathcal{B}</span> acts as the challenger in the EPID signature unforgeability game <span class="math">\\mathsf{H}_{3}</span> and reproduces it exactly except any signing queries to <span class="math">\\mathsf{Sign}(gsk,\\cdot)</span> are sent to the unforgeability game for <span class="math">\\mathcal{S}</span>. As its forgery, <span class="math">\\mathcal{B}</span> outputs the value <span class="math">t_{i}^{\\mathsf{join}}</span> extracted from adversary <span class="math">\\mathcal{A}</span>’s EPID signature forgery.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> wins <span class="math">\\mathcal{S}</span>’s unforgeability game exactly when event <span class="math">F</span> occurs. Thus, if <span class="math">F</span> occurs with more than negligible probability, <span class="math">\\mathcal{B}</span> breaks the unforgeability of signature scheme <span class="math">\\mathcal{S}</span>. Since <span class="math">\\mathcal{S}</span> is an unforgeable signature scheme, <span class="math">F</span> must occur with at most negligible probability, so the outputs of <span class="math">\\mathsf{H}_{2}</span> and <span class="math">\\mathsf{H}_{3}</span> must only differ with at most negligible probability.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Assuming that <span class="math">f</span> is a collision-resistant hash function, the outputs of <span class="math">\\mathsf{H}_{3}</span> and <span class="math">\\mathsf{H}_{4}</span> are indistinguishable.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that so long as there is no <span class="math">j\\in U</span> such that for <span class="math">\\mathsf{cert}_{i}</span> extracted from the forgery, <span class="math">t_{i}^{\\mathsf{join}}=f(\\mathsf{sk}_{j},c_{i})</span>, the outputs of <span class="math">\\mathsf{H}_{3}</span> and <span class="math">\\mathsf{H}_{4}</span> are identical, so the only case in which the two distributions differ is when there does exist such a <span class="math">j</span> and the adversary <span class="math">\\mathcal{A}</span> successfully outputs a forgery. Call this event <span class="math">F</span>. We will show that <span class="math">F</span> occurs with at most negligible probability.</p>

    <p class="text-gray-300">Since it is possible for <span class="math">j\\in U</span> to be revoked by key or by signature, we will show only the case where the group member <span class="math">\\mathcal{P}_{j}</span> is revoked by key. The case for revocation by signature is analogous. Let <span class="math">t_{i}</span> be the value of <span class="math">t</span> extracted from the <span class="math">\\mathcal{A}</span>’s forgery. In order for event <span class="math">F</span> to occur, the adversary must produce a value <span class="math">sk_{i}</span> such that <span class="math">(f(\\mathsf{sk}_{i},r),\\ r)=t_{i}\\neq(f(\\mathsf{sk}_{j},r),\\ r)</span> and <span class="math">f(\\mathsf{sk}_{i},c_{i})=t_{i}^{\\mathsf{join}}=f(\\mathsf{sk}_{j},c_{i})</span>.</p>

    <p class="text-gray-300">We build an adversary <span class="math">\\mathcal{B}</span> that breaks the collision-resistance of <span class="math">f</span> when event <span class="math">F</span> occurs with greater than negligible probability. <span class="math">\\mathcal{B}</span> acts as the challenger in the EPID signature unforgeability game <span class="math">\\mathsf{H}_{3}</span>. At the conclusion of the game, if there exists a group member <span class="math">\\mathcal{P}_{j}</span> as defined in <span class="math">\\mathsf{H}_{4}</span>, <span class="math">\\mathcal{B}</span> outputs the values <span class="math">(\\mathsf{sk}_{i},c_{j})</span> and <span class="math">(\\mathsf{sk}_{j},c_{j})</span>, where <span class="math">\\mathsf{sk}_{i}</span> is extracted from <span class="math">\\mathcal{A}</span>’s forgery and <span class="math">\\mathsf{sk}_{j}</span> by a linear search over compromised group member keys, as its candidate collision for <span class="math">f</span>. Otherwise, it fails to output a collision.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> outputs a successful collision on <span class="math">f</span> whenever event <span class="math">F</span> occurs. Thus, if <span class="math">F</span> occurs with greater than negligible probability, <span class="math">\\mathcal{B}</span> breaks the collision-resistance of <span class="math">f</span> on <span class="math">t_{j}^{\\mathsf{join}}</span>. Since <span class="math">f</span> is collision-resistant, <span class="math">F</span> must occur with at most negligible probability, so the outputs of <span class="math">\\mathsf{H}_{3}</span> and <span class="math">\\mathsf{H}_{4}</span> must only differ with negligible probability.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">By Lemmas 4 and 5, we have shown that <span class="math">\\mathsf{FORGE}[\\mathcal{A},\\lambda]</span> is indistinguishable from <span class="math">\\mathsf{H}_{4}</span>. Now we will show how to use an adversary <span class="math">\\mathcal{A}</span> who successfully outputs a forgery in <span class="math">\\mathsf{H}_{4}</span> with non-negligible probability to construct an adversary <span class="math">\\mathcal{B}</span> that breaks the PRF security of <span class="math">f</span>, completing the proof.</p>

    <p class="text-gray-300">Adversary <span class="math">\\mathcal{B}</span> begins by picking a value <span class="math">n^{<em>}\\ \\epsilon^{\\underline{n}}\\ [N]</span>, where <span class="math">N</span> is an upper bound on the number of members in the group. Then <span class="math">\\mathcal{B}</span> acts as the challenger in the unforgeability game of <span class="math">\\mathsf{H}_{4}</span> and reproduces it exactly except any queries to <span class="math">f(sk_{n^{</em>}},\\cdot)</span> are replaced by queries to the PRF security game challenger. Let <span class="math">\\mathsf{F}_{\\mathsf{PRF}}</span> be the function computed by the PRF adversary. If the <span class="math">\\mathsf{cert}_{i}</span> extracted from</p>

    <p class="text-gray-300">from the <span class="math">\\mathcal{A}</span>’s forgery is not equal to <span class="math">\\mathsf{cert}_{n^{<em>}}</span>, <span class="math">\\mathcal{B}</span> aborts. Otherwise, for the value <span class="math">r</span> used in <span class="math">\\mathcal{A}</span>’s forgery, <span class="math">\\mathcal{B}</span> queries the PRF adversary on <span class="math">r</span> to get response <span class="math">\\mathsf{F_{PRF}}(r)</span>. If <span class="math">\\mathsf{F_{PRF}}(r)=f(\\mathsf{sk}_{n^{</em>}},r)</span> <span class="math">\\mathcal{B}</span> outputs <span class="math">1</span> (interacting with PRF). Otherwise, it outputs <span class="math">0</span>.</p>

    <p class="text-gray-300">Now we argue that <span class="math">\\mathcal{B}</span> successfully distinguishes between a PRF and a random function. First, suppose for the certificate <span class="math">\\mathsf{cert}_{i}</span> extracted from the forgery, that <span class="math">\\mathsf{cert}_{i}=\\mathsf{cert}_{n^{<em>}}</span>, so <span class="math">\\mathsf{F_{PRF}}(c_{n^{</em>}})=f(\\mathsf{sk_{n^{<em>}}},c_{n^{</em>}})</span>. If <span class="math">\\mathcal{B}</span> is interacting with a random function, <span class="math">\\mathcal{B}</span> will output <span class="math">0</span> with high probability because a random function only collides with <span class="math">f(\\mathsf{sk}_{n^{*}},\\cdot)</span> on <span class="math">r</span> with negligible probability. On the other hand, if <span class="math">\\mathcal{B}</span> is interacting with a PRF with key <span class="math">\\mathsf{sk}_{n^{\\prime}}</span>, there are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{sk}_{n^{\\prime}}=\\mathsf{sk}_{n^{*}}</span>: In this case, <span class="math">\\mathcal{B}</span> always outputs <span class="math">1</span>.</li>

      <li><span class="math">\\mathsf{sk}_{n^{\\prime}}\\neq\\mathsf{sk}_{n^{<em>}}</span>: Then <span class="math">\\mathsf{f}(\\mathsf{sk}_{n^{\\prime}},c_{n^{</em>}})=f(\\mathsf{sk_{n^{<em>}}},c_{n^{</em>}})</span> is a collision that violates the collision-resistance of <span class="math">f</span>. Note that this is where we need the check that <span class="math">r\\neq c_{i}^{<em>}</span> because if this check were omitted, an adversary could set <span class="math">r=c_{n}^{</em>}</span> and render the query <span class="math">\\mathsf{F_{PRF}}(r)</span> useless for <span class="math">\\mathcal{B}</span> since <span class="math">\\mathcal{B}</span> already knows this value. Since all the algorithms involved in finding this collision are efficient, this case must only occur with negligible probability.</li>

    </ul>

    <p class="text-gray-300">All that remains is to show that <span class="math">\\mathsf{cert}_{i}=\\mathsf{cert}_{n^{<em>}}</span> with non-negligible probability. Since <span class="math">\\mathsf{cert}_{i}</span> corresponds to a certificate issued by the group manager with all but negligible probability (in which case <span class="math">\\mathcal{A}</span> would abort early), we are assured that <span class="math">i\\in[N]</span>. Since <span class="math">n^{</em>}</span> is chosen independently of <span class="math">\\mathcal{A}</span>’s choice of <span class="math">i</span>, there is a <span class="math">\\frac{1}{N}</span> chance that <span class="math">n^{*}=i</span>, which is certainly non-negligible in <span class="math">\\lambda</span> because there can only be polynomially many group members created by <span class="math">\\mathcal{A}</span>. ∎</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof (sketch) of Theorem 12.</h6>

    <p class="text-gray-300">We proceed by a series of hybrids:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{H_{0}}</span>: The real unforgeability game, <span class="math">\\mathsf{FORGE}[\\mathcal{A},\\lambda]</span> run with an admissible adversary <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathsf{H_{1}}</span>: Same as the previous hybrid, but we output <span class="math">0</span> (i.e. adversary loses) if the signature <span class="math">\\sigma_{\\wedge}</span> received by the verifier in any <span class="math">\\mathsf{ReJoin}</span> is not on an accumulator value <span class="math">\\Lambda</span> output by <span class="math">\\mathcal{M}</span> in a <span class="math">\\mathsf{Join}</span> protocol. This is indistinguishable from the previous world by the unforgeability of signature scheme <span class="math">\\mathcal{S}</span>.</li>

      <li><span class="math">\\mathsf{H_{2}}</span>: Same as the previous hybrid, but we output <span class="math">0</span> (i.e. adversary loses) if the signature <span class="math">\\sigma_{\\wedge}</span> in the forgery is not for the value of <span class="math">\\Lambda</span> included in the forgery or if <span class="math">\\Lambda</span> is not an accumulator value output by <span class="math">\\mathcal{M}</span> in a <span class="math">\\mathsf{Join}</span> protocol. This is indistinguishable from the previous world by the unforgeability of signature scheme <span class="math">\\mathcal{S}</span>.</li>

      <li><span class="math">\\mathsf{H_{3}}</span>: Same as previous hybrid, but we also run the extractor on each hidden value in the proof of knowledge <span class="math">\\pi</span> from the forgery and output <span class="math">0</span> (i.e. adversary loses) if the extractor fails. This is indistinguishable from the previous world by the extractability property of the proof of knowledge.</li>

      <li><span class="math">\\mathsf{H_{4}}</span>: Same as the previous hybrid, but we output <span class="math">0</span> (i.e. adversary loses) if the membership proof <span class="math">\\mathsf{wt}_{x_{i}}</span> extracted from the forgery does not correspond to a value of <span class="math">x_{i}\\in\\mathcal{X}</span>, the set accumulated by <span class="math">\\Lambda</span>. This is indistinguishable from the previous world by the collision-freeness of the accumulator <span class="math">\\mathcal{A}c</span>, as the proof <span class="math">\\mathsf{wt}_{x_{i}}</span> could be used to break collision-freeness if it were produced with greater than negligible probability.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{H}_{5}</span>: Same as previous hybrid, but we abort if there exists a <span class="math">j\\in U</span>, that is, a party <span class="math">\\mathcal{P}_{j}</span> in the set of corrupted group members, such that for <span class="math">\\mathsf{cert}_{i}</span> extracted from the forgery, <span class="math">r_{i}^{\\mathsf{join}}=f(\\mathsf{sk}_{j},c_{i})</span>. This is indistinguishable from the previous world by the collision-resistance of <span class="math">f</span>.</li>

    </ul>

    <p class="text-gray-300">Indistinguishability proofs between hybrids are analogous to those of EPID signature scheme <span class="math">\\mathcal{G}</span>, as is the final argument for unforgeability from Hybrid <span class="math">\\mathsf{H}_{5}</span>. ∎</p>

    <h2 id="sec-55" class="text-2xl font-bold">Appendix D EPID Definitions for Construction II</h2>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 27 (EPID Signature for Attestation).</h6>

    <p class="text-gray-300">An EPID signature scheme <span class="math">\\mathcal{GA}</span> for attestation involving a group manager <span class="math">\\mathcal{M}</span> and <span class="math">n</span> group members parties <span class="math">\\mathcal{P}_{1}</span> to <span class="math">\\mathcal{P}_{n}</span> consists of algorithms <span class="math">\\mathsf{GAInit}</span>, <span class="math">\\mathsf{GAJoin}</span>, <span class="math">\\mathsf{GARejoin}</span>, <span class="math">\\mathsf{GASign}</span>, <span class="math">\\mathsf{GAVerify}</span>, <span class="math">\\mathsf{RevokeKey}</span> and <span class="math">\\mathsf{RevokeSig}</span>. In the following, <span class="math">\\mathcal{X}</span> represents a set, <span class="math">\\Lambda</span> represents a static accumulator representing <span class="math">\\mathcal{X}</span>, and <span class="math">\\sigma_{\\Lambda}</span> is a signature on <span class="math">\\Lambda</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{gsk},\\mathsf{gpk})\\leftarrow\\mathsf{GAInit}(1^{\\lambda})</span>: This algorithm takes as input a security parameter <span class="math">1^{\\lambda}</span> and outputs a key pair <span class="math">(\\mathsf{gsk},\\mathsf{gpk})</span>.</li>

      <li><span class="math">\\langle(\\mathsf{cert}_{i},\\Lambda,\\sigma_{\\wedge}),(\\mathsf{sk}_{i},\\mathsf{cert}_{i},\\Lambda,\\sigma_{\\wedge})\\rangle\\leftarrow\\mathsf{GAJoin}_{\\mathcal{M},\\mathcal{P}_{i}}\\langle(\\mathsf{gsk},\\mathsf{gpk},\\mathcal{X}),\\mathsf{gpk}\\rangle</span>: This is a protocol between the group manager and a group member <span class="math">\\mathcal{P}_{i}</span> where each party has its keys as input, and the group manager also has the set <span class="math">\\mathcal{X}</span> of group member credentials. Both parties get party <span class="math">\\mathcal{P}_{i}</span>’s certificate, an accumulator value <span class="math">\\Lambda</span>, and a signature <span class="math">\\sigma_{\\wedge}</span> on <span class="math">\\Lambda</span> from the group manager as output. <span class="math">\\mathcal{P}_{i}</span> also gets its secret key <span class="math">\\mathsf{sk}_{i}</span> as an output.</li>

      <li><span class="math">\\langle(\\mathsf{cert}_{i},\\Lambda,\\sigma_{\\wedge}),(\\mathsf{cert}_{i},\\Lambda,\\sigma_{\\wedge})\\rangle\\leftarrow\\mathsf{GARejoin}_{\\mathcal{M},\\mathcal{P}_{i}}\\langle(\\mathsf{gsk},\\mathsf{gpk},\\mathcal{X},\\Lambda,\\sigma_{\\wedge}),(\\mathsf{gpk},\\mathsf{cert}_{i})\\rangle</span>: This is a protocol between the group manager and a group member <span class="math">\\mathcal{P}_{i}</span> where the group manager has the group key pair, a set of user credentials <span class="math">\\mathcal{X}</span>, an accumulator <span class="math">\\Lambda</span> for <span class="math">\\mathcal{X}</span>, and a signature <span class="math">\\sigma_{\\wedge}</span> on <span class="math">\\Lambda</span> as inputs, and group member <span class="math">\\mathcal{P}_{i}</span> has the group public key and its certificate as inputs. Both parties get an updated certificate for <span class="math">\\mathcal{P}_{i}</span> as well as the accumulator value <span class="math">\\Lambda</span> and signature <span class="math">\\sigma_{\\wedge}</span> as outputs.</li>

      <li><span class="math">\\bot/\\mathsf{sig}\\leftarrow\\mathsf{GASign}(\\mathsf{gpk},\\mathsf{sk}_{i},\\mathsf{cert}_{i},m,\\mathsf{SIG-RL},\\Lambda,\\sigma_{\\wedge})</span>: This algorithm takes as input the public key, party <span class="math">\\mathcal{P}_{i}</span>’s secret key and certificate, a signature revocation list <span class="math">\\mathsf{SIG-RL}</span>, an accumulator <span class="math">\\Lambda</span>, and a signature <span class="math">\\sigma_{\\wedge}</span> on <span class="math">\\Lambda</span> from the group manager. The output is an EPID signature <span class="math">\\mathsf{sig}</span>.</li>

      <li><span class="math">1/0\\leftarrow\\mathsf{GAVerify}(\\mathsf{gpk},m,\\mathsf{KEY-RL},\\mathsf{SIG-RL},\\mathsf{sig})</span>: This algorithm verifies an EPID signature <span class="math">\\mathsf{sig}</span> on a message <span class="math">m</span> given the group public key and key/signature revocation lists <span class="math">\\mathsf{KEY-RL}</span>, <span class="math">\\mathsf{SIG-RL}</span>. It outputs <span class="math">1</span> to accept the signature and <span class="math">0</span> to reject it.</li>

      <li><span class="math">\\mathsf{KEY-RL}\\leftarrow\\mathsf{GARevokeKey}(\\mathsf{gpk},\\mathsf{KEY-RL},\\mathsf{sk}_{i})</span>: This algorithm adds a secret key <span class="math">\\mathsf{sk}_{i}</span> to a key revocation list, so signatures created with this key will no longer be accepted.</li>

      <li><span class="math">\\mathsf{SIG-RL}\\leftarrow\\mathsf{GARevokeSig}(\\mathsf{gpk},\\mathsf{KEY-RL},\\mathsf{SIG-RL},m,\\mathsf{sig})</span>: This algorithm adds a signature <span class="math">\\mathsf{sig}</span> to a signature revocation list, so signatures created with the same key as <span class="math">\\mathsf{sig}</span> will no longer be accepted.</li>

    </ul>

    <p class="text-gray-300">In order to capture the security guarantees of our new setting for the second construction, namely the fact that anonymity only applies relative to the anonymity set of users with the same merkle root, we add the following admissibility criterion for anonymity adversaries.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 28 (Admissible Anonymity Adversary for Attestation).</h6>

    <p class="text-gray-300">An adversary <span class="math">\\mathcal{A}</span> is <em>admissible</em> for <span class="math">\\mathsf{ANON}[\\mathcal{A},\\lambda,b]</span> if it satisfies the following criteria:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is an admissible anonymity adversary as in Definition 22.</li>

      <li>It chooses parties <span class="math">\\mathcal{P}_{i_{0}}</span> and <span class="math">\\mathcal{P}_{i_{1}}</span> that produce signatures relative to the same accumulator <span class="math">\\Lambda</span>.</li>

    </ul>`;
---

<BaseLayout title="Post-Quantum EPID Signatures from Symmetric Primitives (2018/261)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/261
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
