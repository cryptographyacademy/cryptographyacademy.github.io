---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/403';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On Instantiating Pairing-Based Protocols with Elliptic Curves of Embedding Degree One';
const AUTHORS_HTML = 'Sanjit Chatterjee, Alfred Menezes, Francisco Rodriguez-Henriquez';

const CONTENT = `    <p class="text-gray-300">SANJIT CHATTERJEE, ALFRED MENEZES, AND FRANCISCO RODRÍGUEZ-HENRÍQUEZ</p>

    <p class="text-gray-300">ABSTRACT. Since the discovery of identity-based encryption schemes in 2000, bilinear pairings have been used in the design of hundreds of cryptographic protocols. The most commonly used pairings are constructed from elliptic curves over finite fields with small embedding degree. These pairings can have different security, performance, and functionality characteristics, and were therefore classified into Types 1, 2, 3 and 4. In this paper, we observe that this conventional classification is not applicable to pairings from elliptic curves with embedding degree one. It is important to understand the security, efficiency, and functionality of these pairings in light of recent attacks on certain pairings constructed from elliptic curves with embedding degree greater than one. We define three kinds of pairings from elliptic curves with embedding degree one, discuss some subtleties with using them to implement pairing-based protocols, and provide an estimated cost of implementing them on modern processors.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}_1</span>, <span class="math">\\mathbb{G}_2</span> and <span class="math">\\mathbb{G}_T</span> be groups of prime order <span class="math">n</span>. A cryptographic pairing <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> is a map that is bilinear, non-degenerate and efficiently computable. Since 2000, when Boneh and Franklin proposed their identity-based encryption scheme [11], cryptographic pairings have been used extensively to design a wide variety of cryptographic protocols.</p>

    <p class="text-gray-300">Cryptographic pairings are constructed from elliptic curves of small embedding degree. More precisely, let <span class="math">E</span> be an elliptic curve defined over the finite field <span class="math">\\mathbb{F}_q</span>. Let <span class="math">n</span> be a prime divisor of <span class="math">\\# E(\\mathbb{F}_q)</span> with <span class="math">\\gcd(n,q) = 1</span>, and let <span class="math">k</span> be the smallest positive integer such that <span class="math">n \\mid q^k - 1</span>; the number <span class="math">k</span> is called the embedding degree of <span class="math">E</span> (with respect to <span class="math">n</span>). Then <span class="math">\\mathbb{G}_1</span> is an order-<span class="math">n</span> subgroup of <span class="math">E(\\mathbb{F}_q)</span>, <span class="math">\\mathbb{G}_2</span> is an order-<span class="math">n</span> subgroup of <span class="math">E(\\mathbb{F}_{q^k})</span>, <span class="math">\\mathbb{G}_T</span> is the order-<span class="math">n</span> subgroup of <span class="math">\\mathbb{F}_{q^k}^*</span>, and the map <span class="math">e</span> is derived from the classical Weil and Tate pairings. Among the elliptic curves that have been used to implement pairings are supersingular curves of embedding degree 4 over finite fields of characteristic two (see [7]), supersingular curves of embedding degree 6 over finite fields of characteristic three (see [7]), supersingular and ordinary curves of embedding degree 2 over finite fields of prime order (see [46]), and Barreto-Naehrig (BN) ordinary curves of embedding degree 12 over finite fields of prime order [9].</p>

    <p class="text-gray-300">A necessary condition for the security of pairing-based protocols is that the discrete logarithm problem (DLP) in <span class="math">\\mathbb{F}_{q^k}</span> is intractable. Until recently, the assumption was that the</p>

    <p class="text-gray-300">Date: April 22, 2016; updated on November 11, 2016.</p>

    <p class="text-gray-300">fastest algorithm for computing logarithms in small-characteristic finite fields <span class="math">\\mathbb{F}_{q}</span> was Coppersmith’s algorithm <em>[22]</em> with running time <span class="math">L_{q}[\\frac{1}{3},(\\frac{32}{9})^{1/3}]\\approx L_{q}[\\frac{1}{3},1.526]</span>, and the fastest algorithm for computing logarithms in large-characteristic finite fields <span class="math">\\mathbb{F}_{q}</span> was the Number Field Sieve (NFS) <em>[28, 43]</em> with running time <span class="math">L_{q}[\\frac{1}{3},(\\frac{64}{9})^{1/3}]\\approx L_{q}[\\frac{1}{3},1.923]</span>. Here, <span class="math">L_{Q}[\\alpha,c]</span> with <span class="math">0&lt;\\alpha&lt;1</span> and <span class="math">c&gt;0</span> denotes the expression</p>

    <p class="text-gray-300"><span class="math">O\\left(\\;\\exp\\left((c+o(1))(\\log Q)^{\\alpha}(\\log\\log Q)^{1-\\alpha}\\right)\\,\\right)</span></p>

    <p class="text-gray-300">that is subexponential in <span class="math">\\log Q</span>. However, recent work has shown that these assumptions were overly optimistic. Most dramatically, in 2013 a quasi-polynomial time algorithm (with running time <span class="math">L_{q}[\\epsilon,c]</span> for any <span class="math">\\epsilon&gt;0</span>) was devised for computing discrete logarithms in small-characteristic finite fields <span class="math">\\mathbb{F}_{q}</span> <em>[6]</em>, effectively breaking all pairings derived from supersingular elliptic curves over small-characteristic finite fields (see <em>[1, 29]</em>). In 2015, Kim and Barbulescu <em>[37]</em> devised a variant of the NFS that computes logarithms in <span class="math">\\mathbb{F}_{q}=\\mathbb{F}_{p^{k}}</span> in time <span class="math">L_{q}[\\frac{1}{3},(\\frac{48}{9})^{1/3}]\\approx L_{q}[\\frac{1}{3},1.759]</span> when <span class="math">p</span> is a medium-sized prime (more precisely, <span class="math">p=L_{q}[\\alpha,c]</span> with <span class="math">\\frac{1}{3}&lt;\\alpha&lt;\\frac{2}{3}</span>). Kim and Barbulescu state that their algorithm can be applied to computing logarithms in the fields <span class="math">\\mathbb{F}_{p^{12}}</span> that arise in BN pairings. Moreover, if <span class="math">p</span> has a special form, as is the case with BN pairings, a further refinement of their algorithm has running time <span class="math">L_{q}[\\frac{1}{3},(\\frac{32}{9})^{1/3}]</span>. Also in 2015, experiments conducted by Barbulescu et al. <em>[5]</em> illustrated that the DLP is significantly easier in <span class="math">\\mathbb{F}_{p^{2}}</span> than in prime-order fields <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">The aforementioned improvements in algorithms for computing discrete logarithms cast some suspicions on the true intractability of the DLP in extension fields <span class="math">\\mathbb{F}_{p^{k}}</span>, especially if the characteristic <span class="math">p</span> is of a special form. On the other hand, these improvements do not apply to the DLP in prime-order fields <span class="math">\\mathbb{F}_{p}</span> provided that the prime <span class="math">p</span> does not have a special form; thus, the fastest general-purpose algorithm known for the DLP in <span class="math">\\mathbb{F}_{p}</span> has running time <span class="math">L_{p}[\\frac{1}{3},(\\frac{64}{9})^{1/3}]</span>. Consequently, elliptic curves with embedding degree <span class="math">k=1</span> would appear to be a conservative choice for implementing pairing-based protocols. The group <span class="math">\\mathbb{G}_{T}</span> in these pairings is the order-<span class="math">n</span> subgroup of the multiplicative group of a prime field <span class="math">\\mathbb{F}_{p}^{*}</span>, whence security is not directly affected by advances in algorithms for computing logarithms in extension fields.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">(DLP in <span class="math">\\mathbb{F}_{p}</span> versus DLP in <span class="math">\\mathbb{F}_{p^{k}}</span>) Since <span class="math">\\mathbb{F}_{p}</span> is a subfield of <span class="math">\\mathbb{F}_{p^{k}}</span> for any <span class="math">k\\geq 2</span>, the DLP in <span class="math">\\mathbb{F}_{p}</span> can be reduced to the DLP in <span class="math">\\mathbb{F}_{p^{k}}</span>. Hence, advances in algorithms for the DLP in <span class="math">\\mathbb{F}_{p^{k}}</span> might be effective for solving the DLP in <span class="math">\\mathbb{F}_{p}</span>. For example, an <span class="math">L_{p^{k}}[\\alpha,c]</span> algorithm for solving the DLP in <span class="math">\\mathbb{F}_{p^{k}}</span> (where <span class="math">k&gt;1</span> is a constant) yields an <span class="math">L_{p}[\\alpha,ck^{\\alpha}]</span> algorithm for the DLP in <span class="math">\\mathbb{F}_{p}</span>. Hence, an <span class="math">L_{p^{2}}[\\frac{1}{3},c]</span> algorithm with <span class="math">c&lt;(\\frac{32}{9})^{1/3}</span> for the DLP in <span class="math">\\mathbb{F}_{p^{2}}</span> yields a DLP algorithm for <span class="math">\\mathbb{F}_{p}</span> that is faster than the best currently known algorithm. Similarly, an <span class="math">L_{p^{12}}[\\frac{1}{3},c]</span> algorithm with <span class="math">c&lt;(\\frac{16}{27})^{1/3}</span> for the DLP in <span class="math">\\mathbb{F}_{p^{12}}</span> yields a faster DLP algorithm for <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Elliptic curves with embedding degree one were first mentioned in <em>[34, 35, 52]</em> and further studied in <em>[38, 33, 55]</em>. These papers consider methods for generating suitable elliptic curves, and study the efficiency of the Weil and Tate pairings. However, none of these papers examine the implementation of pairing-based protocols with these pairings. Such implementation</p>

    <p class="text-gray-300">details are important in light of the many inefficiencies and problems that can arise when pairings are treated as black boxes; for example, see <em>[25, 18, 19]</em>. In this paper we observe that the often-cited classification of pairings into Types 1, 2, 3 and 4 <em>[25]</em> is not applicable to pairings from elliptic curves with embedding degree one. We define three kinds of pairings from these elliptic curves, and discuss some subtleties with using them to implement pairing-based protocols.</p>

    <p class="text-gray-300">The remainder of the paper is organized as follows. The classical Weil and Tate pairings are reviewed in §2. The salient features of elliptic curves with embedding degree one are presented in §3. Three kinds of pairings from elliptic curves with embedding degree one are introduced in §§4–6. The efficiency of these pairings is considered in §7. We draw our conclusions in §8.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2. Pairings</h2>

    <p class="text-gray-300">Let <span class="math">p&gt;3</span> be a prime, and let <span class="math">E</span> be an elliptic curve defined over the finite field <span class="math">\\mathbb{F}_{p}</span>. Let <span class="math">\\pi:(x,y)\\mapsto(x^{p},y^{p})</span> be the <span class="math">p</span>-th power Frobenius endomorphism. The <em>trace</em> of the Frobenius is <span class="math">t=p+1-\\#E(\\mathbb{F}_{p})</span>. Let <span class="math">n\\neq p</span> be a prime with <span class="math">n\\mid\\#E(\\mathbb{F}_{p})</span>. The <em>embedding degree</em> is the smallest positive integer <span class="math">k</span> satisfying <span class="math">n\\mid(p^{k}-1)</span>. We will assume that <span class="math">E[n]</span>, the group of all <span class="math">n</span>-torsion points in <span class="math">E(\\overline{\\mathbb{F}}_{p})</span>, is contained in <span class="math">E(\\mathbb{F}_{p^{k}})</span>; this is indeed the case whenever <span class="math">k&gt;1</span> <em>[4]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1. Miller functions</h3>

    <p class="text-gray-300">Let <span class="math">R\\in E(\\mathbb{F}_{p^{k}})</span> and let <span class="math">s</span> be a non-negative integer. A <em>Miller function</em> <span class="math">f_{s,R}</span> <em>[39]</em> of length <span class="math">s</span> is a function in <span class="math">\\mathbb{F}_{p^{k}}(E)</span> with divisor <span class="math">(f_{s,R})=s(R)-(sR)-(s-1)(\\infty)</span>, where <span class="math">\\infty</span> denotes the point at infinity. Let <span class="math">u_{\\infty}</span> be an <span class="math">\\mathbb{F}_{p}</span>-rational uniformizing parameter for <span class="math">\\infty</span>. A function <span class="math">f\\in\\mathbb{F}_{p^{k}}(E)</span> is said to be <em>normalized</em> if <span class="math">lc_{\\infty}(f)=1</span>, where <span class="math">lc_{\\infty}(f)=(u_{\\infty}^{-t}f)(\\infty)</span> and <span class="math">t</span> is the order of <span class="math">f</span> at <span class="math">\\infty</span>.</p>

    <p class="text-gray-300">Let <span class="math">P,Q\\in E[n]\\setminus\\{\\infty\\}</span>. Miller <em>[39]</em> described Algorithm 1 for evaluating a normalized Miller function <span class="math">f_{n,P}</span> at the point <span class="math">Q</span>. In the algorithm, the line functions <span class="math">\\ell</span> and <span class="math">v</span> are normalized.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">(failure of a Miller function computation) When Miller’s algorithm is used to compute <span class="math">f_{n,P}(Q)</span>, one might obtain a value of <span class="math">0</span> in the numerator or denominator. This occurs only if <span class="math">Q</span> happens to be a root of one of the line functions <span class="math">\\ell</span>, <span class="math">v</span> encountered in the computation. Since the roots of <span class="math">\\ell</span> and <span class="math">v</span> must lie in <span class="math">\\langle P\\rangle</span>, we conclude that a Miller function computation can only fail if <span class="math">Q\\in\\langle P\\rangle</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2. Weil and Tate pairings</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}_{T}</span> be the order-<span class="math">n</span> subgroup of <span class="math">\\mathbb{F}_{p^{k}}^{<em>}</span>. The </em>Weil pairing* <span class="math">w_{n}</span> can be defined as follows.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1 (<em>[39]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">P,Q\\in E[n]\\setminus\\{\\infty\\}</span> with <span class="math">P\\neq Q</span>. Then the Weil pairing is</p>

    <p class="text-gray-300">(1) <span class="math">w_{n}(P,Q)=(-1)^{n}\\frac{f_{n,P}(Q)}{f_{n,Q}(P)},</span></p>

    <p class="text-gray-300">where <span class="math">f_{n,P}</span> and <span class="math">f_{n,Q}</span> are normalized Miller functions. Furthermore, <span class="math">w_{n}(P,\\infty)=w_{n}(\\infty,P)=w_{n}(P,P)=1</span> for all <span class="math">P\\in E[n]</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">S. CHATTERJEE, A. MENEZES, AND F. RODRIGUEZ-HENRIQUEZ</p>

    <p class="text-gray-300">|  Algorithm 1 Miller's algorithm  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: P, Q ∈ E[n] \\ {∞}.  |   |</p>

    <p class="text-gray-300">|  Output: fn,P(Q).  |   |</p>

    <p class="text-gray-300">|  1: Write n in binary: n = ∑i=0L-1ni2i  |   |</p>

    <p class="text-gray-300">|  2: f ← 1, g ← 1, T ← P  |   |</p>

    <p class="text-gray-300">|  3: for i ← L-2 downto 0 do  |   |</p>

    <p class="text-gray-300">|  4: Compute the tangent line ℓ through T and the vertical line v through 2T  |   |</p>

    <p class="text-gray-300">|  5: T ← 2T  |   |</p>

    <p class="text-gray-300">|  6: f ← f2·ℓ(Q)  |   |</p>

    <p class="text-gray-300">|  7: g ← g2·v(Q)  |   |</p>

    <p class="text-gray-300">|  8: if ni = 1 then  |   |</p>

    <p class="text-gray-300">|  9: Compute the line ℓ through T and P and the vertical line v through T + P  |   |</p>

    <p class="text-gray-300">|  10: T ← T + P  |   |</p>

    <p class="text-gray-300">|  11: f ← f·ℓ(Q)  |   |</p>

    <p class="text-gray-300">|  12: g ← g·v(Q)  |   |</p>

    <p class="text-gray-300">|  13: end if  |   |</p>

    <p class="text-gray-300">|  14: end for  |   |</p>

    <p class="text-gray-300">|  15: return f/g  |   |</p>

    <p class="text-gray-300">The (reduced) Tate pairing  <span class="math">t_n</span>  can be defined as follows.</p>

    <p class="text-gray-300">Definition 2 ([51]). Let  <span class="math">P, Q \\in E[n]</span> . Let  <span class="math">R \\in E(\\mathbb{F}_{p^k})</span>  with  <span class="math">R \\notin \\{\\infty, P, -Q, P - Q\\}</span> . Then the Tate pairing is</p>

    <p class="text-gray-300">(2)  <span class="math">t_n(P, Q) = \\left(\\frac{f_{n,P}(Q + R)}{f_{n,P}(R)}\\right)^{(p^k - 1)/n}.</span></p>

    <p class="text-gray-300">If  <span class="math">f_{n,P}</span>  is normalized, then</p>

    <p class="text-gray-300">(3)  <span class="math">t_n(P,Q) = (f_{n,P}(Q))^{(p^k -1) / n}</span></p>

    <p class="text-gray-300">for all  <span class="math">P, Q \\in E[n] \\setminus \\{\\infty\\}</span>  with  <span class="math">P \\neq Q</span> .</p>

    <p class="text-gray-300">2.3. Type 1, 2, 3 and 4 pairings. In cryptographic applications, one generally considers the restrictions of the Weil and Tate pairings to a domain  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_2</span> , where  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are fixed order- <span class="math">n</span>  subgroups of  <span class="math">E[n]</span> .</p>

    <p class="text-gray-300">Suppose now that the embedding degree  <span class="math">k</span>  is even. Galbraith, Paterson and Smart [25] defined three kinds of pairings  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> . The pairing  <span class="math">e</span>  is of Type 1 (symmetric) if  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span> . Now, let  <span class="math">\\mathbb{G}_1 = E(\\mathbb{F}_p)[n]</span> . Let  <span class="math">d</span>  be the order of the automorphism group of  <span class="math">E</span> , and suppose that  <span class="math">d \\mid k</span> . Let  <span class="math">e = k / d</span> . Then there is a unique degree-  <span class="math">d</span>  twist  <span class="math">\\tilde{E}</span>  of  <span class="math">E</span>  over  <span class="math">\\mathbb{F}_{p^e}</span>  with  <span class="math">n \\mid \\# \\tilde{E}(\\mathbb{F}_{p^e})</span>  [32]; let  <span class="math">\\mu: \\tilde{E} \\to E</span>  be the associated twisting isomorphism. Let  <span class="math">\\tilde{Q} \\in \\tilde{E}(\\mathbb{F}_{p^e})</span>  be a point of order  <span class="math">n</span> , and let  <span class="math">\\mathbb{G}_2 = \\langle Q \\rangle</span>  where  <span class="math">Q = \\mu(\\tilde{Q})</span> . The group  <span class="math">\\mathbb{G}_2</span>  is called the Trace-0 subgroup of  <span class="math">E[n]</span>  since it is comprised of all points  <span class="math">P \\in E[n]</span>  for which</p>

    <p class="text-gray-300">ELLiptic CURVES OF EMBEDDING DEGREE ONE</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Tr}(P) = \\sum_{i=0}^{k-1} \\pi^i(P) = \\infty</span>. Then <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> is a Type 3 pairing. Finally, if <span class="math">\\mathbb{G}_2&#x27;</span> is any order-<span class="math">n</span> subgroup of <span class="math">E[n]</span> different from <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span>, then <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2&#x27; \\to \\mathbb{G}_T</span> is a Type 2 pairing.</p>

    <p class="text-gray-300">Type 2 pairings have two properties that distinguish them from Type 3 pairings: an efficient method for hashing onto <span class="math">\\mathbb{G}_2&#x27;</span> is not known<span class="math">^1</span>, and there is an efficiently-computable isomorphism <span class="math">\\psi</span> from <span class="math">\\mathbb{G}_2&#x27;</span> to <span class="math">\\mathbb{G}_1</span> (given by the Trace map). In contrast, hashing onto <span class="math">\\mathbb{G}_2</span> can be done efficiently and no efficiently-computable isomorphism from <span class="math">\\mathbb{G}_2</span> to <span class="math">\\mathbb{G}_1</span> is known for Type 3 pairings.</p>

    <p class="text-gray-300">Shacham [49] proposed pairings <span class="math">e: \\mathbb{G}_1 \\times E[n] \\to \\mathbb{G}_T</span>, subsequently named Type 4 pairings. These pairings have the distinguishing property that the Trace map is an efficiently-computable homomorphism from <span class="math">E[n]</span> onto <span class="math">\\mathbb{G}_1</span> with kernel <span class="math">\\mathbb{G}_2</span>. Furthermore, hashing onto <span class="math">E[n]</span> is relatively efficient [16].</p>

    <h2 id="sec-9" class="text-2xl font-bold">3. ELLiptic curves with embedding degree one</h2>

    <p class="text-gray-300">For the sake of concreteness, we will only consider a particular trace-2 elliptic curve from [38] in this paper. Elliptic curves with embedding degree one and having trace different from 2 can be generated using the complex multiplication method [14, 33].</p>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime of the form</p>

    <div class="my-4 text-center"><span class="math-block">p = A^2 + 1, \\text{ where } A \\equiv 2 \\pmod{4}; \\tag{4}</span></div>

    <p class="text-gray-300">note that <span class="math">p \\equiv 1 \\pmod{4}</span>. Suppose also that <span class="math">A = hn</span> where <span class="math">n \\equiv 3 \\pmod{4}</span> is prime. We assume that <span class="math">p</span> does not have any special properties such as having a sparse binary representation. This is done in order to ensure that the discrete logarithm problem in <span class="math">\\mathbb{F}_p</span> does not succumb to variants of the special number field sieve [44]. Then, assuming that the NFS cannot exploit the property of <span class="math">p - 1</span> being a perfect square (cf. §3.3), the fastest algorithm known for computing discrete logarithms in <span class="math">\\mathbb{F}_p</span> has running time <span class="math">L_p[\\frac{1}{3}, \\left(\\frac{64}{9}\\right)^{1/3}]</span>.</p>

    <p class="text-gray-300">Consider the elliptic curve</p>

    <div class="my-4 text-center"><span class="math-block">E: Y^2 = X^3 - 4X \\text{ over } \\mathbb{F}_p. \\tag{5}</span></div>

    <p class="text-gray-300">Then, as shown in [38], <span class="math">\\#E(\\mathbb{F}_p) = p - 1</span> so <span class="math">E</span> is an ordinary curve with trace 2. Furthermore, <span class="math">E(\\mathbb{F}_p) \\cong \\mathbb{Z}_A \\oplus \\mathbb{Z}_A</span> so <span class="math">E[n] \\subseteq E(\\mathbb{F}_p)</span> and <span class="math">E(\\mathbb{F}_p)</span> has embedding degree <span class="math">k = 1</span> with respect to <span class="math">n</span>. The endomorphism ring of <span class="math">E</span> is <span class="math">\\mathbb{Z}[i]</span>, the complex number <span class="math">i</span> being identified with the degree-one endomorphism <span class="math">\\psi</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\psi : (x, y) \\mapsto (-x, A y). \\tag{6}</span></div>

    <p class="text-gray-300">The map <span class="math">\\psi</span> is a distortion map on <span class="math">E[n]</span>. In other words, if <span class="math">P \\in E[n] \\setminus \\{\\infty\\}</span> then <span class="math">\\psi(P) \\notin \\langle P \\rangle</span>. Thus, for any <span class="math">P \\in E[n] \\setminus \\{\\infty\\}</span>, the pair of points <span class="math">(P, \\psi(P))</span> generate <span class="math">E[n]</span>. The <span class="math">p</span>-th power Frobenius <span class="math">\\pi</span> satisfies <span class="math">\\pi(P) = (1 + Ai)P</span> for all <span class="math">P \\in E(\\overline{\\mathbb{F}}_p)</span>.</p>

    <p class="text-gray-300"><span class="math">^1</span>When we say that “hashing onto a group is not known to be efficient” we mean in such a way that discrete logarithms of hash values are difficult to compute.</p>

    <p class="text-gray-300"><span class="math">^2</span>If <span class="math">n \\equiv 1 \\pmod{4}</span>, then <span class="math">\\psi</span> is a distortion map for all but two of the <span class="math">n + 1</span> order-<span class="math">n</span> subgroups of <span class="math">E[n]</span>. These two exceptions were overlooked in Theorem 3 of [38].</p>

    <p class="text-gray-300">The existence of an efficiently-computable distortion map on <span class="math">E[n]</span> means that the decisional Diffie-Hellman (DDH) problem in any order-<span class="math">n</span> subgroup of <span class="math">E[n]</span> is easy. Recall that the DDH problem in an order-<span class="math">n</span> group <span class="math">\\langle P\\rangle</span> is the following: given <span class="math">P</span>, <span class="math">A=aP</span>, <span class="math">B=bP</span> and <span class="math">Q</span>, where <span class="math">a,b\\in_{R}[0,n-1]</span> and either <span class="math">Q=abP</span> or <span class="math">Q=cP</span> for <span class="math">c\\in_{R}[0,n-1]</span>, decide whether or not <span class="math">Q=abP</span>. The Weil pairing can be used to solve DDH efficiently since if <span class="math">Q=abP</span> then <span class="math">w_{n}(P,Q)=w_{n}(A,B)</span>, whereas if <span class="math">Q=cP</span> then <span class="math">w_{n}(P,Q)\\neq w_{n}(A,B)</span> with overwhelming probability.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.1. Subgroup membership testing</h3>

    <p class="text-gray-300">Let <span class="math">P,Q\\in E[n]\\setminus\\{\\infty\\}</span>. In cryptographic protocols it is usually necessary to have an efficient method for testing whether <span class="math">Q\\in\\langle P\\rangle</span>. The alternation and non-degeneracy properties of the Weil pairing imply that <span class="math">Q\\in\\langle P\\rangle</span> if and only if <span class="math">w_{n}(P,Q)=1</span>. Thus, subgroup membership testing can be done using the Weil pairing.</p>

    <p class="text-gray-300">Subgroup membership testing cannot in general be done in the same manner using the Tate pairing. Indeed, it is no longer guaranteed that <span class="math">t_{n}(P,P)=1</span>. The following result was stated in Remark 2 of <em>[33]</em>. We include a self-contained proof for completeness.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be the trace-2 elliptic curve defined in (5). Then <span class="math">t_{n}(P,\\psi(P))=1</span> for all <span class="math">P\\in E[n]</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">P\\in E[n]\\setminus\\{\\infty\\}</span>. By Theorem X.1.1 of <em>[50]</em>, we have <span class="math">w_{n}(\\pi(Q)-Q,iP)=\\beta^{p-1}</span>, where <span class="math">Q\\in E(\\overline{\\mathbb{F}}_{p})</span> with <span class="math">nQ=P</span>, and <span class="math">\\beta\\in\\overline{\\mathbb{F}}_{p}</span> with <span class="math">\\beta^{n}=\\hat{t}_{n}(iP,P)</span> where <span class="math">\\hat{t}_{n}</span> is the unreduced Tate pairing. Now, <span class="math">\\beta^{p-1}=(\\beta^{n})^{(p-1)/n}=\\hat{t}_{n}(iP,P)^{(p-1)/n}=t_{n}(iP,P)</span>. And, <span class="math">\\pi(Q)-Q=(1+Ai)Q-Q=hniQ=hiP</span>. Thus, <span class="math">t_{n}(iP,P)=w_{n}(hiP,iP)=w_{n}(iP,iP)^{h}=1</span>.</p>

    <p class="text-gray-300">Now, the dual of the endomorphism <span class="math">i</span> is <span class="math">-i</span>. Hence, by part 3 of Theorem IX.9 of <em>[24]</em>, we have <span class="math">1=t_{n}(iP,P)=t_{n}(P,-iP)=t_{n}(P,iP)^{-1}</span>, whence <span class="math">t_{n}(P,iP)=t_{n}(P,\\psi(P))=1</span>. ∎</p>

    <p class="text-gray-300">Non-degeneracy of the Tate pairing immediately gives the following result which yields a method for subgroup membership testing using the Tate pairing.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be the trace-2 elliptic curve defined in (5). Let <span class="math">P,Q\\in E[n]\\setminus\\{\\infty\\}</span>. Then <span class="math">Q\\in\\langle P\\rangle</span> if and only if <span class="math">t_{n}(P,\\psi(Q))=1</span>.</p>

    <p class="text-gray-300">Non-degeneracy of the Tate pairing also gives the following result.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be the trace-2 elliptic curve defined in (5). Then <span class="math">t_{n}(P,P)\\neq 1</span> for all <span class="math">P\\in E[n]\\setminus\\{\\infty\\}</span>.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.2. Pairings</h3>

    <p class="text-gray-300">For the trace-2 elliptic curve <span class="math">E</span> defined in (5), there are no analogues to <span class="math">\\mathbb{G}_{1}</span> and the Trace-0 group <span class="math">\\mathbb{G}_{2}</span> in the case of Type 2 and Type 3 pairings (see §2.3). Indeed, there is no natural way of distinguishing any order-<span class="math">n</span> subgroup of <span class="math">E[n]</span> from the other order-<span class="math">n</span> subgroups.</p>

    <p class="text-gray-300">There are several types of pairings on order-<span class="math">n</span> groups that can be defined from the Weil pairing (1) and the Tate pairing (3). We present three kinds of pairings, called Type A, Type B and Type C, and discuss their properties in §§4-6. In all these pairings, <span class="math">\\mathbb{G}_{T}</span> denotes the order-<span class="math">n</span> subgroup of <span class="math">\\mathbb{F}_{p}^{*}</span>. Type A pairings are bilinear pairings from <span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{1}</span> to <span class="math">\\mathbb{G}_{T}</span>, where <span class="math">\\mathbb{G}_{1}</span> is an arbitrary order-<span class="math">n</span> subgroup of <span class="math">E(\\mathbb{F}_{p})</span>. Type B pairings are bilinear pairings from</p>

    <p class="text-gray-300"><span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span> to <span class="math">\\mathbb{G}_{T}</span>, where <span class="math">\\mathbb{G}_{1}</span> is an arbitrary order-<span class="math">n</span> subgroup of <span class="math">E(\\mathbb{F}_{p})</span> and <span class="math">\\mathbb{G}_{2}=E[n]</span>. Type C pairings are bilinear pairings from <span class="math">\\mathbb{G}_{2}\\times\\mathbb{G}_{2}</span> to <span class="math">\\mathbb{G}_{T}</span>, where <span class="math">\\mathbb{G}_{2}=E[n]</span>. Note that no efficient method is known for efficiently and reversibly embedding binary strings from <span class="math">\\{0,1\\}^{m}</span> (for some <span class="math">m</span>) in <span class="math">\\mathbb{G}_{T}</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.3. Applicability of the SNFS</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">d&gt;1</span> and <span class="math">m=\\lfloor p^{1/d}\\rfloor</span>. Suppose also that <span class="math">p&gt;2^{d^{2}}</span>. Let <span class="math">f(t)=t^{d}+f_{d-1}t^{d-1}+\\cdots+f_{1}t+f_{0}\\in\\mathbb{Z}[t]</span>, where <span class="math">m^{d}+\\sum_{i=0}^{d-1}f_{i}m^{i}</span> is the base-<span class="math">m</span> representation of <span class="math">p</span>. Then <span class="math">f</span> is irreducible over <span class="math">\\mathbb{Z}</span> and <span class="math">f(m)=p\\equiv 0\\pmod{p}</span>. Let <span class="math">\\alpha\\in\\mathbb{C}</span> be a root of <span class="math">f</span>. The NFS for computing discrete logarithms in <span class="math">\\mathbb{F}_{p}</span> <em>[28, 43]</em> seeks to find pairs of integers <span class="math">(a,b)</span> with <span class="math">0\\leq b&lt;B</span> and $0\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><B$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">T=(a-bm)\\cdot b^{d}f(a/b)=(a-bm)(a^{d}+f_{t-1}a^{t-1}b+\\cdots+f_{1}ab^{t-1}+f_{0}b^{t})</span></p>

    <p class="text-gray-300">is smooth. Note that <span class="math">T\\approx(d+1)B^{d+1}p^{2/d}</span>. The optimal choices for <span class="math">B</span> and <span class="math">d</span> yield an algorithm with running time <span class="math">L_{p}[\\frac{1}{3},\\left(\\frac{64}{9}\\right)^{1/3}]</span>.</p>

    <p class="text-gray-300">In the special NFS (SNFS), <span class="math">p</span> has a special form, e.g., <span class="math">p=r^{e}\\pm s</span> with small <span class="math">r</span> and <span class="math">s</span>. The special form of <span class="math">p</span> yields a monic irreducible polynomial <span class="math">f</span> with small coefficients. Consequently, the bound on <span class="math">T</span> becomes <span class="math">T\\approx(d+1)B^{d+1}p^{1/d}</span>, resulting in an algorithm with a significantly faster running time <span class="math">L_{p}[\\frac{1}{3},\\left(\\frac{32}{9}\\right)^{1/3}]</span>.</p>

    <p class="text-gray-300">For the case <span class="math">p=A^{2}+1</span>, one could take <span class="math">d=2</span> and <span class="math">f(t)=t^{2}+1</span>. But then <span class="math">T\\approx 3B^{3}p^{1/2}</span>, which is too large to be effective. A second strategy to exploit the structure of <span class="math">p</span> is to let <span class="math">m=\\lfloor A^{1/d}\\rfloor</span> and <span class="math">g(t)=t^{d}+g_{d-1}t^{d-1}+\\cdots+g_{1}t+g_{0}</span>, where <span class="math">m^{d}+\\sum_{i=0}^{d-1}g_{i}m^{i}</span> is the base-<span class="math">m</span> representation of <span class="math">A</span>. Then, one can take <span class="math">f(t)=g^{2}(t)+1</span> and hope that <span class="math">f</span> is irreducible over <span class="math">\\mathbb{Z}</span>; note that <span class="math">f(m)=p</span> and <span class="math">\\deg(f)=2d</span>. However, the coefficients <span class="math">f_{i}</span> of <span class="math">f</span> satisfy <span class="math">f_{i}\\approx m^{2}</span>. Indeed, by taking <span class="math">\\tilde{m}=\\lfloor p^{1/2d}\\rfloor\\approx\\lfloor A^{1/d}\\rfloor</span>, one could have used the method in the original NFS to obtain a degree-<span class="math">2d</span> irreducible polynomial <span class="math">\\tilde{f}</span> with <span class="math">\\tilde{f}(\\tilde{m})=p</span> and coefficients <span class="math">\\tilde{f}_{i}\\approx\\tilde{m}</span>. Thus, this second strategy also fails.</p>

    <p class="text-gray-300">An outstanding open problem is to determine whether the special structure of <span class="math">p=A^{2}+1</span> can be exploited to devise an algorithm for computing discrete logarithms in <span class="math">\\mathbb{F}_{p}</span> that has running time significantly smaller than <span class="math">L_{p}[\\frac{1}{3},\\left(\\frac{64}{9}\\right)^{1/3}]</span>. If this can be accomplished, then the keylength and efficiency estimates in §7 will have to be revised accordingly.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4. Type A pairings</h2>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.1. The pairings</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}_{1}</span> be an arbitrary order-<span class="math">n</span> subgroup of <span class="math">E(\\mathbb{F}_{p})</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">The Type A Weil pairing <span class="math">w_{A}:\\mathbb{G}_{1}\\times\\mathbb{G}_{1}\\to\\mathbb{G}_{T}</span> is</p>

    <p class="text-gray-300">(7) <span class="math">w_{A}(P,Q)=w_{n}(P,\\psi(Q))=(-1)^{n}\\frac{f_{n,P}(\\psi(Q))}{f_{n,\\psi(Q)}(P)},</span></p>

    <p class="text-gray-300">where <span class="math">P,Q\\neq\\infty</span> and <span class="math">f_{n,P}</span> and <span class="math">f_{n,\\psi(Q)}</span> are normalized Miller functions. Furthermore, <span class="math">w_{A}(P,\\infty)=w_{A}(\\infty,P)=1</span> for all <span class="math">P\\in\\mathbb{G}_{1}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">The pairing <span class="math">w_{A}</span> is non-degenerate since <span class="math">\\psi(Q)\\not\\in\\langle P\\rangle</span>. Note that the Miller function computations in (7) never fail since <span class="math">\\psi(Q)\\not\\in\\langle P\\rangle</span> and <span class="math">P\\not\\in\\langle\\psi(Q)\\rangle</span>.</p>

    <p class="text-gray-300">Since <span class="math">t_{n}(P,P)\\neq 1</span>, the Tate pairing restricted to <span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{1}</span> is a non-degenerate pairing. However, as mentioned in Remark 2, the Miller function computation when computing <span class="math">t_{n}(P,Q)</span> using (3) can fail since <span class="math">Q\\in\\langle P\\rangle</span>. To circumvent this possible failure, we select <span class="math">R=\\psi(P)</span> in (2). Then, since <span class="math">f_{n,P}(\\psi(P))^{(p-1)/n}=1</span> when <span class="math">f_{n,P}</span> is normalized, we obtain the following Type A Tate pairing.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">The Type A Tate pairing <span class="math">t_{A}:\\mathbb{G}_{1}\\times\\mathbb{G}_{1}\\to\\mathbb{G}_{T}</span> is</p>

    <p class="text-gray-300">(8) <span class="math">t_{A}(P,Q)=\\left(f_{n,P}(Q+\\psi(P))\\right)^{(p-1)/n},</span></p>

    <p class="text-gray-300">where <span class="math">f_{n,P}</span> is normalized.</p>

    <p class="text-gray-300">The Type A pairings <span class="math">w_{A}</span> and <span class="math">t_{A}</span> are symmetric in the sense that they are defined on <span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{1}</span> where <span class="math">\\mathbb{G}_{1}</span> is a cyclic group of order <span class="math">n</span>. However, these pairings differ from Type 1 symmetric pairings in that no efficient method is known for hashing onto <span class="math">\\mathbb{G}_{1}</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">4.2. Protocols</h3>

    <p class="text-gray-300">Let <span class="math">e_{A}:\\mathbb{G}_{1}\\times\\mathbb{G}_{1}\\to\\mathbb{G}_{T}</span> denote the Type A Weil pairing <span class="math">w_{A}</span> or the Type A Tate pairing <span class="math">t_{A}</span>. The Type A pairing setting provides a protocol designer the same capabilities as in the Type 1 setting provided there is no need of hashing onto <span class="math">\\mathbb{G}_{1}</span> (also known as a map-to-point function). Recall that such a hash function is usually modelled as a random oracle in the security reduction. Hence, all protocols that are originally described in the Type 1 setting and do not require the random oracle assumption for such a map-to-point function can be instantiated in the Type A setting.</p>

    <p class="text-gray-300">Examples of protocols that can be implemented in the Type A setting include Joux’s three-party key agreement scheme <em>[34]</em> and Waters’ IBE and signature schemes <em>[53]</em>. More generally, all so-called standard model protocols in the Type 1 setting can be implemented in the Type A setting without any difficulty. Note that it is straightforward to cast the corresponding hardness assumptions and security theorems and proofs in the Type A setting. For example, the bilinear Diffie-Hellman problem in the Type A setting and its decisional version can be defined as follows.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 5 (BDH-A).</h6>

    <p class="text-gray-300">Bilinear Diffie-Hellman problem in <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{T})</span>: Given <span class="math">P</span>, <span class="math">aP</span>, <span class="math">bP</span>, <span class="math">cP\\in\\mathbb{G}_{1}</span>, where <span class="math">a,b,c\\in_{R}[1,n-1]</span>, compute <span class="math">e_{A}(P,P)^{abc}</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 6 (DBDH-A).</h6>

    <p class="text-gray-300">Decisional Bilinear Diffie-Hellman problem in <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{T})</span>: Given <span class="math">P,aP,bP,cP\\in\\mathbb{G}_{1}</span>, where <span class="math">a,b,c\\in_{R}[1,n-1]</span> and <span class="math">Z\\in\\mathbb{G}_{T}</span>, decide whether <span class="math">Z=e_{A}(P,P)^{abc}</span> or <span class="math">Z</span> is a random element in <span class="math">\\mathbb{G}_{T}</span>.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">4.2.1. BLS-1 signature scheme</h4>

    <p class="text-gray-300">To illustrate the problem of implementing protocols that employ a map-to-point function onto <span class="math">\\mathbb{G}_{1}</span>, we recall the Boneh-Lynn-Shacham (BLS) signature scheme <em>[13]</em> in the Type 1 setting.</p>

    <p class="text-gray-300">Let <span class="math">e_{1}:\\mathbb{G}_{1}\\times\\mathbb{G}_{1}\\to\\mathbb{G}_{T}</span> be a Type 1 pairing where <span class="math">\\mathbb{G}_{1}=\\langle P\\rangle</span>. Let <span class="math">H:\\{0,1\\}^{*}\\to\\mathbb{G}_{1}</span> be a hash function. The public parameters are <span class="math">e_{1}</span>, <span class="math">P</span> and <span class="math">H</span></p>

    <p class="text-gray-300">ice’s private key is an integer <span class="math">a\\in_{R}[1,n-1]</span>, while her public key is <span class="math">A=aP</span>. To sign a message <span class="math">m\\in\\{0,1\\}^{*}</span>, Alice computes <span class="math">M=H(m)</span> and <span class="math">\\sigma=aM</span>. Her signature on <span class="math">m</span> is <span class="math">\\sigma</span>. To verify the signed message <span class="math">(m,\\sigma)</span>, Bob computes <span class="math">M=H(m)</span>, verifies that <span class="math">\\sigma\\in\\langle\\mathbb{G}_{1}\\rangle</span>, and accepts if and only if <span class="math">e_{1}(P,\\sigma)=e_{1}(A,M)</span>.</p>

    <p class="text-gray-300">Observe that the BLS signature scheme <em>cannot</em> be instantiated in the Type A setting simply because there is no known efficient method for hashing onto <span class="math">\\mathbb{G}_{1}</span>. A similar obstruction is present for several other protocols including the original Boneh-Franklin IBE scheme <em>[11]</em>.</p>

    <h2 id="sec-25" class="text-2xl font-bold">5. Type B pairings</h2>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.1. The pairings</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}_{1}</span> be an arbitrary order-<span class="math">n</span> subgroup of <span class="math">E(\\mathbb{F}_{p})</span> and let <span class="math">\\mathbb{G}_{2}=E[n]</span>. Then we have the following restriction of the Weil or Tate pairings:</p>

    <p class="text-gray-300">(9) <span class="math">e_{B}:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}.</span></p>

    <p class="text-gray-300">We can now hash to <span class="math">\\mathbb{G}_{2}</span> — by hashing to a random point in <span class="math">E(\\mathbb{F}_{p})</span> and then multiplying the resulting point by the cofactor <span class="math">A/n=h</span>. However, as before, we cannot hash to any particular order-<span class="math">n</span> subgroup of <span class="math">\\mathbb{G}_{2}</span>. We will henceforth assume that the group <span class="math">\\mathbb{G}_{1}</span> is the same as the one in the definition of <span class="math">e_{A}</span>; thus the restriction of <span class="math">e_{B}</span> to <span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{1}</span> is equal to <span class="math">e_{A}</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\mathbb{G}_{2}</span> is not an order-<span class="math">n</span> group, <span class="math">e_{B}</span> is not a Type 1, 2 or 3 pairing. The pairing <span class="math">e_{B}</span> is reminiscent of a Type 4 pairing (see §2.3). However, unlike the case of Type 4 pairings, no efficiently-computable homomorphism is known from <span class="math">\\mathbb{G}_{2}</span> onto <span class="math">\\mathbb{G}_{1}</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">(failure of a Miller function computation) The Type B Weil pairing</p>

    <p class="text-gray-300">(10) <span class="math">w_{B}(P,Q)=(-1)^{n}\\frac{f_{n,P}(Q)}{f_{n,Q}(P)}</span></p>

    <p class="text-gray-300">is degenerate if <span class="math">Q\\in\\langle P\\rangle</span>. Moreover, the computation of (10) can fail when <span class="math">Q\\in\\langle P\\rangle</span> or when <span class="math">P\\in\\langle Q\\rangle</span> (both these conditions are implied by <span class="math">Q\\in\\langle P\\rangle</span>). Thus protocols that use the Type B pairing <span class="math">w_{B}</span> should ensure that <span class="math">Q\\not\\in\\langle P\\rangle</span>, or that this occurs only with negligible probability.</p>

    <p class="text-gray-300">The Type B Tate pairing</p>

    <p class="text-gray-300">(11) <span class="math">t_{B}(P,Q)=(f_{n,P}(Q))^{(p-1)/n}</span></p>

    <p class="text-gray-300">is degenerate if <span class="math">Q\\in\\langle\\psi(P)\\rangle</span>. Moreover, the computation of (11) can fail when <span class="math">Q\\in\\langle P\\rangle</span>. Thus, protocols that use the Type B pairing <span class="math">t_{B}</span> should ensure that <span class="math">Q\\not\\in\\langle P\\rangle</span> and <span class="math">Q\\not\\in\\langle\\psi(P)\\rangle</span>, or that this occurs only with negligible probability.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.2. Protocols</h3>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">5.2.1. BLS-B signature scheme</h4>

    <p class="text-gray-300">Let <span class="math">E</span> be an elliptic curve with embedding degree one, and let <span class="math">e_{B}:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> be a Type B pairing where <span class="math">\\mathbb{G}_{1}=\\langle P\\rangle</span>. Let <span class="math">H:\\{0,1\\}^{*}\\to E[n]</span> be a hash function. The public parameters are <span class="math">E</span>, <span class="math">P</span>, <span class="math">e_{B}</span> and <span class="math">H</span>.</p>

    <p class="text-gray-300">Alice’s private key is an integer <span class="math">a\\in_{R}[1,n-1]</span>, while her public key is <span class="math">A=aP</span>. To sign a message <span class="math">m</span>, Alice computes <span class="math">M=H(m)</span> and <span class="math">\\sigma=aM</span>. Her signature on <span class="math">m</span> is <span class="math">\\sigma</span>. To ver</p>

    <p class="text-gray-300">the signed message <span class="math">(m,\\sigma)</span>, Bob computes <span class="math">M=H(m)</span>, verifies that <span class="math">\\sigma\\in\\langle M\\rangle</span>, and accepts if and only if <span class="math">e_{B}(P,\\sigma)=e_{B}(A,M)</span>.</p>

    <p class="text-gray-300">Correctness of the verification algorithm follows because</p>

    <p class="text-gray-300"><span class="math">e_{B}(P,\\sigma)=e_{B}(P,aM)=e_{B}(aP,M)=e_{B}(A,M).</span></p>

    <p class="text-gray-300">Note that since <span class="math">M</span> is randomly selected from <span class="math">E[n]</span>, the probability that <span class="math">M\\in\\langle A\\rangle</span> or <span class="math">M\\in\\langle\\psi(A)\\rangle</span> is negligible (cf. Remark 3).</p>

    <p class="text-gray-300">Recall that the Diffie-Hellman problem (DHP) in a cyclic group <span class="math">\\mathbb{G}_{1}=\\langle P\\rangle</span> is the following: Given <span class="math">P</span>, <span class="math">A=aP</span> where <span class="math">a\\in_{R}[1,n-1]</span>, and <span class="math">M\\in_{R}\\mathbb{G}_{1}</span>, compute <span class="math">\\sigma=aM</span>. Security of BLS-B can be proven under the assumption that the following variant of DHP is intractable.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">The DHP-B problem is the following: Given <span class="math">P\\in\\mathbb{G}_{1}</span>, <span class="math">A=aP</span> where <span class="math">a\\in_{R}[1,n-1]</span>, and <span class="math">M\\in_{R}E[n]</span>, compute <span class="math">\\sigma=aM</span>.</p>

    <p class="text-gray-300">It is easy to see that DHP polynomial-time reduces to DHP-B. Namely, suppose we are given an instance <span class="math">(P,A,M)</span> of DHP and a DHP-B oracle. We compute <span class="math">Q=\\psi(P)</span> and <span class="math">M^{\\prime}=M+rQ</span> where <span class="math">r\\in_{R}[0,n-1]</span>. We present <span class="math">(P,A,M^{\\prime})</span> to the oracle and obtain <span class="math">\\sigma^{\\prime}=aM^{\\prime}</span>. Since</p>

    <p class="text-gray-300"><span class="math">\\sigma^{\\prime}=aM^{\\prime}=a(M+rQ)=aM+r(aQ)=\\sigma+r\\psi(A),</span></p>

    <p class="text-gray-300">we can efficiently compute the DHP solution <span class="math">\\sigma=\\sigma^{\\prime}-r\\psi(A)</span>.</p>

    <p class="text-gray-300">Security of BLS-B can be proven with respect to intractability of DHP-B. The following result omits the tightness gap in the reduction.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Suppose that the DHP-B problem is intractable and <span class="math">H</span> is a random oracle. Then BLS-B is existentially unforgeable against adaptive chosen-message attacks.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose we are given a DHP-B instance <span class="math">(P,A,M^{<em>})</span> and need to compute <span class="math">\\sigma^{</em>}=aM^{<em>}</span> where <span class="math">A=aP</span>. We compute <span class="math">Q=\\psi(P)</span> and <span class="math">B=\\psi(A)=aQ</span>, where <span class="math">\\psi</span> is the distortion map (6). We then run the forger with input <span class="math">(P,A)</span>. The forger makes queries to a random oracle <span class="math">H</span> and to a signing oracle. We assume that the forger always queries <span class="math">H</span> with a message <span class="math">m</span> before it queries the signing oracle with <span class="math">m</span>. We also assume that the forger queries <span class="math">H</span> with <span class="math">m</span> before producing its forgery <span class="math">(m,\\sigma)</span>. We respond to all but one randomly selected hash query on <span class="math">m</span> with <span class="math">M=H(m)=r_{1}P+r_{2}Q</span> where <span class="math">r_{1},r_{2}\\in_{R}[0,n-1]</span>; note that <span class="math">M</span> is indeed distributed uniformly at random in <span class="math">E[n]</span>, so the response to the hash query is valid. For the randomly selected hash query <span class="math">m^{</em>}</span>, we respond with <span class="math">H(m^{<em>})=M^{</em>}</span>. We respond to signing queries on messages <span class="math">m\\neq m^{*}</span> with <span class="math">\\sigma=r_{1}A+r_{2}B</span>. This is a valid signature since</p>

    <p class="text-gray-300"><span class="math">\\sigma=r_{1}A+r_{2}B=r_{1}(aP)+r_{2}(aQ)=a(r_{1}P+r_{2}Q)=aH(m)=aM.</span></p>

    <p class="text-gray-300">If the forger asks for the signature on <span class="math">m^{<em>}</span>, we abort. We also abort if the forger does not output a valid signature on <span class="math">m^{</em>}</span>. Otherwise, if the forger outputs a valid signed message <span class="math">(m^{<em>},\\sigma^{</em>})</span>, then <span class="math">\\sigma^{<em>}</span> is the solution to the DHP-B challenge <span class="math">(P,A,M^{</em>})</span>. ∎</p>

    <p class="text-gray-300">Note that in the Type B setting we can hash onto <span class="math">E[n]</span> but not onto <span class="math">\\mathbb{G}_{1}</span>. Hence, protocols that require a map-to-point function such that at most one argument of the pairing function</p>

    <p class="text-gray-300">is expressed in terms of such a point can be instantiated in the Type B pairing setting. Apart from the BLS signature scheme, some other prominent examples are the Boneh-Franklin IBE scheme <em>[11]</em> and the Boneh-Gentry-Lynn-Shacham aggregate signature scheme <em>[12]</em>. Note also that the protocols that can be instantiated in the Type A setting can be instantiated in the Type B setting without any difficulty.</p>

    <p class="text-gray-300">The main difference between the Type A and the Type B settings is that <span class="math">E[n]</span> is not a cyclic group of prime order. This necessitates an appropriate modification in the underlying hardness assumption as well as the protocol description and its security reduction. We have already illustrated this in the context of the BLS signature scheme. Next we briefly describe the bilinear Diffie-Hellman (BDH) problem in the Type B setting and its relation with the corresponding problem in the Type A setting.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">5.2.2. BDH problem in Types A and B</h4>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 8 (BDH-B).</h6>

    <p class="text-gray-300">Bilinear Diffie-Hellman problem in <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T})</span>: Given <span class="math">P</span>, <span class="math">aP</span>, <span class="math">bP\\in\\mathbb{G}_{1}</span>, where <span class="math">a,\\ b\\ \\in_{R}\\ [1,n-1]</span>, and <span class="math">R\\in_{R}\\mathbb{G}_{2}</span>, compute <span class="math">e_{B}(P,R)^{ab}</span>.</p>

    <p class="text-gray-300">It is easy to see that the BDH problem in the Type A setting (BDH-A) polynomial-time reduces to BDH-B. Namely, suppose we are given an instance <span class="math">(P,aP,bP,cP)</span> of BDH-A and access to a BDH-B oracle. We compute <span class="math">Q=\\psi(P)</span> and <span class="math">B=\\psi(bP)=bQ</span>. We further compute <span class="math">R=cP+rQ</span> where <span class="math">r\\in_{R}[1,n-1]</span>. We run the BDH-B oracle with input <span class="math">(P,aP,bP,R)</span>. The oracle returns <span class="math">e_{B}(P,R)^{ab}=e_{A}(P,P)^{abc}e_{B}(aP,bQ)^{r}</span> from which one can easily extract the BDH-A solution, namely <span class="math">e_{A}(P,P)^{abc}</span>.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">5.2.3. Sakai-Oghishi-Kasahara id-based key agreement</h4>

    <p class="text-gray-300">We recall the Sakai-Oghishi-Kasahara id-based Non-Interactive Key Agreement (SOK-NIKA) scheme in the Type 1 setting <em>[42]</em>.</p>

    <p class="text-gray-300">Let <span class="math">e_{1}:\\mathbb{G}_{1}\\times\\mathbb{G}_{1}\\to\\mathbb{G}_{T}</span> be a Type 1 pairing where <span class="math">\\mathbb{G}_{1}=\\langle P\\rangle</span>. Let <span class="math">H:\\{0,1\\}^{*}\\to\\mathbb{G}_{1}</span> be a hash function. The key generation center (KGC) chooses her master secret <span class="math">s\\in_{R}[1,n-1]</span> and the corresponding public parameters are <span class="math">e_{1}</span>, <span class="math">P</span>, <span class="math">sP</span> and <span class="math">H</span>.</p>

    <p class="text-gray-300">An entity with identity <span class="math">\\mathsf{id}</span> obtains her corresponding private key from the KGC as <span class="math">d_{\\mathsf{id}}=sQ_{\\mathsf{id}}</span> where <span class="math">Q_{\\mathsf{id}}=H(\\mathsf{id})</span>. Two parties having identities respectively <span class="math">\\mathsf{id}</span> and <span class="math">\\mathsf{id}^{\\prime}</span> can compute a shared secret without any interaction as follows. The party with identity <span class="math">\\mathsf{id}</span> computes <span class="math">K=e_{1}(d_{\\mathsf{id}},H(\\mathsf{id}^{\\prime}))</span>, whereas the party with identity <span class="math">\\mathsf{id}^{\\prime}</span> computes <span class="math">K^{\\prime}=e_{1}(d_{\\mathsf{id}^{\\prime}},H(\\mathsf{id}))</span>. Both parties compute the same shared secret because</p>

    <p class="text-gray-300"><span class="math">K=e_{1}(d_{\\mathsf{id}},H(\\mathsf{id}^{\\prime}))=e_{1}(sQ_{\\mathsf{id}},Q_{\\mathsf{id}^{\\prime}})=e_{1}(Q_{\\mathsf{id}},sQ_{\\mathsf{id}^{\\prime}})=e_{1}(H(\\mathsf{id}),d_{\\mathsf{id}^{\\prime}})=e_{1}(d_{\\mathsf{id}^{\\prime}},H(\\mathsf{id}))=K^{\\prime}.</span></p>

    <p class="text-gray-300">Note that SOK-NIKA cannot be implemented in the Type B (or Type A) setting because there is no known way to hash onto a fixed order-<span class="math">n</span> group <span class="math">\\mathbb{G}_{1}</span>.</p>

    <h2 id="sec-36" class="text-2xl font-bold">6. Type C pairings</h2>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">6.1. The pairings</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}_{2}=E[n]</span>. Then the full Weil and Tate pairings defined in (1) and (3) are bilinear pairings from <span class="math">\\mathbb{G}_{2}\\times\\mathbb{G}_{2}</span> to <span class="math">\\mathbb{G}_{T}</span>. We say that these pairings are of Type C and denote them by <span class="math">e_{C}</span>. Note that one can efficiently hash onto <span class="math">\\mathbb{G}_{2}</span>. Hence, protocols that require a map-to-point function for either of the two arguments of the pairing function can</p>

    <p class="text-gray-300">be considered for implementation with Type C pairings. For any fixed order-<span class="math">n</span> subgroup <span class="math">\\mathbb{G}_{1}</span>, the restriction of <span class="math">e_{C}</span> to <span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{1}</span> gives the Type A pairing <span class="math">e_{A}</span>. Similarly, the restriction of <span class="math">e_{C}</span> to <span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span> gives the Type B pairing <span class="math">e_{B}</span>.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">6.2. Protocols</h3>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">6.2.1. Sakai-Oghishi-Kasahara id-based key agreement in Type C</h4>

    <p class="text-gray-300">Let <span class="math">e_{C}:\\mathbb{G}_{2}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> be a Type C pairing, and let <span class="math">P\\in\\mathbb{G}_{2}</span>. Let <span class="math">H:\\{0,1\\}^{*}\\to\\mathbb{G}_{2}</span> be a hash function. The key generation center (KGC) chooses her master secret <span class="math">s\\in_{R}[1,n-1]</span> and the corresponding public parameters are <span class="math">e_{C}</span>, <span class="math">P</span>, <span class="math">sP</span> and <span class="math">H</span>.</p>

    <p class="text-gray-300">An entity with identity <span class="math">\\mathsf{id}</span> obtains her corresponding private key from the KGC as <span class="math">d_{\\mathsf{id}}=sQ_{\\mathsf{id}}</span> where <span class="math">Q_{\\mathsf{id}}=H(\\mathsf{id})</span>. Two parties having identities respectively <span class="math">\\mathsf{id}</span> and <span class="math">\\mathsf{id}^{\\prime}</span> can compute a shared secret without any interaction as follows. Suppose that <span class="math">\\mathsf{id}</span> is lexicographically smaller than <span class="math">\\mathsf{id}^{\\prime}</span>. The party with identity <span class="math">\\mathsf{id}</span> computes <span class="math">K=e_{C}(d_{\\mathsf{id}},H(\\mathsf{id}^{\\prime}))</span>, whereas the party with identity <span class="math">\\mathsf{id}^{\\prime}</span> computes <span class="math">K^{\\prime}=e_{C}(H(\\mathsf{id}),d_{\\mathsf{id}^{\\prime}})</span>. Both parties compute the same shared secret because</p>

    <p class="text-gray-300"><span class="math">K=e_{C}(d_{\\mathsf{id}},H(\\mathsf{id}^{\\prime}))=e_{C}(sQ_{\\mathsf{id}},Q_{\\mathsf{id}^{\\prime}})=e_{C}(Q_{\\mathsf{id}},sQ_{\\mathsf{id}^{\\prime}})=e_{C}(H(\\mathsf{id}),d_{\\mathsf{id}^{\\prime}})=K^{\\prime}.</span></p>

    <p class="text-gray-300">A Key Derivation Function (KDF) <span class="math">\\tilde{H}:\\mathbb{G}_{T}\\to\\{0,1\\}^{k}</span> can be applied to the shared secret to produce a <span class="math">k</span>-bit secret key.</p>

    <p class="text-gray-300">In the Type 1 pairing setting it has been shown <em>[23, 40]</em> that when <span class="math">H</span> and <span class="math">\\tilde{H}</span> are modeled as random oracles, the security of SOK-NIKA is based on the hardness of BDH in the Type 1 setting. The original security argument can be easily modified for the above variant whence the security depends on the following version of the BDH problem in the Type C setting.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 9 (BDH-C).</h6>

    <p class="text-gray-300">Bilinear Diffie-Hellman problem in <span class="math">(\\mathbb{G}_{2},\\mathbb{G}_{T})</span>: Given <span class="math">P\\in\\mathbb{G}_{2}</span>, <span class="math">Q=aP</span> where <span class="math">a\\in_{R}[1,n-1]</span>, and <span class="math">R,S\\in_{R}\\mathbb{G}_{2}</span>, compute <span class="math">e_{C}(R,S)^{a}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\tilde{H}</span> is not included in the protocol description, then one can argue the security of SOK-NIKA based on the following version of the decisional Bilinear Diffie-Hellman problem in the Type C setting.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 10 (DBDH-C).</h6>

    <p class="text-gray-300">Decisional Bilinear Diffie-Hellman problem in <span class="math">(\\mathbb{G}_{2},\\mathbb{G}_{T})</span>: Given <span class="math">P\\in\\mathbb{G}_{2}</span>, <span class="math">Q=aP</span> where <span class="math">a\\in_{R}[1,n-1]</span>, <span class="math">R,S\\in_{R}\\mathbb{G}_{2}</span>, and <span class="math">Z\\in\\mathbb{G}_{T}</span>, decide whether <span class="math">Z=e_{C}(R,S)^{a}</span> or <span class="math">Z</span> is a random element in <span class="math">\\mathbb{G}_{T}</span>.</p>

    <p class="text-gray-300">As in the case of variants of the BDH problem, it is easy to see that DBDH-A polynomial-time reduces to DBDH-C. Namely, suppose we are given an instance <span class="math">(P,aP,bP,cP,Z)</span> of DBDH-A and access to a DBDH-C oracle. We compute <span class="math">Q=\\psi(P)</span>, <span class="math">A=\\psi(aP)=aQ</span>, <span class="math">B=\\psi(bP)=bQ</span>, and <span class="math">C=\\psi(cP)=cQ</span>. We further compute <span class="math">R=bP+rQ</span> and <span class="math">S=cP+sQ</span> where <span class="math">r,s\\in_{R}[1,n-1]</span> and <span class="math">Z^{\\prime}=Z\\cdot e_{C}(bP,aQ)^{s}\\cdot e_{C}(aQ,cP)^{r}\\cdot e_{C}(aQ,Q)^{rs}</span>. We run the DBDH-C oracle with input <span class="math">(P,aP,R,S,Z^{\\prime})</span> and return whatever bit the oracle returns. Clearly, when <span class="math">Z=e_{A}(P,P)^{abc}</span> then <span class="math">Z^{\\prime}=e_{C}(R,S)^{a}</span>. On the other hand, if <span class="math">Z</span> is a random element of <span class="math">\\mathbb{G}_{T}</span> then so is <span class="math">Z^{\\prime}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">In the proof sketch below for the security of SOK-NIKA, we follow the IND-SK security model proposed in <em>[40]</em>. In this model the adversary is allowed to make <span class="math">H</span>-oracle queries, key extraction queries on identities of its choice, shared key reveal queries on any pair of identities of its choice, and a challenge (Test) query on a pair of identities subject to the natural restriction that no key extraction query is made on the challenge identities, nor is there any shared-key reveal query on the pair of challenge identities. In response to the challenge query the adversary is given with equal probability either the shared key of the two challenge identities or a random element from the key space. IND-SK security is achieved if the adversary cannot distinguish between the two with probability significantly greater than <span class="math">\\frac{1}{2}</span>. The following result omits the tightness gap in the reduction.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Suppose that the DBDH-C problem is intractable and <span class="math">H</span> is a random oracle. Then SOK-NIKA is a secure key-agreement scheme in the IND-SK model.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose we are given a DBDH-C instance <span class="math">(P,A=aP,R,S,Z)</span> and need to decide whether <span class="math">Z=e_{C}(R,S)^{a}</span> or <span class="math">Z</span> is random. We compute <span class="math">Q=\\psi(P)</span> and <span class="math">B=\\psi(A)=aQ</span>, where <span class="math">\\psi</span> is the distortion map (6). We then run the IND-SK adversary against SOK-NIKA with input <span class="math">(P,A)</span>. The adversary makes queries to a random oracle <span class="math">H</span> as well as key extraction and shared-key reveal queries. We assume that the adversary always queries <span class="math">H</span> with <span class="math">\\mathsf{id}</span> before it queries for key-extraction or shared-key involving that identity. We respond to all but two randomly selected hash queries on <span class="math">\\mathsf{id}</span> with <span class="math">Q_{\\mathsf{id}}=H(\\mathsf{id})=r_{1}P+r_{2}Q</span> where <span class="math">r_{1},r_{2}\\in_{R}[0,n-1]</span>; note that <span class="math">Q_{\\mathsf{id}}</span> is indeed distributed uniformly at random in <span class="math">\\mathbb{G}_{2}</span>, so the response to the hash query is valid. For the randomly selected hash query <span class="math">\\mathsf{id}_{1}^{<em>}</span> and <span class="math">\\mathsf{id}_{2}^{</em>}</span>, we respond with <span class="math">H(\\mathsf{id}_{1}^{<em>})=R</span> and <span class="math">H(\\mathsf{id}_{2}^{</em>})=S</span>. We respond to key-extraction queries on identity <span class="math">\\mathsf{id}\\notin\\{\\mathsf{id}_{1}^{<em>},\\mathsf{id}_{2}^{</em>}\\}</span> with <span class="math">d_{\\mathsf{id}}=r_{1}A+r_{2}B</span>. This is a valid private key for <span class="math">\\mathsf{id}</span> since</p>

    <p class="text-gray-300"><span class="math">d_{\\mathsf{id}}=r_{1}A+r_{2}B=r_{1}(aP)+r_{2}(aQ)=a(r_{1}P+r_{2}Q)=aH(\\mathsf{id})=aQ_{\\mathsf{id}}.</span></p>

    <p class="text-gray-300">We abort if <span class="math">\\mathsf{id}\\in\\{\\mathsf{id}_{1}^{<em>},\\mathsf{id}_{2}^{</em>}\\}</span>.</p>

    <p class="text-gray-300">Next, suppose that the adversary asks for the shared key for <span class="math">(\\mathsf{id}_{i},\\mathsf{id}_{j})</span>. We abort if both of them are from <span class="math">\\{\\mathsf{id}_{1}^{<em>},\\mathsf{id}_{2}^{</em>}\\}</span>. If not, let’s assume without loss of generality,that <span class="math">\\mathsf{id}_{i}\\notin\\{\\mathsf{id}_{1}^{<em>},\\mathsf{id}_{2}^{</em>}\\}</span>. We return <span class="math">e_{C}(d_{\\mathsf{id}_{i}},H(\\mathsf{id}_{j}))</span> as the shared key. When the adversary makes the challenge query we abort if the challenge identities are not <span class="math">\\{\\mathsf{id}_{1}^{<em>},\\mathsf{id}_{2}^{</em>}\\}</span>. Else, we return <span class="math">Z</span> as response. It is easy to see that the above strategy provides a perfect simulation of IND-SK security if we do not abort during the simulation.</p>

    <p class="text-gray-300">Finally, we return the adversary’s response (“real” or “random”) to the challenge query as our solution to the DBDH-C instance. ∎</p>

    <p class="text-gray-300">Some other SOK-type protocols that can be implemented with Type C pairings (but not Type A or Type B) are Scott’s key agreement protocol <em>[45]</em> and the hierarchical id-based key-agreement of Gennaro et al. <em>[26]</em>.</p>

    <h2 id="sec-44" class="text-2xl font-bold">7. Efficiency</h2>

    <p class="text-gray-300">This section provides cost estimates for arithmetic operations on the <span class="math">k=1</span> elliptic curve <span class="math">E</span> defined in (5). The cost estimates are in terms of the number of <span class="math">\\mathbb{F}_{p}</span> multiplications. We do not</p>

    <p class="text-gray-300">S. CHATTERJEE, A. MENEZES, AND F. RODRIGUEZ-HENRIQUEZ</p>

    <p class="text-gray-300">count <span class="math">\\mathbb{F}_p</span> additions and subtractions, so the estimates are somewhat optimistic. Nonetheless, they serve to demonstrate the practicality of implementing pairing-based protocols with <span class="math">k = 1</span> elliptic curves at the 128-bit security level.</p>

    <p class="text-gray-300">We focus on the operations that are needed to implement the BLS-B signature scheme at the 128-bit security level. To achieve this security level against NFS attacks on the discrete logarithm problem, one needs to select a 3072-bit prime <span class="math">p</span>. One method for selecting such a <span class="math">p</span> is to randomly select a 1535-bit prime <span class="math">n</span> with <span class="math">n \\equiv 3 \\pmod{4}</span> until <span class="math">A^2 + 1</span>, where <span class="math">A = 2n</span>, is a 3072-bit prime; here the cofactor is <span class="math">h = 2</span>. We are assuming here that the special form of <span class="math">p</span>, namely <span class="math">p = A^2 + 1</span> where <span class="math">A</span> is twice a randomly selected 1535-bit prime, cannot be exploited to speed up the NFS.</p>

    <p class="text-gray-300">In order to reduce the number of iterations in Miller's algorithm, an alternative is to select a 256-bit prime <span class="math">n</span> with <span class="math">n \\equiv 3 \\pmod{4}</span> and a randomly selected 1280-bit cofactor <span class="math">h = A / n</span>. A smaller <span class="math">n</span> also speeds up subgroup membership testing and point multiplication since scalars are now only 256 bits in length. The resulting speedups are partially offset by an increase in the time to perform hashing and the final exponentiation in the Tate pairing computation. Note that Pollard's rho attack [41] on the discrete logarithm problem in an order-<span class="math">n</span> subgroup of <span class="math">E(\\mathbb{F}_p)</span> takes roughly <span class="math">n^{1/2}</span> steps, so selecting a 256-bit <span class="math">n</span> preserves the 128-bit security level. In order to decrease the number of addition steps in Miller's algorithm (steps 9-12 in Algorithm 1), one can select <span class="math">n</span> so that its binary representation has low Hamming weight. Then, under the heuristic assumption that <span class="math">A</span> is a uniformly distributed 1536-bit number, it is reasonable to assume that the special form of <span class="math">n</span> cannot be exploited to speed up attacks on the discrete logarithm problem.</p>

    <p class="text-gray-300">In §7.1 we give the cost estimates for arithmetic operations; see Table 1. We consider two cases, one where <span class="math">n</span> is a randomly-selected 1535-bit prime with Hamming weight approximately 768, and the other where <span class="math">n</span> is a 256-bit prime of Hamming weight 3 with 1280-bit cofactor <span class="math">h</span> of Hamming weight approximately 640. In both cases, <span class="math">n \\equiv 3 \\pmod{4}</span> and <span class="math">p</span> is assumed to have Hamming weight approximately 1536. We denote the cost of multiplication, squaring and inversion in <span class="math">\\mathbb{F}_p</span> by <span class="math">M</span>, <span class="math">S</span>, and <span class="math">I</span>, respectively. For the sake of simplicity, we will assume that <span class="math">S \\approx M</span>. In §7.2 we give clock cycle counts for BLS-B signature generation and signature verification. These counts indicate that the BLS-B signature scheme at the 128-bit security level is reasonably efficient on desktop computers.</p>

    <h2 id="sec-45" class="text-2xl font-bold">7.1. Cost estimates.</h2>

    <p class="text-gray-300">7.1.1. Elliptic curve representation. To avoid expensive inversions in <span class="math">\\mathbb{F}_p</span>, we represent points in <span class="math">E(\\mathbb{F}_p)</span> using modified Jacobian coordinates, where a point <span class="math">(X,Y,Z,W = Z^2)</span> corresponds to the point <span class="math">(x,y)</span> in affine coordinates with <span class="math">x = X / Z^2</span> and <span class="math">y = Y / Z^3</span> [21]. With modified Jacobian coordinates, the cost of a point addition is <span class="math">A = 7M + 4S \\approx 11M</span> and the cost of a point doubling is <span class="math">D = 1M + 8S \\approx 9M</span>.</p>

    <p class="text-gray-300">3One can also use primes whose signed binary representations have low Hamming weight. Among such primes are <span class="math">2^{255} + 2^{96} - 1</span>, <span class="math">2^{255} + 2^{176} - 1</span>, <span class="math">2^{255} + 2^{232} - 1</span>, <span class="math">2^{256} - 2^{76} - 1</span> and <span class="math">2^{256} - 2^{194} - 1</span>.</p>

    <p class="text-gray-300">ELLiptIC CURVES OF EMBEDDING DEGREE ONE</p>

    <p class="text-gray-300">TABLE 1. Cost estimates for operations on the  <span class="math">k = 1</span>  elliptic curve (5) with 1535-bit  <span class="math">n</span>  and 256-bit  <span class="math">n</span> . The cost of a multiplication in  <span class="math">\\mathbb{F}_p</span>  is denoted by  <span class="math">M</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1535-bit n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">256-bit n</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tate pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">42957M</td>

            <td class="px-3 py-2 border-b border-gray-700">8726M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Weil pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">81306M</td>

            <td class="px-3 py-2 border-b border-gray-700">9252M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Point multiplication</td>

            <td class="px-3 py-2 border-b border-gray-700">16277M</td>

            <td class="px-3 py-2 border-b border-gray-700">2863M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hashing</td>

            <td class="px-3 py-2 border-b border-gray-700">4617M</td>

            <td class="px-3 py-2 border-b border-gray-700">18238M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Subgroup membership testing</td>

            <td class="px-3 py-2 border-b border-gray-700">59234M</td>

            <td class="px-3 py-2 border-b border-gray-700">11589M</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.1.2. Pairing computation. Section 4.2 of [33] gives formulas for the doubling step of Miller's algorithm (steps 4-7 of Algorithm 1) and the addition step (steps 9-12 of Algorithm 1). The costs are  <span class="math">8M + 10S</span>  and  <span class="math">12M + 5S</span> , respectively. Now, the cost of Miller's algorithm with  <span class="math">n</span>  of bitlength  <span class="math">\\ell</span>  and Hamming weight  <span class="math">v</span>  is  <span class="math">(\\ell - 1) \\cdot (8M + 10S) + (v - 1) \\cdot (12M + 5S) + 2M + I</span> . Ignoring the cost of  <span class="math">I</span> , we get a total cost of  <span class="math">40653M</span>  in the case of 1535-bit  <span class="math">n</span> , and  <span class="math">4626M</span>  in the case of 256-bit  <span class="math">n</span>  (with Hamming weight  <span class="math">v = 3</span> ).</p>

    <p class="text-gray-300">In the case of the Tate pairing, we must perform a final exponentiation by the power  <span class="math">(p - 1) / n</span> . Suppose we use the repeated-square-and-multiply method for the exponentiation. Then the final exponentiation cost is  <span class="math">2304M</span>  in the case of 1535-bit  <span class="math">n</span> , and  <span class="math">4100M</span>  in the case of 256-bit  <span class="math">n</span> .</p>

    <p class="text-gray-300">Thus, the total cost of a Tate pairing is  <span class="math">42957M</span>  in the case of 1535-bit  <span class="math">n</span> , and  <span class="math">8726M</span>  in the case of 256-bit  <span class="math">n</span> . The cost of the Weil pairing in the two cases is  <span class="math">81306M</span>  and  <span class="math">9252M</span> .</p>

    <p class="text-gray-300">7.1.3. Point multiplication. Let  <span class="math">P \\in E(\\mathbb{F}_p)</span>  and let  <span class="math">r</span>  be an  <span class="math">\\ell</span> -bit integer. Then point multiplication  <span class="math">rP</span>  can be performed using the  <span class="math">w</span> -NAF method at a cost of  <span class="math">(2^{w-2} - 1)A + (\\ell/(w + 1))A + (\\ell + 1)D</span>  (see [31, Algorithm 3.36]). Thus the cost of the point multiplication when  <span class="math">P \\in E[n]</span>  and  <span class="math">r \\in_R [1, n-1]</span>  is  <span class="math">223A + 1536D = 16277M</span>  in the case of 1535-bit  <span class="math">n</span>  and  <span class="math">w = 7</span> , and  <span class="math">50A + 257D = 2863M</span>  in the case of 256-bit  <span class="math">n</span>  and  <span class="math">w = 5</span> .</p>

    <p class="text-gray-300">7.1.4. Hashing. Hashing onto  <span class="math">\\mathbb{G}_2</span>  can be performed by first using a standard hash function to map an arbitrary string to the  <span class="math">x</span> -coordinate of a point in  <span class="math">E(\\mathbb{F}_p)</span> , then solving a quadratic equation over  <span class="math">\\mathbb{F}_p</span>  to find the corresponding  <span class="math">y</span> -coordinate, and finally multiplying the resulting point by the cofactor  <span class="math">h</span>  to obtain an  <span class="math">n</span> -torsion point. Since  <span class="math">p \\equiv 1 \\pmod{4}</span> , one can select parameters so that  <span class="math">p \\equiv 5 \\pmod{8}</span> . Then the square root of a quadratic residue  <span class="math">a \\in \\mathbb{F}_p</span>  can be computed with one exponentiation by  <span class="math">(p - 5)/8</span>  and a small number of multiplications; see Algorithm 3 in [2]. The exponentiation can be performed using the repeated-square-and-multiply algorithm at a cost of approximately  <span class="math">4608M</span> . The cost of the  <span class="math">w</span> -NAF point multiplication method with an  <span class="math">\\ell</span> -bit scalar is  <span class="math">(2^{w-2} - 1)A + (\\ell/(w + 1))A + (\\ell + 1)D</span>  (see [31, Algorithm 3.36]). Thus the cost of the point multiplication by  <span class="math">h</span>  is  <span class="math">1D = 9M</span>  in the case  <span class="math">h = 2</span> , and approximately  <span class="math">191A + 1281D = 13630M</span>  in the case of  <span class="math">1280</span> -bit  <span class="math">h</span>  and  <span class="math">w = 7</span> . This gives a hashing cost of  <span class="math">4617M</span>  for  <span class="math">h = 2</span> , and  <span class="math">18238M</span>  for  <span class="math">1280</span> -bit  <span class="math">h</span> .</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">7.1.5. Subgroup membership testing</h4>

    <p class="text-gray-300">Let <span class="math">P\\in E[n]</span>. By Corollary 1 a point <span class="math">Q</span> is in <span class="math">\\langle P\\rangle</span> if and only if (i) <span class="math">Q</span> satisfies the defining equation of <span class="math">E</span>; (ii) <span class="math">nQ=\\infty</span>; and (iii) <span class="math">t_{n}(P,\\psi(Q))=1</span>. Thus the cost of subgroup membership testing is approximately the sum of the costs of a point multiplication and a Tate pairing computation.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">7.2. BLS-B signature scheme</h3>

    <p class="text-gray-300">We employ an elliptic curve with 256-bit <span class="math">n</span>, and the Tate pairing. The dominant operations in BLS-B signature generation (see §5.2.1) are a hashing and a point multiplication, for a total cost of <span class="math">21101M</span>. The dominant operations in BLS-B signature verification are a hashing, a subgroup membership testing, and two pairings, for a total cost of <span class="math">47279M</span>.</p>

    <p class="text-gray-300">Now, the 3072-bit operands <span class="math">a,b\\in\\mathbb{F}_{p}</span> each require forty-eight 64-bit words. Beginning with the Haswell microarchitecture, Intel introduced the MULX instruction that performs a 64-bit word product leaving the arithmetic flags untouched. This feature permits the smooth combination of the MULX and add-with-carry instructions. In this way, the Karatsuba multiplier approach as described in <em>[54, 47]</em> can be efficiently implemented on a Haswell processor by computing the 6144-bit integer product <span class="math">t=a\\cdot b</span> in roughly 5,200 clock cycles. The field product <span class="math">c=t\\bmod p</span> can then be performed using Barrett reduction <em>[10]</em> at an extra cost of roughly 1.5 integer multiplications. Hence, the total cost of computing the field multiplication is approximately 13,000 clock cycles.</p>

    <p class="text-gray-300">The 13,000 clock cycle estimate for a field multiplication yields the estimates of 113.4 million clock cycles for computing the Tate pairing, 274.3 million clock cycles for BLS-B signature generation, and 614.6 million clock cycles for BLS-B signature verification. These numbers suggest that <span class="math">k=1</span> pairings have acceptable performance for applications that run on desktop computers and high-end mobile devices where clock rates of 2.0 GHz are common.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">(speed comparisons with pairings of even embedding degree) We did not attempt to optimize our cost estimates, e.g., by exploiting parallelism or combining operations when computing a product of pairings <em>[46]</em>. Nonetheless, the <span class="math">k=1</span> pairings are expected to be significantly slower than pairings derived from elliptic curves of even embedding degree because of the inapplicability of many optimizations available in the latter such as reducing the number of iterations in Miller’s algorithm <em>[51]</em>, denominator elimination <em>[8]</em>, and fast exponentiation <em>[48]</em>. For example, <em>[3]</em> report a speed of 18.7 million clock cycles for computing a BLS12 pairing at the 192-bit security level on an Intel Core i5 Nehalem machine. Still, <span class="math">k=1</span> pairings are not expected to be drastically slower than pairings derived from supersingular elliptic curves with embedding degree 2 as standardized in <em>[15, 30]</em>.</p>

    <h2 id="sec-49" class="text-2xl font-bold">8. Concluding remarks</h2>

    <p class="text-gray-300">We have defined three types of pairings with elliptic curves of embedding degree one. These three pairings do not fit within the general classification of pairings derived from elliptic curves of even embedding degree. Our study of pairing-based protocols indicates that any protocol that can be implemented with a Type A pairing can also be implemented with Types B and C; however the converse is not true. Similarly, any protocol that can be</p>

    <p class="text-gray-300">ELLiptic CURVES OF EMBEDDING DEGREE ONE</p>

    <p class="text-gray-300">implemented with a Type B pairing can also be implemented with Type C, but the converse is not true.</p>

    <p class="text-gray-300">Finally, we note that there are some pairing-based protocols that cannot be implemented in either Types A, B or C. Protocols have been designed based on the Symmetric eXternal Diffie-Hellman assumption (SXDH) in the Type 3 setting (which says that the decisional Diffie-Hellman (DDH) problem is hard in the pairing groups <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>). Examples of such protocols can be found in <em>[20, 36]</em>. Since DDH is <em>easy</em> in the pairing groups defined over elliptic curves with embedding degree one, these protocols cannot be securely instantiated in either Types A, B or C. Neither will it be possible to implement protocols that require reversible embedding of messages in <span class="math">\\mathbb{G}_{T}</span>; among such protocols are Waters’ IBE scheme in its original form <em>[53]</em> and Gentry’s IBE scheme <em>[27]</em> (see also <em>[17]</em>).</p>

    <p class="text-gray-300">We thank Razvan Barbulescu for answering our questions on the Number Field Sieve, and Neal Koblitz for several helpful suggestions.</p>

    <h2 id="sec-50" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] G. Adj, A. Menezes, T. Oliveira and F. Rodríguez-Henríquez, “Computing discrete logarithms in <span class="math">\\mathbb{F}_{3^{6}\\text{ \\text{-}137}}</span> and <span class="math">\\mathbb{F}_{3^{6}\\text{ \\text{-}163}}</span> using Magma”, International Workshop on Arithmetic of Finite Fields — WAIFI 2014, LNCS 9061 (2015), 3–22.</li>

      <li>[2] G. Adj and F. Rodríguez-Henríquez, “Square root computation over even extension fields”, IEEE Transactions on Computers, 63 (2014), 2829–2841.</li>

      <li>[3] D. Aranha, L. Fuentes-Castañeda, E. Knapp, A. Menezes and F. Rodríguez-Henríquez, “Implementing pairings at the 192-bit security level”, Pairing-Based Cryptography — Pairing 2012, LNCS 7708 (2013), 177–195.</li>

      <li>[4] R. Balasubramanian and N. Koblitz, “The improbability that an elliptic curve has subexponential discrete log problem under the Menezes-Okamoto-Vanstone algorithm”, Journal of Cryptology, 11 (1998), 141–145.</li>

      <li>[5] R. Barbulescu, P. Gaudry, A. Guillevic and F. Morain, “Improving NFS for the discrete logarithm problem in non-prime finite fields”, Advances in Cryptology — EUROCRYPT 2015, LNCS 9056 (2015), 129–155.</li>

      <li>[6] R. Barbulescu, P. Gaudry, A. Joux and E. Thomé, “A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic: Improvements over FFS in small to medium characteristic”, Advances in Cryptology — EUROCRYPT 2014, LNCS 8441 (2014), 1–16.</li>

      <li>[7] P. Barreto, S. Galbraith, C. Ó’hÉigeartaigh and M. Scott, “Efficient pairing computation on supersingular abelian varieties”, Designs, Codes and Cryptography, 42 (2007), 239–271.</li>

      <li>[8] P. Barreto, B. Lynn and M. Scott, “On the selection of pairing-friendly group”, Selected Areas in Cryptography — SAC 2003, LNCS 3006 (2004), 17–25.</li>

      <li>[9] P. Barreto and M. Naehrig, “Pairing-friendly elliptic curves of prime order”, Selected Areas in Cryptography — SAC 2005, LNCS 3897 (2006), 319–331.</li>

      <li>[10] P. Barrett, “Implementing the Rivest Shamir and Adleman public key encryption algorithm on a standard digital signal processor”, Advances in Cryptology — CRYPTO ’86, LNCS 263 (1987), 311–323.</li>

      <li>[11] D. Boneh and M. Franklin, “Identity-based encryption from the Weil pairing”, SIAM Journal on Computing, 32 (2003), 586–615.</li>

    </ul>

    <p class="text-gray-300">S. CHATTERJEE, A. MENEZES, AND F. RODRIGUEZ-HENRIQUEZ</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[12] D. Boneh, C. Gentry, B. Lynn and H. Shacham, “Aggregate and verifiably encrypted signatures from bilinear maps”, Advances in Cryptology — EUROCRYPT 2003, LNCS, 2656 (2003), 416–432.</li>

      <li>[13] D. Boneh, B. Lynn, and H. Shacham, “Short signatures from the Weil pairing”, Journal of Cryptology, 17 (2004), 297–319.</li>

      <li>[14] D. Boneh, K. Rubin and A. Silverberg, “Finding composite order ordinary elliptic curves using the Cocks-Pinch method”, Journal of Number Theory, 131 (2011), 832-841.</li>

      <li>[15] X. Boyen and L. Martin, “Identity-based cryptography standard (IBCS) #1: Supersingular curve implementations of the BF and BB1 cryptosystems”, IETF RFC 5091, December 2007.</li>

      <li>[16] S. Chatterjee, D. Hankerson and A. Menezes, “On the efficiency and security of pairing-based protocols in the Type 1 and Type 4 settings”, International Workshop on Arithmetic of Finite Fields — WAIFI 2010, LNCS 6087 (2010), 114–134.</li>

      <li>[17] S. Chatterjee, K. Karabina and A. Menezes, “Fault attacks on pairing-based protocols revisited”, IEEE Transactions on Computers, 64 (2015), 1707–1714.</li>

      <li>[18] S. Chatterjee and A. Menezes, “On cryptographic protocols employing asymmetric bilinear pairings — The role of <span class="math">\\psi</span> revisited”, sl Discrete Applied Mathematics, 159 (2011), 1311–1322</li>

      <li>[19] S. Chatterjee and A. Menezes, “Type 2 structure-preserving signature schemes revisited”, Advances in Cryptology — ASIACRYPT 2015, LNCS 9452 (2015), 286–310</li>

      <li>[20] J. Chen and H. Wee, “Fully, (almost) tightly secure IBE and dual system groups, Advances in Cryptology — CRYPTO 2013, LNCS 8043 (2013), 435–460.</li>

      <li>[21] D. Chudnovsky and G. Chudnovsky, “Sequences of numbers generated by addition in formal groups and new primality and factoring tests”, Advances in Applied Mathematics, 7 (1987), 385–434.</li>

      <li>[22] D. Coppersmith, “Fast evaluation of logarithms in fields of characteristic two”, IEEE Transactions on Information Theory, 30 (1984), 587–594.</li>

      <li>[23] R. Dupont and A Enge, “Provably secure non-interactive key distribution based on pairings”, Discrete Applied Mathematics, 154 (2006), 270–276.</li>

      <li>[24] S. Galbraith, “Pairings”, Chapter IX of I. Blake, G. Seroussi, and N. P. Smart, eds., Advances in Elliptic Curve Cryptography, Vol. 2, Cambridge University Press, 2005.</li>

      <li>[25] S. Galbraith, K. Paterson and N. Smart, “Pairings for cryptographers”, Discrete Applied Mathematics, 156 (2008), 3113-3121.</li>

      <li>[26] R. Gennaro, S. Halevi, H. Krawczyk, T. Rabin, S. Reidt and S. Wolthusen, “Strongly-resilient and non-interactive hierarchical key-agreement in MANETs”, 13th European Symposium on Research in Computer Security — ESORICS 2008, LNCS 5283 (2008), 49–65.</li>

      <li>[27] C. Gentry, “Practical identity-based encryption without random oracles”, Advances in Cryptology — EUROCRYPT 2006, LNCS 4404 (2006), 445–464.</li>

      <li>[28] D. Gordon, “Discrete logarithms in <span class="math">GF(p)</span> using the number field sieve”, SIAM Journal on Discrete Mathematics, 6 (1993), 124–138.</li>

      <li>[29] R. Granger, T. Kleinjung and J. Zumbrägel, “Breaking ‘128-bit secure’ supersingular binary curves (or how to solve discrete logarithms in <span class="math">\\mathbb{F}_{2^{4}\\cdot 1223}</span> and <span class="math">\\mathbb{F}_{2^{12}\\cdot 367}</span>)”, Advances in Cryptology — CRYPTO 2014, LNCS 8617 (2014), 126–145.</li>

      <li>[30] M. Groves, “Sakai-Kasahara key encryption (SAKKE)”, IETF RFC 6508, February 2012.</li>

      <li>[31] D. Hankerson, A. Menezes and S. Vanstone, Guide to Elliptic Curve Cryptography, Springer, 2004.</li>

      <li>[32] F. Hess, N. Smart and F. Vercauteren, “The eta pairing revisited” IEEE Transactions on Information Theory, 52 (2006), 4595–4602.</li>

      <li>[33] Z. Hu, L. Wang, M. Xu and G. Zhang, “Generation and Tate pairing computation of ordinary elliptic curves with embedding degree one”, ICICS 2013, LNCS 8233 (2013), 393-403.</li>

      <li>[34] A. Joux, “A one round protocol for tripartite Diffie-Hellman”, Journal of Cryptology, 17 (2004), 263–276.</li>

      <li>[35] A. Joux and K. Nguyen, “Separating Decision Diffie-Hellman from Computational Diffie-Hellman in cryptographic groups”, Journal of Cryptology, 16 (2003), 239–247.</li>

    </ul>

    <p class="text-gray-300">ELLiptIC CURVES OF EMBEDDING DEGREE ONE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[36] C. Jutla and A. Roy, “Shorter quasi-adaptive NIZK proofs for linear subspaces”, Advances in Cryptology — ASIACRYPT 2013, LNCS 8269 (2013), 1–20.</li>

      <li>[37] T. Kim and R. Barbulescu, “Extended tower number field sieve: A new complexity for medium prime case”, Advances in Cryptology — CRYPTO 2016, LNCS 9814 (2016), 543–571.</li>

      <li>[38] N. Koblitz and A. Menezes, “Pairing-based cryptography at high security levels”, Cryptography and Coding: 10th IMA International Conference, LNCS 3796 (2005), 13–36.</li>

      <li>[39] V. Miller, “The Weil pairing, and its efficient calculation’, Journal of Cryptology, 17 (2004), 235–261.</li>

      <li>[40] K. Paterson and S. Srinivasan, “On the relations between non-interactive key distribution, identity-based encryption and trapdoor discrete log groups”, Designs, Codes and Cryptography, 52 (2009), 219–241.</li>

      <li>[41] J. Pollard, “Monte Carlo methods for index computation mod <span class="math">p</span>”, Mathematics of Computation, 32 (1978), 918–924.</li>

      <li>[42] R. Sakai, K. Oghishi and M. Kasahara, “Cryptosystems based on pairing over elliptic curve” (in Japanese), The 2000 Symposium on Cryptography and Information Security, 2000.</li>

      <li>[43] O. Schirokauer, “Discrete logarithms and local units”, Philosophical Transactions of the Royal Society London A, 345 (1993), 409–423.</li>

      <li>[44] O. Schirokauer, “The number field sieve for integers of low weight”, Mathematics of Computation, 79 (2010), 583-602.</li>

      <li>[45] M. Scott, “Authenticated id-based key exchange and remote log-in with simple token and PIN number”, available at http://eprint.iacr.org/2002/164.</li>

      <li>[46] M. Scott, “Computing the Tate pairing”, Topics in Cryptology — CT-RSA 2005, LNCS 3376 (2005) 300–312.</li>

      <li>[47] M. Scott, “Missing a trick: Karatsuba revisited”, available at http://eprint.iacr.org/2015/1247.</li>

      <li>[48] M. Scott, N. Benger, M. Charlemagne, L. Dominguez Perez and E. Kachisa, “On the final exponentiation for calculating pairings on ordinary elliptic curves”, Pairing-Based Cryptography — Pairing 2009, LNCS 5671 (2009), 78–88.</li>

      <li>[49] H. Shacham, “New paradigms in signature schemes”, Ph.D. thesis, Stanford University, 2005.</li>

      <li>[50] J. Silverman, The Arithmetic of Elliptic Curves, Springer, 1986.</li>

      <li>[51] F. Vercauteren, “Optimal pairings”, IEEE Transactions on Information Theory, 56 (2010), 455–461.</li>

      <li>[52] E. Verheul, “Evidence that XTR is more secure than supersingular elliptic curve cryptosystems”, Journal of Cryptology, 17 (2004), 277–296.</li>

      <li>[53] B. Waters, “Efficient identity-based encryption without random oracles”, Advances in Cryptology — EUROCRYPT 2005, LNCS 3494 (2005), 114–127.</li>

      <li>[54] A. Weimerskirch and C. Paar, “Generalizations of the Karatsuba algorithm for efficient implementation”, available at http://eprint.iacr.org/2006/224.</li>

      <li>[55] C. Zhao, F. Zhang and D. Xie, “Faster computation of self-pairings”, IEEE Transactions on Information Theory, 58 (2012), 3266–3272.</li>

    </ul>

    <p class="text-gray-300">Department of Computer Science and Automation, Indian Institute of Science E-mail address: sanjit@csa.iisc.ernet.in</p>

    <p class="text-gray-300">Department of Combinatorics &amp; Optimization, University of Waterloo E-mail address: ajmeneze@uwaterloo.ca</p>

    <p class="text-gray-300">Computer Science Department, CINVESTAV-IPN E-mail address: francisco@cs.cinvestav.mx</p>`;
---

<BaseLayout title="On Instantiating Pairing-Based Protocols with Elliptic Curve... (2016/403)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/403
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
