---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/403';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'ON INSTANTIATING PAIRING-BASED PROTOCOLS WITH ELLIPTIC CURVES OF EMBEDDING DEGREE ONE';
const AUTHORS_HTML = 'SANJIT CHATTERJEE, ALFRED MENEZES, AND FRANCISCO RODRÍGUEZ-HENRÍQUEZ';

const CONTENT = `    <p class="text-gray-300">SANJIT CHATTERJEE, ALFRED MENEZES, AND FRANCISCO RODRÍGUEZ-HENRÍQUEZ</p>

    <p class="text-gray-300">ABSTRACT. Since the discovery of identity-based encryption schemes in 2000, bilinear pairings have been used in the design of hundreds of cryptographic protocols. The most commonly used pairings are constructed from elliptic curves over finite fields with small embedding degree. These pairings can have different security, performance, and functionality characteristics, and were therefore classified into Types 1, 2, 3 and 4. In this paper, we observe that this conventional classification is not applicable to pairings from elliptic curves with embedding degree one. It is important to understand the security, efficiency, and functionality of these pairings in light of recent attacks on certain pairings constructed from elliptic curves with embedding degree greater than one. We define three kinds of pairings from elliptic curves with embedding degree one, discuss some subtleties with using them to implement pairing-based protocols, and provide an estimated cost of implementing them on modern processors.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">1. Introduction</h4>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span>  and  <span class="math">\\mathbb{G}_T</span>  be groups of prime order n. A cryptographic pairing  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is a map that is bilinear, non-degenerate and efficiently computable. Since 2000, when Boneh and Franklin proposed their identity-based encryption scheme [11], cryptographic pairings have been used extensively to design a wide variety of cryptographic protocols.</p>

    <p class="text-gray-300">Cryptographic pairings are constructed from elliptic curves of small embedding degree. More precisely, let E be an elliptic curve defined over the finite field  <span class="math">\\mathbb{F}_q</span> . Let n be a prime divisor of  <span class="math">\\#E(\\mathbb{F}_q)</span>  with  <span class="math">\\gcd(n,q)=1</span> , and let k be the smallest positive integer such that  <span class="math">n \\mid q^k-1</span> ; the number k is called the embedding degree of E (with respect to n). Then  <span class="math">\\mathbb{G}_1</span>  is an order-n subgroup of  <span class="math">E(\\mathbb{F}_q)</span> ,  <span class="math">\\mathbb{G}_2</span>  is an order-n subgroup of  <span class="math">E(\\mathbb{F}_{q^k})</span> ,  <span class="math">\\mathbb{G}_T</span>  is the order-n subgroup of  <span class="math">\\mathbb{F}_{q^k}^*</span> , and the map e is derived from the classical Weil and Tate pairings. Among the elliptic curves that have been used to implement pairings are supersingular curves of embedding degree 4 over finite fields of characteristic two (see [7]), supersingular and ordinary curves of embedding degree 2 over finite fields of prime order (see [46]), and Barreto-Naehrig (BN) ordinary curves of embedding degree 12 over finite fields of prime order [9].</p>

    <p class="text-gray-300">A necessary condition for the security of pairing-based protocols is that the discrete logarithm problem (DLP) in  <span class="math">\\mathbb{F}_{q^k}</span>  is intractable. Until recently, the assumption was that the fastest algorithm for computing logarithms in small-characteristic finite fields  <span class="math">\\mathbb{F}_q</span>  was Coppersmith's algorithm [22] with running time  <span class="math">L_q[\\frac{1}{3},(\\frac{32}{9})^{1/3}]\\approx L_q[\\frac{1}{3},1.526]</span> , and the fastest algorithm for computing logarithms in large-characteristic finite fields  <span class="math">\\mathbb{F}_q</span>  was the Number Field Sieve (NFS) [28, 43] with running time  <span class="math">L_q[\\frac{1}{3},(\\frac{64}{9})^{1/3}]\\approx L_q[\\frac{1}{3},1.923]</span> . Here,  <span class="math">L_Q[\\alpha,c]</span>  with  <span class="math">0&lt;\\alpha&lt;1</span>  and c&gt;0 denotes the expression</p>

    <p class="text-gray-300"><span class="math">$O\\left(\\exp\\left((c+o(1))(\\log Q)^{\\alpha}(\\log\\log Q)^{1-\\alpha}\\right)\\right)</span>$</p>

    <p class="text-gray-300">that is subexponential in  <span class="math">\\log Q</span> . However, recent work has shown that these assumptions were overly optimistic. Most dramatically, in 2013 a quasi-polynomial time algorithm (with running time  <span class="math">L_q[\\epsilon,c]</span>  for any  <span class="math">\\epsilon&gt;0</span> ) was devised for computing discrete logarithms in small-characteristic finite fields  <span class="math">\\mathbb{F}_q</span>  [6], effectively breaking all pairings derived from supersingular elliptic curves over small-characteristic finite fields (see [1, 29]). In 2015, Kim and Barbulescu [37] devised a variant of the NFS that computes logarithms in  <span class="math">\\mathbb{F}_q=\\mathbb{F}_{p^k}</span>  in time  <span class="math">L_q[\\frac{1}{3},(\\frac{48}{9})^{1/3}]\\approx L_q[\\frac{1}{3},1.759]</span>  when p is a medium-sized prime (more precisely,  <span class="math">p=L_q[\\alpha,c]</span>  with  <span class="math">\\frac{1}{3}&lt;\\alpha&lt;\\frac{2}{3}</span> ). Kim and Barbulescu state that their algorithm can be applied to computing logarithms in the fields  <span class="math">\\mathbb{F}_{p^{12}}</span>  that arise in BN pairings. Moreover, if p has a special form, as is the case with BN pairings, a further refinement of their algorithm has running time  <span class="math">L_q[\\frac{1}{3},(\\frac{32}{9})^{1/3}]</span> . Also in 2015, experiments conducted by Barbulescu et al. [5] illustrated that the DLP is significantly easier in  <span class="math">\\mathbb{F}_{p^2}</span>  than in prime-order fields  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">The aforementioned improvements in algorithms for computing discrete logarithms cast some suspicions on the true intractability of the DLP in extension fields  <span class="math">\\mathbb{F}_{p^k}</span> , especially if the characteristic p is of a special form. On the other hand, these improvements do not apply to the DLP in prime-order fields  <span class="math">\\mathbb{F}_p</span>  provided that the prime p does not have a special form; thus, the fastest general-purpose algorithm known for the DLP in  <span class="math">\\mathbb{F}_p</span>  has running time  <span class="math">L_p[\\frac{1}{3},(\\frac{64}{9})^{1/3}]</span> . Consequently, elliptic curves with embedding degree k=1 would appear to be a conservative choice for implementing pairing-based protocols. The group  <span class="math">\\mathbb{G}_T</span>  in these pairings is the order-n subgroup of the multiplicative group of a prime field  <span class="math">\\mathbb{F}_p^*</span> , whence security is not directly affected by advances in algorithms for computing logarithms in extension fields.</p>

    <p class="text-gray-300">Remark 1. (DLP in  <span class="math">\\mathbb{F}_p</span>  versus DLP in  <span class="math">\\mathbb{F}_{p^k}</span> ) Since  <span class="math">\\mathbb{F}_p</span>  is a subfield of  <span class="math">\\mathbb{F}_{p^k}</span>  for any  <span class="math">k \\geq 2</span> , the DLP in  <span class="math">\\mathbb{F}_p</span>  can be reduced to the DLP in  <span class="math">\\mathbb{F}_{p^k}</span> . Hence, advances in algorithms for the DLP in  <span class="math">\\mathbb{F}_{p^k}</span>  might be effective for solving the DLP in  <span class="math">\\mathbb{F}_p</span> . For example, an  <span class="math">L_{p^k}[\\alpha, c]</span>  algorithm for solving the DLP in  <span class="math">\\mathbb{F}_{p^k}</span>  (where k &gt; 1 is a constant) yields an  <span class="math">L_p[\\alpha, ck^{\\alpha}]</span>  algorithm for the DLP in  <span class="math">\\mathbb{F}_p</span> . Hence, an  <span class="math">L_{p^2}[\\frac{1}{3}, c]</span>  algorithm with  <span class="math">c &lt; (\\frac{32}{9})^{1/3}</span>  for the DLP in  <span class="math">\\mathbb{F}_{p^2}</span>  yields a DLP algorithm for  <span class="math">\\mathbb{F}_p</span>  that is faster than the best currently known algorithm. Similarly, an  <span class="math">L_{p^{12}}[\\frac{1}{3}, c]</span>  algorithm with  <span class="math">c &lt; (\\frac{16}{27})^{1/3}</span>  for the DLP in  <span class="math">\\mathbb{F}_{p^{12}}</span>  yields a faster DLP algorithm for  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">Elliptic curves with embedding degree one were first mentioned in [34, 35, 52] and further studied in [38, 33, 55]. These papers consider methods for generating suitable elliptic curves, and study the efficiency of the Weil and Tate pairings. However, none of these papers examine the implementation of pairing-based protocols with these pairings. Such implementation</p>

    <p class="text-gray-300">details are important in light of the many inefficiencies and problems that can arise when pairings are treated as black boxes; for example, see [25, 18, 19]. In this paper we observe that the often-cited classification of pairings into Types 1, 2, 3 and 4 [25] is not applicable to pairings from elliptic curves with embedding degree one. We define three kinds of pairings from these elliptic curves, and discuss some subtleties with using them to implement pairing-based protocols.</p>

    <p class="text-gray-300">The remainder of the paper is organized as follows. The classical Weil and Tate pairings are reviewed in §2. The salient features of elliptic curves with embedding degree one are presented in §3. Three kinds of pairings from elliptic curves with embedding degree one are introduced in §§4–6. The efficiency of these pairings is considered in §7. We draw our conclusions in §8.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">2. Pairings</h4>

    <p class="text-gray-300">Let p &gt; 3 be a prime, and let E be an elliptic curve defined over the finite field  <span class="math">\\mathbb{F}_p</span> . Let  <span class="math">\\pi: (x,y) \\mapsto (x^p,y^p)</span>  be the p-th power Frobenius endomorphism. The trace of the Frobenius is  <span class="math">t = p + 1 - \\#E(\\mathbb{F}_p)</span> . Let  <span class="math">n \\neq p</span>  be a prime with  <span class="math">n \\mid \\#E(\\mathbb{F}_p)</span> . The embedding degree is the smallest positive integer k satisfying  <span class="math">n \\mid (p^k - 1)</span> . We will assume that E[n], the group of all n-torsion points in  <span class="math">E(\\overline{\\mathbb{F}}_p)</span> , is contained in  <span class="math">E(\\mathbb{F}_{p^k})</span> ; this is indeed the case whenever k &gt; 1 [4].</p>

    <p class="text-gray-300">2.1. <strong>Miller functions.</strong> Let  <span class="math">R \\in E(\\mathbb{F}_{p^k})</span>  and let s be a non-negative integer. A Miller function  <span class="math">f_{s,R}</span>  [39] of length s is a function in  <span class="math">\\mathbb{F}_{p^k}(E)</span>  with divisor  <span class="math">(f_{s,R}) = s(R) - (sR) - (s-1)(\\infty)</span> , where  <span class="math">\\infty</span>  denotes the point at infinity. Let  <span class="math">u_{\\infty}</span>  be an  <span class="math">\\mathbb{F}_p</span> -rational uniformizing parameter for  <span class="math">\\infty</span> . A function  <span class="math">f \\in \\mathbb{F}_{p^k}(E)</span>  is said to be normalized if  <span class="math">lc_{\\infty}(f) = 1</span> , where  <span class="math">lc_{\\infty}(f) = (u_{\\infty}^{-t}f)(\\infty)</span>  and t is the order of f at  <span class="math">\\infty</span> .</p>

    <p class="text-gray-300">Let  <span class="math">P, Q \\in E[n] \\setminus \\{\\infty\\}</span> . Miller [39] described Algorithm 1 for evaluating a normalized Miller function  <span class="math">f_{n,P}</span>  at the point Q. In the algorithm, the line functions  <span class="math">\\ell</span>  and v are normalized.</p>

    <p class="text-gray-300"><strong>Remark 2.</strong> (failure of a Miller function computation) When Miller's algorithm is used to compute  <span class="math">f_{n,P}(Q)</span> , one might obtain a value of 0 in the numerator or denominator. This occurs only if Q happens to be a root of one of the line functions  <span class="math">\\ell</span> , v encountered in the computation. Since the roots of  <span class="math">\\ell</span>  and v must lie in  <span class="math">\\langle P \\rangle</span> , we conclude that a Miller function computation can only fail if  <span class="math">Q \\in \\langle P \\rangle</span> .</p>

    <p class="text-gray-300">2.2. Weil and Tate pairings. Let  <span class="math">\\mathbb{G}_T</span>  be the order-<em>n</em> subgroup of  <span class="math">\\mathbb{F}_{p^k}^*</span> . The Weil pairing  <span class="math">w_n</span>  can be defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 1</strong> ([39]). Let  <span class="math">P,Q \\in E[n] \\setminus \\{\\infty\\}</span>  with  <span class="math">P \\neq Q</span> . Then the Weil pairing is</p>

    <p class="text-gray-300">(1)
<span class="math">$w_n(P,Q) = (-1)^n \\frac{f_{n,P}(Q)}{f_{n,Q}(P)},</span>$</p>

    <p class="text-gray-300">where  <span class="math">f_{n,P}</span>  and  <span class="math">f_{n,Q}</span>  are normalized Miller functions. Furthermore,  <span class="math">w_n(P,\\infty) = w_n(\\infty,P) = w_n(P,P) = 1</span>  for all  <span class="math">P \\in E[n]</span> .</p>

    <pre><code class="language-text">Input: P, Q \\in E[n] \\setminus \\{\\infty\\}.
Output: f_{n,P}(Q).
 1: Write n in binary: n = \\sum_{i=0}^{L-1} n_i 2^i
 2: f \\leftarrow 1, g \\leftarrow 1, T \\leftarrow P
 3: for i \\leftarrow L - 2 downto 0 do
        Compute the tangent line \\ell through T and the vertical line v through 2T
        T \\leftarrow 2T
        f \\leftarrow f^2 \\cdot \\ell(Q)
 6:
        g \\leftarrow g^2 \\cdot v(Q)
 7:
        if n_i = 1 then
           Compute the line \\ell through T and P and the vertical line v through T+P
 9:
           T \\leftarrow T + P
10:
           f \\leftarrow f \\cdot \\ell(Q)
11:
           g \\leftarrow g \\cdot v(Q)
12:
13:
        end if
14: end for
15: return f/q
</code></pre>

    <p class="text-gray-300">The (reduced) Tate pairing  <span class="math">t_n</span>  can be defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 2</strong> ([51]). Let  <span class="math">P, Q \\in E[n]</span> . Let  <span class="math">R \\in E(\\mathbb{F}_{p^k})</span>  with  <span class="math">R \\notin \\{\\infty, P, -Q, P - Q\\}</span> . Then the Tate pairing is</p>

    <p class="text-gray-300">(2)
<span class="math">$t_n(P,Q) = \\left(\\frac{f_{n,P}(Q+R)}{f_{n,P}(R)}\\right)^{(p^k-1)/n}.</span>$</p>

    <p class="text-gray-300">If  <span class="math">f_{n,P}</span>  is normalized, then</p>

    <p class="text-gray-300">(3)
<span class="math">$t_n(P,Q) = (f_{n,P}(Q))^{(p^k-1)/n}</span>$</p>

    <p class="text-gray-300">for all  <span class="math">P, Q \\in E[n] \\setminus \\{\\infty\\}</span>  with  <span class="math">P \\neq Q</span> .</p>

    <p class="text-gray-300">2.3. <strong>Type 1, 2, 3 and 4 pairings.</strong> In cryptographic applications, one generally considers the restrictions of the Weil and Tate pairings to a domain  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_2</span> , where  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are fixed order-n subgroups of E[n].</p>

    <p class="text-gray-300">Suppose now that the embedding degree k is even. Galbraith, Paterson and Smart [25] defined three kinds of pairings  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> . The pairing e is of Type 1 (symmetric) if  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span> . Now, let  <span class="math">\\mathbb{G}_1 = E(\\mathbb{F}_p)[n]</span> . Let d be the order of the automorphism group of E, and suppose that  <span class="math">d \\mid k</span> . Let e = k/d. Then there is a unique degree-d twist  <span class="math">\\tilde{E}</span>  of E over  <span class="math">\\mathbb{F}_{p^e}</span>  with  <span class="math">n \\mid \\#\\tilde{E}(\\mathbb{F}_{p^e})</span>  [32]; let  <span class="math">\\mu: \\tilde{E} \\to E</span>  be the associated twisting isomorphism. Let  <span class="math">\\tilde{Q} \\in \\tilde{E}(\\mathbb{F}_{p^e})</span>  be a point of order n, and let  <span class="math">\\mathbb{G}_2 = \\langle Q \\rangle</span>  where  <span class="math">Q = \\mu(\\tilde{Q})</span> . The group  <span class="math">\\mathbb{G}_2</span>  is called the Trace-0 subgroup of E[n] since it is comprised of all points  <span class="math">P \\in E[n]</span>  for which</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Tr}(P) = \\sum_{i=0}^{k-1} \\pi^i(P) = \\infty</span> . Then  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is a Type 3 pairing. Finally, if  <span class="math">\\mathbb{G}_2&#x27;</span>  is any order-n subgroup of E[n] different from  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , then  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2&#x27; \\to \\mathbb{G}_T</span>  is a Type 2 pairing.</p>

    <p class="text-gray-300">Type 2 pairings have two properties that distinguish them from Type 3 pairings: an efficient method for hashing onto  <span class="math">\\mathbb{G}_2&#x27;</span>  is not known&lt;sup&gt;1&lt;/sup&gt;, and there is an efficiently-computable isomorphism  <span class="math">\\psi</span>  from  <span class="math">\\mathbb{G}_2&#x27;</span>  to  <span class="math">\\mathbb{G}_1</span>  (given by the Trace map). In contrast, hashing onto  <span class="math">\\mathbb{G}_2</span>  can be done efficiently and no efficiently-computable isomorphism from  <span class="math">\\mathbb{G}_2</span>  to  <span class="math">\\mathbb{G}_1</span>  is known for Type 3 pairings.</p>

    <p class="text-gray-300">Shacham [49] proposed pairings  <span class="math">e: \\mathbb{G}_1 \\times E[n] \\to \\mathbb{G}_T</span> , subsequently named Type 4 pairings. These pairings have the distinguishing property that the Trace map is an efficiently-computable homomorphism from E[n] onto  <span class="math">\\mathbb{G}_1</span>  with kernel  <span class="math">\\mathbb{G}_2</span> . Furthermore, hashing onto E[n] is relatively efficient [16].</p>

    <h2 id="sec-3" class="text-2xl font-bold">3. Elliptic curves with embedding degree one</h2>

    <p class="text-gray-300">For the sake of concreteness, we will only consider a particular trace-2 elliptic curve from [38] in this paper. Elliptic curves with embedding degree one and having trace different from 2 can be generated using the complex multiplication method [14, 33].</p>

    <p class="text-gray-300">Let p be a prime of the form</p>

    <p class="text-gray-300">(4)
<span class="math">$p = A^2 + 1, \\text{ where } A \\equiv 2 \\pmod{4};</span>$</p>

    <p class="text-gray-300">note that  <span class="math">p \\equiv 1 \\pmod{4}</span> . Suppose also that A = hn where  <span class="math">n \\equiv 3 \\pmod{4}</span>  is prime. We assume that p does not have any special properties such as having a sparse binary representation. This is done in order to ensure that the discrete logarithm problem in  <span class="math">\\mathbb{F}_p</span>  does not succumb to variants of the special number field sieve [44]. Then, assuming that the NFS cannot exploit the property of p-1 being a perfect square (cf. §3.3), the fastest algorithm known for computing discrete logarithms in  <span class="math">\\mathbb{F}_p</span>  has running time  <span class="math">L_p[\\frac{1}{3}, \\left(\\frac{64}{9}\\right)^{1/3}]</span> .</p>

    <p class="text-gray-300">Consider the elliptic curve</p>

    <p class="text-gray-300">(5)
<span class="math">$E: Y^2 = X^3 - 4X \\text{ over } \\mathbb{F}_p.</span>$</p>

    <p class="text-gray-300">Then, as shown in [38],  <span class="math">\\#E(\\mathbb{F}_p) = p-1</span>  so E is an ordinary curve with trace 2. Furthermore,  <span class="math">E(\\mathbb{F}_p) \\cong \\mathbb{Z}_A \\oplus \\mathbb{Z}_A</span>  so  <span class="math">E[n] \\subseteq E(\\mathbb{F}_p)</span>  and  <span class="math">E(\\mathbb{F}_p)</span>  has embedding degree k=1 with respect to n. The endomorphism ring of E is  <span class="math">\\mathbb{Z}[i]</span> , the complex number i being identified with the degree-one endomorphism  <span class="math">\\psi</span> :</p>

    <p class="text-gray-300">(6)
<span class="math">$\\psi: (x,y) \\mapsto (-x,Ay).</span>$</p>

    <p class="text-gray-300">The map  <span class="math">\\psi</span>  is a distortion map on E[n]. In other words, if  <span class="math">P \\in E[n] \\setminus \\{\\infty\\}</span>  then  <span class="math">\\psi(P) \\notin \\langle P \\rangle</span> . Thus, for any  <span class="math">P \\in E[n] \\setminus \\{\\infty\\}</span> , the pair of points  <span class="math">(P, \\psi(P))</span>  generate E[n]. The p-th power Frobenius  <span class="math">\\pi</span>  satisfies  <span class="math">\\pi(P) = (1 + Ai)P</span>  for all  <span class="math">P \\in E(\\overline{\\mathbb{F}}_p)</span> .</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;1&lt;/sup&gt;When we say that &quot;hashing onto a group is not known to be efficient&quot; we mean in such a way that discrete logarithms of hash values are difficult to compute.</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;2&lt;/sup&gt;If  <span class="math">n \\equiv 1 \\pmod{4}</span> , then  <span class="math">\\psi</span>  is a distortion map for all but two of the n+1 order-n subgroups of E[n]. These two exceptions were overlooked in Theorem 3 of [38].</p>

    <p class="text-gray-300">The existence of an efficiently-computable distortion map on E[n] means that the decisional Diffie-Hellman (DDH) problem in any order-n subgroup of E[n] is easy. Recall that the DDH problem in an order-n group  <span class="math">\\langle P \\rangle</span>  is the following: given P, A = aP, B = bP and Q, where  <span class="math">a, b \\in_R [0, n-1]</span>  and either Q = abP or Q = cP for  <span class="math">c \\in_R [0, n-1]</span> , decide whether or not Q = abP. The Weil pairing can be used to solve DDH efficiently since if Q = abP then  <span class="math">w_n(P,Q) = w_n(A,B)</span> , whereas if Q = cP then  <span class="math">w_n(P,Q) \\neq w_n(A,B)</span>  with overwhelming probability.</p>

    <p class="text-gray-300">3.1. Subgroup membership testing. Let  <span class="math">P, Q \\in E[n] \\setminus \\{\\infty\\}</span> . In cryptographic protocols it is usually necessary to have an efficient method for testing whether  <span class="math">Q \\in \\langle P \\rangle</span> . The alternation and non-degeneracy properties of the Weil pairing imply that  <span class="math">Q \\in \\langle P \\rangle</span>  if and only if  <span class="math">w_n(P,Q) = 1</span> . Thus, subgroup membership testing can be done using the Weil pairing.</p>

    <p class="text-gray-300">Subgroup membership testing cannot in general be done in the same manner using the Tate pairing. Indeed, it is no longer guaranteed that  <span class="math">t_n(P, P) = 1</span> . The following result was stated in Remark 2 of [33]. We include a self-contained proof for completeness.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let E be the trace-2 elliptic curve defined in (5). Then  <span class="math">t_n(P, \\psi(P)) = 1</span>  for all  <span class="math">P \\in E[n]</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">P \\in E[n] \\setminus \\{\\infty\\}</span> . By Theorem X.1.1 of [50], we have  <span class="math">w_n(\\pi(Q) - Q, iP) = \\beta^{p-1}</span> , where  <span class="math">Q \\in E(\\overline{\\mathbb{F}}_p)</span>  with nQ = P, and  <span class="math">\\beta \\in \\overline{\\mathbb{F}}_p</span>  with  <span class="math">\\beta^n = \\hat{t}_n(iP, P)</span>  where  <span class="math">\\hat{t}_n</span>  is the unreduced Tate pairing. Now,  <span class="math">\\beta^{p-1} = (\\beta^n)^{(p-1)/n} = \\hat{t}_n(iP, P)^{(p-1)/n} = t_n(iP, P)</span> . And,  <span class="math">\\pi(Q) - Q = (1 + Ai)Q - Q = hniQ = hiP</span> . Thus,  <span class="math">t_n(iP, P) = w_n(hiP, iP) = w_n(iP, iP)^h = 1</span> .</p>

    <p class="text-gray-300">Now, the dual of the endomorphism i is -i. Hence, by part 3 of Theorem IX.9 of [24], we have  <span class="math">1 = t_n(iP, P) = t_n(P, -iP) = t_n(P, iP)^{-1}</span> , whence  <span class="math">t_n(P, iP) = t_n(P, \\psi(P)) = 1</span> .</p>

    <p class="text-gray-300">Non-degeneracy of the Tate pairing immediately gives the following result which yields a method for subgroup membership testing using the Tate pairing.</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> Let E be the trace-2 elliptic curve defined in (5). Let  <span class="math">P,Q \\in E[n] \\setminus \\{\\infty\\}</span> . Then  <span class="math">Q \\in \\langle P \\rangle</span>  if and only if  <span class="math">t_n(P, \\psi(Q)) = 1</span> .</p>

    <p class="text-gray-300">Non-degeneracy of the Tate pairing also gives the following result.</p>

    <p class="text-gray-300"><strong>Corollary 2.</strong> Let E be the trace-2 elliptic curve defined in (5). Then  <span class="math">t_n(P, P) \\neq 1</span>  for all  <span class="math">P \\in E[n] \\setminus \\{\\infty\\}</span> .</p>

    <p class="text-gray-300">3.2. <strong>Pairings.</strong> For the trace-2 elliptic curve E defined in (5), there are no analogues to  <span class="math">\\mathbb{G}_1</span>  and the Trace-0 group  <span class="math">\\mathbb{G}_2</span>  in the case of Type 2 and Type 3 pairings (see §2.3). Indeed, there is no natural way of distinguishing any order-n subgroup of E[n] from the other order-n subgroups.</p>

    <p class="text-gray-300">There are several types of pairings on order-n groups that can be defined from the Weil pairing (1) and the Tate pairing (3). We present three kinds of pairings, called Type A, Type B and Type C, and discuss their properties in §§4-6. In all these pairings,  <span class="math">\\mathbb{G}_T</span>  denotes the order-n subgroup of  <span class="math">\\mathbb{F}_p^*</span> . Type A pairings are bilinear pairings from  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_1</span>  to  <span class="math">\\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_1</span>  is an arbitrary order-n subgroup of  <span class="math">E(\\mathbb{F}_p)</span> . Type B pairings are bilinear pairings from</p>

    <p class="text-gray-300"><span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_2</span>  to  <span class="math">\\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_1</span>  is an arbitrary order-n subgroup of  <span class="math">E(\\mathbb{F}_p)</span>  and  <span class="math">\\mathbb{G}_2 = E[n]</span> . Type C pairings are bilinear pairings from  <span class="math">\\mathbb{G}_2 \\times \\mathbb{G}_2</span>  to  <span class="math">\\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_2 = E[n]</span> . Note that no efficient method is known for efficiently and reversibly embedding binary strings from  <span class="math">\\{0,1\\}^m</span>  (for some m) in  <span class="math">\\mathbb{G}_T</span> .</p>

    <p class="text-gray-300">3.3. <strong>Applicability of the SNFS.</strong> Let d&gt;1 and  <span class="math">m=\\lfloor p^{1/d}\\rfloor</span> . Suppose also that  <span class="math">p&gt;2^{d^2}</span> . Let  <span class="math">f(t)=t^d+f_{d-1}t^{d-1}+\\cdots+f_1t+f_0\\in\\mathbb{Z}[t]</span> , where  <span class="math">m^d+\\sum_{i=0}^{d-1}f_im^i</span>  is the base-m representation of p. Then f is irreducible over  <span class="math">\\mathbb{Z}</span>  and  <span class="math">f(m)=p\\equiv 0\\pmod p</span> . Let  <span class="math">\\alpha\\in\\mathbb{C}</span>  be a root of f. The NFS for computing discrete logarithms in  <span class="math">\\mathbb{F}_p</span>  [28, 43] seeks to find pairs of integers (a,b) with  <span class="math">0\\leq b&lt; B</span>  and  <span class="math">0\\leq |a|&lt; B</span>  such that</p>

    <p class="text-gray-300"><span class="math">$T = (a - bm) \\cdot b^{d} f(a/b) = (a - bm)(a^{d} + f_{t-1}a^{t-1}b + \\dots + f_{1}ab^{t-1} + f_{0}b^{t})</span>$</p>

    <p class="text-gray-300">is smooth. Note that  <span class="math">T \\approx (d+1)B^{d+1}p^{2/d}</span> . The optimal choices for B and d yield an algorithm with running time  <span class="math">L_p\\left[\\frac{1}{3},\\left(\\frac{64}{9}\\right)^{1/3}\\right]</span> .</p>

    <p class="text-gray-300">In the special NFS (SNFS), p has a special form, e.g.,  <span class="math">p = r^e \\pm s</span>  with small r and s. The special form of p yields a monic irreducible polynomial f with small coefficients. Consequently, the bound on T becomes  <span class="math">T \\approx (d+1)B^{d+1}p^{1/d}</span> , resulting in an algorithm with a significantly faster running time  <span class="math">L_p\\left[\\frac{1}{3},\\left(\\frac{32}{9}\\right)^{1/3}\\right]</span> .</p>

    <p class="text-gray-300">For the case  <span class="math">p = A^2 + 1</span> , one could take d = 2 and  <span class="math">f(t) = t^2 + 1</span> . But then  <span class="math">T \\approx 3B^3p^{1/2}</span> , which is too large to be effective. A second strategy to exploit the structure of p is to let  <span class="math">m = \\lfloor A^{1/d} \\rfloor</span>  and  <span class="math">g(t) = t^d + g_{d-1}t^{d-1} + \\cdots + g_1t + g_0</span> , where  <span class="math">m^d + \\sum_{i=0}^{d-1} g_i m^i</span>  is the base-m representation of A. Then, one can take  <span class="math">f(t) = g^2(t) + 1</span>  and hope that f is irreducible over  <span class="math">\\mathbb{Z}</span> ; note that f(m) = p and  <span class="math">\\deg(f) = 2d</span> . However, the coefficients  <span class="math">f_i</span>  of f satisfy  <span class="math">f_i \\approx m^2</span> . Indeed, by taking  <span class="math">\\tilde{m} = \\lfloor p^{1/2d} \\rfloor \\approx \\lfloor A^{1/d} \\rfloor</span> , one could have used the method in the original NFS to obtain a degree-2d irreducible polynomial  <span class="math">\\tilde{f}</span>  with  <span class="math">\\tilde{f}(\\tilde{m}) = p</span>  and coefficients  <span class="math">\\tilde{f}_i \\approx \\tilde{m}</span> . Thus, this second strategy also fails.</p>

    <p class="text-gray-300">An outstanding open problem is to determine whether the special structure of  <span class="math">p = A^2 + 1</span>  can be exploited to devise an algorithm for computing discrete logarithms in  <span class="math">\\mathbb{F}_p</span>  that has running time significantly smaller than  <span class="math">L_p\\left[\\frac{1}{3},\\left(\\frac{64}{9}\\right)^{1/3}\\right]</span> . If this can be accomplished, then the keylength and efficiency estimates in §7 will have to be revised accordingly.</p>

    <p class="text-gray-300">4.1. <strong>The pairings.</strong> Let  <span class="math">\\mathbb{G}_1</span>  be an arbitrary order-n subgroup of  <span class="math">E(\\mathbb{F}_p)</span> .</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> The Type A Weil pairing  <span class="math">w_A : \\mathbb{G}_1 \\times \\mathbb{G}_1 \\to \\mathbb{G}_T</span>  is</p>

    <p class="text-gray-300">(7)
<span class="math">$w_A(P,Q) = w_n(P,\\psi(Q)) = (-1)^n \\frac{f_{n,P}(\\psi(Q))}{f_{n,\\psi(Q)}(P)},</span>$</p>

    <p class="text-gray-300">where  <span class="math">P, Q \\neq \\infty</span>  and  <span class="math">f_{n,P}</span>  and  <span class="math">f_{n,\\psi(Q)}</span>  are normalized Miller functions. Furthermore,  <span class="math">w_A(P, \\infty) = w_A(\\infty, P) = 1</span>  for all  <span class="math">P \\in \\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">The pairing  <span class="math">w_A</span>  is non-degenerate since  <span class="math">\\psi(Q) \\notin \\langle P \\rangle</span> . Note that the Miller function computations in (7) never fail since  <span class="math">\\psi(Q) \\notin \\langle P \\rangle</span>  and  <span class="math">P \\notin \\langle \\psi(Q) \\rangle</span> .</p>

    <p class="text-gray-300">Since  <span class="math">t_n(P, P) \\neq 1</span> , the Tate pairing restricted to  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_1</span>  is a non-degenerate pairing. However, as mentioned in Remark 2, the Miller function computation when computing  <span class="math">t_n(P, Q)</span>  using (3) can fail since  <span class="math">Q \\in \\langle P \\rangle</span> . To circumvent this possible failure, we select  <span class="math">R = \\psi(P)</span>  in (2). Then, since  <span class="math">f_{n,P}(\\psi(P))^{(p-1)/n} = 1</span>  when  <span class="math">f_{n,P}</span>  is normalized, we obtain the following Type A Tate pairing.</p>

    <p class="text-gray-300"><strong>Definition 4.</strong> The Type A Tate pairing  <span class="math">t_A : \\mathbb{G}_1 \\times \\mathbb{G}_1 \\to \\mathbb{G}_T</span>  is</p>

    <p class="text-gray-300">(8)
<span class="math">$t_A(P,Q) = (f_{n,P}(Q + \\psi(P)))^{(p-1)/n},</span>$</p>

    <p class="text-gray-300">where  <span class="math">f_{n,P}</span>  is normalized.</p>

    <p class="text-gray-300">The Type A pairings  <span class="math">w_A</span>  and  <span class="math">t_A</span>  are symmetric in the sense that they are defined on  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_1</span>  where  <span class="math">\\mathbb{G}_1</span>  is a cyclic group of order n. However, these pairings differ from Type 1 symmetric pairings in that no efficient method is known for hashing onto  <span class="math">\\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">4.2. <strong>Protocols.</strong> Let  <span class="math">e_A : \\mathbb{G}_1 \\times \\mathbb{G}_1 \\to \\mathbb{G}_T</span>  denote the Type A Weil pairing  <span class="math">w_A</span>  or the Type A Tate pairing  <span class="math">t_A</span> . The Type A pairing setting provides a protocol designer the same capabilities as in the Type 1 setting provided there is no need of hashing onto  <span class="math">\\mathbb{G}_1</span>  (also known as a map-to-point function). Recall that such a hash function is usually modelled as a random oracle in the security reduction. Hence, all protocols that are originally described in the Type 1 setting and do not require the random oracle assumption for such a map-to-point function can be instantiated in the Type A setting.</p>

    <p class="text-gray-300">Examples of protocols that can be implemented in the Type A setting include Joux's three-party key agreement scheme [34] and Waters' IBE and signature schemes [53]. More generally, all so-called standard model protocols in the Type 1 setting can be implemented in the Type A setting without any difficulty. Note that it is straightforward to cast the corresponding hardness assumptions and security theorems and proofs in the Type A setting. For example, the bilinear Diffie-Hellman problem in the Type A setting and its decisional version can be defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 5</strong> (BDH-A). Bilinear Diffie-Hellman problem in  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_T)</span> : Given P, aP, bP,  <span class="math">cP \\in \\mathbb{G}_1</span> , where  <span class="math">a, b, c \\in_R [1, n-1]</span> , compute  <span class="math">e_A(P, P)^{abc}</span> .</p>

    <p class="text-gray-300"><strong>Definition 6</strong> (DBDH-A). Decisional Bilinear Diffie-Hellman problem in  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_T)</span> : Given  <span class="math">P, aP, bP, cP \\in \\mathbb{G}_1</span> , where  <span class="math">a, b, c \\in_R [1, n-1]</span>  and  <span class="math">Z \\in \\mathbb{G}_T</span> , decide whether  <span class="math">Z = e_A(P, P)^{abc}</span>  or Z is a random element in  <span class="math">\\mathbb{G}_T</span> .</p>

    <p class="text-gray-300">4.2.1. BLS-1 signature scheme. To illustrate the problem of implementing protocols that employ a map-to-point function onto  <span class="math">\\mathbb{G}_1</span> , we recall the Boneh-Lynn-Shacham (BLS) signature scheme [13] in the Type 1 setting.</p>

    <p class="text-gray-300">Let  <span class="math">e_1: \\mathbb{G}_1 \\times \\mathbb{G}_1 \\to \\mathbb{G}_T</span>  be a Type 1 pairing where  <span class="math">\\mathbb{G}_1 = \\langle P \\rangle</span> . Let  <span class="math">H: \\{0,1\\}^* \\to \\mathbb{G}_1</span>  be a hash function. The public parameters are  <span class="math">e_1</span> , P and H.</p>

    <p class="text-gray-300">Alice's private key is an integer  <span class="math">a \\in_R [1, n-1]</span> , while her public key is A = aP. To sign a message  <span class="math">m \\in \\{0, 1\\}^*</span> , Alice computes M = H(m) and  <span class="math">\\sigma = aM</span> . Her signature on m is  <span class="math">\\sigma</span> . To verify the signed message  <span class="math">(m, \\sigma)</span> , Bob computes M = H(m), verifies that  <span class="math">\\sigma \\in \\langle \\mathbb{G}_1 \\rangle</span> , and accepts if and only if  <span class="math">e_1(P, \\sigma) = e_1(A, M)</span> .</p>

    <p class="text-gray-300">Observe that the BLS signature scheme <em>cannot</em> be instantiated in the Type A setting simply because there is no known efficient method for hashing onto  <span class="math">\\mathbb{G}_1</span> . A similar obstruction is present for several other protocols including the original Boneh-Franklin IBE scheme [11].</p>

    <p class="text-gray-300">5.1. <strong>The pairings.</strong> Let  <span class="math">\\mathbb{G}_1</span>  be an arbitrary order-n subgroup of  <span class="math">E(\\mathbb{F}_p)</span>  and let  <span class="math">\\mathbb{G}_2 = E[n]</span> . Then we have the following restriction of the Weil or Tate pairings:</p>

    <p class="text-gray-300"><span class="math">$(9) e_B: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T.</span>$</p>

    <p class="text-gray-300">We can now hash to  <span class="math">\\mathbb{G}_2</span>  — by hashing to a random point in  <span class="math">E(\\mathbb{F}_p)</span>  and then multiplying the resulting point by the cofactor A/n = h. However, as before, we cannot hash to any particular order-n subgroup of  <span class="math">\\mathbb{G}_2</span> . We will henceforth assume that the group  <span class="math">\\mathbb{G}_1</span>  is the same as the one in the definition of  <span class="math">e_A</span> ; thus the restriction of  <span class="math">e_B</span>  to  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_1</span>  is equal to  <span class="math">e_A</span> .</p>

    <p class="text-gray-300">Since  <span class="math">\\mathbb{G}_2</span>  is not an order-n group,  <span class="math">e_B</span>  is not a Type 1, 2 or 3 pairing. The pairing  <span class="math">e_B</span>  is reminiscent of a Type 4 pairing (see §2.3). However, unlike the case of Type 4 pairings, no efficiently-computable homomorphism is known from  <span class="math">\\mathbb{G}_2</span>  onto  <span class="math">\\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">Remark 3. (failure of a Miller function computation) The Type B Weil pairing</p>

    <p class="text-gray-300">(10)
<span class="math">$w_B(P,Q) = (-1)^n \\frac{f_{n,P}(Q)}{f_{n,Q}(P)}</span>$</p>

    <p class="text-gray-300">is degenerate if  <span class="math">Q \\in \\langle P \\rangle</span> . Moreover, the computation of (10) can fail when  <span class="math">Q \\in \\langle P \\rangle</span>  or when  <span class="math">P \\in \\langle Q \\rangle</span>  (both these conditions are implied by  <span class="math">Q \\in \\langle P \\rangle</span> ). Thus protocols that use the Type B pairing  <span class="math">w_B</span>  should ensure that  <span class="math">Q \\notin \\langle P \\rangle</span> , or that this occurs only with negligible probability.</p>

    <p class="text-gray-300">The Type B Tate pairing</p>

    <p class="text-gray-300">(11)
<span class="math">$t_B(P,Q) = (f_{n,P}(Q))^{(p-1)/n}</span>$</p>

    <p class="text-gray-300">is degenerate if  <span class="math">Q \\in \\langle \\psi(P) \\rangle</span> . Moreover, the computation of (11) can fail when  <span class="math">Q \\in \\langle P \\rangle</span> . Thus, protocols that use the Type B pairing  <span class="math">t_B</span>  should ensure that  <span class="math">Q \\notin \\langle P \\rangle</span>  and  <span class="math">Q \\notin \\langle \\psi(P) \\rangle</span> , or that this occurs only with negligible probability.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">5.2. Protocols.</h3>

    <p class="text-gray-300">5.2.1. BLS-B signature scheme. Let E be an elliptic curve with embedding degree one, and let  <span class="math">e_B : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  be a Type B pairing where  <span class="math">\\mathbb{G}_1 = \\langle P \\rangle</span> . Let  <span class="math">H : \\{0,1\\}^* \\to E[n]</span>  be a hash function. The public parameters are E, P,  <span class="math">e_B</span>  and H.</p>

    <p class="text-gray-300">Alice's private key is an integer  <span class="math">a \\in_R [1, n-1]</span> , while her public key is A = aP. To sign a message m, Alice computes M = H(m) and  <span class="math">\\sigma = aM</span> . Her signature on m is  <span class="math">\\sigma</span> . To verify</p>

    <p class="text-gray-300">the signed message  <span class="math">(m, \\sigma)</span> , Bob computes M = H(m), verifies that  <span class="math">\\sigma \\in \\langle M \\rangle</span> , and accepts if and only if  <span class="math">e_B(P, \\sigma) = e_B(A, M)</span> .</p>

    <p class="text-gray-300">Correctness of the verification algorithm follows because</p>

    <p class="text-gray-300"><span class="math">$e_B(P, \\sigma) = e_B(P, aM) = e_B(aP, M) = e_B(A, M).</span>$</p>

    <p class="text-gray-300">Note that since M is randomly selected from E[n], the probability that  <span class="math">M \\in \\langle A \\rangle</span>  or  <span class="math">M \\in \\langle \\psi(A) \\rangle</span>  is negligible (cf. Remark 3).</p>

    <p class="text-gray-300">Recall that the Diffie-Hellman problem (DHP) in a cyclic group  <span class="math">\\mathbb{G}_1 = \\langle P \\rangle</span>  is the following: Given P, A = aP where  <span class="math">a \\in_R [1, n-1]</span> , and  <span class="math">M \\in_R \\mathbb{G}_1</span> , compute  <span class="math">\\sigma = aM</span> . Security of BLS-B can be proven under the assumption that the following variant of DHP is intractable.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> The DHP-B problem is the following: Given  <span class="math">P \\in \\mathbb{G}_1</span> , A = aP where  <span class="math">a \\in_R [1, n-1]</span> , and  <span class="math">M \\in_R E[n]</span> , compute  <span class="math">\\sigma = aM</span> .</p>

    <p class="text-gray-300">It is easy to see that DHP polynomial-time reduces to DHP-B. Namely, suppose we are given an instance (P, A, M) of DHP and a DHP-B oracle. We compute  <span class="math">Q = \\psi(P)</span>  and M' = M + rQ where  <span class="math">r \\in_R [0, n-1]</span> . We present (P, A, M') to the oracle and obtain  <span class="math">\\sigma&#x27; = aM&#x27;</span> . Since</p>

    <p class="text-gray-300"><span class="math">$\\sigma&#x27; = aM&#x27; = a(M + rQ) = aM + r(aQ) = \\sigma + r\\psi(A),</span>$</p>

    <p class="text-gray-300">we can efficiently compute the DHP solution  <span class="math">\\sigma = \\sigma&#x27; - r\\psi(A)</span> .</p>

    <p class="text-gray-300">Security of BLS-B can be proven with respect to intractability of DHP-B. The following result omits the tightness gap in the reduction.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Suppose that the DHP-B problem is intractable and H is a random oracle. Then BLS-B is existentially unforgeable against adaptive chosen-message attacks.</p>

    <p class="text-gray-300">Proof. Suppose we are given a DHP-B instance  <span class="math">(P, A, M^*)</span>  and need to compute  <span class="math">\\sigma^* = aM^*</span>  where A = aP. We compute  <span class="math">Q = \\psi(P)</span>  and  <span class="math">B = \\psi(A) = aQ</span> , where  <span class="math">\\psi</span>  is the distortion map (6). We then run the forger with input (P, A). The forger makes queries to a random oracle H and to a signing oracle. We assume that the forger always queries H with a message m before it queries the signing oracle with m. We also assume that the forger queries H with m before producing its forgery  <span class="math">(m, \\sigma)</span> . We respond to all but one randomly selected hash query on m with  <span class="math">M = H(m) = r_1P + r_2Q</span>  where  <span class="math">r_1, r_2 \\in_R [0, n-1]</span> ; note that M is indeed distributed uniformly at random in E[n], so the response to the hash query is valid. For the randomly selected hash query  <span class="math">m^*</span> , we respond with  <span class="math">H(m^*) = M^*</span> . We respond to signing queries on messages  <span class="math">m \\neq m^*</span>  with  <span class="math">\\sigma = r_1A + r_2B</span> . This is a valid signature since</p>

    <p class="text-gray-300"><span class="math">$\\sigma = r_1 A + r_2 B = r_1(aP) + r_2(aQ) = a(r_1 P + r_2 Q) = aH(m) = aM.</span>$</p>

    <p class="text-gray-300">If the forger asks for the signature on  <span class="math">m^*</span> , we abort. We also abort if the forger does not output a valid signature on  <span class="math">m^*</span> . Otherwise, if the forger outputs a valid signed message  <span class="math">(m^*, \\sigma^*)</span> , then  <span class="math">\\sigma^*</span>  is the solution to the DHP-B challenge  <span class="math">(P, A, M^*)</span> .</p>

    <p class="text-gray-300">Note that in the Type B setting we can hash onto E[n] but not onto  <span class="math">\\mathbb{G}_1</span> . Hence, protocols that require a map-to-point function such that at most one argument of the pairing function</p>

    <p class="text-gray-300">is expressed in terms of such a point can be instantiated in the Type B pairing setting. Apart from the BLS signature scheme, some other prominent examples are the Boneh-Franklin IBE scheme [11] and the Boneh-Gentry-Lynn-Shacham aggregate signature scheme [12]. Note also that the protocols that can be instantiated in the Type A setting can be instantiated in the Type B setting without any difficulty.</p>

    <p class="text-gray-300">The main difference between the Type A and the Type B settings is that E[n] is not a cyclic group of prime order. This necessitates an appropriate modification in the underlying hardness assumption as well as the protocol description and its security reduction. We have already illustrated this in the context of the BLS signature scheme. Next we briefly describe the bilinear Diffie-Hellman (BDH) problem in the Type B setting and its relation with the corresponding problem in the Type A setting.</p>

    <p class="text-gray-300">5.2.2. BDH problem in Types A and B.</p>

    <p class="text-gray-300"><strong>Definition 8</strong> (BDH-B). Bilinear Diffie-Hellman problem in  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T)</span> : Given P, aP,  <span class="math">bP \\in \\mathbb{G}_1</span> , where  <span class="math">a, b \\in_R [1, n-1]</span> , and  <span class="math">R \\in_R \\mathbb{G}_2</span> , compute  <span class="math">e_B(P, R)^{ab}</span> .</p>

    <p class="text-gray-300">It is easy to see that the BDH problem in the Type A setting (BDH-A) polynomial-time reduces to BDH-B. Namely, suppose we are given an instance (P, aP, bP, cP) of BDH-A and access to a BDH-B oracle. We compute  <span class="math">Q = \\psi(P)</span>  and  <span class="math">B = \\psi(bP) = bQ</span> . We further compute R = cP + rQ where  <span class="math">r \\in_R [1, n-1]</span> . We run the BDH-B oracle with input (P, aP, bP, R). The oracle returns  <span class="math">e_B(P, R)^{ab} = e_A(P, P)^{abc}e_B(aP, bQ)^r</span>  from which one can easily extract the BDH-A solution, namely  <span class="math">e_A(P, P)^{abc}</span> .</p>

    <p class="text-gray-300">5.2.3. Sakai-Oghishi-Kasahara id-based key agreement. We recall the Sakai-Oghishi-Kasahara id-based Non-Interactive Key Agreement (SOK-NIKA) scheme in the Type 1 setting [42].</p>

    <p class="text-gray-300">Let  <span class="math">e_1 : \\mathbb{G}_1 \\times \\mathbb{G}_1 \\to \\mathbb{G}_T</span>  be a Type 1 pairing where  <span class="math">\\mathbb{G}_1 = \\langle P \\rangle</span> . Let  <span class="math">H : \\{0, 1\\}^* \\to \\mathbb{G}_1</span>  be a hash function. The key generation center (KGC) chooses her master secret  <span class="math">s \\in_R [1, n-1]</span>  and the corresponding public parameters are  <span class="math">e_1</span> , P, sP and H.</p>

    <p class="text-gray-300">An entity with identity id obtains her corresponding private key from the KGC as  <span class="math">d_{id} = sQ_{id}</span>  where  <span class="math">Q_{id} = H(id)</span> . Two parties having identities respectively id and id' can compute a shared secret without any interaction as follows. The party with identity id computes  <span class="math">K = e_1(d_{id}, H(id&#x27;))</span> , whereas the party with identity id' computes  <span class="math">K&#x27; = e_1(d_{id&#x27;}, H(id))</span> . Both parties compute the same shared secret because</p>

    <p class="text-gray-300"><span class="math">$K = e_1(d_{\\mathsf{id}}, H(\\mathsf{id}&#x27;)) = e_1(sQ_{\\mathsf{id}}, Q_{\\mathsf{id}&#x27;}) = e_1(Q_{\\mathsf{id}}, sQ_{\\mathsf{id}&#x27;}) = e_1(H(\\mathsf{id}), d_{\\mathsf{id}&#x27;}) = e_1(d_{\\mathsf{id}&#x27;}, H(\\mathsf{id})) = K&#x27;.</span>$</p>

    <p class="text-gray-300">Note that SOK-NIKA cannot be implemented in the Type B (or Type A) setting because there is no known way to hash onto a fixed order-n group  <span class="math">\\mathbb{G}_1</span> .</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">6. Type C pairings</h4>

    <p class="text-gray-300">6.1. The pairings. Let  <span class="math">\\mathbb{G}_2 = E[n]</span> . Then the full Weil and Tate pairings defined in (1) and (3) are bilinear pairings from  <span class="math">\\mathbb{G}_2 \\times \\mathbb{G}_2</span>  to  <span class="math">\\mathbb{G}_T</span> . We say that these pairings are of Type C and denote them by  <span class="math">e_C</span> . Note that one can efficiently hash onto  <span class="math">\\mathbb{G}_2</span> . Hence, protocols that require a map-to-point function for either of the two arguments of the pairing function can</p>

    <p class="text-gray-300">be considered for implementation with Type C pairings. For any fixed order-n subgroup  <span class="math">\\mathbb{G}_1</span> , the restriction of  <span class="math">e_C</span>  to  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_1</span>  gives the Type A pairing  <span class="math">e_A</span> . Similarly, the restriction of  <span class="math">e_C</span>  to  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_2</span>  gives the Type B pairing  <span class="math">e_B</span> .</p>

    <p class="text-gray-300">6.2.1. Sakai-Oghishi-Kasahara id-based key agreement in Type C. Let  <span class="math">e_C : \\mathbb{G}_2 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  be a Type C pairing, and let  <span class="math">P \\in \\mathbb{G}_2</span> . Let  <span class="math">H : \\{0,1\\}^* \\to \\mathbb{G}_2</span>  be a hash function. The key generation center (KGC) chooses her master secret  <span class="math">s \\in_R [1, n-1]</span>  and the corresponding public parameters are  <span class="math">e_C</span> , P, sP and H.</p>

    <p class="text-gray-300">An entity with identity id obtains her corresponding private key from the KGC as  <span class="math">d_{id} = sQ_{id}</span>  where  <span class="math">Q_{id} = H(id)</span> . Two parties having identities respectively id and id' can compute a shared secret without any interaction as follows. Suppose that id is lexicographically smaller than id'. The party with identity id computes  <span class="math">K = e_C(d_{id}, H(id&#x27;))</span> , whereas the party with identity id' computes  <span class="math">K&#x27; = e_C(H(id), d_{id&#x27;})</span> . Both parties compute the same shared secret because</p>

    <p class="text-gray-300"><span class="math">$K = e_C(d_{\\mathsf{id}}, H(\\mathsf{id}&#x27;)) = e_C(sQ_{\\mathsf{id}}, Q_{\\mathsf{id}&#x27;}) = e_C(Q_{\\mathsf{id}}, sQ_{\\mathsf{id}&#x27;}) = e_C(H(\\mathsf{id}), d_{\\mathsf{id}&#x27;}) = K&#x27;.</span>$</p>

    <p class="text-gray-300">A Key Derivation Function (KDF)  <span class="math">\\tilde{H}: \\mathbb{G}_T \\to \\{0,1\\}^k</span>  can be applied to the shared secret to produce a k-bit secret key.</p>

    <p class="text-gray-300">In the Type 1 pairing setting it has been shown [23, 40] that when H and  <span class="math">\\tilde{H}</span>  are modeled as random oracles, the security of SOK-NIKA is based on the hardness of BDH in the Type 1 setting. The original security argument can be easily modified for the above variant whence the security depends on the following version of the BDH problem in the Type C setting.</p>

    <p class="text-gray-300"><strong>Definition 9</strong> (BDH-C). Bilinear Diffie-Hellman problem in  <span class="math">(\\mathbb{G}_2, \\mathbb{G}_T)</span> : Given  <span class="math">P \\in \\mathbb{G}_2</span> , Q = aP where  <span class="math">a \\in_R [1, n-1]</span> , and  <span class="math">R, S \\in_R \\mathbb{G}_2</span> , compute  <span class="math">e_C(R, S)^a</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\tilde{H}</span>  is not included in the protocol description, then one can argue the security of SOK-NIKA based on the following version of the decisional Bilinear Diffie-Hellman problem in the Type C setting.</p>

    <p class="text-gray-300"><strong>Definition 10</strong> (DBDH-C). Decisional Bilinear Diffie-Hellman problem in  <span class="math">(\\mathbb{G}_2, \\mathbb{G}_T)</span> : Given  <span class="math">P \\in \\mathbb{G}_2</span> , Q = aP where  <span class="math">a \\in_R [1, n-1]</span> ,  <span class="math">R, S \\in_R \\mathbb{G}_2</span> , and  <span class="math">Z \\in \\mathbb{G}_T</span> , decide whether  <span class="math">Z = e_C(R, S)^a</span>  or Z is a random element in  <span class="math">\\mathbb{G}_T</span> .</p>

    <p class="text-gray-300">As in the case of variants of the BDH problem, it is easy to see that DBDH-A polynomial-time reduces to DBDH-C. Namely, suppose we are given an instance (P,aP,bP,cP,Z) of DBDH-A and access to a DBDH-C oracle. We compute  <span class="math">Q=\\psi(P),\\ A=\\psi(aP)=aQ,\\ B=\\psi(bP)=bQ,</span>  and  <span class="math">C=\\psi(cP)=cQ.</span>  We further compute R=bP+rQ and S=cP+sQ where  <span class="math">r,s\\in_R[1,n-1]</span>  and  <span class="math">Z&#x27;=Z\\cdot e_C(bP,aQ)^s\\cdot e_C(aQ,cP)^r\\cdot e_C(aQ,Q)^{rs}</span> . We run the DBDH-C oracle with input (P,aP,R,S,Z') and return whatever bit the oracle returns. Clearly, when  <span class="math">Z=e_A(P,P)^{abc}</span>  then  <span class="math">Z&#x27;=e_C(R,S)^a</span> . On the other hand, if Z is a random element of  <span class="math">\\mathbb{G}_T</span>  then so is Z'.</p>

    <p class="text-gray-300">In the proof sketch below for the security of SOK-NIKA, we follow the IND-SK security model proposed in [40]. In this model the adversary is allowed to make H-oracle queries, key extraction queries on identities of its choice, shared key reveal queries on any pair of identities of its choice, and a challenge (Test) query on a pair of identities subject to the natural restriction that no key extraction query is made on the challenge identities, nor is there any shared-key reveal query on the pair of challenge identities. In response to the challenge query the adversary is given with equal probability either the shared key of the two challenge identities or a random element from the key space. IND-SK security is achieved if the adversary cannot distinguish between the two with probability significantly greater than  <span class="math">\\frac{1}{2}</span> . The following result omits the tightness gap in the reduction.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Suppose that the DBDH-C problem is intractable and H is a random oracle. Then SOK-NIKA is a secure key-agreement scheme in the IND-SK model.</p>

    <p class="text-gray-300">Proof. Suppose we are given a DBDH-C instance (P, A = aP, R, S, Z) and need to decide whether  <span class="math">Z = e_C(R, S)^a</span>  or Z is random. We compute  <span class="math">Q = \\psi(P)</span>  and  <span class="math">B = \\psi(A) = aQ</span> , where  <span class="math">\\psi</span>  is the distortion map (6). We then run the IND-SK adversary against SOK-NIKA with input (P, A). The adversary makes queries to a random oracle H as well as key extraction and shared-key reveal queries. We assume that the adversary always queries H with id before it queries for key-extraction or shared-key involving that identity. We respond to all but two randomly selected hash queries on id with  <span class="math">Q_{id} = H(id) = r_1P + r_2Q</span>  where  <span class="math">r_1, r_2 \\in_R [0, n-1]</span> ; note that  <span class="math">Q_{id}</span>  is indeed distributed uniformly at random in  <span class="math">\\mathbb{G}_2</span> , so the response to the hash query is valid. For the randomly selected hash query  <span class="math">\\mathrm{id}_1^*</span>  and  <span class="math">\\mathrm{id}_2^*</span> , we respond with  <span class="math">H(\\mathrm{id}_1^*) = R</span>  and  <span class="math">H(\\mathrm{id}_2^*) = S</span> . We respond to key-extraction queries on identity  <span class="math">\\mathrm{id} \\notin \\{\\mathrm{id}_1^*, \\mathrm{id}_2^*\\}</span>  with  <span class="math">d_{id} = r_1A + r_2B</span> . This is a valid private key for id since</p>

    <p class="text-gray-300"><span class="math">$d_{\\rm id} = r_1 A + r_2 B = r_1(aP) + r_2(aQ) = a(r_1 P + r_2 Q) = aH({\\rm id}) = aQ_{\\rm id}.</span>$</p>

    <p class="text-gray-300">We abort if  <span class="math">id \\in \\{id_1^*, id_2^*\\}</span> .</p>

    <p class="text-gray-300">Next, suppose that the adversary asks for the shared key for  <span class="math">(id_i, id_j)</span> . We abort if both of them are from  <span class="math">\\{id_1^*, id_2^*\\}</span> . If not, let's assume without loss of generality, that  <span class="math">id_i \\notin \\{id_1^*, id_2^*\\}</span> . We return  <span class="math">e_C(d_{id_i}, H(id_j))</span>  as the shared key. When the adversary makes the challenge query we abort if the challenge identities are not  <span class="math">\\{id_1^*, id_2^*\\}</span> . Else, we return Z as response. It is easy to see that the above strategy provides a perfect simulation of IND-SK security if we do not abort during the simulation.</p>

    <p class="text-gray-300">Finally, we return the adversary's response (&quot;real&quot; or &quot;random&quot;) to the challenge query as our solution to the DBDH-C instance.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Some other SOK-type protocols that can be implemented with Type C pairings (but not Type A or Type B) are Scott's key agreement protocol [45] and the hierarchical id-based key-agreement of Gennaro et al. [26].</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">7. Efficiency</h4>

    <p class="text-gray-300">This section provides cost estimates for arithmetic operations on the k=1 elliptic curve E defined in (5). The cost estimates are in terms of the number of  <span class="math">\\mathbb{F}_p</span>  multiplications. We do not</p>

    <p class="text-gray-300">count  <span class="math">\\mathbb{F}_p</span>  additions and subtractions, so the estimates are somewhat optimistic. Nonetheless, they serve to demonstrate the practicality of implementing pairing-based protocols with k=1 elliptic curves at the 128-bit security level.</p>

    <p class="text-gray-300">We focus on the operations that are needed to implement the BLS-B signature scheme at the 128-bit security level. To achieve this security level against NFS attacks on the discrete logarithm problem, one needs to select a 3072-bit prime p. One method for selecting such a p is to randomly select a 1535-bit prime p with p with p with p and p with p with p and p with p with p are assuming here that the special form of p, namely  <span class="math">p = A^2 + 1</span>  where p is twice a randomly selected 1535-bit prime, cannot be exploited to speed up the NFS.</p>

    <p class="text-gray-300">In order to reduce the number of iterations in Miller's algorithm, an alternative is to select a 256-bit prime n with  <span class="math">n \\equiv 3 \\pmod 4</span>  and a randomly selected 1280-bit cofactor h = A/n. A smaller n also speeds up subgroup membership testing and point multiplication since scalars are now only 256 bits in length. The resulting speedups are partially offset by an increase in the time to perform hashing and the final exponentiation in the Tate pairing computation. Note that Pollard's rho attack [41] on the discrete logarithm problem in an order-n subgroup of  <span class="math">E(\\mathbb{F}_p)</span>  takes roughly  <span class="math">n^{1/2}</span>  steps, so selecting a 256-bit n preserves the 128-bit security level. In order to decrease the number of addition steps in Miller's algorithm (steps 9–12 in Algorithm 1), one can select n so that its binary representation has low Hamming weight. Then, under the heuristic assumption that A is a uniformly distributed 1536-bit number, it is reasonable to assume that the special form of n cannot be exploited to speed up attacks on the discrete logarithm problem.</p>

    <p class="text-gray-300">In §7.1 we give the cost estimates for arithmetic operations; see Table 1. We consider two cases, one where n is a randomly-selected 1535-bit prime with Hamming weight approximately 768, and the other where n is a 256-bit prime of Hamming weight 3  <span class="math">^3</span>  with 1280-bit cofactor h of Hamming weight approximately 640. In both cases,  <span class="math">n \\equiv 3 \\pmod{4}</span>  and p is assumed to have Hamming weight approximately 1536. We denote the cost of multiplication, squaring and inversion in  <span class="math">\\mathbb{F}_p</span>  by M, S, and I, respectively. For the sake of simplicity, we will assume that  <span class="math">S \\approx M</span> . In §7.2 we give clock cycle counts for BLS-B signature generation and signature verification. These counts indicate that the BLS-B signature scheme at the 128-bit security level is reasonably efficient on desktop computers.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">7.1. Cost estimates.</h4>

    <p class="text-gray-300">7.1.1. Elliptic curve representation. To avoid expensive inversions in  <span class="math">\\mathbb{F}_p</span> , we represent points in  <span class="math">E(\\mathbb{F}_p)</span>  using modified Jacobian coordinates, where a point  <span class="math">(X,Y,Z,W=Z^2)</span>  corresponds to the point (x,y) in affine coordinates with  <span class="math">x=X/Z^2</span>  and  <span class="math">y=Y/Z^3</span>  [21]. With modified Jacobian coordinates, the cost of a point addition is  <span class="math">A=7M+4S\\approx 11M</span>  and the cost of a point doubling is  <span class="math">D=1M+8S\\approx 9M</span> .</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;3&lt;/sup&gt;One can also use primes whose signed binary representations have low Hamming weight. Among such primes are  <span class="math">2^{255} + 2^{96} - 1</span> ,  <span class="math">2^{255} + 2^{176} - 1</span> ,  <span class="math">2^{255} + 2^{232} - 1</span> ,  <span class="math">2^{256} - 2^{76} - 1</span>  and  <span class="math">2^{256} - 2^{194} - 1</span> .</p>

    <p class="text-gray-300">TABLE 1. Cost estimates for operations on the k = 1 elliptic curve (5) with 1535-bit n and 256-bit n. The cost of a multiplication in  <span class="math">\\mathbb{F}_p</span>  is denoted by M.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Operation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1535-bit <span class="math">n</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">256-bit <span class="math">n</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate pairing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42957M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8726M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Weil pairing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81306M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9252M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Point multiplication</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16277M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2863M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hashing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4617M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18238M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Subgroup membership testing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59234M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11589M</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">7.1.2. Pairing computation. Section 4.2 of [33] gives formulas for the doubling step of Miller's algorithm (steps 4–7 of Algorithm 1) and the addition step (steps 9–12 of Algorithm 1). The costs are 8M+10S and 12M+5S, respectively. Now, the cost of Miller's algorithm with n of bitlength  <span class="math">\\ell</span>  and Hamming weight v is  <span class="math">(\\ell-1)\\cdot(8M+10S)+(v-1)\\cdot(12M+5S)+2M+I</span> . Ignoring the cost of I, we get a total cost of 40653M in the case of 1535-bit n, and 4626M in the case of 256-bit n (with Hamming weight v=3).</p>

    <p class="text-gray-300">In the case of the Tate pairing, we must perform a final exponentiation by the power (p-1)/n. Suppose we use the repeated-square-and-multiply method for the exponentiation. Then the final exponentiation cost is 2304M in the case of 1535-bit n, and 4100M in the case of 256-bit n.</p>

    <p class="text-gray-300">Thus, the total cost of a Tate pairing is 42957M in the case of 1535-bit n, and 8726M in the case of 256-bit n. The cost of the Weil pairing in the two cases is 81306M and 9252M.</p>

    <p class="text-gray-300">7.1.3. Point multiplication. Let  <span class="math">P \\in E(\\mathbb{F}_p)</span>  and let r be an  <span class="math">\\ell</span> -bit integer. Then point multiplication rP can be performed using the w-NAF method at a cost of  <span class="math">(2^{w-2}-1)A+(\\ell/(w+1))A+(\\ell+1)D</span>  (see [31, Algorithm 3.36]). Thus the cost of the point multiplication when  <span class="math">P \\in E[n]</span>  and  <span class="math">r \\in_R [1, n-1]</span>  is 223A+1536D=16277M in the case of 1535-bit n and w=7, and 50A+257D=2863M in the case of 256-bit n and w=5.</p>

    <p class="text-gray-300">7.1.4. Hashing. Hashing onto  <span class="math">\\mathbb{G}_2</span>  can be performed by first using a standard hash function to map an arbitrary string to the x-coordinate of a point in  <span class="math">E(\\mathbb{F}_p)</span> , then solving a quadratic equation over  <span class="math">\\mathbb{F}_p</span>  to find the corresponding y-coordinate, and finally multiplying the resulting point by the cofactor h to obtain an n-torsion point. Since  <span class="math">p \\equiv 1 \\pmod{4}</span> , one can select parameters so that  <span class="math">p \\equiv 5 \\pmod{8}</span> . Then the square root of a quadratic residue  <span class="math">a \\in \\mathbb{F}_p</span>  can be computed with one exponentiation by (p-5)/8 and a small number of multiplications; see Algorithm 3 in [2]. The exponentiation can be performed using the repeated-square-and-multiply algorithm at a cost of approximately 4608M. The cost of the w-NAF point multiplication method with an  <span class="math">\\ell</span> -bit scalar is  <span class="math">(2^{w-2}-1)A+(\\ell/(w+1))A+(\\ell+1)D</span>  (see [31, Algorithm 3.36]). Thus the cost of the point multiplication by h is 1D=9M in the case h=2, and approximately 191A+1281D=13630M in the case of 1280-bit h and w=7. This gives a hashing cost of 4617M for h=2, and 18238M for 1280-bit h.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>7.1.5. Subgroup membership testing. Let P ∈ E[n]. By Corollary 1 a point Q is in hPi if and only if (i) Q satisfies the defining equation of E; (ii) nQ = ∞; and (iii) tn(P, ψ(Q)) = 1. Thus the cost of subgroup membership testing is approximately the sum of the costs of a point multiplication and a Tate pairing computation.</li>
      <li>7.2. BLS-B signature scheme. We employ an elliptic curve with 256-bit n, and the Tate pairing. The dominant operations in BLS-B signature generation (see §5.2.1) are a hashing and a point multiplication, for a total cost of 21101M. The dominant operations in BLS-B signature verification are a hashing, a subgroup membership testing, and two pairings, for a total cost of 47279M.</li>
    </ul>

    <p class="text-gray-300">Now, the 3072-bit operands a, b ∈ F&lt;sup&gt;p&lt;/sup&gt; each require forty-eight 64-bit words. Beginning with the Haswell microarchitecture, Intel introduced the MULX instruction that performs a 64 bit word product leaving the arithmetic flags untouched. This feature permits the smooth combination of the MULX and add-with-carry instructions. In this way, the Karatsuba multiplier approach as described in [54, 47] can be efficiently implemented on a Haswell processor by computing the 6144-bit integer product t = a · b in roughly 5,200 clock cycles. The field product c = t mod p can then be performed using Barrett reduction [10] at an extra cost of roughly 1.5 integer multiplications. Hence, the total cost of computing the field multiplication is approximately 13,000 clock cycles.</p>

    <p class="text-gray-300">The 13,000 clock cycle estimate for a field multiplication yields the estimates of 113.4 million clock cycles for computing the Tate pairing, 274.3 million clock cycles for BLS-B signature generation, and 614.6 million clock cycles for BLS-B signature verification. These numbers suggest that k = 1 pairings have acceptable performance for applications that run on desktop computers and high-end mobile devices where clock rates of 2.0 GHz are common.</p>

    <p class="text-gray-300">Remark 4. (speed comparisons with pairings of even embedding degree) We did not attempt to optimize our cost estimates, e.g., by exploiting parallelism or combining operations when computing a product of pairings [46]. Nonetheless, the k = 1 pairings are expected to be significantly slower than pairings derived from elliptic curves of even embedding degree because of the inapplicability of many optimizations available in the latter such as reducing the number of iterations in Miller's algorithm [51], denominator elimination [8], and fast exponentiation [48]. For example, [3] report a speed of 18.7 million clock cycles for computing a BLS12 pairing at the 192-bit security level on an Intel Core i5 Nehalem machine. Still, k = 1 pairings are not expected to be drastically slower than pairings derived from supersingular elliptic curves with embedding degree 2 as standardized in [15, 30].</p>

    <p class="text-gray-300">We have defined three types of pairings with elliptic curves of embedding degree one. These three pairings do not fit within the general classification of pairings derived from elliptic curves of even embedding degree. Our study of pairing-based protocols indicates that any protocol that can be implemented with a Type A pairing can also be implemented with Types B and C; however the converse is not true. Similarly, any protocol that can be implemented with a Type B pairing can also be implemented with Type C, but the converse is not true.</p>

    <p class="text-gray-300">Finally, we note that there are some pairing-based protocols that cannot be implemented in either Types A, B or C. Protocols have been designed based on the Symmetric eXternal Diffie-Hellman assumption (SXDH) in the Type 3 setting (which says that the decisional Diffie-Hellman (DDH) problem is hard in the pairing groups G&lt;sup&gt;1&lt;/sup&gt; and G2). Examples of such protocols can be found in [20, 36]. Since DDH is easy in the pairing groups defined over elliptic curves with embedding degree one, these protocols cannot be securely instantiated in either Types A, B or C. Neither will it be possible to implement protocols that require reversible embedding of messages in G&lt;sup&gt;T&lt;/sup&gt; ; among such protocols are Waters' IBE scheme in its original form [53] and Gentry's IBE scheme [27] (see also [17]).</p>

    <p class="text-gray-300">We thank Razvan Barbulescu for answering our questions on the Number Field Sieve, and Neal Koblitz for several helpful suggestions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] G. Adj, A. Menezes, T. Oliveira and F. Rodr´ıguez-Henr´ıquez, &quot;Computing discrete logarithms in F&lt;sup&gt;3&lt;/sup&gt; 6·137 and F&lt;sup&gt;3&lt;/sup&gt; &lt;sup&gt;6&lt;/sup&gt;·&lt;sup&gt;163&lt;/sup&gt; using Magma&quot;, International Workshop on Arithmetic of Finite Fields — WAIFI 2014, LNCS 9061 (2015), 3–22.</p></li>
      <li><p class="text-gray-300">[2] G. Adj and F. Rodr´ıguez-Henr´ıquez, &quot;Square root computation over even extension fields&quot;, IEEE Transactions on Computers, 63 (2014), 2829–2841.</p></li>
      <li><p class="text-gray-300">[3] D. Aranha, L. Fuentes-Casta˜neda, E. Knapp, A. Menezes and F. Rodr´ıguez-Henr´ıquez, &quot;Implementing pairings at the 192-bit security level&quot;, Pairing-Based Cryptography — Pairing 2012, LNCS 7708 (2013), 177–195.</p></li>
      <li><p class="text-gray-300">[4] R. Balasubramanian and N. Koblitz, &quot;The improbability that an elliptic curve has subexponential discrete log problem under the Menezes-Okamoto-Vanstone algorithm&quot;, Journal of Cryptology, 11 (1998), 141–145.</p></li>
      <li><p class="text-gray-300">[5] R. Barbulescu, P. Gaudry, A. Guillevic and F. Morain, &quot;Improving NFS for the discrete logarithm problem in non-prime finite fields&quot;, Advances in Cryptology — EUROCRYPT 2015, LNCS 9056 (2015), 129–155.</p></li>
      <li><p class="text-gray-300">[6] R. Barbulescu, P. Gaudry, A. Joux and E. Thom´e, &quot;A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic: Improvements over FFS in small to medium characteristic&quot;, Advances in Cryptology — EUROCRYPT 2014, LNCS 8441 (2014), 1–16.</p></li>
      <li><p class="text-gray-300">[7] P. Barreto, S. Galbraith, C. O'h ´ Eigeartaigh and M. Scott, &quot;Efficient pairing computation on supersin- ´ gular abelian varieties&quot;, Designs, Codes and Cryptography, 42 (2007), 239–271.</p></li>
      <li><p class="text-gray-300">[8] P. Barreto, B. Lynn and M. Scott, &quot;On the selection of pairing-friendly group&quot;, Selected Areas in Cryptography — SAC 2003, LNCS 3006 (2004), 17–25.</p></li>
      <li><p class="text-gray-300">[9] P. Barreto and M. Naehrig, &quot;Pairing-friendly elliptic curves of prime order&quot;, Selected Areas in Cryptography — SAC 2005, LNCS 3897 (2006), 319–331.</p></li>
      <li><p class="text-gray-300">[10] P. Barrett, &quot;Implementing the Rivest Shamir and Adleman public key encryption algorithm on a standard digital signal processor&quot;, Advances in Cryptology — CRYPTO '86, LNCS 263 (1987), 311–323.</p></li>
      <li><p class="text-gray-300">[11] D. Boneh and M. Franklin, &quot;Identity-based encryption from the Weil pairing&quot;, SIAM Journal on Computing, 32 (2003), 586–615.</p></li>
      <li><p class="text-gray-300">[12] D. Boneh, C. Gentry, B. Lynn and H. Shacham, &quot;Aggregate and verifiably encrypted signatures from bilinear maps&quot;, Advances in Cryptology EUROCRYPT 2003, LNCS, 2656 (2003), 416–432.</p></li>
      <li><p class="text-gray-300">[13] D. Boneh, B. Lynn, and H. Shacham, &quot;Short signatures from the Weil pairing&quot;, <em>Journal of Cryptology</em>, 17 (2004), 297–319.</p></li>
      <li><p class="text-gray-300">[14] D. Boneh, K. Rubin and A. Silverberg, &quot;Finding composite order ordinary elliptic curves using the Cocks-Pinch method&quot;, <em>Journal of Number Theory</em>, 131 (2011), 832-841.</p></li>
      <li><p class="text-gray-300">[15] X. Boyen and L. Martin, &quot;Identity-based cryptography standard (IBCS) #1: Supersingular curve implementations of the BF and BB1 cryptosystems&quot;, IETF RFC 5091, December 2007.</p></li>
      <li><p class="text-gray-300">[16] S. Chatterjee, D. Hankerson and A. Menezes, &quot;On the efficiency and security of pairing-based protocols in the Type 1 and Type 4 settings&quot;, <em>International Workshop on Arithmetic of Finite Fields</em> WAIFI 2010, LNCS 6087 (2010), 114–134.</p></li>
      <li><p class="text-gray-300">[17] S. Chatterjee, K. Karabina and A. Menezes, &quot;Fault attacks on pairing-based protocols revisited&quot;, <em>IEEE Transactions on Computers</em>, 64 (2015), 1707–1714.</p></li>
      <li><p class="text-gray-300">[18] S. Chatterjee and A. Menezes, &quot;On cryptographic protocols employing asymmetric bilinear pairings The role of  <span class="math">\\psi</span>  revisited&quot;, sl Discrete Applied Mathematics, 159 (2011), 1311–1322</p></li>
      <li><p class="text-gray-300">[19] S. Chatterjee and A. Menezes, &quot;Type 2 structure-preserving signature schemes revisited&quot;, Advances in Cryptology — ASIACRYPT 2015, LNCS 9452 (2015), 286–310</p></li>
      <li><p class="text-gray-300">[20] J. Chen and H. Wee, &quot;Fully, (almost) tightly secure IBE and dual system groups, <em>Advances in Cryptology CRYPTO 2013</em>, LNCS 8043 (2013), 435–460.</p></li>
      <li><p class="text-gray-300">[21] D. Chudnovsky and G. Chudnovsky, &quot;Sequences of numbers generated by addition in formal groups and new primality and factoring tests&quot;, <em>Advances in Applied Mathematics</em>, 7 (1987), 385–434.</p></li>
      <li><p class="text-gray-300">[22] D. Coppersmith, &quot;Fast evaluation of logarithms in fields of characteristic two&quot;, <em>IEEE Transactions on Information Theory</em>, 30 (1984), 587–594.</p></li>
      <li><p class="text-gray-300">[23] R. Dupont and A Enge, &quot;Provably secure non-interactive key distribution based on pairings&quot;, <em>Discrete Applied Mathematics</em>, 154 (2006), 270–276.</p></li>
      <li><p class="text-gray-300">[24] S. Galbraith, &quot;Pairings&quot;, Chapter IX of I. Blake, G. Seroussi, and N. P. Smart, eds., Advances in Elliptic Curve Cryptography, Vol. 2, Cambridge University Press, 2005.</p></li>
      <li><p class="text-gray-300">[25] S. Galbraith, K. Paterson and N. Smart, &quot;Pairings for cryptographers&quot;, <em>Discrete Applied Mathematics</em>, 156 (2008), 3113-3121.</p></li>
      <li><p class="text-gray-300">[26] R. Gennaro, S. Halevi, H. Krawczyk, T. Rabin, S. Reidt and S. Wolthusen, &quot;Strongly-resilient and non-interactive hierarchical key-agreement in MANETs&quot;, 13th European Symposium on Research in Computer Security — ESORICS 2008, LNCS 5283 (2008), 49–65.</p></li>
      <li><p class="text-gray-300">[27] C. Gentry, &quot;Practical identity-based encryption without random oracles&quot;, Advances in Cryptology EUROCRYPT 2006, LNCS 4404 (2006), 445–464.</p></li>
      <li><p class="text-gray-300">[28] D. Gordon, &quot;Discrete logarithms in GF(p) using the number field sieve&quot;, SIAM Journal on Discrete Mathematics, 6 (1993), 124–138.</p></li>
      <li><p class="text-gray-300">[29] R. Granger, T. Kleinjung and J. Zumbrägel, &quot;Breaking '128-bit secure' supersingular binary curves (or how to solve discrete logarithms in  <span class="math">\\mathbb{F}_{2^{4-1223}}</span>  and  <span class="math">\\mathbb{F}_{2^{12\\cdot367}}</span> )&quot;, Advances in Cryptology CRYPTO 2014, LNCS 8617 (2014), 126–145.</p></li>
      <li><p class="text-gray-300">[30] M. Groves, &quot;Sakai-Kasahara key encryption (SAKKE)&quot;, IETF RFC 6508, February 2012.</p></li>
      <li><p class="text-gray-300">[31] D. Hankerson, A. Menezes and S. Vanstone, Guide to Elliptic Curve Cryptography, Springer, 2004.</p></li>
      <li><p class="text-gray-300">[32] F. Hess, N. Smart and F. Vercauteren, &quot;The eta pairing revisited&quot; <em>IEEE Transactions on Information Theory</em>, 52 (2006), 4595–4602.</p></li>
      <li><p class="text-gray-300">[33] Z. Hu, L. Wang, M. Xu and G. Zhang, &quot;Generation and Tate pairing computation of ordinary elliptic curves with embedding degree one&quot;, <em>ICICS 2013</em>, LNCS 8233 (2013), 393-403.</p></li>
      <li><p class="text-gray-300">[34] A. Joux, &quot;A one round protocol for tripartite Diffie-Hellman&quot;, Journal of Cryptology, 17 (2004), 263–276.</p></li>
      <li><p class="text-gray-300">[35] A. Joux and K. Nguyen, &quot;Separating Decision Diffie-Hellman from Computational Diffie-Hellman in cryptographic groups&quot;, <em>Journal of Cryptology</em>, 16 (2003), 239–247.</p></li>
      <li><p class="text-gray-300">[36] C. Jutla and A. Roy, &quot;Shorter quasi-adaptive NIZK proofs for linear subspaces&quot;, Advances in Cryptology — ASIACRYPT 2013, LNCS 8269 (2013), 1–20.</p></li>
      <li><p class="text-gray-300">[37] T. Kim and R. Barbulescu, &quot;Extended tower number field sieve: A new complexity for medium prime case&quot;, Advances in Cryptology — CRYPTO 2016, LNCS 9814 (2016), 543–571.</p></li>
      <li><p class="text-gray-300">[38] N. Koblitz and A. Menezes, &quot;Pairing-based cryptography at high security levels&quot;, Cryptography and Coding: 10th IMA International Conference, LNCS 3796 (2005), 13–36.</p></li>
      <li><p class="text-gray-300">[39] V. Miller, &quot;The Weil pairing, and its efficient calculation', Journal of Cryptology, 17 (2004), 235–261.</p></li>
      <li><p class="text-gray-300">[40] K. Paterson and S. Srinivasan, &quot;On the relations between non-interactive key distribution, identity-based encryption and trapdoor discrete log groups&quot;, Designs, Codes and Cryptography, 52 (2009), 219–241.</p></li>
      <li><p class="text-gray-300">[41] J. Pollard, &quot;Monte Carlo methods for index computation mod p&quot;, Mathematics of Computation, 32 (1978), 918–924.</p></li>
      <li><p class="text-gray-300">[42] R. Sakai, K. Oghishi and M. Kasahara, &quot;Cryptosystems based on pairing over elliptic curve&quot; (in Japanese), The 2000 Symposium on Cryptography and Information Security, 2000.</p></li>
      <li><p class="text-gray-300">[43] O. Schirokauer, &quot;Discrete logarithms and local units&quot;, Philosophical Transactions of the Royal Society London A, 345 (1993), 409–423.</p></li>
      <li><p class="text-gray-300">[44] O. Schirokauer, &quot;The number field sieve for integers of low weight&quot;, Mathematics of Computation, 79 (2010), 583-602.</p></li>
      <li><p class="text-gray-300">[45] M. Scott, &quot;Authenticated id-based key exchange and remote log-in with simple token and PIN number&quot;, available at http://eprint.iacr.org/2002/164.</p></li>
      <li><p class="text-gray-300">[46] M. Scott, &quot;Computing the Tate pairing&quot;, Topics in Cryptology CT-RSA 2005, LNCS 3376 (2005) 300–312.</p></li>
      <li><p class="text-gray-300">[47] M. Scott, &quot;Missing a trick: Karatsuba revisited&quot;, available at http://eprint.iacr.org/2015/1247.</p></li>
      <li><p class="text-gray-300">[48] M. Scott, N. Benger, M. Charlemagne, L. Dominguez Perez and E. Kachisa, &quot;On the final exponentiation for calculating pairings on ordinary elliptic curves&quot;, Pairing-Based Cryptography — Pairing 2009, LNCS 5671 (2009), 78–88.</p></li>
      <li><p class="text-gray-300">[49] H. Shacham, &quot;New paradigms in signature schemes&quot;, Ph.D. thesis, Stanford University, 2005.</p></li>
      <li><p class="text-gray-300">[50] J. Silverman, The Arithmetic of Elliptic Curves, Springer, 1986.</p></li>
      <li><p class="text-gray-300">[51] F. Vercauteren, &quot;Optimal pairings&quot;, IEEE Transactions on Information Theory, 56 (2010), 455–461.</p></li>
      <li><p class="text-gray-300">[52] E. Verheul, &quot;Evidence that XTR is more secure than supersingular elliptic curve cryptosystems&quot;, Journal of Cryptology, 17 (2004), 277–296.</p></li>
      <li><p class="text-gray-300">[53] B. Waters, &quot;Efficient identity-based encryption without random oracles&quot;, Advances in Cryptology EUROCRYPT 2005, LNCS 3494 (2005), 114–127.</p></li>
      <li><p class="text-gray-300">[54] A. Weimerskirch and C. Paar, &quot;Generalizations of the Karatsuba algorithm for efficient implementation&quot;, available at http://eprint.iacr.org/2006/224.</p></li>
      <li><p class="text-gray-300">[55] C. Zhao, F. Zhang and D. Xie, &quot;Faster computation of self-pairings&quot;, IEEE Transactions on Information Theory, 58 (2012), 3266–3272.</p></li>
    </ul>

    <p class="text-gray-300">Department of Computer Science and Automation, Indian Institute of Science E-mail address: sanjit@csa.iisc.ernet.in</p>

    <p class="text-gray-300">Department of Combinatorics &amp; Optimization, University of Waterloo E-mail address: ajmeneze@uwaterloo.ca</p>

    <p class="text-gray-300">Computer Science Department, CINVESTAV-IPN</p>

    <p class="text-gray-300">E-mail address: francisco@cs.cinvestav.mx</p>

`;
---

<BaseLayout title="ON INSTANTIATING PAIRING-BASED PROTOCOLS WITH ELLIPTIC CURVE... (2016/403)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/403
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="on-instantiating-pairing-based-protocols-with-elliptic-2016" />
  </article>
</BaseLayout>
