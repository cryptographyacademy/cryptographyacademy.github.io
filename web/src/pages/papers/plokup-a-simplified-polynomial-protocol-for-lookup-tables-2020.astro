---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/315';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'plookup: A simplified polynomial protocol for lookup tables';
const AUTHORS_HTML = 'Ariel Gabizon, Zachary J.  Williamson';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We present a protocol for checking the values of a committed polynomial $f\\in \\mathbb{F}_{&lt;n}[X]$ over a multiplicative subgroup $H\\subset \\mathbb{F}$ of size $n$, are contained in the values of a table $t\\in \\mathbb{F}^d$. Our protocol can be viewed as a simplification of one from Bootle et. al [BCGJM, ASIACRYPT 2018] for a similar problem, with potential efficiency improvements when $d\\leq n$. In particular, [BCGJM]&#x27;s protocol requires comitting to several auxiliary polynomials of degree $d\\cdot \\log n$, whereas ours requires three commitments to auxiliary polynomials of degree $n$, which can be much smaller in the case $d\\sim n$.

One common use case of this primitive in the zk-SNARK setting is a \`\`batched range proof&#x27;&#x27;, where one wishes to check all of $f$&#x27;s values on $H$ are in a range $[0,\\ldots,M]$. We present a slightly optimized protocol for this special case, and pose improving it as an open problem.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> zk-SNARKs &middot; Polynomial Commitment Schemes</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">When wanting to use zk-SNARKs to prove statements involving standard primitives like AES-128 or SHA-256, one runs into the problem that the operations involved in these primitives are &quot;SNARK unfriendly&quot;, in the sense of having large representations in the native SNARK language, which typically corresponds to low degree equations over a large prime field. Examples of operations with large overhead, are ones involving bit decomposition like bitwise XOR or AND. This has lead to growing research into STARK and SNARK friendly hash functions and symmetric primitives that are based solely on native field operations [GKK<sup>+</sup>19, AAB<sup>+</sup>19, AGR<sup>+</sup>16, ACG<sup>+</sup>19].</p>

    <p class="text-gray-300">We investigate an alternative approach, where for commonly used operations we precompute a lookup table of the legitimate (input, output) combinations; and the prover argues the witness values exist in this table.</p>

    <p class="text-gray-300">Using randomness, we can reduce to the case of looking up single field elements instead of tupples. Then, in polynomial language, this ultimately boils down to proving polynomials are the same &quot;up to multiplicities&quot;. That is, suppose that the values in the</p>

    <p class="text-gray-300">lookup table are {ti}i&isin;[d] and the values in the witness are {fi}i&isin;[n] . We want to show that the polynomials</p>

    <p class="text-gray-300"><span class="math">$F(X) := \\prod_{i \\in [n]} (X - f_i), G(X) := \\prod_{i \\in [d]} (X - t_i)</span>$</p>

    <p class="text-gray-300">have the same roots, ignoring multiplicites; i.e. that for some non-negative integers {ei}i&isin;[d] we have F(X) = Q i&isin;[d] (X &minus; ti) ei . Bootle et. al <a href="#page-9-0">[BCG</a>+] gave an algorithm for this exact problem, also in the context of efficient SNARK arithmetization of a common operation (in their case, repeatedly checking that field elements correspond to certain convenient sparse representations of boolean strings).</p>

    <p class="text-gray-300">Their algorithm requires committing to a vector of length d log n that contains for each i &isin; [d], j &isin; [log n] the value (x &minus; ti) 2 j for a random verifier challenge x &isin; F. They also commit to the binary decomposition of the {ei}, and using the two, prove that F is of the desired form.</p>

    <p class="text-gray-300">We present here an arguably simpler protocol for the same problem, that doesn't require explicitly representing the multiplicities. Let us use the notation f &sub; t as shorthand for {fi}i&isin;[n] &sub; {ti}i&isin;[d] .</p>

    <p class="text-gray-300">The idea is to look at a sorted version {si} of the values {fi}, and compare the set of non-zero differences in {si} and {ti}. Note that if f &sub; t, and every element of t appears at least once in f, we indeed have that these sets of differences are the same. However, the converse is not true: We can create a sequence of values {si} having the same difference set as {ti}, but with the differences appearing in different order ; and in this case we won't have s &sub; t. As an illustrating example, take</p>

    <p class="text-gray-300"><span class="math">$t = \\{1, 4, 8\\}, s = \\{1, 1, 4, 8, 8, 8\\}, s&#x27; = \\{1, 5, 5, 5, 8, 8\\}</span>$</p>

    <p class="text-gray-300">All three sets have the same difference set {3, 4}; but since those differences appear in different order in s <sup>0</sup> and t, we don't have s <sup>0</sup> &sub; t. Though not an issue in the above examples, we also didn't address checking the starting point is the same in s and t. Both issues can be solved by comparing randomized difference sets: We choose random &beta; &isin; F, and compare the elements in the sequences {t<sup>i</sup> + &beta;ti+1}i&isin;[d&minus;1], {s<sup>i</sup> + &beta;si+1}i&isin;[n&minus;1].</p>

    <p class="text-gray-300">Seemingly, we have taken &quot;one step forward and one back&quot; by adding the random &beta;, as now pairs (s<sup>i</sup> , si+1) with s<sup>i</sup> = si+1 will give a non-zero contribution s<sup>i</sup> + &beta; &middot; si+1 = (1 + &beta;) &middot; s<sup>i</sup> . However, all elements corresponding to a repetition are now multiples of (1+&beta;) and we are able to use this to &quot;identify&quot; them and not use them in the comparison with the table. Specifically, we show that this check can be done correctly and efficiently using a &quot;grand product argument&quot; similar to the one used in <a href="#page-9-5">[GWC19]</a>'s permutation argument.</p>

    <p class="text-gray-300">A technicality is that as mentioned this approach assumes all of t's values appear at least once in f; which is one reason we in fact take s to be the sorted version of the concatenation of f and t. This ends up also helping to batch both checks into one product: The check that f &sub; s, and the check that s &sub; t.</p>

    <p class="text-gray-300">Precise details of the scheme are given in Section <a href="#page-3-0">3.</a></p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300"><strong>Terminology</strong> For integer d, we denote by  <span class="math">\\mathbb{F}_{&lt; d}[X]</span>  the set of univariate polynomials over  <span class="math">\\mathbb{F}</span>  of degree smaller than d.</p>

    <p class="text-gray-300">Polynomial Protocols We use the ranged polynomial protocol terminology from [GWC19] to describe our protocols. We repeat the definition for reference.</p>

    <p class="text-gray-300">In such a protocol a prover  <span class="math">\\mathbf{P}</span>  sends polynomials of a certain degree bound d to an ideal party  <span class="math">\\mathcal{I}</span> , and at the end of protocol, the verifier can ask whether certain identities hold between the polynomials sent during the protocol, the input polynomials, and the preprocessed polynomials, on a predefined set H.</p>

    <p class="text-gray-300">More precisely,</p>

    <p class="text-gray-300"><strong>Definition 2.1.</strong> Fix positive integers  <span class="math">d, D, t, \\ell</span>  and  <span class="math">H \\subset \\mathbb{F}</span> . An H-ranged  <span class="math">(d, D, t, \\ell)</span> -polynomial protocol is a multiround protocol between a prover  <span class="math">\\mathbf{P}</span> , verifier  <span class="math">\\mathbf{V}</span>  and trusted party  <span class="math">\\mathcal{I}</span>  that proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The protocol definition includes a set of preprocessed and input polynomials  <span class="math">g_1, \\ldots, g_\\ell \\in \\mathbb{F}_{\\leq d}[X]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The messages of  <span class="math">\\mathbf{P}</span>  are sent to  <span class="math">\\mathcal{I}</span>  and are of the form f for  <span class="math">f \\in \\mathbb{F}_{&lt; d}[X]</span> . If  <span class="math">\\mathbf{P}</span>  sends a message not of this form, the protocol is aborted.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The messages of V to P are arbitrary (but we will concentrate on public coin protocols where the messages are simply random coins).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the end of the protocol, suppose  <span class="math">f_1, \\ldots, f_t</span>  are the polynomials that were sent from  <span class="math">\\mathbf{P}</span>  to  <span class="math">\\mathcal{I}</span> .  <span class="math">\\mathbf{V}</span>  may ask  <span class="math">\\mathcal{I}</span>  if certain polynomial identities holds on H between  <span class="math">\\{f_1, \\ldots, f_t, g_1, \\ldots, g_\\ell\\}</span> . Where each identity is of the form</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$F(X) := G(X, h_1(v_1(X)), \\dots, h_M(v_M(X))) \\equiv 0,</span>$</p>

    <p class="text-gray-300">for some  <span class="math">h_i \\in \\{f_1, \\ldots, f_t, g_1, \\ldots, g_\\ell\\}</span> ,  <span class="math">G \\in \\mathbb{F}[X, X_1, \\ldots, X_M]</span> ,  <span class="math">v_1, \\ldots, v_M \\in \\mathbb{F}_{&lt; d}[X]</span>  such that  <span class="math">F \\in \\mathbb{F}_{&lt; D}[X]</span>  for every choice of  <span class="math">f_1, \\ldots, f_t</span>  made by  <span class="math">\\mathbf{P}</span>  when following the protocol correctly.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>After receiving the answers from  <span class="math">\\mathcal{I}</span>  regarding the identities,  <span class="math">\\mathbf{V}</span>  outputs acc if all identities hold, and outputs rej otherwise.</li>
    </ol>

    <p class="text-gray-300">It is shown in Section 4 of [GWC19] how such a protocol can be compiled into one in the algebraic group model using the polynomial commitment scheme of [KZG10].</p>

    <p class="text-gray-300">For such a protocol  <span class="math">\\mathscr{P}</span> , let  <span class="math">\\mathfrak{d}(\\mathscr{P})</span>  be the maximum over  <span class="math">f_1, \\ldots, f_t</span>  sent by an honest prover during protocol execution of  <span class="math">\\left(\\sum_{i \\in [t]} \\deg(f_i) + 1\\right) + D - |H|</span> .</p>

    <p class="text-gray-300">The prover complexity ends up being closely tied to  <span class="math">\\mathfrak{d}(\\mathscr{P})</span>  as this corresponds to the number of group operations to commit to all polynomials (including the quotient polynomial that comes up in translating a ranged polynomial protocol to a polynomial protocol) using [KZG10]. We will thus attempt to minimize  <span class="math">\\mathfrak{d}(\\mathscr{P})</span>  in our protocols.</p>

    <p class="text-gray-300">Lagrange bases and multiplicative subgroups In our protocols, we take H to be a multiplicative subgroup of some order N with generator  <span class="math">\\mathbf{g}</span> . For  <span class="math">i \\in [N]</span> , we denote by  <span class="math">L_i \\in \\mathbb{F}_{&lt; N}[X]</span>  the i'th Lagrange polynomial for H, that satisfies  <span class="math">L_i(\\mathbf{g}^i) = 1</span>  and  <span class="math">L_i(\\mathbf{g}^j) = 0</span>  for  <span class="math">j \\neq i</span> . These polynomials are covenient when specifying a point check in an H-ranged protocol. For example, requiring  <span class="math">L_i(\\mathbf{x})f(\\mathbf{x}) = 0</span>  for all  <span class="math">\\mathbf{x} \\in H</span>  is equivalent to  <span class="math">f(\\mathbf{g}^i) = 0</span> .</p>

    <p class="text-gray-300">The generator  <span class="math">\\mathbf{g}</span>  is convenient for specifying constraints on &quot;neighboring values&quot;. For example, the constraint  <span class="math">f(\\mathbf{g} \\cdot \\mathbf{x}) - f(\\mathbf{x}) = 1</span>  means that f's value grows by one when going to the &quot;next&quot; point.</p>

    <p class="text-gray-300">We refer the reader to Section 4 of [GWC19] for more details.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 The main scheme</h2>

    <p class="text-gray-300">Notation: Fix integers n,d and vectors  <span class="math">f \\in \\mathbb{F}^n, t \\in \\mathbb{F}^d</span> . We use the notation  <span class="math">f \\subset t</span>  to mean  <span class="math">\\{f_i\\}_{i \\in [n]} \\subset \\{t_i\\}_{i \\in [d]}</span> . Let  <span class="math">H = \\{\\mathbf{g}, \\dots, \\mathbf{g}^{n+1} = 1\\}</span>  be a multiplicative subgroup of order n+1 in  <span class="math">\\mathbb{F}</span> . For a polynomial  <span class="math">f \\in \\mathbb{F}[X]</span>  and  <span class="math">i \\in [n+1]</span>  we sometimes denote  <span class="math">f_i := f(\\mathbf{g}^i)</span> . For a vector  <span class="math">f \\in \\mathbb{F}^n</span> , we also denote by f the polynomial in  <span class="math">\\mathbb{F}_{&lt; n}[X]</span>  with  <span class="math">f(\\mathbf{g}^i) = f_i</span> .</p>

    <p class="text-gray-300">When  <span class="math">f \\subset t</span> , we say that f is sorted by t when values appear in the same order in f as they do in t. Formally, for any  <span class="math">i &lt; i&#x27; \\in [n]</span>  such that  <span class="math">f_i \\neq f_{i&#x27;}</span> , if  <span class="math">j, j&#x27; \\in [d]</span>  are such that  <span class="math">t_j = f_i, t_{j&#x27;} = f_{i&#x27;}</span>  then j &lt; j'.</p>

    <p class="text-gray-300">Now, given  <span class="math">t \\in \\mathbb{F}^d</span> ,  <span class="math">f \\in \\mathbb{F}^n</span> ,  <span class="math">s \\in \\mathbb{F}^{n+d}</span> , define bi-variate polynomials F, G as</p>

    <p class="text-gray-300"><span class="math">$F(\\beta, \\gamma) := (1 + \\beta)^n \\cdot \\prod_{i \\in [n]} (\\gamma + f_i) \\prod_{i \\in [d-1]} (\\gamma(1 + \\beta) + t_i + \\beta t_{i+1})</span>$</p>

    <p class="text-gray-300"><span class="math">$G(\\beta, \\gamma) := \\prod_{i \\in [n+d-1]} (\\gamma(1+\\beta) + s_i + \\beta s_{i+1})</span>$</p>

    <p class="text-gray-300">we have</p>

    <p class="text-gray-300">Claim 3.1.  <span class="math">F \\equiv G</span>  if and only if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f \\subset t</span> , and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>s is (f,t) sorted by t.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> We write F, G as elements of  <span class="math">\\mathbb{F}(\\beta)[\\gamma]</span>  while taking out a  <span class="math">(1+\\beta)</span>  factor as follows.</p>

    <p class="text-gray-300"><span class="math">$F(\\beta, \\gamma) = (1 + \\beta)^{n+d-1} \\cdot \\prod_{i \\in [n]} (\\gamma + f_i) \\prod_{i \\in [d-1]} (\\gamma + (t_i + \\beta t_{i+1})/(1 + \\beta))</span>$</p>

    <p class="text-gray-300"><span class="math">$G(\\beta, \\gamma) = (1 + \\beta)^{n+d-1} \\prod_{i \\in [n+d-1]} (\\gamma + (s_i + \\beta s_{i+1})/(1 + \\beta))</span>$</p>

    <p class="text-gray-300">Suppose first that  <span class="math">f \\subset t</span>  and  <span class="math">s \\in \\mathbb{F}^{n+d}</span>  is (f,t) sorted by t.</p>

    <p class="text-gray-300">Then for each  <span class="math">j \\in [d-1]</span> , there is a distinct index  <span class="math">i \\in [n+d-1]</span>  such that  <span class="math">(t_j, t_{j+1}) = (s_i, s_{i+1})</span> . The corresponding factors in F, G are equal. That is,</p>

    <p class="text-gray-300"><span class="math">$(\\gamma + (t_i + \\beta t_{i+1})/(1+\\beta)) \\equiv (\\gamma + (s_i + \\beta s_{i+1})/(1+\\beta))</span>$</p>

    <p class="text-gray-300">Let  <span class="math">P&#x27; \\subset [n+d-1]</span>  the set of these d-1 indices i, and let  <span class="math">P := [n+d-1] \\setminus P&#x27;</span> . The n indices  <span class="math">i \\in P</span>  are such that  <span class="math">s_i = s_{i+1}</span> , and  <span class="math">\\{s_i\\}_{i \\in P}</span>  equals  <span class="math">\\{f_i\\}_{i \\in [n]}</span>  as multisets. That is, we have a one-to-one map  <span class="math">j: P \\to [n]</span>  such that for each  <span class="math">i \\in P</span> ,  <span class="math">s_i = f_{j(i)}</span> . For each  <span class="math">i \\in P</span> , the corresponding factor of G, will be</p>

    <p class="text-gray-300"><span class="math">$\\gamma + (s_i + \\beta s_{i+1})/(1+\\beta) = \\gamma + s_i,</span>$</p>

    <p class="text-gray-300">which equals the factor  <span class="math">\\gamma + f_{i(i)}</span>  in F.</p>

    <p class="text-gray-300">For the other direction, assume  <span class="math">F \\equiv G</span>  as polynomials in  <span class="math">\\mathbb{F}[\\beta, \\gamma]</span> . Then  <span class="math">F \\equiv G</span>  also as elements of  <span class="math">\\mathbb{F}(\\beta)[\\gamma]</span> . Since  <span class="math">\\mathbb{F}(\\beta)[\\gamma]</span>  is a unique factorization domain, we know that the linear factors of F, G, as written above must be equal. Thus, for each  <span class="math">i \\in [d-1]</span> , G must have a factor equal to  <span class="math">(\\gamma + (t_i + \\beta t_{i+1})/(1+\\beta))</span> . In other words, for some  <span class="math">j \\in [n+d-1]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\gamma + (t_i + \\beta t_{i+1})/(1+\\beta) = \\gamma + (s_j + \\beta s_{j+1})/(1+\\beta),</span>$</p>

    <p class="text-gray-300">which implies  <span class="math">t_i + \\beta t_{i+1} = s_j + \\beta s_{j+1}</span> , and therefore  <span class="math">t_i = s_j, t_{i+1} = s_{j+1}</span> . Call  <span class="math">P&#x27; \\subset [n+d-1]</span>  the set of these d-1 indices j. For any index  <span class="math">j \\in [n+d-1] \\setminus P&#x27;</span> , there must be a factor &quot;coming from f&quot; in F that equals the corresponding factor in G. More precisely, for such j there exists  <span class="math">i \\in [n]</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\gamma + f_i = \\gamma + (s_j + \\beta s_{j+1})/(1+\\beta),</span>$</p>

    <p class="text-gray-300">or equivalently</p>

    <p class="text-gray-300"><span class="math">$f_i + \\beta f_i = s_i + \\beta s_{i+1}</span>$</p>

    <p class="text-gray-300">which implies  <span class="math">f_i = s_j = s_{j+1}</span> .</p>

    <p class="text-gray-300">Thus, we know that whenever consecutive values in s are different, they are exactly equal to two consecutive values in t, and all values of f are values of t.</p>

    <p class="text-gray-300">Claim 3.1 motivates the following protocol. It will be convenient to assume d = n+1. (If  <span class="math">d \\le n</span>  pad t with n-d+1 repetitions of the last element.)</p>

    <p class="text-gray-300">Preprocessed polynomials: The polynomial  <span class="math">t \\in \\mathbb{F}_{\\leq n+1}[X]</span>  describing the lookup values.</p>

    <p class="text-gray-300">Inputs:  <span class="math">f \\in \\mathbb{F}_{&lt; n}[X]</span></p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Protocol:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">s \\in \\mathbb{F}^{2n+1}</span>  be the vector that is (f,t) sorted by t. We represent s by  <span class="math">h_1, h_2 \\in \\mathbb{F}_{&lt; n+1}[X]</span>  as follows.  <span class="math">h_1(\\mathbf{g}^i) = s_i</span>  for  <span class="math">i \\in [n+1]</span> ; and  <span class="math">h_2(\\mathbf{g}^i) = s_{n+i}</span>  for each  <span class="math">i \\in [n+1]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> computes the polynomials  <span class="math">h_1, h_2</span>  and sends them to the ideal party  <span class="math">\\mathcal{I}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V chooses random  <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span>  and sends them to <strong>P</strong>.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> computes a polynomial  <span class="math">Z \\in \\mathbb{F}_{\\leq n+1}[X]</span>  that aggregates the value  <span class="math">F(\\beta, \\gamma)/G(\\beta, \\gamma)</span>  where F, G are as described above. Specifically, we let</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">Z(\\mathbf{g}) = 1</span> ,</li>
      <li>(b) For  <span class="math">2 \\le i \\le n</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$Z(\\mathbf{g}^{i}) = \\frac{(1+\\beta)^{i-1} \\prod_{j &lt; i} (\\gamma + f_{j}) \\cdot \\prod_{1 \\le j &lt; i} (\\gamma(1+\\beta) + t_{j} + \\beta t_{j+1})}{\\prod_{1 \\le j &lt; i} (\\gamma(1+\\beta) + s_{j} + \\beta s_{j+1}) (\\gamma(1+\\beta) + s_{n+j} + \\beta s_{n+j+1})},</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">(c)
<span class="math">$Z(\\mathbf{g}^{n+1}) = 1</span>$
.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> sends Z to  <span class="math">\\mathcal{I}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>V</strong> checks that Z is indeed of the form described above, and that  <span class="math">Z(\\mathbf{g}^{n+1}) = 1</span> . More precisely, <strong>V</strong> checks the following identities for all  <span class="math">\\mathbf{x} \\in H</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">(a)
<span class="math">$L_1(\\mathbf{x})(Z(\\mathbf{x}) - 1) = 0</span>$
.</p>

    <p class="text-gray-300">(b)
<span class="math">$(\\mathbf{x} - \\mathbf{g}^{n+1}) Z(\\mathbf{x}) (1+\\beta) \\cdot (\\gamma + f(\\mathbf{x})) (\\gamma (1+\\beta) + t(\\mathbf{x}) + \\beta t(\\mathbf{g} \\cdot \\mathbf{x}))</span>$</p>

    <p class="text-gray-300"><span class="math">$= (\\mathbf{x} - \\mathbf{g}^{n+1}) Z(\\mathbf{g} \\cdot \\mathbf{x}) (\\gamma (1+\\beta) + h_1(\\mathbf{x}) + \\beta h_1(\\mathbf{g} \\cdot \\mathbf{x})) (\\gamma (1+\\beta) + h_2(\\mathbf{x}) + \\beta h_2(\\mathbf{g} \\cdot \\mathbf{x}))</span>$</p>

    <p class="text-gray-300">(c)
<span class="math">$L_{n+1}(\\mathbf{x})(h_1(\\mathbf{x}) - h_2(\\mathbf{g} \\cdot \\mathbf{x})) = 0.</span>$</p>

    <p class="text-gray-300">(d)
<span class="math">$L_{n+1}(\\mathbf{x})(Z(\\mathbf{x}) - 1) = 0.</span>$</p>

    <p class="text-gray-300">and outputs acc iff all checks hold.</p>

    <p class="text-gray-300"><strong>Lemma 3.2.</strong> Suppose that  <span class="math">\\{f(\\mathbf{g}^i)\\}_{i\\in[n]}</span>  is not contained in  <span class="math">\\{t(\\mathbf{g}^i)\\}_{i\\in[n+1]}</span> . Then for any strategy of  <span class="math">\\mathcal A</span>  playing the role of  <span class="math">\\mathbf P</span>  in the above protocol  <span class="math">\\mathscr P</span> , the probability that  <span class="math">\\mathbf V</span>  accepts is  <span class="math">\\operatorname{negl}(\\lambda)</span> . Furthermore, we have  <span class="math">\\mathfrak d(\\mathscr P)=5n+4</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We start by computing  <span class="math">\\mathfrak{d}(\\mathscr{P})</span> . The prover sends  <span class="math">h_1, h_2, Z \\in \\mathbb{F}_{&lt; n+1}[X]</span> , which aggregates to 3n+3. The second identity checked by the verifier is of the highest degree, containing a product of these three and the linear term  <span class="math">X - \\mathbf{g}^{n+1}</span> , which gives us another 3n+2 from which we subtract |H| = n+1. In total we get 5n+4.</p>

    <p class="text-gray-300">We proceed to prove correctness. The check in step 6c shows that  <span class="math">h_1(\\mathbf{g}^{n+1}) = h_2(\\mathbf{g})</span> , and thus  <span class="math">h_1, h_2</span>  indeed consistently describe a single vector  <span class="math">s \\in \\mathbb{F}^{2n+1}</span> . Using Claim</p>

    <p class="text-gray-300">3.1 we know that when f's range is not contained in t's for any choice of s sent by  <span class="math">\\mathbf{P}</span>  the polynomials F(X,Y), G(X,Y) are different. From the SZ lemma e.w.p  <span class="math">\\operatorname{negl}(\\lambda)</span>   <span class="math">\\mathbf{V}</span>  chooses  <span class="math">\\beta, \\gamma</span>  such that  <span class="math">F(\\beta, \\gamma) \\neq G(\\beta, \\gamma)</span> . In this case we have  <span class="math">Z(\\mathbf{g}^{n+1}) \\neq 1</span>  which means  <span class="math">\\mathbf{V}</span>  rejects.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Generalizing to vector lookups and multiple tables</h2>

    <p class="text-gray-300">Suppose we have several witness polynomials  <span class="math">f_1, \\ldots, f_w \\in \\mathbb{F}_{&lt; n}[X]</span> , and a table of values  <span class="math">t^* \\in (\\mathbb{F}^w)^d</span> . We wish to check that for each  <span class="math">j \\in [n]</span>   <span class="math">(f_1(\\mathbf{g}^j), \\ldots, f_w(\\mathbf{g}^j)) \\in t^*</span> . We can use randomization to efficiently reduce to the case of Section 3.</p>

    <p class="text-gray-300">For each  <span class="math">i \\in [w]</span>  we will include in the set of preprocessed polynomials  <span class="math">t_i \\in \\mathbb{F}_{&lt; d}[X]</span>  with  <span class="math">t_i(\\mathbf{g}^j) = t_{i,j}^*</span>  for each  <span class="math">j \\in [d]</span> .</p>

    <p class="text-gray-300">The verifier will choose random  <span class="math">\\alpha \\in \\mathbb{F}</span> .</p>

    <p class="text-gray-300">Then we will define  <span class="math">t := \\sum_{i \\in [w]} \\alpha^i t_i</span> ,  <span class="math">f := \\sum_{i \\in [w]} \\alpha^i f_i</span> .</p>

    <p class="text-gray-300">Assume that for some  <span class="math">j \\in [n]</span> ,  <span class="math">(f_1(\\mathbf{g}^j), \\dots, f_w(\\mathbf{g}^j)) \\notin t^*</span> . Then e.w.p  <span class="math">d \\cdot w/|\\mathbb{F}|</span> ,  <span class="math">f(\\mathbf{g}^j) \\notin t</span> . Thus, after the selection of  <span class="math">\\alpha</span> , we can run the protocol of the previous section on f, t.</p>

    <p class="text-gray-300">As alluded to in the introduction, a natural use case for this vector lookup primitive is a key-value setting, where we have a function f with w-1 inputs, and wish to verify a vector is of the form  <span class="math">(x_1, \\ldots, x_{w-1}, f(x_1, \\ldots, x_{w-1}))</span>  for some input  <span class="math">(x_1, \\ldots, x_{w-1})</span> .</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Multiple tables</h3>

    <p class="text-gray-300">Suppose further that we have in fact have multiple tables  <span class="math">t_1^*, \\ldots, t_\\ell^*</span>  and for each  <span class="math">i \\in [n]</span>  wish to check that for some predefined  <span class="math">j = j(i) \\in [\\ell]</span>   <span class="math">(f_1(\\mathbf{g}^i), \\ldots, f_w(\\mathbf{g}^i)) \\in t_j^*</span> . We can reduce to the previous setting as follows. We create a preprocessed table containing  <span class="math">t_1^*, \\ldots, t_\\ell^*</span>  as sub-tables, by adding a column specifying the table index.</p>

    <p class="text-gray-300">That is, suppose for simplicity that for each  <span class="math">j \\in [\\ell]</span> ,  <span class="math">t_j^* \\in (\\mathbb{F}^w)^{d/\\ell}</span> . We construct  <span class="math">t^* \\in (\\mathbb{F}^{w+1})^d</span> , containing for each  <span class="math">j \\in [\\ell]</span> ,  <span class="math">i \\in [d/\\ell]</span>  of the element  <span class="math">(j, (t_j^*)_i)</span> . We preprocess a polynomial  <span class="math">q \\in \\mathbb{F}_{\\leq n}[X]</span>  such that  <span class="math">q_i = j(i)</span> , where again j(i) is the subtable we wish the <em>i</em>'th value to be in. Now apply the method above to check that for each  <span class="math">i \\in [n]</span> ,  <span class="math">(q(\\mathbf{g}^i), f_1(\\mathbf{g}^i), \\dots, f_w(\\mathbf{g}^i)) \\in t^*</span></p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 An optimized solution for continuous ranges</h2>

    <p class="text-gray-300">Suppose we wish to check that  <span class="math">f \\subset \\{0, \\ldots, d-1\\}</span>  for some integer d &lt; n. We could use our above protocol while setting  <span class="math">t_i = i-1</span>  for  <span class="math">i \\in [d]</span> . By using d = n+1, the above protocol allows us to check  <span class="math">f \\subset \\{0, \\ldots, n\\}</span>  with complexity  <span class="math">\\mathfrak{d}(\\mathscr{P}) = 5n+4</span>  as stated in Lemma 3.2. We present an alternative protocol with the same complexity that will allow us to check  <span class="math">f \\subset \\{0, \\ldots, 2n-2\\}</span> . In fact, the protocol naturally generalizes for ranges  <span class="math">\\{0, \\ldots, c(n-1)\\}</span>  while only increasing the degree of verifier constraints. Thus, one may choose a larger c in protocols where the range proof is a subroutine, according to the maximal constraint degree in other parts of the protocol.</p>

    <p class="text-gray-300">The idea is the following. (We emphasize we are assuming the range is in fact contained in  <span class="math">\\mathbb{F}</span> , i.e.  <span class="math">cn &lt; |\\mathbb{F}|</span> .) Suppose that we enforce that the sorted witness s starts from zero and ends at  <span class="math">c \\cdot (n-1)</span> , i.e.  <span class="math">s_1 = 0</span> ,  <span class="math">s_{2n+1} = c \\cdot (n-1)</span> , and that for each  <span class="math">i \\in [2n]</span> ,  <span class="math">s_{i+1} - s_i \\leq c</span> . This sufficies to deduce that  <span class="math">s_i \\in \\{0, \\ldots, c(n-1)\\}</span>  for each  <span class="math">i \\in [2n+1]</span> .</p>

    <p class="text-gray-300">The condition  <span class="math">s_{i+1}-s_i \\leq c</span>  can be enforced by a constraint that plugs in this difference into the degree c+1 polynomial that vanishes on  <span class="math">\\{0,\\ldots,c\\}</span> . Enforcing the increments this way obviates the need to look at a permutation between differences, and instead we can directly check a permutation between the values of (f,t) and s; where t is the table of c'th multiples, i.e.  <span class="math">t_i = c \\cdot (i-1)</span>  for  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">We proceed to describe the protocol in detail. As in the first protocol, we assume H is a multiplicative subgroup of order n+1 with generator  <span class="math">\\mathbf{g}</span> .</p>

    <p class="text-gray-300">The protocol is parameterized by a positive integer parameter c. And we denote by P the polynomial  <span class="math">P(X) := \\prod_{i=0}^{c} (X - i)</span> .</p>

    <p class="text-gray-300">Preprocessed polynomials: The polynomial  <span class="math">t \\in \\mathbb{F}_{\\leq n}[X]</span>  with  <span class="math">t_i = c \\cdot (i-1)</span>  for  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">Inputs:  <span class="math">f \\in \\mathbb{F}_{&lt; n}[X]</span></p>

    <p class="text-gray-300">Protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">s \\in \\mathbb{F}^{2n+1}</span>  be the vector that is (f,t) sorted by t. We represent s by  <span class="math">h_1, h_2 \\in \\mathbb{F}_{&lt; n+1}[X]</span>  as follows.  <span class="math">h_1(\\mathbf{g}^i) = s_i</span>  for  <span class="math">i \\in [n+1]</span> ; and  <span class="math">h_2(\\mathbf{g}^i) = s_{n+i}</span>  for each  <span class="math">i \\in [n]</span>  and  <span class="math">h_2(\\mathbf{g}^{n+1}) = c(n-1)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> computes the polynomials  <span class="math">h_1, h_2</span>  and sends them to the ideal party  <span class="math">\\mathcal{I}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V chooses random  <span class="math">\\gamma \\in \\mathbb{F}</span>  and sends it to <strong>P</strong>.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> computes a polynomial  <span class="math">Z \\in \\mathbb{F}_{&lt; n+1}[X]</span>  that aggregates the value  <span class="math">F(\\beta, \\gamma)/G(\\beta, \\gamma)</span>  where F, G are as described above. Specifically, we let</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">Z(\\mathbf{g}) = 1</span> ,</li>
      <li>(b) For 2 &lt; i &lt; n</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$Z(\\mathbf{g}^i) = \\frac{\\prod_{j &lt; i} (\\gamma + f_j) \\cdot \\prod_{1 \\le j &lt; i} (\\gamma + t_j)}{\\prod_{1 \\le j &lt; i} (\\gamma + s_j) (\\gamma + s_{n+j})},</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">(c)
<span class="math">$Z(\\mathbf{g}^{n+1}) = 1</span>$
.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> sends Z to  <span class="math">\\mathcal{I}</span> .</li>
    </ol></li>
      <li><p class="text-gray-300">6. V checks the following identities for all  <span class="math">\\mathbf{x} \\in H</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">L_1(\\mathbf{x})(h_1(\\mathbf{x})) = 0</span> .</li>
      <li>(b)  <span class="math">P(h_1(\\mathbf{g} \\cdot \\mathbf{x}) h_1(\\mathbf{x})) = 0.</span></li>
    </ul></li>
      <li><p class="text-gray-300">(c) P (h2(g &middot; x) &minus; h2(x)) = 0.</p></li>
      <li><p class="text-gray-300">(d) Ln+1(x)(h1(x) &minus; h2(g &middot; x)) = 0</p></li>
      <li><p class="text-gray-300">(e) Ln+1(x)(h2(x)) = c &middot; (n &minus; 1).</p></li>
      <li><p class="text-gray-300">(f) L1(x)(Z(x) &minus; 1) = 0.</p></li>
      <li><p class="text-gray-300">(g)</p></li>
    </ul>

    <p class="text-gray-300"><span class="math">$(\\mathbf{x} - \\mathbf{g}^{n+1})(Z(\\mathbf{x})(\\gamma + f(\\mathbf{x}))(\\gamma + t(\\mathbf{x})) = (\\mathbf{x} - \\mathbf{g}^{n+1}) \\cdot Z(\\mathbf{g} \\cdot \\mathbf{x})(\\gamma + h_1(\\mathbf{x}))(\\gamma + h_2(\\mathbf{x})))</span>$</p>

    <p class="text-gray-300">(h) Ln+1(x)(Z(x) &minus; 1) &equiv; 0.</p>

    <p class="text-gray-300">and outputs acc iff all checks hold.</p>

    <p class="text-gray-300">Remark 5.1. Note that if we are in a situation where the sorted values of f alone already have a consecutive gap of at most c, we can use a simpler protocol showing a permutation between f and s without needing to use t.</p>

    <p class="text-gray-300">Lemma 5.2. Fix positive integer c. Suppose that f(g i ) i&isin;[n] is not contained in {0, . . . , c(n &minus; 1)}. Then for any strategy of A playing the role of P in the above protocol P, the probability that V accepts is negl(&lambda;). Furthermore, for c &ge; 2 we have d(P) = (3 + c)n + 2.</p>

    <p class="text-gray-300">Proof. We compute d(P): As in the previous protocol P sends Z, h1, h<sup>2</sup> &isin; F&lt;n+1[X], which aggregates to 3n + 3. Now, for c &ge; 2 the highest degree constraints are the check P (h1(g &middot; X) &minus; h1(X)) &equiv; 0 (and the same check for h2). Which gives degree (c+ 1)&middot;n to which we add one and subtract |H| = n + 1; totalling in 3n + 3 + (c + 1) &middot; n &minus; (n + 1) = (3 + c)n + 2.</p>

    <p class="text-gray-300">Now for the main claim, assume that for some i &isin; [n], f<sup>i</sup> &isin; { / 0, . . . , c(n &minus; 1)}. The checks in steps <a href="#page-7-0">6a</a><a href="#page-8-0">-6e</a> imply that the values h1(g i ), h2(g i ) i&isin;[n] are all in the range {0, . . . , c(n &minus; 1)}. Define polynomials</p>

    <p class="text-gray-300"><span class="math">$F(X) := \\prod_{i \\in [n]} (X - f(\\mathbf{g}^i))(X - t(\\mathbf{g}^i)), G(X) := \\prod_{i \\in [n]} (X - h_1(\\mathbf{g}^i))(X - h_2(\\mathbf{g}^i)))</span>$</p>

    <p class="text-gray-300">Under the assumption that for some i &isin; [n], f<sup>i</sup> &isin; { / 0, . . . , cn}, we have that F and G are distinct polynomials.</p>

    <p class="text-gray-300">The checks in steps <a href="#page-8-1">6f-</a><a href="#page-8-2">6h</a> imply that F(&gamma;) = G(&gamma;).</p>

    <p class="text-gray-300">Since &gamma; &isin; F is chosen uniformly it follows that V accepts with probability negl(&lambda;).</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Jens Groth for introducing us to the lookup protocol of <a href="#page-9-0">[BCG</a>+]. We thank Kevaundray Wedderburn for comments and corrections and the name plookup.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>[AAB+19] A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and A. Szepieniec. Efficient symmetric primitives for advanced cryptographic protocols (A marvellous contribution). IACR Cryptology ePrint Archive, 2019:426, 2019.</li>
      <li>[ACG+19] M. R. Albrecht, C. Cid, L. Grassi, D. Khovratovich, R. L&uml;uftenegger, C. Rechberger, and M. Schofnegger. Algebraic cryptanalysis of stark-friendly designs: Application to marvellous and mimc. In Advances in Cryptology - ASIACRYPT 2019 - 25th International Conference on the Theory and Application of Cryptology and Information Security, Kobe, Japan, December 8-12, 2019, Proceedings, Part III, pages 371&ndash;397, 2019.</li>
      <li>[AGR+16] M. R. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In Advances in Cryptology - ASIACRYPT 2016 - 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part I, pages 191&ndash;219, 2016.</li>
      <li>[BCG+] J. Bootle, A. Cerulli, J. Groth, S. K. Jakobsen, and M. Maller. Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In Advances in Cryptology - ASIACRYPT 2018 - 24th International Conference on the Theory and Application of Cryptology and Information Security, Brisbane, QLD, Australia, December 2-6, 2018, Proceedings, Part I, volume 11272 of Lecture Notes in Computer Science, pages 595&ndash;626.</li>
      <li>[BG12] S. Bayer and J. Groth. Efficient zero-knowledge argument for correctness of a shuffle. In Advances in Cryptology - EUROCRYPT 2012 - 31st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cambridge, UK, April 15-19, 2012. Proceedings, pages 263&ndash;280, 2012.</li>
      <li>[GKK+19] L. Grassi, D.l Kales, D. Khovratovich, A. Roy, C. Rechberger, and M. Schofnegger. Starkad and poseidon: New hash functions for zero knowledge proof systems. IACR Cryptology ePrint Archive, 2019:458, 2019.</li>
      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. IACR Cryptology ePrint Archive, 2019:953, 2019.</li>
      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. pages 177&ndash;194, 2010.</li>
    </ul>

    </section>
`;
---

<BaseLayout title="plookup: A simplified polynomial protocol for lookup tables (2020/315)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/315
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li><a href="#sec-2" class="hover:text-white">Preliminaries</a></li>
        <li><a href="#sec-3" class="hover:text-white">The main scheme</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Generalizing to vector lookups and multiple tables</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Multiple tables</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">An optimized solution for continuous ranges</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="plokup-a-simplified-polynomial-protocol-for-lookup-tables-2020" />
  </article>
</BaseLayout>
